<html><head></head><body>
  <div id="_idContainer313" class="Basic-Text-Frame">
    <h1 class="chapterNumber">11</h1>
    <h1 id="_idParaDest-211" class="chapterTitle">Sorting</h1>
    <p class="normal">Sorting means reorganizing data in such a way that it is in ascending or descending order. Sorting is one of the most important algorithms in computer science and is widely used in database-related algorithms. For several applications, if the data is sorted, it can efficiently be retrieved, for example, if it is a collection of names, telephone numbers, or items on a simple to-do list.</p>
    <p class="normal">In this chapter, we’ll study some of the most important and popular sorting techniques, including the following:</p>
    <ul>
      <li class="bulletList">Bubble sort</li>
      <li class="bulletList">Insertion sort</li>
      <li class="bulletList">Selection sort</li>
      <li class="bulletList">Quicksort</li>
      <li class="bulletList">Timsort</li>
    </ul>
    <h1 id="_idParaDest-212" class="heading-1">Technical requirements</h1>
    <p class="normal">All source code used to explain the concepts of this chapter is provided in the GitHub repository at the following link:</p>
    <p class="normal"><a href="https://github.com/PacktPublishing/Hands-On-Data-Structures-and-Algorithms-with-Python-Third-Edition/tree/main/Chapter11"><span class="url">https://github.com/PacktPublishing/Hands-On-Data-Structures-and-Algorithms-with-Python-Third-Edition/tree/main/Chapter11</span></a></p>
    <h1 id="_idParaDest-213" class="heading-1">Sorting algorithms</h1>
    <p class="normal">Sorting means<a id="_idIndexMarker928"/> arranging all the items in a list in ascending or descending order. We can compare different sorting algorithms by how much time and memory space is required to use them. </p>
    <p class="normal">The time taken by an algorithm changes depending on the input size. Moreover, some algorithms are relatively easy to implement, but may perform poorly with respect to time and space complexity, whereas other algorithms are slightly more complex to implement, but can perform well when sorting longer lists of data. One of the sorting algorithm, merge sort, we have already discussed in <em class="chapterRef">Chapter 3</em>, <em class="italic">Algorithm Design Techniques and Strategies</em>. We will discuss several more sorting algorithms one by one in detail along with their implementation details, starting with the bubble sort algorithm.</p>
    <h1 id="_idParaDest-214" class="heading-1">Bubble sort algorithms</h1>
    <p class="normal">The <a id="_idIndexMarker929"/>idea behind the bubble sort algorithm<a id="_idIndexMarker930"/> is very simple. Given an unordered list, we compare adjacent elements in the list, and after each comparison, we place them in the right order according to their values. So, we swap the adjacent items if they are not in the correct order. This process is repeated <code class="inlineCode">n-1</code> times for a list of <code class="inlineCode">n</code> items.</p>
    <p class="normal">In each iteration, the largest element of the list is moved to the end of the list. After the second iteration, the second largest element will be placed at the second-to-last position in the list. The same process is repeated until the list is sorted.</p>
    <p class="normal">Let’s take a list with only two elements, {<code class="inlineCode">5</code>, <code class="inlineCode">2</code>}, to understand the concept of bubble sort, as shown in <em class="italic">Figure 11.1</em>:</p>
    <figure class="mediaobject"><img src="../Images/B17217_11_01.png" alt=""/></figure>
    <p class="packt_figref">Figure 11.1: Example of bubble sort</p>
    <p class="normal">To sort this list of two elements, first, we compare <code class="inlineCode">5</code> and <code class="inlineCode">2</code>; since <code class="inlineCode">5</code> is greater than <code class="inlineCode">2</code>, it means they are not in the correct order, so we swap these values to put them in the correct<a id="_idIndexMarker931"/> order. To swap these two numbers, first, we <a id="_idIndexMarker932"/>move the element stored at index <code class="inlineCode">0</code> in a temporary variable (<em class="italic">step 1</em> of <em class="italic">Figure 11.2</em>), then the element stored at index <code class="inlineCode">1</code> is copied to index <code class="inlineCode">0</code> (<em class="italic">step 2</em> of <em class="italic">Figure 11.2)</em>, and finally the first element stored in the temporary variable is stored back at index <code class="inlineCode">1</code> (<em class="italic">step 3</em> of <em class="italic">Figure 11.2</em>). So, first, element <code class="inlineCode">5</code> is copied to a temporary variable, <code class="inlineCode">temp</code>. Then, element <code class="inlineCode">2</code> is moved to index <code class="inlineCode">0</code>. Finally, <code class="inlineCode">5</code> is moved from <code class="inlineCode">temp</code> to index <code class="inlineCode">1</code>. The list will now contain the elements as <code class="inlineCode">[2, 5]</code>:</p>
    <figure class="mediaobject"><img src="../Images/B17217_11_02.png" alt=""/></figure>
    <p class="packt_figref">Figure 11.2: Swapping of two elements in bubble sort</p>
    <p class="normal">The following code will swap the elements of <code class="inlineCode">unordered_list[0]</code> with <code class="inlineCode">unordered_list[1]</code> if they are not in the right order:</p>
    <pre class="programlisting code"><code class="hljs-code">unordered_list = [<span class="hljs-number">5</span>, <span class="hljs-number">2</span>]
temp = unordered_list[<span class="hljs-number">0</span>]
unordered_list[<span class="hljs-number">0</span>] = unordered_list[<span class="hljs-number">1</span>]
unordered_list[<span class="hljs-number">1</span>] = temp
<span class="hljs-built_in">print</span>(unordered_list)
</code></pre>
    <p class="normal">The output of the above code is:</p>
    <pre class="programlisting con"><code class="hljs-con">[2, 5]
</code></pre>
    <p class="normal">Now that we have been able to swap a two-element array, it should be simple to use this same idea to sort a whole list using bubble sort.</p>
    <p class="normal">Let’s consider another example to understand the working of the bubble sort algorithm and sort an unordered list of six elements, such as {<code class="inlineCode">45</code>, <code class="inlineCode">23</code>, <code class="inlineCode">87</code>, <code class="inlineCode">12</code>, <code class="inlineCode">32</code>, <code class="inlineCode">4</code>}. In the first iteration, we start comparing the first two elements, <code class="inlineCode">45</code> and <code class="inlineCode">23</code>, and we swap them, as <code class="inlineCode">45</code> should be placed after <code class="inlineCode">23</code>. Then, we compare the next adjacent values, <code class="inlineCode">45</code> and <code class="inlineCode">87</code>, to see whether they<a id="_idIndexMarker933"/> are in the correct order. As <code class="inlineCode">87</code> is a higher <a id="_idIndexMarker934"/>value than <code class="inlineCode">45</code>, we do not need to swap them. We swap two elements if they are not in the correct order. </p>
    <p class="normal">We can see, in <em class="italic">Figure 11.3</em>, that after the first iteration of the bubble sort, the largest element, <code class="inlineCode">87</code>, is placed in the last position of the list:</p>
    <figure class="mediaobject"><img src="../Images/B17217_11_03.png" alt=""/></figure>
    <p class="packt_figref">Figure 11.3: Steps of the first iteration to sort an example array using bubble sort </p>
    <p class="normal">After the first iteration, we just need to arrange the remaining <code class="inlineCode">(n-1)</code> elements; we repeat the same process by comparing the adjacent elements for the remaining five elements. After the second iteration, the second largest element, <code class="inlineCode">45</code>, is placed at the second-to-last position in the list, as shown in <em class="italic">Figure 11.4</em>:</p>
    <figure class="mediaobject"><img src="../Images/B17217_11_04.png" alt=""/></figure>
    <p class="packt_figref">Figure 11.4: Steps of the second iteration to sort an example array using bubble sort</p>
    <p class="normal">Next, we have to compare the remaining <code class="inlineCode">(n-2)</code> elements to arrange them as shown in <em class="italic">Figure 11.5</em>:</p>
    <figure class="mediaobject"><img src="../Images/B17217_11_05.png" alt=""/></figure>
    <p class="packt_figref">Figure 11.5: Steps of the third iteration to sort an example array using bubble sort </p>
    <p class="normal">Similarly, we <a id="_idIndexMarker935"/>compare the remaining elements to sort <a id="_idIndexMarker936"/>them, as well, as shown in <em class="italic">Figure 11.6</em>:</p>
    <figure class="mediaobject"><img src="../Images/B17217_11_06.png" alt=""/></figure>
    <p class="packt_figref">Figure 11.6: Steps of the fourth iteration to sort an example array using bubble sort</p>
    <p class="normal">Finally, for the last two remaining elements, we place them in the correct order to obtain the final sorted list, as shown in <em class="italic">Figure 11.7</em>:</p>
    <figure class="mediaobject"><img src="../Images/B17217_11_07.png" alt=""/></figure>
    <p class="packt_figref">Figure 11.7: Steps of the fifth iteration to sort an example array using bubble sort</p>
    <p class="normal">The complete Python code of the bubble sort algorithm is shown below, and afterward, each step is explained in detail:</p>
    <pre class="programlisting code"><code class="hljs-code"><span class="hljs-keyword">def</span><span class="hljs-function"> </span><span class="hljs-title">bubble_sort</span><span class="hljs-function">(</span><span class="hljs-params">unordered_list</span><span class="hljs-function">):</span>
    iteration_number = <span class="hljs-built_in">len</span>(unordered_list)-<span class="hljs-number">1</span>
    <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(iteration_number,<span class="hljs-number">0</span>,-<span class="hljs-number">1</span>):
        <span class="hljs-keyword">for</span> j <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(i):
            <span class="hljs-keyword">if</span> unordered_list[j] &gt; unordered_list[j+<span class="hljs-number">1</span>]:
                temp = unordered_list[j]
                unordered_list[j] = unordered_list[j+<span class="hljs-number">1</span>]
                unordered_list[j+<span class="hljs-number">1</span>] = temp
</code></pre>
    <p class="normal">Bubble sort is <a id="_idIndexMarker937"/>implemented using a double-nested<a id="_idIndexMarker938"/> loop, wherein one loop is inside another loop. In bubble sort, the inner loop repeatedly compares and swaps the adjacent elements in each iteration for a given list, and the outer loop keeps track of how many times the inner loop should be repeated.</p>
    <p class="normal">Firstly, in the above code, we compute how many times the loop should run to complete all swaps; this is equal to the length of the list minus 1 and could be written as <code class="inlineCode">iteration_number = len(unordered_list)-1</code>. Here, the <code class="inlineCode">len</code> function will give the length of the list. We subtract 1 because it gives us exactly the maximum number of iterations to run. The outer loop ensures this and executes for one minus the size of the list.</p>
    <p class="normal">Further, in the above code, for each iteration, in the inner loop, we compare the adjacent elements using the <code class="inlineCode">if</code> statement, and we check if the adjacent elements are in the correct order or not. For the first iteration, the inner loop should run for <code class="inlineCode">n</code> times, for the second iteration, the inner loop should run <code class="inlineCode">n-1</code> times, and so on. For example, to sort a list of three numbers say <code class="inlineCode">[3, 2, 1]</code>, the inner loop runs two times, and we need to swap the elements a maximum of two times as shown in <em class="italic">Figure 11.8</em>:</p>
    <figure class="mediaobject"> <img src="../Images/B17217_11_08.png" alt=""/></figure>
    <p class="packt_figref">Figure 11.8: Number of swaps in iteration 1 for an example list [3, 2, 1]</p>
    <p class="normal">Further, after<a id="_idIndexMarker939"/> the first iteration, in the second<a id="_idIndexMarker940"/> iteration, we execute the inner loop once as shown in <em class="italic">Figure 11.9</em>:</p>
    <figure class="mediaobject"><img src="../Images/B17217_11_09.png" alt=""/></figure>
    <p class="packt_figref">Figure 11.9: Number of swaps in iteration 2 for an example list [3, 2, 1]</p>
    <p class="normal">The following code snippet can be used to deploy the bubble sort algorithm:</p>
    <pre class="programlisting code"><code class="hljs-code">my_list = [<span class="hljs-number">4</span>,<span class="hljs-number">3</span>,<span class="hljs-number">2</span>,<span class="hljs-number">1</span>]
bubble_sort(my_list)
<span class="hljs-built_in">print</span>(my_list)
 
my_list = [<span class="hljs-number">1</span>,<span class="hljs-number">12</span>,<span class="hljs-number">3</span>,<span class="hljs-number">4</span>]
bubble_sort(my_list)
<span class="hljs-built_in">print</span>(my_list)
</code></pre>
    <p class="normal">The output is as follows:</p>
    <pre class="programlisting con"><code class="hljs-con">[1, 2, 3, 4]
[1, 3, 4, 12]
</code></pre>
    <p class="normal">In the worst case, the number of comparisons required in the first<sup class="superscript"> </sup>iteration will be (<code class="inlineCode">n-1</code>), in the second, the number of comparisons will be (<code class="inlineCode">n-2</code>), and in the third iteration it will be (<code class="inlineCode">n-3</code>), and so on. Therefore, the total number of comparisons required in the bubble sort will be as follows:</p>
    <pre class="programlisting code"><code class="hljs-code">(n-<span class="hljs-number">1</span>) + (n-<span class="hljs-number">2</span>) + (n-<span class="hljs-number">3</span>) +.....+ <span class="hljs-number">1</span> = n(n-<span class="hljs-number">1</span>)/<span class="hljs-number">2</span>
n(n+<span class="hljs-number">1</span>)/<span class="hljs-number">2</span>
O(n<sup class="superscript">2</sup>)
</code></pre>
    <p class="normal">The <a id="_idIndexMarker941"/>bubble sort algorithm is not an efficient <a id="_idIndexMarker942"/>sorting algorithm, as it provides a worst-case runtime complexity of <code class="inlineCode">O(n</code><sup class="superscript">2</sup><code class="inlineCode">)</code>, and a best-case complexity of <code class="inlineCode">O(n)</code>. The worst-case situation occurs when we want to sort the given list in ascending order and the given list is in descending order, and the best case occurs when the given list is already sorted; in that case, there will not be any need for swapping.</p>
    <p class="normal">Generally, the bubble sort algorithm should not be used to sort large lists. The bubble sort algorithm is suitable for applications where performance is not important or the length of the given list is short, and moreover, short and simple code is preferred. The bubble sort algorithm performs well on relatively small lists.</p>
    <p class="normal">Now we shall look into the insertion sort algorithm.</p>
    <h1 id="_idParaDest-215" class="heading-1">Insertion sort algorithm</h1>
    <p class="normal">The idea of <a id="_idIndexMarker943"/>insertion sort is that we maintain two sublists (a sublist is<a id="_idIndexMarker944"/> a part of the original larger list), one<a id="_idIndexMarker945"/> that is sorted and one that is not sorted, in which elements are added one by one from the unsorted sublist to the sorted sublist. So, we take elements from the unsorted sublist and insert them in the correct position in the sorted sublist, in such a way that this sublist remains sorted.</p>
    <p class="normal">In the insertion sort algorithm, we always start with one element, taking it to be sorted, and then take elements one by one from the unsorted sublist and place them at the correct positions (in relation to the first element) in the sorted sublist. So, after taking one element from the unsorted sublist and adding it to the sorted sublist, now we have two elements in the sorted sublist. Then, we again take another element from the unsorted sublist, and place it in the correct position (in relation to the two already sorted elements) in the sorted sublist. We repeatedly follow this process to insert all the elements one by one from the unsorted sublist into the sorted sublist. The shaded elements denote the ordered sublists in <em class="italic">Figure 11.10</em>, and in each iteration, an element from the unordered sublist is inserted at the correct position in the sorted sublist.</p>
    <p class="normal">Let’s consider <a id="_idIndexMarker946"/>an example to understand the working of the insertion <a id="_idIndexMarker947"/>sorting algorithm. Let’s say; we have to sort a list of six elements: {<code class="inlineCode">45</code>, <code class="inlineCode">23</code>, <code class="inlineCode">87</code>, <code class="inlineCode">12</code>, <code class="inlineCode">32</code>, <code class="inlineCode">4</code>}. Firstly, we start with one element, assuming it to be sorted, then take the next element, <code class="inlineCode">23</code>, from the unsorted sublist and insert it at the correct position in the sorted sublist. In the next iteration, we take the third element, <code class="inlineCode">87</code>, from the unsorted sublist, and again insert it into the sorted sublist at the correct position. We follow the same process until all elements are in the sorted sub-list. This whole process is shown in <em class="italic">Figure 11.10</em>:</p>
    <figure class="mediaobject"><img src="../Images/B17217_11_10.png" alt=""/></figure>
    <p class="packt_figref">Figure 11.10: Steps to sort example array elements using the insertion sort algorithm</p>
    <p class="normal">The complete <a id="_idIndexMarker948"/>Python code for insertion sort is given below; each statement of the<a id="_idIndexMarker949"/> algorithm is further explained in detail with an example:</p>
    <pre class="programlisting code"><code class="hljs-code"><span class="hljs-keyword">def</span><span class="hljs-function"> </span><span class="hljs-title">insertion_sort</span><span class="hljs-function">(</span><span class="hljs-params">unsorted_list</span><span class="hljs-function">):</span>
    <span class="hljs-keyword">for</span> index <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-number">1</span>, <span class="hljs-built_in">len</span>(unsorted_list)):
        search_index = index
        insert_value = unsorted_list[index]
        <span class="hljs-keyword">while</span> search_index &gt; <span class="hljs-number">0</span> <span class="hljs-keyword">and</span> unsorted_list[search_index-<span class="hljs-number">1</span>] &gt; insert_value :
            unsorted_list[search_index] = unsorted_list[search_index-<span class="hljs-number">1</span>]
            search_index -= <span class="hljs-number">1</span>
        unsorted_list[search_index] = insert_value
</code></pre>
    <p class="normal">To understand the implementation of the insertion sort algorithm, let’s take another example of five elements, <code class="inlineCode">{5, 1, 100, 2, 10}</code>, and examine the process with a detailed explanation. Let’s consider the following array, as shown in <em class="italic">Figure 11.11</em>:</p>
    <figure class="mediaobject"><img src="../Images/B17217_11_11.png" alt=""/></figure>
    <p class="packt_figref">Figure 11.11: An example array with index positions</p>
    <p class="normal">The <a id="_idIndexMarker950"/>algorithm starts by using a <code class="inlineCode">for</code> loop to run between the <code class="inlineCode">1</code> and <code class="inlineCode">4</code> indices. We<a id="_idIndexMarker951"/> start from index <code class="inlineCode">1</code> because we take the element stored at index <code class="inlineCode">0</code> to be in the sorted subarray and elements between index <code class="inlineCode">1</code> to <code class="inlineCode">4</code> are of the unsorted sublist, as shown in <em class="italic">Figure 11.12</em>:</p>
    <figure class="mediaobject"><img src="../Images/B17217_11_12.png" alt=""/></figure>
    <p class="packt_figref">Figure 11.12: Demonstration of sorted and unsorted sublists in insertion sorting</p>
    <p class="normal">At the start of the execution of the loop, we have the following code snippet:</p>
    <pre class="programlisting code"><code class="hljs-code">    <span class="hljs-keyword">for</span> index <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-number">1</span>, <span class="hljs-built_in">len</span>(unsorted_list)):
        search_index = index
        insert_value = unsorted_list[index]
</code></pre>
    <p class="normal">At the beginning of the execution of each run of the <code class="inlineCode">for</code> loop, the element at <code class="inlineCode">unsorted_list[index]</code> is stored in the <code class="inlineCode">insert_value</code> variable. Later, when we find the appropriate position in the sorted portion of the sublist, <code class="inlineCode">insert_value</code> will be stored at that index in the sorted sublist. The next code snippet is shown below:</p>
    <pre class="programlisting code"><code class="hljs-code">        <span class="hljs-keyword">while</span> search_index &gt; <span class="hljs-number">0</span> <span class="hljs-keyword">and</span> unsorted_list[search_index-<span class="hljs-number">1</span>] &gt; insert_value :
        unsorted_list[search_index] = unsorted_list[search_index-<span class="hljs-number">1</span>]
        search_index -= <span class="hljs-number">1</span>
    unsorted_list[search_index] = insert_value 
</code></pre>
    <p class="normal"><code class="inlineCode">search_index</code> is used to provide information to the <code class="inlineCode">while</code> loop, that is, exactly where to find the next element that needs to be inserted into the sorted sublist.</p>
    <p class="normal">The <code class="inlineCode">while</code> loop <a id="_idIndexMarker952"/>traverses the list backward, guided by<a id="_idIndexMarker953"/> two conditions. First, if <code class="inlineCode">search_index &gt; 0</code>, then it means that there are more elements in the sorted portion of the list; second, for the <code class="inlineCode">while</code> loop to run, <code class="inlineCode">unsorted_list[search_index-1]</code> must be greater than the <code class="inlineCode">insert_value</code> variable. The <code class="inlineCode">unsorted_list[search_index-1]</code> array will do either of the following things:</p>
    <ul>
      <li class="bulletList">Point to the element, just before <code class="inlineCode">unsorted_list[search_index]</code>, before the <code class="inlineCode">while</code> loop is executed the first time</li>
      <li class="bulletList">Point to one element before <code class="inlineCode">unsorted_list[search_index-1]</code>, after the <code class="inlineCode">while</code> loop has been run the first time</li>
    </ul>
    <p class="normal">In the example list, the <code class="inlineCode">while</code> loop will be executed because <code class="inlineCode">5 &gt; 1</code>. In the body of the <code class="inlineCode">while</code> loop, the element at <code class="inlineCode">unsorted_list[search_index-1]</code> is stored at <code class="inlineCode">unsorted_list[search_index]</code>. And, <code class="inlineCode">search_index -= 1</code> moves the list traversal backward until it holds a value of <code class="inlineCode">0</code>.</p>
    <p class="normal">After the <code class="inlineCode">while</code> loop exits, the last known position of <code class="inlineCode">search_index</code> (which, in this case, is <code class="inlineCode">0</code>) now helps us to know where to insert <code class="inlineCode">insert_value</code>. <em class="italic">Figure 11.13</em> shows the position of elements after the first iteration:</p>
    <figure class="mediaobject"><img src="../Images/B17217_11_13.png" alt=""/></figure>
    <p class="packt_figref">Figure 11.13: Example list position after 1st iteration</p>
    <p class="normal">On the second <a id="_idIndexMarker954"/>iteration of the <code class="inlineCode">for</code> loop, <code class="inlineCode">search_index</code> will<a id="_idIndexMarker955"/> have a value of <code class="inlineCode">2</code>, which is the index of the third element in the array. At this point, we start our comparison in the leftward direction (toward index <code class="inlineCode">0</code>). <code class="inlineCode">100</code> will be compared with <code class="inlineCode">5</code>, but because <code class="inlineCode">100</code> is greater than <code class="inlineCode">5</code>, the <code class="inlineCode">while</code> loop will not be executed. <code class="inlineCode">100</code> will be replaced by itself, because the <code class="inlineCode">search_index</code> variable never got decremented. As such, <code class="inlineCode">unsorted_list[search_index] = insert_value</code> will have no effect.</p>
    <p class="normal">When <code class="inlineCode">search_index</code> is pointing at index <code class="inlineCode">3</code>, we compare <code class="inlineCode">2</code> with <code class="inlineCode">100</code>, and move <code class="inlineCode">100</code> to where <code class="inlineCode">2</code> is stored. We then compare <code class="inlineCode">2</code> with <code class="inlineCode">5</code> and move <code class="inlineCode">5</code> to where <code class="inlineCode">100</code> was initially stored. At this point, the <code class="inlineCode">while</code> loop will break and <code class="inlineCode">2</code> will be stored in index <code class="inlineCode">1</code>. The array will be partially sorted with the values <code class="inlineCode">[1, 2, 5, 100, 10]</code>. The preceding step will occur one last time for the list to be sorted. </p>
    <p class="normal">The following code can be used to create a list of elements, which we can sort using the defined <code class="inlineCode">insertion_sort()</code> method:</p>
    <pre class="programlisting code"><code class="hljs-code">my_list = [<span class="hljs-number">5</span>, <span class="hljs-number">1</span>, <span class="hljs-number">100</span>, <span class="hljs-number">2</span>, <span class="hljs-number">10</span>]
<span class="hljs-built_in">print</span>(<span class="hljs-string">"Original list"</span>, my_list)
insertion_sort(my_list)
<span class="hljs-built_in">print</span>(<span class="hljs-string">"Sorted list"</span>, my_list)
</code></pre>
    <p class="normal">The output of the above code is as follows:</p>
    <pre class="programlisting con"><code class="hljs-con">Original list [5, 1, 100, 2, 10]
Sorted list [1, 2, 5, 10, 100]
</code></pre>
    <p class="normal">The worst-case time complexity of insertion sort is when the given list of elements is sorted in reverse order. In that case, each element will have to be compared with each of the other elements. So, we will need one comparison in the first iteration, two comparisons in<sup class="superscript"> </sup>the second iteration, and three comparisons in the third iteration, and (n-1) comparisons in the (n-1)<sup class="superscript">th</sup> iteration. Thus, the total number of comparisons are:</p>
    <pre class="programlisting code"><code class="hljs-code"><span class="hljs-number">1</span> + <span class="hljs-number">2</span> + <span class="hljs-number">3</span> .. (n-<span class="hljs-number">1</span>) 
n(n-<span class="hljs-number">1</span>)/<span class="hljs-number">2</span>
</code></pre>
    <p class="normal">Hence, the <a id="_idIndexMarker956"/>insertion sort algorithm gives a<a id="_idIndexMarker957"/> worst-case runtime complexity of O(n<sup class="superscript">2</sup>). Furthermore, the best-case complexity of the insertion sort algorithm is O(n), in the situation when the given input list is already sorted in which each element from the unsorted sublist is compared to only the right-most element of the sorted sublist in each iteration. The insertion sort algorithm is good to use when the given list has a small number of elements, and it is best suited when the input data arrives one by one, and we need to keep the list sorted. Now we are going to take a look at the selection sort algorithm.</p>
    <h1 id="_idParaDest-216" class="heading-1">Selection sort algorithm</h1>
    <p class="normal">Another popular <a id="_idIndexMarker958"/>sorting algorithm is selection sort. The <a id="_idIndexMarker959"/>selection sort algorithm begins by finding the smallest element in the list and interchanges it with the data stored at the first position in the list. Thus, it sorts the sublist sorted up to the first element. This process is repeated for <code class="inlineCode">(n-1) </code>times to sort <code class="inlineCode">n</code> items. </p>
    <p class="normal">Next, the second smallest element, which is the smallest element in the remaining list, is identified and interchanged with the second position in the list. This makes the initial two elements sorted. The process is repeated, and the smallest element remaining in the list is swapped with the element in the third index on the list. This means that the first three elements are now sorted. </p>
    <p class="normal">Let’s look at an example to understand how the algorithm works. We’ll sort the following list of four elements {<code class="inlineCode">15, 12, 65, 10, 7</code>}, as shown in <em class="italic">Figure 11.14,</em> along with their index positions using the selection sort algorithm:</p>
    <figure class="mediaobject"><img src="../Images/B17217_11_14.png" alt=""/></figure>
    <p class="packt_figref">Figure 11.14: Demonstration of the first iteration of the selection sort</p>
    <p class="normal">In the first<a id="_idIndexMarker960"/> iteration of the selection sort, we start <a id="_idIndexMarker961"/>at index <code class="inlineCode">0</code>, we search for the smallest item in the list, and when the smallest element is found, it is exchanged with the first data element of the list at index <code class="inlineCode">0</code>. We simply repeat this process until the list is fully sorted. After the first iteration, the smallest element will be placed in the first position in the list.</p>
    <p class="normal">Next, we start<a id="_idIndexMarker962"/> from the second element of the<a id="_idIndexMarker963"/> list at index position <code class="inlineCode">1</code> and search the smallest element in the data list from index position <code class="inlineCode">1</code> to the length of the list. Once we find the smallest element from this remaining list of elements, we swap this element with the second element of the list. The step-by-step process of the second iteration of the selection sort is shown in <em class="italic">Figure 11.15</em>:</p>
    <figure class="mediaobject"><img src="../Images/B17217_11_15.png" alt=""/></figure>
    <p class="packt_figref">Figure 11.15: Demonstration of the second iteration of the selection sort</p>
    <p class="normal">In the next iteration, we find out the smallest element in the remaining list in index position <code class="inlineCode">2</code> to <code class="inlineCode">4</code> and swap the smallest data element with the data element at index <code class="inlineCode">2</code> in the second iteration. We follow the same process until we sort the complete list.</p>
    <p class="normal">The following is an implementation of the selection sort algorithm. The argument to the function is the unsorted list of items we want to put in ascending order of their values:</p>
    <pre class="programlisting code"><code class="hljs-code"><span class="hljs-keyword">def</span><span class="hljs-function"> </span><span class="hljs-title">selection_sort</span><span class="hljs-function">(</span><span class="hljs-params">unsorted_list</span><span class="hljs-function">):</span> 
    size_of_list = <span class="hljs-built_in">len</span>(unsorted_list) 
    <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(size_of_list): 
        small = i
        <span class="hljs-keyword">for</span> j <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(i+<span class="hljs-number">1</span>, size_of_list): 
            <span class="hljs-keyword">if</span> unsorted_list[j] &lt; unsorted_list[small]: 
                small = j
        temp = unsorted_list[i] 
        unsorted_list[i] = unsorted_list[small] 
        unsorted_list[small] = temp
</code></pre>
    <p class="normal">In the above<a id="_idIndexMarker964"/> code of selection sort, the algorithm<a id="_idIndexMarker965"/> begins with the outer <code class="inlineCode">for</code> loop to go through the list, starting from index <code class="inlineCode">0</code> to <code class="inlineCode">size_of_list</code>. Because we pass <code class="inlineCode">size_of_list</code> to the <code class="inlineCode">range</code> method, it’ll produce a sequence from <code class="inlineCode">0</code> through to <code class="inlineCode">size_of_list-1</code>.</p>
    <p class="normal">Next, we declare a variable <code class="inlineCode">small</code>, which stores the index of the smallest element. Further, the inner loop is responsible for going through the list and we keep track of the index of the smallest value of the list. Once the index of the smallest element is found, then we swap this element with the correct position in the list.</p>
    <p class="normal">The following code can be used to create a list of elements and we use the selection sort algorithm to sort the list:</p>
    <pre class="programlisting code"><code class="hljs-code">a_list = [<span class="hljs-number">3</span>, <span class="hljs-number">2</span>, <span class="hljs-number">35</span>, <span class="hljs-number">4</span>, <span class="hljs-number">32</span>, <span class="hljs-number">94</span>, <span class="hljs-number">5</span>, <span class="hljs-number">7</span>]
<span class="hljs-built_in">print</span>("<span class="hljs-type">List</span> before sorting", a_list)
selection_sort(a_list)
<span class="hljs-built_in">print</span>("<span class="hljs-type">List</span> after sorting", a_list)
</code></pre>
    <p class="normal">The output of the above code is as follows:</p>
    <pre class="programlisting con"><code class="hljs-con">List before sorting [3, 2, 35, 4, 32, 94, 5, 7]
List after sorting [2, 3, 4, 5, 7, 32, 35, 94]
</code></pre>
    <p class="normal">In the selection sort, <code class="inlineCode">(n-1)</code> comparisons are required in the first iteration, and <code class="inlineCode">(n-2)</code> comparisons are required in the second iteration, and <code class="inlineCode">(n-3)</code> comparisons are required in the third iteration, and so on. So, the total number of comparisons required is: <code class="inlineCode">(n-1) + (n-2) + (n-3) + ..... + 1 = n(n-1) / 2</code> , which nearly equals to n<sup class="superscript">2</sup>. Thus, the worst-case time complexity of the selection sort is O(n<sup class="superscript">2</sup>). The worst-case situation is when the given list of elements is reverse ordered. The selection sorting algorithm gives the best-case runtime complexity of O(n<sup class="superscript">2</sup>). The selection sorting algorithm can be used when we have a small list of elements.</p>
    <p class="normal">Next, we will discuss the quicksort algorithm.</p>
    <h1 id="_idParaDest-217" class="heading-1">Quicksort algorithm</h1>
    <p class="normal">Quicksort is an <a id="_idIndexMarker966"/>efficient sorting algorithm. The quicksort algorithm is based on the<a id="_idIndexMarker967"/> divide-and-conquer class of algorithms, similar to the merge sort algorithm, where we break (divide) a problem into smaller chunks that are much simpler to solve, and further, the final results are obtained by combining the outputs of smaller problems (conquer).</p>
    <p class="normal">The concept behind quicksorting is partitioning a given list or array. To partition the list, we first select a data element from the given list, which is called a pivot element. </p>
    <p class="normal">We can choose any element as a pivot element in the list. However, for the sake of simplicity, we’ll take the first element in the array as the pivot element. Next, all the elements in the list are compared with this pivot element. At the end of first iteration, all the elements of the list are arranged in such a way that the elements which are less than the pivot element are arranged to the left of the pivot, that the elements that are greater than the pivot element are arranged to the right of the pivot.</p>
    <p class="normal">Now, let’s understand the working of the quicksort algorithm with an example.</p>
    <p class="normal">In this algorithm, firstly we partition the given list of unsorted data elements into two sublists in such a way that all the elements on the left side of that partition point (also called a pivot) should be smaller than the pivot, and all the elements on the right side of the pivot should be greater. This means that elements of the left sublist and the right sublist will be unsorted, but the pivot element will be at its correct position in the complete list. This is shown in <em class="italic">Figure 11.16</em>.</p>
    <p class="normal">Therefore, after the first iteration of the quicksort algorithm, the chosen pivot point is placed in the list at its correct position, and after the first iteration, we obtain two unordered sublists and follow the same process again on these two sublists. Thus, the quicksort algorithm partitions the list into two parts and recursively applies the quicksort algorithm to these two sublists to sort the whole list:</p>
    <figure class="mediaobject"><img src="../Images/B17217_11_16.png" alt=""/></figure>
    <p class="packt_figref">Figure 11.16: Illustration of sublists in quicksort</p>
    <p class="normal">The <a id="_idIndexMarker968"/>quicksort algorithm<a id="_idIndexMarker969"/> works as follows:</p>
    <ol class="numberedList" style="list-style-type: decimal;">
      <li class="numberedList" value="1">We start by choosing a pivot element with which all the data elements are to be compared, and at the end of the first iteration, this pivot element will be placed in its correct position in the list. In order to place the pivot element in its correct position, we use two pointers, a left pointer, and a right pointer. This process is as follows:<ol class="alphabeticList" style="list-style-type: lower-alpha;">
          <li class="alphabeticList" value="1">The left pointer initially points to the value at index <code class="inlineCode">1</code>, and the right pointer points to the value at the last index. The main idea here is to move the data items that are on the wrong side of the pivot element. So, we start with the left pointer, moving in a left-to-right direction until we reach a position where the data item in the list has a greater value than the pivot element.</li>
          <li class="alphabeticList">Similarly, we move the right pointer toward the left until we find a data item less than the pivot element.</li>
          <li class="alphabeticList">Next, we swap these two values indicated by the left and right pointers.</li>
          <li class="alphabeticList">We repeat the same process until both pointers cross each other, in other words, until the right pointer index indicates a value less than that of the left pointer index.</li>
        </ol>
      </li>
      <li class="numberedList">After each iteration described in <em class="italic">step 1</em>, the pivot element will be placed at its correct position in the list, and the original list will be divided into two unordered sublists, left and right. We follow the same process (as described in <em class="italic">step 1</em>) for both these left and right sublists until each of the sublists contains a single element.</li>
      <li class="numberedList">Finally, all the elements will be placed at their correct positions, which will give the sorted list as an output.</li>
    </ol>
    <p class="normal">Let’s take<a id="_idIndexMarker970"/> an example of a list of numbers, <code class="inlineCode">{45</code>, <code class="inlineCode">23</code>, <code class="inlineCode">87</code>, <code class="inlineCode">12</code>, <code class="inlineCode">72</code>, <code class="inlineCode">4</code>,<code class="inlineCode"> 54</code>, <code class="inlineCode">32</code>, <code class="inlineCode">52}</code>, to understand how the quicksort algorithm works. Let’s assume that the <a id="_idIndexMarker971"/>pivot element (also called the pivot point) in our list is the first element, <code class="inlineCode">45</code>. We move the left pointer from index <code class="inlineCode">1</code> in a rightward direction, and stop when we reach the value <code class="inlineCode">87</code>, because <code class="inlineCode">(87&gt;45)</code>. Next, we move the right pointer toward the left and stop when we find the value <code class="inlineCode">32</code>, because <code class="inlineCode">(32&lt;45)</code>. Now, we swap these two values. This process is shown in <em class="italic">Figure 11.17</em>:</p>
    <figure class="mediaobject"><img src="../Images/B17217_11_17.png" alt=""/></figure>
    <p class="packt_figref">Figure 11.17: An illustrative example of the quicksort algorithm</p>
    <p class="normal">After that, we <a id="_idIndexMarker972"/>repeat the same process and move the left pointer toward<a id="_idIndexMarker973"/> the right, and stop when we find the value <code class="inlineCode">72</code>, because <code class="inlineCode">(72 &gt; 45)</code>. Next, we move the right pointer toward the left and stop when we reach the value <code class="inlineCode">4</code>, because <code class="inlineCode">(4 &lt; 45)</code>. Now, we swap these two values, because they are on the wrong sides of the pivot value. We repeat the same process and stop once the right pointer index value becomes less than the left pointer index. Here, we <a id="_idIndexMarker974"/>find <code class="inlineCode">4</code> as the splitting point, and swap it with the pivot value. This is <a id="_idIndexMarker975"/>shown in <em class="italic">Figure 11.18</em>:</p>
    <figure class="mediaobject"><img src="../Images/B17217_11_18.png" alt=""/></figure>
    <p class="packt_figref">Figure 11.18: An example of the quicksort algorithm (continued)</p>
    <p class="normal">It can be <a id="_idIndexMarker976"/>observed that after the first iteration of the quicksort<a id="_idIndexMarker977"/> algorithm, the pivot value <code class="inlineCode">45</code> is placed at its correct position in the list.</p>
    <p class="normal">Now we have two sublists:</p>
    <ol class="numberedList" style="list-style-type: decimal;">
      <li class="numberedList" value="1">The sublist to the left of the pivot value, <code class="inlineCode">45</code>, has values less than <code class="inlineCode">45</code>.</li>
      <li class="numberedList">Another sublist to the right of the pivot value contains values greater than <code class="inlineCode">45</code>. We will apply the quicksort algorithm recursively on these two sublists, and repeat it until the whole list is sorted, as shown in <em class="italic">Figure 11.19</em>:</li>
    </ol>
    <figure class="mediaobject"><img src="../Images/B17217_11_19.png" alt=""/></figure>
    <p class="packt_figref">Figure 11.19: After the first iteration of the quicksort algorithm on an example list of elements</p>
    <p class="normal">We will take a look at the implementation of the quicksort algorithm in the next section.</p>
    <h1 id="_idParaDest-218" class="heading-1">Implementation of quicksort</h1>
    <p class="normal">The main task of the<a id="_idIndexMarker978"/> quicksort algorithm is to first place the pivot element in its correct position so that we divide the given unsorted list into two sublists (left and right sublists); this process is called the partitioning step. The partitioning step is very important in understanding the implementation of the quicksort algorithm, so we will understand the implementation of the partitioning step first with an example. In this, given a list of elements, all the elements will be arranged in such a way that elements smaller than the pivot element will be on the left side of it, and elements greater than the pivot will be arranged to the right of the pivot element.</p>
    <p class="normal">Let’s look at an example to understand the implementation. Consider the following list of integers. <code class="inlineCode">[43, 3, 20, 89, 4, 77]</code>. We shall partition this list using the partition function:</p>
    <p class="normal"><code class="inlineCode">[43, 3, 20, 89, 4, 77]</code></p>
    <p class="normal">Consider the code of the partition function below; we will discuss each line of this in detail:</p>
    <pre class="programlisting code"><code class="hljs-code"><span class="hljs-keyword">def</span><span class="hljs-function"> </span><span class="hljs-title">partition</span><span class="hljs-function">(</span><span class="hljs-params">unsorted_array, first_index, last_index</span><span class="hljs-function">):</span>
    pivot = unsorted_array[first_index]
    pivot_index = first_index
    index_of_last_element = last_index
    less_than_pivot_index = index_of_last_element
    greater_than_pivot_index = first_index + <span class="hljs-number">1</span>
    <span class="hljs-keyword">while</span> <span class="hljs-literal">True</span>:
        <span class="hljs-keyword">while</span> unsorted_array[greater_than_pivot_index] &lt; pivot <span class="hljs-keyword">and</span> greater_than_pivot_index &lt; last_index:
            greater_than_pivot_index += <span class="hljs-number">1</span>
        <span class="hljs-keyword">while</span> unsorted_array[less_than_pivot_index] &gt; pivot <span class="hljs-keyword">and</span> less_than_pivot_index &gt;= first_index:
            less_than_pivot_index -= <span class="hljs-number">1</span>
        <span class="hljs-keyword">if</span> greater_than_pivot_index &lt; less_than_pivot_index:
            temp = unsorted_array[greater_than_pivot_index]
            unsorted_array[greater_than_pivot_index] = unsorted_array[less_than_pivot_index]
            unsorted_array[less_than_pivot_index] = temp
        <span class="hljs-keyword">else</span>:
            <span class="hljs-keyword">break</span>
    unsorted_array[pivot_index] = unsorted_array[less_than_pivot_index]
    unsorted_array[less_than_pivot_index] = pivot
    <span class="hljs-keyword">return</span> less_than_pivot_index
</code></pre>
    <p class="normal">The partition function receives, as its parameters, the indices of the first and last elements of the array that we need to partition.</p>
    <p class="normal">The value of the <a id="_idIndexMarker979"/>pivot is stored in the <code class="inlineCode">pivot</code> variable, while its index is stored in <code class="inlineCode">pivot_index</code>. We are not using <code class="inlineCode">unsorted_array[0]</code>, because when the unsorted array parameter is called with a segment of an array, index <code class="inlineCode">0</code> will not necessarily point to the first element in that array. The index of the element next to the pivot, that is, the <strong class="keyWord">left pointer</strong>, <code class="inlineCode">first_index + 1</code>, marks the position where we begin to look for an element in the array. This array is greater than the <code class="inlineCode">pivot</code> as <code class="inlineCode">greater_than_pivot_index = first_index + 1</code> suggests. The <strong class="keyWord">right pointer</strong> <code class="inlineCode">less_than_pivot_index</code> variable points to the position of the last element in the <code class="inlineCode">less_than_pivot_index = index_of_last_element</code> list, where we begin the search for the element that is less than the pivot.</p>
    <p class="normal">Further, at the beginning of the execution of the main <code class="inlineCode">while</code> loop, the array looks as shown in <em class="italic">Figure 11.20</em>:</p>
    <figure class="mediaobject"><img src="../Images/B17217_11_20.png" alt=""/></figure>
    <p class="packt_figref">Figure 11.20: Illustration 1 of an example array for the quicksort algorithm</p>
    <p class="normal">The<a id="_idIndexMarker980"/> first inner <code class="inlineCode">while</code> loop moves one index to the right until it lands on index <code class="inlineCode">2</code> because the value at that index is greater than <code class="inlineCode">43</code>. At this point, the first <code class="inlineCode">while</code> loop breaks and does not continue. At each test of the condition in the first <code class="inlineCode">while</code> loop, <code class="inlineCode">greater_than_pivot_index += 1</code> is evaluated only if the <code class="inlineCode">while</code> loop’s test condition evaluates to <code class="inlineCode">True</code>. This makes the search for an element, greater than the pivot, progress to the next element on the right.</p>
    <p class="normal">The second inner <code class="inlineCode">while</code> loop moves one index at a time to the left, until it lands on index <code class="inlineCode">5</code>, whose value, <code class="inlineCode">20</code>, is less than <code class="inlineCode">43</code>, as shown in <em class="italic">Figure 11.21</em>:</p>
    <figure class="mediaobject"><img src="../Images/B17217_11_21.png" alt=""/></figure>
    <p class="packt_figref">Figure 11.21 Illustration 2 of example array for quicksort algorithm</p>
    <p class="normal">Next, at this point, neither of the inner <code class="inlineCode">while</code> loops can be executed any further, and the next code snippet is as shown below:</p>
    <pre class="programlisting code"><code class="hljs-code">    <span class="hljs-keyword">if</span> greater_than_pivot_index &lt; less_than_pivot_index:
        temp = unsorted_array[greater_than_pivot_index]
        unsorted_array[greater_than_pivot_index] = 
                unsorted_array[less_than_pivot_index] 
        unsorted_array[less_than_pivot_index] = temp
    <span class="hljs-keyword">else</span>:
        <span class="hljs-keyword">break</span>
</code></pre>
    <p class="normal">Here, since <code class="inlineCode">greater_than_pivot_index &lt; less_than_pivot_index</code>, the body of the <code class="inlineCode">if</code> statement swaps the element at those indexes. The <code class="inlineCode">else</code> condition breaks the infinite loop any <a id="_idIndexMarker981"/>time that <code class="inlineCode">greater_than_pivot_index</code> becomes greater than <code class="inlineCode">less_than_pivot_index</code>. In such a condition, it means that <code class="inlineCode">greater_than_pivot_index</code> and <code class="inlineCode">less_than_pivot_index</code> have crossed over each other.</p>
    <p class="normal">The array now looks as shown in <em class="italic">Figure 11.22</em>:</p>
    <figure class="mediaobject"><img src="../Images/B17217_11_22.png" alt=""/></figure>
    <p class="packt_figref">Figure 11.22: Illustration 3 of an example array for the quicksort algorithm</p>
    <p class="normal">The <code class="inlineCode">break</code> statement is executed when <code class="inlineCode">less_than_pivot_index</code> is equal to <code class="inlineCode">3</code> and <code class="inlineCode">greater_than_pivot_index</code> is equal to <code class="inlineCode">4</code>.</p>
    <p class="normal">As soon as we exit the <code class="inlineCode">while</code> loop, we interchange the element at <code class="inlineCode">unsorted_array[less_than_pivot_index]</code> with that of <code class="inlineCode">less_than_pivot_index</code>, which is returned as the index of the pivot:</p>
    <pre class="programlisting code"><code class="hljs-code">    unsorted_array[pivot_index]=unsorted_array[less_than_pivot_index]
    unsorted_array[less_than_pivot_index]=pivot
    <span class="hljs-keyword">return</span> less_than_pivot_index
</code></pre>
    <p class="normal"><em class="italic">Figure 11.23</em> shows how the code interchanges <code class="inlineCode">4</code> with <code class="inlineCode">43</code> as the last step in the partitioning process:</p>
    <figure class="mediaobject"><img src="../Images/B17217_11_23.png" alt=""/></figure>
    <p class="packt_figref">Figure 11.23: Illustration 4 of an example array for the quicksort algorithm</p>
    <p class="normal">To recap, the first time the <code class="inlineCode">quick_sort</code> function was called, it was partitioned at the element at index <code class="inlineCode">0</code>. After the return of the partitioning function, we obtain the array in the order of <code class="inlineCode">[4, 3, 20, 43, 89, 77]</code>.</p>
    <p class="normal">As you can see, all elements to the right of element <code class="inlineCode">43</code> are greater than <code class="inlineCode">43</code>, while those to the left are smaller. Thus, the partitioning is complete.</p>
    <p class="normal">Using the<a id="_idIndexMarker982"/> split point <code class="inlineCode">43</code> with index <code class="inlineCode">3</code>, we will recursively sort the two subarrays, <code class="inlineCode">[4, 30, 20]</code> and <code class="inlineCode">[89, 77]</code>, using the same process we just went through.</p>
    <p class="normal">The body of the main <code class="inlineCode">quick_sort</code> function is as follows:</p>
    <pre class="programlisting code"><code class="hljs-code"><span class="hljs-keyword">def</span><span class="hljs-function"> </span><span class="hljs-title">quick_sort</span><span class="hljs-function">(</span><span class="hljs-params">unsorted_array, first, last</span><span class="hljs-function">):</span>
    <span class="hljs-keyword">if</span> last - first &lt;= <span class="hljs-number">0</span>:
        <span class="hljs-keyword">return</span>
    <span class="hljs-keyword">else</span>:
        partition_point = partition(unsorted_array, first, last)
        quick_sort(unsorted_array, first, partition_point-<span class="hljs-number">1</span>)
        quick_sort(unsorted_array, partition_point+<span class="hljs-number">1</span>, last)
</code></pre>
    <p class="normal">The <code class="inlineCode">quick_sort</code> function is quite simple; initially, the <code class="inlineCode">partition</code> method is called, which returns the partition point. This partition point is in the <code class="inlineCode">unsorted_array</code> array where all elements to the left are less than the pivot value, and all elements to the right are greater. We print the state of <code class="inlineCode">unsorted_array</code> immediately after the partition progress to see the status of the array after every call.</p>
    <p class="normal">After the first partition, the first subarray<code class="inlineCode">[4, 3, 20]</code> will be done; the partition of this subarray will stop when <code class="inlineCode">greater_than_pivot_index</code> is at index <code class="inlineCode">2</code> and <code class="inlineCode">less_than_pivot_index</code> is at index <code class="inlineCode">1</code>. At that point, the two markers are said to have crossed. Because <code class="inlineCode">greater_than_pivot_index</code> is greater than <code class="inlineCode">less_than_pivot_index</code>, further execution of the <code class="inlineCode">while</code> loop will cease. Pivot <code class="inlineCode">4</code> will be exchanged with <code class="inlineCode">3</code>, while index <code class="inlineCode">1</code> is returned as the partition point.</p>
    <p class="normal">We can use the below code snippet to create a list of elements, and use the quicksort algorithm to sort it:</p>
    <pre class="programlisting code"><code class="hljs-code">my_array = [<span class="hljs-number">43</span>, <span class="hljs-number">3</span>, <span class="hljs-number">77</span>, <span class="hljs-number">89</span>, <span class="hljs-number">4</span>, <span class="hljs-number">20</span>]
<span class="hljs-built_in">print</span>(my_array)
quick_sort(my_array, <span class="hljs-number">0</span>, <span class="hljs-number">5</span>)
<span class="hljs-built_in">print</span>(my_array)
</code></pre>
    <p class="normal">The output of the above code is as follows:</p>
    <pre class="programlisting con"><code class="hljs-con">[43, 3, 77, 89, 4, 20]
[3, 4, 20, 43, 77, 89]
</code></pre>
    <p class="normal">In the quicksort algorithm, the partition algorithm takes <code class="inlineCode">O(n)</code> time. As the quicksort algorithm follows the <strong class="keyWord">divide and conquer</strong> paradigm, it takes <code class="inlineCode">O(logn)</code> time; therefore, the overall <a id="_idIndexMarker983"/>average-case runtime complexity of the quicksort algorithm is <code class="inlineCode">O(n)</code> <code class="inlineCode">*</code> <code class="inlineCode">O(logn)</code> <code class="inlineCode">= O(nlogn)</code>. The quicksort algorithm gives a worst-case runtime complexity of O(n<sup class="superscript">2</sup>). The worst-case complexity for the quicksort algorithm would be when it selects the worst pivot point every time, and one of the partitions always has a single element. For example, if the list is already sorted, the worst-case complexity would occur if the partition picks the smallest element as a pivot point. When worst-case complexity does occur, the quicksort algorithm can be improved by using the randomized quicksort. The quicksort algorithm is efficient when the given list of elements is very long; it works better compared to the other aforementioned algorithms for sorting in such situations.</p>
    <h1 id="_idParaDest-219" class="heading-1">Timsort algorithm</h1>
    <p class="normal">Timsort is used as<a id="_idIndexMarker984"/> the default standard sorting algorithm in all Python<a id="_idIndexMarker985"/> versions &gt;=2.3. The Timsort algorithm is an optimal algorithm for real-world long lists that is based on a combination of the merge sort and insertion sort algorithms. The Timsort algorithm utilizes the best of both algorithms; insertion sort works best when the array is sorted partially and its size is small, and the merge method of the merge sort algorithm works fast when we have to combine small, sorted lists.</p>
    <p class="normal">The main concept of the Timsort algorithm is that it uses the insertion sort algorithm to sort small blocks (also known as chunks) of data elements, and then it uses the merge sort algorithm to merge all the sorted chunks. The main characteristic of the Timsort algorithm is that it takes advantage of already-sorted data elements known as “natural runs,” which occur very frequently in real-world data.</p>
    <p class="normal">The <a id="_idIndexMarker986"/>Timsort algorithm<a id="_idIndexMarker987"/> works as follows:</p>
    <ol class="numberedList" style="list-style-type: decimal;">
      <li class="numberedList" value="1">Firstly, we divide the given array of data elements into a number of blocks which are also known as a run.</li>
      <li class="numberedList">We generally use 32 or 64 as the size of the run as it is suitable for Timsort; however, we can use any other size that can be computed from the length of the given array (say <code class="inlineCode">N</code>). The <code class="inlineCode">minrun</code> is the minimum length of each run. The size of the <code class="inlineCode">minrun</code> can be computed by following the given principles:<ol class="alphabeticList" style="list-style-type: lower-alpha;">
          <li class="alphabeticList" value="1">The <code class="inlineCode">minrun</code> size should not be too long as we use the insertion sort algorithm to sort these small blocks, which performs well for short lists of elements.</li>
          <li class="alphabeticList">The length of the run should not be very short; in that case, it will result in a greater number of runs, which will make the merging algorithm slow.</li>
          <li class="alphabeticList">Since merge sort works best when we have the number of runs as a power of 2, it would be good if the number of runs that compute as <code class="inlineCode">N/minrun</code> are a power of 2.</li>
        </ol>
      </li>
      <li class="numberedList">For example, if we take a run size of 32, then the number of runs will be <code class="inlineCode">(size_of_array/32)</code>; if this is a power of 2, then the merge process will be very efficient.</li>
      <li class="numberedList">Sort each of the runs one by one using the insertion sort algorithm.</li>
      <li class="numberedList">Merge all the sorted runs one by one using the merge method of the merge sort algorithm.</li>
      <li class="numberedList">After each iteration, we double the size of the merged subarray.</li>
    </ol>
    <p class="normal">Let’s take an example to understand the working of the Timsort algorithm. Let’s say we have the array <code class="inlineCode">[4, 6, 3, 9, 2, 8, 7, 5]</code>. We sort it using the Timsort algorithm; here, for simplicity, we take the size of the run as 4. So, we divide the given array into two runs, run 1 and run 2. Next, we sort run 1 using the insertion sort algorithm, and then we sort run 2 using the insertion sort algorithm. Once we have all the runs sorted, we use the merge method of the merge sort algorithm to obtain the final complete sorted list. The complete process is shown in <em class="italic">Figure 11.24</em>:</p>
    <figure class="mediaobject"><img src="../Images/B17217_11_24.png" alt=""/></figure>
    <p class="packt_figref">Figure 11.24: Illustration of an example array for the Timsort algorithm</p>
    <p class="normal">Next, let’s <a id="_idIndexMarker988"/>discuss the implementation of the Timsort algorithm. Firstly, we implement the insertion sort algorithm and the merge method of the merge <a id="_idIndexMarker989"/>sort algorithm. The insertion sort algorithm has already been discussed in detail in previous sections. For completeness, it is given below again:</p>
    <pre class="programlisting code"><code class="hljs-code"><span class="hljs-keyword">def</span><span class="hljs-function"> </span><span class="hljs-title">Insertion_Sort</span><span class="hljs-function">(</span><span class="hljs-params">unsorted_list</span><span class="hljs-function">):</span> 
    <span class="hljs-keyword">for</span> index <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-number">1</span>, <span class="hljs-built_in">len</span>(unsorted_list)): 
        search_index = index 
        insert_value = unsorted_list[index] 
        <span class="hljs-keyword">while</span> search_index &gt; <span class="hljs-number">0</span> <span class="hljs-keyword">and</span> unsorted_list[search_index-<span class="hljs-number">1</span>] &gt; insert_value : 
            unsorted_list[search_index] = unsorted_list[search_index-<span class="hljs-number">1</span>] 
            search_index -= <span class="hljs-number">1</span> 
        unsorted_list[search_index] = insert_value 
    <span class="hljs-keyword">return</span> unsorted_list
</code></pre>
    <p class="normal">In the above, the insertion sort method is responsible in sorting the run. Next, we present the merge method of the merge sort algorithm; this has been discussed in detail in <em class="chapterRef">Chapter 3</em>, <em class="italic">Algorithm Design Techniques and Strategies</em>. This <code class="inlineCode">Merge()</code> function is used to merge the sorted runs, and it is defined as follows:</p>
    <pre class="programlisting code"><code class="hljs-code"><span class="hljs-keyword">def</span><span class="hljs-function"> </span><span class="hljs-title">Merge</span><span class="hljs-function">(</span><span class="hljs-params">first_sublist, second_sublist</span><span class="hljs-function">):</span>
    i = j = <span class="hljs-number">0</span>
    merged_list = []
    <span class="hljs-keyword">while</span> i &lt; <span class="hljs-built_in">len</span>(first_sublist) <span class="hljs-keyword">and</span> j &lt; <span class="hljs-built_in">len</span>(second_sublist):
        <span class="hljs-keyword">if</span> first_sublist[i] &lt; second_sublist[j]:
            merged_list.append(first_sublist[i])  
            i += <span class="hljs-number">1</span>  
        <span class="hljs-keyword">else</span>:
            merged_list.append(second_sublist[j])  
            j += <span class="hljs-number">1</span>
    <span class="hljs-keyword">while</span> i &lt; <span class="hljs-built_in">len</span>(first_sublist):  
        merged_list.append(first_sublist[i])  
        i += <span class="hljs-number">1</span>  
    <span class="hljs-keyword">while</span> j &lt; <span class="hljs-built_in">len</span>(second_sublist):
        merged_list.append(second_sublist[j])  
        j += <span class="hljs-number">1</span>
    <span class="hljs-keyword">return</span> merged_list
</code></pre>
    <p class="normal">Next, let’s<a id="_idIndexMarker990"/> discuss the Timsort algorithm. Its implementation is given below. Let’s<a id="_idIndexMarker991"/> understand it bit by bit:</p>
    <pre class="programlisting code"><code class="hljs-code"><span class="hljs-keyword">def</span><span class="hljs-function"> </span><span class="hljs-title">Tim_Sort</span><span class="hljs-function">(</span><span class="hljs-params">arr, run</span><span class="hljs-function">):</span>
    <span class="hljs-keyword">for</span> x <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-number">0</span>, <span class="hljs-built_in">len</span>(arr), run):
        arr[x : x + run] = Insertion_Sort(arr[x : x + run]) 
    runSize = run    
    <span class="hljs-keyword">while</span> runSize &lt; <span class="hljs-built_in">len</span>(arr):
        <span class="hljs-keyword">for</span> x <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-number">0</span>, <span class="hljs-built_in">len</span>(arr), <span class="hljs-number">2</span> * runSize):
            arr[x : x + <span class="hljs-number">2</span> * runSize] = Merge(arr[x : x + runSize], arr[x + runSize: x + <span class="hljs-number">2</span> * runSize]) 
            
        runSize = runSize * <span class="hljs-number">2</span>
</code></pre>
    <p class="normal">In the above implementation, we firstly pass two parameters, the array that is to be sorted and the size of the run. Next, we use insertion sort to sort the individual subarrays by run size in the below code snippet:</p>
    <pre class="programlisting code"><code class="hljs-code"><span class="hljs-keyword">for</span> x <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-number">0</span>, <span class="hljs-built_in">len</span>(arr), run):
       arr[x : x + run] = Insertion_Sort(arr[x : x + run])
</code></pre>
    <p class="normal">In the above code for the example list <code class="inlineCode">[4, 6, 3, 9, 2, 8, 7, 5]</code>, let’s say run size is 2, so we will have a total of four blocks/chunks/runs, and after exiting this loop, the array will be like this: <code class="inlineCode">[4, 6, 3, 9, 2, 8, 5, 7]</code>, indicating that all runs of size 2 are sorted. After that we initialize <code class="inlineCode">runSize</code> and we iterate until <code class="inlineCode">runSize</code> becomes equal to the array length. So, we use the merge method for combining the sorted small lists:</p>
    <pre class="programlisting code"><code class="hljs-code">    runSize = run    
    <span class="hljs-keyword">while</span> runSize &lt; <span class="hljs-built_in">len</span>(arr):
        <span class="hljs-keyword">for</span> x <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-number">0</span>, <span class="hljs-built_in">len</span>(arr), <span class="hljs-number">2</span> * runSize):
            arr[x : x + <span class="hljs-number">2</span> * runSize] = Merge(arr[x : x + runSize], arr[x + runSize: x + <span class="hljs-number">2</span> * runSize]) 
            
        runSize = runSize * <span class="hljs-number">2</span>
</code></pre>
    <p class="normal">In the above<a id="_idIndexMarker992"/> code, the <code class="inlineCode">for</code> loop is using the <code class="inlineCode">Merge</code> function for merging the<a id="_idIndexMarker993"/> runs of size <code class="inlineCode">runSize</code>. For the example above, the <code class="inlineCode">runSize</code> is <code class="inlineCode">2</code>. In the first iteration, it will merge the left run from index <code class="inlineCode">(0</code> <code class="inlineCode">to</code> <code class="inlineCode">1)</code> and right run from index <code class="inlineCode">(2 to 3)</code> to form a sorted array from index <code class="inlineCode">(0 to 3)</code>, and the array will become <code class="inlineCode">[3, 4, 6, 9, 2, 8, 5, 7]</code>.</p>
    <p class="normal">Further, in the second iteration, it will merge the left run from index <code class="inlineCode">(4 to 5)</code> and the right run from index <code class="inlineCode">(6 to 7)</code> to form a sorted run from index <code class="inlineCode">(4 to 7)</code>. After the second iteration the <code class="inlineCode">for</code> loop will terminate and the array will become <code class="inlineCode">[3, 4, 6, 9, 2, 5, 7, 8]</code>, which indicates the array has been sorted from index <code class="inlineCode">(0 to 3)</code> and <code class="inlineCode">(4 to 7)</code>.</p>
    <p class="normal">Now we update the size of the run as <code class="inlineCode">2*runSize</code> and we repeat the same process for the updated <code class="inlineCode">runSize</code>. So now, <code class="inlineCode">runSize</code> is <code class="inlineCode">4</code>. Now, in the first iteration, it will merge the left run (index <code class="inlineCode">0</code> to <code class="inlineCode">3</code>) and right run (index <code class="inlineCode">4</code> to <code class="inlineCode">7</code>) to form a sorted array from index (<code class="inlineCode">0</code> to <code class="inlineCode">7</code>) and after this the <code class="inlineCode">for</code> loop will terminate and the array will become <code class="inlineCode">[2, 3, 4, 5, 6, 7, 8, 9]</code>, which indicates the array has been sorted.</p>
    <p class="normal">Now, <code class="inlineCode">runSize</code> will become equal to the array length so the <code class="inlineCode">while</code> loop will terminate, and at last, we will be left with the sorted array.</p>
    <p class="normal">We can use the below code snippet to create a list, and then sort the list using the Timsort algorithm:</p>
    <pre class="programlisting code"><code class="hljs-code">arr = [<span class="hljs-number">4</span>, <span class="hljs-number">6</span>, <span class="hljs-number">3</span>, <span class="hljs-number">9</span>, <span class="hljs-number">2</span>, <span class="hljs-number">8</span>, <span class="hljs-number">7</span>, <span class="hljs-number">5</span>]
run = <span class="hljs-number">2</span>
Tim_Sort(arr, run) 
<span class="hljs-built_in">print</span>(arr)
</code></pre>
    <p class="normal">The output of the above code is as follows:</p>
    <pre class="programlisting con"><code class="hljs-con">[2,3,4,5,6,7,8,9]
</code></pre>
    <p class="normal">Timsort is<a id="_idIndexMarker994"/> very efficient for real-world applications since it has a worst-case<a id="_idIndexMarker995"/> complexity of <code class="inlineCode">O(n logn)</code>. Timsort is the best choice for sorting, even if the length of the given list is short. In that case, it uses the insertion sort algorithm, which is very fast for smaller lists, and the Timsort algorithm works fast for long lists due to the merge method; hence, the Timsort algorithm is a good choice for sorting due to its adaptability for sorting arrays of any length in real-world usage.</p>
    <p class="normal">A comparison of the complexities of different sorting algorithms is given in the following table:</p>
    <table id="table001-5" class="table-container">
      <tbody>
        <tr>
          <td class="table-cell">
            <p class="normal"><strong class="keyWord">Algorithm</strong></p>
          </td>
          <td class="table-cell">
            <p class="normal"><strong class="keyWord">worst-case</strong></p>
          </td>
          <td class="table-cell">
            <p class="normal"><strong class="keyWord">average-case</strong></p>
          </td>
          <td class="table-cell">
            <p class="normal"><strong class="keyWord">best-case</strong></p>
          </td>
        </tr>
        <tr>
          <td class="table-cell">
            <p class="normal">Bubble sort</p>
          </td>
          <td class="table-cell">
            <p class="normal"><code class="inlineCode">O(n2)</code></p>
          </td>
          <td class="table-cell">
            <p class="normal"><code class="inlineCode">O(n2)</code></p>
          </td>
          <td class="table-cell">
            <p class="normal"><code class="inlineCode">O(n)</code></p>
          </td>
        </tr>
        <tr>
          <td class="table-cell">
            <p class="normal">Insertion sort</p>
          </td>
          <td class="table-cell">
            <p class="normal"><code class="inlineCode">O(n2)</code></p>
          </td>
          <td class="table-cell">
            <p class="normal"><code class="inlineCode">O(n2)</code></p>
          </td>
          <td class="table-cell">
            <p class="normal"><code class="inlineCode">O(n)</code></p>
          </td>
        </tr>
        <tr>
          <td class="table-cell">
            <p class="normal">Selection sort</p>
          </td>
          <td class="table-cell">
            <p class="normal"><code class="inlineCode">O(n2)</code></p>
          </td>
          <td class="table-cell">
            <p class="normal"><code class="inlineCode">O(n2)</code></p>
          </td>
          <td class="table-cell">
            <p class="normal"><code class="inlineCode">O(n2)</code></p>
          </td>
        </tr>
        <tr>
          <td class="table-cell">
            <p class="normal">Quicksort</p>
          </td>
          <td class="table-cell">
            <p class="normal"><code class="inlineCode">O(n2)</code></p>
          </td>
          <td class="table-cell">
            <p class="normal"><code class="inlineCode">O(n log n)</code></p>
          </td>
          <td class="table-cell">
            <p class="normal"><code class="inlineCode">O(n log n)</code></p>
          </td>
        </tr>
        <tr>
          <td class="table-cell">
            <p class="normal">Timsort </p>
          </td>
          <td class="table-cell">
            <p class="normal"><code class="inlineCode">O(n log n)</code></p>
          </td>
          <td class="table-cell">
            <p class="normal"><code class="inlineCode">O(n log n)</code></p>
          </td>
          <td class="table-cell">
            <p class="normal"><code class="inlineCode">O(n)</code></p>
          </td>
        </tr>
      </tbody>
    </table>
    <p class="packt_figref">Table 11.1: Comparing the complexity of different sorting algorithms</p>
    <h1 id="_idParaDest-220" class="heading-1">Summary</h1>
    <p class="normal">In this chapter, we have explored important and popular sorting algorithms that are very useful for many real-world applications. We have discussed the bubble sort, insertion sort, selection sort, quicksort, and Timsort algorithms, along with explaining their implementation in Python. In general, the quicksort algorithm performs better than the other sorting algorithms, and the Timsort algorithm is the best choice to use in real-world applications.</p>
    <p class="normal">In the next chapter, we will discuss selection algorithms.</p>
    <h1 id="_idParaDest-221" class="heading-1">Exercise</h1>
    <ol class="numberedList" style="list-style-type: decimal;">
      <li class="numberedList" value="1">If an array <code class="inlineCode">arr = {55, 42, 4, 31}</code> is given and bubble sort is used to sort the array elements, then how many iterations will be required to sort the array?<ol class="alphabeticList" style="list-style-type: lower-alpha;">
          <li class="alphabeticList" value="1">3</li>
          <li class="alphabeticList">2</li>
          <li class="alphabeticList">1</li>
          <li class="alphabeticList">0</li>
        </ol>
      </li>
      <li class="numberedList">What is the worst-case complexity of bubble sort?<ol class="alphabeticList" style="list-style-type: lower-alpha;">
          <li class="alphabeticList" value="1"><code class="inlineCode">O(n</code> <code class="inlineCode">log</code> <code class="inlineCode">n)</code></li>
          <li class="alphabeticList"><code class="inlineCode">O(log</code> <code class="inlineCode">n)</code></li>
          <li class="alphabeticList"><code class="inlineCode">O(n)</code></li>
          <li class="alphabeticList"><code class="inlineCode">O(n</code><sup class="superscript">2</sup><code class="inlineCode">)</code></li>
        </ol>
      </li>
      <li class="numberedList">Apply quicksort to the sequence (<code class="inlineCode">56, 89, 23, 99, 45, 12, 66, 78, 34</code>). What is the sequence after the first phase, and what pivot is the first element?<ol class="alphabeticList" style="list-style-type: lower-alpha;">
          <li class="alphabeticList" value="1">45, 23, 12, 34, 56, 99, 66, 78, 89</li>
          <li class="alphabeticList">34, 12, 23, 45, 56, 99, 66, 78, 89</li>
          <li class="alphabeticList">12, 45, 23, 34, 56, 89, 78, 66, 99</li>
          <li class="alphabeticList">34, 12, 23, 45, 99, 66, 89, 78, 56</li>
        </ol>
      </li>
      <li class="numberedList">Quicksort is a ___________<ol class="alphabeticList" style="list-style-type: lower-alpha;">
          <li class="alphabeticList" value="1">Greedy algorithm</li>
          <li class="alphabeticList">Divide and conquer algorithm</li>
          <li class="alphabeticList">Dynamic programming algorithm</li>
          <li class="alphabeticList">Backtracking algorithm</li>
        </ol>
      </li>
      <li class="numberedList">Consider a situation where a swap operation is very costly. Which of the following sorting algorithms should be used so that the number of swap operations is minimized?<ol class="alphabeticList" style="list-style-type: lower-alpha;">
          <li class="alphabeticList" value="1">Heap sort</li>
          <li class="alphabeticList">Selection sort</li>
          <li class="alphabeticList">Insertion sort</li>
          <li class="alphabeticList">Merge sort</li>
        </ol>
      </li>
      <li class="numberedList">If the input array <code class="inlineCode">A</code> <code class="inlineCode">=</code> <code class="inlineCode">{15</code>, <code class="inlineCode">9</code>, <code class="inlineCode">33</code>, <code class="inlineCode">35</code>, <code class="inlineCode">100</code>, <code class="inlineCode">95</code>, <code class="inlineCode">13</code>, <code class="inlineCode">11</code>, <code class="inlineCode">2</code>, <code class="inlineCode">13}</code> is given, using selection sort, what would the order of the array be after the fifth swap? (Note: it counts regardless of whether they exchange places or remain in the same position.)<ol class="alphabeticList" style="list-style-type: lower-alpha;">
          <li class="alphabeticList" value="1">2, 9, 11, 13, 13, 95, 35, 33, 15, 100</li>
          <li class="alphabeticList">2, 9, 11, 13, 13, 15, 35, 33, 95, 100</li>
          <li class="alphabeticList">35, 100, 95, 2, 9, 11, 13, 33, 15, 13</li>
          <li class="alphabeticList">11, 13, 9, 2, 100, 95, 35, 33, 13, 13</li>
        </ol>
      </li>
      <li class="numberedList">What will be the number of iterations to sort the elements <code class="inlineCode">{44, 21, 61, 6, 13, 1}</code> using insertion sort?<ol class="alphabeticList" style="list-style-type: lower-alpha;">
          <li class="alphabeticList" value="1">6</li>
          <li class="alphabeticList">5</li>
          <li class="alphabeticList">7</li>
          <li class="alphabeticList">1</li>
        </ol>
      </li>
      <li class="numberedList">How will the array elements <code class="inlineCode">A= [35, 7, 64, 52, 32, 22]</code> look after the second iteration, if the elements are sorted using insertion sort?<ol class="alphabeticList" style="list-style-type: lower-alpha;">
          <li class="alphabeticList" value="1">7, 22, 32, 35, 52, 64</li>
          <li class="alphabeticList">7, 32, 35, 52, 64, 22</li>
          <li class="alphabeticList">7, 35, 52, 64, 32, 22</li>
          <li class="alphabeticList">7, 35, 64, 52, 32, 22</li>
        </ol>
      </li>
    </ol>
    <h1 class="heading-1">Join our community on Discord</h1>
    <p class="normal">Join our community’s Discord space for discussions with the author and other readers: <a href="https://packt.link/MEvK4"><span class="url">https://packt.link/MEvK4</span></a></p>
    <p class="normal"><img src="../Images/QR_Code1421249772551223062.png" alt=""/></p>
  </div>
</body></html>