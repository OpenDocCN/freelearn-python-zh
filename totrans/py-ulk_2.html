<html><head></head><body><div><div><div><div><h1 class="title"><a id="ch02"/>Chapter 2. Namespaces and Classes</h1></div></div></div><p>In the previous chapter, we covered how objects worked. In this chapter, we will explore how objects are made available to code via reference, specifically how namespaces work, what modules are, and how they are imported. We will also cover topics related to classes, such as language protocols, MRO, and abstract classes. We will discuss the following topics:</p><div><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">Namespaces</li><li class="listitem" style="list-style-type: disc">Imports and modules</li><li class="listitem" style="list-style-type: disc">Class multiple inheritance, MRO, super</li><li class="listitem" style="list-style-type: disc">Protocols</li><li class="listitem" style="list-style-type: disc">Abstract classes</li></ul></div><div><div><div><div><h1 class="title"><a id="ch02lvl1sec13"/>How referencing objects work – namespaces</h1></div></div></div><p>
<strong>Key 1: Interrelations between objects.</strong>
</p><p>The scope is <a id="id41" class="indexterm"/>the visibility <a id="id42" class="indexterm"/>of a name within a code block. Namespace is mapping from names to objects. Namespaces are important in order to maintain localization and avoid name collision. Every module has a global namespace. Modules store mapping from variable name to objects in their <code class="literal">__dict__</code> attribute, which is a normal Python dictionary along with information to reload it, package information, and so on.</p><p>Every module's global namespace has an implicit reference to the built-in module; hence, objects that are in the built-in module are always available. We can also import other modules in the main script. When we use the syntax import module name, a mapping with module name to module object is created in the global namespace of the current module. For import statements with syntax such as <code class="literal">import modname as modrename</code>, mapping is created with a new name to module object.</p><p>We are always<a id="id43" class="indexterm"/> in the <code class="literal">__main__</code> module's global namespace when the program starts, as it is the module<a id="id44" class="indexterm"/> that imports all others. When we import a variable from another module, only an entry is created for that variable in the global namespace pointing at the referenced object. Now interestingly, if this variable references a function object, and if this function uses a global variable, then this variable will be searched in the global namespace of the module that the function was defined in, not in the module that we imported this function to. This is possible because functions have the <code class="literal">__globals__</code> attribute that points to its <code class="literal">__dict__</code> modules, or in short, its modules namespace.</p><p>All modules that are loaded and referenced are cached in <code class="literal">sys.modules</code>. All imported modules are names pointing to objects in <code class="literal">sys.modules</code>. Let's define a new module like this with the name <code class="literal">new.py</code>:</p><div><pre class="programlisting">k = 10 
def foo():
    print(k)</pre></div><p>By importing this module in the interactive session, we can see how global namespaces work. When this module is reloaded, its namespace dictionary is updated, not recreated. Hence, if you attach anything new from the outside of the module to it, it will survive reload:</p><div><pre class="programlisting">&gt;&gt;&gt; import importlib
&gt;&gt;&gt; import new
&gt;&gt;&gt; from new import foo
&gt;&gt;&gt; import sys
&gt;&gt;&gt; foo()
10
&gt;&gt;&gt; new.foo()
10
&gt;&gt;&gt; foo.__globals__ is sys.modules['new'].__dict__ # dictionary used by namespace and function attribute __globals__ is indeed same
True
&gt;&gt;&gt; foo.__globals__['k'] = 20  # changing global namespace dictionary
&gt;&gt;&gt; new.do   #attribute is not defined in the module
Traceback (most recent call last):
  File "&lt;stdin&gt;", line 1, in &lt;module&gt;
AttributeError: module 'new' has no attribute 'do'
&gt;&gt;&gt; foo.__globals__['do'] = 22 #we are attaching attribute to module from outside the module
&gt;&gt;&gt; new.do
22
&gt;&gt;&gt; foo()  # we get updated value for global variable
20
&gt;&gt;&gt; new.foo()
20
&gt;&gt;&gt; importlib.reload(new) #reload repopulates old modules dictionary
&lt;module 'new' from '/tmp/new.py'&gt;
&gt;&gt;&gt; new.do #it didn't got updated as it was populated from outside.
22
&gt;&gt;&gt; new.foo() #variables updated by execution of code in module are updated
10
&gt;&gt;&gt;</pre></div><p>If we use the<a id="id45" class="indexterm"/> functions <a id="id46" class="indexterm"/>that are defined in different modules to compose a class on runtime, such as using metaclasses, or class decorators, this can bring up surprises as each function could be using a different global namespace.</p><p>Locals are simple and they work in the way that you expect. Each function call gets its own copy of variables. Nonlocal variables make variables that are defined in the outer scope (not global namespace) accessible to the current code block. In the following code example, we can see how variables can be referenced in enclosed functions.</p><p>Code blocks are able to reference variables that are defined in enclosing scopes. Hence, if a variable is not defined in a function but in an enclosing function, we are able to get its value. If, after referencing a variable in an outer scope, we assign a value to this variable in a code block, it will confuse the interpreter in finding the right variable, and we will get the value from the current local scope. If we assign a value to the variable, it defaults to the local variable. We can specify that we want to work with an enclosing variable using a nonlocal keyword:</p><div><pre class="programlisting">&gt;&gt;&gt; #variable in enclosing scope can be referenced any level deep
... 
&gt;&gt;&gt; def f1():
...     v1 = "ohm"
...     def f2():
...         print("f2",v1)
...         def f3():
...             print("f3",v1)
...         f3()
...     f2()
... 
&gt;&gt;&gt; f1()
f2 ohm
f3 ohm
&gt;&gt;&gt; 
&gt;&gt;&gt; #variable can be made non-local (variable in outer scopes) skipping one level of enclosing scope
... 
&gt;&gt;&gt; def f1():
...     v1 = "ohm"
...     def f2():
...         print("f2",v1)
...         def f3():
...             nonlocal v1
...             v1 = "mho"
...             print("f3",v1)
...         f3()
...         print("f2",v1)
...     f2()
...     print("f1",v1)
... 
&gt;&gt;&gt; f1()
f2 ohm
f3 mho
f2 mho
f1 mho
&gt;&gt;&gt; 
&gt;&gt;&gt; 
&gt;&gt;&gt; #global can be specified at any level of enclosed function
... 
&gt;&gt;&gt; v2 = "joule"
&gt;&gt;&gt; 
&gt;&gt;&gt; def f1():
...     def f2():
...         def f3():
...             global v2
...             v2 = "mho"
...             print("f3",v2)
...         f3()
...         print("f2",v2)
...     f2()
...     print("f1",v2)
... 
&gt;&gt;&gt; f1()
f3 mho
f2 mho
f1 mho</pre></div><p>As variables<a id="id47" class="indexterm"/> are searched without any dictionary lookup for the local namespace, it is faster to look up <a id="id48" class="indexterm"/>variables inside a function with a small number of variables than to search in a global namespace. On similar lines, we will get a little speed boost if we pull objects that are referenced in loops in a function's local namespace inside a function block:</p><div><pre class="programlisting">In [6]: def fun():
   ...:     localsum = sum
   ...:     return localsum(localsum((a,a+1)) for a in range(1000))
   ...: 

In [8]: def fun2():
   ...:     return sum(sum((a,a+1)) for a in range(1000))
   ...: 

In [9]: %timeit fun2()
1000 loops, best of 3: 1.07 ms per loop

In [11]: %timeit fun()
1000 loops, best of 3: 983 µs per loop</pre></div></div></div>
<div><div><div><div><h1 class="title"><a id="ch02lvl1sec14"/>Functions with state – closures</h1></div></div></div><p>
<strong>Key 2: Creating cheap state-remembering functions.</strong>
</p><p>A closure is a<a id="id49" class="indexterm"/> function that has access to variables in an enclosing scope, which has completed its execution. This means that referenced objects are kept alive until the function is in memory. The main utility of such a setup is to easily retain some state, or to create specialized functions whose functioning depends on the initial setup:</p><div><pre class="programlisting">&gt;&gt;&gt; def getformatter(start,end):
...     def formatter(istr):
...         print("%s%s%s"%(start,istr,end))
...     return formatter
... 
&gt;&gt;&gt; formatter1 = getformatter("&lt;","&gt;")
&gt;&gt;&gt; formatter2 = getformatter("[","]")
&gt;&gt;&gt; 
&gt;&gt;&gt; formatter1("hello")
&lt;hello&gt;
&gt;&gt;&gt; formatter2("hello")
[hello]
&gt;&gt;&gt; formatter1.__closure__[0].cell_contents
'&gt;'
&gt;&gt;&gt; formatter1.__closure__[1].cell_contents
'&lt;'</pre></div><p>We can do the same<a id="id50" class="indexterm"/> by creating a class and using the instance object to save state. The benefit with closures is that variables are stored in a <code class="literal">__closure__</code> tuple, and hence, they are fast to access. Less code is required to create a closure as compared to classes:</p><div><pre class="programlisting">&gt;&gt;&gt; def formatter(st,en):
...     def fmt(inp):
...             return "%s%s%s"%(st,inp,en)
...     return fmt
... 
&gt;&gt;&gt; fmt1 = formatter("&lt;","&gt;")
&gt;&gt;&gt; fmt1("hello")
'&lt;hello&gt;'
&gt;&gt;&gt; timeit.timeit(stmt="fmt1('hello')",
... number=1000000,globals={'fmt1':fmt1})
0.3326794120075647
&gt;&gt;&gt; class Formatter:
...     def __init__(self,st,en):
...             self.st = st
...             self.en = en
...     def __call__(self, inp):
...             return "%s%s%s"%(self.st,inp,self.en)
... 
&gt;&gt;&gt; fmt2 = Formatter("&lt;","&gt;")
&gt;&gt;&gt; fmt2("hello")
'&lt;hello&gt;'
&gt;&gt;&gt; timeit.timeit(stmt="fmt2('hello')",
... number=1000000,globals={'fmt2':fmt2})
0.5502702980011236</pre></div><p>One such function is available from the standard library, named partial, that makes use of closure to create a new function that is always invoked with some predefined arguments:</p><div><pre class="programlisting">&gt;&gt;&gt; import functools
&gt;&gt;&gt; 
&gt;&gt;&gt; def foo(*args,**kwargs):
...     print("foo with",args,kwargs)    
... 
&gt;&gt;&gt; pfoo = functools.partial(foo,10,20,v1=23)
&gt;&gt;&gt; 
&gt;&gt;&gt; foo(1,2,3,array=1)
foo with (1, 2, 3) {'array': 1}
&gt;&gt;&gt; pfoo()
foo with (10, 20) {'v1': 23}
&gt;&gt;&gt; pfoo(30,40,array=12)
foo with (10, 20, 30, 40) {'v1': 23, 'array': 12}</pre></div></div>
<div><div><div><div><h1 class="title"><a id="ch02lvl1sec15"/>Understanding import and modules</h1></div></div></div><p>
<strong>Key 3: Creating a custom loader for modules.</strong>
</p><p>Import statements <a id="id51" class="indexterm"/>get references <a id="id52" class="indexterm"/>of other module objects in the current module's namespace. It consists of searching the module, executing code to create a module object, updating caches (<code class="literal">sys.modules</code>), updating modules namespace, and creating a reference to new module being imported.</p><p>The built-in <code class="literal">__import__</code> function searches and executes the module to create a module object. The <code class="literal">importlib</code> library has the implementation, and it also provides a customizable interface to the import mechanism. Various classes interact to get the job done. The <code class="literal">__import__</code> function should return a module object. For example, in the following example, we are creating a module finder, which checks for modules in any path that is given as an argument during construction. Here, an empty file named <code class="literal">names.py</code> should be present at the given path. We have loaded the module, then inserted its module object in <code class="literal">sys.modules</code> and added a function to this module's global namespace:</p><div><pre class="programlisting">import os
import sys

class Spec:
    def __init__(self,name,loader,file='None',path=None,
                 cached=None,parent=None,has_location=False):
        self.name = name
        self.loader = loader
        self.origin = file
        self.submodule_search_locations = path
        self.cached = cached
        self.has_location = has_location


class Finder:
    def __init__(self, path):
        self.path = path

    def find_spec(self,name,path,target):
        print("find spec name:%s path:%s target:%s"%(name,path,target))
        return Spec(name,self,path)

    def load_module(self, fullname):
        print("loading module",fullname)
        if fullname+'.py' in os.listdir(self.path):
            import builtins
            mod = type(os)
            modobject = mod(fullname)
            modobject.__builtins__ = builtins
            def foo():
                print("hii i am foo")
            modobject.__dict__['too'] = foo
            sys.modules[fullname] = modobject
            modobject.__spec__ = 'asdfasfsadfsd'
            modobject.__name__ = fullname
            modobject.__file__ = 'aruns file'
            return modobject

sys.meta_path.append(Finder(r'/tmp'))
import notes
notes.too()

Output:
find spec name:notes path:None target:None
loading module notes
hii i am foo</pre></div><div><div><div><div><h2 class="title"><a id="ch02lvl2sec15"/>Customizing imports</h2></div></div></div><p>If the module has an <code class="literal">__all__</code> attribute, only the names that are specified by the iterable in this <a id="id53" class="indexterm"/>attribute will be imported from module import <code class="literal">*</code>. Let's assume that we created a module named <code class="literal">mymod.py</code>, as follows:</p><div><pre class="programlisting">__all__ = ('hulk','k')

k = 10
def hulk():
    print("i am hulk")

def spidey():
    print("i am spidey")</pre></div><p>We will not be<a id="id54" class="indexterm"/> able to import <code class="literal">spidey</code> from <code class="literal">mymod</code> as it is not included in <code class="literal">__all__</code>:</p><div><pre class="programlisting">&gt;&gt;&gt; from mymod import *
&gt;&gt;&gt; 
&gt;&gt;&gt; hulk()
i am hulk
&gt;&gt;&gt; k
10
&gt;&gt;&gt; spidey()
Traceback (most recent call last):
  File "&lt;stdin&gt;", line 1, in &lt;module&gt;
NameError: name 'spidey' is not defined</pre></div></div></div>
<div><div><div><div><h1 class="title"><a id="ch02lvl1sec16"/>Class inheritance</h1></div></div></div><p>We already discussed how instances and classes are created. We also discussed how attributes are accessed in a class. Let's dive deeper into how this works for multiple base classes. As <a id="id55" class="indexterm"/>type is searched for the presence of an attribute for an instance, if the type inherits from a number of classes, they all are searched as well. There is a defined pattern to this (<strong>Method Resolution Order</strong> (<strong>MRO</strong>)). This order plays an important role in <a id="id56" class="indexterm"/>determining the method in cases of multiple inheritance and diamond-shaped inheritance.</p><div><div><div><div><h2 class="title"><a id="ch02lvl2sec16"/>Method resolution order</h2></div></div></div><p>
<strong>Key 4: Understanding MRO.</strong>
</p><p>The methods <a id="id57" class="indexterm"/>are searched in the base classes of a class in predefined manner. This sequence or order is known as method resolution order. In Python 3, when an attribute is not found in a class, it is searched in all the base classes of that class. If the attribute is still not found, the base classes of the base classes are searched. This process goes on until we exhaust all base classes. This is similar to how if we have to ask a question, we will first go to our parents and then to uncles, and aunts (the same level base classes). If we still do not get an answer, we will approach grandparents. The following code snippet shows this sequence:</p><div><pre class="programlisting">&gt;&gt;&gt; class GrandParent:
...     def do(self,):
...         print("Grandparent do called")
...
&gt;&gt;&gt; class Father(GrandParent):
...     def do(self,):
...         print("Father do called")
...
&gt;&gt;&gt; class Mother(GrandParent):
...     def do(self,):
...         print("Mother do called")
...
&gt;&gt;&gt; class Child(Father, Mother):
...     def do(self,):
...         print("Child do called")
...
&gt;&gt;&gt; c = Child() # calls method in Class
&gt;&gt;&gt; c.do()
Child do called
&gt;&gt;&gt; del Child.do # if method is not defined it is searched in bases
&gt;&gt;&gt; c.do()  #Father's method
Father do called
&gt;&gt;&gt; c.__class__.__bases__ =  (c.__class__.__bases__[1],c.__class__.__bases__[0]) #we swap bases order
&gt;&gt;&gt; c.do() #Mothers's method
Mother do called
&gt;&gt;&gt; del Mother.do
&gt;&gt;&gt; c.do() #Fathers' method
Father do called
&gt;&gt;&gt; del Father.do
&gt;&gt;&gt; c.do()
Grandparent do called</pre></div></div><div><div><div><div><h2 class="title"><a id="ch02lvl2sec17"/>Super's superpowers</h2></div></div></div><p>
<strong>Key 6: Get superclass's methods without a superclass definition.</strong>
</p><p>We mostly <a id="id58" class="indexterm"/>create subclasses to specialize methods or add a new functionality. We may need to add <a id="id59" class="indexterm"/>some feature, which is 80% the same as one in the base class. Then it will be natural to call base class's method for that portion of functionality and add extra functionality in new method in the subclass. To call a method in superclass, we can either use its class name to access the method, or super it like this:</p><div><pre class="programlisting">&gt;&gt;&gt; class GrandParent:
...     def do(self,):
...         print("Grandparent do called")
...
&gt;&gt;&gt; class Father(GrandParent):
...     def do(self,):
...         print("Father do called")
...
&gt;&gt;&gt; class Mother(GrandParent):
...     def do(self,):
...         print("Mother do called")
...
&gt;&gt;&gt; class Child(Father, Mother):
...     def do(self,):
...         print("Child do called")
...
&gt;&gt;&gt; c = Child()
&gt;&gt;&gt; c.do()
Child do called
&gt;&gt;&gt; class Child(Father, Mother):
...     def do(self,):
...         print("Child do called")
...         super().do()
...
&gt;&gt;&gt; c = Child()
&gt;&gt;&gt; c.do()
Child do called
Father do called
&gt;&gt;&gt; print("Father and child super calling")
Father and child super calling
&gt;&gt;&gt; class Father(GrandParent):
...     def do(self,):
...         print("Father do called")
...         super().do()
...
&gt;&gt;&gt; class Child(Father, Mother):
...     def do(self,):
...         print("Child do called")
...         super().do()
...
&gt;&gt;&gt; c = Child()
&gt;&gt;&gt; c.do()
Child do called
Father do called
Mother do called
&gt;&gt;&gt; print("Father and Mother super calling")
Father and Mother super calling
&gt;&gt;&gt; class Mother(GrandParent):
...     def do(self,):
...         print("Mother do called")
...         super().do()
...
&gt;&gt;&gt; class Father(GrandParent):
...     def do(self,):
...         print("Father do called")
...         super().do()
...
&gt;&gt;&gt; class Child(Father, Mother):
...     def do(self,):
...         print("Child do called")
...         super().do()
...
&gt;&gt;&gt; c = Child()
&gt;&gt;&gt; c.do()
Child do called
Father do called
Mother do called
Grandparent do called
&gt;&gt;&gt; print(Child.__mro__)
(&lt;class '__main__.Child'&gt;, &lt;class '__main__.Father'&gt;, &lt;class '__main__.Mother'&gt;, &lt;class '__main__.GrandParent'&gt;, &lt;class 'object'&gt;)</pre></div></div></div>
<div><div><div><div><h1 class="title"><a id="ch02lvl1sec17"/>Using language protocols in classes</h1></div></div></div><p>All objects that <a id="id60" class="indexterm"/>provide a specific functionality have certain methods that facilitate that behavior, for <a id="id61" class="indexterm"/>example, you can create an object of type worker and expect it to have the <code class="literal">submit_work(function, kwargs)</code>, and is <code class="literal">_completed()</code> methods. Now, we can expect all objects that have these methods to be usable as workers in any application portion. Similarly, the Python language has defined some methods that are needed to add a certain functionality to an object. If an object possesses these methods, it has that functionality.</p><p>We will discuss two very import protocols: iteration protocol, and context protocol.</p><div><div><div><div><h2 class="title"><a id="ch02lvl2sec18"/>Iteration protocol</h2></div></div></div><p>For <a id="id62" class="indexterm"/>iteration protocol, objects must possess the <code class="literal">__iter__</code> method. If the object possesses it, we <a id="id63" class="indexterm"/>can use the object anywhere that we use an iterator object. When we are using the iterator object in a <code class="literal">for</code> loop or passing it to the <code class="literal">iter</code> built-in function, we are calling its <code class="literal">__iter__</code> method. This method returns another or the same object that is responsible for maintaining the index during iteration, and this object that is returned from <code class="literal">__iter__</code> must have a <code class="literal">__next__</code> method that provides the next values in sequence and raises <code class="literal">StopIteration</code> on the finish of this sequence. In the following code snippet, the <code class="literal">BooksIterState</code> objects help retain the index that is used for iteration. If the books <code class="literal">__iter__</code> method returned self, then it would be difficult to maintain a state index when the object is accessed from two loops:</p><div><pre class="programlisting">&gt;&gt;&gt; class BooksIterState:
...     def __init__(self, books):
...             self.books = books
...             self.index = 0
...     def __next__(self,):
...             if self.index &gt;= len(self.books._data):
...                     raise StopIteration
...             else:
...                     tmp = self.books._data[self.index]
...                     self.index += 1
...                     return tmp
... 
&gt;&gt;&gt; class Books:
...     def __init__(self, data):
...             self._data = data
...     def __iter__(self,):
...             return BooksIterState(self)
... 
&gt;&gt;&gt; ii = iter(Books(["don quixote","lord of the flies","great expectations"]))
&gt;&gt;&gt; next(ii)
'don quixote'
&gt;&gt;&gt; for i in Books(["don quixote","lord of the flies","great expectations"]):
...     print(i)
... 
don quixote
lord of the flies
great expectations
&gt;&gt;&gt; next(ii)
'lord of the flies'
&gt;&gt;&gt; next(ii)
'great expectations'
&gt;&gt;&gt; next(ii)
Traceback (most recent call last):
  File "&lt;stdin&gt;", line 1, in &lt;module&gt;
  File "&lt;stdin&gt;", line 7, in __next__
StopIteration
&gt;&gt;&gt; </pre></div></div><div><div><div><div><h2 class="title"><a id="ch02lvl2sec19"/>Context manager protocol</h2></div></div></div><p>The objects <a id="id64" class="indexterm"/>providing <a id="id65" class="indexterm"/>context for execution are like try finally statements. If an object has the <code class="literal">__enter__</code> and <code class="literal">__exit__</code> methods, then this object can be used as a replacement of try finally statements. The most common uses are releasing locks and resources, or flushing and closing files. In the following example, we are creating a <code class="literal">Ctx</code> class to serve as context manager:</p><div><pre class="programlisting">&gt;&gt;&gt; class Ctx:
...     def __enter__(*args):
...         print("entering")
...         return "do some work"
...     def __exit__(self, exception_type,
...                  exception_value,
...                  exception_traceback):
...         print("exit")
...         if exception_type is not None:
...             print("error",exception_type)
...         return True
... 
&gt;&gt;&gt; with Ctx() as k:
...     print(k)
...     raise KeyError
... 
entering
do some work
exit
error &lt;class 'KeyError'&gt;</pre></div><p>We can also use the <code class="literal">contextmanager</code> decorator of <code class="literal">contextlib</code> to easily create context managers like the one shown in the following code:</p><div><pre class="programlisting">&gt;&gt;&gt; import contextlib
&gt;&gt;&gt; @contextlib.contextmanager
... def ctx():
...     try:
...         print("start")
...         yield "so some work"
...     except KeyError:
...         print("error")
...     print("done")
... 
&gt;&gt;&gt; with ctx() as k:
...     print(k)
...     raise KeyError
... 
start
so some work
error
done</pre></div><p>There are other <a id="id66" class="indexterm"/>methods <a id="id67" class="indexterm"/>that one should know, such as <code class="literal">__str__</code>, <code class="literal">__add__</code>, <code class="literal">__getitem__</code>, and so on, that define various functionalities of the objects. There is a list of them at the language reference's <code class="literal">datamodel.html</code>. You should at least read it once to get to know <a id="id68" class="indexterm"/>what methods are available. Here is the link: <a class="ulink" href="https://docs.python.org/3/reference/datamodel.html#special-method-names">https://docs.python.org/3/reference/datamodel.html#special-method-names</a>.</p></div></div>
<div><div><div><div><h1 class="title"><a id="ch02lvl1sec18"/>Using abstract classes</h1></div></div></div><p>
<strong>Key 6: Making interfaces for conformity.</strong>
</p><p>Abstract classes <a id="id69" class="indexterm"/>are available via the standard <code class="literal">abc</code> library package. They are useful for the definition of interfaces and common functionality. These abstract classes can implement a portion of the interface and make the rest of the API mandatory for subclasses by defining their methods as abstract. Also, classes can be turned into subclasses of the abstract class by simply registering them. These classes are useful to make a set of classes conform to a single interface. Here is how to use them. Here, worker class defines an interface with two methods, do and <code class="literal">is_busy</code>, which each type of worker must implement. <code class="literal">ApiWorker</code> is the implementation for this interface:</p><div><pre class="programlisting">&gt;&gt;&gt; from abc import ABCMeta, abstractmethod
&gt;&gt;&gt; class Worker(metaclass=ABCMeta):
...     @abstractmethod
...     def do(self, func, args, kwargs):
...         """ work on function """
...     @abstractmethod
...     def is_busy(self,):
...         """ tell if busy """
...
&gt;&gt;&gt; class ApiWorker(Worker):
...     def __init__(self,):
...         self._busy = False
...     def do(self, func, args=[], kwargs={}):
...         self._busy = True
...         res = func(*args, **kwargs)
...         self._busy = False
...         return res
...     def is_busy(self,):
...         return self._busy
...
&gt;&gt;&gt; apiworker = ApiWorker()
&gt;&gt;&gt; print(apiworker.do(lambda x: x + 1, (1,)))
2
&gt;&gt;&gt; print(apiworker.is_busy())
False</pre></div></div>
<div><div><div><div><h1 class="title"><a id="ch02lvl1sec19"/>Summary</h1></div></div></div><p>Now, we have seen how to manipulate namespaces, and to create custom module-loading classes. We can use multiple inheritance to create mixin classes in which each mixin class provides a new functionality to the subclass. Context manager and iterator protocols are very useful constructs to create clean code. We created abstract classes that can help us in setting up API contracts for classes.</p><p>In the next chapter, we will cover the functions and utilities that are available to us from a standard Python installation.</p></div></body></html>