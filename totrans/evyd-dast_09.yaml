- en: 'Chapter 9. Trees: Non-Linear Structures'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第9章 树：非线性结构
- en: '**Tree ** **structures** are essentially collections of nodes, typically including
    constraints that prevent more than one reference to each node, and stipulate that
    no references point to the root node. This structure simulates a hierarchical
    tree-like structure that can be either ordered or unordered based on the value
    contained in each node. Also, nodes can contain either value types or instances
    of objects, depending on the purpose of the tree.'
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: '**树结构**基本上是节点的集合，通常包括防止对每个节点有多个引用的约束，并规定没有引用指向根节点。这种结构模拟了一个层次化的树状结构，可以根据每个节点中包含的值是有序的还是无序的。此外，节点可以包含值类型或对象的实例，具体取决于树的目的。'
- en: Trees are incredibly useful data structures in programming, although their applications
    can be somewhat limited. Even when a structure is in use, you may not always recognize
    their presence since many other data structures are built on top of them. In this
    chapter we are going to examine the tree data structure in detail, and in later
    chapters we will examine other structures that typically use the tree structure
    as a foundation.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 树在编程中是极其有用的数据结构，尽管它们的用途可能有些受限。即使一个结构在使用中，你也可能并不总是意识到它们的存在，因为许多其他数据结构都是建立在它们之上的。在本章中，我们将详细检查树数据结构，并在后续章节中检查其他通常以树结构为基础的结构。
- en: 'In this chapter we will cover the following topics:'
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将涵盖以下主题：
- en: Definition of the tree data structure
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 树数据结构的定义
- en: Tree data structure versus the tree data type
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 树数据结构与树数据类型
- en: Terminology associated with trees
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 与树相关的术语
- en: Common operations
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 常见操作
- en: Creating trees
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 创建树
- en: Recursion
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 递归
- en: Traversal
  id: totrans-10
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 遍历
- en: Tree data structure versus tree data type
  id: totrans-11
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 树数据结构 versus 树数据类型
- en: In fact, there is both a tree data type as well as a tree data structure, and
    the two are quite different. So before we go any further, it is important to make
    a distinction between a tree data structure and a tree data type.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 实际上，既有树数据类型，也有树数据结构，两者相当不同。因此，在我们继续之前，区分树数据结构和树数据类型非常重要。
- en: For starters, a data type is only an arrangement of data without any definition
    of how a collection of that data is to be implemented. On the other hand, a data
    structure is precisely concerned with detailing how to take a particular data
    type and create a usable, concrete implementation of that type.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，数据类型只是数据的排列，没有定义如何实现该数据集合的任何定义。另一方面，数据结构精确地关注如何将特定的数据类型详细说明，以创建该类型的可用、具体实现。
- en: In the case of trees, a tree data type must have a value and some concept of
    children where each of those children is also a tree. A tree data structure is
    a group of nodes that are linked according to the pattern of a tree data type.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 在树的情况下，一个树数据类型必须有一个值以及一些关于子节点的概念，其中每个子节点也是一个树。树数据结构是一组节点，这些节点根据树数据类型的模式相互链接。
- en: 'The two diagrams following show the two types of tree:'
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 下面的两个图表显示了两种类型的树：
- en: 'Ordered Tree:'
  id: totrans-16
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 有序树：
- en: '![Tree data structure versus tree data type](img/00013.jpeg)'
  id: totrans-17
  prefs: []
  type: TYPE_IMG
  zh: '![树数据结构与树数据类型](img/00013.jpeg)'
- en: 'Unordered Tree:'
  id: totrans-18
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 无序树：
- en: '![Tree data structure versus tree data type](img/00014.jpeg)'
  id: totrans-19
  prefs: []
  type: TYPE_IMG
  zh: '![树数据结构与树数据类型](img/00014.jpeg)'
- en: Therefore each node is a tree, with the potential for child nodes that are also
    trees. In this chapter, we will be focusing on the concrete implementation of
    a tree data structure.
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，每个节点都是一个树，具有潜在的孩子节点，这些孩子节点也是树。在本章中，我们将关注树数据结构的具体实现。
- en: Tree terminology
  id: totrans-21
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 树术语
- en: Many of the terms and definitions used in trees are unique to these data structures.
    Therefore, before we can examine tree data structures we need to take the time
    to learn the language.
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 树中使用的许多术语和定义都是这些数据结构特有的。因此，在我们检查树数据结构之前，我们需要花时间学习这种语言。
- en: 'Here are some of the most common and important terms:'
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 这里有一些最常见和最重要的术语：
- en: '**Node**: Any object or value stored in the tree represents a node. In the
    preceding figure, the root and all of its children and descendants are independent
    nodes.'
  id: totrans-24
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**节点**：树中存储的任何对象或值都代表一个节点。在上面的图中，根及其所有子节点和后代都是独立的节点。'
- en: '**Root**: The root is the base node of the tree. Ironically, this node is typically
    depicted at the top of a graphic representation of the tree. Note that a root
    node, even if it has zero descendants, represents an entire tree by itself.'
  id: totrans-25
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**根节点**：根节点是树的基节点。具有讽刺意味的是，这个节点通常在树的图形表示的顶部。请注意，即使根节点没有后代，它本身也代表了一整棵树。'
- en: '**Parent**: A parent node is any node which contains *1...n* child nodes. The
    parent is only the parent in respect to one of its children. Also note that any
    parent node can have *0...n* children depending on the rules associated with the
    tree''s structure.'
  id: totrans-26
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**父节点**：父节点是包含1...n个子节点的任何节点。父节点仅对其子节点中的一个而言是父节点。此外，请注意，任何父节点可以有0...n个子节点，这取决于与树的结构相关的规则。'
- en: '**Child**: Any node other than the root node is a child to one (and only one)
    other node. The root node of any tree that is not a sub-tree of another structure
    is the only node that is not itself a child.'
  id: totrans-27
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**子节点**：任何非根节点都是其他一个（且仅一个）节点的子节点。任何不是其他结构子树的树的根节点是唯一一个不是自身子节点的节点。'
- en: '**Siblings**: Siblings, also referred to as children, represent the collection
    of all of the child nodes to one particular parent. For example, referring to
    the preceding figure, the collection of two nodes below the root represents siblings.'
  id: totrans-28
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**兄弟节点**：兄弟节点，也称为子节点，代表了一个特定父节点的所有子节点集合。例如，参考前面的图，根节点下方的两个节点集合表示兄弟节点。'
- en: '**Leaf**: Any node that has no child nodes is called a leaf.'
  id: totrans-29
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**叶节点**：任何没有子节点的节点被称为叶节点。'
- en: '**Edge**: An edge is the route, or reference, between a parent and child node.'
  id: totrans-30
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**边**：边是父节点与子节点之间的路径或引用。'
- en: '**Descendant**: The descendants of a node are any of the nodes that can be
    reached from that node following edges away from the root node.'
  id: totrans-31
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**后代**：节点的后代是可以通过从该节点沿边远离根节点到达的所有节点。'
- en: '**Ancestor**: The ancestors of a node are any of the nodes that can be reached
    from that node following edges toward the root node.'
  id: totrans-32
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**祖先节点**：节点的祖先是从该节点沿边向根节点到达的所有节点。'
- en: '**Path**: A path is described as a list of edges between a node and one of
    its descendants.'
  id: totrans-33
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**路径**：路径被描述为一组节点与其后代之间的边。'
- en: '**Height of tree**: The height of a tree represents the number of edges between
    the root node and the leaf that is furthest from the root node.'
  id: totrans-34
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**树的高度**：树的高度表示根节点与离根节点最远的叶节点之间的边的数量。'
- en: '**Depth**: The number of edges between that node and the root node represents
    the depth of a node. The root node, therefore, has a depth equal to zero.'
  id: totrans-35
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**深度**：节点与根节点之间的边的数量表示节点的深度。因此，根节点的深度为零。'
- en: Common operations
  id: totrans-36
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 常见操作
- en: Tree data structures can consistent of *1...n* nodes., which means that even
    a single node without a parent or any children is still considered a tree. Therefore,
    many of the common operations associated with trees can be defined in terms of
    a single node, or from the perspective of the same. Here is a list of the most
    common operations associated with trees
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 树数据结构可以由1...n个节点组成，这意味着即使是一个没有父节点或任何子节点的单个节点也被认为是树。因此，许多与树相关的常见操作可以用单个节点或从相同的角度来定义。以下是与树相关最常见的操作列表
- en: '**Data**: The data operation is associated with a single node, and returns
    the object or value contained in that node.'
  id: totrans-38
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**数据**：数据操作与单个节点相关联，并返回该节点中包含的对象或值。'
- en: '**Children**: The children operation returns the collection of siblings associated
    with this parent node.'
  id: totrans-39
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**子节点**：子节点操作返回与该父节点关联的兄弟节点集合。'
- en: '**Parent**: Some tree structures provide a mechanism to "climb" the tree, or
    traverse the structure from any particular node back toward the root.'
  id: totrans-40
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**父节点**：某些树结构提供了一种机制来“爬升”树，或从任何特定节点遍历结构回到根节点。'
- en: '**Enumerate**: An enumeration operation will return a list or some other collection
    containing every descendant of a particular node, including the root node itself.'
  id: totrans-41
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**枚举**：枚举操作将返回一个列表或包含特定节点的所有后代的集合，包括根节点本身。'
- en: '**Insert**: An insert operation allows a new node to be added as a child of
    an existing node in the tree. The insert operation can be somewhat complicated
    when the tree structure has a limit to the number of children that can be associated
    with a particular parent. When the maximum number of children permitted is already
    in place, one of those children must be relocated as a child of the new node being
    inserted.'
  id: totrans-42
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**插入**：插入操作允许将新节点添加到树中现有节点的子节点。当树结构对特定父节点关联的子节点数量有限制时，插入操作可能会变得有些复杂。当允许的最大子节点数量已经就位时，必须将其中一个子节点重新定位为新插入节点的子节点。'
- en: '**Graft**: Graft is a similar operation to insert, except that the node being
    inserted has descendants of its own, meaning it is a multi-layer tree. As with
    the insert operation, graft can be somewhat complicated when the tree structure
    has a limit to the number of children that can be associated with a particular
    parent. When the maximum number of children permitted is already in place, one
    of those children must be logically relocated as a child of a leaf of the new
    tree being inserted.'
  id: totrans-43
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**嫁接**：嫁接操作与插入操作类似，但被插入的节点有自己的后代，这意味着它是一个多层树。与插入操作一样，当树结构对特定父节点关联的子节点数量有限制时，嫁接操作可能会变得有些复杂。当允许的最大子节点数量已经就位时，必须将其中一个子节点逻辑上重新定位为新插入的树的叶子的子节点。'
- en: '**Delete**: The delete operation will remove a specified node from the tree.
    If the node being deleted has descendants, those nodes must be relocated to the
    deleted node''s parent in some fashion, otherwise the operation is classified
    as a prune.'
  id: totrans-44
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**删除**：删除操作将从树中删除指定的节点。如果被删除的节点有后代，这些节点必须以某种方式重新定位到被删除节点的父节点，否则该操作被分类为修剪操作。'
- en: '**Prune**: Prune operations will remove a node and all of its descendants from
    a tree.'
  id: totrans-45
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**修剪**：修剪操作将从树中删除一个节点及其所有后代。'
- en: Instantiating trees
  id: totrans-46
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 树的实例化
- en: Considering how commonly the tree is seen in computer science, it is somewhat
    surprising that *none* of the languages we are discussing provides a simple and
    versatile concrete implementation of the tree structure for general use. Therefore,
    we are going to create implementations of our own.
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 考虑到树在计算机科学中出现的频率，我们讨论的语言中*没有*一种简单且通用的具体实现为通用用途的树结构，这有点令人惊讶。因此，我们将创建我们自己的实现。
- en: Tree structures
  id: totrans-48
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 树结构
- en: Before we begin, we need to detail a few characteristics our tree structure
    will possess. For starters, we are going to create an ordered tree so we are not
    going to allow duplicate values to be added, which will simplify our implementation.
    Also, we are going to restrict each node to two child nodes. Technically this
    means we are defining a binary tree structure, but for now we are going to ignore
    the specific advantages and applications of such a structure and examine that
    definition in more detail later. Next, our structure is going to implement *data*
    and *children* operations by simply exposing the underlying objects contained
    in each node. We will not be implementing the parent operation because we have
    no need to traverse the tree backward at this time.
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们开始之前，我们需要详细说明我们的树结构将具有的一些特性。首先，我们将创建一个有序树，因此我们不会允许添加重复值，这将简化我们的实现。此外，我们将限制每个节点有两个子节点。从技术上讲，这意味着我们正在定义一个二叉树结构，但到目前为止，我们将忽略这种结构的特定优点和应用，稍后我们将更详细地研究这个定义。接下来，我们的结构将通过简单地暴露每个节点中包含的底层对象来实现*数据*和*子节点*操作。我们不会实现父节点操作，因为我们目前没有需要反向遍历树的需求。
- en: The *insert* operation will be implemented as two separate methods supporting
    raw data and an existing node, while the *graft* operation will only support existing
    nodes. Due to our decision not to permit duplicates, the *graft* operation will
    act similarly to a union operation within a set data structure in that the resulting
    tree will only consist of unique values from the two input trees. Each of these
    three operations will return Boolean values indicating whether the operation succeeded.
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: '*插入*操作将作为两个独立的方法实现，支持原始数据和现有节点，而*嫁接*操作将仅支持现有节点。由于我们决定不允许重复，因此*嫁接*操作将类似于在集合数据结构内的并集操作，即结果树将只包含来自两个输入树的唯一值。这三个操作中的每一个都将返回布尔值，指示操作是否成功。'
- en: The *delete* operation will also provide two methods supporting raw data and
    existing nodes, while the *prune* operation will only support existing nodes.
    Each of these three methods will remove the node from the tree and return that
    node to the caller. In this way, the *delete* and *prune* operations will act
    similarly to a *pop* function in a queue or stack.
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: '*删除* 操作也将提供两个支持原始数据和现有节点的方法，而 *修剪* 操作将仅支持现有节点。这三个方法中的每一个都将从树中删除节点并将该节点返回给调用者。这样，*删除*
    和 *修剪* 操作将类似于队列或栈中的 *pop* 函数。'
- en: We will need to implement *search* operations that will return matching nodes
    but will not remove the node from the tree. In this way, the search functions
    will act similarly to a *peek* function in a queue or stack.
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将需要实现 *搜索* 操作，这些操作将返回匹配的节点，但不会从树中删除节点。这样，搜索函数将类似于队列或栈中的 *peek* 函数。
- en: Our *enumerate* operation will be implemented as a recursive function. We will
    examine recursion in more detail later, but for now we'll just implement the method.
    Finally, we will implement some form of *copy* operation.
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的 *enumerate* 操作将实现为一个递归函数。我们将在稍后更详细地探讨递归，但现在我们只需实现这个方法。最后，我们将实现某种形式的 *copy*
    操作。
- en: '**C#**'
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: '**C#**'
- en: 'C# provides enough functionality for us to create a versatile tree data structure
    with surprisingly little code. First we need to build a class to represent the
    nodes of a tree. Here''s what a concrete implementation of a `Node` class might
    look like in C#:'
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: C# 提供了足够的功能，使我们能够用惊人的少量代码创建一个多功能的树数据结构。首先，我们需要构建一个表示树节点的类。以下是一个 `Node` 类的具体实现示例，在
    C# 中可能看起来是这样的：
- en: '[PRE0]'
  id: totrans-56
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: A `Node` represents two basic components including the data contained in the
    node, and a collection of child nodes that are referenced by our node. In our
    implementation we have a public field for our node's data, which in this case
    is an integer. We also have a public field for each of the two child nodes called
    `Left` and `Right`.
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 一个 `Node` 代表两个基本组件，包括节点中包含的数据，以及由我们的节点引用的子节点集合。在我们的实现中，我们有一个公共字段用于我们的节点数据，在这种情况下是一个整数。我们还有一个公共字段用于两个子节点，分别称为
    `Left` 和 `Right`。
- en: '[PRE1]'
  id: totrans-58
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: We have added one additional getter called `Children` that returns a `List<Node>`
    containing any child nodes that exist in this node. This property is not so much
    for convenience as an integral part of our various recursive functions that come
    later.
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 我们添加了一个额外的获取器 `Children`，它返回一个包含此节点中存在的任何子节点的 `List<Node>`。这个属性与其说是为了方便，不如说是我们后面将要到来的各种递归函数的一个组成部分。
- en: '[PRE2]'
  id: totrans-60
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: Our `Node` class defines one custom constructor, which accepts a single parameter
    of type `Int`. This parameter populates our `Data` field as it is the only required
    field in our structure, since child nodes are always optional.
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的 `Node` 类定义了一个自定义构造函数，它接受一个类型为 `Int` 的单个参数。该参数填充我们的 `Data` 字段，因为它是我们结构中唯一的必需字段，因为子节点始终是可选的。
- en: '[PRE3]'
  id: totrans-62
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: Our first two methods support inserting data and inserting nodes. The `InsertData(Int
    data)` method provides our *insert* functionality for raw node data. Therefore,
    this method takes the data point and creates a new `Node` object from it before
    passing that object to the `InsertNode(Node node)` method.
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的前两种方法支持插入数据和插入节点。`InsertData(Int data)` 方法提供了我们用于原始节点数据的 *插入* 功能。因此，此方法在将对象传递给
    `InsertNode(Node node)` 方法之前，会从数据点创建一个新的 `Node` 对象。
- en: The `InsertNode(Node node)` method provides the *Insert* functionality for an
    existing `Node` object. The method first checks whether `node` is `null`, or the
    `Data` value of `node` matches that of the current node. If so, we return `false`,
    which prevents duplicates from being added to our tree. Next we check if the value
    is less than our current node's data value. If so, we first check if the `Left`
    node exists and if not we assign the newly inserted node to that open position.
    Otherwise, this new node must be inserted somewhere below the `Left` node so we
    recursively call `InsertNode(Node node)` on the `Left` node. That recursive call
    will start the process over again, confirming that `Left` does not contain this
    value and so on.
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: '`InsertNode(Node node)` 方法提供了对现有 `Node` 对象的 *插入* 功能。该方法首先检查 `node` 是否为 `null`，或者
    `node` 的 `Data` 值是否与当前节点匹配。如果是这样，我们返回 `false`，这可以防止重复项被添加到我们的树中。接下来，我们检查值是否小于我们当前节点的数据值。如果是这样，我们首先检查
    `Left` 节点是否存在，如果不存在，我们将新插入的节点分配到那个空位。否则，这个新节点必须插入到 `Left` 节点下方，因此我们递归调用 `InsertNode(Node
    node)` 在 `Left` 节点上。那个递归调用将再次开始这个过程，确认 `Left` 不包含此值，依此类推。'
- en: If the value of the inserted `Node` is greater than our current node, the entire
    process repeats but starting with the `Right` node. Eventually, we either find
    the value already exists in our tree, or we find a leaf with an available child
    position that can accept the inserted `Node`. This method has a worst case complexity
    of **O**(*log(n)*).
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 如果插入的 `Node` 的值大于我们当前的节点，整个过程将重复，但开始于 `Right` 节点。最终，我们或者在树中找到已存在的值，或者在叶子节点找到一个可用的子节点位置，可以接受插入的
    `Node`。这种方法的最坏情况复杂度为 **O**(*log(n)*)。
- en: Using this method, we could theoretically merge entire trees together with a
    single call. Unfortunately, `InsertNode(Node node)` will not prevent duplicates
    from being entered into our tree if values existing in our current tree also exist
    as descendants of the inserted node. The *graft* operation is required for this
    functionality.
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 使用此方法，理论上我们可以通过单个调用合并整个树。不幸的是，如果当前树中存在的值也是插入节点的后代，则 `InsertNode(Node node)`
    不会阻止重复值进入我们的树。为此功能，需要执行 *graft* 操作。
- en: '[PRE4]'
  id: totrans-67
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: The `Graft(Node node)` method leverages the existing `InsertNode(Node node)`.
    The method first confirms that `node` is not `null`, and returns `false` if it
    is. Next, the method creates a new `List<Node>` collection by calling `ListTree()`
    on `node`. We will examine `ListTree()` in a moment, but for now know that `ListTree()`
    will return a list containing `node` and every one of its descendants.
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: '`Graft(Node node)` 方法利用现有的 `InsertNode(Node node)` 方法。该方法首先确认 `node` 不是 `null`，如果是，则返回
    `false`。接下来，该方法通过在 `node` 上调用 `ListTree()` 来创建一个新的 `List<Node>` 集合。我们稍后会检查 `ListTree()`，但在此刻，要知道
    `ListTree()` 将返回一个包含 `node` 及其所有后代的列表。'
- en: '[PRE5]'
  id: totrans-69
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: The next two methods support deleting data and deleting nodes. The `RemoveData(Int
    data)` method provides our *delete* functionality for raw node data. Therefore,
    this method takes the data point and creates a new `Node` object from it, before
    passing that object to the `RemoveNode(Node node)` method.
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 下两个方法支持删除数据和删除节点。`RemoveData(Int data)` 方法为我们提供了对原始节点数据的 *删除* 功能。因此，该方法接受数据点，并从中创建一个新的
    `Node` 对象，然后将该对象传递给 `RemoveNode(Node node)` 方法。
- en: The `RemoveNode(Node node)` method provides the *delete* functionality for an
    existing `Node` object. The method first confirms that `node` is not `null`, and
    returns `null` if it is. Otherwise, the method sets up three objects including
    `retNode` which represents the node that will be returned; `modNode` which represents
    the node that will be modified to accommodate the removed node; and `treelist` which
    will be used to reorder the tree when a node is removed.
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: '`RemoveNode(Node node)` 方法为现有的 `Node` 对象提供 *删除* 功能。该方法首先确认 `node` 不是 `null`，如果是，则返回
    `null`。否则，该方法设置三个对象，包括 `retNode`，它表示将要返回的节点；`modNode`，它表示需要修改以容纳被删除节点的节点；以及 `treelist`，当删除节点时将用于重新排序树。'
- en: Following this, the method is broken down into two major components. The first
    searches for a match to the `node` parameter. The first `if` block checks if the
    current node data matches the node. If the node matches, `retNode` is created
    using `this.Data` and `modNode` is set to `this`. Before the execution moves on,
    the method checks if `this` has any children. If not, we have a single node tree
    so our method simply returns `this`. This logic prevents us from trying to completely
    eliminate the tree, which can only be done by another class that instantiates
    the root `Node` object. The next two `if else` blocks check if node matches `Left`
    or `Right`, respectively. In either case, `retNode` is created using the `Data`
    from the matching child, and `modNode` is set to the matching child. If we still
    don't find a match, the method recursively calls `RemoveNode(Node node)` on each
    of the two child nodes. If any of those calls return a `Node` object, that object
    is returned to the caller. When all else fails, our method returns `null`, meaning
    there is no match for `node`.
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 接着，该方法分为两个主要部分。第一个部分搜索与 `node` 参数匹配的内容。第一个 `if` 块检查当前节点数据是否与节点匹配。如果节点匹配，则使用
    `this.Data` 创建 `retNode`，并将 `modNode` 设置为 `this`。在执行继续之前，该方法检查 `this` 是否有任何子节点。如果没有，我们就有一个单节点树，因此我们的方法简单地返回
    `this`。这种逻辑防止我们尝试完全删除树，这只能由另一个实例化根 `Node` 对象的类来完成。接下来的两个 `if else` 块分别检查节点是否匹配
    `Left` 或 `Right`。在任何情况下，都使用匹配子节点的 `Data` 创建 `retNode`，并将 `modNode` 设置为匹配的子节点。如果我们仍然找不到匹配项，该方法将递归地对两个子节点分别调用
    `RemoveNode(Node node)`。如果其中任何调用返回一个 `Node` 对象，则将该对象返回给调用者。如果所有其他方法都失败，我们的方法返回
    `null`，意味着没有找到与 `node` 匹配的内容。
- en: Note
  id: totrans-73
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: Due to how the algorithm is written, the contents of the first `if` block can
    only execute when the root of the tree is being examined. That's because, by the
    time we begin calling the method recursively on the children, we already know
    their `Data` values don't match that of `node`. From this point forward, our method
    is always looking forward to the children for a match. In terms of recursion,
    we refer to the first if statement as the **base case** of our algorithm. We will
    examine recursion in greater detail later in this chapter.
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 由于算法的编写方式，第一个 `if` 块的内容只能在检查树的根时执行。那是因为，当我们开始递归调用子节点的方法时，我们已经知道它们的 `Data` 值与
    `node` 的不匹配。从这一点开始，我们的方法始终在寻找匹配的后代。在递归方面，我们将第一个 `if` 语句称为我们算法的 **基本案例**。我们将在本章的后面部分更详细地探讨递归。
- en: The second component of `RemoveNode(Node node)` reorders the remaining nodes
    so our sorting is not lost in the process of removing node. This component first
    checks whether `Left` is not `null`, meaning there is a branch of nodes to the
    left of this node. If `Left` happens to be `null`, `Right` is checked next. If
    both `Left` and `Right` are `null`, we've gotten off easy as this is a leaf with
    no descendants that need to be reordered.
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: '`RemoveNode(Node node)` 的第二个组件重新排序剩余的节点，以便在删除节点过程中不会丢失排序。该组件首先检查 `Left` 是否不是
    `null`，这意味着此节点左侧有一个节点分支。如果 `Left` 竟然是 `null`，则接下来检查 `Right`。如果 `Left` 和 `Right`
    都为 `null`，那么我们很容易完成，因为这个节点是一个没有后代的叶子节点，不需要重新排序。'
- en: If either `Left` or `Right` has an object, there are descendants that need to
    be addressed. In either case, the block of code moves the `Data` value from the
    child node and assigns it to `modNode.Data`, which if you recall is the node we
    actually want to remove. By moving the data in this fashion we are simultaneously
    deleting the node and moving its child `Data` up to take its place. Following
    this, our method creates a `List<Node>` collection by calling `ListTree()` on
    the child node. This operation returns the child node and every one of its descendants.
    Then the block completes by setting the child to `null`, effectively deleting
    the entire branch.
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 如果 `Left` 或 `Right` 有对象，则需要处理后代。在任何情况下，代码块都会将子节点的 `Data` 值移动到 `modNode.Data`，如果您还记得，这就是我们实际上想要删除的节点。通过这种方式移动数据，我们同时删除了节点并将其子
    `Data` 上移以取代其位置。随后，我们的方法通过在子节点上调用 `ListTree()` 创建一个 `List<Node>` 集合。此操作返回子节点及其所有后代。然后，代码块通过将子节点设置为
    `null` 来完成，从而有效地删除了整个分支。
- en: Finally, the method loops through the `treeList` collection and calls `InsertNode(Node
    node)` with every `Node` in the list. This approach ensures that the data value
    of our child node will not be duplicated in the final tree, plus our final tree
    will be properly ordered before the operation has completed.
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，该方法遍历 `treeList` 集合，并使用列表中的每个 `Node` 调用 `InsertNode(Node node)`。这种方法确保我们的子节点在最终树中的数据值不会重复，并且最终树在操作完成之前将正确排序。
- en: Although many algorithms could perform this reorder, and perhaps more than a
    few of those more efficient than this, for now we just need to make sure that
    our final tree structure still contains every node but the one that was deleted
    and it is properly ordered. That being said, the `RemoveNode(Node node)` method
    has a *painfully* expensive complexity cost of **O**(*n²*).
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管许多算法可以执行此重新排序，也许其中一些比这个更有效，但到目前为止，我们只需要确保我们的最终树结构仍然包含每个节点（除了被删除的节点）并且是正确排序的。换句话说，`RemoveNode(Node
    node)` 方法有一个 *痛苦地* 高复杂度成本为 **O**(*n²*)。
- en: '[PRE6]'
  id: totrans-79
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: The `Prune(Node root)` method operates in a similar fashion to `RemoveNode(Node
    node)`. We start by confirming that `root` is not `null` and returning `null`
    if it is. Next we establish our base case and look for a match in `this`. If our
    root node matches, the method creates a copy of the entire tree named `b`, then
    sets `Left` and `Right` to `null` to delete all descendants of the root before
    returning `b`. As in `RemoveNode(Node node)`, this logic prevents us from trying
    to completely eliminate the tree, which can only be done by another class that
    instantiates the root `Node` object.
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: '`Prune(Node root)` 方法的工作方式与 `RemoveNode(Node node)` 类似。我们首先确认 `root` 不是 `null`，如果是，则返回
    `null`。接下来，我们建立基本案例，并在 `this` 中寻找匹配项。如果根节点匹配，该方法会创建整个树的副本，命名为 `b`，然后将 `Left` 和
    `Right` 设置为 `null` 以删除根的所有后代，然后返回 `b`。与 `RemoveNode(Node node)` 类似，这种逻辑防止我们尝试完全删除树，这只能由另一个实例化根
    `Node` 对象的类来完成。'
- en: If the root node does not match `root`, our method checks `Left` and `Right` and
    finally it recursively checks `Children`. If all else fails, we still return `null`
    denoting that a match could not be found.
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 如果根节点不匹配`root`，我们的方法将检查`Left`和`Right`，最后递归检查`Children`。如果所有其他方法都失败了，我们仍然返回`null`，表示找不到匹配项。
- en: If a match is found in `Left` or `Right`, `matchNode` is set to the matching
    node and that node is later copied to `Node branch`. Finally, `matchNode` is set
    to `null`, which deletes the node and its descendants from the tree, and branch
    is finally returned. This method has a worst case complexity of **O**(*n*).
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 如果在`Left`或`Right`中找到匹配项，`matchNode`将被设置为匹配的节点，该节点随后被复制到`Node branch`。最后，`matchNode`被设置为`null`，这将从树中删除节点及其后代，并最终返回分支。该方法的最坏情况复杂度为**O**(*n*)。
- en: '[PRE7]'
  id: totrans-83
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: Our `Node` class implements *search* functionality using the `FindData(Int data)`
    and `FindNode(Node node)` methods. `FindData(Int data)` allows us to pass in a
    raw `Int` value, which creates a new `Node` object and passes that to `FindNode(Node
    node)`.
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的`Node`类使用`FindData(Int data)`和`FindNode(Node node)`方法实现*搜索*功能。`FindData(Int
    data)`允许我们传入一个原始的`Int`值，这会创建一个新的`Node`对象，并将其传递给`FindNode(Node node)`。
- en: The `FindNode(Node node)` method in turn checks if the search node data matches
    the current node's data. If so, we return `true` because we have a match. Otherwise,
    the method recursively calls `FindNode(Node node)` on each node in the `Children`
    collection until a match is found, or we reach the end of the tree. In that case,
    we return `false` denoting that the data does not exist in the tree. This method
    has a worst case complexity of **O**(*log(n)*).
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: '`FindNode(Node node)`方法反过来检查搜索节点数据是否与当前节点数据匹配。如果是这样，我们返回`true`，因为我们找到了匹配项。否则，该方法将递归地对`Children`集合中的每个节点调用`FindNode(Node
    node)`，直到找到匹配项，或者我们到达树的末尾。在这种情况下，我们返回`false`，表示数据在树中不存在。该方法的最坏情况复杂度为**O**(*log(n)*)。'
- en: '[PRE8]'
  id: totrans-86
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: The `CopyTree()` method duplicates the current node, then sets `Left` and `Right`
    to copies of this using recursive method calls. When the method returns the copied
    node, the copy represents a complete duplicate of the entire tree, branch, or
    node.
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: '`CopyTree()`方法复制当前节点，然后使用递归方法调用将`Left`和`Right`设置为该副本。当方法返回复制的节点时，该副本表示整个树、分支或节点的完整副本。'
- en: '[PRE9]'
  id: totrans-88
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: Finally, we come to the *enumeration* functionality provided by the `ListTree()`
    method. This method simply creates a new `List<Node>` collection, adds a new `Node`
    based on the `Data` in `this` to the collection, then recursively calls `ListTree()`
    on each node in the `Children` collection until we have gathered every node in
    the tree. Finally, the method returns `result` to the caller.
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们来到由`ListTree()`方法提供的*枚举*功能。此方法简单地创建一个新的`List<Node>`集合，根据`this`中的`Data`添加一个新的`Node`到集合中，然后递归地对`Children`集合中的每个节点调用`ListTree()`，直到我们收集到树中的每个节点。最后，该方法将`result`返回给调用者。
- en: Note
  id: totrans-90
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: This simple class represents each of the nodes in our tree. However, you may
    be wondering why a node class implements all of the functionality of a tree data
    structure. If you recall the discussion on terminology, a root node without any
    descendants represents an entire tree. This means any definition of a node must
    necessarily provide all of the functionality of the entire tree, in and of itself.
    Any subsequent implementations of a tree structure will then be built with a single
    `Node` object as its core. This node will have children, which will in turn also
    have children, and so on, thus providing an entire tree structure encapsulated
    within a single field.
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 这个简单的类代表我们树中的每个节点。然而，你可能想知道为什么节点类实现了整个树数据结构的所有功能。如果你还记得关于术语的讨论，没有任何后代的根节点代表一个完整的树。这意味着任何节点的定义都必须必然提供整个树的所有功能，本身就是一个完整的树。任何随后的树结构实现都将使用单个`Node`对象作为其核心。这个节点将有子节点，这些子节点反过来也会有子节点，依此类推，从而在单个字段中封装整个树结构。
- en: '**Java**'
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: '**Java**'
- en: 'Java also provides the basic tools necessary to build a robust implementation
    of our `Node` class with little effort. Here''s an example of what that implementation
    might look like:'
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: Java还提供了构建我们`Node`类健壮实现所需的基本工具，而且几乎不需要付出太多努力。以下是一个该实现可能的样子示例：
- en: '[PRE10]'
  id: totrans-94
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: As with C#, our Java `Node` class includes a public field for our node's data,
    as well as public fields for each of the two child nodes called `Left` and `Right`.
    Our Java `Node` likewise includes a public method called `getChildren()` that
    returns a `LinkedList<Node>` containing any child nodes that exist in this node.
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 与 C# 类似，我们的 Java `Node` 类包括一个用于节点数据的公共字段，以及两个子节点 `Left` 和 `Right` 的公共字段。我们的
    Java `Node` 类同样包括一个名为 `getChildren()` 的公共方法，该方法返回一个包含此节点中存在的任何子节点的 `LinkedList<Node>`。
- en: '[PRE11]'
  id: totrans-96
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: Our `Node` class defines one custom constructor, that accepts a single parameter
    of type `int` which is used to populate the `Data` field.
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的 `Node` 类定义了一个自定义构造函数，它接受一个类型为 `int` 的单个参数，用于填充 `Data` 字段。
- en: '[PRE12]'
  id: totrans-98
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: Our first two methods support inserting data and inserting nodes. The `insertData(int
    data)` method provides our *insert* functionality for raw node data. Therefore,
    this method takes the data point and creates a new `Node` object from it before
    passing that object to the `insertNode(Node node)` method.
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的前两个方法支持插入数据和插入节点。`insertData(int data)` 方法为我们提供了对原始节点数据的 *插入* 功能。因此，此方法接受数据点，并从它创建一个新的
    `Node` 对象，然后再将此对象传递给 `insertNode(Node node)` 方法。
- en: '`insertNode(Node node)` provides the *insert* functionality for an existing
    `Node` object. The method first checks if `node` is `null`, or the `Data` value
    of `node` matches that of the current node. If so, we return `false`, which prevents
    duplicates from being added to our tree. Next we check if the value is less than
    our current node''s data value. If so, we first check if the `Left` node exists
    and if not we assign the newly inserted node to that open position. Otherwise,
    this new node must be inserted somewhere below the `Left` node so we recursively
    call `insertNode(Node node)` on the `Left` node. That recursive call will start
    the process over again, confirming that `Left` does not contain this value and
    so on.'
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: '`insertNode(Node node)` 方法为现有的 `Node` 对象提供了 *插入* 功能。该方法首先检查 `node` 是否为 `null`，或者
    `node` 的 `Data` 值是否与当前节点匹配。如果是这样，我们返回 `false`，这可以防止重复项被添加到我们的树中。接下来，我们检查值是否小于我们当前节点的数据值。如果是这样，我们首先检查
    `Left` 节点是否存在，如果不存在，我们将新插入的节点分配到那个空位。否则，这个新节点必须插入到 `Left` 节点下方某个位置，因此我们在 `Left`
    节点上递归调用 `insertNode(Node node)`。那个递归调用将重新开始这个过程，确认 `Left` 不包含这个值，等等。'
- en: If the value of the inserted `Node` is greater than our current node, the entire
    process repeats using the `Right` node. Eventually, we will determine the value
    already existed in our tree, or we find a leaf with an available child position
    that can accept the inserted `Node`. This method has a worst case complexity of
    **O**(*log(n)*).
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 如果插入的 `Node` 的值大于我们当前节点，整个过程将重复使用 `Right` 节点。最终，我们将确定值已经在我们的树中存在，或者我们找到一个有可用子位置可以接受插入的
    `Node` 的叶子节点。此方法的最坏情况复杂度为 **O**(*log(n)*)。
- en: '[PRE13]'
  id: totrans-102
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: The `graft(Node node)` method leverages the existing `insertNode(Node node)`.
    The method first confirms that `node` is not `null`, and returns `false` if it
    is. Next, the method creates a new `List<Node>` collection by calling `listTree()`
    on `node` which returns a list containing `node` and every one of its descendants.
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: '`graft(Node node)` 方法利用现有的 `insertNode(Node node)`。该方法首先确认 `node` 不是 `null`，如果是，则返回
    `false`。接下来，该方法通过在 `node` 上调用 `listTree()` 创建一个新的 `List<Node>` 集合，该方法返回一个包含 `node`
    和其所有后代的列表。'
- en: '[PRE14]'
  id: totrans-104
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: The next two methods support deleting data and deleting nodes. The `removeData(Int
    data)` method provides our *delete* functionality for raw node data. Therefore,
    this method takes the data point and creates a new `Node` object from it, before
    passing that object to the `removeNode(Node node)` method.
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来的两个方法支持删除数据和删除节点。`removeData(int data)` 方法为我们提供了对原始节点数据的 *删除* 功能。因此，此方法接受数据点，并从它创建一个新的
    `Node` 对象，然后再将此对象传递给 `removeNode(Node node)` 方法。
- en: '`removeNode(Node node)` provides the *delete* functionality for an existing
    `Node` object. The method first confirms that `node` is not `null`, and returns
    `null` if it is. Otherwise, the method sets up three objects including `retNode` which represents
    the node that will be returned; `modNode`, which represents the node that will
    be modified to accommodate the removed node; `treelist`, that will be used to
    reorder the tree when a node is removed.'
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: '`removeNode(Node node)` 方法为现有的 `Node` 对象提供了 *删除* 功能。该方法首先确认 `node` 不是 `null`，如果是，则返回
    `null`。否则，该方法设置三个对象，包括 `retNode`，它表示将要返回的节点；`modNode`，它表示将被修改以适应被删除节点的节点；以及 `treelist`，在删除节点时将用于重新排序树。'
- en: The next block begins by searching for a match to the `node` parameter. The
    first `if` block checks if the current node matches the node. If the node matches,
    `retNode` is created using `this.Data` and `modNode` is set to `this`. Before
    the execution moves on, the method checks if `this` has any children. If not,
    we have a single node tree so our method simply returns `this`. The next two `if
    else` blocks check if node matches `Left` or `Right`, respectively. In both cases,
    `retNode` is created using Data from the matching child, and `modNode` is set
    to the matching child. If we still don't find a match, the method recursively
    calls `removeNode(Node node)` on each of the two child nodes. If any of those
    calls return a `Node` object, that object is returned to the caller. When all
    else fails, our method returns `null` meaning there is no match for `node` in
    our tree.
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 下一个块首先搜索与`node`参数匹配的项。第一个`if`块检查当前节点是否匹配该节点。如果节点匹配，则使用`this.Data`创建`retNode`，并将`modNode`设置为`this`。在执行继续之前，方法会检查`this`是否有任何子节点。如果没有，我们有一个单节点树，因此我们的方法只需返回`this`。接下来的两个`if
    else`块检查节点是否匹配`Left`或`Right`，分别。在这两种情况下，使用匹配子节点的数据创建`retNode`，并将`modNode`设置为匹配的子节点。如果我们仍然找不到匹配项，方法会递归地对两个子节点中的每个调用`removeNode(Node
    node)`。如果其中任何调用返回一个`Node`对象，则将该对象返回给调用者。如果所有其他方法都失败了，我们的方法返回`null`，意味着在我们的树中没有与`node`匹配的节点。
- en: The second block of `removeNode(Node node)` reorders the remaining nodes so
    our sorting is not lost in the process of removing node. This component first
    checks if `Left` is not `null`, meaning there is a branch of nodes to the left
    of this node. If `Left` happens to be `null`, `Right` is checked next. If both
    `Left` and `Right` are `null`, we're done.
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: '`removeNode(Node node)`的第二块代码重新排列剩余的节点，以便在删除节点的过程中不会丢失排序。此组件首先检查`Left`是否不是`null`，这意味着此节点左侧有一个节点分支。如果`Left`恰好是`null`，则接下来检查`Right`。如果`Left`和`Right`都是`null`，则完成。'
- en: If either `Left` or `Right` is not `null`, the method moves the `Data` value
    from the child node and assigns it to `modNode.Data`. Following this, our method
    creates a `List<Node>` collection by calling `listTree()` on the child node. Then
    the block wraps up by setting the child to `null`, effectively deleting the entire
    branch.
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 如果`Left`或`Right`中的任何一个不是`null`，该方法会将`Data`值从子节点移动并分配给`modNode.Data`。随后，我们的方法通过在子节点上调用`listTree()`来创建一个`List<Node>`集合。然后，通过将子节点设置为`null`来结束这个块，从而有效地删除整个分支。
- en: Finally, the method loops through the `treeList` collection and calls `insertNode(Node
    node)` with every `Node` in the list. The `RemoveNode(Node node)` method has a
    cost of **O**(*n²*).
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，该方法遍历`treeList`集合，并对列表中的每个`Node`调用`insertNode(Node node)`。`RemoveNode(Node
    node)`方法的开销为**O**(*n²*)。
- en: '[PRE15]'
  id: totrans-111
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: The `prune(Node root)` method operates in a similar fashion to `removeNode(Node
    node)`. We start by confirming that `root` is not `null` and returning `null`
    if it is. Next we establish our base case and look for a match in `this`. If our
    root node matches, the method creates a copy of the entire tree named `b`, then
    sets `Left` and `Right` to `null` to delete all descendants of the root before
    returning `b`.
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: '`prune(Node root)`方法与`removeNode(Node node)`类似。我们首先确认`root`不是`null`，如果是，则返回`null`。接下来，我们建立我们的基本情况，并在`this`中寻找匹配项。如果我们的根节点匹配，该方法会创建整个树的副本，命名为`b`，然后设置`Left`和`Right`为`null`以删除根节点的所有后代，然后返回`b`。'
- en: If the root node does not match `root`, our method checks `Left` and `Right`,
    and finally it recursively checks `Children`. If all else fails, we return `null`
    since there is no match for `root` in our tree.
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 如果根节点与`root`不匹配，我们的方法会检查`Left`和`Right`，最后递归检查`Children`。如果所有其他方法都失败了，我们返回`null`，因为我们的树中没有与`root`匹配的节点。
- en: If a match is found in `Left` or `Right`, `matchNode` is set to the matching
    node and that node is later copied to `Node branch`. Finally, `matchNode` is set
    to `null`, which deletes the node and its descendants from the tree and branch
    is finally returned. This method has a cost of **O**(*n*).
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 如果在`Left`或`Right`中找到匹配项，`matchNode`会被设置为匹配的节点，然后该节点稍后会被复制到`Node branch`。最后，`matchNode`被设置为`null`，这会从树和分支中删除该节点及其后代，并最终返回分支。此方法的开销为**O**(*n*)。
- en: '[PRE16]'
  id: totrans-115
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: Our `Node` class implements *search* functionality using the `findData(Int data)`
    and `findNode(Node node)` methods. `findData(Int data)` allows us to pass in a
    raw `int` value, which creates a new `Node` object and passes that to `findNode(Node
    node)`.
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的`Node`类使用`findData(Int data)`和`findNode(Node node)`方法实现*搜索*功能。`findData(Int
    data)`允许我们传入一个原始的`int`值，这会创建一个新的`Node`对象并将其传递给`findNode(Node node)`。
- en: 'The `findNode(Node node)` method in turn checks if the search node data matches
    the current node''s data. If so, we return `true` because we have a match. Otherwise,
    the method recursively calls `findNode(Node node)` on each node in the `Children`
    collection until a match is found, or we reach the end of the tree. In that case,
    we return `false`, denoting that the data does not exist in the tree. This method
    has a cost of **O**(*log(n)*):'
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: '`findNode(Node node)` 方法接着检查搜索节点数据是否与当前节点的数据匹配。如果是，我们返回 `true`，因为我们找到了匹配项。否则，该方法将递归地对
    `Children` 集合中的每个节点调用 `findNode(Node node)`，直到找到匹配项，或者我们到达树的末尾。在这种情况下，我们返回 `false`，表示数据不在树中。此方法的开销为
    **O**(*log(n)*):'
- en: '[PRE17]'
  id: totrans-118
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: The `copyTree()` method duplicates the current node, then sets `Left` and `Right`
    to copies of the same using recursive method calls. When the method returns the
    copied node, the copy represents a complete duplicate of the entire tree, branch
    or node.
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: '`copyTree()` 方法首先复制当前节点，然后使用递归方法调用将 `Left` 和 `Right` 设置为相同的副本。当方法返回复制的节点时，该副本表示整个树、分支或节点的完整副本。'
- en: '[PRE18]'
  id: totrans-120
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: Finally, we come to the *enumeration* functionality provided by the `listTree()`
    method. This method simply creates a new `LinkedList<Node>` collection, adds a
    new `Node` to the collection based on the `Data` in `this`, then recursively calls
    `listTree()` on each node in the `Children` collection until we have gathered
    every node in the tree. Finally, the method returns `result` to the caller.
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们来到由 `listTree()` 方法提供的 *枚举* 功能。此方法简单地创建一个新的 `LinkedList<Node>` 集合，根据 `this`
    中的 `Data` 添加一个新的 `Node` 到集合中，然后递归地对 `Children` 集合中的每个节点调用 `listTree()`，直到我们收集到树中的每个节点。最后，方法将
    `result` 返回给调用者。
- en: '**Objective-C**'
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: '**Objective-C**'
- en: 'As with other data structure implementations in Objective-C, we have to think
    a little out-of-the-box to build our Node class. In some ways, Objective-C makes
    our job simpler but that isn''t always the case. Here''s what a Node implementation
    might look like in Objective-C:'
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 与 Objective-C 中的其他数据结构实现一样，我们必须稍微跳出思维定式来构建我们的节点类。在某些方面，Objective-C 使得我们的工作变得更简单，但并不总是如此。以下是一个
    Node 实现可能的样子，在 Objective-C 中：
- en: '[PRE19]'
  id: totrans-124
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: Our `EDSNode` class defines one initializer, which accepts a single parameter
    of type `NSInetger`. This parameter populates our `_data` field as it is the only
    required field in our structure since child nodes are always optional.
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的 `EDSNode` 类定义了一个初始化器，它接受一个类型为 `NSInetger` 的单个参数。该参数填充我们的 `_data` 字段，因为它是我们结构中唯一的必需字段，因为子节点始终是可选的。
- en: '[PRE20]'
  id: totrans-126
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'The `EDSNode` node has three public properties for the data and two child nodes
    `left` and `right`, as well as an array property named `children` representing
    the collection of child nodes:'
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: '`EDSNode` 节点有三个公共属性用于数据，以及两个子节点 `left` 和 `right`，还有一个名为 `children` 的数组属性，表示子节点集合：'
- en: '[PRE21]'
  id: totrans-128
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: Our first two methods support inserting data and inserting nodes. The `insertData:`
    method provides our *insert* functionality for raw node data. Therefore, this
    method takes the data point and creates a new `EDSNode` object from it before
    passing that object to the `insertNode:` method.
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的前两种方法支持插入数据和插入节点。`insertData:` 方法提供了我们用于原始节点数据的 *插入* 功能。因此，此方法在将对象传递给 `insertNode:`
    方法之前，会从数据点创建一个新的 `EDSNode` 对象。
- en: '`insertNode:` provides the *insert* functionality for an existing `EDSNode`
    object. The method first checks if `node` is `nil`, or the `data` value of `node`
    matches that of the current node. If so, we return `NO`. Next we check if the
    value of `data` is less than our current node''s `data` value. If so, we first
    check if the `left` node exists and if not we assign the newly inserted node to
    that available position. Otherwise, this new node must be inserted somewhere below
    the `left` node so we recursively call `insertNode:` on the `left` node. If the
    value of the inserted `EDSNode` is greater than our current node, the entire process
    repeats with the `right` node. Eventually, we either confirm the value already
    exists in our tree, or we find a leaf with an available child position that can
    accept the inserted `EDSNode`. This method has a worst case complexity of **O**(*log(n)*):'
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: '`insertNode:` 为现有的 `EDSNode` 对象提供 *插入* 功能。该方法首先检查 `node` 是否为 `nil`，或者 `node`
    的 `data` 值是否与当前节点的 `data` 值匹配。如果是，我们返回 `NO`。接下来，我们检查 `data` 的值是否小于我们当前节点的 `data`
    值。如果是，我们首先检查 `left` 节点是否存在，如果不存在，我们将新插入的节点分配到该可用位置。否则，这个新节点必须插入到 `left` 节点下方，因此我们递归地对
    `left` 节点调用 `insertNode:`。如果插入的 `EDSNode` 的值大于我们当前节点，整个过程将重复使用 `right` 节点。最终，我们或者在树中确认值已经存在，或者找到一个有可用子位置可以接受插入的
    `EDSNode` 的叶子节点。此方法的最坏情况复杂度为 **O**(*log(n)*):'
- en: '[PRE22]'
  id: totrans-131
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: The `graft:` method leverages the existing `insertNode:`. The method first confirms
    that `node` is not `nil`, and returns `false` if it is. Next, the method creates
    a new `NSArray` collection by calling `listTree` on `node`. We will examine the
    `listTree` method in more detail in a moment, but for now just be aware that this
    method will return a list containing the node object and every one of its descendants.
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: '`graft:` 方法利用现有的 `insertNode:` 方法。该方法首先确认 `node` 不是 `nil`，如果是，则返回 `false`。接下来，该方法通过在
    `node` 上调用 `listTree` 来创建一个新的 `NSArray` 集合。我们将在稍后更详细地检查 `listTree` 方法，但在此刻只需知道该方法将返回一个包含节点对象及其所有后代的列表。'
- en: '[PRE23]'
  id: totrans-133
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: The next two methods support deleting data and deleting nodes. The `removeData:`
    method provides our *delete* functionality for raw node data. Therefore, this
    method takes the data point and creates a new `EDSNode` object from it, before
    passing that object to the `removeNode:` method. The `removeNode:` method provides
    the *delete* functionality for an existing `Node` object. The method first confirms
    that `node` is not `nil`, and returns `nil` if it is. Otherwise, the method sets
    up three objects including `retNode` which represents the node that will be returned; `modNode`
    that represents the node that will be modified to accommodate the removed node,
    and `treelist` which will be used to reorder the tree when a node is removed.
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来的两个方法支持删除数据和删除节点。`removeData:` 方法为我们提供了原始节点数据的 *删除* 功能。因此，该方法接受数据点并从中创建一个新的
    `EDSNode` 对象，然后将该对象传递给 `removeNode:` 方法。`removeNode:` 方法提供了对现有 `Node` 对象的 *删除*
    功能。该方法首先确认 `node` 不是 `nil`，如果是，则返回 `nil`。否则，该方法设置三个对象，包括 `retNode`，它表示将要返回的节点；`modNode`，它表示需要修改以适应被删除节点的节点；以及
    `treelist`，当删除节点时将用于重新排列树。
- en: Following this, the method is broken down into two major components. The first
    searches for a match to the `node` parameter. The first `if` block checks if `self.data`
    matches `node.data`. If the node matches, `retNode` is created using `this.data`
    and `modNode` is set to `this`. Before the execution moves on, the method checks
    if `this` has any children. If not, we have a single node tree so our method simply
    returns `this`. This logic prevents us from trying to completely eliminate the
    tree, which can only be done by another class that instantiates the root `EDSNode`
    object. The next two `if else` blocks check if node matches `left` or `right`,
    respectively. In either case, `retNode` is created using the `data` from the matching
    child, and `modNode` is set to the matching child. If we still don't find a match,
    the method recursively calls `removeNode:` on each of the two child nodes. If
    any of those calls return a `Node` object, that object is returned to the caller.
    When all else fails, our method returns `nil` meaning, there is no match for `node`.
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，该方法分为两个主要组件。第一个组件搜索与 `node` 参数匹配的对象。第一个 `if` 块检查 `self.data` 是否与 `node.data`
    匹配。如果节点匹配，则使用 `this.data` 创建 `retNode`，并将 `modNode` 设置为 `this`。在执行继续之前，该方法检查 `this`
    是否有任何子节点。如果没有，我们有一个单个节点树，因此我们的方法简单地返回 `this`。这个逻辑阻止我们尝试完全删除树，这只能由另一个实例化根 `EDSNode`
    对象的类来完成。接下来的两个 `if else` 块检查节点是否与 `left` 或 `right` 匹配，分别。在任何情况下，都使用匹配子节点的 `data`
    创建 `retNode`，并将 `modNode` 设置为匹配的子节点。如果我们仍然找不到匹配项，则方法递归地对两个子节点中的每个调用 `removeNode:`。如果其中任何调用返回
    `Node` 对象，则将该对象返回给调用者。当所有其他方法都失败时，我们的方法返回 `nil`，这意味着没有找到与 `node` 匹配的对象。
- en: The second half of `removeNode:` reorders the remaining nodes so our sorting
    is not lost in the process of removing node. This component first checks if `left`
    is not `nil`, meaning there is a branch of nodes to the left of this node. If
    `left` happens to be `nil`, `Right` is checked next. If both `left` and `right`
    are `nil`, we are done.
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: '`removeNode:` 方法的后半部分重新排列剩余的节点，以便在移除节点过程中不会丢失排序。这个组件首先检查 `left` 是否不是 `nil`，这意味着在这个节点左侧有一个节点的分支。如果
    `left` 竟然是 `nil`，则接下来检查 `Right`。如果 `left` 和 `right` 都不是 `nil`，则完成。'
- en: 'If either `left` or `right` has an object, our code moves `data` from the child
    node and assigns it to `modNode.data`. Following this, our method creates a `NSArray`
    by calling `listTree` on the child node. The method then sets the child to `nil`,
    effectively deleting the entire branch. Finally, the method loops through the
    `treeList` collection and calls `insertNode:` with every `EDSNode` in the list.
    The `removeNode:` method has a cost of **O**(*n²*):'
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  id: totrans-138
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: The `prune:` method starts by confirming that `root` is not `nil` and returning
    `nil` if it is. Next we establish our base case and look for a match in `this`.
    If our root node matches, the method creates a copy of the entire tree named `b`,
    then sets `left` and `right` to `nil` to delete all descendants of the root before
    returning `b`. If the root node does not match `root`, our method checks `left`
    and `right`, and last it recursively checks `children`. If all else fails, we
    still return `nil` denoting that a match could not be found.
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
- en: 'If a match is found in `left` or `right`, `matchNode` is set to the matching
    node and that node is later copied to `EDSNode branch`. Finally, `matchNode` is
    set to `nil`, which deletes the node and its descendants from the tree, and branch
    is finally returned. This method has a worst-case complexity of **O**(*n*):'
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  id: totrans-141
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: Our `EDSNode` class implements *search* functionality using the `findData:`
    and `findNode:` methods. `findData:` allows us to pass in a raw `NSInteger` value,
    which creates a new `EDSNode` object and passes that to `findNode:`.
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
- en: 'The `findNode:` method in turn checks if the search node data matches the current
    node''s data. If so, we return `YES` because we have a match. Otherwise, the method
    recursively calls `findNode:` on each node in the `children` collection until
    a match is found, or we reach the end of the tree. In that case, we return `NO`
    denoting that the data does not exist in the tree. This method has a worst case
    complexity of **O**(*log(n)*):'
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  id: totrans-144
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: 'The `copyTree` method duplicates the current node, then sets `left` and `right`
    to copies of this using recursive method calls. When the method returns the copied
    node, the copy represents a complete duplicate of the entire tree, branch, or
    node:'
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  id: totrans-146
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: Finally, we come to the *enumeration* functionality, which is provided by the
    `listTree:` method. This method simply creates a new `NSArray` collection, adds
    a new `EDSNode` based on the `data` in `this` to the collection, then recursively
    calls `listTree` on each node in the `children` collection until we have gathered
    every node in the tree. Finally, the method returns `result` to the caller.
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
- en: '**Swift**'
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
- en: 'Our Swift `Node` class is similar in structure and functionality to the C#
    and Java implementations. Here''s what an example of the `Node` class might look
    like in Swift:'
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  id: totrans-150
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: 'Our Swift `Node` has three public properties for the data and two child nodes
    `left` and `right`, as well as an array property named `children` representing
    the collection of child nodes:'
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  id: totrans-152
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: 'Our `EDSNode` class defines one initializer, which accepts a single parameter
    of type `NSInetger`. This parameter populates our `_data` field as it is the only
    required field in our structure since child nodes are always optional:'
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的 `EDSNode` 类定义了一个初始化器，它接受一个类型为 `NSInetger` 的单个参数。该参数填充我们的 `_data` 字段，因为它是我们结构中唯一的必填字段，因为子节点始终是可选的：
- en: '[PRE30]'
  id: totrans-154
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: Our first two methods support inserting data and inserting nodes. The `insertData:`
    method provides our *insert* functionality for raw node data. Therefore, this
    method takes the data point and creates a new `EDSNode` object from it before
    passing that object to the `insertNode:` method.
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的前两个方法支持插入数据和插入节点。`insertData:` 方法为我们提供了原始节点数据的 *插入* 功能。因此，此方法接收数据点，并从它创建一个新的
    `EDSNode` 对象，然后再将其传递给 `insertNode:` 方法。
- en: 'The `insertNode:` method provides the *insert* functionality for an existing
    `EDSNode` object. The method first checks if `node` is `nil`, or the `data` value
    of `node` matches that of the current node. If so, we return `NO`. Next we check
    if the value of `data` is less than our current node''s `data` value. If so, we
    first check if the `left` node exists and if not we assign the newly inserted
    node to that available position. Otherwise, this new node must be inserted somewhere
    below the `left` node so we recursively call `insertNode:` on the `left` node.
    If the value of the inserted `EDSNode` is greater than our current node, the entire
    process repeats with the `right` node. Eventually, we either confirm the value
    already exists in our tree, or we find a leaf with an available child position
    that can accept the inserted `EDSNode`. This method has a worst case complexity
    of **O**(*log(n)*):'
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: '`insertNode:` 方法为现有的 `EDSNode` 对象提供了 *插入* 功能。该方法首先检查 `node` 是否为 `nil`，或者 `node`
    的 `data` 值与当前节点匹配。如果是，我们返回 `NO`。接下来我们检查 `data` 的值是否小于我们当前节点的 `data` 值。如果是，我们首先检查
    `left` 节点是否存在，如果不存在，我们将新插入的节点分配到那个可用位置。否则，这个新节点必须插入到 `left` 节点下方，因此我们递归调用 `insertNode:`
    在 `left` 节点上。如果插入的 `EDSNode` 的值大于我们当前节点的值，整个过程将重复进行 `right` 节点。最终，我们或者在树中确认值已经存在，或者在叶节点找到一个可用的子节点位置，该位置可以接受插入的
    `EDSNode`。此方法的最坏情况复杂度为 **O**(*log(n)*):'
- en: '[PRE31]'
  id: totrans-157
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: 'The `graft:` method functions leverages the existing `insertNode:`. The method
    first confirms that `node` is not `nil`, and returns `false` if it is. Next, the
    method creates a new `NSArray` collection by calling `listTree` on `node`. We
    will examine `listTree` in a moment, but for now know that `listTree` will return
    a list containing `node` and every one of its descendants:'
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: '`graft:` 方法利用现有的 `insertNode:` 方法。该方法首先确认 `node` 不是 `nil`，如果是，则返回 `false`。接下来，该方法通过在
    `node` 上调用 `listTree` 创建一个新的 `NSArray` 集合。我们稍后将检查 `listTree`，但在此刻我们知道 `listTree`
    将返回一个包含 `node` 和其所有后代列表：'
- en: '[PRE32]'
  id: totrans-159
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: The next two methods support deleting data and deleting nodes. The `removeData:`
    method provides our *delete* functionality for raw node data. Therefore, this
    method takes the data point and creates a new `EDSNode` object from it, before
    passing that object to the `removeNode:` method.
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来的两个方法支持删除数据和删除节点。`removeData:` 方法为我们提供了原始节点数据的 *删除* 功能。因此，此方法接收数据点，并从它创建一个新的
    `EDSNode` 对象，然后再将其传递给 `removeNode:` 方法。
- en: The `removeNode:` method provides the *delete* functionality for an existing
    `Node` object. The method first confirms that `node` is not `nil`, and returns
    `nil` if it is. Otherwise, the method sets up three objects including `retNode` which
    represents the node that will be returned; `modNode`, that represents the node
    that will be modified to accommodate the removed node; `treelist`, that will be
    used to reorder the tree when a node is removed.
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: '`removeNode:` 方法为现有的 `Node` 对象提供了 *删除* 功能。该方法首先确认 `node` 不是 `nil`，如果是，则返回 `nil`。否则，该方法设置三个对象，包括
    `retNode`，它表示将要返回的节点；`modNode`，它表示将被修改以容纳被删除节点的节点；`treelist`，当删除节点时将用于重新排序树。'
- en: Following this, the method is broken down into two major components. The first
    searches for a match to the `node` parameter. The first `if` block checks if `self.data`
    matches `node.data`. If the node matches, `retNode` is created using `this.data`
    and `modNode` is set to `this`. Before the execution moves on, the method checks
    if `this` has any children. If not, we have a single node tree so our method simply
    returns `this`. This logic prevents us from trying to completely eliminate the
    tree, which can only be done by another class that instantiates the root `EDSNode`
    object. The next two `if else` blocks check if node matches `left` or `right`,
    respectively. In either case, `retNode` is created using the `data` from the matching
    child, and `modNode` is set to the matching child. If we still don't find a match,
    the method recursively calls `removeNode:` on each of the two child nodes. If
    any of those calls return a `Node` object, that object is returned to the caller.
    When all else fails, our method returns `nil` meaning there is no match for `node`.
    The second half of `removeNode:` reorders the remaining nodes so our sorting is
    not lost in the process of removing node. This component first checks if `left`
    is not `nil`, meaning there is a branch of nodes to the left of this node. If
    `left` happens to be `nil`, `right` is checked next. If both `left` and `right`
    are `nil` we are done.
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 在此之后，该方法被分解为两个主要组件。第一个组件搜索与`node`参数匹配的内容。第一个`if`块检查`self.data`是否与`node.data`匹配。如果节点匹配，则使用`this.data`创建`retNode`，并将`modNode`设置为`this`。在执行继续之前，该方法检查`this`是否有任何子节点。如果没有，我们就有一个单独的节点树，因此我们的方法简单地返回`this`。这个逻辑阻止我们尝试完全消除树，这只能由另一个实例化根`EDSNode`对象的类来完成。接下来的两个`if
    else`块分别检查节点是否匹配`left`或`right`。在任何情况下，都会使用匹配子节点的`data`创建`retNode`，并将`modNode`设置为匹配的子节点。如果我们仍然找不到匹配项，该方法将递归地对两个子节点分别调用`removeNode:`。如果其中任何调用返回`Node`对象，则将该对象返回给调用者。如果所有其他方法都失败，我们的方法返回`nil`，表示没有找到与`node`匹配的内容。`removeNode:`方法的第二部分重新排列剩余的节点，以便在删除节点过程中不会丢失排序。这个组件首先检查`left`是否不是`nil`，这意味着在这个节点左侧有一个节点分支。如果`left`恰好是`nil`，则接下来检查`right`。如果`left`和`right`都是`nil`，则完成。
- en: 'If either `left` or `right` has an object, our code moves `data` from the child
    node and assigns it to `modNode.data`. Following this, our method creates a `NSArray`
    by calling `listTree` on the child node. The method then sets the child to `nil`,
    effectively deleting the entire branch. Finally, the method loops through the
    `treeList` collection and calls `insertNode:` with every `EDSNode` in the list.
    The `removeNode:` method has a cost of **O**(*n²*):'
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 如果`left`或`right`中有一个对象，我们的代码将子节点的`data`移动到`modNode.data`。在此之后，我们的方法通过在子节点上调用`listTree`来创建一个`NSArray`。然后，方法将子节点设置为`nil`，实际上删除了整个分支。最后，方法遍历`treeList`集合，并使用列表中的每个`EDSNode`调用`insertNode:`。`removeNode:`方法的成本为**O**(*n²*)：
- en: '[PRE33]'
  id: totrans-164
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: The `prune:` method starts by confirming that `root` is not `nil` and returning
    `nil` if it is. Next we establish our base case and look for a match in `this`.
    If our root node matches, the method creates a copy of the entire tree named `b`,
    then sets `left` and `right` to `nil` to delete all descendants of the root before
    returning `b`. If the root node does not match `root`, our method checks `left`
    and `right`, and finally it recursively checks `children`. If all else fails,
    we still return `nil` denoting that a match could not be found.
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: '`prune:`方法首先确认`root`不是`nil`，如果是，则返回`nil`。接下来，我们建立基本案例并在`this`中寻找匹配项。如果根节点与`root`匹配，则方法创建整个树的副本，命名为`b`，然后将`left`和`right`设置为`nil`以删除根的所有后代，然后返回`b`。如果根节点不匹配`root`，则方法检查`left`和`right`，最后递归检查`children`。如果所有其他方法都失败，我们仍然返回`nil`，表示找不到匹配项。'
- en: 'If a match is found in `left` or `right`, `matchNode` is set to the matching
    node and that node is later copied to `EDSNode branch`. Finally, `matchNode` is
    set to `nil`, which deletes the node and its descendants from the tree, and branch
    is finally returned. This method has a worst case complexity of **O**(*n*):'
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 如果在`left`或`right`中找到匹配项，则将`matchNode`设置为匹配的节点，并将该节点稍后复制到`EDSNode branch`。最后，将`matchNode`设置为`nil`，这将删除树中的节点及其后代，并最终返回分支。该方法的最坏情况复杂度为**O**(*n*)：
- en: '[PRE34]'
  id: totrans-167
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: Our `EDSNode` class implements *search* functionality using the `findData:`
    and `findNode:` methods. `findData:` allows us to pass in a raw `NSInteger` value,
    which creates a new `EDSNode` object and passes that to `findNode:`. The `findNode:`
    method in turn checks if the search node data matches the current node's data.
    If so, we return `YES` because we have a match. Otherwise, the method recursively
    calls `findNode:` on each node in the `children` collection until a match is found,
    or we reach the end of the tree. In that case, we return `NO` denoting that the
    data does not exist in the tree. This method has a worst case complexity of **O**(*log(n)*).
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的`EDSNode`类使用`findData:`和`findNode:`方法实现了*搜索*功能。`findData:`允许我们传入一个原始的`NSInteger`值，这会创建一个新的`EDSNode`对象并将其传递给`findNode:`。`findNode:`方法随后检查搜索节点数据是否与当前节点的数据匹配。如果是这样，我们返回`YES`，因为我们找到了匹配项。否则，该方法递归地对`children`集合中的每个节点调用`findNode:`，直到找到匹配项，或者我们到达树的末尾。在这种情况下，我们返回`NO`，表示数据在树中不存在。这个方法的最坏情况复杂度为**O**(*log(n)*)。
- en: '[PRE35]'
  id: totrans-169
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: 'The `copyTree` method duplicates the current node, then sets `left` and `right`
    to copies of this using recursive method calls. When the method returns the copied
    node, the copy represents a complete duplicate of the entire tree, branch, or
    node:'
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: '`copyTree`方法通过递归方法调用复制当前节点，然后将`left`和`right`设置为这个节点的副本。当方法返回复制的节点时，这个副本代表整个树、分支或节点的完整副本：'
- en: '[PRE36]'
  id: totrans-171
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: 'Our Swift `Node` class implements the *enumeration* functionality with the
    `listTree:` method. This method simply creates a new `NSArray` collection, adds
    a new `EDSNode` based on the `data` in `this` to the collection, then recursively
    calls `listTree` on each node in the `children` collection until we have gathered
    every node in the tree. Finally, the method returns `result` to the caller:'
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的Swift `Node`类通过`listTree:`方法实现了*枚举*功能。这个方法简单地创建一个新的`NSArray`集合，将基于`this`中的`data`的新`EDSNode`添加到集合中，然后递归地对`children`集合中的每个节点调用`listTree`，直到我们收集到树中的每个节点。最后，该方法将`result`返回给调用者：
- en: '[PRE37]'
  id: totrans-173
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: Finally, since our class implements the `Equatable` protocol, we need to override
    the `==` operator with respect to `Node`. This method allows us to compare data
    tags for our `Node` objects by simply comparing the nodes themselves; this makes
    our resulting code more concise and readable.
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，由于我们的类实现了`Equatable`协议，我们需要针对`Node`重写`==`运算符。这个方法允许我们通过简单地比较节点本身来比较我们的`Node`对象的数据标签；这使得我们的代码更加简洁易读。
- en: Recursion
  id: totrans-175
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 递归
- en: Although many programmers and even computer science students have a difficult
    time understanding recursion, the concept is actually quite simple. Plainly stated,
    recursion is repeatedly performing the same operation by having the method of
    that operation invoke itself. Therefore, any function that calls an instance of
    itself is a **recursive function**. As a matter of fact, if a function `f()` calls
    another function `g()` which in turn may call function `f()` again, this is still
    a recursive function because `f()` eventually calls itself. Recursion is an excellent
    tool for solving complex problems where the solution to the problem is based on
    the solution to smaller examples of the same problem.
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管许多程序员甚至计算机科学学生都难以理解递归，但这个概念实际上非常简单。简单地说，递归是通过让该操作的函数调用自身来重复执行相同的操作。因此，任何调用自身实例的函数都是**递归函数**。实际上，如果一个函数`f()`调用另一个函数`g()`，而`g()`又可能再次调用函数`f()`，这仍然是一个递归函数，因为`f()`最终会调用自身。递归是解决复杂问题的优秀工具，其中问题的解决方案基于相同问题的较小示例的解决方案。
- en: The concept of recursion, or recursive functions, is so powerful that almost
    every modern computer language supports it by providing the ability for a method
    to call itself. However, before you define a recursive function, you should be
    aware any function that calls itself could very easily become an **infinite loop**
    that will crash your application. Any recursive function is useless if there is
    no way to make it stop. To avoid this your algorithm must define a **base case,**
    or a value that marks the end of your processing and allows the recursive function
    to return. Lets examine the quintessential recursion example, the **Fibonacci
    sequence**.
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 递归的概念或递归函数非常强大，以至于几乎每种现代计算机语言都通过提供方法自我调用的能力来支持它。然而，在你定义递归函数之前，你应该意识到任何调用自身的函数很容易变成一个会导致应用程序崩溃的**无限循环**。如果没有任何方法可以使递归函数停止，那么任何递归函数都是无用的。为了避免这种情况，你的算法必须定义一个**基本情况**，或者一个标记处理结束的值，允许递归函数返回。让我们看看经典的递归示例，**斐波那契数列**。
- en: The Fibonacci sequence is a series of integers where each integer in the list
    is the sum of the previous two integers. This definition is easily converted to
    the algorithm *x[n] = x[n-1] + x[n-2]* where n is the value of any integer in
    the list. For example, for the list of integers *[1, 1, 2, 3, 5, 8, 13, 21, 34,
    ..., x[i]]*, where *x[n] = 8, x[n-1] = 5* and *x[n-2] = 3* so *5 + 3 = 8*. Likewise,
    where *n = 21*, *x[n-1] = 13* and *x[n-2] = 8* so *13 + 8 = 21*. This pattern
    is consistent throughout the list of integers where n > 2.
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
- en: 'So we have a repeatable pattern where *n > 2*, but what if *n = 2*? In that
    case *x[n] = 1, x[n-1] = 1* and *x[n-2] = undefined*, which means our algorithm
    breaks down. At n = 1 we run into a similar problem. Therefore, we need to define
    the base case for n = 1 and n = 2, or x[1] and x[2]. In the Fibonacci sequence,
    *x[1] = 1* and *x[2] = 1*. If we were to take this algorithm with the base case
    values, we can create a recursive function to return the list of Fibonacci integers
    for any value of n. In this method we will define two base case values for n =
    0 and n = 1, but when n > 1 our method calls itself and returns the value. Here''s
    one example in C#:'
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE38]'
  id: totrans-180
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: Recursion is a great tool to have under your belt, but don't abuse it! It has
    been my experience that many programmers fall into two categories. On one hand,
    there are programmers who either don't fully understand recursion or simply choose
    to never use it. On the other hand, some programmers try to use it to solve every
    problem, which is only forgivable if you're programming in a language LISP.
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
- en: The truth is, you should use recursion where it is appropriate, and it's appropriate
    when it feels natural. When you are trying to solve a problem where recursion
    fits you will most likely recognize it instinctively. You will either be able
    to distinguish the recursive nature of the problem, or no matter how hard you
    try you will not be able to develop an iterative solution that handles all of
    the base cases.
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
- en: One final consideration for recursive functions is readability. While writing
    your function, keep in mind that other programmers will have to read your work.
    If you find yourself struggling to understand the function minutes after you wrote
    it, imagine how someone who is removed from the problem domain will feel while
    they are reading it. Therefore, review your code carefully to ensure that it is
    as readable and understandable as possible. Your peers will thank you.
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
- en: Traversal
  id: totrans-184
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: There are several ways to traverse the nodes in a tree data structure, but which
    one you choose will be based largely on how the nodes of your tree are implemented.
    For example, our Node class includes references from parents to children, but
    not the reverse. Nor does it provide references to any siblings or cousins of
    the same order, or level, of the tree. Therefore, our traversal pattern is limited
    to stepping through the tree by means of following edges, or references, from
    parents to children. This type of traversal is called **walking the tree**.
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
- en: Our node construction would have also allowed us to examine either child prior
    to examining the parent. If we had structured our search patterns to check the
    left child node, then the right child node, and finally the node itself, we would
    have implemented an *in-order traversal*. If our nodes contained links between
    objects of the same order, we could examine all parents of a particular order
    prior to examining any children. This approach is called a **pre-order walk**.
    If we were to also include links from the child nodes to their respective parents,
    we could perform the inverse operation, whereby we examine all of the children
    of a particular order prior to examining any parents. This approach is called
    a post-order walk. Both of these approaches could be categorized as a **level-order
    walk**, which performs a breadth-first search over the entire tree, checking nodes
    level by level.
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  id: totrans-187
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter we learned about tree data structures, and how they differ from
    tree data types. We took the time to examine the terminology associated with trees
    including a visual representation of tree data structures. Next we evaluated the
    most common operations when working with trees and their complexity cost. Following
    this we created our own simple binary tree data structure class from scratch,
    and discussed how the recursive operations are used to traverse the tree. We examined
    the meaning of recursion and how to write recursive functions of your own using
    the Fibonacci sequence as an example of this process. Finally, we examined the
    various ways that tree data structures can be traversed depending on how the nodes
    in the tree are related to one another.
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
