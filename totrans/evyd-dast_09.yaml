- en: 'Chapter 9. Trees: Non-Linear Structures'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '**Tree ** **structures** are essentially collections of nodes, typically including
    constraints that prevent more than one reference to each node, and stipulate that
    no references point to the root node. This structure simulates a hierarchical
    tree-like structure that can be either ordered or unordered based on the value
    contained in each node. Also, nodes can contain either value types or instances
    of objects, depending on the purpose of the tree.'
  prefs: []
  type: TYPE_NORMAL
- en: Trees are incredibly useful data structures in programming, although their applications
    can be somewhat limited. Even when a structure is in use, you may not always recognize
    their presence since many other data structures are built on top of them. In this
    chapter we are going to examine the tree data structure in detail, and in later
    chapters we will examine other structures that typically use the tree structure
    as a foundation.
  prefs: []
  type: TYPE_NORMAL
- en: 'In this chapter we will cover the following topics:'
  prefs: []
  type: TYPE_NORMAL
- en: Definition of the tree data structure
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Tree data structure versus the tree data type
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Terminology associated with trees
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Common operations
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Creating trees
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Recursion
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Traversal
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Tree data structure versus tree data type
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In fact, there is both a tree data type as well as a tree data structure, and
    the two are quite different. So before we go any further, it is important to make
    a distinction between a tree data structure and a tree data type.
  prefs: []
  type: TYPE_NORMAL
- en: For starters, a data type is only an arrangement of data without any definition
    of how a collection of that data is to be implemented. On the other hand, a data
    structure is precisely concerned with detailing how to take a particular data
    type and create a usable, concrete implementation of that type.
  prefs: []
  type: TYPE_NORMAL
- en: In the case of trees, a tree data type must have a value and some concept of
    children where each of those children is also a tree. A tree data structure is
    a group of nodes that are linked according to the pattern of a tree data type.
  prefs: []
  type: TYPE_NORMAL
- en: 'The two diagrams following show the two types of tree:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Ordered Tree:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '![Tree data structure versus tree data type](img/00013.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: 'Unordered Tree:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '![Tree data structure versus tree data type](img/00014.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: Therefore each node is a tree, with the potential for child nodes that are also
    trees. In this chapter, we will be focusing on the concrete implementation of
    a tree data structure.
  prefs: []
  type: TYPE_NORMAL
- en: Tree terminology
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Many of the terms and definitions used in trees are unique to these data structures.
    Therefore, before we can examine tree data structures we need to take the time
    to learn the language.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here are some of the most common and important terms:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Node**: Any object or value stored in the tree represents a node. In the
    preceding figure, the root and all of its children and descendants are independent
    nodes.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Root**: The root is the base node of the tree. Ironically, this node is typically
    depicted at the top of a graphic representation of the tree. Note that a root
    node, even if it has zero descendants, represents an entire tree by itself.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Parent**: A parent node is any node which contains *1...n* child nodes. The
    parent is only the parent in respect to one of its children. Also note that any
    parent node can have *0...n* children depending on the rules associated with the
    tree''s structure.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Child**: Any node other than the root node is a child to one (and only one)
    other node. The root node of any tree that is not a sub-tree of another structure
    is the only node that is not itself a child.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Siblings**: Siblings, also referred to as children, represent the collection
    of all of the child nodes to one particular parent. For example, referring to
    the preceding figure, the collection of two nodes below the root represents siblings.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Leaf**: Any node that has no child nodes is called a leaf.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Edge**: An edge is the route, or reference, between a parent and child node.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Descendant**: The descendants of a node are any of the nodes that can be
    reached from that node following edges away from the root node.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Ancestor**: The ancestors of a node are any of the nodes that can be reached
    from that node following edges toward the root node.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Path**: A path is described as a list of edges between a node and one of
    its descendants.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Height of tree**: The height of a tree represents the number of edges between
    the root node and the leaf that is furthest from the root node.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Depth**: The number of edges between that node and the root node represents
    the depth of a node. The root node, therefore, has a depth equal to zero.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Common operations
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Tree data structures can consistent of *1...n* nodes., which means that even
    a single node without a parent or any children is still considered a tree. Therefore,
    many of the common operations associated with trees can be defined in terms of
    a single node, or from the perspective of the same. Here is a list of the most
    common operations associated with trees
  prefs: []
  type: TYPE_NORMAL
- en: '**Data**: The data operation is associated with a single node, and returns
    the object or value contained in that node.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Children**: The children operation returns the collection of siblings associated
    with this parent node.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Parent**: Some tree structures provide a mechanism to "climb" the tree, or
    traverse the structure from any particular node back toward the root.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Enumerate**: An enumeration operation will return a list or some other collection
    containing every descendant of a particular node, including the root node itself.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Insert**: An insert operation allows a new node to be added as a child of
    an existing node in the tree. The insert operation can be somewhat complicated
    when the tree structure has a limit to the number of children that can be associated
    with a particular parent. When the maximum number of children permitted is already
    in place, one of those children must be relocated as a child of the new node being
    inserted.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Graft**: Graft is a similar operation to insert, except that the node being
    inserted has descendants of its own, meaning it is a multi-layer tree. As with
    the insert operation, graft can be somewhat complicated when the tree structure
    has a limit to the number of children that can be associated with a particular
    parent. When the maximum number of children permitted is already in place, one
    of those children must be logically relocated as a child of a leaf of the new
    tree being inserted.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Delete**: The delete operation will remove a specified node from the tree.
    If the node being deleted has descendants, those nodes must be relocated to the
    deleted node''s parent in some fashion, otherwise the operation is classified
    as a prune.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Prune**: Prune operations will remove a node and all of its descendants from
    a tree.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Instantiating trees
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Considering how commonly the tree is seen in computer science, it is somewhat
    surprising that *none* of the languages we are discussing provides a simple and
    versatile concrete implementation of the tree structure for general use. Therefore,
    we are going to create implementations of our own.
  prefs: []
  type: TYPE_NORMAL
- en: Tree structures
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Before we begin, we need to detail a few characteristics our tree structure
    will possess. For starters, we are going to create an ordered tree so we are not
    going to allow duplicate values to be added, which will simplify our implementation.
    Also, we are going to restrict each node to two child nodes. Technically this
    means we are defining a binary tree structure, but for now we are going to ignore
    the specific advantages and applications of such a structure and examine that
    definition in more detail later. Next, our structure is going to implement *data*
    and *children* operations by simply exposing the underlying objects contained
    in each node. We will not be implementing the parent operation because we have
    no need to traverse the tree backward at this time.
  prefs: []
  type: TYPE_NORMAL
- en: The *insert* operation will be implemented as two separate methods supporting
    raw data and an existing node, while the *graft* operation will only support existing
    nodes. Due to our decision not to permit duplicates, the *graft* operation will
    act similarly to a union operation within a set data structure in that the resulting
    tree will only consist of unique values from the two input trees. Each of these
    three operations will return Boolean values indicating whether the operation succeeded.
  prefs: []
  type: TYPE_NORMAL
- en: The *delete* operation will also provide two methods supporting raw data and
    existing nodes, while the *prune* operation will only support existing nodes.
    Each of these three methods will remove the node from the tree and return that
    node to the caller. In this way, the *delete* and *prune* operations will act
    similarly to a *pop* function in a queue or stack.
  prefs: []
  type: TYPE_NORMAL
- en: We will need to implement *search* operations that will return matching nodes
    but will not remove the node from the tree. In this way, the search functions
    will act similarly to a *peek* function in a queue or stack.
  prefs: []
  type: TYPE_NORMAL
- en: Our *enumerate* operation will be implemented as a recursive function. We will
    examine recursion in more detail later, but for now we'll just implement the method.
    Finally, we will implement some form of *copy* operation.
  prefs: []
  type: TYPE_NORMAL
- en: '**C#**'
  prefs: []
  type: TYPE_NORMAL
- en: 'C# provides enough functionality for us to create a versatile tree data structure
    with surprisingly little code. First we need to build a class to represent the
    nodes of a tree. Here''s what a concrete implementation of a `Node` class might
    look like in C#:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: A `Node` represents two basic components including the data contained in the
    node, and a collection of child nodes that are referenced by our node. In our
    implementation we have a public field for our node's data, which in this case
    is an integer. We also have a public field for each of the two child nodes called
    `Left` and `Right`.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: We have added one additional getter called `Children` that returns a `List<Node>`
    containing any child nodes that exist in this node. This property is not so much
    for convenience as an integral part of our various recursive functions that come
    later.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: Our `Node` class defines one custom constructor, which accepts a single parameter
    of type `Int`. This parameter populates our `Data` field as it is the only required
    field in our structure, since child nodes are always optional.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: Our first two methods support inserting data and inserting nodes. The `InsertData(Int
    data)` method provides our *insert* functionality for raw node data. Therefore,
    this method takes the data point and creates a new `Node` object from it before
    passing that object to the `InsertNode(Node node)` method.
  prefs: []
  type: TYPE_NORMAL
- en: The `InsertNode(Node node)` method provides the *Insert* functionality for an
    existing `Node` object. The method first checks whether `node` is `null`, or the
    `Data` value of `node` matches that of the current node. If so, we return `false`,
    which prevents duplicates from being added to our tree. Next we check if the value
    is less than our current node's data value. If so, we first check if the `Left`
    node exists and if not we assign the newly inserted node to that open position.
    Otherwise, this new node must be inserted somewhere below the `Left` node so we
    recursively call `InsertNode(Node node)` on the `Left` node. That recursive call
    will start the process over again, confirming that `Left` does not contain this
    value and so on.
  prefs: []
  type: TYPE_NORMAL
- en: If the value of the inserted `Node` is greater than our current node, the entire
    process repeats but starting with the `Right` node. Eventually, we either find
    the value already exists in our tree, or we find a leaf with an available child
    position that can accept the inserted `Node`. This method has a worst case complexity
    of **O**(*log(n)*).
  prefs: []
  type: TYPE_NORMAL
- en: Using this method, we could theoretically merge entire trees together with a
    single call. Unfortunately, `InsertNode(Node node)` will not prevent duplicates
    from being entered into our tree if values existing in our current tree also exist
    as descendants of the inserted node. The *graft* operation is required for this
    functionality.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: The `Graft(Node node)` method leverages the existing `InsertNode(Node node)`.
    The method first confirms that `node` is not `null`, and returns `false` if it
    is. Next, the method creates a new `List<Node>` collection by calling `ListTree()`
    on `node`. We will examine `ListTree()` in a moment, but for now know that `ListTree()`
    will return a list containing `node` and every one of its descendants.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: The next two methods support deleting data and deleting nodes. The `RemoveData(Int
    data)` method provides our *delete* functionality for raw node data. Therefore,
    this method takes the data point and creates a new `Node` object from it, before
    passing that object to the `RemoveNode(Node node)` method.
  prefs: []
  type: TYPE_NORMAL
- en: The `RemoveNode(Node node)` method provides the *delete* functionality for an
    existing `Node` object. The method first confirms that `node` is not `null`, and
    returns `null` if it is. Otherwise, the method sets up three objects including
    `retNode` which represents the node that will be returned; `modNode` which represents
    the node that will be modified to accommodate the removed node; and `treelist` which
    will be used to reorder the tree when a node is removed.
  prefs: []
  type: TYPE_NORMAL
- en: Following this, the method is broken down into two major components. The first
    searches for a match to the `node` parameter. The first `if` block checks if the
    current node data matches the node. If the node matches, `retNode` is created
    using `this.Data` and `modNode` is set to `this`. Before the execution moves on,
    the method checks if `this` has any children. If not, we have a single node tree
    so our method simply returns `this`. This logic prevents us from trying to completely
    eliminate the tree, which can only be done by another class that instantiates
    the root `Node` object. The next two `if else` blocks check if node matches `Left`
    or `Right`, respectively. In either case, `retNode` is created using the `Data`
    from the matching child, and `modNode` is set to the matching child. If we still
    don't find a match, the method recursively calls `RemoveNode(Node node)` on each
    of the two child nodes. If any of those calls return a `Node` object, that object
    is returned to the caller. When all else fails, our method returns `null`, meaning
    there is no match for `node`.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Due to how the algorithm is written, the contents of the first `if` block can
    only execute when the root of the tree is being examined. That's because, by the
    time we begin calling the method recursively on the children, we already know
    their `Data` values don't match that of `node`. From this point forward, our method
    is always looking forward to the children for a match. In terms of recursion,
    we refer to the first if statement as the **base case** of our algorithm. We will
    examine recursion in greater detail later in this chapter.
  prefs: []
  type: TYPE_NORMAL
- en: The second component of `RemoveNode(Node node)` reorders the remaining nodes
    so our sorting is not lost in the process of removing node. This component first
    checks whether `Left` is not `null`, meaning there is a branch of nodes to the
    left of this node. If `Left` happens to be `null`, `Right` is checked next. If
    both `Left` and `Right` are `null`, we've gotten off easy as this is a leaf with
    no descendants that need to be reordered.
  prefs: []
  type: TYPE_NORMAL
- en: If either `Left` or `Right` has an object, there are descendants that need to
    be addressed. In either case, the block of code moves the `Data` value from the
    child node and assigns it to `modNode.Data`, which if you recall is the node we
    actually want to remove. By moving the data in this fashion we are simultaneously
    deleting the node and moving its child `Data` up to take its place. Following
    this, our method creates a `List<Node>` collection by calling `ListTree()` on
    the child node. This operation returns the child node and every one of its descendants.
    Then the block completes by setting the child to `null`, effectively deleting
    the entire branch.
  prefs: []
  type: TYPE_NORMAL
- en: Finally, the method loops through the `treeList` collection and calls `InsertNode(Node
    node)` with every `Node` in the list. This approach ensures that the data value
    of our child node will not be duplicated in the final tree, plus our final tree
    will be properly ordered before the operation has completed.
  prefs: []
  type: TYPE_NORMAL
- en: Although many algorithms could perform this reorder, and perhaps more than a
    few of those more efficient than this, for now we just need to make sure that
    our final tree structure still contains every node but the one that was deleted
    and it is properly ordered. That being said, the `RemoveNode(Node node)` method
    has a *painfully* expensive complexity cost of **O**(*n²*).
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: The `Prune(Node root)` method operates in a similar fashion to `RemoveNode(Node
    node)`. We start by confirming that `root` is not `null` and returning `null`
    if it is. Next we establish our base case and look for a match in `this`. If our
    root node matches, the method creates a copy of the entire tree named `b`, then
    sets `Left` and `Right` to `null` to delete all descendants of the root before
    returning `b`. As in `RemoveNode(Node node)`, this logic prevents us from trying
    to completely eliminate the tree, which can only be done by another class that
    instantiates the root `Node` object.
  prefs: []
  type: TYPE_NORMAL
- en: If the root node does not match `root`, our method checks `Left` and `Right` and
    finally it recursively checks `Children`. If all else fails, we still return `null`
    denoting that a match could not be found.
  prefs: []
  type: TYPE_NORMAL
- en: If a match is found in `Left` or `Right`, `matchNode` is set to the matching
    node and that node is later copied to `Node branch`. Finally, `matchNode` is set
    to `null`, which deletes the node and its descendants from the tree, and branch
    is finally returned. This method has a worst case complexity of **O**(*n*).
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: Our `Node` class implements *search* functionality using the `FindData(Int data)`
    and `FindNode(Node node)` methods. `FindData(Int data)` allows us to pass in a
    raw `Int` value, which creates a new `Node` object and passes that to `FindNode(Node
    node)`.
  prefs: []
  type: TYPE_NORMAL
- en: The `FindNode(Node node)` method in turn checks if the search node data matches
    the current node's data. If so, we return `true` because we have a match. Otherwise,
    the method recursively calls `FindNode(Node node)` on each node in the `Children`
    collection until a match is found, or we reach the end of the tree. In that case,
    we return `false` denoting that the data does not exist in the tree. This method
    has a worst case complexity of **O**(*log(n)*).
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: The `CopyTree()` method duplicates the current node, then sets `Left` and `Right`
    to copies of this using recursive method calls. When the method returns the copied
    node, the copy represents a complete duplicate of the entire tree, branch, or
    node.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: Finally, we come to the *enumeration* functionality provided by the `ListTree()`
    method. This method simply creates a new `List<Node>` collection, adds a new `Node`
    based on the `Data` in `this` to the collection, then recursively calls `ListTree()`
    on each node in the `Children` collection until we have gathered every node in
    the tree. Finally, the method returns `result` to the caller.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: This simple class represents each of the nodes in our tree. However, you may
    be wondering why a node class implements all of the functionality of a tree data
    structure. If you recall the discussion on terminology, a root node without any
    descendants represents an entire tree. This means any definition of a node must
    necessarily provide all of the functionality of the entire tree, in and of itself.
    Any subsequent implementations of a tree structure will then be built with a single
    `Node` object as its core. This node will have children, which will in turn also
    have children, and so on, thus providing an entire tree structure encapsulated
    within a single field.
  prefs: []
  type: TYPE_NORMAL
- en: '**Java**'
  prefs: []
  type: TYPE_NORMAL
- en: 'Java also provides the basic tools necessary to build a robust implementation
    of our `Node` class with little effort. Here''s an example of what that implementation
    might look like:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: As with C#, our Java `Node` class includes a public field for our node's data,
    as well as public fields for each of the two child nodes called `Left` and `Right`.
    Our Java `Node` likewise includes a public method called `getChildren()` that
    returns a `LinkedList<Node>` containing any child nodes that exist in this node.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: Our `Node` class defines one custom constructor, that accepts a single parameter
    of type `int` which is used to populate the `Data` field.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: Our first two methods support inserting data and inserting nodes. The `insertData(int
    data)` method provides our *insert* functionality for raw node data. Therefore,
    this method takes the data point and creates a new `Node` object from it before
    passing that object to the `insertNode(Node node)` method.
  prefs: []
  type: TYPE_NORMAL
- en: '`insertNode(Node node)` provides the *insert* functionality for an existing
    `Node` object. The method first checks if `node` is `null`, or the `Data` value
    of `node` matches that of the current node. If so, we return `false`, which prevents
    duplicates from being added to our tree. Next we check if the value is less than
    our current node''s data value. If so, we first check if the `Left` node exists
    and if not we assign the newly inserted node to that open position. Otherwise,
    this new node must be inserted somewhere below the `Left` node so we recursively
    call `insertNode(Node node)` on the `Left` node. That recursive call will start
    the process over again, confirming that `Left` does not contain this value and
    so on.'
  prefs: []
  type: TYPE_NORMAL
- en: If the value of the inserted `Node` is greater than our current node, the entire
    process repeats using the `Right` node. Eventually, we will determine the value
    already existed in our tree, or we find a leaf with an available child position
    that can accept the inserted `Node`. This method has a worst case complexity of
    **O**(*log(n)*).
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: The `graft(Node node)` method leverages the existing `insertNode(Node node)`.
    The method first confirms that `node` is not `null`, and returns `false` if it
    is. Next, the method creates a new `List<Node>` collection by calling `listTree()`
    on `node` which returns a list containing `node` and every one of its descendants.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: The next two methods support deleting data and deleting nodes. The `removeData(Int
    data)` method provides our *delete* functionality for raw node data. Therefore,
    this method takes the data point and creates a new `Node` object from it, before
    passing that object to the `removeNode(Node node)` method.
  prefs: []
  type: TYPE_NORMAL
- en: '`removeNode(Node node)` provides the *delete* functionality for an existing
    `Node` object. The method first confirms that `node` is not `null`, and returns
    `null` if it is. Otherwise, the method sets up three objects including `retNode` which represents
    the node that will be returned; `modNode`, which represents the node that will
    be modified to accommodate the removed node; `treelist`, that will be used to
    reorder the tree when a node is removed.'
  prefs: []
  type: TYPE_NORMAL
- en: The next block begins by searching for a match to the `node` parameter. The
    first `if` block checks if the current node matches the node. If the node matches,
    `retNode` is created using `this.Data` and `modNode` is set to `this`. Before
    the execution moves on, the method checks if `this` has any children. If not,
    we have a single node tree so our method simply returns `this`. The next two `if
    else` blocks check if node matches `Left` or `Right`, respectively. In both cases,
    `retNode` is created using Data from the matching child, and `modNode` is set
    to the matching child. If we still don't find a match, the method recursively
    calls `removeNode(Node node)` on each of the two child nodes. If any of those
    calls return a `Node` object, that object is returned to the caller. When all
    else fails, our method returns `null` meaning there is no match for `node` in
    our tree.
  prefs: []
  type: TYPE_NORMAL
- en: The second block of `removeNode(Node node)` reorders the remaining nodes so
    our sorting is not lost in the process of removing node. This component first
    checks if `Left` is not `null`, meaning there is a branch of nodes to the left
    of this node. If `Left` happens to be `null`, `Right` is checked next. If both
    `Left` and `Right` are `null`, we're done.
  prefs: []
  type: TYPE_NORMAL
- en: If either `Left` or `Right` is not `null`, the method moves the `Data` value
    from the child node and assigns it to `modNode.Data`. Following this, our method
    creates a `List<Node>` collection by calling `listTree()` on the child node. Then
    the block wraps up by setting the child to `null`, effectively deleting the entire
    branch.
  prefs: []
  type: TYPE_NORMAL
- en: Finally, the method loops through the `treeList` collection and calls `insertNode(Node
    node)` with every `Node` in the list. The `RemoveNode(Node node)` method has a
    cost of **O**(*n²*).
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: The `prune(Node root)` method operates in a similar fashion to `removeNode(Node
    node)`. We start by confirming that `root` is not `null` and returning `null`
    if it is. Next we establish our base case and look for a match in `this`. If our
    root node matches, the method creates a copy of the entire tree named `b`, then
    sets `Left` and `Right` to `null` to delete all descendants of the root before
    returning `b`.
  prefs: []
  type: TYPE_NORMAL
- en: If the root node does not match `root`, our method checks `Left` and `Right`,
    and finally it recursively checks `Children`. If all else fails, we return `null`
    since there is no match for `root` in our tree.
  prefs: []
  type: TYPE_NORMAL
- en: If a match is found in `Left` or `Right`, `matchNode` is set to the matching
    node and that node is later copied to `Node branch`. Finally, `matchNode` is set
    to `null`, which deletes the node and its descendants from the tree and branch
    is finally returned. This method has a cost of **O**(*n*).
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: Our `Node` class implements *search* functionality using the `findData(Int data)`
    and `findNode(Node node)` methods. `findData(Int data)` allows us to pass in a
    raw `int` value, which creates a new `Node` object and passes that to `findNode(Node
    node)`.
  prefs: []
  type: TYPE_NORMAL
- en: 'The `findNode(Node node)` method in turn checks if the search node data matches
    the current node''s data. If so, we return `true` because we have a match. Otherwise,
    the method recursively calls `findNode(Node node)` on each node in the `Children`
    collection until a match is found, or we reach the end of the tree. In that case,
    we return `false`, denoting that the data does not exist in the tree. This method
    has a cost of **O**(*log(n)*):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: The `copyTree()` method duplicates the current node, then sets `Left` and `Right`
    to copies of the same using recursive method calls. When the method returns the
    copied node, the copy represents a complete duplicate of the entire tree, branch
    or node.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: Finally, we come to the *enumeration* functionality provided by the `listTree()`
    method. This method simply creates a new `LinkedList<Node>` collection, adds a
    new `Node` to the collection based on the `Data` in `this`, then recursively calls
    `listTree()` on each node in the `Children` collection until we have gathered
    every node in the tree. Finally, the method returns `result` to the caller.
  prefs: []
  type: TYPE_NORMAL
- en: '**Objective-C**'
  prefs: []
  type: TYPE_NORMAL
- en: 'As with other data structure implementations in Objective-C, we have to think
    a little out-of-the-box to build our Node class. In some ways, Objective-C makes
    our job simpler but that isn''t always the case. Here''s what a Node implementation
    might look like in Objective-C:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: Our `EDSNode` class defines one initializer, which accepts a single parameter
    of type `NSInetger`. This parameter populates our `_data` field as it is the only
    required field in our structure since child nodes are always optional.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: 'The `EDSNode` node has three public properties for the data and two child nodes
    `left` and `right`, as well as an array property named `children` representing
    the collection of child nodes:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: Our first two methods support inserting data and inserting nodes. The `insertData:`
    method provides our *insert* functionality for raw node data. Therefore, this
    method takes the data point and creates a new `EDSNode` object from it before
    passing that object to the `insertNode:` method.
  prefs: []
  type: TYPE_NORMAL
- en: '`insertNode:` provides the *insert* functionality for an existing `EDSNode`
    object. The method first checks if `node` is `nil`, or the `data` value of `node`
    matches that of the current node. If so, we return `NO`. Next we check if the
    value of `data` is less than our current node''s `data` value. If so, we first
    check if the `left` node exists and if not we assign the newly inserted node to
    that available position. Otherwise, this new node must be inserted somewhere below
    the `left` node so we recursively call `insertNode:` on the `left` node. If the
    value of the inserted `EDSNode` is greater than our current node, the entire process
    repeats with the `right` node. Eventually, we either confirm the value already
    exists in our tree, or we find a leaf with an available child position that can
    accept the inserted `EDSNode`. This method has a worst case complexity of **O**(*log(n)*):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: The `graft:` method leverages the existing `insertNode:`. The method first confirms
    that `node` is not `nil`, and returns `false` if it is. Next, the method creates
    a new `NSArray` collection by calling `listTree` on `node`. We will examine the
    `listTree` method in more detail in a moment, but for now just be aware that this
    method will return a list containing the node object and every one of its descendants.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: The next two methods support deleting data and deleting nodes. The `removeData:`
    method provides our *delete* functionality for raw node data. Therefore, this
    method takes the data point and creates a new `EDSNode` object from it, before
    passing that object to the `removeNode:` method. The `removeNode:` method provides
    the *delete* functionality for an existing `Node` object. The method first confirms
    that `node` is not `nil`, and returns `nil` if it is. Otherwise, the method sets
    up three objects including `retNode` which represents the node that will be returned; `modNode`
    that represents the node that will be modified to accommodate the removed node,
    and `treelist` which will be used to reorder the tree when a node is removed.
  prefs: []
  type: TYPE_NORMAL
- en: Following this, the method is broken down into two major components. The first
    searches for a match to the `node` parameter. The first `if` block checks if `self.data`
    matches `node.data`. If the node matches, `retNode` is created using `this.data`
    and `modNode` is set to `this`. Before the execution moves on, the method checks
    if `this` has any children. If not, we have a single node tree so our method simply
    returns `this`. This logic prevents us from trying to completely eliminate the
    tree, which can only be done by another class that instantiates the root `EDSNode`
    object. The next two `if else` blocks check if node matches `left` or `right`,
    respectively. In either case, `retNode` is created using the `data` from the matching
    child, and `modNode` is set to the matching child. If we still don't find a match,
    the method recursively calls `removeNode:` on each of the two child nodes. If
    any of those calls return a `Node` object, that object is returned to the caller.
    When all else fails, our method returns `nil` meaning, there is no match for `node`.
  prefs: []
  type: TYPE_NORMAL
- en: The second half of `removeNode:` reorders the remaining nodes so our sorting
    is not lost in the process of removing node. This component first checks if `left`
    is not `nil`, meaning there is a branch of nodes to the left of this node. If
    `left` happens to be `nil`, `Right` is checked next. If both `left` and `right`
    are `nil`, we are done.
  prefs: []
  type: TYPE_NORMAL
- en: 'If either `left` or `right` has an object, our code moves `data` from the child
    node and assigns it to `modNode.data`. Following this, our method creates a `NSArray`
    by calling `listTree` on the child node. The method then sets the child to `nil`,
    effectively deleting the entire branch. Finally, the method loops through the
    `treeList` collection and calls `insertNode:` with every `EDSNode` in the list.
    The `removeNode:` method has a cost of **O**(*n²*):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: The `prune:` method starts by confirming that `root` is not `nil` and returning
    `nil` if it is. Next we establish our base case and look for a match in `this`.
    If our root node matches, the method creates a copy of the entire tree named `b`,
    then sets `left` and `right` to `nil` to delete all descendants of the root before
    returning `b`. If the root node does not match `root`, our method checks `left`
    and `right`, and last it recursively checks `children`. If all else fails, we
    still return `nil` denoting that a match could not be found.
  prefs: []
  type: TYPE_NORMAL
- en: 'If a match is found in `left` or `right`, `matchNode` is set to the matching
    node and that node is later copied to `EDSNode branch`. Finally, `matchNode` is
    set to `nil`, which deletes the node and its descendants from the tree, and branch
    is finally returned. This method has a worst-case complexity of **O**(*n*):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: Our `EDSNode` class implements *search* functionality using the `findData:`
    and `findNode:` methods. `findData:` allows us to pass in a raw `NSInteger` value,
    which creates a new `EDSNode` object and passes that to `findNode:`.
  prefs: []
  type: TYPE_NORMAL
- en: 'The `findNode:` method in turn checks if the search node data matches the current
    node''s data. If so, we return `YES` because we have a match. Otherwise, the method
    recursively calls `findNode:` on each node in the `children` collection until
    a match is found, or we reach the end of the tree. In that case, we return `NO`
    denoting that the data does not exist in the tree. This method has a worst case
    complexity of **O**(*log(n)*):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: 'The `copyTree` method duplicates the current node, then sets `left` and `right`
    to copies of this using recursive method calls. When the method returns the copied
    node, the copy represents a complete duplicate of the entire tree, branch, or
    node:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: Finally, we come to the *enumeration* functionality, which is provided by the
    `listTree:` method. This method simply creates a new `NSArray` collection, adds
    a new `EDSNode` based on the `data` in `this` to the collection, then recursively
    calls `listTree` on each node in the `children` collection until we have gathered
    every node in the tree. Finally, the method returns `result` to the caller.
  prefs: []
  type: TYPE_NORMAL
- en: '**Swift**'
  prefs: []
  type: TYPE_NORMAL
- en: 'Our Swift `Node` class is similar in structure and functionality to the C#
    and Java implementations. Here''s what an example of the `Node` class might look
    like in Swift:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: 'Our Swift `Node` has three public properties for the data and two child nodes
    `left` and `right`, as well as an array property named `children` representing
    the collection of child nodes:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: 'Our `EDSNode` class defines one initializer, which accepts a single parameter
    of type `NSInetger`. This parameter populates our `_data` field as it is the only
    required field in our structure since child nodes are always optional:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: Our first two methods support inserting data and inserting nodes. The `insertData:`
    method provides our *insert* functionality for raw node data. Therefore, this
    method takes the data point and creates a new `EDSNode` object from it before
    passing that object to the `insertNode:` method.
  prefs: []
  type: TYPE_NORMAL
- en: 'The `insertNode:` method provides the *insert* functionality for an existing
    `EDSNode` object. The method first checks if `node` is `nil`, or the `data` value
    of `node` matches that of the current node. If so, we return `NO`. Next we check
    if the value of `data` is less than our current node''s `data` value. If so, we
    first check if the `left` node exists and if not we assign the newly inserted
    node to that available position. Otherwise, this new node must be inserted somewhere
    below the `left` node so we recursively call `insertNode:` on the `left` node.
    If the value of the inserted `EDSNode` is greater than our current node, the entire
    process repeats with the `right` node. Eventually, we either confirm the value
    already exists in our tree, or we find a leaf with an available child position
    that can accept the inserted `EDSNode`. This method has a worst case complexity
    of **O**(*log(n)*):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: 'The `graft:` method functions leverages the existing `insertNode:`. The method
    first confirms that `node` is not `nil`, and returns `false` if it is. Next, the
    method creates a new `NSArray` collection by calling `listTree` on `node`. We
    will examine `listTree` in a moment, but for now know that `listTree` will return
    a list containing `node` and every one of its descendants:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: The next two methods support deleting data and deleting nodes. The `removeData:`
    method provides our *delete* functionality for raw node data. Therefore, this
    method takes the data point and creates a new `EDSNode` object from it, before
    passing that object to the `removeNode:` method.
  prefs: []
  type: TYPE_NORMAL
- en: The `removeNode:` method provides the *delete* functionality for an existing
    `Node` object. The method first confirms that `node` is not `nil`, and returns
    `nil` if it is. Otherwise, the method sets up three objects including `retNode` which
    represents the node that will be returned; `modNode`, that represents the node
    that will be modified to accommodate the removed node; `treelist`, that will be
    used to reorder the tree when a node is removed.
  prefs: []
  type: TYPE_NORMAL
- en: Following this, the method is broken down into two major components. The first
    searches for a match to the `node` parameter. The first `if` block checks if `self.data`
    matches `node.data`. If the node matches, `retNode` is created using `this.data`
    and `modNode` is set to `this`. Before the execution moves on, the method checks
    if `this` has any children. If not, we have a single node tree so our method simply
    returns `this`. This logic prevents us from trying to completely eliminate the
    tree, which can only be done by another class that instantiates the root `EDSNode`
    object. The next two `if else` blocks check if node matches `left` or `right`,
    respectively. In either case, `retNode` is created using the `data` from the matching
    child, and `modNode` is set to the matching child. If we still don't find a match,
    the method recursively calls `removeNode:` on each of the two child nodes. If
    any of those calls return a `Node` object, that object is returned to the caller.
    When all else fails, our method returns `nil` meaning there is no match for `node`.
    The second half of `removeNode:` reorders the remaining nodes so our sorting is
    not lost in the process of removing node. This component first checks if `left`
    is not `nil`, meaning there is a branch of nodes to the left of this node. If
    `left` happens to be `nil`, `right` is checked next. If both `left` and `right`
    are `nil` we are done.
  prefs: []
  type: TYPE_NORMAL
- en: 'If either `left` or `right` has an object, our code moves `data` from the child
    node and assigns it to `modNode.data`. Following this, our method creates a `NSArray`
    by calling `listTree` on the child node. The method then sets the child to `nil`,
    effectively deleting the entire branch. Finally, the method loops through the
    `treeList` collection and calls `insertNode:` with every `EDSNode` in the list.
    The `removeNode:` method has a cost of **O**(*n²*):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: The `prune:` method starts by confirming that `root` is not `nil` and returning
    `nil` if it is. Next we establish our base case and look for a match in `this`.
    If our root node matches, the method creates a copy of the entire tree named `b`,
    then sets `left` and `right` to `nil` to delete all descendants of the root before
    returning `b`. If the root node does not match `root`, our method checks `left`
    and `right`, and finally it recursively checks `children`. If all else fails,
    we still return `nil` denoting that a match could not be found.
  prefs: []
  type: TYPE_NORMAL
- en: 'If a match is found in `left` or `right`, `matchNode` is set to the matching
    node and that node is later copied to `EDSNode branch`. Finally, `matchNode` is
    set to `nil`, which deletes the node and its descendants from the tree, and branch
    is finally returned. This method has a worst case complexity of **O**(*n*):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs: []
  type: TYPE_PRE
- en: Our `EDSNode` class implements *search* functionality using the `findData:`
    and `findNode:` methods. `findData:` allows us to pass in a raw `NSInteger` value,
    which creates a new `EDSNode` object and passes that to `findNode:`. The `findNode:`
    method in turn checks if the search node data matches the current node's data.
    If so, we return `YES` because we have a match. Otherwise, the method recursively
    calls `findNode:` on each node in the `children` collection until a match is found,
    or we reach the end of the tree. In that case, we return `NO` denoting that the
    data does not exist in the tree. This method has a worst case complexity of **O**(*log(n)*).
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs: []
  type: TYPE_PRE
- en: 'The `copyTree` method duplicates the current node, then sets `left` and `right`
    to copies of this using recursive method calls. When the method returns the copied
    node, the copy represents a complete duplicate of the entire tree, branch, or
    node:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs: []
  type: TYPE_PRE
- en: 'Our Swift `Node` class implements the *enumeration* functionality with the
    `listTree:` method. This method simply creates a new `NSArray` collection, adds
    a new `EDSNode` based on the `data` in `this` to the collection, then recursively
    calls `listTree` on each node in the `children` collection until we have gathered
    every node in the tree. Finally, the method returns `result` to the caller:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE37]'
  prefs: []
  type: TYPE_PRE
- en: Finally, since our class implements the `Equatable` protocol, we need to override
    the `==` operator with respect to `Node`. This method allows us to compare data
    tags for our `Node` objects by simply comparing the nodes themselves; this makes
    our resulting code more concise and readable.
  prefs: []
  type: TYPE_NORMAL
- en: Recursion
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Although many programmers and even computer science students have a difficult
    time understanding recursion, the concept is actually quite simple. Plainly stated,
    recursion is repeatedly performing the same operation by having the method of
    that operation invoke itself. Therefore, any function that calls an instance of
    itself is a **recursive function**. As a matter of fact, if a function `f()` calls
    another function `g()` which in turn may call function `f()` again, this is still
    a recursive function because `f()` eventually calls itself. Recursion is an excellent
    tool for solving complex problems where the solution to the problem is based on
    the solution to smaller examples of the same problem.
  prefs: []
  type: TYPE_NORMAL
- en: The concept of recursion, or recursive functions, is so powerful that almost
    every modern computer language supports it by providing the ability for a method
    to call itself. However, before you define a recursive function, you should be
    aware any function that calls itself could very easily become an **infinite loop**
    that will crash your application. Any recursive function is useless if there is
    no way to make it stop. To avoid this your algorithm must define a **base case,**
    or a value that marks the end of your processing and allows the recursive function
    to return. Lets examine the quintessential recursion example, the **Fibonacci
    sequence**.
  prefs: []
  type: TYPE_NORMAL
- en: The Fibonacci sequence is a series of integers where each integer in the list
    is the sum of the previous two integers. This definition is easily converted to
    the algorithm *x[n] = x[n-1] + x[n-2]* where n is the value of any integer in
    the list. For example, for the list of integers *[1, 1, 2, 3, 5, 8, 13, 21, 34,
    ..., x[i]]*, where *x[n] = 8, x[n-1] = 5* and *x[n-2] = 3* so *5 + 3 = 8*. Likewise,
    where *n = 21*, *x[n-1] = 13* and *x[n-2] = 8* so *13 + 8 = 21*. This pattern
    is consistent throughout the list of integers where n > 2.
  prefs: []
  type: TYPE_NORMAL
- en: 'So we have a repeatable pattern where *n > 2*, but what if *n = 2*? In that
    case *x[n] = 1, x[n-1] = 1* and *x[n-2] = undefined*, which means our algorithm
    breaks down. At n = 1 we run into a similar problem. Therefore, we need to define
    the base case for n = 1 and n = 2, or x[1] and x[2]. In the Fibonacci sequence,
    *x[1] = 1* and *x[2] = 1*. If we were to take this algorithm with the base case
    values, we can create a recursive function to return the list of Fibonacci integers
    for any value of n. In this method we will define two base case values for n =
    0 and n = 1, but when n > 1 our method calls itself and returns the value. Here''s
    one example in C#:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE38]'
  prefs: []
  type: TYPE_PRE
- en: Recursion is a great tool to have under your belt, but don't abuse it! It has
    been my experience that many programmers fall into two categories. On one hand,
    there are programmers who either don't fully understand recursion or simply choose
    to never use it. On the other hand, some programmers try to use it to solve every
    problem, which is only forgivable if you're programming in a language LISP.
  prefs: []
  type: TYPE_NORMAL
- en: The truth is, you should use recursion where it is appropriate, and it's appropriate
    when it feels natural. When you are trying to solve a problem where recursion
    fits you will most likely recognize it instinctively. You will either be able
    to distinguish the recursive nature of the problem, or no matter how hard you
    try you will not be able to develop an iterative solution that handles all of
    the base cases.
  prefs: []
  type: TYPE_NORMAL
- en: One final consideration for recursive functions is readability. While writing
    your function, keep in mind that other programmers will have to read your work.
    If you find yourself struggling to understand the function minutes after you wrote
    it, imagine how someone who is removed from the problem domain will feel while
    they are reading it. Therefore, review your code carefully to ensure that it is
    as readable and understandable as possible. Your peers will thank you.
  prefs: []
  type: TYPE_NORMAL
- en: Traversal
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: There are several ways to traverse the nodes in a tree data structure, but which
    one you choose will be based largely on how the nodes of your tree are implemented.
    For example, our Node class includes references from parents to children, but
    not the reverse. Nor does it provide references to any siblings or cousins of
    the same order, or level, of the tree. Therefore, our traversal pattern is limited
    to stepping through the tree by means of following edges, or references, from
    parents to children. This type of traversal is called **walking the tree**.
  prefs: []
  type: TYPE_NORMAL
- en: Our node construction would have also allowed us to examine either child prior
    to examining the parent. If we had structured our search patterns to check the
    left child node, then the right child node, and finally the node itself, we would
    have implemented an *in-order traversal*. If our nodes contained links between
    objects of the same order, we could examine all parents of a particular order
    prior to examining any children. This approach is called a **pre-order walk**.
    If we were to also include links from the child nodes to their respective parents,
    we could perform the inverse operation, whereby we examine all of the children
    of a particular order prior to examining any parents. This approach is called
    a post-order walk. Both of these approaches could be categorized as a **level-order
    walk**, which performs a breadth-first search over the entire tree, checking nodes
    level by level.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter we learned about tree data structures, and how they differ from
    tree data types. We took the time to examine the terminology associated with trees
    including a visual representation of tree data structures. Next we evaluated the
    most common operations when working with trees and their complexity cost. Following
    this we created our own simple binary tree data structure class from scratch,
    and discussed how the recursive operations are used to traverse the tree. We examined
    the meaning of recursion and how to write recursive functions of your own using
    the Fibonacci sequence as an example of this process. Finally, we examined the
    various ways that tree data structures can be traversed depending on how the nodes
    in the tree are related to one another.
  prefs: []
  type: TYPE_NORMAL
