<html><head></head><body><div id="sbo-rt-content"><div id="_idContainer284">&#13;&#13;
    <h1 class="chapterNumber"><span class="python">6</span></h1>&#13;&#13;
    <h1 id="_idParaDest-112" class="chapterTitle"><span class="python">Web Server Structures</span></h1>&#13;&#13;
    <p class="normal"><span class="python">Web servers are the most common servers for remote access at the moment. Web services based on HTTP are flexible and powerful.</span></p>&#13;&#13;
    <p class="normal"><span class="python">In this chapter, we will see how web servers are structured, starting by describing how the basic request-response architecture works, and then diving into a LAMP-style architecture in three layers: the web server itself, the workers executing the code, and an intermediate layer that controls those workers and presents a standardized connection to the web server.</span></p>&#13;&#13;
    <p class="normal"><span class="python">We will describe each layer in detail, presenting a specific tool, such as nginx for the web server, uWSGI for the intermediate layer, and the Python Django framework for the specific code inside the worker. We will describe each of them in detail.</span></p>&#13;&#13;
    <p class="normal"><span class="python">We will also include the Django REST framework, as it's a tool that builds on top of Django to generate RESTful API interfaces.</span></p>&#13;&#13;
    <p class="normal"><span class="python">Finally, we will describe how extra layers can be added on top for greater flexibility, scalability, and performance.</span></p>&#13;&#13;
    <p class="normal"><span class="python">In this chapter, we'll cover the following topics:</span></p>&#13;&#13;
    <ul>&#13;&#13;
      <li class="bullet"><span class="python">Request-response</span></li>&#13;&#13;
      <li class="bullet"><span class="python">Web architecture</span></li>&#13;&#13;
      <li class="bullet"><span class="python">Web servers</span></li>&#13;&#13;
      <li class="bullet"><span class="python">uWSGI</span></li>&#13;&#13;
      <li class="bullet"><span class="python">Python workers</span></li>&#13;&#13;
      <li class="bullet"><span class="python">External layers</span></li>&#13;&#13;
    </ul>&#13;&#13;
    <p class="normal"><span class="python">Let's start by describing the basis of the request-response architecture.</span></p>&#13;&#13;
    <h1 id="_idParaDest-113" class="title"><span class="python">Request-response</span></h1>&#13;&#13;
    <p class="normal"><span class="python">The classical server architecture is heavily based on request-response to communicate. A client sends </span><span class="python"><a id="_idIndexMarker376"/></span><span class="python">a request to a remote server and the server processes it and returns a response.</span></p>&#13;&#13;
    <p class="normal"><span class="python">This communication pattern has been prevalent since the era of mainframes and works in an analog manner as software communicates internally with a library, but over a network. The software calls a library and receives a response from it. </span></p>&#13;&#13;
    <p class="normal"><span class="python">An important element is the time delay between the sending of the request and the reception of the response. Internally, it is rare that a call takes more than a couple of milliseconds, but for a network, it may be measured in hundreds of milliseconds and seconds, very commonly.</span></p>&#13;&#13;
    <div class="note">&#13;&#13;
      <p class="Information-Box--PACKT-"><span class="python">Network calls are very dependent on where the server is located. A call within the same data center will be fast, perhaps taking less than 100 milliseconds, while a connection to an external API will likely take close to a second or more.</span></p>&#13;&#13;
    </div>&#13;&#13;
    <p class="normal"><span class="python">Times will also be highly variable, as the network conditions may affect them greatly. This time difference makes it important to handle it properly.</span></p>&#13;&#13;
    <p class="normal"><span class="python">The usual strategy when making requests is to make them synchronously. That means that the code stops and waits until the response is ready. This is convenient, as the code will be simple, but it's also inefficient, as the computer will be not doing anything while the server is calculating the response and it's being transferred through the network.</span></p>&#13;&#13;
    <div class="note">&#13;&#13;
      <p class="Information-Box--PACKT-"><span class="python">The client can be improved to perform multiple requests at the same time. This can be done when the requests are independent of each other, allowing it to make them in parallel. An easy way to achieve this is to use a multithreaded system to perform them, so they can speed up the process. </span></p>&#13;&#13;
      <p class="Information-Box--PACKT-"><span class="python">Typically, a flow will be required, with some requests that can be performed in parallel and others that require waiting until information is received. For example, a common request to retrieve a web page will make one request to retrieve the page and later will download multiple files referenced (e.g. header files, images) in parallel.</span></p>&#13;&#13;
      <p class="Information-Box--PACKT-"><span class="python">We will see later in the chapter how this effect can be designed to increase the responsiveness of web pages.</span></p>&#13;&#13;
    </div>&#13;&#13;
    <p class="normal"><span class="python">The fact that the network is more unreliable than a local call, requires better error handling that understands this fact. Any request-response system should take extra care about capturing different errors, and retry, as network problems typically are transient, and can be recovered if retried after waiting.</span></p>&#13;&#13;
    <div class="note">&#13;&#13;
      <p class="Information-Box--PACKT-"><span class="python">As we saw in </span><em class="chapterRef">Chapter 2</em>, <em class="italic">API Design</em> the multiple status codes from HTTP can give detailed information. </p>&#13;&#13;
    </div>&#13;&#13;
    <p class="normal">Another characteristic of the request-response pattern is that a server cannot call the client proactively, only return information. This simplifies the communication, as it's not entirely bidirectional. The client is required to initiate the request, and the server only needs to listen for new requests coming. This also makes both roles asymmetrical and requires the client to know where the server is, usually by its DNS address and the port to access (by default, port 80 for HTTP and 443 for HTTPS).</p>&#13;&#13;
    <p class="normal">This characteristic <a id="_idIndexMarker377"/>makes some communication patterns difficult to achieve. For example, full bidirectional communication, where two parts want to initiate the sending of messages, is difficult to achieve with request-response.</p>&#13;&#13;
    <p class="normal">A crude example of this is a message server implemented only in request-response. Two clients require the usage of an intermediate server. </p>&#13;&#13;
    <div class="note">&#13;&#13;
      <p class="Information-Box--PACKT-">This basic structure is common in applications like forums or social networks that allow the users to have some sort of direct messaging between users.</p>&#13;&#13;
    </div>&#13;&#13;
    <p class="normal">Each user can perform two actions:</p>&#13;&#13;
    <ul>&#13;&#13;
      <li class="bullet">Request any new message addressed to them</li>&#13;&#13;
      <li class="bullet">Send a new message to another user</li>&#13;&#13;
    </ul>&#13;&#13;
    <p class="normal">A user needs to check periodically whether there are new messages available through polling. This is inefficient, as it's likely that for any new message there'll be a significant number of checks that return "no new messages available." Even worse, there could be a significant delay before noticing that a new message is available if the checks are not performed often enough.</p>&#13;&#13;
    <div class="note">&#13;&#13;
      <p class="Information-Box--PACKT-">In real applications, normally this polling is avoided by sending a notification in a way that's proactive towards the client. For example, mobile OSes have a system to deliver notifications, enabling the server to send a notification through an external API provided by the OS to notify the user of a new message. An older alternative is to send an email with the same goal.</p>&#13;&#13;
      <p class="Information-Box--PACKT-">There are other alternatives, of course. There are P2P alternatives, where two clients can connect to each other, and there are connections with a server through websockets that can remain open, allowing the server to notify the user of new information. They both deviate from the request-response architecture.</p>&#13;&#13;
    </div>&#13;&#13;
    <p class="normal">Even with these limitations, request-response architecture is the basis of web services and has been <a id="_idIndexMarker378"/>proven to be very reliable over the decades. The possibility of having a central server that controls communication and can take a passive role in accepting new requests makes the architecture simple to implement and quick to evolve, and simplifies the client's work. The centralized aspect allows a lot of control.</p>&#13;&#13;
    <h1 id="_idParaDest-114" class="title">Web architecture</h1>&#13;&#13;
    <p class="normal">We introduced in the introduction of the chapter the LAMP architecture, which is the base for <a id="_idIndexMarker379"/>the web server architecture:</p>&#13;&#13;
    <figure class="mediaobject"><img src="Images/B17580_06_01.png" alt="Diagram&#13;&#10;&#13;&#10;Description automatically generated" width="826" height="238"/></figure>&#13;&#13;
    <p class="packt_figref">Figure 6.1: The LAMP architecture</p>&#13;&#13;
    <p class="normal">The LAMP architecture is more general, but we will take a closer look at the web server and web worker. We will use specific tools, based on the Python ecosystem, but we will discuss possible alternatives.</p>&#13;&#13;
    <figure class="mediaobject"><img src="Images/B17580_06_02.png" alt="Diagram&#13;&#10;&#13;&#10;Description automatically generated" width="826" height="210"/></figure>&#13;&#13;
    <p class="packt_figref">Figure 6.2: More detailed architecture in a Python environment</p>&#13;&#13;
    <p class="normal">From the point <a id="_idIndexMarker380"/>of view of an incoming request, a web request accesses the different elements.</p>&#13;&#13;
    <h1 id="_idParaDest-115" class="title">Web servers</h1>&#13;&#13;
    <p class="normal">The<strong class="keyword"> web server</strong> exposes the HTTP port, accepts incoming connections, and redirects them towards <a id="_idIndexMarker381"/>the backend. One common option is nginx (<a href="https://www.nginx.com/"><span class="url">https://www.nginx.com/</span></a>). Another <a id="_idIndexMarker382"/>common option is Apache (<a href="https://httpd.apache.org/"><span class="url">https://httpd.apache.org/</span></a>). The web <a id="_idIndexMarker383"/>server can directly serve a request, for example, by directly returning static files, permanent redirects, or similar simple requests. If the request requires more computation, it will be directed towards the backend, acting as a reverse proxy.</p>&#13;&#13;
    <p class="normal">The primary objective of the web server in the presented architecture is to work as a reverse proxy, accepting HTTP requests, stabilizing the input of data, and queuing the incoming requests. </p>&#13;&#13;
    <p class="normal">A basic configuration for nginx could look like this. The code is available on GitHub at <a href="https://github.com/PacktPublishing/Python-Architecture-Patterns/blob/main/chapter_06_web_server/nginx_example.conf"><span class="url">https://github.com/PacktPublishing/Python-Architecture-Patterns/blob/main/chapter_06_web_server/nginx_example.conf</span></a>.</p>&#13;&#13;
    <pre class="programlisting code"><code class="hljs-code"><span class="hljs-section">server</span> {&#13;&#13;
    <span class="hljs-attribute">listen</span> <span class="hljs-number">80</span> default_server;&#13;&#13;
    <span class="hljs-attribute">listen</span> [::]:<span class="hljs-number">80</span> default_server;&#13;&#13;
    <span class="hljs-attribute">error_log</span> /dev/stdout;&#13;&#13;
    <span class="hljs-attribute">access_log</span> /dev/stdout;&#13;&#13;
       <span class="hljs-attribute">root</span> /opt/;&#13;&#13;
    <span class="hljs-attribute">location</span> /static/ {&#13;&#13;
        <span class="hljs-attribute">autoindex</span> <span class="hljs-literal">on</span>;&#13;&#13;
        <span class="hljs-attribute">try_files</span> $uri $uri/ =<span class="hljs-number">404</span>;&#13;&#13;
    }&#13;&#13;
    <span class="hljs-attribute">location</span> / {&#13;&#13;
        <span class="hljs-attribute">proxy_set_header</span> Host $host;&#13;&#13;
        <span class="hljs-attribute">proxy_set_header</span> X-Real-IP $remote_addr;&#13;&#13;
         <span class="hljs-attribute">uwsgi_pass</span> unix:///tmp/uwsgi.sock;&#13;&#13;
         <span class="hljs-attribute">include</span> uwsgi_params;&#13;&#13;
    }&#13;&#13;
}&#13;&#13;
</code></pre>&#13;&#13;
    <p class="normal">The directive <code class="Code-In-Text--PACKT-">server</code> opens <a id="_idIndexMarker384"/>and closes the basic block to define how to serve the data. Note each line ends with a semicolon.</p>&#13;&#13;
    <div class="note">&#13;&#13;
      <p class="Information-Box--PACKT-">In nginx parlance, each server directive defines a virtual server. Normally there will be only one, but multiple can be configured, for example, to define different behaviors based on the DNS addressed.</p>&#13;&#13;
    </div>&#13;&#13;
    <p class="normal">Inside, we have a basic configuration on what port to serve – in our case, port 80 and both IPv4 and IPv6 addresses. The <code class="Code-In-Text--PACKT-">default_server</code> clause means this is the server to be used by default:</p>&#13;&#13;
    <pre class="programlisting code"><code class="hljs-code">    <span class="hljs-attribute">listen</span> <span class="hljs-number">80</span> default_server;&#13;&#13;
    <span class="hljs-attribute">listen</span> [::]:<span class="hljs-number">80</span> default_server;&#13;&#13;
</code></pre>&#13;&#13;
    <div class="note">&#13;&#13;
      <p class="Information-Box--PACKT-">IPv4 is the common address with four numbers, like <code style="font-weight: bold;" class="codeHighlighted">127.0.0.1</code>. IPv6 is longer, and it's intended as a replacement for IPv4. For example, an IPv6 address can be expressed as <code style="font-weight: bold;" class="codeHighlighted">2001:0db8:0000:0000:0000:ff00:0042:7879</code>. IPv4 addresses have already been exhausted, meaning that there are no new addresses available. IPv6 will in the long run provide enough to avoid this problem, though IPv4 is still widely used, and probably will remain in use for a long time yet.</p>&#13;&#13;
    </div>&#13;&#13;
    <p class="normal">Next, we define <a id="_idIndexMarker385"/>where the static files are, both in terms of the external URL, and what is the mapping with some section of the hard drive.</p>&#13;&#13;
    <p class="normal">Note the static location needs to be defined before the reverse proxy: </p>&#13;&#13;
    <pre class="programlisting code"><code class="hljs-code">    root /opt/;&#13;&#13;
    location /static/ {&#13;&#13;
        autoindex on;&#13;&#13;
        try_files $uri $uri/ =<span class="hljs-number">404</span>;&#13;&#13;
    }&#13;&#13;
</code></pre>&#13;&#13;
    <p class="normal"><code class="Code-In-Text--PACKT-">root</code> defines the starting point, while <code class="Code-In-Text--PACKT-">location</code> starts a section that will serve the URL <code class="Code-In-Text--PACKT-">/static/file1.txt</code> from the file located in the hard drive at <code class="Code-In-Text--PACKT-">/opt/static/file1.txt</code>.</p>&#13;&#13;
    <p class="normal"><code class="Code-In-Text--PACKT-">try_files</code> will scan for files in the URI and raise a 404 error if it's not there.</p>&#13;&#13;
    <p class="normal"><code class="Code-In-Text--PACKT-">autoindex</code> automatically generates an index page to check the contents of a directory.</p>&#13;&#13;
    <div class="packt_tip">&#13;&#13;
      <p class="Tip--PACKT-">This option is typically disabled in production servers, but it's very handy to detect problems with static files while running in test mode.</p>&#13;&#13;
    </div>&#13;&#13;
    <p class="normal">It's important in production environments to serve static files directly from the web server, instead of doing them further along the line with the Python worker. While this is possible, and a common case when working in a development environment, it's very inefficient. The speed and memory usage will be much bigger, while a web server is optimized to serve static files. Please always remember to serve static files in production through a web server.</p>&#13;&#13;
    <h2 id="_idParaDest-116" class="title">Serving static content externally</h2>&#13;&#13;
    <p class="normal">An alternative is to <a id="_idIndexMarker386"/>use an external service to handle files, like AWS S3, that allows you to serve <a id="_idIndexMarker387"/>static files. The files then will be under a different URL than the service, for example:</p>&#13;&#13;
    <ul>&#13;&#13;
      <li class="bullet">The service URL is <code class="Code-In-Text--PACKT-">https://example.com/index</code></li>&#13;&#13;
      <li class="bullet">The static files are in <code class="Code-In-Text--PACKT-">https://mybucket.external-service/static/</code></li>&#13;&#13;
    </ul>&#13;&#13;
    <p class="normal">All the references inside the service web pages, then, should point to the external service endpoint.</p>&#13;&#13;
    <p class="normal">This way of operating requires you to push the code to the external service as part of the deployment. To allow for uninterrupted deployments, remember that the static content needs to be available before. Another important detail is to upload them with a different path, so static files between deployments are not confused.</p>&#13;&#13;
    <p class="normal">This is easy to do using different root paths. For example:</p>&#13;&#13;
    <ol>&#13;&#13;
      <li class="numbered">Version <code class="Code-In-Text--PACKT-">v1</code> of the service is deployed. This is the starting point. The static content is served from <code class="Code-In-Text--PACKT-">https://mybucket.external-service/static/v1/</code>.<p class="bullet-para">The calls to the service, like <code class="Code-In-Text--PACKT-">https://example.com/index</code>, return all their static content pointing at version <code class="Code-In-Text--PACKT-">v1</code>.</p>&#13;&#13;
      </li>&#13;&#13;
      <li class="numbered">Once <code class="Code-In-Text--PACKT-">v2</code> of the service is ready, the first thing to do is to push it to the external service, so it's available in <code class="Code-In-Text--PACKT-">https://mybucket.external-service/static/v2/</code>. Note that, at this point, no user is accessing <code class="Code-In-Text--PACKT-">/static/v2</code>; the service is still returning <code class="Code-In-Text--PACKT-">/static/v1</code>.<p class="bullet-para">Deploy the new service. Once it is deployed, the users will start accessing <code class="Code-In-Text--PACKT-">/static/v2 </code>when they call <code class="Code-In-Text--PACKT-">https://example.com/index</code>.</p>&#13;&#13;
      </li>&#13;&#13;
    </ol>&#13;&#13;
    <p class="normal">As we've seen in previous chapters, the key for a seamless deployment is to perform actions in small increments, and each step must perform actions that are reversible and prepare the terrain so there's no moment when something that's required is not ready.</p>&#13;&#13;
    <p class="normal">This approach can be used for big operations. In a JavaScript-heavy interface, like a single-page application, changing the static files effectively can be a new deployment. The underlying service API can remain the same but changing the downloaded version for all JavaScript code and other static content, which in effect will deploy a new version.</p>&#13;&#13;
    <div class="note">&#13;&#13;
      <p class="Information-Box--PACKT-">We talked about single-page apps in <em class="chapterRef">Chapter 2</em>.</p>&#13;&#13;
    </div>&#13;&#13;
    <p class="normal">This structure makes both versions of the static content available at the same time. This can also be used to make tests or release beta versions. As the service is returning whether to use version A or B, this can be set dynamically.</p>&#13;&#13;
    <p class="normal">For example, adding an optional parameter in any call to overwrite the returned version:</p>&#13;&#13;
    <ul>&#13;&#13;
      <li class="bullet">Calling <code class="Code-In-Text--PACKT-">https://example.com/index</code> returns the default version, for example, <code class="Code-In-Text--PACKT-">v2</code>.</li>&#13;&#13;
      <li class="bullet">Calling <code class="Code-In-Text--PACKT-">https://example.com/index?overwrite_static=v3</code> returns the specified version instead, like <code class="Code-In-Text--PACKT-">v3</code>.</li>&#13;&#13;
    </ul>&#13;&#13;
    <p class="normal">Other options <a id="_idIndexMarker388"/>are returning <code class="Code-In-Text--PACKT-">v3</code> for specific users, like beta testers or internal staff. Once <code class="Code-In-Text--PACKT-">v3</code> is deemed correct, it can be changed to be the new default with a small change in the service.</p>&#13;&#13;
    <div class="packt_tip">&#13;&#13;
      <p class="Tip--PACKT-">This approach can be taken to the extreme to push any single commit to the source control to the public S3 bucket, and then test in any environment, including production. This can help to generate a very fast feedback loop where QA or product owners can quickly see changes in their own browser, without requiring any deployment or special environment.</p>&#13;&#13;
      <p class="Tip--PACKT-">Don't feel limited to a unique integer as the version number; it can work as well with a random UUID or SHA of the content generated automatically. Web storage is quite cheap, so it would require a lot of versions with very big files to really start to worry about cost. And old versions can be deleted periodically.</p>&#13;&#13;
      <p class="Tip--PACKT-">While this approach can be very aggressive and not viable for all applications, for an application that requires many changes in a rich JavaScript interface or to make drastic changes to the look and feel, it can be highly productive. </p>&#13;&#13;
    </div>&#13;&#13;
    <p class="normal">This external <a id="_idIndexMarker389"/>serving can be combined with <strong class="keyword">CDN</strong> (<strong class="keyword">content delivery network</strong>) support for a multiregional proxy. This will distribute the files around the world to provide a copy of it closer to the user.</p>&#13;&#13;
    <div class="packt_tip">&#13;&#13;
      <p class="Tip--PACKT-">Think of a CDN as an internal cache by the company providing the service. For example, we have a service where their servers are located in Europe, but a user is accessing it from Japan. This company has servers in Japan that store a copy of the static content. That means that the user can access the files with much lower latency than if the request had to reach a server in Europe, more than 8,000 kilometers away.</p>&#13;&#13;
    </div>&#13;&#13;
    <p class="normal">Using a CDN is very powerful for truly global audiences. They are especially useful for serving data that requires low latency around the world. For example, broadcasting near real-time video.</p>&#13;&#13;
    <div class="packt_tip">&#13;&#13;
      <p class="Tip--PACKT-">Video broadcast online is typically transferred as small video chunks of a few seconds in duration. An index file keeps track of what is the latest chunk generated, so clients can be kept up to date. This is the basis of the format <strong class="keyword">HTTP Live Streaming</strong>, or <strong class="keyword">HLS</strong>, very common as the transfer of data is done directly through HTTP.</p>&#13;&#13;
    </div>&#13;&#13;
    <p class="normal">The data <a id="_idIndexMarker390"/>can be distributed internally between the different servers from the company providing the CDN service quite quickly, as they'll use dedicated networks between them instead of using an external network.</p>&#13;&#13;
    <p class="normal">In any case, using an external service to store the static files will, obviously, remove the need to configure the web server for them.</p>&#13;&#13;
    <h2 id="_idParaDest-117" class="title">Reverse proxy</h2>&#13;&#13;
    <p class="normal">Let's continue describing the web server configuration. After describing the static files, we need <a id="_idIndexMarker391"/>to define a connection to the backend, acting as a reverse proxy.</p>&#13;&#13;
    <p class="normal">A reverse proxy is <a id="_idIndexMarker392"/>a proxy server that can redirect a received request towards one or more defined backends. In our example, the backend is the uWSGI process.</p>&#13;&#13;
    <div class="packt_tip">&#13;&#13;
      <p class="Tip--PACKT-">A reverse proxy <a id="_idIndexMarker393"/>works in a similar way as a load balancer, though load balancers can work with more protocols, while a reverse proxy is only capable of working with web requests. On top of distributing requests across different servers, it can also add some features like caching, security, SSL termination (receiving a request in HTTPS and connecting to other servers using HTTP), or, in this particular case, receive a web request and transfer it to through a WSGI connection.</p>&#13;&#13;
    </div>&#13;&#13;
    <p class="normal">The web server will be able to communicate with the backend in multiple ways, allowing flexibility. This can use different protocols, like FastCGI, SCGI, straight HTTP for pure proxying, or, in our case, connecting directly to the uWSGI protocol. We need to define it to connect through either a TCP socket or a UNIX socket. We will use a UNIX socket.</p>&#13;&#13;
    <div class="packt_tip">&#13;&#13;
      <p class="Tip--PACKT-">TCP sockets are designed to allow communication between different servers, while UNIX sockets are designed to communicate processes locally. UNIX sockets are a little bit lighter for communication inside the same host and they work like a file, allowing you to assign them permissions to control what process can access what socket.</p>&#13;&#13;
    </div>&#13;&#13;
    <p class="normal">The socket <a id="_idIndexMarker394"/>needs to be coordinated with the way uWSGI is <a id="_idIndexMarker395"/>configured. As we will see later, the uWSGI process will create it:</p>&#13;&#13;
    <pre class="programlisting code"><code class="hljs-code">    location / {&#13;&#13;
       proxy_set_header Host $host;&#13;&#13;
       proxy_set_header X-Real-IP $remote_addr;&#13;&#13;
       include uwsgi_params;&#13;&#13;
        uwsgi_pass unix:<span class="hljs-comment">///tmp/uwsgi.sock;</span>&#13;&#13;
    }&#13;&#13;
</code></pre>&#13;&#13;
    <p class="normal">First of all, the root of the server is at the <code class="Code-In-Text--PACKT-">/</code> URL. It's important to make the static content before the reverse proxy, as the locations are checked in order. So any request for a <code class="Code-In-Text--PACKT-">/static</code> request gets detected before checking for <code class="Code-In-Text--PACKT-">/</code> and it's properly treated.</p>&#13;&#13;
    <p class="normal">The core of the reverse proxy configuration is the <code class="Code-In-Text--PACKT-">uwsgi_pass</code> clause. This specified where to redirect the requests. <code class="Code-In-Text--PACKT-">include uwgi_params</code> will add a bunch of standard configurations to be passed to the next stage. </p>&#13;&#13;
    <div class="note">&#13;&#13;
      <p class="Information-Box--PACKT-"><code class="Code-In-Text--PACKT-">uwsgi_params</code> is actually a defined file included by default in nginx config that adds a lot of <code class="Code-In-Text--PACKT-">uwsgi_param</code> statements with elements like <code class="Code-In-Text--PACKT-">SERVER_NAME</code>, <code class="Code-In-Text--PACKT-">REMOTE_ADDRESS</code>, etc.</p>&#13;&#13;
      <p class="Information-Box--PACKT-">More <code class="Code-In-Text--PACKT-">uwsgi_param</code> can be added if necessary, in a similar way to the headers.</p>&#13;&#13;
    </div>&#13;&#13;
    <p class="normal">Extra elements can be added as HTTP headers. They'll be added to the request, so they are available further down the request. </p>&#13;&#13;
    <pre class="programlisting code"><code class="hljs-code">       proxy_set_header Host $host;&#13;&#13;
       proxy_set_header X-Real-IP $remote_addr;&#13;&#13;
</code></pre>&#13;&#13;
    <p class="normal">In this case, we are adding the <code class="Code-In-Text--PACKT-">Host</code> header, with information about the requested host. Note that <a id="_idIndexMarker396"/>the <code class="Code-In-Text--PACKT-">$host</code> is an indication to nginx to fill the value with <a id="_idIndexMarker397"/>the host the request is addressed to. In the same way, the header <code class="Code-In-Text--PACKT-">X-Real-IP</code> is added with the IP address from the remote address.</p>&#13;&#13;
    <div class="packt_tip">&#13;&#13;
      <p class="Tip--PACKT-">Setting headers correctly to pass on is unappreciated work, but can be critical to properly monitor problems. Setting headers may require doing so at different stages. As we will discuss later, a single request can pass through multiple proxies, and each of them needs to adequately forward the headers.</p>&#13;&#13;
    </div>&#13;&#13;
    <p class="normal">In our configuration, we only use a single backend, as uWSGI will balance between different workers. But, if necessary, multiple backends can be defined, even mixing UNIX and TCP sockets, defining a cluster.</p>&#13;&#13;
    <pre class="programlisting code"><code class="hljs-code">upstream uwsgibackends {&#13;&#13;
  server unix:<span class="hljs-comment">///tmp/uwsgi.sock;</span>&#13;&#13;
  server <span class="hljs-number">192.168</span>.<span class="hljs-number">1.117</span>:<span class="hljs-number">8080</span>;&#13;&#13;
  server <span class="hljs-number">10.0</span>.<span class="hljs-number">0.6</span>:<span class="hljs-number">8000</span>;&#13;&#13;
}&#13;&#13;
</code></pre>&#13;&#13;
    <p class="normal">Later, define the <code class="Code-In-Text--PACKT-">uwsgi_pass</code> to use the cluster. The requests will be equally spread over the different backends.</p>&#13;&#13;
    <pre class="programlisting code"><code class="hljs-code">uwsgi_pass uwsgibackends;&#13;&#13;
</code></pre>&#13;&#13;
    <h2 id="_idParaDest-118" class="title">Logging</h2>&#13;&#13;
    <p class="normal">We also <a id="_idIndexMarker398"/>need to track any possible error or access. There are two different <a id="_idIndexMarker399"/>logs that <code class="Code-In-Text--PACKT-">nginx</code> (and other web servers) produces:</p>&#13;&#13;
    <ul>&#13;&#13;
      <li class="bullet"><strong class="keyword">Error log</strong>: The error <a id="_idIndexMarker400"/>log tracks possible problems from the web <a id="_idIndexMarker401"/>server itself, like not being able to start, configuration problems, etc. </li>&#13;&#13;
      <li class="bullet"><strong class="keyword">Access log</strong>: The access log reports any request accessing the system. This is the basic <a id="_idIndexMarker402"/>information about the system flowing. It can be used to find specific <a id="_idIndexMarker403"/>problems like 502 errors when the backend cannot be connected, or, when treated as aggregated, it can detect problems like an abnormal number of error status codes (<code class="Code-In-Text--PACKT-">4xx</code> or <code class="Code-In-Text--PACKT-">5xx</code>).</li>&#13;&#13;
    </ul>&#13;&#13;
    <div class="note">&#13;&#13;
      <p class="Information-Box--PACKT-">We will talk in further detail about logs in <em class="chapterRef">Chapter 11</em>.</p>&#13;&#13;
    </div>&#13;&#13;
    <p class="normal">Both logs are <a id="_idIndexMarker404"/>critical information that needs to be adequately detected. Following the Twelve-Factor App, we should treat them as streams of data. The easiest is to redirect them both to standard output.</p>&#13;&#13;
    <pre class="programlisting code"><code class="hljs-code">    access_log /dev/stdout;&#13;&#13;
    error_log /dev/stdout;&#13;&#13;
</code></pre>&#13;&#13;
    <p class="normal">This requires nginx to not start as a daemon process, or if it is, capture the standard output properly.</p>&#13;&#13;
    <p class="normal">Another option <a id="_idIndexMarker405"/>is to redirect the log into a centralized log facility, using the proper protocol. This directs all the logs into a centralized server that captures the information. In this example, we send it to a syslog host in <code class="Code-In-Text--PACKT-">syslog_host</code>.</p>&#13;&#13;
    <pre class="programlisting code"><code class="hljs-code">    error_log syslog:server=syslog_host:<span class="hljs-number">514</span>;&#13;&#13;
    access_log syslog:server=syslog_host:<span class="hljs-number">514</span>,tag=nginx;&#13;&#13;
</code></pre>&#13;&#13;
    <p class="normal">This protocol allows you to include tags and extra information that can help separate the origin of each log later.</p>&#13;&#13;
    <div class="packt_tip">&#13;&#13;
      <p class="Tip--PACKT-">Being able to distinguish the source of each log is critical and always requires a bit of tweaking. Be sure to spend some time making the logs easy to search. It will greatly simplify the work when an error in production requires gathering information.</p>&#13;&#13;
    </div>&#13;&#13;
    <h2 id="_idParaDest-119" class="title">Advanced usages</h2>&#13;&#13;
    <p class="normal">A web server is very powerful, and shouldn't be underestimated. Other than acting purely as <a id="_idIndexMarker406"/>a proxy, there are a lot of other features that can be enabled like returning custom redirects, overwriting the proxy with a static page for maintenance windows, rewriting URLs to adjust changes, providing SSL termination (decrypt receiving HTTPS requests to pass them decrypted through regular HTTP, and encrypt the result back), caching requests, splitting the requests based on percentages for A/B testing, choosing a backend server based on geolocalization of the requester, etc.</p>&#13;&#13;
    <p class="normal">Be sure to read the documentation of <code class="Code-In-Text--PACKT-">nginx</code> at <a href="http://nginx.org/en/docs/"><span class="url">http://nginx.org/en/docs/</span></a> to read all the possibilities.</p>&#13;&#13;
    <h1 id="_idParaDest-120" class="title">uWSGI</h1>&#13;&#13;
    <p class="normal">The next element <a id="_idIndexMarker407"/>of the chain is the uWSGI application. This application receives the requests from <code class="Code-In-Text--PACKT-">nginx</code> and redirects them into independent Python workers, in WSGI format.</p>&#13;&#13;
    <div class="note">&#13;&#13;
      <p class="Information-Box--PACKT-"><strong class="keyword">Web Server Gateway Interface</strong> (<strong class="keyword">WSGI</strong>) is a Python standard to deal with web requests. It's <a id="_idIndexMarker408"/>very popular and supported by a lot of software, both from the sending end (like <code class="Code-In-Text--PACKT-">nginx</code>, but also other web servers like Apache and GUnicorn) and from the receiving end (virtually every Python web framework, like Django, Flask, or Pyramid).</p>&#13;&#13;
    </div>&#13;&#13;
    <p class="normal">uWSGI will also start and coordinate the different processes, handling the lifecycle for each of them. The application works as an intermediary, starting a group of workers receiving the requests.</p>&#13;&#13;
    <p class="normal">uWSGI is configured through a <code class="Code-In-Text--PACKT-">uwsgi.ini</code> file. Let's see an example, available on GitHub at <a href="https://github.com/PacktPublishing/Python-Architecture-Patterns/blob/main/chapter_06_web_server/uwsgi_example.uni"><span class="url">https://github.com/PacktPublishing/Python-Architecture-Patterns/blob/main/chapter_06_web_server/uwsgi_example.uni</span></a>.</p>&#13;&#13;
    <pre class="programlisting code"><code class="hljs-code">[uwsgi]&#13;&#13;
chdir=/root/directory&#13;&#13;
wsgi-file = webapplication/wsgi.py&#13;&#13;
master=True&#13;&#13;
socket=/tmp/uwsgi.sock&#13;&#13;
vacuum=True&#13;&#13;
processes=1&#13;&#13;
max-requests=5000&#13;&#13;
# Used to send commands to uWSGI&#13;&#13;
master-fifo=/tmp/uwsgi-fifo&#13;&#13;
</code></pre>&#13;&#13;
    <p class="normal">The first <a id="_idIndexMarker409"/>element defines what the working directory is. The application will be launched here, and other file references will work from here:</p>&#13;&#13;
    <pre class="programlisting code"><code class="hljs-code">chdir=/root/directory&#13;&#13;
</code></pre>&#13;&#13;
    <p class="normal">Then, we describe where the <code class="Code-In-Text--PACKT-">wsgi.py</code> file is, which describes our application.</p>&#13;&#13;
    <h2 id="_idParaDest-121" class="title">The WSGI application</h2>&#13;&#13;
    <p class="normal">Inside this file is the definition of the <code class="Code-In-Text--PACKT-">application</code> function, which uWSGI can use to address <a id="_idIndexMarker410"/>the internal Python code, in a controlled way. </p>&#13;&#13;
    <p class="normal">For example:</p>&#13;&#13;
    <pre class="programlisting code"><code class="hljs-code"><span class="hljs-keyword">def</span><span class="hljs-function"> </span><span class="hljs-title">application</span><span class="hljs-function">(</span><span class="hljs-params">environ, start_response</span><span class="hljs-function">):</span>&#13;&#13;
    start_response(<span class="hljs-string">'200 OK'</span>, [(<span class="hljs-string">'Content-Type'</span>, <span class="hljs-string">'text/plain'</span>)])&#13;&#13;
    <span class="hljs-keyword">return</span> [<span class="hljs-string">b'Body of the response\n'</span>]&#13;&#13;
</code></pre>&#13;&#13;
    <p class="normal">The first parameter is a dictionary with predefined variables that detail the request (like <code class="Code-In-Text--PACKT-">METHOD</code>, <code class="Code-In-Text--PACKT-">PATH_INFO</code>, <code class="Code-In-Text--PACKT-">CONTENT_TYPE</code>, and so on) and parameters related to the protocol or environment (for example, <code class="Code-In-Text--PACKT-">wsgi.version</code>). </p>&#13;&#13;
    <p class="normal">The second parameter, <code class="Code-In-Text--PACKT-">start_response</code>, is a callable that allows you to set up the return status and any headers. </p>&#13;&#13;
    <p class="normal">The function should return the body. Note how it's returned in byte stream format.</p>&#13;&#13;
    <div class="note">&#13;&#13;
      <p class="Information-Box--PACKT-">The difference between text streams (or strings) and byte streams was one of the big differences introduced in Python 3. To summarize it, byte streams are raw binary data, while text streams contain meaning by interpreting that data through a particular encoding.</p>&#13;&#13;
      <p class="Information-Box--PACKT-">The differentiation between both can be a bit baffling sometimes, in particular since Python 3 makes the difference explicit, and that clashes with some previous lax practices, especially when dealing with ASCII content that can be represented in the same way.</p>&#13;&#13;
      <p class="Information-Box--PACKT-">Keep in mind that text streams need to be encoded to be transformed into byte streams, and byte streams need to be decoded into text streams. Encoding is moving from the abstract representation of text to the precise representation of binary.</p>&#13;&#13;
      <p class="Information-Box--PACKT-">For example, the Spanish word "cañón" contains two characters not present in ASCII, <code class="Code-In-Text--PACKT-">ñ</code> and <code class="Code-In-Text--PACKT-">ó</code>. You can see how encoding them through UTF8 replaces them with specific binary elements described in UTF8: </p>&#13;&#13;
      <pre class="programlisting con"><code class="hljs-con">&gt;&gt;&gt; 'cañón'.encode('utf-8')&#13;&#13;
b'ca\xc3\xb1\xc3\xb3n' &#13;&#13;
&gt;&gt;&gt; b'ca\xc3\xb1\xc3\xb3n'.decode('utf-8')&#13;&#13;
'cañón'&#13;&#13;
</code></pre>&#13;&#13;
    </div>&#13;&#13;
    <p class="normal">The function can also work as a generator and use the keyword <code class="Code-In-Text--PACKT-">yield</code> instead of <code class="Code-In-Text--PACKT-">return</code> when the <a id="_idIndexMarker411"/>returning body needs to be streamed.</p>&#13;&#13;
    <div class="note">&#13;&#13;
      <p class="Information-Box--PACKT-">Any function that uses <code class="Code-In-Text--PACKT-">yield</code> is a generator in Python. This means that when called, it returns an iterator object that returns elements one by one, normally to be used in loops.</p>&#13;&#13;
      <p class="Information-Box--PACKT-">This is very useful for situations where each element of the loop takes some time to process but can be returned without being required to calculate every single item, reducing latency and memory usage, as not all elements need to be maintained in memory.</p>&#13;&#13;
      <pre class="programlisting con"><code class="hljs-con">&gt;&gt;&gt; def mygenerator():&#13;&#13;
...   yield 1&#13;&#13;
...   yield 2&#13;&#13;
...   yield 3&#13;&#13;
&gt;&gt;&gt; for i in mygenerator():&#13;&#13;
...   print(i)&#13;&#13;
...&#13;&#13;
1&#13;&#13;
2&#13;&#13;
3&#13;&#13;
</code></pre>&#13;&#13;
    </div>&#13;&#13;
    <p class="normal">In any case, the WSGI file is normally created by default by whatever framework is used. For example, a <code class="Code-In-Text--PACKT-">wsgi.py</code> file created by Django will look like this.</p>&#13;&#13;
    <pre class="programlisting code"><code class="hljs-code"><span class="hljs-keyword">import</span> os&#13;&#13;
<span class="hljs-keyword">from</span> django.core.wsgi <span class="hljs-keyword">import</span> get_wsgi_application&#13;&#13;
os.environ.setdefault(<span class="hljs-string">"DJANGO_SETTINGS_MODULE"</span>, <span class="hljs-string">"webapplication.settings"</span>)&#13;&#13;
application = get_wsgi_application()&#13;&#13;
</code></pre>&#13;&#13;
    <p class="normal">Note how <a id="_idIndexMarker412"/>the function <code class="Code-In-Text--PACKT-">get_wsgi_application</code> will automatically set up the proper application function, and connect it with the rest of the defined code – a great advantage of using an existing framework!</p>&#13;&#13;
    <h2 id="_idParaDest-122" class="title">Interacting with the web server</h2>&#13;&#13;
    <p class="normal">Let's continue with the <code class="Code-In-Text--PACKT-">uwsgi.ini</code> configuration with the socket configuration:</p>&#13;&#13;
    <pre class="programlisting code"><code class="hljs-code">socket=/tmp/uwsgi.sock&#13;&#13;
vacuum=True&#13;&#13;
</code></pre>&#13;&#13;
    <p class="normal">The <code class="Code-In-Text--PACKT-">socket</code> parameter creates the UNIX socket for the web server to connect to. It was discussed <a id="_idIndexMarker413"/>before in this chapter, when talking about the web server. This needs to be coordinated on both sides, to ensure they connect properly.</p>&#13;&#13;
    <div class="note">&#13;&#13;
      <p class="Information-Box--PACKT-">uWSGI also allows you to use a native HTTP socket, using the option <code class="Code-In-Text--PACKT-">http-socket</code>. For example, <code class="Code-In-Text--PACKT-">http-socket = 0.0.0.0:8000</code> to serve all addresses on port 8000. You may use this option if the web server is not on the same server and needs to communicate through the network.</p>&#13;&#13;
      <p class="Information-Box--PACKT-">When possible, avoid exposing uWSGI directly publicly over the internet. A web server will be safer and more efficient. It will also serve static content much more efficiently. If you really must skip the web server, use the option <code class="Code-In-Text--PACKT-">http</code> instead of <code class="Code-In-Text--PACKT-">http-socket</code>, which includes a certain level of protection.</p>&#13;&#13;
    </div>&#13;&#13;
    <p class="normal">The <code class="Code-In-Text--PACKT-">vacuum</code> option cleans up the socket when the server is closed.</p>&#13;&#13;
    <h2 id="_idParaDest-123" class="title">Processes</h2>&#13;&#13;
    <p class="normal">The next <a id="_idIndexMarker414"/>parameters control the number of processes and how to control them:</p>&#13;&#13;
    <pre class="programlisting code"><code class="hljs-code">master=True&#13;&#13;
processes=1&#13;&#13;
</code></pre>&#13;&#13;
    <p class="normal">The <code class="Code-In-Text--PACKT-">master</code> parameter creates a master process that ensures that the number of workers is correct, restarting if not, and deals with the process lifecycle, among other tasks. It should always be enabled in production for smooth operation.</p>&#13;&#13;
    <p class="normal">The <code class="Code-In-Text--PACKT-">processes</code> parameter is very straightforward and describes how many Python workers should be started. Received requests will be load balanced across them. </p>&#13;&#13;
    <p class="normal">The way uWSGI generates new processes is through pre-forking. This means that a single process gets started, and after the application is loaded (which may take a while), it's cloned through a fork process. This sensibly speeds up the startup time for new processes, but at the same time, relays that the setup of the application can be duplicated. </p>&#13;&#13;
    <div class="packt_tip">&#13;&#13;
      <p class="Tip--PACKT-">This assumption, on rare occasions, may cause problems with certain libraries that, for example, open file descriptors during initializations that cannot be shared safely. If that's the case, the parameter <code class="Code-In-Text--PACKT-">lazy-apps</code> will make each worker start from scratch, independently. This is slower, but it creates more consistent results.</p>&#13;&#13;
    </div>&#13;&#13;
    <p class="normal">Choosing the right number of processes is highly dependent on the application itself and the hardware that supports it. The hardware is important as a CPU with multiple cores will be able to run more processes efficiently. The amount of IO vs CPU usage in the application will determine how many processes can be run by the CPU core.</p>&#13;&#13;
    <div class="packt_tip">&#13;&#13;
      <p class="Tip--PACKT-">Theoretically, a process not using IO and purely crunching numbers will use the whole core without wait periods, not allowing the core to switch to another process meanwhile. A process with high IO, with the core idle while waiting for results from the database and external services, will increase its efficiency by performing more context switches. This number should be tested to ensure the best results. A common starting point will be two times the number of cores, but remember to monitor the system to tweak it and obtain the best results.</p>&#13;&#13;
    </div>&#13;&#13;
    <p class="normal">An important detail about the created processes is that they deactivate the creation of new threads by default. This is an optimization choice. In the majority of web applications, there's no need to create independent threads inside each of the workers, and that allows you to deactivate the Python GIL, speeding up the code. </p>&#13;&#13;
    <div class="note">&#13;&#13;
      <p class="Information-Box--PACKT-">The <strong class="keyword">Global Interpreter Lock</strong> or <strong class="keyword">GIL</strong> is a mutex lock that only allows a single thread <a id="_idIndexMarker415"/>to have control of the Python process. This means that, inside a single process, no two threads can run at the same time, something that multi-core CPU architecture makes possible. Note that multiple threads may be waiting for IO results while another runs, which is a usual situation in real-life applications. The GIL is typically held and released constantly, as each operation first holds the GIL and then releases it at the end.</p>&#13;&#13;
      <p class="Information-Box--PACKT-">The GIL is commonly blamed for inefficiencies in Python, though the effect is only perceived in high-CPU multi-threaded operations in native Python (as opposed to using optimized libraries like NumPy), which are not as usual and are already slow to start with.</p>&#13;&#13;
      <p class="Information-Box--PACKT-">These interactions with the GIL are only wasteful if no threads will be run, so that's why uWSGI deactivates it by default.</p>&#13;&#13;
    </div>&#13;&#13;
    <p class="normal">If threads <a id="_idIndexMarker416"/>need to be used, the option <code class="Code-In-Text--PACKT-">enable-threads</code> will enable them. </p>&#13;&#13;
    <h2 id="_idParaDest-124" class="title">Process lifecycle</h2>&#13;&#13;
    <p class="normal">During the time of operation, processes won't stay static. Any working web application will need <a id="_idIndexMarker417"/>to reload with new code changes regularly. The next parameters are related to how processes are created and destroyed.</p>&#13;&#13;
    <pre class="programlisting code"><code class="hljs-code">max-requests=5000&#13;&#13;
# Used to send commands to uWSGI&#13;&#13;
master-fifo=/tmp/uwsgi-fifo&#13;&#13;
</code></pre>&#13;&#13;
    <p class="normal"><code class="Code-In-Text--PACKT-">max-requests</code> specifies the number of requests to be processed by a single worker before being restarted. Once the worker gets to this number, uWSGI will destroy it and create another worker from scratch, following the usual process (fork by default, or using <code class="Code-In-Text--PACKT-">lazy-apps</code> if configured).</p>&#13;&#13;
    <p class="normal">This is useful to avoid problems with memory leaks or other sorts of stale problems, where the performance of a worker gets degraded over time. Recycling the workers is a protective measure that can be taken pre-emptively, so even if a problem is present, it will be corrected before it causes any issues. </p>&#13;&#13;
    <p class="normal">Remember that, based on the Twelve-Factor App, web workers need to be able to be stopped and started at any time, so this recycling is painless.</p>&#13;&#13;
    <p class="normal">uWSGI will also recycle the worker when it's idle, after serving its 5,000<sup class="Superscript--PACKT-">th</sup> request, so it will be a controlled operation.</p>&#13;&#13;
    <div class="packt_tip">&#13;&#13;
      <p class="Tip--PACKT-">Keep in mind this recycling may interfere with other operations. Depending on the startup time, it may take a few seconds or worse (especially if <code class="Code-In-Text--PACKT-">lazy-apps</code> is used) to start the worker, potentially creating a backlog of requests. uWSGI will queue the incoming requests. In our example configuration, there's only a single worker defined in <code class="Code-In-Text--PACKT-">processes</code>. With multiple workers this can be mitigated, as the rest of the workers will be able to handle the extra load.</p>&#13;&#13;
    </div>&#13;&#13;
    <p class="normal">When multiple workers are involved, if each of them will restart after their 5,000<sup class="Superscript--PACKT-">th</sup> request, a stampede problem can be created where one after another all the workers are recycled. Keep in mind that the load is distributed through the workers equally, so this count <a id="_idIndexMarker418"/>will be in sync across the multiple workers. While the expectation is that, for example, with 16 workers, at least 15 of them will be available, in practice we might find that all are being recycled at the same time.</p>&#13;&#13;
    <p class="normal">To avoid this problem, use the <code class="Code-In-Text--PACKT-">max-requests-delta</code> parameter. This parameter adds a variable number for each worker. It will multiply the delta for the worker ID (a unique consecutive number for each worker starting from 1). So, configuring a delta of 200, each worker will have the following: </p>&#13;&#13;
    <table id="table001-3" class="No-Table-Style _idGenTablePara-1">&#13;&#13;
      <colgroup>&#13;&#13;
        <col/>&#13;&#13;
        <col/>&#13;&#13;
        <col/>&#13;&#13;
        <col/>&#13;&#13;
      </colgroup>&#13;&#13;
      <tbody>&#13;&#13;
        <tr class="No-Table-Style">&#13;&#13;
          <td class="No-Table-Style">&#13;&#13;
            <p class="Table-Column-Heading--PACKT-"><span class="python">Worker</span></p>&#13;&#13;
          </td>&#13;&#13;
          <td class="No-Table-Style">&#13;&#13;
            <p class="Table-Column-Heading--PACKT-"><span class="python">Base max-request</span></p>&#13;&#13;
          </td>&#13;&#13;
          <td class="No-Table-Style">&#13;&#13;
            <p class="Table-Column-Heading--PACKT-"><span class="python">Delta</span></p>&#13;&#13;
          </td>&#13;&#13;
          <td class="No-Table-Style">&#13;&#13;
            <p class="Table-Column-Heading--PACKT-"><span class="python">Total requests to recycle</span></p>&#13;&#13;
          </td>&#13;&#13;
        </tr>&#13;&#13;
        <tr class="No-Table-Style">&#13;&#13;
          <td class="No-Table-Style">&#13;&#13;
            <p class="Table-Column-Content--PACKT-"><span class="python">Worker 1</span></p>&#13;&#13;
          </td>&#13;&#13;
          <td class="No-Table-Style">&#13;&#13;
            <p class="Table-Column-Content--PACKT-"><span class="python">5,000</span></p>&#13;&#13;
          </td>&#13;&#13;
          <td class="No-Table-Style">&#13;&#13;
            <p class="Table-Column-Content--PACKT-"><span class="python">1 * 200</span></p>&#13;&#13;
          </td>&#13;&#13;
          <td class="No-Table-Style">&#13;&#13;
            <p class="Table-Column-Content--PACKT-"><span class="python">5,200</span></p>&#13;&#13;
          </td>&#13;&#13;
        </tr>&#13;&#13;
        <tr class="No-Table-Style">&#13;&#13;
          <td class="No-Table-Style">&#13;&#13;
            <p class="Table-Column-Content--PACKT-"><span class="python">Worker 2</span></p>&#13;&#13;
          </td>&#13;&#13;
          <td class="No-Table-Style">&#13;&#13;
            <p class="Table-Column-Content--PACKT-"><span class="python">5,000</span></p>&#13;&#13;
          </td>&#13;&#13;
          <td class="No-Table-Style">&#13;&#13;
            <p class="Table-Column-Content--PACKT-"><span class="python">2 * 200</span></p>&#13;&#13;
          </td>&#13;&#13;
          <td class="No-Table-Style">&#13;&#13;
            <p class="Table-Column-Content--PACKT-"><span class="python">5,400</span></p>&#13;&#13;
          </td>&#13;&#13;
        </tr>&#13;&#13;
        <tr class="No-Table-Style">&#13;&#13;
          <td class="No-Table-Style">&#13;&#13;
            <p class="Table-Column-Content--PACKT-"><span class="python">Worker 3</span></p>&#13;&#13;
          </td>&#13;&#13;
          <td class="No-Table-Style">&#13;&#13;
            <p class="Table-Column-Content--PACKT-"><span class="python">5,000</span></p>&#13;&#13;
          </td>&#13;&#13;
          <td class="No-Table-Style">&#13;&#13;
            <p class="Table-Column-Content--PACKT-"><span class="python">3 * 200</span></p>&#13;&#13;
          </td>&#13;&#13;
          <td class="No-Table-Style">&#13;&#13;
            <p class="Table-Column-Content--PACKT-"><span class="python">5,600</span></p>&#13;&#13;
          </td>&#13;&#13;
        </tr>&#13;&#13;
        <tr class="No-Table-Style">&#13;&#13;
          <td class="No-Table-Style">&#13;&#13;
            <p class="Table-Column-Content--PACKT-"><span class="python">…</span></p>&#13;&#13;
          </td>&#13;&#13;
          <td class="No-Table-Style">&#13;&#13;
          </td>&#13;&#13;
          <td class="No-Table-Style">&#13;&#13;
          </td>&#13;&#13;
          <td class="No-Table-Style">&#13;&#13;
          </td>&#13;&#13;
        </tr>&#13;&#13;
        <tr class="No-Table-Style">&#13;&#13;
          <td class="No-Table-Style">&#13;&#13;
            <p class="Table-Column-Content--PACKT-"><span class="python">Worker 16</span></p>&#13;&#13;
          </td>&#13;&#13;
          <td class="No-Table-Style">&#13;&#13;
            <p class="Table-Column-Content--PACKT-"><span class="python">5,000</span></p>&#13;&#13;
          </td>&#13;&#13;
          <td class="No-Table-Style">&#13;&#13;
            <p class="Table-Column-Content--PACKT-"><span class="python">16 * 200</span></p>&#13;&#13;
          </td>&#13;&#13;
          <td class="No-Table-Style">&#13;&#13;
            <p class="Table-Column-Content--PACKT-"><span class="python">8,200</span></p>&#13;&#13;
          </td>&#13;&#13;
        </tr>&#13;&#13;
      </tbody>&#13;&#13;
    </table>&#13;&#13;
    <p class="normal">This makes the recycling happen at different times, increasing the number of workers available at the same time, as they won't restart simultaneously.</p>&#13;&#13;
    <div class="packt_tip">&#13;&#13;
      <p class="Tip--PACKT-">This problem is of the same kind as what's called a cache stampede. This is produced where multiple cache values are invalidated at the same time, producing the regeneration of values at the same time. Because the system expects to be running under some cache acceleration, suddenly having to recreate a significant portion section of the cache may produce a serious performance problem, to the point of the complete collapse of the system.</p>&#13;&#13;
      <p class="Tip--PACKT-">To avoid this, avoid setting fixed times for the cache to expire, such as a certain hour of the clock. This can happen, for example, if a backend gets updated with news for the day at midnight, making it tempting to expire the cache at this time. Instead, add an element to make the different keys expire at slightly different times to avoid this problem. This can be achieved by adding a small random amount of time to the expiry time for each of the keys, so they can reliably be refreshed at different times.</p>&#13;&#13;
    </div>&#13;&#13;
    <p class="normal">The <code class="Code-In-Text--PACKT-">master-fifo</code> parameter creates a way to communicate with uWSGI and send commands:</p>&#13;&#13;
    <pre class="programlisting code"><code class="hljs-code"># Used to send commands to uWSGI&#13;&#13;
master-fifo=/tmp/uwsgi-fifo&#13;&#13;
</code></pre>&#13;&#13;
    <p class="normal">This creates <a id="_idIndexMarker419"/>a UNIX socket in <code class="Code-In-Text--PACKT-">/tmp/uwsgi-fifo</code> that can receive commands in the form of characters redirected to it. For example:</p>&#13;&#13;
    <pre class="programlisting code"><code class="hljs-code"># Generate a graceful reload&#13;&#13;
echo r &gt;&gt; /tmp/uwsgi-fifo&#13;&#13;
# Graceful stop of the server&#13;&#13;
echo q &gt;&gt; /tmp/uwsgi-fifo&#13;&#13;
</code></pre>&#13;&#13;
    <p class="normal">This method allows for better handling of situations than sending signals, as there are more commands available and it allows for quite granular control of the processes and the whole uWSGI.</p>&#13;&#13;
    <p class="normal">For example, sending <code class="Code-In-Text--PACKT-">Q</code> will produce a direct shutdown of uWSGI, while <code class="Code-In-Text--PACKT-">q</code> will produce a graceful one. A graceful shutdown will start by stopping accepting new requests in uWSGI, then waiting until any request in the internal uWSGI queue is being processed, and when a worker has finished its request, stopping it in an orderly fashion. Finally, when all workers are done, stop the uWSGI master process.</p>&#13;&#13;
    <p class="normal">The graceful reload with <code class="Code-In-Text--PACKT-">r</code> takes a similar approach, keeping the requests in the internal queue and waiting until the workers are done to stop them and restart them. It will also load any new configuration related to uWSGI itself. Note that, during the time of the operation, the internal uWSGI listen queue may be filled up, causing problems.</p>&#13;&#13;
    <div class="packt_tip">&#13;&#13;
      <p class="Tip--PACKT-">The size of the listen queue can be tweaked with the <code class="Code-In-Text--PACKT-">listen</code> parameter, but keep in mind that there's a limit set up by Linux that you may need to change as well. Defaults are 100 for listen and 128 for the Linux configuration.</p>&#13;&#13;
      <p class="Tip--PACKT-">Do tests before changing those to big values, as churning through a big backlog of tasks has its own problems.</p>&#13;&#13;
    </div>&#13;&#13;
    <p class="normal">If the loading of processes is done through the fork process, after starting up the first one, the rest <a id="_idIndexMarker420"/>will be copies, so they will be loaded quite quickly. By comparison, using <code class="Code-In-Text--PACKT-">lazy-apps</code> may delay achieving full capacity as each individual worker will need to be individually started from scratch. This can produce an extra load on the server, depending on the number of workers and the startup procedure.</p>&#13;&#13;
    <div class="packt_tip">&#13;&#13;
      <p class="Tip--PACKT-">A possible alternative for <code class="Code-In-Text--PACKT-">lazy-apps</code> is to use the <code class="Code-In-Text--PACKT-">c</code> option, reloading the workers with chain reloading. This reloads each worker independently, waiting until a single worker is totally reloaded before moving to the next one. This procedure doesn't reload the uWSGI configuration but will do with code changes in the workers. It will take longer, but it will work at a controller pace.</p>&#13;&#13;
    </div>&#13;&#13;
    <p class="normal">Reloading a single server under load may be complicated. Using multiple uWSGI servers simplifies the process. In this situation, reloads should happen at different times to allow you to distribute the load. </p>&#13;&#13;
    <p class="normal">A cluster-style approach can be taken in using multiple servers to perform this dance, creating copies of the uWSGI configuration in multiple servers and then recycling them one at a time. While one is reloading, the others will be able to handle the extra load. In extreme situations, an extra server can be used to produce extra capacity during the reload.</p>&#13;&#13;
    <div class="packt_tip">&#13;&#13;
      <p class="Tip--PACKT-">This is common in cloud environments where an extra server can be used and then destroyed. In Docker situations, new containers can be added to provide this extra capacity.</p>&#13;&#13;
    </div>&#13;&#13;
    <p class="normal">For more <a id="_idIndexMarker421"/>information about the <code class="Code-In-Text--PACKT-">master-fifo</code> and accepted commands, including how to pause and resume the instance, and other exotic <a id="_idIndexMarker422"/>operations, check the uWSGI documentation at <a href="https://uwsgi-docs.readthedocs.io/en/latest/MasterFIFO.html"><span class="url">https://uwsgi-docs.readthedocs.io/en/latest/MasterFIFO.html</span></a>.</p>&#13;&#13;
    <div class="note">&#13;&#13;
      <p class="Information-Box--PACKT-">uWSGI is a very powerful application that has almost endless possibilities for configuration. Its documentation is overwhelming in the amount of detail it contains, but it's incredibly comprehensive and insightful. You can learn a lot, not only about uWSGI but also about how the whole web stack works. I highly recommend <a id="_idIndexMarker423"/>going through slowly, but surely, to learn a lot. You can access the documentation at <a href="https://uwsgi-docs.readthedocs.io/"><span class="url">https://uwsgi-docs.readthedocs.io/</span></a>.</p>&#13;&#13;
    </div>&#13;&#13;
    <h1 id="_idParaDest-125" class="title">Python worker</h1>&#13;&#13;
    <p class="normal">The core of the system is the Python WSGI worker. This worker receives the HTTP requests from uWSGI after they're routed by the external web server, etc.</p>&#13;&#13;
    <p class="normal">This is where <a id="_idIndexMarker424"/>the magic happens, and it is specific to the application. This is the element that will see faster iteration than the rest of the links of the chain.</p>&#13;&#13;
    <p class="normal">Each framework will interact in a slightly different way with the requests, but in general, they will follow similar patterns. We will use Django as an example.</p>&#13;&#13;
    <div class="packt_tip">&#13;&#13;
      <p class="Tip--PACKT-">We won't discuss all aspects of Django or go into a deep dive of its features but will use a selection to look at some lessons that are useful for other frameworks.</p>&#13;&#13;
      <p class="Tip--PACKT-">The Django project is really well documented. Seriously, it has always been distinguished <a id="_idIndexMarker425"/>by its world-class documentation, since the project started. You can read it here: <a href="http://www.djangoproject.com"><span class="url">http://www.djangoproject.com</span></a>.</p>&#13;&#13;
    </div>&#13;&#13;
    <h2 id="_idParaDest-126" class="title">Django MVT architecture</h2>&#13;&#13;
    <p class="normal">Django borrows <a id="_idIndexMarker426"/>heavily from the MVC structure but tweaks <a id="_idIndexMarker427"/>it a bit into what's called <strong class="keyword">MVT</strong> (<strong class="keyword">Model-View-Template</strong>): </p>&#13;&#13;
    <ul>&#13;&#13;
      <li class="bullet">The Model remains the same, the representation of the data and interacting with the storage.</li>&#13;&#13;
      <li class="bullet">The View receives the HTTP request and processes it, interacting with the different Models that may be required.</li>&#13;&#13;
      <li class="bullet">The Template is a system to generate HTML files, from values passed on.</li>&#13;&#13;
    </ul>&#13;&#13;
    <p class="normal">This changes Model-View-Controller a bit, though the result is similar.</p>&#13;&#13;
    <figure class="mediaobject"><img src="Images/B17580_06_03.png" alt="Shape, arrow&#13;&#10;&#13;&#10;Description automatically generated" width="826" height="247"/></figure>&#13;&#13;
    <p class="packt_figref">Figure 6.3: The Model-View-Controller</p>&#13;&#13;
    <p class="normal">The Model works the same in both systems. The Django View acts as a combination of the View and the Controller, and the Template is a helping system for the View component of the Django View.</p>&#13;&#13;
    <p class="normal">The templating system is not strictly required to be used, as not every Django interface requires an HTML page as a result. </p>&#13;&#13;
    <div class="packt_tip">&#13;&#13;
      <p class="Tip--PACKT-">While Django was designed to create HTML interfaces, there are ways of creating <a id="_idIndexMarker428"/>other types of interfaces. In particular, for RESTful interfaces, the Django REST framework (<a href="https://www.django-rest-framework.org"><span class="url">https://www.django-rest-framework.org</span></a>) allows you to expand the functionality and generate self-documented RESTful interfaces easily.</p>&#13;&#13;
      <p class="Tip--PACKT-">We will look at the Django REST framework later in the chapter.</p>&#13;&#13;
    </div>&#13;&#13;
    <p class="normal">Django is a powerful and comprehensive framework and has some assumptions on how things are supposed to run, such as using the Django ORM or using its templating system. While <a id="_idIndexMarker429"/>doing so is "swimming with the current," it's definitely possible to take other approaches and tailor any part of the system. This can involve elements like not using templates, using a different templating system, using a different ORM library like SQLAlchemy, and adding extra libraries to connect to different databases, including ones not supported natively by Django (like NoSQL databases). Do not let the constraints of the system limit you from achieving your goals.</p>&#13;&#13;
    <div class="packt_tip">&#13;&#13;
      <p class="Tip--PACKT-">Django is opinionated in the way that it presents a lot of elements working together with certain assumptions. They are tightly related to each other. If that's an impediment, for example, because you need to use wildly different tools, a good <a id="_idIndexMarker430"/>alternative can be Pyramid (<a href="https://trypyramid.com"><span class="url">https://trypyramid.com</span></a>), a Python web framework designed to build your own combination of tools to ensure flexibility. </p>&#13;&#13;
    </div>&#13;&#13;
    <h2 id="_idParaDest-127" class="title">Routing a request towards a View</h2>&#13;&#13;
    <p class="normal">Django provides <a id="_idIndexMarker431"/>the tools to perform the proper routing from a particular URL to a specific View.</p>&#13;&#13;
    <p class="normal">This is done in the <code class="Code-In-Text--PACKT-">urls.py</code> file. Let's see an example.</p>&#13;&#13;
    <pre class="programlisting code"><code class="hljs-code"><span class="hljs-keyword">from</span> django.urls <span class="hljs-keyword">import</span> path&#13;&#13;
<span class="hljs-keyword">from</span> views <span class="hljs-keyword">import</span> first_view, second_view&#13;&#13;
urlpatterns = [&#13;&#13;
    path('example/<span class="hljs-string">', first_view)</span>&#13;&#13;
<span class="hljs-string">    path('example/&lt;int:parameter&gt;/&lt;slug:other_parameter&gt;'</span>, second_view)&#13;&#13;
]&#13;&#13;
</code></pre>&#13;&#13;
    <p class="normal">The required Views (that are typically declared as functions) are imported from whatever module they are currently in into the file.</p>&#13;&#13;
    <p class="normal">The <code class="Code-In-Text--PACKT-">urlpatterns</code> list defines an ordered list of URL patterns that will be tested against an input URL.</p>&#13;&#13;
    <p class="normal">The first <code class="Code-In-Text--PACKT-">path</code> definition is very straightforward. If the URL is <code class="Code-In-Text--PACKT-">example/</code>, it will call the View <code class="Code-In-Text--PACKT-">first_view</code>. </p>&#13;&#13;
    <p class="normal">The second <code class="Code-In-Text--PACKT-">path</code> definition contains definitions to capture parameters. It will transform the defined parameters properly and pass them over to the view. For example, the URL <code class="Code-In-Text--PACKT-">example/15/example-slug</code> will create these parameters:</p>&#13;&#13;
    <ul>&#13;&#13;
      <li class="bullet"><code class="Code-In-Text--PACKT-">parameter=int(15)</code></li>&#13;&#13;
      <li class="bullet"><code class="Code-In-Text--PACKT-">other_parameter=str("example-slug")</code></li>&#13;&#13;
    </ul>&#13;&#13;
    <p class="normal">There are <a id="_idIndexMarker432"/>different types of parameters that can be configured. <code class="Code-In-Text--PACKT-">int</code> is self-explanatory, but <code class="Code-In-Text--PACKT-">slug</code> is a limited string that will include only alphanumeric, <code class="Code-In-Text--PACKT-">_</code> (underscore), and <code class="Code-In-Text--PACKT-">–</code> (dash) symbols, excluding characters like <code class="Code-In-Text--PACKT-">.</code> or other symbols. </p>&#13;&#13;
    <div class="packt_tip">&#13;&#13;
      <p class="Tip--PACKT-">There are more types available. There's also a <code class="Code-In-Text--PACKT-">str</code> type that can be too broad. The character <code class="Code-In-Text--PACKT-">/</code> is understood as special in URLs and it's always excluded. This allows for easy separation of parameters. The type <code class="Code-In-Text--PACKT-">slug</code> should cover more typical use cases for parameters inside a URL.</p>&#13;&#13;
    </div>&#13;&#13;
    <p class="normal">Another option is to generate the paths directly as regex. If you are familiar with the regex format, this can be very powerful and allow a great deal of control. At the same time, regexes can grow really complex and difficult to read and use. </p>&#13;&#13;
    <pre class="programlisting code"><code class="hljs-code"><span class="hljs-keyword">from</span> django.urls <span class="hljs-keyword">import</span> re_path&#13;&#13;
urlpatterns = [&#13;&#13;
    re_path('example/(?P&lt;parameter&gt;\d+)/<span class="hljs-string">', view)</span>&#13;&#13;
<span class="hljs-string">]</span>&#13;&#13;
</code></pre>&#13;&#13;
    <div class="note">&#13;&#13;
      <p class="Information-Box--PACKT-">This was the only option available previously in Django. As you can see for the example, equivalent to <code class="Code-In-Text--PACKT-">example/&lt;int:parameter&gt;/</code>, the new path-defined URL patterns are easier to read and to deal with.</p>&#13;&#13;
    </div>&#13;&#13;
    <p class="normal">An intermediate option is to define types to be sure that they match specific values, for example, creating a type to match only months like <code class="Code-In-Text--PACKT-">Apr</code> or <code class="Code-In-Text--PACKT-">Jun</code>. If the type is defined in this way, an incorrect pattern like <code class="Code-In-Text--PACKT-">Jen</code> will return a 404 automatically. Internally, this will require <a id="_idIndexMarker433"/>writing a regex to match the proper string anyway, but afterwards, it can transform the value. For example, to transform the month <code class="Code-In-Text--PACKT-">Jun</code> to either the number 1, normalize it as <code class="Code-In-Text--PACKT-">JUNE</code>, or any other value that makes sense later. The complexity of the regex will be abstracted by the type.</p>&#13;&#13;
    <p class="normal">Keep in mind that the patterns are checked in order. That means that, if a pattern may fulfil two paths, it will select the first one. This may have unintended effects when a previous path "hides" the next one, so the least restrictive patterns should be positioned later.</p>&#13;&#13;
    <p class="normal">For example:</p>&#13;&#13;
    <pre class="programlisting code"><code class="hljs-code"><span class="hljs-keyword">from</span> django.urls <span class="hljs-keyword">import</span> path&#13;&#13;
urlpatterns = [&#13;&#13;
    path(<span class="hljs-string">'example/&lt;str:parameter&gt;/'</span>, first_view)&#13;&#13;
<span class="hljs-string">    </span>path(<span class="hljs-string">'example/&lt;int:parameter&gt;/'</span>, second_view)&#13;&#13;
]&#13;&#13;
</code></pre>&#13;&#13;
    <p class="normal">No URL will ever get passed to <code class="Code-In-Text--PACKT-">second_view</code>, as any parameter that is an integer will be captured first. </p>&#13;&#13;
    <div class="note">&#13;&#13;
      <p class="Information-Box--PACKT-">This kind of error is usually possible in most URL routers in web frameworks, as most of them are pattern-based. Keep an eye in case it affects your code.</p>&#13;&#13;
    </div>&#13;&#13;
    <p class="normal">The interesting stuff happens inside of the View. </p>&#13;&#13;
    <h2 id="_idParaDest-128" class="title">The View</h2>&#13;&#13;
    <p class="normal">The View is the central element of Django. It receives the request information, plus any parameters <a id="_idIndexMarker434"/>from the URL, and processes it. The View normally will use the different Models to compose the information, and finally returns a response.</p>&#13;&#13;
    <p class="normal">The View is in charge of deciding if there's any change in behavior based on the request. Note that the routing towards the View only distinguishes between different paths, but other distinctions like HTTP method or parameters will need to be differentiated here.</p>&#13;&#13;
    <p class="normal">This makes it a very common pattern to differentiate between POST and GET requests to the same URL. A common usage in web pages is to make a form page to display the empty form, and then POST to the same URL. For example, in a form with a single parameter, the structure will be similar to the following example: </p>&#13;&#13;
    <div class="note">&#13;&#13;
      <p class="Information-Box--PACKT-">This is intended as pseudocode to not complicate it.</p>&#13;&#13;
    </div>&#13;&#13;
    <pre class="programlisting code"><code class="hljs-code"><span class="hljs-keyword">def</span><span class="hljs-function"> </span><span class="hljs-title">example_view</span><span class="hljs-function">(</span><span class="hljs-params">request</span><span class="hljs-function">):</span>&#13;&#13;
    <span class="hljs-comment"># create an empty form</span>&#13;&#13;
    form_content = Form()&#13;&#13;
    <span class="hljs-keyword">if</span> request.method == 'POST':&#13;&#13;
        <span class="hljs-comment"># Obtain the value</span>&#13;&#13;
           value = request.POST['my-value']&#13;&#13;
           <span class="hljs-keyword">if</span> validate(value):&#13;&#13;
               <span class="hljs-comment"># Perform actions based on the value</span>&#13;&#13;
            do_stuff()&#13;&#13;
            content = 'Thanks <span class="hljs-keyword">for</span> your answer'&#13;&#13;
        <span class="hljs-keyword">else</span>:&#13;&#13;
            content = 'Sorry, this <span class="hljs-keyword">is</span> incorrect' + form_content&#13;&#13;
    <span class="hljs-keyword">elif</span> request.method == 'GET':&#13;&#13;
        content = form_content&#13;&#13;
    <span class="hljs-keyword">return</span> render(content)&#13;&#13;
    &#13;&#13;
</code></pre>&#13;&#13;
    <p class="normal">While it's true that Django includes a form system that simplifies the validation and reporting of forms, this structure can grow legs and become tiresome. In particular, the multiple nested <code class="Code-In-Text--PACKT-">if</code> blocks are confusing.</p>&#13;&#13;
    <div class="packt_tip">&#13;&#13;
      <p class="Tip--PACKT-">We won't go into details with the form system in Django. It is quite complete and allows you to render rich HTML forms that will validate and show possible errors to the user. Read the Django documentation to know more.</p>&#13;&#13;
    </div>&#13;&#13;
    <p class="normal">Instead <a id="_idIndexMarker435"/>of that, dividing the View with two different subfunctions may be clearer. </p>&#13;&#13;
    <pre class="programlisting code"><code class="hljs-code"><span class="hljs-keyword">def</span><span class="hljs-function"> </span><span class="hljs-title">display_form</span><span class="hljs-function">(</span><span class="hljs-params">form_content, message=''</span><span class="hljs-function">):</span>&#13;&#13;
    content = message + form_content&#13;&#13;
    <span class="hljs-keyword">return</span> content&#13;&#13;
<span class="hljs-keyword">def</span><span class="hljs-function"> </span><span class="hljs-title">process_data</span><span class="hljs-function">(</span><span class="hljs-params">parameters, form_content</span><span class="hljs-function">):</span>&#13;&#13;
    <span class="hljs-comment"># Obtain the value</span>&#13;&#13;
       <span class="hljs-keyword">if</span> validate(parameters):&#13;&#13;
           <span class="hljs-comment"># Perform actions based on the value</span>&#13;&#13;
        do_stuff()&#13;&#13;
        content = 'Thanks <span class="hljs-keyword">for</span> your answer'&#13;&#13;
    <span class="hljs-keyword">else</span>:&#13;&#13;
        message = 'Sorry, this <span class="hljs-keyword">is</span> incorrect'&#13;&#13;
        content = display_form(form_content , message)&#13;&#13;
    <span class="hljs-keyword">return</span> content&#13;&#13;
<span class="hljs-keyword">def</span><span class="hljs-function"> </span><span class="hljs-title">example_view</span><span class="hljs-function">(</span><span class="hljs-params">request</span><span class="hljs-function">):</span>&#13;&#13;
    <span class="hljs-comment"># create an empty form</span>&#13;&#13;
    form_content = Form()&#13;&#13;
    <span class="hljs-keyword">if</span> request.method == 'POST':&#13;&#13;
        content = process_data(request.POST, form_content)&#13;&#13;
    <span class="hljs-keyword">elif</span> request.method == 'GET':&#13;&#13;
        content = display_form(form_content)&#13;&#13;
    <span class="hljs-keyword">return</span> render(content)&#13;&#13;
</code></pre>&#13;&#13;
    <p class="normal">The challenge here is to preserve the fact that, when the parameters are incorrect, the form needs to be rendered again. By the principle of <strong class="keyword">DRY</strong> (<strong class="keyword">Don't Repeat Yourself</strong>), we should <a id="_idIndexMarker436"/>try to locate that code in a single place. Here, in the <code class="Code-In-Text--PACKT-">display_form</code> function. We allow some customization of the message to add some extra content, in case the data is incorrect.</p>&#13;&#13;
    <div class="note">&#13;&#13;
      <p class="Information-Box--PACKT-">In a more complete example, the form will be tweaked to show the specific errors. Django forms are able to do this automatically. The process will be to create a form with the parameters from the request, validate it, and print it. It automatically will produce the proper error messages, based on the type of each of the fields, including custom types. Again, refer to Django's documentation for more information.</p>&#13;&#13;
    </div>&#13;&#13;
    <p class="normal">Note that the <code class="Code-In-Text--PACKT-">display_form</code> function gets called both from <code class="Code-In-Text--PACKT-">example_view</code> and also inside <code class="Code-In-Text--PACKT-">process_data</code>.</p>&#13;&#13;
    <h3 id="_idParaDest-129" class="title">HttpRequest</h3>&#13;&#13;
    <p class="normal">The key element <a id="_idIndexMarker437"/>for passing information is the <code class="Code-In-Text--PACKT-">request</code> parameter. This object's type is <code class="Code-In-Text--PACKT-">HttpRequest</code>, and contains all the information that the user is <a id="_idIndexMarker438"/>sending in the request.</p>&#13;&#13;
    <p class="normal">Its most <a id="_idIndexMarker439"/>important attributes are:</p>&#13;&#13;
    <ul>&#13;&#13;
      <li class="bullet"><code class="Code-In-Text--PACKT-">method</code>, which contains the used HTTP method. </li>&#13;&#13;
      <li class="bullet">If the method is <code class="Code-In-Text--PACKT-">GET</code>, it will contain a <code class="Code-In-Text--PACKT-">GET</code> attribute with a <code class="Code-In-Text--PACKT-">QueryDict</code> (a dictionary subclass) containing all the query parameters in the request. For example, a request such as:&#13;&#13;
        <pre class="programlisting code"><code class="hljs-code">/example?param1=1&amp;param2=text&amp;param1=2&#13;&#13;
</code></pre>&#13;&#13;
        <p class="bullet-para">Will produce a <code class="Code-In-Text--PACKT-">request.GET</code> value like this:</p>&#13;&#13;
        <pre class="programlisting con"><code class="hljs-con">&lt;QueryDict: {'param1': ['1', '2'], 'param2': ['text']}&gt;&#13;&#13;
</code></pre>&#13;&#13;
        <p class="bullet-para">Note that the parameters are stored internally as a list of values, because query parameters accept multiple parameters with the same key, though that's not usually the case. They'll return a unique value when queried anyway:</p>&#13;&#13;
        <pre class="programlisting con"><code class="hljs-con"><span class="hljs-con-meta">&gt;&gt;&gt;</span> <span class="python">request.GET['param1']</span>&#13;&#13;
2&#13;&#13;
<span class="hljs-con-meta">&gt;&gt;&gt;</span> <span class="python">request.GET['param2']</span>&#13;&#13;
text&#13;&#13;
</code></pre>&#13;&#13;
      </li>&#13;&#13;
    </ul>&#13;&#13;
    <div class="note">&#13;&#13;
      <p class="Information-Box--PACKT-">They'll be all reported in order, with the latest value being returned. If you need to access all values, use the method <code class="Code-In-Text--PACKT-">getlist</code>:</p>&#13;&#13;
      <pre class="programlisting con"><code class="hljs-con">&gt;&gt;&gt; request.GET.getlist('param1')&#13;&#13;
['1', '2']&#13;&#13;
</code></pre>&#13;&#13;
    </div>&#13;&#13;
    <p class="bullet-para">All the parameters are defined as strings, needing to be converted to other types if necessary.</p>&#13;&#13;
    <ul>&#13;&#13;
      <li class="bullet">If the method is <code class="Code-In-Text--PACKT-">POST</code>, an analogous <code class="Code-In-Text--PACKT-">POST</code> attribute will be created. In this case, it will be <a id="_idIndexMarker440"/>filled first by the body of the request, to allow encoding form posts. If the body is empty, it will fill the values with query parameters like the <code class="Code-In-Text--PACKT-">GET</code> case.</li>&#13;&#13;
    </ul>&#13;&#13;
    <div class="note">&#13;&#13;
      <p class="Information-Box--PACKT-">POST multiple values will commonly be used in multiple selection forms.</p>&#13;&#13;
    </div>&#13;&#13;
    <ul>&#13;&#13;
      <li class="bullet"><code class="Code-In-Text--PACKT-">content_type</code> with the MIME type of the request.</li>&#13;&#13;
      <li class="bullet"><code class="Code-In-Text--PACKT-">FILES</code>, including data for any uploaded files in the request, for certain <code class="Code-In-Text--PACKT-">POST</code> requests.</li>&#13;&#13;
      <li class="bullet"><code class="Code-In-Text--PACKT-">headers</code>, a dictionary containing all the HTTP headers of the request and headers. Another dictionary, <code class="Code-In-Text--PACKT-">META</code>, contains extra information from headers that may be introduced and are not necessarily HTTP-based, like <code class="Code-In-Text--PACKT-">SERVER_NAME</code>. In general, it is better to obtain information from the <code class="Code-In-Text--PACKT-">headers</code> attribute.</li>&#13;&#13;
    </ul>&#13;&#13;
    <p class="normal">There are also some useful methods to retrieve information from the request, for example:</p>&#13;&#13;
    <ul>&#13;&#13;
      <li class="bullet"><code class="Code-In-Text--PACKT-">.get_host()</code> to obtain the name of the host. It will interpret the different headers to determine the proper host, so it's more reliable than directly reading the <code class="Code-In-Text--PACKT-">HTTP_HOST</code> header.</li>&#13;&#13;
      <li class="bullet"><code class="Code-In-Text--PACKT-">.build_absolute_uri(location)</code> to generate a full URI, including the host, port, etc. This method <a id="_idIndexMarker441"/>is useful to create full references to return them.</li>&#13;&#13;
    </ul>&#13;&#13;
    <p class="normal">These attributes <a id="_idIndexMarker442"/>and methods, combined with the parameters described in the request, allow you to retrieve all the relevant information necessary for processing the request and call the required Models.</p>&#13;&#13;
    <h3 id="_idParaDest-130" class="title">HttpResponse</h3>&#13;&#13;
    <p class="normal">The <code class="Code-In-Text--PACKT-">HttpResponse</code> class <a id="_idIndexMarker443"/>handles the information being returned by <a id="_idIndexMarker444"/>the View to the web server. The return from a View function needs to be an <code class="Code-In-Text--PACKT-">HttpResponse</code> object.</p>&#13;&#13;
    <pre class="programlisting code"><code class="hljs-code"><span class="hljs-keyword">from</span> django.http <span class="hljs-keyword">import</span> HttpResponse&#13;&#13;
<span class="hljs-keyword">def</span><span class="hljs-function"> </span><span class="hljs-title">my_view</span><span class="hljs-function">(</span><span class="hljs-params">request</span><span class="hljs-function">):</span>&#13;&#13;
    <span class="hljs-keyword">return</span> HttpResponse(content="example text", status_code=<span class="hljs-number">200</span>)&#13;&#13;
</code></pre>&#13;&#13;
    <p class="normal">The response has a default <code class="Code-In-Text--PACKT-">status_code</code> of 200 if it's not specified.</p>&#13;&#13;
    <p class="normal">If the response needs to be written in several steps, it can be added through the <code class="Code-In-Text--PACKT-">.write()</code> method.</p>&#13;&#13;
    <pre class="programlisting code"><code class="hljs-code">response = HttpResponse()&#13;&#13;
response.write('First part of the body')&#13;&#13;
response.write('Second part of the body')&#13;&#13;
</code></pre>&#13;&#13;
    <p class="normal">The body can also be composed as an iterable.</p>&#13;&#13;
    <pre class="programlisting code"><code class="hljs-code">body= ['Multiple ', 'data ', 'that ', 'will ', 'be ', 'composed']&#13;&#13;
response = HttpResponse(content=body)&#13;&#13;
</code></pre>&#13;&#13;
    <div class="note">&#13;&#13;
      <p class="Information-Box--PACKT-">All responses from <code class="Code-In-Text--PACKT-">HttpResponse</code> will be composed completely before being returned. It is possible to return responses in a streaming way, meaning that the status code will be returned first and chunks of the body will be sent over time. To do that, there's another class called <code class="Code-In-Text--PACKT-">StreamingHttpResponse</code> that will work in that way, and can be useful for sending big responses over time.</p>&#13;&#13;
    </div>&#13;&#13;
    <p class="normal">Instead of using integers to define the status code, it's better to use the defined constants available in Python, for example:</p>&#13;&#13;
    <pre class="programlisting code"><code class="hljs-code"><span class="hljs-keyword">from</span> django.http <span class="hljs-keyword">import</span> HttpResponse&#13;&#13;
<span class="hljs-keyword">from</span> http <span class="hljs-keyword">import</span> HTTPStatus&#13;&#13;
<span class="hljs-keyword">def</span><span class="hljs-function"> </span><span class="hljs-title">my_view</span><span class="hljs-function">(</span><span class="hljs-params">request</span><span class="hljs-function">):</span>&#13;&#13;
    <span class="hljs-keyword">return</span> HttpResponse(content="example text", status_code=HTTPStatus.OK)&#13;&#13;
</code></pre>&#13;&#13;
    <p class="normal">This makes the usage of each status code more explicit and helps increase the readability of the code, making them explicitly <code class="Code-In-Text--PACKT-">HTTPStatus</code> objects.</p>&#13;&#13;
    <div class="packt_tip">&#13;&#13;
      <p class="Tip--PACKT-">You can <a id="_idIndexMarker445"/>see all the status codes defined in Python here: <a href="https://docs.python.org/3/library/http.html"><span class="url">https://docs.python.org/3/library/http.html</span></a>. Note the name is their standard HTTP status code name, as defined in several RFC documents, for example, <code class="Code-In-Text--PACKT-">201 CREATED</code>, <code class="Code-In-Text--PACKT-">404 NOT FOUND</code>, <code class="Code-In-Text--PACKT-">502 BAD GATEWAY</code>, etc.</p>&#13;&#13;
    </div>&#13;&#13;
    <p class="normal">The <code class="Code-In-Text--PACKT-">content</code> parameter defines the body of the request. It can be described as a Python string, but it <a id="_idIndexMarker446"/>also accepts binary data, if the response is not plain text. If that's the case, a <code class="Code-In-Text--PACKT-">content_type</code> parameter should be added to adequately label the <a id="_idIndexMarker447"/>data with the proper MIME type.</p>&#13;&#13;
    <pre class="programlisting code"><code class="hljs-code">HttpResponse(content=img_data, content_type="image/png")&#13;&#13;
</code></pre>&#13;&#13;
    <div class="note">&#13;&#13;
      <p class="Information-Box--PACKT-">It is very important that the returned <code class="Code-In-Text--PACKT-">Content-Type</code> matches the format of the body. This will make any other tool, like a browser, properly interpret the content adequately.</p>&#13;&#13;
    </div>&#13;&#13;
    <p class="normal">Headers can also be added to the response using the <code class="Code-In-Text--PACKT-">headers</code> parameter.</p>&#13;&#13;
    <pre class="programlisting code"><code class="hljs-code">headers = {&#13;&#13;
    'Content-Type': 'application/pdf',&#13;&#13;
    'Content-Disposition': 'attachment; filename=<span class="hljs-string">"report.pdf"</span>',&#13;&#13;
}&#13;&#13;
response = HttpResponse(content=img_data, headers=header)&#13;&#13;
</code></pre>&#13;&#13;
    <div class="note">&#13;&#13;
      <p class="Information-Box--PACKT-"><code class="Code-In-Text--PACKT-">Content-Disposition</code> can be used to label the response as an attachment that should be downloaded to the hard drive. </p>&#13;&#13;
      <p class="Information-Box--PACKT-">Also, we can set up the <code class="Code-In-Text--PACKT-">Content-Type</code> header either manually through the <code class="Code-In-Text--PACKT-">headers</code> parameter or through the <code class="Code-In-Text--PACKT-">content_type</code> parameter directly.</p>&#13;&#13;
    </div>&#13;&#13;
    <p class="normal">Headers are also stored in the response when it is accessed as a dictionary:</p>&#13;&#13;
    <pre class="programlisting code"><code class="hljs-code">response['Content-Disposition'] = 'attachment; filename=<span class="hljs-string">"myreport.pdf"</span>'&#13;&#13;
<span class="hljs-keyword">del</span> response['Content-Disposition']&#13;&#13;
</code></pre>&#13;&#13;
    <p class="normal">There are <a id="_idIndexMarker448"/>specialized subclasses for common cases. Instead of using <a id="_idIndexMarker449"/>a generic <code class="Code-In-Text--PACKT-">HttpResponse</code>, for JSON encoded requests, it's better to use <code class="Code-In-Text--PACKT-">JsonResponse</code>, which will correctly fill the Content-Type and encode it:</p>&#13;&#13;
    <pre class="programlisting code"><code class="hljs-code"><span class="hljs-keyword">from</span> django.http <span class="hljs-keyword">import</span> JsonResponse&#13;&#13;
response = JsonResponse({'example': <span class="hljs-number">1</span>, 'key': 'body'})&#13;&#13;
</code></pre>&#13;&#13;
    <p class="normal">In the same style, the <code class="Code-In-Text--PACKT-">FileResponse</code> allows you to download a file directly, providing a file-like object and directly filling the headers and content type, including if it needs to be an attachment</p>&#13;&#13;
    <pre class="programlisting code"><code class="hljs-code"><span class="hljs-keyword">from</span> django.http <span class="hljs-keyword">import</span> FileResponse&#13;&#13;
file_object = <span class="hljs-built_in">open</span>('report.pdf', 'rb')&#13;&#13;
response = FileResponse(file_object, is_attachment=<span class="hljs-literal">True</span>)&#13;&#13;
</code></pre>&#13;&#13;
    <p class="normal">The response can also be created by rendering a template. This is the usual way of doing so for HTML interfaces, which was what Django was originally designed for. The <code class="Code-In-Text--PACKT-">render</code> function will automatically return an <code class="Code-In-Text--PACKT-">HttpResponse</code> object. </p>&#13;&#13;
    <pre class="programlisting code"><code class="hljs-code"><span class="hljs-keyword">from</span> django.shortcuts <span class="hljs-keyword">import</span> render&#13;&#13;
<span class="hljs-keyword">def</span><span class="hljs-function"> </span><span class="hljs-title">my_view</span><span class="hljs-function">(</span><span class="hljs-params">request</span><span class="hljs-function">):</span>&#13;&#13;
    ...&#13;&#13;
    <span class="hljs-keyword">return</span> render(request, 'mytemplate.html')&#13;&#13;
</code></pre>&#13;&#13;
    <h2 id="_idParaDest-131" class="title">Middleware</h2>&#13;&#13;
    <p class="normal">A key concept in WSGI requests is that they can be chained. This means that a request can go <a id="_idIndexMarker450"/>through different stages, wrapping a new request around the orinal at each stage, which allows you to add functionality.</p>&#13;&#13;
    <p class="normal">This leads to the concept of middleware. Middleware improves the handling between systems by simplifying handling several aspects of the request, adding functionality, or simplifying their usage.</p>&#13;&#13;
    <div class="packt_tip">&#13;&#13;
      <p class="Tip--PACKT-">Middleware is a word that can refer to different concepts depending on the context of its usage. When used in an HTTP server environment, it typically refers to plugins that enhance or simplify the handling of requests.</p>&#13;&#13;
    </div>&#13;&#13;
    <p class="normal">A typical example of middleware is logging each received request in a standard manner. The middleware will receive the request, produce a log, and hand the request to the next level.</p>&#13;&#13;
    <p class="normal">Another example is managing whether the user is logged or not. There's a standard Django middleware that will detect any session stored in cookies and will search in the database for the associated user. It will then fill the <code class="Code-In-Text--PACKT-">request.user</code> object with the proper user.</p>&#13;&#13;
    <p class="normal">Another example, enabled by default in Django, checks the CSRF token on <code class="Code-In-Text--PACKT-">POST</code> requests. If the CSRF token is not present or it's incorrect, the request will be immediately intercepted and it will return <code class="Code-In-Text--PACKT-">403 FORBIDDEN</code>, before accessing the View code.</p>&#13;&#13;
    <div class="note">&#13;&#13;
      <p class="Information-Box--PACKT-">We introduced the idea of CSRF and tokens in <em class="chapterRef">Chapter 2</em>.</p>&#13;&#13;
    </div>&#13;&#13;
    <p class="normal">Middleware can access the request both when it's received and the response when it's ready, so they can work on either side or both sides in coordination:</p>&#13;&#13;
    <ul>&#13;&#13;
      <li class="bullet">Logging middleware that generates a log with the path and method of the received request can generate it before the request is sent to the View.</li>&#13;&#13;
      <li class="bullet">Logging middleware that also logs the status code needs to have the information of the status code, so it will need to do it once the View is finished and the response is ready.</li>&#13;&#13;
      <li class="bullet">Logging middleware that logs the time it took to generate the request will need to first register the time when the request was received, and what time it is when the response is ready, to log the difference. This requires code both before and after the View.</li>&#13;&#13;
    </ul>&#13;&#13;
    <p class="normal">Middleware <a id="_idIndexMarker451"/>is defined in this way:</p>&#13;&#13;
    <pre class="programlisting code"><code class="hljs-code"><span class="hljs-keyword">def</span><span class="hljs-function"> </span><span class="hljs-title">example_middleware</span><span class="hljs-function">(</span><span class="hljs-params">get_response</span><span class="hljs-function">):</span>&#13;&#13;
    <span class="hljs-comment"># The example_middleware wraps the actual middleware</span>&#13;&#13;
    <span class="hljs-keyword">def</span><span class="hljs-function"> </span><span class="hljs-title">middleware</span><span class="hljs-function">(</span><span class="hljs-params">request</span><span class="hljs-function">):</span>&#13;&#13;
        <span class="hljs-comment"># Any code to be executed before the view</span>&#13;&#13;
        <span class="hljs-comment"># should be located here</span>&#13;&#13;
        response = get_response(request)&#13;&#13;
        <span class="hljs-comment"># Code to be executed after the view</span>&#13;&#13;
        <span class="hljs-comment"># should be located here</span>&#13;&#13;
        <span class="hljs-keyword">return</span> response&#13;&#13;
    <span class="hljs-keyword">return</span> middleware&#13;&#13;
</code></pre>&#13;&#13;
    <p class="normal">The structure to return a function allows the initialization of chained elements. The input <code class="Code-In-Text--PACKT-">get_reponse</code> can be another middleware function or could be the final view. This allows this kind of structure:</p>&#13;&#13;
    <pre class="programlisting code"><code class="hljs-code">chain = middleware_one(middleware_two(my_view))&#13;&#13;
final_response = chain(request)&#13;&#13;
</code></pre>&#13;&#13;
    <p class="normal">The order of the middleware is also important. For example, logging should happen before any middleware that can stop the request, as if done in reverse order, any rejected request (for example, not adding a proper CSRF) won't be logged.</p>&#13;&#13;
    <div class="packt_tip">&#13;&#13;
      <p class="Tip--PACKT-">Generally, middleware functions have some recommendations on where they should be located. Some are more sensitive to their position than others. Check the documentation for each one. </p>&#13;&#13;
    </div>&#13;&#13;
    <p class="normal">Middleware can be easily added, either custom-made or by using third-party options. There are a <a id="_idIndexMarker452"/>lot of packages that create their own middleware functions for useful features in Django. When considering adding a new feature, spend some time searching to see if there's something already available.</p>&#13;&#13;
    <h2 id="_idParaDest-132" class="title">Django REST framework</h2>&#13;&#13;
    <p class="normal">While Django was designed originally to support HTML interfaces, its functionality has been expanded, both as new features inside the Django project itself, as well as other external <a id="_idIndexMarker453"/>projects that enhance Django.</p>&#13;&#13;
    <p class="normal">One of particular interest is Django REST framework. We will use it as an example of the available possibilities.</p>&#13;&#13;
    <div class="note">&#13;&#13;
      <p class="Information-Box--PACKT-">Django REST framework is not only a popular and powerful module. It also uses a lot of conventions that are common across REST frameworks in multiple programming languages. </p>&#13;&#13;
    </div>&#13;&#13;
    <p class="normal">For our example, we will implement some of the endpoints that we defined in <em class="chapterRef">Chapter 2</em>. We will use the following endpoints, to follow the whole lifecycle of a micropost.</p>&#13;&#13;
    <table id="table002-3" class="No-Table-Style _idGenTablePara-1">&#13;&#13;
      <colgroup>&#13;&#13;
        <col/>&#13;&#13;
        <col/>&#13;&#13;
        <col/>&#13;&#13;
      </colgroup>&#13;&#13;
      <tbody>&#13;&#13;
        <tr class="No-Table-Style">&#13;&#13;
          <td class="No-Table-Style">&#13;&#13;
            <p class="Table-Column-Heading--PACKT-"><span class="python">Endpoint</span></p>&#13;&#13;
          </td>&#13;&#13;
          <td class="No-Table-Style">&#13;&#13;
            <p class="Table-Column-Heading--PACKT-"><span class="python">Method</span></p>&#13;&#13;
          </td>&#13;&#13;
          <td class="No-Table-Style">&#13;&#13;
            <p class="Table-Column-Heading--PACKT-"><span class="python">Action</span></p>&#13;&#13;
          </td>&#13;&#13;
        </tr>&#13;&#13;
        <tr class="No-Table-Style">&#13;&#13;
          <td class="No-Table-Style">&#13;&#13;
            <p class="Table-Column-Content--PACKT-"><code class="Code-In-Text--PACKT-">/api/users/&lt;username&gt;/collection</code></p>&#13;&#13;
          </td>&#13;&#13;
          <td class="No-Table-Style">&#13;&#13;
            <p class="Table-Column-Content--PACKT-"><code class="Code-In-Text--PACKT-">GET </code></p>&#13;&#13;
          </td>&#13;&#13;
          <td class="No-Table-Style">&#13;&#13;
            <p class="Table-Column-Content--PACKT-"><span class="python">Retrieve all the microposts from a user</span></p>&#13;&#13;
          </td>&#13;&#13;
        </tr>&#13;&#13;
        <tr class="No-Table-Style">&#13;&#13;
          <td class="No-Table-Style">&#13;&#13;
            <p class="Table-Column-Content--PACKT-"><code class="Code-In-Text--PACKT-">/api/users/&lt;username&gt;/collection</code></p>&#13;&#13;
          </td>&#13;&#13;
          <td class="No-Table-Style">&#13;&#13;
            <p class="Table-Column-Content--PACKT-"><code class="Code-In-Text--PACKT-">POST</code></p>&#13;&#13;
          </td>&#13;&#13;
          <td class="No-Table-Style">&#13;&#13;
            <p class="Table-Column-Content--PACKT-"><span class="python">Create a new micropost for the user</span></p>&#13;&#13;
          </td>&#13;&#13;
        </tr>&#13;&#13;
        <tr class="No-Table-Style">&#13;&#13;
          <td class="No-Table-Style">&#13;&#13;
            <p class="Table-Column-Content--PACKT-"><code class="Code-In-Text--PACKT-">/api/users/&lt;username&gt;/collection/&lt;micropost_id&gt;</code></p>&#13;&#13;
          </td>&#13;&#13;
          <td class="No-Table-Style">&#13;&#13;
            <p class="Table-Column-Content--PACKT-"><code class="Code-In-Text--PACKT-">GET</code></p>&#13;&#13;
          </td>&#13;&#13;
          <td class="No-Table-Style">&#13;&#13;
            <p class="Table-Column-Content--PACKT-"><span class="python">Retrieve a single micropost</span></p>&#13;&#13;
          </td>&#13;&#13;
        </tr>&#13;&#13;
        <tr class="No-Table-Style">&#13;&#13;
          <td class="No-Table-Style">&#13;&#13;
            <p class="Table-Column-Content--PACKT-"><code class="Code-In-Text--PACKT-">/api/users/&lt;username&gt;/collection/&lt;micropost_id&gt;</code></p>&#13;&#13;
          </td>&#13;&#13;
          <td class="No-Table-Style">&#13;&#13;
            <p class="Table-Column-Content--PACKT-"><code class="Code-In-Text--PACKT-">PUT, PATCH</code></p>&#13;&#13;
          </td>&#13;&#13;
          <td class="No-Table-Style">&#13;&#13;
            <p class="Table-Column-Content--PACKT-"><span class="python">Update a micropost</span></p>&#13;&#13;
          </td>&#13;&#13;
        </tr>&#13;&#13;
        <tr class="No-Table-Style">&#13;&#13;
          <td class="No-Table-Style">&#13;&#13;
            <p class="Table-Column-Content--PACKT-"><code class="Code-In-Text--PACKT-">/api/users/&lt;username&gt;/collection/&lt;micropost_id&gt;</code></p>&#13;&#13;
          </td>&#13;&#13;
          <td class="No-Table-Style">&#13;&#13;
            <p class="Table-Column-Content--PACKT-"><code class="Code-In-Text--PACKT-">DELETE</code></p>&#13;&#13;
          </td>&#13;&#13;
          <td class="No-Table-Style">&#13;&#13;
            <p class="Table-Column-Content--PACKT-"><span class="python">Delete a micropost</span></p>&#13;&#13;
          </td>&#13;&#13;
        </tr>&#13;&#13;
      </tbody>&#13;&#13;
    </table>&#13;&#13;
    <p class="normal">The basic principle behind Django REST framework is to create different classes that encapsulate the exposed resources as URLs. </p>&#13;&#13;
    <p class="normal">The extra <a id="_idIndexMarker454"/>concept is that objects will be transformed from an internal Model into an external JSON object and vice versa through a <em class="italic">serializer</em>. The serializer will handle the creation and validate that the external data is correct.</p>&#13;&#13;
    <div class="packt_tip">&#13;&#13;
      <p class="Tip--PACKT-">A serializer can't only transform a Model object, but any kind of internal Python class. You can use them to create "virtual objects" that can pull information from multiple Models.</p>&#13;&#13;
      <p class="Tip--PACKT-">A peculiarity of Django REST framework is that the serializer is the same for input and output. In other frameworks, there are different modules for the way in and out.</p>&#13;&#13;
    </div>&#13;&#13;
    <h3 id="_idParaDest-133" class="title">Models</h3>&#13;&#13;
    <p class="normal">We first <a id="_idIndexMarker455"/>need to introduce the models to store the information. We will use a <code class="Code-In-Text--PACKT-">Usr</code> Model for the users and a <code class="Code-In-Text--PACKT-">Micropost</code> Model.</p>&#13;&#13;
    <pre class="programlisting code"><code class="hljs-code"><span class="hljs-keyword">from</span> django.db <span class="hljs-keyword">import</span> models&#13;&#13;
<span class="hljs-keyword">class</span><span class="hljs-class"> </span><span class="hljs-title">Usr</span><span class="hljs-class">(</span><span class="hljs-params">models.Model</span><span class="hljs-class">):</span>&#13;&#13;
    username = models.CharField(max_length=<span class="hljs-number">50</span>)&#13;&#13;
<span class="hljs-keyword">class</span><span class="hljs-class"> </span><span class="hljs-title">Micropost</span><span class="hljs-class">(</span><span class="hljs-params">models.Model</span><span class="hljs-class">):</span>&#13;&#13;
    user = models.ForeignKey(Usr, on_delete=models.CASCADE,&#13;&#13;
                             related_name=<span class="hljs-string">'owner'</span>)&#13;&#13;
    text = models.CharField(max_length=<span class="hljs-number">300</span>)&#13;&#13;
    referenced = models.ForeignKey(Usr, null=<span class="hljs-literal">True</span>,&#13;&#13;
                                   on_delete=models.CASCADE,&#13;&#13;
                                   related_name=<span class="hljs-string">'reference'</span>)&#13;&#13;
    timestamp = models.DateTimeField(auto_now=<span class="hljs-literal">True</span>&#13;&#13;
</code></pre>&#13;&#13;
    <p class="normal">The <code class="Code-In-Text--PACKT-">Usr</code> model is very straightforward, only storing the username. The <code class="Code-In-Text--PACKT-">Micropost</code> Model stores a string of text and the user that created the micropost. Optionally, it can store a referenced user.</p>&#13;&#13;
    <div class="packt_tip">&#13;&#13;
      <p class="Tip--PACKT-">Note that the relations have their own named back reference, <code class="Code-In-Text--PACKT-">reference</code> and <code class="Code-In-Text--PACKT-">owner</code>. They are created by default by Django so you can search where a <code class="Code-In-Text--PACKT-">Usr</code> is referenced, for example. </p>&#13;&#13;
      <p class="Tip--PACKT-">Note also that the <code class="Code-In-Text--PACKT-">text</code> allows for 300 characters, instead of the 255 that we said in the API. This is to allow a bit of extra space in the database. We will still protect against more characters later.</p>&#13;&#13;
    </div>&#13;&#13;
    <h3 id="_idParaDest-134" class="title">URL routing</h3>&#13;&#13;
    <p class="normal">With this <a id="_idIndexMarker456"/>information, we create two different <a id="_idIndexMarker457"/>views, one <a id="_idIndexMarker458"/>for each URL that we need to create. They'll be called <code class="Code-In-Text--PACKT-">MicropostsListView</code> and <code class="Code-In-Text--PACKT-">MicropostView</code>. Let's take a look first at how the URLs are defined in the <code class="Code-In-Text--PACKT-">urls.py</code> file:</p>&#13;&#13;
    <pre class="programlisting code"><code class="hljs-code"><span class="hljs-keyword">from</span> django.urls <span class="hljs-keyword">import</span> path&#13;&#13;
<span class="hljs-keyword">from</span> . <span class="hljs-keyword">import</span> views&#13;&#13;
urlpatterns = [&#13;&#13;
    path(<span class="hljs-string">'users/&lt;username&gt;/collection'</span>, views.MicropostsListView.as_view(),&#13;&#13;
         name=<span class="hljs-string">'user-collection'</span>),&#13;&#13;
    path(<span class="hljs-string">'users/&lt;username&gt;/collection/&lt;pk&gt;'</span>, views.MicropostView.as_view(),&#13;&#13;
         name=<span class="hljs-string">'micropost-detail'</span>),&#13;&#13;
]&#13;&#13;
</code></pre>&#13;&#13;
    <p class="normal">Note that there are two URLs, that correspond to this definition:</p>&#13;&#13;
    <pre class="programlisting code"><code class="hljs-code">/api/users/&lt;username&gt;/collection&#13;&#13;
/api/users/&lt;username&gt;/collection/&lt;micropost_id&gt;&#13;&#13;
</code></pre>&#13;&#13;
    <p class="normal">And each is mapped to the corresponding view.</p>&#13;&#13;
    <h3 id="_idParaDest-135" class="title">Views</h3>&#13;&#13;
    <p class="normal">Each view <a id="_idIndexMarker459"/>inherits from the proper API endpoint, the collection one from <code class="Code-In-Text--PACKT-">ListCreateAPIView</code>, which defines the actions for <code class="Code-In-Text--PACKT-">LIST</code> (<code class="Code-In-Text--PACKT-">GET</code>) and <code class="Code-In-Text--PACKT-">CREATE</code> (<code class="Code-In-Text--PACKT-">POST</code>):</p>&#13;&#13;
    <pre class="programlisting code"><code class="hljs-code"><span class="hljs-keyword">from</span> rest_framework.generics <span class="hljs-keyword">import</span> ListCreateAPIView&#13;&#13;
<span class="hljs-keyword">from</span> .models <span class="hljs-keyword">import</span> Micropost, Usr&#13;&#13;
<span class="hljs-keyword">from</span> .serializers <span class="hljs-keyword">import</span> MicropostSerializer&#13;&#13;
<span class="hljs-keyword">class</span><span class="hljs-class"> </span><span class="hljs-title">MicropostsListView</span><span class="hljs-class">(</span><span class="hljs-params">ListCreateAPIView</span><span class="hljs-class">):</span>&#13;&#13;
    serializer_class = MicropostSerializer&#13;&#13;
    <span class="hljs-keyword">def</span><span class="hljs-function"> </span><span class="hljs-title">get_queryset</span><span class="hljs-function">(</span><span class="hljs-params">self</span><span class="hljs-function">):</span>&#13;&#13;
        result = Micropost.objects.<span class="hljs-built_in">filter</span>(&#13;&#13;
             user__username=self.kwargs[<span class="hljs-string">'username'</span>]&#13;&#13;
        )&#13;&#13;
        <span class="hljs-keyword">return</span> result&#13;&#13;
    <span class="hljs-keyword">def</span><span class="hljs-function"> </span><span class="hljs-title">perform_create</span><span class="hljs-function">(</span><span class="hljs-params">self, serializer</span><span class="hljs-function">):</span>&#13;&#13;
        user = Usr.objects.get(username=self.kwargs[<span class="hljs-string">'username'</span>])&#13;&#13;
        serializer.save(user=user)&#13;&#13;
</code></pre>&#13;&#13;
    <p class="normal">We will check the serializer later. The class requires defining the queryset that it will use to retrieve the information when the <code class="Code-In-Text--PACKT-">LIST</code> part of the class is called. Because our URL includes the username, we need to identify it:</p>&#13;&#13;
    <pre class="programlisting code"><code class="hljs-code">    <span class="hljs-keyword">def</span><span class="hljs-function"> </span><span class="hljs-title">get_queryset</span><span class="hljs-function">(</span><span class="hljs-params">self</span><span class="hljs-function">):</span>&#13;&#13;
        result = Micropost.objects.<span class="hljs-built_in">filter</span>(&#13;&#13;
             user__username=self.kwargs[<span class="hljs-string">'username'</span>]&#13;&#13;
        )&#13;&#13;
        <span class="hljs-keyword">return</span> result&#13;&#13;
</code></pre>&#13;&#13;
    <p class="normal"><code class="Code-In-Text--PACKT-">self.kwargs['username']</code> will retrieve the username defined in the URL.</p>&#13;&#13;
    <p class="normal">For the <code class="Code-In-Text--PACKT-">CREATE</code> part, we need to overwrite the <code class="Code-In-Text--PACKT-">perform_create</code> method. This method receives a serializer parameter that already contains the validated parameters.</p>&#13;&#13;
    <p class="normal">We need to obtain the username and user from the same <code class="Code-In-Text--PACKT-">self.kwargs</code> to be sure to add it to the creation of the <code class="Code-In-Text--PACKT-">Micropost</code> object.</p>&#13;&#13;
    <pre class="programlisting code"><code class="hljs-code">    <span class="hljs-keyword">def</span><span class="hljs-function"> </span><span class="hljs-title">perform_create</span><span class="hljs-function">(</span><span class="hljs-params">self, serializer</span><span class="hljs-function">):</span>&#13;&#13;
        user = Usr.objects.get(username=self.kwargs[<span class="hljs-string">'username'</span>])&#13;&#13;
        serializer.save(user=user)&#13;&#13;
</code></pre>&#13;&#13;
    <p class="normal">The new object is created combining both the user and the rest of the data, added as part of the <code class="Code-In-Text--PACKT-">save</code> method for the serializer.</p>&#13;&#13;
    <p class="normal">The individual <a id="_idIndexMarker460"/>View follows a similar pattern, but there's no need to overwrite the creation:</p>&#13;&#13;
    <pre class="programlisting code"><code class="hljs-code"><span class="hljs-keyword">from</span> rest_framework.generics <span class="hljs-keyword">import</span> ListCreateAPIView&#13;&#13;
<span class="hljs-keyword">from</span> .models <span class="hljs-keyword">import</span> Micropost, Usr&#13;&#13;
<span class="hljs-keyword">from</span> .serializers <span class="hljs-keyword">import</span> MicropostSerializer&#13;&#13;
<span class="hljs-keyword">class</span><span class="hljs-class"> </span><span class="hljs-title">MicropostView</span><span class="hljs-class">(</span><span class="hljs-params">RetrieveUpdateDestroyAPIView</span><span class="hljs-class">):</span>&#13;&#13;
    serializer_class = MicropostSerializer&#13;&#13;
    <span class="hljs-keyword">def</span><span class="hljs-function"> </span><span class="hljs-title">get_queryset</span><span class="hljs-function">(</span><span class="hljs-params">self</span><span class="hljs-function">):</span>&#13;&#13;
        result = Micropost.objects.<span class="hljs-built_in">filter</span>(&#13;&#13;
            user__username=self.kwargs[<span class="hljs-string">'username'</span>]&#13;&#13;
        )&#13;&#13;
        <span class="hljs-keyword">return</span> result&#13;&#13;
</code></pre>&#13;&#13;
    <p class="normal">In this case, we allow more operations: <code class="Code-In-Text--PACKT-">RETRIEVE</code> (<code class="Code-In-Text--PACKT-">GET</code>), <code class="Code-In-Text--PACKT-">UPDATE</code> (<code class="Code-In-Text--PACKT-">PUT</code> and <code class="Code-In-Text--PACKT-">PATCH</code>), and <code class="Code-In-Text--PACKT-">DESTROY</code> (<code class="Code-In-Text--PACKT-">DELETE</code>).</p>&#13;&#13;
    <h3 id="_idParaDest-136" class="title">Serializer</h3>&#13;&#13;
    <p class="normal">The serializer <a id="_idIndexMarker461"/>transforms from the Python object of the Model to the JSON result and the other way around. The serializer is defined like this:</p>&#13;&#13;
    <pre class="programlisting code"><code class="hljs-code"><span class="hljs-keyword">from</span> .models <span class="hljs-keyword">import</span> Micropost, Usr&#13;&#13;
<span class="hljs-keyword">from</span> rest_framework <span class="hljs-keyword">import</span> serializers&#13;&#13;
<span class="hljs-keyword">class</span><span class="hljs-class"> </span><span class="hljs-title">MicropostSerializer</span><span class="hljs-class">(</span><span class="hljs-params">serializers.ModelSerializer</span><span class="hljs-class">):</span>&#13;&#13;
    href = MicropostHyperlink(source=<span class="hljs-string">'*'</span>, read_only=<span class="hljs-literal">True</span>)&#13;&#13;
    text = serializers.CharField(max_length=<span class="hljs-number">255</span>)&#13;&#13;
    referenced = serializers.SlugRelatedField(queryset=Usr.objects.<span class="hljs-built_in">all</span>(),&#13;&#13;
                                             slug_field=<span class="hljs-string">'username'</span>,&#13;&#13;
                                             allow_null=<span class="hljs-literal">True</span>)&#13;&#13;
    user = serializers.CharField(source=<span class="hljs-string">'user.username'</span>, read_only=<span class="hljs-literal">True</span>)&#13;&#13;
    <span class="hljs-keyword">class</span><span class="hljs-class"> </span><span class="hljs-title">Meta</span><span class="hljs-class">:</span>&#13;&#13;
        model = Micropost&#13;&#13;
        fields = [<span class="hljs-string">'href'</span>, <span class="hljs-string">'id'</span>, <span class="hljs-string">'text'</span>, <span class="hljs-string">'referenced'</span>, <span class="hljs-string">'timestamp'</span>, <span class="hljs-string">'user'</span>]&#13;&#13;
</code></pre>&#13;&#13;
    <p class="normal"><code class="Code-In-Text--PACKT-">ModelSerializer</code> will automatically detect the fields in the model defined in the <code class="Code-In-Text--PACKT-">Meta</code> subclass. We specified the fields to be included in the <code class="Code-In-Text--PACKT-">fields</code> section. Note that, apart from the ones that are directly translated, <code class="Code-In-Text--PACKT-">id</code> and <code class="Code-In-Text--PACKT-">timestamp</code>, we include others that will change (<code class="Code-In-Text--PACKT-">user</code>, <code class="Code-In-Text--PACKT-">text</code>, <code class="Code-In-Text--PACKT-">referenced</code>) and an extra one (<code class="Code-In-Text--PACKT-">href</code>). The directly translated ones are straightforward; we don't need to do anything there.</p>&#13;&#13;
    <p class="normal">The <code class="Code-In-Text--PACKT-">text</code> field is described again as a <code class="Code-In-Text--PACKT-">CharField</code>, but this time, we limit the maximum number of characters. </p>&#13;&#13;
    <p class="normal">The <code class="Code-In-Text--PACKT-">user</code> field is <a id="_idIndexMarker462"/>also redescribed as a <code class="Code-In-Text--PACKT-">CharField</code>, but using the source parameter we define it as the username of the referenced user. The field is defined as <code class="Code-In-Text--PACKT-">read_only</code>.</p>&#13;&#13;
    <p class="normal"><code class="Code-In-Text--PACKT-">referenced</code> is similar to it, but we need to define it as <code class="Code-In-Text--PACKT-">SlugRelatedField</code>, so it understands that's a reference. A slug is a string that references the value. We define that the <code class="Code-In-Text--PACKT-">slug_field</code> is the username of the reference, and add the queryset to allow searching for it.</p>&#13;&#13;
    <p class="normal">The <code class="Code-In-Text--PACKT-">href</code> field requires an extra defined class to create a proper URL reference. Let's take a detailed look:</p>&#13;&#13;
    <pre class="programlisting code"><code class="hljs-code"><span class="hljs-keyword">from</span> .models <span class="hljs-keyword">import</span> Micropost, Usr&#13;&#13;
<span class="hljs-keyword">from</span> rest_framework <span class="hljs-keyword">import</span> serializers&#13;&#13;
<span class="hljs-keyword">from</span> rest_framework.reverse <span class="hljs-keyword">import</span> reverse&#13;&#13;
<span class="hljs-keyword">class</span><span class="hljs-class"> </span><span class="hljs-title">MicropostHyperlink</span><span class="hljs-class">(</span><span class="hljs-params">serializers.HyperlinkedRelatedField</span><span class="hljs-class">):</span>&#13;&#13;
    view_name = <span class="hljs-string">'micropost-detail'</span>&#13;&#13;
    <span class="hljs-keyword">def</span><span class="hljs-function"> </span><span class="hljs-title">get_url</span><span class="hljs-function">(</span><span class="hljs-params">self, obj, view_name, request, </span><span class="hljs-built_in">format</span><span class="hljs-function">):</span>&#13;&#13;
        url_kwargs = {&#13;&#13;
            <span class="hljs-string">'pk'</span>: obj.pk,&#13;&#13;
            <span class="hljs-string">'username'</span>: obj.user.username,&#13;&#13;
        }&#13;&#13;
        result = reverse(view_name, kwargs=url_kwargs, request=request,&#13;&#13;
                         <span class="hljs-built_in">format</span>=<span class="hljs-built_in">format</span>)&#13;&#13;
        <span class="hljs-keyword">return</span> result&#13;&#13;
<span class="hljs-keyword">class</span><span class="hljs-class"> </span><span class="hljs-title">MicropostSerializer</span><span class="hljs-class">(</span><span class="hljs-params">serializers.ModelSerializer</span><span class="hljs-class">):</span>&#13;&#13;
    href = MicropostHyperlink(source=<span class="hljs-string">'*'</span>, read_only=<span class="hljs-literal">True</span>)&#13;&#13;
    ...&#13;&#13;
</code></pre>&#13;&#13;
    <p class="normal"><code class="Code-In-Text--PACKT-">view_name</code> describes the URL that will be used. The <code class="Code-In-Text--PACKT-">reverse</code> call transforms the parameters <a id="_idIndexMarker463"/>into the proper full URL. This is wrapped in the <code class="Code-In-Text--PACKT-">get_url</code> method. This method receives mainly the <code class="Code-In-Text--PACKT-">obj</code> parameter with the full object. This full object is defined in the <code class="Code-In-Text--PACKT-">source='*'</code> call to the <code class="Code-In-Text--PACKT-">MicropostHyperlink</code> class in the serializer.</p>&#13;&#13;
    <p class="normal">The combination of all these factors makes the interface work correctly. Django REST framework can also create an interface to help you visualize the whole interface and use it.</p>&#13;&#13;
    <p class="normal">For example, a list will look like this:</p>&#13;&#13;
    <figure class="mediaobject"><img src="Images/B17580_06_04.png" alt="Graphical user interface, application, Teams&#13;&#10;&#13;&#10;Description automatically generated" width="826" height="1032"/></figure>&#13;&#13;
    <p class="packt_figref">Figure 6.4: Microposts List</p>&#13;&#13;
    <p class="normal">And a micropost <a id="_idIndexMarker464"/>page will look like this, which allows you to test different actions like <code class="Code-In-Text--PACKT-">PUT</code>, <code class="Code-In-Text--PACKT-">PATCH</code>, <code class="Code-In-Text--PACKT-">DELETE</code>, and <code class="Code-In-Text--PACKT-">GET</code>.</p>&#13;&#13;
    <figure class="mediaobject"><img src="Images/B17580_06_05.png" alt="Graphical user interface, application, Teams&#13;&#10;&#13;&#10;Description automatically generated" width="825" height="749"/></figure>&#13;&#13;
    <p class="packt_figref">Figure 6.5: Microposts page</p>&#13;&#13;
    <div class="note">&#13;&#13;
      <p class="Information-Box--PACKT-">Django REST framework is very powerful and can be used in different ways to be sure that it behaves exactly as you expect. It has its own quirks, and it tends to be a little temperamental with the parameters until everything is configured just right. At the same time, it allows you to customize the interface in every aspect. Be sure to read the documentation carefully. </p>&#13;&#13;
      <p class="Information-Box--PACKT-">You can find the whole documentation here: <a href="https://www.django-rest-framework.org/"><span class="url">https://www.django-rest-framework.org/</span></a>. </p>&#13;&#13;
    </div>&#13;&#13;
    <h1 id="_idParaDest-137" class="title">External layers</h1>&#13;&#13;
    <p class="normal">On top of the web server, there is the possibility to continue the link by adding extra levels that <a id="_idIndexMarker465"/>work on the HTTP layer. This allows you to load balance between multiple servers and increase the total throughput of the system. This can be chained into multiple layers, if necessary.</p>&#13;&#13;
    <figure class="mediaobject"><img src="Images/B17580_06_06.png" alt="Diagram&#13;&#10;&#13;&#10;Description automatically generated" width="826" height="253"/></figure>&#13;&#13;
    <p class="packt_figref">Figure 6.6: Chained load balancers</p>&#13;&#13;
    <p class="normal">The route from the user to the edge of our system is handled by the internet, but once it reaches the edge load balancer, it directs the requests inside the system. The edge load balancer works as a gateway between the external networks and the controlled environment of our network.</p>&#13;&#13;
    <div class="note">&#13;&#13;
      <p class="Information-Box--PACKT-">The edge load balancer is normally the only one that handles HTTPS connection, allowing <a id="_idIndexMarker466"/>the rest of the system to use only HTTP. This is convenient as HTTP requests are easier to cache and handle. HTTPS requests are encoded end to end and cannot be properly cached or analyzed. The internal traffic is protected from external access and should have robust policies to be sure that only approved engineers are able to access it and access logs to audit accesses. But at the same time, it can be easily debugged, and any traffic problems can be solved much more easily.</p>&#13;&#13;
    </div>&#13;&#13;
    <p class="normal">The configuration of the network can greatly vary, and in lots of cases multiple load balancers are <a id="_idIndexMarker467"/>not required, and the edge load balancer can handle multiple web servers directly. The capacity in this case is key, as a load balancer has a limit on the number of requests that it can take.</p>&#13;&#13;
    <div class="packt_tip">&#13;&#13;
      <p class="Tip--PACKT-">Some key load balancers can be set up as specialized hardware to ensure that they have the capacity to handle the required number of requests.</p>&#13;&#13;
    </div>&#13;&#13;
    <p class="normal">This multi-layered structure allows you to introduce caching at any point of the system. This can improve the performance of the system, though it needs to be treated with care to be sure that it's adequate. After all, one of the most difficult problems in software development is the proper handling of the cache and its invalidation.</p>&#13;&#13;
    <h1 id="_idParaDest-138" class="title">Summary</h1>&#13;&#13;
    <p class="normal">In this chapter, we went into the details about how web servers work, and the different layers that are involved.</p>&#13;&#13;
    <p class="normal">We started by describing the fundamental details of the request-response and web server architecture. Then, we moved on to describe a system with three layers, using nginx as the front web server and uWSGI to handle multiple Python workers that run Django code.</p>&#13;&#13;
    <p class="normal">We started with the web server itself, which allows you to serve HTTP, directly return the static content stored in files, and route it towards the next layer. We analyzed the different configuration elements, including enabling header forwarding and logging.</p>&#13;&#13;
    <p class="normal">We continued by describing how uWSGI works and how it's able to create and set up different processes that interact through the WSGI protocol in Python. We described how to set up the interaction with the previous level (the nginx web server) and the next level (the Python code). We also described how the workers can be restarted in an orderly way, and how they can be automatically recycled periodically to mitigate certain kinds of problems.</p>&#13;&#13;
    <p class="normal">We described how Django works to define a web application, and how the requests and responses flow through the code, including how the middleware can be used to chain elements in the flow. We also introduced Django REST framework as a way to create RESTful APIs and show how our example introduced in <em class="chapterRef">Chapter 2</em> can be implemented through the views and serializers provided by Django REST framework.</p>&#13;&#13;
    <p class="normal">Finally, we described how the structure can be extended by layers on top to be sure to distribute the load across multiple servers and scale the system.</p>&#13;&#13;
    <p class="normal">We will next describe event-driven systems.</p>&#13;&#13;
  </div>&#13;&#13;
</div></body></html>