<html><head></head><body><div id="sbo-rt-content"><div id="_idContainer191" class="Basic-Text-Frame">&#13;
    <h1 class="chapterNumber">10</h1>&#13;
    <h1 id="_idParaDest-262" class="chapterTitle">Testing and Logging – Preparing for Bugs</h1>&#13;
    <p class="normal">When programming, most developers plan a bit and immediately start writing code. After all, we all expect to write bug-free code! Unfortunately, we don’t. At some point, an incorrect assumption, a misinterpretation, or just a silly mistake is bound to happen. Debugging (covered in <em class="chapterRef">Chapter 11</em>, <em class="italic">Debugging – Solving the Bugs</em>) will always be required at some point, but there are several methods that you can use to prevent bugs or, at the very least, make it much easier to solve them when they do occur.</p>&#13;
    <p class="normal">To prevent bugs from occurring in the first place, test-driven development or, at the very least, functional/regression/unit tests, are very useful. The standard Python installation alone offers several options such as the <code class="inlineCode">doctest</code>, <code class="inlineCode">unittest</code>, and <code class="inlineCode">test</code> modules. The <code class="inlineCode">doctest</code> module allows you to combine tests with example documentation. The <code class="inlineCode">unittest</code> module allows you to easily write regression tests. The <code class="inlineCode">test</code> module is meant for internal usage only, so unless you are planning to modify the Python core, you probably won’t need this one.</p>&#13;
    <p class="normal">The test modules we will discuss in this chapter are:</p>&#13;
    <ul>&#13;
      <li class="bulletList"><code class="inlineCode">doctest</code></li>&#13;
      <li class="bulletList"><code class="inlineCode">py.test</code> (and why it’s more convenient than <code class="inlineCode">unittest</code>)</li>&#13;
      <li class="bulletList"><code class="inlineCode">unittest.mock</code></li>&#13;
    </ul>&#13;
    <p class="normal">The <code class="inlineCode">py.test</code> module has roughly the same purpose as the <code class="inlineCode">unittest</code> module, but it’s much more convenient to use and has many more options and plugins available.</p>&#13;
    <p class="normal">After learning how to avoid the bugs, it’ll be time to take a look at logging so that we can inspect what is happening in our program and why. The <code class="inlineCode">logging</code> module in Python is highly configurable and can be adjusted for just about any use case. If you’ve ever written Java code, you should feel right at home with the <code class="inlineCode">logging</code> module, as its design is largely based on the <code class="inlineCode">log4j</code> module and is very similar in both implementation and naming. The latter makes it a bit of an odd module in Python as well, as it is one of the few modules that does not follow the <code class="inlineCode">pep8</code> naming standards.</p>&#13;
    <p class="normal">This chapter will explain the following topics:</p>&#13;
    <ul>&#13;
      <li class="bulletList">Combining documentation with tests using <code class="inlineCode">doctest</code></li>&#13;
      <li class="bulletList">Regression and unit tests using <code class="inlineCode">py.test</code> and <code class="inlineCode">unittest</code></li>&#13;
      <li class="bulletList">Testing with fake objects using <code class="inlineCode">unittest.mock</code></li>&#13;
      <li class="bulletList">Testing multiple environments using <code class="inlineCode">tox</code></li>&#13;
      <li class="bulletList">Using the <code class="inlineCode">logging</code> module effectively</li>&#13;
      <li class="bulletList">Combining <code class="inlineCode">logging</code> and <code class="inlineCode">py.test</code></li>&#13;
    </ul>&#13;
    <h1 id="_idParaDest-263" class="heading-1">Using documentation as tests with doctest</h1>&#13;
    <p class="normal">The <code class="inlineCode">doctest</code> module is <a id="_idIndexMarker723"/>one of the most useful modules within Python. It allows you to combine documenting your code with tests to make sure that it keeps working as it is supposed to.</p>&#13;
    <p class="normal">By now the format should be very familiar to you; most of the code samples in this book use the <code class="inlineCode">doctest</code> format, which offers the advantage that both the input and the output are shown intertwined. Especially in demonstrations, this is much more convenient than having a block of code followed by the output. </p>&#13;
    <h2 id="_idParaDest-264" class="heading-2">A simple doctest example</h2>&#13;
    <p class="normal">Let’s start <a id="_idIndexMarker724"/>with a quick example: a function that squares the input. The following example is a fully functional command-line application, containing not only code but also functioning tests. The first few tests cover how the function is supposed to behave when executing normally, followed by a few tests to demonstrate the expected errors:</p>&#13;
    <pre class="programlisting code"><code class="hljs-code"><span class="hljs-keyword">def</span><span class="hljs-function"> </span><span class="hljs-title">square</span><span class="hljs-function">(</span><span class="hljs-params">n: </span><span class="hljs-built_in">int</span><span class="hljs-function">) -&gt; int:</span>&#13;
    <span class="hljs-string">'''</span>&#13;
<span class="hljs-string">    Returns the input number, squared</span>&#13;
<span class="hljs-string">    &gt;&gt;&gt; square(0)</span>&#13;
<span class="hljs-string">    0</span>&#13;
<span class="hljs-string">    &gt;&gt;&gt; square(1)</span>&#13;
<span class="hljs-string">    1</span>&#13;
<span class="hljs-string">    &gt;&gt;&gt; square(2)</span>&#13;
<span class="hljs-string">    4</span>&#13;
<span class="hljs-string">    &gt;&gt;&gt; square(3)</span>&#13;
<span class="hljs-string">    9</span>&#13;
<span class="hljs-string">    &gt;&gt;&gt; square()</span>&#13;
<span class="hljs-string">    Traceback (most recent call last):</span>&#13;
<span class="hljs-string">    ...</span>&#13;
<span class="hljs-string">    TypeError: square() missing 1 required positional argument: 'n'</span>&#13;
<span class="hljs-string">    &gt;&gt;&gt; square('x')</span>&#13;
<span class="hljs-string">    Traceback (most recent call last):</span>&#13;
<span class="hljs-string">    ...</span>&#13;
<span class="hljs-string">    TypeError: can't multiply sequence by non-int of type 'str'</span>&#13;
<span class="hljs-string">    Args:</span>&#13;
<span class="hljs-string">        n (int): The number to square</span>&#13;
&#13;
<span class="hljs-string">    Returns:</span>&#13;
<span class="hljs-string">        int: The squared result</span>&#13;
<span class="hljs-string">    '''</span>&#13;
    <span class="hljs-keyword">return</span> n * n&#13;
&#13;
<span class="hljs-keyword">if</span> __name__ == <span class="hljs-string">'__main__'</span>:&#13;
    <span class="hljs-keyword">import</span> doctest&#13;
    doctest.testmod()&#13;
</code></pre>&#13;
    <p class="normal">It can be<a id="_idIndexMarker725"/> executed as any Python script, but the regular command won’t give any output as all tests are successful. The <code class="inlineCode">doctest.testmod</code> function takes verbosity parameters, luckily:</p>&#13;
    <pre class="programlisting con"><code class="hljs-con"><span class="hljs-con-meta">$</span> python3 T_00_simple_doctest.py -v&#13;
Trying:&#13;
    square(0)&#13;
Expecting:&#13;
    0&#13;
ok&#13;
Trying:&#13;
    square(1)&#13;
Expecting:&#13;
    1&#13;
ok&#13;
Trying:&#13;
    square(2)&#13;
Expecting:&#13;
    4&#13;
ok&#13;
Trying:&#13;
    square(3)&#13;
Expecting:&#13;
    9&#13;
ok&#13;
Trying:&#13;
    square()&#13;
Expecting:&#13;
    Traceback (most recent call last):&#13;
    ...&#13;
    TypeError: square() missing 1 required positional argument: 'n'&#13;
ok&#13;
Trying:&#13;
    square('x')&#13;
Expecting:&#13;
    Traceback (most recent call last):&#13;
    ...&#13;
    TypeError: can't multiply sequence by non-int of type 'str'&#13;
ok&#13;
1 items had no tests:&#13;
    __main__&#13;
1 items passed all tests:&#13;
   6 tests in __main__.square&#13;
6 tests in 2 items.&#13;
6 passed and 0 failed.&#13;
Test passed.&#13;
</code></pre>&#13;
    <p class="normal">Additionally, since<a id="_idIndexMarker726"/> it uses the Google syntax (as discussed in <em class="chapterRef">Chapter 9</em>, <em class="italic">Documentation – How to Use Sphinx and reStructuredText</em>, the documentation chapter), we can generate pretty documentation using Sphinx:</p>&#13;
    <figure class="mediaobject"><img src="Images/B15882_10_01.png" alt="A simple doctest example" width="736" height="579"/></figure>&#13;
    <p class="packt_figref">Figure 10.1: Documentation generated using Sphinx</p>&#13;
    <p class="normal">However, the <a id="_idIndexMarker727"/>code is not always correct, of course. What will happen if we modify the code so that the tests do not pass anymore?</p>&#13;
    <p class="normal">This time, instead of <code class="inlineCode">n * n</code>, we use <code class="inlineCode">n ** 2</code>. Both square a number, so the results must be identical. Right? These are the types of assumptions that create bugs, and the types of assumptions that are trivial to catch using a few basic tests. Since most results are the same we will skip them in the example, but one test has different results now:</p>&#13;
    <pre class="programlisting code"><code class="hljs-code"><span class="hljs-keyword">def</span><span class="hljs-function"> </span><span class="hljs-title">square</span><span class="hljs-function">(</span><span class="hljs-params">n: </span><span class="hljs-built_in">int</span><span class="hljs-function">) -&gt; int:</span>&#13;
    <span class="hljs-string">'''</span>&#13;
<span class="hljs-string">    &gt;&gt;&gt; square('x')</span>&#13;
<span class="hljs-string">    Traceback (most recent call last):</span>&#13;
<span class="hljs-string">    ...</span>&#13;
<span class="hljs-string">    TypeError: unsupported operand type(s) for ** or pow(): ...</span>&#13;
<span class="hljs-string">    '''</span>&#13;
    <span class="hljs-keyword">return</span> n ** <span class="hljs-number">2</span>&#13;
&#13;
<span class="hljs-keyword">if</span> __name__ == <span class="hljs-string">'__main__'</span>:&#13;
    <span class="hljs-keyword">import</span> doctest&#13;
    doctest.testmod(optionflags=doctest.ELLIPSIS)&#13;
</code></pre>&#13;
    <p class="normal">The only<a id="_idIndexMarker728"/> modification we made to the code was replacing <code class="inlineCode">n * n</code> with <code class="inlineCode">n ** 2</code>, which translates to the power function. Since multiplication is not the same as taking the power of a number, the results are slightly different, but similar enough in practice that most programmers wouldn’t notice the difference.</p>&#13;
    <p class="normal">Because of that difference, however, the error changed from <code class="inlineCode">can't multiply sequence ...</code> to <code class="inlineCode">unsupported operand type(s) for ** or pow(): ...</code>. It’s an innocent mistake, but a quick optimization by a programmer could have changed this unintentionally with possibly wrong results. If the <code class="inlineCode">__pow__</code> method was overloaded with different behavior, for example, this could result in bigger problems.</p>&#13;
    <p class="normal">This example has shown us how useful these tests can be. When rewriting or optimizing code, an incorrect assumption is easily made, and that is where tests are very useful—knowing you are breaking code as soon as you break it instead of finding out months later.</p>&#13;
    <h2 id="_idParaDest-265" class="heading-2">Writing doctests</h2>&#13;
    <p class="normal">Perhaps you <a id="_idIndexMarker729"/>have noticed from the preceding examples that the syntax is very similar to the regular Python console, and that is because it is. The <code class="inlineCode">doctest</code> input is nothing more than the output of a regular Python shell session. This is what makes testing with this module so intuitive; simply write the code in the Python console and copy the output into a docstring to get tests. Here is an example:</p>&#13;
    <pre class="programlisting con"><code class="hljs-con"><span class="hljs-con-meta">$</span> python3&#13;
<span class="hljs-con-meta">&gt;&gt;&gt;</span> <span class="hljs-con-keyword">from</span> square <span class="hljs-con-keyword">import</span> square&#13;
&#13;
<span class="hljs-con-meta">&gt;&gt;&gt;</span> square(<span class="hljs-con-number">5</span>)&#13;
25&#13;
<span class="hljs-con-meta">&gt;&gt;&gt;</span> square()&#13;
Traceback (most recent call last):&#13;
  File "&lt;stdin&gt;", line 1, in &lt;module&gt;&#13;
TypeError: square() missing 1 required positional argument: 'n'&#13;
</code></pre>&#13;
    <p class="normal">That’s why this is probably the easiest way to test code. With almost no effort, you can check whether your code is working as you would expect it, add tests, and add documentation at the<a id="_idIndexMarker730"/> same time. Simply copy the output from the interpreter to your function or class documentation and you have functioning doctests.</p>&#13;
    <h2 id="_idParaDest-266" class="heading-2">Testing with documentation</h2>&#13;
    <p class="normal">The <a id="_idIndexMarker731"/>docstrings in functions, classes, and modules are <a id="_idIndexMarker732"/>usually the most obvious way to add doctests to your code, but they are not the only way. The Sphinx documentation, as we discussed in the previous chapter, also supports the <code class="inlineCode">doctest</code> module.</p>&#13;
    <p class="normal">To enable <code class="inlineCode">doctest</code> support in Sphinx, you need to add the <code class="inlineCode">sphinx.ext.doctest</code> extension in Sphinx, which tells Sphinx to run those tests as well. Since not all the examples in the code are useful, let’s see whether we can split them into the ones that are actually useful and the ones that are only relevant for documentation. Moreover, to see the results, we will add an error to the documentation.</p>&#13;
    <p class="normal"><code class="inlineCode">square.py</code></p>&#13;
    <pre class="programlisting code"><code class="hljs-code"><span class="hljs-keyword">def</span><span class="hljs-function"> </span><span class="hljs-title">square</span><span class="hljs-function">(</span><span class="hljs-params">n: </span><span class="hljs-built_in">int</span><span class="hljs-function">) -&gt; int:</span>&#13;
    <span class="hljs-string">'''</span>&#13;
<span class="hljs-string">    Returns the input number, squared</span>&#13;
<span class="hljs-string">    &gt;&gt;&gt; square(2)</span>&#13;
<span class="hljs-string">    4</span>&#13;
<span class="hljs-string">    Args:</span>&#13;
<span class="hljs-string">        n (int): The number to square</span>&#13;
<span class="hljs-string">    Returns:</span>&#13;
<span class="hljs-string">        int: The squared result</span>&#13;
<span class="hljs-string">    '''</span>&#13;
    <span class="hljs-keyword">return</span> n * n&#13;
&#13;
<span class="hljs-keyword">if</span> __name__ == <span class="hljs-string">'__main__'</span>:&#13;
    <span class="hljs-keyword">import</span> doctest&#13;
    doctest.testmod()&#13;
</code></pre>&#13;
    <p class="normal"><code class="inlineCode">square.rst</code></p>&#13;
    <pre class="programlisting code"><code class="hljs-code">square module&#13;
=============&#13;
&#13;
.. automodule:: square&#13;
    :members:&#13;
    :undoc-members:&#13;
    :show-inheritance:&#13;
&#13;
Examples:&#13;
&#13;
.. testsetup::&#13;
&#13;
    <span class="hljs-keyword">from</span> square <span class="hljs-keyword">import</span> square&#13;
&#13;
.. doctest::&#13;
    <span class="hljs-comment"># pytest does not recognize testsetup</span>&#13;
    &gt;&gt;&gt; <span class="hljs-keyword">from</span> square <span class="hljs-keyword">import</span> square&#13;
&#13;
    &gt;&gt;&gt; square(<span class="hljs-number">100</span>)&#13;
    <span class="hljs-number">10000</span>&#13;
    &gt;&gt;&gt; square(<span class="hljs-number">0</span>)&#13;
    <span class="hljs-number">0</span>&#13;
    &gt;&gt;&gt; square(<span class="hljs-number">1</span>)&#13;
    <span class="hljs-number">1</span>&#13;
    &gt;&gt;&gt; square(<span class="hljs-number">3</span>)&#13;
    <span class="hljs-number">9</span>&#13;
    &gt;&gt;&gt; square()&#13;
    Traceback (most recent call last):&#13;
    ...&#13;
    TypeError: square() missing <span class="hljs-number">1</span> required positional argument: <span class="hljs-string">'n'</span>&#13;
&#13;
    &gt;&gt;&gt; square(<span class="hljs-string">'x'</span>)&#13;
    Traceback (most recent call last):&#13;
    ...&#13;
    TypeError: can't multiply sequence by non-int of type 'str'&#13;
</code></pre>&#13;
    <p class="normal">Now, it’s<a id="_idIndexMarker733"/> time to execute the tests. In the case of Sphinx, there<a id="_idIndexMarker734"/> is a specific command for this:</p>&#13;
    <pre class="programlisting con"><code class="hljs-con"><span class="hljs-con-meta">$</span> make doctest&#13;
Running Sphinx v3.2.1&#13;
loading pickled environment... done&#13;
building [mo]: targets for 0 po files that are out of date&#13;
building [doctest]: targets for 2 source files that are out of date&#13;
updating environment: 0 added, 0 changed, 0 removed&#13;
looking for now-outdated files... none found&#13;
running tests...&#13;
&#13;
Document: square&#13;
----------------&#13;
1 items passed all tests:&#13;
   8 tests in default&#13;
8 tests in 1 items.&#13;
8 passed and 0 failed.&#13;
Test passed.&#13;
&#13;
Doctest summary&#13;
===============&#13;
    8 tests&#13;
    0 failures in tests&#13;
    0 failures in setup code&#13;
    0 failures in cleanup code&#13;
build succeeded.&#13;
&#13;
Testing of doctests in the sources finished, look at the results in _build/doctest/output.txt.&#13;
</code></pre>&#13;
    <p class="normal">As <a id="_idIndexMarker735"/>expected, we are getting an error for the incomplete <code class="inlineCode">doctest</code>, but beyond that, all tests executed correctly. To make sure that the tests <a id="_idIndexMarker736"/>know what <code class="inlineCode">square</code> is, we had to add the <code class="inlineCode">testsetup</code> directive, and this still generates a pretty output:</p>&#13;
    <figure class="mediaobject"> <img src="Images/B15882_10_02.png" alt="" width="627" height="622"/></figure>&#13;
    <p class="packt_figref">Figure 10.2: Rendered Sphinx output</p>&#13;
    <p class="normal">Sphinx <a id="_idIndexMarker737"/>nicely renders both the documentation for the code <a id="_idIndexMarker738"/>and the highlighted code samples.</p>&#13;
    <h2 id="_idParaDest-267" class="heading-2">The doctest flags</h2>&#13;
    <p class="normal">The <code class="inlineCode">doctest</code> module features several option flags that affect how <code class="inlineCode">doctest</code> processes the tests. These option flags <a id="_idIndexMarker739"/>can be passed globally using your test suite, through command-line parameters while running the tests, and through inline commands. For this book, I have globally enabled the following option flags through a <code class="inlineCode">pytest.ini</code> file (we will cover more about <code class="inlineCode">py.test</code> later in this chapter):</p>&#13;
    <pre class="programlisting code"><code class="hljs-code">doctest_optionflags = ELLIPSIS NORMALIZE_WHITESPACE&#13;
</code></pre>&#13;
    <p class="normal">Without these option flags, some of the examples in this book will not function properly. This is because they have to be reformatted to fit. The next few paragraphs will cover the following option flags:</p>&#13;
    <ul>&#13;
      <li class="bulletList"><code class="inlineCode">DONT_ACCEPT_TRUE_FOR_1</code></li>&#13;
      <li class="bulletList"><code class="inlineCode">NORMALIZE_WHITESPACE</code></li>&#13;
      <li class="bulletList"><code class="inlineCode">ELLIPSIS</code></li>&#13;
    </ul>&#13;
    <p class="normal">There are<a id="_idIndexMarker740"/> several other option flags available with varying degrees of usefulness, but these are better left to the Python documentation: <a href="https://docs.python.org/3/library/doctest.html#option-flags%20"><span class="url">https://docs.python.org/3/library/doctest.html#option-flags</span></a></p>&#13;
    <h3 id="_idParaDest-268" class="heading-3">True and False versus 1 and 0</h3>&#13;
    <p class="normal">Having <code class="inlineCode">True</code> evaluating to <code class="inlineCode">1</code> and <code class="inlineCode">False</code> evaluating to <code class="inlineCode">0</code> is useful in most cases, but it can give unexpected results if you were actually expecting a <code class="inlineCode">bool</code> instead of an <code class="inlineCode">int</code>. To demonstrate the <a id="_idIndexMarker741"/>difference, we have these lines:</p>&#13;
    <pre class="programlisting code"><code class="hljs-code"><span class="hljs-string">'''</span>&#13;
<span class="hljs-string">&gt;&gt;&gt; False</span>&#13;
<span class="hljs-string">0</span>&#13;
<span class="hljs-string">&gt;&gt;&gt; True</span>&#13;
<span class="hljs-string">1</span>&#13;
<span class="hljs-string">'''</span>&#13;
<span class="hljs-keyword">if</span> __name__ == <span class="hljs-string">'__main__'</span>:&#13;
    <span class="hljs-keyword">import</span> doctest&#13;
    doctest.testmod()&#13;
    doctest.testmod(optionflags=doctest.DONT_ACCEPT_TRUE_FOR_1)&#13;
</code></pre>&#13;
    <p class="normal">When we run this, it will run the tests both without and with the <code class="inlineCode">DONT_ACCEPT_TRUE_FOR_1</code> flag:</p>&#13;
    <pre class="programlisting con"><code class="hljs-con"><span class="hljs-con-meta">$</span> python3 T_03_doctest_true_for_1_flag.py -v&#13;
Trying:&#13;
    False&#13;
Expecting:&#13;
    0&#13;
ok&#13;
Trying:&#13;
    True&#13;
Expecting:&#13;
    1&#13;
ok&#13;
1 items passed all tests:&#13;
   2 tests in __main__&#13;
2 tests in 1 items.&#13;
2 passed and 0 failed.&#13;
Test passed.&#13;
Trying:&#13;
    False&#13;
Expecting:&#13;
    0&#13;
**********************************************************************&#13;
File "T_03_doctest_true_for_1_flag.py", line 2, in __main__&#13;
Failed example:&#13;
    False&#13;
Expected:&#13;
    0&#13;
Got:&#13;
    False&#13;
Trying:&#13;
    True&#13;
Expecting:&#13;
    1&#13;
**********************************************************************&#13;
File "T_03_doctest_true_for_1_flag.py", line 4, in __main__&#13;
Failed example:&#13;
    True&#13;
Expected:&#13;
    1&#13;
Got:&#13;
    True&#13;
**********************************************************************&#13;
1 items had failures:&#13;
   2 of   2 in __main__&#13;
2 tests in 1 items.&#13;
0 passed and 2 failed.&#13;
***Test Failed*** 2 failures.&#13;
</code></pre>&#13;
    <p class="normal">As you <a id="_idIndexMarker742"/>can see, the <code class="inlineCode">DONT_ACCEPT_TRUE_FOR_1</code> flag makes <code class="inlineCode">doctest</code> reject <code class="inlineCode">1</code> as a valid response for <code class="inlineCode">True</code> as well as <code class="inlineCode">0</code> for <code class="inlineCode">False</code>.</p>&#13;
    <h3 id="_idParaDest-269" class="heading-3">Normalizing whitespace</h3>&#13;
    <p class="normal">Since <a id="_idIndexMarker743"/>doctests are used for both documentation and test purposes, it is pretty much a requirement to keep them readable. Without normalizing whitespace, this can be tricky, however. Consider the following example:</p>&#13;
    <pre class="programlisting con"><code class="hljs-con"><span class="hljs-con-meta">&gt;&gt;&gt;</span> [<span class="hljs-con-built_in">list</span>(<span class="hljs-con-built_in">range</span>(<span class="hljs-con-number">5</span>)) <span class="hljs-con-keyword">for</span> i <span class="hljs-con-keyword">in</span> <span class="hljs-con-built_in">range</span>(<span class="hljs-con-number">3</span>)]&#13;
[[0, 1, 2, 3, 4], [0, 1, 2, 3, 4], [0, 1, 2, 3, 4]]&#13;
</code></pre>&#13;
    <p class="normal">While not all that bad, this output isn’t the best for readability. With whitespace normalizing, here is what we can do instead:</p>&#13;
    <pre class="programlisting con"><code class="hljs-con"><span class="hljs-con-meta">&gt;&gt;&gt;</span> <span class="hljs-con-comment"># doctest: +NORMALIZE_WHITESPACE</span>&#13;
<span class="hljs-con-meta">...</span> [<span class="hljs-con-built_in">list</span>(<span class="hljs-con-built_in">range</span>(<span class="hljs-con-number">5</span>)) <span class="hljs-con-keyword">for</span> i <span class="hljs-con-keyword">in</span> <span class="hljs-con-built_in">range</span>(<span class="hljs-con-number">3</span>)]&#13;
[[0, 1, 2, 3, 4],&#13;
 [0, 1, 2, 3, 4],&#13;
 [0, 1, 2, 3, 4]]&#13;
</code></pre>&#13;
    <p class="normal">Formatting the output in this manner is both more readable and convenient for keeping your lines shorter.</p>&#13;
    <h3 id="_idParaDest-270" class="heading-3">Ellipsis</h3>&#13;
    <p class="normal">The <code class="inlineCode">ELLIPSIS</code> flag is very<a id="_idIndexMarker744"/> useful but also a bit dangerous, as it can easily lead to incorrect matches. It makes <code class="inlineCode">...</code> match any substring, which is very useful for exceptions but dangerous in other cases:</p>&#13;
    <pre class="programlisting con"><code class="hljs-con"><span class="hljs-con-meta">&gt;&gt;&gt;</span> {<span class="hljs-con-number">10</span>: <span class="hljs-con-string">'a'</span>, <span class="hljs-con-number">20</span>: <span class="hljs-con-string">'b'</span>}  <span class="hljs-con-comment"># doctest: +ELLIPSIS</span>&#13;
{...}&#13;
<span class="hljs-con-meta">&gt;&gt;&gt;</span> [<span class="hljs-con-literal">True</span>, <span class="hljs-con-number">1</span>, <span class="hljs-con-string">'a'</span>]  <span class="hljs-con-comment"># doctest: +ELLIPSIS</span>&#13;
[...]&#13;
<span class="hljs-con-meta">&gt;&gt;&gt;</span> <span class="hljs-con-literal">True</span>,  <span class="hljs-con-comment"># doctest: +ELLIPSIS</span>&#13;
(...)&#13;
<span class="hljs-con-meta">&gt;&gt;&gt;</span> [<span class="hljs-con-number">1</span>, <span class="hljs-con-number">2</span>, <span class="hljs-con-number">3</span>, <span class="hljs-con-number">4</span>]  <span class="hljs-con-comment"># doctest: +ELLIPSIS</span>&#13;
[1, ..., 4]&#13;
<span class="hljs-con-meta">&gt;&gt;&gt;</span> [<span class="hljs-con-number">1</span>, <span class="hljs-con-number">0</span>, <span class="hljs-con-number">0</span>, <span class="hljs-con-number">0</span>, <span class="hljs-con-number">0</span>, <span class="hljs-con-number">0</span>, <span class="hljs-con-number">4</span>]  <span class="hljs-con-comment"># doctest: +ELLIPSIS</span>&#13;
[1, ..., 4]&#13;
</code></pre>&#13;
    <p class="normal">These cases are not too useful in real scenarios, but they demonstrate how the <code class="inlineCode">ELLIPSIS</code> option flag functions. They also indicate the danger. Both <code class="inlineCode">[1, 2, 3, 4]</code> and <code class="inlineCode">[1, 0, ... , 4]</code> match the <code class="inlineCode">[1, ..., 4]</code> test, which is probably unintentional, so be very careful while using <code class="inlineCode">ELLIPSIS</code>.</p>&#13;
    <p class="normal">A more useful case is when documenting class instances:</p>&#13;
    <pre class="programlisting con"><code class="hljs-con"><span class="hljs-con-meta">&gt;&gt;&gt;</span> <span class="hljs-con-keyword">class</span><span class="hljs-con-class"> </span><span class="hljs-con-title">Spam</span><span class="hljs-con-class">(</span><span class="hljs-con-built_in">object</span><span class="hljs-con-class">):</span>&#13;
<span class="hljs-con-meta">...</span>     <span class="hljs-con-keyword">pass</span>&#13;
&#13;
<span class="hljs-con-meta">&gt;&gt;&gt;</span> Spam()  <span class="hljs-con-comment"># doctest: +ELLIPSIS</span>&#13;
&lt;__main__.Spam object at 0x...&gt;&#13;
</code></pre>&#13;
    <p class="normal">Without the <code class="inlineCode">ELLIPSIS</code> flag, the <a id="_idIndexMarker745"/>memory address (the <code class="inlineCode">0x...</code> part) would never be what you expect. Let’s demonstrate an actual run in a normal CPython instance:</p>&#13;
    <pre class="programlisting con"><code class="hljs-con">Failed example:&#13;
    Spam()&#13;
Expected:&#13;
    &lt;__main__.Spam object at 0x...&gt;&#13;
Got:&#13;
    &lt;__main__.Spam object at 0x10d9ad160&gt;&#13;
</code></pre>&#13;
    <h2 id="_idParaDest-271" class="heading-2">Doctest quirks</h2>&#13;
    <p class="normal">The three option<a id="_idIndexMarker746"/> flags discussed earlier take care of quite a few quirks found in doctests, but there are several more cases that require care. In these cases, you just need to be a bit careful and work around the limitations of the <code class="inlineCode">doctest</code> module. The <code class="inlineCode">doctest</code> module effectively uses the representation string, and those are not always consistent.</p>&#13;
    <div class="note">&#13;
      <p class="normal">The representation string can be generated using <code class="inlineCode">repr(object)</code> and uses the <code class="inlineCode">__repr__</code> magic method internally. On regular classes without a specific <code class="inlineCode">__repr__</code> method, this will look like <code class="inlineCode">&lt;module.className instance at 0x....&gt;</code>, where the <code class="inlineCode">0x...</code> is the memory address of the object, which changes with each run and each object.</p>&#13;
    </div>&#13;
    <p class="normal">The most important cases are floating-point inaccuracies, and random values, such as timers. With the following example, the floating-point example will return consistent results for your system, but on a different system it is likely to fail. The <code class="inlineCode">time</code> example will almost certainly always fail:</p>&#13;
    <pre class="programlisting con"><code class="hljs-con"><span class="hljs-con-meta">&gt;&gt;&gt;</span> <span class="hljs-con-number">1.</span>/<span class="hljs-con-number">7.</span>&#13;
0.14285714285714285&#13;
&#13;
<span class="hljs-con-meta">&gt;&gt;&gt;</span> <span class="hljs-con-keyword">import</span> time&#13;
&#13;
<span class="hljs-con-meta">&gt;&gt;&gt;</span> time.time() - time.time()&#13;
-9.5367431640625e-07&#13;
</code></pre>&#13;
    <p class="normal">All the problems have several possible solutions, which differ mostly in style and your personal preference.</p>&#13;
    <h3 id="_idParaDest-272" class="heading-3">Testing dictionaries</h3>&#13;
    <p class="normal">Since the<a id="_idIndexMarker747"/> implementation of dictionaries has changed in recent Python versions, this exact issue is probably one you will not encounter anymore. However, there are still situations where similar solutions are useful.</p>&#13;
    <p class="normal">The problem with dictionaries used to be that they had an effectively random representation order. Since the <code class="inlineCode">doctest</code> system requires a representation string that is identical in meaning (save for certain <code class="inlineCode">doctest</code> flags, of course) to the <code class="inlineCode">docstring</code>, this does not work. Naturally, there are several workaround options available and all have some advantages and disadvantages.</p>&#13;
    <p class="normal">The first is using the <code class="inlineCode">pprint</code> (pretty print) library to format the dictionary in a pretty and consistent way:</p>&#13;
    <pre class="programlisting con"><code class="hljs-con"><span class="hljs-con-meta">&gt;&gt;&gt;</span> <span class="hljs-con-keyword">import</span> pprint&#13;
&#13;
<span class="hljs-con-meta">&gt;&gt;&gt;</span> data = <span class="hljs-con-built_in">dict</span>.fromkeys(<span class="hljs-con-string">'spam'</span>)&#13;
<span class="hljs-con-meta">&gt;&gt;&gt;</span> pprint.pprint(data)&#13;
{'a': None, 'm': None, 'p': None, 's': None}&#13;
</code></pre>&#13;
    <p class="normal">Since the <code class="inlineCode">pprint</code> library always sorts the items before outputting, this solves the problem with random representation orders. However, it does require an extra import and function call, which some people prefer to avoid.</p>&#13;
    <p class="normal">Another option is manual sorting of the items:</p>&#13;
    <pre class="programlisting con"><code class="hljs-con"><span class="hljs-con-meta">&gt;&gt;&gt;</span> data = <span class="hljs-con-built_in">dict</span>.fromkeys(<span class="hljs-con-string">'spam'</span>)&#13;
<span class="hljs-con-meta">&gt;&gt;&gt;</span> <span class="hljs-con-built_in">sorted</span>(data.items())&#13;
[('a', None), ('m', None), ('p', None), ('s', None)]&#13;
</code></pre>&#13;
    <p class="normal">The downside here is that it is not visible from the output that <code class="inlineCode">data</code> is a dictionary, which makes the output less readable.</p>&#13;
    <p class="normal">Lastly, comparing the <code class="inlineCode">dict</code> with a different <code class="inlineCode">dict</code> comprising the same elements works as well:</p>&#13;
    <pre class="programlisting con"><code class="hljs-con"><span class="hljs-con-meta">&gt;&gt;&gt;</span> data = <span class="hljs-con-built_in">dict</span>.fromkeys(<span class="hljs-con-string">'spam'</span>)&#13;
<span class="hljs-con-meta">&gt;&gt;&gt;</span> data == {<span class="hljs-con-string">'a'</span>: <span class="hljs-con-literal">None</span>, <span class="hljs-con-string">'m'</span>: <span class="hljs-con-literal">None</span>, <span class="hljs-con-string">'p'</span>: <span class="hljs-con-literal">None</span>, <span class="hljs-con-string">'s'</span>: <span class="hljs-con-literal">None</span>}&#13;
True&#13;
</code></pre>&#13;
    <p class="normal">A perfectly okay solution, of course! But <code class="inlineCode">True</code> is not really the clearest output, especially if the comparison doesn’t work:</p>&#13;
    <pre class="programlisting con"><code class="hljs-con">Failed example:&#13;
    data == {'a': None, 'm': None, 'p': None}&#13;
Expected:&#13;
    True&#13;
Got:&#13;
    False&#13;
</code></pre>&#13;
    <p class="normal">On the other hand, the other options presented previously show both the expected value and the returned value correctly:</p>&#13;
    <pre class="programlisting con"><code class="hljs-con">Failed example:&#13;
    sorted(data.items())&#13;
Expected:&#13;
    [('a', None), ('m', None), ('p', None)]&#13;
Got:&#13;
    [('a', None), ('m', None), ('p', None), ('s', None)]&#13;
&#13;
Failed example:&#13;
    pprint.pprint(data)&#13;
Expected:&#13;
    {'a': None, 'm': None, 'p': None}&#13;
Got:&#13;
    {'a': None, 'm': None, 'p': None, 's': None}&#13;
</code></pre>&#13;
    <p class="normal">Personally, out of<a id="_idIndexMarker748"/> the solutions presented, I would recommend using <code class="inlineCode">pprint</code>, as I find it the most readable solution, but all the solutions have some merits to them.</p>&#13;
    <h3 id="_idParaDest-273" class="heading-3">Testing floating-point numbers</h3>&#13;
    <p class="normal">For the same reason a <a id="_idIndexMarker749"/>floating-point comparison can be problematic (that is, <code class="inlineCode">1/3 == 0.333</code>), a representation string comparison is also problematic. The easiest solution is to round or clip the value, but the <code class="inlineCode">ELLIPSIS</code> flag is also an option here. Here is a list of several solutions:</p>&#13;
    <pre class="programlisting con"><code class="hljs-con"><span class="hljs-con-meta">&gt;&gt;&gt;</span> <span class="hljs-con-number">1</span>/<span class="hljs-con-number">3</span>  <span class="hljs-con-comment"># doctest: +ELLIPSIS</span>&#13;
0.333...&#13;
<span class="hljs-con-meta">&gt;&gt;&gt;</span> <span class="hljs-con-string">'%.3f'</span> % (<span class="hljs-con-number">1</span>/<span class="hljs-con-number">3</span>)&#13;
'0.333'&#13;
<span class="hljs-con-meta">&gt;&gt;&gt;</span> <span class="hljs-con-string">'{:.3f}'</span>.<span class="hljs-con-built_in">format</span>(<span class="hljs-con-number">1</span>/<span class="hljs-con-number">3</span>)&#13;
'0.333'&#13;
<span class="hljs-con-meta">&gt;&gt;&gt;</span> <span class="hljs-con-built_in">round</span>(<span class="hljs-con-number">1</span>/<span class="hljs-con-number">3</span>, <span class="hljs-con-number">3</span>)&#13;
0.333&#13;
<span class="hljs-con-meta">&gt;&gt;&gt;</span> <span class="hljs-con-number">0.333</span> &lt; <span class="hljs-con-number">1</span>/<span class="hljs-con-number">3</span> &lt; <span class="hljs-con-number">0.334</span>&#13;
True&#13;
</code></pre>&#13;
    <p class="normal">Which solution<a id="_idIndexMarker750"/> you choose should depend on your own preference or consistency with the project you are working on. In general, my choice would be to enable the <code class="inlineCode">ELLIPSIS</code> option flag globally and go for that solution, as it looks the cleanest to me. </p>&#13;
    <h3 id="_idParaDest-274" class="heading-3">Times and durations</h3>&#13;
    <p class="normal">For timings, the problems that you will encounter are quite similar to the floating-point issues. When measuring the execution time of a code snippet, there will always be some variation present. That’s why limiting the precision is the easiest solution for time dependent tests. To achieve this we can check whether the delta (difference) between the two times is smaller than a certain number:</p>&#13;
    <pre class="programlisting con"><code class="hljs-con"><span class="hljs-con-meta">&gt;&gt;&gt;</span> <span class="hljs-con-keyword">import</span> time&#13;
&#13;
<span class="hljs-con-meta">&gt;&gt;&gt;</span> a = time.time()&#13;
<span class="hljs-con-meta">&gt;&gt;&gt;</span> b = time.time()&#13;
<span class="hljs-con-meta">&gt;&gt;&gt;</span> (b - a) &lt; <span class="hljs-con-number">0.01</span>&#13;
True&#13;
</code></pre>&#13;
    <p class="normal">For the <code class="inlineCode">timedelta</code> objects, however, it’s slightly more complicated. Yet, this is where the <code class="inlineCode">ELLIPSIS</code> flag definitely comes in handy again:</p>&#13;
    <pre class="programlisting con"><code class="hljs-con"><span class="hljs-con-meta">&gt;&gt;&gt;</span> <span class="hljs-con-keyword">import</span> datetime&#13;
&#13;
<span class="hljs-con-meta">&gt;&gt;&gt;</span> a = datetime.datetime.now()&#13;
<span class="hljs-con-meta">&gt;&gt;&gt;</span> b = datetime.datetime.now()&#13;
<span class="hljs-con-meta">&gt;&gt;&gt;</span> <span class="hljs-con-built_in">str</span>(b - a)  <span class="hljs-con-comment"># doctest: +ELLIPSIS</span>&#13;
'0:00:00.000...&#13;
</code></pre>&#13;
    <p class="normal">The <a id="_idIndexMarker751"/>alternative to the <code class="inlineCode">ELLIPSIS</code> option flag would be comparing the days, hours, minutes, and microseconds in <code class="inlineCode">timedelta</code> separately. Or you can use <code class="inlineCode">timedelta.total_seconds()</code> to convert the <code class="inlineCode">timedelta</code> into seconds and use a regular floating-point comparison.</p>&#13;
    <p class="normal">In a later paragraph, we will see a completely stable solution for problems like these using mock objects. For doctests, however, that is generally overkill.</p>&#13;
    <p class="normal">Now that we are done with <code class="inlineCode">doctest</code>, it is time to continue with more explicit tests using <code class="inlineCode">py.test</code>.</p>&#13;
    <h1 id="_idParaDest-275" class="heading-1">Testing with py.test</h1>&#13;
    <p class="normal">The <code class="inlineCode">py.test</code> tool <a id="_idIndexMarker752"/>makes it very easy to write tests and run them. There are a <a id="_idIndexMarker753"/>few other options such as <code class="inlineCode">nose2</code> and the bundled <code class="inlineCode">unittest</code> module available, but the <code class="inlineCode">py.test</code> library offers a very good combination of usability and active development. In the past, I was an avid <code class="inlineCode">nose</code> user but have since switched to <code class="inlineCode">py.test</code> as it tends to be easier to use and has better community support, in my experience at least. Regardless, <code class="inlineCode">nose2</code> is still a good choice, and if you’re already using either <code class="inlineCode">nose</code> or <code class="inlineCode">nose2</code>, there is little reason to switch and rewrite all of your tests. When writing tests for a new project, however, <code class="inlineCode">py.test</code> can be much more convenient.</p>&#13;
    <p class="normal">Now, we will run the doctests from the previously discussed <code class="inlineCode">square.py</code> file using <code class="inlineCode">py.test</code>.</p>&#13;
    <p class="normal">First, start by installing <code class="inlineCode">py.test</code>, of course:</p>&#13;
    <pre class="programlisting con"><code class="hljs-con"><span class="hljs-con-meta">$ </span>pip3 install pytest pytest-flake8&#13;
</code></pre>&#13;
    <div class="note">&#13;
      <p class="normal">We also installed <code class="inlineCode">pytest-flake8</code> here because the default <code class="inlineCode">pytest.ini</code> for this project depends on it. We will discuss what it does and how it can be configured later in this chapter.</p>&#13;
    </div>&#13;
    <p class="normal">Now you can do a test run, so let’s give the doctests we have in <code class="inlineCode">square.py</code> a try:</p>&#13;
    <pre class="programlisting con"><code class="hljs-con"><span class="hljs-con-meta">$</span> py.test --doctest-modules -v square.py&#13;
===================== test session starts ======================&#13;
collected 2 items&#13;
&#13;
square.py::square.square PASSED [100%]&#13;
&#13;
====================== 1 passed in 0.03s =======================&#13;
</code></pre>&#13;
    <p class="normal">We can see that <code class="inlineCode">py.test</code> was able to find two tests for the given file: the test in <code class="inlineCode">square.square</code> itself, and a <code class="inlineCode">flake8</code> test from the <code class="inlineCode">pytest-flake8</code> plugin that we will see later in this chapter.</p>&#13;
    <h2 id="_idParaDest-276" class="heading-2">The difference between the unittest and py.test output</h2>&#13;
    <p class="normal">We have the doctests in <code class="inlineCode">square.py</code>. Let’s create a new class called <code class="inlineCode">cube</code> and create a proper set of tests outside of the code.</p>&#13;
    <p class="normal">First of all, we have the code of <code class="inlineCode">cube.py</code>, similar to <code class="inlineCode">square.py</code> but minus the doctests, since they mostly won’t work anyway:</p>&#13;
    <pre class="programlisting code"><code class="hljs-code"><span class="hljs-keyword">def</span><span class="hljs-function"> </span><span class="hljs-title">cube</span><span class="hljs-function">(</span><span class="hljs-params">n: </span><span class="hljs-built_in">int</span><span class="hljs-function">) -&gt; int:</span>&#13;
    <span class="hljs-string">'''</span>&#13;
<span class="hljs-string">    Returns the input number, cubed</span>&#13;
<span class="hljs-string">    Args:</span>&#13;
<span class="hljs-string">        n (int): The number to cube</span>&#13;
<span class="hljs-string">    Returns:</span>&#13;
<span class="hljs-string">        int: The cubed result</span>&#13;
<span class="hljs-string">    '''</span>&#13;
    <span class="hljs-keyword">return</span> n ** <span class="hljs-number">3</span>&#13;
</code></pre>&#13;
    <p class="normal">Now let’s start <a id="_idIndexMarker754"/>with the <code class="inlineCode">unittest</code> example, <code class="inlineCode">T_09_test_cube.py</code>:</p>&#13;
    <pre class="programlisting code"><code class="hljs-code"><span class="hljs-keyword">import</span> cube&#13;
<span class="hljs-keyword">import</span> unittest&#13;
&#13;
<span class="hljs-keyword">class</span><span class="hljs-class"> </span><span class="hljs-title">TestCube</span><span class="hljs-class">(</span><span class="hljs-params">unittest.TestCase</span><span class="hljs-class">):</span>&#13;
    <span class="hljs-keyword">def</span><span class="hljs-function"> </span><span class="hljs-title">test_0</span><span class="hljs-function">(</span><span class="hljs-params">self</span><span class="hljs-function">):</span>&#13;
        self.assertEqual(cube.cube(<span class="hljs-number">0</span>), <span class="hljs-number">0</span>)&#13;
&#13;
    <span class="hljs-keyword">def</span><span class="hljs-function"> </span><span class="hljs-title">test_1</span><span class="hljs-function">(</span><span class="hljs-params">self</span><span class="hljs-function">):</span>&#13;
        self.assertEqual(cube.cube(<span class="hljs-number">1</span>), <span class="hljs-number">1</span>)&#13;
&#13;
    <span class="hljs-keyword">def</span><span class="hljs-function"> </span><span class="hljs-title">test_2</span><span class="hljs-function">(</span><span class="hljs-params">self</span><span class="hljs-function">):</span>&#13;
        self.assertEqual(cube.cube(<span class="hljs-number">2</span>), <span class="hljs-number">8</span>)&#13;
&#13;
    <span class="hljs-keyword">def</span><span class="hljs-function"> </span><span class="hljs-title">test_3</span><span class="hljs-function">(</span><span class="hljs-params">self</span><span class="hljs-function">):</span>&#13;
        self.assertEqual(cube.cube(<span class="hljs-number">3</span>), <span class="hljs-number">27</span>)&#13;
&#13;
    <span class="hljs-keyword">def</span><span class="hljs-function"> </span><span class="hljs-title">test_no_arguments</span><span class="hljs-function">(</span><span class="hljs-params">self</span><span class="hljs-function">):</span>&#13;
        <span class="hljs-keyword">with</span> self.assertRaises(TypeError):&#13;
            cube.cube()&#13;
&#13;
    <span class="hljs-keyword">def</span><span class="hljs-function"> </span><span class="hljs-title">test_exception_str</span><span class="hljs-function">(</span><span class="hljs-params">self</span><span class="hljs-function">):</span>&#13;
        <span class="hljs-keyword">with</span> self.assertRaises(TypeError):&#13;
            cube.cube(<span class="hljs-string">'x'</span>)&#13;
&#13;
<span class="hljs-keyword">if</span> __name__ == <span class="hljs-string">'__main__'</span>:&#13;
    unittest.main()&#13;
</code></pre>&#13;
    <p class="normal">This can be executed by executing the file itself:</p>&#13;
    <pre class="programlisting con"><code class="hljs-con"><span class="hljs-con-meta">$</span> python3 T_09_test_cube.py -v&#13;
test_0 (__main__.TestCube) ... ok&#13;
test_1 (__main__.TestCube) ... ok&#13;
test_2 (__main__.TestCube) ... ok&#13;
test_3 (__main__.TestCube) ... ok&#13;
test_exception_str (__main__.TestCube) ... ok&#13;
test_no_arguments (__main__.TestCube) ... ok&#13;
&#13;
----------------------------------------------------------------&#13;
Ran 6 tests in 0.000s&#13;
&#13;
OK&#13;
</code></pre>&#13;
    <p class="normal">Alternatively, it can be done <a id="_idIndexMarker755"/>through the <code class="inlineCode">unittest</code> module:</p>&#13;
    <pre class="programlisting con"><code class="hljs-con"><span class="hljs-con-meta">$</span> python3 -m unittest -v T_09_test_cube.py&#13;
...&#13;
</code></pre>&#13;
    <p class="normal">But it also works with<a id="_idIndexMarker756"/> other tools such as <code class="inlineCode">py.test</code>:</p>&#13;
    <pre class="programlisting con"><code class="hljs-con"><span class="hljs-con-meta">$</span> py.test -v T_09_test_cube.py&#13;
===================== test session starts ======================&#13;
&#13;
collected 7 items&#13;
&#13;
T_09_test_cube.py::FLAKE8 SKIPPED                        [ 14%]&#13;
T_09_test_cube.py::TestCube::test_0 PASSED               [ 28%]&#13;
T_09_test_cube.py::TestCube::test_1 PASSED               [ 42%]&#13;
T_09_test_cube.py::TestCube::test_2 PASSED               [ 57%]&#13;
T_09_test_cube.py::TestCube::test_3 PASSED               [ 71%]&#13;
T_09_test_cube.py::TestCube::test_exception_str PASSED   [ 85%]&#13;
T_09_test_cube.py::TestCube::test_no_arguments PASSED    [100%]&#13;
&#13;
================= 6 passed, 1 skipped in 0.08s =================&#13;
</code></pre>&#13;
    <p class="normal">And other tools<a id="_idIndexMarker757"/> such as <code class="inlineCode">nose</code> are also possible. First, we need to install it using pip:</p>&#13;
    <pre class="programlisting con"><code class="hljs-con"><span class="hljs-con-meta">$</span> pip3 install nose&#13;
</code></pre>&#13;
    <p class="normal">After that, we can use the <code class="inlineCode">nosetests</code> command to run:</p>&#13;
    <pre class="programlisting con"><code class="hljs-con"><span class="hljs-con-meta">$</span> nosetests -v T_09_test_cube.py&#13;
test_0 (T_09_test_cube.TestCube) ... ok&#13;
test_1 (T_09_test_cube.TestCube) ... ok&#13;
test_2 (T_09_test_cube.TestCube) ... ok&#13;
test_3 (T_09_test_cube.TestCube) ... ok&#13;
test_exception_str (T_09_test_cube.TestCube) ... ok&#13;
test_no_arguments (T_09_test_cube.TestCube) ... ok&#13;
&#13;
-------------------------------------------------------------&#13;
Ran 6 tests in 0.001s&#13;
&#13;
OK&#13;
</code></pre>&#13;
    <p class="normal">As long as all the results are successful, the differences between the output from <code class="inlineCode">unittest</code> and <code class="inlineCode">py.test</code> are slim. This time around, however, we are going to break the code to show the difference when it actually matters. Instead of the <code class="inlineCode">cube</code> code, we will add the <code class="inlineCode">square</code> code, returning <code class="inlineCode">n ** 2</code> from <code class="inlineCode">square</code>, instead of <code class="inlineCode">n ** 3</code>.</p>&#13;
    <p class="normal">To reduce the amount of output, we will not be running the verbose variants of the commands here.</p>&#13;
    <p class="normal">First of all, we have the regular <code class="inlineCode">unittest</code> output:</p>&#13;
    <pre class="programlisting con"><code class="hljs-con"><span class="hljs-con-meta">$</span> python3 T_09_test_cube.py&#13;
..FF..&#13;
================================================================&#13;
FAIL: test_2 (__main__.TestCube)&#13;
----------------------------------------------------------------&#13;
Traceback (most recent call last):&#13;
  File " T_09_test_cube.py", line 14, in test_2&#13;
    self.assertEqual(cube.cube(2), 8)&#13;
AssertionError: 4 != 8&#13;
&#13;
================================================================&#13;
FAIL: test_3 (__main__.TestCube)&#13;
----------------------------------------------------------------&#13;
Traceback (most recent call last):&#13;
  File " T_09_test_cube.py", line 17, in test_3&#13;
    self.assertEqual(cube.cube(3), 27)&#13;
AssertionError: 9 != 27&#13;
&#13;
----------------------------------------------------------------&#13;
Ran 6 tests in 0.001s&#13;
&#13;
FAILED (failures=2)&#13;
</code></pre>&#13;
    <p class="normal">Not all that bad, as each test <a id="_idIndexMarker758"/>returns a nice stack trace that includes the values and everything. Yet, we can observe a small difference here when compared with the <code class="inlineCode">py.test</code> run:</p>&#13;
    <pre class="programlisting con"><code class="hljs-con"><span class="hljs-con-meta">$</span> py.test T_09_test_cube.py&#13;
===================== test session starts ======================&#13;
collected 7 items&#13;
&#13;
T_09_test_cube.py s..FF..                                [100%]&#13;
&#13;
=========================== FAILURES ===========================&#13;
_______________________ TestCube.test_2 ________________________&#13;
&#13;
self = &lt;T_09_test_cube.TestCube testMethod=test_2&gt;&#13;
&#13;
    def test_2(self):&#13;
<span class="hljs-con-meta">&gt;</span>       self.assertEqual(cube.cube(2), 8)&#13;
E       AssertionError: 4 != 8&#13;
&#13;
T_09_test_cube.py:14: AssertionError&#13;
_______________________ TestCube.test_3 ________________________&#13;
&#13;
self = &lt;T_09_test_cube.TestCube testMeth&#13;
od=test_3&gt;&#13;
&#13;
    def test_3(self):&#13;
<span class="hljs-con-meta">&gt;</span>       self.assertEqual(cube.cube(3), 27)&#13;
E       AssertionError: 9 != 27&#13;
&#13;
T_09_test_cube.py:17: AssertionError&#13;
=================== short test summary info ====================&#13;
FAILED T_09_test_cube.py::TestCube::test_2 - AssertionError: 4..&#13;
FAILED T_09_test_cube.py::TestCube::test_3 - AssertionError: 9..&#13;
============ 2 failed, 4 passed, 1 skipped in 0.17s ============&#13;
</code></pre>&#13;
    <p class="normal">In small cases such as these, the difference is not all that apparent, but when testing complicated code with large stack traces, it becomes even more useful. However, for me personally, seeing the surrounding test code is a big advantage. </p>&#13;
    <p class="normal">In the example that was just discussed, the <code class="inlineCode">self.assertEqual(...)</code> line shows the entire test, but in many other cases, you will need more information. The difference between the regular <code class="inlineCode">unittest</code> module and the <code class="inlineCode">py.test</code> module is that with <code class="inlineCode">py.test</code> you can see the entire function with all of the code and the output. Later in this chapter, we will see how powerful this can be when writing more advanced tests.</p>&#13;
    <p class="normal">To truly <a id="_idIndexMarker759"/>appreciate the <code class="inlineCode">py.test</code> output, we need colors as well. Unfortunately, that is not possible within the constraints of this book, but I strongly encourage you to give <code class="inlineCode">py.test</code> a try if you aren’t using it already.</p>&#13;
    <p class="normal">Perhaps you are wondering now, “Is that all? The only difference between <code class="inlineCode">py.test</code> and <code class="inlineCode">unittest</code> is a bit of color and a slightly different output?” Well, far from it; there are many other differences, but this alone is enough reason to give it a try.</p>&#13;
    <h2 id="_idParaDest-277" class="heading-2">The difference between unittest and py.test tests</h2>&#13;
    <p class="normal">The improved output does help a bit, but the combination of improved output and a much easier way to write tests is what makes <code class="inlineCode">py.test</code> so useful. There are quite a few methods for making the tests simpler and more legible, and in many cases, you can choose which you prefer. As always, readability counts, so choose wisely and try not to over-engineer the solutions.</p>&#13;
    <h3 id="_idParaDest-278" class="heading-3">Simplifying assertions</h3>&#13;
    <p class="normal">Where the <code class="inlineCode">unittest</code> library<a id="_idIndexMarker760"/> requires the usage of <code class="inlineCode">self.assertEqual</code> to compare variables, <code class="inlineCode">py.test</code> allows the use of a regular <code class="inlineCode">assert</code> statement while still understanding the comparison between the variables.</p>&#13;
    <p class="normal">The following test file contains three styles of tests, so they can be compared easily:</p>&#13;
    <pre class="programlisting code"><code class="hljs-code"><span class="hljs-keyword">import</span> unittest&#13;
<span class="hljs-keyword">import</span> cube&#13;
&#13;
n = <span class="hljs-number">2</span>&#13;
expected = <span class="hljs-number">8</span>&#13;
&#13;
<span class="hljs-comment"># Regular unit test</span>&#13;
<span class="hljs-keyword">class</span><span class="hljs-class"> </span><span class="hljs-title">TestCube</span><span class="hljs-class">(</span><span class="hljs-params">unittest.TestCase</span><span class="hljs-class">):</span>&#13;
    <span class="hljs-keyword">def</span><span class="hljs-function"> </span><span class="hljs-title">test_2</span><span class="hljs-function">(</span><span class="hljs-params">self</span><span class="hljs-function">):</span>&#13;
        self.assertEqual(cube.cube(n), expected)&#13;
&#13;
    <span class="hljs-keyword">def</span><span class="hljs-function"> </span><span class="hljs-title">test_no_arguments</span><span class="hljs-function">(</span><span class="hljs-params">self</span><span class="hljs-function">):</span>&#13;
        <span class="hljs-keyword">with</span> self.assertRaises(TypeError):&#13;
            cube.cube()&#13;
&#13;
<span class="hljs-comment"># py.test class</span>&#13;
<span class="hljs-keyword">class</span><span class="hljs-class"> </span><span class="hljs-title">TestPyCube</span><span class="hljs-class">:</span>&#13;
    <span class="hljs-keyword">def</span><span class="hljs-function"> </span><span class="hljs-title">test_2</span><span class="hljs-function">(</span><span class="hljs-params">self</span><span class="hljs-function">):</span>&#13;
        <span class="hljs-keyword">assert</span> cube.cube(n) == expected&#13;
&#13;
<span class="hljs-comment"># py.test functions</span>&#13;
<span class="hljs-keyword">def</span><span class="hljs-function"> </span><span class="hljs-title">test_2</span><span class="hljs-function">():</span>&#13;
    <span class="hljs-keyword">assert</span> cube.cube(n) == expected&#13;
</code></pre>&#13;
    <p class="normal">To convert to <code class="inlineCode">py.test</code>, we simply replaced <code class="inlineCode">self.assertEqual</code> with <code class="inlineCode">assert ... == ...</code>. A minor improvement indeed, but the actual benefit is seen in the failure output. The first two use <a id="_idIndexMarker761"/>the <code class="inlineCode">unittest</code> style and the latter two use the <code class="inlineCode">py.test</code> style both inside a class and as separate functions:</p>&#13;
    <pre class="programlisting con"><code class="hljs-con"><span class="hljs-con-meta">$</span> py.test T_10_simplifying_assertions.py&#13;
...&#13;
=========================== FAILURES ===========================&#13;
_______________________ TestCube.test_2 ________________________&#13;
&#13;
self = &lt;TestCube testMethod=test_2&gt;&#13;
&#13;
    def test_2(self):&#13;
<span class="hljs-con-meta">&gt;</span>       self.assertEqual(cube.cube(n), expected)&#13;
E       AssertionError: 4 != 8&#13;
&#13;
T_10_simplifying_assertions.py:12: AssertionError&#13;
______________________ TestPyCube.test_2 _______________________&#13;
&#13;
self = &lt;TestPyCube object at 0x...&gt;&#13;
&#13;
    def test_2(self):&#13;
<span class="hljs-con-meta">&gt;</span>       assert cube.cube(n) == expected&#13;
E       assert 4 == 8&#13;
E        +  where 4 = &lt;function cube at 0x...&gt;(2)&#13;
E        +    where &lt;function cube at 0x...&gt; = cube.cube&#13;
&#13;
T_10_simplifying_assertions.py:23: AssertionError&#13;
____________________________ test_2 ____________________________&#13;
&#13;
    def test_2():&#13;
<span class="hljs-con-meta">&gt;</span>       assert cube.cube(n) == expected&#13;
E       assert 4 == 8&#13;
E        +  where 4 = &lt;function cube at 0x...&gt;(2)&#13;
E        +    where &lt;function cube at 0x...&gt; = cube.cube&#13;
&#13;
T_10_simplifying_assertions.py:28: AssertionError&#13;
=================== short test summary info ====================&#13;
FAILED T_10_simplifying_assertions.py::TestCube::test_2 - Ass...&#13;
FAILED T_10_simplifying_assertions.py::TestPyCube::test_2 - a...&#13;
FAILED T_10_simplifying_assertions.py::test_2 - assert 4 == 8&#13;
============ 3 failed, 1 passed, 1 skipped in 0.15s ============&#13;
</code></pre>&#13;
    <p class="normal">In addition to seeing the values that were compared, we can actually see the function that was called and which input parameters it received. With the regular <code class="inlineCode">unittest</code> we have no way of knowing that <code class="inlineCode">2</code> was entered as a parameter to the <code class="inlineCode">cube()</code> function.</p>&#13;
    <p class="normal">The standard <code class="inlineCode">py.test</code> behavior works for most test cases, but it may not be enough for some custom types. For example, let’s say that we have a <code class="inlineCode">User</code> object with a <code class="inlineCode">name</code> attribute that<a id="_idIndexMarker762"/> should be compared with the <code class="inlineCode">name</code> attribute on another object. This part can easily be achieved by implementing the <code class="inlineCode">__eq__</code> method on <code class="inlineCode">User</code>, but it does not improve clarity. Since <code class="inlineCode">name</code> is the attribute that we compare, it would be useful if the tests showed <code class="inlineCode">name</code> when errors were displayed. </p>&#13;
    <p class="normal">First is the class with two tests, one working and one broken to demonstrate the regular output:</p>&#13;
    <p class="normal"><code class="inlineCode">T_11_representing_assertions.py</code></p>&#13;
    <pre class="programlisting code"><code class="hljs-code"><span class="hljs-keyword">class</span><span class="hljs-class"> </span><span class="hljs-title">User</span><span class="hljs-class">:</span>&#13;
    <span class="hljs-keyword">def</span><span class="hljs-function"> </span><span class="hljs-title">__init__</span><span class="hljs-function">(</span><span class="hljs-params">self, name</span><span class="hljs-function">):</span>&#13;
        self.name = name&#13;
&#13;
    <span class="hljs-keyword">def</span><span class="hljs-function"> </span><span class="hljs-title">__eq__</span><span class="hljs-function">(</span><span class="hljs-params">self, other</span><span class="hljs-function">):</span>&#13;
        <span class="hljs-keyword">return</span> self.name == other.name&#13;
&#13;
<span class="hljs-keyword">def</span><span class="hljs-function"> </span><span class="hljs-title">test_user_equal</span><span class="hljs-function">():</span>&#13;
    a = User(<span class="hljs-string">'Rick'</span>)&#13;
    b = User(<span class="hljs-string">'Guido'</span>)&#13;
&#13;
    <span class="hljs-keyword">assert</span> a == b&#13;
</code></pre>&#13;
    <p class="normal">And here is the regular <code class="inlineCode">py.test</code> output:</p>&#13;
    <pre class="programlisting con"><code class="hljs-con">_______________________ test_user_equal ________________________&#13;
&#13;
    def test_user_equal():&#13;
        a = User('Rick')&#13;
        b = User('Guido')&#13;
&#13;
&gt;       assert a == b&#13;
E       assert &lt;T_11_representing_assertions.User object at 0x...&gt; == &lt;T_11_representing_assertions.User object at 0x...&gt;&#13;
&#13;
T_11_representing_assertions.py:13: AssertionError&#13;
=================== short test summary info ====================&#13;
FAILED T_11_representing_assertions.py::test_user_equal - asse...&#13;
================= 1 failed, 1 skipped in 0.17s =================&#13;
</code></pre>&#13;
    <p class="normal">The default<a id="_idIndexMarker763"/> test output is still usable since the function is fairly straightforward, and the value for <code class="inlineCode">name</code> is visible due to it being available in the constructor. However, it would have been more useful if we could explicitly see the value of <code class="inlineCode">name</code>. By adding a <code class="inlineCode">pytest_assertrepr_compare</code> function to the <code class="inlineCode">conftest.py</code> file, we can modify the behavior of the <code class="inlineCode">assert</code> statements.</p>&#13;
    <div class="note">&#13;
      <p class="normal">The <code class="inlineCode">conftest.py</code> file is a special file for <code class="inlineCode">py.test</code> that can be used to override or extend <code class="inlineCode">py.test</code>. Note that this file will automatically be loaded by every test run in that directory, so we need to test the types of both the left-hand side and the right-hand side of the operator. In this case, it’s <code class="inlineCode">a</code> and <code class="inlineCode">b</code>.</p>&#13;
    </div>&#13;
    <p class="normal"><code class="inlineCode">conftest.py</code></p>&#13;
    <pre class="programlisting code"><code class="hljs-code"><span class="hljs-keyword">from</span> T_12_assert_representation <span class="hljs-keyword">import</span> User&#13;
&#13;
<span class="hljs-keyword">def</span><span class="hljs-function"> </span><span class="hljs-title">is_user</span><span class="hljs-function">(</span><span class="hljs-params">value</span><span class="hljs-function">):</span>&#13;
    <span class="hljs-keyword">return</span> <span class="hljs-built_in">isinstance</span>(value, User)&#13;
&#13;
<span class="hljs-keyword">def</span><span class="hljs-function"> </span><span class="hljs-title">pytest_assertrepr_compare</span><span class="hljs-function">(</span><span class="hljs-params">config, op, left, right</span><span class="hljs-function">):</span>&#13;
    <span class="hljs-keyword">if</span> is_user(left) <span class="hljs-keyword">and</span> is_user(right) <span class="hljs-keyword">and</span> op == <span class="hljs-string">'=='</span>:&#13;
        <span class="hljs-keyword">return</span> [&#13;
            <span class="hljs-string">'Comparing User instances:'</span>,&#13;
            <span class="hljs-string">f'    name: </span><span class="hljs-subst">{left.name}</span><span class="hljs-string"> != </span><span class="hljs-subst">{right.name}</span><span class="hljs-string">'</span>,&#13;
        ]&#13;
</code></pre>&#13;
    <p class="normal">The preceding function will be used as the output for our test. So when it fails, this time we get our own, slightly more useful, output:</p>&#13;
    <pre class="programlisting con"><code class="hljs-con">    def test_user_equal():&#13;
        a = User('Rick')&#13;
        b = User('Guido')&#13;
&#13;
&gt;       assert a == b&#13;
E       assert Comparing User instances:&#13;
E             name: Rick != Guido&#13;
&#13;
T_12_assert_representation.py:13: AssertionError&#13;
</code></pre>&#13;
    <p class="normal">In this case, we <a id="_idIndexMarker764"/>could have easily changed the <code class="inlineCode">__repr__</code> function of <code class="inlineCode">User</code> as well, but there are many cases where modifying the <code class="inlineCode">py.test</code> output can be useful – if you need more debug output, for example. Similar to this, there is specific support for many types, such as sets, dictionaries, and texts.</p>&#13;
    <h3 id="_idParaDest-279" class="heading-3">Parameterizing tests</h3>&#13;
    <p class="normal">So far, we have <a id="_idIndexMarker765"/>specified every test separately, but we can simplify tests a lot by parameterizing them. The square and cube tests are very similar; a certain input gave a certain output.</p>&#13;
    <p class="normal">You could solve this by creating a loop in a test, but a loop in a test will be executed as a single test. This means that it will fail in its entirety if a single test iteration of the loop fails, which means you can’t easily see what exactly broke if you compare older and newer test output. In this example with the numbers, the result is obvious, but if you were to apply a list of filenames to a complicated processing test, it would be far less obvious what happened.</p>&#13;
    <p class="normal">In these cases, parameterized tests can help a lot. After creating a list of parameters and the expected output data, you can make it run the test function for every parameter combination separately:</p>&#13;
    <pre class="programlisting code"><code class="hljs-code"><span class="hljs-keyword">import</span> cube&#13;
<span class="hljs-keyword">import</span> pytest&#13;
&#13;
cubes = (&#13;
    (<span class="hljs-number">0</span>, <span class="hljs-number">0</span>),&#13;
    (<span class="hljs-number">1</span>, <span class="hljs-number">1</span>),&#13;
    (<span class="hljs-number">2</span>, <span class="hljs-number">8</span>),&#13;
    (<span class="hljs-number">3</span>, <span class="hljs-number">27</span>),&#13;
)&#13;
&#13;
<span class="hljs-meta">@pytest.mark.parametrize(</span><span class="hljs-string">'n,expected'</span><span class="hljs-params">, cubes</span><span class="hljs-meta">)</span>&#13;
<span class="hljs-keyword">def</span><span class="hljs-function"> </span><span class="hljs-title">test_cube</span><span class="hljs-function">(</span><span class="hljs-params">n, expected</span><span class="hljs-function">):</span>&#13;
    <span class="hljs-keyword">assert</span> cube.cube(n) == expected&#13;
</code></pre>&#13;
    <p class="normal">This outputs the <a id="_idIndexMarker766"/>following, as you might have already expected:</p>&#13;
    <pre class="programlisting con"><code class="hljs-con">=========================== FAILURES ===========================&#13;
________________________ test_cube[2-8] ________________________&#13;
&#13;
n = 2, expected = 8&#13;
    @pytest.mark.parametrize('n,expected', cubes)&#13;
    def test_cube(n, expected):&#13;
&gt;       assert cube.cube(n) == expected&#13;
E       assert 4 == 8&#13;
E        +  where 4 = &lt;function cube at 0x...&gt;(2)&#13;
E        +    where &lt;function cube at 0x...&gt; = cube.cube&#13;
&#13;
T_13_parameterizing_tests.py:15: AssertionError&#13;
_______________________ test_cube[3-27] ________________________&#13;
&#13;
n = 3, expected = 27&#13;
&#13;
    @pytest.mark.parametrize('n,expected', cubes)&#13;
    def test_cube(n, expected):&#13;
&gt;       assert cube.cube(n) == expected&#13;
E       assert 9 == 27&#13;
E        +  where 9 = &lt;function cube at 0x...&gt;(3)&#13;
E        +    where &lt;function cube at 0x...&gt; = cube.cube&#13;
&#13;
T_13_parameterizing_tests.py:15: AssertionError&#13;
=================== short test summary info ====================&#13;
FAILED T_13_parameterizing_tests.py::test_cube[2-8] - assert ...&#13;
FAILED T_13_parameterizing_tests.py::test_cube[3-27] - assert...&#13;
============ 2 failed, 2 passed, 1 skipped in 0.16s ============&#13;
</code></pre>&#13;
    <p class="normal">With the parameterized tests, we can see the parameters clearly, which means we can see all inputs and outputs without any extra effort.</p>&#13;
    <p class="normal">Generating the list of tests dynamically at runtime is also possible with a global function. Similar to the <code class="inlineCode">pytest_assertrepr_compare</code> function that we added to <code class="inlineCode">conftest.py</code> earlier, we can add a <code class="inlineCode">pytest_generate_tests</code> function, which generates tests.</p>&#13;
    <p class="normal">Creating the <code class="inlineCode">pytest_generate_tests</code> function can be useful only to test a subset of options<a id="_idIndexMarker767"/> depending on the configuration options. If possible, however, I recommend trying to configure selective tests using fixtures instead, as they are somewhat more explicit. We will cover this in the following section. The problem with functions such as <code class="inlineCode">pytest_generate_tests</code> is that they are global and don’t discriminate between specific tests, resulting in strange behavior if you are not expecting that.</p>&#13;
    <h3 id="_idParaDest-280" class="heading-3">Automatic arguments using fixtures</h3>&#13;
    <p class="normal">The <code class="inlineCode">py.test</code> fixture system<a id="_idIndexMarker768"/> is one of the most magical features of <code class="inlineCode">py.test</code>. It <a id="_idIndexMarker769"/>magically executes a fixture function with the same <strong class="keyWord">name</strong> as your arguments. Let’s create a basic fixture to demonstrate this:</p>&#13;
    <pre class="programlisting code"><code class="hljs-code"><span class="hljs-keyword">import</span> pytest&#13;
&#13;
<span class="hljs-meta">@pytest.fixture</span>&#13;
<span class="hljs-keyword">def</span><span class="hljs-function"> </span><span class="hljs-title">name</span><span class="hljs-function">():</span>&#13;
    <span class="hljs-keyword">return</span> <span class="hljs-string">'Rick'</span>&#13;
&#13;
<span class="hljs-keyword">def</span><span class="hljs-function"> </span><span class="hljs-title">test_something</span><span class="hljs-function">(</span><span class="hljs-params">name</span><span class="hljs-function">):</span>&#13;
    <span class="hljs-keyword">assert</span> name == <span class="hljs-string">'Rick'</span>&#13;
</code></pre>&#13;
    <p class="normal">When the <code class="inlineCode">test_something()</code> test is executed, the <code class="inlineCode">name</code> argument will be filled with the output from the <code class="inlineCode">name()</code> function automatically.</p>&#13;
    <p class="normal">Because arguments are automatically filled by fixtures, the naming of the arguments becomes very important, as fixtures can easily collide with other fixtures. To prevent collisions, the scope is set to <code class="inlineCode">function</code> by default. However, <code class="inlineCode">class</code>, <code class="inlineCode">module</code>, and <code class="inlineCode">session</code> are also valid options for the scope. There are several fixtures available by default, some of which you will use often, and others most likely never. A complete list can always be generated with the following command:</p>&#13;
    <pre class="programlisting con"><code class="hljs-con"><span class="hljs-con-meta">$</span> py.test --quiet --fixtures&#13;
...&#13;
capsys&#13;
    enables capturing of writes to sys.stdout/sys.stderr and&#13;
    makes captured output available via ''capsys.readouterr()''&#13;
    method calls which return a ''(out, err)'' tuple.&#13;
...&#13;
monkeypatch&#13;
    The returned ''monkeypatch'' funcarg provides these helper &#13;
    methods to modify objects, dictionaries or os.environ::&#13;
&#13;
    monkeypatch.setattr(obj, name, value, raising=True)&#13;
    monkeypatch.delattr(obj, name, raising=True)&#13;
    monkeypatch.setitem(mapping, name, value)&#13;
    monkeypatch.delitem(obj, name, raising=True)&#13;
    monkeypatch.setenv(name, value, prepend=False)&#13;
    monkeypatch.delenv(name, value, raising=True)&#13;
    monkeypatch.syspath_prepend(path)&#13;
    monkeypatch.chdir(path)&#13;
    All modifications will be undone after the requesting&#13;
    test function has finished. The ''raising''&#13;
    parameter determines if a KeyError or AttributeError&#13;
    will be raised if the set/deletion operation has no target.&#13;
...&#13;
tmpdir&#13;
    return a temporary directory path object which is unique to&#13;
    each test function invocation, created as a sub directory of&#13;
    the base temporary directory. The returned object is a&#13;
    'py.path.local'_ path object.&#13;
</code></pre>&#13;
    <p class="normal">The next few <a id="_idIndexMarker770"/>paragraphs demonstrate some fixture usage, and <a id="_idIndexMarker771"/>the <code class="inlineCode">monkeypatch</code> fixture is covered later in the chapter.</p>&#13;
    <h4 class="heading-4">cache</h4>&#13;
    <p class="normal">The <code class="inlineCode">cache</code> fixture<a id="_idIndexMarker772"/> is as simple as it is useful; there is a <code class="inlineCode">get</code> function and a <code class="inlineCode">set</code> function, and the <code class="inlineCode">cache</code> state remains between separate <code class="inlineCode">py.test</code> runs. To illustrate how to get and set values from <code class="inlineCode">cache</code>:</p>&#13;
    <pre class="programlisting code"><code class="hljs-code"> <span class="hljs-keyword">def</span><span class="hljs-function"> </span><span class="hljs-title">test_cache</span><span class="hljs-function">(</span><span class="hljs-params">cache</span><span class="hljs-function">):</span>&#13;
    counter = cache.get(<span class="hljs-string">'counter'</span>, <span class="hljs-number">0</span>) + <span class="hljs-number">1</span>&#13;
    <span class="hljs-keyword">assert</span> counter&#13;
    cache.<span class="hljs-built_in">set</span>(<span class="hljs-string">'counter'</span>, counter)&#13;
</code></pre>&#13;
    <div class="note">&#13;
      <p class="normal">The default value (<code class="inlineCode">0</code> in this case) is required for the <code class="inlineCode">cache.get</code> function.</p>&#13;
    </div>&#13;
    <p class="normal">The cache can be cleared through the <code class="inlineCode">--cache-clear</code> command-line parameter, and all caches can be shown through <code class="inlineCode">--cache-show</code>. Internally, the <code class="inlineCode">cache</code> fixture uses the <code class="inlineCode">json</code> module to encode/decode the values, so anything JSON encodable will work.</p>&#13;
    <h4 class="heading-4">Custom fixtures</h4>&#13;
    <p class="normal">Bundled fixtures are quite <a id="_idIndexMarker773"/>useful, but within most projects, you will want to create your own fixtures to make things easier. Fixtures make it trivial to repeat code that is needed more often. You are most likely wondering how this is different from a regular function, context wrapper, or something else, but the special thing about fixtures is that they themselves can accept fixtures as well. So, if your function needs the <code class="inlineCode">pytestconfig</code> variables, it can ask for them without needing to modify the calling functions.</p>&#13;
    <p class="normal">You can create a fixture out of anything that would be useful to reuse. The basic premise is simple enough: a function with the <code class="inlineCode">pytest.fixture</code> decorator, which returns a value that will be passed along as an argument. Also, the function can take parameters and fixtures just as any test can. </p>&#13;
    <p class="normal">The only notable variation is <code class="inlineCode">pytest.yield_fixture</code>. This fixture variation has one small difference: the actual test will be executed at the <code class="inlineCode">yield</code> (more than one <code class="inlineCode">yield</code> results in errors) and the code before/after functions as setup/teardown code, which is useful for things like database connections and file handles. A basic example of a <code class="inlineCode">fixture</code> and a <code class="inlineCode">yield_fixture</code> looks like this:</p>&#13;
    <pre class="programlisting code"><code class="hljs-code"><span class="hljs-keyword">import</span> pytest&#13;
&#13;
<span class="hljs-meta">@pytest.yield_fixture</span>&#13;
<span class="hljs-keyword">def</span><span class="hljs-function"> </span><span class="hljs-title">some_yield_fixture</span><span class="hljs-function">():</span>&#13;
    <span class="hljs-keyword">with</span> <span class="hljs-built_in">open</span>(__file__ + <span class="hljs-string">'.txt'</span>, <span class="hljs-string">'w'</span>) <span class="hljs-keyword">as</span> fh:&#13;
        <span class="hljs-comment"># Before the function</span>&#13;
        <span class="hljs-keyword">yield</span> fh&#13;
        <span class="hljs-comment"># After the function</span>&#13;
&#13;
<span class="hljs-meta">@pytest.fixture</span>&#13;
<span class="hljs-keyword">def</span><span class="hljs-function"> </span><span class="hljs-title">some_regular_fixture</span><span class="hljs-function">():</span>&#13;
    <span class="hljs-comment"># Do something here</span>&#13;
    <span class="hljs-keyword">return</span> <span class="hljs-string">'some_value_to_pass_as_parameter'</span>&#13;
&#13;
<span class="hljs-keyword">def</span><span class="hljs-function"> </span><span class="hljs-title">some_test</span><span class="hljs-function">(</span><span class="hljs-params">some_yield_fixture, some_regular_fixture</span><span class="hljs-function">):</span>&#13;
    some_yield_fixture.write(some_regular_fixture)&#13;
</code></pre>&#13;
    <p class="normal">These fixtures take no<a id="_idIndexMarker774"/> parameters and simply pass a parameter to the <code class="inlineCode">py.test</code> functions. A more useful example would be setting up a database connection and executing a query in a transaction:</p>&#13;
    <pre class="programlisting code"><code class="hljs-code"><span class="hljs-keyword">import</span> pytest&#13;
<span class="hljs-keyword">import</span> sqlite3&#13;
&#13;
<span class="hljs-meta">@pytest.fixture(</span><span class="hljs-params">params=[</span><span class="hljs-string">':memory:'</span><span class="hljs-params">]</span><span class="hljs-meta">)</span>&#13;
<span class="hljs-keyword">def</span><span class="hljs-function"> </span><span class="hljs-title">connection</span><span class="hljs-function">(</span><span class="hljs-params">request</span><span class="hljs-function">):</span>&#13;
    <span class="hljs-keyword">return</span> sqlite3.connect(request.param)&#13;
&#13;
<span class="hljs-meta">@pytest.yield_fixture</span>&#13;
<span class="hljs-keyword">def</span><span class="hljs-function"> </span><span class="hljs-title">transaction</span><span class="hljs-function">(</span><span class="hljs-params">connection</span><span class="hljs-function">):</span>&#13;
    <span class="hljs-keyword">with</span> connection:&#13;
        <span class="hljs-keyword">yield</span> connection&#13;
&#13;
<span class="hljs-keyword">def</span><span class="hljs-function"> </span><span class="hljs-title">test_insert</span><span class="hljs-function">(</span><span class="hljs-params">transaction</span><span class="hljs-function">):</span>&#13;
    transaction.execute(<span class="hljs-string">'create table test (id integer)'</span>)&#13;
    transaction.execute(<span class="hljs-string">'insert into test values (1), (2), (3)'</span>)&#13;
</code></pre>&#13;
    <p class="normal">First we have the <code class="inlineCode">connection()</code> fixture, which uses the special parameter <code class="inlineCode">params</code>. Instead of using the <code class="inlineCode">:memory:</code> database in <code class="inlineCode">sqlite3</code>, we can use a different database name or multiple names as well. That is why <code class="inlineCode">params</code> is a <code class="inlineCode">list</code>; the test will be executed for each value in <code class="inlineCode">params</code>.</p>&#13;
    <p class="normal">The <code class="inlineCode">transaction()</code> fixture uses <a id="_idIndexMarker775"/>the <code class="inlineCode">connection()</code> to open the database connection, <code class="inlineCode">yield</code> it to the user of that fixture, and take care of the cleanup after. This could easily have been omitted and done in <code class="inlineCode">transation()</code> immediately, but it saves an indentation level and it allows you to further customize the connection at a single location if needed.</p>&#13;
    <p class="normal">Lastly, the <code class="inlineCode">test_insert()</code> function<a id="_idIndexMarker776"/> uses the <code class="inlineCode">transaction()</code> fixture to execute the queries on the database. It is important to note that if we had passed more values to <code class="inlineCode">params</code>, this test would have been executed for each value.</p>&#13;
    <h3 id="_idParaDest-281" class="heading-3">Print statements and logging</h3>&#13;
    <p class="normal">Even though print statements<a id="_idIndexMarker777"/> are generally not the most optimal way to debug code, I admit that it is still my default method of debugging. This means that when running and trying tests, I will include many print statements. However, let’s see what happens when we try this with <code class="inlineCode">py.test</code>. Here is the testing code:</p>&#13;
    <pre class="programlisting code"><code class="hljs-code"><span class="hljs-keyword">import</span> os&#13;
<span class="hljs-keyword">import</span> sys&#13;
<span class="hljs-keyword">import</span> logging&#13;
&#13;
<span class="hljs-keyword">def</span><span class="hljs-function"> </span><span class="hljs-title">test_print</span><span class="hljs-function">():</span>&#13;
    print(<span class="hljs-string">'Printing to stdout'</span>)&#13;
    print(<span class="hljs-string">'Printing to stderr'</span>, file=sys.stderr)&#13;
    logging.debug(<span class="hljs-string">'Printing to debug'</span>)&#13;
    logging.info(<span class="hljs-string">'Printing to info'</span>)&#13;
    logging.warning(<span class="hljs-string">'Printing to warning'</span>)&#13;
    logging.error(<span class="hljs-string">'Printing to error'</span>)&#13;
    <span class="hljs-comment"># We don't want to display os.environ so hack around it</span>&#13;
    fail = <span class="hljs-string">'FAIL'</span> <span class="hljs-keyword">in</span> os.environ&#13;
    <span class="hljs-keyword">assert</span> <span class="hljs-keyword">not</span> fail &#13;
</code></pre>&#13;
    <p class="normal">The following is the actual output:</p>&#13;
    <pre class="programlisting con"><code class="hljs-con"><span class="hljs-con-meta">$</span> py.test -v T_15_print_statements_and_logging.py &#13;
T_15_print_statements_and_logging.py::test_print PASSED  [100%]&#13;
&#13;
================= 1 passed, 1 skipped in 0.06s =================&#13;
</code></pre>&#13;
    <p class="normal">So, all of our print statements and logging<a id="_idIndexMarker778"/> got trashed? Well, not really. In this case, <code class="inlineCode">py.test</code> assumed that it wouldn’t be relevant to you, so it ignored the output. But what about the same run with an error?</p>&#13;
    <pre class="programlisting con"><code class="hljs-con"><span class="hljs-con-meta">$</span> FAIL=true py.test -v T_15_print_statements_and_logging.py &#13;
=========================== FAILURES ===========================&#13;
__________________________ test_print __________________________&#13;
&#13;
    def test_print():&#13;
        print('Printing to stdout')&#13;
        print('Printing to stderr', file=sys.stderr)&#13;
        logging.debug('Printing to debug')&#13;
        logging.info('Printing to info')&#13;
        logging.warning('Printing to warning')&#13;
        logging.error('Printing to error')&#13;
        # We don't want to display os.environ so hack around it&#13;
        fail = 'FAIL' in os.environ&#13;
<span class="hljs-con-meta">&gt;</span>       assert not fail&#13;
E       assert not True&#13;
&#13;
T_15_print_statements_and_logging.py:15: AssertionError&#13;
--------------------- Captured stdout call ---------------------&#13;
Printing to stdout&#13;
--------------------- Captured stderr call ---------------------&#13;
Printing to stderr&#13;
---------------------- Captured log call -----------------------&#13;
WARNING  root:T_15_print_statements_and_logging.py:11 Printing t&#13;
o warning&#13;
ERROR    root:T_15_print_statements_and_logging.py:12 Printing t&#13;
o error&#13;
=================== short test summary info ====================&#13;
FAILED T_15_print_statements_and_logging.py::test_print - ass...&#13;
================= 1 failed, 1 skipped in 0.16s ================= &#13;
</code></pre>&#13;
    <p class="normal">As we see here, when it’s actually useful, we do get the <code class="inlineCode">stdout</code> and <code class="inlineCode">stderr</code> output. Additionally, logging <a id="_idIndexMarker779"/>with a level of <code class="inlineCode">WARNING</code> or higher is visible now. <code class="inlineCode">DEBUG</code> and <code class="inlineCode">INFO</code> still won’t be visible, but we’ll see more about that later in this chapter, in the <em class="chapterRef">Logging</em> section.</p>&#13;
    <p class="normal">There is one big caveat to using print<a id="_idIndexMarker780"/> statements for debugging, however: since they write to <code class="inlineCode">stdout</code> they can break quickly break your doctests. Because <code class="inlineCode">doctest</code> looks at all generated output, your print statements will be included as expected output.</p>&#13;
    <h3 id="_idParaDest-282" class="heading-3">Plugins</h3>&#13;
    <p class="normal">One of the most <a id="_idIndexMarker781"/>powerful features of <code class="inlineCode">py.test</code> is the plugin system. Within <code class="inlineCode">py.test</code>, nearly everything can be modified using the available hooks; the result of this is that writing plugins is almost simple. Actually, if you’ve been typing along, you already wrote a few plugins in the previous paragraphs without realizing it. By packaging <code class="inlineCode">conftest.py</code> in a different package or directory, it becomes a <code class="inlineCode">py.test</code> plugin. We will explain more about packaging in <em class="chapterRef">Chapter 18</em>, <em class="italic">Packaging – Creating Your Own Libraries or Applications</em>. </p>&#13;
    <p class="normal">Generally, it won’t be required to write your own plugin because the odds are that the plugins you seek are already available. A small list of plugins can be found on the <code class="inlineCode">py.test</code> website at <a href="https://pytest.org/latest/plugins.html"><span class="url">https://pytest.org/latest/plugins.html</span></a>, an automatically generated list with plugins here: <a href="https://docs.pytest.org/en/latest/reference/plugin_list.html"><span class="url">https://docs.pytest.org/en/latest/reference/plugin_list.html</span></a>, and a longer completely uncurated list (currently over 8,000) can be found through the Python Package Index at <a href="https://pypi.org/search/?q=pytest-"><span class="url">https://pypi.org/search/?q=pytest-</span></a>.</p>&#13;
    <p class="normal">By default, <code class="inlineCode">py.test</code> does <a id="_idIndexMarker782"/>cover quite a bit of the desirable features, so you can easily do without plugins, but within the packages that I write myself, I generally default to the following list:</p>&#13;
    <ul>&#13;
      <li class="bulletList"><code class="inlineCode">pytest-cov</code></li>&#13;
      <li class="bulletList"><code class="inlineCode">pytest-flake8</code></li>&#13;
      <li class="bulletList"><code class="inlineCode">pytest-mypy</code></li>&#13;
    </ul>&#13;
    <p class="normal">By using these plugins, it becomes much easier to maintain the code quality of your project. In order to understand why, we will take a closer look at these packages in the following paragraphs.</p>&#13;
    <h4 class="heading-4">pytest-cov</h4>&#13;
    <p class="normal">Using the <code class="inlineCode">pytest-cov</code> package, you can see <a id="_idIndexMarker783"/>whether your code is properly covered by tests or not. Internally, it uses the <code class="inlineCode">coverage</code> package to detect how much of the code is being tested.</p>&#13;
    <div>&#13;
      <p class="normal">Make sure you have <code class="inlineCode">pytest-cov</code> installed:</p>&#13;
      <pre class="programlisting con"><code class="hljs-con"><span class="hljs-con-meta">$</span> pip3 install pytest-cov&#13;
</code></pre>&#13;
    </div>&#13;
    <p class="normal">To demonstrate the principle, we will check the coverage of a <code class="inlineCode">cube_root</code> function.</p>&#13;
    <p class="normal">First of all, let’s create a <code class="inlineCode">.coveragerc</code> file with some useful defaults:</p>&#13;
    <pre class="programlisting code"><code class="hljs-code">[report]&#13;
<span class="hljs-comment"># The test coverage you require. Keeping to 100% is not easily</span>&#13;
<span class="hljs-comment"># possible for all projects but it's a good default for new projects.</span>&#13;
fail_under = <span class="hljs-number">100</span>&#13;
&#13;
<span class="hljs-comment"># These functions are generally only needed for debugging and/or</span>&#13;
<span class="hljs-comment"># extra safety so we want to ignore them in the coverage</span>&#13;
<span class="hljs-comment"># requirements</span>&#13;
exclude_lines =&#13;
    <span class="hljs-comment"># Make it possible to ignore blocks of code</span>&#13;
    pragma: no cover&#13;
&#13;
    <span class="hljs-comment"># Generally only debug code uses this</span>&#13;
    <span class="hljs-keyword">def</span><span class="hljs-function"> </span><span class="hljs-title">__repr__</span>&#13;
&#13;
<span class="hljs-function">    </span><span class="hljs-comment"># If a debug setting</span><span class="hljs-comment"> is set, skip testing</span>&#13;
<span class="hljs-function">    </span><span class="hljs-title">if</span><span class="hljs-function"> </span><span class="hljs-title">self</span><span class="hljs-function">\.</span><span class="hljs-title">debug</span><span class="hljs-function">:</span>&#13;
    <span class="hljs-keyword">if</span> settings.DEBUG&#13;
&#13;
    <span class="hljs-comment"># Don't worry about safety checks and expected errors</span>&#13;
    <span class="hljs-keyword">raise</span> AssertionError&#13;
    <span class="hljs-keyword">raise</span> NotImplementedError&#13;
&#13;
    <span class="hljs-comment"># Do not complain about code that will never run</span>&#13;
    <span class="hljs-keyword">if</span> <span class="hljs-number">0</span>:&#13;
    <span class="hljs-keyword">if</span> __name__ == .__main__.:&#13;
<span class="hljs-meta">    @abc.abstractmethod</span>&#13;
&#13;
[run]&#13;
<span class="hljs-comment"># Make sure we require that all branches of the code are covered. </span>&#13;
<span class="hljs-comment"># So both the if and the else</span>&#13;
branch = <span class="hljs-literal">True</span>&#13;
&#13;
<span class="hljs-comment"># No need to require coverage of testing code</span>&#13;
omit =&#13;
    test_*.py&#13;
</code></pre>&#13;
    <div class="packt_tip">&#13;
      <p class="normal">Since Linux and Mac <a id="_idIndexMarker784"/>systems hide files starting with a <code class="inlineCode">.</code> (such as <code class="inlineCode">.coveragerc</code>), the filename in the GitHub repository is <code class="inlineCode">_coveragerc</code>. To use the file, you can either choose to copy/rename it, or set the <code class="inlineCode">COVERAGE_RCFILE</code> environment variable to override the filename.</p>&#13;
    </div>&#13;
    <p class="normal">Which defaults are good for your project is of course a personal decision, but I find the defaults above quite useful. Be sure to read through these instead of blindly copying them, however; perhaps you want to make sure all of your <code class="inlineCode">AssertionErrors</code> are tested instead of silently <a id="_idIndexMarker785"/>ignoring them from the coverage output.</p>&#13;
    <p class="normal">Here is the <code class="inlineCode">cube_root.py</code> code:</p>&#13;
    <pre class="programlisting code"><code class="hljs-code"> <span class="hljs-keyword">def</span><span class="hljs-function"> </span><span class="hljs-title">cube_root</span><span class="hljs-function">(</span><span class="hljs-params">n: </span><span class="hljs-built_in">int</span><span class="hljs-function">) -&gt; int:</span>&#13;
    <span class="hljs-string">'''</span>&#13;
<span class="hljs-string">    Returns the cube root of the input number</span>&#13;
&#13;
<span class="hljs-string">    Args:</span>&#13;
<span class="hljs-string">        n (int): The number to cube root</span>&#13;
&#13;
<span class="hljs-string">    Returns:</span>&#13;
<span class="hljs-string">        int: The cube root result</span>&#13;
<span class="hljs-string">    '''</span>&#13;
    <span class="hljs-keyword">if</span> n &gt;= <span class="hljs-number">0</span>:&#13;
        <span class="hljs-keyword">return</span> n ** (<span class="hljs-number">1</span> / <span class="hljs-number">3</span>)&#13;
    <span class="hljs-keyword">else</span>:&#13;
        <span class="hljs-keyword">raise</span> ValueError(<span class="hljs-string">'A number larger than 0 was expected'</span>)&#13;
</code></pre>&#13;
    <p class="normal">And the <code class="inlineCode">T_16_test_cube_root.py</code> code:</p>&#13;
    <pre class="programlisting code"><code class="hljs-code"><span class="hljs-keyword">import</span> pytest&#13;
<span class="hljs-keyword">import</span> cube_root&#13;
&#13;
cubes = (&#13;
    (<span class="hljs-number">0</span>, <span class="hljs-number">0</span>),&#13;
    (<span class="hljs-number">1</span>, <span class="hljs-number">1</span>),&#13;
    (<span class="hljs-number">8</span>, <span class="hljs-number">2</span>),&#13;
    (<span class="hljs-number">27</span>, <span class="hljs-number">3</span>),&#13;
)&#13;
&#13;
<span class="hljs-meta">@pytest.mark.parametrize(</span><span class="hljs-string">'n,expected'</span><span class="hljs-params">, cubes</span><span class="hljs-meta">)</span>&#13;
<span class="hljs-keyword">def</span><span class="hljs-function"> </span><span class="hljs-title">test_cube_root</span><span class="hljs-function">(</span><span class="hljs-params">n, expected</span><span class="hljs-function">):</span>&#13;
    <span class="hljs-keyword">assert</span> cube_root.cube_root(n) == expected&#13;
</code></pre>&#13;
    <p class="normal">Now, let’s see what happens when we run this with coverage enabled:</p>&#13;
    <pre class="programlisting con"><code class="hljs-con"><span class="hljs-con-meta">$</span> py.test --cov-report=html --cov-report=term-missing \&#13;
  --cov=cube_root --cov-branch T_16_test_cube_root.py&#13;
Name           Stmts   Miss Branch BrPart  Cover   Missing&#13;
----------------------------------------------------------&#13;
cube_root.py       4      1      2      1    67%   14&#13;
Coverage HTML written to dir htmlcov&#13;
================= 4 passed, 1 skipped in 0.12s =================&#13;
</code></pre>&#13;
    <p class="normal">What happened here? It<a id="_idIndexMarker786"/> looks like we forgot to test some part of the code: line <code class="inlineCode">14</code> and the branch that goes from line <code class="inlineCode">11</code> to line <code class="inlineCode">14</code>. This output isn’t all that readable, and that’s why we added <code class="inlineCode">--cov-report=html</code> to get easily readable HTML output in the <code class="inlineCode">htmlcov</code> directory as well:</p>&#13;
    <figure class="mediaobject"> <img src="Images/B15882_10_03.png" alt="" width="630" height="408"/></figure>&#13;
    <p class="packt_figref">Figure 10.3: Coverage report generated by --cov-report=html</p>&#13;
    <p class="normal">Perfect! So now we know – we forgot to test for values smaller than <code class="inlineCode">0</code>.</p>&#13;
    <p class="normal">The yellow line (line 11) indicates that only one part of the branch was executed (<code class="inlineCode">(n &gt;= 0) == True</code>) and not the other (<code class="inlineCode">(n &gt;= 0) == False</code>). This occurs with <code class="inlineCode">if</code> statements, loops, and other things where at least one of the branches is not covered. For example, if a loop over an empty array is an impossible scenario, then the test can be partially skipped using a comment:</p>&#13;
    <pre class="programlisting code"><code class="hljs-code"><span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-number">10</span>):  <span class="hljs-comment"># pragma: no branch</span>&#13;
</code></pre>&#13;
    <p class="normal">But since we know the <a id="_idIndexMarker787"/>problem, that is, the missing test for <code class="inlineCode">ValueError</code>, let’s add the test case:</p>&#13;
    <pre class="programlisting code"><code class="hljs-code"><span class="hljs-comment"># Previous test cases omitted</span>&#13;
...&#13;
<span class="hljs-keyword">def</span><span class="hljs-function"> </span><span class="hljs-title">test_cube_root_below_zero</span><span class="hljs-function">():</span>&#13;
    <span class="hljs-keyword">with</span> pytest.raises(ValueError):&#13;
        cube_root.cube_root(-<span class="hljs-number">1</span>)&#13;
</code></pre>&#13;
    <p class="normal">Then we run the test again:</p>&#13;
    <pre class="programlisting con"><code class="hljs-con"><span class="hljs-con-meta">$</span> py.test --cov-report=html --cov-report=term-missing \&#13;
  --cov=cube_root --cov-branch T_17_test_cube_root_subzero.py&#13;
Name           Stmts   Miss Branch BrPart  Cover   Missing&#13;
----------------------------------------------------------&#13;
cube_root.py       4      0      2      0   100%&#13;
Coverage HTML written to dir htmlcov&#13;
================= 5 passed, 1 skipped in 0.12s =================&#13;
</code></pre>&#13;
    <p class="normal">Perfect! Now we have 100% test coverage of our function. At least, in theory. I can think of several other test cases with different types of values that are not covered. So keep in mind that 100% test coverage is still no guarantee for bug-free code.</p>&#13;
    <p class="normal">But what if we have a branch that really doesn’t need testing because it is intentionally not implemented? If we raise a <code class="inlineCode">NotImplementedError</code> instead of raising a <code class="inlineCode">ValueError</code> for values below <code class="inlineCode">0</code>, we also get 100% test coverage without adding that test.</p>&#13;
    <p class="normal">This is because we added <code class="inlineCode">raise NotImplementedError</code> to the ignore list in the <code class="inlineCode">.coveragerc</code> file. Even if we were to test for the <code class="inlineCode">NotImplementedError</code> in the test file, the coverage report would still ignore the line.</p>&#13;
    <h4 class="heading-4">pytest-flake8</h4>&#13;
    <p class="normal">Code quality testing tools are very <a id="_idIndexMarker788"/>useful for making your code readable, consistent, and <code class="inlineCode">pep8</code> compliant. The <code class="inlineCode">pytest-flake8</code> plugin automatically executes these checks before running the actual tests. To install it, simply execute this line:</p>&#13;
    <pre class="programlisting con"><code class="hljs-con"><span class="hljs-con-meta">$</span> pip3 install pytest-flake8&#13;
</code></pre>&#13;
    <div class="note">&#13;
      <p class="normal">We already installed <code class="inlineCode">pytest-flake8</code> earlier in this chapter because the default configuration for the code in this book depends on it.</p>&#13;
    </div>&#13;
    <p class="normal">Now we’ll create some bad code:</p>&#13;
    <pre class="programlisting code"><code class="hljs-code"><span class="hljs-keyword">import</span> os&#13;
<span class="hljs-keyword">def</span><span class="hljs-function"> </span><span class="hljs-title">test</span><span class="hljs-function">(</span><span class="hljs-params">a,b</span><span class="hljs-function">):</span>&#13;
    <span class="hljs-keyword">return</span> c&#13;
</code></pre>&#13;
    <p class="normal">After that, we can <a id="_idIndexMarker789"/>check the code using the <code class="inlineCode">pytest-flake8</code> plugin by adding it to the <code class="inlineCode">pytest.ini</code>, or by running <code class="inlineCode">py.test</code> like this:</p>&#13;
    <pre class="programlisting con"><code class="hljs-con"><span class="hljs-con-meta">$</span> py.test --flake8 T_18_bad_code.py&#13;
=========================== FAILURES ===========================&#13;
____________ FLAKE8-check(ignoring W391 E402 F811) _____________&#13;
T_18_bad_code.py:1:1: F401 'os' imported but unused&#13;
T_18_bad_code.py:2:1: E302 expected 2 blank lines, found 0&#13;
T_18_bad_code.py:2:11: E231 missing whitespace after ','&#13;
T_18_bad_code.py:3:12: F821 undefined name 'c'&#13;
&#13;
---------------------- Captured log call -----------------------&#13;
WARNING  flake8.options.manager:manager.py:207 option --max-complexity: please update from optparse string 'type=' to argparse callable 'type=' -- this will be an error in the future&#13;
WARNING  flake8.checker:checker.py:119 The multiprocessing module is not available. Ignoring --jobs arguments.&#13;
</code></pre>&#13;
    <p class="normal">The output of <code class="inlineCode">pytest-flake8</code> is, as expected, very similar to the output from the <code class="inlineCode">flake8</code> command that is called internally and combines the <code class="inlineCode">pyflakes</code> and <code class="inlineCode">pep8</code> commands to test code quality.</p>&#13;
    <p class="normal">Depending on your situation, you might opt for having the code quality tests before you commit to the repository, or you could only run it on-demand if code quality isn’t that important to you. After all, while code quality considerations are important, it does not mean the code does not function without them, and a good editor will already notify you of code quality issues while typing.</p>&#13;
    <h4 class="heading-4">pytest-mypy</h4>&#13;
    <p class="normal">The <code class="inlineCode">pytest-mypy</code> plugin <a id="_idIndexMarker790"/>runs the <code class="inlineCode">mypy</code> static type checker, which uses the type hints to check if the input and output are as expected. First, we need to install it using <code class="inlineCode">pip</code>:</p>&#13;
    <pre class="programlisting con"><code class="hljs-con"><span class="hljs-con-meta">$</span> pip3 install pytest-mypy&#13;
</code></pre>&#13;
    <p class="normal">When we apply this to our <code class="inlineCode">cube_root.py</code> file, we can already see a possible error:</p>&#13;
    <pre class="programlisting con"><code class="hljs-con"><span class="hljs-con-meta">$</span> py.test --mypy cube_root.py&#13;
=========================== FAILURES ===========================&#13;
_________________________ cube_root.py _________________________&#13;
12: error: Incompatible return value type (got "float", expected&#13;
 "int")&#13;
</code></pre>&#13;
    <p class="normal">As opposed to the <code class="inlineCode">cube.py</code> file, which will return an <code class="inlineCode">int</code> when given an <code class="inlineCode">int</code>, the cube root of a number does not have to be an integer when an integer is passed. While the cube root of <code class="inlineCode">8</code> is <code class="inlineCode">2</code>, the <a id="_idIndexMarker791"/>cube root of <code class="inlineCode">4</code> returns a floating-point number of approximately <code class="inlineCode">1.587</code>.</p>&#13;
    <p class="normal">This is an error that is easily overlooked without a tool such as <code class="inlineCode">mypy</code>.</p>&#13;
    <h4 class="heading-4">Configuring plugins</h4>&#13;
    <p class="normal">To make sure that all the <a id="_idIndexMarker792"/>plugins get executed and to configure them, simply add the settings to the <code class="inlineCode">pytest.ini</code> file. The following example can be a reasonable default for development, but for production releases, you will probably want to take care of the <code class="inlineCode">UnusedImport</code> warnings.</p>&#13;
    <p class="normal"><code class="inlineCode">pytest.ini</code></p>&#13;
    <pre class="programlisting code"><code class="hljs-code"><span class="hljs-section">[pytest]</span>&#13;
<span class="hljs-attr">python_files</span> =&#13;
    your_project_source/*.py&#13;
    tests/*.py&#13;
&#13;
<span class="hljs-attr">addopts</span> =&#13;
    --doctest-modules&#13;
    --cov your_project_source&#13;
    --cov-report term-missing&#13;
    --cov-report html&#13;
    --flake8&#13;
    --mypy&#13;
&#13;
<span class="hljs-comment"># W391 is the error about blank lines at the end of a file</span>&#13;
<span class="hljs-attr">flake8-ignore</span> =&#13;
    *.py W391&#13;
</code></pre>&#13;
    <p class="normal">Using the <code class="inlineCode">addopts</code> setting in the <code class="inlineCode">pytest.ini</code>, you can add options to the <code class="inlineCode">py.test</code> command as if you had added them to the command while running. </p>&#13;
    <div class="packt_tip">&#13;
      <p class="normal">When debugging to find out why a test is failing, it can be useful to simply look at the first test that fails. The <code class="inlineCode">py.test</code> module offers both a <code class="inlineCode">-x</code>/<code class="inlineCode">--exitfirst</code> flag to stop after the first failure and <code class="inlineCode">--maxfail=n</code> to stop after <em class="italic">n</em> failures. </p>&#13;
      <p class="normal">Additionally, the <code class="inlineCode">--ff</code>/<code class="inlineCode">--failed-first</code> option is useful to run the previously failed tests first.</p>&#13;
      <p class="normal">Or you can use the <code class="inlineCode">--lf</code>/<code class="inlineCode">--last-failed</code> option to only run previously failed tests.</p>&#13;
    </div>&#13;
    <p class="normal">Now that we have <a id="_idIndexMarker793"/>a good understanding of the <code class="inlineCode">py.test</code> possibilities, it is time to continue writing tests. Next up is the subject of faking objects using <code class="inlineCode">mock</code>.</p>&#13;
    <h1 id="_idParaDest-283" class="heading-1">Mock objects</h1>&#13;
    <p class="normal">When writing tests, you <a id="_idIndexMarker794"/>will often find that you are not only testing your own code, but also the interaction with external resources, such as hardware, databases, web hosts, servers, and others. Some of these can be run safely, but certain tests are too slow, too dangerous, or even impossible to run. In those cases, mock objects are your friends; they can be used to fake anything, so you can be certain that your code still returns the expected results without having any variation from external factors.</p>&#13;
    <h2 id="_idParaDest-284" class="heading-2">Using unittest.mock</h2>&#13;
    <p class="normal">The <code class="inlineCode">unittest.mock</code> library <a id="_idIndexMarker795"/>provides two base objects, <code class="inlineCode">Mock</code> and <code class="inlineCode">MagicMock</code>, to easily mock any external resources. The <code class="inlineCode">Mock</code> object is just a general generic mock object and <code class="inlineCode">MagicMock</code> is mostly the same, but it has all the Python magic methods such as <code class="inlineCode">__contains__</code> and <code class="inlineCode">__len__</code> defined. In addition to this, it can make your life even easier. This is because in addition to creating mock objects manually, it is possible to patch objects directly using the <code class="inlineCode">patch</code> decorator/context manager.</p>&#13;
    <p class="normal">The following function uses <code class="inlineCode">random</code> to return <code class="inlineCode">True</code> or <code class="inlineCode">False</code> with probabilities governed by a certain probability distribution. Due to the random nature of a function like this, it is notoriously difficult to test, but not with <code class="inlineCode">unittest.mock</code>. With the use of <code class="inlineCode">unittest.mock</code>, it’s easy to get repeatable results:</p>&#13;
    <pre class="programlisting code"><code class="hljs-code"><span class="hljs-keyword">from</span> unittest <span class="hljs-keyword">import</span> mock&#13;
<span class="hljs-keyword">import</span> random&#13;
&#13;
<span class="hljs-meta">@mock.patch(</span><span class="hljs-string">'random.random'</span><span class="hljs-meta">)</span>&#13;
<span class="hljs-keyword">def</span><span class="hljs-function"> </span><span class="hljs-title">test_random</span><span class="hljs-function">(</span><span class="hljs-params">mock_random</span><span class="hljs-function">):</span>&#13;
    <span class="hljs-comment"># Specify our mock return value</span>&#13;
    mock_random.return_value = <span class="hljs-number">0.1</span>&#13;
    <span class="hljs-comment"># Test for the mock return value</span>&#13;
    <span class="hljs-keyword">assert</span> random.random() == <span class="hljs-number">0.1</span>&#13;
    <span class="hljs-keyword">assert</span> mock_random.call_count == <span class="hljs-number">1</span>&#13;
&#13;
<span class="hljs-keyword">def</span><span class="hljs-function"> </span><span class="hljs-title">test_random_with</span><span class="hljs-function">():</span>&#13;
    <span class="hljs-keyword">with</span> mock.patch(<span class="hljs-string">'random.random'</span>) <span class="hljs-keyword">as</span> mock_random:&#13;
        mock_random.return_value = <span class="hljs-number">0.1</span>&#13;
        <span class="hljs-keyword">assert</span> random.random() == <span class="hljs-number">0.1</span>&#13;
</code></pre>&#13;
    <p class="normal">Wonderful, isn’t it? Without having to modify the original code, we can make sure that <code class="inlineCode">random.random()</code> now returns <code class="inlineCode">0.1</code> instead of some random number. If you have an <code class="inlineCode">if</code> statement in your code so it only runs 10% of the time (<code class="inlineCode">if random.random() &lt; 0.1</code>), you can now test explicitly what happens in both cases of the <code class="inlineCode">if</code>.</p>&#13;
    <p class="normal">The possibilities with <a id="_idIndexMarker796"/>mock objects are nearly endless. They vary from raising exceptions on access to faking entire APIs and returning different results on multiple calls. For example, let’s fake deleting a file:</p>&#13;
    <pre class="programlisting code"><code class="hljs-code"><span class="hljs-keyword">import</span> os&#13;
<span class="hljs-keyword">from</span> unittest <span class="hljs-keyword">import</span> mock&#13;
&#13;
<span class="hljs-keyword">def</span><span class="hljs-function"> </span><span class="hljs-title">delete_file</span><span class="hljs-function">(</span><span class="hljs-params">filename</span><span class="hljs-function">):</span>&#13;
    <span class="hljs-keyword">while</span> os.path.exists(filename):&#13;
        os.unlink(filename)&#13;
&#13;
<span class="hljs-meta">@mock.patch(</span><span class="hljs-string">'os.path.exists'</span><span class="hljs-params">, side_effect=(</span><span class="hljs-literal">True</span><span class="hljs-params">, </span><span class="hljs-literal">False</span><span class="hljs-params">, </span><span class="hljs-literal">False</span><span class="hljs-params">)</span><span class="hljs-meta">)</span>&#13;
<span class="hljs-meta">@mock.patch(</span><span class="hljs-string">'os.unlink'</span><span class="hljs-meta">)</span>&#13;
<span class="hljs-keyword">def</span><span class="hljs-function"> </span><span class="hljs-title">test_delete_file</span><span class="hljs-function">(</span><span class="hljs-params">mock_exists, mock_unlink</span><span class="hljs-function">):</span>&#13;
    <span class="hljs-comment"># First try:</span>&#13;
    delete_file(<span class="hljs-string">'some non-existing file'</span>)&#13;
&#13;
    <span class="hljs-comment"># Second try:</span>&#13;
    delete_file(<span class="hljs-string">'some non-existing file'</span>)&#13;
</code></pre>&#13;
    <p class="normal">Quite a bit of magic<a id="_idIndexMarker797"/> in this example! The <code class="inlineCode">side_effect</code> parameter tells <code class="inlineCode">mock</code> to return those values in that sequence, making sure that the first call to <code class="inlineCode">os.path.exists</code> returns <code class="inlineCode">True</code> and the other two return <code class="inlineCode">False</code>. The <code class="inlineCode">mock.patch</code> call without specific arguments simply returns a callable that does nothing and accepts anything.</p>&#13;
    <h2 id="_idParaDest-285" class="heading-2">Using py.test monkeypatch</h2>&#13;
    <p class="normal">The <code class="inlineCode">monkeypatch</code> object in <code class="inlineCode">py.test</code> is a fixture that allows mocking as well. While it may seem useless after seeing <a id="_idIndexMarker798"/>the possibilities with <code class="inlineCode">unittest.mock</code>, in summary, it’s not. Some of the functionality does overlap, but while <code class="inlineCode">unittest.mock</code> focuses on controlling and recording the actions of an object, the <code class="inlineCode">monkeypatch</code> fixture focuses on simple and temporary environmental changes. Some examples of these are given in the following list:</p>&#13;
    <ul>&#13;
      <li class="bulletList">Setting and deleting attributes using <code class="inlineCode">monkeypatch.setattr</code> and <code class="inlineCode">monkeypatch.delattr</code></li>&#13;
      <li class="bulletList">Setting and deleting dictionary items using <code class="inlineCode">monkeypatch.setitem</code> and <code class="inlineCode">monkeypatch.delitem</code></li>&#13;
      <li class="bulletList">Setting and deleting environment variables using <code class="inlineCode">monkeypatch.setenv</code> and <code class="inlineCode">monkeypatch.delenv</code></li>&#13;
      <li class="bulletList">Inserting an extra path to <code class="inlineCode">sys.path</code> before all others using <code class="inlineCode">monkeypatch.syspath_prepend</code></li>&#13;
      <li class="bulletList">Changing the directory using <code class="inlineCode">monkeypatch.chdir</code></li>&#13;
    </ul>&#13;
    <p class="normal">To undo all modifications, simply use <code class="inlineCode">monkeypatch.undo</code>. Naturally, at the end of your test function, <code class="inlineCode">monkeypatch.undo()</code> will be called automatically.</p>&#13;
    <p class="normal">For example, let’s<a id="_idIndexMarker799"/> say that for a certain test, we need to work from a different directory. With <code class="inlineCode">mock</code>, your options would be to mock pretty much all file functions, including the <code class="inlineCode">os.path</code> functions, and even in that case, you will probably forget about a few. So, it’s definitely not useful in this case. Another option would be to put the entire test into a <code class="inlineCode">try...finally</code> block and just do an <code class="inlineCode">os.chdir</code> before and after the testing code. This is quite a good and safe solution, but it’s a bit of extra work, so let’s compare the two methods:</p>&#13;
    <pre class="programlisting code"><code class="hljs-code"><span class="hljs-keyword">import</span> os&#13;
&#13;
<span class="hljs-keyword">def</span><span class="hljs-function"> </span><span class="hljs-title">test_chdir_monkeypatch</span><span class="hljs-function">(</span><span class="hljs-params">monkeypatch</span><span class="hljs-function">):</span>&#13;
    monkeypatch.chdir(<span class="hljs-string">'/'</span>)&#13;
    <span class="hljs-keyword">assert</span> os.getcwd() == <span class="hljs-string">'</span><span class="hljs-string">/'</span>&#13;
&#13;
<span class="hljs-keyword">def</span><span class="hljs-function"> </span><span class="hljs-title">test_chdir</span><span class="hljs-function">():</span>&#13;
    original_directory = os.getcwd()&#13;
    <span class="hljs-keyword">try</span>:&#13;
        os.chdir(<span class="hljs-string">'/'</span>)&#13;
        <span class="hljs-keyword">assert</span> os.getcwd() == <span class="hljs-string">'/'</span>&#13;
    <span class="hljs-keyword">finally</span>:&#13;
        os.chdir(original_directory)&#13;
</code></pre>&#13;
    <p class="normal">They effectively do the same, but one needs a single line of code to temporarily change directory whereas the other needs four, or five if you count the <code class="inlineCode">os</code> import as well. All of these can easily be worked around with a few extra lines of code, of course, but the simpler the code is, the<a id="_idIndexMarker800"/> fewer mistakes you can make and the more readable it is.</p>&#13;
    <p class="normal">Now that we know how to fake objects, let’s look at how we can run our tests on multiple platforms simultaneously using <code class="inlineCode">tox</code>.</p>&#13;
    <h1 id="_idParaDest-286" class="heading-1">Testing multiple environments with tox</h1>&#13;
    <p class="normal">Now that we<a id="_idIndexMarker801"/> have written our tests and are able to run<a id="_idIndexMarker802"/> them for our own environment, it’s time to make sure that others can easily run the tests too. <code class="inlineCode">tox</code> can create sandboxed environments for all specified Python versions (assuming they are installed) and runs them automatically and in parallel if needed. This is especially useful to test if your dependency specification is up to date. While you may have a lot of packages installed in your local environment, someone else might not have those packages.</p>&#13;
    <h2 id="_idParaDest-287" class="heading-2">Getting started with tox</h2>&#13;
    <p class="normal">Before we can do anything, we<a id="_idIndexMarker803"/> need to install the <code class="inlineCode">tox</code> command. A simple pip install will suffice:</p>&#13;
    <pre class="programlisting con"><code class="hljs-con"><span class="hljs-con-meta">$</span> pip3 install --upgrade tox&#13;
</code></pre>&#13;
    <p class="normal">After the install, we can start by creating a <code class="inlineCode">tox.ini</code> file to specify what we want to run. The easiest way is by using <code class="inlineCode">tox-quickstart</code>, but if you already have a functioning <code class="inlineCode">tox.ini</code> from a different project you can easily copy and modify that:</p>&#13;
    <pre class="programlisting con"><code class="hljs-con"><span class="hljs-con-meta">$</span> tox-quickstart&#13;
Welcome to the tox 3.20.1 quickstart utility.&#13;
This utility will ask you a few questions and then generate a simple configuration file to help get you started using tox.&#13;
Please enter values for the following settings (just press Enter to accept a default value, if one is given in brackets).&#13;
&#13;
What Python versions do you want to test against?&#13;
            <span class="hljs-section">[1]</span> py37&#13;
            <span class="hljs-section">[2]</span> py27, py37&#13;
            <span class="hljs-section">[3]</span> (All versions) py27, py35, py36, py37, pypy, jython&#13;
            <span class="hljs-section">[4]</span> Choose each one-by-one&#13;
&gt; Enter the number of your choice <span class="hljs-section">[3]</span>: 1&#13;
What command should be used to test your project? Examples:            &#13;
            - pytest&#13;
            - python -m unittest discover&#13;
            - python setup.py test&#13;
            - trial package.module&#13;
&gt; Type the command to run your tests <span class="hljs-section">[pytest]</span>:&#13;
What extra dependencies do your tests have?&#13;
default dependencies are: <span class="hljs-section">['pytest']</span>&#13;
&gt; Comma-separated list of dependencies: pytest-flake8,pytest-mypy,pytest-cov&#13;
Finished: ./tox.ini has been created. For information on this file, see https://tox.readthedocs.io/en/latest/config.html&#13;
Execute 'tox' to test your project.&#13;
</code></pre>&#13;
    <p class="normal">Now we have our first <code class="inlineCode">tox</code> configuration <a id="_idIndexMarker804"/>finished. The <code class="inlineCode">tox-quickstart</code> command has made a <code class="inlineCode">tox.ini</code> file with a few sane defaults.</p>&#13;
    <div class="note">&#13;
      <p class="normal">When looking at the output of <code class="inlineCode">tox-quickstart</code>, you might be wondering why newer Python versions are not listed. The reason is that the Python versions are hardcoded in the <code class="inlineCode">tox-quickstart</code> command at the time of writing. This issue is expected to be solved in the near future but should not be a big issue in either case, as the versions can be changed in the <code class="inlineCode">tox.ini</code> file quite easily.</p>&#13;
    </div>&#13;
    <h2 id="_idParaDest-288" class="heading-2">The tox.ini config file</h2>&#13;
    <p class="normal">The <code class="inlineCode">tox.ini</code> file is very <a id="_idIndexMarker805"/>basic by default:</p>&#13;
    <pre class="programlisting code"><code class="hljs-code"><span class="hljs-section">[tox]</span>&#13;
<span class="hljs-attr">envlist</span> = py37&#13;
&#13;
<span class="hljs-section">[testenv]</span>&#13;
<span class="hljs-attr">deps</span> =&#13;
    pytest-flake8&#13;
    pytest-mypy&#13;
    pytest-cov&#13;
    pytest&#13;
<span class="hljs-attr">commands</span> =&#13;
    pytest&#13;
</code></pre>&#13;
    <p class="normal">The <code class="inlineCode">tox.ini</code> file usually consists of two main types of sections, the <code class="inlineCode">tox</code> and <code class="inlineCode">testenv</code> sections.</p>&#13;
    <p class="normal">The <code class="inlineCode">tox</code> section configures <a id="_idIndexMarker806"/>the <code class="inlineCode">tox</code> command itself and specifies options such as:</p>&#13;
    <ul>&#13;
      <li class="bulletList"><code class="inlineCode">envlist</code>: Specifies the default list of environments to run, can be overridden by running <code class="inlineCode">tox -e &lt;env&gt;</code>.</li>&#13;
      <li class="bulletList"><code class="inlineCode">requires</code>: Specifies which packages (and specific versions) are required alongside <code class="inlineCode">tox</code>. This can be useful for specifying a specific <code class="inlineCode">setuptools</code> version so your package can be installed correctly.</li>&#13;
      <li class="bulletList"><code class="inlineCode">skip_missing_interpreters</code>: A very useful feature that allows you to test all available environments on your system but skip the ones that are not installed.</li>&#13;
    </ul>&#13;
    <p class="normal">The <code class="inlineCode">testenv</code> section configures <a id="_idIndexMarker807"/>your actual environment. Some of the most useful options are:</p>&#13;
    <ul>&#13;
      <li class="bulletList"><code class="inlineCode">basepython</code>: The Python executable to run, useful if your Python binary has a non-standard name but more commonly useful when using custom environment names.</li>&#13;
      <li class="bulletList"><code class="inlineCode">commands</code>: Commands to run when testing, in our case <code class="inlineCode">pytest</code>.</li>&#13;
      <li class="bulletList"><code class="inlineCode">install_command</code>: Command to run to install the package, defaults to <code class="inlineCode">python -m pip install {opts} {packages}(ARGV)</code>.</li>&#13;
      <li class="bulletList"><code class="inlineCode">allowlist_externals</code>: Which external commands such as <code class="inlineCode">make</code>, <code class="inlineCode">rm</code>, <code class="inlineCode">ls</code>, and <code class="inlineCode">cd</code> to allow so they can be run from the package or the scripts.</li>&#13;
      <li class="bulletList"><code class="inlineCode">changedir</code>: Switch to a specific directory before running tests; to the directory containing the tests, for example.</li>&#13;
      <li class="bulletList"><code class="inlineCode">deps</code>: Which Python packages to install, uses the <code class="inlineCode">pip</code> command syntax. A <code class="inlineCode">requirements.txt</code> file can be specified through <code class="inlineCode">-rrequirements.txt</code>.</li>&#13;
      <li class="bulletList"><code class="inlineCode">platform</code>: Restrict the environment to a specific value of <code class="inlineCode">sys.platform</code>.</li>&#13;
      <li class="bulletList"><code class="inlineCode">setenv</code>: Set environment variables, very useful to let tests know that they are being run from <code class="inlineCode">tox</code>, for example.</li>&#13;
      <li class="bulletList"><code class="inlineCode">skipsdist</code>: With this flag enabled, you can test a regular directory instead of only installable Python packages.</li>&#13;
    </ul>&#13;
    <p class="normal">The most<a id="_idIndexMarker808"/> interesting part of the configuration is the <code class="inlineCode">testenv</code> section prefix. While the <code class="inlineCode">testenv</code> options above can be configured globally for all environments, you can use a section such as <code class="inlineCode">[testenv:my_custom_env]</code> to only apply to your custom environment. In those cases, you will need to specify the <code class="inlineCode">basepython</code> option so <code class="inlineCode">tox</code> knows what to execute.</p>&#13;
    <p class="normal">Additionally to a single environment, you can also expand the pattern to configure multiple environments simultaneously with a pattern such as <code class="inlineCode">[testenv:py{27,38}]</code> to specify both the <code class="inlineCode">py27</code> and <code class="inlineCode">py38</code> environments.</p>&#13;
    <p class="normal">Expansions such as <code class="inlineCode">py{27,38}</code> are also possible for all other options, so to specify a whole list of Python environments, you could do:</p>&#13;
    <pre class="programlisting code"><code class="hljs-code"><span class="hljs-attr">envlist</span> = py27, py3{<span class="hljs-number">7</span>,<span class="hljs-number">8</span>,<span class="hljs-number">9</span>}, docs, coverage, flake8&#13;
</code></pre>&#13;
    <p class="normal">Furthermore, all options in the <code class="inlineCode">tox.ini</code> also allow for variable interpolation based on a whole range of available variables, such as <code class="inlineCode">{envname}</code>, but also based on options from other environments. The next example shows how to copy the <code class="inlineCode">basepython</code> variable from the <code class="inlineCode">py39</code> environment:</p>&#13;
    <pre class="programlisting code"><code class="hljs-code"><span class="hljs-section">[testenv:custom_env]</span>&#13;
<span class="hljs-attr">basepython</span> = {[py39]basepython}&#13;
</code></pre>&#13;
    <p class="normal">Naturally, interpolating from environment variables is also possible:</p>&#13;
    <pre class="programlisting code"><code class="hljs-code">{env:NAME_OF_ENV_VARIABLE}&#13;
</code></pre>&#13;
    <p class="normal">With an optional default:</p>&#13;
    <pre class="programlisting code"><code class="hljs-code">{env:NAME_OF_ENV_VARIABLE:some default value}&#13;
</code></pre>&#13;
    <h2 id="_idParaDest-289" class="heading-2">Running tox</h2>&#13;
    <p class="normal">Now that we know some of the basic<a id="_idIndexMarker809"/> config options for <code class="inlineCode">tox</code>, let’s run a simple test to illustrate how convenient it can be.</p>&#13;
    <p class="normal">First we need to create a <code class="inlineCode">tox.ini</code> file to configure <code class="inlineCode">tox</code>:</p>&#13;
    <pre class="programlisting code"><code class="hljs-code"><span class="hljs-section">[tox]</span>&#13;
<span class="hljs-attr">envlist</span> = py3{<span class="hljs-number">8</span>,<span class="hljs-number">9</span>}&#13;
<span class="hljs-attr">skipsdist</span> = <span class="hljs-literal">True</span>&#13;
&#13;
<span class="hljs-section">[testenv]</span>&#13;
<span class="hljs-attr">deps</span> =&#13;
    pytest&#13;
<span class="hljs-attr">commands</span> =&#13;
    pytest test.py&#13;
</code></pre>&#13;
    <p class="normal">Next, we will create a <code class="inlineCode">test.py</code> file containing the Python 3.9 <code class="inlineCode">dict</code> merge operator:</p>&#13;
    <pre class="programlisting code"><code class="hljs-code"><span class="hljs-keyword">def</span><span class="hljs-function"> </span><span class="hljs-title">test_dict_merge</span><span class="hljs-function">():</span>&#13;
    a = <span class="hljs-built_in">dict</span>(a=<span class="hljs-number">123</span>)&#13;
    b = <span class="hljs-built_in">dict</span>(b=<span class="hljs-number">456</span>)&#13;
    <span class="hljs-keyword">assert</span> a | b&#13;
</code></pre>&#13;
    <p class="normal">Now when running <code class="inlineCode">tox</code>, it will<a id="_idIndexMarker810"/> show us that this syntax failed on Python 3.8 and works on Python 3.9 as expected:</p>&#13;
    <pre class="programlisting con"><code class="hljs-con"><span class="hljs-con-meta">$</span> tox&#13;
py38 installed: ...&#13;
py38 run-test: commands[0] | pytest test.py&#13;
===================== test session starts ======================&#13;
=========================== FAILURES ===========================&#13;
_______________________ test_dict_merge ________________________&#13;
    def test_dict_merge():&#13;
        a = dict(a=123)&#13;
        b = dict(b=456)&#13;
<span class="hljs-con-meta">&gt;</span>       assert a | b&#13;
E       TypeError: unsupported operand type(s) for |: 'dict' and 'dict'&#13;
...&#13;
ERROR:   py38: commands failed&#13;
  py39: commands succeeded&#13;
</code></pre>&#13;
    <p class="normal">That all looks good – an error for Python 3.8 and a fully working Python 3.9 run. This is where <code class="inlineCode">tox</code> is really useful; you can easily test multiple Python versions and multiple environments simultaneously, even in parallel if you use the <code class="inlineCode">tox -p&lt;processes&gt;</code> parameter. And best of all, since it creates a completely blank Python environment, you are testing your requirements specification as well.</p>&#13;
    <p class="normal">Now that we know how to run our tests on multiple Python environments simultaneously, it is time to continue with <code class="inlineCode">logging</code>, the last section of this chapter. While a simple print statement can be very useful in debugging, when working on larger or distributed systems it is often not the most convenient option anymore. This is where the <code class="inlineCode">logging</code> module can help you greatly to debug your issues.</p>&#13;
    <h1 id="_idParaDest-290" class="heading-1">Logging</h1>&#13;
    <p class="normal">The Python <code class="inlineCode">logging</code> module is <a id="_idIndexMarker811"/>one of those modules that are extremely useful, but it tends to be very difficult to use correctly. The result is often that people just disable logging completely and use <code class="inlineCode">print</code> statements instead. While it is somewhat understandable, this is a waste of the very extensive logging system in Python.</p>&#13;
    <p class="normal">The Python <code class="inlineCode">logging</code> module is largely based on the Java <code class="inlineCode">log4j</code> library so it might be familiar to you if you’ve written Java before. That is also one of the biggest problems with the <code class="inlineCode">logging</code> module in my opinion; Python is not Java and the <code class="inlineCode">logging</code> module feels pretty un-Pythonic because of it. That does not make it a bad library, but it takes a little effort to get used to its design.</p>&#13;
    <p class="normal">The most important objects of the <code class="inlineCode">logging</code> module are the following:</p>&#13;
    <ul>&#13;
      <li class="bulletList"><strong class="keyWord">Logger</strong>: The actual logging interface</li>&#13;
      <li class="bulletList"><strong class="keyWord">Handler</strong>: This processes the log statements and outputs them</li>&#13;
      <li class="bulletList"><strong class="keyWord">Formatter</strong>: This formats the input data into a string</li>&#13;
      <li class="bulletList"><strong class="keyWord">Filter</strong>: This allows filtering of certain messages</li>&#13;
    </ul>&#13;
    <p class="normal">Within these objects, you can set the logging levels to one of the default levels:</p>&#13;
    <ul>&#13;
      <li class="bulletList"><code class="inlineCode">CRITICAL: 50</code></li>&#13;
      <li class="bulletList"><code class="inlineCode">ERROR: 40</code></li>&#13;
      <li class="bulletList"><code class="inlineCode">WARNING: 30</code></li>&#13;
      <li class="bulletList"><code class="inlineCode">INFO: 20</code></li>&#13;
      <li class="bulletList"><code class="inlineCode">DEBUG: 10</code></li>&#13;
      <li class="bulletList"><code class="inlineCode">NOTSET: 0</code></li>&#13;
    </ul>&#13;
    <p class="normal">The numbers are the numeric values of these log levels. While you can generally ignore them, the order is obviously important while setting the minimum level. Also, when defining custom levels, you will have to overwrite existing levels if they have the same numeric value.</p>&#13;
    <h2 id="_idParaDest-291" class="heading-2">Configuration</h2>&#13;
    <p class="normal">There are several <a id="_idIndexMarker812"/>ways to configure the logging system, ranging from pure code to JSON files or even remote configuration. The examples will use parts of the <code class="inlineCode">logging</code> module discussed later in this chapter, but the usage of the config system is all that matters here. If you are not interested in the internal workings of the <code class="inlineCode">logging</code> module, you should be able to get by with just this paragraph of the <em class="italic">Logging</em> section.</p>&#13;
    <h3 id="_idParaDest-292" class="heading-3">Basic logging configuration</h3>&#13;
    <p class="normal">The most basic<a id="_idIndexMarker813"/> logging configuration is, of course, no configuration, but that will not get you much useful output:</p>&#13;
    <pre class="programlisting code"><code class="hljs-code"><span class="hljs-keyword">import</span> logging&#13;
&#13;
logging.debug(<span class="hljs-string">'debug'</span>)&#13;
logging.info(<span class="hljs-string">'info'</span>)&#13;
logging.warning(<span class="hljs-string">'warning'</span>)&#13;
logging.error(<span class="hljs-string">'error'</span>)&#13;
logging.critical(<span class="hljs-string">'critical'</span>)&#13;
</code></pre>&#13;
    <p class="normal">With the default log level, you will only see a <code class="inlineCode">WARNING</code> and up:</p>&#13;
    <pre class="programlisting con"><code class="hljs-con"><span class="hljs-con-meta">$</span> python3 T_23_logging_basic.py&#13;
WARNING:root:warning&#13;
ERROR:root:error&#13;
CRITICAL:root:critical&#13;
</code></pre>&#13;
    <p class="normal">A quick and easy start for a configuration is <code class="inlineCode">logging.basicConfig()</code>. I recommend using this if you just need some quick logging for a script you’re writing, but not for a full-blown application. While you can configure pretty much anything you wish, once you get a more complicated setup, there are usually more convenient options. We will talk more about that in later paragraphs, but first, we have <code class="inlineCode">logging.basicConfig()</code>, which creates a <code class="inlineCode">logging.StreamHandler</code> that is added to the root logger and configured to write all output to <code class="inlineCode">sys.stderr</code> (standard error). Note that if the root logger already has handlers, the <code class="inlineCode">logging.basicConfig()</code> function does nothing (unless <code class="inlineCode">force=True</code>).</p>&#13;
    <div class="note">&#13;
      <p class="normal">If no log handlers are configured for the root logger, the logging functions (<code class="inlineCode">debug()</code>, <code class="inlineCode">info()</code>, <code class="inlineCode">warning()</code>, <code class="inlineCode">error()</code>, and <code class="inlineCode">critical()</code>) will automatically call <code class="inlineCode">logging.basicConfig()</code> to set up a logger for you. This means that if you have a log statement before your <code class="inlineCode">logging.basicConfig()</code> call, it will be ignored.</p>&#13;
    </div>&#13;
    <p class="normal">To illustrate the<a id="_idIndexMarker814"/> usage of <code class="inlineCode">basicConfig()</code> with a few customizations:</p>&#13;
    <pre class="programlisting code"><code class="hljs-code"><span class="hljs-keyword">import</span> logging&#13;
&#13;
log_format = <span class="hljs-string">'%(levelname)-8s %(name)-12s %(message)s'</span>&#13;
&#13;
logging.basicConfig(&#13;
    filename=<span class="hljs-string">'debug.log'</span>,&#13;
    <span class="hljs-built_in">format</span>=log_format,&#13;
    level=logging.DEBUG,&#13;
)&#13;
&#13;
formatter = logging.Formatter(log_format)&#13;
handler = logging.StreamHandler()&#13;
handler.setLevel(logging.WARNING)&#13;
handler.setFormatter(formatter)&#13;
logging.getLogger().addHandler(handler)&#13;
</code></pre>&#13;
    <p class="normal">Now we can test the code:</p>&#13;
    <pre class="programlisting code"><code class="hljs-code">logging.debug(<span class="hljs-string">'debug'</span>)&#13;
logging.info(<span class="hljs-string">'info'</span>)&#13;
some_logger = logging.getLogger(<span class="hljs-string">'some'</span>)&#13;
some_logger.warning(<span class="hljs-string">'warning'</span>)&#13;
some_logger.error(<span class="hljs-string">'error'</span>)&#13;
other_logger = some_logger.getChild(<span class="hljs-string">'other'</span>)&#13;
other_logger.critical(<span class="hljs-string">'critical'</span>)&#13;
</code></pre>&#13;
    <p class="normal">This will <a id="_idIndexMarker815"/>give us the following output on our screen:</p>&#13;
    <pre class="programlisting con"><code class="hljs-con"><span class="hljs-con-meta">$</span> python3 T_24_logging_basic_formatted.py&#13;
WARNING  some         warning&#13;
ERROR    some         error&#13;
CRITICAL some.other   critical&#13;
</code></pre>&#13;
    <p class="normal">And here is the output in the <code class="inlineCode">debug.log</code> file:</p>&#13;
    <pre class="programlisting con"><code class="hljs-con">DEBUG    root         debug&#13;
INFO     root         info&#13;
WARNING  some         warning&#13;
ERROR    some         error&#13;
CRITICAL some.other   critical&#13;
</code></pre>&#13;
    <p class="normal">This configuration <a id="_idIndexMarker816"/>shows how log outputs can be configured with separate configurations, log levels, and, if you choose so, formatting. It tends to become unreadable though, which is why it’s usually a better idea to use <code class="inlineCode">basicConfig</code> only for simple configurations that don’t involve multiple handlers.</p>&#13;
    <h3 id="_idParaDest-293" class="heading-3">Dictionary configuration</h3>&#13;
    <p class="normal"><code class="inlineCode">dictConfig</code> makes it <a id="_idIndexMarker817"/>possible to name all parts so that they can be reused easily, for example, a single formatter for multiple loggers and handlers. Let’s rewrite our previous configuration using <code class="inlineCode">dictConfig</code>:</p>&#13;
    <pre class="programlisting code"><code class="hljs-code"><span class="hljs-keyword">from</span> logging <span class="hljs-keyword">import</span> config&#13;
&#13;
config.dictConfig({&#13;
    'version': <span class="hljs-number">1</span>,&#13;
    'formatters': {&#13;
        'standard': {&#13;
            'format': '%(levelname)-8s %(name)-12s %(message)s',&#13;
        },&#13;
    },&#13;
    'handlers': {&#13;
        'file': {&#13;
            'filename': 'debug.log',&#13;
            'level': 'DEBUG',&#13;
            'class': 'logging.FileHandler',&#13;
            'formatter': 'standard',&#13;
        },&#13;
        'stream': {&#13;
            'level': 'WARNING',&#13;
            'class': 'logging.StreamHandler',&#13;
            'formatter': 'standard',&#13;
        },&#13;
    },&#13;
    'loggers': {&#13;
        '': {&#13;
            'handlers': ['file', 'stream'],&#13;
            'level': 'DEBUG',&#13;
        },&#13;
    },&#13;
})&#13;
</code></pre>&#13;
    <p class="normal">You can probably see the similarities with the <code class="inlineCode">logging.basicConfig()</code> call we used earlier. It is merely a different syntax for a <code class="inlineCode">logging</code> configuration.</p>&#13;
    <p class="normal">The nice thing about the <a id="_idIndexMarker818"/>dictionary configuration is that it’s very easy to extend and/or overwrite the logging configuration. For example, if you want to change the formatter for all of your logging, you can simply change the <code class="inlineCode">standard</code> formatter or even loop through <code class="inlineCode">handlers</code>.</p>&#13;
    <h3 id="_idParaDest-294" class="heading-3">JSON configuration</h3>&#13;
    <p class="normal">Since <code class="inlineCode">dictConfig</code> takes<a id="_idIndexMarker819"/> any type of dictionary, it is actually quite simple to implement a different type of reader employing JSON or YAML files. This is especially useful as they tend to be a bit friendlier toward non-Python programmers. As opposed to Python files, they are easily readable and writable from outside of Python.</p>&#13;
    <p class="normal">Let’s assume that we have a <code class="inlineCode">T_26_logging_json_config.json</code> file such as the following:</p>&#13;
    <pre class="programlisting code"><code class="hljs-code">{&#13;
    <span class="hljs-attr">"version"</span>: <span class="hljs-number">1</span>,&#13;
    <span class="hljs-attr">"formatters"</span>: {&#13;
        <span class="hljs-attr">"standard"</span>: {&#13;
            <span class="hljs-attr">"format"</span>: <span class="hljs-string">"%(levelname)-8s %(name)-12s %(message)s"</span>&#13;
        }&#13;
    },&#13;
    <span class="hljs-attr">"handlers"</span>: {&#13;
        <span class="hljs-attr">"file"</span>: {&#13;
            <span class="hljs-attr">"filename"</span>: <span class="hljs-string">"debug.log"</span>,&#13;
            <span class="hljs-attr">"level"</span>: <span class="hljs-string">"DEBUG"</span>,&#13;
            <span class="hljs-attr">"class"</span>: <span class="hljs-string">"logging.FileHandler"</span>,&#13;
            <span class="hljs-attr">"formatter"</span>: <span class="hljs-string">"standard"</span>&#13;
        },&#13;
        <span class="hljs-attr">"stream"</span>: {&#13;
            <span class="hljs-attr">"level"</span>: <span class="hljs-string">"WARNING"</span>,&#13;
            <span class="hljs-attr">"class"</span>: <span class="hljs-string">"logging.StreamHandler"</span>,&#13;
            <span class="hljs-attr">"formatter"</span>: <span class="hljs-string">"standard"</span>&#13;
        }&#13;
    },&#13;
    <span class="hljs-attr">"loggers"</span>: {&#13;
        <span class="hljs-attr">""</span>: {&#13;
            <span class="hljs-attr">"handlers"</span>: [<span class="hljs-string">"file"</span>, <span class="hljs-string">"stream"</span>],&#13;
            <span class="hljs-attr">"level"</span>: <span class="hljs-string">"DEBUG"</span>&#13;
        }&#13;
    }&#13;
}&#13;
</code></pre>&#13;
    <p class="normal">We can simply use this code to read the config:</p>&#13;
    <pre class="programlisting code"><code class="hljs-code"><span class="hljs-keyword">import</span> json&#13;
<span class="hljs-keyword">from</span> logging <span class="hljs-keyword">import</span> config&#13;
&#13;
<span class="hljs-keyword">with</span> <span class="hljs-built_in">open</span>(<span class="hljs-string">'T_26_logging_json_config.json'</span>) <span class="hljs-keyword">as</span> fh:&#13;
    config.dictConfig(json.load(fh))&#13;
</code></pre>&#13;
    <p class="normal">Naturally, you could use <a id="_idIndexMarker820"/>any source that can generate a <code class="inlineCode">dict</code>, but be mindful of the source. Since the <code class="inlineCode">logging</code> module will import the specified class, it can be a potential security risk.</p>&#13;
    <h3 id="_idParaDest-295" class="heading-3">ini file configuration</h3>&#13;
    <p class="normal">The file configuration <a id="_idIndexMarker821"/>is probably the most readable format for non-programmers. It uses the <code class="inlineCode">ini-style</code> configuration format and uses the <code class="inlineCode">configparser</code> module internally. The downside is that it is perhaps a little verbose, but it is clear enough and makes it easy to combine several configuration files without us having to worry too much about overwriting other configurations. Having said that, if <code class="inlineCode">dictConfig</code> is an option, then it is most likely a better option. This is because <code class="inlineCode">fileConfig</code> is slightly limited and awkward at times. Just look at the handlers as an example:</p>&#13;
    <pre class="programlisting code"><code class="hljs-code"><span class="hljs-section">[formatters]</span>&#13;
<span class="hljs-attr">keys</span>=standard&#13;
&#13;
<span class="hljs-section">[handlers]</span>&#13;
<span class="hljs-attr">keys</span>=file,stream&#13;
&#13;
<span class="hljs-section">[loggers]</span>&#13;
<span class="hljs-attr">keys</span>=root&#13;
&#13;
<span class="hljs-section">[formatter_standard]</span>&#13;
<span class="hljs-attr">format</span>=%(levelname)-<span class="hljs-number">8</span>s %(name)-<span class="hljs-number">12</span>s %(message)s&#13;
&#13;
<span class="hljs-section">[handler_file]</span>&#13;
<span class="hljs-attr">level</span>=DEBUG&#13;
<span class="hljs-attr">class</span>=FileHandler&#13;
<span class="hljs-attr">formatter</span>=standard&#13;
<span class="hljs-attr">args</span>=(<span class="hljs-string">'debug.log'</span>,)&#13;
&#13;
<span class="hljs-section">[handler_stream]</span>&#13;
<span class="hljs-attr">level</span>=WARNING&#13;
<span class="hljs-attr">class</span>=StreamHandler&#13;
<span class="hljs-attr">formatter</span>=standard&#13;
<span class="hljs-attr">args</span>=(sys.stderr,)&#13;
&#13;
<span class="hljs-section">[logger_root]</span>&#13;
<span class="hljs-attr">handlers</span>=file,stream&#13;
<span class="hljs-attr">level</span>=DEBUG&#13;
</code></pre>&#13;
    <p class="normal">Reading the files is extremely easy though:</p>&#13;
    <pre class="programlisting code"><code class="hljs-code"><span class="hljs-keyword">from</span> logging <span class="hljs-keyword">import</span> config&#13;
&#13;
config.fileConfig(<span class="hljs-string">'T_27_logging_ini_config.ini'</span>)&#13;
</code></pre>&#13;
    <p class="normal">One thing to<a id="_idIndexMarker822"/> make note of, however, is that if you look carefully, you will see that this config is slightly different from the other configs. With <code class="inlineCode">fileConfig</code> you can’t just use keyword arguments alone. The args is required for both <code class="inlineCode">FileHandler</code> and <code class="inlineCode">StreamHandler</code>.</p>&#13;
    <h3 id="_idParaDest-296" class="heading-3">The network configuration</h3>&#13;
    <p class="normal">The network <a id="_idIndexMarker823"/>configuration is a rarely used but very convenient way to configure your loggers across multiple processes. This type of configuration is quite esoteric and if you have no use for such a setup, feel free to skip to the <em class="italic">Logger</em> section.</p>&#13;
    <p class="normal">The major caveat of the network configuration is that it can be dangerous because it allows you to configure your logger on the fly while your application/script is still running. The dangerous part is that the config is (partially) read by using the <code class="inlineCode">eval</code> function, which allows people to potentially execute code within your application remotely. Even though <code class="inlineCode">logging.config.listen</code> only listens to local connections, it can still be dangerous if you execute the code on a shared/unsafe host where others can run code as well.</p>&#13;
    <p class="normal">If your system is unsafe, you can pass <code class="inlineCode">verify</code> as a callable argument to <code class="inlineCode">listen()</code>, which could implement signature verification or encryption of the configurations before they are evaluated. By default, the <code class="inlineCode">verify</code> function is analogous to <code class="inlineCode">lambda config: config</code>. As the most simple verification method, you could use something along these lines:</p>&#13;
    <pre class="programlisting code"><code class="hljs-code"><span class="hljs-keyword">def</span><span class="hljs-function"> </span><span class="hljs-title">verify</span><span class="hljs-function">(</span><span class="hljs-params">config</span><span class="hljs-function">):</span>&#13;
    <span class="hljs-keyword">if</span> config.pop(<span class="hljs-string">'secret'</span>, <span class="hljs-literal">None</span>) != <span class="hljs-string">'some secret'</span>:&#13;
        <span class="hljs-keyword">raise</span> RuntimeError(<span class="hljs-string">'Access denied'</span>)&#13;
    <span class="hljs-keyword">return</span> config&#13;
</code></pre>&#13;
    <p class="normal">To show the <a id="_idIndexMarker824"/>workings of the network configuration, we need two scripts. One script will continuously print a few messages to the loggers and the other will change the logging configuration. We will start with the same test code that we had before, but keep it running in an endless loop with a <code class="inlineCode">sleep</code> in between:</p>&#13;
    <pre class="programlisting code"><code class="hljs-code"><span class="hljs-keyword">import</span> sys&#13;
&#13;
<span class="hljs-keyword">def</span><span class="hljs-function"> </span><span class="hljs-title">receive</span><span class="hljs-function">():</span>&#13;
    <span class="hljs-keyword">import</span> time&#13;
    <span class="hljs-keyword">import</span> logging&#13;
    <span class="hljs-keyword">from</span> logging <span class="hljs-keyword">import</span> config&#13;
&#13;
    listener = config.listen()&#13;
    listener.start()&#13;
&#13;
    <span class="hljs-keyword">try</span>:&#13;
        <span class="hljs-keyword">while</span> <span class="hljs-literal">True</span>:&#13;
            logging.debug(<span class="hljs-string">'debug'</span>)&#13;
            logging.info(<span class="hljs-string">'info'</span>)&#13;
            some_logger = logging.getLogger(<span class="hljs-string">'some'</span>)&#13;
            some_logger.warning(<span class="hljs-string">'warning'</span>)&#13;
            some_logger.error(<span class="hljs-string">'error'</span>)&#13;
            other_logger = some_logger.getChild(<span class="hljs-string">'other'</span>)&#13;
            other_logger.critical(<span class="hljs-string">'critical'</span>)&#13;
&#13;
            time.sleep(<span class="hljs-number">5</span>)&#13;
&#13;
    <span class="hljs-keyword">except</span> KeyboardInterrupt:&#13;
        <span class="hljs-comment"># Stop listening and finish the listening thread</span>&#13;
        config.stopListening()&#13;
        listener.join()&#13;
&#13;
<span class="hljs-keyword">def</span><span class="hljs-function"> </span><span class="hljs-title">send</span><span class="hljs-function">():</span>&#13;
    <span class="hljs-keyword">import</span> os&#13;
    <span class="hljs-keyword">import</span> struct&#13;
    <span class="hljs-keyword">import</span> socket&#13;
    <span class="hljs-keyword">from</span> logging <span class="hljs-keyword">import</span> config&#13;
&#13;
    ini_filename = os.path.splitext(__file__)[<span class="hljs-number">0</span>] + <span class="hljs-string">'.ini'</span>&#13;
    <span class="hljs-keyword">with</span> <span class="hljs-built_in">open</span>(ini_filename, <span class="hljs-string">'rb'</span>) <span class="hljs-keyword">as</span> fh:&#13;
        data = fh.read()&#13;
&#13;
    <span class="hljs-comment"># Open the socket</span>&#13;
    sock = socket.socket(socket.AF_INET, socket.SOCK_STREAM)&#13;
    <span class="hljs-comment"># Connect to the server</span>&#13;
    sock.connect((<span class="hljs-string">'127.0.0.1'</span>,&#13;
                  config.DEFAULT_LOGGING_CONFIG_PORT))&#13;
    <span class="hljs-comment"># Send the magic logging packet</span>&#13;
    sock.send(struct.pack(<span class="hljs-string">'&gt;L'</span>, <span class="hljs-built_in">len</span>(data)))&#13;
    <span class="hljs-comment"># Send the config</span>&#13;
    sock.send(data)&#13;
    <span class="hljs-comment"># And close the connection again</span>&#13;
    sock.close()&#13;
&#13;
<span class="hljs-keyword">if</span> __name__ == <span class="hljs-string">'__main__'</span>:&#13;
    <span class="hljs-keyword">if</span> sys.argv[-<span class="hljs-number">1</span>] == <span class="hljs-string">'send'</span>:&#13;
        send()&#13;
    <span class="hljs-keyword">elif</span> sys.argv[-<span class="hljs-number">1</span>] == <span class="hljs-string">'receive'</span>:&#13;
        receive()&#13;
    <span class="hljs-keyword">else</span>:&#13;
        print(<span class="hljs-string">f'Usage: </span><span class="hljs-subst">{sys.argv[</span><span class="hljs-number">0</span><span class="hljs-subst">]}</span><span class="hljs-string"> [send/receive]'</span>)&#13;
</code></pre>&#13;
    <p class="normal">Now we need to <a id="_idIndexMarker825"/>run both of the scripts at the same time. First, we start the <code class="inlineCode">receive</code> script, which will start outputting data:</p>&#13;
    <pre class="programlisting con"><code class="hljs-con"><span class="hljs-con-meta">$</span> python3 T_28_logging_network_config.py receive&#13;
WARNING:some:warning&#13;
ERROR:some:error&#13;
CRITICAL:some.other:critical&#13;
# The send <span class="hljs-con-built_in">command</span> was run here&#13;
WARNING  some         warning&#13;
ERROR    some         error&#13;
CRITICAL some.other   critical&#13;
</code></pre>&#13;
    <p class="normal">In the meantime, we run the <code class="inlineCode">send</code> command:</p>&#13;
    <pre class="programlisting con"><code class="hljs-con"><span class="hljs-con-meta">$</span> python3 T_28_logging_network_config.py send&#13;
</code></pre>&#13;
    <p class="normal">As you can see, the logging configuration was updated while the code was still running. This can be very useful for long-running scripts that you need to debug but don’t want to restart.</p>&#13;
    <p class="normal">In addition to the <a id="_idIndexMarker826"/>output on the screen, the extra output was sent to the <code class="inlineCode">debug.log</code> file, which looks something like this now:</p>&#13;
    <pre class="programlisting con"><code class="hljs-con">DEBUG    root         debug&#13;
INFO     root         info&#13;
WARNING  some         warning&#13;
ERROR    some         error&#13;
CRITICAL some.other   critical&#13;
</code></pre>&#13;
    <p class="normal">This allows you to redirect mostly useless debug output to a separate log file while still keeping the most important messages on the screen.</p>&#13;
    <h2 id="_idParaDest-297" class="heading-2">Logger</h2>&#13;
    <p class="normal">The main object that <a id="_idIndexMarker827"/>you will be using all the time with the <code class="inlineCode">logging</code> module is the <code class="inlineCode">Logger</code> object. This object contains all the APIs that you will need to do the actual logging. Most are simple enough but some require attention.</p>&#13;
    <p class="normal">First of all, loggers inherit the parent settings by default. As we have seen previously, with the <code class="inlineCode">propagate</code> setting, by default, all settings will propagate from the parent. This is really useful when incorporating loggers within your files. </p>&#13;
    <p class="normal">Assuming your modules are using sane names and import paths, I recommend the following style of naming your loggers:</p>&#13;
    <pre class="programlisting code"><code class="hljs-code"><span class="hljs-keyword">import</span> logging&#13;
&#13;
logger = logging.getLogger(__name__)&#13;
&#13;
<span class="hljs-keyword">class</span><span class="hljs-class"> </span><span class="hljs-title">MyClass</span><span class="hljs-class">(</span><span class="hljs-built_in">object</span><span class="hljs-class">):</span>&#13;
    <span class="hljs-keyword">def</span><span class="hljs-function"> </span><span class="hljs-title">__init__</span><span class="hljs-function">(</span><span class="hljs-params">self, count</span><span class="hljs-function">):</span>&#13;
        self.logger = logger.getChild(self.__class__.__name__)&#13;
</code></pre>&#13;
    <p class="normal">By using this style, your loggers will get names such as <code class="inlineCode">main_module.sub_module.ClassName</code>. Not only does this make your logs easier to read, but also it is easily possible to enable or disable logging per module with the propagation of log settings. To create a new log file that logs everything from <code class="inlineCode">main_module.sub_module</code>, we can simply do this:</p>&#13;
    <pre class="programlisting code"><code class="hljs-code"><span class="hljs-keyword">import</span> logging&#13;
&#13;
logger = logging.getLogger(<span class="hljs-string">'main_module.sub_module'</span>)&#13;
logger.addHandler(logging.FileHandler(<span class="hljs-string">'sub_module.log'</span>))&#13;
</code></pre>&#13;
    <p class="normal">Alternatively, you can configure it using your chosen configuration option, of course. The relevant point is that with sub-loggers, you have very fine-grained control over your loggers.</p>&#13;
    <p class="normal">This includes <a id="_idIndexMarker828"/>increasing the log level:</p>&#13;
    <pre class="programlisting code"><code class="hljs-code"><span class="hljs-keyword">import</span> logging&#13;
&#13;
logger = logging.getLogger(<span class="hljs-string">'main_module.sub_module'</span>)&#13;
logger.setLevel(logging.DEBUG)&#13;
</code></pre>&#13;
    <h3 id="_idParaDest-298" class="heading-3">Usage</h3>&#13;
    <p class="normal">The usage of<a id="_idIndexMarker829"/> the <code class="inlineCode">Logger</code> object is mostly identical to that of the bare <code class="inlineCode">logging</code> module, but <code class="inlineCode">Logger</code> actually supports a bit more. This is because the bare <code class="inlineCode">logging</code> module just calls the functions on the root logger. The <code class="inlineCode">Logger</code> object has a few very useful properties, although most of these are undocumented in the library:</p>&#13;
    <ul>&#13;
      <li class="bulletList"><code class="inlineCode">propagate</code>: Whether <a id="_idIndexMarker830"/>to pass events to this logger or to the handlers of the parent loggers. Without this, a log message to <code class="inlineCode">main_module.sub_module</code> won’t be logged by <code class="inlineCode">main_module</code>.<ul>&#13;
          <li class="bulletList">The <code class="inlineCode">handle</code> method will keep looking for parent handlers as long as those loggers have <code class="inlineCode">propagate</code> set to <code class="inlineCode">true</code>, which is the default.</li>&#13;
        </ul>&#13;
      </li>&#13;
      <li class="bulletList"><code class="inlineCode">filters</code>: These are the filters attached to the logger. They can be set through <code class="inlineCode">addFilter</code> and <code class="inlineCode">removeFilter</code>. To see whether a message will be filtered, the <code class="inlineCode">filter</code> method can be used.</li>&#13;
      <li class="bulletList"><code class="inlineCode">disabled</code>: By setting this property, it’s possible to disable a certain logger. The regular API only allows the disabling of all loggers below a certain level. This offers some fine-grained control.</li>&#13;
      <li class="bulletList"><code class="inlineCode">handlers</code>: These are the handlers attached to the logger. They can be added through <code class="inlineCode">addHandler</code> and <code class="inlineCode">removeHandler</code>. The existence of any (inherited) handlers can be checked through the <code class="inlineCode">hasHandlers</code> function.</li>&#13;
      <li class="bulletList"><code class="inlineCode">level</code>: This is really an internal one as it simply has a numeric value and not a name. But beyond that, it doesn’t take inheritance into account, so it’s better to avoid the property and use the <code class="inlineCode">getEffectiveLevel</code> function instead. To check whether the setting is enabled for a <code class="inlineCode">DEBUG</code>, for example, you can simply do <code class="inlineCode">logger.isEnabledFor(logging.DEBUG)</code>. Setting the property is possible through the <code class="inlineCode">setLevel</code> function, of course.</li>&#13;
      <li class="bulletList"><code class="inlineCode">name</code>: As this <a id="_idIndexMarker831"/>property’s name suggests, it is very useful for your own reference, of course.</li>&#13;
    </ul>&#13;
    <p class="normal">Now that you know about the properties, it is time to discuss the logging functions themselves. The functions you will use most often are the <code class="inlineCode">log</code>, <code class="inlineCode">debug</code>, <code class="inlineCode">info</code>, <code class="inlineCode">warning</code>, <code class="inlineCode">error</code>, and <code class="inlineCode">critical</code> log functions. They can be used quite simply, but they support string formatting as well, which is very useful:</p>&#13;
    <pre class="programlisting code"><code class="hljs-code"><span class="hljs-keyword">import</span> logging&#13;
&#13;
logger = logging.getLogger()&#13;
exception = <span class="hljs-string">'Oops...'</span>&#13;
logger.error(<span class="hljs-string">'Some horrible error: %r'</span>, exception)&#13;
</code></pre>&#13;
    <h3 id="_idParaDest-299" class="heading-3">Formatting</h3>&#13;
    <p class="normal">When seeing the previous<a id="_idIndexMarker832"/> examples, you might wonder why we use <code class="inlineCode">logger.error('error: %r', error)</code> instead of regular string formatting with f-strings, <code class="inlineCode">%</code>, or <code class="inlineCode">string.format</code> instead. The reason is that when parameters are used instead of preformatted strings, the handler gets them as parameters. The result is that you can group log messages by the original string, which is <a id="_idIndexMarker833"/>what tools such as Sentry (<a href="https://github.com/getsentry/sentry"><span class="url">https://github.com/getsentry/sentry</span></a>) use.</p>&#13;
    <p class="normal">There is more to it, however. In terms of parameters, <code class="inlineCode">*args</code> are only for string formatting, but it’s possible to add extra parameters to a log object using the <code class="inlineCode">extra</code> keyword parameter:</p>&#13;
    <pre class="programlisting code"><code class="hljs-code"><span class="hljs-keyword">import</span> logging&#13;
&#13;
logger = logging.getLogger()&#13;
logger.error(<span class="hljs-string">'simple error'</span>, extra=<span class="hljs-built_in">dict</span>(some_variable=<span class="hljs-string">'my value'</span>))&#13;
</code></pre>&#13;
    <p class="normal">These <code class="inlineCode">extra</code> parameters can be used in the logging formatter to display extra information just like the standard formatting options:</p>&#13;
    <pre class="programlisting code"><code class="hljs-code"><span class="hljs-keyword">import</span> logging&#13;
&#13;
logging.basicConfig(<span class="hljs-built_in">format</span>=<span class="hljs-string">'%(some_variable)s: %(message)s'</span>)&#13;
logger = logging.getLogger()&#13;
logger.error(<span class="hljs-string">'</span><span class="hljs-string">the message'</span>, extra=<span class="hljs-built_in">dict</span>(some_variable=<span class="hljs-string">'my value'</span>))&#13;
</code></pre>&#13;
    <p class="normal">This results in the following:</p>&#13;
    <pre class="programlisting con"><code class="hljs-con"><span class="hljs-con-meta">$</span> python3 T_30_formatting.py&#13;
simple error&#13;
my value: the message&#13;
</code></pre>&#13;
    <p class="normal">However, one of the most useful features is the support for exceptions:</p>&#13;
    <pre class="programlisting code"><code class="hljs-code"><span class="hljs-keyword">import</span> logging&#13;
&#13;
logging.basicConfig()&#13;
logger = logging.getLogger()&#13;
&#13;
<span class="hljs-keyword">try</span>:&#13;
    <span class="hljs-keyword">raise</span> RuntimeError(<span class="hljs-string">'some runtime error'</span>)&#13;
<span class="hljs-keyword">except</span> Exception <span class="hljs-keyword">as</span> exception:&#13;
    logger.exception(<span class="hljs-string">'Got an exception: %s'</span>, exception)&#13;
&#13;
logger.error(<span class="hljs-string">'And an error'</span>)&#13;
</code></pre>&#13;
    <p class="normal">This results<a id="_idIndexMarker834"/> in a stack trace for the exception, but it will not kill the code:</p>&#13;
    <pre class="programlisting con"><code class="hljs-con"><span class="hljs-con-meta">$</span> python3 T_31_exception.py&#13;
ERROR:root:Got an exception: some runtime error&#13;
Traceback (most recent call last):&#13;
  File "T_31_exception.py", line 7, in &lt;module&gt;&#13;
    raise RuntimeError('some runtime error')&#13;
RuntimeError: some runtime error&#13;
ERROR:root:And an error&#13;
</code></pre>&#13;
    <h3 id="_idParaDest-300" class="heading-3">Modern formatting using f-strings and str.format</h3>&#13;
    <p class="normal">The Python <code class="inlineCode">logging</code> module is still largely based on the “old” formatting syntax and doesn’t have much <a id="_idIndexMarker835"/>support for <code class="inlineCode">str.format</code>. For the <code class="inlineCode">Formatter</code> itself, you can easily use the new style formatting, but that’s ultimately mostly useless since you rarely modify the <code class="inlineCode">Formatter</code> and mainly need formatting when logging messages instead.</p>&#13;
    <p class="normal">Regardless, the syntax is simple enough to enable:</p>&#13;
    <pre class="programlisting code"><code class="hljs-code"><span class="hljs-keyword">import</span> logging&#13;
&#13;
formatter = logging.Formatter(<span class="hljs-string">'{levelname} {message}'</span>, style=<span class="hljs-string">'{'</span>)&#13;
handler = logging.StreamHandler()&#13;
handler.setFormatter(formatter)&#13;
&#13;
logging.error(<span class="hljs-string">'formatted message?'</span>)&#13;
</code></pre>&#13;
    <p class="normal">Which results in:</p>&#13;
    <pre class="programlisting con"><code class="hljs-con"><span class="hljs-con-meta">$</span> python3 T_32_str_format.py&#13;
ERROR:root:formatted message?&#13;
</code></pre>&#13;
    <p class="normal">For <a id="_idIndexMarker836"/>actual messages requiring formatting, we need to implement something ourselves, however. A logging adapter is the easiest solution:</p>&#13;
    <pre class="programlisting code"><code class="hljs-code"><span class="hljs-keyword">import</span> logging&#13;
&#13;
<span class="hljs-keyword">class</span><span class="hljs-class"> </span><span class="hljs-title">FormattingMessage</span><span class="hljs-class">:</span>&#13;
    <span class="hljs-keyword">def</span><span class="hljs-function"> </span><span class="hljs-title">__init__</span><span class="hljs-function">(</span><span class="hljs-params">self, message, kwargs</span><span class="hljs-function">):</span>&#13;
        self.message = message&#13;
        self.kwargs = kwargs&#13;
&#13;
    <span class="hljs-keyword">def</span><span class="hljs-function"> </span><span class="hljs-title">__str__</span><span class="hljs-function">(</span><span class="hljs-params">self</span><span class="hljs-function">):</span>&#13;
        <span class="hljs-keyword">return</span> self.message.<span class="hljs-built_in">format</span>(**self.kwargs)&#13;
&#13;
<span class="hljs-keyword">class</span><span class="hljs-class"> </span><span class="hljs-title">FormattingAdapter</span><span class="hljs-class">(</span><span class="hljs-params">logging.LoggerAdapter</span><span class="hljs-class">):</span>&#13;
    <span class="hljs-keyword">def</span><span class="hljs-function"> </span><span class="hljs-title">process</span><span class="hljs-function">(</span><span class="hljs-params">self, msg, kwargs</span><span class="hljs-function">):</span>&#13;
        msg, kwargs = <span class="hljs-built_in">super</span>().process(msg, kwargs)&#13;
        <span class="hljs-keyword">return</span> FormattingMessage(msg, kwargs), <span class="hljs-built_in">dict</span>()&#13;
&#13;
logger = FormattingAdapter(logging.root, <span class="hljs-built_in">dict</span>())&#13;
logger.error(<span class="hljs-string">'Hi {name}'</span>, name=<span class="hljs-string">'Rick'</span>)&#13;
</code></pre>&#13;
    <p class="normal">When executing the code, this results in the following output:</p>&#13;
    <pre class="programlisting con"><code class="hljs-con"><span class="hljs-con-meta">$</span> python3 T_33_logging_format.py&#13;
Hi Rick&#13;
</code></pre>&#13;
    <p class="normal">The solution still doesn’t look that <a id="_idIndexMarker837"/>pretty in my opinion, but it works. Because the formatting of log messages cannot be overridden easily in the <code class="inlineCode">logging</code> module, we have created a separate <code class="inlineCode">FormattingMessage</code> that formats itself whenever <code class="inlineCode">str(message)</code> is called. This way we can override the formatting using a simple <code class="inlineCode">logging.LoggerAdapter</code> without having to replace large portions of the <code class="inlineCode">logging</code> library.</p>&#13;
    <p class="normal">Please note that if you want to send the value of <code class="inlineCode">kwargs</code> to a logger such as Sentry, you will need to make sure the order of operations is correct, since this method cannot pass the <code class="inlineCode">kwargs</code> along or the standard log formatter would complain.</p>&#13;
    <p class="normal">Additionally, you<a id="_idIndexMarker838"/> might be wondering why we used the <code class="inlineCode">FormattingMessage</code> instead of running <code class="inlineCode">msg.format(**kwargs)</code> in the <code class="inlineCode">process()</code> method. The reason is that we want to avoid string formatting for as long as possible. </p>&#13;
    <p class="normal">If the logger doesn’t have an active handler or the handler ignores messages of this level, it means we would have done useless work. Depending on the implementation, string formatting can be a very heavy operation and the <code class="inlineCode">logging</code> system is meant to be as light as possible until enabled.</p>&#13;
    <h2 id="_idParaDest-301" class="heading-2">Logging pitfalls</h2>&#13;
    <p class="normal">The logging propagation<a id="_idIndexMarker839"/> is one of the most useful features and also the biggest problem with the <code class="inlineCode">logging</code> module. We have already seen how logging settings are inherited from parent loggers, but what if you override them? Well, let’s find out:</p>&#13;
    <pre class="programlisting code"><code class="hljs-code"><span class="hljs-keyword">import</span> logging&#13;
&#13;
a = logging.getLogger(<span class="hljs-string">'a'</span>)&#13;
ab = logging.getLogger(<span class="hljs-string">'</span><span class="hljs-string">a.b'</span>)&#13;
&#13;
ab.error(<span class="hljs-string">'before setting level'</span>)&#13;
a.setLevel(logging.CRITICAL)&#13;
ab.error(<span class="hljs-string">'after setting level'</span>)&#13;
</code></pre>&#13;
    <p class="normal">When we run this code, we get this output:</p>&#13;
    <pre class="programlisting con"><code class="hljs-con"><span class="hljs-con-meta">$</span> python3 T_34_logging_pitfalls.py&#13;
before setting level&#13;
</code></pre>&#13;
    <p class="normal">In this case it’s obvious that the <code class="inlineCode">a.setLevel(...)</code> caused the issue, but if that happens in some external code that you didn’t know about, you could be searching for a long time.</p>&#13;
    <p class="normal">And the reverse can also happen; an explicit level on a logger will ignore your parent level:</p>&#13;
    <pre class="programlisting code"><code class="hljs-code"><span class="hljs-keyword">import</span> logging&#13;
&#13;
a = logging.getLogger(<span class="hljs-string">'a'</span>)&#13;
ab = logging.getLogger(<span class="hljs-string">'a.b'</span>)&#13;
&#13;
ab.setLevel(logging.ERROR)&#13;
ab.error(<span class="hljs-string">'before setting level'</span>)&#13;
a.setLevel(logging.CRITICAL)&#13;
ab.error(<span class="hljs-string">'after setting level'</span>)&#13;
</code></pre>&#13;
    <p class="normal">When we execute this, we <a id="_idIndexMarker840"/>notice that setting the level is completely ignored:</p>&#13;
    <pre class="programlisting con"><code class="hljs-con"><span class="hljs-con-meta">$</span> python3 T_35_logging_propagate_pitfalls.py&#13;
before setting level&#13;
after setting level&#13;
</code></pre>&#13;
    <p class="normal">Once again, not a problem in this case, but if that happens in some external library without your knowledge it can certainly cause a headache.</p>&#13;
    <h2 id="_idParaDest-302" class="heading-2">Debugging loggers</h2>&#13;
    <p class="normal">The most important rule about<a id="_idIndexMarker841"/> loggers is that they inherit the settings from the parent loggers unless you override them. If your logging isn’t working as you expect it, most of the time it’s caused by some inheritance issue and that can be difficult to debug.</p>&#13;
    <p class="normal">The logging flow according to the Python manual looks like this:</p>&#13;
    <figure class="mediaobject"><img src="Images/B15882_10_04.png" alt="../_images/logging_flow.png" width="876" height="695"/></figure>&#13;
    <p class="packt_figref">Figure 10.4: Logging flow. Copyright © 2001-2021 Python Software Foundation; All Rights Reserved</p>&#13;
    <p class="normal">Now that we know how the logging flow is supposed to go, we can start creating a method to show our <a id="_idIndexMarker842"/>current logger structure and the settings:</p>&#13;
    <pre class="programlisting code"><code class="hljs-code"><span class="hljs-keyword">import</span> logging&#13;
&#13;
<span class="hljs-keyword">def</span><span class="hljs-function"> </span><span class="hljs-title">get_handlers</span><span class="hljs-function">(</span><span class="hljs-params">logger</span><span class="hljs-function">):</span>&#13;
    handlers = []&#13;
    <span class="hljs-comment"># Walk through the loggers and their parents recursively to</span>&#13;
    <span class="hljs-comment"># fetch the handlers</span>&#13;
    <span class="hljs-keyword">while</span> logger:&#13;
        handlers += logger.handlers&#13;
&#13;
        <span class="hljs-keyword">if</span> logger.propagate:&#13;
            logger = logger.parent&#13;
        <span class="hljs-keyword">else</span>:&#13;
            <span class="hljs-keyword">break</span>&#13;
&#13;
    <span class="hljs-comment"># Python has a lastResort handler in case no handlers are</span>&#13;
    <span class="hljs-comment"># defined</span>&#13;
    <span class="hljs-keyword">if</span> <span class="hljs-keyword">not</span> handlers <span class="hljs-keyword">and</span> logging.lastResort:&#13;
        handlers.append(logging.lastResort)&#13;
&#13;
    <span class="hljs-keyword">return</span> handlers&#13;
&#13;
<span class="hljs-keyword">def</span><span class="hljs-function"> </span><span class="hljs-title">debug_loggers</span><span class="hljs-function">():</span>&#13;
    logger: logging.Logger&#13;
    <span class="hljs-keyword">for</span> name, logger <span class="hljs-keyword">in</span> logging.root.manager.loggerDict.items():&#13;
        <span class="hljs-comment"># Placeholders are loggers without settings</span>&#13;
        <span class="hljs-keyword">if</span> <span class="hljs-built_in">isinstance</span>(logger, logging.PlaceHolder):&#13;
            print(<span class="hljs-string">'skipping'</span>, name)&#13;
            <span class="hljs-keyword">continue</span>&#13;
&#13;
        level = logging.getLevelName(logger.getEffectiveLevel())&#13;
        handlers = get_handlers(logger)&#13;
        print(<span class="hljs-string">f'</span><span class="hljs-subst">{name}</span><span class="hljs-string">@</span><span class="hljs-subst">{level}</span><span class="hljs-string">: </span><span class="hljs-subst">{handlers}</span><span class="hljs-string">'</span>)&#13;
&#13;
<span class="hljs-keyword">if</span> __name__ == <span class="hljs-string">'__main__'</span>:&#13;
    a = logging.getLogger(<span class="hljs-string">'a'</span>)&#13;
    a.setLevel(logging.INFO)&#13;
&#13;
    handler = logging.StreamHandler()&#13;
    handler.setLevel(logging.INFO)&#13;
    ab = logging.getLogger(<span class="hljs-string">'a.b'</span>)&#13;
    ab.setLevel(logging.DEBUG)&#13;
    ab.addHandler(handler)&#13;
&#13;
    debug_loggers()&#13;
</code></pre>&#13;
    <p class="normal">The <code class="inlineCode">get_handlers()</code> function<a id="_idIndexMarker843"/> recursively walks through a logger and all of its parents to collect all propagated handlers. The <code class="inlineCode">debug_loggers()</code> function walks through the internal config of the <code class="inlineCode">logging</code> module to list all configured loggers and fetch the matching handlers through <code class="inlineCode">get_handlers()</code>.</p>&#13;
    <p class="normal">This is just a basic <a id="_idIndexMarker844"/>debugging function of course, but it can really help you when you’re wondering why your logging is not working as expected. The output looks something like this:</p>&#13;
    <pre class="programlisting con"><code class="hljs-con"><span class="hljs-con-meta">$</span> python3 T_36_logger_debugging.py&#13;
a@INFO: [&lt;_StderrHandler &lt;stderr&gt; (WARNING)&gt;]&#13;
a.b@DEBUG: [&lt;StreamHandler &lt;stderr&gt; (INFO)&gt;]&#13;
</code></pre>&#13;
    <p class="normal">Now we can see that the <code class="inlineCode">a</code> logger has level <code class="inlineCode">INFO</code> but only has a handler at a <code class="inlineCode">WARNING</code> level. So, none of our <code class="inlineCode">INFO</code> messages will show. Similarly, the <code class="inlineCode">a.b</code> logger has a <code class="inlineCode">DEBUG</code> level but a handler at level <code class="inlineCode">INFO</code> so it will only show <code class="inlineCode">INFO</code> and higher levels.</p>&#13;
    <h1 id="_idParaDest-303" class="heading-1">Exercises</h1>&#13;
    <p class="normal">Now that you have seen several testing and logging options, it’s time to try it yourself.</p>&#13;
    <p class="normal">A few challenges:</p>&#13;
    <ul>&#13;
      <li class="bulletList">Create a function that tests the doctests of a given function/class.</li>&#13;
      <li class="bulletList">For a greater challenge, create a function that recursively tests all doctests of every function and class in a given module.</li>&#13;
      <li class="bulletList">Create a <code class="inlineCode">py.test</code> plugin that checks if all tested files have file-level documentation. Hint: use <code class="inlineCode">pytest_collect_file</code>.</li>&#13;
      <li class="bulletList">Create a custom <code class="inlineCode">tox</code> environment to run <code class="inlineCode">flake8</code> or <code class="inlineCode">mypy</code> on your project.</li>&#13;
      <li class="bulletList">Create a <code class="inlineCode">LoggerAdapter</code> that combines multiple messages into a single message based on some task ID. This can be useful when debugging long-running tasks.</li>&#13;
</ul>&#13;
      &#13;
        <div class="note">&#13;
          <p class="normal">Example answers for these exercises can be found on GitHub: <a href="Chapter_10.xhtml"><span class="url">https://github.com/mastering-python/exercises</span></a>. You are encouraged to submit your own solutions and learn about alternative solutions from others.</p>&#13;
        </div>&#13;
      &#13;
    &#13;
    <h1 id="_idParaDest-304" class="heading-1">Summary</h1>&#13;
    <p class="normal">This chapter showed us how to write doctests, make use of the shortcuts provided by <code class="inlineCode">py.test</code>, and use the <code class="inlineCode">logging</code> module. With testing, there is never a one-size-fits-all solution. While the <code class="inlineCode">doctest</code> system is very useful in many cases for providing both documentation and tests at the same time, in many functions there are edge cases that simply don’t matter for documentation but still need to be tested. This is where regular unit tests come in and where <code class="inlineCode">py.test</code> helps a lot.</p>&#13;
    <p class="normal">We have also seen how we can use <code class="inlineCode">tox</code> to run tests in multiple sandboxed environments. If you ever have a project that also has to run on different computers or even on different Python versions, I would highly encourage you to use it. </p>&#13;
    <p class="normal">The <code class="inlineCode">logging</code> module is extremely useful when configured correctly and if your project becomes somewhat larger, it quickly becomes useful to do so. The usage of the logging system should be clear enough for most of the common use cases now, and as long as you keep the <code class="inlineCode">propagate</code> parameter in check, you should be fine when implementing a logging system. </p>&#13;
    <p class="normal">Next up is debugging, where testing helps prevent bugs. We will see how to solve them effectively. In addition, the logging that we added in this chapter will help a lot in that area.</p>&#13;
    <h1 class="heading-1">Join our community on Discord</h1>&#13;
    <p class="normal">Join our community’s Discord space for discussions with the author and other readers: <a href="https://discord.gg/QMzJenHuJf"><span class="url">https://discord.gg/QMzJenHuJf</span></a></p>&#13;
    <p class="normal"><img src="Images/QR_Code156081100001293319171.png" alt="" width="177" height="177"/></p>&#13;
  </div>&#13;
</div></body></html>