- en: Chapter 4. Mocking HTTP Requests Using HTTPretty
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: With the `Requests` module, we gained the means to open URLs, post data, and
    get data from web services. Let us take an instance of building an application,
    which uses a RESTful API and unfortunately, the API on which the server is running
    is down. Even though we achieved interaction with the web using Requests, we failed
    this time because we got no response from the server's side. This condition may
    leave us irked and blocked from our progress, as we found no way of testing our
    code any further.
  prefs: []
  type: TYPE_NORMAL
- en: So, there came this idea of creating an HTTP request mock tool, which can serve
    us by mocking the web server on the client side. Even though HTTPretty is no way
    directly connected with Requests, we would like to introduce a mock tool which
    would help us in the previously mentioned case.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: HTTP mock tool helps to mock web services by faking requests.
  prefs: []
  type: TYPE_NORMAL
- en: 'We''ll look at the following topics in this chapter:'
  prefs: []
  type: TYPE_NORMAL
- en: Understanding HTTPretty
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Installing HTTPretty
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Usage in detail
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Setting headers
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Working with responses
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Understanding HTTPretty
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: HTTPretty is an HTTP client mock library for Python. The basic idea of HTTPretty
    is inspired by Ruby's FakeWeb, which is well known to the people from the Ruby
    community. HTTPretty re-implements the HTTP protocol by mimicking requests and
    responses.
  prefs: []
  type: TYPE_NORMAL
- en: Essentially, HTTPretty works on socket level, which gives it the inward virtue
    of working with most of the HTTP client libraries and it is more specifically
    battle tested against HTTP client libraries like `Requests`, `httplib2` and `urlib2`.
    So, we can mock the interactions from our Request library without any difficulty.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here are the two cases in which HTTPretty comes to the rescue:'
  prefs: []
  type: TYPE_NORMAL
- en: The condition in which the API server is down
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The condition in which the API content has changed
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Installing HTTPretty
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We can install HTTPretty effortlessly from **Python Package Index** (**PyPi**).
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'We will be learning many more things with examples in this process of getting
    used to HTTPretty; And in this course of journey we will be using libraries like
    mock, sure and obviously Requests. Here we go, with those installations:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: 'Let us take a peek at what exactly those packages deal with:'
  prefs: []
  type: TYPE_NORMAL
- en: '`mock`: It is a testing library which allows us to replace parts of the system
    under test with mock objects'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`sure`: It is a Python library which is used to make assertions'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Working with HTTPretty
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'There are three main steps to be followed while dealing with HTTPretty:'
  prefs: []
  type: TYPE_NORMAL
- en: Enable HTTPretty
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Register the uniform resource locator to HTTPretty
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Disable HTTPretty
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'We should enable HTTPretty initially, so that it will apply monkey patching;
    that is, a dynamic replacement of the attributes of the socket module. We will
    be using the function `register_uri` for registering the uniform resource locator.
    The `register_uri` function takes `class`, `uri` and `body` as arguments:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: 'And at the end of our testing process, we should disable HTTPretty so that
    it doesn''t alter the behavior of the other. Let us take a look at using HTTPretty
    with an example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: In this example, we used the `httpretty.GET` class in `register_uri` function
    to register the `uri` value that is `"http://google.com/"`. In the next line,
    we used Request to get the information from the URI and then we used the expect
    function to assert the expected status code. In a nutshell, the preceding code
    tries to mock the URI and tests whether we are getting the same status code as
    expected.
  prefs: []
  type: TYPE_NORMAL
- en: 'We can simplify the preceding code using a decorator. As in the first and third
    step, that is, enabling and disabling HTTPretty are same all the time, we can
    use a decorator so that those functions get wrapped up whenever we want them to
    come into the picture. The decorator looks like this: `@httpretty.activate`. The
    previous code example can be rewritten using a decorator in the following way:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: Setting headers
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: HTTP header fields supply the necessary information about the request or response.
    We can mock any HTTP response header by using HTTPretty. To achieve that, we will
    be adding them as keyword arguments. We should keep in mind that the keys of the
    keyword arguments are always lower case and have underscores (_) instead of dashes.
  prefs: []
  type: TYPE_NORMAL
- en: 'For example, if we want to mock the server, which returns Content-Type, we
    can use the argument `content_type`. Do notice that, in the following part we
    are using an inexistent URL to showcase the syntax:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: Similarly, all the keyword arguments are taken by HTTPretty and changed into
    the RFC2616 equivalent name.
  prefs: []
  type: TYPE_NORMAL
- en: Working with responses
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'When we mock HTTP requests using HTTPretty, it returns an `httpretty.Response`
    object. We can generate the following responses through callbacks:'
  prefs: []
  type: TYPE_NORMAL
- en: Rotating Responses
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Streaming Responses
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Dynamic Responses
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Rotating responses
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Rotating responses are the responses we receive in a given order when we send
    a request to a server with the same URL and same request method. We can define
    as many responses as we wish with the responses argument.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following snippet explains the mocking of Rotating Responses:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: In this example, we have registered three different responses using the responses
    argument with the `httpretty.register_uri` method. And then, we sent four different
    requests to the server with the same URI and the same method. As a result, we
    received the first three responses in the sequence of registration. From the fourth
    request, we'll get the last response defined in the responses object.
  prefs: []
  type: TYPE_NORMAL
- en: Streaming responses
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Streaming responses will not have `Content-Length` header. Rather, they have
    a `Transfer-Encoding` header with a value of `chunked`, and a body consisting
    of a series of chunks you write to the socket preceded by their individual sizes.
    These kinds of responses are also called **Chunked Responses**.
  prefs: []
  type: TYPE_NORMAL
- en: 'We can mock a Streaming response by registering a generator response body:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: To mock a streaming response, we need to set the streaming argument to `True`
    while registering `uri`. In the previous example, we mocked the streaming response
    using the generator `mock_streaming_repos,` which will take the list as an argument,
    and will yield the list item every half second.
  prefs: []
  type: TYPE_NORMAL
- en: Dynamic responses through callbacks
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'If the response from the API server is generated, depending on the values from
    the request, then we call it a Dynamic response. To mock dynamic responses based
    on the request, we will use a callback method as defined in the following example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: In this example, `request_callback` method is registered while mocking the response,
    in order to generate dynamic response content.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we learnt the basic concepts related to HTTPretty. We looked
    at what HTTPretty is, and why we need HTTPretty. We also walked through detailed
    usage of the mocking library, setting headers, and mocking different types of
    Responses. These topics are enough for us to get started and keep the progress
    moving on.
  prefs: []
  type: TYPE_NORMAL
- en: In the next chapter, we will learn how to interact with the social networks
    like Facebook, Twitter, and reddit with the requests library.
  prefs: []
  type: TYPE_NORMAL
