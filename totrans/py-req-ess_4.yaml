- en: Chapter 4. Mocking HTTP Requests Using HTTPretty
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第四章 使用 HTTPretty 模拟 HTTP 请求
- en: With the `Requests` module, we gained the means to open URLs, post data, and
    get data from web services. Let us take an instance of building an application,
    which uses a RESTful API and unfortunately, the API on which the server is running
    is down. Even though we achieved interaction with the web using Requests, we failed
    this time because we got no response from the server's side. This condition may
    leave us irked and blocked from our progress, as we found no way of testing our
    code any further.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 使用 `Requests` 模块，我们获得了打开 URL、发送数据以及从网络服务获取数据的手段。让我们以构建一个应用程序的实例来举例，该应用程序使用 RESTful
    API，不幸的是，服务器运行的 API 出现了故障。尽管我们通过 Requests 实现了与网络的交互，但这次我们失败了，因为我们从服务器端没有得到任何响应。这种状况可能会让我们感到恼火并阻碍我们的进展，因为我们找不到进一步测试我们代码的方法。
- en: So, there came this idea of creating an HTTP request mock tool, which can serve
    us by mocking the web server on the client side. Even though HTTPretty is no way
    directly connected with Requests, we would like to introduce a mock tool which
    would help us in the previously mentioned case.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，产生了创建一个HTTP请求模拟工具的想法，它可以模拟客户端的Web服务器来为我们提供服务。即使HTTPretty与Requests没有直接连接，我们仍然希望介绍一个模拟工具，以帮助我们在之前提到的情况下。
- en: Note
  id: totrans-3
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意事项
- en: HTTP mock tool helps to mock web services by faking requests.
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: HTTP 模拟工具通过伪造请求来模拟网络服务。
- en: 'We''ll look at the following topics in this chapter:'
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在本章中将探讨以下主题：
- en: Understanding HTTPretty
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 理解 HTTPretty
- en: Installing HTTPretty
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 安装 HTTPretty
- en: Usage in detail
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 详细用法
- en: Setting headers
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 设置标题
- en: Working with responses
  id: totrans-10
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 与响应一起工作
- en: Understanding HTTPretty
  id: totrans-11
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 理解 HTTPretty
- en: HTTPretty is an HTTP client mock library for Python. The basic idea of HTTPretty
    is inspired by Ruby's FakeWeb, which is well known to the people from the Ruby
    community. HTTPretty re-implements the HTTP protocol by mimicking requests and
    responses.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: HTTPretty 是一个用于 Python 的 HTTP 客户端模拟库。HTTPretty 的基本理念受到了 Ruby 社区中广为人知的 FakeWeb
    的启发，它通过模拟请求和响应来重新实现 HTTP 协议。
- en: Essentially, HTTPretty works on socket level, which gives it the inward virtue
    of working with most of the HTTP client libraries and it is more specifically
    battle tested against HTTP client libraries like `Requests`, `httplib2` and `urlib2`.
    So, we can mock the interactions from our Request library without any difficulty.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 本质上，HTTPretty 在套接字级别上工作，这使得它具有与大多数 HTTP 客户端库协同工作的内在优势，并且它特别针对像 `Requests`、`httplib2`
    和 `urlib2` 这样的 HTTP 客户端库进行了实战测试。因此，我们可以毫无困难地模拟我们的请求库中的交互。
- en: 'Here are the two cases in which HTTPretty comes to the rescue:'
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 这里是HTTPretty提供帮助的两个案例：
- en: The condition in which the API server is down
  id: totrans-15
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: API服务器宕机的情况
- en: The condition in which the API content has changed
  id: totrans-16
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: API内容发生变化的条件
- en: Installing HTTPretty
  id: totrans-17
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 安装 HTTPretty
- en: We can install HTTPretty effortlessly from **Python Package Index** (**PyPi**).
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以轻松地从**Python软件包索引**（**PyPi**）安装HTTPretty。
- en: '[PRE0]'
  id: totrans-19
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'We will be learning many more things with examples in this process of getting
    used to HTTPretty; And in this course of journey we will be using libraries like
    mock, sure and obviously Requests. Here we go, with those installations:'
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 在熟悉HTTPretty的过程中，我们将通过实例学习到更多内容；在这个过程中，我们将使用mock、sure以及显然的Requests等库。现在，让我们开始这些安装：
- en: '[PRE1]'
  id: totrans-21
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'Let us take a peek at what exactly those packages deal with:'
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们一探究竟，看看那些包具体处理了什么：
- en: '`mock`: It is a testing library which allows us to replace parts of the system
    under test with mock objects'
  id: totrans-23
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`mock`: 它是一个测试库，允许我们用模拟对象替换被测试系统中的部分组件'
- en: '`sure`: It is a Python library which is used to make assertions'
  id: totrans-24
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`sure`: 它是一个用于进行断言的 Python 库'
- en: Working with HTTPretty
  id: totrans-25
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用 HTTPretty
- en: 'There are three main steps to be followed while dealing with HTTPretty:'
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 处理HTTPretty时需要遵循三个主要步骤：
- en: Enable HTTPretty
  id: totrans-27
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 启用 HTTPretty
- en: Register the uniform resource locator to HTTPretty
  id: totrans-28
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将统一资源定位符注册到HTTPretty
- en: Disable HTTPretty
  id: totrans-29
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 禁用HTTPretty
- en: 'We should enable HTTPretty initially, so that it will apply monkey patching;
    that is, a dynamic replacement of the attributes of the socket module. We will
    be using the function `register_uri` for registering the uniform resource locator.
    The `register_uri` function takes `class`, `uri` and `body` as arguments:'
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 我们应该最初启用HTTPretty，这样它就会应用猴子补丁；也就是说，动态替换套接字模块的属性。我们将使用`register_uri`函数来注册统一资源定位符。`register_uri`函数接受`class`、`uri`和`body`作为参数：
- en: '[PRE2]'
  id: totrans-31
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'And at the end of our testing process, we should disable HTTPretty so that
    it doesn''t alter the behavior of the other. Let us take a look at using HTTPretty
    with an example:'
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的测试过程结束时，我们应该禁用HTTPretty，以免它改变其他组件的行为。让我们通过一个示例来看看如何使用HTTPretty：
- en: '[PRE3]'
  id: totrans-33
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: In this example, we used the `httpretty.GET` class in `register_uri` function
    to register the `uri` value that is `"http://google.com/"`. In the next line,
    we used Request to get the information from the URI and then we used the expect
    function to assert the expected status code. In a nutshell, the preceding code
    tries to mock the URI and tests whether we are getting the same status code as
    expected.
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个例子中，我们使用了`httpretty.GET`类在`register_uri`函数中注册了`uri`值为`"http://google.com/"`。在下一行，我们使用Request从URI获取信息，然后使用expect函数断言预期的状态码。总的来说，前面的代码试图模拟URI并测试我们是否得到了预期的相同状态码。
- en: 'We can simplify the preceding code using a decorator. As in the first and third
    step, that is, enabling and disabling HTTPretty are same all the time, we can
    use a decorator so that those functions get wrapped up whenever we want them to
    come into the picture. The decorator looks like this: `@httpretty.activate`. The
    previous code example can be rewritten using a decorator in the following way:'
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以使用装饰器来简化前面的代码。正如第一步和第三步，即启用和禁用HTTPretty始终相同，我们可以使用装饰器，这样那些函数就可以在我们需要它们出现的时候被包装起来。装饰器看起来是这样的：`@httpretty.activate`。之前的代码示例可以用以下方式使用装饰器重写：
- en: '[PRE4]'
  id: totrans-36
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: Setting headers
  id: totrans-37
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 设置标题
- en: HTTP header fields supply the necessary information about the request or response.
    We can mock any HTTP response header by using HTTPretty. To achieve that, we will
    be adding them as keyword arguments. We should keep in mind that the keys of the
    keyword arguments are always lower case and have underscores (_) instead of dashes.
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: HTTP头部字段提供了关于请求或响应的必要信息。我们可以通过使用HTTPretty来模拟任何HTTP响应头部。为了实现这一点，我们将它们作为关键字参数添加。我们应该记住，关键字参数的键始终是小写字母，并且使用下划线（_）而不是破折号（-）。
- en: 'For example, if we want to mock the server, which returns Content-Type, we
    can use the argument `content_type`. Do notice that, in the following part we
    are using an inexistent URL to showcase the syntax:'
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，如果我们想模拟返回Content-Type的服务器，我们可以使用`content_type`参数。请注意，在下面的部分，我们使用一个不存在的URL来展示语法：
- en: '[PRE5]'
  id: totrans-40
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: Similarly, all the keyword arguments are taken by HTTPretty and changed into
    the RFC2616 equivalent name.
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 同样，HTTPretty 会接收所有关键字参数并将其转换为 RFC2616 的等效名称。
- en: Working with responses
  id: totrans-42
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 与响应一起工作
- en: 'When we mock HTTP requests using HTTPretty, it returns an `httpretty.Response`
    object. We can generate the following responses through callbacks:'
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们使用HTTPretty模拟HTTP请求时，它会返回一个`httpretty.Response`对象。我们可以通过回调函数生成以下响应：
- en: Rotating Responses
  id: totrans-44
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 旋转响应
- en: Streaming Responses
  id: totrans-45
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 流式响应
- en: Dynamic Responses
  id: totrans-46
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 动态响应
- en: Rotating responses
  id: totrans-47
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 旋转响应
- en: Rotating responses are the responses we receive in a given order when we send
    a request to a server with the same URL and same request method. We can define
    as many responses as we wish with the responses argument.
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 旋转响应是我们向服务器发送请求时，按照给定顺序收到的响应。我们可以使用响应参数定义我们想要的任意数量的响应。
- en: 'The following snippet explains the mocking of Rotating Responses:'
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 以下片段解释了旋转响应的模拟过程：
- en: '[PRE6]'
  id: totrans-50
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: In this example, we have registered three different responses using the responses
    argument with the `httpretty.register_uri` method. And then, we sent four different
    requests to the server with the same URI and the same method. As a result, we
    received the first three responses in the sequence of registration. From the fourth
    request, we'll get the last response defined in the responses object.
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个例子中，我们使用`httpretty.register_uri`方法通过`responses`参数注册了三种不同的响应。然后，我们向服务器发送了四个不同的请求，这些请求具有相同的URI和相同的方法。结果，我们按照注册的顺序收到了前三个响应。从第四个请求开始，我们将获得`responses`对象中定义的最后一个响应。
- en: Streaming responses
  id: totrans-52
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 流式响应
- en: Streaming responses will not have `Content-Length` header. Rather, they have
    a `Transfer-Encoding` header with a value of `chunked`, and a body consisting
    of a series of chunks you write to the socket preceded by their individual sizes.
    These kinds of responses are also called **Chunked Responses**.
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 流式响应将不会包含`Content-Length`头部。相反，它们有一个值为`chunked`的`Transfer-Encoding`头部，以及由一系列数据块组成的内容体，这些数据块由它们各自的大小值
    precede。这类响应也被称为**分块响应**。
- en: 'We can mock a Streaming response by registering a generator response body:'
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以通过注册一个生成器响应体来模拟一个 Streaming 响应：
- en: '[PRE7]'
  id: totrans-55
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: To mock a streaming response, we need to set the streaming argument to `True`
    while registering `uri`. In the previous example, we mocked the streaming response
    using the generator `mock_streaming_repos,` which will take the list as an argument,
    and will yield the list item every half second.
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 为了模拟流式响应，我们需要在注册`uri`时将流式参数设置为`True`。在之前的示例中，我们使用生成器`mock_streaming_repos`来模拟流式响应，该生成器将列表作为参数，并且每半秒产生列表中的一个项目。
- en: Dynamic responses through callbacks
  id: totrans-57
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 通过回调函数实现动态响应
- en: 'If the response from the API server is generated, depending on the values from
    the request, then we call it a Dynamic response. To mock dynamic responses based
    on the request, we will use a callback method as defined in the following example:'
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 如果API服务器的响应是根据请求的值生成的，那么我们称之为动态响应。为了根据请求模拟动态响应，我们将使用以下示例中定义的回调方法：
- en: '[PRE8]'
  id: totrans-59
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: In this example, `request_callback` method is registered while mocking the response,
    in order to generate dynamic response content.
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 在此示例中，在模拟响应时注册了`request_callback`方法，以便生成动态响应内容。
- en: Summary
  id: totrans-61
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: In this chapter, we learnt the basic concepts related to HTTPretty. We looked
    at what HTTPretty is, and why we need HTTPretty. We also walked through detailed
    usage of the mocking library, setting headers, and mocking different types of
    Responses. These topics are enough for us to get started and keep the progress
    moving on.
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们学习了与HTTPretty相关的基本概念。我们了解了HTTPretty是什么，以及为什么我们需要HTTPretty。我们还详细介绍了模拟库的使用，设置头部信息和模拟不同类型的响应。这些主题足以让我们开始并保持进展。
- en: In the next chapter, we will learn how to interact with the social networks
    like Facebook, Twitter, and reddit with the requests library.
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章中，我们将学习如何使用requests库与社交网络如Facebook、Twitter和Reddit进行交互。
