<html><head></head><body>
		<div><div></div>
		</div>
		<div><h1 id="_idParaDest-99"><a id="_idTextAnchor197"/>5. Object Serialization with marshmallow</h1>
		</div>
		<div><h2>Learning Objectives</h2>
			<p>By the end of this chapter, you will be able to:</p>
			<ul>
				<li class="bullets">Create a schema for serialization/deserialization</li>
				<li class="bullets">Validate the data in a client request</li>
				<li class="bullets">Perform data filtering before displaying the data to the client</li>
				<li class="bullets">Use the HTTP PATCH method to partially update data</li>
			</ul>
			<p>This chapter covers serialization and deserialization, as well as data filtering and validation with marshmallow.</p>
		</div>
		<div><h2 id="_idParaDest-100"><a id="_idTextAnchor198"/>Introduction</h2>
			<p>In this era of information explosion, the correctness of data is crucially important. We need to ensure that the data passed in by the client is in the format we expect. For example, we expect the <code>cooking time</code> variable to be a data type integer with a value of 30, but the client could pass in a string data type, with <code>value = "thirty minutes"</code>. They mean the same thing, and both are understandable to human beings but the system won't be able to interpret them. In this chapter, we will learn about data validation, making sure the system only takes valid data. The marshmallow package not only helps us to verify the client's data but also to verify the data that we send back. This ensures data integrity in both directions, which will greatly improve the quality of the system. </p>
			<p>In this chapter, we will focus on doing three essential things: first, we will modify the <code>User</code> class and add in the API verification. This is mainly to show the basic functions of marshmallow. We'll then modify the <code>Recipe</code> class, add a custom authentication method, and optimize the code. Finally, a new feature will be added, which allows us to query all the recipes of a specific user and filter the recipes with different publish statuses by the visibility parameter. With this in mind, let's move on to the first topic: <strong class="bold">Serialization</strong> versus <strong class="bold">Deserialization</strong>.</p>
			<h2 id="_idParaDest-101"><a id="_idTextAnchor199"/>Serialization versus Deserialization</h2>
			<div><div><img src="img/C15309_05_01.jpg" alt="Figure 5.1: Serialization versus deserialization&#13;&#10;"/>
				</div>
			</div>
			<h6>Figure 5.1: Serialization versus deserialization</h6>
			<p>An object is something that lives in the application memory. We can invoke its method or access its attributes in our application. However, when we want to transfer or store an object, we will have to convert it into a storable or transferrable format, and that format will be a stream of bytes. It can then be stored in a text file, in a database, or be transmitted over the internet. The process of converting an object to a stream of bytes is called serialization. This stream of bytes persists the state of the object so that it can be recreated later. The recreation of the object from a stream of bytes is called deserialization. </p>
			<p>Serialization/deserialization is an essential part of RESTful API development. During actual development, the data validation related to business logic will often be included in the serialization and deserialization implementation processes as well.</p>
			<h2 id="_idParaDest-102">m<a id="_idTextAnchor200"/>arshmallow</h2>
			<p><strong class="keyword">marshmallow</strong> itself is an excellent package for serialization and deserialization in Python, as well as providing validation features. It allows developers to define schemas, which can be used to represent a field in various ways (required and validation), and automatically perform validation during deserialization. We will start by implementing a data validation function in this chapter. We will implement it using the marshmallow package to ensure that the information the user entered is correct. We will work with you through various exercises and activities to test serialization and deserialization afterward with Postman.</p>
			<h2 id="_idParaDest-103"><a id="_idTextAnchor201"/>A Simple Schema</h2>
			<p>We will be using the <code>Schema</code> class from marshmallow to specify the fields for the objects that we want to serialize/deserialize. Without knowing the schema of the objects and how we want to serialize the fields, we can't perform serialization or deserialization. In the following example, you can see we have a simple <code>SimpleSchema</code> class, which extends <code>marshmallow.Schema</code>, and there are two fields defined there, <code>id</code> and <code>username</code>:</p>
			<pre>from marshmallow import Schema, fields
class SimpleSchema(Schema):
    id = fields.Int() 
    username = fields.String()</pre>
			<p>The data type of the fields are defined using the <code>marshmallow</code> fields. From the preceding example, the <code>id</code> field is an <code>username</code> field is a <strong class="bold">string</strong>. There are a number of different data types in marshmallow, including <strong class="bold">Str</strong>, <strong class="bold">Int</strong>, <strong class="bold">Bool</strong>, <strong class="bold">Float</strong>, <strong class="bold">DateTime</strong>, <strong class="bold">Email</strong>, <strong class="bold">Nested</strong>, and so on.</p>
			<p>With the schema specified, we can start doing object serialization and deserialization. We can serialize objects in our application and return them in the HTTP response. Or, the other way round, we can take in a request from users and deserialize that into an object so that it can be used in our application.</p>
			<h3 id="_idParaDest-104"><a id="_idTextAnchor202"/>Field Validation</h3>
			<p>We can also add field-level validation during serialization/deserialization. Again, this can be done in the schema definition. For example, if we want to specify a field as mandatory, we can add in the <code>required=True</code> argument. Using the same <code>SimpleSchema</code> example, we can specify the <code>username</code> field as mandatory as follows:</p>
			<pre>class SimpleSchema(Schema):
    id = fields.Int() 
    username = fields.String(required=True)</pre>
			<p>If this <code>SimpleSchema</code> is used to deserialize the JSON request from the user and the <code>username</code> field is not filled in there, there will be an error message, <code>Validation errors</code>, and the HTTP status code will be <strong class="bold">400 Bad Request</strong>:</p>
			<pre>{
    "message": "Validation errors",
    "errors": {
        "username": [
            "Missing data for the required field."
        ]
    }
}</pre>
			<p>Now we will learn how to customize deserialization methods.</p>
			<h3 id="_idParaDest-105"><a id="_idTextAnchor203"/>Customizing Deserialization Methods</h3>
			<p>We can also customize the way we want to deserialize certain fields. We can do so by using <code>Method</code> fields in marshmallow. A <code>Method</code> field receives an optional <code>deserialize</code> argument, which defines how the field should be deserialized.</p>
			<p>From the following <code>SimpleSchema</code> example, we can define a custom method to deserialize the <code>password</code> field. We just need to pass in the <code>deserialize='load_password'</code> argument. It will invoke the <code>load_password</code> method to deserialize the <code>password</code> field:</p>
			<pre>class SimpleSchema(Schema):
    id = fields.Int() 
    username = fields.String(required=True)
    password = fields.Method(required=True, deserialize='load_password')
    def load_password(self, value): 
        return hash_password(value)</pre>
			<p>In the next section, we will learn how to use the <code>UserSchema</code> design.</p>
			<h2 id="_idParaDest-106"><a id="_idTextAnchor204"/>UserSchema Design</h2>
			<p>Now we have learned why we need to use <code>Schema</code> and how we can define a schema, we will start to work on that in our <code>Smilecook</code> application. In the case of user registration, we will expect the user to fill in their information on a web form, and then send the details in JSON format to the server. Our <code>Smilecook</code> application will then deserialize it to be a <code>User</code> object, which can be worked on in our application. </p>
			<p>We will, therefore, need to define a <code>UserSchema</code> class to specify the expected attributes in the JSON request coming from the frontend. We will need the following fields: </p>
			<ul>
				<li><code>id</code>: Use <code>fields.Int()</code> to represent an integer. In addition, <code>dump_only=True</code> means that this property is only available for serialization, not deserialization. This is because <code>id</code> is autogenerated, not passed in by the user. </li>
				<li><code>username</code>: Use <code>fields.String()</code> to represent a string and apply <code>required=True</code> to indicate that this property is mandatory. When the client sends JSON data without the username, there will be a validation error.</li>
				<li><code>email</code>: Use <code>fields.Email()</code> to indicate that <code>email</code> format is needed, and apply <code>required=True</code> to indicate that this property is mandatory. </li>
				<li><code>password:fields.Method()</code> is a <code>Method</code> field. The <code>Method</code> field here receives an optional <code>deserialize</code> argument, which defines how the field should be deserialized. We use <code>deserialize='load_password'</code> to indicate that the <code>load_password(self, value)</code> method will be invoked when using <code>load()</code> deserialization. Please note that this <code>load_password(self, value)</code> method will only be invoked during <code>load()</code> deserialization. </li>
				<li><code>created_at:fields.DateTime()</code> represents the time format, and <code>dump_only=True</code> means that this property will only be available in serialization.</li>
				<li><code>updated_at:fields.DateTime()</code> represents the time format, and <code>dump_only=True</code> means that this property will only be available in serialization.</li>
			</ul>
			<p>In our next exercise, we will install the marshmallow package in our <code>Smilecook</code> project. Then, we will define the <code>UserSchema</code> and use it in <code>UserListResource</code> and <code>UserResource</code>.</p>
			<h3 id="_idParaDest-107">E<a id="_idTextAnchor205"/>xercise 33: Using marshmallow to Validate the User Data</h3>
			<p>Firstly, we will perform data verification using marshmallow. We will install the <code>marshmallow</code> package and build <code>UserSchema</code>, and then use it in <code>UserListResource</code> to transmit the <code>User</code> object: </p>
			<ol>
				<li>W<a id="_idTextAnchor206"/>e will first install the marshmallow package. Please enter the following in <code>requirements.txt</code>:<pre>marshmallow==2.19.5</pre></li>
				<li><a id="_idTextAnchor207"/>R<a id="_idTextAnchor208"/>un the <code>pip install</code> command:<pre>pip install -r requirements.txt</pre><p>You should see the result that follows:</p><pre>Installing collected packages: marshmallow
Successfully installed marshmallow-2.19.5</pre></li>
				<li><a id="_idTextAnchor209"/>Create a folder under the <code>Smilecook</code> project and name it <code>schemas</code>. We will store all our schema files here.</li>
				<li>C<a id="_idTextAnchor210"/>reate a <code>user.py</code> file under that and enter the following code. Use a schema to define the basic structure of the content of our expected client request. The following code creates <code>UserSchema</code> to define the attributes we will receive in the client request:<pre>from marshmallow import Schema, fields
from utils import hash_password
class UserSchema(Schema):
    class Meta:
        ordered = True
    id = fields.Int(dump_only=True)
    username = fields.String(required=True)
    email = fields.Email(required=True)
    password = fields.Method(required=True, deserialize='load_password')
    created_at = fields.DateTime(dump_only=True)
    updated_at = fields.DateTime(dump_only=True)
    def load_password(self, value):
        return hash_password(value)</pre><p>Before defining <code>UserSchema</code>, we need to first import <code>Schema</code> and <code>fields</code> from marshmallow. All self-defined marshmallow schemas must inherit <code>marshmallow.Schema</code>. Then, we import <code>hash_password</code>, and we define four attributes: <code>id</code>, <code>username</code>, <code>email</code>, and <code>password</code> in <code>UserSchema</code>.</p></li>
				<li><a id="_idTextAnchor211"/>Add the following code in <code>resources/user.py</code>. We will first import the <code>UserSchema</code> class from the previous step and instantiate two <code>UserSchema</code> objects here. One of them is for use in public, and we can see that the email is excluded: <pre>from schemas.user import UserSchema
user_schema = UserSchema()
user_public_schema = UserSchema(exclude=('email', ))</pre><p>For our <code>user</code> resource, when the authenticated user accesses its <code>users/&lt;username&gt;</code> endpoint, they can get <code>id</code>, <code>username</code>, and <code>email</code>. But if they are not authenticated or are accessing other people's <code>/users/&lt;username&gt;</code> endpoint, the email address will be hidden. </p></li>
				<li>W<a id="_idTextAnchor212"/>e will then modify <code>UserListResource</code> to the following to validate the data in the user's request:<pre>class UserListResource(Resource):
    def post(self):
        json_data = request.get_json()
        data, errors = user_schema.load(data=json_data)
        if errors:
            return {'message': 'Validation errors', 'errors': errors}, HTTPStatus.BAD_REQUEST</pre></li>
				<li>In the same <code>UserListResource.post</code>, we will proceed if there is no error. It will then check whether <code>username</code> and <code>email</code> exist, and if everything is fine, we will use <code>User(**data)</code> to create a user instance, the <code>**data</code> will give us keyword arguments for the <code>User</code> class, then we use <code>user.save()</code> to store things in the database:<pre>        if User.get_by_username(data.get('username')):
            return {'message': 'username already used'}, HTTPStatus.BAD_REQUEST
        if User.get_by_email(data.get('email')):
            return {'message': 'email already used'}, HTTPStatus.BAD_REQUEST
        user = User(**data)
        user.save()</pre></li>
				<li>Finally, also in <code>UsersLitResource.post</code>, we use <code>user_schema.dump(user).data</code> to return the successfully registered user data. It will contain <code>id</code>, <code>username</code>, <code>created_at</code>, <code>updated_at</code>, and <code>email</code>:<pre>        return user_schema.dump(user).data, HTTPStatus.CREATED</pre></li>
				<li><a id="_idTextAnchor213"/>N<a id="_idTextAnchor214"/>ext, we will modify <code>UserResource</code>. We will see the difference between with and without filtering email using <code>user_schema</code> and <code>user_public_schema</code> here:<pre>class UserResource(Resource):
    @jwt_optional
    def get(self, username):
        user = User.get_by_username(username=username)
        if user is None:
            return {'message': 'user not found'}, HTTPStatus.NOT_FOUND
        current_user = get_jwt_identity()
        if current_user == user.id:
            data = user_schema.dump(user).data
        else:
            data = user_public_schema.dump(user).data
        return data, HTTPStatus.OK</pre><p>When a user sends a request to <code>/users/&lt;username/</code>, we will get their username. If a user can't be found, we will get <code>user_schema.dump(user).data</code>, which contains all the information. Otherwise, <code>user_public_schema.dump(user).data</code> will be used, which excludes the email information. Finally, it returns data with the HTTP status code <strong class="bold">200 OK</strong>.</p></li>
				<li>Next, we will modify <code>MeResource</code>. It will be serialized using <code>user_schema.dump(user).data</code>, which contains all the information of the user:<pre>class MeResource(Resource):
    @ jwt_required
    def get(self): 
         user = User.get_by_id(id=get_jwt_identity())
         return user_schema.dump(user).data, HTTPStatus.OK</pre></li>
				<li><a id="_idTextAnchor215"/>Save <code>app.py</code> and right-click on it to run the application. Flask will then be started up and run on the localhost (<code>127.0.0.1</code>) at port <code>5000</code>:<div><img src="img/C15309_05_02.jpg" alt="Figure 5.2: Run the application and then run Flask on the localhost&#13;&#10;"/></div></li>
			</ol>
			<h6>Figure 5.2: Run the application and then run Flask on the localhost</h6>
			<p>So, we have finished adding marshmallow to the picture. From now onward, when we transfer the <code>User</code> object between the frontend and backend, it will first be serialized/deserialized. In the process, we can leverage the data validation functions provided by marshmallow to make our API endpoints even more secure.</p>
			<h3 id="_idParaDest-108"><a id="_idTextAnchor216"/>Exercise 34: Testing the User Endpoint before and after Authentication</h3>
			<p>We implemented different user schemas in the previous exercise one for private viewing and one for public viewing. In this exercise, we are going to test whether they work as expected. We will check the data in the HTTP response and verify whether we get different user information before and after authentication. We want to hide the user's email address from the public, to protect user privacy.</p>
			<p>We will do the whole test using Postman. Let's get started!</p>
			<ol>
				<li value="1">Check the <code>user</code> details before the user has logged in. We shouldn't see the user's email address in the result. Click on the <strong class="bold">Collections</strong> tab.</li>
				<li>Select the <strong class="bold">GET User</strong> request.</li>
				<li>Enter <code>http://localhost:5000/users/james</code> in the URL field. You can replace the username <code>James</code> with any username that is appropriate.</li>
				<li>Click <code>user</code> details. And in the response body, we can see the user details for James. We can see the <code>username</code>, <code>created_at</code>, <code>updated_at</code>, and <code>id</code>, but not the email address.</p></li>
				<li>Now<a id="_idTextAnchor217"/>, let's login using Postman. Select the <strong class="bold">POST Token</strong> request. Click <strong class="bold">Send</strong> to log in. The result is shown in the following screenshot:</li>
				<li><div><img src="img/C15309_05_04.jpg" alt="Figure 5.4: Log in and select the POST Token request&#13;&#10;"/></div><h6>Figure 5.4: Log in and select the POST Token request</h6><p>You will then see the response body for the access token and the refresh token.</p></li>
				<li>Chec<a id="_idTextAnchor218"/>k the <code>user</code> details after the user has logged in. You should see the user's email address in the result. Click on the <strong class="bold">Collections</strong> tab. Choose to <strong class="bold">GET User</strong>. Select the <strong class="bold">Headers</strong> tab.</li>
				<li>Enter <code>Authorization</code> in the <code>Bearer {token}</code> in the <code>JWT</code> token we got in <em class="italics">step 5</em>.</li>
				<li>Click <strong class="bold">Send</strong> to check the user details for James. The result is shown in the following screenshot:<div><img src="img/C15309_05_05.jpg" alt="Figure 5.5: Checking the details after the user has logged in&#13;&#10;"/></div></li>
			</ol>
			<h6>Figure 5.5: Checking the details after the user has logged in</h6>
			<p>You will then see the return response. In the response body, we can see the user details for James. We can see all his information, including his email address.</p>
			<p>So, by using the <code>exclude</code> parameter in the user schema, we can easily exclude certain sensitive fields from showing up in the HTTP response. Apart from the <code>exclude</code> parameter, marshmallow also has the <code>include</code> parameter, which you can explore more yourself if you are interested.</p>
			<h2 id="_idParaDest-109">Reci<a id="_idTextAnchor219"/>peSchema Design</h2>
			<p>So, we have done the serialization/deserialization for the <code>User</code> object. Now we are going to design the schema for the <code>Recipe</code> object. In the case of the <code>Recipe</code> update, we will expect the user to fill in updated recipe details on a web form, and then send the details in JSON format to the server. Our <code>Smilecook</code> application will then deserialize it to be a <code>Recipe</code> object, which can be worked on in our application.</p>
			<p><code>RecipeSchema</code> should inherit <code>marshmallow.Schema</code> and contains the following attributes:</p>
			<ul>
				<li><code>id</code>: Use <code>fields.Int()</code> to represent an integer, and apply <code>dump_only=True</code> to specify that this property is only available for serialization.</li>
				<li><code>name</code>: Use <code>fields.String()</code> to represent a string and apply <code>required=True</code> to indicate that this attribute is required. </li>
				<li><code>description</code>: Use <code>fields.String()</code> to represent a string.</li>
				<li><code>num_of_servings</code>: Use <code>fields.Int()</code> to represent an integer.</li>
				<li><code>cook_time</code>: Use <code>fields.Int()</code> to represent an integer.</li>
				<li><code>directions</code>: Use <code>fields.String()</code> to represent a string.</li>
				<li><code>is_publish</code>: Use <code>fields.Boolean()</code> to represent a Boolean, and apply <code>dump_only=True</code> to specify that this attribute is only available for serialization.</li>
				<li><code>author</code>: This attribute is used to display the author of the recipe. </li>
				<li><code>created_at</code>: Use <code>fields.DateTime</code> to represent the format of the time, and <code>dump_only=True</code> means that this attribute is only available for serialization.</li>
				<li><code>updated_at</code>: Use <code>fields.DateTime</code> to represent the format of the time, and <code>dump_only=True</code> means that this attribute is only available for serialization.</li>
			</ul>
			<h3 id="_idParaDest-110">Exerc<a id="_idTextAnchor220"/>ise 35: Implementing RecipeSchema</h3>
			<p>Now we have the <code>RecipeSchema</code> design in mind. In this exercise, we will learn more about marshmallow by implementing <code>RecipeSchema</code>. Not only can we just validate the data type of <code>fields</code>, but we can also build our own validation function. Let's get started:</p>
			<ol>
				<li value="1">Firs<a id="_idTextAnchor221"/>t<a id="_idTextAnchor222"/>, we import <code>schema</code>, <code>fields</code>, <code>post_dump</code>, <code>validate</code>, <code>validates</code>, and <code>ValidationError</code> and create the <code>recipe schema</code> by entering the following code in <code>schemas/recipe.py</code>:<pre>from marshmallow import Schema, fields, post_dump, validate, validates, ValidationError
class RecipeSchema(Schema):
    class Meta:
        ordered = True
    id = fields.Integer(dump_only=True)
    name = fields.String(required=True, validate=[validate.Length(max=100)])
    description = fields.String(validate=[validate.Length(max=200)])
    directions = fields.String(validate=[validate.Length(max=1000)])
    is_publish = fields.Boolean(dump_only=True)
    created_at = fields.DateTime(dump_only=True)
    updated_at = fields.DateTime(dump_only=True)</pre><p>We can perform additional validation for a field by passing in the <code>validate</code> argument. We use <code>validate.Length(max=100)</code> to limit the maximum length of this attribute to <code>100</code>. When it exceeds <code>100</code>, it will trigger a validation error. This can prevent users from passing in an extremely long string, which will create a burden on our database. Using the <code>validation</code> function from marshmallow, that can be easily prevented. </p></li>
				<li>Then, we define the <code>validate_num_of_servings(n)</code> method in <code>RecipeSchema</code>, which is a customized validation function. This will validate that this attribute has a minimum of <code>1</code> and cannot be greater than <code>50</code>. If its value doesn't fall within this range, it will raise an error message:<pre>def validate_num_of_servings(n):
    if n &lt; 1:
        raise ValidationError('Number of servings must be greater than 0.')
    if n &gt; 50:
        raise ValidationError('Number of servings must not be greater than 50.')</pre></li>
				<li>Next, add the <code>num_of_servings</code> attribute in <code>RecipeSchema</code>. Use <code>validate=validate_num_of_servings</code> to link to our custom function, which will verify the number of servings of this recipe:<pre>num_of_servings = fields.Integer(validate=validate_num_of_servings)</pre></li>
				<li>There is another way for us to add a customized validation method. We can add the <code>cooktime</code> attribute in <code>RecipeSchema</code>:<pre>cook_time = fields.Integer()</pre></li>
				<li>Then, in <code>RecipeSchema</code>, use the <code>@validates('cook_time')</code> decorator to define the validation method. When validating the <code>cook_time</code> property, it will call the <code>validate_cook_time</code> method to specify that the cooking time should be between 1 minute and 300 minutes:<pre>    @validates('cook_time')
    def validate_cook_time(self, value):
        if value &lt; 1:
            raise ValidationError('Cook time must be greater than 0.')
        if value &gt; 300:
            raise ValidationError('Cook time must not be greater than 300.')</pre></li>
				<li>On top of the <code>schemas/recipe.py</code> file, import <code>UserSchema</code> from marshmallow, because we will display the author information for the recipe together when displaying the recipe information:<pre>from schemas.user import UserSchema</pre></li>
				<li>Then, in <code>RecipeSchema</code>, define the attribute <code>author</code>. We use <code>fields.Nested</code> to link this attribute to an external object, which is <code>UserSchema</code> in this case:<pre>author = fields.Nested(UserSchema, attribute='user', dump_only=True, only=['id', 'username'])</pre><p>To avoid any confusion, this attribute is named <code>author</code> in the JSON response, but the original attribute name is the <code>user</code>. In addition, <code>dump_only=True</code> means that this attribute is only available for serialization. Finally, add <code>only=['id', ' username']</code> to specify that we will only show the user's ID and username.</p></li>
				<li>In addition, we add the <code>@post_dump(pass_many=True)</code> decorator so that further processing can be done when the recipe is serialized. The code is as follows:<pre>    @post_dump(pass_many=True)
    def wrap(self, data, many, **kwargs):
        if many:
            return {'data': data}
        return data</pre><p>In the case of returning only one recipe, it will be simply returned in a JSON string. But when we are returning multiple recipes, we will store the recipes in a list and return them using the <code>{'data': data}</code> format in JSON. This format will be beneficial for us when we develop the pagination feature.</p></li>
				<li>The code in <code>schemas/recipe.py</code> should now look like the following – please review it:<pre>from marshmallow import Schema, fields, post_dump, validate, validates, ValidationError
from schemas.user import UserSchema
def validate_num_of_servings(n):
    if n &lt; 1:
        raise ValidationError('Number of servings must be greater than 0.')
    if n &gt; 50:
        raise ValidationError('Number of servings must not be greater than 50.')
class RecipeSchema(Schema):
    class Meta:
        ordered = True
    id = fields.Integer(dump_only=True)
    name = fields.String(required=True, validate=[validate.Length(max=100)])
    description = fields.String(validate=[validate.Length(max=200)])
    num_of_servings = fields.Integer(validate=validate_num_of_servings)
    cook_time = fields.Integer()
    directions = fields.String(validate=[validate.Length(max=1000)])
    is_publish = fields.Boolean(dump_only=True)
    author = fields.Nested(UserSchema, attribute='user', dump_only=True, only=['id', 'username'])
    created_at = fields.DateTime(dump_only=True)
    updated_at = fields.DateTime(dump_only=True)
    @post_dump(pass_many=True)
    def wrap(self, data, many, **kwargs):
        if many:
            return {'data': data}
        return data
    @validates('cook_time')
    def validate_cook_time(self, value):
        if value &lt; 1:
            raise ValidationError('Cook time must be greater than 0.')
        if value &gt; 300:
            raise ValidationError('Cook time must not be greater than 300.'</pre><p>Once we have completed the recipe schema, we can start to use it in the related resources.</p></li>
				<li>We wi<a id="_idTextAnchor223"/>ll then modify <code>resources/recipe.py</code> as follows:<pre>from schemas.recipe import RecipeSchema
recipe_schema = RecipeSchema()
recipe_list_schema = RecipeSchema(many=True)</pre><p>We first import <code>RecipeSchema</code> from <code>schemas.recipe</code>,then define the <code>recipe_schema</code> variable and <code>recipe_list_schema</code>; they are for storing single and multiple recipes.</p></li>
				<li>Modif<a id="_idTextAnchor224"/>y the <code>RecipeListResource</code> <code>get</code> method to return all the published recipes back to the client by using the <code>recipe_list_schema.dump(recipes).data</code> method:<pre>class RecipeListResource(Resource):
    def get(self):
        recipes = Recipe.get_all_published()
        return recipe_list_schema.dump(recipes).data, HTTPStatus.OK</pre></li>
				<li>Modif<a id="_idTextAnchor225"/>y the <code>RecipeListResource</code> <code>post</code> method to use the recipe schema:<pre>    @jwt_required
    def post(self):
        json_data = request.get_json()
        current_user = get_jwt_identity()
        data, errors = recipe_schema.load(data=json_data)
        if errors:
            return {'message': "Validation errors", 'errors': errors}, HTTPStatus.BAD_REQUEST
        recipe = Recipe(**data)
        recipe.user_id = current_user
        recipe.save()
        return recipe_schema.dump(recipe).data, HTTPStatus.CREATED</pre><p>After receiving the JSON data, the data is verified by <code>recipe_schema.load(data=json_data)</code>. If there is an error, it will return <code>Recipe(**data)</code> will be used to create a <code>recipe</code> object, then specify it as the currently logged-in user's ID via <code>recipe.user_id = current_user</code>. The recipe will then be saved to the repository via <code>recipe.save()</code>, and finally, converted to JSON using <code>recipe_schema.dump(recipe).data</code> to the client, with a HTTP status code <strong class="bold">201 CREATED</strong> message.</p></li>
				<li>Beca<a id="_idTextAnchor226"/><a id="_idTextAnchor227"/><a id="_idTextAnchor228"/>u<a id="_idTextAnchor229"/><a id="_idTextAnchor230"/><a id="_idTextAnchor231"/>se the rendering of our data has been done through marshmallow, we don't need the <code>data</code> method in the recipe, so we can delete the <code>data</code> method in <code>model/recipe.py</code>. That is, delete the following code from the file:<pre>    def data(self):
        return {
            'id': self.id,
            'name': self.name,
            'description': self.description,
            'num_of_servings': self.num_of_servings,
            'cook_time': self.cook_time,
            'directions': self.directions,
            'user_id': self.user_id
        }</pre></li>
				<li>Now w<a id="_idTextAnchor232"/>e have finished the implementation. Right-click on it to run the application. Flask will then be started up and run on the localhost (<code>127.0.0.1</code>) at port <code>5000</code>:<div><img src="img/C15309_05_06.jpg" alt="Figure 5.6: Run the application and then Flask on the localhost&#13;&#10;"/></div></li>
			</ol>
			<h6>Figure 5.6: Run the application and then Flask on the localhost</h6>
			<p>So, we have just completed the work on <code>RecipeSchema</code>, as well as modifying the API endpoints to transmit the object using the serialization/deserialization approach. In the next exercise, we will test whether our implementation works.</p>
			<h3 id="_idParaDest-111">Exerci<a id="_idTextAnchor233"/>se 36: Testing the Recipe API</h3>
			<p>To tes<a id="_idTextAnchor234"/>t whether the serialization/deserialization of the object works, we will again need to test it in Postman. This exercise is to test creating and getting all our recipe details using Postman.</p>
			<ol>
				<li value="1">First,<a id="_idTextAnchor235"/> log in to the account. Our previous token was only valid for 15 minutes. If it expires, we need to log in again via <code>/token</code> or reacquire the token using the <strong class="bold">Refresh</strong> Token. Click on the <strong class="bold">Collections</strong> tab.</li>
				<li>Select the <strong class="bold">POST</strong> <strong class="bold">Token</strong> request.</li>
				<li>Click <strong class="bold">Send</strong> to log in. The result is shown in the following screenshot:<div><img src="img/C15309_05_07.jpg" alt="Figure 5.7: Log in to the account and select the POST Token request&#13;&#10;"/></div><h6>Figure 5.7: Log in to the account and select the POST Token request</h6><p>You will then see the return response, <strong class="bold">HTTP Status is 200 OK</strong>, meaning the login was successful, and we will see the access token in the response body. This access token will be used in later steps. </p></li>
				<li>Next, w<a id="_idTextAnchor236"/>e will create a new recipe. Click on the <strong class="bold">Collections</strong> tab. Choose <strong class="bold">POST RecipeList</strong>. </li>
				<li>Select the <code>Authorization</code> in the <code>Bearer {token}</code> in the <code>JWT</code> token we got in our previous step.</li>
				<li>Select the <strong class="bold">Body</strong> tab. Fill in the recipe details as follows:<pre>{
    "name": "Blueberry Smoothie",
    "description": "This is a lovely Blueberry Smoothie",
    "num_of_servings": 2,
    "cook_time": 10,
    "directions": "This is how you make it"
}</pre></li>
				<li>Click <strong class="bold">Send</strong> to create a new recipe. The result is shown in the following screenshot:<div><img src="img/C15309_05_08.jpg" alt="Figure 5.8: Creating a new recipe&#13;&#10;"/></div><h6>Figure 5.8: Creating a new recipe</h6><p>You will then see the return response, <strong class="bold">HTTP Status is 201 CREATED</strong>, meaning the new recipe has been created successfully. In the response body, we can see the recipe details. We can also see the author's details shown in a nested format.</p></li>
				<li>Then, w<a id="_idTextAnchor237"/><a id="_idTextAnchor238"/><a id="_idTextAnchor239"/>e will publish the recipe with <code>id = 4</code>. Click on the <code>http://localhost:5000/recipes/4/publish</code> in <strong class="bold">Enter request URL</strong>.</li>
				<li>Select the <code>Authorization</code> in the <code>Bearer {token}</code> in the <code>id = 4</code>. The result is shown in the following screenshot:<div><img src="img/C15309_05_09.jpg" alt="Figure 5.9: Publish the recipe with ID 4&#13;&#10;"/></div><h6>Figure 5.9: Publish the recipe with ID 4</h6><p>You will then see the return response, HTTP Status is <strong class="bold">204 NO CONTENT</strong>, meaning it is published successfully. You will see no content in the body.</p></li>
				<li>Then, w<a id="_idTextAnchor240"/>e will get all the recipes back. Select the <strong class="bold">GET RecipeList</strong> request. Click <strong class="bold">Send</strong> to get all the recipes back. The result is shown in the following screenshot:<div><img src="img/C15309_05_10.jpg" alt="Figure 5.10: Getting all the recipes back by selecting the GET RecipeList request&#13;&#10;"/></div></li>
			</ol>
			<h6>Figure 5.10: Getting all the recipes back by selecting the GET RecipeList request</h6>
			<p>You will then see the return response, HTTP Status is 200 <strong class="bold">OK</strong>, meaning we have successfully retrieved all the recipe details. In the response body, we can see that there is a list of data, which contains all the published recipes.</p>
			<p>So, we have successfully implemented and tested the serialization (creating the recipe) and deserialization (retrieving the recipe) on the recipe-related API endpoints. We are making good progress here!</p>
			<h2 id="_idParaDest-112"><a id="_idTextAnchor241"/>The PATCH Method</h2>
			<p>We have been using the <code>PUT</code> HTTP method all along for data updates. However, the actual usage of the <code>PUT</code> method is to <code>PUT /items/1</code> means to replace everything in <code>/items/1</code>. If this item already exists, it will be replaced. Otherwise, it will create a new item. <code>PUT</code> must contain all attribute data for <code>items/1</code>.</p>
			<p>This doesn't seem to work very well in all cases. If you just want to update only one of the attributes of <code>items/1</code>, you need to retransmit all the attributes of <code>items/1</code> to the server, which is not efficient at all. So, there is a new HTTP method: <code>PATCH</code> method was invented to do a partial update. With this method, we need to pass in only the attributes that need to be modified to the server.</p>
			<h3 id="_idParaDest-113"><a id="_idTextAnchor242"/>Exercise 37: Using the PATCH Method to Update the Recipe</h3>
			<p>In this exercise, we will change the recipe update method from <code>PUT</code> to <code>PATCH</code>. We will also use the serialization/deserialization approach to transmit the recipes. Finally, we will test our changes in Postman, to make sure things work as expected. The aim of this exercise is to reduce the bandwidth and server processing resources when we update the recipe data: </p>
			<ol>
				<li value="1">Create the <code>patch</code> method in <code>RecipeListResource</code>. We will first use <code>request.get_json()</code> to get the JSON recipe details sent by the client, and then use <code>recipe_schema.load(data=json_data, partial=('name',))</code> to validate the data format. We are using <code>partial=('name',)</code> because the original name is a required field in the schema. When the client only wants to update a single attribute, using <code>partial</code> allows us to specify that the <code>Name</code> attribute is optional, so no error will occur even though we are not passing in this attribute:<pre>   @jwt_required
    def patch(self, recipe_id):
        json_data = request.get_json()
        data, errors = recipe_schema.load(data=json_data, partial=('name',))</pre></li>
				<li>Then, in the same <code>patch</code> method, we will check whether there is an error message. If any, it will return the <strong class="bold">HTTP Status Code 400 Bad Request</strong> error message. If the validation passes, then check whether the user has permission to update this recipe. If not, <strong class="bold">HTTP status code Forbidden 403</strong> will be returned:<pre>        if errors:
            return {'message': 'Validation errors', 'errors': errors}, HTTPStatus.BAD_REQUEST
        recipe = Recipe.get_by_id(recipe_id=recipe_id)
        if recipe is None:
            return {'message': 'Recipe not found'}, HTTPStatus.NOT_FOUND
        current_user = get_jwt_identity()
        if current_user != recipe.user_id:
            return {'message': 'Access is not allowed'}, HTTPStatus.FORBIDDEN</pre></li>
				<li>We continue to work on the same <code>patch</code> method. <code>recipe.name = data.get('name') or recipe.name</code> means it will try to get the name of the key value of the data. If this value exists, it will be used. Otherwise, <code>recipe.name</code> will stay the same. This is basically how we do the update:<pre>        recipe.name = data.get('name') or recipe.name
        recipe.description = data.get('description') or recipe.description
        recipe.num_of_servings = data.get('num_of_servings') or recipe.num_of_servings
        recipe.cook_time = data.get('cook_time') or recipe.cook_time
        recipe.directions = data.get('directions') or recipe.directions</pre></li>
				<li>In the same <code>patch</code> method, we use the <code>save</code> method to save everything to the database and return the recipe data in JSON format:<pre>        recipe.save()
        return recipe_schema.dump(recipe).data, HTTPStatus.OK</pre></li>
				<li>Now we have the new <code>patch</code> method ready. Right-click on it to run the application. Flask will then be started up and run on the localhost (<code>127.0.0.1</code>) at port <code>5000</code>: <div><img src="img/C15309_05_06.jpg" alt="Figure 5.11: Run the application and then run Flask on the localhost&#13;&#10;"/></div><h6>Figure 5.11: Run the application and then run Flask on the localhost</h6><p>Next, we are going to update the recipe with <code>id = 4</code>. We will update only two fields:  <code>num_of_servings,</code> and <code>cook_time</code>.</p></li>
				<li>Click on the <strong class="bold">Collections</strong> tab. Choose the <strong class="bold">PUT Recipe</strong> request. Change the <strong class="bold">HTTP</strong> method from <strong class="bold">PUT</strong> to <strong class="bold">PATCH</strong>.</li>
				<li>Select the <code>Authorization</code> in the <code>Bearer {token}</code> in the <code>JWT</code> token we got in our previous exercise. </li>
				<li>Select the <strong class="bold">Body</strong> tab. Type the following in the <strong class="bold">Body</strong> field:<pre>{
    "num_of_servings": 4,
    "cook_time": 20
}</pre><p>Click <strong class="bold">Send</strong> to update the recipe. The result is shown in the following screenshot:</p><div><img src="img/C15309_05_12.jpg" alt="Figure 5.12: Updating the recipe&#13;&#10;"/></div></li>
			</ol>
			<h6>Figure 5.12: Updating the recipe</h6>
			<p>You will then see the return response <code>num_of_servings</code> and <code>cook_time</code> is updated. We can also see the <code>updated_at</code> timestamp has been automatically updated as well.</p>
			<h3 id="_idParaDest-114"><a id="_idTextAnchor243"/>Searching for Authors and Unpublished Recipes</h3>
			<p>On the <code>Smilecook</code> platform, there will be many different foodies from around the world (here, we call them authors) to share their recipes. Among these outstanding authors, we will definitely have a favorite author, and we will definitely want to learn all of their recipes. Therefore, we have added a new endpoint (or function), which is to list the recipes of a specific author. This endpoint not only lists all the recipes published by a particular gourmet but can also allow the author to search all of their own published/unpublished recipes.</p>
			<h3 id="_idParaDest-115"><a id="_idTextAnchor244"/>Using the webargs Package to Parse the Request Arguments</h3>
			<p>The request arguments, also known as the query string, are the arguments that we can pass in through the URL. For example, in the URL <code>http://localhost/testing?abc=123</code>, <code>abc=123</code> is the request argument.</p>
			<p><code>GET http://localhost:5000/user/{username}/recipes</code>, to get all the published recipes from a particular author. For this endpoint, we will pass in the visibility request argument. The <code>visibility</code> request argument can have a value of <code>public</code>, <code>private</code>, or <code>all</code>. The default value is <code>public</code>. If it is <code>private</code> or <code>all</code>, the user needs to be authenticated first.</p>
			<p>If you want to get only the unpublished recipes, you can add the request argument <code>visibility=private</code>. So, the URL will look like this: <code>http://localhost:5000/user/{username}/recipes?visibility=private</code>. The <code>webargs</code> package provides functions to parse this <code>visibility=private</code> argument in the URL, and then our <code>Smilecook</code> application will know this request is asking for private information in the recipe. Our <code>Smilecook</code> application will then determine whether the authenticated user is the author. If they are, it will return all the unpublished recipes. Otherwise, there is no permission for the user to see the unpublished recipes.</p>
			<h3 id="_idParaDest-116">Exercise 38:<a id="_idTextAnchor245"/><a id="_idTextAnchor246"/><a id="_idTextAnchor247"/> Implementing Access Control on Recipes</h3>
			<p>In this exercise, we are going to implement access control on recipes. So, only authenticated users will be able to see all of their own recipes, including unpublished ones. The user will pass in the <code>visibility</code> mode by using the <code>request</code> argument. We use <code>webargs</code> to parse the visibility mode and return published, unpublished, or all recipes accordingly:</p>
			<ol>
				<li value="1">Create the <a id="_idTextAnchor248"/><code>get_all_by_user</code> method in the <code>Recipe</code> class in <code>models/recipe.py</code>:<pre>    @classmethod
    def get_all_by_user(cls, user_id, visibility='public'):
        if visibility == 'public':
            return cls.query.filter_by(user_id=user_id, is_publish=True).all()
        elif visibility == 'private':
            return cls.query.filter_by(user_id=user_id, is_publish=False).all()
        else:
            return cls.query.filter_by(user_id=user_id).all()</pre><p>This method needs to take in <code>user_id</code> and <code>visibility</code>. If the <code>visibility</code> is not defined, the default will be <code>public</code>. If the <code>visibility</code> is <code>public</code>, it will get all the recipes by <code>user_id</code> and <code>is_publish=True</code>. If the visibility is <code>private</code>, it will search for the recipe with <code>is_publish=False</code>. If the visibility is not <code>public</code> or <code>private</code>, it will get all the recipes of this user. </p></li>
				<li>We will ins<a id="_idTextAnchor249"/>tall the <code>webargs</code> package, which is a package for interpreting and verifying HTTP arguments (for example, <code>visibility</code>). Please add the following package in <code>requirements.txt</code>:<pre>webargs==5.4.0</pre></li>
				<li>Install the<a id="_idTextAnchor250"/> <a id="_idTextAnchor251"/>package using the following command:<pre>pip install -r requirements.txt</pre><p>You should see a result like the following:</p><pre>Installing collected packages: webargs
Successfully installed webargs-5.4.0</pre></li>
				<li>Import the <a id="_idTextAnchor252"/>n<a id="_idTextAnchor253"/>ecessary modules, functions, and classes in <code>resources/user.py</code>:<pre>from flask import request
from flask_restful import Resource
from flask_jwt_extended import get_jwt_identity, jwt_required, jwt_optional
from http import HTTPStatus
from webargs import fields
from webargs.flaskparser import use_kwargs
from models.recipe import Recipe
from models.user import User
from schemas.recipe import RecipeSchema
from schemas.user import UserSchema</pre><p>First, import <code>webargs.fields</code> and <code>webargs.flaskparser.use_kwargs</code>, then we will need to use the recipe data, so we also need to import the recipe model and schema.</p></li>
				<li>Then, we wil<a id="_idTextAnchor254"/>l declare the <code>recipe_list_schema</code> variable. Use <code>RecipeSchema</code> with the <code>many=True</code> parameter. This is to show that we will have multiple recipes:<pre>recipe_list_schema = RecipeSchema(many=True)</pre></li>
				<li>We will the<a id="_idTextAnchor255"/>n<a id="_idTextAnchor256"/> create the <code>UserRecipeListResource</code> class. This resource is mainly for getting the recipes under a specific user. Please refer to the following code:<pre>class UserRecipeListResource(Resource):
    @jwt_optional
    @use_kwargs('visibility': fields.Str(missing='public')})
    def get(self, username, visibility):</pre><p>First, define <code>@jwt_optional</code> to mean that this endpoint can be accessed without a user being logged in. Then, use <code>@use_kwargs({'visibility': fields.Str(missing='public')})</code> to specify that we expect to receive the parameters of <code>visibility</code> here. If the parameter is absent, the default will be public. The <code>visibility</code> parameter will then be passed into <code>def get(self, username, visibility)</code>. </p></li>
				<li>We will implement access control in <code>UserRecipeListResource.get</code>. If the username (the author of the recipe) is the currently authenticated user, then they can see all the recipes, including the private ones. Otherwise, they can only see the published recipes: <pre>def get(self, username, visibility):
        user = User.get_by_username(username=username)
        if user is None:
            return {'message': 'User not found'}, HTTPStatus.NOT_FOUND
        current_user = get_jwt_identity()
        if current_user == user.id and visibility in ['all', 'private']:
            pass
        else:
            visibility = 'public'
        recipes = Recipe.get_all_by_user(user_id=user.id, visibility=visibility)
        return recipe_list_schema.dump(recipes).data, HTTPStatus.OK</pre><p>The user is then obtained by <code>User.get_by_username(username=username)</code>. If the user cannot be found, will return a HTTP status code <code>get_jwt_identity()</code> and save it to the <code>current_user</code> variable.</p><p>Based on the user and their permission, we will display a different set of recipes. After the recipe is obtained, <code>recipe_list_schema.dump(recipes).data</code> is used to convert the recipes into JSON format and return to the client with HTTP Status Code is <strong class="bold">200 OK</strong>.</p></li>
				<li>Then, import<a id="_idTextAnchor257"/> <code>UserRecipeListResource</code> in <code>app.py</code>:<pre>from resources.user import UserListResource, UserResource, MeResource, UserRecipeListResource</pre></li>
				<li>Finally, we<a id="_idTextAnchor258"/> <a id="_idTextAnchor259"/>add the following endpoint:<pre>api.add_resource(UserListResource, '/users')
api.add_resource(UserResource, '/users/&lt;string:username&gt;')
api.add_resource(UserRecipeListResource, '/users/&lt;string:username&gt;/recipes')</pre></li>
				<li>Now, we have finished the implementation. Right-click on it to run the application. Flask will then be started up and run on the localhost (<code>127.0.0.1</code>) at port <code>5000</code>: <div><img src="img/C15309_05_13.jpg" alt="Figure 5.13: Run Flask on the localhost&#13;&#10;"/></div></li>
			</ol>
			<h6>Figure 5.13: Run Flask on the localhost</h6>
			<p>Now we have learned how to use <code>webargs</code> to parse <code>request</code> arguments and have applied that to our <code>Smilecook</code> application. Next, as usual, we want to test and make sure that it works.</p>
			<h3 id="_idParaDest-117">Exercise 39: <a id="_idTextAnchor260"/>Retrieving <a id="_idTextAnchor261"/>Recipes from a Specific Author</h3>
			<p>This exercise is to test what we implemented in our last exercise. We will make sure the API is parsing the visibility mode that the user passes in and returns different sets of recipes accordingly. We will use a specific user (James) for testing. We will see that before and after authentication, the user will be able to see different sets of recipes: </p>
			<ol>
				<li value="1">We will get a<a id="_idTextAnchor262"/>ll the published recipes for a particular user before they have logged in. First, click on the <strong class="bold">Collections</strong> tab.</li>
				<li>Add a new request under the <code>UserRecipeList</code> and save.</li>
				<li>Select the newly created <code>http://localhost:5000/users/james/recipes</code> in the <strong class="bold">URL</strong> field (change the username if necessary).</li>
				<li>Click <strong class="bold">Send</strong> to check all the published recipes under this particular user (James here). The result is shown in the following screenshot:<div><img src="img/C15309_05_14.jpg" alt="Figure 5.14: Get all the published recipes for a user before they have logged in&#13;&#10;"/></div><h6>Figure 5.14: Get all the published recipes for a user before they have logged in</h6><p>You will then see the return response. The HTTP status code <strong class="bold">200 OK</strong> here indicates that the request has succeeded and, in the body, we can see one published recipe under this author.</p></li>
				<li>Similar to the<a id="_idTextAnchor263"/> previous step, we will see whether we can get all the recipes under a particular user before the user has logged in – it shouldn't be allowed. Select the <code>visibility</code>. Set <code>all</code>. Click <strong class="bold">Send</strong> to check all the recipes under this particular user. The result is shown in the following screenshot:<div><img src="img/C15309_05_15.jpg" alt="Figure 5.15: Check all the recipes under a particular user&#13;&#10;"/></div><h6>Figure 5.15: Check all the recipes under a particular user</h6><p>You will then see the return response. The HTTP status code <strong class="bold">200 OK</strong> here indicates that the request has succeeded, and in the body again, though we are asking for all recipes, we can only see one published recipe under this author because the user hasn't logged in.</p></li>
				<li>Log in and clic<a id="_idTextAnchor264"/>k on the <strong class="bold">Collections</strong> tab. Select the <strong class="bold">POST</strong> <strong class="bold">Token</strong> request. Click <strong class="bold">Send</strong> to check all the recipes under this particular user. The result is shown in the following screenshot:<div><img src="img/C15309_05_16.jpg" alt="Figure 5.16: Select the POST Token request and send the request&#13;&#10;"/></div><h6>Figure 5.16: Select the POST Token request and send the request</h6><p>You will then see the return response. The <strong class="bold">HTTP status code 200 OK</strong> here indicates that the request has succeeded, and in the body, we can get the access token and refresh token that we will use in the next step.</p></li>
				<li>Select the <code>Authorization</code> in the <code>Bearer {token}</code> in the <strong class="bold">Value</strong> field, where the token is the <strong class="bold">JWT</strong> token we got in our previous step. Click <strong class="bold">Send</strong> to query. The result is shown in the following screenshot:<div><img src="img/C15309_05_17.jpg" alt="Figure 5.17: Use the JWT token and send to query&#13;&#10;"/></div></li>
			</ol>
			<h6>Figure 5.17: Use the JWT token and send to query</h6>
			<p>You will then see the return response. The <strong class="bold">HTTP status code 200 OK</strong> here indicates that the request has succeeded. In the response body, we can get all the recipes under this user, including the unpublished ones.</p>
			<p>This testing exercise concluded what we have learned about the <code>webargs</code> package, as well as testing the new access control functions we added for viewing recipes.</p>
			<h3 id="_idParaDest-118">Activity 8: Seria<a id="_idTextAnchor266"/>lizing the recipe Object Using marshmallow</h3>
			<p>In this activity, we want you to work on the serialization of the <code>RecipeResource.get</code> method. We did serialization for <code>User</code> and <code>RecipeList</code> in previous exercises. Now, it is your turn to work on this last one. </p>
			<p>Currently, <code>RecipeResource.get</code> is returning the <code>recipe</code> object using <code>recipe.data()</code>. We want you to replace that by serializing the <code>recipe</code> object using marshmallow. The <code>recipe</code> object should be converted into JSON format and return to the frontend client-side. To do that, you will modify <code>recipe_schema</code> in <code>resources/recipe.py</code>. You are also required to test your implementation using Postman at the end.</p>
			<p>The following are the steps to perform:</p>
			<ol>
				<li value="1">Modify the recipe schema, to include all attributes except for <code>email</code>.</li>
				<li>Modify the <code>get</code> method in <code>RecipeResource</code> to serialize the <code>recipe</code> object into JSON format using the recipe schema.</li>
				<li>Run the application so that Flask will start and run on the localhost.</li>
				<li>Test the implementation by getting one specific published recipe in Postman.<h4>Note</h4><p class="callout">The solution for the activity can be found on page 312.</p></li>
			</ol>
			<p>After this activity, you should have a good understanding of how to use schema to serialize objects. We have the flexibility to specify the attributes that need to be serialized, and how they are going to be serialized. Attributes that linked to another object can be serialized as well. As you can see from this activity, the author's information is included in this recipe response.</p>
			<h2 id="_idParaDest-119"><a id="_idTextAnchor267"/>Summary</h2>
			<p>In this chapter, we have learned a lot of things. The data verification of an API through marshmallow is very important. This function should also be constantly updated in the production environment to ensure that the information we receive is correct.</p>
			<p>In this chapter, we started with the verification of registered members and then talked about basic verification methods, such as setting mandatory fields, performing data type validation, and so on. Apart from data validation, marshmallow can be used for data filtering as well. We can use the <code>exclude</code> parameter to display the user email field. Based on what we learned, we then developed customized verifications for our application, such as verifying the length of the recipe creation time.</p>
			<p>At the end of this chapter, we added the functionality to get all the recipes written by our favorite author. Then, we searched for different publish statuses through the <code>visibility</code> parameter and applied access control accordingly.</p>
		</div>
	</body></html>