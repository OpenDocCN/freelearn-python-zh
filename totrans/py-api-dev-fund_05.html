<html><head></head><body>
		<div>
			<div id="_idContainer086" class="Content">
			</div>
		</div>
		<div id="_idContainer087" class="Content">
			<h1 id="_idParaDest-99"><a id="_idTextAnchor197"/>5. Object Serialization with marshmallow</h1>
		</div>
		<div id="_idContainer088" class="Content">
			<h2>Learning Objectives</h2>
			<p>By the end of this chapter, you will be able to:</p>
			<ul>
				<li class="bullets">Create a schema for serialization/deserialization</li>
				<li class="bullets">Validate the data in a client request</li>
				<li class="bullets">Perform data filtering before displaying the data to the client</li>
				<li class="bullets">Use the HTTP PATCH method to partially update data</li>
			</ul>
			<p>This chapter covers serialization and deserialization, as well as data filtering and validation with marshmallow.</p>
		</div>
		<div id="_idContainer106" class="Content">
			<h2 id="_idParaDest-100"><a id="_idTextAnchor198"/>Introduction</h2>
			<p>In this era of information explosion, the correctness of data is crucially important. We need to ensure that the data passed in by the client is in the format we expect. For example, we expect the <strong class="inline">cooking time</strong> variable to be a data type integer with a value of 30, but the client could pass in a string data type, with <strong class="inline">value = "thirty minutes"</strong>. They mean the same thing, and both are understandable to human beings but the system won't be able to interpret them. In this chapter, we will learn about data validation, making sure the system only takes valid data. The marshmallow package not only helps us to verify the client's data but also to verify the data that we send back. This ensures data integrity in both directions, which will greatly improve the quality of the system. </p>
			<p>In this chapter, we will focus on doing three essential things: first, we will modify the <strong class="inline">User</strong> class and add in the API verification. This is mainly to show the basic functions of marshmallow. We'll then modify the <strong class="inline">Recipe</strong> class, add a custom authentication method, and optimize the code. Finally, a new feature will be added, which allows us to query all the recipes of a specific user and filter the recipes with different publish statuses by the visibility parameter. With this in mind, let's move on to the first topic: <strong class="bold">Serialization</strong> versus <strong class="bold">Deserialization</strong>.</p>
			<h2 id="_idParaDest-101"><a id="_idTextAnchor199"/>Serialization versus Deserialization</h2>
			<div>
				<div id="_idContainer089" class="IMG---Figure">
					<img src="image/C15309_05_01.jpg" alt="Figure 5.1: Serialization versus deserialization&#13;&#10;"/>
				</div>
			</div>
			<h6>Figure 5.1: Serialization versus deserialization</h6>
			<p>An object is something that lives in the application memory. We can invoke its method or access its attributes in our application. However, when we want to transfer or store an object, we will have to convert it into a storable or transferrable format, and that format will be a stream of bytes. It can then be stored in a text file, in a database, or be transmitted over the internet. The process of converting an object to a stream of bytes is called serialization. This stream of bytes persists the state of the object so that it can be recreated later. The recreation of the object from a stream of bytes is called deserialization. </p>
			<p>Serialization/deserialization is an essential part of RESTful API development. During actual development, the data validation related to business logic will often be included in the serialization and deserialization implementation processes as well.</p>
			<h2 id="_idParaDest-102">m<a id="_idTextAnchor200"/>arshmallow</h2>
			<p><strong class="keyword">marshmallow</strong> itself is an excellent package for serialization and deserialization in Python, as well as providing validation features. It allows developers to define schemas, which can be used to represent a field in various ways (required and validation), and automatically perform validation during deserialization. We will start by implementing a data validation function in this chapter. We will implement it using the marshmallow package to ensure that the information the user entered is correct. We will work with you through various exercises and activities to test serialization and deserialization afterward with Postman.</p>
			<h2 id="_idParaDest-103"><a id="_idTextAnchor201"/>A Simple Schema</h2>
			<p>We will be using the <strong class="inline">Schema</strong> class from marshmallow to specify the fields for the objects that we want to serialize/deserialize. Without knowing the schema of the objects and how we want to serialize the fields, we can't perform serialization or deserialization. In the following example, you can see we have a simple <strong class="inline">SimpleSchema</strong> class, which extends <strong class="inline">marshmallow.Schema</strong>, and there are two fields defined there, <strong class="inline">id</strong> and <strong class="inline">username</strong>:</p>
			<p class="snippet">from marshmallow import Schema, fields</p>
			<p class="snippet">class SimpleSchema(Schema):</p>
			<p class="snippet">    id = fields.Int() </p>
			<p class="snippet">    username = fields.String()</p>
			<p>The data type of the fields are defined using the <strong class="inline">marshmallow</strong> fields. From the preceding example, the <strong class="inline">id</strong> field is an <strong class="bold">integer</strong>, while the <strong class="inline">username</strong> field is a <strong class="bold">string</strong>. There are a number of different data types in marshmallow, including <strong class="bold">Str</strong>, <strong class="bold">Int</strong>, <strong class="bold">Bool</strong>, <strong class="bold">Float</strong>, <strong class="bold">DateTime</strong>, <strong class="bold">Email</strong>, <strong class="bold">Nested</strong>, and so on.</p>
			<p>With the schema specified, we can start doing object serialization and deserialization. We can serialize objects in our application and return them in the HTTP response. Or, the other way round, we can take in a request from users and deserialize that into an object so that it can be used in our application.</p>
			<h3 id="_idParaDest-104"><a id="_idTextAnchor202"/>Field Validation</h3>
			<p>We can also add field-level validation during serialization/deserialization. Again, this can be done in the schema definition. For example, if we want to specify a field as mandatory, we can add in the <strong class="inline">required=True</strong> argument. Using the same <strong class="inline">SimpleSchema</strong> example, we can specify the <strong class="inline">username</strong> field as mandatory as follows:</p>
			<p class="snippet">class SimpleSchema(Schema):</p>
			<p class="snippet">    id = fields.Int() </p>
			<p class="snippet">    username = fields.String(required=True)</p>
			<p>If this <strong class="inline">SimpleSchema</strong> is used to deserialize the JSON request from the user and the <strong class="inline">username</strong> field is not filled in there, there will be an error message, <strong class="inline">Validation errors</strong>, and the HTTP status code will be <strong class="bold">400 Bad Request</strong>:</p>
			<p class="snippet">{</p>
			<p class="snippet">    "message": "Validation errors",</p>
			<p class="snippet">    "errors": {</p>
			<p class="snippet">        "username": [</p>
			<p class="snippet">            "Missing data for the required field."</p>
			<p class="snippet">        ]</p>
			<p class="snippet">    }</p>
			<p class="snippet">}</p>
			<p>Now we will learn how to customize deserialization methods.</p>
			<h3 id="_idParaDest-105"><a id="_idTextAnchor203"/>Customizing Deserialization Methods</h3>
			<p>We can also customize the way we want to deserialize certain fields. We can do so by using <strong class="inline">Method</strong> fields in marshmallow. A <strong class="inline">Method</strong> field receives an optional <strong class="inline">deserialize</strong> argument, which defines how the field should be deserialized.</p>
			<p>From the following <strong class="inline">SimpleSchema</strong> example, we can define a custom method to deserialize the <strong class="inline">password</strong> field. We just need to pass in the <strong class="inline">deserialize='load_password'</strong> argument. It will invoke the <strong class="inline">load_password</strong> method to deserialize the <strong class="inline">password</strong> field:</p>
			<p class="snippet">class SimpleSchema(Schema):</p>
			<p class="snippet">    id = fields.Int() </p>
			<p class="snippet">    username = fields.String(required=True)</p>
			<p class="snippet">    password = fields.Method(required=True, deserialize='load_password')</p>
			<p class="snippet">    def load_password(self, value): </p>
			<p class="snippet">        return hash_password(value)</p>
			<p>In the next section, we will learn how to use the <strong class="inline">UserSchema</strong> design.</p>
			<h2 id="_idParaDest-106"><a id="_idTextAnchor204"/>UserSchema Design</h2>
			<p>Now we have learned why we need to use <strong class="inline">Schema</strong> and how we can define a schema, we will start to work on that in our <strong class="inline">Smilecook</strong> application. In the case of user registration, we will expect the user to fill in their information on a web form, and then send the details in JSON format to the server. Our <strong class="inline">Smilecook</strong> application will then deserialize it to be a <strong class="inline">User</strong> object, which can be worked on in our application. </p>
			<p>We will, therefore, need to define a <strong class="inline">UserSchema</strong> class to specify the expected attributes in the JSON request coming from the frontend. We will need the following fields: </p>
			<ul>
				<li><strong class="inline">id</strong>: Use <strong class="inline">fields.Int()</strong> to represent an integer. In addition, <strong class="inline">dump_only=True</strong> means that this property is only available for serialization, not deserialization. This is because <strong class="inline">id</strong> is autogenerated, not passed in by the user. </li>
				<li><strong class="inline">username</strong>: Use <strong class="inline">fields.String()</strong> to represent a string and apply <strong class="inline">required=True</strong> to indicate that this property is mandatory. When the client sends JSON data without the username, there will be a validation error.</li>
				<li><strong class="inline">email</strong>: Use <strong class="inline">fields.Email()</strong> to indicate that <strong class="inline">email</strong> format is needed, and apply <strong class="inline">required=True</strong> to indicate that this property is mandatory. </li>
				<li><strong class="inline">password:fields.Method()</strong> is a <strong class="inline">Method</strong> field. The <strong class="inline">Method</strong> field here receives an optional <strong class="inline">deserialize</strong> argument, which defines how the field should be deserialized. We use <strong class="inline">deserialize='load_password'</strong> to indicate that the <strong class="inline">load_password(self, value)</strong> method will be invoked when using <strong class="inline">load()</strong> deserialization. Please note that this <strong class="inline">load_password(self, value)</strong> method will only be invoked during <strong class="inline">load()</strong> deserialization. </li>
				<li><strong class="inline">created_at:fields.DateTime()</strong> represents the time format, and <strong class="inline">dump_only=True</strong> means that this property will only be available in serialization.</li>
				<li><strong class="inline">updated_at:fields.DateTime()</strong> represents the time format, and <strong class="inline">dump_only=True</strong> means that this property will only be available in serialization.</li>
			</ul>
			<p>In our next exercise, we will install the marshmallow package in our <strong class="inline">Smilecook</strong> project. Then, we will define the <strong class="inline">UserSchema</strong> and use it in <strong class="inline">UserListResource</strong> and <strong class="inline">UserResource</strong>.</p>
			<h3 id="_idParaDest-107">E<a id="_idTextAnchor205"/>xercise 33: Using marshmallow to Validate the User Data</h3>
			<p>Firstly, we will perform data verification using marshmallow. We will install the <strong class="inline">marshmallow</strong> package and build <strong class="inline">UserSchema</strong>, and then use it in <strong class="inline">UserListResource</strong> to transmit the <strong class="inline">User</strong> object: </p>
			<ol>
				<li>W<a id="_idTextAnchor206"/>e will first install the marshmallow package. Please enter the following in <strong class="inline">requirements.txt</strong>:<p class="snippet">marshmallow==2.19.5</p></li>
				<li><a id="_idTextAnchor207"/>R<a id="_idTextAnchor208"/>un the <strong class="inline">pip install</strong> command:<p class="snippet">pip install -r requirements.txt</p><p>You should see the result that follows:</p><p class="snippet">Installing collected packages: marshmallow</p><p class="snippet">Successfully installed marshmallow-2.19.5</p></li>
				<li><a id="_idTextAnchor209"/>Create a folder under the <strong class="inline">Smilecook</strong> project and name it <strong class="inline">schemas</strong>. We will store all our schema files here.</li>
				<li>C<a id="_idTextAnchor210"/>reate a <strong class="inline">user.py</strong> file under that and enter the following code. Use a schema to define the basic structure of the content of our expected client request. The following code creates <strong class="inline">UserSchema</strong> to define the attributes we will receive in the client request:<p class="snippet">from marshmallow import Schema, fields</p><p class="snippet">from utils import hash_password</p><p class="snippet">class UserSchema(Schema):</p><p class="snippet">    class Meta:</p><p class="snippet">        ordered = True</p><p class="snippet">    id = fields.Int(dump_only=True)</p><p class="snippet">    username = fields.String(required=True)</p><p class="snippet">    email = fields.Email(required=True)</p><p class="snippet">    password = fields.Method(required=True, deserialize='load_password')</p><p class="snippet">    created_at = fields.DateTime(dump_only=True)</p><p class="snippet">    updated_at = fields.DateTime(dump_only=True)</p><p class="snippet">    def load_password(self, value):</p><p class="snippet">        return hash_password(value)</p><p>Before defining <strong class="inline">UserSchema</strong>, we need to first import <strong class="inline">Schema</strong> and <strong class="inline">fields</strong> from marshmallow. All self-defined marshmallow schemas must inherit <strong class="inline">marshmallow.Schema</strong>. Then, we import <strong class="inline">hash_password</strong>, and we define four attributes: <strong class="inline">id</strong>, <strong class="inline">username</strong>, <strong class="inline">email</strong>, and <strong class="inline">password</strong> in <strong class="inline">UserSchema</strong>.</p></li>
				<li><a id="_idTextAnchor211"/>Add the following code in <strong class="inline">resources/user.py</strong>. We will first import the <strong class="inline">UserSchema</strong> class from the previous step and instantiate two <strong class="inline">UserSchema</strong> objects here. One of them is for use in public, and we can see that the email is excluded: <p class="snippet">from schemas.user import UserSchema</p><p class="snippet">user_schema = UserSchema()</p><p class="snippet">user_public_schema = UserSchema(exclude=('email', ))</p><p>For our <strong class="inline">user</strong> resource, when the authenticated user accesses its <strong class="inline">users/&lt;username&gt;</strong> endpoint, they can get <strong class="inline">id</strong>, <strong class="inline">username</strong>, and <strong class="inline">email</strong>. But if they are not authenticated or are accessing other people's <strong class="inline">/users/&lt;username&gt;</strong> endpoint, the email address will be hidden. </p></li>
				<li>W<a id="_idTextAnchor212"/>e will then modify <strong class="inline">UserListResource</strong> to the following to validate the data in the user's request:<p class="snippet">class UserListResource(Resource):</p><p class="snippet">    def post(self):</p><p class="snippet">        json_data = request.get_json()</p><p class="snippet">        data, errors = user_schema.load(data=json_data)</p><p class="snippet">        if errors:</p><p class="snippet">            return {'message': 'Validation errors', 'errors': errors}, HTTPStatus.BAD_REQUEST</p></li>
				<li>In the same <strong class="inline">UserListResource.post</strong>, we will proceed if there is no error. It will then check whether <strong class="inline">username</strong> and <strong class="inline">email</strong> exist, and if everything is fine, we will use <strong class="inline">User(**data)</strong> to create a user instance, the <strong class="inline">**data</strong> will give us keyword arguments for the <strong class="inline">User</strong> class, then we use <strong class="inline">user.save()</strong> to store things in the database:<p class="snippet">        if User.get_by_username(data.get('username')):</p><p class="snippet">            return {'message': 'username already used'}, HTTPStatus.BAD_REQUEST</p><p class="snippet">        if User.get_by_email(data.get('email')):</p><p class="snippet">            return {'message': 'email already used'}, HTTPStatus.BAD_REQUEST</p><p class="snippet">        user = User(**data)</p><p class="snippet">        user.save()</p></li>
				<li>Finally, also in <strong class="inline">UsersLitResource.post</strong>, we use <strong class="inline">user_schema.dump(user).data</strong> to return the successfully registered user data. It will contain <strong class="inline">id</strong>, <strong class="inline">username</strong>, <strong class="inline">created_at</strong>, <strong class="inline">updated_at</strong>, and <strong class="inline">email</strong>:<p class="snippet">        return user_schema.dump(user).data, HTTPStatus.CREATED</p></li>
				<li><a id="_idTextAnchor213"/>N<a id="_idTextAnchor214"/>ext, we will modify <strong class="inline">UserResource</strong>. We will see the difference between with and without filtering email using <strong class="inline">user_schema</strong> and <strong class="inline">user_public_schema</strong> here:<p class="snippet">class UserResource(Resource):</p><p class="snippet">    @jwt_optional</p><p class="snippet">    def get(self, username):</p><p class="snippet">        user = User.get_by_username(username=username)</p><p class="snippet">        if user is None:</p><p class="snippet">            return {'message': 'user not found'}, HTTPStatus.NOT_FOUND</p><p class="snippet">        current_user = get_jwt_identity()</p><p class="snippet">        if current_user == user.id:</p><p class="snippet">            data = user_schema.dump(user).data</p><p class="snippet">        else:</p><p class="snippet">            data = user_public_schema.dump(user).data</p><p class="snippet">        return data, HTTPStatus.OK</p><p>When a user sends a request to <strong class="inline">/users/&lt;username/</strong>, we will get their username. If a user can't be found, we will get <strong class="bold">404 Not Found</strong> error. If the user is found, we will check whether this user is the one currently logged in. If so, the user information will be serialized using <strong class="inline">user_schema.dump(user).data</strong>, which contains all the information. Otherwise, <strong class="inline">user_public_schema.dump(user).data</strong> will be used, which excludes the email information. Finally, it returns data with the HTTP status code <strong class="bold">200 OK</strong>.</p></li>
				<li>Next, we will modify <strong class="inline">MeResource</strong>. It will be serialized using <strong class="inline">user_schema.dump(user).data</strong>, which contains all the information of the user:<p class="snippet">class MeResource(Resource):</p><p class="snippet">    @ jwt_required</p><p class="snippet">    def get(self): </p><p class="snippet">         user = User.get_by_id(id=get_jwt_identity())</p><p class="snippet">         return user_schema.dump(user).data, HTTPStatus.OK</p></li>
				<li><a id="_idTextAnchor215"/>Save <strong class="inline">app.py</strong> and right-click on it to run the application. Flask will then be started up and run on the localhost (<strong class="inline">127.0.0.1</strong>) at port <strong class="inline">5000</strong>:<div id="_idContainer090" class="IMG---Figure"><img src="image/C15309_05_02.jpg" alt="Figure 5.2: Run the application and then run Flask on the localhost&#13;&#10;"/></div></li>
			</ol>
			<h6>Figure 5.2: Run the application and then run Flask on the localhost</h6>
			<p>So, we have finished adding marshmallow to the picture. From now onward, when we transfer the <strong class="inline">User</strong> object between the frontend and backend, it will first be serialized/deserialized. In the process, we can leverage the data validation functions provided by marshmallow to make our API endpoints even more secure.</p>
			<h3 id="_idParaDest-108"><a id="_idTextAnchor216"/>Exercise 34: Testing the User Endpoint before and after Authentication</h3>
			<p>We implemented different user schemas in the previous exercise one for private viewing and one for public viewing. In this exercise, we are going to test whether they work as expected. We will check the data in the HTTP response and verify whether we get different user information before and after authentication. We want to hide the user's email address from the public, to protect user privacy.</p>
			<p>We will do the whole test using Postman. Let's get started!</p>
			<ol>
				<li value="1">Check the <strong class="inline">user</strong> details before the user has logged in. We shouldn't see the user's email address in the result. Click on the <strong class="bold">Collections</strong> tab.</li>
				<li>Select the <strong class="bold">GET User</strong> request.</li>
				<li>Enter <strong class="inline">http://localhost:5000/users/james</strong> in the URL field. You can replace the username <strong class="inline">James</strong> with any username that is appropriate.</li>
				<li>Click <strong class="bold">Send</strong> to check the user details for James. The result is shown in the following screenshot:<div id="_idContainer091" class="IMG---Figure"><img src="image/C15309_05_03.jpg" alt="Figure 5.3: Checking the user details for James&#13;&#10;"/></div><h6>Figure 5.3: Checking the user details for James</h6><p>You will then see the return response. We can see that the HTTP status code is <strong class="bold">200 OK</strong>, meaning we successfully get back <strong class="inline">user</strong> details. And in the response body, we can see the user details for James. We can see the <strong class="inline">username</strong>, <strong class="inline">created_at</strong>, <strong class="inline">updated_at</strong>, and <strong class="inline">id</strong>, but not the email address.</p></li>
				<li>Now<a id="_idTextAnchor217"/>, let's login using Postman. Select the <strong class="bold">POST Token</strong> request. Click <strong class="bold">Send</strong> to log in. The result is shown in the following screenshot:</li>
				<li><div id="_idContainer092" class="IMG---Figure"><img src="image/C15309_05_04.jpg" alt="Figure 5.4: Log in and select the POST Token request&#13;&#10;"/></div><h6>Figure 5.4: Log in and select the POST Token request</h6><p>You will then see the response body for the access token and the refresh token.</p></li>
				<li>Chec<a id="_idTextAnchor218"/>k the <strong class="inline">user</strong> details after the user has logged in. You should see the user's email address in the result. Click on the <strong class="bold">Collections</strong> tab. Choose to <strong class="bold">GET User</strong>. Select the <strong class="bold">Headers</strong> tab.</li>
				<li>Enter <strong class="inline">Authorization</strong> in the <strong class="bold">KEY</strong> field and <strong class="inline">Bearer {token}</strong> in the <strong class="bold">VALUE</strong> field, where the token is the <strong class="inline">JWT</strong> token we got in <em class="italics">step 5</em>.</li>
				<li>Click <strong class="bold">Send</strong> to check the user details for James. The result is shown in the following screenshot:<div id="_idContainer093" class="IMG---Figure"><img src="image/C15309_05_05.jpg" alt="Figure 5.5: Checking the details after the user has logged in&#13;&#10;"/></div></li>
			</ol>
			<h6>Figure 5.5: Checking the details after the user has logged in</h6>
			<p>You will then see the return response. In the response body, we can see the user details for James. We can see all his information, including his email address.</p>
			<p>So, by using the <strong class="inline">exclude</strong> parameter in the user schema, we can easily exclude certain sensitive fields from showing up in the HTTP response. Apart from the <strong class="inline">exclude</strong> parameter, marshmallow also has the <strong class="inline">include</strong> parameter, which you can explore more yourself if you are interested.</p>
			<h2 id="_idParaDest-109">Reci<a id="_idTextAnchor219"/>peSchema Design</h2>
			<p>So, we have done the serialization/deserialization for the <strong class="inline">User</strong> object. Now we are going to design the schema for the <strong class="inline">Recipe</strong> object. In the case of the <strong class="inline">Recipe</strong> update, we will expect the user to fill in updated recipe details on a web form, and then send the details in JSON format to the server. Our <strong class="inline">Smilecook</strong> application will then deserialize it to be a <strong class="inline">Recipe</strong> object, which can be worked on in our application.</p>
			<p><strong class="inline">RecipeSchema</strong> should inherit <strong class="inline">marshmallow.Schema</strong> and contains the following attributes:</p>
			<ul>
				<li><strong class="inline">id</strong>: Use <strong class="inline">fields.Int()</strong> to represent an integer, and apply <strong class="inline">dump_only=True</strong> to specify that this property is only available for serialization.</li>
				<li><strong class="inline">name</strong>: Use <strong class="inline">fields.String()</strong> to represent a string and apply <strong class="inline">required=True</strong> to indicate that this attribute is required. </li>
				<li><strong class="inline">description</strong>: Use <strong class="inline">fields.String()</strong> to represent a string.</li>
				<li><strong class="inline">num_of_servings</strong>: Use <strong class="inline">fields.Int()</strong> to represent an integer.</li>
				<li><strong class="inline">cook_time</strong>: Use <strong class="inline">fields.Int()</strong> to represent an integer.</li>
				<li><strong class="inline">directions</strong>: Use <strong class="inline">fields.String()</strong> to represent a string.</li>
				<li><strong class="inline">is_publish</strong>: Use <strong class="inline">fields.Boolean()</strong> to represent a Boolean, and apply <strong class="inline">dump_only=True</strong> to specify that this attribute is only available for serialization.</li>
				<li><strong class="inline">author</strong>: This attribute is used to display the author of the recipe. </li>
				<li><strong class="inline">created_at</strong>: Use <strong class="inline">fields.DateTime</strong> to represent the format of the time, and <strong class="inline">dump_only=True</strong> means that this attribute is only available for serialization.</li>
				<li><strong class="inline">updated_at</strong>: Use <strong class="inline">fields.DateTime</strong> to represent the format of the time, and <strong class="inline">dump_only=True</strong> means that this attribute is only available for serialization.</li>
			</ul>
			<h3 id="_idParaDest-110">Exerc<a id="_idTextAnchor220"/>ise 35: Implementing RecipeSchema</h3>
			<p>Now we have the <strong class="inline">RecipeSchema</strong> design in mind. In this exercise, we will learn more about marshmallow by implementing <strong class="inline">RecipeSchema</strong>. Not only can we just validate the data type of <strong class="inline">fields</strong>, but we can also build our own validation function. Let's get started:</p>
			<ol>
				<li value="1">Firs<a id="_idTextAnchor221"/>t<a id="_idTextAnchor222"/>, we import <strong class="inline">schema</strong>, <strong class="inline">fields</strong>, <strong class="inline">post_dump</strong>, <strong class="inline">validate</strong>, <strong class="inline">validates</strong>, and <strong class="inline">ValidationError</strong> and create the <strong class="inline">recipe schema</strong> by entering the following code in <strong class="inline">schemas/recipe.py</strong>:<p class="snippet">from marshmallow import Schema, fields, post_dump, validate, validates, ValidationError</p><p class="snippet">class RecipeSchema(Schema):</p><p class="snippet">    class Meta:</p><p class="snippet">        ordered = True</p><p class="snippet">    id = fields.Integer(dump_only=True)</p><p class="snippet">    name = fields.String(required=True, validate=[validate.Length(max=100)])</p><p class="snippet">    description = fields.String(validate=[validate.Length(max=200)])</p><p class="snippet">    directions = fields.String(validate=[validate.Length(max=1000)])</p><p class="snippet">    is_publish = fields.Boolean(dump_only=True)</p><p class="snippet">    created_at = fields.DateTime(dump_only=True)</p><p class="snippet">    updated_at = fields.DateTime(dump_only=True)</p><p>We can perform additional validation for a field by passing in the <strong class="inline">validate</strong> argument. We use <strong class="inline">validate.Length(max=100)</strong> to limit the maximum length of this attribute to <strong class="inline">100</strong>. When it exceeds <strong class="inline">100</strong>, it will trigger a validation error. This can prevent users from passing in an extremely long string, which will create a burden on our database. Using the <strong class="inline">validation</strong> function from marshmallow, that can be easily prevented. </p></li>
				<li>Then, we define the <strong class="inline">validate_num_of_servings(n)</strong> method in <strong class="inline">RecipeSchema</strong>, which is a customized validation function. This will validate that this attribute has a minimum of <strong class="inline">1</strong> and cannot be greater than <strong class="inline">50</strong>. If its value doesn't fall within this range, it will raise an error message:<p class="snippet">def validate_num_of_servings(n):</p><p class="snippet">    if n &lt; 1:</p><p class="snippet">        raise ValidationError('Number of servings must be greater than 0.')</p><p class="snippet">    if n &gt; 50:</p><p class="snippet">        raise ValidationError('Number of servings must not be greater than 50.')</p></li>
				<li>Next, add the <strong class="inline">num_of_servings</strong> attribute in <strong class="inline">RecipeSchema</strong>. Use <strong class="inline">validate=validate_num_of_servings</strong> to link to our custom function, which will verify the number of servings of this recipe:<p class="snippet">num_of_servings = fields.Integer(validate=validate_num_of_servings)</p></li>
				<li>There is another way for us to add a customized validation method. We can add the <strong class="inline">cooktime</strong> attribute in <strong class="inline">RecipeSchema</strong>:<p class="snippet">cook_time = fields.Integer()</p></li>
				<li>Then, in <strong class="inline">RecipeSchema</strong>, use the <strong class="inline">@validates('cook_time')</strong> decorator to define the validation method. When validating the <strong class="inline">cook_time</strong> property, it will call the <strong class="inline">validate_cook_time</strong> method to specify that the cooking time should be between 1 minute and 300 minutes:<p class="snippet">    @validates('cook_time')</p><p class="snippet">    def validate_cook_time(self, value):</p><p class="snippet">        if value &lt; 1:</p><p class="snippet">            raise ValidationError('Cook time must be greater than 0.')</p><p class="snippet">        if value &gt; 300:</p><p class="snippet">            raise ValidationError('Cook time must not be greater than 300.')</p></li>
				<li>On top of the <strong class="inline">schemas/recipe.py</strong> file, import <strong class="inline">UserSchema</strong> from marshmallow, because we will display the author information for the recipe together when displaying the recipe information:<p class="snippet">from schemas.user import UserSchema</p></li>
				<li>Then, in <strong class="inline">RecipeSchema</strong>, define the attribute <strong class="inline">author</strong>. We use <strong class="inline">fields.Nested</strong> to link this attribute to an external object, which is <strong class="inline">UserSchema</strong> in this case:<p class="snippet">author = fields.Nested(UserSchema, attribute='user', dump_only=True, only=['id', 'username'])</p><p>To avoid any confusion, this attribute is named <strong class="inline">author</strong> in the JSON response, but the original attribute name is the <strong class="inline">user</strong>. In addition, <strong class="inline">dump_only=True</strong> means that this attribute is only available for serialization. Finally, add <strong class="inline">only=['id', ' username']</strong> to specify that we will only show the user's ID and username.</p></li>
				<li>In addition, we add the <strong class="inline">@post_dump(pass_many=True)</strong> decorator so that further processing can be done when the recipe is serialized. The code is as follows:<p class="snippet">    @post_dump(pass_many=True)</p><p class="snippet">    def wrap(self, data, many, **kwargs):</p><p class="snippet">        if many:</p><p class="snippet">            return {'data': data}</p><p class="snippet">        return data</p><p>In the case of returning only one recipe, it will be simply returned in a JSON string. But when we are returning multiple recipes, we will store the recipes in a list and return them using the <strong class="inline">{'data': data}</strong> format in JSON. This format will be beneficial for us when we develop the pagination feature.</p></li>
				<li>The code in <strong class="inline">schemas/recipe.py</strong> should now look like the following – please review it:<p class="snippet">from marshmallow import Schema, fields, post_dump, validate, validates, ValidationError</p><p class="snippet">from schemas.user import UserSchema</p><p class="snippet">def validate_num_of_servings(n):</p><p class="snippet">    if n &lt; 1:</p><p class="snippet">        raise ValidationError('Number of servings must be greater than 0.')</p><p class="snippet">    if n &gt; 50:</p><p class="snippet">        raise ValidationError('Number of servings must not be greater than 50.')</p><p class="snippet">class RecipeSchema(Schema):</p><p class="snippet">    class Meta:</p><p class="snippet">        ordered = True</p><p class="snippet">    id = fields.Integer(dump_only=True)</p><p class="snippet">    name = fields.String(required=True, validate=[validate.Length(max=100)])</p><p class="snippet">    description = fields.String(validate=[validate.Length(max=200)])</p><p class="snippet">    num_of_servings = fields.Integer(validate=validate_num_of_servings)</p><p class="snippet">    cook_time = fields.Integer()</p><p class="snippet">    directions = fields.String(validate=[validate.Length(max=1000)])</p><p class="snippet">    is_publish = fields.Boolean(dump_only=True)</p><p class="snippet">    author = fields.Nested(UserSchema, attribute='user', dump_only=True, only=['id', 'username'])</p><p class="snippet">    created_at = fields.DateTime(dump_only=True)</p><p class="snippet">    updated_at = fields.DateTime(dump_only=True)</p><p class="snippet">    @post_dump(pass_many=True)</p><p class="snippet">    def wrap(self, data, many, **kwargs):</p><p class="snippet">        if many:</p><p class="snippet">            return {'data': data}</p><p class="snippet">        return data</p><p class="snippet">    @validates('cook_time')</p><p class="snippet">    def validate_cook_time(self, value):</p><p class="snippet">        if value &lt; 1:</p><p class="snippet">            raise ValidationError('Cook time must be greater than 0.')</p><p class="snippet">        if value &gt; 300:</p><p class="snippet">            raise ValidationError('Cook time must not be greater than 300.'</p><p>Once we have completed the recipe schema, we can start to use it in the related resources.</p></li>
				<li>We wi<a id="_idTextAnchor223"/>ll then modify <strong class="inline">resources/recipe.py</strong> as follows:<p class="snippet">from schemas.recipe import RecipeSchema</p><p class="snippet">recipe_schema = RecipeSchema()</p><p class="snippet">recipe_list_schema = RecipeSchema(many=True)</p><p>We first import <strong class="inline">RecipeSchema</strong> from <strong class="inline">schemas.recipe</strong>,then define the <strong class="inline">recipe_schema</strong> variable and <strong class="inline">recipe_list_schema</strong>; they are for storing single and multiple recipes.</p></li>
				<li>Modif<a id="_idTextAnchor224"/>y the <strong class="inline">RecipeListResource</strong> <strong class="inline">get</strong> method to return all the published recipes back to the client by using the <strong class="inline">recipe_list_schema.dump(recipes).data</strong> method:<p class="snippet">class RecipeListResource(Resource):</p><p class="snippet">    def get(self):</p><p class="snippet">        recipes = Recipe.get_all_published()</p><p class="snippet">        return recipe_list_schema.dump(recipes).data, HTTPStatus.OK</p></li>
				<li>Modif<a id="_idTextAnchor225"/>y the <strong class="inline">RecipeListResource</strong> <strong class="inline">post</strong> method to use the recipe schema:<p class="snippet">    @jwt_required</p><p class="snippet">    def post(self):</p><p class="snippet">        json_data = request.get_json()</p><p class="snippet">        current_user = get_jwt_identity()</p><p class="snippet">        data, errors = recipe_schema.load(data=json_data)</p><p class="snippet">        if errors:</p><p class="snippet">            return {'message': "Validation errors", 'errors': errors}, HTTPStatus.BAD_REQUEST</p><p class="snippet">        recipe = Recipe(**data)</p><p class="snippet">        recipe.user_id = current_user</p><p class="snippet">        recipe.save()</p><p class="snippet">        return recipe_schema.dump(recipe).data, HTTPStatus.CREATED</p><p>After receiving the JSON data, the data is verified by <strong class="inline">recipe_schema.load(data=json_data)</strong>. If there is an error, it will return <strong class="bold">HTTP status code 400 Bad Request</strong> with an error message. </p><p>If the validation is passed, <strong class="inline">Recipe(**data)</strong> will be used to create a <strong class="inline">recipe</strong> object, then specify it as the currently logged-in user's ID via <strong class="inline">recipe.user_id = current_user</strong>. The recipe will then be saved to the repository via <strong class="inline">recipe.save()</strong>, and finally, converted to JSON using <strong class="inline">recipe_schema.dump(recipe).data</strong> to the client, with a HTTP status code <strong class="bold">201 CREATED</strong> message.</p></li>
				<li>Beca<a id="_idTextAnchor226"/><a id="_idTextAnchor227"/><a id="_idTextAnchor228"/>u<a id="_idTextAnchor229"/><a id="_idTextAnchor230"/><a id="_idTextAnchor231"/>se the rendering of our data has been done through marshmallow, we don't need the <strong class="inline">data</strong> method in the recipe, so we can delete the <strong class="inline">data</strong> method in <strong class="inline">model/recipe.py</strong>. That is, delete the following code from the file:<p class="snippet">    def data(self):</p><p class="snippet">        return {</p><p class="snippet">            'id': self.id,</p><p class="snippet">            'name': self.name,</p><p class="snippet">            'description': self.description,</p><p class="snippet">            'num_of_servings': self.num_of_servings,</p><p class="snippet">            'cook_time': self.cook_time,</p><p class="snippet">            'directions': self.directions,</p><p class="snippet">            'user_id': self.user_id</p><p class="snippet">        }</p></li>
				<li>Now w<a id="_idTextAnchor232"/>e have finished the implementation. Right-click on it to run the application. Flask will then be started up and run on the localhost (<strong class="inline">127.0.0.1</strong>) at port <strong class="inline">5000</strong>:<div id="_idContainer094" class="IMG---Figure"><img src="image/C15309_05_06.jpg" alt="Figure 5.6: Run the application and then Flask on the localhost&#13;&#10;"/></div></li>
			</ol>
			<h6>Figure 5.6: Run the application and then Flask on the localhost</h6>
			<p>So, we have just completed the work on <strong class="inline">RecipeSchema</strong>, as well as modifying the API endpoints to transmit the object using the serialization/deserialization approach. In the next exercise, we will test whether our implementation works.</p>
			<h3 id="_idParaDest-111">Exerci<a id="_idTextAnchor233"/>se 36: Testing the Recipe API</h3>
			<p>To tes<a id="_idTextAnchor234"/>t whether the serialization/deserialization of the object works, we will again need to test it in Postman. This exercise is to test creating and getting all our recipe details using Postman.</p>
			<ol>
				<li value="1">First,<a id="_idTextAnchor235"/> log in to the account. Our previous token was only valid for 15 minutes. If it expires, we need to log in again via <strong class="inline">/token</strong> or reacquire the token using the <strong class="bold">Refresh</strong> Token. Click on the <strong class="bold">Collections</strong> tab.</li>
				<li>Select the <strong class="bold">POST</strong> <strong class="bold">Token</strong> request.</li>
				<li>Click <strong class="bold">Send</strong> to log in. The result is shown in the following screenshot:<div id="_idContainer095" class="IMG---Figure"><img src="image/C15309_05_07.jpg" alt="Figure 5.7: Log in to the account and select the POST Token request&#13;&#10;"/></div><h6>Figure 5.7: Log in to the account and select the POST Token request</h6><p>You will then see the return response, <strong class="bold">HTTP Status is 200 OK</strong>, meaning the login was successful, and we will see the access token in the response body. This access token will be used in later steps. </p></li>
				<li>Next, w<a id="_idTextAnchor236"/>e will create a new recipe. Click on the <strong class="bold">Collections</strong> tab. Choose <strong class="bold">POST RecipeList</strong>. </li>
				<li>Select the <strong class="bold">Headers</strong> tab. Enter <strong class="inline">Authorization</strong> in the <strong class="bold">KEY</strong> field and <strong class="inline">Bearer {token}</strong> in the <strong class="bold">VALUE</strong> field, where the token is the <strong class="inline">JWT</strong> token we got in our previous step.</li>
				<li>Select the <strong class="bold">Body</strong> tab. Fill in the recipe details as follows:<p class="snippet">{</p><p class="snippet">    "name": "Blueberry Smoothie",</p><p class="snippet">    "description": "This is a lovely Blueberry Smoothie",</p><p class="snippet">    "num_of_servings": 2,</p><p class="snippet">    "cook_time": 10,</p><p class="snippet">    "directions": "This is how you make it"</p><p class="snippet">}</p></li>
				<li>Click <strong class="bold">Send</strong> to create a new recipe. The result is shown in the following screenshot:<div id="_idContainer096" class="IMG---Figure"><img src="image/C15309_05_08.jpg" alt="Figure 5.8: Creating a new recipe&#13;&#10;"/></div><h6>Figure 5.8: Creating a new recipe</h6><p>You will then see the return response, <strong class="bold">HTTP Status is 201 CREATED</strong>, meaning the new recipe has been created successfully. In the response body, we can see the recipe details. We can also see the author's details shown in a nested format.</p></li>
				<li>Then, w<a id="_idTextAnchor237"/><a id="_idTextAnchor238"/><a id="_idTextAnchor239"/>e will publish the recipe with <strong class="inline">id = 4</strong>. Click on the <strong class="bold">Collections</strong> tab. Choose the <strong class="bold">PUT RecipePublish</strong> request. Enter <strong class="inline">http://localhost:5000/recipes/4/publish</strong> in <strong class="bold">Enter request URL</strong>.</li>
				<li>Select the <strong class="bold">Headers</strong> tab. Enter <strong class="inline">Authorization</strong> in the <strong class="bold">KEY</strong> field and <strong class="inline">Bearer {token}</strong> in the <strong class="bold">VALUE</strong> field, where the token is the JWT token we got in the previous step. Click <strong class="bold">Send</strong> to publish the recipe with <strong class="inline">id = 4</strong>. The result is shown in the following screenshot:<div id="_idContainer097" class="IMG---Figure"><img src="image/C15309_05_09.jpg" alt="Figure 5.9: Publish the recipe with ID 4&#13;&#10;"/></div><h6>Figure 5.9: Publish the recipe with ID 4</h6><p>You will then see the return response, HTTP Status is <strong class="bold">204 NO CONTENT</strong>, meaning it is published successfully. You will see no content in the body.</p></li>
				<li>Then, w<a id="_idTextAnchor240"/>e will get all the recipes back. Select the <strong class="bold">GET RecipeList</strong> request. Click <strong class="bold">Send</strong> to get all the recipes back. The result is shown in the following screenshot:<div id="_idContainer098" class="IMG---Figure"><img src="image/C15309_05_10.jpg" alt="Figure 5.10: Getting all the recipes back by selecting the GET RecipeList request&#13;&#10;"/></div></li>
			</ol>
			<h6>Figure 5.10: Getting all the recipes back by selecting the GET RecipeList request</h6>
			<p>You will then see the return response, HTTP Status is 200 <strong class="bold">OK</strong>, meaning we have successfully retrieved all the recipe details. In the response body, we can see that there is a list of data, which contains all the published recipes.</p>
			<p>So, we have successfully implemented and tested the serialization (creating the recipe) and deserialization (retrieving the recipe) on the recipe-related API endpoints. We are making good progress here!</p>
			<h2 id="_idParaDest-112"><a id="_idTextAnchor241"/>The PATCH Method</h2>
			<p>We have been using the <strong class="inline">PUT</strong> HTTP method all along for data updates. However, the actual usage of the <strong class="inline">PUT</strong> method is to <strong class="bold">Replace</strong> (<strong class="bold">Create</strong> or <strong class="bold">Update</strong>). For example, <strong class="inline">PUT /items/1</strong> means to replace everything in <strong class="inline">/items/1</strong>. If this item already exists, it will be replaced. Otherwise, it will create a new item. <strong class="inline">PUT</strong> must contain all attribute data for <strong class="inline">items/1</strong>.</p>
			<p>This doesn't seem to work very well in all cases. If you just want to update only one of the attributes of <strong class="inline">items/1</strong>, you need to retransmit all the attributes of <strong class="inline">items/1</strong> to the server, which is not efficient at all. So, there is a new HTTP method: <strong class="keyword">PATCH</strong>. The <strong class="inline">PATCH</strong> method was invented to do a partial update. With this method, we need to pass in only the attributes that need to be modified to the server.</p>
			<h3 id="_idParaDest-113"><a id="_idTextAnchor242"/>Exercise 37: Using the PATCH Method to Update the Recipe</h3>
			<p>In this exercise, we will change the recipe update method from <strong class="inline">PUT</strong> to <strong class="inline">PATCH</strong>. We will also use the serialization/deserialization approach to transmit the recipes. Finally, we will test our changes in Postman, to make sure things work as expected. The aim of this exercise is to reduce the bandwidth and server processing resources when we update the recipe data: </p>
			<ol>
				<li value="1">Create the <strong class="inline">patch</strong> method in <strong class="inline">RecipeListResource</strong>. We will first use <strong class="inline">request.get_json()</strong> to get the JSON recipe details sent by the client, and then use <strong class="inline">recipe_schema.load(data=json_data, partial=('name',))</strong> to validate the data format. We are using <strong class="inline">partial=('name',)</strong> because the original name is a required field in the schema. When the client only wants to update a single attribute, using <strong class="inline">partial</strong> allows us to specify that the <strong class="inline">Name</strong> attribute is optional, so no error will occur even though we are not passing in this attribute:<p class="snippet">   @jwt_required</p><p class="snippet">    def patch(self, recipe_id):</p><p class="snippet">        json_data = request.get_json()</p><p class="snippet">        data, errors = recipe_schema.load(data=json_data, partial=('name',))</p></li>
				<li>Then, in the same <strong class="inline">patch</strong> method, we will check whether there is an error message. If any, it will return the <strong class="bold">HTTP Status Code 400 Bad Request</strong> error message. If the validation passes, then check whether the user has permission to update this recipe. If not, <strong class="bold">HTTP status code Forbidden 403</strong> will be returned:<p class="snippet">        if errors:</p><p class="snippet">            return {'message': 'Validation errors', 'errors': errors}, HTTPStatus.BAD_REQUEST</p><p class="snippet">        recipe = Recipe.get_by_id(recipe_id=recipe_id)</p><p class="snippet">        if recipe is None:</p><p class="snippet">            return {'message': 'Recipe not found'}, HTTPStatus.NOT_FOUND</p><p class="snippet">        current_user = get_jwt_identity()</p><p class="snippet">        if current_user != recipe.user_id:</p><p class="snippet">            return {'message': 'Access is not allowed'}, HTTPStatus.FORBIDDEN</p></li>
				<li>We continue to work on the same <strong class="inline">patch</strong> method. <strong class="inline">recipe.name = data.get('name') or recipe.name</strong> means it will try to get the name of the key value of the data. If this value exists, it will be used. Otherwise, <strong class="inline">recipe.name</strong> will stay the same. This is basically how we do the update:<p class="snippet">        recipe.name = data.get('name') or recipe.name</p><p class="snippet">        recipe.description = data.get('description') or recipe.description</p><p class="snippet">        recipe.num_of_servings = data.get('num_of_servings') or recipe.num_of_servings</p><p class="snippet">        recipe.cook_time = data.get('cook_time') or recipe.cook_time</p><p class="snippet">        recipe.directions = data.get('directions') or recipe.directions</p></li>
				<li>In the same <strong class="inline">patch</strong> method, we use the <strong class="inline">save</strong> method to save everything to the database and return the recipe data in JSON format:<p class="snippet">        recipe.save()</p><p class="snippet">        return recipe_schema.dump(recipe).data, HTTPStatus.OK</p></li>
				<li>Now we have the new <strong class="inline">patch</strong> method ready. Right-click on it to run the application. Flask will then be started up and run on the localhost (<strong class="inline">127.0.0.1</strong>) at port <strong class="inline">5000</strong>: <div id="_idContainer099" class="IMG---Figure"><img src="image/C15309_05_06.jpg" alt="Figure 5.11: Run the application and then run Flask on the localhost&#13;&#10;"/></div><h6>Figure 5.11: Run the application and then run Flask on the localhost</h6><p>Next, we are going to update the recipe with <strong class="inline">id = 4</strong>. We will update only two fields:  <strong class="inline">num_of_servings,</strong> and <strong class="inline">cook_time</strong>.</p></li>
				<li>Click on the <strong class="bold">Collections</strong> tab. Choose the <strong class="bold">PUT Recipe</strong> request. Change the <strong class="bold">HTTP</strong> method from <strong class="bold">PUT</strong> to <strong class="bold">PATCH</strong>.</li>
				<li>Select the <strong class="bold">Headers</strong> tab. Enter <strong class="inline">Authorization</strong> in the <strong class="bold">KEY</strong> field and <strong class="inline">Bearer {token}</strong> in the <strong class="bold">VALUE</strong> field, where the token is the <strong class="inline">JWT</strong> token we got in our previous exercise. </li>
				<li>Select the <strong class="bold">Body</strong> tab. Type the following in the <strong class="bold">Body</strong> field:<p class="snippet">{</p><p class="snippet">    "num_of_servings": 4,</p><p class="snippet">    "cook_time": 20</p><p class="snippet">}</p><p>Click <strong class="bold">Send</strong> to update the recipe. The result is shown in the following screenshot:</p><div id="_idContainer100" class="IMG---Figure"><img src="image/C15309_05_12.jpg" alt="Figure 5.12: Updating the recipe&#13;&#10;"/></div></li>
			</ol>
			<h6>Figure 5.12: Updating the recipe</h6>
			<p>You will then see the return response <strong class="bold">HTTP Status is 200 OK</strong>, meaning the update was successful. In the body is the recipe details, and we can see that only <strong class="inline">num_of_servings</strong> and <strong class="inline">cook_time</strong> is updated. We can also see the <strong class="inline">updated_at</strong> timestamp has been automatically updated as well.</p>
			<h3 id="_idParaDest-114"><a id="_idTextAnchor243"/>Searching for Authors and Unpublished Recipes</h3>
			<p>On the <strong class="inline">Smilecook</strong> platform, there will be many different foodies from around the world (here, we call them authors) to share their recipes. Among these outstanding authors, we will definitely have a favorite author, and we will definitely want to learn all of their recipes. Therefore, we have added a new endpoint (or function), which is to list the recipes of a specific author. This endpoint not only lists all the recipes published by a particular gourmet but can also allow the author to search all of their own published/unpublished recipes.</p>
			<h3 id="_idParaDest-115"><a id="_idTextAnchor244"/>Using the webargs Package to Parse the Request Arguments</h3>
			<p>The request arguments, also known as the query string, are the arguments that we can pass in through the URL. For example, in the URL <strong class="inline">http://localhost/testing?abc=123</strong>, <strong class="inline">abc=123</strong> is the request argument.</p>
			<p><strong class="keyword">webargs</strong> is a package for parsing request arguments. We will create a new endpoint, <strong class="inline">GET http://localhost:5000/user/{username}/recipes</strong>, to get all the published recipes from a particular author. For this endpoint, we will pass in the visibility request argument. The <strong class="inline">visibility</strong> request argument can have a value of <strong class="inline">public</strong>, <strong class="inline">private</strong>, or <strong class="inline">all</strong>. The default value is <strong class="inline">public</strong>. If it is <strong class="inline">private</strong> or <strong class="inline">all</strong>, the user needs to be authenticated first.</p>
			<p>If you want to get only the unpublished recipes, you can add the request argument <strong class="inline">visibility=private</strong>. So, the URL will look like this: <strong class="inline">http://localhost:5000/user/{username}/recipes?visibility=private</strong>. The <strong class="inline">webargs</strong> package provides functions to parse this <strong class="inline">visibility=private</strong> argument in the URL, and then our <strong class="inline">Smilecook</strong> application will know this request is asking for private information in the recipe. Our <strong class="inline">Smilecook</strong> application will then determine whether the authenticated user is the author. If they are, it will return all the unpublished recipes. Otherwise, there is no permission for the user to see the unpublished recipes.</p>
			<h3 id="_idParaDest-116">Exercise 38:<a id="_idTextAnchor245"/><a id="_idTextAnchor246"/><a id="_idTextAnchor247"/> Implementing Access Control on Recipes</h3>
			<p>In this exercise, we are going to implement access control on recipes. So, only authenticated users will be able to see all of their own recipes, including unpublished ones. The user will pass in the <strong class="inline">visibility</strong> mode by using the <strong class="inline">request</strong> argument. We use <strong class="inline">webargs</strong> to parse the visibility mode and return published, unpublished, or all recipes accordingly:</p>
			<ol>
				<li value="1">Create the <a id="_idTextAnchor248"/><strong class="inline">get_all_by_user</strong> method in the <strong class="inline">Recipe</strong> class in <strong class="inline">models/recipe.py</strong>:<p class="snippet">    @classmethod</p><p class="snippet">    def get_all_by_user(cls, user_id, visibility='public'):</p><p class="snippet">        if visibility == 'public':</p><p class="snippet">            return cls.query.filter_by(user_id=user_id, is_publish=True).all()</p><p class="snippet">        elif visibility == 'private':</p><p class="snippet">            return cls.query.filter_by(user_id=user_id, is_publish=False).all()</p><p class="snippet">        else:</p><p class="snippet">            return cls.query.filter_by(user_id=user_id).all()</p><p>This method needs to take in <strong class="inline">user_id</strong> and <strong class="inline">visibility</strong>. If the <strong class="inline">visibility</strong> is not defined, the default will be <strong class="inline">public</strong>. If the <strong class="inline">visibility</strong> is <strong class="inline">public</strong>, it will get all the recipes by <strong class="inline">user_id</strong> and <strong class="inline">is_publish=True</strong>. If the visibility is <strong class="inline">private</strong>, it will search for the recipe with <strong class="inline">is_publish=False</strong>. If the visibility is not <strong class="inline">public</strong> or <strong class="inline">private</strong>, it will get all the recipes of this user. </p></li>
				<li>We will ins<a id="_idTextAnchor249"/>tall the <strong class="inline">webargs</strong> package, which is a package for interpreting and verifying HTTP arguments (for example, <strong class="inline">visibility</strong>). Please add the following package in <strong class="inline">requirements.txt</strong>:<p class="snippet">webargs==5.4.0</p></li>
				<li>Install the<a id="_idTextAnchor250"/> <a id="_idTextAnchor251"/>package using the following command:<p class="snippet">pip install -r requirements.txt</p><p>You should see a result like the following:</p><p class="snippet">Installing collected packages: webargs</p><p class="snippet">Successfully installed webargs-5.4.0</p></li>
				<li>Import the <a id="_idTextAnchor252"/>n<a id="_idTextAnchor253"/>ecessary modules, functions, and classes in <strong class="inline">resources/user.py</strong>:<p class="snippet">from flask import request</p><p class="snippet">from flask_restful import Resource</p><p class="snippet">from flask_jwt_extended import get_jwt_identity, jwt_required, jwt_optional</p><p class="snippet">from http import HTTPStatus</p><p class="snippet">from webargs import fields</p><p class="snippet">from webargs.flaskparser import use_kwargs</p><p class="snippet">from models.recipe import Recipe</p><p class="snippet">from models.user import User</p><p class="snippet">from schemas.recipe import RecipeSchema</p><p class="snippet">from schemas.user import UserSchema</p><p>First, import <strong class="inline">webargs.fields</strong> and <strong class="inline">webargs.flaskparser.use_kwargs</strong>, then we will need to use the recipe data, so we also need to import the recipe model and schema.</p></li>
				<li>Then, we wil<a id="_idTextAnchor254"/>l declare the <strong class="inline">recipe_list_schema</strong> variable. Use <strong class="inline">RecipeSchema</strong> with the <strong class="inline">many=True</strong> parameter. This is to show that we will have multiple recipes:<p class="snippet">recipe_list_schema = RecipeSchema(many=True)</p></li>
				<li>We will the<a id="_idTextAnchor255"/>n<a id="_idTextAnchor256"/> create the <strong class="inline">UserRecipeListResource</strong> class. This resource is mainly for getting the recipes under a specific user. Please refer to the following code:<p class="snippet">class UserRecipeListResource(Resource):</p><p class="snippet">    @jwt_optional</p><p class="snippet">    @use_kwargs('visibility': fields.Str(missing='public')})</p><p class="snippet">    def get(self, username, visibility):</p><p>First, define <strong class="inline">@jwt_optional</strong> to mean that this endpoint can be accessed without a user being logged in. Then, use <strong class="inline">@use_kwargs({'visibility': fields.Str(missing='public')})</strong> to specify that we expect to receive the parameters of <strong class="inline">visibility</strong> here. If the parameter is absent, the default will be public. The <strong class="inline">visibility</strong> parameter will then be passed into <strong class="inline">def get(self, username, visibility)</strong>. </p></li>
				<li>We will implement access control in <strong class="inline">UserRecipeListResource.get</strong>. If the username (the author of the recipe) is the currently authenticated user, then they can see all the recipes, including the private ones. Otherwise, they can only see the published recipes: <p class="snippet">def get(self, username, visibility):</p><p class="snippet">        user = User.get_by_username(username=username)</p><p class="snippet">        if user is None:</p><p class="snippet">            return {'message': 'User not found'}, HTTPStatus.NOT_FOUND</p><p class="snippet">        current_user = get_jwt_identity()</p><p class="snippet">        if current_user == user.id and visibility in ['all', 'private']:</p><p class="snippet">            pass</p><p class="snippet">        else:</p><p class="snippet">            visibility = 'public'</p><p class="snippet">        recipes = Recipe.get_all_by_user(user_id=user.id, visibility=visibility)</p><p class="snippet">        return recipe_list_schema.dump(recipes).data, HTTPStatus.OK</p><p>The user is then obtained by <strong class="inline">User.get_by_username(username=username)</strong>. If the user cannot be found, will return a HTTP status code <strong class="bold">404 NOT FOUND</strong>. Otherwise, get the current user's ID using <strong class="inline">get_jwt_identity()</strong> and save it to the <strong class="inline">current_user</strong> variable.</p><p>Based on the user and their permission, we will display a different set of recipes. After the recipe is obtained, <strong class="inline">recipe_list_schema.dump(recipes).data</strong> is used to convert the recipes into JSON format and return to the client with HTTP Status Code is <strong class="bold">200 OK</strong>.</p></li>
				<li>Then, import<a id="_idTextAnchor257"/> <strong class="inline">UserRecipeListResource</strong> in <strong class="inline">app.py</strong>:<p class="snippet">from resources.user import UserListResource, UserResource, MeResource, UserRecipeListResource</p></li>
				<li>Finally, we<a id="_idTextAnchor258"/> <a id="_idTextAnchor259"/>add the following endpoint:<p class="snippet">api.add_resource(UserListResource, '/users')</p><p class="snippet">api.add_resource(UserResource, '/users/&lt;string:username&gt;')</p><p class="snippet">api.add_resource(UserRecipeListResource, '/users/&lt;string:username&gt;/recipes')</p></li>
				<li>Now, we have finished the implementation. Right-click on it to run the application. Flask will then be started up and run on the localhost (<strong class="inline">127.0.0.1</strong>) at port <strong class="inline">5000</strong>: <div id="_idContainer101" class="IMG---Figure"><img src="image/C15309_05_13.jpg" alt="Figure 5.13: Run Flask on the localhost&#13;&#10;"/></div></li>
			</ol>
			<h6>Figure 5.13: Run Flask on the localhost</h6>
			<p>Now we have learned how to use <strong class="inline">webargs</strong> to parse <strong class="inline">request</strong> arguments and have applied that to our <strong class="inline">Smilecook</strong> application. Next, as usual, we want to test and make sure that it works.</p>
			<h3 id="_idParaDest-117">Exercise 39: <a id="_idTextAnchor260"/>Retrieving <a id="_idTextAnchor261"/>Recipes from a Specific Author</h3>
			<p>This exercise is to test what we implemented in our last exercise. We will make sure the API is parsing the visibility mode that the user passes in and returns different sets of recipes accordingly. We will use a specific user (James) for testing. We will see that before and after authentication, the user will be able to see different sets of recipes: </p>
			<ol>
				<li value="1">We will get a<a id="_idTextAnchor262"/>ll the published recipes for a particular user before they have logged in. First, click on the <strong class="bold">Collections</strong> tab.</li>
				<li>Add a new request under the <strong class="bold">User</strong> folder. Set the <strong class="bold">Request Name</strong> to <strong class="inline">UserRecipeList</strong> and save.</li>
				<li>Select the newly created <strong class="bold">GET UserRecipeList</strong> request. Enter <strong class="inline">http://localhost:5000/users/james/recipes</strong> in the <strong class="bold">URL</strong> field (change the username if necessary).</li>
				<li>Click <strong class="bold">Send</strong> to check all the published recipes under this particular user (James here). The result is shown in the following screenshot:<div id="_idContainer102" class="IMG---Figure"><img src="image/C15309_05_14.jpg" alt="Figure 5.14: Get all the published recipes for a user before they have logged in&#13;&#10;"/></div><h6>Figure 5.14: Get all the published recipes for a user before they have logged in</h6><p>You will then see the return response. The HTTP status code <strong class="bold">200 OK</strong> here indicates that the request has succeeded and, in the body, we can see one published recipe under this author.</p></li>
				<li>Similar to the<a id="_idTextAnchor263"/> previous step, we will see whether we can get all the recipes under a particular user before the user has logged in – it shouldn't be allowed. Select the <strong class="bold">Params</strong> tab. Set <strong class="bold">KEY</strong> to <strong class="inline">visibility</strong>. Set <strong class="bold">VALUE</strong> to <strong class="inline">all</strong>. Click <strong class="bold">Send</strong> to check all the recipes under this particular user. The result is shown in the following screenshot:<div id="_idContainer103" class="IMG---Figure"><img src="image/C15309_05_15.jpg" alt="Figure 5.15: Check all the recipes under a particular user&#13;&#10;"/></div><h6>Figure 5.15: Check all the recipes under a particular user</h6><p>You will then see the return response. The HTTP status code <strong class="bold">200 OK</strong> here indicates that the request has succeeded, and in the body again, though we are asking for all recipes, we can only see one published recipe under this author because the user hasn't logged in.</p></li>
				<li>Log in and clic<a id="_idTextAnchor264"/>k on the <strong class="bold">Collections</strong> tab. Select the <strong class="bold">POST</strong> <strong class="bold">Token</strong> request. Click <strong class="bold">Send</strong> to check all the recipes under this particular user. The result is shown in the following screenshot:<div id="_idContainer104" class="IMG---Figure"><img src="image/C15309_05_16.jpg" alt="Figure 5.16: Select the POST Token request and send the request&#13;&#10;"/></div><h6>Figure 5.16: Select the POST Token request and send the request</h6><p>You will then see the return response. The <strong class="bold">HTTP status code 200 OK</strong> here indicates that the request has succeeded, and in the body, we can get the access token and refresh token that we will use in the next step.</p></li>
				<li>Select the <strong class="bold">GET U<a id="_idTextAnchor265"/>serRecipeList</strong> request. Select the <strong class="bold">Headers</strong> tab. Enter <strong class="inline">Authorization</strong> in the <strong class="bold">Key</strong> field and <strong class="inline">Bearer {token}</strong> in the <strong class="bold">Value</strong> field, where the token is the <strong class="bold">JWT</strong> token we got in our previous step. Click <strong class="bold">Send</strong> to query. The result is shown in the following screenshot:<div id="_idContainer105" class="IMG---Figure"><img src="image/C15309_05_17.jpg" alt="Figure 5.17: Use the JWT token and send to query&#13;&#10;"/></div></li>
			</ol>
			<h6>Figure 5.17: Use the JWT token and send to query</h6>
			<p>You will then see the return response. The <strong class="bold">HTTP status code 200 OK</strong> here indicates that the request has succeeded. In the response body, we can get all the recipes under this user, including the unpublished ones.</p>
			<p>This testing exercise concluded what we have learned about the <strong class="inline">webargs</strong> package, as well as testing the new access control functions we added for viewing recipes.</p>
			<h3 id="_idParaDest-118">Activity 8: Seria<a id="_idTextAnchor266"/>lizing the recipe Object Using marshmallow</h3>
			<p>In this activity, we want you to work on the serialization of the <strong class="inline">RecipeResource.get</strong> method. We did serialization for <strong class="inline">User</strong> and <strong class="inline">RecipeList</strong> in previous exercises. Now, it is your turn to work on this last one. </p>
			<p>Currently, <strong class="inline">RecipeResource.get</strong> is returning the <strong class="inline">recipe</strong> object using <strong class="inline">recipe.data()</strong>. We want you to replace that by serializing the <strong class="inline">recipe</strong> object using marshmallow. The <strong class="inline">recipe</strong> object should be converted into JSON format and return to the frontend client-side. To do that, you will modify <strong class="inline">recipe_schema</strong> in <strong class="inline">resources/recipe.py</strong>. You are also required to test your implementation using Postman at the end.</p>
			<p>The following are the steps to perform:</p>
			<ol>
				<li value="1">Modify the recipe schema, to include all attributes except for <strong class="inline">email</strong>.</li>
				<li>Modify the <strong class="inline">get</strong> method in <strong class="inline">RecipeResource</strong> to serialize the <strong class="inline">recipe</strong> object into JSON format using the recipe schema.</li>
				<li>Run the application so that Flask will start and run on the localhost.</li>
				<li>Test the implementation by getting one specific published recipe in Postman.<h4>Note</h4><p class="callout">The solution for the activity can be found on page 312.</p></li>
			</ol>
			<p>After this activity, you should have a good understanding of how to use schema to serialize objects. We have the flexibility to specify the attributes that need to be serialized, and how they are going to be serialized. Attributes that linked to another object can be serialized as well. As you can see from this activity, the author's information is included in this recipe response.</p>
			<h2 id="_idParaDest-119"><a id="_idTextAnchor267"/>Summary</h2>
			<p>In this chapter, we have learned a lot of things. The data verification of an API through marshmallow is very important. This function should also be constantly updated in the production environment to ensure that the information we receive is correct.</p>
			<p>In this chapter, we started with the verification of registered members and then talked about basic verification methods, such as setting mandatory fields, performing data type validation, and so on. Apart from data validation, marshmallow can be used for data filtering as well. We can use the <strong class="inline">exclude</strong> parameter to display the user email field. Based on what we learned, we then developed customized verifications for our application, such as verifying the length of the recipe creation time.</p>
			<p>At the end of this chapter, we added the functionality to get all the recipes written by our favorite author. Then, we searched for different publish statuses through the <strong class="inline">visibility</strong> parameter and applied access control accordingly.</p>
		</div>
	</body></html>