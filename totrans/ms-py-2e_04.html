<html><head></head><body><div id="sbo-rt-content"><div id="_idContainer095" class="Basic-Text-Frame">&#13;
    <h1 class="chapterNumber">4</h1>&#13;
    <h1 id="_idParaDest-106" class="chapterTitle">Pythonic Design Patterns</h1>&#13;
    <p class="normal">The previous chapter covered a lot of guidelines for what to do and what to avoid in Python. Next, we will explore a few examples of how to work in a Pythonic way using the modules included with Python.</p>&#13;
    <p class="normal">Design patterns are largely dependent on storing data; for this, Python comes bundled with several very useful collections. The most basic collections such as <code class="inlineCode">list</code>, <code class="inlineCode">tuple</code>, <code class="inlineCode">set</code>, and <code class="inlineCode">dict</code> will already be familiar to you, but Python also comes bundled with more advanced collections. Most of these simply combine the basic types for more powerful features. In this chapter, I will explain how to use these data types and collections in a Pythonic fashion.</p>&#13;
    <p class="normal">Before we can properly discuss data structures and related performance, a basic understanding of time complexity (and specifically the big O notation) is required. The concept is really simple, but without it, I cannot easily explain the performance characteristics of operations and why seemingly nice-looking code can perform horribly.</p>&#13;
    <p class="normal">In this chapter, once the big O notation is clear, we will discuss some data structures and I will show you some example design patterns, along with how to use them. We will start with the following basic data structures:</p>&#13;
    <ul>&#13;
      <li class="bulletList"><code class="inlineCode">list</code></li>&#13;
      <li class="bulletList"><code class="inlineCode">dict</code></li>&#13;
      <li class="bulletList"><code class="inlineCode">set</code></li>&#13;
      <li class="bulletList"><code class="inlineCode">tuple</code></li>&#13;
    </ul>&#13;
    <p class="normal">Building on the basic data structures, we will continue with more advanced collections, such as the following:</p>&#13;
    <ul>&#13;
      <li class="bulletList">Dictionary-like types:<ul>&#13;
          <li class="bulletList"><code class="inlineCode">ChainMap</code></li>&#13;
          <li class="bulletList"><code class="inlineCode">Counter</code></li>&#13;
          <li class="bulletList"><code class="inlineCode">Defaultdict</code></li>&#13;
          <li class="bulletList"><code class="inlineCode">OrderedDict</code></li>&#13;
        </ul>&#13;
      </li>&#13;
      <li class="bulletList">List types: <code class="inlineCode">heapq</code></li>&#13;
      <li class="bulletList">Tuple types: <code class="inlineCode">dataclass</code></li>&#13;
      <li class="bulletList">Other types: <code class="inlineCode">enum</code></li>&#13;
    </ul>&#13;
    <h1 id="_idParaDest-107" class="heading-1">Time complexity – The big O notation</h1>&#13;
    <p class="normal">Before<a id="_idIndexMarker239"/> we can begin with this chapter, there is a simple notation that you need to understand. This chapter uses the big O notation to indicate the time complexity for an operation. Feel free to skip this section if you are already familiar with this notation. While the notation sounds really complicated, the concept is actually quite simple.</p>&#13;
    <div class="note">&#13;
      <p class="normal">The big O letter refers to the capital version of the Greek letter Omicron, which means small-o (micron o).</p>&#13;
    </div>&#13;
    <p class="normal">When we say that a function takes <code class="inlineCode">O(1)</code> time, it means that it generally only takes <code class="inlineCode">1</code> step to execute. Similarly, a function with <code class="inlineCode">O(n)</code> time would take <code class="inlineCode">n</code> steps to execute, where <code class="inlineCode">n</code> is generally the size (or length) of the object. This time complexity is just a basic indication of what to expect when executing the code, as it is generally what matters most.</p>&#13;
    <div class="note">&#13;
      <p class="normal">In addition to O, several other characters might pop up in literature. Here’s an overview of the characters used:</p>&#13;
      <ul>&#13;
        <li class="bulletList"><code class="inlineCode">Ο</code> Big Omicron: The upper bound/worst-case scenario.</li>&#13;
        <li class="bulletList"><code class="inlineCode">Ω</code> Big Omega: The lower bound/best-case scenario.</li>&#13;
        <li class="bulletList"><code class="inlineCode">Θ</code> Big Theta: The tight bound, which means both O and Ω are identical.</li>&#13;
      </ul>&#13;
      <p class="normal">A good example of an algorithm where these differ a lot is the quicksort algorithm. The quicksort algorithm is one of the most widely used sorting algorithm, which is surprising if you only look at time complexity according to the (big) O. The worst case for quicksort is <code class="inlineCode">O(n**2)</code> and the best case is either <code class="inlineCode">Ω(n log n)</code> or <code class="inlineCode">Ω(n)</code>, depending on the implementation.</p>&#13;
      <p class="normal">Given the worst case of <code class="inlineCode">O(n**2)</code>, you might not expect the algorithm to be used a lot, but it has been the default sorting algorithm for many programming languages. Within C, it is still the default; for Java, it was the default up to Java 6; and Python used it up to 2002. So, why is/was quicksort so popular? For quicksort, it is very important to look at the average case, which is far more likely to occur than the worst case. Indeed, the average case is <code class="inlineCode">O(n log n)</code>, which is really good for a sorting algorithm.</p>&#13;
    </div>&#13;
    <p class="normal">The <a id="_idIndexMarker240"/>purpose of the big O notation is to indicate the approximate performance of an operation based on the number of steps that need to be executed. A piece of code that executes a single step 1,000 times faster but needs to execute <code class="inlineCode">O(2**n)</code> steps will still be slower than another version of it that takes only <code class="inlineCode">O(n)</code> steps for a value of <code class="inlineCode">n</code> equal to 10 or more. </p>&#13;
    <p class="normal">This is because <code class="inlineCode">2**n</code> for <code class="inlineCode">n=10</code> is <code class="inlineCode">2**10=1024</code>, which is 1,024 steps to execute the same code. This makes choosing the right algorithm very important, even when using languages such as <code class="inlineCode">C</code>/<code class="inlineCode">C++</code>, which are generally expected to perform better than Python with the CPython interpreter. If the code uses the wrong algorithm, it will still be slower for a non-trivial <code class="inlineCode">n</code>.</p>&#13;
    <p class="normal">For example, suppose <a id="_idIndexMarker241"/>you have a list of 1,000 items and you walk through them. This will take <code class="inlineCode">O(n)</code> time because there are <code class="inlineCode">n=1000</code> items. Checking to see whether an item exists in a list means silently walking through the items in a similar way, which means it also takes <code class="inlineCode">O(n)</code>, so that’s 1,000 steps.</p>&#13;
    <p class="normal">If you do the same with a <code class="inlineCode">dict</code> or <code class="inlineCode">set</code> that has 1,000 keys/items, it will only take <code class="inlineCode">O(1)</code> step because of how a <code class="inlineCode">dict</code>/<code class="inlineCode">set</code> is structured. How the <code class="inlineCode">dict</code> and <code class="inlineCode">set</code> are structured internally will be covered later in this chapter.</p>&#13;
    <p class="normal">This means that if you want to check the existence of 100 items in that <code class="inlineCode">list</code> or <code class="inlineCode">dict</code>, it will take you <code class="inlineCode">100*O(n)</code> for the <code class="inlineCode">list</code> and <code class="inlineCode">100*O(1)</code> for the <code class="inlineCode">dict</code> or <code class="inlineCode">set</code>. That is the difference between 100 steps and 100,000 steps, which means that the <code class="inlineCode">dict</code>/<code class="inlineCode">set</code> is <code class="inlineCode">n</code> or 1,000 times faster in this case.</p>&#13;
    <p class="normal">Even though the code seems very similar, the performance characteristics vary enormously:</p>&#13;
    <pre class="programlisting con"><code class="hljs-con"><span class="hljs-con-meta">&gt;&gt;&gt;</span> n = <span class="hljs-con-number">1000</span>&#13;
<span class="hljs-con-meta">&gt;&gt;&gt;</span> a = <span class="hljs-con-built_in">list</span>(<span class="hljs-con-built_in">range</span>(n))&#13;
<span class="hljs-con-meta">&gt;&gt;&gt;</span> b = <span class="hljs-con-built_in">dict</span>.fromkeys(<span class="hljs-con-built_in">range</span>(n))&#13;
&#13;
<span class="hljs-con-meta">&gt;&gt;&gt;</span> <span class="hljs-con-keyword">for</span> i <span class="hljs-con-keyword">in</span> <span class="hljs-con-built_in">range</span>(<span class="hljs-con-number">100</span>):&#13;
<span class="hljs-con-meta">...</span>     <span class="hljs-con-keyword">assert</span> i <span class="hljs-con-keyword">in</span> a  <span class="hljs-con-comment"># takes n=1000 steps</span>&#13;
<span class="hljs-con-meta">...</span>     <span class="hljs-con-keyword">assert</span> i <span class="hljs-con-keyword">in</span> b  <span class="hljs-con-comment"># takes 1 step</span>&#13;
</code></pre>&#13;
    <p class="normal">To<a id="_idIndexMarker242"/> illustrate <code class="inlineCode">O(1)</code>, <code class="inlineCode">O(n)</code>, and <code class="inlineCode">O(n**2)</code> functions:</p>&#13;
    <pre class="programlisting con"><code class="hljs-con"><span class="hljs-con-meta">&gt;&gt;&gt;</span> <span class="hljs-con-keyword">def</span><span class="hljs-con-function"> </span><span class="hljs-con-title">o_one</span><span class="hljs-con-function">(</span><span class="hljs-con-params">items</span><span class="hljs-con-function">):</span>&#13;
<span class="hljs-con-meta">...</span>     <span class="hljs-con-keyword">return</span> <span class="hljs-con-number">1</span>  <span class="hljs-con-comment"># 1 operation so O(1)</span>&#13;
&#13;
<span class="hljs-con-meta">&gt;&gt;&gt;</span> <span class="hljs-con-keyword">def</span><span class="hljs-con-function"> </span><span class="hljs-con-title">o_n</span><span class="hljs-con-function">(</span><span class="hljs-con-params">items</span><span class="hljs-con-function">):</span>&#13;
<span class="hljs-con-meta">...</span>     total = <span class="hljs-con-number">0</span>&#13;
<span class="hljs-con-meta">...</span>     <span class="hljs-con-comment"># Walks through all items once so O(n)</span>&#13;
<span class="hljs-con-meta">...</span>     <span class="hljs-con-keyword">for</span> item <span class="hljs-con-keyword">in</span> items:&#13;
<span class="hljs-con-meta">...</span>         total += item&#13;
<span class="hljs-con-meta">...</span>     <span class="hljs-con-keyword">return</span> total&#13;
&#13;
<span class="hljs-con-meta">&gt;&gt;&gt;</span> <span class="hljs-con-keyword">def</span><span class="hljs-con-function"> </span><span class="hljs-con-title">o_n_squared</span><span class="hljs-con-function">(</span><span class="hljs-con-params">items</span><span class="hljs-con-function">):</span>&#13;
<span class="hljs-con-meta">...</span>     total = <span class="hljs-con-number">0</span>&#13;
<span class="hljs-con-meta">...</span>     <span class="hljs-con-comment"># Walks through all items n*n times so O(n**2)</span>&#13;
<span class="hljs-con-meta">...</span>     <span class="hljs-con-keyword">for</span> a <span class="hljs-con-keyword">in</span> items:&#13;
<span class="hljs-con-meta">...</span>         <span class="hljs-con-keyword">for</span> b <span class="hljs-con-keyword">in</span> items:&#13;
<span class="hljs-con-meta">...</span>             total += a * b&#13;
<span class="hljs-con-meta">...</span>     <span class="hljs-con-keyword">return</span> total&#13;
&#13;
<span class="hljs-con-meta">&gt;&gt;&gt;</span> n = <span class="hljs-con-number">10</span>&#13;
<span class="hljs-con-meta">&gt;&gt;&gt;</span> items = <span class="hljs-con-built_in">range</span>(n)&#13;
<span class="hljs-con-meta">&gt;&gt;&gt;</span> o_one(items)  <span class="hljs-con-comment"># 1 operation</span>&#13;
1&#13;
<span class="hljs-con-meta">&gt;&gt;&gt;</span> o_n(items)  <span class="hljs-con-comment"># n = 10 operations</span>&#13;
45&#13;
<span class="hljs-con-meta">&gt;&gt;&gt;</span> o_n_squared(items)  <span class="hljs-con-comment"># n*n = 10*10 = 100 operations</span>&#13;
2025&#13;
</code></pre>&#13;
    <p class="normal">To illustrate this, we will look at some slower-growing functions first:</p>&#13;
    <figure class="mediaobject"><img src="Images/B15882_04_01.png" alt="" width="878" height="490"/></figure>&#13;
    <p class="packt_figref">Figure 4.1: Time complexity of slow-growing functions with n=1 to n=10,000</p>&#13;
    <p class="normal">As you <a id="_idIndexMarker243"/>can see, the <code class="inlineCode">O(log(n))</code> function scales really well with larger numbers; this is why a binary search is so incredibly fast, even for large datasets. Later in this chapter, you will see an example of a binary search algorithm.</p>&#13;
    <p class="normal">The <code class="inlineCode">O(n*log(n))</code> result shows a rather fast growth, which is undesirable, but better than some of the alternatives, as you can see in <em class="italic">Figure 4.2</em> with faster-growing functions:</p>&#13;
    <figure class="mediaobject"><img src="Images/B15882_04_02.png" alt="" width="806" height="396"/></figure>&#13;
    <p class="packt_figref">Figure 4.2: Time complexity of fast-growing functions with n=1 to n=10</p>&#13;
    <p class="normal">Looking <a id="_idIndexMarker244"/>at these charts, the <code class="inlineCode">O(n*log(n))</code> looks quite good by comparison. As you will see later in this chapter, many sorting algorithms use <code class="inlineCode">O(n*log(n))</code> functions and some use <code class="inlineCode">O(n**2)</code>.</p>&#13;
    <p class="normal">These algorithms quickly grow to an incalculable size; the <code class="inlineCode">O(2**n)</code> function, for example, already takes 1,024 steps with 10 items and doubles with every step. A famous example of this is the current solution to the Towers of Hanoi problem, where <code class="inlineCode">n</code> is the number of disks.</p>&#13;
    <p class="normal">The <code class="inlineCode">O(n!)</code> factorial function is far worse and becomes impossibly large after just a few steps. One of the most famous examples of this is the Traveling Salesman problem: finding the shortest route covering a list of cities exactly once.</p>&#13;
    <p class="normal">Next, we’ll dive into core collections. </p>&#13;
    <h1 id="_idParaDest-108" class="heading-1">Core collections</h1>&#13;
    <p class="normal">Before we can look at the <a id="_idIndexMarker245"/>more advanced combined collections later in this chapter, you need to understand the workings of the core Python collections. This is not just about their usage; it is also about the time complexities involved, which can strongly affect how your application will behave as it grows. If you are well versed in the time complexities of these objects and know the possibilities of Python 3’s tuple packing and unpacking by heart, then feel free to jump to the <em class="italic">Advanced collections</em> section.</p>&#13;
    <h2 id="_idParaDest-109" class="heading-2">list – A mutable list of items</h2>&#13;
    <p class="normal">The <code class="inlineCode">list</code> is <a id="_idIndexMarker246"/>most likely the container structure that you’ve used <a id="_idIndexMarker247"/>most in Python. It is simple in terms of its usage, and for most cases, it exhibits great performance.</p>&#13;
    <p class="normal">While you may already be very familiar with the usage of <code class="inlineCode">list</code>, you might not be aware of the time complexities of the <code class="inlineCode">list</code> object. Luckily, many of the time complexities of <code class="inlineCode">list</code> are very low; <code class="inlineCode">append</code>, get operations, set operations, and <code class="inlineCode">len</code> all take <code class="inlineCode">O(1)</code> time—the best possible. However, you may not know that <code class="inlineCode">remove</code> and <code class="inlineCode">insert</code> have <code class="inlineCode">O(n)</code> worst-case time complexity. So, to delete a single item out of 1,000 items, Python might have to walk through 1,000 items. Internally, the <code class="inlineCode">remove</code> and <code class="inlineCode">insert</code> operations execute something along these lines:</p>&#13;
    <pre class="programlisting con"><code class="hljs-con"><span class="hljs-con-meta">&gt;&gt;&gt;</span> <span class="hljs-con-keyword">def</span><span class="hljs-con-function"> </span><span class="hljs-con-title">remove</span><span class="hljs-con-function">(</span><span class="hljs-con-params">items, value</span><span class="hljs-con-function">):</span>&#13;
<span class="hljs-con-meta">...</span>     new_items = []&#13;
<span class="hljs-con-meta">...</span>     found = <span class="hljs-con-literal">False</span>&#13;
<span class="hljs-con-meta">...</span>     <span class="hljs-con-keyword">for</span> item <span class="hljs-con-keyword">in</span> items:&#13;
<span class="hljs-con-meta">...</span>         <span class="hljs-con-comment"># Skip the first item which is equal to value</span>&#13;
<span class="hljs-con-meta">...</span>         <span class="hljs-con-keyword">if</span> <span class="hljs-con-keyword">not</span> found <span class="hljs-con-keyword">and</span> item == value:&#13;
<span class="hljs-con-meta">...</span>             found = <span class="hljs-con-literal">True</span>&#13;
<span class="hljs-con-meta">...</span>             <span class="hljs-con-keyword">continue</span>&#13;
<span class="hljs-con-meta">...</span>         new_items.append(item)&#13;
<span class="hljs-con-meta">...</span>&#13;
<span class="hljs-con-meta">...</span>     <span class="hljs-con-keyword">if</span> <span class="hljs-con-keyword">not</span> found:&#13;
<span class="hljs-con-meta">...</span>         <span class="hljs-con-keyword">raise</span> ValueError(<span class="hljs-con-string">'list.remove(x): x not in list'</span>)&#13;
<span class="hljs-con-meta">...</span>&#13;
<span class="hljs-con-meta">...</span>     <span class="hljs-con-keyword">return</span> new_items&#13;
&#13;
<span class="hljs-con-meta">&gt;&gt;&gt;</span> <span class="hljs-con-keyword">def</span><span class="hljs-con-function"> </span><span class="hljs-con-title">insert</span><span class="hljs-con-function">(</span><span class="hljs-con-params">items, index, value</span><span class="hljs-con-function">):</span>&#13;
<span class="hljs-con-meta">...</span>     new_items = []&#13;
<span class="hljs-con-meta">...</span>     <span class="hljs-con-keyword">for</span> i, item <span class="hljs-con-keyword">in</span> <span class="hljs-con-built_in">enumerate</span>(items):&#13;
<span class="hljs-con-meta">...</span>         <span class="hljs-con-keyword">if</span> i == index:&#13;
<span class="hljs-con-meta">...</span>             new_items.append(value)&#13;
<span class="hljs-con-meta">...</span>         new_items.append(item)&#13;
<span class="hljs-con-meta">...</span>     <span class="hljs-con-keyword">return</span> new_items&#13;
<span class="hljs-con-meta">&gt;&gt;&gt;</span> items = <span class="hljs-con-built_in">list</span>(<span class="hljs-con-built_in">range</span>(<span class="hljs-con-number">10</span>))&#13;
<span class="hljs-con-meta">&gt;&gt;&gt;</span> items&#13;
[0, 1, 2, 3, 4, 5, 6, 7, 8, 9]&#13;
&#13;
<span class="hljs-con-meta">&gt;&gt;&gt;</span> items = remove(items, <span class="hljs-con-number">5</span>)&#13;
<span class="hljs-con-meta">&gt;&gt;&gt;</span> items&#13;
[0, 1, 2, 3, 4, 6, 7, 8, 9]&#13;
&#13;
<span class="hljs-con-meta">&gt;&gt;&gt;</span> items = insert(items, <span class="hljs-con-number">2</span>, <span class="hljs-con-number">5</span>)&#13;
<span class="hljs-con-meta">&gt;&gt;&gt;</span> items&#13;
[0, 1, 5, 2, 3, 4, 6, 7, 8, 9]&#13;
</code></pre>&#13;
    <p class="normal">To <a id="_idIndexMarker248"/>remove or insert a single item from/into the list, Python needs to shift the rest of the list after the insertion/deletion point. For a large <code class="inlineCode">list</code>, this can become <a id="_idIndexMarker249"/>a performance burden and, if possible, should be avoided by using <code class="inlineCode">append</code> instead of <code class="inlineCode">insert</code>. When executing this only once, it is, of course, not all that bad. But when executing a large number of <code class="inlineCode">remove</code> operations, a <code class="inlineCode">filter</code> or <code class="inlineCode">list</code> comprehension is a much faster solution because, if properly structured, it needs to copy the list only once.</p>&#13;
    <p class="normal">For example, suppose we wish to remove a specific set of numbers from the list. We have quite a few options for this. The first is a solution using <code class="inlineCode">remove</code>, which becomes slower if the number of items to remove becomes larger. </p>&#13;
    <p class="normal">Next up is constructing a new list, a list comprehension, or a <code class="inlineCode">filter</code> statement. <em class="chapterRef">Chapter 5</em>, <em class="italic">Functional Programming – Readability Versus Brevity</em>, will explain <code class="inlineCode">list</code> comprehensions and the <code class="inlineCode">filter</code> statement in more detail. But first, let’s check out some examples:</p>&#13;
    <pre class="programlisting con"><code class="hljs-con"><span class="hljs-con-meta">&gt;&gt;&gt;</span> primes = <span class="hljs-con-built_in">set</span>((<span class="hljs-con-number">1</span>, <span class="hljs-con-number">2</span>, <span class="hljs-con-number">3</span>, <span class="hljs-con-number">5</span>, <span class="hljs-con-number">7</span>))&#13;
&#13;
<span class="hljs-con-comment"># Classic solution</span>&#13;
<span class="hljs-con-meta">&gt;&gt;&gt;</span> items = <span class="hljs-con-built_in">list</span>(<span class="hljs-con-built_in">range</span>(<span class="hljs-con-number">10</span>))&#13;
<span class="hljs-con-meta">&gt;&gt;&gt;</span> <span class="hljs-con-keyword">for</span> prime <span class="hljs-con-keyword">in</span> primes:&#13;
<span class="hljs-con-meta">...</span>     items.remove(prime)&#13;
<span class="hljs-con-meta">&gt;&gt;&gt;</span> items&#13;
[0, 4, 6, 8, 9]&#13;
&#13;
<span class="hljs-con-comment"># List comprehension</span>&#13;
<span class="hljs-con-meta">&gt;&gt;&gt;</span> items = <span class="hljs-con-built_in">list</span>(<span class="hljs-con-built_in">range</span>(<span class="hljs-con-number">10</span>))&#13;
<span class="hljs-con-meta">&gt;&gt;&gt;</span> [item <span class="hljs-con-keyword">for</span> item <span class="hljs-con-keyword">in</span> items <span class="hljs-con-keyword">if</span> item <span class="hljs-con-keyword">not</span> <span class="hljs-con-keyword">in</span> primes]&#13;
[0, 4, 6, 8, 9]&#13;
&#13;
<span class="hljs-con-comment"># Filter</span>&#13;
<span class="hljs-con-meta">&gt;&gt;&gt;</span> items = <span class="hljs-con-built_in">list</span>(<span class="hljs-con-built_in">range</span>(<span class="hljs-con-number">10</span>))&#13;
<span class="hljs-con-meta">&gt;&gt;&gt;</span> <span class="hljs-con-built_in">list</span>(<span class="hljs-con-built_in">filter</span>(<span class="hljs-con-keyword">lambda</span> item: item <span class="hljs-con-keyword">not</span> <span class="hljs-con-keyword">in</span> primes, items))&#13;
[0, 4, 6, 8, 9]&#13;
</code></pre>&#13;
    <p class="normal">The latter <a id="_idIndexMarker250"/>two examples are much faster for large lists of items. This is because the operations <a id="_idIndexMarker251"/>are much faster. To compare using <code class="inlineCode">n=len(items)</code> and <code class="inlineCode">m=len(primes)</code>, the first example takes <code class="inlineCode">O(m*n)=5*10=50</code> operations, whereas the latter two take <code class="inlineCode">O(n*1)=10*1=10</code> operations.</p>&#13;
    <div class="note">&#13;
      <p class="normal">The first method is actually slightly better than stated because <code class="inlineCode">n</code> decreases during the loop. So, it’s effectively <code class="inlineCode">10+9+8+7+6=40</code>, but this is an effect that is negligible enough to ignore. In the case of <code class="inlineCode">n=1000</code>, that would be the difference between <code class="inlineCode">1000+999+998+997+996=4990</code> and <code class="inlineCode">5*1000=5000</code>, which makes no real-world difference.</p>&#13;
    </div>&#13;
    <p class="normal">Of course, <code class="inlineCode">min</code>, <code class="inlineCode">max</code>, and <code class="inlineCode">in</code> all take <code class="inlineCode">O(n)</code> as well, but that is expected for a structure that is not optimized for these types of lookups.</p>&#13;
    <p class="normal">They can be implemented like this:</p>&#13;
    <pre class="programlisting con"><code class="hljs-con"><span class="hljs-con-meta">&gt;&gt;&gt;</span> <span class="hljs-con-keyword">def</span><span class="hljs-con-function"> </span><span class="hljs-con-title">in_</span><span class="hljs-con-function">(</span><span class="hljs-con-params">items, value</span><span class="hljs-con-function">):</span>&#13;
<span class="hljs-con-meta">...</span>     <span class="hljs-con-keyword">for</span> item <span class="hljs-con-keyword">in</span> items:&#13;
<span class="hljs-con-meta">...</span>         <span class="hljs-con-keyword">if</span> item == value:&#13;
<span class="hljs-con-meta">...</span>             <span class="hljs-con-keyword">return</span> <span class="hljs-con-literal">True</span>&#13;
<span class="hljs-con-meta">...</span>     <span class="hljs-con-keyword">return</span> <span class="hljs-con-literal">False</span>&#13;
&#13;
<span class="hljs-con-meta">&gt;&gt;&gt;</span> <span class="hljs-con-keyword">def</span><span class="hljs-con-function"> </span><span class="hljs-con-title">min_</span><span class="hljs-con-function">(</span><span class="hljs-con-params">items</span><span class="hljs-con-function">):</span>&#13;
<span class="hljs-con-meta">...</span>     current_min = items[<span class="hljs-con-number">0</span>]&#13;
<span class="hljs-con-meta">...</span>     <span class="hljs-con-keyword">for</span> item <span class="hljs-con-keyword">in</span> items[<span class="hljs-con-number">1</span>:]:&#13;
<span class="hljs-con-meta">...</span>         <span class="hljs-con-keyword">if</span> current_min &gt; item:&#13;
<span class="hljs-con-meta">...</span>             current_min = item&#13;
<span class="hljs-con-meta">...</span>     <span class="hljs-con-keyword">return</span> current_min&#13;
&#13;
<span class="hljs-con-meta">&gt;&gt;&gt;</span> <span class="hljs-con-keyword">def</span><span class="hljs-con-function"> </span><span class="hljs-con-title">max_</span><span class="hljs-con-function">(</span><span class="hljs-con-params">items</span><span class="hljs-con-function">):</span>&#13;
<span class="hljs-con-meta">...</span>     current_max = items[<span class="hljs-con-number">0</span>]&#13;
<span class="hljs-con-meta">...</span>     <span class="hljs-con-keyword">for</span> item <span class="hljs-con-keyword">in</span> items[<span class="hljs-con-number">1</span>:]:&#13;
<span class="hljs-con-meta">...</span>         <span class="hljs-con-keyword">if</span> current_max &lt; item:&#13;
<span class="hljs-con-meta">...</span>             current_max = item&#13;
<span class="hljs-con-meta">...</span>     <span class="hljs-con-keyword">return</span> current_max&#13;
&#13;
<span class="hljs-con-meta">&gt;&gt;&gt;</span> items = <span class="hljs-con-built_in">range</span>(<span class="hljs-con-number">5</span>)&#13;
<span class="hljs-con-meta">&gt;&gt;&gt;</span> in_(items, <span class="hljs-con-number">3</span>)&#13;
True&#13;
<span class="hljs-con-meta">&gt;&gt;&gt;</span> min_(items)&#13;
0&#13;
<span class="hljs-con-meta">&gt;&gt;&gt;</span> max_(items)&#13;
4&#13;
</code></pre>&#13;
    <p class="normal">With these <a id="_idIndexMarker252"/>examples, it’s also clear that the <code class="inlineCode">in</code> operator is a good example of where the best, worst, and average cases are vastly different. The best case is <code class="inlineCode">O(1)</code>, which is being lucky <a id="_idIndexMarker253"/>and finding our value at the first item. The worst case is <code class="inlineCode">O(n)</code> because it might not exist or it could be the last item. From this, you might expect the average case to be <code class="inlineCode">O(n/2)</code>, but you would be wrong. The average case is still <code class="inlineCode">O(n)</code> since there is a large likelihood of the item not existing in the list at all.</p>&#13;
    <h2 id="_idParaDest-110" class="heading-2">dict – A map of items</h2>&#13;
    <p class="normal">The <code class="inlineCode">dict</code> is <a id="_idIndexMarker254"/>probably the container structure you will choose to use the most. You might not realize that you are using it constantly without explicitly using <code class="inlineCode">dict</code>. Every function call and variable access goes through a <code class="inlineCode">dict</code> to look up the name from the <code class="inlineCode">local()</code> or <code class="inlineCode">global()</code> scope dictionaries.</p>&#13;
    <p class="normal">The <code class="inlineCode">dict</code> is fast, simple to use, and very effective for a wide range of use cases. The average<a id="_idIndexMarker255"/> time complexity is <code class="inlineCode">O(1)</code> for the <code class="inlineCode">get</code>, <code class="inlineCode">set</code>, and <code class="inlineCode">delete</code> operations. </p>&#13;
    <p class="normal">There are exceptions to this time complexity that you need to be aware of, however. The way a <code class="inlineCode">dict</code> works is by converting the key into a hash using the <code class="inlineCode">hash</code> function (which calls the <code class="inlineCode">__hash__</code> method of the object given as a key) and storing it in a <a id="_idIndexMarker256"/>hash table.</p>&#13;
    <div class="packt_tip">&#13;
      <p class="normal">Magic methods such as <code class="inlineCode">__hash__</code> are called either <strong class="keyWord">magic methods</strong> or <strong class="keyWord">dunder methods</strong>, where <strong class="keyWord">dunder</strong> is short for double-underscore.</p>&#13;
    </div>&#13;
    <p class="normal">There are <a id="_idIndexMarker257"/>two problems with hash tables, however. The first and the most obvious is that the items will be sorted by hash, which appears at random in most cases. The second problem with hash tables is that they can have hash collisions, and the result of a hash collision is that in the worst case, all the former operations can take <code class="inlineCode">O(n)</code> instead. Hash collisions are not all that likely to occur, but they can occur, and if a large <code class="inlineCode">dict</code> performs below par, that is the place to look.</p>&#13;
    <div class="note">&#13;
      <p class="normal">Since Python 3.6, the default <code class="inlineCode">dict</code> implementation in CPython has changed to a version that is sorted by insertion. Since Python 3.7, this is guaranteed behavior since other Python versions such as Jython and PyPy could use different implementations before version 3.7.</p>&#13;
    </div>&#13;
    <p class="normal">Let’s see <a id="_idIndexMarker258"/>how this actually works in practice. For the sake of this example, I will<a id="_idIndexMarker259"/> use one of the simplest hashing algorithms I can think of, which uses the most significant digit of a number. So, for the case of <code class="inlineCode">12345</code>, this hashing function will return <code class="inlineCode">1</code>, and for <code class="inlineCode">56789</code>, it will return <code class="inlineCode">5</code>:</p>&#13;
    <pre class="programlisting con"><code class="hljs-con"><span class="hljs-con-meta">&gt;&gt;&gt;</span> <span class="hljs-con-keyword">def</span><span class="hljs-con-function"> </span><span class="hljs-con-title">most_significant</span><span class="hljs-con-function">(</span><span class="hljs-con-params">value</span><span class="hljs-con-function">):</span>&#13;
<span class="hljs-con-meta">...</span>     <span class="hljs-con-keyword">while</span> value &gt;= <span class="hljs-con-number">10</span>:&#13;
<span class="hljs-con-meta">...</span>         value //= <span class="hljs-con-number">10</span>&#13;
<span class="hljs-con-meta">...</span>     <span class="hljs-con-keyword">return</span> value&#13;
&#13;
<span class="hljs-con-meta">&gt;&gt;&gt;</span> most_significant(<span class="hljs-con-number">12345</span>)&#13;
1&#13;
<span class="hljs-con-meta">&gt;&gt;&gt;</span> most_significant(<span class="hljs-con-number">99</span>)&#13;
9&#13;
<span class="hljs-con-meta">&gt;&gt;&gt;</span> most_significant(<span class="hljs-con-number">0</span>)&#13;
0&#13;
</code></pre>&#13;
    <p class="normal">Now, we will emulate a <code class="inlineCode">dict</code> using a <code class="inlineCode">list</code> of lists with this hashing method. We know that our hashing method can only return numbers from <code class="inlineCode">0</code> to <code class="inlineCode">9</code>, so we need only 10 buckets in our list. Now, we will add a few values and see how a <code class="inlineCode">contains</code> function could work:</p>&#13;
    <pre class="programlisting con"><code class="hljs-con"><span class="hljs-con-meta">&gt;&gt;&gt;</span> <span class="hljs-con-keyword">def</span><span class="hljs-con-function"> </span><span class="hljs-con-title">add</span><span class="hljs-con-function">(</span><span class="hljs-con-params">collection, key, value</span><span class="hljs-con-function">):</span>&#13;
<span class="hljs-con-meta">...</span>     index = most_significant(key)&#13;
<span class="hljs-con-meta">...</span>     collection[index].append((key, value))&#13;
&#13;
<span class="hljs-con-meta">&gt;&gt;&gt;</span> <span class="hljs-con-keyword">def</span><span class="hljs-con-function"> </span><span class="hljs-con-title">contains</span><span class="hljs-con-function">(</span><span class="hljs-con-params">collection, key</span><span class="hljs-con-function">):</span>&#13;
<span class="hljs-con-meta">...</span>     index = most_significant(key)&#13;
<span class="hljs-con-meta">...</span>     <span class="hljs-con-keyword">for</span> k, v <span class="hljs-con-keyword">in</span> collection[index]:&#13;
<span class="hljs-con-meta">...</span>         <span class="hljs-con-keyword">if</span> k == key:&#13;
<span class="hljs-con-meta">...</span>             <span class="hljs-con-keyword">return</span> <span class="hljs-con-literal">True</span>&#13;
<span class="hljs-con-meta">...</span>     <span class="hljs-con-keyword">return</span> <span class="hljs-con-literal">False</span>&#13;
&#13;
<span class="hljs-con-comment"># Create the collection of 10 lists</span>&#13;
<span class="hljs-con-meta">&gt;&gt;&gt;</span> collection = [[], [], [], [], [], [], [], [], [], []]&#13;
<span class="hljs-con-comment"># Add some items, using key/value pairs</span>&#13;
<span class="hljs-con-meta">&gt;&gt;&gt;</span> add(collection, <span class="hljs-con-number">123</span>, <span class="hljs-con-string">'a'</span>)&#13;
<span class="hljs-con-meta">&gt;&gt;&gt;</span> add(collection, <span class="hljs-con-number">456</span>, <span class="hljs-con-string">'</span><span class="hljs-con-string">b'</span>)&#13;
<span class="hljs-con-meta">&gt;&gt;&gt;</span> add(collection, <span class="hljs-con-number">789</span>, <span class="hljs-con-string">'c'</span>)&#13;
<span class="hljs-con-meta">&gt;&gt;&gt;</span> add(collection, <span class="hljs-con-number">101</span>, <span class="hljs-con-string">'c'</span>)&#13;
&#13;
<span class="hljs-con-comment"># Look at the collection</span>&#13;
<span class="hljs-con-meta">&gt;&gt;&gt;</span> collection&#13;
[[], [(123, 'a'), (101, 'c')], [], [],&#13;
 [(456, 'b')], [], [], [(789, 'c')], [], []]&#13;
&#13;
<span class="hljs-con-comment"># Check if the contains works correctly</span>&#13;
<span class="hljs-con-meta">&gt;&gt;&gt;</span> contains(collection, <span class="hljs-con-number">123</span>)&#13;
True&#13;
<span class="hljs-con-meta">&gt;&gt;&gt;</span> contains(collection, <span class="hljs-con-number">1</span>)&#13;
False&#13;
</code></pre>&#13;
    <p class="normal">This code <a id="_idIndexMarker260"/>is obviously not identical to the <code class="inlineCode">dict</code> implementation, but it is similar. Since we can just get item <code class="inlineCode">1</code> for a value of <code class="inlineCode">123</code> by simple indexing, we <a id="_idIndexMarker261"/>have only <code class="inlineCode">O(1)</code> lookup costs in the general case. However, since both keys, <code class="inlineCode">123</code> and <code class="inlineCode">101</code>, are within the <code class="inlineCode">1</code> bucket, the runtime can actually increase to <code class="inlineCode">O(n)</code> in the worst case, where all keys have the same hash. As mentioned, that is a hash collision. To alleviate hash collisions beyond what the <code class="inlineCode">hash()</code> function already does, the Python <code class="inlineCode">dict</code> uses a probing sequence to automatically shift hashes if needed. The details of this method are well explained in the <code class="inlineCode">dictobject.c</code> file of the Python source.</p>&#13;
    <div class="packt_tip">&#13;
      <p class="normal">To debug hash collisions, you can use the <code class="inlineCode">hash()</code> function paired with <code class="inlineCode">collections.Counter</code>. This will quickly show you where hash collisions occur but it does not take the <code class="inlineCode">dict</code> probing sequence into consideration.</p>&#13;
    </div>&#13;
    <p class="normal">In addition to the hash collision performance problem, there is another behavior that might surprise you. When deleting items from a dictionary, it won’t actually resize the dictionary in memory. The result is that both copying and iterating over the entire dictionary take <code class="inlineCode">O(m)</code> time (where <code class="inlineCode">m</code> is the maximum size of the dictionary); <code class="inlineCode">n</code>, the current number of items, is not used. So, if you add 1,000 items to a <code class="inlineCode">dict</code> and remove 999, iterating and copying will still take 1,000 steps. The only way to work around this issue is by recreating the dictionary, which is something that both the <code class="inlineCode">copy</code> and <code class="inlineCode">insert</code> operations do. Note that recreation during an <code class="inlineCode">insert</code> operation is not guaranteed and depends on the number of free slots available internally. </p>&#13;
    <h2 id="_idParaDest-111" class="heading-2">set – Like a dict without values</h2>&#13;
    <p class="normal">A <code class="inlineCode">set</code> is a<a id="_idIndexMarker262"/> structure that uses the <code class="inlineCode">hash()</code> function to get a unique<a id="_idIndexMarker263"/> collection of values. Internally, it is very similar to a <code class="inlineCode">dict</code>, with the same hash collision problem, but there are a few handy features of <code class="inlineCode">set</code> that need to be shown:</p>&#13;
    <pre class="programlisting con"><code class="hljs-con"><span class="hljs-con-comment"># All output in the table below is generated using this function</span>&#13;
<span class="hljs-con-meta">&gt;&gt;&gt;</span> <span class="hljs-con-keyword">def</span><span class="hljs-con-function"> </span><span class="hljs-con-title">print_set</span><span class="hljs-con-function">(</span><span class="hljs-con-params">expression, set_</span><span class="hljs-con-function">):</span>&#13;
<span class="hljs-con-meta">...</span>     <span class="hljs-con-string">'Print set as a string sorted by letters'</span>&#13;
<span class="hljs-con-meta">...</span>     print(expression, <span class="hljs-con-string">''</span>.join(<span class="hljs-con-built_in">sorted</span>(set_)))&#13;
&#13;
<span class="hljs-con-meta">&gt;&gt;&gt;</span> spam = <span class="hljs-con-built_in">set</span>(<span class="hljs-con-string">'spam'</span>)&#13;
<span class="hljs-con-meta">&gt;&gt;&gt;</span> print_set(<span class="hljs-con-string">'spam:'</span>, spam)&#13;
spam: amps&#13;
&#13;
<span class="hljs-con-meta">&gt;&gt;&gt;</span> eggs = <span class="hljs-con-built_in">set</span>(<span class="hljs-con-string">'eggs'</span>)&#13;
<span class="hljs-con-meta">&gt;&gt;&gt; </span>print_set(<span class="hljs-con-string">'eggs:'</span>, eggs)&#13;
eggs: egs&#13;
</code></pre>&#13;
    <p class="normal">The first few are pretty much as expected. When we get to the operators, it gets interesting:</p>&#13;
    <table id="table001" class="table-container">&#13;
      <thead>&#13;
        <tr>&#13;
          <td class="table-cell">&#13;
            <p class="normal"><strong class="keyWord">Expression</strong></p>&#13;
          </td>&#13;
          <td class="table-cell">&#13;
            <p class="normal"><strong class="keyWord">Output</strong></p>&#13;
          </td>&#13;
          <td class="table-cell">&#13;
            <p class="normal"><strong class="keyWord">Explanation</strong></p>&#13;
          </td>&#13;
        </tr>&#13;
      </thead>&#13;
      <tbody>&#13;
        <tr>&#13;
          <td class="table-cell">&#13;
            <p class="normal"><code class="inlineCode">spam</code></p>&#13;
          </td>&#13;
          <td class="table-cell">&#13;
            <p class="normal"><code class="inlineCode">amps</code></p>&#13;
          </td>&#13;
          <td class="table-cell" rowspan="2">&#13;
            <p class="normal">All unique items. A <code class="inlineCode">set</code> doesn’t allow for duplicates.</p>&#13;
          </td>&#13;
        </tr>&#13;
        <tr>&#13;
          <td class="table-cell">&#13;
            <p class="normal"><code class="inlineCode">eggs</code></p>&#13;
          </td>&#13;
          <td class="table-cell">&#13;
            <p class="normal"><code class="inlineCode">egs</code></p>&#13;
          </td>&#13;
        </tr>&#13;
        <tr>&#13;
          <td class="table-cell">&#13;
            <p class="normal"><code class="inlineCode">spam &amp; eggs</code></p>&#13;
          </td>&#13;
          <td class="table-cell">&#13;
            <p class="normal"><code class="inlineCode">s</code></p>&#13;
          </td>&#13;
          <td class="table-cell">&#13;
            <p class="normal">Every item in both.</p>&#13;
          </td>&#13;
        </tr>&#13;
        <tr>&#13;
          <td class="table-cell">&#13;
            <p class="normal"><code class="inlineCode">spam | eggs</code></p>&#13;
          </td>&#13;
          <td class="table-cell">&#13;
            <p class="normal"><code class="inlineCode">aegmps</code></p>&#13;
          </td>&#13;
          <td class="table-cell">&#13;
            <p class="normal">Every item in either or both.</p>&#13;
          </td>&#13;
        </tr>&#13;
        <tr>&#13;
          <td class="table-cell">&#13;
            <p class="normal"><code class="inlineCode">spam ^ eggs</code></p>&#13;
          </td>&#13;
          <td class="table-cell">&#13;
            <p class="normal"><code class="inlineCode">aegmp</code></p>&#13;
          </td>&#13;
          <td class="table-cell">&#13;
            <p class="normal">Every item in either but not in both.</p>&#13;
          </td>&#13;
        </tr>&#13;
        <tr>&#13;
          <td class="table-cell">&#13;
            <p class="normal"><code class="inlineCode">spam - eggs</code></p>&#13;
          </td>&#13;
          <td class="table-cell">&#13;
            <p class="normal"><code class="inlineCode">amp</code></p>&#13;
          </td>&#13;
          <td class="table-cell" rowspan="2">&#13;
            <p class="normal">Every item in the first but not the latter.</p>&#13;
          </td>&#13;
        </tr>&#13;
        <tr>&#13;
          <td class="table-cell">&#13;
            <p class="normal"><code class="inlineCode">eggs - spam</code></p>&#13;
          </td>&#13;
          <td class="table-cell">&#13;
            <p class="normal"><code class="inlineCode">eg</code></p>&#13;
          </td>&#13;
        </tr>&#13;
        <tr>&#13;
          <td class="table-cell">&#13;
            <p class="normal"><code class="inlineCode">spam &gt; eggs</code></p>&#13;
          </td>&#13;
          <td class="table-cell">&#13;
            <p class="normal"><code class="inlineCode">False</code></p>&#13;
          </td>&#13;
          <td class="table-cell" rowspan="3">&#13;
            <p class="normal">True if every item in the latter is in the first.</p>&#13;
          </td>&#13;
        </tr>&#13;
        <tr>&#13;
          <td class="table-cell">&#13;
            <p class="normal"><code class="inlineCode">eggs &gt; spam</code></p>&#13;
          </td>&#13;
          <td class="table-cell">&#13;
            <p class="normal"><code class="inlineCode">False</code></p>&#13;
          </td>&#13;
        </tr>&#13;
        <tr>&#13;
          <td class="table-cell">&#13;
            <p class="normal"><code class="inlineCode">spam &gt; sp</code></p>&#13;
          </td>&#13;
          <td class="table-cell">&#13;
            <p class="normal"><code class="inlineCode">True</code></p>&#13;
          </td>&#13;
        </tr>&#13;
        <tr>&#13;
          <td class="table-cell">&#13;
            <p class="normal"><code class="inlineCode">spam &lt; sp</code></p>&#13;
          </td>&#13;
          <td class="table-cell">&#13;
            <p class="normal"><code class="inlineCode">False</code></p>&#13;
          </td>&#13;
          <td class="table-cell">&#13;
            <p class="normal">True if every item in the first is contained in the latter.</p>&#13;
          </td>&#13;
        </tr>&#13;
      </tbody>&#13;
    </table>&#13;
    <p class="normal">One useful example of <code class="inlineCode">set</code> operations is calculating the differences between two objects. For example, let’s assume we have two lists:</p>&#13;
    <ul>&#13;
      <li class="bulletList"><code class="inlineCode">current_users</code>: The current users in a group</li>&#13;
      <li class="bulletList"><code class="inlineCode">new_users</code>: The new list of users in a group</li>&#13;
    </ul>&#13;
    <p class="normal">In<a id="_idIndexMarker264"/> permission<a id="_idIndexMarker265"/> systems, this is a very common scenario—mass adding and/or removing users from a group. Within many permission databases, it’s not easily possible to set the entire list at once, so you need a list to insert and a list to delete. This is where <code class="inlineCode">set</code> comes in really handy:</p>&#13;
    <pre class="programlisting con"><code class="hljs-con"><span class="hljs-con-comment"># The set function takes a sequence as argument so the double ( is required.</span>&#13;
<span class="hljs-con-meta">&gt;&gt;&gt;</span> current_users = <span class="hljs-con-built_in">set</span>((&#13;
<span class="hljs-con-meta">...</span>     <span class="hljs-con-string">'a'</span>,&#13;
<span class="hljs-con-meta">...</span>     <span class="hljs-con-string">'b'</span>,&#13;
<span class="hljs-con-meta">...</span>     <span class="hljs-con-string">'d'</span>,&#13;
<span class="hljs-con-meta">...</span> ))&#13;
&#13;
<span class="hljs-con-meta">&gt;&gt;&gt;</span> new_users = <span class="hljs-con-built_in">set</span>((&#13;
<span class="hljs-con-meta">...</span>     <span class="hljs-con-string">'b'</span>,&#13;
<span class="hljs-con-meta">...</span>     <span class="hljs-con-string">'c'</span>,&#13;
<span class="hljs-con-meta">...</span>     <span class="hljs-con-string">'d'</span>,&#13;
<span class="hljs-con-meta">...</span>     <span class="hljs-con-string">'e'</span>,&#13;
<span class="hljs-con-meta">...</span> ))&#13;
&#13;
<span class="hljs-con-meta">&gt;&gt;&gt;</span> to_insert = new_users - current_users&#13;
<span class="hljs-con-meta">&gt;&gt;&gt;</span> <span class="hljs-con-built_in">sorted</span>(to_insert)&#13;
['c', 'e']&#13;
<span class="hljs-con-meta">&gt;&gt;&gt;</span> to_delete = current_users - new_users&#13;
<span class="hljs-con-meta">&gt;&gt;&gt;</span> <span class="hljs-con-built_in">sorted</span>(to_delete)&#13;
['a']&#13;
<span class="hljs-con-meta">&gt;&gt;&gt;</span> unchanged = new_users &amp; current_users&#13;
<span class="hljs-con-meta">&gt;&gt;&gt;</span> <span class="hljs-con-built_in">sorted</span>(unchanged)&#13;
['b', 'd']&#13;
</code></pre>&#13;
    <p class="normal">Now, we have lists of all users who were added, removed, and unchanged. Note that <code class="inlineCode">sorted</code> is only needed for consistent output, since a <code class="inlineCode">set</code> has no predefined sort order.</p>&#13;
    <h2 id="_idParaDest-112" class="heading-2">tuple – The immutable list</h2>&#13;
    <p class="normal">A <code class="inlineCode">tuple</code> is <a id="_idIndexMarker266"/>another object that you probably use very often without <a id="_idIndexMarker267"/>even noticing it. When you look at it initially, it seems like a useless data structure. It’s like a list that you can’t modify, so why not just use a <code class="inlineCode">list</code>? In fact, there are a few cases where a <code class="inlineCode">tuple</code> offers some really useful functionalities that a <code class="inlineCode">list</code> does not.</p>&#13;
    <p class="normal">Firstly, they are hashable. This means that you can use a <code class="inlineCode">tuple</code> as a key in a <code class="inlineCode">dict</code> or as an item of a <code class="inlineCode">set</code>, which is something a <code class="inlineCode">list</code> can’t do:</p>&#13;
    <pre class="programlisting con"><code class="hljs-con"><span class="hljs-con-meta">&gt;&gt;&gt;</span> spam = <span class="hljs-con-number">1</span>, <span class="hljs-con-number">2</span>, <span class="hljs-con-number">3</span>&#13;
<span class="hljs-con-meta">&gt;&gt;&gt;</span> eggs = <span class="hljs-con-number">4</span>, <span class="hljs-con-number">5</span>, <span class="hljs-con-number">6</span>&#13;
&#13;
<span class="hljs-con-meta">&gt;&gt;&gt;</span> data = <span class="hljs-con-built_in">dict</span>()&#13;
<span class="hljs-con-meta">&gt;&gt;&gt;</span> data[spam] = <span class="hljs-con-string">'spam'</span>&#13;
<span class="hljs-con-meta">&gt;&gt;&gt;</span> data[eggs] = <span class="hljs-con-string">'eggs'</span>&#13;
&#13;
<span class="hljs-con-meta">&gt;&gt;&gt;</span> <span class="hljs-con-keyword">import</span> pprint  <span class="hljs-con-comment"># Using pprint for consistent and sorted output</span>&#13;
&#13;
<span class="hljs-con-meta">&gt;&gt;&gt;</span> pprint.pprint(data)&#13;
{(1, 2, 3): 'spam', (4, 5, 6): 'eggs'}&#13;
</code></pre>&#13;
    <p class="normal">However, tuples can contain more than simple numbers. You can use nested tuples, strings, numbers, and anything else for which the <code class="inlineCode">hash()</code> function returns a consistent result:</p>&#13;
    <pre class="programlisting con"><code class="hljs-con"><span class="hljs-con-meta">&gt;&gt;&gt;</span> spam = <span class="hljs-con-number">1</span>, <span class="hljs-con-string">'abc'</span>, (<span class="hljs-con-number">2</span>, <span class="hljs-con-number">3</span>, (<span class="hljs-con-number">4</span>, <span class="hljs-con-number">5</span>)), <span class="hljs-con-string">'def'</span>&#13;
<span class="hljs-con-meta">&gt;&gt;&gt;</span> eggs = <span class="hljs-con-number">4</span>, (spam, <span class="hljs-con-number">5</span>), <span class="hljs-con-number">6</span>&#13;
&#13;
<span class="hljs-con-meta">&gt;&gt;&gt;</span> data = <span class="hljs-con-built_in">dict</span>()&#13;
<span class="hljs-con-meta">&gt;&gt;&gt;</span> data[spam] = <span class="hljs-con-string">'spam'</span>&#13;
<span class="hljs-con-meta">&gt;&gt;&gt;</span> data[eggs] = <span class="hljs-con-string">'eggs'</span>&#13;
&#13;
<span class="hljs-con-meta">&gt;&gt;&gt;</span> <span class="hljs-con-keyword">import</span> pprint  <span class="hljs-con-comment"># Using pprint for consistent and sorted output</span>&#13;
&#13;
<span class="hljs-con-meta">&gt;&gt;&gt;</span> pprint.pprint(data)&#13;
{(1, 'abc', (2, 3, (4, 5)), 'def'): 'spam',&#13;
 (4, ((1, 'abc', (2, 3, (4, 5)), 'def'), 5), 6): 'eggs'}&#13;
</code></pre>&#13;
    <p class="normal">You can make these as complex as you need. As long as all the parts of the tuple are hashable, you will have no problem hashing the tuple as well. You can still construct a tuple containing a <code class="inlineCode">list</code> or <a id="_idIndexMarker268"/>any other unhashable type without a problem, but that will make the tuple unhashable.</p>&#13;
    <p class="normal">Perhaps even more useful is the fact that tuples also support tuple packing and unpacking:</p>&#13;
    <pre class="programlisting con"><code class="hljs-con"><span class="hljs-con-comment"># Assign using tuples on both sides</span>&#13;
<span class="hljs-con-meta">&gt;&gt;&gt;</span> a, b, c = <span class="hljs-con-number">1</span>, <span class="hljs-con-number">2</span>, <span class="hljs-con-number">3</span>&#13;
<span class="hljs-con-meta">&gt;&gt;&gt;</span> a&#13;
1&#13;
&#13;
<span class="hljs-con-comment"># Assign a tuple to a single variable</span>&#13;
<span class="hljs-con-meta">&gt;&gt;&gt;</span> spam = a, (b, c)&#13;
<span class="hljs-con-meta">&gt;&gt;&gt;</span> spam&#13;
(1, (2, 3))&#13;
&#13;
<span class="hljs-con-comment"># Unpack a tuple to two variables</span>&#13;
<span class="hljs-con-meta">&gt;&gt;&gt;</span> a, b = spam&#13;
<span class="hljs-con-meta">&gt;&gt;&gt;</span> a&#13;
1&#13;
<span class="hljs-con-meta">&gt;&gt;&gt;</span> b&#13;
(2, 3)&#13;
</code></pre>&#13;
    <p class="normal">In addition<a id="_idIndexMarker269"/> to regular packing and unpacking, from Python 3 onward, we can actually pack and unpack objects with a variable number of items:</p>&#13;
    <pre class="programlisting con"><code class="hljs-con"><span class="hljs-con-comment"># Unpack with variable length objects which assigns a list instead</span>&#13;
<span class="hljs-con-comment"># of a tuple</span>&#13;
<span class="hljs-con-meta">&gt;&gt;&gt;</span> spam, *eggs = <span class="hljs-con-number">1</span>, <span class="hljs-con-number">2</span>, <span class="hljs-con-number">3</span>, <span class="hljs-con-number">4</span>&#13;
<span class="hljs-con-meta">&gt;&gt;&gt;</span> spam&#13;
1&#13;
<span class="hljs-con-meta">&gt;&gt;&gt;</span> eggs&#13;
[2, 3, 4]&#13;
&#13;
<span class="hljs-con-comment"># Which can be unpacked as well of, course</span>&#13;
<span class="hljs-con-meta">&gt;&gt;&gt;</span> a, b, c = eggs&#13;
<span class="hljs-con-meta">&gt;&gt;&gt;</span> c&#13;
4&#13;
&#13;
<span class="hljs-con-comment"># This works for ranges as well</span>&#13;
<span class="hljs-con-meta">&gt;&gt;&gt;</span> spam, *eggs = <span class="hljs-con-built_in">range</span>(<span class="hljs-con-number">10</span>)&#13;
<span class="hljs-con-meta">&gt;&gt;&gt;</span> spam&#13;
0&#13;
<span class="hljs-con-meta">&gt;&gt;&gt;</span> eggs&#13;
[1, 2, 3, 4, 5, 6, 7, 8, 9]&#13;
&#13;
<span class="hljs-con-comment"># And it works both ways</span>&#13;
<span class="hljs-con-meta">&gt;&gt;&gt;</span> a, b, *c = a, *eggs&#13;
<span class="hljs-con-meta">&gt;&gt;&gt;</span> a, b&#13;
(2, 1)&#13;
<span class="hljs-con-meta">&gt;&gt;&gt;</span> c&#13;
[2, 3, 4, 5, 6, 7, 8, 9]&#13;
</code></pre>&#13;
    <p class="normal">Packing and <a id="_idIndexMarker270"/>unpacking can be applied to function arguments:</p>&#13;
    <pre class="programlisting con"><code class="hljs-con"><span class="hljs-con-meta">&gt;&gt;&gt;</span> <span class="hljs-con-keyword">def</span><span class="hljs-con-function"> </span><span class="hljs-con-title">eggs</span><span class="hljs-con-function">(</span><span class="hljs-con-params">*args</span><span class="hljs-con-function">):</span>&#13;
<span class="hljs-con-meta">...</span>     print(<span class="hljs-con-string">'args:'</span>, args)&#13;
&#13;
<span class="hljs-con-meta">&gt;&gt;&gt;</span> eggs(<span class="hljs-con-number">1</span>, <span class="hljs-con-number">2</span>, <span class="hljs-con-number">3</span>)&#13;
args: (1, 2, 3)&#13;
</code></pre>&#13;
    <p class="normal">They are<a id="_idIndexMarker271"/> equally useful when returning from a function:</p>&#13;
    <pre class="programlisting con"><code class="hljs-con"><span class="hljs-con-meta">&gt;&gt;&gt;</span> <span class="hljs-con-keyword">def</span><span class="hljs-con-function"> </span><span class="hljs-con-title">spam_eggs</span><span class="hljs-con-function">():</span>&#13;
<span class="hljs-con-meta">...</span>     <span class="hljs-con-keyword">return</span> <span class="hljs-con-string">'spam'</span>, <span class="hljs-con-string">'eggs'</span>&#13;
&#13;
<span class="hljs-con-meta">&gt;&gt;&gt;</span> spam, eggs = spam_eggs()&#13;
<span class="hljs-con-meta">&gt;&gt;&gt;</span> spam&#13;
'spam'&#13;
<span class="hljs-con-meta">&gt;&gt;&gt;</span> eggs&#13;
'eggs'&#13;
</code></pre>&#13;
    <p class="normal">Now that you have seen the core Python collections and their limitations, you should understand a bit better when certain collections are a good (or bad) idea. And more importantly, if a data structure doesn’t perform as you expect it to, you will understand why.</p>&#13;
    <p class="normal">Unfortunately, often real-world problems are not as simple as the ones you have seen in this chapter, so you will have to weigh up the pros and the cons of the data structures and choose the best solution for your case. Alternatively, you can build a more advanced data structure by combining a few of these structures. Before you start building your own structures, however, keep reading because we will now dive into more advanced collections that do just that: combine the core collections.</p>&#13;
    <h1 id="_idParaDest-113" class="heading-1">Pythonic patterns using advanced collections</h1>&#13;
    <p class="normal">The<a id="_idIndexMarker272"/> following collections are mostly just extensions of base collections; some of them are fairly simple, while others are a bit more advanced. For all of them, though, it is important to know the characteristics of the underlying structures. Without understanding them, it will be difficult to comprehend the characteristics of the collections.</p>&#13;
    <p class="normal">There are a few collections that are implemented in native C code for performance reasons, but all of them can easily be implemented in pure Python as well. The following examples will show you not only the features and characteristics of these collections, but also a few example design patterns where they can be useful. Naturally, this is not an exhaustive list, but it should give you an idea of the possibilities.</p>&#13;
    <h2 id="_idParaDest-114" class="heading-2">Smart data storage with type hinting using dataclasses</h2>&#13;
    <p class="normal">One of the <a id="_idIndexMarker273"/>most useful recent additions to Python (since 3.5) is type hinting. With the type <a id="_idIndexMarker274"/>annotations, you can give type hints to your editor, documentation generator, and others reading your code.</p>&#13;
    <div class="note">&#13;
      <p class="normal">Within Python, we are generally expected to be “consenting adults,” which means the hints are not enforced in any way. This is similar to how private and protected variables in Python are not enforced. This means that we can easily give a completely different type from what our hint would suggest:</p>&#13;
      <pre class="programlisting con"><code class="hljs-con"><span class="hljs-con-meta">&gt;&gt;&gt;</span> spam: int&#13;
<span class="hljs-con-meta">&gt;&gt;&gt;</span> __annotations__['spam']&#13;
&lt;class 'int'&gt;&#13;
&#13;
<span class="hljs-con-meta">&gt;&gt;&gt;</span> spam = 'not a number'&#13;
<span class="hljs-con-meta">&gt;&gt;&gt;</span> __annotations__['spam']&#13;
&lt;class 'int'&gt;&#13;
</code></pre>&#13;
      <p class="normal">Even with the <code class="inlineCode">int</code> type hint, we can still insert a <code class="inlineCode">str</code> if we want to.</p>&#13;
    </div>&#13;
    <p class="normal">The <code class="inlineCode">dataclasses</code> module, which<a id="_idIndexMarker275"/> was introduced in Python 3.7 (backports available for Python 3.6), uses the type hinting system to automatically generate classes, including documentation and constructors based on these types:</p>&#13;
    <pre class="programlisting con"><code class="hljs-con"><span class="hljs-con-meta">&gt;&gt;&gt;</span> <span class="hljs-con-keyword">import</span> dataclasses&#13;
&#13;
<span class="hljs-con-meta">&gt;&gt;&gt;</span> <span class="hljs-con-meta">@dataclasses.dataclass</span>&#13;
<span class="hljs-con-meta">...</span> <span class="hljs-con-keyword">class</span><span class="hljs-con-class"> </span><span class="hljs-con-title">Sandwich</span><span class="hljs-con-class">:</span>&#13;
<span class="hljs-con-meta">...</span>     spam: <span class="hljs-con-built_in">int</span>&#13;
<span class="hljs-con-meta">...</span>     eggs: <span class="hljs-con-built_in">int</span> = <span class="hljs-con-number">3</span>&#13;
&#13;
<span class="hljs-con-meta">&gt;&gt;&gt;</span> Sandwich(<span class="hljs-con-number">1</span>, <span class="hljs-con-number">2</span>)&#13;
Sandwich(spam=1, eggs=2)&#13;
&#13;
<span class="hljs-con-meta">&gt;&gt;&gt;</span> sandwich = Sandwich(<span class="hljs-con-number">4</span>)&#13;
<span class="hljs-con-meta">&gt;&gt;&gt;</span> sandwich&#13;
Sandwich(spam=4, eggs=3)&#13;
<span class="hljs-con-meta">&gt;&gt;&gt;</span> sandwich.eggs&#13;
3&#13;
<span class="hljs-con-meta">&gt;&gt;&gt;</span> dataclasses.asdict(sandwich)&#13;
{'spam': 4, 'eggs': 3}&#13;
<span class="hljs-con-meta">&gt;&gt;&gt;</span> dataclasses.astuple(sandwich)&#13;
(4, 3)&#13;
</code></pre>&#13;
    <p class="normal">The basic class <a id="_idIndexMarker276"/>looks quite simple and like it’s nothing special, but if you look carefully, the <code class="inlineCode">dataclass</code> has generated multiple methods for us. Which ones are generated <a id="_idIndexMarker277"/>becomes obvious when looking at the <code class="inlineCode">dataclass</code> arguments:</p>&#13;
    <pre class="programlisting con"><code class="hljs-con"><span class="hljs-con-meta">&gt;&gt;&gt;</span> <span class="hljs-con-built_in">help</span>(dataclasses.dataclass)&#13;
Help on ... dataclass(..., *, init=True, repr=True, eq=True,&#13;
order=False, unsafe_hash=False, frozen=False) ...&#13;
</code></pre>&#13;
    <p class="normal">As you can see, <code class="inlineCode">dataclass</code> has several Boolean flags that decide what to generate. </p>&#13;
    <p class="normal">First, the <code class="inlineCode">init</code> flag tells <code class="inlineCode">dataclass</code> to create an <code class="inlineCode">__init__</code> method that looks something like this:</p>&#13;
    <pre class="programlisting con"><code class="hljs-con"><span class="hljs-con-meta">&gt;&gt;&gt;</span> <span class="hljs-con-keyword">def</span><span class="hljs-con-function"> </span><span class="hljs-con-title">__init__</span><span class="hljs-con-function">(</span><span class="hljs-con-params">self, spam, eggs=</span><span class="hljs-con-number">3</span><span class="hljs-con-function">):</span>&#13;
<span class="hljs-con-meta">...</span>    self.spam = spam&#13;
<span class="hljs-con-meta">...</span>    self.eggs = eggs&#13;
</code></pre>&#13;
    <p class="normal">Further, <code class="inlineCode">dataclass</code> has flags for:</p>&#13;
    <ul>&#13;
      <li class="bulletList"><code class="inlineCode">repr</code>: This generates a <code class="inlineCode">__repr__</code> magic function that generates a nice and readable output like <code class="inlineCode">Sandwich(spam=1, eggs=2)</code> instead of something like <code class="inlineCode">&lt;__main__.Sandwich object at 0x...&gt;</code>.</li>&#13;
      <li class="bulletList"><code class="inlineCode">eq</code>: This generates an automatic comparison method that compares two instances of <code class="inlineCode">Sandwich</code> by their value when doing <code class="inlineCode">if sandwich_a == sandwich_b</code>.</li>&#13;
      <li class="bulletList"><code class="inlineCode">order</code>: This generates a whole range of methods so that comparison operators such as <code class="inlineCode">&gt;=</code> and <code class="inlineCode">&lt;</code> work by comparing the output of <code class="inlineCode">dataclasses.astuple</code>.</li>&#13;
      <li class="bulletList"><code class="inlineCode">unsafe_hash</code>: This will force the generation of a <code class="inlineCode">__hash__</code> method so that you use the <code class="inlineCode">hash()</code> function on it. By default, a <code class="inlineCode">__hash__</code> function is only generated when all parts of the object are considered immutable. The reason for this is that <code class="inlineCode">hash()</code> should <em class="italic">always</em> be consistent. If you wish to store an object in a <code class="inlineCode">set</code>, it needs to have a consistent hash. Since a <code class="inlineCode">set</code> uses <code class="inlineCode">hash()</code> to decide which memory address to use, if the object changes, the <code class="inlineCode">set</code> would need to move the object as well.</li>&#13;
      <li class="bulletList"><code class="inlineCode">frozen</code>: This will prevent changes after the instance has been created. The main use for this is to make sure the <code class="inlineCode">hash()</code> of the object remains consistent.</li>&#13;
      <li class="bulletList"><code class="inlineCode">slots</code>: This automatically adds a <code class="inlineCode">__slots__</code> attribute which makes attribute access and storage faster and more efficient. More about slots in <em class="chapterRef">Chapter 12</em>, <em class="italic">Performance – Tracking and Reducing Your Memory and CPU Usage</em>.</li>&#13;
    </ul>&#13;
    <p class="normal">The only <a id="_idIndexMarker278"/>flag that adds validation is the <code class="inlineCode">frozen</code> flag, which makes everything <a id="_idIndexMarker279"/>read-only and prevents us from changing the <code class="inlineCode">__setattr__</code> and <code class="inlineCode">__getattr__</code> methods, which could be used to modify the instance otherwise.</p>&#13;
    <p class="normal">The type hinting system still only provides hints; however, these hints are not enforced in any way. In <em class="chapterRef">Chapter 6</em>, <em class="italic">Decorators – Enabling Code Reuse by Decorating</em>, you will see how we can add these types of enforcements to our code using custom decorators. </p>&#13;
    <p class="normal">For a more useful example that includes dependence, let’s say that we have some users who all belong to one or multiple groups in a system:</p>&#13;
    <pre class="programlisting con"><code class="hljs-con"><span class="hljs-con-meta">&gt;&gt;&gt;</span> <span class="hljs-con-keyword">import</span> typing&#13;
&#13;
<span class="hljs-con-meta">&gt;&gt;&gt;</span> <span class="hljs-con-meta">@dataclasses.dataclass</span>&#13;
<span class="hljs-con-meta">...</span> <span class="hljs-con-keyword">class</span><span class="hljs-con-class"> </span><span class="hljs-con-title">Group</span><span class="hljs-con-class">:</span>&#13;
<span class="hljs-con-meta">...</span>     name: <span class="hljs-con-built_in">str</span>&#13;
<span class="hljs-con-meta">...</span>     parent: <span class="hljs-con-string">'Group'</span> = <span class="hljs-con-literal">None</span>&#13;
&#13;
<span class="hljs-con-meta">&gt;&gt;&gt;</span> <span class="hljs-con-meta">@dataclasses.dataclass</span>&#13;
<span class="hljs-con-meta">...</span> <span class="hljs-con-keyword">class</span><span class="hljs-con-class"> </span><span class="hljs-con-title">User</span><span class="hljs-con-class">:</span>&#13;
<span class="hljs-con-meta">...</span>     username: <span class="hljs-con-built_in">str</span>&#13;
<span class="hljs-con-meta">...</span>     email: <span class="hljs-con-built_in">str</span> = <span class="hljs-con-literal">None</span>&#13;
<span class="hljs-con-meta">...</span>     groups: typing.List[Group] = <span class="hljs-con-literal">None</span>&#13;
&#13;
<span class="hljs-con-meta">&gt;&gt;&gt;</span> users = Group(<span class="hljs-con-string">'users'</span>)&#13;
<span class="hljs-con-meta">&gt;&gt;&gt;</span> admins = Group(<span class="hljs-con-string">'admins'</span>, users)&#13;
<span class="hljs-con-meta">&gt;&gt;&gt;</span> rick = User(<span class="hljs-con-string">'rick'</span>, groups=[admins])&#13;
<span class="hljs-con-meta">&gt;&gt;&gt;</span> gvr = User(<span class="hljs-con-string">'gvanrossum'</span>, <span class="hljs-con-string">'guido@python.org'</span>, [admins])&#13;
&#13;
<span class="hljs-con-meta">&gt;&gt;&gt;</span> rick.groups&#13;
[Group(name='admins', parent=Group(name='users', parent=None))]&#13;
&#13;
<span class="hljs-con-meta">&gt;&gt;&gt;</span> rick.groups[<span class="hljs-con-number">0</span>].parent&#13;
Group(name='users', parent=None)&#13;
</code></pre>&#13;
    <p class="normal">In addition to linking dataclasses to each other, this also shows how to create a collection <a id="_idIndexMarker280"/>as a field and how to have recursive definitions. As you can see, the <code class="inlineCode">Group</code> class references its own definition as a parent.</p>&#13;
    <p class="normal">These dataclasses are especially <a id="_idIndexMarker281"/>useful when used for reading data from databases or CSV files. You can easily extend the behavior of dataclasses to include custom methods, which makes them a very useful basis for storing your custom data models.</p>&#13;
    <h2 id="_idParaDest-115" class="heading-2">Combining multiple scopes with ChainMap</h2>&#13;
    <p class="normal">Introduced<a id="_idIndexMarker282"/> in Python 3.3, <code class="inlineCode">ChainMap</code> allows you to combine multiple mappings (dictionaries, for example) into one. This <a id="_idIndexMarker283"/>is especially useful when combining multiple contexts. For example, when looking for a variable in your current scope, by default, Python will search in <code class="inlineCode">locals()</code>, <code class="inlineCode">globals()</code>, and, lastly, <code class="inlineCode">builtins</code>.</p>&#13;
    <p class="normal">To explicitly write code to do this, we could do something like this:</p>&#13;
    <pre class="programlisting con"><code class="hljs-con"><span class="hljs-con-meta">&gt;&gt;&gt;</span> <span class="hljs-con-keyword">import</span> builtins&#13;
&#13;
<span class="hljs-con-meta">&gt;&gt;&gt;</span> builtin_vars = <span class="hljs-con-built_in">vars</span>(builtins)&#13;
&#13;
<span class="hljs-con-meta">&gt;&gt;&gt;</span> key = <span class="hljs-con-string">'something to search for'</span>&#13;
&#13;
<span class="hljs-con-meta">&gt;&gt;&gt;</span> <span class="hljs-con-keyword">if</span> key <span class="hljs-con-keyword">in</span> <span class="hljs-con-built_in">locals</span>():&#13;
<span class="hljs-con-meta">...</span>     value = <span class="hljs-con-built_in">locals</span>()[key]&#13;
<span class="hljs-con-meta">...</span> <span class="hljs-con-keyword">elif</span> key <span class="hljs-con-keyword">in</span> <span class="hljs-con-built_in">globals</span>():&#13;
<span class="hljs-con-meta">...</span>     value = <span class="hljs-con-built_in">globals</span>()[key]&#13;
<span class="hljs-con-meta">...</span> <span class="hljs-con-keyword">elif</span> key <span class="hljs-con-keyword">in</span> builtin_vars:&#13;
<span class="hljs-con-meta">...</span>     value = builtin_vars[key]&#13;
<span class="hljs-con-meta">...</span> <span class="hljs-con-keyword">else</span>:&#13;
<span class="hljs-con-meta">...</span>     <span class="hljs-con-keyword">raise</span> NameError(<span class="hljs-con-string">f'name </span><span class="hljs-con-subst">{key!r}</span><span class="hljs-con-string"> is not defined'</span>)&#13;
Traceback (most recent call last):&#13;
<span class="hljs-con-meta">...</span>&#13;
NameError: name 'something to search for' is not defined&#13;
</code></pre>&#13;
    <p class="normal">This <a id="_idIndexMarker284"/>works, but it’s ugly to say the least. We can make it prettier by removing some of the repeated code:</p>&#13;
    <pre class="programlisting con"><code class="hljs-con"><span class="hljs-con-meta">&gt;&gt;&gt;</span> mappings = <span class="hljs-con-built_in">locals</span>(), <span class="hljs-con-built_in">globals</span>(), <span class="hljs-con-built_in">vars</span>(builtins)&#13;
&#13;
<span class="hljs-con-meta">&gt;&gt;&gt;</span> <span class="hljs-con-keyword">for</span> mapping <span class="hljs-con-keyword">in</span> mappings:&#13;
<span class="hljs-con-meta">...</span>     <span class="hljs-con-keyword">if</span> key <span class="hljs-con-keyword">in</span> mapping:&#13;
<span class="hljs-con-meta">...</span>         value = mapping[key]&#13;
<span class="hljs-con-meta">...</span>         <span class="hljs-con-keyword">break</span>&#13;
<span class="hljs-con-meta">...</span> <span class="hljs-con-keyword">else</span>:&#13;
<span class="hljs-con-meta">...</span>     <span class="hljs-con-keyword">raise</span> NameError(<span class="hljs-con-string">f'name </span><span class="hljs-con-subst">{key!r}</span><span class="hljs-con-string"> is not defined'</span>)&#13;
Traceback (most recent call last):&#13;
<span class="hljs-con-meta">...</span>&#13;
NameError: name 'something to search for' is not defined&#13;
</code></pre>&#13;
    <p class="normal">That’s a lot better! Moreover, this<a id="_idIndexMarker285"/> can actually be considered a nice solution. But since Python 3.3, it’s even easier. Now, we can simply use the following code:</p>&#13;
    <pre class="programlisting con"><code class="hljs-con"><span class="hljs-con-meta">&gt;&gt;&gt;</span> <span class="hljs-con-keyword">import</span> collections&#13;
&#13;
<span class="hljs-con-meta">&gt;&gt;&gt;</span> mappings = collections.ChainMap(&#13;
<span class="hljs-con-meta">...</span>     <span class="hljs-con-built_in">locals</span>(), <span class="hljs-con-built_in">globals</span>(), <span class="hljs-con-built_in">vars</span>(builtins))&#13;
<span class="hljs-con-meta">&gt;&gt;&gt;</span> mappings[key]&#13;
Traceback (most recent call last):&#13;
<span class="hljs-con-meta">...</span>&#13;
KeyError: 'something to search for'&#13;
</code></pre>&#13;
    <p class="normal">As you can see, the <code class="inlineCode">ChainMap</code> class is automatically coalescing the requested value through every given <code class="inlineCode">dict</code> until it finds a match. And if the value is not available, a <code class="inlineCode">KeyError</code> is raised since it behaves like a <code class="inlineCode">dict</code>.</p>&#13;
    <p class="normal">This is very useful for reading configurations from multiple sources and simply getting the first matching item. For a command-line application, this could start with the command-line arguments, followed by the local configuration file, followed by the global configuration file, and lastly the defaults. To illustrate a bit of code similar to what I use in small command-line scripts:</p>&#13;
    <pre class="programlisting con"><code class="hljs-con"><span class="hljs-con-meta">&gt;&gt;&gt;</span> <span class="hljs-con-keyword">import</span> json&#13;
<span class="hljs-con-meta">&gt;&gt;&gt;</span> <span class="hljs-con-keyword">import</span> pathlib&#13;
<span class="hljs-con-meta">&gt;&gt;&gt;</span> <span class="hljs-con-keyword">import</span> argparse&#13;
<span class="hljs-con-meta">&gt;&gt;&gt;</span> <span class="hljs-con-keyword">import</span> collections&#13;
&#13;
<span class="hljs-con-meta">&gt;&gt;&gt;</span> DEFAULT = <span class="hljs-con-built_in">dict</span>(verbosity=<span class="hljs-con-number">1</span>)&#13;
&#13;
<span class="hljs-con-meta">&gt;&gt;&gt;</span> config_file = pathlib.Path(<span class="hljs-con-string">'config.json'</span>)&#13;
<span class="hljs-con-meta">&gt;&gt;&gt;</span> <span class="hljs-con-keyword">if</span> config_file.exists():&#13;
<span class="hljs-con-meta">...</span>     config = json.load(config_file.<span class="hljs-con-built_in">open</span>())&#13;
<span class="hljs-con-meta">...</span> <span class="hljs-con-keyword">else</span>:&#13;
<span class="hljs-con-meta">...</span>     config = <span class="hljs-con-built_in">dict</span>()&#13;
&#13;
<span class="hljs-con-meta">&gt;&gt;&gt;</span> parser = argparse.ArgumentParser()&#13;
<span class="hljs-con-meta">&gt;&gt;&gt;</span> parser.add_argument(<span class="hljs-con-string">'-v'</span>, <span class="hljs-con-string">'</span><span class="hljs-con-string">--verbose'</span>, action=<span class="hljs-con-string">'count'</span>,&#13;
<span class="hljs-con-meta">...</span>                     dest=<span class="hljs-con-string">'verbosity'</span>)&#13;
_CountAction(...)&#13;
&#13;
<span class="hljs-con-meta">&gt;&gt;&gt;</span> args, _ = parser.parse_known_args()&#13;
<span class="hljs-con-meta">&gt;&gt;&gt;</span> defined_args = {k: v <span class="hljs-con-keyword">for</span> k, v <span class="hljs-con-keyword">in</span> <span class="hljs-con-built_in">vars</span>(args).items() <span class="hljs-con-keyword">if</span> v}&#13;
<span class="hljs-con-meta">&gt;&gt;&gt;</span> combined = collections.ChainMap(defined_args, config, DEFAULT)&#13;
<span class="hljs-con-meta">&gt;&gt;&gt;</span> combined[<span class="hljs-con-string">'verbosity'</span>]&#13;
1&#13;
&#13;
<span class="hljs-con-meta">&gt;&gt;&gt;</span> args, _ = parser.parse_known_args([<span class="hljs-con-string">'</span><span class="hljs-con-string">-vv'</span>])&#13;
<span class="hljs-con-meta">&gt;&gt;&gt;</span> defined_args = {k: v <span class="hljs-con-keyword">for</span> k, v <span class="hljs-con-keyword">in</span> <span class="hljs-con-built_in">vars</span>(args).items() <span class="hljs-con-keyword">if</span> v}&#13;
<span class="hljs-con-meta">&gt;&gt;&gt;</span> combined = collections.ChainMap(defined_args, config, DEFAULT)&#13;
<span class="hljs-con-meta">&gt;&gt;&gt;</span> combined[<span class="hljs-con-string">'verbosity'</span>]&#13;
2&#13;
</code></pre>&#13;
    <p class="normal">The<a id="_idIndexMarker286"/> inheritance <a id="_idIndexMarker287"/>can clearly be seen here. When a specific command-line argument is given (<code class="inlineCode">-vv</code>), that result is used. Otherwise, the code falls back to the one in <code class="inlineCode">DEFAULTS</code> or any other available variable.</p>&#13;
    <h2 id="_idParaDest-116" class="heading-2">Default dictionary values using defaultdict</h2>&#13;
    <p class="normal">The <code class="inlineCode">defaultdict</code> is <a id="_idIndexMarker288"/>one <a id="_idIndexMarker289"/>of my favorite objects in the <code class="inlineCode">collections</code> package. Before it was added to the core, I wrote similar objects several times. While it is a <a id="_idIndexMarker290"/>fairly simple object, it is extremely useful for all sorts of design patterns. Instead of having to check for the existence of a key and adding a value every time, you can just declare the default from the beginning, and there is no need to worry about the rest.</p>&#13;
    <p class="normal">For example, let’s say we are building a very basic graph structure from a list of connected nodes.</p>&#13;
    <p class="normal">This is our list of connected nodes (one way):</p>&#13;
    <pre class="programlisting code"><code class="hljs-code">nodes = [&#13;
    ('a', 'b'),&#13;
    ('a', 'c'),&#13;
    ('b', 'a'),&#13;
    ('b', 'd'),&#13;
    ('c', 'a'),&#13;
    ('d', 'a'),&#13;
    ('d', 'b'),&#13;
    ('d', 'c'),&#13;
]&#13;
</code></pre>&#13;
    <p class="normal">Now, let’s put this graph into a normal dictionary:</p>&#13;
    <pre class="programlisting con"><code class="hljs-con"><span class="hljs-con-meta">&gt;&gt;&gt;</span> graph = <span class="hljs-con-built_in">dict</span>()&#13;
<span class="hljs-con-meta">&gt;&gt;&gt;</span> <span class="hljs-con-keyword">for</span> from_, to <span class="hljs-con-keyword">in</span> nodes:&#13;
<span class="hljs-con-meta">...</span>     <span class="hljs-con-keyword">if</span> from_ <span class="hljs-con-keyword">not</span> <span class="hljs-con-keyword">in</span> graph:&#13;
<span class="hljs-con-meta">...</span>         graph[from_] = []&#13;
<span class="hljs-con-meta">...</span>     graph[from_].append(to)&#13;
&#13;
<span class="hljs-con-meta">&gt;&gt;&gt;</span> <span class="hljs-con-keyword">import</span> pprint&#13;
&#13;
<span class="hljs-con-meta">&gt;&gt;&gt;</span> pprint.pprint(graph)&#13;
{'a': ['b', 'c'],&#13;
 'b': ['a', 'd'],&#13;
 'c': ['a'],&#13;
 'd': ['a', 'b', 'c']}&#13;
</code></pre>&#13;
    <p class="normal">Some variations are possible, of course, such as using <code class="inlineCode">setdefault</code>. However, they remain more complex than they need to be.</p>&#13;
    <p class="normal">The truly Pythonic version uses <code class="inlineCode">defaultdict</code> instead:</p>&#13;
    <pre class="programlisting con"><code class="hljs-con"><span class="hljs-con-meta">&gt;&gt;&gt;</span> <span class="hljs-con-keyword">import</span> collections&#13;
&#13;
<span class="hljs-con-meta">&gt;&gt;&gt;</span> graph = collections.defaultdict(<span class="hljs-con-built_in">list</span>)&#13;
<span class="hljs-con-meta">&gt;&gt;&gt;</span> <span class="hljs-con-keyword">for</span> from_, to <span class="hljs-con-keyword">in</span> nodes:&#13;
<span class="hljs-con-meta">...</span>     graph[from_].append(to)&#13;
&#13;
<span class="hljs-con-meta">&gt;&gt;&gt;</span> <span class="hljs-con-keyword">import</span> pprint&#13;
&#13;
<span class="hljs-con-meta">&gt;&gt;&gt;</span> pprint.pprint(graph)&#13;
defaultdict(&lt;class 'list'&gt;,&#13;
            {'a': ['b', 'c'],&#13;
             'b': ['a', 'd'],&#13;
             'c': ['a'],&#13;
             'd': ['a', 'b', 'c']})&#13;
</code></pre>&#13;
    <p class="normal">Isn’t that<a id="_idIndexMarker291"/> a beautiful bit of code? The <code class="inlineCode">defaultdict</code> can also be used as a basic version of the <code class="inlineCode">Counter</code> object. It’s <a id="_idIndexMarker292"/>not as fancy and doesn’t have all the bells and whistles that <code class="inlineCode">Counter</code> has, but it does the job in many cases:</p>&#13;
    <pre class="programlisting con"><code class="hljs-con"><span class="hljs-con-meta">&gt;&gt;&gt;</span> counter = collections.defaultdict(<span class="hljs-con-built_in">int</span>)&#13;
<span class="hljs-con-meta">&gt;&gt;&gt;</span> counter[<span class="hljs-con-string">'spam'</span>] += <span class="hljs-con-number">5</span>&#13;
<span class="hljs-con-meta">&gt;&gt;&gt;</span> counter&#13;
defaultdict(&lt;class 'int'&gt;, {'spam': 5})&#13;
</code></pre>&#13;
    <p class="normal">The default value for <code class="inlineCode">defaultdict</code> needs to be a callable object. In the previous cases, these were <code class="inlineCode">int</code> and <code class="inlineCode">list</code>, but you can easily define your own functions to use as a default value. That’s what the following example uses, although I don’t recommend production usage since it lacks a bit of readability. I do believe, however, that it is a beautiful example of the power of Python.</p>&#13;
    <p class="normal">This is how we create a <code class="inlineCode">tree</code> in a single line of Python:</p>&#13;
    <pre class="programlisting code"><code class="hljs-code"><span class="hljs-keyword">import</span> collections&#13;
<span class="hljs-keyword">def</span> <span class="hljs-title">tree</span>(): return collections.defaultdict(tree)&#13;
</code></pre>&#13;
    <p class="normal">Brilliant, isn’t it? Here’s how we can actually use it:</p>&#13;
    <pre class="programlisting con"><code class="hljs-con"><span class="hljs-con-meta">&gt;&gt;&gt;</span> <span class="hljs-con-keyword">import</span> json&#13;
<span class="hljs-con-meta">&gt;&gt;&gt;</span> <span class="hljs-con-keyword">import</span> collections&#13;
&#13;
<span class="hljs-con-meta">&gt;&gt;&gt;</span> <span class="hljs-con-keyword">def</span><span class="hljs-con-function"> </span><span class="hljs-con-title">tree</span><span class="hljs-con-function">():</span>&#13;
<span class="hljs-con-meta">...</span>     <span class="hljs-con-keyword">return</span> collections.defaultdict(tree)&#13;
&#13;
<span class="hljs-con-meta">&gt;&gt;&gt;</span> colours = tree()&#13;
<span class="hljs-con-meta">&gt;&gt;&gt;</span> colours[<span class="hljs-con-string">'other'</span>][<span class="hljs-con-string">'black'</span>] = <span class="hljs-con-number">0x000000</span>&#13;
<span class="hljs-con-meta">&gt;&gt;&gt;</span> colours[<span class="hljs-con-string">'other'</span>][<span class="hljs-con-string">'white'</span>] = <span class="hljs-con-number">0xFFFFFF</span>&#13;
<span class="hljs-con-meta">&gt;&gt;&gt;</span> colours[<span class="hljs-con-string">'primary'</span>][<span class="hljs-con-string">'red'</span>] = <span class="hljs-con-number">0xFF0000</span>&#13;
<span class="hljs-con-meta">&gt;&gt;&gt;</span> colours[<span class="hljs-con-string">'primary'</span>][<span class="hljs-con-string">'green'</span>] = <span class="hljs-con-number">0x00FF00</span>&#13;
<span class="hljs-con-meta">&gt;&gt;&gt;</span> colours[<span class="hljs-con-string">'primary'</span>][<span class="hljs-con-string">'blue'</span>] = <span class="hljs-con-number">0x0000FF</span>&#13;
<span class="hljs-con-meta">&gt;&gt;&gt;</span> colours[<span class="hljs-con-string">'secondary'</span>][<span class="hljs-con-string">'yellow'</span>] = <span class="hljs-con-number">0xFFFF00</span>&#13;
<span class="hljs-con-meta">&gt;&gt;&gt;</span> colours[<span class="hljs-con-string">'secondary'</span>][<span class="hljs-con-string">'aqua'</span>] = <span class="hljs-con-number">0x00FFFF</span>&#13;
<span class="hljs-con-meta">&gt;&gt;&gt;</span> colours[<span class="hljs-con-string">'</span><span class="hljs-con-string">secondary'</span>][<span class="hljs-con-string">'fuchsia'</span>] = <span class="hljs-con-number">0xFF00FF</span>&#13;
&#13;
<span class="hljs-con-meta">&gt;&gt;&gt;</span> print(json.dumps(colours, sort_keys=<span class="hljs-con-literal">True</span>, indent=<span class="hljs-con-number">4</span>))&#13;
{&#13;
    "other": {&#13;
        "black": 0,&#13;
        "white": 16777215&#13;
    },&#13;
    "primary": {&#13;
        "blue": 255,&#13;
        "green": 65280,&#13;
        "red": 16711680&#13;
    },&#13;
    "secondary": {&#13;
        "aqua": 65535,&#13;
        "fuchsia": 16711935,&#13;
        "yellow": 16776960&#13;
    }&#13;
}&#13;
</code></pre>&#13;
    <p class="normal">The <a id="_idIndexMarker293"/>nice thing<a id="_idIndexMarker294"/> is that you can make it go as deep as you like. Because of the <code class="inlineCode">defaultdict</code> base, it generates itself recursively.</p>&#13;
    <h2 id="_idParaDest-117" class="heading-2">enum – A group of constants</h2>&#13;
    <p class="normal">The <code class="inlineCode">enum</code> package<a id="_idIndexMarker295"/> introduced<a id="_idIndexMarker296"/> in Python 3.4 is quite similar in its workings to enums in many other programming languages, such as C and C++. It helps to create reusable constants for your module so you can avoid arbitrary constants. A basic example is as follows:</p>&#13;
    <pre class="programlisting con"><code class="hljs-con"><span class="hljs-con-meta">&gt;&gt;&gt;</span> <span class="hljs-con-keyword">import</span> enum&#13;
&#13;
<span class="hljs-con-meta">&gt;&gt;&gt;</span> <span class="hljs-con-keyword">class</span><span class="hljs-con-class"> </span><span class="hljs-con-title">Color</span><span class="hljs-con-class">(</span><span class="hljs-con-params">enum.Enum</span><span class="hljs-con-class">):</span>&#13;
<span class="hljs-con-meta">...</span>     red = <span class="hljs-con-number">1</span>&#13;
<span class="hljs-con-meta">...</span>     green = <span class="hljs-con-number">2</span>&#13;
<span class="hljs-con-meta">...</span>     blue = <span class="hljs-con-number">3</span>&#13;
&#13;
<span class="hljs-con-meta">&gt;&gt;&gt;</span> Color.red&#13;
&lt;Color.red: 1&gt;&#13;
<span class="hljs-con-meta">&gt;&gt;&gt;</span> Color[<span class="hljs-con-string">'red'</span>]&#13;
&lt;Color.red: 1&gt;&#13;
<span class="hljs-con-meta">&gt;&gt;&gt;</span> Color(<span class="hljs-con-number">1</span>)&#13;
&lt;Color.red: 1&gt;&#13;
<span class="hljs-con-meta">&gt;&gt;&gt;</span> Color.red.name&#13;
'red'&#13;
<span class="hljs-con-meta">&gt;&gt;&gt;</span> Color.red.value&#13;
1&#13;
<span class="hljs-con-meta">&gt;&gt;&gt;</span> <span class="hljs-con-built_in">isinstance</span>(Color.red, Color)&#13;
True&#13;
<span class="hljs-con-meta">&gt;&gt;&gt;</span> Color.red <span class="hljs-con-keyword">is</span> Color[<span class="hljs-con-string">'red'</span>]&#13;
True&#13;
<span class="hljs-con-meta">&gt;&gt;&gt;</span> Color.red <span class="hljs-con-keyword">is</span> Color(<span class="hljs-con-number">1</span>)&#13;
True&#13;
</code></pre>&#13;
    <p class="normal">A few <a id="_idIndexMarker297"/>of the handy features <a id="_idIndexMarker298"/>of the <code class="inlineCode">enum</code> package are that the objects are iterable, accessible through both numeric and textual representation of the values, and, with proper inheritance, even comparable to other classes.</p>&#13;
    <p class="normal">The following code shows the usage of a basic API:</p>&#13;
    <pre class="programlisting con"><code class="hljs-con"><span class="hljs-con-meta">&gt;&gt;&gt;</span> <span class="hljs-con-keyword">for</span> color <span class="hljs-con-keyword">in</span> Color:&#13;
<span class="hljs-con-meta">...</span>     color&#13;
&lt;Color.red: 1&gt;&#13;
&lt;Color.green: 2&gt;&#13;
&lt;Color.blue: 3&gt;&#13;
&#13;
<span class="hljs-con-meta">&gt;&gt;&gt;</span> colors = <span class="hljs-con-built_in">dict</span>()&#13;
<span class="hljs-con-meta">&gt;&gt;&gt;</span> colors[Color.green] = <span class="hljs-con-number">0x00FF00</span>&#13;
<span class="hljs-con-meta">&gt;&gt;&gt;</span> colors&#13;
{&lt;Color.green: 2&gt;: 65280}&#13;
</code></pre>&#13;
    <p class="normal">One of the lesser-known possibilities of the <code class="inlineCode">enum</code> package is that you can make value comparisons<a id="_idIndexMarker299"/> work in addition to the identity comparisons you would normally use. And this works for every type—not just integers but (your own) custom types as well.</p>&#13;
    <p class="normal">With a regular <code class="inlineCode">enum</code>, only an identity check (that is, <code class="inlineCode">a is b</code>) works:</p>&#13;
    <pre class="programlisting con"><code class="hljs-con"><span class="hljs-con-meta">&gt;&gt;&gt;</span> <span class="hljs-con-keyword">import</span> enum&#13;
&#13;
<span class="hljs-con-meta">&gt;&gt;&gt;</span> <span class="hljs-con-keyword">class</span><span class="hljs-con-class"> </span><span class="hljs-con-title">Spam</span><span class="hljs-con-class">(</span><span class="hljs-con-params">enum.Enum</span><span class="hljs-con-class">):</span>&#13;
<span class="hljs-con-meta">...</span>     EGGS = <span class="hljs-con-string">'eggs'</span>&#13;
&#13;
<span class="hljs-con-meta">&gt;&gt;&gt;</span> Spam.EGGS == <span class="hljs-con-string">'eggs'</span>&#13;
False&#13;
</code></pre>&#13;
    <p class="normal">When <a id="_idIndexMarker300"/>we make the <code class="inlineCode">enum</code> inherit <code class="inlineCode">str</code> as well, it starts comparing the values in addition to the identity:</p>&#13;
    <pre class="programlisting con"><code class="hljs-con"><span class="hljs-con-meta">&gt;&gt;&gt;</span> <span class="hljs-con-keyword">import</span> enum&#13;
&#13;
<span class="hljs-con-meta">&gt;&gt;&gt;</span> <span class="hljs-con-keyword">class</span><span class="hljs-con-class"> </span><span class="hljs-con-title">Spam</span><span class="hljs-con-class">(</span><span class="hljs-con-built_in">str</span><span class="hljs-con-params">, enum.Enum</span><span class="hljs-con-class">):</span>&#13;
<span class="hljs-con-meta">...</span>     EGGS = <span class="hljs-con-string">'eggs'</span>&#13;
&#13;
<span class="hljs-con-meta">&gt;&gt;&gt;</span> Spam.EGGS == <span class="hljs-con-string">'eggs'</span>&#13;
True&#13;
</code></pre>&#13;
    <p class="normal">In addition to the preceding examples, the <code class="inlineCode">enum</code> package has a few other variants such as <code class="inlineCode">enum.Flag</code> and <code class="inlineCode">enum.IntFlag</code>, which allow for bitwise operations. These can be useful for representing permissions as follows: <code class="inlineCode">permissions = Perm.READ | Perm.Write</code>.</p>&#13;
    <p class="normal">Whenever you have a list of constants that can be grouped together, consider using the <code class="inlineCode">enum</code> package. It makes validation much cleaner than having to use <code class="inlineCode">if/elif/elif/else</code> several times.</p>&#13;
    <h2 id="_idParaDest-118" class="heading-2">Sorting collections using heapq</h2>&#13;
    <p class="normal">The <code class="inlineCode">heapq</code> module is a<a id="_idIndexMarker301"/> great<a id="_idIndexMarker302"/> little module that makes it very easy to create a priority queue in Python. It is a data structure that will always make the smallest (or largest, depending on the implementation) item available with minimum effort. The API is quite simple, and one of the best examples of its usage can be seen in the <code class="inlineCode">OrderedDict</code> object. While <a id="_idIndexMarker303"/>you might not need it often, it is a very useful structure if you need it. And understanding the inner workings is important if you wish to understand the workings of classes such as <code class="inlineCode">OrderedDict</code>.</p>&#13;
    <div class="packt_tip">&#13;
      <p class="normal">If you are looking for a structure to keep your list always sorted, try the <code class="inlineCode">bisect</code> module instead, which is covered in the next section.</p>&#13;
    </div>&#13;
    <p class="normal">The basic usage of <code class="inlineCode">heapq</code> is simple but somewhat confusing initially:</p>&#13;
    <pre class="programlisting con"><code class="hljs-con"><span class="hljs-con-meta">&gt;&gt;&gt;</span> <span class="hljs-con-keyword">import</span> heapq&#13;
&#13;
<span class="hljs-con-meta">&gt;&gt;&gt;</span> heap = [<span class="hljs-con-number">1</span>, <span class="hljs-con-number">3</span>, <span class="hljs-con-number">5</span>, <span class="hljs-con-number">7</span>, <span class="hljs-con-number">2</span>, <span class="hljs-con-number">4</span>, <span class="hljs-con-number">3</span>]&#13;
<span class="hljs-con-meta">&gt;&gt;&gt;</span> heapq.heapify(heap)&#13;
<span class="hljs-con-meta">&gt;&gt;&gt;</span> heap&#13;
[1, 2, 3, 7, 3, 4, 5]&#13;
&#13;
<span class="hljs-con-meta">&gt;&gt;&gt;</span> <span class="hljs-con-keyword">while</span> heap:&#13;
<span class="hljs-con-meta">...</span>     heapq.heappop(heap), heap&#13;
(1, [2, 3, 3, 7, 5, 4])&#13;
(2, [3, 3, 4, 7, 5])&#13;
(3, [3, 5, 4, 7])&#13;
(3, [4, 5, 7])&#13;
(4, [5, 7])&#13;
(5, [7])&#13;
(7, [])&#13;
</code></pre>&#13;
    <p class="normal">One<a id="_idIndexMarker304"/> important thing to note here—something that you have probably already understood from the preceding example—is that the <code class="inlineCode">heapq</code> module does not create a special object. It consists of a few methods to treat a regular list as a <code class="inlineCode">heap</code>. That doesn’t make it less useful, but it is something to take into consideration.</p>&#13;
    <p class="normal">The really confusing part, at first glance, is the sort order. The array is actually sorted but not as a list; it is sorted as a tree. To illustrate this, take a look at the following tree, which shows how the tree is supposed to be read:</p>&#13;
    <pre class="programlisting con"><code class="hljs-con">   1&#13;
 2   3&#13;
7 3 4 5&#13;
</code></pre>&#13;
    <p class="normal">The smallest <a id="_idIndexMarker305"/>number is always at the top and the biggest numbers are always at the bottom row of the tree. Because of that, it’s really easy to find the smallest number, but finding the largest is not as easy. To get the sorted version of the heap, we simply need to keep removing the top of the tree until all the items are gone. Therefore, the heapsort algorithm can be implemented as follows:</p>&#13;
    <pre class="programlisting con"><code class="hljs-con"><span class="hljs-con-meta">&gt;&gt;&gt;</span> <span class="hljs-con-keyword">def</span><span class="hljs-con-function"> </span><span class="hljs-con-title">heapsort</span><span class="hljs-con-function">(</span><span class="hljs-con-params">iterable</span><span class="hljs-con-function">):</span>&#13;
<span class="hljs-con-meta">...</span>     heap = []&#13;
<span class="hljs-con-meta">...</span>     <span class="hljs-con-keyword">for</span> value <span class="hljs-con-keyword">in</span> iterable:&#13;
<span class="hljs-con-meta">...</span>         heapq.heappush(heap, value)&#13;
<span class="hljs-con-meta">...</span>&#13;
<span class="hljs-con-meta">...</span>     <span class="hljs-con-keyword">while</span> heap:&#13;
<span class="hljs-con-meta">...</span>         <span class="hljs-con-keyword">yield</span> heapq.heappop(heap)&#13;
&#13;
<span class="hljs-con-meta">&gt;&gt;&gt;</span> <span class="hljs-con-built_in">list</span>(heapsort([<span class="hljs-con-number">1</span>, <span class="hljs-con-number">3</span>, <span class="hljs-con-number">5</span>, <span class="hljs-con-number">2</span>, <span class="hljs-con-number">4</span>, <span class="hljs-con-number">1</span>]))&#13;
[1, 1, 2, 3, 4, 5]&#13;
</code></pre>&#13;
    <p class="normal">With <code class="inlineCode">heapq</code> doing the heavy lifting, it becomes incredibly easy to write your own version of the <code class="inlineCode">sorted()</code> function.</p>&#13;
    <p class="normal">Since the <code class="inlineCode">heappush</code> and <code class="inlineCode">heappop</code> functions both have <code class="inlineCode">O(log(n))</code> time complexity, they can be considered really fast. Combining those for the <code class="inlineCode">n</code> items in the preceding iterable gives us <code class="inlineCode">O(n*log(n))</code> for the <code class="inlineCode">heapsort</code> function. The <code class="inlineCode">heappush</code> method uses <code class="inlineCode">list.append()</code> internally and swaps the items in the <code class="inlineCode">list</code> to avoid the <code class="inlineCode">O(n)</code> time complexity of <code class="inlineCode">list.insert()</code>.</p>&#13;
    <div class="note">&#13;
      <p class="normal">The <code class="inlineCode">log(n)</code> refers to the base 2 logarithm function. To calculate this value, the <code class="inlineCode">math.log2()</code> function can be used. This results in an increase of 1 every time the number doubles in size. For <code class="inlineCode">n=2</code>, the value of <code class="inlineCode">log(n)</code> is <code class="inlineCode">1</code>, and consequently for <code class="inlineCode">n=4</code> and <code class="inlineCode">n=8</code>, the log values are <code class="inlineCode">2</code> and <code class="inlineCode">3</code>, respectively. And <code class="inlineCode">n=1024</code> results in a log of only <code class="inlineCode">10</code>.</p>&#13;
      <p class="normal">This means that a 32-bit number, which is <code class="inlineCode">2**32 = 4294967296</code>, has a log of <code class="inlineCode">32</code>.</p>&#13;
    </div>&#13;
    <h2 id="_idParaDest-119" class="heading-2">Searching through sorted collections using bisect</h2>&#13;
    <p class="normal">The <code class="inlineCode">heapq</code> module in the<a id="_idIndexMarker306"/> previous section gave us an easy way to sort a structure and keep it sorted. But what if we<a id="_idIndexMarker307"/> want to search through a sorted collection to see whether the item exists? Or what’s the next biggest/smallest item if it doesn’t? That’s where the <code class="inlineCode">bisect</code> algorithm helps us.</p>&#13;
    <p class="normal">The <code class="inlineCode">bisect</code> module <a id="_idIndexMarker308"/>inserts items in an object in such a way that they stay sorted and are easily searchable. If your primary purpose is searching, then <code class="inlineCode">bisect</code> should be your choice. If you’re modifying your collection a lot, <code class="inlineCode">heapq</code> might be better for you.</p>&#13;
    <p class="normal">As is the case with <code class="inlineCode">heapq</code>, <code class="inlineCode">bisect</code> does not really create a special data structure. The <code class="inlineCode">bisect</code> module expects a <code class="inlineCode">list</code> and expects that <code class="inlineCode">list</code> to always be sorted. It is important to understand the performance implications of this. While appending items to a <code class="inlineCode">list</code> has <code class="inlineCode">O(1)</code> time complexity, inserting has <code class="inlineCode">O(n)</code> time complexity, making it a very heavy operation. Effectively, creating a sorted list using bisect takes <code class="inlineCode">O(n*n)</code>, which is quite slow, especially because creating the same sorted list using <code class="inlineCode">heapq</code> or <code class="inlineCode">sorted()</code> takes <code class="inlineCode">O(n*log(n))</code> instead.</p>&#13;
    <p class="normal">If you have a sorted structure and you only need to add a single item, then the <code class="inlineCode">bisect</code> algorithm can be used for insertion. Otherwise, it’s generally faster to simply append the items and call <code class="inlineCode">list.sort()</code> or <code class="inlineCode">sorted()</code> afterward.</p>&#13;
    <p class="normal">To illustrate, we have these lines:</p>&#13;
    <pre class="programlisting con"><code class="hljs-con"><span class="hljs-con-meta">&gt;&gt;&gt;</span> <span class="hljs-con-keyword">import</span> bisect&#13;
&#13;
<span class="hljs-con-comment"># Using the regular sort:</span>&#13;
<span class="hljs-con-meta">&gt;&gt;&gt;</span> sorted_list = []&#13;
<span class="hljs-con-meta">&gt;&gt;&gt;</span> sorted_list.append(<span class="hljs-con-number">5</span>)  <span class="hljs-con-comment"># O(1)</span>&#13;
<span class="hljs-con-meta">&gt;&gt;&gt;</span> sorted_list.append(<span class="hljs-con-number">3</span>)  <span class="hljs-con-comment"># O(1)</span>&#13;
<span class="hljs-con-meta">&gt;&gt;&gt;</span> sorted_list.append(<span class="hljs-con-number">1</span>)  <span class="hljs-con-comment"># O(1)</span>&#13;
<span class="hljs-con-meta">&gt;&gt;&gt;</span> sorted_list.append(<span class="hljs-con-number">2</span>)  <span class="hljs-con-comment"># O(1)</span>&#13;
<span class="hljs-con-meta">&gt;&gt;&gt;</span> sorted_list.sort()  <span class="hljs-con-comment"># O(n * log(n)) = 4 * log(4) = 8</span>&#13;
<span class="hljs-con-meta">&gt;&gt;&gt;</span> sorted_list&#13;
[1, 2, 3, 5]&#13;
&#13;
<span class="hljs-con-comment"># Using bisect:</span>&#13;
<span class="hljs-con-meta">&gt;&gt;&gt;</span> sorted_list = []&#13;
<span class="hljs-con-meta">&gt;&gt;&gt;</span> bisect.insort(sorted_list, <span class="hljs-con-number">5</span>)  <span class="hljs-con-comment"># O(n) = 1</span>&#13;
<span class="hljs-con-meta">&gt;&gt;&gt;</span> bisect.insort(sorted_list, <span class="hljs-con-number">3</span>)  <span class="hljs-con-comment"># O(n) = 2</span>&#13;
<span class="hljs-con-meta">&gt;&gt;&gt;</span> bisect.insort(sorted_list, <span class="hljs-con-number">1</span>)  <span class="hljs-con-comment"># O(n) = 3</span>&#13;
<span class="hljs-con-meta">&gt;&gt;&gt;</span> bisect.insort(sorted_list, <span class="hljs-con-number">2</span>)  <span class="hljs-con-comment"># O(n) = 4</span>&#13;
<span class="hljs-con-meta">&gt;&gt;&gt;</span> sorted_list&#13;
[1, 2, 3, 5]&#13;
</code></pre>&#13;
    <p class="normal">For a small number of items, the difference is negligible, but the number of operations needed to sort using <code class="inlineCode">bisect</code> quickly grows to a point where the difference will be large. For <code class="inlineCode">n=4</code>, the difference is just between <code class="inlineCode">4 * 1 + 8 = 12</code> and <code class="inlineCode">1 + 2 + 3 + 4 = 10</code>, making the <code class="inlineCode">bisect</code> solution faster. But if we were to insert 1,000 items, it would be <code class="inlineCode">1000 + 1000 * log(1000) = 10966</code> versus <code class="inlineCode">1 + 2 + … 1000 = 1000 * (1000 + 1) / 2 = 500500</code>. So, be very careful while inserting many items.</p>&#13;
    <p class="normal">Searching <a id="_idIndexMarker309"/>within the list is very fast, though; because it is sorted, we can use a very simple binary search algorithm. For example, what if we want to check whether a few numbers exist within the list? The simplest algorithm, shown as follows, simply loops through the list and checks all items, resulting in <code class="inlineCode">O(n)</code> worst-case performance:</p>&#13;
    <pre class="programlisting con"><code class="hljs-con"><span class="hljs-con-meta">&gt;&gt;&gt;</span> sorted_list = [<span class="hljs-con-number">1</span>, <span class="hljs-con-number">2</span>, <span class="hljs-con-number">5</span>]&#13;
&#13;
<span class="hljs-con-meta">&gt;&gt;&gt;</span> <span class="hljs-con-keyword">def</span><span class="hljs-con-function"> </span><span class="hljs-con-title">contains</span><span class="hljs-con-function">(</span><span class="hljs-con-params">sorted_list, value</span><span class="hljs-con-function">):</span>&#13;
<span class="hljs-con-meta">...</span>     <span class="hljs-con-keyword">for</span> item <span class="hljs-con-keyword">in</span> sorted_list:&#13;
<span class="hljs-con-meta">...</span>         <span class="hljs-con-keyword">if</span> item &gt; value:&#13;
<span class="hljs-con-meta">...</span>             <span class="hljs-con-keyword">break</span>&#13;
<span class="hljs-con-meta">...</span>         <span class="hljs-con-keyword">elif</span> item == value:&#13;
<span class="hljs-con-meta">...</span>             <span class="hljs-con-keyword">return</span> <span class="hljs-con-literal">True</span>&#13;
<span class="hljs-con-meta">...</span>     <span class="hljs-con-keyword">return</span> <span class="hljs-con-literal">False</span>&#13;
&#13;
<span class="hljs-con-meta">&gt;&gt;&gt;</span> contains(sorted_list, <span class="hljs-con-number">2</span>)  <span class="hljs-con-comment"># Need to walk through 2 items, O(n) = 2</span>&#13;
True&#13;
<span class="hljs-con-meta">&gt;&gt;&gt;</span> contains(sorted_list, <span class="hljs-con-number">4</span>)  <span class="hljs-con-comment"># Need to walk through 3 items, O(n) = 3</span>&#13;
False&#13;
<span class="hljs-con-meta">&gt;&gt;&gt;</span> contains(sorted_list, <span class="hljs-con-number">6</span>)  <span class="hljs-con-comment"># Need to walk through 3 items, O(n) = 3</span>&#13;
False&#13;
</code></pre>&#13;
    <p class="normal">With<a id="_idIndexMarker310"/> the <code class="inlineCode">bisect</code> algorithm, though, there is no need to walk through the entire list:</p>&#13;
    <pre class="programlisting con"><code class="hljs-con"><span class="hljs-con-meta">&gt;&gt;&gt;</span> <span class="hljs-con-keyword">import</span> bisect&#13;
&#13;
<span class="hljs-con-meta">&gt;&gt;&gt;</span> sorted_list = [<span class="hljs-con-number">1</span>, <span class="hljs-con-number">2</span>, <span class="hljs-con-number">5</span>]&#13;
<span class="hljs-con-meta">&gt;&gt;&gt;</span> <span class="hljs-con-keyword">def</span><span class="hljs-con-function"> </span><span class="hljs-con-title">contains</span><span class="hljs-con-function">(</span><span class="hljs-con-params">sorted_list, value</span><span class="hljs-con-function">):</span>&#13;
<span class="hljs-con-meta">...</span>     i = bisect.bisect_left(sorted_list, value)&#13;
<span class="hljs-con-meta">...</span>     <span class="hljs-con-keyword">return</span> i &lt; <span class="hljs-con-built_in">len</span>(sorted_list) <span class="hljs-con-keyword">and</span> sorted_list[i] == value&#13;
&#13;
<span class="hljs-con-meta">&gt;&gt;&gt;</span> contains(sorted_list, <span class="hljs-con-number">2</span>)  <span class="hljs-con-comment"># Found it after the first step, O(log(n)) = 1</span>&#13;
True&#13;
<span class="hljs-con-meta">&gt;&gt;&gt;</span> contains(sorted_list, <span class="hljs-con-number">4</span>)  <span class="hljs-con-comment"># No result after 2 steps, O(log(n)) = 2</span>&#13;
False&#13;
<span class="hljs-con-meta">&gt;&gt;&gt;</span> contains(sorted_list, <span class="hljs-con-number">6</span>)  <span class="hljs-con-comment"># No result after 2 steps, O(log(n)) = 2</span>&#13;
False&#13;
</code></pre>&#13;
    <p class="normal">The <code class="inlineCode">bisect_left</code> function tries to find the position at which the number is supposed to be. This is actually what <code class="inlineCode">bisect.insort</code> does as well; it inserts the number at the correct position by searching for the location of the number.</p>&#13;
    <p class="normal">The <a id="_idIndexMarker311"/>biggest difference between these methods is that <code class="inlineCode">bisect</code> does a binary search internally, which means that it starts in the middle and jumps to the middle of the left or right section, depending on whether the value in the list is bigger or smaller than the value we are looking for. To illustrate, we will search for <code class="inlineCode">4</code> in a list of numbers from <code class="inlineCode">0</code> to <code class="inlineCode">14</code>:</p>&#13;
    <pre class="programlisting con"><code class="hljs-con">sorted_list = [0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14]&#13;
Step 1: 4 &gt; 7                       ^&#13;
Step 2: 4 &gt; 3           ^&#13;
Step 3: 4 &gt; 5                 ^&#13;
Step 4: 4 &gt; 5              ^&#13;
</code></pre>&#13;
    <p class="normal">As you <a id="_idIndexMarker312"/>can see, after only four steps, we have found the number we searched for. Depending on the number (<code class="inlineCode">7</code>, for example), it may go faster, but it will never take more than <code class="inlineCode">O(log(n))</code> steps to find a number.</p>&#13;
    <p class="normal">With a regular list, a search will simply walk through all the items until it finds the desired item. If you’re lucky, it could be the first number you encounter, but if you’re unlucky, it could be the last item. In the case of 1,000 items, that would be the difference between 1,000 steps and <code class="inlineCode">log(1000) = 10</code> steps.</p>&#13;
    <p class="normal">While very fast and efficient, the <code class="inlineCode">bisect</code> module doesn’t feel Pythonic at all. Let’s fix that by creating our own <code class="inlineCode">SortedList</code> class:</p>&#13;
    <pre class="programlisting con"><code class="hljs-con"><span class="hljs-con-meta">&gt;&gt;&gt;</span> <span class="hljs-con-keyword">import</span> bisect&#13;
<span class="hljs-con-meta">&gt;&gt;&gt;</span> <span class="hljs-con-keyword">import</span> collections&#13;
&#13;
<span class="hljs-con-meta">&gt;&gt;&gt;</span> <span class="hljs-con-keyword">class</span><span class="hljs-con-class"> </span><span class="hljs-con-title">SortedList</span><span class="hljs-con-class">:</span>&#13;
<span class="hljs-con-meta">...</span>     <span class="hljs-con-keyword">def</span><span class="hljs-con-function"> </span><span class="hljs-con-title">__init__</span><span class="hljs-con-function">(</span><span class="hljs-con-params">self, *values</span><span class="hljs-con-function">):</span>&#13;
<span class="hljs-con-meta">...</span>         self._list = <span class="hljs-con-built_in">sorted</span>(values)&#13;
<span class="hljs-con-meta">...</span>     &#13;
<span class="hljs-con-meta">...</span>     <span class="hljs-con-keyword">def</span><span class="hljs-con-function"> </span><span class="hljs-con-title">index</span><span class="hljs-con-function">(</span><span class="hljs-con-params">self, value</span><span class="hljs-con-function">):</span>&#13;
<span class="hljs-con-meta">...</span>         i = bisect.bisect_left(self._list, value)&#13;
<span class="hljs-con-meta">...</span>         <span class="hljs-con-keyword">if</span> i &lt; <span class="hljs-con-built_in">len</span>(self._list) <span class="hljs-con-keyword">and</span> self._list[i] == value:&#13;
<span class="hljs-con-meta">...</span>             <span class="hljs-con-keyword">return</span> index&#13;
<span class="hljs-con-meta">...</span>&#13;
<span class="hljs-con-meta">...</span>     <span class="hljs-con-keyword">def</span><span class="hljs-con-function"> </span><span class="hljs-con-title">delete</span><span class="hljs-con-function">(</span><span class="hljs-con-params">self, value</span><span class="hljs-con-function">):</span>&#13;
<span class="hljs-con-meta">...</span>         <span class="hljs-con-keyword">del</span> self._list[self.index(value)]&#13;
<span class="hljs-con-meta">...</span>&#13;
<span class="hljs-con-meta">...</span>     <span class="hljs-con-keyword">def</span><span class="hljs-con-function"> </span><span class="hljs-con-title">add</span><span class="hljs-con-function">(</span><span class="hljs-con-params">self, value</span><span class="hljs-con-function">):</span>&#13;
<span class="hljs-con-meta">...</span>         bisect.insort(self._list, value)&#13;
<span class="hljs-con-meta">...</span>&#13;
<span class="hljs-con-meta">...</span>     <span class="hljs-con-keyword">def</span><span class="hljs-con-function"> </span><span class="hljs-con-title">__iter__</span><span class="hljs-con-function">(</span><span class="hljs-con-params">self</span><span class="hljs-con-function">):</span>&#13;
<span class="hljs-con-meta">...</span>         <span class="hljs-con-keyword">for</span> value <span class="hljs-con-keyword">in</span> self._list:&#13;
<span class="hljs-con-meta">...</span>             <span class="hljs-con-keyword">yield</span> value&#13;
<span class="hljs-con-meta">...</span>&#13;
<span class="hljs-con-meta">...</span>     <span class="hljs-con-keyword">def</span><span class="hljs-con-function"> </span><span class="hljs-con-title">__exists__</span><span class="hljs-con-function">(</span><span class="hljs-con-params">self, value</span><span class="hljs-con-function">):</span>&#13;
<span class="hljs-con-meta">...</span>         <span class="hljs-con-keyword">return</span> self.index(value) <span class="hljs-con-keyword">is</span> <span class="hljs-con-keyword">not</span> <span class="hljs-con-literal">None</span>&#13;
&#13;
<span class="hljs-con-meta">&gt;&gt;&gt;</span> sorted_list = SortedList(<span class="hljs-con-number">1</span>, <span class="hljs-con-number">3</span>, <span class="hljs-con-number">6</span>, <span class="hljs-con-number">2</span>)&#13;
<span class="hljs-con-meta">&gt;&gt;&gt;</span> <span class="hljs-con-number">3</span> <span class="hljs-con-keyword">in</span> sorted_list&#13;
True&#13;
<span class="hljs-con-meta">&gt;&gt;&gt;</span> <span class="hljs-con-number">5</span> <span class="hljs-con-keyword">in</span> sorted_list&#13;
False&#13;
<span class="hljs-con-meta">&gt;&gt;&gt;</span> sorted_list.add(<span class="hljs-con-number">5</span>)&#13;
<span class="hljs-con-meta">&gt;&gt;&gt;</span> <span class="hljs-con-number">5</span> <span class="hljs-con-keyword">in</span> sorted_list&#13;
True&#13;
<span class="hljs-con-meta">&gt;&gt;&gt;</span> <span class="hljs-con-built_in">list</span>(sorted_list)&#13;
[1, 2, 3, 5, 6]&#13;
</code></pre>&#13;
    <p class="normal">While <a id="_idIndexMarker313"/>functional, this <a id="_idIndexMarker314"/>implementation is obviously still a tad limited. But it’s certainly a nice starting point in case you need a structure like this.</p>&#13;
    <h2 id="_idParaDest-120" class="heading-2">Global instances using Borg or Singleton patterns</h2>&#13;
    <p class="normal">Most programmers<a id="_idIndexMarker315"/> will <a id="_idIndexMarker316"/>be familiar with the Singleton pattern, which ensures that only a single instance of a class will ever exist. Within Python, a common alternative solution to this is the<a id="_idIndexMarker317"/> Borg pattern, named after the Borg in Star Trek. Where a <a id="_idIndexMarker318"/>Singleton enforces a single instance, the Borg pattern <a id="_idIndexMarker319"/>enforces a single state for all instances and subclasses as well. Due to the way class creation <a id="_idIndexMarker320"/>works in Python, the Borg pattern is a tiny bit easier to implement and modify than the Singleton pattern as well.</p>&#13;
    <p class="normal">To illustrate an example of both:</p>&#13;
    <p class="normal">The Borg class:</p>&#13;
    <pre class="programlisting con"><code class="hljs-con"><span class="hljs-con-meta">&gt;&gt;&gt;</span> <span class="hljs-con-keyword">class</span><span class="hljs-con-class"> </span><span class="hljs-con-title">Borg</span><span class="hljs-con-class">:</span>&#13;
<span class="hljs-con-meta">...</span>     _state = {}&#13;
<span class="hljs-con-meta">...</span>     <span class="hljs-con-keyword">def</span><span class="hljs-con-function"> </span><span class="hljs-con-title">__init__</span><span class="hljs-con-function">(</span><span class="hljs-con-params">self</span><span class="hljs-con-function">):</span>&#13;
<span class="hljs-con-meta">...</span>         self.__dict__ = self._state&#13;
&#13;
<span class="hljs-con-meta">&gt;&gt;&gt;</span> <span class="hljs-con-keyword">class</span><span class="hljs-con-class"> </span><span class="hljs-con-title">SubBorg</span><span class="hljs-con-class">(</span><span class="hljs-con-params">Borg</span><span class="hljs-con-class">):</span>&#13;
<span class="hljs-con-meta">...</span>     <span class="hljs-con-keyword">pass</span>&#13;
&#13;
<span class="hljs-con-meta">&gt;&gt;&gt;</span> a = Borg()&#13;
<span class="hljs-con-meta">&gt;&gt;&gt;</span> b = Borg()&#13;
<span class="hljs-con-meta">&gt;&gt;&gt;</span> c = Borg()&#13;
<span class="hljs-con-meta">&gt;&gt;&gt;</span> a.a_property = <span class="hljs-con-number">123</span>&#13;
<span class="hljs-con-meta">&gt;&gt;&gt;</span> b.a_property&#13;
123&#13;
<span class="hljs-con-meta">&gt;&gt;&gt;</span> c.a_property&#13;
123&#13;
</code></pre>&#13;
    <p class="normal">The Singleton class:</p>&#13;
    <pre class="programlisting con"><code class="hljs-con"><span class="hljs-con-meta">&gt;&gt;&gt;</span> <span class="hljs-con-keyword">class</span><span class="hljs-con-class"> </span><span class="hljs-con-title">Singleton</span><span class="hljs-con-class">:</span>&#13;
<span class="hljs-con-meta">...</span>     <span class="hljs-con-keyword">def</span><span class="hljs-con-function"> </span><span class="hljs-con-title">__new__</span><span class="hljs-con-function">(</span><span class="hljs-con-params">cls</span><span class="hljs-con-function">):</span>&#13;
<span class="hljs-con-meta">...</span>         <span class="hljs-con-keyword">if</span> <span class="hljs-con-keyword">not</span> <span class="hljs-con-built_in">hasattr</span>(cls, <span class="hljs-con-string">'_instance'</span>):&#13;
<span class="hljs-con-meta">...</span>             cls._instance = <span class="hljs-con-built_in">super</span>(Singleton, cls).__new__(cls)&#13;
<span class="hljs-con-meta">...</span>&#13;
<span class="hljs-con-meta">...</span>         <span class="hljs-con-keyword">return</span> cls._instance&#13;
&#13;
<span class="hljs-con-meta">&gt;&gt;&gt;</span> <span class="hljs-con-keyword">class</span><span class="hljs-con-class"> </span><span class="hljs-con-title">SubSingleton</span><span class="hljs-con-class">(</span><span class="hljs-con-params">Singleton</span><span class="hljs-con-class">):</span>&#13;
<span class="hljs-con-meta">...</span>     <span class="hljs-con-keyword">pass</span>&#13;
&#13;
<span class="hljs-con-meta">&gt;&gt;&gt;</span> a = Singleton()&#13;
<span class="hljs-con-meta">&gt;&gt;&gt;</span> b = Singleton()&#13;
<span class="hljs-con-meta">&gt;&gt;&gt;</span> c = SubSingleton()&#13;
<span class="hljs-con-meta">&gt;&gt;&gt;</span> a.a_property = <span class="hljs-con-number">123</span>&#13;
<span class="hljs-con-meta">&gt;&gt;&gt;</span> b.a_property&#13;
123&#13;
<span class="hljs-con-meta">&gt;&gt;&gt;</span> c.a_property&#13;
123&#13;
</code></pre>&#13;
    <p class="normal">The <a id="_idIndexMarker321"/>Borg pattern <a id="_idIndexMarker322"/>works <a id="_idIndexMarker323"/>by overriding the <code class="inlineCode">__dict__</code> of the instance that contains<a id="_idIndexMarker324"/> the instance state. The Singleton overrides the <code class="inlineCode">__new__</code> (note, not <code class="inlineCode">__init__</code>) method so that we only ever return a single instance of the class.</p>&#13;
    <h2 id="_idParaDest-121" class="heading-2">No need for getters and setters with properties</h2>&#13;
    <p class="normal">Within many languages (notably Java), a common design pattern for accessing instance variables is using<a id="_idIndexMarker325"/> getters and setters so that you can modify the behavior when needed in the future. Within Python, we can transparently change the behavior of attributes for existing classes without the need to touch the calling code:</p>&#13;
    <pre class="programlisting con"><code class="hljs-con"><span class="hljs-con-meta">&gt;&gt;&gt;</span> <span class="hljs-con-keyword">class</span><span class="hljs-con-class"> </span><span class="hljs-con-title">Sandwich</span><span class="hljs-con-class">:</span>&#13;
<span class="hljs-con-meta">...</span>     <span class="hljs-con-keyword">def</span><span class="hljs-con-function"> </span><span class="hljs-con-title">__init__</span><span class="hljs-con-function">(</span><span class="hljs-con-params">self, spam</span><span class="hljs-con-function">):</span>&#13;
<span class="hljs-con-meta">...</span>         self.spam = spam&#13;
<span class="hljs-con-meta">...</span>&#13;
<span class="hljs-con-meta">...</span> <span class="hljs-con-meta">    @property</span>&#13;
<span class="hljs-con-meta">...</span>     <span class="hljs-con-keyword">def</span><span class="hljs-con-function"> </span><span class="hljs-con-title">spam</span><span class="hljs-con-function">(</span><span class="hljs-con-params">self</span><span class="hljs-con-function">):</span>&#13;
<span class="hljs-con-meta">...</span>         <span class="hljs-con-keyword">return</span> self._spam&#13;
<span class="hljs-con-meta">...</span>&#13;
<span class="hljs-con-meta">...</span> <span class="hljs-con-meta">    @spam.setter</span>&#13;
<span class="hljs-con-meta">...</span>     <span class="hljs-con-keyword">def</span><span class="hljs-con-function"> </span><span class="hljs-con-title">spam</span><span class="hljs-con-function">(</span><span class="hljs-con-params">self, value</span><span class="hljs-con-function">):</span>&#13;
<span class="hljs-con-meta">...</span>         self._spam = value&#13;
<span class="hljs-con-meta">...</span>         <span class="hljs-con-keyword">if</span> self._spam &gt;= <span class="hljs-con-number">5</span>:&#13;
<span class="hljs-con-meta">...</span>             print(<span class="hljs-con-string">'You must be hungry'</span>)&#13;
<span class="hljs-con-meta">...</span>&#13;
<span class="hljs-con-meta">...</span> <span class="hljs-con-meta">    @spam.deleter</span>&#13;
<span class="hljs-con-meta">...</span>     <span class="hljs-con-keyword">def</span><span class="hljs-con-function"> </span><span class="hljs-con-title">spam</span><span class="hljs-con-function">(</span><span class="hljs-con-params">self</span><span class="hljs-con-function">):</span>&#13;
<span class="hljs-con-meta">...</span>         self._spam = <span class="hljs-con-number">0</span>&#13;
&#13;
<span class="hljs-con-meta">&gt;&gt;&gt;</span> sandwich = Sandwich(<span class="hljs-con-number">2</span>)&#13;
<span class="hljs-con-meta">&gt;&gt;&gt;</span> sandwich.spam += <span class="hljs-con-number">1</span>&#13;
<span class="hljs-con-meta">&gt;&gt;&gt;</span> sandwich.spam += <span class="hljs-con-number">2</span>&#13;
You must be hungry&#13;
</code></pre>&#13;
    <p class="normal">The calling <a id="_idIndexMarker326"/>code doesn’t need to be changed at all. We can simply change the behavior of the property in a completely transparent way.</p>&#13;
    <h2 id="_idParaDest-122" class="heading-2">Dict union operators</h2>&#13;
    <p class="normal">This is<a id="_idIndexMarker327"/> not actually a separate <a id="_idIndexMarker328"/>advanced collection, but it is advanced usage of the <code class="inlineCode">dict</code> collection. Since Python 3.9, we have a few easy options for combining multiple <code class="inlineCode">dict</code> instances. The “old” solution was to use <code class="inlineCode">dict.update()</code>, possibly combined with <code class="inlineCode">dict.copy()</code> to create a new instance. While that works fine, it is rather verbose and a tad clunky.</p>&#13;
    <p class="normal">Since this is a case where a few examples are much more useful than just explanation, let’s see how the old solution works:</p>&#13;
    <pre class="programlisting con"><code class="hljs-con"><span class="hljs-con-meta">&gt;&gt;&gt;</span> a = <span class="hljs-con-built_in">dict</span>(x=<span class="hljs-con-number">1</span>, y=<span class="hljs-con-number">2</span>)&#13;
<span class="hljs-con-meta">&gt;&gt;&gt;</span> b = <span class="hljs-con-built_in">dict</span>(y=<span class="hljs-con-number">1</span>, z=<span class="hljs-con-number">2</span>)&#13;
&#13;
<span class="hljs-con-meta">&gt;&gt;&gt;</span> c = a.copy()&#13;
<span class="hljs-con-meta">&gt;&gt;&gt;</span> c&#13;
{'x': 1, 'y': 2}&#13;
<span class="hljs-con-meta">&gt;&gt;&gt;</span> c.update(b)&#13;
&#13;
<span class="hljs-con-meta">&gt;&gt;&gt;</span> a&#13;
{'x': 1, 'y': 2}&#13;
<span class="hljs-con-meta">&gt;&gt;&gt;</span> b&#13;
{'y': 1, 'z': 2}&#13;
<span class="hljs-con-meta">&gt;&gt;&gt;</span> c&#13;
{'x': 1, 'y': 1, 'z': 2}&#13;
</code></pre>&#13;
    <p class="normal">That solution works great, but with Python 3.9 and above we can do it in a much easier and shorter way:</p>&#13;
    <pre class="programlisting con"><code class="hljs-con"><span class="hljs-con-meta">&gt;&gt;&gt;</span> a = <span class="hljs-con-built_in">dict</span>(x=<span class="hljs-con-number">1</span>, y=<span class="hljs-con-number">2</span>)&#13;
<span class="hljs-con-meta">&gt;&gt;&gt;</span> b = <span class="hljs-con-built_in">dict</span>(y=<span class="hljs-con-number">1</span>, z=<span class="hljs-con-number">2</span>)&#13;
&#13;
<span class="hljs-con-meta">&gt;&gt;&gt;</span> a | b&#13;
{'x': 1, 'y': 1, 'z': 2}&#13;
</code></pre>&#13;
    <p class="normal">This is a<a id="_idIndexMarker329"/> feature that can be very convenient when specifying arguments to a function, especially if you want to <a id="_idIndexMarker330"/>automatically fill in keyword arguments with default arguments:</p>&#13;
    <pre class="programlisting code"><code class="hljs-code">some_function(**(default_arguments | given_arguments))&#13;
</code></pre>&#13;
    <p class="normal">Now that you have seen a few of the more advanced collections bundled with Python, you should have a pretty good idea of when to apply which type of collection. You may also have learned about a few new Python design patterns.</p>&#13;
    <h1 id="_idParaDest-123" class="heading-1">Exercises</h1>&#13;
    <p class="normal">In addition to enhancing the examples in this chapter, there are many other exercises:</p>&#13;
    <ul>&#13;
      <li class="bulletList">Create a <code class="inlineCode">SortedDict</code> collection that takes a <code class="inlineCode">keyfunc</code> to decide the sort order.</li>&#13;
      <li class="bulletList">Create a <code class="inlineCode">SortedList</code> collection that has <code class="inlineCode">O(log(n))</code> inserts and always returns a sorted list during each iteration.</li>&#13;
      <li class="bulletList">Create a Borg pattern that has a state per subclass.</li>&#13;
    </ul>&#13;
    <div class="note">&#13;
      <p class="normal">Example answers for these exercises can be found on GitHub: <a href="Chapter_4.xhtml"><span class="url">https://github.com/mastering-python/exercises</span></a>. You are encouraged to submit your own solutions and learn about alternative solutions from others.</p>&#13;
    </div>&#13;
    <h1 id="_idParaDest-124" class="heading-1">Summary</h1>&#13;
    <p class="normal">Python is a bit unlike other languages in some aspects and several design patterns that are common in other languages make little sense in Python. In this chapter, you have seen some common Python design patterns, but many more patterns exist. Before you start implementing your own collections based on these patterns, quickly search the web to see whether there is an existing solution already. In particular, the <code class="inlineCode">collections</code> module receives a lot of updates, so it is possible that your problem has already been solved.</p>&#13;
    <p class="normal">If you are ever wondering how these structures work, have a look at the following source:<a href="https://github.com/python/cpython/blob/master/Lib/collections/__init__.py"><span class="url">https://github.com/python/cpython/blob/master/Lib/collections/__init__.py</span></a>.</p>&#13;
    <p class="normal">After finishing this chapter, you should be aware of the time complexities of the basic Python structures. You should also be familiar with a few Pythonic methods of tackling certain problems. Many of these examples use the <code class="inlineCode">collections</code> module, but this chapter does not list all of the classes in the <code class="inlineCode">collections</code> module. </p>&#13;
    <p class="normal">Selecting the correct data structure within your applications is by far the most important performance factor for your code. This makes basic knowledge about performance characteristics essential for any serious programmer.</p>&#13;
    <p class="normal">In the next chapter, we will continue with functional programming, which covers <code class="inlineCode">lambda</code> functions, <code class="inlineCode">list</code> comprehensions, <code class="inlineCode">dict</code> comprehensions, <code class="inlineCode">set</code> comprehensions, and an array of related topics. Additionally, you will learn about the mathematic background of functional programming.</p>&#13;
    <h1 class="heading-1">Join our community on Discord</h1>&#13;
    <p class="normal">Join our community’s Discord space for discussions with the author and other readers: <a href="https://discord.gg/QMzJenHuJf"><span class="url">https://discord.gg/QMzJenHuJf</span></a></p>&#13;
    <p class="normal"><img src="Images/QR_Code156081100001293319171.png" alt="" width="177" height="177"/></p>&#13;
  </div>&#13;
</div></body></html>