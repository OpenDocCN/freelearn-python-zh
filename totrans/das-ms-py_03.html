<html><head></head><body>
        <section>

                            <header>
                    <h1 class="header-title">Making a Package</h1>
                </header>
            
            <article>
                
<p>In the previous chapter, we saw how to install Python and third-party packages of code that we can use with Python. In this chapter, we'll see how packages are represented on the computer's filesystem. We'll take a look at how to add code modules inside the package, how to make those code modules interact with each other within the package, and how to access data from non-code files that are incorporated into our package.</p>
<p>By the end of this chapter, you'll have a pretty good idea about how to create your own packages of Python code. Packages will form the basis for programs and help you to make your code modular.</p>
<p>In this chapter, we will cover the following topics:</p>
<ul>
<li>Creating an empty package</li>
<li>Adding modules to the package</li>
<li>Accessing code from other modules</li>
<li>Adding static data files to the package</li>
</ul>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Creating an empty package</h1>
                </header>
            
            <article>
                
<p>The first section of this chapter deals with creating a simple empty package, which won't do anything yet, but by the time we're done, we'll be able to import the empty package into the Python shell.</p>
<p>Simple Python projects may consist of a single code module, but normally there are multiple modules combined together into a package. A package can contain as many modules as we need it to. Packages start their lives as folders on the filesystem, which means we can make them just as we would make any other folder.</p>
<p>If you prefer to use your operating system's file browser to make folders, that's fine, but I usually use the command line. For example let's run a demo package:</p>
<pre>
<strong>$ mkdir demopackage<br/></strong>
</pre>
<p>This is shown as the following screenshot:</p>
<div class="CDPAlignCenter CDPAlign"><img height="31" width="332" class="image-border" src="assets/93df4e38-10cc-4c9e-adce-7fb163f047f7.jpg"/></div>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Turning a regular folder into a package</h1>
                </header>
            
            <article>
                
<p>There are two things that turn a regular folder into a package. These are explained as follows:</p>
<p>The first is <em>where is it</em> that is, the location of the folder. Python only looks in certain places for packages and if your folder isn't in the right place, Python won't notice it.</p>
<p>The <kbd>sys.path</kbd> variable contains the list of all the places Python will look for packages. The <kbd>sys.path</kbd> variable is fairly sparse, but user configuration can make it much more extensive as shown in the following screenshot:</p>
<div class="CDPAlignCenter CDPAlign"><img height="82" width="950" class="image-border" src="assets/15a9435e-92b9-44d6-82b1-35dfd6501e41.jpg"/></div>
<p>Notice that the first entry in the list is an empty string. This stands for the current working directory.</p>
<div class="packt_infobox">For those who are using the command line, the current working directory is just the folder we're currently in.</div>
<p>We can change the current working directory with the <kbd>cd</kbd> command:</p>
<pre>
<strong>cd demopackage</strong>
<strong>cd ..</strong>  
</pre>
<p>The <kbd>cd..</kbd> command in the preceding code means go back to the previous directory or the parent directory. So, in this case, I went in and out of <kbd>demopackage</kbd>.</p>
<p>The fact that the current working directory is in the path is convenient during development; it means that we could just set the current working directory to the place where we're doing our development and all of our packages become available, at least, as long as we also use the command line to launch Python.</p>
<p>The second thing that turns a regular folder into a package is the presence of <kbd>__init__.py</kbd> file, though not strictly necessary since Python 3.3 and beyond. An <kbd>init</kbd> file marks the folder as a package, which makes it load more efficiently and also gives us a place to put information and code relevant to the interface of the package as a whole.</p>
<p>While it's quite common that the <kbd>__init__.py</kbd> file is completely empty and serves only as a marker, there's one language feature that won't be supported unless we add a little code to the file.</p>
<p>This feature is the ability to import all the package's modules using the <kbd>import*</kbd> syntax, as shown here:</p>
<div class="CDPAlignCenter CDPAlign"><img height="65" width="465" class="image-border" src="assets/6ba7b4dd-eeed-4b97-8974-0f7776d10eb7.jpg"/></div>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Importing all package modules</h1>
                </header>
            
            <article>
                
<p>If we want Python to be able to import all the package's modules using <kbd>import*</kbd> syntax, we have to tell it the names of all those modules.</p>
<p>To do this, we add the module names to a list called <kbd>__all__</kbd> in the <kbd>init</kbd> file as shown in the following code:</p>
<div class="CDPAlignCenter CDPAlign"><img height="292" width="444" class="image-border" src="assets/e260d3ec-8221-427c-9503-f279ae03fe16.jpg"/></div>
<div class="packt_infobox">If you don't have <em>emacs</em> installed on your system, you can install it by using the following command:<br/>
<br/>
<span><kbd><strong>sudo apt install emacs24<br/></strong></kbd></span> <span>In the preceding screenshot, I have used Ubuntu, thus the editor is white background, however in case of Windows OS and macOS, the background of the editor can be different. </span></div>
<p>You might be wondering why we need to do this manually rather than Python just scanning the filesystem for module files.</p>
<p>Well, there are a couple of reasons:</p>
<ul>
<li>First, Python tries not to make any assumptions about whether filenames are case-sensitive or not. On some operating systems, filenames are case-sensitive and on other operating systems they are not. Module names are variables, so it's better they originate within the source code, rather than depending on something external that might change depending on where the code is run.</li>
</ul>
<ul>
<li>The second reason for doing this manually is that importing a module makes code execute. </li>
</ul>
<p>Imagine we have a package that plays soundtracks. In addition to the general purpose code, we also have a bunch of modules that handle audio output on various systems.</p>
<p>Allowing our users to do an <kbd>import*</kbd> to bring their packages' programming interface into their module is quite reasonable; however, we don't want all of the output modules to load, just the one that's appropriate to the system we're running on. Trying to load any of the others would most likely trigger an exception in the user's code. The way <kbd>__all__</kbd> works now, we can exclude the output modules from <kbd>import*</kbd> and get the best of both worlds.</p>
<p>Alright, let's make sure that Python is willing to import our demo package before we move on to the next part, which is how to add source code modules to a package.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Adding modules to the package</h1>
                </header>
            
            <article>
                
<p>Now, let's take look at how to add actual code to the package and look out for a couple of pitfalls to avoid.</p>
<p>Python modules have the same name as objects that they have as filenames, except without the <kbd>.py</kbd> suffix. This means that the filenames need to be valid Python variable names  and also that they should use letters and symbols that are reliably available across different operating systems. The following screenshot showns an example for this:</p>
<div class="CDPAlignCenter CDPAlign"><img class="image-border" src="assets/e66aaf50-521f-427c-9518-cb0ddacc16cd.jpg"/></div>
<p>So, module names should not start with a number because Python variables are not allowed to start with numbers. Also, it should not use capital letters because some common operating system don't differentiate between filenames containing capital letters and filenames that are all lowercase. As long as we stay within Python variable name guidelines and remember to use a <kbd>.py</kbd> suffix, we can name our modules anything we please.</p>
<p>So, we just pick a filename and start writing Python code into a file with that name in the <kbd>package</kbd> folder. That simple scenario is also the common case, but there's another possibility.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Module loading with namespace packages</h1>
                </header>
            
            <article>
                
<p>As mentioned earlier, starting with Python 3.3, it's possible to have a <kbd>package</kbd> folder that doesn't contain an <kbd>init</kbd> file. Leaving out the <kbd>init</kbd> file means we can't support <kbd>import*</kbd> or the other tricks within it that we'll discover as we go along. But, there's more to it than that. The following screenshot shows a code example for this:</p>
<div class="CDPAlignCenter CDPAlign"><img height="420" width="457" class="image-border" src="assets/deaa05f7-42be-4323-a8b8-d9b1eac596b4.jpg"/></div>
<p>When the <kbd>init</kbd> file is missing, the folder becomes part of a <kbd>namespace package</kbd> folder. When Python is importing, it combines all of the <kbd>namespace package</kbd> folders it finds, that share a name, into a single logical package, as shown in the following screenshot:</p>
<div class="CDPAlignCenter CDPAlign"><img height="76" width="262" class="image-border" src="assets/880b45e2-324a-41b9-ad4e-df5b379cca34.jpg"/></div>
<p>This behavior means that while choosing the module filename, Python still follows the same rules, we could potentially place that file into one of any number of <kbd>namespace package</kbd> folders instead of into a singular concrete <kbd>package</kbd> folder.</p>
<p>What do we gain from that? Often nothing!</p>
<p>As I mentioned earlier, packages with an <kbd>init</kbd> load faster, and in many cases, the extra abstraction of namespace packages doesn't buy us anything.</p>
<p>There are cases, however, when we want different parts of the same package to be distributed or managed separately and when we do, <kbd>namespace packages</kbd> address that need. For example, imagine again that we are working on a package for playing soundtracks. If we make a <kbd>namespace package</kbd> folder for audio codecs, each codec could be installed and removed individually using <kbd>pip</kbd> or the operating system's normal package management tools.</p>
<p>On a slightly different topic, now let's talk about the difference between how a package is structured and the interface it should present for use by external code.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">The Package structure and interface</h1>
                </header>
            
            <article>
                
<p>For the convenience and sanity of ourselves as the package developers, it's often best to break up the code in a package into many different modules, all of which contain a selection of conceptually related code; this is the package's structure. As a rule of thumb, whenever we think we might want to break the code up into more modules, we probably should go with that impulse.</p>
<p>On the other hand, external code calling on our package is best off when it can take advantage of our code with just one or two import statements that bring in a small number of functions or classes. This is the package's interface, and as a rule of thumb, it should be as minimal as possible, while preserving full functionality, as shown in the following code example:</p>
<pre>
from example.foo import Foo<br/>from example.bar import BarFactory<br/>from example.baz import Baz<br/><br/>MAIN_BAZ = BAZ()<br/><br/>__all__ = ['Foo', 'BarFactory', 'MAIN_BAZ']
</pre>
<p>Fortunately, we can have our cake and eat it too!</p>
<p>We could divide our code up however we wish and then import the most useful elements into our <kbd>init</kbd> file, which will make them part of the package's route namespace. If all that's in an <kbd>init</kbd> file is <kbd>import</kbd> statements, we don't need the <kbd>__all__</kbd> variable.</p>
<p>An <kbd>import*</kbd> statement will grab the contents of the <kbd>init</kbd> file except for variables, starting with an underscore. However, if we define or import anything in the <kbd>init</kbd> file that should not be part of the public interface, we can use the <kbd>__all__</kbd> variable to narrow down and control what we export.</p>
<div class="packt_infobox">Just remember, if we have an all list, it needs to list everything that is part of the package's interface, whether a module, class, function, or variable.</div>
<p>The rest of the modules in the package are still available to be explicitly imported. We're just making it convenient to access the parts that are most likely to be useful outside our own package.</p>
<p>Now we have a good idea of how to name our modules, where to put them so that they become part of our package, and how to give our package a convenient interface. Next, we'll move on to looking at how to make the modules in a package interact with each other.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Accessing code from other modules</h1>
                </header>
            
            <article>
                
<p>We'll start off this section by understanding the difference between absolute and relative imports, then move on to writing those, and finally, we'll look at cyclic dependencies.</p>
<p>When we are importing one of the package's modules from outside the package, there's only one sensible way that it could work-we tell Python which package and module we want, and it either finds and imports it or raises an exception if it can't. Simple!</p>
<pre>
import packagename.modulename  
</pre>
<p>When we're already inside a package, the situation is more ambiguous because <kbd>import name</kbd> could just as easily mean "look for <kbd>name</kbd> within this package" or "look for <kbd>name</kbd> in the Python search path." Python breaks this ambiguity by defining <kbd>import name</kbd> to mean that a package or module called <strong>name</strong> should be searched for in Python's search path:</p>
<pre>
import name  
</pre>
<p>Also, it also gives us a way to specify a relative <kbd>import</kbd> if we'd rather have it just look within the current package. We can specify a relative <kbd>import</kbd> by putting a dot in front of the name of the module we want to import, as shown in the following code:</p>
<pre>
import .name  
</pre>
<p>When Python sees this, it will look for a module called <kbd>name</kbd> in the same package as the module our code is running in.</p>
<p>Often, we only need one or two objects from another module and it's more convenient to import those objects directly into our global scope than it would be to import the module as a whole and access its contents. Python lets us do that with a slight variation on the <kbd>import</kbd> syntax:</p>
<pre>
from .name import Foo  
</pre>
<p>Finally, sometimes we want to rename an object within our scope as we import it. We could do that by modifying our import with the <kbd>as</kbd> keyword:</p>
<pre>
from .name import Foo as Bar 
</pre>
<p>In the preceding example, even though the object is called <kbd>Foo</kbd> in the <kbd>name</kbd> module, in our current module, it's named <kbd>Bar</kbd>. This trick works for absolute imports too by the way.</p>
<div class="packt_infobox">Before we move on, let's take note that Python 2 used a different rule for deciding where to find imported code. In Python 2, it first tried to find a target of an import within the current package. Then, if no matching module was found there, it went out and looked for it on the search path. This approach usually did the right thing, but occasionally caused problems due to the ambiguous meaning; and it meant that we couldn't have some packages, sub-packages, or modules that shared the name of anything in the standard library or other installed packages. So, this behavior was changed in Python 3.</div>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Importing a cyclic dependency</h1>
                </header>
            
            <article>
                
<p>There is something that might trip us up when we're importing a module that shares the same package. Sometimes, the module we're importing wants to import us as well. This is called a <strong>cyclic dependency</strong>. When we try to import a cyclic dependency, we'll almost always get an attribute error exception, as in the following example:</p>
<div class="CDPAlignCenter CDPAlign"><img height="164" width="432" class="image-border" src="assets/9cb740b2-3831-4c8d-8375-97be13077540.jpg"/></div>
<p>That happens because when we ask Python to import the first module, Python immediately creates a module object for it and begins executing the code in the module.</p>
<p>That's fine, except that, when Python gets to the <kbd>import</kbd> statement for the next module in this cycle, it pauses running the code in the first module, leaving it not fully initialized. Even that isn't normally a problem because Python will come back and finish the initialization later.</p>
<p>However, when the second module asks to import the first module, Python just hands it the already allocated, and not fully initialized, module object. When the second module tries to access the variables stored in the first object, many of them will not yet have been created. Hence, an attribute error is raised.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Resolving attribute errors raised due to cyclic dependencies</h1>
                </header>
            
            <article>
                
<p>There are two common ways to address the attribute error. The first one is usually considered the best. This method is to break the cycle by taking some of the code from one of the modules and moving it into a third module, which both the other modules can import without causing a cycle. In the following example, if we move the <kbd>A</kbd> class into its own module, there would be no cycle and all would be well:</p>
<div class="CDPAlignCenter CDPAlign"><img height="157" width="386" class="image-border" src="assets/dad5ee64-c51b-489d-935b-13e1ac917d9b.jpg"/></div>
<p>The other way to address this problem is to move the <kbd>import</kbd> statement that causes the cycle, as shown in the following screenshot:</p>
<div class="CDPAlignCenter CDPAlign"><img height="160" width="394" class="image-border" src="assets/93ba170e-592f-4227-9b25-3d8f3ebf975f.jpg"/></div>
<p>If we move the <kbd>import</kbd> statement down, as shown in the preceding example, until it's below all the variable definitions that are needed by the other modules in this cycle, the module will be initialized enough when it's imported by the other modules. Python will still come back and finish the initialization later.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Adding static data files to the package</h1>
                </header>
            
            <article>
                
<p>If we're going to add static data files to the package, where should we put them?</p>
<p>Well we can put them anywhere that's convenient within the <kbd>package</kbd> folder, but it's often a good idea to create a subfolder specifically for holding the data files. This keeps data files separate from the source code and generally makes them a little easier to work with.</p>
<div class="packt_infobox">The data files that are part of a package should be assumed to be read-only.</div>
<p>There are many reasons that might cause the files to not be writable at runtime. So, if we want to write data to a file while our code is running, we need to pick somewhere else to store it. Only files that do not change are appropriate for inclusion in a package:</p>
<pre>
<strong>ls example/</strong>
<strong>__init__.py data</strong>
<strong>ls example/data</strong>
<strong>datafile.txt</strong>
<strong>cat example/data/datafile.txt</strong>
<strong>Hello world of data</strong>
</pre>
<p>So, that said, all we have to do to include a data file in our package is drop it into our package and then access the data with the <kbd>get_data</kbd> function from the <kbd>util</kbd> package in the standard library:</p>
<pre>
<strong>from pkgutil import get_data</strong>
<strong>get_data('example', 'data/datafile.txt')</strong>
<strong>b'Hello world of data\n'</strong>
</pre>
<p>The <kbd>get_data</kbd> function takes two parameters:</p>
<ul>
<li>The name of the package we want to get the data from</li>
<li>The relative path of the data file inside the package</li>
</ul>
<p>Using forward slashes to separate path components, we pass it these two pieces of information and it returns a byte object to us containing the contents of the file.</p>
<p>If we want a text string instead of bytes, that's easily done. We just need to apply the proper string decoder to the bytes object and we'll get back a unicode text string. This technique will work even if our package has been compressed into a ZIP file or otherwise hidden away because it uses the same underlying mechanism that Python uses to load module source code.</p>
<p>If Python can find the code, it can find the data file as well. That's all there is to working with static data that's packaged up alongside our code. It's simple and useful.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Summary</h1>
                </header>
            
            <article>
                
<p>In this chapter, we learned how to create a Python package as a directory on the filesystem and how to mark it with an <kbd>__init__.py</kbd> file, so that importing is efficient and we can add package metadata. We looked at adding code modules to a package. We saw how code modules within the same package interact.</p>
<p>We learned how to put together a Python code package that can be used in a program or distributed to other programmers. Soon, we'll see how to turn a package into a complete program as well. In the next chapter, we'll step back a little bit and talk about some best practices for working with Python code.</p>


            </article>

            
        </section>
    </body></html>