- en: Useful Flask Extensions
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: As we have seen throughout this book, Flask is designed to be as small as possible,
    while still giving you the flexibility and tools needed to create web applications.
    However, there are a lot of features that are common to many web applications,
    which means that many applications will require code that does the same task for
    each web application. To solve this problem, and avoid reinventing the wheel,
    people have created extensions for Flask, and we have seen many Flask extensions
    already throughout the book. This chapter will focus on some of the more useful
    Flask extensions that don't have enough content to separate them out into their
    own chapter, but will save you a lot of time and frustration.
  prefs: []
  type: TYPE_NORMAL
- en: 'In this chapter, you will learn how to do the following:'
  prefs: []
  type: TYPE_NORMAL
- en: Developing a debug toolbar, with great backend performance metrics
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Page cache using Redis or memcached
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Creating an administration back office, with CRUD functionality for all your
    models
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Enabling internationalization (i18n), and translating your site into multiple
    languages
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Sending emails easily
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Flask CLI
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In [Chapter 1](2d7573ed-1b2f-48df-9fac-9423d3f1cd51.xhtml), *Getting Started*,
    we introduced some basic features and learned how to use Flask CLI. Now, we are
    going to see how to make good use of this feature.
  prefs: []
  type: TYPE_NORMAL
- en: In Flask CLI, you can create custom commands to be run within the application
    context. Flask CLI itself uses **Click**,which is a library developed by the creator
    of Flask to create command-line tools with complex arguments early.
  prefs: []
  type: TYPE_NORMAL
- en: For further details on Click, take a look at the documentation, available at [http://click.pocoo.org](http://click.pocoo.org).
  prefs: []
  type: TYPE_NORMAL
- en: 'Our goal is to create a set of commands to help us manage and deploy our Flask
    app. The first problem to tackle is where and how we are going to create these
    command-line functions. Since our CLI is an application global utility, we are
    going to place it in `webapp/cli.py`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'We are going to develop all of our functions inside the `register` function,
    so that we don''t have to import our Flask app from the main module. Doing so
    would result in a circular dependency import. Next, take note of the following
    decorators we use:'
  prefs: []
  type: TYPE_NORMAL
- en: '`@app.cli.command` registers that our function has a new command-line command;
    if no argument is passed, then `Click` will assume the function''s name.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`@click.argument` adds a command-line argument; in our case, for username and
    password (needed to create the user credentials). Arguments are positional command-line
    options.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'We register all of our command-line functions in `main.py`. Note the highlighted
    text in the following snippet, where we call the previously created `register` method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: 'From the CLI, let''s try our newly created command as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: Next, you can go to your web browser and log in to our blog using the newly
    created `user10` credentials.
  prefs: []
  type: TYPE_NORMAL
- en: 'The provided code also includes a `list-users` command, but its implementation
    should be straightforward for you by now, without any additional explanation here.
    Let''s focus on a simple and handy function to show all of our app''s routes:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: The `list-routes` command lists all of the routes registered on the `app` object,
    and the URL tied to that route. This is very useful while debugging Flask extensions,
    as it makes it trivial to see whether or not the registration of its blueprints
    is working.
  prefs: []
  type: TYPE_NORMAL
- en: Flask Debug Toolbar
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '**Flask Debug Toolbar** is a Flask extension that aids development by adding
    debugging tools into the web view of your application. It gives you information
    on things such as the bottlenecks of your view rendering code, and how many SQLAlchemy
    queries it took to render the view.'
  prefs: []
  type: TYPE_NORMAL
- en: 'As always, we will use `pip` to install Flask Debug Toolbar and add it to our `requirements.txt` file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: 'Next, we need to add Flask Debug Toolbar to the `webapp/__init__.py` file.
    As we will be modifying this file a lot in this chapter, here is the start of
    the file so far, along with the code to initialize Flask Debug Toolbar:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: 'This is all that is needed to get Flask Debug Toolbar up and running. If the
    `DEBUG` variable in your app''s `config` is set to `true`, the toolbar will appear.
    If `DEBUG` is not set to `true`, the toolbar will not be injected into the page:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/21d3d10e-70e0-49a7-81ad-5d2b1fcd2ad3.png)'
  prefs: []
  type: TYPE_IMG
- en: On the right-hand side of the screen, you will see the toolbar. Each section
    is a link that will display a table of values on the page. To get a list of all
    the functions that were called in order to render the view, click the checkbox
    next to Profiler to enable it, then reload the page and click on Profiler. This
    view easily allows you to quickly diagnose which parts of your apps are the slowest,
    or are called the most.
  prefs: []
  type: TYPE_NORMAL
- en: 'By default, Flask Debug Toolbar intercepts `HTTP 302 redirect` requests. To
    disable this, add the following to your configuration:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: 'Also, if you are using Flask-MongoEngine, you can view all of the queries that
    were made to render the page, by overriding which panels are rendered and adding
    MongoEngine''s custom panel as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: This will add a panel to the toolbar that is very similar to the default SQLAlchemy
    one.
  prefs: []
  type: TYPE_NORMAL
- en: Flask Caching
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In [Chapter 7](2f42c8ba-61f2-4855-bc61-af2c22f24800.xhtml), *Using NoSQL with
    Flask*, we learned that page load time is one of the most important factors that
    will determine the success or failure of your web app. Despite the facts that
    our pages do not change very often, and that new posts will not be made very often,
    we still render the template and query the database every single time the page
    is asked for by our users' browsers.
  prefs: []
  type: TYPE_NORMAL
- en: 'Flask Caching solves this problem by allowing us to store the results of our
    view functions and return the stored results, rather than render the template
    again. First, we need to install Flask Caching on our virtual environment. This
    was already done when running the `init.sh` bash script. The `init.sh` script
    will first install all the declared dependencies in `requirements.txt`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: 'Next, initialize it in `webapp/__init__.py` as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: 'Before we can start caching our views, we need to tell Flask Cache how we want
    to store the results of our new functions:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: The `simple` option tells Flask Cache to store the results in memory in a Python
    dictionary, which, for the vast majority of Flask apps, is adequate. We'll cover
    more types of cache backends later in this section.
  prefs: []
  type: TYPE_NORMAL
- en: Caching views and functions
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In order to cache the results of a view function, simply add a decorator to
    any function:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: The `timeout` parameter specifies how many seconds the cached result should
    last, before the function should again be run and stored. To confirm that the
    view is actually being cached, check the SQLAlchemy section of the Debug toolbar.
    Also, we can see the impact that caching has on page load times, by activating
    the profiler and comparing the times for before and after. On the author's top-of-the-range
    laptop, the main blog page takes 34 ms to render, mainly due to the eight different
    queries that are made to the database. But, after the cache is activated, this
    decreases to 0.08 ms. That's a 462.5 percent increase in speed!
  prefs: []
  type: TYPE_NORMAL
- en: 'View functions are not the only thing that can be cached. To cache any Python
    function, simply add a similar decorator to the function definition, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: The `key_prefix` keyword argument is necessary in order for Flask Caching to
    properly store the results of non-view functions. This needs to be unique for
    every function cached, or the results of the functions will override each other.
    Also, note that the timeout for this function is set to two hours, rather than
    the 60 seconds, as in the previous examples. This is because the results for this
    function are less likely to change than the view functions, and if the data is
    stale, it is not as big of an issue as it would be for the view functions.
  prefs: []
  type: TYPE_NORMAL
- en: Caching functions with parameters
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'However, the normal cache decorator does not take function parameters into
    account. If we cached a function that took parameters with the normal cache decorator,
    it would return the same result for every parameter set. In order to fix this,
    we use the `memoize` function:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: '`Memoize` stores the parameters passed to the function as well as the result.
    In the preceding example, `memoize` is being used to store the result of the `verify_auth_token`
    method, which is called many times, and queries the database every single time.
    This method can safely memoized, because it returns the same result every time
    if the same token is passed to it. The only exception to this rule is if the user
    object gets deleted during the 60 seconds that the function is stored, but this
    is very unlikely.'
  prefs: []
  type: TYPE_NORMAL
- en: Be careful not to `memoize` or cache functions that rely on either globally-scoped
    variables, or on constantly changing data. This can lead to some very subtle bugs,
    and in the worst case, data race. The best candidates for memoization are what
    are referred to as pure functions. **Pure functions** are functions that will
    produce the same result when the same parameters are passed to it. It does not
    matter how many times the function is run. Pure functions also don't have any
    *side effects*, which means that they do not change globally scoped variables.
    This also means that pure functions cannot do any I/O operations. While the `verify_auth_token`
    function is not pure, because it does database I/O, this is okay, because, as
    was stated before, it is very unlikely that the underlying data will change.
  prefs: []
  type: TYPE_NORMAL
- en: 'While we are developing the application, we do not want the view functions
    to be cached, because results will be changing all the time. To fix this, set
    the `CACHE_TYPE` variable to `null` and, in the production configuration, set
    the `CACHE_TYPE` variable to simple, so when the app is deployed, everything works
    as expected:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: Caching routes with query strings
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Some routes, such as our `home` and `post` routes, take the parameters through
    the URL and return content specific to those parameters. We run into a problem
    if routes like these are cached, as the first rendering of the route will be returned
    for all requests, regardless of the URL parameters. The solution to this is rather
    simple. The `key_prefix` keyword argument in the cache method can be either a
    string or a function, which will be executed to dynamically generate a key.
  prefs: []
  type: TYPE_NORMAL
- en: 'This means that a function can be created to create, in turn, a key that is
    tied to the URL parameters, so that each request only returns a cached page if
    that specific combination of parameters was called before. In the `blog/controllers.py`
    file, find the following function:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: We use this function to create a cache key, using a mixture of URL paths, arguments,
    and Flask messages. This will prevent messages from not being shown when a user
    logs out. We will be using this type of cache key generation on the home view
    and show post by ID.
  prefs: []
  type: TYPE_NORMAL
- en: Now, each individual post page will be cached for 10 minutes.
  prefs: []
  type: TYPE_NORMAL
- en: Using Redis as a cache backend
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'If the amount of view functions, or the number of unique parameters, passed
    to your cached functions becomes too large for memory, you can use a different
    backend for the cache. As was mentioned in [Chapter 7](2f42c8ba-61f2-4855-bc61-af2c22f24800.xhtml),
    *Using NoSQL with Flask*, Redis can be used as a backend for the cache. To implement
    that functionality, all that needs to be done is to add the following configuration
    variables to the `ProdConfig` class, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: If you replace the values of the variables with your own data, Flask Cache will
    automatically create a connection to your `redis` database and use it to store
    the results of the functions. All that is needed is to install the Python `redis`
    library. This is already installed after issuing the `init.sh` script, which we
    did to set up the work environment for this chapter. You will find the library
    in `requirements.txt`**:**
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: 'If you want to test your Redis cache, we have prepared a Docker composer file
    that includes RabbitMQ and Redis. To launch it, just issue the following on the
    CLI:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: 'Remember to test your application using the production configuration as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: Using memcached as a cache backend
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Just like the Redis backend, the memcached backend provides an alternative
    way of storing results, should the storage constraints become too limiting. In
    contrast to Redis, memcached is designed to cache objects for later use and reduce
    load on the database. Both Redis and memcached serve the same purpose, and choosing
    one over the other comes down to personal preference. To use memcached, we need
    to install its Python library with the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: 'The process of connecting to your memcached server is handled in the configuration
    object, just like the Redis setup:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: Flask Assets
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Another bottleneck in web applications is the amount of HTTP requests required
    to download the CSS and JavaScript libraries for the page. The extra files can
    only be downloaded after HTML for the page has been loaded and parsed. To combat
    this, many modern browsers download many of these libraries at once, but there
    is a limit to how many simultaneous requests the browser can make.
  prefs: []
  type: TYPE_NORMAL
- en: Several things can be done on the server to reduce the amount of time spent
    downloading these files. The main technique that developers use to solve this
    is to concatenate all of the JavaScript libraries into one file, and all of the
    CSS libraries into another, while removing all of the whitespace and carriage
    returns from the resulting files (also known as **minification**). This reduces
    the overhead of multiple HTTP requests, and can reduce file's size by up to 30
    percent. Another technique is to tell the browser to cache the files locally,
    with specialized HTTP headers, so the file is only loaded again once it changes.
    These can be tedious to do manually, because they need to be done after every
    deployment to the server.
  prefs: []
  type: TYPE_NORMAL
- en: Thankfully, Flask Assets implements all the discussed techniques. Flask Assets
    works by giving it a list of files and a way to concatenate them, and then adding
    a special control block into your templates, in place of the normal link and script
    tags. Flask Assets will then add in a `link` or a `script` tag that links to the
    new generated file. To get started, Flask Assets needs to be installed. We also
    need to install `cssmin` and `jsmin`—you can find these dependencies in `requirements.txt`.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, the collections of files to be concatenated, named bundles, need to be
    created. In `ewebapp/__init__.py`, we have the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: Each `Bundle` object takes an infinite number of files as positional arguments
    to define the files to be bundled, a keyword argument `filters` to define the
    filters to send the files through, and an `output` that defines the filename in
    the `static` folder to which the result will be saved.
  prefs: []
  type: TYPE_NORMAL
- en: The `filters` keyword can be a single value or a list. To get the full list
    of available filters, including automatic Less and CSS compilers, see the docs
    at [http://webassets.readthedocs.org/en/latest/](http://webassets.readthedocs.org/en/latest/).
  prefs: []
  type: TYPE_NORMAL
- en: While it's true that, because our site is light on styles, the CSS bundle only
    has one file in it, it's still a good idea to put the file in a bundle for two
    reasons. Firstly, while we are in development, we can use the un-minified versions
    of the libraries, which makes debugging easier. When the app is deployed to production,
    the libraries are automatically minified. Secondly, these libraries will be sent
    to the browser with the cache headers, when linking them normally in HTML would
    not.
  prefs: []
  type: TYPE_NORMAL
- en: 'Before Flask Assets can be tested, three more changes need to be made. First,
    in the `_init_.py` format, the extension and bundles need to be registered:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: 'Next, the `DevConfig` class needs an extra variable to tell Flask Assets not to compile
    the libraries while in development:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: 'Finally, the link and script tags in both of the `base.html` files need to
    be replaced with the control block from Flask Assets. We have the following in
    the files already:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: 'Replace the preceding snippet with the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: 'Likewise, find the following in the `base.html` files:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: 'Again, replace the preceding code with the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: Now, if you reload the page, all of the CSS and JavaScript will be handled by
    Flask Assets.
  prefs: []
  type: TYPE_NORMAL
- en: Flask Admin
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In [Chapter 6](433b4f3b-4e05-4a63-ae8b-ec2e392877b4.xhtml), *Securing Your App*,
    we created an interface to allow users to create and edit blog posts without having
    to use the CLI. This was adequate to demonstrate the security measures presented
    in the chapter, but there is still no way for posts to be deleted, or to assign
    tags to posts, using the interface. We also do not have a way to delete or edit
    comments that is hidden from regular users. What our app needs is a fully featured
    administrator interface, in the same vein as the WordPress interface. This is
    such a common requirement for apps that a Flask extension, called Flask Admin,
    was produced to help developers create administrator interfaces easily. Once more,
    we can find Flask Admin on the list of dependencies in `requirements.txt`.
  prefs: []
  type: TYPE_NORMAL
- en: 'Since we are going to create a full administrator interface, with forms, views
    and templates, Flask Admin is a good candidate for a new module on our application.
    First, take a look at our new application structure:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: 'As usual, we need to create the  `create_module` function in our `webapp/admin/__init__.py` file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: 'Then, call the `create_module` function in the main `webapp/__init__.py` file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: 'Flask Admin works by registering view classes on the `admin` object that define
    one or more routes. Flask Admin has three main types of views: `ModelView`, `FileAdmin`,
    and `BaseView`. Next, we are going to see how to use these views and customize
    them.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Finally, we add a navigation bar option to the admin interface, and only render
    it to the users that have the admin role. So, in the `templates/navbar.html` file,
    insert the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: Creating basic admin pages
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The `BaseView` class allows normal Flask pages to be added to your `admin`
    interface. This is normally the least used type of view in Flask Admin setups,
    but if you wish to include something like custom reporting with JavaScript charting
    libraries, you can do it with a base view alone. As expected, we are going to
    define our views in the `admin/controllers.py` file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: In a subclass of `BaseView`, multiple views can be registered at once, if they
    are defined together. Keep in mind, however, that each subclass of `BaseView`
    requires at least one exposed method on the `/` path. Also, methods other than
    the method within the `/` path will not be in the navigation of the administrator
    interface, and will have to be linked to the other pages in the class. The expose
    and `self.render` functions work exactly the same as their counterparts in the
    normal Flask API.
  prefs: []
  type: TYPE_NORMAL
- en: 'To have your templates inherit the default styles of Flask Admin, we create
    a new folder in the templates directory, named `admin`, containing a file named
    `custom.html`, and add the following Jinja code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs: []
  type: TYPE_PRE
- en: 'To view this template, an instance of `CustomView` needs to be registered on
    the `admin` object. This will be done in the `create_module` function, following
    the same structure and logic as for the API module:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs: []
  type: TYPE_PRE
- en: 'The `name` keyword argument specifies that the label, used in the navigation
    bar on the top of the `admin` interface, should read `Custom`. After you have
    registered `CustomView` to the `admin` object, your `admin` interface should now
    have a second link in the navigation bar, as shown in the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/53cf3e18-3657-4f5f-a025-99e502d0e002.png)'
  prefs: []
  type: TYPE_IMG
- en: Creating database admin pages
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The main power of Flask Admin comes from the fact that you can automatically
    create administrator pages for your data by giving Flask Admin your SQLAlchemy
    or MongoEngine models. Creating these pages is very easy; in `admin.py`, you just
    need to write the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs: []
  type: TYPE_PRE
- en: 'Then, in `admin/__init__.py`, register  the database `session` object and the
    class with the model you wish to use, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE37]'
  prefs: []
  type: TYPE_PRE
- en: 'The `category` keyword tells Flask Admin to put all of the views with the same
    category value into the same drop-down menu on the navigation bar. If you go to
    the browser now, you will see a new drop-down menu labeled Models, with links
    to the admin pages of all of the tables in the database, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/dd891965-d771-4133-b666-3a74a4965b4e.png)'
  prefs: []
  type: TYPE_IMG
- en: The generated interface for each model provides a lot of functionality. New
    posts can be created, and the existing posts can be deleted in bulk. All of the
    fields can be set from this interface, including the relationship fields, which
    are implemented as searchable drop-down menus. The `date` and `datetime` fields
    even have custom JavaScript inputs with drop-down calendar menus. Overall, this
    is a huge improvement to the hand-created interface that was created in [Chapter
    6](433b4f3b-4e05-4a63-ae8b-ec2e392877b4.xhtml), *Securing Your App*.
  prefs: []
  type: TYPE_NORMAL
- en: Enhancing administration for the post page
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: While this interface is a huge step up in quality, there are some features missing.
    We no longer have the WYSIWYG editor that was available in the original interface,
    but this page can be improved by enabling some of the more powerful Flask Admin
    features.
  prefs: []
  type: TYPE_NORMAL
- en: 'To add the WYSIWYG editor back into the `post` creation page, we will need
    a new `WTForms` field, as Flask Admin constructs its forms with Flask WTF. We
    will also need to override the `textarea` field in the `post` edit and creation
    page with this new field type. The first thing that needs to be done is to create
    the new field type in `admin/forms.py` by using the `textarea` field as a base,
    as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE38]'
  prefs: []
  type: TYPE_PRE
- en: 'In this code, we created a new field type, `CKTextAreaField`, that adds a widget
    to the `textarea`. All that the widget does is adds a class to the HTML tag. Now,
    to add this field to the `Post` admin page, the `Post` will need its own `ModelView`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE39]'
  prefs: []
  type: TYPE_PRE
- en: There are several new things in this code. First, the `form_overrides` class
    variable tells Flask Admin to override the field type of the name text with this
    new field type. The `column_searchable_list` function defines which columns are
    searchable via text. Adding this will allow Flask Admin to include a search field
    on the overview page, with which we can search the values of the defined fields.
    Next, the `column_filters` class variable tells Flask Admin to create a `filters`
    interface on the overview page of this model. The `filters` interface allows columns
    that are not text to be filtered down by adding conditions to the shown rows.
    An example that could be implemented with the preceding code is to create a filter
    that shows all rows with `publish_date` values greater than January 1, 2015.
  prefs: []
  type: TYPE_NORMAL
- en: 'Finally, the `create_template` and `edit_template` class variables allow you
    to define custom templates for Flask Admin to use. For the custom template that
    we will be using, we need to create a new file, `post_edit.html`, in the `admin`
    folder. In this template, we will include the same JavaScript library that was
    used in [Chapter 6](433b4f3b-4e05-4a63-ae8b-ec2e392877b4.xhtml), *Securing Your
    App*, as shown here:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE40]'
  prefs: []
  type: TYPE_PRE
- en: 'Finally, to add our newly created customized view to Flask-Admin, we need to
    add it to the `create_module` function in the `admin/__init__.py` file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE41]'
  prefs: []
  type: TYPE_PRE
- en: 'The tail block of the inherited template is located at the end of the file.
    Once the template is created, your `post` edit and creation page should look like
    this:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/bd0e778c-7096-4441-97c8-4fad385505b4.png)'
  prefs: []
  type: TYPE_IMG
- en: Creating file system admin pages
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Another common function that most `admin` interfaces cover is being able to
    access the server''s file system from the web. Thankfully, Flask Admin includes
    this feature with the `FileAdmin` class:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE42]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, just import the new class into your `admin/__init__.py` file, and pass
    in the path that you wish to be accessible from the web:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE43]'
  prefs: []
  type: TYPE_PRE
- en: Securing Flask Admin
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Currently, the entire `admin` interface is accessible to the world—let''s fix
    that. The routes in the `CustomView` can be secured just like any other route,
    as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE44]'
  prefs: []
  type: TYPE_PRE
- en: 'To secure the `ModeView` and `FileAdmin` subclasses, they need to have a method
    named `is_accessible` defined, which either returns `true` or `false`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE45]'
  prefs: []
  type: TYPE_PRE
- en: Because we set up our authentication correctly in [Chapter 6](433b4f3b-4e05-4a63-ae8b-ec2e392877b4.xhtml),
    *Securing Your App*, this task was trivial.
  prefs: []
  type: TYPE_NORMAL
- en: Flask-Babel
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In this section, we will explore a way to enable internationalization for our
    blog. This is an essential feature for building global websites with multi-language
    support. We will be using the Flask-Babel extension, again created by the author
    of Flask. As always, we will make sure this dependency exists in our `requirements.txt`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE46]'
  prefs: []
  type: TYPE_PRE
- en: 'Flask-Babel uses the Babel Python library for i18 and localization, and adds
    some utilities and Flask integration. To use Flask-Babel, first we need to configure
    Babel in the `babel/babel.cfg` file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE47]'
  prefs: []
  type: TYPE_PRE
- en: We configure Babel to look for text to translate in Python files in the `webapp` directory
    only, and to extract text from `Jinja2` templates in the `webapp/templates` directory.
  prefs: []
  type: TYPE_NORMAL
- en: Then, we need to create a translations directory on `webapp/translations`, where
    all the translations for our supported languages will be.
  prefs: []
  type: TYPE_NORMAL
- en: 'Babel comes with a command-line utility, named `pybabel`. We will use it to
    set up all the languages that our blog will support, in addition to triggering
    an extract process, updating, and compiling. First, to create a new language,
    enter the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE48]'
  prefs: []
  type: TYPE_PRE
- en: Portuguese, or `pt`, is already initialized in the provided support code, but
    you could try creating a new language. Just change `pt` to some other language.
    After this, you can check `webapp/translations`, and should see that Babel has
    created a new directory with our language code. This directory contains a `messages.po` file,
    where we are going to write the translations necessary for the extracted text,
    and a `messages.mo` compiled version of the `messages.po` file.
  prefs: []
  type: TYPE_NORMAL
- en: 'Next, to trigger Babel to search for text to be translated on our application,
    use this command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE49]'
  prefs: []
  type: TYPE_PRE
- en: 'This will update the `messages.pot` main file with all the text that needs
    to be translated. Then, we tell Babel to update all the `messages.po` files for
    all the supported languages with the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE50]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, the `messages.po` files will contain something like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE51]'
  prefs: []
  type: TYPE_PRE
- en: 'Here, the translator will need to update `msgstr` with the translated text
    from `msgid`. English to some target language. After this is done, we will tell
    Babel to compile the `messages.po` files and generate updated `messages.mo` files
    with the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE52]'
  prefs: []
  type: TYPE_PRE
- en: 'How does Babel identify which text to translate on our application? Simple—`Jinja2`
    is already prepared for Babel, so on our templates, we just have to enter the
    following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE53]'
  prefs: []
  type: TYPE_PRE
- en: '`_(''text'')` is an alias for the `gettext` function, and will return a translation
    for the string if one exists, and `ngettext` for text that can become plural.'
  prefs: []
  type: TYPE_NORMAL
- en: 'For Flaskintegration, we are going to create a new module named `webapp/babel`.
    This is where we will initialize the extension. To do this, add the following
    to the `babel/__init__.py` file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE54]'
  prefs: []
  type: TYPE_PRE
- en: 'Then, we need to define a function that returns the current locale code to
    Flask-Babel. The best place to add it is in the `babel/__init__.py` file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE55]'
  prefs: []
  type: TYPE_PRE
- en: We will use the session to hold the currently selected locale, and if none exists,
    we'll fall back to English. Our function is decorated with `@babel.localeselector` to
    register our function on Flask-Babel.
  prefs: []
  type: TYPE_NORMAL
- en: 'Next, we need to define an endpoint that can be called to switch the current
    selected language. This endpoint will set the session locale to the new language
    and redirect to the home page. Do this by adding the following code to the `babel/controllers.py` file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE56]'
  prefs: []
  type: TYPE_PRE
- en: 'Finally, we will create a way for our users to change the current language.
    This will be done on the navigation bar. To do this, add the following to the `templates/navbar.html` file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE57]'
  prefs: []
  type: TYPE_PRE
- en: 'The new navigation bar options will send us to our Babel index endpoint with
    the selected language. Any new languages that we want to support should be added
    here. Finally, we just have to call Babel''s `create_module` function on our main `__init__.py` file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE58]'
  prefs: []
  type: TYPE_PRE
- en: And that's it. We now have all the necessary configurations in place to support
    any language on our blog application.
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/0264c6b3-d3e0-4420-829d-b6a38b377432.png)'
  prefs: []
  type: TYPE_IMG
- en: Flask Mail
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The final Flask extension that this chapter will cover is Flask Mail, which
    allows you to connect and configure your SMTP client from Flask''s configuration.
    Flask Mail will also help to simplify application testing in [Chapter 12](9ffdc8da-2c26-4e97-8738-eebc7629535c.xhtml),
    *Testing Flask Apps*. The first step is to install Flask Mail with `pip`. You
    should already have done this in this chapter, in our `init.sh` script, so let''s
    check our dependencies file for the following to make sure:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE59]'
  prefs: []
  type: TYPE_PRE
- en: '`flask_mail` will connect to our SMTP server of choice by reading the configuration
    variables in our `app` object, so we need to add those values to our `config`
    object:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE60]'
  prefs: []
  type: TYPE_PRE
- en: 'Finally, the `mail` object is initialized on the `app` object in `_init_.py`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE61]'
  prefs: []
  type: TYPE_PRE
- en: 'To see how Flask Mail can simplify our emailing code, consider the following—this
    code snippet is the Remind task that we created in [Chapter 9](5672073f-7a18-4865-9800-a2124147042c.xhtml),
    *Creating Asynchronous Tasks with Celery*, but uses Flask Mail instead of the
    standard library SMTP module:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE62]'
  prefs: []
  type: TYPE_PRE
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The tasks in this chapter have allowed us to grow the functionality of our app
    significantly. We now have a fully featured administrator interface, a useful
    debugging tool in the browser, two tools that greatly speed up page load times,
    and a utility to make sending emails less of a headache.
  prefs: []
  type: TYPE_NORMAL
- en: As was stated at the start of this chapter, Flask is bare-bones, and allows
    you to pick and choose the functionality that you want. Therefore, it is important
    to keep in mind that it is not necessary to include all of these extensions in
    your app. If you are the only content creator working on your app, the CLI might
    be all you need, because adding in these features takes up development time (and
    maintenance time, when they inevitably break). This warning is given at the end
    of the chapter, because one of the main reasons many Flask apps become unwieldy
    is because they include so many extensions, that testing and maintaining all of
    them becomes a very large task.
  prefs: []
  type: TYPE_NORMAL
- en: In the next chapter, you will learn the internals of how an extension works,
    and how to create your own extension.
  prefs: []
  type: TYPE_NORMAL
