- en: Chapter 29
  id: totrans-0
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 第29章
- en: More with Loop Control Structures
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 更多关于循环控制结构的练习
- en: 29.1 Simple Exercises with Loop Control Structures
  id: totrans-2
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 29.1 使用循环控制结构的简单练习
- en: Exercise 29.1-1 Counting the Numbers According to Which is Greater
  id: totrans-3
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 练习29.1-1 根据哪个更大来计数
- en: Write a Python program that prompts the user to enter 10 pairs of numbers and
    then counts and displays the number of times that the first user-provided number
    was greater than the second one and the number of times that the second one was
    greater than the first one.
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 编写一个Python程序，提示用户输入10对数字，然后计算并显示第一个用户提供的数字大于第二个数字的次数和第二个数字大于第一个数字的次数。
- en: Solution
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 解决方案
- en: The Python program is as follows. It uses variable countA to count the number
    of times that the first user-provided number was greater than the second one and
    variable countB to count the number of times that the second one was greater than
    the first one.
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: Python程序如下。它使用变量countA来计数第一个用户提供的数字大于第二个数字的次数，并使用变量countB来计数第二个数字大于第一个数字的次数。
- en: '![](img/my_exercise_header.png) file_29.1-1'
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: '![](img/my_exercise_header.png) file_29.1-1'
- en: countA = 0
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: countA = 0
- en: countB = 0
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: countB = 0
- en: 'for i in range(10):'
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 'for i in range(10):'
- en: 'a = int(input("Enter number A: "))'
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 'a = int(input("输入数字 A: "))'
- en: 'b = int(input("Enter number B: "))'
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 'b = int(input("输入数字 B: "))'
- en: 'if a > b:'
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 'if a > b:'
- en: countA += 1
  id: totrans-14
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: countA += 1
- en: 'elif b > a:'
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 'elif b > a:'
- en: countB += 1
  id: totrans-16
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: countB += 1
- en: print(countA, countB)
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: print(countA, countB)
- en: A reasonable question that someone may ask is “Why is a multiple-decision control
    structure being used? Why not use a dual-alternative decision structure instead?”
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 可能有人会问一个合理的问题：“为什么使用多决策控制结构？为什么不使用双分支决策结构？”
- en: Suppose, indeed, that a dual-alternative decision structure, such as the following,
    is used.
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 假设，确实，使用了以下的双分支决策结构。
- en: 'if a > b:'
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 'if a > b:'
- en: countA += 1
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: countA += 1
- en: 'else:'
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 'else:'
- en: countB += 1
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: countB += 1
- en: In this decision control structure, the variable countB would increment when
    variable b is greater than variable a (this is desirable) but also when variable
    b is equal to variable a (this is undesirable). Using a multiple-decision control
    structure instead would ensure that variable countB increments only when variable
    b is greater than (and not when it is equal to) variable a.
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个决策控制结构中，当变量b大于变量a时（这是期望的），变量countB会增加，但当变量b等于变量a时（这是不期望的），变量countB也会增加。使用多决策控制结构可以确保只有当变量b大于（而不是等于）变量a时，变量countB才会增加。
- en: Exercise 29.1-2 Counting the Numbers According to Their Digits
  id: totrans-25
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 练习29.1-2 根据它们的位数来计数
- en: Write a Python program that prompts the user to enter 20 integers and then counts
    and displays the total number of one-digit, two-digit, and three-digit integers.
    Assume that the user enters values between 1 and 999.
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 编写一个Python程序，提示用户输入20个整数，然后计算并显示一位数、两位数和三位数的总数。假设用户输入的值在1到999之间。
- en: Solution
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 解决方案
- en: Using knowledge from [Exercise 18.1-3](chapter18.html#toc_4), the Python program
    is as follows.
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 使用[练习18.1-3](chapter18.html#toc_4)中的知识，Python程序如下所示。
- en: '![](img/my_exercise_header.png) file_29.1-2'
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: '![](img/my_exercise_header.png) file_29.1-2'
- en: count1 = count2 = count3 = 0
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: count1 = count2 = count3 = 0
- en: 'for i in range(20):'
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 'for i in range(20):'
- en: 'a = int(input("Enter a number: "))'
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 'a = int(input("输入一个数字: "))'
- en: 'if a <= 9:'
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 'if a <= 9:'
- en: count1 += 1
  id: totrans-34
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: count1 += 1
- en: 'elif a <= 99:'
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 'elif a <= 99:'
- en: count2 += 1
  id: totrans-36
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: count2 += 1
- en: 'else:'
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 'else:'
- en: count3 += 1
  id: totrans-38
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: count3 += 1
- en: print(count1, count2, count3)
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: print(count1, count2, count3)
- en: Exercise 29.1-3 How Many Numbers Fit in a Sum
  id: totrans-40
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 练习29.1-3 在一个和中可以放入多少个数
- en: Write a Python program that lets the user enter numeric values repeatedly until
    the sum of them exceeds 1000\. At the end, the program must display the total
    quantity of numbers entered.
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 编写一个Python程序，让用户重复输入数值，直到它们的总和超过1000。最后，程序必须显示输入的总数。
- en: Solution
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 解决方案
- en: In this case, since the exact number of iterations is unknown, a definite loop
    cannot be used; an indefinite loop is required. Let's employ a pre-test loop to
    create that loop. However, to ensure the program is free of logic errors, it is
    crucial to adhere to the “Ultimate” rule discussed in [Section 28.3](chapter28.html#toc_3).
    According to this rule, the pre-test loop structure should be as follows, given
    in general form.
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 在这种情况下，由于迭代的确切次数未知，不能使用确定循环；需要使用不确定循环。让我们使用预测试循环来创建这个循环。然而，为了确保程序没有逻辑错误，必须遵守在[第28.3节](chapter28.html#toc_3)中讨论的“终极”规则。根据此规则，预测试循环的结构应如下所示，以一般形式给出。
- en: Initialize total
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 初始化总数
- en: 'while total <= 1000 :'
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 'while total <= 1000 :'
- en: A statement or block of statements
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 一个语句或语句块
- en: Update/alter total
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 更新/修改总数
- en: Since loop's Boolean expression depends on variable total, this is the variable
    that must be initialized before the loop starts and also updated (altered) within
    the loop. And more specifically, the statement that updates/alters variable total
    must be the last statement of the loop. Following this, the Python program becomes
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 由于循环的布尔表达式依赖于变量 total，因此必须在循环开始之前初始化该变量，并在循环内部更新（修改）。更具体地说，更新/修改变量 total 的语句必须是循环的最后一个语句。遵循此规则后，Python
    程序变为
- en: '![](img/my_exercise_header.png) file_29.1-3'
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: '![](img/my_exercise_header.png) file_29.1-3'
- en: count = 0
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: count = 0
- en: 'total = 0   #Initialization of total'
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 'total = 0   # total 的初始化'
- en: 'while total <= 1000:   #Boolean expression dependent on total'
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 'while total <= 1000:   # 依赖于 total 的布尔表达式'
- en: x = float(input())
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: x = float(input())
- en: count += 1
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: count += 1
- en: 'total += x   #Update/alteration of total'
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 'total += x   # 总数的更新/修改'
- en: print(count)
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: print(count)
- en: Exercise 29.1-4 Finding the Total Number of Positive Integers
  id: totrans-57
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 练习 29.1-4 求正整数的总数
- en: Write a Python program that prompts the user to enter integer values repeatedly
    until a real one is entered. At the end, the program must display the total number
    of positive integers entered.
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 编写一个 Python 程序，提示用户重复输入整数，直到输入一个实数为止。最后，程序必须显示输入的正整数总数。
- en: Solution
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 解答
- en: Once again, you don't know the exact number of iterations, so you cannot use
    a for-loop.
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 再次强调，你不知道确切的迭代次数，因此不能使用 for 循环。
- en: According to the “Ultimate” rule, the pre-test loop structure should be as follows,
    given in general form.
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 根据“终极”规则，预测试循环结构应如下所示，以一般形式给出。
- en: 'x = float(input("Enter a number: "))   #Initialization of x'
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 'x = float(input("输入一个数字: "))   # x 的初始化'
- en: 'while int(x) == x:   #Boolean expression dependent on x'
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 'while int(x) == x:   # 依赖于 x 的布尔表达式'
- en: A statement or block of statements
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 一个语句或语句块
- en: 'x = float(input("Enter a number: "))   #Update/alteration of x'
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 'x = float(input("输入一个数字: "))   # x 的更新/修改'
- en: The final Python program is as follows.
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 最终的 Python 程序如下。
- en: '![](img/my_exercise_header.png) file_29.1-4'
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: '![](img/my_exercise_header.png) file_29.1-4'
- en: count = 0
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: count = 0
- en: 'x = float(input("Enter a number: "))'
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 'x = float(input("输入一个数字: "))'
- en: 'while int(x) == x:'
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 'while int(x) == x:'
- en: 'if x > 0:'
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 'if x > 0:'
- en: count += 1
  id: totrans-72
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: count += 1
- en: 'x = float(input("Enter a number: "))'
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 'x = float(input("输入一个数字: "))'
- en: print(count)
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: print(count)
- en: '![](img/notice.jpg)Note that the program operates properly even when the first
    user-provided number is a real (a float); the pre-test loop structure ensures
    that the flow of execution will never enter the loop for any real numbers!'
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: '![](img/notice.jpg)注意，即使第一个用户提供的数字是实数（浮点数），程序也能正常工作；预测试循环结构确保执行流程永远不会进入循环以处理任何实数！'
- en: Exercise 29.1-5 Iterating as Many Times as the User Wishes
  id: totrans-76
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 练习 29.1-5 用户希望迭代多少次
- en: Write a Python program that prompts the user to enter two numbers and then calculates
    and displays the first number raised to the power of the second one. The program
    must iterate as many times as the user wishes. At the end of each calculation,
    the program must prompt the user if they wish to calculate again. If the answer
    is “yes” the program must repeat; it must end otherwise. Make your program accept
    the answer in all possible forms such as “yes”, “YES”, “Yes”, or even “YeS”.
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 编写一个 Python 程序，提示用户输入两个数字，然后计算并显示第一个数字的第二个数字次幂。程序必须根据用户的意愿迭代多次。每次计算结束后，程序必须提示用户是否希望再次计算。如果答案是“yes”，程序必须重复；否则必须结束。程序应接受所有可能的答案形式，如“yes”、“YES”、“Yes”、“YeS”。
- en: Solution
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 解答
- en: According to the “Ultimate” rule, the pre-test loop structure should be as follows,
    given in general form.
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 根据“终极”规则，预测试循环结构应如下所示，以一般形式给出。
- en: answer = "yes"    #Initialization of answer
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 'answer = "yes"   # answer 的初始化'
- en: 'while answer.upper() != "YES":'
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 'while answer.upper() != "YES":'
- en: Prompt the user to enter two numbers and then calculate and display the first
    number raised to the power of the second one.
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 提示用户输入两个数字，然后计算并显示第一个数字的第二个数字次幂。
- en: '#Update/alteration of answer'
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: '# 更新/修改 answer'
- en: answer = input("Would you like to repeat? ")
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: answer = input("你想重复吗？ ")
- en: '![](img/notice.jpg)The upper() method ensures that the program operates properly
    for any user-provided answer: “yes”, “YES”, “Yes”, or even “YeS” or “yEs”!'
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: '![](img/notice.jpg)upper() 方法确保程序对任何用户提供的答案（“yes”、“YES”、“Yes”、“YeS”或“yEs”）都能正确运行！'
- en: However, instead of using the pre-test loop structure, let's employ the post-test
    loop structure this time. This is a better approach, as the initialization of
    the answer variable outside of the loop can be omitted. Unlike the pre-test loop
    structure, the flow of execution enters the loop in either way, and the initialization
    of the answer will be done inside the post-test loop, as shown in the code fragment
    (given in general form) that follows.
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，这次我们不是使用预测试循环结构，而是使用后测试循环结构。这是一个更好的方法，因为可以在循环外部省略答案变量的初始化。与预测试循环结构不同，执行流程无论哪种方式都会进入循环，答案的初始化将在后测试循环内部完成，如下面的代码片段（以一般形式给出）所示。
- en: 'while True:'
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 'while True:'
- en: Prompt the user to enter two numbers and then calculate and display the first
    number raised to the power of the second one.
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 提示用户输入两个数字，然后计算并显示第一个数字的第二个数字次幂。
- en: '#Initialization and update/alteration of answer'
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: '# 初始化和答案的更新/修改'
- en: answer = input("Would you like to repeat? ")
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: answer = input("你想重复吗？")
- en: 'if answer.upper() != "YES": break'
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 'if answer.upper() != "YES": break'
- en: The solution to this exercise becomes
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 这个练习的解决方案变为
- en: '![](img/my_exercise_header.png) file_29.1-5'
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: '![](img/my_exercise_header.png) file_29.1-5'
- en: 'while True:'
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 'while True:'
- en: 'print("Enter two numbers: ")'
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: print("请输入两个数字：")
- en: a = int(input())
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: a = int(input())
- en: b = int(input())
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: b = int(input())
- en: result = a ** b
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: result = a ** b
- en: print("The result is:", result)
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: print("结果是：", result)
- en: answer = input("Would you like to repeat? ")
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: answer = input("你想重复吗？")
- en: 'if answer.upper() != "YES": break'
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 'if answer.upper() != "YES": break'
- en: Exercise 29.1-6 Finding the Sum of the Digits
  id: totrans-102
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 练习29.1-6 求各位数字之和
- en: Write a Python program that lets the user enter an integer and then calculates
    the sum of its digits.
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 编写一个Python程序，允许用户输入一个整数，然后计算其各位数字之和。
- en: Solution
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 解答
- en: In [Exercise 13.1-2](chapter13.html#toc_3), you learned how to split the digits
    of an integer when its total number of digits was known. In this exercise however,
    the user is allowed to enter any value, no matter how small or large. Thus, the
    total number of the digits is an unknown quantity.
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 在[练习13.1-2](chapter13.html#toc_3)中，你学习了如何在知道整数总位数的情况下分割整数的数字。然而，在这个练习中，用户可以输入任何值，无论大小。因此，数字的总数是一个未知量。
- en: To solve this exercise, a loop control structure could be used. However, there
    are two approaches that you can use.
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 为了解决这个练习，可以使用循环控制结构。然而，您可以使用两种方法。
- en: First approach
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 第一种方法
- en: In this approach, the main idea is to isolate one digit at each iteration. However,
    the challenge lies in determining the total number of iterations required, as
    it hinges on the size of the user-provided integer. So, does this pose a roadblock?
    Certainly not!
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 在这种方法中，主要思想是在每次迭代中隔离一个数字。然而，挑战在于确定所需的迭代总数，因为它取决于用户提供的整数的大小。那么，这会成为一个障碍吗？当然不会！
- en: Within the loop, the user-provided integer should undergo a continuous reduction
    with each iteration until it eventually reaches zero. That value of zero can act
    as a condition to stop the loop control structure from iterating. For instance,
    if the user-provided number is 4753, it should become 475 in the first iteration,
    47 in the second iteration, then 4, and ultimately 0\. Once it reaches 0, the
    iterations must stop.
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 在循环中，用户提供的整数应该在每个迭代中连续减少，直到最终达到零。这个零值可以作为停止循环控制结构迭代的条件。例如，如果用户提供的数字是4753，它应该在第一次迭代中变为475，在第二次迭代中变为47，然后变为4，最终变为0。一旦它达到0，迭代必须停止。
- en: Let's try to comprehend the proposed solution using the following flowchart.
    Some statements are written in general form.
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们尝试使用以下流程图来理解所提出的解决方案。其中一些语句是以一般形式编写的。
- en: '![Image](img/chapter29-01.png)'
  id: totrans-111
  prefs: []
  type: TYPE_IMG
  zh: '![图像](img/chapter29-01.png)'
- en: The statement
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 语句
- en: digit ← Isolate last digit of variable x.
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: digit ← 隔离变量x的最后一位数字。
- en: can be written using the well-known MOD 10 operation as shown here.
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 可以使用众所周知的MOD 10运算符，如下所示。
- en: digit ← x MOD 10
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: digit ← x MOD 10
- en: The whole concept, however, relies on the statement
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，整个概念依赖于以下语句
- en: x ← Keep all except last digit of variable x.
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: x ← 保留变量x的所有数字，除了最后一位。
- en: This is the statement that eventually zeros the value of variable x, and the
    flow of execution then exits the loop. To write this statement you can use a DIV
    10 operation as shown here.
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 这是最终将变量x的值置零的语句，然后执行流程退出循环。要编写此语句，您可以使用如下所示的DIV 10运算符。
- en: x ← x DIV 10
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: x ← x DIV 10
- en: Accordingly, the Python program becomes
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，Python程序变为
- en: '![](img/my_exercise_header.png) file_29.1-6a'
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: '![](img/my_exercise_header.png) file_29.1-6a'
- en: x = int(input())
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: x = int(input())
- en: s = 0
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: s = 0
- en: 'while x != 0:'
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 'while x != 0:'
- en: 'digit = x % 10     #This is the x MOD 10 operation'
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 'digit = x % 10     #这是x MOD 10操作'
- en: s = s + digit
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: s = s + digit
- en: x = x // 10        #This is the x DIV 10 operation
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: x = x // 10        #这是x DIV 10操作
- en: print(s)
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: print(s)
- en: Let's create a trace table for the input value 4753 to better understand what
    is really happening.
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们为输入值4753创建一个跟踪表，以更好地理解实际发生的情况。
- en: '| Step | Statement | Notes | x | digit | s |'
  id: totrans-130
  prefs: []
  type: TYPE_TB
  zh: '| 步骤 | 语句 | 备注 | x | digit | s |'
- en: '| 1 | x = int(input()) | User enters the value 4753 | 4753 | ? | ? |'
  id: totrans-131
  prefs: []
  type: TYPE_TB
  zh: '| 1 | x = int(input()) | 用户输入的值为4753 | 4753 | ? | ? |'
- en: '| 2 | s = 0 |   | 4753 | ? | 0 |'
  id: totrans-132
  prefs: []
  type: TYPE_TB
  zh: '| 2 | s = 0 |   | 4753 | ? | 0 |'
- en: '| 3 | while x != 0: | This evaluates to True |'
  id: totrans-133
  prefs: []
  type: TYPE_TB
  zh: '| 3 | while x != 0: | 这将评估为True |'
- en: '| 4 | digit = x % 10 |   | 4753 | 3 | 0 |'
  id: totrans-134
  prefs: []
  type: TYPE_TB
  zh: '| 4 | digit = x % 10 |   | 4753 | 3 | 0 |'
- en: '| 5 | s = s + digit |   | 4753 | 3 | 3 |'
  id: totrans-135
  prefs: []
  type: TYPE_TB
  zh: '| 5 | s = s + digit |   | 4753 | 3 | 3 |'
- en: '| 6 | x = x // 10 |   | 475 | 3 | 3 |'
  id: totrans-136
  prefs: []
  type: TYPE_TB
  zh: '| 6 | x = x // 10 |   | 475 | 3 | 3 |'
- en: '| 7 | while x != 0: | This evaluates to True |'
  id: totrans-137
  prefs: []
  type: TYPE_TB
  zh: '| 7 | while x != 0: | 这将评估为True |'
- en: '| 8 | digit = x % 10 |   | 475 | 5 | 3 |'
  id: totrans-138
  prefs: []
  type: TYPE_TB
  zh: '| 8 | digit = x % 10 |   | 475 | 5 | 3 |'
- en: '| 9 | s = s + digit |   | 475 | 5 | 8 |'
  id: totrans-139
  prefs: []
  type: TYPE_TB
  zh: '| 9 | s = s + digit |   | 475 | 5 | 8 |'
- en: '| 10 | x = x // 10 |   | 47 | 5 | 8 |'
  id: totrans-140
  prefs: []
  type: TYPE_TB
  zh: '| 10 | x = x // 10 |   | 47 | 5 | 8 |'
- en: '| 11 | while x != 0: | This evaluates to True |'
  id: totrans-141
  prefs: []
  type: TYPE_TB
  zh: '| 11 | while x != 0: | 这将评估为True |'
- en: '| 12 | digit = x % 10 |   | 47 | 7 | 8 |'
  id: totrans-142
  prefs: []
  type: TYPE_TB
  zh: '| 12 | digit = x % 10 |   | 47 | 7 | 8 |'
- en: '| 13 | s = s + digit |   | 47 | 7 | 15 |'
  id: totrans-143
  prefs: []
  type: TYPE_TB
  zh: '| 13 | s = s + digit |   | 47 | 7 | 15 |'
- en: '| 14 | x = x // 10 |   | 4 | 7 | 15 |'
  id: totrans-144
  prefs: []
  type: TYPE_TB
  zh: '| 14 | x = x // 10 |   | 4 | 7 | 15 |'
- en: '| 15 | while x != 0: | This evaluates to True |'
  id: totrans-145
  prefs: []
  type: TYPE_TB
  zh: '| 15 | while x != 0: | 这将评估为True |'
- en: '| 16 | digit = x % 10 |   | 4 | 4 | 15 |'
  id: totrans-146
  prefs: []
  type: TYPE_TB
  zh: '| 16 | digit = x % 10 |   | 4 | 4 | 15 |'
- en: '| 17 | s = s + digit |   | 4 | 4 | 19 |'
  id: totrans-147
  prefs: []
  type: TYPE_TB
  zh: '| 17 | s = s + digit |   | 4 | 4 | 19 |'
- en: '| 18 | x = x // 10 |   | 0 | 4 | 19 |'
  id: totrans-148
  prefs: []
  type: TYPE_TB
  zh: '| 18 | x = x // 10 |   | 0 | 4 | 19 |'
- en: '| 19 | while x != 0: | This evaluates to False |'
  id: totrans-149
  prefs: []
  type: TYPE_TB
  zh: '| 19 | while x != 0: | 这将评估为False |'
- en: '| 20 | print(s) | It displays: 19 |'
  id: totrans-150
  prefs: []
  type: TYPE_TB
  zh: '| 20 | print(s) | 显示：19 |'
- en: Second approach
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 第二种方法
- en: In this approach, the main idea is to convert the user-provided integer to a
    string and then use a for-loop to iterate for all its characters (digits). In
    the for-loop, however, you need to convert each digit from type string back to
    type integer before it is accumulated in variable s. The Python program is as
    follows.
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 在这种方法中，主要思想是将用户提供的整数转换为字符串，然后使用for循环遍历其所有字符（数字）。然而，在for循环中，在将每个数字累积到变量s之前，需要将每个数字从字符串类型转换回整数类型。Python程序如下。
- en: '![](img/my_exercise_header.png) file_29.1-6b'
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: '![](img/my_exercise_header.png) file_29.1-6b'
- en: x = int(input())
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: x = int(input())
- en: s = 0
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: s = 0
- en: 'for digit in str(x):'
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 'for digit in str(x):'
- en: s += int(digit)
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: s += int(digit)
- en: print(s)
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: print(s)
- en: 29.2 Exercises with Nested Loop Control Structures
  id: totrans-159
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 29.2 使用嵌套循环控制结构的练习
- en: Exercise 29.2-1 Displaying all Three-Digit Integers that Contain a Given Digit
  id: totrans-160
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 练习29.2-1 显示包含给定数字的所有三位数
- en: Write a Python program that prompts the user to enter a digit (0 to 9) and then
    displays all three-digit integers that contain that user-provided digit at least
    once. For example, for the user-provided value 7, the values 357, 771, and 700
    are such integers.
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 编写一个Python程序，提示用户输入一个数字（0到9），然后显示所有包含该用户提供的数字至少一次的三位数。例如，对于用户提供的值7，357、771和700都是这样的整数。
- en: Solution
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 解决方案
- en: There are three different approaches! The first one uses just one for-loop,
    the second one uses three for-loops, nested one within the other, and the last
    one uses Python's magic forces. Let's analyze them all!
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 有三种不同的方法！第一种只使用一个for循环，第二种使用三个for循环，嵌套一个在另一个中，最后一种使用Python的魔法力量。让我们分析它们所有！
- en: First approach – Using a for-loop and a decision control structure
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 首种方法 – 使用for循环和决策控制结构
- en: The main idea is to use a for-loop where the value of variable counter goes
    from 100 to 999\. Inside the loop, the counter variable is split into its individual
    digits (digit[3], digit[2], digit[1]) and a decision control structure is used
    to check if at least one of its digits is equal to the provided one. The Python
    program is as follows.
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 主要思想是使用一个for循环，其中变量counter的值从100到999。在循环中，将counter变量分解为其各个数字（digit[3]、digit[2]、digit[1]），并使用决策控制结构检查其数字中至少有一个等于提供的数字。Python程序如下。
- en: '![](img/my_exercise_header.png) file_29.2-1a'
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: '![](img/my_exercise_header.png) file_29.2-1a'
- en: 'x = int(input("Enter a digit 0 - 9: "))'
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 'x = int(input("输入一个数字0 - 9: "))'
- en: 'for i in range(100, 1000):'
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 'for i in range(100, 1000):'
- en: digit3 = i // 100
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: digit3 = i // 100
- en: r = i % 100
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: r = i % 100
- en: digit2 = r // 10
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: digit2 = r // 10
- en: digit1 = r % 10
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: digit1 = r % 10
- en: 'if digit3 == x or digit2 == x or digit1 == x:'
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 'if digit3 == x or digit2 == x or digit1 == x:'
- en: print(i)
  id: totrans-174
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: print(i)
- en: After some refinement, the program can be improved as follows
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 经过一些改进后，程序可以如下改进
- en: '![](img/my_exercise_header.png) file_29.2-1b'
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: '![](img/my_exercise_header.png) file_29.2-1b'
- en: 'x = int(input("Enter a digit 0 - 9: "))'
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 'x = int(input("输入一个数字0 - 9: "))'
- en: 'for i in range(100, 1000):'
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: 'for i in range(100, 1000):'
- en: digit3, r = divmod(i, 100)
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: digit3, r = divmod(i, 100)
- en: digit2, digit1 = divmod(r, 10)
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: digit2, digit1 = divmod(r, 10)
- en: 'if x in [digit1, digit2, digit3]:'
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: 'if x in [digit1, digit2, digit3]:'
- en: print(i)
  id: totrans-182
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: print(i)
- en: Second approach – Using nested loop control structures and a decision control
    structure
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: 第二种方法 - 使用嵌套循环控制结构和决策控制结构
- en: The main idea here is to use three for-loops, nested one within the other. In
    this case, there are three counter variables (digit3, digit2, and digit1) and
    each one of them corresponds to one digit of the three-digit integer. The Python
    program is as follows.
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: 这里的主要思想是使用三个嵌套的 for 循环。在这种情况下，有三个计数器变量（digit3、digit2 和 digit1），每个变量对应三位整数的一个数字。Python
    程序如下。
- en: '![](img/my_exercise_header.png) file_29.2-1c'
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: '![](img/my_exercise_header.png) file_29.2-1c'
- en: 'x = int(input("Enter a digit 0 - 9: "))'
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: 'x = int(input("Enter a digit 0 - 9: "))'
- en: 'for digit3 in range(1, 10):'
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: 'for digit3 in range(1, 10):'
- en: 'for digit2 in range(10):'
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: 'for digit2 in range(10):'
- en: 'for digit1 in range(10):'
  id: totrans-189
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 'for digit1 in range(10):'
- en: 'if x in [digit1, digit2, digit3]:'
  id: totrans-190
  prefs:
  - PREF_BQ
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 'if x in [digit1, digit2, digit3]:'
- en: print(digit3 * 100 + digit2 * 10 + digit1)
  id: totrans-191
  prefs:
  - PREF_BQ
  - PREF_BQ
  - PREF_BQ
  type: TYPE_NORMAL
  zh: print(digit3 * 100 + digit2 * 10 + digit1)
- en: If you follow the flow of execution, the value 100 is the first “integer” evaluated
    (digit3 = 1, digit2 = 0, digit1 = 0). Then, the most-nested loop control structure
    increments variable digit1 by one and the next value evaluated is “integer” 101\.
    This continues until digit1 reaches the value 9; that is, until the “integer”
    reaches the value 109\. The flow of execution then exits the most-nested loop
    control structure, variable digit2 increments by one, and the most-nested loop
    control structure starts over again, thus the values evaluated are the “integers”
    110, 111, 112, … 119\. The process goes on until all integers up to the value
    999 are evaluated.
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您遵循执行流程，100 是第一个“整数”评估的值（digit3 = 1，digit2 = 0，digit1 = 0）。然后，最内层的循环控制结构将变量
    digit1 加一，下一个评估的值是“整数”101。这个过程一直持续到 digit1 达到 9 的值；即，“整数”达到 109 的值。执行流程然后退出最内层的循环控制结构，变量
    digit2 加一，最内层的循环控制结构重新开始，因此评估的值是“整数”110、111、112、… 119。这个过程一直持续到评估所有值直到 999 的整数。
- en: '![](img/notice.jpg)Note that variable digit3 starts from 1, whereas variables
    digit2 and digit1 start from 0\. This is necessary since the scale for three-digit
    numbers begins from 100 and not from 000.'
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: '![](img/notice.jpg)注意变量 digit3 从 1 开始，而变量 digit2 和 digit1 从 0 开始。这是必要的，因为三位数的范围从
    100 开始，而不是从 000 开始。'
- en: '![](img/notice.jpg)Note how the print statement composes the three-digit integer.'
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: '![](img/notice.jpg)注意打印语句如何组合三位整数。'
- en: Third approach – The Pythonic way (version 1.0)
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: 第三种方法 - Python 风格（版本 1.0）
- en: In this approach, the counter variable of a for-loop is converted to string
    and unpacked into three individual variables as shown here.
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: 在这种方法中，for 循环的计数器变量被转换为字符串，并像下面这样解包成三个单独的变量。
- en: '![](img/my_exercise_header.png) file_29.2-1d'
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: '![](img/my_exercise_header.png) file_29.2-1d'
- en: 'x = input("Enter a digit 0 - 9: ")'
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: 'x = input("Enter a digit 0 - 9: ")'
- en: 'for i in range(100, 1000):'
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: 'for i in range(100, 1000):'
- en: digit3, digit2, digit1 = str(i)
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: digit3, digit2, digit1 = str(i)
- en: 'if x in [digit3, digit2, digit1]:'
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: 'if x in [digit3, digit2, digit1]:'
- en: print(i)
  id: totrans-202
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: print(i)
- en: '![](img/notice.jpg)Note that variable x, as well as variables digit1, digit2,
    and digit3, are of type string.'
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: '![](img/notice.jpg)注意变量 x，以及变量 digit1、digit2 和 digit3，都是字符串类型。'
- en: Fourth approach – The Pythonic way (version 2.0)
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: 第四种方法 - Python 风格（版本 2.0）
- en: In this approach, the counter variable of a for-loop is converted to string
    and the in operator checks if the user-provided “digit” exists in the string.
    The Python program is as follows.
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: 在这种方法中，for 循环的计数器变量被转换为字符串，并且 in 操作符检查用户提供的“数字”是否存在于字符串中。Python 程序如下。
- en: '![](img/my_exercise_header.png) file_29.2-1e'
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: '![](img/my_exercise_header.png) file_29.2-1e'
- en: 'x = input("Enter a digit 0 - 9: ")'
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: 'x = input("Enter a digit 0 - 9: ")'
- en: 'for i in range(100, 1000):'
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: 'for i in range(100, 1000):'
- en: 'if x in str(i):'
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
  zh: 'if x in str(i):'
- en: print(i)
  id: totrans-210
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: print(i)
- en: '![](img/notice.jpg)Note that variable x is of type string.'
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
  zh: '![](img/notice.jpg)注意变量 x 是字符串类型。'
- en: Exercise 29.2-2 Displaying all Instances of a Specified Condition
  id: totrans-212
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 练习 29.2-2 显示指定条件的所有实例
- en: Write a Python program that displays all three-digit integers in which the first
    digit is smaller than the second digit and the second digit is smaller than the
    third digit. For example, the values 357, 456, and 159 are such integers.
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
  zh: 编写一个 Python 程序，显示所有三位整数，其中第一位数字小于第二位数字，第二位数字小于第三位数字。例如，357、456 和 159 是这样的整数。
- en: Solution
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
  zh: 解答
- en: Using knowledge from the previous exercise ([Exercise 29.2-1](#toc_9)), there
    are three different approaches! Let's analyze them all!
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
  zh: 利用上一练习（[练习 29.2-1](#toc_9)）的知识，有三种不同的方法！让我们分析一下所有的方法！
- en: First approach – Using a for-loop and a decision control structure
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
  zh: 第一种方法 – 使用for循环和决策控制结构
- en: Using a for-loop and a decision control structure, the Python program is as
    follows.
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
  zh: 使用for循环和决策控制结构，Python程序如下。
- en: '![](img/my_exercise_header.png) file_29.2-2a'
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
  zh: '![](img/my_exercise_header.png) file_29.2-2a'
- en: 'for i in range(100, 1000):'
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
  zh: 'for i in range(100, 1000):'
- en: digit3, r = divmod(i, 100)
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
  zh: digit3, r = divmod(i, 100)
- en: digit2, digit1 = divmod(r, 10)
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
  zh: digit2, digit1 = divmod(r, 10)
- en: 'if digit3 < digit2 and digit2 < digit1:'
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
  zh: 'if digit3 < digit2 and digit2 < digit1:'
- en: print(i)
  id: totrans-223
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: print(i)
- en: Second approach – Using nested loop control structures and a decision control
    structure
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
  zh: 第二种方法 – 使用嵌套循环控制结构和决策控制结构
- en: Using nested loop control structures and a decision control structure, the Python
    program is as follows.
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
  zh: 使用嵌套循环控制结构和决策控制结构，Python程序如下。
- en: '![](img/my_exercise_header.png) file_29.2-2b'
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
  zh: '![](img/my_exercise_header.png) file_29.2-2b'
- en: 'for digit3 in range(1, 10):'
  id: totrans-227
  prefs: []
  type: TYPE_NORMAL
  zh: 'for digit3 in range(1, 10):'
- en: 'for digit2 in range(10):'
  id: totrans-228
  prefs: []
  type: TYPE_NORMAL
  zh: 'for digit2 in range(10):'
- en: 'for digit1 in range(10):'
  id: totrans-229
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 'for digit1 in range(10):'
- en: 'if digit3 < digit2 and digit2 < digit1:'
  id: totrans-230
  prefs:
  - PREF_BQ
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 'if digit3 < digit2 and digit2 < digit1:'
- en: print(digit3 * 100 + digit2 * 10 + digit1)
  id: totrans-231
  prefs:
  - PREF_BQ
  - PREF_BQ
  - PREF_BQ
  type: TYPE_NORMAL
  zh: print(digit3 * 100 + digit2 * 10 + digit1)
- en: Third approach – Using nested loop control structures only
  id: totrans-232
  prefs: []
  type: TYPE_NORMAL
  zh: 第三种方法 – 仅使用嵌套循环控制结构
- en: This approach is based on the second approach. The main difference between them
    is that in this case, variable digit1 always begins from a value greater than
    digit2, and variable digit2 always begins from a value greater than digit3\. In
    that way, the first integer that will be displayed is 123.
  id: totrans-233
  prefs: []
  type: TYPE_NORMAL
  zh: 这种方法基于第二种方法。它们之间的主要区别在于，在这种情况下，变量digit1始终从大于digit2的值开始，而变量digit2始终从大于digit3的值开始。这样，第一个将显示的整数是123。
- en: '![](img/notice.jpg)There are no integers below the value 123 and above the
    value 789 that can validate the Boolean expression digit3 < digit2 and digit2
    < digit1 to True.'
  id: totrans-234
  prefs: []
  type: TYPE_NORMAL
  zh: '![](img/notice.jpg)没有小于123和大于789的整数可以验证布尔表达式digit3 < digit2和digit2 < digit1为真。'
- en: The Python program is as follows.
  id: totrans-235
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是一个Python程序。
- en: '![](img/my_exercise_header.png) file_29.2-2c'
  id: totrans-236
  prefs: []
  type: TYPE_NORMAL
  zh: '![](img/my_exercise_header.png) file_29.2-2c'
- en: 'for digit3 in range(1, 8):'
  id: totrans-237
  prefs: []
  type: TYPE_NORMAL
  zh: 'for digit3 in range(1, 8):'
- en: 'for digit2 in range(digit3 + 1, 9):'
  id: totrans-238
  prefs: []
  type: TYPE_NORMAL
  zh: 'for digit2 in range(digit3 + 1, 9):'
- en: 'for digit1 in range(digit2 + 1, 10):'
  id: totrans-239
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 'for digit1 in range(digit2 + 1, 10):'
- en: print(digit3 * 100 + digit2 * 10 + digit1)
  id: totrans-240
  prefs:
  - PREF_BQ
  - PREF_BQ
  type: TYPE_NORMAL
  zh: print(digit3 * 100 + digit2 * 10 + digit1)
- en: '![](img/notice.jpg)This solution is the most efficient since it doesn''t use
    any decision control structure and, moreover, the number of iterations is kept
    to a minimum!'
  id: totrans-241
  prefs: []
  type: TYPE_NORMAL
  zh: '![](img/notice.jpg)这种解决方案是最有效的，因为它没有使用任何决策控制结构，而且迭代次数保持在最小！'
- en: '![](img/remember.jpg)As you can see, one problem can have many solutions. It
    is up to you to find the optimal one!'
  id: totrans-242
  prefs: []
  type: TYPE_NORMAL
  zh: '![](img/remember.jpg)如您所见，一个问题可以有多个解决方案。取决于您找到最优解！'
- en: 29.3 Data Validation with Loop Control Structures
  id: totrans-243
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 29.3 使用循环控制结构进行数据验证
- en: As you already know, data validation is the process of restricting data input,
    which forces the user to enter only valid values. You have already encountered
    one method of data validation using decision control structures. Let's recall
    an example.
  id: totrans-244
  prefs: []
  type: TYPE_NORMAL
  zh: 正如您已经知道的，数据验证是限制数据输入的过程，这迫使用户只能输入有效的值。您已经遇到了一种使用决策控制结构的数据验证方法。让我们回顾一个例子。
- en: from math import sqrt
  id: totrans-245
  prefs: []
  type: TYPE_NORMAL
  zh: from math import sqrt
- en: 'x = float(input("Enter a non-negative number: "))'
  id: totrans-246
  prefs: []
  type: TYPE_NORMAL
  zh: 'x = float(input("Enter a non-negative number: "))'
- en: 'if x < 0:'
  id: totrans-247
  prefs: []
  type: TYPE_NORMAL
  zh: 'if x < 0:'
- en: 'print("Error: Negative number entered!")'
  id: totrans-248
  prefs: []
  type: TYPE_NORMAL
  zh: 'print("Error: Negative number entered!")'
- en: 'else:'
  id: totrans-249
  prefs: []
  type: TYPE_NORMAL
  zh: 'else:'
- en: print(sqrt(x))
  id: totrans-250
  prefs: []
  type: TYPE_NORMAL
  zh: print(sqrt(x))
- en: This approach, however, may not be the most convenient for the user. If they
    enter an invalid number, the program displays the error message, and the flow
    of execution inevitably reaches the end. The user must then restart the program
    to re-enter a valid number.
  id: totrans-251
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，这种方法可能对用户来说并不方便。如果他们输入了一个无效的数字，程序会显示错误信息，执行流程不可避免地达到末尾。然后，用户必须重新启动程序以重新输入一个有效的数字。
- en: Next, you will find three approaches given in general form for validating data
    input using loop control structures. In cases where a user enters an invalid value,
    the primary objective is to prompt them repeatedly until they eventually provide
    a valid one. Of course, if the user initially enters a valid value, the flow of
    execution simply proceeds to the next section of the program.
  id: totrans-252
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，您将找到三种使用循环控制结构验证数据输入的一般形式的解决方案。在用户输入无效值的情况下，主要目标是反复提示他们，直到他们最终提供一个有效的值。当然，如果用户最初输入了一个有效的值，执行流程将简单地继续到程序的下一部分。
- en: Which approach you use depends on whether or not you wish to display an error
    message and whether you wish to display different error messages, one for each
    type of input error, or just a generic error message for any kind of error.
  id: totrans-253
  prefs: []
  type: TYPE_NORMAL
  zh: 你选择哪种方法取决于你是否希望显示错误信息，以及你是否希望为每种输入错误显示不同的错误信息，或者只是显示一个通用的错误信息来处理任何类型的错误。
- en: First approach – Validating data input without error messages
  id: totrans-254
  prefs: []
  type: TYPE_NORMAL
  zh: 第一种方法 – 无错误信息的验证数据输入
- en: To validate data input without displaying any error messages, you can use the
    following code fragment given in general form.
  id: totrans-255
  prefs: []
  type: TYPE_NORMAL
  zh: 要在没有显示任何错误信息的情况下验证数据输入，你可以使用以下代码片段，以通用形式给出。
- en: 'while True:'
  id: totrans-256
  prefs: []
  type: TYPE_NORMAL
  zh: 'while True:'
- en: input_data = input("Prompt message")
  id: totrans-257
  prefs: []
  type: TYPE_NORMAL
  zh: input_data = input("提示信息")
- en: if input_data test 1 succeeds and    \
  id: totrans-258
  prefs: []
  type: TYPE_NORMAL
  zh: if input_data 测试 1 成功且
- en: input_data test 2 succeeds and    \
  id: totrans-259
  prefs: []
  type: TYPE_NORMAL
  zh: input_data 测试 2 成功且
- en: …
  id: totrans-260
  prefs: []
  type: TYPE_NORMAL
  zh: …
- en: 'input_data test N succeeds: break'
  id: totrans-261
  prefs: []
  type: TYPE_NORMAL
  zh: input_data 测试 N 成功：break
- en: Second approach – Validating data input with a generic error message
  id: totrans-262
  prefs: []
  type: TYPE_NORMAL
  zh: 第二种方法 – 使用通用错误信息验证数据输入
- en: To validate data input and display a generic error message (that is, the same
    error message for any type of input error), you can use the following code fragment
    given in general form.
  id: totrans-263
  prefs: []
  type: TYPE_NORMAL
  zh: 要验证数据输入并显示一个通用的错误信息（即，对于任何类型的输入错误都是相同的错误信息），你可以使用以下代码片段，以通用形式给出。
- en: input_data = input("Prompt message")
  id: totrans-264
  prefs: []
  type: TYPE_NORMAL
  zh: input_data = input("提示信息")
- en: while input_data test 1 fails or    \
  id: totrans-265
  prefs: []
  type: TYPE_NORMAL
  zh: while input_data 测试 1 失败或
- en: input_data test 2 fails or    \
  id: totrans-266
  prefs: []
  type: TYPE_NORMAL
  zh: input_data 测试 2 失败或
- en: …
  id: totrans-267
  prefs: []
  type: TYPE_NORMAL
  zh: …
- en: 'input_data test N fails:'
  id: totrans-268
  prefs: []
  type: TYPE_NORMAL
  zh: input_data 测试 N 失败：
- en: print("Error message")
  id: totrans-269
  prefs: []
  type: TYPE_NORMAL
  zh: print("错误信息")
- en: input_data = input("Prompt message")
  id: totrans-270
  prefs: []
  type: TYPE_NORMAL
  zh: input_data = input("提示信息")
- en: Third approach – Validating data input with different error messages
  id: totrans-271
  prefs: []
  type: TYPE_NORMAL
  zh: 第三种方法 – 使用不同的错误信息验证数据输入
- en: To validate data input and display a different error message for each type of
    input error, you can use the following code fragment given in general form.
  id: totrans-272
  prefs: []
  type: TYPE_NORMAL
  zh: 要验证数据输入并显示每种输入错误的特定错误信息，你可以使用以下代码片段，以通用形式给出。
- en: 'while True:'
  id: totrans-273
  prefs: []
  type: TYPE_NORMAL
  zh: 'while True:'
- en: input_data = input("Prompt message")
  id: totrans-274
  prefs: []
  type: TYPE_NORMAL
  zh: input_data = input("提示信息")
- en: failure = False
  id: totrans-275
  prefs: []
  type: TYPE_NORMAL
  zh: failure = False
- en: 'if input_data test 1 fails:'
  id: totrans-276
  prefs: []
  type: TYPE_NORMAL
  zh: if input_data 测试 1 失败：
- en: print("Error message 1")
  id: totrans-277
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: print("错误信息 1")
- en: failure = True
  id: totrans-278
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: failure = True
- en: 'elif input_data test 2 fails:'
  id: totrans-279
  prefs: []
  type: TYPE_NORMAL
  zh: elif input_data 测试 2 失败：
- en: print("Error message 2")
  id: totrans-280
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: print("错误信息 2")
- en: failure = True
  id: totrans-281
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: failure = True
- en: elif …
  id: totrans-282
  prefs: []
  type: TYPE_NORMAL
  zh: elif …
- en: …
  id: totrans-283
  prefs: []
  type: TYPE_NORMAL
  zh: …
- en: 'elif input_data test N fails:'
  id: totrans-284
  prefs: []
  type: TYPE_NORMAL
  zh: elif input_data 测试 N 失败：
- en: print("Error message N")
  id: totrans-285
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: print("错误信息 N")
- en: failure = True
  id: totrans-286
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: failure = True
- en: 'if not failure: break'
  id: totrans-287
  prefs: []
  type: TYPE_NORMAL
  zh: 'if not failure: break'
- en: '![](img/notice.jpg)The statement if not failure is equivalent to the statement
    if failure == False'
  id: totrans-288
  prefs: []
  type: TYPE_NORMAL
  zh: '![](img/notice.jpg)if not failure 等价于 if failure == False'
- en: Exercise 29.3-1 Finding Odd and Even Numbers - Validation Without Error Messages
  id: totrans-289
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 练习 29.3-1 寻找奇偶数 - 无错误信息的验证
- en: Write a Python program that prompts the user to enter a non-negative integer,
    and then displays a message indicating whether this number is even; it must display
    “Odd” otherwise. Using a loop control structure, the program must also validate
    data input, allowing the user to enter only a non-negative integer.
  id: totrans-290
  prefs: []
  type: TYPE_NORMAL
  zh: 编写一个 Python 程序，提示用户输入一个非负整数，然后显示一条消息，指出该数字是偶数；如果不是，则显示“Odd”。使用循环控制结构，程序还必须验证数据输入，允许用户只能输入一个非负整数。
- en: Solution
  id: totrans-291
  prefs: []
  type: TYPE_NORMAL
  zh: 解答
- en: All three approaches for validating data input that you learned in [Section
    29.3](#toc_11) will be presented here. But first, let's solve this exercise without
    data validation.
  id: totrans-292
  prefs: []
  type: TYPE_NORMAL
  zh: 在 [第 29.3 节](#toc_11) 中学习到的所有三种验证数据输入的方法都将在此处展示。但首先，让我们在不进行数据验证的情况下解决这个练习。
- en: 'x = float(input("Enter a non-negative integer: "))   [[More…]](more.html#more_29_3_1_1)'
  id: totrans-293
  prefs: []
  type: TYPE_NORMAL
  zh: 'x = float(input("输入一个非负整数: "))   [[更多…]](more.html#more_29_3_1_1)'
- en: 'if x % 2 == 0:'
  id: totrans-294
  prefs: []
  type: TYPE_NORMAL
  zh: 'if x % 2 == 0:'
- en: print("Even")
  id: totrans-295
  prefs: []
  type: TYPE_NORMAL
  zh: print("Even")
- en: 'else:'
  id: totrans-296
  prefs: []
  type: TYPE_NORMAL
  zh: 'else:'
- en: print("Odd")
  id: totrans-297
  prefs: []
  type: TYPE_NORMAL
  zh: print("Odd")
- en: Validation Without Error Messages
  id: totrans-298
  prefs: []
  type: TYPE_NORMAL
  zh: 无错误信息的验证
- en: To validate data input without displaying any error messages, use the first
    approach from [Section 29.3](#toc_11). Simply replace the statements marked with
    a dashed rectangle with the following code fragment.
  id: totrans-299
  prefs: []
  type: TYPE_NORMAL
  zh: 要在没有显示任何错误信息的情况下验证数据输入，请使用 [第 29.3 节](#toc_11) 中的第一种方法。只需将带有虚线框的语句替换为以下代码片段。
- en: 'while True:'
  id: totrans-300
  prefs: []
  type: TYPE_NORMAL
  zh: 'while True:'
- en: 'x = float(input("Enter a non-negative integer: "))'
  id: totrans-301
  prefs: []
  type: TYPE_NORMAL
  zh: 'x = float(input("输入一个非负整数: "))'
- en: 'if x >= 0 and int(x) == x: break'
  id: totrans-302
  prefs: []
  type: TYPE_NORMAL
  zh: 'if x >= 0 and int(x) == x: break'
- en: '![](img/notice.jpg)Instead of the function int(), the function float() is used
    in the data input stage. This is necessary in order to allow the user to enter
    either an integer or a float.'
  id: totrans-303
  prefs: []
  type: TYPE_NORMAL
  zh: '![](img/notice.jpg)在数据输入阶段，使用的是 float() 函数而不是 int() 函数。这是为了允许用户输入整数或浮点数。'
- en: The final Python program becomes
  id: totrans-304
  prefs: []
  type: TYPE_NORMAL
  zh: 最终的 Python 程序变为
- en: '![](img/my_exercise_header.png) file_29.3-1a'
  id: totrans-305
  prefs: []
  type: TYPE_NORMAL
  zh: '![](img/my_exercise_header.png) file_29.3-1a'
- en: while True:                                   [[More…]](more.html#more_29_3_1_2)
  id: totrans-306
  prefs: []
  type: TYPE_NORMAL
  zh: while True:                                   [[更多…]](more.html#more_29_3_1_2)
- en: 'x = float(input("Enter a non-negative integer: "))'
  id: totrans-307
  prefs: []
  type: TYPE_NORMAL
  zh: 'x = float(input("Enter a non-negative integer: "))'
- en: 'if x >= 0 and int(x) == x: break'
  id: totrans-308
  prefs: []
  type: TYPE_NORMAL
  zh: 'if x >= 0 and int(x) == x: break'
- en: 'if x % 2 == 0:'
  id: totrans-309
  prefs: []
  type: TYPE_NORMAL
  zh: 'if x % 2 == 0:'
- en: print("Even")
  id: totrans-310
  prefs: []
  type: TYPE_NORMAL
  zh: print("Even")
- en: 'else:'
  id: totrans-311
  prefs: []
  type: TYPE_NORMAL
  zh: 'else:'
- en: print("Odd")
  id: totrans-312
  prefs: []
  type: TYPE_NORMAL
  zh: print("Odd")
- en: Validation with a Generic Error Message
  id: totrans-313
  prefs: []
  type: TYPE_NORMAL
  zh: Validation with a Generic Error Message
- en: To validate data input and display a generic error message, replace the statements
    marked with the dashed rectangle with a code fragment based on the second approach
    from [Section 29.3](#toc_11). The Python program is as follows.
  id: totrans-314
  prefs: []
  type: TYPE_NORMAL
  zh: 为了验证数据输入并显示一个通用的错误信息，将带有虚线矩形的语句替换为基于[第29.3节](#toc_11)的第二种方法的代码片段。Python程序如下。
- en: '![](img/my_exercise_header.png) file_29.3-1b'
  id: totrans-315
  prefs: []
  type: TYPE_NORMAL
  zh: '![](img/my_exercise_header.png) file_29.3-1b'
- en: 'x = float(input("Enter a non-negative integer: "))    [[More…]](more.html#more_29_3_1_3)'
  id: totrans-316
  prefs: []
  type: TYPE_NORMAL
  zh: 'x = float(input("Enter a non-negative integer: "))    [[更多…]](more.html#more_29_3_1_3)'
- en: 'while x < 0 or x != int(x):'
  id: totrans-317
  prefs: []
  type: TYPE_NORMAL
  zh: 'while x < 0 or x != int(x):'
- en: print("Error! A negative value or a float entered.")
  id: totrans-318
  prefs: []
  type: TYPE_NORMAL
  zh: print("Error! A negative value or a float entered.")
- en: 'x = float(input("Enter a non-negative integer: "))'
  id: totrans-319
  prefs: []
  type: TYPE_NORMAL
  zh: 'x = float(input("Enter a non-negative integer: "))'
- en: 'if x % 2 == 0:'
  id: totrans-320
  prefs: []
  type: TYPE_NORMAL
  zh: 'if x % 2 == 0:'
- en: print("Even")
  id: totrans-321
  prefs: []
  type: TYPE_NORMAL
  zh: print("Even")
- en: 'else:'
  id: totrans-322
  prefs: []
  type: TYPE_NORMAL
  zh: 'else:'
- en: print("Odd")
  id: totrans-323
  prefs: []
  type: TYPE_NORMAL
  zh: print("Odd")
- en: Validation with Different Error Messages
  id: totrans-324
  prefs: []
  type: TYPE_NORMAL
  zh: Validation with Different Error Messages
- en: Here, the replacing code fragment is based on the third approach from [Section
    29.3](#toc_11). To validate data input and display a different error message for
    each type of input error, the Python program is as follows.
  id: totrans-325
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，替换的代码片段基于[第29.3节](#toc_11)的第三种方法。为了验证数据输入并针对每种输入错误显示不同的错误信息，Python程序如下。
- en: '![](img/my_exercise_header.png) file_29.3-1c'
  id: totrans-326
  prefs: []
  type: TYPE_NORMAL
  zh: '![](img/my_exercise_header.png) file_29.3-1c'
- en: while True:                                    [[More…]](more.html#more_29_3_1_4)
  id: totrans-327
  prefs: []
  type: TYPE_NORMAL
  zh: while True:                                    [[更多…]](more.html#more_29_3_1_4)
- en: 'x = float(input("Enter a non-negative integer: "))'
  id: totrans-328
  prefs: []
  type: TYPE_NORMAL
  zh: 'x = float(input("Enter a non-negative integer: "))'
- en: failure = False
  id: totrans-329
  prefs: []
  type: TYPE_NORMAL
  zh: failure = False
- en: 'if x < 0:'
  id: totrans-330
  prefs: []
  type: TYPE_NORMAL
  zh: 'if x < 0:'
- en: print("Error! You entered a negative value")
  id: totrans-331
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: print("Error! You entered a negative value")
- en: failure = True
  id: totrans-332
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: failure = True
- en: 'elif x != int(x):'
  id: totrans-333
  prefs: []
  type: TYPE_NORMAL
  zh: 'elif x != int(x):'
- en: print("Error! You entered a float")
  id: totrans-334
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: print("Error! You entered a float")
- en: failure = True
  id: totrans-335
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: failure = True
- en: 'if not failure: break'
  id: totrans-336
  prefs: []
  type: TYPE_NORMAL
  zh: 'if not failure: break'
- en: 'if x % 2 == 0:'
  id: totrans-337
  prefs: []
  type: TYPE_NORMAL
  zh: 'if x % 2 == 0:'
- en: print("Even")
  id: totrans-338
  prefs: []
  type: TYPE_NORMAL
  zh: print("Even")
- en: 'else:'
  id: totrans-339
  prefs: []
  type: TYPE_NORMAL
  zh: 'else:'
- en: print("Odd")
  id: totrans-340
  prefs: []
  type: TYPE_NORMAL
  zh: print("Odd")
- en: Exercise 29.3-2 Finding the Sum of Four Numbers
  id: totrans-341
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: Exercise 29.3-2 Finding the Sum of Four Numbers
- en: Write a Python program that prompts the user to enter four positive numbers
    and then calculates and displays their sum. Using a loop control structure, the
    program must also validate data input and display an error message when the user
    enters any non-positive value.
  id: totrans-342
  prefs: []
  type: TYPE_NORMAL
  zh: 编写一个Python程序，提示用户输入四个正数，然后计算并显示它们的总和。使用循环控制结构，程序必须验证数据输入，并在用户输入任何非正值时显示错误信息。
- en: Solution
  id: totrans-343
  prefs: []
  type: TYPE_NORMAL
  zh: Solution
- en: This exercise was already discussed in [Exercise 25.1-4](chapter25.html#toc_5).
    The only difference here is that this program must validate data input and display
    an error message when the user enters invalid values. For your convenience, the
    solution proposed in that exercise is reproduced next.
  id: totrans-344
  prefs: []
  type: TYPE_NORMAL
  zh: 这个练习已经在[练习25.1-4](chapter25.html#toc_5)中讨论过了。这里唯一的区别是，这个程序必须验证数据输入，并在用户输入无效值时显示错误信息。为了方便起见，该练习中提出的解决方案如下。
- en: total = 0
  id: totrans-345
  prefs: []
  type: TYPE_NORMAL
  zh: total = 0
- en: 'for i in range(4):'
  id: totrans-346
  prefs: []
  type: TYPE_NORMAL
  zh: 'for i in range(4):'
- en: 'x = float(input("Enter a number: "))   [[More…]](more.html#more_29_3_2_1)'
  id: totrans-347
  prefs: []
  type: TYPE_NORMAL
  zh: 'x = float(input("Enter a number: "))   [[更多…]](more.html#more_29_3_2_1)'
- en: total = total + x
  id: totrans-348
  prefs: []
  type: TYPE_NORMAL
  zh: total = total + x
- en: print(total)
  id: totrans-349
  prefs: []
  type: TYPE_NORMAL
  zh: print(total)
- en: The primary purpose of this exercise is to demonstrate how to nest the loop
    control structure that validates data input into other pre-existing loop control
    structures. In this exercise, you should replace the statement marked with a dashed
    rectangle with the following code fragment
  id: totrans-350
  prefs: []
  type: TYPE_NORMAL
  zh: 本练习的主要目的是演示如何将验证数据输入的循环控制结构嵌套到其他现有的循环控制结构中。在这个练习中，你应该将带有虚线矩形的语句替换为以下代码片段
- en: 'x = float(input("Enter a number: "))'
  id: totrans-351
  prefs: []
  type: TYPE_NORMAL
  zh: 'x = float(input("Enter a number: "))'
- en: 'while x <= 0:'
  id: totrans-352
  prefs: []
  type: TYPE_NORMAL
  zh: 'while x <= 0:'
- en: print("Please enter a positive value!")
  id: totrans-353
  prefs: []
  type: TYPE_NORMAL
  zh: print("Please enter a positive value!")
- en: 'x = float(input("Enter a number: "))'
  id: totrans-354
  prefs: []
  type: TYPE_NORMAL
  zh: 'x = float(input("Enter a number: "))'
- en: and the final Python program becomes
  id: totrans-355
  prefs: []
  type: TYPE_NORMAL
  zh: 最终的Python程序变为
- en: '![](img/my_exercise_header.png) file_29.3-2'
  id: totrans-356
  prefs: []
  type: TYPE_NORMAL
  zh: '![](img/my_exercise_header.png) file_29.3-2'
- en: total = 0
  id: totrans-357
  prefs: []
  type: TYPE_NORMAL
  zh: total = 0
- en: 'for i in range(4):'
  id: totrans-358
  prefs: []
  type: TYPE_NORMAL
  zh: 'for i in range(4):'
- en: 'x = float(input("Enter a number: "))   [[More…]](more.html#more_29_3_2_2)'
  id: totrans-359
  prefs: []
  type: TYPE_NORMAL
  zh: 'x = float(input("Enter a number: "))   [[更多…]](more.html#more_29_3_2_2)'
- en: 'while x <= 0:'
  id: totrans-360
  prefs: []
  type: TYPE_NORMAL
  zh: 'while x <= 0:'
- en: print("Please enter a positive value!")
  id: totrans-361
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: print("Please enter a positive value!")
- en: 'x = float(input("Enter a number: "))'
  id: totrans-362
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 'x = float(input("Enter a number: "))'
- en: total = total + x
  id: totrans-363
  prefs: []
  type: TYPE_NORMAL
  zh: total = total + x
- en: print(total)
  id: totrans-364
  prefs: []
  type: TYPE_NORMAL
  zh: print(total)
- en: '![](img/notice.jpg)Note that the replacing code fragment is entirely nested
    within this outer for-loop.'
  id: totrans-365
  prefs: []
  type: TYPE_NORMAL
  zh: '![注意](img/notice.jpg)注意，替换的代码片段完全嵌套在这个外层for循环中。'
- en: 29.4 Finding Minimum and Maximum Values with Loop Control Structures
  id: totrans-366
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 29.4 使用循环控制结构查找最小和最大值
- en: In [Section 22.2](chapter22.html#toc_8) you learned how to find the minimum
    and maximum values among four values using single-alternative decision structures.
    Now, the following code fragment achieves the same result but uses only one variable
    w, for the user-provided values.
  id: totrans-367
  prefs: []
  type: TYPE_NORMAL
  zh: 在[第22.2节](chapter22.html#toc_8)中，你学习了如何使用单选择决策结构在四个值中查找最小和最大值。现在，以下代码片段实现了相同的结果，但只使用了一个变量w，用于用户提供的值。
- en: 'w = int(input())     #User enters 1st value'
  id: totrans-368
  prefs: []
  type: TYPE_NORMAL
  zh: 'w = int(input())     #用户输入第1个值'
- en: maximum = w
  id: totrans-369
  prefs: []
  type: TYPE_NORMAL
  zh: 最大值 = w
- en: 'w = int(input())     #User enters 2nd value'
  id: totrans-370
  prefs: []
  type: TYPE_NORMAL
  zh: 'w = int(input())     #用户输入第2个值'
- en: 'if w > maximum:'
  id: totrans-371
  prefs: []
  type: TYPE_NORMAL
  zh: 'if w > maximum:'
- en: maximum = w
  id: totrans-372
  prefs: []
  type: TYPE_NORMAL
  zh: 最大值 = w
- en: 'w = int(input())     #User enters 3rd value'
  id: totrans-373
  prefs: []
  type: TYPE_NORMAL
  zh: 'w = int(input())     #用户输入第3个值'
- en: 'if w > maximum:'
  id: totrans-374
  prefs: []
  type: TYPE_NORMAL
  zh: 'if w > maximum:'
- en: maximum = w
  id: totrans-375
  prefs: []
  type: TYPE_NORMAL
  zh: 最大值 = w
- en: 'w = int(input())     #User enters 4th value'
  id: totrans-376
  prefs: []
  type: TYPE_NORMAL
  zh: 'w = int(input())     #用户输入第4个值'
- en: 'if w > maximum:'
  id: totrans-377
  prefs: []
  type: TYPE_NORMAL
  zh: 'if w > maximum:'
- en: maximum = w
  id: totrans-378
  prefs: []
  type: TYPE_NORMAL
  zh: 最大值 = w
- en: Except for the first pair of statements, all other blocks of statements are
    identical. Therefore, you can retain only one of these pairs and enclose it within
    a loop control structure that performs three iterations, as presented below.
  id: totrans-379
  prefs: []
  type: TYPE_NORMAL
  zh: 除了第一对语句外，所有其他语句块都是相同的。因此，你可以保留这些对中的一对，并将其包含在一个执行三次迭代的循环控制结构中，如下所示。
- en: 'w = int(input())     #User enters 1st value'
  id: totrans-380
  prefs: []
  type: TYPE_NORMAL
  zh: 'w = int(input())     #用户输入第1个值'
- en: maximum = w
  id: totrans-381
  prefs: []
  type: TYPE_NORMAL
  zh: 最大值 = w
- en: 'for i in range(3):'
  id: totrans-382
  prefs: []
  type: TYPE_NORMAL
  zh: 'for i in range(3):'
- en: 'w = int(input())     #User enters 2nd, 3rd and 4th value'
  id: totrans-383
  prefs: []
  type: TYPE_NORMAL
  zh: 'w = int(input())     #用户输入第2个、第3个和第4个值'
- en: 'if w > maximum:'
  id: totrans-384
  prefs: []
  type: TYPE_NORMAL
  zh: 'if w > maximum:'
- en: maximum = w
  id: totrans-385
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 最大值 = w
- en: Of course, if you want to allow the user to enter more values, you can simply
    increase the final_value of the for-loop.
  id: totrans-386
  prefs: []
  type: TYPE_NORMAL
  zh: 当然，如果你想允许用户输入更多的值，你可以简单地增加for循环的final_value。
- en: Accordingly, a program that finds and displays the heaviest person among 10
    individuals is presented next.
  id: totrans-387
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，下面展示了一个程序，该程序查找并显示10个人中体重最重的人。
- en: '![](img/my_exercise_header.png) file_29.4a'
  id: totrans-388
  prefs: []
  type: TYPE_NORMAL
  zh: '![我的练习标题](img/my_exercise_header.png) file_29.4a'
- en: 'w = int(input("Enter a weight (in pounds): "))'
  id: totrans-389
  prefs: []
  type: TYPE_NORMAL
  zh: w = int(input("输入体重（以磅为单位）："))
- en: maximum = w
  id: totrans-390
  prefs: []
  type: TYPE_NORMAL
  zh: 最大值 = w
- en: 'for i in range(9):'
  id: totrans-391
  prefs: []
  type: TYPE_NORMAL
  zh: 'for i in range(9):'
- en: 'w = int(input("Enter a weight (in pounds): "))'
  id: totrans-392
  prefs: []
  type: TYPE_NORMAL
  zh: w = int(input("输入体重（以磅为单位）："))
- en: 'if w > maximum:'
  id: totrans-393
  prefs: []
  type: TYPE_NORMAL
  zh: 'if w > maximum:'
- en: maximum = w
  id: totrans-394
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 最大值 = w
- en: print(maximum)
  id: totrans-395
  prefs: []
  type: TYPE_NORMAL
  zh: print(maximum)
- en: '![](img/notice.jpg)Note that the for-loop iterates one time less than the total
    number of user-provided values.'
  id: totrans-396
  prefs: []
  type: TYPE_NORMAL
  zh: '![注意](img/notice.jpg)注意，for循环迭代的次数比用户提供的值的总数少一次。'
- en: Even though this Python program operates fine, let's do something slightly different.
    Instead of prompting the user to enter the first value before the loop and the
    remaining nine values within the loop, let's prompt them to enter all values within
    the loop.
  id: totrans-397
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管这个Python程序运行良好，但让我们做一些稍微不同的事情。而不是在循环之前提示用户输入第一个值，然后在循环中输入剩余的九个值，让我们在循环中提示他们输入所有值。
- en: However, the issue that arises here is that, no matter what, an initial value
    must always be assigned to the variable maximum before the loop starts iterating.
    But, this value cannot be arbitrarily chosen; it depends on the given problem.
    Therefore, choosing an “almost arbitrary” initial value requires careful consideration,
    as an incorrect choice may yield inaccurate results.
  id: totrans-398
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，这里出现的问题是，无论如何，在循环开始迭代之前，必须始终给变量最大值分配一个初始值。但是，这个值不能随意选择；它取决于给定的问题。因此，选择一个“几乎随意的”初始值需要仔细考虑，因为错误的选择可能会导致不准确的结果。
- en: In this exercise, all user-provided values have to do with people's weight.
    Since there is no chance of finding any person with a negative weight (at least
    not on planet Earth), you can safely assign the initial value −1 to variable maximum,
    as follows.
  id: totrans-399
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个练习中，所有用户提供的值都与人们的体重有关。由于在地球上不可能找到任何体重为负的人（至少不是在地球上），你可以安全地将初始值-1分配给变量最大值，如下所示。
- en: '![](img/my_exercise_header.png) file_29.4b'
  id: totrans-400
  prefs: []
  type: TYPE_NORMAL
  zh: '![我的练习标题](img/my_exercise_header.png) file_29.4b'
- en: maximum = -1
  id: totrans-401
  prefs: []
  type: TYPE_NORMAL
  zh: 最大值 = -1
- en: 'for i in range(10):'
  id: totrans-402
  prefs: []
  type: TYPE_NORMAL
  zh: 'for i in range(10):'
- en: 'w = int(input("Enter a weight (in pounds): "))'
  id: totrans-403
  prefs: []
  type: TYPE_NORMAL
  zh: w = int(input("输入体重（以磅为单位）："))
- en: 'if w > maximum:'
  id: totrans-404
  prefs: []
  type: TYPE_NORMAL
  zh: 'if w > maximum:'
- en: maximum = w
  id: totrans-405
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 最大值 = w
- en: print(maximum)
  id: totrans-406
  prefs: []
  type: TYPE_NORMAL
  zh: print(maximum)
- en: Once the flow of execution enters the loop, the user enters the first value
    and the decision control structure evaluates to True. The initial value −1 in
    variable maximum is then overwritten by this first user-provided value and afterward,
    the flow of execution proceeds normally.
  id: totrans-407
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦执行流程进入循环，用户输入第一个值，决策控制结构评估为True。然后，变量maximum中的初始值-1被这个第一个用户提供的值覆盖，之后执行流程正常进行。
- en: '![](img/notice.jpg)Note that this method may not be applicable in all cases.
    If an exercise requires prompting the user to enter any number (not limited to
    positive ones), this method cannot be applied, as the user could potentially enter
    only negative values. If this were to occur, the initial value of −1 would never
    be replaced by any of the user-provided values. This method can be used to find
    the maximum value only when the lower limit of user-provided values is known,
    or to find the minimum value only when the upper limit of user-provided values
    is known. For instance, if the exercise requires finding the lightest person,
    you can assign the initial value +1500 to variable minimum, as there is no human
    on Earth who can weigh that much! For reference, Jon Brower Minnoch was an American
    who, at his peak weight, was recorded as the heaviest human being ever, weighing
    approximately 1,400 lb!!!!!'
  id: totrans-408
  prefs: []
  type: TYPE_NORMAL
  zh: '![](img/notice.jpg)请注意，这种方法可能不适用于所有情况。如果练习要求提示用户输入任何数字（不仅限于正数），则不能应用此方法，因为用户可能会只输入负值。如果发生这种情况，初始值-1将永远不会被用户提供的任何值替换。当用户提供的值的下限已知时，可以使用此方法找到最大值；或者当用户提供的值的上限已知时，可以找到最小值。例如，如果练习要求找到最轻的人，可以将变量minimum的初始值设置为+1500，因为地球上没有人能重达如此之多！为了参考，乔恩·布朗·米诺奇是一位美国人，在他体重最高的时候，被记录为有史以来最重的人类，体重约为1400磅!!!!!'
- en: Exercise 29.4-1 Validating and Finding the Minimum and the Maximum Value
  id: totrans-409
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 练习29.4-1 验证并找到最小值和最大值
- en: Write a Python program that prompts the user to enter the weight of 10 people
    and then finds the lightest and the heaviest weights. Using a loop control structure,
    the program must also validate data input and display an error message when the
    user enters any non-positive value, or any value greater than 1500.
  id: totrans-410
  prefs: []
  type: TYPE_NORMAL
  zh: 编写一个Python程序，提示用户输入10个人的体重，然后找出最轻和最重的体重。使用循环控制结构，程序还必须验证数据输入，并在用户输入任何非正值或任何大于1500的值时显示错误信息。
- en: Solution
  id: totrans-411
  prefs: []
  type: TYPE_NORMAL
  zh: 解答
- en: Using the previous exercise as a guide, you should now be able to do this with
    your eyes closed!
  id: totrans-412
  prefs: []
  type: TYPE_NORMAL
  zh: 使用上一个练习作为指导，你现在应该能够闭着眼睛完成这个任务！
- en: To validate data input, all you have to do is replace the following line of
    code of the previous exercise,
  id: totrans-413
  prefs: []
  type: TYPE_NORMAL
  zh: 为了验证数据输入，你只需要替换上一个练习中的以下代码行，
- en: 'w = int(input("Enter a weight (in pounds): "))'
  id: totrans-414
  prefs: []
  type: TYPE_NORMAL
  zh: w = int(input("请输入一个体重（以磅为单位）："))
- en: 'with the following code fragment:'
  id: totrans-415
  prefs: []
  type: TYPE_NORMAL
  zh: 使用以下代码片段：
- en: 'w = int(input("Enter a weight between 1 and 1500 (in pounds): "))'
  id: totrans-416
  prefs: []
  type: TYPE_NORMAL
  zh: w = int(input("请输入一个介于1到1500（以磅为单位）之间的重量："))
- en: 'while w < 1 or x > 1500:'
  id: totrans-417
  prefs: []
  type: TYPE_NORMAL
  zh: 'while w < 1 or x > 1500:'
- en: 'w = int(input("Invalid value! Enter a weight between 1 and 1500 (in pounds):
    "))'
  id: totrans-418
  prefs: []
  type: TYPE_NORMAL
  zh: w = int(input("无效值！请输入一个介于1到1500（以磅为单位）之间的重量："))
- en: Following is the final program that finds the lightest and the heaviest weights.
  id: totrans-419
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是一个找到最轻和最重体重的最终程序。
- en: '![](img/my_exercise_header.png) file_29.4-1'
  id: totrans-420
  prefs: []
  type: TYPE_NORMAL
  zh: '![](img/my_exercise_header.png) file_29.4-1'
- en: minimum = 1500
  id: totrans-421
  prefs: []
  type: TYPE_NORMAL
  zh: minimum = 1500
- en: maximum = 0
  id: totrans-422
  prefs: []
  type: TYPE_NORMAL
  zh: maximum = 0
- en: 'for i in range(10):'
  id: totrans-423
  prefs: []
  type: TYPE_NORMAL
  zh: 'for i in range(10):'
- en: 'w = int(input("Enter a weight between 1 and 1500 (in pounds): "))          [[More…]](more.html#more_29_4_1_1)'
  id: totrans-424
  prefs: []
  type: TYPE_NORMAL
  zh: w = int(input("请输入一个介于1到1500（以磅为单位）之间的重量："))          [[更多…]](more.html#more_29_4_1_1)
- en: 'while w < 1 or w > 1500:'
  id: totrans-425
  prefs: []
  type: TYPE_NORMAL
  zh: 'while w < 1 or w > 1500:'
- en: 'w = int(input("Invalid value! Enter a weight between 1 and 1500 (in pounds):
    "))'
  id: totrans-426
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: w = int(input("无效值！请输入一个介于1到1500（以磅为单位）之间的重量："))
- en: 'if w < minimum:'
  id: totrans-427
  prefs: []
  type: TYPE_NORMAL
  zh: 'if w < minimum:'
- en: minimum = w
  id: totrans-428
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: minimum = w
- en: 'if w > maximum:'
  id: totrans-429
  prefs: []
  type: TYPE_NORMAL
  zh: 'if w > maximum:'
- en: maximum = w
  id: totrans-430
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: maximum = w
- en: print(minimum, maximum)
  id: totrans-431
  prefs: []
  type: TYPE_NORMAL
  zh: print(minimum, maximum)
- en: Exercise 29.4-2 Validating and Finding the Hottest Planet
  id: totrans-432
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 练习29.4-2 验证并找到最热的行星
- en: Write a Python program that prompts the user to repeatedly enter the names and
    the average temperatures of planets from space, until the word “STOP” (used as
    a name) is entered. In the end, the program must display the name of the hottest
    planet. Moreover, since −459.67^o (on the Fahrenheit scale) is the lowest temperature
    possible (it is called absolute zero), the program must also validate data input
    (using  a loop control structure) and display an error message when the user enters
    temperature values lower than absolute zero.
  id: totrans-433
  prefs: []
  type: TYPE_NORMAL
  zh: 编写一个Python程序，提示用户反复输入来自太空的行星名称和平均温度，直到输入“STOP”（用作名称）为止。最后，程序必须显示最热行星的名称。此外，由于-459.67^o（华氏温度）是可能达到的最低温度（称为绝对零度），程序还必须验证数据输入（使用循环控制结构），并在用户输入低于绝对零度的温度值时显示错误信息。
- en: Solution
  id: totrans-434
  prefs: []
  type: TYPE_NORMAL
  zh: 解决方案
- en: 'First, let''s write the Python program without using data validation. According
    to the “Ultimate” rule, the pre-test loop structure should be as follows, given
    in general form:'
  id: totrans-435
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，让我们编写一个不使用数据验证的Python程序。根据“终极”规则，预测试循环结构应如下所示，以一般形式给出：
- en: 'name = input("Enter the name of a planet: ")  #Initialization of name'
  id: totrans-436
  prefs: []
  type: TYPE_NORMAL
  zh: 'name = input("输入行星名称: ")  #名称初始化'
- en: 'while name.upper() != "STOP":'
  id: totrans-437
  prefs: []
  type: TYPE_NORMAL
  zh: 'while name.upper() != "STOP":'
- en: A statement or block of statements
  id: totrans-438
  prefs: []
  type: TYPE_NORMAL
  zh: 一个语句或语句块
- en: 'name = input("Enter the name of a planet: ")   #Update/alteration of name'
  id: totrans-439
  prefs: []
  type: TYPE_NORMAL
  zh: 'name = input("输入行星名称: ")   #名称更新/修改'
- en: Now, let's add the rest of the statements, still without data input validation.
    Keep in mind that, since value −459.67^o is the lower limit of the temperature
    scale, you can use a value lower than this as the initial value of variable maximum.
  id: totrans-440
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们添加其余的语句，仍然不进行数据输入验证。请注意，由于值-459.67^o是温度尺度的下限，你可以使用低于这个值的值作为变量maximum的初始值。
- en: maximum = -460
  id: totrans-441
  prefs: []
  type: TYPE_NORMAL
  zh: maximum = -460
- en: mName = ""
  id: totrans-442
  prefs: []
  type: TYPE_NORMAL
  zh: mName = ""
- en: 'name = input("Enter the name of a planet: ")'
  id: totrans-443
  prefs: []
  type: TYPE_NORMAL
  zh: 'name = input("输入行星名称: ")'
- en: 'while name.upper() != "STOP":'
  id: totrans-444
  prefs: []
  type: TYPE_NORMAL
  zh: 'while name.upper() != "STOP":'
- en: 't = float(input("Enter its average temperature: "))'
  id: totrans-445
  prefs: []
  type: TYPE_NORMAL
  zh: 't = float(input("输入其平均温度: "))'
- en: 'if t > maximum:'
  id: totrans-446
  prefs: []
  type: TYPE_NORMAL
  zh: 'if t > maximum:'
- en: maximum = t
  id: totrans-447
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: maximum = t
- en: mName = name
  id: totrans-448
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: mName = name
- en: 'name = input("Enter the name of a planet: ")'
  id: totrans-449
  prefs: []
  type: TYPE_NORMAL
  zh: 'name = input("输入行星名称: ")'
- en: 'if maximum != -460:'
  id: totrans-450
  prefs: []
  type: TYPE_NORMAL
  zh: 'if maximum != -460:'
- en: print("The hottest planet is:", mName)
  id: totrans-451
  prefs: []
  type: TYPE_NORMAL
  zh: print("最热的行星是:", mName)
- en: 'else:'
  id: totrans-452
  prefs: []
  type: TYPE_NORMAL
  zh: 'else:'
- en: print("Nothing Entered!")
  id: totrans-453
  prefs: []
  type: TYPE_NORMAL
  zh: print("未输入任何内容！")
- en: '![](img/notice.jpg)The if maximum != -460 statement is required because there
    is a possibility that the user could enter the word “STOP” right from the beginning.'
  id: totrans-454
  prefs: []
  type: TYPE_NORMAL
  zh: '![](img/notice.jpg)需要if maximum != -460语句，因为用户有可能从一开始就输入“STOP”这个词。'
- en: 'To validate the data input, all you have to do is replace the following line
    of code:'
  id: totrans-455
  prefs: []
  type: TYPE_NORMAL
  zh: 为了验证数据输入，你只需替换以下代码行：
- en: 't = float(input("Enter its average temperature: "))'
  id: totrans-456
  prefs: []
  type: TYPE_NORMAL
  zh: 't = float(input("输入其平均温度: "))'
- en: 'with the following code fragment:'
  id: totrans-457
  prefs: []
  type: TYPE_NORMAL
  zh: 'with the following code fragment:'
- en: 't = float(input("Enter its average temperature: "))'
  id: totrans-458
  prefs: []
  type: TYPE_NORMAL
  zh: 't = float(input("输入其平均温度: "))'
- en: 'while t < -459.67:'
  id: totrans-459
  prefs: []
  type: TYPE_NORMAL
  zh: 'while t < -459.67:'
- en: 't = float(input("Invalid value! Enter its average temperature: "))'
  id: totrans-460
  prefs: []
  type: TYPE_NORMAL
  zh: 't = float(input("无效值！输入其平均温度: "))'
- en: The final program is as follows.
  id: totrans-461
  prefs: []
  type: TYPE_NORMAL
  zh: 最终程序如下。
- en: '![](img/my_exercise_header.png) file_29.4-2'
  id: totrans-462
  prefs: []
  type: TYPE_NORMAL
  zh: '![](img/my_exercise_header.png) file_29.4-2'
- en: maximum = -460
  id: totrans-463
  prefs: []
  type: TYPE_NORMAL
  zh: maximum = -460
- en: mName = ""
  id: totrans-464
  prefs: []
  type: TYPE_NORMAL
  zh: mName = ""
- en: 'name = input("Enter the name of a planet: ")'
  id: totrans-465
  prefs: []
  type: TYPE_NORMAL
  zh: 'name = input("输入行星名称: ")'
- en: 'while name.upper() != "STOP":'
  id: totrans-466
  prefs: []
  type: TYPE_NORMAL
  zh: 'while name.upper() != "STOP":'
- en: 't = float(input("Enter its average temperature: "))'
  id: totrans-467
  prefs: []
  type: TYPE_NORMAL
  zh: 't = float(input("输入其平均温度: "))'
- en: 'while t < -459.67:'
  id: totrans-468
  prefs: []
  type: TYPE_NORMAL
  zh: 'while t < -459.67:'
- en: 't = float(input("Invalid value! Enter its average temperature: "))'
  id: totrans-469
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 't = float(input("无效值！输入其平均温度: "))'
- en: 'if t > maximum:'
  id: totrans-470
  prefs: []
  type: TYPE_NORMAL
  zh: 'if t > maximum:'
- en: maximum = t
  id: totrans-471
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: maximum = t
- en: mName = name
  id: totrans-472
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: mName = name
- en: 'name = input("Enter the name of a planet: ")'
  id: totrans-473
  prefs: []
  type: TYPE_NORMAL
  zh: 'name = input("输入行星名称: ")'
- en: 'if maximum != -460:'
  id: totrans-474
  prefs: []
  type: TYPE_NORMAL
  zh: 'if maximum != -460:'
- en: print("The hottest planet is:", mName)
  id: totrans-475
  prefs: []
  type: TYPE_NORMAL
  zh: print("最热的行星是:", mName)
- en: 'else:'
  id: totrans-476
  prefs: []
  type: TYPE_NORMAL
  zh: 'else:'
- en: print("Nothing Entered!")
  id: totrans-477
  prefs: []
  type: TYPE_NORMAL
  zh: print("未输入任何内容！")
- en: Exercise 29.4-3 ”Making the Grade”
  id: totrans-478
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 练习29.4-3 “获得高分”
- en: In a classroom, there are 20 students. Write a Python program that prompts the
    teacher to enter the grades (0 ‐ 100) that students received in a math test and
    then displays the highest grade as well as the number of students that got an
    “A” (that is, 90 to 100). Moreover, the program must validate data input. User-provided
    values must be within the range 0 to 100.
  id: totrans-479
  prefs: []
  type: TYPE_NORMAL
  zh: 在教室里，有20名学生。编写一个Python程序，提示教师输入学生在数学考试中获得的分数（0至100分），然后显示最高分以及获得“A”（即90至100分）的学生人数。此外，程序必须验证数据输入。用户提供的值必须在0至100分的范围内。
- en: Solution
  id: totrans-480
  prefs: []
  type: TYPE_NORMAL
  zh: 解决方案
- en: Let's first write the program without data validation. Since the number of students
    is known, you can use a for-loop. For an initial value of variable maximum, you
    can use value −1 as there is no grade lower than 0.
  id: totrans-481
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们先编写一个没有数据验证的程序。由于学生人数已知，可以使用for循环。对于变量maximum的初始值，可以使用值-1，因为没有低于0的分数。
- en: maximum = -1
  id: totrans-482
  prefs: []
  type: TYPE_NORMAL
  zh: maximum = -1
- en: count = 0
  id: totrans-483
  prefs: []
  type: TYPE_NORMAL
  zh: count = 0
- en: 'for i in range(20):'
  id: totrans-484
  prefs: []
  type: TYPE_NORMAL
  zh: 'for i in range(20):'
- en: 'grade = int(input("Grade for student No" + str(i + 1) + ": "))'
  id: totrans-485
  prefs: []
  type: TYPE_NORMAL
  zh: 'grade = int(input("学生编号" + str(i + 1) + "的分数: "))'
- en: 'if grade > maximum:'
  id: totrans-486
  prefs: []
  type: TYPE_NORMAL
  zh: 'if grade > maximum:'
- en: maximum = grade
  id: totrans-487
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: maximum = grade
- en: 'if grade >= 90:'
  id: totrans-488
  prefs: []
  type: TYPE_NORMAL
  zh: 'if grade >= 90:'
- en: count += 1
  id: totrans-489
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: count += 1
- en: print(maximum, count)
  id: totrans-490
  prefs: []
  type: TYPE_NORMAL
  zh: print(maximum, count)
- en: 'Now, you can deal with data validation. As the wording of the exercise implies,
    there is no need to display any error messages. So, all you need to do is replace
    the following line of code:'
  id: totrans-491
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，你可以处理数据验证。根据练习的措辞，不需要显示任何错误信息。所以，你需要做的就是替换以下代码行：
- en: 'grade = int(input("Grade for student No" + str(i + 1) + ": "))'
  id: totrans-492
  prefs: []
  type: TYPE_NORMAL
  zh: 'grade = int(input("学生编号" + str(i + 1) + "的分数: "))'
- en: 'with the following code fragment:'
  id: totrans-493
  prefs: []
  type: TYPE_NORMAL
  zh: 使用以下代码片段：
- en: 'while True:'
  id: totrans-494
  prefs: []
  type: TYPE_NORMAL
  zh: 'while True:'
- en: 'grade = int(input("Grade for student No" + str(i + 1) + ": "))'
  id: totrans-495
  prefs: []
  type: TYPE_NORMAL
  zh: 'grade = int(input("学生编号" + str(i + 1) + "的分数: "))'
- en: 'if 0 <= grade <= 100: break'
  id: totrans-496
  prefs: []
  type: TYPE_NORMAL
  zh: 'if 0 <= grade <= 100: break'
- en: and the final program becomes
  id: totrans-497
  prefs: []
  type: TYPE_NORMAL
  zh: 最终程序变为
- en: '![](img/my_exercise_header.png) file_29.4-3'
  id: totrans-498
  prefs: []
  type: TYPE_NORMAL
  zh: '![](img/my_exercise_header.png) file_29.4-3'
- en: maximum = -1
  id: totrans-499
  prefs: []
  type: TYPE_NORMAL
  zh: maximum = -1
- en: count = 0
  id: totrans-500
  prefs: []
  type: TYPE_NORMAL
  zh: count = 0
- en: 'for i in range(20):'
  id: totrans-501
  prefs: []
  type: TYPE_NORMAL
  zh: 'for i in range(20):'
- en: 'while True:'
  id: totrans-502
  prefs: []
  type: TYPE_NORMAL
  zh: 'while True:'
- en: 'grade = int(input("Grade for student No" + str(i + 1) + ": "))'
  id: totrans-503
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 'grade = int(input("学生编号" + str(i + 1) + "的分数: "))'
- en: 'if 0 <= grade <= 100: break'
  id: totrans-504
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 'if 0 <= grade <= 100: break'
- en: 'if grade > maximum:'
  id: totrans-505
  prefs: []
  type: TYPE_NORMAL
  zh: 'if grade > maximum:'
- en: maximum = grade
  id: totrans-506
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: maximum = grade
- en: 'if grade >= 90:'
  id: totrans-507
  prefs: []
  type: TYPE_NORMAL
  zh: 'if grade >= 90:'
- en: count += 1
  id: totrans-508
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: count += 1
- en: print(maximum, count)
  id: totrans-509
  prefs: []
  type: TYPE_NORMAL
  zh: print(maximum, count)
- en: 29.5 Using Loop Control Structures to Solve Mathematical Problems
  id: totrans-510
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 29.5 使用循环控制结构解决数学问题
- en: Exercise 29.5-1 Calculating the Area of as Many Triangles as the User Wishes
  id: totrans-511
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 练习29.5-1 计算用户想要的任意多个三角形的面积
- en: Write a Python program that prompts the user to enter the lengths of all three
    sides A, B, and C of a triangle and then calculates and displays its area. You
    can use Heron's formula,
  id: totrans-512
  prefs: []
  type: TYPE_NORMAL
  zh: 编写一个Python程序，提示用户输入三角形的三边长度A、B和C，然后计算并显示其面积。你可以使用海伦公式，
- en: .![Image](img/chapter12-24.png)
  id: totrans-513
  prefs: []
  type: TYPE_NORMAL
  zh: .![Image](img/chapter12-24.png)
- en: where S is the semi-perimeter
  id: totrans-514
  prefs: []
  type: TYPE_NORMAL
  zh: 其中S是半周长
- en: .![Image](img/chapter12-25.png)
  id: totrans-515
  prefs: []
  type: TYPE_NORMAL
  zh: .![Image](img/chapter12-25.png)
- en: The program must iterate as many times as the user wishes. At the end of each
    area calculation, the program must ask the user if they wish to calculate the
    area of another triangle. If the answer is “yes” the program must repeat; it must
    end otherwise. Make your program accept the answer in all possible forms such
    as “yes”, “YES”, “Yes”, or even “YeS”.
  id: totrans-516
  prefs: []
  type: TYPE_NORMAL
  zh: 程序必须根据用户的意愿迭代多次。每次面积计算结束后，程序必须询问用户是否想要计算另一个三角形的面积。如果答案是“是”，程序必须重复；否则必须结束。程序应接受所有可能的答案形式，如“是”、“YES”、“Yes”或甚至“YeS”。
- en: Moreover, using a loop control structure, the program must validate data input
    and display an error message when the user enters any non-positive value.
  id: totrans-517
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，使用循环控制结构，程序必须验证数据输入，并在用户输入任何非正值时显示错误信息。
- en: Solution
  id: totrans-518
  prefs: []
  type: TYPE_NORMAL
  zh: 解决方案
- en: According to the “Ultimate” rule, the post-test loop structure should be as
    follows, given in general form.
  id: totrans-519
  prefs: []
  type: TYPE_NORMAL
  zh: 根据“终极”规则，后测试循环结构应如下所示，以一般形式给出。
- en: 'answer = "yes"   #Initialization of answer (redundant).'
  id: totrans-520
  prefs: []
  type: TYPE_NORMAL
  zh: 'answer = "yes"   #答案的初始化（冗余）。'
- en: 'while True:'
  id: totrans-521
  prefs: []
  type: TYPE_NORMAL
  zh: 'while True:'
- en: Prompt the user to enter the lengths of all three sides A, B, C of a triangle
    and then calculate and display its area.
  id: totrans-522
  prefs: []
  type: TYPE_NORMAL
  zh: 提示用户输入三角形的三边长度A、B、C，然后计算并显示其面积。
- en: '#Update/alteration of answer'
  id: totrans-523
  prefs: []
  type: TYPE_NORMAL
  zh: '#答案的更新/修改'
- en: answer = input("Would you like to repeat? ")
  id: totrans-524
  prefs: []
  type: TYPE_NORMAL
  zh: answer = input("你想重复吗？")
- en: 'if answer.upper() != "YES": break'
  id: totrans-525
  prefs: []
  type: TYPE_NORMAL
  zh: 'if answer.upper() != "YES": break'
- en: '![](img/remember.jpg)The upper() method ensures that the program operates properly
    for any user-provided answer “Yes”, “yes”, “YES” or even “YeS” or “yEs”!'
  id: totrans-526
  prefs: []
  type: TYPE_NORMAL
  zh: '![](img/remember.jpg)upper()方法确保程序对用户提供的任何答案“是”、“yes”、“YES”或甚至“YeS”或“yEs”都能正常工作！'
- en: The solution to this exercise is as follows.
  id: totrans-527
  prefs: []
  type: TYPE_NORMAL
  zh: 本练习的解决方案如下。
- en: '![](img/my_exercise_header.png) file_29.5-1'
  id: totrans-528
  prefs: []
  type: TYPE_NORMAL
  zh: '![](img/my_exercise_header.png) file_29.5-1'
- en: from math import sqrt
  id: totrans-529
  prefs: []
  type: TYPE_NORMAL
  zh: from math import sqrt
- en: 'while True:'
  id: totrans-530
  prefs: []
  type: TYPE_NORMAL
  zh: 'while True:'
- en: '#Prompt the user to enter the length of side A'
  id: totrans-531
  prefs: []
  type: TYPE_NORMAL
  zh: '#提示用户输入边长A的长度'
- en: 'a = float(input("Enter side A: "))'
  id: totrans-532
  prefs: []
  type: TYPE_NORMAL
  zh: 'a = float(input("输入边长A: "))'
- en: 'while a <= 0:'
  id: totrans-533
  prefs: []
  type: TYPE_NORMAL
  zh: 'while a <= 0:'
- en: 'a = float(input("Invalid side. Enter side A: "))'
  id: totrans-534
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 'a = float(input("无效的边长。请输入边长A: "))'
- en: '#Prompt the user to enter the length of side B'
  id: totrans-535
  prefs: []
  type: TYPE_NORMAL
  zh: '#提示用户输入边长B的长度'
- en: 'b = float(input("Enter side B: "))'
  id: totrans-536
  prefs: []
  type: TYPE_NORMAL
  zh: 'b = float(input("输入边长B: "))'
- en: 'while b <= 0:'
  id: totrans-537
  prefs: []
  type: TYPE_NORMAL
  zh: 'while b <= 0:'
- en: 'b = float(input("Invalid side. Enter side B: "))'
  id: totrans-538
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 'b = float(input("无效的边长。请输入边长 B: "))'
- en: '#Prompt the user to enter the length of side C'
  id: totrans-539
  prefs: []
  type: TYPE_NORMAL
  zh: '#提示用户输入边长 C 的长度'
- en: 'c = float(input("Enter side C: "))'
  id: totrans-540
  prefs: []
  type: TYPE_NORMAL
  zh: 'c = float(input("输入边长 C: "))'
- en: 'while c <= 0:'
  id: totrans-541
  prefs: []
  type: TYPE_NORMAL
  zh: 'while c <= 0:'
- en: 'c = float(input("Invalid side. Enter side C: "))'
  id: totrans-542
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 'c = float(input("无效的边长。请输入边长 C: "))'
- en: '#Calculate and display the area of the triangle'
  id: totrans-543
  prefs: []
  type: TYPE_NORMAL
  zh: '#计算并显示三角形的面积'
- en: s = (a + b + c) / 2
  id: totrans-544
  prefs: []
  type: TYPE_NORMAL
  zh: s = (a + b + c) / 2
- en: area = sqrt(s * (s - a) * (s - b) * (s - c))
  id: totrans-545
  prefs: []
  type: TYPE_NORMAL
  zh: area = sqrt(s * (s - a) * (s - b) * (s - c))
- en: print("The area is:", area)
  id: totrans-546
  prefs: []
  type: TYPE_NORMAL
  zh: print("面积是:", area)
- en: answer = input("Would you like to repeat? ")
  id: totrans-547
  prefs: []
  type: TYPE_NORMAL
  zh: answer = input("你想重复吗？")
- en: 'if answer.upper() != "YES": break'
  id: totrans-548
  prefs: []
  type: TYPE_NORMAL
  zh: 'if answer.upper() 不等于 "YES": break'
- en: Exercise 29.5-2 Finding x and y
  id: totrans-549
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 练习 29.5-2 求解 x 和 y
- en: 'Write a Python program that displays all possible integer values of x and y
    within the range −20 to +20 that validate the following formula:'
  id: totrans-550
  prefs: []
  type: TYPE_NORMAL
  zh: 编写一个 Python 程序，显示在范围 -20 到 +20 内所有可能的整数 x 和 y 值，这些值验证以下公式：
- en: 3x² − 6y² = 6
  id: totrans-551
  prefs: []
  type: TYPE_NORMAL
  zh: 3x² − 6y² = 6
- en: Solution
  id: totrans-552
  prefs: []
  type: TYPE_NORMAL
  zh: 解答
- en: If you just want to display all possible combinations of variables x and y,
    you can use the following Python program.
  id: totrans-553
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你只想显示变量 x 和 y 的所有可能组合，你可以使用以下 Python 程序。
- en: 'for x in range(-20, 21):'
  id: totrans-554
  prefs: []
  type: TYPE_NORMAL
  zh: 'for x in range(-20, 21):'
- en: 'for y in range(-20, 21):'
  id: totrans-555
  prefs: []
  type: TYPE_NORMAL
  zh: 'for y in range(-20, 21):'
- en: print(x, y)
  id: totrans-556
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: print(x, y)
- en: However, from all those combinations, you need only those that validate the
    expression 3x² − 6y² = 6\. A decision control structure is perfect for that purpose!
    The final Python program is as follows.
  id: totrans-557
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，从所有这些组合中，你只需要那些验证表达式 3x² − 6y² = 6 的组合。决策控制结构非常适合这个目的！最终的 Python 程序如下。
- en: '![](img/my_exercise_header.png) file_29.5-2'
  id: totrans-558
  prefs: []
  type: TYPE_NORMAL
  zh: '![](img/my_exercise_header.png) file_29.5-2'
- en: 'for x in range(-20, 21):'
  id: totrans-559
  prefs: []
  type: TYPE_NORMAL
  zh: 'for x in range(-20, 21):'
- en: 'for y in range(-20, 21):'
  id: totrans-560
  prefs: []
  type: TYPE_NORMAL
  zh: 'for y in range(-20, 21):'
- en: 'if 3 * x ** 2 - 6 * y ** 2 == 6:'
  id: totrans-561
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 'if 3 * x ** 2 - 6 * y ** 2 == 6:'
- en: print(x, y)
  id: totrans-562
  prefs:
  - PREF_BQ
  - PREF_BQ
  type: TYPE_NORMAL
  zh: print(x, y)
- en: Exercise 29.5-3 The Russian Multiplication Algorithm
  id: totrans-563
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 练习 29.5-3 俄罗斯乘法算法
- en: You can multiply two positive integers using the “Russian multiplication algorithm”,
    which is presented in the following flowchart.
  id: totrans-564
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以使用“俄罗斯乘法算法”乘以两个正整数，该算法在以下流程图中展示。
- en: '![Image](img/chapter29-02.png)'
  id: totrans-565
  prefs: []
  type: TYPE_IMG
  zh: '![Image](img/chapter29-02.png)'
- en: Write the corresponding Python program and create a trace table to determine
    the values of the variables in each step for the input values 5 and 13.
  id: totrans-566
  prefs: []
  type: TYPE_NORMAL
  zh: 编写相应的 Python 程序并创建跟踪表以确定输入值 5 和 13 时每一步的变量值。
- en: Solution
  id: totrans-567
  prefs: []
  type: TYPE_NORMAL
  zh: 解答
- en: In the given flowchart, a single-alternative decision structure is nested within
    a pre-test loop structure. The corresponding Python program is as follows.
  id: totrans-568
  prefs: []
  type: TYPE_NORMAL
  zh: 在给定的流程图中，一个单分支决策结构嵌套在一个预测试循环结构中。相应的 Python 程序如下。
- en: '![](img/my_exercise_header.png) file_29.5-3'
  id: totrans-569
  prefs: []
  type: TYPE_NORMAL
  zh: '![](img/my_exercise_header.png) file_29.5-3'
- en: m1 = int(input())
  id: totrans-570
  prefs: []
  type: TYPE_NORMAL
  zh: m1 = int(input())
- en: m2 = int(input())
  id: totrans-571
  prefs: []
  type: TYPE_NORMAL
  zh: m2 = int(input())
- en: s = 0
  id: totrans-572
  prefs: []
  type: TYPE_NORMAL
  zh: s = 0
- en: 'while m2 != 0:'
  id: totrans-573
  prefs: []
  type: TYPE_NORMAL
  zh: 当 m2 不等于 0 时：
- en: 'if m2 % 2 != 0:'
  id: totrans-574
  prefs: []
  type: TYPE_NORMAL
  zh: 'if m2 % 2 不等于 0:'
- en: s += m1
  id: totrans-575
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: s += m1
- en: m1 *= 2
  id: totrans-576
  prefs: []
  type: TYPE_NORMAL
  zh: m1 *= 2
- en: m2 //= 2
  id: totrans-577
  prefs: []
  type: TYPE_NORMAL
  zh: m2 //= 2
- en: print(s)
  id: totrans-578
  prefs: []
  type: TYPE_NORMAL
  zh: print(s)
- en: For the input values of 5 and 13, the trace table looks like this.
  id: totrans-579
  prefs: []
  type: TYPE_NORMAL
  zh: 对于输入值 5 和 13，跟踪表如下所示。
- en: '| Step | Statement | Notes | m1 | m2 | s |'
  id: totrans-580
  prefs: []
  type: TYPE_TB
  zh: '| 步骤 | 语句 | 备注 | m1 | m2 | s |'
- en: '| 1 | m1 = int(input()) | User enters the value 5 | 5 | ? | ? |'
  id: totrans-581
  prefs: []
  type: TYPE_TB
  zh: '| 1 | m1 = int(input()) | 用户输入值 5 | 5 | ? | ? |'
- en: '| 2 | m2 = int(input()) | User enters the value 13 | 5 | 13 | ? |'
  id: totrans-582
  prefs: []
  type: TYPE_TB
  zh: '| 2 | m2 = int(input()) | 用户输入值 13 | 5 | 13 | ? |'
- en: '| 3 | s = 0 |   | 5 | 13 | 0 |'
  id: totrans-583
  prefs: []
  type: TYPE_TB
  zh: '| 3 | s = 0 |   | 5 | 13 | 0 |'
- en: '| 4 | while m2 != 0: | This evaluates to True |'
  id: totrans-584
  prefs: []
  type: TYPE_TB
  zh: '| 4 | while m2 不等于 0: | 这将评估为 True |'
- en: '| 5 | if m2 % 2 != 0: | This evaluates to True |'
  id: totrans-585
  prefs: []
  type: TYPE_TB
  zh: '| 5 | if m2 % 2 不等于 0: | 这将评估为 True |'
- en: '| 6 | s += m1 |   | 5 | 13 | 5 |'
  id: totrans-586
  prefs: []
  type: TYPE_TB
  zh: '| 6 | s += m1 |   | 5 | 13 | 5 |'
- en: '| 7 | m1 *= 2 |   | 10 | 13 | 5 |'
  id: totrans-587
  prefs: []
  type: TYPE_TB
  zh: '| 7 | m1 *= 2 |   | 10 | 13 | 5 |'
- en: '| 8 | m2 //= 2 |   | 10 | 6 | 5 |'
  id: totrans-588
  prefs: []
  type: TYPE_TB
  zh: '| 8 | m2 //= 2 |   | 10 | 6 | 5 |'
- en: '| 9 | while m2 != 0: | This evaluates to True |'
  id: totrans-589
  prefs: []
  type: TYPE_TB
  zh: '| 9 | while m2 不等于 0: | 这将评估为 True |'
- en: '| 10 | if m2 % 2 != 0: | This evaluates to False |'
  id: totrans-590
  prefs: []
  type: TYPE_TB
  zh: '| 10 | if m2 % 2 不等于 0: | 这将评估为 False |'
- en: '| 11 | m1 *= 2 |   | 20 | 6 | 5 |'
  id: totrans-591
  prefs: []
  type: TYPE_TB
  zh: '| 11 | m1 *= 2 |   | 20 | 6 | 5 |'
- en: '| 12 | m2 //= 2 |   | 20 | 3 | 5 |'
  id: totrans-592
  prefs: []
  type: TYPE_TB
  zh: '| 12 | m2 //= 2 |   | 20 | 3 | 5 |'
- en: '| 13 | while m2 != 0: | This evaluates to True |'
  id: totrans-593
  prefs: []
  type: TYPE_TB
  zh: '| 13 | while m2 不等于 0: | 这将评估为 True |'
- en: '| 14 | if m2 % 2 != 0: | This evaluates to True |'
  id: totrans-594
  prefs: []
  type: TYPE_TB
  zh: '| 14 | if m2 % 2 不等于 0: | 这将评估为 True |'
- en: '| 15 | s += m1 |   | 20 | 3 | 25 |'
  id: totrans-595
  prefs: []
  type: TYPE_TB
  zh: '| 15 | s += m1 |   | 20 | 3 | 25 |'
- en: '| 16 | m1 *= 2 |   | 40 | 3 | 25 |'
  id: totrans-596
  prefs: []
  type: TYPE_TB
  zh: '| 16 | m1 *= 2 |   | 40 | 3 | 25 |'
- en: '| 17 | m2 //= 2 |   | 40 | 1 | 25 |'
  id: totrans-597
  prefs: []
  type: TYPE_TB
  zh: '| 17 | m2 //= 2 |   | 40 | 1 | 25 |'
- en: '| 18 | while m2 != 0: | This evaluates to True |'
  id: totrans-598
  prefs: []
  type: TYPE_TB
  zh: '| 18 | while m2 不等于 0: | 这将评估为 True |'
- en: '| 19 | if m2 % 2 != 0: | This evaluates to True |'
  id: totrans-599
  prefs: []
  type: TYPE_TB
  zh: '| 19 | if m2 % 2 不等于 0: | 这将评估为 True |'
- en: '| 20 | s += m1 |   | 40 | 1 | 65 |'
  id: totrans-600
  prefs: []
  type: TYPE_TB
  zh: '| 20 | s += m1 |   | 40 | 1 | 65 |'
- en: '| 21 | m1 *= 2 |   | 80 | 1 | 65 |'
  id: totrans-601
  prefs: []
  type: TYPE_TB
  zh: '| 21 | m1 *= 2 |   | 80 | 1 | 65 |'
- en: '| 22 | m2 //= 2 |   | 80 | 0 | 65 |'
  id: totrans-602
  prefs: []
  type: TYPE_TB
  zh: '| 22 | m2 //= 2 |   | 80 | 0 | 65 |'
- en: '| 23 | while m2 != 0: | This evaluates to False |'
  id: totrans-603
  prefs: []
  type: TYPE_TB
  zh: '| 23 | while m2 不等于 0: | 这将评估为 False |'
- en: '| 24 | print(s) | The value 65 is displayed which is, of course, the result
    of the multiplication 5 × 13 |'
  id: totrans-604
  prefs: []
  type: TYPE_TB
  zh: '| 24 | print(s) | 显示值65，这是当然的，是5乘以13的结果 |'
- en: Exercise 29.5-4 Finding the Number of Divisors
  id: totrans-605
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 练习 29.5-4 求一个数的因数个数
- en: Write a Python program that lets the user enter a positive integer and then
    displays the total number of its divisors.
  id: totrans-606
  prefs: []
  type: TYPE_NORMAL
  zh: 编写一个Python程序，允许用户输入一个正整数，然后显示它的因数总数。
- en: Solution
  id: totrans-607
  prefs: []
  type: TYPE_NORMAL
  zh: 解答
- en: Let's see some examples.
  id: totrans-608
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看一些例子。
- en: ►The divisors of value 12 are numbers 1, 2, 3, 4, 6, 12.
  id: totrans-609
  prefs: []
  type: TYPE_NORMAL
  zh: ►值12的因数是数字1，2，3，4，6，12。
- en: ►The divisors of value 15 are numbers 1, 3, 5, 15.
  id: totrans-610
  prefs: []
  type: TYPE_NORMAL
  zh: ►值15的因数是数字1，3，5，15。
- en: ►The divisors of value 20 are numbers 1, 2, 4, 5, 10, 20.
  id: totrans-611
  prefs: []
  type: TYPE_NORMAL
  zh: ►值20的因数是数字1，2，4，5，10，20。
- en: ►The divisors of value 50 are numbers 1, 2, 5, 10, 25, 50.
  id: totrans-612
  prefs: []
  type: TYPE_NORMAL
  zh: ►值50的因数是数字1，2，5，10，25，50。
- en: If variable x contains the user-provided integer, all possible divisors of x
    are between 1 and x. Thus, all you need here is a for-loop where the value of
    variable counter goes  from 1 to x and, in each iteration, a simple-alternative
    decision structure checks whether the value of counter is a divisor of x, The
    Python program is as follows.
  id: totrans-613
  prefs: []
  type: TYPE_NORMAL
  zh: 如果变量x包含用户提供的整数，x的所有可能的因数都在1到x之间。因此，这里只需要一个for循环，变量counter的值从1到x，在每次迭代中，一个简单的选择结构检查counter的值是否是x的因数。以下是一个Python程序。
- en: '![](img/my_exercise_header.png) file_29.5-4a'
  id: totrans-614
  prefs: []
  type: TYPE_NORMAL
  zh: '![](img/my_exercise_header.png) file_29.5-4a'
- en: x = int(input())
  id: totrans-615
  prefs: []
  type: TYPE_NORMAL
  zh: x = int(input())
- en: numberOfDivisors = 0
  id: totrans-616
  prefs: []
  type: TYPE_NORMAL
  zh: numberOfDivisors = 0
- en: 'for i in range(1, x + 1):'
  id: totrans-617
  prefs: []
  type: TYPE_NORMAL
  zh: 'for i in range(1, x + 1):'
- en: 'if x % i == 0:'
  id: totrans-618
  prefs: []
  type: TYPE_NORMAL
  zh: 'if x % i == 0:'
- en: numberOfDivisors += 1
  id: totrans-619
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: numberOfDivisors += 1
- en: print(numberOfDivisors)
  id: totrans-620
  prefs: []
  type: TYPE_NORMAL
  zh: print(numberOfDivisors)
- en: This program, for input value 20, performs 20 iterations. However, wouldn't
    it be even better if it could perform less than the half of the iterations and
    achieve the same result? Of course it would! So, let's make it more efficient!
  id: totrans-621
  prefs: []
  type: TYPE_NORMAL
  zh: 这个程序对于输入值20，执行了20次迭代。然而，如果它能够执行少于一半的迭代并达到相同的结果会更好！当然，这样会更好！所以，让我们让它更高效！
- en: As you probably know, for any user-provided integer (in variable x)
  id: totrans-622
  prefs: []
  type: TYPE_NORMAL
  zh: 如你所知，对于任何用户提供的整数（变量x）
- en: ►the value 1 is always a divisor.
  id: totrans-623
  prefs: []
  type: TYPE_NORMAL
  zh: ►值1总是因数。
- en: ►the user-provided integer is always a divisor of itself.
  id: totrans-624
  prefs: []
  type: TYPE_NORMAL
  zh: ►用户提供的整数总是它自己的因数。
- en: ►except for the user-provided integer, there are no other divisors after the
    middle of the range 1 to x.
  id: totrans-625
  prefs: []
  type: TYPE_NORMAL
  zh: ►除了用户提供的整数外，在1到x的范围中间没有其他因数。
- en: Accordingly, for any integer there are certainly 2 divisors, the value 1 and
    the user-provided integer itself. Therefore, the program must check for other
    possible divisors starting from the value 2 until the middle of the range 1 to
    x. The improved Python program is as follows.
  id: totrans-626
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，对于任何整数，肯定有2个因数，值1和用户提供的整数本身。因此，程序必须从值2开始检查其他可能的因数，直到1到x的范围中间。改进后的Python程序如下。
- en: '![](img/my_exercise_header.png) file_29.5-4b'
  id: totrans-627
  prefs: []
  type: TYPE_NORMAL
  zh: '![](img/my_exercise_header.png) file_29.5-4b'
- en: x = int(input())
  id: totrans-628
  prefs: []
  type: TYPE_NORMAL
  zh: x = int(input())
- en: numberOfDivisors = 2
  id: totrans-629
  prefs: []
  type: TYPE_NORMAL
  zh: numberOfDivisors = 2
- en: 'for i in range(2, x // 2 + 1):'
  id: totrans-630
  prefs: []
  type: TYPE_NORMAL
  zh: 'for i in range(2, x // 2 + 1):'
- en: 'if x % i == 0:'
  id: totrans-631
  prefs: []
  type: TYPE_NORMAL
  zh: 'if x % i == 0:'
- en: numberOfDivisors += 1
  id: totrans-632
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: numberOfDivisors += 1
- en: print(numberOfDivisors)
  id: totrans-633
  prefs: []
  type: TYPE_NORMAL
  zh: print(numberOfDivisors)
- en: This Python program performs less than half of the iterations that the previous
    program did! For example, for the input value 20, this Python program performs
    only (20 − 2)  DIV 2 = 9 iterations!
  id: totrans-634
  prefs: []
  type: TYPE_NORMAL
  zh: 这个Python程序执行的迭代次数比上一个程序少！例如，对于输入值20，这个Python程序只执行了(20 - 2) DIV 2 = 9次迭代！
- en: Exercise 29.5-5 Is the Number a Prime?
  id: totrans-635
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 练习 29.5-5 判断一个数是否为素数？
- en: Write a Python program that prompts the user to enter an integer greater than
    1 and then displays a message indicating if this number is a prime. A prime number
    is any integer greater than 1 that has no divisors other than 1 and itself. The
    numbers 7, 11, and 13 are all such numbers.
  id: totrans-636
  prefs: []
  type: TYPE_NORMAL
  zh: 编写一个Python程序，提示用户输入一个大于1的整数，然后显示一条消息，指出该数是否为素数。素数是任何大于1的整数，它除了1和它本身外没有其他因数。数字7，11和13都是这样的数。
- en: Solution
  id: totrans-637
  prefs: []
  type: TYPE_NORMAL
  zh: 解答
- en: This exercise is based on the previous one. It is very simple! If the user-provided
    integer has only two divisors (1 and itself), the number is a prime. The Python
    program is as follows.
  id: totrans-638
  prefs: []
  type: TYPE_NORMAL
  zh: 这个练习基于上一个练习。它非常简单！如果用户提供的整数只有两个因数（1和它本身），则该数是素数。以下是一个Python程序。
- en: '![](img/my_exercise_header.png) file_29.5-5a'
  id: totrans-639
  prefs: []
  type: TYPE_NORMAL
  zh: '![](img/my_exercise_header.png) file_29.5-5a'
- en: 'x = int(input("Enter an integer greater than 1: "))'
  id: totrans-640
  prefs: []
  type: TYPE_NORMAL
  zh: x = int(input("请输入一个大于1的整数："))
- en: numberOfDivisors = 2
  id: totrans-641
  prefs: []
  type: TYPE_NORMAL
  zh: numberOfDivisors = 2
- en: 'for i in range(2, x // 2 + 1):'
  id: totrans-642
  prefs: []
  type: TYPE_NORMAL
  zh: 'for i in range(2, x // 2 + 1):'
- en: 'if x % i == 0:'
  id: totrans-643
  prefs: []
  type: TYPE_NORMAL
  zh: 'if x % i == 0:'
- en: numberOfDivisors += 1
  id: totrans-644
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: numberOfDivisors += 1
- en: 'if numberOfDivisors == 2:'
  id: totrans-645
  prefs: []
  type: TYPE_NORMAL
  zh: 'if numberOfDivisors == 2:'
- en: print("Number", x, "is prime")
  id: totrans-646
  prefs: []
  type: TYPE_NORMAL
  zh: print("数字", x, "是素数")
- en: Now let's make the program more efficient. The flow of execution can break out
    of the loop when a third divisor is found, because this means that the user-provided
    integer is definitely not a prime. The Python program is as follows.
  id: totrans-647
  prefs: []
  type: TYPE_NORMAL
  zh: 现在让我们使程序更高效。当找到第三个除数时，执行流程可以跳出循环，因为这意味着用户提供的整数肯定不是素数。Python 程序如下。
- en: '![](img/my_exercise_header.png) file_29.5-5b'
  id: totrans-648
  prefs: []
  type: TYPE_NORMAL
  zh: '![](img/my_exercise_header.png) file_29.5-5b'
- en: 'x = int(input("Enter an integer greater than 1: "))'
  id: totrans-649
  prefs: []
  type: TYPE_NORMAL
  zh: 'x = int(input("Enter an integer greater than 1: "))'
- en: numberOfDivisors = 2
  id: totrans-650
  prefs: []
  type: TYPE_NORMAL
  zh: numberOfDivisors = 2
- en: 'for i in range(2, x // 2 + 1):'
  id: totrans-651
  prefs: []
  type: TYPE_NORMAL
  zh: 'for i in range(2, x // 2 + 1):'
- en: 'if x % i == 0:'
  id: totrans-652
  prefs: []
  type: TYPE_NORMAL
  zh: 'if x % i == 0:'
- en: numberOfDivisors += 1
  id: totrans-653
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: numberOfDivisors += 1
- en: break
  id: totrans-654
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: break
- en: 'if numberOfDivisors == 2:'
  id: totrans-655
  prefs: []
  type: TYPE_NORMAL
  zh: 'if numberOfDivisors == 2:'
- en: print("Number", x, "is prime")
  id: totrans-656
  prefs: []
  type: TYPE_NORMAL
  zh: print("Number", x, "is prime")
- en: Exercise 29.5-6 Finding all Prime Numbers from 1 to N
  id: totrans-657
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 练习 29.5-6 从 1 到 N 找到所有素数
- en: Write a Python program that prompts the user to enter an integer greater than
    1 and then displays all prime numbers from 1 to that user-provided integer. Using
    a loop control structure, the program must also validate data input and display
    an error message when the user enters any values less than 1.
  id: totrans-658
  prefs: []
  type: TYPE_NORMAL
  zh: 编写一个 Python 程序，提示用户输入一个大于 1 的整数，然后显示从 1 到该用户提供的整数的所有素数。使用循环控制结构，程序必须验证数据输入，并在用户输入任何小于
    1 的值时显示错误信息。
- en: Solution
  id: totrans-659
  prefs: []
  type: TYPE_NORMAL
  zh: 解答
- en: The following Python program, given in general form, solves this exercise.
  id: totrans-660
  prefs: []
  type: TYPE_NORMAL
  zh: 以下 Python 程序以一般形式给出，解决了这个练习。
- en: '![](img/my_exercise_header.png) Main Code'
  id: totrans-661
  prefs: []
  type: TYPE_NORMAL
  zh: '![](img/my_exercise_header.png) 主代码'
- en: 'N = int(input("Enter an integer greater than 1: "))'
  id: totrans-662
  prefs: []
  type: TYPE_NORMAL
  zh: 'N = int(input("Enter an integer greater than 1: "))'
- en: 'while N <= 1:'
  id: totrans-663
  prefs: []
  type: TYPE_NORMAL
  zh: 'while N <= 1:'
- en: 'N = int(input("Wrong number. Enter an integer greater than 1: "))'
  id: totrans-664
  prefs: []
  type: TYPE_NORMAL
  zh: 'N = int(input("Wrong number. Enter an integer greater than 1: "))'
- en: 'for x in range(1, N + 1):'
  id: totrans-665
  prefs: []
  type: TYPE_NORMAL
  zh: 'for x in range(1, N + 1):'
- en: 'Code Fragment 1: Check whether variable x contains a prime number'
  id: totrans-666
  prefs: []
  type: TYPE_NORMAL
  zh: 代码片段 1：检查变量 x 是否包含一个素数
- en: Code Fragment 1, shown below, is taken from the previous exercise ([Exercise
    29.5-5](#toc_23)). It checks whether variable x contains a prime number.
  id: totrans-667
  prefs: []
  type: TYPE_NORMAL
  zh: 代码片段 1，如下所示，取自之前的练习（[练习 29.5-5](#toc_23)）。它检查变量 x 是否包含一个素数。
- en: '![](img/my_exercise_header.png) Code Fragment 1'
  id: totrans-668
  prefs: []
  type: TYPE_NORMAL
  zh: '![](img/my_exercise_header.png) 代码片段 1'
- en: numberOfDivisors = 2
  id: totrans-669
  prefs: []
  type: TYPE_NORMAL
  zh: numberOfDivisors = 2
- en: 'for i in range(2, x // 2 + 1):'
  id: totrans-670
  prefs: []
  type: TYPE_NORMAL
  zh: 'for i in range(2, x // 2 + 1):'
- en: 'if x % i == 0:'
  id: totrans-671
  prefs: []
  type: TYPE_NORMAL
  zh: 'if x % i == 0:'
- en: numberOfDivisors += 1
  id: totrans-672
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: numberOfDivisors += 1
- en: break
  id: totrans-673
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: break
- en: 'if numberOfDivisors == 2:'
  id: totrans-674
  prefs: []
  type: TYPE_NORMAL
  zh: 'if numberOfDivisors == 2:'
- en: print("Number", x, "is prime")
  id: totrans-675
  prefs: []
  type: TYPE_NORMAL
  zh: print("Number", x, "is prime")
- en: After embedding Code Fragment 1 in Main Code, the final Python program becomes
  id: totrans-676
  prefs: []
  type: TYPE_NORMAL
  zh: 在将代码片段 1 嵌入主代码后，最终的 Python 程序如下
- en: '![](img/my_exercise_header.png) file_29.5-6'
  id: totrans-677
  prefs: []
  type: TYPE_NORMAL
  zh: '![](img/my_exercise_header.png) file_29.5-6'
- en: 'N = int(input("Enter an integer greater than 1: "))'
  id: totrans-678
  prefs: []
  type: TYPE_NORMAL
  zh: 'N = int(input("Enter an integer greater than 1: "))'
- en: 'while N <= 1:'
  id: totrans-679
  prefs: []
  type: TYPE_NORMAL
  zh: 'while N <= 1:'
- en: 'N = int(input("Wrong number. Enter an integer greater than 1: "))'
  id: totrans-680
  prefs: []
  type: TYPE_NORMAL
  zh: 'N = int(input("Wrong number. Enter an integer greater than 1: "))'
- en: 'for x in range(1, N + 1):'
  id: totrans-681
  prefs: []
  type: TYPE_NORMAL
  zh: 'for x in range(1, N + 1):'
- en: numberOfDivisors = 2     [[More…]](more.html#more_29_5_6_1)
  id: totrans-682
  prefs: []
  type: TYPE_NORMAL
  zh: numberOfDivisors = 2     [[更多…]](more.html#more_29_5_6_1)
- en: 'for i in range(2, x // 2 + 1):'
  id: totrans-683
  prefs: []
  type: TYPE_NORMAL
  zh: 'for i in range(2, x // 2 + 1):'
- en: 'if x % i == 0:'
  id: totrans-684
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 'if x % i == 0:'
- en: numberOfDivisors += 1
  id: totrans-685
  prefs:
  - PREF_BQ
  - PREF_BQ
  type: TYPE_NORMAL
  zh: numberOfDivisors += 1
- en: break
  id: totrans-686
  prefs:
  - PREF_BQ
  - PREF_BQ
  type: TYPE_NORMAL
  zh: break
- en: 'if numberOfDivisors == 2:'
  id: totrans-687
  prefs: []
  type: TYPE_NORMAL
  zh: 'if numberOfDivisors == 2:'
- en: print("Number", x, "is prime")
  id: totrans-688
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: print("Number", x, "is prime")
- en: Exercise 29.5-7 Heron's Square Root
  id: totrans-689
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 练习 29.5-7 赫伦平方根
- en: Write a Python program that prompts the user to enter a non-negative value and
    then calculates its square root using Heron's formula, as follows.
  id: totrans-690
  prefs: []
  type: TYPE_NORMAL
  zh: 编写一个 Python 程序，提示用户输入一个非负值，然后使用赫伦公式计算其平方根，如下所示。
- en: .![Image](img/chapter11-01.png)
  id: totrans-691
  prefs: []
  type: TYPE_NORMAL
  zh: .![Image](img/chapter11-01.png)
- en: where
  id: totrans-692
  prefs: []
  type: TYPE_NORMAL
  zh: 其中
- en: ►y is the number for which you want to find the square root
  id: totrans-693
  prefs: []
  type: TYPE_NORMAL
  zh: ►y 是你想要找到平方根的数
- en: ►x[n] is the n-th iteration value of the square root of y
  id: totrans-694
  prefs: []
  type: TYPE_NORMAL
  zh: ►x[n] 是 y 的平方根的第 n 次迭代值
- en: Moreover, using a loop control structure, the program must validate data input
    and display an error message when the user enters any negative values.
  id: totrans-695
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，使用循环控制结构，程序必须验证数据输入，并在用户输入任何负值时显示错误信息。
- en: Solution
  id: totrans-696
  prefs: []
  type: TYPE_NORMAL
  zh: 解答
- en: It is almost certain that you are a little bit confused and you are scratching
    your head right now. Don't get scared by all this math stuff! You can try to understand
    Heron's formula through the following flowchart instead!
  id: totrans-697
  prefs: []
  type: TYPE_NORMAL
  zh: 你现在可能有点困惑，正在挠头。不要被所有这些数学东西吓到！你可以通过以下流程图来尝试理解赫伦公式！
- en: '![Image](img/chapter29-03.png)'
  id: totrans-698
  prefs: []
  type: TYPE_IMG
  zh: '![Image](img/chapter29-03.png)'
- en: 'Still confused? Let''s go through an example. Let''s try to find the square
    root of 25:'
  id: totrans-699
  prefs: []
  type: TYPE_NORMAL
  zh: 仍然感到困惑？让我们通过一个例子来解释。让我们尝试找到 25 的平方根：
- en: ►Formulate a guess. Assume 8 as your first guess.
  id: totrans-700
  prefs: []
  type: TYPE_NORMAL
  zh: ►提出一个猜测。假设 8 作为你的第一个猜测。
- en: ►The square of 8 is 64.
  id: totrans-701
  prefs: []
  type: TYPE_NORMAL
  zh: ►8 的平方是 64。
- en: ►Since 64 isn't “close enough” to 25, formulate a new guess by calculating the
    expression
  id: totrans-702
  prefs: []
  type: TYPE_NORMAL
  zh: ►由于64不够接近25，通过计算表达式来制定一个新的猜测
- en: .![Image](img/chapter29-04.png)
  id: totrans-703
  prefs: []
  type: TYPE_NORMAL
  zh: '![Image](img/chapter29-04.png)'
- en: ►The square of 5.56 is about 30.91
  id: totrans-704
  prefs: []
  type: TYPE_NORMAL
  zh: ►5.56的平方大约是30.91
- en: ►Since 30.91 isn't “close enough” to 25, formulate a new guess by calculating
    the expression
  id: totrans-705
  prefs: []
  type: TYPE_NORMAL
  zh: ►由于30.91不够接近25，通过计算表达式来制定一个新的猜测
- en: .![Image](img/chapter29-05.png)
  id: totrans-706
  prefs: []
  type: TYPE_NORMAL
  zh: .![Image](img/chapter29-05.png)
- en: ►The square of 5.02 is 25.2
  id: totrans-707
  prefs: []
  type: TYPE_NORMAL
  zh: ►5.02的平方是25.2
- en: ►If you think that 25.2 is “close enough” to 25, then you can stop the whole
    process and conclude that the approximate square root of 25 is 5.02.
  id: totrans-708
  prefs: []
  type: TYPE_NORMAL
  zh: ►如果你认为25.2足够接近25，那么你可以停止整个过程，并得出结论，25的近似平方根是5.02。
- en: '![](img/notice.jpg)Obviously, if greater precision is required, you have the
    option to continue the process until you find a value that is considered closer
    to the square root of 25.'
  id: totrans-709
  prefs: []
  type: TYPE_NORMAL
  zh: '![](img/notice.jpg)显然，如果需要更高的精度，你可以继续这个过程，直到找到一个被认为是更接近25平方根的值。'
- en: Now, let's see the corresponding Python program.
  id: totrans-710
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们看看相应的Python程序。
- en: '![](img/my_exercise_header.png) file_29.5-7'
  id: totrans-711
  prefs: []
  type: TYPE_NORMAL
  zh: '![](img/my_exercise_header.png) file_29.5-7'
- en: from random import randrange
  id: totrans-712
  prefs: []
  type: TYPE_NORMAL
  zh: from random import randrange
- en: ACCURACY = 0.0000000000001
  id: totrans-713
  prefs: []
  type: TYPE_NORMAL
  zh: ACCURACY = 0.0000000000001
- en: 'y = float(input("Enter a non-negative number: "))'
  id: totrans-714
  prefs: []
  type: TYPE_NORMAL
  zh: y = float(input("请输入一个非负数："))
- en: 'while y < 0:'
  id: totrans-715
  prefs: []
  type: TYPE_NORMAL
  zh: 'while y < 0:'
- en: 'y = float(input("Invalid value. Enter a non-negative number: "))'
  id: totrans-716
  prefs: []
  type: TYPE_NORMAL
  zh: y = float(input("无效值。请输入一个非负数："))
- en: guess = randrange(1, y + 1)      #Make a random first guess between 1 and user-provided
    value
  id: totrans-717
  prefs: []
  type: TYPE_NORMAL
  zh: 'guess = randrange(1, y + 1)      #在1和用户提供的值之间生成一个随机初始猜测'
- en: 'while abs(guess ** 2 - y) > ACCURACY:     #Is it "close enough"?'
  id: totrans-718
  prefs: []
  type: TYPE_NORMAL
  zh: 'while abs(guess ** 2 - y) > ACCURACY:    #它“足够接近”了吗？'
- en: guess = (guess + y / guess) / 2          #No, create a new "guess"!
  id: totrans-719
  prefs: []
  type: TYPE_NORMAL
  zh: 'guess = (guess + y / guess) / 2    #不，创建一个新的“猜测”！'
- en: print(guess)
  id: totrans-720
  prefs: []
  type: TYPE_NORMAL
  zh: print(guess)
- en: '![](img/notice.jpg)Note the way that “Is it close enough” is checked. When
    the absolute value of the difference |guess² - y| becomes less than 0.0000000000001
    (where y is the user-provided value), the flow of execution exits the loop.'
  id: totrans-721
  prefs: []
  type: TYPE_NORMAL
  zh: '![](img/notice.jpg)注意检查“它足够接近”的方式。当差的绝对值 |guess² - y| 变得小于0.0000000000001（其中y是用户提供的值）时，执行流程退出循环。'
- en: Exercise 29.5-8 Calculating π
  id: totrans-722
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 练习29.5-8 计算π
- en: Write a Python program that calculates π using the Madhava–Leibniz^([[19]](footnotes.html#Endnote_19),[[20]](footnotes.html#Endnote_20))
    series, which follows, with an accuracy of 0.00001.
  id: totrans-723
  prefs: []
  type: TYPE_NORMAL
  zh: 编写一个Python程序，使用以下Madhava–Leibniz级数计算π，精度为0.00001。
- en: .![Image](img/chapter29-06.png)
  id: totrans-724
  prefs: []
  type: TYPE_NORMAL
  zh: .![Image](img/chapter29-06.png)
- en: Solution
  id: totrans-725
  prefs: []
  type: TYPE_NORMAL
  zh: 解答
- en: The Madhava–Leibniz series can be solved for π, and becomes
  id: totrans-726
  prefs: []
  type: TYPE_NORMAL
  zh: Madhava–Leibniz级数可以解出π，并变为
- en: .![Image](img/chapter29-07.png)
  id: totrans-727
  prefs: []
  type: TYPE_NORMAL
  zh: .![Image](img/chapter29-07.png)
- en: The more fractions you have, the better the accuracy! Thus, to calculate this
    formula the program needs to perform many iterations so as to use as many fractions
    as possible. But, of course, it can't iterate forever! The loop must actually
    stop iterating when the current calculated value of π and the one calculated in
    the previous iteration are ”close enough”, which means that the absolute value
    of their difference has become very small. The constant ACCURACY defines how small
    this difference must be. The Python program is shown here.
  id: totrans-728
  prefs: []
  type: TYPE_NORMAL
  zh: 分数越多，精度越好！因此，为了计算这个公式，程序需要执行多次迭代，以便尽可能多地使用分数。但是，当然，它不能无限迭代！循环必须在当前计算出的π值和前一次迭代计算出的π值“足够接近”时停止迭代，这意味着它们之间的差的绝对值已经变得非常小。常量ACCURACY定义了这种差异必须有多小。Python程序如下所示。
- en: '![](img/my_exercise_header.png) file_29.5-8'
  id: totrans-729
  prefs: []
  type: TYPE_NORMAL
  zh: '![](img/my_exercise_header.png) file_29.5-8'
- en: ACCURACY = 0.00001
  id: totrans-730
  prefs: []
  type: TYPE_NORMAL
  zh: 精度 = 0.00001
- en: pi = 0
  id: totrans-731
  prefs: []
  type: TYPE_NORMAL
  zh: pi = 0
- en: sign = 1    #This is the sign of the first fraction
  id: totrans-732
  prefs: []
  type: TYPE_NORMAL
  zh: 'sign = 1    #这是第一个分数的符号'
- en: 'denom = 1   #This is the denominator of the first fraction'
  id: totrans-733
  prefs: []
  type: TYPE_NORMAL
  zh: 'denom = 1    #这是第一个分数的分母'
- en: 'while True:'
  id: totrans-734
  prefs: []
  type: TYPE_NORMAL
  zh: 'while True:'
- en: 'piPrevious = pi   #Keep previous pi'
  id: totrans-735
  prefs: []
  type: TYPE_NORMAL
  zh: 'piPrevious = pi    #保留前一个pi值'
- en: pi += sign * 4 / denom    #Calculate new pi by adding a fraction (a term)
  id: totrans-736
  prefs: []
  type: TYPE_NORMAL
  zh: 'pi += sign * 4 / denom    #通过添加一个分数（项）来计算新的π'
- en: 'sign = -sign   #Prepare sign for the next fraction'
  id: totrans-737
  prefs: []
  type: TYPE_NORMAL
  zh: 'sign = -sign    #为下一个分数准备符号'
- en: 'denom += 2     #Prepare denominator for the next fraction'
  id: totrans-738
  prefs: []
  type: TYPE_NORMAL
  zh: 'denom += 2    #为下一个分数准备分母'
- en: 'if abs(pi - piPrevious) <= ACCURACY: break   #Is it "close enough"?'
  id: totrans-739
  prefs: []
  type: TYPE_NORMAL
  zh: 'if abs(pi - piPrevious) <= ACCURACY: break    #它“足够接近”了吗？'
- en: print("Pi ~=", pi)
  id: totrans-740
  prefs: []
  type: TYPE_NORMAL
  zh: print("π ~=", pi)
- en: '![](img/notice.jpg)Note the way in which variable sign toggles between the
    values −1 and +1 in each iteration.'
  id: totrans-741
  prefs: []
  type: TYPE_NORMAL
  zh: '![](img/notice.jpg)注意变量sign在每次迭代之间在-1和+1之间切换的方式。'
- en: If you reduce the value of the constant ACCURACY, π will be calculated more
    and more accurately. Depending on how fast your computer is, you can calculate
    the first five digits of π fairly quickly. However, the time it takes to calculate
    each succeeding digit of π goes up exponentially. To calculate 40 digits of π
    on a modern computer using this method could take years!
  id: totrans-742
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你降低常数 ACCURACY 的值，π 将会计算得越来越精确。根据你的计算机速度，你可以相当快地计算出 π 的前五个数字。然而，计算 π 的后续每一位所需的时间会呈指数级增长。使用这种方法在现代计算机上计算
    40 位 π 可能需要数年！
- en: Exercise 29.5-9 Approximating a Real with a Fraction
  id: totrans-743
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 练习 29.5-9 使用分数逼近实数
- en: Write a Python program that prompts the user to enter a real between 0 and 100
    and then tries to find the fraction ![Image](img/chapter29-08.png) that better
    approximates it, where N is an integer between 0 and 100 and M is an integer between
    1 and 100\. Using a loop control structure, the program must also validate data
    input, allowing the user to enter only values between 0 and 100\. There is no
    need to display any error messages.
  id: totrans-744
  prefs: []
  type: TYPE_NORMAL
  zh: 编写一个 Python 程序，提示用户输入一个介于 0 和 100 之间的实数，然后尝试找到更好的近似该实数的分数 ![Image](img/chapter29-08.png)，其中
    N 是介于 0 和 100 之间的整数，M 是介于 1 和 100 之间的整数。使用循环控制结构，程序还必须验证数据输入，只允许用户输入介于 0 和 100
    之间的值。无需显示任何错误消息。
- en: Solution
  id: totrans-745
  prefs: []
  type: TYPE_NORMAL
  zh: 解答
- en: The solution is simple. All you need to do is iterate through all possible combinations
    of variables n and m and check which one better approximates the user-provided
    real.
  id: totrans-746
  prefs: []
  type: TYPE_NORMAL
  zh: 解答很简单。你所需要做的就是迭代所有可能的 n 和 m 的组合，并检查哪一个更好地逼近用户提供的实数。
- en: To iterate through all possible combinations of variables n and m, you can use
    a nested loop control structure, that is, two for-loops, one nested within the
    other, as follows.
  id: totrans-747
  prefs: []
  type: TYPE_NORMAL
  zh: 要迭代 n 和 m 所有可能的组合，你可以使用嵌套循环控制结构，即两个嵌套的 for 循环，如下所示。
- en: 'for n in range(101):'
  id: totrans-748
  prefs: []
  type: TYPE_NORMAL
  zh: 'for n in range(101):'
- en: 'for m in range(1, 101):'
  id: totrans-749
  prefs: []
  type: TYPE_NORMAL
  zh: 'for m in range(1, 101):'
- en: …
  id: totrans-750
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: …
- en: '![](img/notice.jpg)The total number of iterations is 101 × 100 = 10100\. Quite
    a big number but, for a modern computer, this is peanuts!'
  id: totrans-751
  prefs: []
  type: TYPE_NORMAL
  zh: '![](img/notice.jpg)总迭代次数为 101 × 100 = 10100。这是一个相当大的数字，但对于现代计算机来说，这只是小菜一碟！'
- en: '![](img/notice.jpg)Variable m represents the denominator of the fraction, and
    a denominator cannot be zero. This is why it starts from 1, and not from 0.'
  id: totrans-752
  prefs: []
  type: TYPE_NORMAL
  zh: '![](img/notice.jpg)变量 m 代表分数的分母，分母不能为零。这就是为什么它从 1 开始，而不是从 0 开始。'
- en: The following criteria
  id: totrans-753
  prefs: []
  type: TYPE_NORMAL
  zh: 以下标准
- en: .![Image](img/chapter29-09.png)
  id: totrans-754
  prefs: []
  type: TYPE_NORMAL
  zh: .![Image](img/chapter29-09.png)
- en: can evaluate how “good” an approximation is.
  id: totrans-755
  prefs: []
  type: TYPE_NORMAL
  zh: 可以评估近似的好坏。
- en: Confused? Let's try to approximate the value 0.333 with a fraction, iterating
    through all possible combinations of N and M.
  id: totrans-756
  prefs: []
  type: TYPE_NORMAL
  zh: 感到困惑？让我们尝试用分数逼近值 0.333，通过迭代 N 和 M 所有可能的组合。
- en: ►For N = 1, M = 1 the criteria equals to ![Image](img/chapter29-10.png) = 0.6670
  id: totrans-757
  prefs: []
  type: TYPE_NORMAL
  zh: ►对于 N = 1，M = 1 时，标准等于 ![Image](img/chapter29-10.png) = 0.6670
- en: ►For N = 1, M = 2 the criteria equals to ![Image](img/chapter29-11.png) = 0.1670
  id: totrans-758
  prefs: []
  type: TYPE_NORMAL
  zh: ►对于 N = 1，M = 2 时，标准等于 ![Image](img/chapter29-11.png) = 0.1670
- en: ►For N = 1, M = 3 the criteria equals to ![Image](img/chapter29-12.png) = 0.0003
  id: totrans-759
  prefs: []
  type: TYPE_NORMAL
  zh: ►对于 N = 1，M = 3 时，标准等于 ![Image](img/chapter29-12.png) = 0.0003
- en: ►For N = 1, M = 4 the criteria equals to ![Image](img/chapter29-13.png) = 0.0830
  id: totrans-760
  prefs: []
  type: TYPE_NORMAL
  zh: ►对于 N = 1，M = 4 时，标准等于 ![Image](img/chapter29-13.png) = 0.0830
- en: ►…
  id: totrans-761
  prefs: []
  type: TYPE_NORMAL
  zh: ►…
- en: ►For N = 100, M = 99 the criteria equals to ![Image](img/chapter29-14.png) =
    0.6771
  id: totrans-762
  prefs: []
  type: TYPE_NORMAL
  zh: ►对于 N = 100，M = 99 时，标准等于 ![Image](img/chapter29-14.png) = 0.6771
- en: ►For N = 100, M = 100 the criteria equals to ![Image](img/chapter29-15.png)
    = 0.6670
  id: totrans-763
  prefs: []
  type: TYPE_NORMAL
  zh: ►对于 N = 100，M = 100 时，标准等于 ![Image](img/chapter29-15.png) = 0.6670
- en: It is obvious that the value 0.0003 is the minimum value among all possible
    results. Thus, the combination N = 1 and M = 3 (which corresponds to the fraction
    1/3) is considered the best approximation for the value 0.333.
  id: totrans-764
  prefs: []
  type: TYPE_NORMAL
  zh: 显然，0.0003 是所有可能结果中的最小值。因此，N = 1 和 M = 3（对应于分数 1/3）的组合被认为是 0.333 的最佳近似。
- en: 'And now the Python program:'
  id: totrans-765
  prefs: []
  type: TYPE_NORMAL
  zh: 现在的 Python 程序：
- en: '![](img/my_exercise_header.png) file_29.5-9'
  id: totrans-766
  prefs: []
  type: TYPE_NORMAL
  zh: '![](img/my_exercise_header.png) file_29.5-9'
- en: 'while True:'
  id: totrans-767
  prefs: []
  type: TYPE_NORMAL
  zh: 'while True:'
- en: 'x = float(input("Enter a real between 0 and 100: "))'
  id: totrans-768
  prefs: []
  type: TYPE_NORMAL
  zh: 'x = float(input("Enter a real between 0 and 100: "))'
- en: 'if 0 <= x <= 100: break'
  id: totrans-769
  prefs: []
  type: TYPE_NORMAL
  zh: 'if 0 <= x <= 100: break'
- en: minimum = 100
  id: totrans-770
  prefs: []
  type: TYPE_NORMAL
  zh: minimum = 100
- en: 'for n in range(101):'
  id: totrans-771
  prefs: []
  type: TYPE_NORMAL
  zh: 'for n in range(101):'
- en: 'for m in range(1, 101):'
  id: totrans-772
  prefs: []
  type: TYPE_NORMAL
  zh: 'for m in range(1, 101):'
- en: y = abs(n / m - x)
  id: totrans-773
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: y = abs(n / m - x)
- en: 'if y < minimum:'
  id: totrans-774
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 'if y < minimum:'
- en: minimum = y
  id: totrans-775
  prefs:
  - PREF_BQ
  - PREF_BQ
  type: TYPE_NORMAL
  zh: minimum = y
- en: bestN = n
  id: totrans-776
  prefs:
  - PREF_BQ
  - PREF_BQ
  type: TYPE_NORMAL
  zh: bestN = n
- en: bestM = m
  id: totrans-777
  prefs:
  - PREF_BQ
  - PREF_BQ
  type: TYPE_NORMAL
  zh: bestM = m
- en: print("The fraction is:", bestN, "/", bestM)
  id: totrans-778
  prefs: []
  type: TYPE_NORMAL
  zh: print("The fraction is:", bestN, "/", bestM)
- en: 29.6 Exercises of a General Nature with Loop Control Structures
  id: totrans-779
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 29.6 使用循环控制结构的通用练习
- en: Exercise 29.6-1 Fahrenheit to Kelvin, from 0 to 100
  id: totrans-780
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 练习 29.6-1 华氏度到开尔文，从 0 到 100
- en: Write a Python program that displays all degrees Fahrenheit from 0 to 100 and
    their equivalent degrees Kelvin. Use an increment value of 0.5\. It is given that
  id: totrans-781
  prefs: []
  type: TYPE_NORMAL
  zh: 编写一个 Python 程序，显示从 0 到 100 华氏度的所有华氏度和它们对应的开氏度。使用增量值为 0.5。已知
- en: 1.8 · Kelvin = Fahrenheit + 459.67
  id: totrans-782
  prefs: []
  type: TYPE_NORMAL
  zh: 1.8 · 开氏度 = 华氏度 + 459.67
- en: Solution
  id: totrans-783
  prefs: []
  type: TYPE_NORMAL
  zh: 解决方案
- en: The formula, solved for Kelvin becomes
  id: totrans-784
  prefs: []
  type: TYPE_NORMAL
  zh: 将公式解为开氏度，得到
- en: .![Image](img/chapter29-16.png)
  id: totrans-785
  prefs: []
  type: TYPE_NORMAL
  zh: .![Image](img/chapter29-16.png)
- en: All you need here is a while-loop that increments the value of variable fahrenheit
    from 0 to 100 using an step of 0.5\. The solution is presented next.
  id: totrans-786
  prefs: []
  type: TYPE_NORMAL
  zh: 这里你需要一个 while-loop，它使用步长 0.5 将变量 fahrenheit 从 0 增加到 100。解决方案如下。
- en: '![](img/my_exercise_header.png) file_29.6-1a'
  id: totrans-787
  prefs: []
  type: TYPE_NORMAL
  zh: '![](img/my_exercise_header.png) file_29.6-1a'
- en: fahrenheit = 0
  id: totrans-788
  prefs: []
  type: TYPE_NORMAL
  zh: fahrenheit = 0
- en: 'while fahrenheit <= 100:'
  id: totrans-789
  prefs: []
  type: TYPE_NORMAL
  zh: 'while fahrenheit <= 100:'
- en: kelvin = (fahrenheit + 459.67) / 1.8
  id: totrans-790
  prefs: []
  type: TYPE_NORMAL
  zh: kelvin = (fahrenheit + 459.67) / 1.8
- en: print("Fahrenheit:", fahrenheit, "Kelvin:", kelvin)
  id: totrans-791
  prefs: []
  type: TYPE_NORMAL
  zh: print("Fahrenheit:", fahrenheit, "Kelvin:", kelvin)
- en: fahrenheit += 0.5
  id: totrans-792
  prefs: []
  type: TYPE_NORMAL
  zh: fahrenheit += 0.5
- en: Of course, you may now wonder if this exercise can be solved using a for-loop.
    One could say “No, this is impossible! The step in the range() function must be
    an integer!” However, there is an easy trick that you can do to solve this exercise
    with a for-loop, as shown here.
  id: totrans-793
  prefs: []
  type: TYPE_NORMAL
  zh: 当然，你现在可能想知道这个练习是否可以用 for-loop 解决。有人可能会说“不，这是不可能的！range() 函数的步长必须是整数！”然而，有一个简单的技巧可以帮助你使用
    for-loop 解决这个练习，如下所示。
- en: '![](img/my_exercise_header.png) file_29.6-1b'
  id: totrans-794
  prefs: []
  type: TYPE_NORMAL
  zh: '![](img/my_exercise_header.png) file_29.6-1b'
- en: 'for f in range(0, 1001, 5):'
  id: totrans-795
  prefs: []
  type: TYPE_NORMAL
  zh: 'for f in range(0, 1001, 5):'
- en: fahrenheit = f / 10
  id: totrans-796
  prefs: []
  type: TYPE_NORMAL
  zh: fahrenheit = f / 10
- en: kelvin = (fahrenheit + 459.67) / 1.8
  id: totrans-797
  prefs: []
  type: TYPE_NORMAL
  zh: kelvin = (fahrenheit + 459.67) / 1.8
- en: print("Fahrenheit:", fahrenheit, "Kelvin:", kelvin)
  id: totrans-798
  prefs: []
  type: TYPE_NORMAL
  zh: print("Fahrenheit:", fahrenheit, "Kelvin:", kelvin)
- en: '![](img/notice.jpg)Generally speaking, division and multiplication are CPU-time
    consuming operations. Though this second approach works well, it is not the best
    option. The statement fahrenheit = f / 10 included within the for-loop may look
    innocent, but actually it is not, because the division f / 10 is executed 1001
    times! It is like having a sequence control structure of 1001 statements that
    perform 1001 divisions! Try to avoid division and multiplication operations within
    loops as much as possible!'
  id: totrans-799
  prefs: []
  type: TYPE_NORMAL
  zh: '![](img/notice.jpg)一般来说，除法和乘法是占用 CPU 时间的操作。尽管第二种方法效果不错，但并不是最佳选择。for-loop 中包含的语句
    fahrenheit = f / 10 可能看起来无害，但实际上并非如此，因为除法 f / 10 被执行了 1001 次！这就像有一个包含 1001 个语句的序列控制结构，每个语句执行
    1001 次除法！尽可能避免在循环中执行除法和乘法操作！'
- en: Exercise 29.6-2 Rice on a Chessboard
  id: totrans-800
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 练习 29.6-2 棋盘上的米粒
- en: There is a myth about a poor man who invented chess. The King of India was so
    pleased with that new game that he offered to give the poor man anything he wished
    for. The poor but wise man told his King that he would like one grain of rice
    for the first square of the board, two grains for the second, four grains for
    the third and so on, doubled for each of the 64 squares of the game board. This
    seemed to the King to be a modest request, so he ordered his servants to bring
    the rice.
  id: totrans-801
  prefs: []
  type: TYPE_NORMAL
  zh: 关于一个发明了国际象棋的穷人的传说。印度的国王对这款新游戏非常满意，以至于他提出给这个穷人任何他想要的。这个贫穷但聪明的男人告诉他的国王，他想要棋盘第一格一粒米，第二格两粒，第三格四粒，以此类推，每个棋盘的
    64 个方格都是翻倍。国王认为这是一个适度的要求，于是命令他的仆人带来大米。
- en: Write a Python program that calculates and displays how many grains of rice,
    and how many pounds of rice, will be on the chessboard in the end. Suppose that
    one pound of rice contains about 30,000 grains of rice.
  id: totrans-802
  prefs: []
  type: TYPE_NORMAL
  zh: 编写一个 Python 程序，计算并显示棋盘上最终会有多少粒米，以及多少磅米。假设一磅米含有大约 30,000 粒米。
- en: Solution
  id: totrans-803
  prefs: []
  type: TYPE_NORMAL
  zh: 解决方案
- en: Assume a chessboard of only 2 × 2 = 4 squares and a variable grains assigned
    the initial value 1 (this is the number of grains of the 1^(st) square). A for-loop
    that iterates three times can double the value of variable grains in each iteration,
    as shown in the next code fragment.
  id: totrans-804
  prefs: []
  type: TYPE_NORMAL
  zh: 假设一个只有 2 × 2 = 4 个方格的国际象棋棋盘，以及一个变量 grains 被赋予初始值 1（这是第 1 个方格的米粒数量）。一个循环三次的 for-loop
    可以在每次迭代中将变量 grains 的值翻倍，如下代码片段所示。
- en: grains = 1
  id: totrans-805
  prefs: []
  type: TYPE_NORMAL
  zh: grains = 1
- en: 'for i in range(3):'
  id: totrans-806
  prefs: []
  type: TYPE_NORMAL
  zh: 'for i in range(3):'
- en: grains = 2 * grains
  id: totrans-807
  prefs: []
  type: TYPE_NORMAL
  zh: grains = 2 * grains
- en: The value of variable grains at the end of each iteration is shown in the next
    table.
  id: totrans-808
  prefs: []
  type: TYPE_NORMAL
  zh: 每次迭代结束时变量 grains 的值如下表所示。
- en: '| Iteration | Value of grains |'
  id: totrans-809
  prefs: []
  type: TYPE_TB
  zh: '| 迭代 | grains 的值 |'
- en: '| 1st | 2 × 1 = 2 |'
  id: totrans-810
  prefs: []
  type: TYPE_TB
  zh: '| 第 1 次迭代 | 2 × 1 = 2 |'
- en: '| 2nd | 2 × 2 = 4 |'
  id: totrans-811
  prefs: []
  type: TYPE_TB
  zh: '| 第 2 次迭代 | 2 × 2 = 4 |'
- en: '| 3rd | 2 × 4 = 8 |'
  id: totrans-812
  prefs: []
  type: TYPE_TB
  zh: '| 第 3 次迭代 | 2 × 4 = 8 |'
- en: At the end of the 3^(rd) iteration, variable grains contains the value 8\. This
    value is not the total number of grains on the chessboard but only the number
    of grains on the 4^(th) square. If you need to find the total number of grains
    on the chessboard you can sum up the grains on all squares, that is, 1 + 2 + 4
    + 8 = 15.
  id: totrans-813
  prefs: []
  type: TYPE_NORMAL
  zh: 在第3次迭代的末尾，变量grains的值为8。这个值不是棋盘上的总米粒数，而只是第4个方格上的米粒数。如果你需要找到棋盘上的总米粒数，你可以将所有方格上的米粒数相加，即1
    + 2 + 4 + 8 = 15。
- en: In the real world a real chessboard contains 8 × 8 = 64 squares, thus you need
    to iterate for 63 times. The Python program is as follows.
  id: totrans-814
  prefs: []
  type: TYPE_NORMAL
  zh: 在现实世界中，一个真正的棋盘包含8 × 8 = 64个方格，因此你需要迭代63次。以下是一个Python程序。
- en: '![](img/my_exercise_header.png) file_29.6-2'
  id: totrans-815
  prefs: []
  type: TYPE_NORMAL
  zh: '![](img/my_exercise_header.png) file_29.6-2'
- en: grains = 1
  id: totrans-816
  prefs: []
  type: TYPE_NORMAL
  zh: grains = 1
- en: total = 1
  id: totrans-817
  prefs: []
  type: TYPE_NORMAL
  zh: total = 1
- en: 'for i in range(63):'
  id: totrans-818
  prefs: []
  type: TYPE_NORMAL
  zh: 'for i in range(63):'
- en: grains = 2 * grains
  id: totrans-819
  prefs: []
  type: TYPE_NORMAL
  zh: grains = 2 * grains
- en: total += grains  #This is equivalent to total = total + grains
  id: totrans-820
  prefs: []
  type: TYPE_NORMAL
  zh: total += grains  # 这相当于 total = total + grains
- en: weight = total / 30000
  id: totrans-821
  prefs: []
  type: TYPE_NORMAL
  zh: weight = total / 30000
- en: print(total, weight)
  id: totrans-822
  prefs: []
  type: TYPE_NORMAL
  zh: print(total, weight)
- en: 'In case you are wondering how big these numbers are, here is your answer: On
    the chessboard there will be 18,446,744,073,709,551,615 grains of rice; that is,
    614,891,469,123,651.8 pounds!'
  id: totrans-823
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你想知道这些数字有多大，这里就是答案：在棋盘上将有18,446,744,073,709,551,615粒米；即614,891,469,123,651.8磅！
- en: Exercise 29.6-3 Just a Poll
  id: totrans-824
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: Exercise 29.6-3 Just a Poll
- en: A public opinion polling company asks 1000 citizens if they eat breakfast in
    the morning. Write a Python program that prompts the citizens to enter their gender
    (M for Male, F for Female, O for Other) and their answer to the question (Y for
    Yes, N for No, S for Sometimes), and then calculates and displays the number of
    citizens that gave “Yes” as an answer, as well as the percentage of women among
    the citizens that gave “No” as an answer. Using a loop control structure, the
    program must also validate data input and accept only values M, F or O for gender
    and Y, N, or S for answer.
  id: totrans-825
  prefs: []
  type: TYPE_NORMAL
  zh: 一家民意调查公司询问1000名公民他们是否在早上吃早餐。编写一个Python程序，提示公民输入他们的性别（M代表男性，F代表女性，O代表其他）以及他们对问题的回答（Y代表是，N代表否，S代表有时），然后计算并显示回答“是”的公民数量，以及回答“否”的女性公民的百分比。使用循环控制结构，程序还必须验证数据输入，并且只接受性别为M、F或O，以及回答为Y、N或S的值。
- en: Solution
  id: totrans-826
  prefs: []
  type: TYPE_NORMAL
  zh: Solution
- en: The Python program is as follows.
  id: totrans-827
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是一个Python程序。
- en: '![](img/my_exercise_header.png) file_29.6-3a'
  id: totrans-828
  prefs: []
  type: TYPE_NORMAL
  zh: '![](img/my_exercise_header.png) file_29.6-3a'
- en: CITIZENS = 1000
  id: totrans-829
  prefs: []
  type: TYPE_NORMAL
  zh: CITIZENS = 1000
- en: totalYes = 0
  id: totrans-830
  prefs: []
  type: TYPE_NORMAL
  zh: totalYes = 0
- en: femaleNo = 0
  id: totrans-831
  prefs: []
  type: TYPE_NORMAL
  zh: femaleNo = 0
- en: 'for i in range(CITIZENS):'
  id: totrans-832
  prefs: []
  type: TYPE_NORMAL
  zh: 'for i in range(CITIZENS):'
- en: 'while True:'
  id: totrans-833
  prefs: []
  type: TYPE_NORMAL
  zh: 'while True:'
- en: 'gender = input("Enter gender: ").lower()'
  id: totrans-834
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 'gender = input("Enter gender: ").lower()'
- en: 'if gender == "m" or gender == "f" or gender == "o": break'
  id: totrans-835
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 'if gender == "m" or gender == "f" or gender == "o": break'
- en: 'while True:'
  id: totrans-836
  prefs: []
  type: TYPE_NORMAL
  zh: 'while True:'
- en: answer = input("Do you eat breakfast in the morning? ").lower()
  id: totrans-837
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: answer = input("Do you eat breakfast in the morning? ").lower()
- en: 'if answer == "y" or answer == "n" or answer == "s": break'
  id: totrans-838
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 'if answer == "y" or answer == "n" or answer == "s": break'
- en: 'if answer == "y":'
  id: totrans-839
  prefs: []
  type: TYPE_NORMAL
  zh: 'if answer == "y":'
- en: totalYes += 1
  id: totrans-840
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: totalYes += 1
- en: 'if gender == "f" and answer == "n":'
  id: totrans-841
  prefs: []
  type: TYPE_NORMAL
  zh: 'if gender == "f" and answer == "n":'
- en: femaleNo += 1
  id: totrans-842
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: femaleNo += 1
- en: print(totalYes)
  id: totrans-843
  prefs: []
  type: TYPE_NORMAL
  zh: print(totalYes)
- en: print(femaleNo * 100 / CITIZENS, "%", sep = "")
  id: totrans-844
  prefs: []
  type: TYPE_NORMAL
  zh: print(femaleNo * 100 / CITIZENS, "%", sep = "")
- en: '![](img/notice.jpg)Note how Python converts the user''s input to lowercase.'
  id: totrans-845
  prefs: []
  type: TYPE_NORMAL
  zh: '![](img/notice.jpg)注意Python如何将用户的输入转换为小写。'
- en: Of course, after a little refinement, this program can become
  id: totrans-846
  prefs: []
  type: TYPE_NORMAL
  zh: 当然，经过一点改进，这个程序可以变成
- en: '![](img/my_exercise_header.png) file_29.6-3b'
  id: totrans-847
  prefs: []
  type: TYPE_NORMAL
  zh: '![](img/my_exercise_header.png) file_29.6-3b'
- en: CITIZENS = 1000
  id: totrans-848
  prefs: []
  type: TYPE_NORMAL
  zh: CITIZENS = 1000
- en: totalYes = 0
  id: totrans-849
  prefs: []
  type: TYPE_NORMAL
  zh: totalYes = 0
- en: femaleNo = 0
  id: totrans-850
  prefs: []
  type: TYPE_NORMAL
  zh: femaleNo = 0
- en: 'for i in range(CITIZENS):'
  id: totrans-851
  prefs: []
  type: TYPE_NORMAL
  zh: 'for i in range(CITIZENS):'
- en: 'while True:'
  id: totrans-852
  prefs: []
  type: TYPE_NORMAL
  zh: 'while True:'
- en: 'gender = input("Enter gender: ").lower()'
  id: totrans-853
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 'gender = input("Enter gender: ").lower()'
- en: 'if gender in ["m", "f", "o"]: break'
  id: totrans-854
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 'if gender in ["m", "f", "o"]: break'
- en: 'while True:'
  id: totrans-855
  prefs: []
  type: TYPE_NORMAL
  zh: 'while True:'
- en: answer = input("Do you eat breakfast in the morning? ").lower()
  id: totrans-856
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: answer = input("Do you eat breakfast in the morning? ").lower()
- en: 'if answer in ["y", "n", "s"]: break'
  id: totrans-857
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 'if answer in ["y", "n", "s"]: break'
- en: 'if answer == "y":'
  id: totrans-858
  prefs: []
  type: TYPE_NORMAL
  zh: 'if answer == "y":'
- en: totalYes += 1
  id: totrans-859
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: totalYes += 1
- en: 'elif gender == "f":'
  id: totrans-860
  prefs: []
  type: TYPE_NORMAL
  zh: 'elif gender == "f":'
- en: femaleNo += 1
  id: totrans-861
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: femaleNo += 1
- en: print(totalYes)
  id: totrans-862
  prefs: []
  type: TYPE_NORMAL
  zh: print(totalYes)
- en: print(femaleNo * 100 / CITIZENS, "%", sep = "")
  id: totrans-863
  prefs: []
  type: TYPE_NORMAL
  zh: print(femaleNo * 100 / CITIZENS, "%", sep = "")
- en: Exercise 29.6-4 Is the Message a Palindrome?
  id: totrans-864
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: Exercise 29.6-4 Is the Message a Palindrome?
- en: A palindrome is a word or sentence that reads the same both backwards and forward.
    (You may recall from [Exercise 22.5-4](chapter22.html#toc_26) that a number can
    also be a palindrome). Write a Python program that prompts the user to enter a
    word or sentence and then displays a message stating whether or not the user-provided
    word or sentence is a palindrome. Following are some palindrome words and messages.
  id: totrans-865
  prefs: []
  type: TYPE_NORMAL
  zh: 回文是一个既可以正向读也可以反向读的单词或句子。（你可能还记得，从[练习22.5-4](chapter22.html#toc_26)中，一个数字也可以是回文）。编写一个Python程序，提示用户输入一个单词或句子，然后显示一条消息，说明用户提供的单词或句子是否是回文。以下是一些回文单词和消息。
- en: ►Anna
  id: totrans-866
  prefs: []
  type: TYPE_NORMAL
  zh: Anna
- en: ►Radar
  id: totrans-867
  prefs: []
  type: TYPE_NORMAL
  zh: Radar
- en: ►Madam
  id: totrans-868
  prefs: []
  type: TYPE_NORMAL
  zh: Madam
- en: ►A nut for a jar of tuna.
  id: totrans-869
  prefs: []
  type: TYPE_NORMAL
  zh: 一颗坚果换一罐金枪鱼罐头。
- en: ►Dennis and Edna sinned.
  id: totrans-870
  prefs: []
  type: TYPE_NORMAL
  zh: Dennis和Edna犯了罪。
- en: ►Murder for a jar of red rum.
  id: totrans-871
  prefs: []
  type: TYPE_NORMAL
  zh: 借一罐红酒换命。
- en: ►Borrow or rob?
  id: totrans-872
  prefs: []
  type: TYPE_NORMAL
  zh: 借还是抢？
- en: ►Are we not drawn onward, we few, drawn onward to new era?
  id: totrans-873
  prefs: []
  type: TYPE_NORMAL
  zh: 我们不是被吸引向前，我们这些人，被吸引向前进入新时代？
- en: Solution
  id: totrans-874
  prefs: []
  type: TYPE_NORMAL
  zh: 解决方案
- en: There are some things you should keep in mind before starting to compare the
    letters one by one and checking whether the first letter is the same as the last
    one, the second letter is the same as the last but one, and so forth.
  id: totrans-875
  prefs: []
  type: TYPE_NORMAL
  zh: 在开始逐个比较字母并检查第一个字母是否与最后一个字母相同，第二个字母是否与倒数第二个字母相同等等之前，有一些事情你应该记住。
- en: ►In a given sentence or word, some letters may be in uppercase and some in lowercase.
    For example, in the sentence “A nut for a jar of tuna”, even though the first
    and last letters are the same, they are not considered equal. Thus, the program
    must first convert all the letters—for example, to lowercase—before it can start
    comparing them.
  id: totrans-876
  prefs: []
  type: TYPE_NORMAL
  zh: 在给定的句子或单词中，一些字母可能是大写，一些可能是小写。例如，在句子“A nut for a jar of tuna”中，尽管第一个和最后一个字母相同，但它们不被认为是相等的。因此，程序必须首先将所有字母（例如，转换为小写）进行比较，然后才能开始比较它们。
- en: ►Removing characters like spaces, periods, question marks, and commas is crucial
    for the program to accurately compare the letters. For example, without this step,
    in the sentence “Borrow or rob?” the program will mistakenly assume it's not a
    palindrome, as it would attempt to compare the initial “B” with the final question
    mark “?”.
  id: totrans-877
  prefs: []
  type: TYPE_NORMAL
  zh: 删除空格、句号、问号和逗号等字符对于程序准确比较字母至关重要。例如，如果不进行此步骤，在句子“借还是抢？”中，程序会错误地假设它不是一个回文，因为它会尝试将初始字母“B”与最后的问号“？”进行比较。
- en: '►Assume that the examined sentence is “Borrow or rob?”. After changing all
    letters to lowercase and after removing all unwanted spaces and the question mark,
    the sentence becomes “borroworrob”. These letters and their corresponding position
    in the string are as follows:'
  id: totrans-878
  prefs: []
  type: TYPE_NORMAL
  zh: 假设要检查的句子是“借还是抢？”。在将所有字母转换为小写并删除所有不需要的空格和问号之后，句子变为“borroworrob”。这些字母及其在字符串中的对应位置如下：
- en: '![Image](img/chapter29-17.png)'
  id: totrans-879
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/chapter29-17.png)'
- en: What you should realize here is that the for-loop should iterate for only half
    of the letters. Can you figure out why?
  id: totrans-880
  prefs: []
  type: TYPE_NORMAL
  zh: 你在这里应该意识到的是，for循环应该只遍历字母的一半。你能想出为什么吗？
- en: The program should start the iterations and compare the letter at position 0
    with the letter at position 10\. Then it should compare the letter at position
    1 with the letter at position 9, and so forth. The last iteration should be the
    one that compares the letters at positions 4 and 6\. It would be pointless to
    continue checking thereafter, since all letters have already been compared.
  id: totrans-881
  prefs: []
  type: TYPE_NORMAL
  zh: 程序应该开始迭代，并将位置0的字母与位置10的字母进行比较。然后它应该将位置1的字母与位置9的字母进行比较，以此类推。最后一次迭代应该是比较位置4和6的字母。在此之后继续检查将是徒劳的，因为所有字母都已经比较过了。
- en: There are many solutions to this problem. Some of them are presented below.
    Comments written within the programs can help you fully understand the way they
    operate. However, if you still have doubts about how they operate you can use
    an IDE (IDLE or Visual Studio Code) to execute them step by step and observe the
    values of the variables in each step.
  id: totrans-882
  prefs: []
  type: TYPE_NORMAL
  zh: 这个问题有多个解决方案。下面介绍其中一些。程序中的注释可以帮助你完全理解它们的工作方式。然而，如果你仍然对它们的工作方式有疑问，可以使用IDE（IDLE或Visual
    Studio Code）逐步执行它们并观察每一步的变量值。
- en: First approach
  id: totrans-883
  prefs: []
  type: TYPE_NORMAL
  zh: 第一种方法
- en: The solution is presented here.
  id: totrans-884
  prefs: []
  type: TYPE_NORMAL
  zh: 解决方案在此处展示。
- en: '![](img/my_exercise_header.png) file_29.6-4a'
  id: totrans-885
  prefs: []
  type: TYPE_NORMAL
  zh: '![](img/my_exercise_header.png) file_29.6-4a'
- en: 'message = input("Enter a message: ").lower()'
  id: totrans-886
  prefs: []
  type: TYPE_NORMAL
  zh: 'message = input("输入一条消息: ").lower()'
- en: '#Create a new string which contains all except spaces, commas, periods, and
    question marks'
  id: totrans-887
  prefs: []
  type: TYPE_NORMAL
  zh: '#创建一个新的字符串，其中包含除空格、逗号、句号和问号之外的所有内容'
- en: messageClean = ""
  id: totrans-888
  prefs: []
  type: TYPE_NORMAL
  zh: messageClean = ""
- en: 'for letter in message:'
  id: totrans-889
  prefs: []
  type: TYPE_NORMAL
  zh: 'for letter in message:'
- en: 'if letter != " " and letter != "," and letter != "." and letter != "?":'
  id: totrans-890
  prefs: []
  type: TYPE_NORMAL
  zh: 'if letter != " " and letter != "," and letter != "." and letter != "?":'
- en: messageClean += letter
  id: totrans-891
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: messageClean += letter
- en: j = len(messageClean) – 1  #This is the last position of messageClean
  id: totrans-892
  prefs: []
  type: TYPE_NORMAL
  zh: j = len(messageClean) – 1  # 这是 messageClean 的最后一个位置
- en: 'middlePos = j // 2         #This is the middle position of messageClean'
  id: totrans-893
  prefs: []
  type: TYPE_NORMAL
  zh: 'middlePos = j // 2         # 这是 messageClean 的中间位置'
- en: palindrome = True  #In the beginning, assume that sentence is palindrome
  id: totrans-894
  prefs: []
  type: TYPE_NORMAL
  zh: palindrome = True  # 开始时，假设句子是回文
- en: '#This for-loop compares letters one by one.'
  id: totrans-895
  prefs: []
  type: TYPE_NORMAL
  zh: '# 此循环逐个比较字母。'
- en: 'for i in range(middlePos + 1):'
  id: totrans-896
  prefs: []
  type: TYPE_NORMAL
  zh: 'for i in range(middlePos + 1):'
- en: leftLetter = messageClean[i]
  id: totrans-897
  prefs: []
  type: TYPE_NORMAL
  zh: leftLetter = messageClean[i]
- en: rightLetter = messageClean[j]
  id: totrans-898
  prefs: []
  type: TYPE_NORMAL
  zh: rightLetter = messageClean[j]
- en: '#If at least one pair of letters fails to validate set variable palindrome
    to False'
  id: totrans-899
  prefs: []
  type: TYPE_NORMAL
  zh: '# 如果至少有一对字母未能通过验证，将变量 palindrome 设置为 False'
- en: 'if leftLetter != rightLetter:'
  id: totrans-900
  prefs: []
  type: TYPE_NORMAL
  zh: 'if leftLetter != rightLetter:'
- en: palindrome = False
  id: totrans-901
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: palindrome = False
- en: j -= 1
  id: totrans-902
  prefs: []
  type: TYPE_NORMAL
  zh: j -= 1
- en: '#If variable palindrome is still True'
  id: totrans-903
  prefs: []
  type: TYPE_NORMAL
  zh: '# 如果变量 palindrome 仍然为 True'
- en: 'if palindrome:'
  id: totrans-904
  prefs: []
  type: TYPE_NORMAL
  zh: 'if palindrome:'
- en: print("The message is palindrome")
  id: totrans-905
  prefs: []
  type: TYPE_NORMAL
  zh: print("信息是回文")
- en: Second approach
  id: totrans-906
  prefs: []
  type: TYPE_NORMAL
  zh: 第二种方法
- en: The previous approach works fine, but let's assume that the user enters a very
    large sentence that is not a palindrome; for example, its second letter is not
    the same as the last but one. Unfortunately, in the previous approach, the last
    for-loop continues to iterate until the middle of the sentence despite the fact
    that the variable palindrome has been set to False, even from the second iteration.
    So, let's try to make this program even better. As you already know, you can break
    out of a loop before it completes all of its iterations using the break statement.
  id: totrans-907
  prefs: []
  type: TYPE_NORMAL
  zh: 前一种方法效果良好，但假设用户输入一个非常长的句子，它不是回文；例如，它的第二个字母与倒数第二个字母不同。不幸的是，在前一种方法中，最后一个 for 循环即使在变量
    palindrome 被设置为 False 后，仍然继续迭代到句子的中间。所以，让我们尝试使这个程序更加完善。如您所知，您可以使用 break 语句在循环完成所有迭代之前跳出循环。
- en: 'Furthermore, you can improve the previous approach in two ways:'
  id: totrans-908
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，您可以通过两种方式改进前一种方法：
- en: ►You can remove spaces, commas, periods, and question marks from the variable
    message, using the not in membership operator.
  id: totrans-909
  prefs: []
  type: TYPE_NORMAL
  zh: ►您可以使用 not in 成员运算符从变量 message 中移除空格、逗号、句号和问号。
- en: ►Instead of using the variable j to access the letters of variable messageClean
    on the right, you can use negative indexes.
  id: totrans-910
  prefs: []
  type: TYPE_NORMAL
  zh: ►而不是使用变量 j 访问 messageClean 变量右侧的字母，你可以使用负索引。
- en: The solution is shown here.
  id: totrans-911
  prefs: []
  type: TYPE_NORMAL
  zh: 解决方案在此处展示。
- en: '![](img/my_exercise_header.png) file_29.6-4b'
  id: totrans-912
  prefs: []
  type: TYPE_NORMAL
  zh: '![](img/my_exercise_header.png) file_29.6-4b'
- en: 'message = input("Enter a message: ").lower()'
  id: totrans-913
  prefs: []
  type: TYPE_NORMAL
  zh: 'message = input("输入一条信息: ").lower()'
- en: '#Remove spaces, commas, periods and question marks using the "not in" membership
    operator'
  id: totrans-914
  prefs: []
  type: TYPE_NORMAL
  zh: '# 使用 "not in" 成员运算符移除空格、逗号、句号和问号'
- en: messageClean = ""
  id: totrans-915
  prefs: []
  type: TYPE_NORMAL
  zh: messageClean = ""
- en: 'for letter in message:'
  id: totrans-916
  prefs: []
  type: TYPE_NORMAL
  zh: 'for letter in message:'
- en: 'if letter not in " ,.?":'
  id: totrans-917
  prefs: []
  type: TYPE_NORMAL
  zh: 'if letter not in " ,.?":'
- en: messageClean += letter
  id: totrans-918
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: messageClean += letter
- en: middlePos = (len(messageClean) - 1) // 2
  id: totrans-919
  prefs: []
  type: TYPE_NORMAL
  zh: middlePos = (len(messageClean) - 1) // 2
- en: palindrome = True
  id: totrans-920
  prefs: []
  type: TYPE_NORMAL
  zh: palindrome = True
- en: 'for i in range(middlePos + 1):'
  id: totrans-921
  prefs: []
  type: TYPE_NORMAL
  zh: 'for i in range(middlePos + 1):'
- en: 'if messageClean[i] != messageClean[-i - 1]:  #Right letter uses negative index'
  id: totrans-922
  prefs: []
  type: TYPE_NORMAL
  zh: 'if messageClean[i] != messageClean[-i - 1]:  # 正确的字母使用负索引'
- en: palindrome = False
  id: totrans-923
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: palindrome = False
- en: break
  id: totrans-924
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: break
- en: 'if palindrome:'
  id: totrans-925
  prefs: []
  type: TYPE_NORMAL
  zh: 'if palindrome:'
- en: print("The message is palindrome")
  id: totrans-926
  prefs: []
  type: TYPE_NORMAL
  zh: print("信息是回文")
- en: Third approach
  id: totrans-927
  prefs: []
  type: TYPE_NORMAL
  zh: 第三种方法
- en: A more Pythonic and sophisticated way is to remove spaces, commas, periods,
    and question marks using the replace() method, and then just compare messageClean
    to its reversed value.
  id: totrans-928
  prefs: []
  type: TYPE_NORMAL
  zh: 一种更 Pythonic 和复杂的方法是使用 replace() 方法移除空格、逗号、句号和问号，然后只需比较 messageClean 与其反转值。
- en: The solution is shown here.
  id: totrans-929
  prefs: []
  type: TYPE_NORMAL
  zh: 解决方案在此处展示。
- en: '![](img/my_exercise_header.png) file_29.6-4c'
  id: totrans-930
  prefs: []
  type: TYPE_NORMAL
  zh: '![](img/my_exercise_header.png) file_29.6-4c'
- en: 'message = input("Enter a message: ").lower()'
  id: totrans-931
  prefs: []
  type: TYPE_NORMAL
  zh: 'message = input("输入一条信息: ").lower()'
- en: '#Create a new string which contains letters without spaces, commas, periods
    or question marks'
  id: totrans-932
  prefs: []
  type: TYPE_NORMAL
  zh: '# 创建一个新的字符串，其中包含不带空格、逗号、句号或问号的字母'
- en: messageClean = message
  id: totrans-933
  prefs: []
  type: TYPE_NORMAL
  zh: messageClean = message
- en: 'for c in " ,.?":'
  id: totrans-934
  prefs: []
  type: TYPE_NORMAL
  zh: 'for c in " ,.?":'
- en: messageClean = messageClean.replace(c, "")
  id: totrans-935
  prefs: []
  type: TYPE_NORMAL
  zh: messageClean = messageClean.replace(c, "")
- en: 'if messageClean == messageClean[::-1]:'
  id: totrans-936
  prefs: []
  type: TYPE_NORMAL
  zh: 'if messageClean == messageClean[::-1]:'
- en: print("The message is palindrome")
  id: totrans-937
  prefs: []
  type: TYPE_NORMAL
  zh: print("信息是回文")
- en: Furthermore, since there are just four different characters that must be removed
    (spaces, commas, periods, and question marks) you can avoid the first loop if
    you just chain four replace() methods, as shown in the Python program that follows.
  id: totrans-938
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，由于只需移除四种不同的字符（空格、逗号、句号和问号），您可以通过链式四个 replace() 方法来避免第一个循环，就像下面的 Python 程序所示。
- en: '![](img/my_exercise_header.png) file_29.6-4d'
  id: totrans-939
  prefs: []
  type: TYPE_NORMAL
  zh: '![](img/my_exercise_header.png) file_29.6-4d'
- en: 'message = input("Enter a message: ").lower()'
  id: totrans-940
  prefs: []
  type: TYPE_NORMAL
- en: '#Create a new string which contains letters without spaces, commas, periods
    or question marks'
  id: totrans-941
  prefs: []
  type: TYPE_NORMAL
- en: messageClean = message.replace(" ", "").replace(",", "").replace(".", "").replace("?",
    "")
  id: totrans-942
  prefs: []
  type: TYPE_NORMAL
- en: 'if messageClean == messageClean[::-1]:'
  id: totrans-943
  prefs: []
  type: TYPE_NORMAL
- en: print("The message is palindrome")
  id: totrans-944
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/notice.jpg)It is obvious that one problem can have many solutions.
    It is up to you to find the optimal one!'
  id: totrans-945
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/notice.jpg)If you wish to remove all the unwanted characters (spaces,
    commas, periods, question marks, ampersands, etc.), you can use the following
    code fragment instead. It keeps only the letters in the variable messageClean!'
  id: totrans-946
  prefs: []
  type: TYPE_NORMAL
- en: '#Create a new string which contains only letters'
  id: totrans-947
  prefs: []
  type: TYPE_NORMAL
- en: messageClean = ""
  id: totrans-948
  prefs: []
  type: TYPE_NORMAL
- en: validChars = "abcdefghijklmnopqrstuvwxyz"
  id: totrans-949
  prefs: []
  type: TYPE_NORMAL
- en: 'for char in message:'
  id: totrans-950
  prefs: []
  type: TYPE_NORMAL
- en: 'if char in validChars:'
  id: totrans-951
  prefs: []
  type: TYPE_NORMAL
- en: 'messageClean += char   #Concatenation'
  id: totrans-952
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '29.7 Review Questions: True/False'
  id: totrans-953
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Choose true or false for each of the following statements.
  id: totrans-954
  prefs: []
  type: TYPE_NORMAL
- en: 1)Data validation is the process of restricting data input, forcing the user
    to enter only valid values.
  id: totrans-955
  prefs: []
  type: TYPE_NORMAL
- en: 2)You can use a definite loop to validate data input.
  id: totrans-956
  prefs: []
  type: TYPE_NORMAL
- en: 3)To force a user to enter only positive numbers, without displaying any error
    messages, you can use the following code fragment.
  id: totrans-957
  prefs: []
  type: TYPE_NORMAL
- en: 'while True:'
  id: totrans-958
  prefs: []
  type: TYPE_NORMAL
- en: 'x = float(input("Enter a positive number: "))'
  id: totrans-959
  prefs: []
  type: TYPE_NORMAL
- en: 'if x > 0: break'
  id: totrans-960
  prefs: []
  type: TYPE_NORMAL
- en: 4)To force a user to enter numbers between 1 and 10, you can use the following
    code fragment.
  id: totrans-961
  prefs: []
  type: TYPE_NORMAL
- en: 'x = float(input("Enter a number between 1 and 10: "))'
  id: totrans-962
  prefs: []
  type: TYPE_NORMAL
- en: 'while x >= 1 and x <= 10:'
  id: totrans-963
  prefs: []
  type: TYPE_NORMAL
- en: print("Wrong number")
  id: totrans-964
  prefs: []
  type: TYPE_NORMAL
- en: 'x = float(input("Enter a number between 1 and 10: "))'
  id: totrans-965
  prefs: []
  type: TYPE_NORMAL
- en: 5)In order to find the lowest number among 10 user-provided numbers, you can
    use the following code fragment.
  id: totrans-966
  prefs: []
  type: TYPE_NORMAL
- en: minimum = 0
  id: totrans-967
  prefs: []
  type: TYPE_NORMAL
- en: 'for i in range(10):'
  id: totrans-968
  prefs: []
  type: TYPE_NORMAL
- en: w = float(input())
  id: totrans-969
  prefs: []
  type: TYPE_NORMAL
- en: 'if w < minimum: minimum = w'
  id: totrans-970
  prefs: []
  type: TYPE_NORMAL
- en: 6)In order to find the highest number among 10 user-provided numbers, you can
    use the following code fragment.
  id: totrans-971
  prefs: []
  type: TYPE_NORMAL
- en: maximum = 0
  id: totrans-972
  prefs: []
  type: TYPE_NORMAL
- en: 'for i in range(10):'
  id: totrans-973
  prefs: []
  type: TYPE_NORMAL
- en: w = float(input())
  id: totrans-974
  prefs: []
  type: TYPE_NORMAL
- en: 'if w > maximum: maximum = w'
  id: totrans-975
  prefs: []
  type: TYPE_NORMAL
- en: 7)In order to find the highest number among 10 positive user-provided numbers,
    you can use the following code fragment.
  id: totrans-976
  prefs: []
  type: TYPE_NORMAL
- en: maximum = 0
  id: totrans-977
  prefs: []
  type: TYPE_NORMAL
- en: 'for i in range(10):'
  id: totrans-978
  prefs: []
  type: TYPE_NORMAL
- en: w = float(input())
  id: totrans-979
  prefs: []
  type: TYPE_NORMAL
- en: 'if w > maximum: maximum = w'
  id: totrans-980
  prefs: []
  type: TYPE_NORMAL
- en: 29.8 Review Exercises
  id: totrans-981
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Complete the following exercises.
  id: totrans-982
  prefs: []
  type: TYPE_NORMAL
- en: 1)Design a flowchart and write the corresponding Python program that prompts
    the user to repeatedly enter non-negative values until their average value exceeds
    3000\. At the end, the program must display the total number of zeros entered.
  id: totrans-983
  prefs: []
  type: TYPE_NORMAL
- en: 2)Write a Python program that prompts the user to enter an integer between 1
    and 20 and then displays all four-digit integers for which the sum of their digits
    is less than the user-provided integer. For example, if the user enters 15, the
    value 9301 is such a number, since
  id: totrans-984
  prefs: []
  type: TYPE_NORMAL
- en: 9 + 3 + 0 + 1 < 15
  id: totrans-985
  prefs: []
  type: TYPE_NORMAL
- en: '3)Write a Python program that displays all four-digit integers that satisfy
    all of the following conditions:'
  id: totrans-986
  prefs: []
  type: TYPE_NORMAL
- en: ►the number's first digit is greater than its second digit
  id: totrans-987
  prefs: []
  type: TYPE_NORMAL
- en: ►the number's second digit is equal to its third digit
  id: totrans-988
  prefs: []
  type: TYPE_NORMAL
- en: ►the number's third digit is smaller than its fourth digit
  id: totrans-989
  prefs: []
  type: TYPE_NORMAL
- en: For example, the values 7559, 3112, and 9889 are such numbers.
  id: totrans-990
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，7559、3112和9889是这样的数字。
- en: 4)Write a Python program that prompts the user to enter an integer and then
    displays the number of its digits.
  id: totrans-991
  prefs: []
  type: TYPE_NORMAL
  zh: 4)编写一个Python程序，提示用户输入一个整数，然后显示其位数。
- en: 5)A student wrote the following code fragment which is supposed to validate
    data input, forcing the user to enter only values 0 and 1\. Identify any error(s)
    in the code fragment.
  id: totrans-992
  prefs: []
  type: TYPE_NORMAL
  zh: 5)一名学生编写了以下代码片段，目的是验证数据输入，强制用户只能输入0和1的值。请识别代码片段中的任何错误。
- en: 'while x != 1 or x != 0:'
  id: totrans-993
  prefs: []
  type: TYPE_NORMAL
  zh: 'while x != 1 or x != 0:'
- en: print("Error")
  id: totrans-994
  prefs: []
  type: TYPE_NORMAL
  zh: print("Error")
- en: x = int(input())
  id: totrans-995
  prefs: []
  type: TYPE_NORMAL
  zh: x = int(input())
- en: 6)Using a loop control structure, write the code fragment that validates data
    input, forcing the user to enter a valid gender (M for Male, F for Female, O for
    Other). Moreover, it must validate correctly both for lowercase and uppercase
    letters.
  id: totrans-996
  prefs: []
  type: TYPE_NORMAL
  zh: 6)使用循环控制结构，编写验证数据输入的代码片段，强制用户输入有效的性别（M代表男性，F代表女性，O代表其他）。此外，它必须正确验证小写和大写字母。
- en: 7)Write a Python program that prompts the user to enter a non-negative number
    and then calculates its square root. Using a loop control structure, the program
    must also validate data input and display an error message when the user enters
    any negative values. Additionally, the user has a maximum number of two retries.
    If the user enters more than three negative values, a message “Dude, you are dumb!”
    must be displayed and the program execution must end.
  id: totrans-997
  prefs: []
  type: TYPE_NORMAL
  zh: 7)编写一个Python程序，提示用户输入一个非负数，然后计算其平方根。使用循环控制结构，程序还必须验证数据输入，并在用户输入任何负值时显示错误信息。此外，用户有两次重试的机会。如果用户输入超过三个负值，必须显示消息“Dude,
    you are dumb!”，并且程序执行必须结束。
- en: '8)The area of a circle can be calculated using the following formula:'
  id: totrans-998
  prefs: []
  type: TYPE_NORMAL
  zh: 8)圆的面积可以使用以下公式计算：
- en: Area = π∙Radius²
  id: totrans-999
  prefs: []
  type: TYPE_NORMAL
  zh: 面积 = π∙半径²
- en: Write a Python program that prompts the user to enter the length of the radius
    of a circle and then calculates and displays its area. The program must iterate
    as many times as the user wishes. At the end of each area calculation, the program
    must ask the user if they wish to calculate the area of another circle. If the
    answer is “yes” the program must repeat; it must end otherwise. Make your program
    accept the answer in all possible forms such as “yes”, “YES”, “Yes”, or even “YeS”.
  id: totrans-1000
  prefs: []
  type: TYPE_NORMAL
  zh: 编写一个Python程序，提示用户输入圆的半径长度，然后计算并显示其面积。程序必须根据用户的意愿迭代执行。在每次面积计算结束后，程序必须询问用户是否希望计算另一个圆的面积。如果答案是“是”，程序必须重复执行；否则必须结束。程序应接受所有可能的答案形式，如“是”、“YES”、“Yes”或甚至“YeS”。
- en: Moreover, using a loop control structure, the program must validate data input
    and display an error message when the user enters any non-positive value for Radius.
  id: totrans-1001
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，使用循环控制结构，程序必须验证数据输入，并在用户输入任何非正值作为半径时显示错误信息。
- en: 'Hint: Use the pi from the math module to get the value of π.'
  id: totrans-1002
  prefs: []
  type: TYPE_NORMAL
  zh: 提示：使用math模块中的pi获取π的值。
- en: 9)Write a Python program that prompts the user to enter the daily temperatures
    (in degrees Fahrenheit) recorded at the same hour each day in August and then
    calculates and displays the average as well as the highest temperature.
  id: totrans-1003
  prefs: []
  type: TYPE_NORMAL
  zh: 9)编写一个Python程序，提示用户输入8月份每天同一小时记录的温度（华氏度），然后计算并显示平均值以及最高温度。
- en: Since −459.67^o (on the Fahrenheit scale) is the lowest temperature possible
    (it is called absolute zero), using a loop control structure, the program must
    also validate data input and display an error message when the user enters a value
    lower than absolute zero.
  id: totrans-1004
  prefs: []
  type: TYPE_NORMAL
  zh: 由于-459.67°F（华氏温度）是可能达到的最低温度（称为绝对零度），使用循环控制结构，程序还必须验证数据输入，并在用户输入低于绝对零度的值时显示错误信息。
- en: 10)A scientist needs a software application to record the level of the sea based
    on values logged at specific times (HH:MM), in order to extract some useful information.
    Write a Python program that lets the scientist enter the sea level, along with
    the hour and minutes, repeatedly until the value 9999 is entered for the sea level.
    Then, the program must display both the highest and the lowest recorded sea levels,
    along with the corresponding hour and minutes at which these levels were recorded.
  id: totrans-1005
  prefs: []
  type: TYPE_NORMAL
  zh: 10)一名科学家需要一个软件应用程序来根据特定时间（HH:MM）记录的海平面值来记录海平面，以便提取一些有用的信息。编写一个Python程序，让科学家可以重复输入海平面值，包括小时和分钟，直到输入海平面值为9999。然后，程序必须显示记录的最高和最低海平面值，以及记录这些水平值对应的小时和分钟。
- en: 11)In some countries, when someone sneezes, a number (an integer) is said aloud
    by another person. The sneezing person then adds up the digits of this number
    until they obtain a number between 1 and 26\. The letter corresponding to this
    number (1 for “A”, 2 for “B”, and so on) represents the first letter of the name
    of someone who might be thinking of them.
  id: totrans-1006
  prefs: []
  type: TYPE_NORMAL
  zh: 11)在一些国家，当有人打喷嚏时，另一个人会大声说出一个数字（一个整数）。打喷嚏的人然后将这个数字的各位数相加，直到得到一个介于1到26之间的数字。这个数字对应的字母（1对应“A”，2对应“B”，依此类推）代表可能正在想他们的人的名字的第一个字母。
- en: Write a Python program that prompts the user to enter the number said after
    the sneeze. It must then sum up the digits of the number until a number between
    1 and 26 is obtained, and display the corresponding letter in the English alphabet.
  id: totrans-1007
  prefs: []
  type: TYPE_NORMAL
  zh: 编写一个Python程序，提示用户输入打喷嚏后所说的数字。然后必须将这个数字的各位数相加，直到得到一个介于1到26之间的数字，并显示对应的英文字母。
- en: '12)Write a Python program that displays all possible integer values of x and
    y within the range −100 to +100 that validate the following formula:'
  id: totrans-1008
  prefs: []
  type: TYPE_NORMAL
  zh: 12)编写一个Python程序，显示所有在范围-100到+100之间满足以下公式的整数x和y的值：
- en: 5x + 3y² = 0
  id: totrans-1009
  prefs: []
  type: TYPE_NORMAL
  zh: 5x + 3y² = 0
- en: '13)Write a Python program that displays all possible integer values of x, y,
    and z within the range −10 to +10 that validate the following formula:'
  id: totrans-1010
  prefs: []
  type: TYPE_NORMAL
  zh: 13)编写一个Python程序，显示所有在范围-10到+10之间满足以下公式的整数x、y和z的值：
- en: .![Image](img/chapter29-18.png)
  id: totrans-1011
  prefs: []
  type: TYPE_NORMAL
  zh: '![图像](img/chapter29-18.png)'
- en: 14)Write a Python program that lets the user enter three positive integers and
    then finds their product using the Russian multiplication algorithm.
  id: totrans-1012
  prefs: []
  type: TYPE_NORMAL
  zh: 14)编写一个Python程序，让用户输入三个正整数，然后使用俄罗斯乘法算法找到它们的乘积。
- en: 15)Rewrite the Python program of [Exercise 29.5-4](#toc_22) to validate the
    data input using a loop control structure. If the user enters a non-positive integer,
    an error message must be displayed.
  id: totrans-1013
  prefs: []
  type: TYPE_NORMAL
  zh: 15)将[练习29.5-4](#toc_22)的Python程序重写，使用循环控制结构验证数据输入。如果用户输入非正整数，必须显示错误信息。
- en: 16)Rewrite the Python program of [Exercise 29.5-5](#toc_23) to validate the
    data input using a loop control structure. If the user enters an integer less
    than or equal to 1, an error message must be displayed.
  id: totrans-1014
  prefs: []
  type: TYPE_NORMAL
  zh: 16)将[练习29.5-5](#toc_23)的Python程序重写，使用循环控制结构验证数据输入。如果用户输入小于或等于1的整数，必须显示错误信息。
- en: 17)Write a Python program that prompts the user to enter two positive integers
    into variables start and finish. The program must then find and display all Pythagorean
    triples (x, y, z) where x, y, and z are integers between start and finish such
    that x² + y² = z².
  id: totrans-1015
  prefs: []
  type: TYPE_NORMAL
  zh: 17)编写一个Python程序，提示用户将两个正整数输入到变量start和finish中。然后程序必须找到并显示所有满足x² + y² = z²的毕达哥拉斯三元组（x,
    y, z），其中x、y和z是介于start和finish之间的整数。
- en: 'Hint: To make your program operate correctly, independent of which user-provided
    integer is the lowest, you can swap their values (if necessary) so that they are
    always in the proper order.'
  id: totrans-1016
  prefs: []
  type: TYPE_NORMAL
  zh: 提示：为了使程序正确运行，独立于用户提供的哪个整数是最低的，你可以（如果需要）交换它们的值，使它们始终处于正确的顺序。
- en: 18)Write a Python program that prompts the user to enter two positive integers
    and then displays all prime integers between them. Using a loop control structure,
    the program must also validate data input and display an error message when the
    user enters a value less than +2.
  id: totrans-1017
  prefs: []
  type: TYPE_NORMAL
  zh: 18)编写一个Python程序，提示用户输入两个正整数，然后显示它们之间所有的质整数。使用循环控制结构，程序还必须验证数据输入，并在用户输入小于+2的值时显示错误信息。
- en: 'Hint: To make your program operate correctly, independent of which user-provided
    integer is the lowest, you can swap their values (if necessary) so that they are
    always in the proper order.'
  id: totrans-1018
  prefs: []
  type: TYPE_NORMAL
  zh: 提示：为了使程序正确运行，独立于用户提供的哪个整数是最低的，你可以（如果需要）交换它们的值，使它们始终处于正确的顺序。
- en: 19)A perfect number is a positive integer that is equal to the sum of its positive
    divisors, excluding the number itself. For example, the divisors of 6 are 1, 2,
    and 3 (excluding 6 itself), and 1 + 2 + 3 = 6, making 6 a perfect number. Write
    a Python program that prompts the user to enter a positive integer and displays
    a message indicating whether or not the number is perfect. Using a loop control
    structure, the program must also validate data input and display an error message
    when the user enters a non-positive integer.
  id: totrans-1019
  prefs: []
  type: TYPE_NORMAL
  zh: 19)完美数是一个正整数，它等于其所有正除数之和（不包括该数本身）。例如，6的除数是1、2和3（不包括6本身），且1 + 2 + 3 = 6，使6成为一个完美数。编写一个Python程序，提示用户输入一个正整数，并显示一条消息，指出该数是否为完美数。使用循环控制结构，程序还必须验证数据输入，并在用户输入非正整数时显示错误信息。
- en: 20)Write a Python program that prompts the user to enter two positive integers
    and then displays all perfect numbers between them. Using a loop control structure,
    the program must also validate data input and display an error message when the
    user enters a non-positive integer.
  id: totrans-1020
  prefs: []
  type: TYPE_NORMAL
  zh: 20)编写一个Python程序，提示用户输入两个正整数，然后显示它们之间的所有完全数。使用循环控制结构，程序还必须验证数据输入，并在用户输入非正整数时显示错误信息。
- en: 'Hint: To make your program operate correctly, independent of which user-provided
    integer is the lowest, you can swap their values (if necessary) so that they are
    always in the proper order.'
  id: totrans-1021
  prefs: []
  type: TYPE_NORMAL
  zh: 提示：为了使你的程序正确运行，独立于用户提供的最低整数是哪个，你可以（如果需要）交换它们的值，使它们始终处于正确的顺序。
- en: 21)Write a Python program that prompts the user to enter two positive four-digit
    integers and then displays all integers between them that are palindromes. Using
    a loop control structure, the program must also validate data input and display
    an error message when the user enters any numbers other than four-digit ones.
  id: totrans-1022
  prefs: []
  type: TYPE_NORMAL
  zh: 21)编写一个Python程序，提示用户输入两个正四位数整数，然后显示它们之间所有是回文的整数。使用循环控制结构，程序还必须验证数据输入，并在用户输入任何非四位数时显示错误信息。
- en: 'Hint: To make your Python program operate correctly, independent of which user-provided
    integer is the lowest, you can swap their values (if necessary) so that they are
    always in the proper order.'
  id: totrans-1023
  prefs: []
  type: TYPE_NORMAL
  zh: 提示：为了使你的Python程序正确运行，独立于用户提供的最低整数是哪个，你可以（如果需要）交换它们的值，使它们始终处于正确的顺序。
- en: 22)Write a Python program that displays all possible RAM sizes between 1 byte
    and 1GByte, such as 1, 2, 4, 8, 16, 32, 64, 128, and so on.
  id: totrans-1024
  prefs: []
  type: TYPE_NORMAL
  zh: 22)编写一个Python程序，显示从1字节到1GByte之间所有可能的RAM大小，例如1, 2, 4, 8, 16, 32, 64, 128，等等。
- en: 'Hint: 1GByte equals 2^(30) bytes, or 1073741824 bytes'
  id: totrans-1025
  prefs: []
  type: TYPE_NORMAL
  zh: 提示：1GByte等于2^(30)字节，或1073741824字节
- en: '23)Write a Python program that displays the following sequence of numbers:'
  id: totrans-1026
  prefs: []
  type: TYPE_NORMAL
  zh: 23)编写一个Python程序，显示以下数字序列：
- en: 1, 11, 23, 37, 53, 71, 91, 113, 137, … 401
  id: totrans-1027
  prefs: []
  type: TYPE_NORMAL
  zh: 1, 11, 23, 37, 53, 71, 91, 113, 137, … 401
- en: '24)Write a Python program that displays the following sequence of numbers:'
  id: totrans-1028
  prefs: []
  type: TYPE_NORMAL
  zh: 24)编写一个Python程序，显示以下数字序列：
- en: −1, 1, −2, 2, −3, 3, −4, 4, … −100, 100
  id: totrans-1029
  prefs: []
  type: TYPE_NORMAL
  zh: −1, 1, −2, 2, −3, 3, −4, 4, … −100, 100
- en: '25)Write a Python program that displays the following sequence of numbers:'
  id: totrans-1030
  prefs: []
  type: TYPE_NORMAL
  zh: 25)编写一个Python程序，显示以下数字序列：
- en: 1, 11, 111, 1111, 11111, … 11111111
  id: totrans-1031
  prefs: []
  type: TYPE_NORMAL
  zh: 1, 11, 111, 1111, 11111, … 11111111
- en: '26)The Fibonacci^([[21]](footnotes.html#Endnote_21)) sequence is a series of
    numbers in the following sequence:'
  id: totrans-1032
  prefs: []
  type: TYPE_NORMAL
  zh: 26)斐波那契数列是一个以下序列的数字序列：
- en: 0, 1, 1, 2, 3, 5, 8, 13, 21, 34, 55, …
  id: totrans-1033
  prefs: []
  type: TYPE_NORMAL
  zh: 0, 1, 1, 2, 3, 5, 8, 13, 21, 34, 55, …
- en: By definition, the first two terms are 0 and 1 and each subsequent term is the
    sum of the previous two.
  id: totrans-1034
  prefs: []
  type: TYPE_NORMAL
  zh: 根据定义，前两项是0和1，每一项都是前两项的和。
- en: Write a Python program that lets the user enter a positive integer and then
    displays as many Fibonacci terms as that user-provided integer.
  id: totrans-1035
  prefs: []
  type: TYPE_NORMAL
  zh: 编写一个Python程序，允许用户输入一个正整数，然后显示与该用户提供的整数一样多的斐波那契数列项。
- en: 27)Write a Python program that lets the user enter a positive integer and then
    displays all Fibonacci terms that are less than that user-provided integer.
  id: totrans-1036
  prefs: []
  type: TYPE_NORMAL
  zh: 27)编写一个Python程序，允许用户输入一个正整数，然后显示所有小于该用户提供的整数的斐波那契数列项。
- en: '28)Write a Python program that prompts the user to enter a positive integer
    N and then finds and displays the value of y in the following formula:'
  id: totrans-1037
  prefs: []
  type: TYPE_NORMAL
  zh: 28)编写一个Python程序，提示用户输入一个正整数N，然后根据以下公式找到并显示y的值：
- en: .![Image](img/chapter29-19.png)
  id: totrans-1038
  prefs: []
  type: TYPE_NORMAL
  zh: .![Image](img/chapter29-19.png)
- en: Moreover, using a loop control structure, the program must validate data input
    and display an error message when the user enters a value less than 1.
  id: totrans-1039
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，使用循环控制结构，当用户输入小于1的值时，程序必须验证数据输入并显示错误信息。
- en: 29)Write a Python program that prompts the user to enter a positive integer
    N and then finds and displays the value of y in the following formula
  id: totrans-1040
  prefs: []
  type: TYPE_NORMAL
  zh: 29)编写一个Python程序，提示用户输入一个正整数N，然后根据以下公式找到并显示y的值
- en: .![Image](img/chapter29-20.png)
  id: totrans-1041
  prefs: []
  type: TYPE_NORMAL
  zh: .![Image](img/chapter29-20.png)
- en: Moreover, using a loop control structure, the program must validate data input
    and display an error message when the user enters a non-positive value.
  id: totrans-1042
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，使用循环控制结构，当用户输入非正值时，程序必须验证数据输入并显示错误信息。
- en: '30)Write a Python program that prompts the user to enter an integer N greater
    than 2 and then finds and displays the value of y in the following formula:'
  id: totrans-1043
  prefs: []
  type: TYPE_NORMAL
  zh: 30)编写一个Python程序，提示用户输入一个大于2的整数N，然后根据以下公式找到并显示y的值：
- en: .![Image](img/chapter29-21.png)
  id: totrans-1044
  prefs: []
  type: TYPE_NORMAL
  zh: .![Image](img/chapter29-21.png)
- en: Moreover, using a loop control structure, the program must validate data input
    and display an error message when the user enters a value that is less than or
    equal to 2.
  id: totrans-1045
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，使用循环控制结构，程序必须验证数据输入，并在用户输入小于或等于2的值时显示错误信息。
- en: 'Hint: Note that beyond the term 1 / 3 the subsequent denominators increment
    by 2.'
  id: totrans-1046
  prefs: []
  type: TYPE_NORMAL
  zh: 提示：注意，在1/3的项之后，后续的分母递增2。
- en: '31)Write a Python program that prompts the user to enter a positive integer
    N and then finds and displays the value of y in the following formula:'
  id: totrans-1047
  prefs: []
  type: TYPE_NORMAL
  zh: 31)编写一个Python程序，提示用户输入一个正整数N，然后根据以下公式找到并显示y的值：
- en: .![Image](img/chapter29-22.png)
  id: totrans-1048
  prefs: []
  type: TYPE_NORMAL
  zh: .![Image](img/chapter29-22.png)
- en: Moreover, using a loop control structure, the program must validate data input
    and display an error message when the user enters a non-positive value.
  id: totrans-1049
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，使用循环控制结构，程序必须验证数据输入，并在用户输入非正值时显示错误信息。
- en: 32)In mathematics, the factorial of a non-negative integer N is the product
    of all positive integers less than or equal to N, and it is denoted by N! The
    factorial of 0 is, by definition, equal to 1\. In mathematics, you can write
  id: totrans-1050
  prefs: []
  type: TYPE_NORMAL
  zh: 32)在数学中，非负整数N的阶乘是所有小于或等于N的正整数的乘积，用N!表示。0的阶乘定义为等于1。在数学中，你可以写成
- en: .![Image](img/chapter29-23.png)
  id: totrans-1051
  prefs: []
  type: TYPE_NORMAL
  zh: .![Image](img/chapter29-23.png)
- en: For example, the factorial of 5 is written as 5! and is equal to 1 × 2 × 3 ×
    4 × 5 = 120.
  id: totrans-1052
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，5的阶乘写作5!，等于1 × 2 × 3 × 4 × 5 = 120。
- en: Write a Python program that prompts the user to enter a non-negative integer
    N and then calculates its factorial.
  id: totrans-1053
  prefs: []
  type: TYPE_NORMAL
  zh: 编写一个Python程序，提示用户输入一个非负整数N，然后计算它的阶乘。
- en: 33)Write a Python program that lets the user enter a value for x and then calculates
    and displays the exponential function e^x using the Taylor^([[22]](footnotes.html#Endnote_22))
    series, shown next, with an accuracy of 0.00001.
  id: totrans-1054
  prefs: []
  type: TYPE_NORMAL
  zh: 33)编写一个Python程序，允许用户输入一个x的值，然后使用以下所示的泰勒级数（Taylor^([[22]](footnotes.html#Endnote_22))）计算并显示指数函数e^x，精度为0.00001。
- en: .![Image](img/chapter29-24.png)
  id: totrans-1055
  prefs: []
  type: TYPE_NORMAL
  zh: .![Image](img/chapter29-24.png)
- en: 'Hint: Keep in mind that ![Image](img/chapter29-25.png).'
  id: totrans-1056
  prefs: []
  type: TYPE_NORMAL
  zh: 提示：记住![Image](img/chapter29-25.png)。
- en: 34)Write a Python program that lets the user enter a value for x and then calculates
    and displays the sine of x using the Taylor series, shown next, with an accuracy
    of 0.00001.
  id: totrans-1057
  prefs: []
  type: TYPE_NORMAL
  zh: 34)编写一个Python程序，允许用户输入一个x的值，然后使用以下所示的泰勒级数计算并显示x的正弦值，精度为0.00001。
- en: .![Image](img/chapter29-26.png)
  id: totrans-1058
  prefs: []
  type: TYPE_NORMAL
  zh: .![Image](img/chapter29-26.png)
- en: 'Hint: Keep in mind that x is in radians and ![Image](img/chapter29-27.png).'
  id: totrans-1059
  prefs: []
  type: TYPE_NORMAL
  zh: 提示：记住x是以弧度为单位的，并且![Image](img/chapter29-27.png)。
- en: 35)Write a Python program that lets the user enter a value for x and then calculates
    and displays the cosine of x using the Taylor series, shown next, with an accuracy
    of 0.00001.
  id: totrans-1060
  prefs: []
  type: TYPE_NORMAL
  zh: 35)编写一个Python程序，允许用户输入一个x的值，然后使用以下所示的泰勒级数计算并显示x的余弦值，精度为0.00001。
- en: .![Image](img/chapter29-28.png)
  id: totrans-1061
  prefs: []
  type: TYPE_NORMAL
  zh: .![Image](img/chapter29-28.png)
- en: 'Hint: Keep in mind that x is in radians and ![Image](img/chapter29-25.png).'
  id: totrans-1062
  prefs: []
  type: TYPE_NORMAL
  zh: 提示：记住x是以弧度为单位的，并且![Image](img/chapter29-25.png)。
- en: 36)Suppose that the letter A corresponds to the number 1, the letter B corresponds
    to the number 2, and so on. Write a Python program that prompts the user to enter
    two integers and then displays all alphabet letters that exist between them. For
    example, if the user enters 3 and 6, the program must display C, D, E, F. Using
    a loop control structure, the program must also validate data input and display
    a different error message for each type of input error when the user enters any
    negative, or any value greater than 26.
  id: totrans-1063
  prefs: []
  type: TYPE_NORMAL
  zh: 36)假设字母A对应数字1，字母B对应数字2，依此类推。编写一个Python程序，提示用户输入两个整数，然后显示它们之间存在的所有字母。例如，如果用户输入3和6，程序必须显示C、D、E、F。使用循环控制结构，程序还必须验证数据输入，并在用户输入任何负数或任何大于26的值时显示不同的错误信息。
- en: 'Hint: To make your Python program operate correctly, independent of which user-provided
    integer is the lowest, you can swap their values (if necessary) so that they are
    always in the proper order.'
  id: totrans-1064
  prefs: []
  type: TYPE_NORMAL
  zh: 提示：为了使你的Python程序正确运行，独立于用户提供的整数哪个是最小的，你可以（如果需要）交换它们的值，使它们始终处于正确的顺序。
- en: 37)Write a Python program that randomly selects an integer between 1 and 100
    and assigns it to a variable. The program must then prompt the user to guess the
    number. If the user's guess is smaller than the secret number, the message “Your
    guess is smaller than my secret number. Try again!” must be displayed. If the
    user's guess is greater than the secret number, the message “Your guess is bigger
    than my secret number. Try again!” must be displayed. This process must repeat
    until the user correctly guesses the secret number. Once the user guesses correctly,
    the message “You found it!” must be displayed, along with the total number of
    attempts made by the user.
  id: totrans-1065
  prefs: []
  type: TYPE_NORMAL
  zh: 37) 编写一个Python程序，随机选择一个介于1到100之间的整数并将其分配给一个变量。然后程序必须提示用户猜测这个数字。如果用户的猜测小于秘密数字，必须显示消息“你的猜测比我秘密数字小。再试一次！”如果用户的猜测大于秘密数字，必须显示消息“你的猜测比我秘密数字大。再试一次！”这个过程必须重复，直到用户正确猜出秘密数字。一旦用户猜对了，必须显示消息“你找到了！”以及用户所进行的总尝试次数。
- en: 38)Expand the previous exercise/game by making it operate for two players. The
    player that wins is the one that finds the random secret number in fewer attempts.
  id: totrans-1066
  prefs: []
  type: TYPE_NORMAL
  zh: 38) 通过使游戏适用于两位玩家来扩展之前的练习/游戏。获胜者是找到随机秘密数字尝试次数更少的玩家。
- en: '39)The size of a TV screen always refers to its diagonal measurement. For example,
    a 40-inch TV screen is 40 inches diagonally, from one corner on top to the other
    corner on bottom. The old TV screens had a width-to-height aspect ratio of 4:3,
    which means that for every 3 inches in TV screen height, there were 4 inches in
    TV screen width. Today, most TV screens have a width-to-height aspect ratio of
    16:9, which means that for every 9 inches in TV screen height there are 16 inches
    in TV screen width. Using these aspect ratios and the Pythagorean Theorem, you
    can easily determine that:'
  id: totrans-1067
  prefs: []
  type: TYPE_NORMAL
  zh: 39) 电视屏幕的大小始终指其对角线测量值。例如，一个40英寸的电视屏幕对角线长度为40英寸，从顶部的一个角到底部的另一个角。旧电视屏幕的宽高比为4:3，这意味着对于电视屏幕高度中的每3英寸，电视屏幕宽度中有4英寸。如今，大多数电视屏幕的宽高比为16:9，这意味着对于电视屏幕高度中的每9英寸，电视屏幕宽度中有16英寸。使用这些宽高比和勾股定理，你可以轻松地确定：
- en: ►for all 4:3 TV screens
  id: totrans-1068
  prefs: []
  type: TYPE_NORMAL
  zh: ►对于所有4:3电视屏幕
- en: Width = Diagonal × 0.8
  id: totrans-1069
  prefs: []
  type: TYPE_NORMAL
  zh: 宽度 = 对角线 × 0.8
- en: Height = Diagonal × 0.6
  id: totrans-1070
  prefs: []
  type: TYPE_NORMAL
  zh: 高度 = 对角线 × 0.6
- en: ►for all 16:9 TV screens
  id: totrans-1071
  prefs: []
  type: TYPE_NORMAL
  zh: ►对于所有16:9电视屏幕
- en: Width = Diagonal × 0.87
  id: totrans-1072
  prefs: []
  type: TYPE_NORMAL
  zh: 宽度 = 对角线 × 0.87
- en: Height = Diagonal × 0.49
  id: totrans-1073
  prefs: []
  type: TYPE_NORMAL
  zh: 高度 = 对角线 × 0.49
- en: 'Write a Python program that displays the following menu:'
  id: totrans-1074
  prefs: []
  type: TYPE_NORMAL
  zh: 编写一个Python程序，显示以下菜单：
- en: 1)4/3 TV Screen
  id: totrans-1075
  prefs: []
  type: TYPE_NORMAL
  zh: 1) 4/3电视屏幕
- en: 2)16/9 TV Screen
  id: totrans-1076
  prefs: []
  type: TYPE_NORMAL
  zh: 2) 16/9电视屏幕
- en: 3)Exit
  id: totrans-1077
  prefs: []
  type: TYPE_NORMAL
  zh: 3) 退出
- en: and prompts the user to enter a choice (of 1, 2, or 3) as well as the diagonal
    screen size in inches. Then, the Python program must display the width and the
    height of the TV screen. This process must continue repeatedly, until the user
    selects choice 3 (Exit) from the menu.
  id: totrans-1078
  prefs: []
  type: TYPE_NORMAL
  zh: 并提示用户输入一个选择（1、2或3）以及英寸的屏幕对角线尺寸。然后，Python程序必须显示电视屏幕的宽度和高度。这个过程必须反复进行，直到用户从菜单中选择3（退出）。
- en: '40)Write a Python program that prompts a teacher to enter the total number
    of students, their grades, and their gender (M for Male, F for Female, O for Other),
    and then calculates and displays all of the following:'
  id: totrans-1079
  prefs: []
  type: TYPE_NORMAL
  zh: 40) 编写一个Python程序，提示教师输入学生总数、他们的成绩和他们的性别（M代表男性，F代表女性，O代表其他），然后计算并显示以下内容：
- en: a)the average value of those who got an “A” (90 ‐ 100)
  id: totrans-1080
  prefs: []
  type: TYPE_NORMAL
  zh: a) 获得“A”（90-100分）的人的平均分
- en: b)the average value of those who got a “B” (80 ‐ 89)
  id: totrans-1081
  prefs: []
  type: TYPE_NORMAL
  zh: b) 获得“B”（80-89分）的人的平均分
- en: c)the average value of boys who got an “A” (90 ‐ 100)
  id: totrans-1082
  prefs: []
  type: TYPE_NORMAL
  zh: c) 获得“A”（90-100分）的男生的平均分
- en: d)the total number of girls that got less than “B”
  id: totrans-1083
  prefs: []
  type: TYPE_NORMAL
  zh: d) 获得“B”以下成绩的女生的总数
- en: e)the highest and lowest grade
  id: totrans-1084
  prefs: []
  type: TYPE_NORMAL
  zh: e) 最高和最低成绩
- en: f)the average grade of the whole class
  id: totrans-1085
  prefs: []
  type: TYPE_NORMAL
  zh: f) 全班平均成绩
- en: 'Add all necessary checks to make the program satisfy the property of definiteness.
    Moreover, using a loop control structure, the program must validate data input
    and display an error message when the teacher enters any of the following:'
  id: totrans-1086
  prefs: []
  type: TYPE_NORMAL
  zh: 添加所有必要的检查，以确保程序满足确定性属性。此外，使用循环控制结构，程序必须验证数据输入，并在教师输入以下任何内容时显示错误消息：
- en: ►non-positive values for total number of students
  id: totrans-1087
  prefs: []
  type: TYPE_NORMAL
  zh: ►学生总数为非正数
- en: ►negatives, or values greater than 100 for student grades
  id: totrans-1088
  prefs: []
  type: TYPE_NORMAL
  zh: ►学生成绩为负数或大于100的值
- en: ►values other than M, F, or O for gender
  id: totrans-1089
  prefs: []
  type: TYPE_NORMAL
  zh: ►性别为除M、F或O之外的值
- en: 41)Write a Python program that calculates and displays the discount that a customer
    receives based on the amount of their order, according to the following table.
  id: totrans-1090
  prefs: []
  type: TYPE_NORMAL
  zh: 41) 编写一个Python程序，根据以下表格计算并显示客户根据订单金额获得的折扣。
- en: '| Amount | Discount |'
  id: totrans-1091
  prefs: []
  type: TYPE_TB
  zh: '| 金额 | 折扣 |'
- en: '| $0 < amount < $20 | 0% |'
  id: totrans-1092
  prefs: []
  type: TYPE_TB
  zh: '| 0 < 金额 < 20 美元 | 0% |'
- en: '| $20 ≤ amount < $50 | 3% |'
  id: totrans-1093
  prefs: []
  type: TYPE_TB
  zh: '| 20 美元 ≤ 金额 < 50 美元 | 3% |'
- en: '| $50 ≤ amount < $100 | 5% |'
  id: totrans-1094
  prefs: []
  type: TYPE_TB
  zh: '| 50 美元 ≤ 金额 < 100 美元 | 5% |'
- en: '| $100 ≤ amount | 10% |'
  id: totrans-1095
  prefs: []
  type: TYPE_TB
  zh: '| 100 美元 ≤ 金额 | 10% |'
- en: At the end of each discount calculation, the program must ask the user if they
    wish to calculate the discount of another amount. If the answer is “yes”, the
    program must repeat; it must end otherwise. Make your program accept the answer
    in all possible forms such as “yes”, “YES”, “Yes”, or even “YeS”.
  id: totrans-1096
  prefs: []
  type: TYPE_NORMAL
  zh: 在每次折扣计算结束后，程序必须询问用户是否希望计算另一个金额的折扣。如果答案是“是”，程序必须重复；否则必须结束。程序应接受所有可能的形式的答案，如“是”、“YES”、“Yes”或甚至“YeS”。
- en: Moreover, using a loop control structure the program must validate data input
    and display an error message when the user enters any non-positive value for amount.
  id: totrans-1097
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，使用循环控制结构，程序必须验证数据输入，并在用户输入任何非正金额值时显示错误信息。
- en: 42)The LAV Electricity Company charges subscribers for their electricity consumption
    according to the following table (monthly rates for domestic accounts).
  id: totrans-1098
  prefs: []
  type: TYPE_NORMAL
  zh: 42) LAV 电力公司根据以下表格（家庭账户的月度费率）向用户收取电费。
- en: '| Kilowatt‑hours (kWh) | USD per kWh |'
  id: totrans-1099
  prefs: []
  type: TYPE_TB
  zh: '| 千瓦时 (kWh) | 每千瓦时 (kWh) 美元 |'
- en: '| 0 ≤ kWh ≤ 400 | $0.11 |'
  id: totrans-1100
  prefs: []
  type: TYPE_TB
  zh: '| 0 ≤ 千瓦时 (kWh) ≤ 400 | 每千瓦时 (kWh) 0.11 美元 |'
- en: '| 401 ≤ kWh ≤ 1500 | $0.22 |'
  id: totrans-1101
  prefs: []
  type: TYPE_TB
  zh: '| 401 ≤ 千瓦时 (kWh) ≤ 1500 | 每千瓦时 (kWh) 0.22 美元 |'
- en: '| 1501 ≤ kWh ≤ 3500 | $0.25 |'
  id: totrans-1102
  prefs: []
  type: TYPE_TB
  zh: '| 1501 ≤ 千瓦时 (kWh) ≤ 3500 | 每千瓦时 (kWh) 0.25 美元 |'
- en: '| 3501 ≤ kWh | $0.50 |'
  id: totrans-1103
  prefs: []
  type: TYPE_TB
  zh: '| 3501 ≤ 千瓦时 (kWh) | 每千瓦时 (kWh) 0.50 美元 |'
- en: Write a Python program that prompts the user to enter the total number of kWh
    consumed by a subscriber and then calculates and displays the total amount to
    pay. This process must repeat until the value −1 for kWh is entered.
  id: totrans-1104
  prefs: []
  type: TYPE_NORMAL
  zh: 编写一个 Python 程序，提示用户输入用户消耗的总千瓦时 (kWh)，然后计算并显示应付总额。此过程必须重复进行，直到输入的千瓦时值为 -1。
- en: Moreover, using a loop control structure, the program must validate data input
    and display an error message when the user enters any negative value for kWh.
    An exception for the value −1 must be made.
  id: totrans-1105
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，使用循环控制结构，程序必须验证数据输入，并在用户输入任何负千瓦时 (kWh) 值时显示错误信息。对于值 -1 必须做出例外。
- en: Transmission services and distribution charges, as well as federal, state, and
    local taxes, add a total of 25% to each bill.
  id: totrans-1106
  prefs: []
  type: TYPE_NORMAL
  zh: '传输服务费和配电费，以及联邦、州和地方税，总计为每张账单增加 25%。 '
- en: Please note that the rates are progressive.
  id: totrans-1107
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，费率是累进制的。
