- en: Chapter 29
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: More with Loop Control Structures
  prefs: []
  type: TYPE_NORMAL
- en: 29.1 Simple Exercises with Loop Control Structures
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Exercise 29.1-1 Counting the Numbers According to Which is Greater
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Write a Python program that prompts the user to enter 10 pairs of numbers and
    then counts and displays the number of times that the first user-provided number
    was greater than the second one and the number of times that the second one was
    greater than the first one.
  prefs: []
  type: TYPE_NORMAL
- en: Solution
  prefs: []
  type: TYPE_NORMAL
- en: The Python program is as follows. It uses variable countA to count the number
    of times that the first user-provided number was greater than the second one and
    variable countB to count the number of times that the second one was greater than
    the first one.
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/my_exercise_header.png) file_29.1-1'
  prefs: []
  type: TYPE_NORMAL
- en: countA = 0
  prefs: []
  type: TYPE_NORMAL
- en: countB = 0
  prefs: []
  type: TYPE_NORMAL
- en: 'for i in range(10):'
  prefs: []
  type: TYPE_NORMAL
- en: 'a = int(input("Enter number A: "))'
  prefs: []
  type: TYPE_NORMAL
- en: 'b = int(input("Enter number B: "))'
  prefs: []
  type: TYPE_NORMAL
- en: 'if a > b:'
  prefs: []
  type: TYPE_NORMAL
- en: countA += 1
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: 'elif b > a:'
  prefs: []
  type: TYPE_NORMAL
- en: countB += 1
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: print(countA, countB)
  prefs: []
  type: TYPE_NORMAL
- en: A reasonable question that someone may ask is “Why is a multiple-decision control
    structure being used? Why not use a dual-alternative decision structure instead?”
  prefs: []
  type: TYPE_NORMAL
- en: Suppose, indeed, that a dual-alternative decision structure, such as the following,
    is used.
  prefs: []
  type: TYPE_NORMAL
- en: 'if a > b:'
  prefs: []
  type: TYPE_NORMAL
- en: countA += 1
  prefs: []
  type: TYPE_NORMAL
- en: 'else:'
  prefs: []
  type: TYPE_NORMAL
- en: countB += 1
  prefs: []
  type: TYPE_NORMAL
- en: In this decision control structure, the variable countB would increment when
    variable b is greater than variable a (this is desirable) but also when variable
    b is equal to variable a (this is undesirable). Using a multiple-decision control
    structure instead would ensure that variable countB increments only when variable
    b is greater than (and not when it is equal to) variable a.
  prefs: []
  type: TYPE_NORMAL
- en: Exercise 29.1-2 Counting the Numbers According to Their Digits
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Write a Python program that prompts the user to enter 20 integers and then counts
    and displays the total number of one-digit, two-digit, and three-digit integers.
    Assume that the user enters values between 1 and 999.
  prefs: []
  type: TYPE_NORMAL
- en: Solution
  prefs: []
  type: TYPE_NORMAL
- en: Using knowledge from [Exercise 18.1-3](chapter18.html#toc_4), the Python program
    is as follows.
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/my_exercise_header.png) file_29.1-2'
  prefs: []
  type: TYPE_NORMAL
- en: count1 = count2 = count3 = 0
  prefs: []
  type: TYPE_NORMAL
- en: 'for i in range(20):'
  prefs: []
  type: TYPE_NORMAL
- en: 'a = int(input("Enter a number: "))'
  prefs: []
  type: TYPE_NORMAL
- en: 'if a <= 9:'
  prefs: []
  type: TYPE_NORMAL
- en: count1 += 1
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: 'elif a <= 99:'
  prefs: []
  type: TYPE_NORMAL
- en: count2 += 1
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: 'else:'
  prefs: []
  type: TYPE_NORMAL
- en: count3 += 1
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: print(count1, count2, count3)
  prefs: []
  type: TYPE_NORMAL
- en: Exercise 29.1-3 How Many Numbers Fit in a Sum
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Write a Python program that lets the user enter numeric values repeatedly until
    the sum of them exceeds 1000\. At the end, the program must display the total
    quantity of numbers entered.
  prefs: []
  type: TYPE_NORMAL
- en: Solution
  prefs: []
  type: TYPE_NORMAL
- en: In this case, since the exact number of iterations is unknown, a definite loop
    cannot be used; an indefinite loop is required. Let's employ a pre-test loop to
    create that loop. However, to ensure the program is free of logic errors, it is
    crucial to adhere to the “Ultimate” rule discussed in [Section 28.3](chapter28.html#toc_3).
    According to this rule, the pre-test loop structure should be as follows, given
    in general form.
  prefs: []
  type: TYPE_NORMAL
- en: Initialize total
  prefs: []
  type: TYPE_NORMAL
- en: 'while total <= 1000 :'
  prefs: []
  type: TYPE_NORMAL
- en: A statement or block of statements
  prefs: []
  type: TYPE_NORMAL
- en: Update/alter total
  prefs: []
  type: TYPE_NORMAL
- en: Since loop's Boolean expression depends on variable total, this is the variable
    that must be initialized before the loop starts and also updated (altered) within
    the loop. And more specifically, the statement that updates/alters variable total
    must be the last statement of the loop. Following this, the Python program becomes
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/my_exercise_header.png) file_29.1-3'
  prefs: []
  type: TYPE_NORMAL
- en: count = 0
  prefs: []
  type: TYPE_NORMAL
- en: 'total = 0   #Initialization of total'
  prefs: []
  type: TYPE_NORMAL
- en: 'while total <= 1000:   #Boolean expression dependent on total'
  prefs: []
  type: TYPE_NORMAL
- en: x = float(input())
  prefs: []
  type: TYPE_NORMAL
- en: count += 1
  prefs: []
  type: TYPE_NORMAL
- en: 'total += x   #Update/alteration of total'
  prefs: []
  type: TYPE_NORMAL
- en: print(count)
  prefs: []
  type: TYPE_NORMAL
- en: Exercise 29.1-4 Finding the Total Number of Positive Integers
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Write a Python program that prompts the user to enter integer values repeatedly
    until a real one is entered. At the end, the program must display the total number
    of positive integers entered.
  prefs: []
  type: TYPE_NORMAL
- en: Solution
  prefs: []
  type: TYPE_NORMAL
- en: Once again, you don't know the exact number of iterations, so you cannot use
    a for-loop.
  prefs: []
  type: TYPE_NORMAL
- en: According to the “Ultimate” rule, the pre-test loop structure should be as follows,
    given in general form.
  prefs: []
  type: TYPE_NORMAL
- en: 'x = float(input("Enter a number: "))   #Initialization of x'
  prefs: []
  type: TYPE_NORMAL
- en: 'while int(x) == x:   #Boolean expression dependent on x'
  prefs: []
  type: TYPE_NORMAL
- en: A statement or block of statements
  prefs: []
  type: TYPE_NORMAL
- en: 'x = float(input("Enter a number: "))   #Update/alteration of x'
  prefs: []
  type: TYPE_NORMAL
- en: The final Python program is as follows.
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/my_exercise_header.png) file_29.1-4'
  prefs: []
  type: TYPE_NORMAL
- en: count = 0
  prefs: []
  type: TYPE_NORMAL
- en: 'x = float(input("Enter a number: "))'
  prefs: []
  type: TYPE_NORMAL
- en: 'while int(x) == x:'
  prefs: []
  type: TYPE_NORMAL
- en: 'if x > 0:'
  prefs: []
  type: TYPE_NORMAL
- en: count += 1
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: 'x = float(input("Enter a number: "))'
  prefs: []
  type: TYPE_NORMAL
- en: print(count)
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/notice.jpg)Note that the program operates properly even when the first
    user-provided number is a real (a float); the pre-test loop structure ensures
    that the flow of execution will never enter the loop for any real numbers!'
  prefs: []
  type: TYPE_NORMAL
- en: Exercise 29.1-5 Iterating as Many Times as the User Wishes
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Write a Python program that prompts the user to enter two numbers and then calculates
    and displays the first number raised to the power of the second one. The program
    must iterate as many times as the user wishes. At the end of each calculation,
    the program must prompt the user if they wish to calculate again. If the answer
    is “yes” the program must repeat; it must end otherwise. Make your program accept
    the answer in all possible forms such as “yes”, “YES”, “Yes”, or even “YeS”.
  prefs: []
  type: TYPE_NORMAL
- en: Solution
  prefs: []
  type: TYPE_NORMAL
- en: According to the “Ultimate” rule, the pre-test loop structure should be as follows,
    given in general form.
  prefs: []
  type: TYPE_NORMAL
- en: answer = "yes"    #Initialization of answer
  prefs: []
  type: TYPE_NORMAL
- en: 'while answer.upper() != "YES":'
  prefs: []
  type: TYPE_NORMAL
- en: Prompt the user to enter two numbers and then calculate and display the first
    number raised to the power of the second one.
  prefs: []
  type: TYPE_NORMAL
- en: '#Update/alteration of answer'
  prefs: []
  type: TYPE_NORMAL
- en: answer = input("Would you like to repeat? ")
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/notice.jpg)The upper() method ensures that the program operates properly
    for any user-provided answer: “yes”, “YES”, “Yes”, or even “YeS” or “yEs”!'
  prefs: []
  type: TYPE_NORMAL
- en: However, instead of using the pre-test loop structure, let's employ the post-test
    loop structure this time. This is a better approach, as the initialization of
    the answer variable outside of the loop can be omitted. Unlike the pre-test loop
    structure, the flow of execution enters the loop in either way, and the initialization
    of the answer will be done inside the post-test loop, as shown in the code fragment
    (given in general form) that follows.
  prefs: []
  type: TYPE_NORMAL
- en: 'while True:'
  prefs: []
  type: TYPE_NORMAL
- en: Prompt the user to enter two numbers and then calculate and display the first
    number raised to the power of the second one.
  prefs: []
  type: TYPE_NORMAL
- en: '#Initialization and update/alteration of answer'
  prefs: []
  type: TYPE_NORMAL
- en: answer = input("Would you like to repeat? ")
  prefs: []
  type: TYPE_NORMAL
- en: 'if answer.upper() != "YES": break'
  prefs: []
  type: TYPE_NORMAL
- en: The solution to this exercise becomes
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/my_exercise_header.png) file_29.1-5'
  prefs: []
  type: TYPE_NORMAL
- en: 'while True:'
  prefs: []
  type: TYPE_NORMAL
- en: 'print("Enter two numbers: ")'
  prefs: []
  type: TYPE_NORMAL
- en: a = int(input())
  prefs: []
  type: TYPE_NORMAL
- en: b = int(input())
  prefs: []
  type: TYPE_NORMAL
- en: result = a ** b
  prefs: []
  type: TYPE_NORMAL
- en: print("The result is:", result)
  prefs: []
  type: TYPE_NORMAL
- en: answer = input("Would you like to repeat? ")
  prefs: []
  type: TYPE_NORMAL
- en: 'if answer.upper() != "YES": break'
  prefs: []
  type: TYPE_NORMAL
- en: Exercise 29.1-6 Finding the Sum of the Digits
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Write a Python program that lets the user enter an integer and then calculates
    the sum of its digits.
  prefs: []
  type: TYPE_NORMAL
- en: Solution
  prefs: []
  type: TYPE_NORMAL
- en: In [Exercise 13.1-2](chapter13.html#toc_3), you learned how to split the digits
    of an integer when its total number of digits was known. In this exercise however,
    the user is allowed to enter any value, no matter how small or large. Thus, the
    total number of the digits is an unknown quantity.
  prefs: []
  type: TYPE_NORMAL
- en: To solve this exercise, a loop control structure could be used. However, there
    are two approaches that you can use.
  prefs: []
  type: TYPE_NORMAL
- en: First approach
  prefs: []
  type: TYPE_NORMAL
- en: In this approach, the main idea is to isolate one digit at each iteration. However,
    the challenge lies in determining the total number of iterations required, as
    it hinges on the size of the user-provided integer. So, does this pose a roadblock?
    Certainly not!
  prefs: []
  type: TYPE_NORMAL
- en: Within the loop, the user-provided integer should undergo a continuous reduction
    with each iteration until it eventually reaches zero. That value of zero can act
    as a condition to stop the loop control structure from iterating. For instance,
    if the user-provided number is 4753, it should become 475 in the first iteration,
    47 in the second iteration, then 4, and ultimately 0\. Once it reaches 0, the
    iterations must stop.
  prefs: []
  type: TYPE_NORMAL
- en: Let's try to comprehend the proposed solution using the following flowchart.
    Some statements are written in general form.
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](img/chapter29-01.png)'
  prefs: []
  type: TYPE_IMG
- en: The statement
  prefs: []
  type: TYPE_NORMAL
- en: digit ← Isolate last digit of variable x.
  prefs: []
  type: TYPE_NORMAL
- en: can be written using the well-known MOD 10 operation as shown here.
  prefs: []
  type: TYPE_NORMAL
- en: digit ← x MOD 10
  prefs: []
  type: TYPE_NORMAL
- en: The whole concept, however, relies on the statement
  prefs: []
  type: TYPE_NORMAL
- en: x ← Keep all except last digit of variable x.
  prefs: []
  type: TYPE_NORMAL
- en: This is the statement that eventually zeros the value of variable x, and the
    flow of execution then exits the loop. To write this statement you can use a DIV
    10 operation as shown here.
  prefs: []
  type: TYPE_NORMAL
- en: x ← x DIV 10
  prefs: []
  type: TYPE_NORMAL
- en: Accordingly, the Python program becomes
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/my_exercise_header.png) file_29.1-6a'
  prefs: []
  type: TYPE_NORMAL
- en: x = int(input())
  prefs: []
  type: TYPE_NORMAL
- en: s = 0
  prefs: []
  type: TYPE_NORMAL
- en: 'while x != 0:'
  prefs: []
  type: TYPE_NORMAL
- en: 'digit = x % 10     #This is the x MOD 10 operation'
  prefs: []
  type: TYPE_NORMAL
- en: s = s + digit
  prefs: []
  type: TYPE_NORMAL
- en: x = x // 10        #This is the x DIV 10 operation
  prefs: []
  type: TYPE_NORMAL
- en: print(s)
  prefs: []
  type: TYPE_NORMAL
- en: Let's create a trace table for the input value 4753 to better understand what
    is really happening.
  prefs: []
  type: TYPE_NORMAL
- en: '| Step | Statement | Notes | x | digit | s |'
  prefs: []
  type: TYPE_TB
- en: '| 1 | x = int(input()) | User enters the value 4753 | 4753 | ? | ? |'
  prefs: []
  type: TYPE_TB
- en: '| 2 | s = 0 |   | 4753 | ? | 0 |'
  prefs: []
  type: TYPE_TB
- en: '| 3 | while x != 0: | This evaluates to True |'
  prefs: []
  type: TYPE_TB
- en: '| 4 | digit = x % 10 |   | 4753 | 3 | 0 |'
  prefs: []
  type: TYPE_TB
- en: '| 5 | s = s + digit |   | 4753 | 3 | 3 |'
  prefs: []
  type: TYPE_TB
- en: '| 6 | x = x // 10 |   | 475 | 3 | 3 |'
  prefs: []
  type: TYPE_TB
- en: '| 7 | while x != 0: | This evaluates to True |'
  prefs: []
  type: TYPE_TB
- en: '| 8 | digit = x % 10 |   | 475 | 5 | 3 |'
  prefs: []
  type: TYPE_TB
- en: '| 9 | s = s + digit |   | 475 | 5 | 8 |'
  prefs: []
  type: TYPE_TB
- en: '| 10 | x = x // 10 |   | 47 | 5 | 8 |'
  prefs: []
  type: TYPE_TB
- en: '| 11 | while x != 0: | This evaluates to True |'
  prefs: []
  type: TYPE_TB
- en: '| 12 | digit = x % 10 |   | 47 | 7 | 8 |'
  prefs: []
  type: TYPE_TB
- en: '| 13 | s = s + digit |   | 47 | 7 | 15 |'
  prefs: []
  type: TYPE_TB
- en: '| 14 | x = x // 10 |   | 4 | 7 | 15 |'
  prefs: []
  type: TYPE_TB
- en: '| 15 | while x != 0: | This evaluates to True |'
  prefs: []
  type: TYPE_TB
- en: '| 16 | digit = x % 10 |   | 4 | 4 | 15 |'
  prefs: []
  type: TYPE_TB
- en: '| 17 | s = s + digit |   | 4 | 4 | 19 |'
  prefs: []
  type: TYPE_TB
- en: '| 18 | x = x // 10 |   | 0 | 4 | 19 |'
  prefs: []
  type: TYPE_TB
- en: '| 19 | while x != 0: | This evaluates to False |'
  prefs: []
  type: TYPE_TB
- en: '| 20 | print(s) | It displays: 19 |'
  prefs: []
  type: TYPE_TB
- en: Second approach
  prefs: []
  type: TYPE_NORMAL
- en: In this approach, the main idea is to convert the user-provided integer to a
    string and then use a for-loop to iterate for all its characters (digits). In
    the for-loop, however, you need to convert each digit from type string back to
    type integer before it is accumulated in variable s. The Python program is as
    follows.
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/my_exercise_header.png) file_29.1-6b'
  prefs: []
  type: TYPE_NORMAL
- en: x = int(input())
  prefs: []
  type: TYPE_NORMAL
- en: s = 0
  prefs: []
  type: TYPE_NORMAL
- en: 'for digit in str(x):'
  prefs: []
  type: TYPE_NORMAL
- en: s += int(digit)
  prefs: []
  type: TYPE_NORMAL
- en: print(s)
  prefs: []
  type: TYPE_NORMAL
- en: 29.2 Exercises with Nested Loop Control Structures
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Exercise 29.2-1 Displaying all Three-Digit Integers that Contain a Given Digit
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Write a Python program that prompts the user to enter a digit (0 to 9) and then
    displays all three-digit integers that contain that user-provided digit at least
    once. For example, for the user-provided value 7, the values 357, 771, and 700
    are such integers.
  prefs: []
  type: TYPE_NORMAL
- en: Solution
  prefs: []
  type: TYPE_NORMAL
- en: There are three different approaches! The first one uses just one for-loop,
    the second one uses three for-loops, nested one within the other, and the last
    one uses Python's magic forces. Let's analyze them all!
  prefs: []
  type: TYPE_NORMAL
- en: First approach – Using a for-loop and a decision control structure
  prefs: []
  type: TYPE_NORMAL
- en: The main idea is to use a for-loop where the value of variable counter goes
    from 100 to 999\. Inside the loop, the counter variable is split into its individual
    digits (digit[3], digit[2], digit[1]) and a decision control structure is used
    to check if at least one of its digits is equal to the provided one. The Python
    program is as follows.
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/my_exercise_header.png) file_29.2-1a'
  prefs: []
  type: TYPE_NORMAL
- en: 'x = int(input("Enter a digit 0 - 9: "))'
  prefs: []
  type: TYPE_NORMAL
- en: 'for i in range(100, 1000):'
  prefs: []
  type: TYPE_NORMAL
- en: digit3 = i // 100
  prefs: []
  type: TYPE_NORMAL
- en: r = i % 100
  prefs: []
  type: TYPE_NORMAL
- en: digit2 = r // 10
  prefs: []
  type: TYPE_NORMAL
- en: digit1 = r % 10
  prefs: []
  type: TYPE_NORMAL
- en: 'if digit3 == x or digit2 == x or digit1 == x:'
  prefs: []
  type: TYPE_NORMAL
- en: print(i)
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: After some refinement, the program can be improved as follows
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/my_exercise_header.png) file_29.2-1b'
  prefs: []
  type: TYPE_NORMAL
- en: 'x = int(input("Enter a digit 0 - 9: "))'
  prefs: []
  type: TYPE_NORMAL
- en: 'for i in range(100, 1000):'
  prefs: []
  type: TYPE_NORMAL
- en: digit3, r = divmod(i, 100)
  prefs: []
  type: TYPE_NORMAL
- en: digit2, digit1 = divmod(r, 10)
  prefs: []
  type: TYPE_NORMAL
- en: 'if x in [digit1, digit2, digit3]:'
  prefs: []
  type: TYPE_NORMAL
- en: print(i)
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: Second approach – Using nested loop control structures and a decision control
    structure
  prefs: []
  type: TYPE_NORMAL
- en: The main idea here is to use three for-loops, nested one within the other. In
    this case, there are three counter variables (digit3, digit2, and digit1) and
    each one of them corresponds to one digit of the three-digit integer. The Python
    program is as follows.
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/my_exercise_header.png) file_29.2-1c'
  prefs: []
  type: TYPE_NORMAL
- en: 'x = int(input("Enter a digit 0 - 9: "))'
  prefs: []
  type: TYPE_NORMAL
- en: 'for digit3 in range(1, 10):'
  prefs: []
  type: TYPE_NORMAL
- en: 'for digit2 in range(10):'
  prefs: []
  type: TYPE_NORMAL
- en: 'for digit1 in range(10):'
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: 'if x in [digit1, digit2, digit3]:'
  prefs:
  - PREF_BQ
  - PREF_BQ
  type: TYPE_NORMAL
- en: print(digit3 * 100 + digit2 * 10 + digit1)
  prefs:
  - PREF_BQ
  - PREF_BQ
  - PREF_BQ
  type: TYPE_NORMAL
- en: If you follow the flow of execution, the value 100 is the first “integer” evaluated
    (digit3 = 1, digit2 = 0, digit1 = 0). Then, the most-nested loop control structure
    increments variable digit1 by one and the next value evaluated is “integer” 101\.
    This continues until digit1 reaches the value 9; that is, until the “integer”
    reaches the value 109\. The flow of execution then exits the most-nested loop
    control structure, variable digit2 increments by one, and the most-nested loop
    control structure starts over again, thus the values evaluated are the “integers”
    110, 111, 112, … 119\. The process goes on until all integers up to the value
    999 are evaluated.
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/notice.jpg)Note that variable digit3 starts from 1, whereas variables
    digit2 and digit1 start from 0\. This is necessary since the scale for three-digit
    numbers begins from 100 and not from 000.'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/notice.jpg)Note how the print statement composes the three-digit integer.'
  prefs: []
  type: TYPE_NORMAL
- en: Third approach – The Pythonic way (version 1.0)
  prefs: []
  type: TYPE_NORMAL
- en: In this approach, the counter variable of a for-loop is converted to string
    and unpacked into three individual variables as shown here.
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/my_exercise_header.png) file_29.2-1d'
  prefs: []
  type: TYPE_NORMAL
- en: 'x = input("Enter a digit 0 - 9: ")'
  prefs: []
  type: TYPE_NORMAL
- en: 'for i in range(100, 1000):'
  prefs: []
  type: TYPE_NORMAL
- en: digit3, digit2, digit1 = str(i)
  prefs: []
  type: TYPE_NORMAL
- en: 'if x in [digit3, digit2, digit1]:'
  prefs: []
  type: TYPE_NORMAL
- en: print(i)
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '![](img/notice.jpg)Note that variable x, as well as variables digit1, digit2,
    and digit3, are of type string.'
  prefs: []
  type: TYPE_NORMAL
- en: Fourth approach – The Pythonic way (version 2.0)
  prefs: []
  type: TYPE_NORMAL
- en: In this approach, the counter variable of a for-loop is converted to string
    and the in operator checks if the user-provided “digit” exists in the string.
    The Python program is as follows.
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/my_exercise_header.png) file_29.2-1e'
  prefs: []
  type: TYPE_NORMAL
- en: 'x = input("Enter a digit 0 - 9: ")'
  prefs: []
  type: TYPE_NORMAL
- en: 'for i in range(100, 1000):'
  prefs: []
  type: TYPE_NORMAL
- en: 'if x in str(i):'
  prefs: []
  type: TYPE_NORMAL
- en: print(i)
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '![](img/notice.jpg)Note that variable x is of type string.'
  prefs: []
  type: TYPE_NORMAL
- en: Exercise 29.2-2 Displaying all Instances of a Specified Condition
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Write a Python program that displays all three-digit integers in which the first
    digit is smaller than the second digit and the second digit is smaller than the
    third digit. For example, the values 357, 456, and 159 are such integers.
  prefs: []
  type: TYPE_NORMAL
- en: Solution
  prefs: []
  type: TYPE_NORMAL
- en: Using knowledge from the previous exercise ([Exercise 29.2-1](#toc_9)), there
    are three different approaches! Let's analyze them all!
  prefs: []
  type: TYPE_NORMAL
- en: First approach – Using a for-loop and a decision control structure
  prefs: []
  type: TYPE_NORMAL
- en: Using a for-loop and a decision control structure, the Python program is as
    follows.
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/my_exercise_header.png) file_29.2-2a'
  prefs: []
  type: TYPE_NORMAL
- en: 'for i in range(100, 1000):'
  prefs: []
  type: TYPE_NORMAL
- en: digit3, r = divmod(i, 100)
  prefs: []
  type: TYPE_NORMAL
- en: digit2, digit1 = divmod(r, 10)
  prefs: []
  type: TYPE_NORMAL
- en: 'if digit3 < digit2 and digit2 < digit1:'
  prefs: []
  type: TYPE_NORMAL
- en: print(i)
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: Second approach – Using nested loop control structures and a decision control
    structure
  prefs: []
  type: TYPE_NORMAL
- en: Using nested loop control structures and a decision control structure, the Python
    program is as follows.
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/my_exercise_header.png) file_29.2-2b'
  prefs: []
  type: TYPE_NORMAL
- en: 'for digit3 in range(1, 10):'
  prefs: []
  type: TYPE_NORMAL
- en: 'for digit2 in range(10):'
  prefs: []
  type: TYPE_NORMAL
- en: 'for digit1 in range(10):'
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: 'if digit3 < digit2 and digit2 < digit1:'
  prefs:
  - PREF_BQ
  - PREF_BQ
  type: TYPE_NORMAL
- en: print(digit3 * 100 + digit2 * 10 + digit1)
  prefs:
  - PREF_BQ
  - PREF_BQ
  - PREF_BQ
  type: TYPE_NORMAL
- en: Third approach – Using nested loop control structures only
  prefs: []
  type: TYPE_NORMAL
- en: This approach is based on the second approach. The main difference between them
    is that in this case, variable digit1 always begins from a value greater than
    digit2, and variable digit2 always begins from a value greater than digit3\. In
    that way, the first integer that will be displayed is 123.
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/notice.jpg)There are no integers below the value 123 and above the
    value 789 that can validate the Boolean expression digit3 < digit2 and digit2
    < digit1 to True.'
  prefs: []
  type: TYPE_NORMAL
- en: The Python program is as follows.
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/my_exercise_header.png) file_29.2-2c'
  prefs: []
  type: TYPE_NORMAL
- en: 'for digit3 in range(1, 8):'
  prefs: []
  type: TYPE_NORMAL
- en: 'for digit2 in range(digit3 + 1, 9):'
  prefs: []
  type: TYPE_NORMAL
- en: 'for digit1 in range(digit2 + 1, 10):'
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: print(digit3 * 100 + digit2 * 10 + digit1)
  prefs:
  - PREF_BQ
  - PREF_BQ
  type: TYPE_NORMAL
- en: '![](img/notice.jpg)This solution is the most efficient since it doesn''t use
    any decision control structure and, moreover, the number of iterations is kept
    to a minimum!'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/remember.jpg)As you can see, one problem can have many solutions. It
    is up to you to find the optimal one!'
  prefs: []
  type: TYPE_NORMAL
- en: 29.3 Data Validation with Loop Control Structures
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: As you already know, data validation is the process of restricting data input,
    which forces the user to enter only valid values. You have already encountered
    one method of data validation using decision control structures. Let's recall
    an example.
  prefs: []
  type: TYPE_NORMAL
- en: from math import sqrt
  prefs: []
  type: TYPE_NORMAL
- en: 'x = float(input("Enter a non-negative number: "))'
  prefs: []
  type: TYPE_NORMAL
- en: 'if x < 0:'
  prefs: []
  type: TYPE_NORMAL
- en: 'print("Error: Negative number entered!")'
  prefs: []
  type: TYPE_NORMAL
- en: 'else:'
  prefs: []
  type: TYPE_NORMAL
- en: print(sqrt(x))
  prefs: []
  type: TYPE_NORMAL
- en: This approach, however, may not be the most convenient for the user. If they
    enter an invalid number, the program displays the error message, and the flow
    of execution inevitably reaches the end. The user must then restart the program
    to re-enter a valid number.
  prefs: []
  type: TYPE_NORMAL
- en: Next, you will find three approaches given in general form for validating data
    input using loop control structures. In cases where a user enters an invalid value,
    the primary objective is to prompt them repeatedly until they eventually provide
    a valid one. Of course, if the user initially enters a valid value, the flow of
    execution simply proceeds to the next section of the program.
  prefs: []
  type: TYPE_NORMAL
- en: Which approach you use depends on whether or not you wish to display an error
    message and whether you wish to display different error messages, one for each
    type of input error, or just a generic error message for any kind of error.
  prefs: []
  type: TYPE_NORMAL
- en: First approach – Validating data input without error messages
  prefs: []
  type: TYPE_NORMAL
- en: To validate data input without displaying any error messages, you can use the
    following code fragment given in general form.
  prefs: []
  type: TYPE_NORMAL
- en: 'while True:'
  prefs: []
  type: TYPE_NORMAL
- en: input_data = input("Prompt message")
  prefs: []
  type: TYPE_NORMAL
- en: if input_data test 1 succeeds and    \
  prefs: []
  type: TYPE_NORMAL
- en: input_data test 2 succeeds and    \
  prefs: []
  type: TYPE_NORMAL
- en: …
  prefs: []
  type: TYPE_NORMAL
- en: 'input_data test N succeeds: break'
  prefs: []
  type: TYPE_NORMAL
- en: Second approach – Validating data input with a generic error message
  prefs: []
  type: TYPE_NORMAL
- en: To validate data input and display a generic error message (that is, the same
    error message for any type of input error), you can use the following code fragment
    given in general form.
  prefs: []
  type: TYPE_NORMAL
- en: input_data = input("Prompt message")
  prefs: []
  type: TYPE_NORMAL
- en: while input_data test 1 fails or    \
  prefs: []
  type: TYPE_NORMAL
- en: input_data test 2 fails or    \
  prefs: []
  type: TYPE_NORMAL
- en: …
  prefs: []
  type: TYPE_NORMAL
- en: 'input_data test N fails:'
  prefs: []
  type: TYPE_NORMAL
- en: print("Error message")
  prefs: []
  type: TYPE_NORMAL
- en: input_data = input("Prompt message")
  prefs: []
  type: TYPE_NORMAL
- en: Third approach – Validating data input with different error messages
  prefs: []
  type: TYPE_NORMAL
- en: To validate data input and display a different error message for each type of
    input error, you can use the following code fragment given in general form.
  prefs: []
  type: TYPE_NORMAL
- en: 'while True:'
  prefs: []
  type: TYPE_NORMAL
- en: input_data = input("Prompt message")
  prefs: []
  type: TYPE_NORMAL
- en: failure = False
  prefs: []
  type: TYPE_NORMAL
- en: 'if input_data test 1 fails:'
  prefs: []
  type: TYPE_NORMAL
- en: print("Error message 1")
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: failure = True
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: 'elif input_data test 2 fails:'
  prefs: []
  type: TYPE_NORMAL
- en: print("Error message 2")
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: failure = True
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: elif …
  prefs: []
  type: TYPE_NORMAL
- en: …
  prefs: []
  type: TYPE_NORMAL
- en: 'elif input_data test N fails:'
  prefs: []
  type: TYPE_NORMAL
- en: print("Error message N")
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: failure = True
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: 'if not failure: break'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/notice.jpg)The statement if not failure is equivalent to the statement
    if failure == False'
  prefs: []
  type: TYPE_NORMAL
- en: Exercise 29.3-1 Finding Odd and Even Numbers - Validation Without Error Messages
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Write a Python program that prompts the user to enter a non-negative integer,
    and then displays a message indicating whether this number is even; it must display
    “Odd” otherwise. Using a loop control structure, the program must also validate
    data input, allowing the user to enter only a non-negative integer.
  prefs: []
  type: TYPE_NORMAL
- en: Solution
  prefs: []
  type: TYPE_NORMAL
- en: All three approaches for validating data input that you learned in [Section
    29.3](#toc_11) will be presented here. But first, let's solve this exercise without
    data validation.
  prefs: []
  type: TYPE_NORMAL
- en: 'x = float(input("Enter a non-negative integer: "))   [[More…]](more.html#more_29_3_1_1)'
  prefs: []
  type: TYPE_NORMAL
- en: 'if x % 2 == 0:'
  prefs: []
  type: TYPE_NORMAL
- en: print("Even")
  prefs: []
  type: TYPE_NORMAL
- en: 'else:'
  prefs: []
  type: TYPE_NORMAL
- en: print("Odd")
  prefs: []
  type: TYPE_NORMAL
- en: Validation Without Error Messages
  prefs: []
  type: TYPE_NORMAL
- en: To validate data input without displaying any error messages, use the first
    approach from [Section 29.3](#toc_11). Simply replace the statements marked with
    a dashed rectangle with the following code fragment.
  prefs: []
  type: TYPE_NORMAL
- en: 'while True:'
  prefs: []
  type: TYPE_NORMAL
- en: 'x = float(input("Enter a non-negative integer: "))'
  prefs: []
  type: TYPE_NORMAL
- en: 'if x >= 0 and int(x) == x: break'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/notice.jpg)Instead of the function int(), the function float() is used
    in the data input stage. This is necessary in order to allow the user to enter
    either an integer or a float.'
  prefs: []
  type: TYPE_NORMAL
- en: The final Python program becomes
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/my_exercise_header.png) file_29.3-1a'
  prefs: []
  type: TYPE_NORMAL
- en: while True:                                   [[More…]](more.html#more_29_3_1_2)
  prefs: []
  type: TYPE_NORMAL
- en: 'x = float(input("Enter a non-negative integer: "))'
  prefs: []
  type: TYPE_NORMAL
- en: 'if x >= 0 and int(x) == x: break'
  prefs: []
  type: TYPE_NORMAL
- en: 'if x % 2 == 0:'
  prefs: []
  type: TYPE_NORMAL
- en: print("Even")
  prefs: []
  type: TYPE_NORMAL
- en: 'else:'
  prefs: []
  type: TYPE_NORMAL
- en: print("Odd")
  prefs: []
  type: TYPE_NORMAL
- en: Validation with a Generic Error Message
  prefs: []
  type: TYPE_NORMAL
- en: To validate data input and display a generic error message, replace the statements
    marked with the dashed rectangle with a code fragment based on the second approach
    from [Section 29.3](#toc_11). The Python program is as follows.
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/my_exercise_header.png) file_29.3-1b'
  prefs: []
  type: TYPE_NORMAL
- en: 'x = float(input("Enter a non-negative integer: "))    [[More…]](more.html#more_29_3_1_3)'
  prefs: []
  type: TYPE_NORMAL
- en: 'while x < 0 or x != int(x):'
  prefs: []
  type: TYPE_NORMAL
- en: print("Error! A negative value or a float entered.")
  prefs: []
  type: TYPE_NORMAL
- en: 'x = float(input("Enter a non-negative integer: "))'
  prefs: []
  type: TYPE_NORMAL
- en: 'if x % 2 == 0:'
  prefs: []
  type: TYPE_NORMAL
- en: print("Even")
  prefs: []
  type: TYPE_NORMAL
- en: 'else:'
  prefs: []
  type: TYPE_NORMAL
- en: print("Odd")
  prefs: []
  type: TYPE_NORMAL
- en: Validation with Different Error Messages
  prefs: []
  type: TYPE_NORMAL
- en: Here, the replacing code fragment is based on the third approach from [Section
    29.3](#toc_11). To validate data input and display a different error message for
    each type of input error, the Python program is as follows.
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/my_exercise_header.png) file_29.3-1c'
  prefs: []
  type: TYPE_NORMAL
- en: while True:                                    [[More…]](more.html#more_29_3_1_4)
  prefs: []
  type: TYPE_NORMAL
- en: 'x = float(input("Enter a non-negative integer: "))'
  prefs: []
  type: TYPE_NORMAL
- en: failure = False
  prefs: []
  type: TYPE_NORMAL
- en: 'if x < 0:'
  prefs: []
  type: TYPE_NORMAL
- en: print("Error! You entered a negative value")
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: failure = True
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: 'elif x != int(x):'
  prefs: []
  type: TYPE_NORMAL
- en: print("Error! You entered a float")
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: failure = True
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: 'if not failure: break'
  prefs: []
  type: TYPE_NORMAL
- en: 'if x % 2 == 0:'
  prefs: []
  type: TYPE_NORMAL
- en: print("Even")
  prefs: []
  type: TYPE_NORMAL
- en: 'else:'
  prefs: []
  type: TYPE_NORMAL
- en: print("Odd")
  prefs: []
  type: TYPE_NORMAL
- en: Exercise 29.3-2 Finding the Sum of Four Numbers
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Write a Python program that prompts the user to enter four positive numbers
    and then calculates and displays their sum. Using a loop control structure, the
    program must also validate data input and display an error message when the user
    enters any non-positive value.
  prefs: []
  type: TYPE_NORMAL
- en: Solution
  prefs: []
  type: TYPE_NORMAL
- en: This exercise was already discussed in [Exercise 25.1-4](chapter25.html#toc_5).
    The only difference here is that this program must validate data input and display
    an error message when the user enters invalid values. For your convenience, the
    solution proposed in that exercise is reproduced next.
  prefs: []
  type: TYPE_NORMAL
- en: total = 0
  prefs: []
  type: TYPE_NORMAL
- en: 'for i in range(4):'
  prefs: []
  type: TYPE_NORMAL
- en: 'x = float(input("Enter a number: "))   [[More…]](more.html#more_29_3_2_1)'
  prefs: []
  type: TYPE_NORMAL
- en: total = total + x
  prefs: []
  type: TYPE_NORMAL
- en: print(total)
  prefs: []
  type: TYPE_NORMAL
- en: The primary purpose of this exercise is to demonstrate how to nest the loop
    control structure that validates data input into other pre-existing loop control
    structures. In this exercise, you should replace the statement marked with a dashed
    rectangle with the following code fragment
  prefs: []
  type: TYPE_NORMAL
- en: 'x = float(input("Enter a number: "))'
  prefs: []
  type: TYPE_NORMAL
- en: 'while x <= 0:'
  prefs: []
  type: TYPE_NORMAL
- en: print("Please enter a positive value!")
  prefs: []
  type: TYPE_NORMAL
- en: 'x = float(input("Enter a number: "))'
  prefs: []
  type: TYPE_NORMAL
- en: and the final Python program becomes
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/my_exercise_header.png) file_29.3-2'
  prefs: []
  type: TYPE_NORMAL
- en: total = 0
  prefs: []
  type: TYPE_NORMAL
- en: 'for i in range(4):'
  prefs: []
  type: TYPE_NORMAL
- en: 'x = float(input("Enter a number: "))   [[More…]](more.html#more_29_3_2_2)'
  prefs: []
  type: TYPE_NORMAL
- en: 'while x <= 0:'
  prefs: []
  type: TYPE_NORMAL
- en: print("Please enter a positive value!")
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: 'x = float(input("Enter a number: "))'
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: total = total + x
  prefs: []
  type: TYPE_NORMAL
- en: print(total)
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/notice.jpg)Note that the replacing code fragment is entirely nested
    within this outer for-loop.'
  prefs: []
  type: TYPE_NORMAL
- en: 29.4 Finding Minimum and Maximum Values with Loop Control Structures
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: In [Section 22.2](chapter22.html#toc_8) you learned how to find the minimum
    and maximum values among four values using single-alternative decision structures.
    Now, the following code fragment achieves the same result but uses only one variable
    w, for the user-provided values.
  prefs: []
  type: TYPE_NORMAL
- en: 'w = int(input())     #User enters 1st value'
  prefs: []
  type: TYPE_NORMAL
- en: maximum = w
  prefs: []
  type: TYPE_NORMAL
- en: 'w = int(input())     #User enters 2nd value'
  prefs: []
  type: TYPE_NORMAL
- en: 'if w > maximum:'
  prefs: []
  type: TYPE_NORMAL
- en: maximum = w
  prefs: []
  type: TYPE_NORMAL
- en: 'w = int(input())     #User enters 3rd value'
  prefs: []
  type: TYPE_NORMAL
- en: 'if w > maximum:'
  prefs: []
  type: TYPE_NORMAL
- en: maximum = w
  prefs: []
  type: TYPE_NORMAL
- en: 'w = int(input())     #User enters 4th value'
  prefs: []
  type: TYPE_NORMAL
- en: 'if w > maximum:'
  prefs: []
  type: TYPE_NORMAL
- en: maximum = w
  prefs: []
  type: TYPE_NORMAL
- en: Except for the first pair of statements, all other blocks of statements are
    identical. Therefore, you can retain only one of these pairs and enclose it within
    a loop control structure that performs three iterations, as presented below.
  prefs: []
  type: TYPE_NORMAL
- en: 'w = int(input())     #User enters 1st value'
  prefs: []
  type: TYPE_NORMAL
- en: maximum = w
  prefs: []
  type: TYPE_NORMAL
- en: 'for i in range(3):'
  prefs: []
  type: TYPE_NORMAL
- en: 'w = int(input())     #User enters 2nd, 3rd and 4th value'
  prefs: []
  type: TYPE_NORMAL
- en: 'if w > maximum:'
  prefs: []
  type: TYPE_NORMAL
- en: maximum = w
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: Of course, if you want to allow the user to enter more values, you can simply
    increase the final_value of the for-loop.
  prefs: []
  type: TYPE_NORMAL
- en: Accordingly, a program that finds and displays the heaviest person among 10
    individuals is presented next.
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/my_exercise_header.png) file_29.4a'
  prefs: []
  type: TYPE_NORMAL
- en: 'w = int(input("Enter a weight (in pounds): "))'
  prefs: []
  type: TYPE_NORMAL
- en: maximum = w
  prefs: []
  type: TYPE_NORMAL
- en: 'for i in range(9):'
  prefs: []
  type: TYPE_NORMAL
- en: 'w = int(input("Enter a weight (in pounds): "))'
  prefs: []
  type: TYPE_NORMAL
- en: 'if w > maximum:'
  prefs: []
  type: TYPE_NORMAL
- en: maximum = w
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: print(maximum)
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/notice.jpg)Note that the for-loop iterates one time less than the total
    number of user-provided values.'
  prefs: []
  type: TYPE_NORMAL
- en: Even though this Python program operates fine, let's do something slightly different.
    Instead of prompting the user to enter the first value before the loop and the
    remaining nine values within the loop, let's prompt them to enter all values within
    the loop.
  prefs: []
  type: TYPE_NORMAL
- en: However, the issue that arises here is that, no matter what, an initial value
    must always be assigned to the variable maximum before the loop starts iterating.
    But, this value cannot be arbitrarily chosen; it depends on the given problem.
    Therefore, choosing an “almost arbitrary” initial value requires careful consideration,
    as an incorrect choice may yield inaccurate results.
  prefs: []
  type: TYPE_NORMAL
- en: In this exercise, all user-provided values have to do with people's weight.
    Since there is no chance of finding any person with a negative weight (at least
    not on planet Earth), you can safely assign the initial value −1 to variable maximum,
    as follows.
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/my_exercise_header.png) file_29.4b'
  prefs: []
  type: TYPE_NORMAL
- en: maximum = -1
  prefs: []
  type: TYPE_NORMAL
- en: 'for i in range(10):'
  prefs: []
  type: TYPE_NORMAL
- en: 'w = int(input("Enter a weight (in pounds): "))'
  prefs: []
  type: TYPE_NORMAL
- en: 'if w > maximum:'
  prefs: []
  type: TYPE_NORMAL
- en: maximum = w
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: print(maximum)
  prefs: []
  type: TYPE_NORMAL
- en: Once the flow of execution enters the loop, the user enters the first value
    and the decision control structure evaluates to True. The initial value −1 in
    variable maximum is then overwritten by this first user-provided value and afterward,
    the flow of execution proceeds normally.
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/notice.jpg)Note that this method may not be applicable in all cases.
    If an exercise requires prompting the user to enter any number (not limited to
    positive ones), this method cannot be applied, as the user could potentially enter
    only negative values. If this were to occur, the initial value of −1 would never
    be replaced by any of the user-provided values. This method can be used to find
    the maximum value only when the lower limit of user-provided values is known,
    or to find the minimum value only when the upper limit of user-provided values
    is known. For instance, if the exercise requires finding the lightest person,
    you can assign the initial value +1500 to variable minimum, as there is no human
    on Earth who can weigh that much! For reference, Jon Brower Minnoch was an American
    who, at his peak weight, was recorded as the heaviest human being ever, weighing
    approximately 1,400 lb!!!!!'
  prefs: []
  type: TYPE_NORMAL
- en: Exercise 29.4-1 Validating and Finding the Minimum and the Maximum Value
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Write a Python program that prompts the user to enter the weight of 10 people
    and then finds the lightest and the heaviest weights. Using a loop control structure,
    the program must also validate data input and display an error message when the
    user enters any non-positive value, or any value greater than 1500.
  prefs: []
  type: TYPE_NORMAL
- en: Solution
  prefs: []
  type: TYPE_NORMAL
- en: Using the previous exercise as a guide, you should now be able to do this with
    your eyes closed!
  prefs: []
  type: TYPE_NORMAL
- en: To validate data input, all you have to do is replace the following line of
    code of the previous exercise,
  prefs: []
  type: TYPE_NORMAL
- en: 'w = int(input("Enter a weight (in pounds): "))'
  prefs: []
  type: TYPE_NORMAL
- en: 'with the following code fragment:'
  prefs: []
  type: TYPE_NORMAL
- en: 'w = int(input("Enter a weight between 1 and 1500 (in pounds): "))'
  prefs: []
  type: TYPE_NORMAL
- en: 'while w < 1 or x > 1500:'
  prefs: []
  type: TYPE_NORMAL
- en: 'w = int(input("Invalid value! Enter a weight between 1 and 1500 (in pounds):
    "))'
  prefs: []
  type: TYPE_NORMAL
- en: Following is the final program that finds the lightest and the heaviest weights.
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/my_exercise_header.png) file_29.4-1'
  prefs: []
  type: TYPE_NORMAL
- en: minimum = 1500
  prefs: []
  type: TYPE_NORMAL
- en: maximum = 0
  prefs: []
  type: TYPE_NORMAL
- en: 'for i in range(10):'
  prefs: []
  type: TYPE_NORMAL
- en: 'w = int(input("Enter a weight between 1 and 1500 (in pounds): "))          [[More…]](more.html#more_29_4_1_1)'
  prefs: []
  type: TYPE_NORMAL
- en: 'while w < 1 or w > 1500:'
  prefs: []
  type: TYPE_NORMAL
- en: 'w = int(input("Invalid value! Enter a weight between 1 and 1500 (in pounds):
    "))'
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: 'if w < minimum:'
  prefs: []
  type: TYPE_NORMAL
- en: minimum = w
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: 'if w > maximum:'
  prefs: []
  type: TYPE_NORMAL
- en: maximum = w
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: print(minimum, maximum)
  prefs: []
  type: TYPE_NORMAL
- en: Exercise 29.4-2 Validating and Finding the Hottest Planet
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Write a Python program that prompts the user to repeatedly enter the names and
    the average temperatures of planets from space, until the word “STOP” (used as
    a name) is entered. In the end, the program must display the name of the hottest
    planet. Moreover, since −459.67^o (on the Fahrenheit scale) is the lowest temperature
    possible (it is called absolute zero), the program must also validate data input
    (using  a loop control structure) and display an error message when the user enters
    temperature values lower than absolute zero.
  prefs: []
  type: TYPE_NORMAL
- en: Solution
  prefs: []
  type: TYPE_NORMAL
- en: 'First, let''s write the Python program without using data validation. According
    to the “Ultimate” rule, the pre-test loop structure should be as follows, given
    in general form:'
  prefs: []
  type: TYPE_NORMAL
- en: 'name = input("Enter the name of a planet: ")  #Initialization of name'
  prefs: []
  type: TYPE_NORMAL
- en: 'while name.upper() != "STOP":'
  prefs: []
  type: TYPE_NORMAL
- en: A statement or block of statements
  prefs: []
  type: TYPE_NORMAL
- en: 'name = input("Enter the name of a planet: ")   #Update/alteration of name'
  prefs: []
  type: TYPE_NORMAL
- en: Now, let's add the rest of the statements, still without data input validation.
    Keep in mind that, since value −459.67^o is the lower limit of the temperature
    scale, you can use a value lower than this as the initial value of variable maximum.
  prefs: []
  type: TYPE_NORMAL
- en: maximum = -460
  prefs: []
  type: TYPE_NORMAL
- en: mName = ""
  prefs: []
  type: TYPE_NORMAL
- en: 'name = input("Enter the name of a planet: ")'
  prefs: []
  type: TYPE_NORMAL
- en: 'while name.upper() != "STOP":'
  prefs: []
  type: TYPE_NORMAL
- en: 't = float(input("Enter its average temperature: "))'
  prefs: []
  type: TYPE_NORMAL
- en: 'if t > maximum:'
  prefs: []
  type: TYPE_NORMAL
- en: maximum = t
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: mName = name
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: 'name = input("Enter the name of a planet: ")'
  prefs: []
  type: TYPE_NORMAL
- en: 'if maximum != -460:'
  prefs: []
  type: TYPE_NORMAL
- en: print("The hottest planet is:", mName)
  prefs: []
  type: TYPE_NORMAL
- en: 'else:'
  prefs: []
  type: TYPE_NORMAL
- en: print("Nothing Entered!")
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/notice.jpg)The if maximum != -460 statement is required because there
    is a possibility that the user could enter the word “STOP” right from the beginning.'
  prefs: []
  type: TYPE_NORMAL
- en: 'To validate the data input, all you have to do is replace the following line
    of code:'
  prefs: []
  type: TYPE_NORMAL
- en: 't = float(input("Enter its average temperature: "))'
  prefs: []
  type: TYPE_NORMAL
- en: 'with the following code fragment:'
  prefs: []
  type: TYPE_NORMAL
- en: 't = float(input("Enter its average temperature: "))'
  prefs: []
  type: TYPE_NORMAL
- en: 'while t < -459.67:'
  prefs: []
  type: TYPE_NORMAL
- en: 't = float(input("Invalid value! Enter its average temperature: "))'
  prefs: []
  type: TYPE_NORMAL
- en: The final program is as follows.
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/my_exercise_header.png) file_29.4-2'
  prefs: []
  type: TYPE_NORMAL
- en: maximum = -460
  prefs: []
  type: TYPE_NORMAL
- en: mName = ""
  prefs: []
  type: TYPE_NORMAL
- en: 'name = input("Enter the name of a planet: ")'
  prefs: []
  type: TYPE_NORMAL
- en: 'while name.upper() != "STOP":'
  prefs: []
  type: TYPE_NORMAL
- en: 't = float(input("Enter its average temperature: "))'
  prefs: []
  type: TYPE_NORMAL
- en: 'while t < -459.67:'
  prefs: []
  type: TYPE_NORMAL
- en: 't = float(input("Invalid value! Enter its average temperature: "))'
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: 'if t > maximum:'
  prefs: []
  type: TYPE_NORMAL
- en: maximum = t
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: mName = name
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: 'name = input("Enter the name of a planet: ")'
  prefs: []
  type: TYPE_NORMAL
- en: 'if maximum != -460:'
  prefs: []
  type: TYPE_NORMAL
- en: print("The hottest planet is:", mName)
  prefs: []
  type: TYPE_NORMAL
- en: 'else:'
  prefs: []
  type: TYPE_NORMAL
- en: print("Nothing Entered!")
  prefs: []
  type: TYPE_NORMAL
- en: Exercise 29.4-3 ”Making the Grade”
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: In a classroom, there are 20 students. Write a Python program that prompts the
    teacher to enter the grades (0 ‐ 100) that students received in a math test and
    then displays the highest grade as well as the number of students that got an
    “A” (that is, 90 to 100). Moreover, the program must validate data input. User-provided
    values must be within the range 0 to 100.
  prefs: []
  type: TYPE_NORMAL
- en: Solution
  prefs: []
  type: TYPE_NORMAL
- en: Let's first write the program without data validation. Since the number of students
    is known, you can use a for-loop. For an initial value of variable maximum, you
    can use value −1 as there is no grade lower than 0.
  prefs: []
  type: TYPE_NORMAL
- en: maximum = -1
  prefs: []
  type: TYPE_NORMAL
- en: count = 0
  prefs: []
  type: TYPE_NORMAL
- en: 'for i in range(20):'
  prefs: []
  type: TYPE_NORMAL
- en: 'grade = int(input("Grade for student No" + str(i + 1) + ": "))'
  prefs: []
  type: TYPE_NORMAL
- en: 'if grade > maximum:'
  prefs: []
  type: TYPE_NORMAL
- en: maximum = grade
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: 'if grade >= 90:'
  prefs: []
  type: TYPE_NORMAL
- en: count += 1
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: print(maximum, count)
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, you can deal with data validation. As the wording of the exercise implies,
    there is no need to display any error messages. So, all you need to do is replace
    the following line of code:'
  prefs: []
  type: TYPE_NORMAL
- en: 'grade = int(input("Grade for student No" + str(i + 1) + ": "))'
  prefs: []
  type: TYPE_NORMAL
- en: 'with the following code fragment:'
  prefs: []
  type: TYPE_NORMAL
- en: 'while True:'
  prefs: []
  type: TYPE_NORMAL
- en: 'grade = int(input("Grade for student No" + str(i + 1) + ": "))'
  prefs: []
  type: TYPE_NORMAL
- en: 'if 0 <= grade <= 100: break'
  prefs: []
  type: TYPE_NORMAL
- en: and the final program becomes
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/my_exercise_header.png) file_29.4-3'
  prefs: []
  type: TYPE_NORMAL
- en: maximum = -1
  prefs: []
  type: TYPE_NORMAL
- en: count = 0
  prefs: []
  type: TYPE_NORMAL
- en: 'for i in range(20):'
  prefs: []
  type: TYPE_NORMAL
- en: 'while True:'
  prefs: []
  type: TYPE_NORMAL
- en: 'grade = int(input("Grade for student No" + str(i + 1) + ": "))'
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: 'if 0 <= grade <= 100: break'
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: 'if grade > maximum:'
  prefs: []
  type: TYPE_NORMAL
- en: maximum = grade
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: 'if grade >= 90:'
  prefs: []
  type: TYPE_NORMAL
- en: count += 1
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: print(maximum, count)
  prefs: []
  type: TYPE_NORMAL
- en: 29.5 Using Loop Control Structures to Solve Mathematical Problems
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Exercise 29.5-1 Calculating the Area of as Many Triangles as the User Wishes
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Write a Python program that prompts the user to enter the lengths of all three
    sides A, B, and C of a triangle and then calculates and displays its area. You
    can use Heron's formula,
  prefs: []
  type: TYPE_NORMAL
- en: .![Image](img/chapter12-24.png)
  prefs: []
  type: TYPE_NORMAL
- en: where S is the semi-perimeter
  prefs: []
  type: TYPE_NORMAL
- en: .![Image](img/chapter12-25.png)
  prefs: []
  type: TYPE_NORMAL
- en: The program must iterate as many times as the user wishes. At the end of each
    area calculation, the program must ask the user if they wish to calculate the
    area of another triangle. If the answer is “yes” the program must repeat; it must
    end otherwise. Make your program accept the answer in all possible forms such
    as “yes”, “YES”, “Yes”, or even “YeS”.
  prefs: []
  type: TYPE_NORMAL
- en: Moreover, using a loop control structure, the program must validate data input
    and display an error message when the user enters any non-positive value.
  prefs: []
  type: TYPE_NORMAL
- en: Solution
  prefs: []
  type: TYPE_NORMAL
- en: According to the “Ultimate” rule, the post-test loop structure should be as
    follows, given in general form.
  prefs: []
  type: TYPE_NORMAL
- en: 'answer = "yes"   #Initialization of answer (redundant).'
  prefs: []
  type: TYPE_NORMAL
- en: 'while True:'
  prefs: []
  type: TYPE_NORMAL
- en: Prompt the user to enter the lengths of all three sides A, B, C of a triangle
    and then calculate and display its area.
  prefs: []
  type: TYPE_NORMAL
- en: '#Update/alteration of answer'
  prefs: []
  type: TYPE_NORMAL
- en: answer = input("Would you like to repeat? ")
  prefs: []
  type: TYPE_NORMAL
- en: 'if answer.upper() != "YES": break'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/remember.jpg)The upper() method ensures that the program operates properly
    for any user-provided answer “Yes”, “yes”, “YES” or even “YeS” or “yEs”!'
  prefs: []
  type: TYPE_NORMAL
- en: The solution to this exercise is as follows.
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/my_exercise_header.png) file_29.5-1'
  prefs: []
  type: TYPE_NORMAL
- en: from math import sqrt
  prefs: []
  type: TYPE_NORMAL
- en: 'while True:'
  prefs: []
  type: TYPE_NORMAL
- en: '#Prompt the user to enter the length of side A'
  prefs: []
  type: TYPE_NORMAL
- en: 'a = float(input("Enter side A: "))'
  prefs: []
  type: TYPE_NORMAL
- en: 'while a <= 0:'
  prefs: []
  type: TYPE_NORMAL
- en: 'a = float(input("Invalid side. Enter side A: "))'
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '#Prompt the user to enter the length of side B'
  prefs: []
  type: TYPE_NORMAL
- en: 'b = float(input("Enter side B: "))'
  prefs: []
  type: TYPE_NORMAL
- en: 'while b <= 0:'
  prefs: []
  type: TYPE_NORMAL
- en: 'b = float(input("Invalid side. Enter side B: "))'
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '#Prompt the user to enter the length of side C'
  prefs: []
  type: TYPE_NORMAL
- en: 'c = float(input("Enter side C: "))'
  prefs: []
  type: TYPE_NORMAL
- en: 'while c <= 0:'
  prefs: []
  type: TYPE_NORMAL
- en: 'c = float(input("Invalid side. Enter side C: "))'
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '#Calculate and display the area of the triangle'
  prefs: []
  type: TYPE_NORMAL
- en: s = (a + b + c) / 2
  prefs: []
  type: TYPE_NORMAL
- en: area = sqrt(s * (s - a) * (s - b) * (s - c))
  prefs: []
  type: TYPE_NORMAL
- en: print("The area is:", area)
  prefs: []
  type: TYPE_NORMAL
- en: answer = input("Would you like to repeat? ")
  prefs: []
  type: TYPE_NORMAL
- en: 'if answer.upper() != "YES": break'
  prefs: []
  type: TYPE_NORMAL
- en: Exercise 29.5-2 Finding x and y
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'Write a Python program that displays all possible integer values of x and y
    within the range −20 to +20 that validate the following formula:'
  prefs: []
  type: TYPE_NORMAL
- en: 3x² − 6y² = 6
  prefs: []
  type: TYPE_NORMAL
- en: Solution
  prefs: []
  type: TYPE_NORMAL
- en: If you just want to display all possible combinations of variables x and y,
    you can use the following Python program.
  prefs: []
  type: TYPE_NORMAL
- en: 'for x in range(-20, 21):'
  prefs: []
  type: TYPE_NORMAL
- en: 'for y in range(-20, 21):'
  prefs: []
  type: TYPE_NORMAL
- en: print(x, y)
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: However, from all those combinations, you need only those that validate the
    expression 3x² − 6y² = 6\. A decision control structure is perfect for that purpose!
    The final Python program is as follows.
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/my_exercise_header.png) file_29.5-2'
  prefs: []
  type: TYPE_NORMAL
- en: 'for x in range(-20, 21):'
  prefs: []
  type: TYPE_NORMAL
- en: 'for y in range(-20, 21):'
  prefs: []
  type: TYPE_NORMAL
- en: 'if 3 * x ** 2 - 6 * y ** 2 == 6:'
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: print(x, y)
  prefs:
  - PREF_BQ
  - PREF_BQ
  type: TYPE_NORMAL
- en: Exercise 29.5-3 The Russian Multiplication Algorithm
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: You can multiply two positive integers using the “Russian multiplication algorithm”,
    which is presented in the following flowchart.
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](img/chapter29-02.png)'
  prefs: []
  type: TYPE_IMG
- en: Write the corresponding Python program and create a trace table to determine
    the values of the variables in each step for the input values 5 and 13.
  prefs: []
  type: TYPE_NORMAL
- en: Solution
  prefs: []
  type: TYPE_NORMAL
- en: In the given flowchart, a single-alternative decision structure is nested within
    a pre-test loop structure. The corresponding Python program is as follows.
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/my_exercise_header.png) file_29.5-3'
  prefs: []
  type: TYPE_NORMAL
- en: m1 = int(input())
  prefs: []
  type: TYPE_NORMAL
- en: m2 = int(input())
  prefs: []
  type: TYPE_NORMAL
- en: s = 0
  prefs: []
  type: TYPE_NORMAL
- en: 'while m2 != 0:'
  prefs: []
  type: TYPE_NORMAL
- en: 'if m2 % 2 != 0:'
  prefs: []
  type: TYPE_NORMAL
- en: s += m1
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: m1 *= 2
  prefs: []
  type: TYPE_NORMAL
- en: m2 //= 2
  prefs: []
  type: TYPE_NORMAL
- en: print(s)
  prefs: []
  type: TYPE_NORMAL
- en: For the input values of 5 and 13, the trace table looks like this.
  prefs: []
  type: TYPE_NORMAL
- en: '| Step | Statement | Notes | m1 | m2 | s |'
  prefs: []
  type: TYPE_TB
- en: '| 1 | m1 = int(input()) | User enters the value 5 | 5 | ? | ? |'
  prefs: []
  type: TYPE_TB
- en: '| 2 | m2 = int(input()) | User enters the value 13 | 5 | 13 | ? |'
  prefs: []
  type: TYPE_TB
- en: '| 3 | s = 0 |   | 5 | 13 | 0 |'
  prefs: []
  type: TYPE_TB
- en: '| 4 | while m2 != 0: | This evaluates to True |'
  prefs: []
  type: TYPE_TB
- en: '| 5 | if m2 % 2 != 0: | This evaluates to True |'
  prefs: []
  type: TYPE_TB
- en: '| 6 | s += m1 |   | 5 | 13 | 5 |'
  prefs: []
  type: TYPE_TB
- en: '| 7 | m1 *= 2 |   | 10 | 13 | 5 |'
  prefs: []
  type: TYPE_TB
- en: '| 8 | m2 //= 2 |   | 10 | 6 | 5 |'
  prefs: []
  type: TYPE_TB
- en: '| 9 | while m2 != 0: | This evaluates to True |'
  prefs: []
  type: TYPE_TB
- en: '| 10 | if m2 % 2 != 0: | This evaluates to False |'
  prefs: []
  type: TYPE_TB
- en: '| 11 | m1 *= 2 |   | 20 | 6 | 5 |'
  prefs: []
  type: TYPE_TB
- en: '| 12 | m2 //= 2 |   | 20 | 3 | 5 |'
  prefs: []
  type: TYPE_TB
- en: '| 13 | while m2 != 0: | This evaluates to True |'
  prefs: []
  type: TYPE_TB
- en: '| 14 | if m2 % 2 != 0: | This evaluates to True |'
  prefs: []
  type: TYPE_TB
- en: '| 15 | s += m1 |   | 20 | 3 | 25 |'
  prefs: []
  type: TYPE_TB
- en: '| 16 | m1 *= 2 |   | 40 | 3 | 25 |'
  prefs: []
  type: TYPE_TB
- en: '| 17 | m2 //= 2 |   | 40 | 1 | 25 |'
  prefs: []
  type: TYPE_TB
- en: '| 18 | while m2 != 0: | This evaluates to True |'
  prefs: []
  type: TYPE_TB
- en: '| 19 | if m2 % 2 != 0: | This evaluates to True |'
  prefs: []
  type: TYPE_TB
- en: '| 20 | s += m1 |   | 40 | 1 | 65 |'
  prefs: []
  type: TYPE_TB
- en: '| 21 | m1 *= 2 |   | 80 | 1 | 65 |'
  prefs: []
  type: TYPE_TB
- en: '| 22 | m2 //= 2 |   | 80 | 0 | 65 |'
  prefs: []
  type: TYPE_TB
- en: '| 23 | while m2 != 0: | This evaluates to False |'
  prefs: []
  type: TYPE_TB
- en: '| 24 | print(s) | The value 65 is displayed which is, of course, the result
    of the multiplication 5 × 13 |'
  prefs: []
  type: TYPE_TB
- en: Exercise 29.5-4 Finding the Number of Divisors
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Write a Python program that lets the user enter a positive integer and then
    displays the total number of its divisors.
  prefs: []
  type: TYPE_NORMAL
- en: Solution
  prefs: []
  type: TYPE_NORMAL
- en: Let's see some examples.
  prefs: []
  type: TYPE_NORMAL
- en: ►The divisors of value 12 are numbers 1, 2, 3, 4, 6, 12.
  prefs: []
  type: TYPE_NORMAL
- en: ►The divisors of value 15 are numbers 1, 3, 5, 15.
  prefs: []
  type: TYPE_NORMAL
- en: ►The divisors of value 20 are numbers 1, 2, 4, 5, 10, 20.
  prefs: []
  type: TYPE_NORMAL
- en: ►The divisors of value 50 are numbers 1, 2, 5, 10, 25, 50.
  prefs: []
  type: TYPE_NORMAL
- en: If variable x contains the user-provided integer, all possible divisors of x
    are between 1 and x. Thus, all you need here is a for-loop where the value of
    variable counter goes  from 1 to x and, in each iteration, a simple-alternative
    decision structure checks whether the value of counter is a divisor of x, The
    Python program is as follows.
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/my_exercise_header.png) file_29.5-4a'
  prefs: []
  type: TYPE_NORMAL
- en: x = int(input())
  prefs: []
  type: TYPE_NORMAL
- en: numberOfDivisors = 0
  prefs: []
  type: TYPE_NORMAL
- en: 'for i in range(1, x + 1):'
  prefs: []
  type: TYPE_NORMAL
- en: 'if x % i == 0:'
  prefs: []
  type: TYPE_NORMAL
- en: numberOfDivisors += 1
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: print(numberOfDivisors)
  prefs: []
  type: TYPE_NORMAL
- en: This program, for input value 20, performs 20 iterations. However, wouldn't
    it be even better if it could perform less than the half of the iterations and
    achieve the same result? Of course it would! So, let's make it more efficient!
  prefs: []
  type: TYPE_NORMAL
- en: As you probably know, for any user-provided integer (in variable x)
  prefs: []
  type: TYPE_NORMAL
- en: ►the value 1 is always a divisor.
  prefs: []
  type: TYPE_NORMAL
- en: ►the user-provided integer is always a divisor of itself.
  prefs: []
  type: TYPE_NORMAL
- en: ►except for the user-provided integer, there are no other divisors after the
    middle of the range 1 to x.
  prefs: []
  type: TYPE_NORMAL
- en: Accordingly, for any integer there are certainly 2 divisors, the value 1 and
    the user-provided integer itself. Therefore, the program must check for other
    possible divisors starting from the value 2 until the middle of the range 1 to
    x. The improved Python program is as follows.
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/my_exercise_header.png) file_29.5-4b'
  prefs: []
  type: TYPE_NORMAL
- en: x = int(input())
  prefs: []
  type: TYPE_NORMAL
- en: numberOfDivisors = 2
  prefs: []
  type: TYPE_NORMAL
- en: 'for i in range(2, x // 2 + 1):'
  prefs: []
  type: TYPE_NORMAL
- en: 'if x % i == 0:'
  prefs: []
  type: TYPE_NORMAL
- en: numberOfDivisors += 1
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: print(numberOfDivisors)
  prefs: []
  type: TYPE_NORMAL
- en: This Python program performs less than half of the iterations that the previous
    program did! For example, for the input value 20, this Python program performs
    only (20 − 2)  DIV 2 = 9 iterations!
  prefs: []
  type: TYPE_NORMAL
- en: Exercise 29.5-5 Is the Number a Prime?
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Write a Python program that prompts the user to enter an integer greater than
    1 and then displays a message indicating if this number is a prime. A prime number
    is any integer greater than 1 that has no divisors other than 1 and itself. The
    numbers 7, 11, and 13 are all such numbers.
  prefs: []
  type: TYPE_NORMAL
- en: Solution
  prefs: []
  type: TYPE_NORMAL
- en: This exercise is based on the previous one. It is very simple! If the user-provided
    integer has only two divisors (1 and itself), the number is a prime. The Python
    program is as follows.
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/my_exercise_header.png) file_29.5-5a'
  prefs: []
  type: TYPE_NORMAL
- en: 'x = int(input("Enter an integer greater than 1: "))'
  prefs: []
  type: TYPE_NORMAL
- en: numberOfDivisors = 2
  prefs: []
  type: TYPE_NORMAL
- en: 'for i in range(2, x // 2 + 1):'
  prefs: []
  type: TYPE_NORMAL
- en: 'if x % i == 0:'
  prefs: []
  type: TYPE_NORMAL
- en: numberOfDivisors += 1
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: 'if numberOfDivisors == 2:'
  prefs: []
  type: TYPE_NORMAL
- en: print("Number", x, "is prime")
  prefs: []
  type: TYPE_NORMAL
- en: Now let's make the program more efficient. The flow of execution can break out
    of the loop when a third divisor is found, because this means that the user-provided
    integer is definitely not a prime. The Python program is as follows.
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/my_exercise_header.png) file_29.5-5b'
  prefs: []
  type: TYPE_NORMAL
- en: 'x = int(input("Enter an integer greater than 1: "))'
  prefs: []
  type: TYPE_NORMAL
- en: numberOfDivisors = 2
  prefs: []
  type: TYPE_NORMAL
- en: 'for i in range(2, x // 2 + 1):'
  prefs: []
  type: TYPE_NORMAL
- en: 'if x % i == 0:'
  prefs: []
  type: TYPE_NORMAL
- en: numberOfDivisors += 1
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: break
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: 'if numberOfDivisors == 2:'
  prefs: []
  type: TYPE_NORMAL
- en: print("Number", x, "is prime")
  prefs: []
  type: TYPE_NORMAL
- en: Exercise 29.5-6 Finding all Prime Numbers from 1 to N
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Write a Python program that prompts the user to enter an integer greater than
    1 and then displays all prime numbers from 1 to that user-provided integer. Using
    a loop control structure, the program must also validate data input and display
    an error message when the user enters any values less than 1.
  prefs: []
  type: TYPE_NORMAL
- en: Solution
  prefs: []
  type: TYPE_NORMAL
- en: The following Python program, given in general form, solves this exercise.
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/my_exercise_header.png) Main Code'
  prefs: []
  type: TYPE_NORMAL
- en: 'N = int(input("Enter an integer greater than 1: "))'
  prefs: []
  type: TYPE_NORMAL
- en: 'while N <= 1:'
  prefs: []
  type: TYPE_NORMAL
- en: 'N = int(input("Wrong number. Enter an integer greater than 1: "))'
  prefs: []
  type: TYPE_NORMAL
- en: 'for x in range(1, N + 1):'
  prefs: []
  type: TYPE_NORMAL
- en: 'Code Fragment 1: Check whether variable x contains a prime number'
  prefs: []
  type: TYPE_NORMAL
- en: Code Fragment 1, shown below, is taken from the previous exercise ([Exercise
    29.5-5](#toc_23)). It checks whether variable x contains a prime number.
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/my_exercise_header.png) Code Fragment 1'
  prefs: []
  type: TYPE_NORMAL
- en: numberOfDivisors = 2
  prefs: []
  type: TYPE_NORMAL
- en: 'for i in range(2, x // 2 + 1):'
  prefs: []
  type: TYPE_NORMAL
- en: 'if x % i == 0:'
  prefs: []
  type: TYPE_NORMAL
- en: numberOfDivisors += 1
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: break
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: 'if numberOfDivisors == 2:'
  prefs: []
  type: TYPE_NORMAL
- en: print("Number", x, "is prime")
  prefs: []
  type: TYPE_NORMAL
- en: After embedding Code Fragment 1 in Main Code, the final Python program becomes
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/my_exercise_header.png) file_29.5-6'
  prefs: []
  type: TYPE_NORMAL
- en: 'N = int(input("Enter an integer greater than 1: "))'
  prefs: []
  type: TYPE_NORMAL
- en: 'while N <= 1:'
  prefs: []
  type: TYPE_NORMAL
- en: 'N = int(input("Wrong number. Enter an integer greater than 1: "))'
  prefs: []
  type: TYPE_NORMAL
- en: 'for x in range(1, N + 1):'
  prefs: []
  type: TYPE_NORMAL
- en: numberOfDivisors = 2     [[More…]](more.html#more_29_5_6_1)
  prefs: []
  type: TYPE_NORMAL
- en: 'for i in range(2, x // 2 + 1):'
  prefs: []
  type: TYPE_NORMAL
- en: 'if x % i == 0:'
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: numberOfDivisors += 1
  prefs:
  - PREF_BQ
  - PREF_BQ
  type: TYPE_NORMAL
- en: break
  prefs:
  - PREF_BQ
  - PREF_BQ
  type: TYPE_NORMAL
- en: 'if numberOfDivisors == 2:'
  prefs: []
  type: TYPE_NORMAL
- en: print("Number", x, "is prime")
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: Exercise 29.5-7 Heron's Square Root
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Write a Python program that prompts the user to enter a non-negative value and
    then calculates its square root using Heron's formula, as follows.
  prefs: []
  type: TYPE_NORMAL
- en: .![Image](img/chapter11-01.png)
  prefs: []
  type: TYPE_NORMAL
- en: where
  prefs: []
  type: TYPE_NORMAL
- en: ►y is the number for which you want to find the square root
  prefs: []
  type: TYPE_NORMAL
- en: ►x[n] is the n-th iteration value of the square root of y
  prefs: []
  type: TYPE_NORMAL
- en: Moreover, using a loop control structure, the program must validate data input
    and display an error message when the user enters any negative values.
  prefs: []
  type: TYPE_NORMAL
- en: Solution
  prefs: []
  type: TYPE_NORMAL
- en: It is almost certain that you are a little bit confused and you are scratching
    your head right now. Don't get scared by all this math stuff! You can try to understand
    Heron's formula through the following flowchart instead!
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](img/chapter29-03.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Still confused? Let''s go through an example. Let''s try to find the square
    root of 25:'
  prefs: []
  type: TYPE_NORMAL
- en: ►Formulate a guess. Assume 8 as your first guess.
  prefs: []
  type: TYPE_NORMAL
- en: ►The square of 8 is 64.
  prefs: []
  type: TYPE_NORMAL
- en: ►Since 64 isn't “close enough” to 25, formulate a new guess by calculating the
    expression
  prefs: []
  type: TYPE_NORMAL
- en: .![Image](img/chapter29-04.png)
  prefs: []
  type: TYPE_NORMAL
- en: ►The square of 5.56 is about 30.91
  prefs: []
  type: TYPE_NORMAL
- en: ►Since 30.91 isn't “close enough” to 25, formulate a new guess by calculating
    the expression
  prefs: []
  type: TYPE_NORMAL
- en: .![Image](img/chapter29-05.png)
  prefs: []
  type: TYPE_NORMAL
- en: ►The square of 5.02 is 25.2
  prefs: []
  type: TYPE_NORMAL
- en: ►If you think that 25.2 is “close enough” to 25, then you can stop the whole
    process and conclude that the approximate square root of 25 is 5.02.
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/notice.jpg)Obviously, if greater precision is required, you have the
    option to continue the process until you find a value that is considered closer
    to the square root of 25.'
  prefs: []
  type: TYPE_NORMAL
- en: Now, let's see the corresponding Python program.
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/my_exercise_header.png) file_29.5-7'
  prefs: []
  type: TYPE_NORMAL
- en: from random import randrange
  prefs: []
  type: TYPE_NORMAL
- en: ACCURACY = 0.0000000000001
  prefs: []
  type: TYPE_NORMAL
- en: 'y = float(input("Enter a non-negative number: "))'
  prefs: []
  type: TYPE_NORMAL
- en: 'while y < 0:'
  prefs: []
  type: TYPE_NORMAL
- en: 'y = float(input("Invalid value. Enter a non-negative number: "))'
  prefs: []
  type: TYPE_NORMAL
- en: guess = randrange(1, y + 1)      #Make a random first guess between 1 and user-provided
    value
  prefs: []
  type: TYPE_NORMAL
- en: 'while abs(guess ** 2 - y) > ACCURACY:     #Is it "close enough"?'
  prefs: []
  type: TYPE_NORMAL
- en: guess = (guess + y / guess) / 2          #No, create a new "guess"!
  prefs: []
  type: TYPE_NORMAL
- en: print(guess)
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/notice.jpg)Note the way that “Is it close enough” is checked. When
    the absolute value of the difference |guess² - y| becomes less than 0.0000000000001
    (where y is the user-provided value), the flow of execution exits the loop.'
  prefs: []
  type: TYPE_NORMAL
- en: Exercise 29.5-8 Calculating π
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Write a Python program that calculates π using the Madhava–Leibniz^([[19]](footnotes.html#Endnote_19),[[20]](footnotes.html#Endnote_20))
    series, which follows, with an accuracy of 0.00001.
  prefs: []
  type: TYPE_NORMAL
- en: .![Image](img/chapter29-06.png)
  prefs: []
  type: TYPE_NORMAL
- en: Solution
  prefs: []
  type: TYPE_NORMAL
- en: The Madhava–Leibniz series can be solved for π, and becomes
  prefs: []
  type: TYPE_NORMAL
- en: .![Image](img/chapter29-07.png)
  prefs: []
  type: TYPE_NORMAL
- en: The more fractions you have, the better the accuracy! Thus, to calculate this
    formula the program needs to perform many iterations so as to use as many fractions
    as possible. But, of course, it can't iterate forever! The loop must actually
    stop iterating when the current calculated value of π and the one calculated in
    the previous iteration are ”close enough”, which means that the absolute value
    of their difference has become very small. The constant ACCURACY defines how small
    this difference must be. The Python program is shown here.
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/my_exercise_header.png) file_29.5-8'
  prefs: []
  type: TYPE_NORMAL
- en: ACCURACY = 0.00001
  prefs: []
  type: TYPE_NORMAL
- en: pi = 0
  prefs: []
  type: TYPE_NORMAL
- en: sign = 1    #This is the sign of the first fraction
  prefs: []
  type: TYPE_NORMAL
- en: 'denom = 1   #This is the denominator of the first fraction'
  prefs: []
  type: TYPE_NORMAL
- en: 'while True:'
  prefs: []
  type: TYPE_NORMAL
- en: 'piPrevious = pi   #Keep previous pi'
  prefs: []
  type: TYPE_NORMAL
- en: pi += sign * 4 / denom    #Calculate new pi by adding a fraction (a term)
  prefs: []
  type: TYPE_NORMAL
- en: 'sign = -sign   #Prepare sign for the next fraction'
  prefs: []
  type: TYPE_NORMAL
- en: 'denom += 2     #Prepare denominator for the next fraction'
  prefs: []
  type: TYPE_NORMAL
- en: 'if abs(pi - piPrevious) <= ACCURACY: break   #Is it "close enough"?'
  prefs: []
  type: TYPE_NORMAL
- en: print("Pi ~=", pi)
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/notice.jpg)Note the way in which variable sign toggles between the
    values −1 and +1 in each iteration.'
  prefs: []
  type: TYPE_NORMAL
- en: If you reduce the value of the constant ACCURACY, π will be calculated more
    and more accurately. Depending on how fast your computer is, you can calculate
    the first five digits of π fairly quickly. However, the time it takes to calculate
    each succeeding digit of π goes up exponentially. To calculate 40 digits of π
    on a modern computer using this method could take years!
  prefs: []
  type: TYPE_NORMAL
- en: Exercise 29.5-9 Approximating a Real with a Fraction
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Write a Python program that prompts the user to enter a real between 0 and 100
    and then tries to find the fraction ![Image](img/chapter29-08.png) that better
    approximates it, where N is an integer between 0 and 100 and M is an integer between
    1 and 100\. Using a loop control structure, the program must also validate data
    input, allowing the user to enter only values between 0 and 100\. There is no
    need to display any error messages.
  prefs: []
  type: TYPE_NORMAL
- en: Solution
  prefs: []
  type: TYPE_NORMAL
- en: The solution is simple. All you need to do is iterate through all possible combinations
    of variables n and m and check which one better approximates the user-provided
    real.
  prefs: []
  type: TYPE_NORMAL
- en: To iterate through all possible combinations of variables n and m, you can use
    a nested loop control structure, that is, two for-loops, one nested within the
    other, as follows.
  prefs: []
  type: TYPE_NORMAL
- en: 'for n in range(101):'
  prefs: []
  type: TYPE_NORMAL
- en: 'for m in range(1, 101):'
  prefs: []
  type: TYPE_NORMAL
- en: …
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '![](img/notice.jpg)The total number of iterations is 101 × 100 = 10100\. Quite
    a big number but, for a modern computer, this is peanuts!'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/notice.jpg)Variable m represents the denominator of the fraction, and
    a denominator cannot be zero. This is why it starts from 1, and not from 0.'
  prefs: []
  type: TYPE_NORMAL
- en: The following criteria
  prefs: []
  type: TYPE_NORMAL
- en: .![Image](img/chapter29-09.png)
  prefs: []
  type: TYPE_NORMAL
- en: can evaluate how “good” an approximation is.
  prefs: []
  type: TYPE_NORMAL
- en: Confused? Let's try to approximate the value 0.333 with a fraction, iterating
    through all possible combinations of N and M.
  prefs: []
  type: TYPE_NORMAL
- en: ►For N = 1, M = 1 the criteria equals to ![Image](img/chapter29-10.png) = 0.6670
  prefs: []
  type: TYPE_NORMAL
- en: ►For N = 1, M = 2 the criteria equals to ![Image](img/chapter29-11.png) = 0.1670
  prefs: []
  type: TYPE_NORMAL
- en: ►For N = 1, M = 3 the criteria equals to ![Image](img/chapter29-12.png) = 0.0003
  prefs: []
  type: TYPE_NORMAL
- en: ►For N = 1, M = 4 the criteria equals to ![Image](img/chapter29-13.png) = 0.0830
  prefs: []
  type: TYPE_NORMAL
- en: ►…
  prefs: []
  type: TYPE_NORMAL
- en: ►For N = 100, M = 99 the criteria equals to ![Image](img/chapter29-14.png) =
    0.6771
  prefs: []
  type: TYPE_NORMAL
- en: ►For N = 100, M = 100 the criteria equals to ![Image](img/chapter29-15.png)
    = 0.6670
  prefs: []
  type: TYPE_NORMAL
- en: It is obvious that the value 0.0003 is the minimum value among all possible
    results. Thus, the combination N = 1 and M = 3 (which corresponds to the fraction
    1/3) is considered the best approximation for the value 0.333.
  prefs: []
  type: TYPE_NORMAL
- en: 'And now the Python program:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/my_exercise_header.png) file_29.5-9'
  prefs: []
  type: TYPE_NORMAL
- en: 'while True:'
  prefs: []
  type: TYPE_NORMAL
- en: 'x = float(input("Enter a real between 0 and 100: "))'
  prefs: []
  type: TYPE_NORMAL
- en: 'if 0 <= x <= 100: break'
  prefs: []
  type: TYPE_NORMAL
- en: minimum = 100
  prefs: []
  type: TYPE_NORMAL
- en: 'for n in range(101):'
  prefs: []
  type: TYPE_NORMAL
- en: 'for m in range(1, 101):'
  prefs: []
  type: TYPE_NORMAL
- en: y = abs(n / m - x)
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: 'if y < minimum:'
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: minimum = y
  prefs:
  - PREF_BQ
  - PREF_BQ
  type: TYPE_NORMAL
- en: bestN = n
  prefs:
  - PREF_BQ
  - PREF_BQ
  type: TYPE_NORMAL
- en: bestM = m
  prefs:
  - PREF_BQ
  - PREF_BQ
  type: TYPE_NORMAL
- en: print("The fraction is:", bestN, "/", bestM)
  prefs: []
  type: TYPE_NORMAL
- en: 29.6 Exercises of a General Nature with Loop Control Structures
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Exercise 29.6-1 Fahrenheit to Kelvin, from 0 to 100
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Write a Python program that displays all degrees Fahrenheit from 0 to 100 and
    their equivalent degrees Kelvin. Use an increment value of 0.5\. It is given that
  prefs: []
  type: TYPE_NORMAL
- en: 1.8 · Kelvin = Fahrenheit + 459.67
  prefs: []
  type: TYPE_NORMAL
- en: Solution
  prefs: []
  type: TYPE_NORMAL
- en: The formula, solved for Kelvin becomes
  prefs: []
  type: TYPE_NORMAL
- en: .![Image](img/chapter29-16.png)
  prefs: []
  type: TYPE_NORMAL
- en: All you need here is a while-loop that increments the value of variable fahrenheit
    from 0 to 100 using an step of 0.5\. The solution is presented next.
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/my_exercise_header.png) file_29.6-1a'
  prefs: []
  type: TYPE_NORMAL
- en: fahrenheit = 0
  prefs: []
  type: TYPE_NORMAL
- en: 'while fahrenheit <= 100:'
  prefs: []
  type: TYPE_NORMAL
- en: kelvin = (fahrenheit + 459.67) / 1.8
  prefs: []
  type: TYPE_NORMAL
- en: print("Fahrenheit:", fahrenheit, "Kelvin:", kelvin)
  prefs: []
  type: TYPE_NORMAL
- en: fahrenheit += 0.5
  prefs: []
  type: TYPE_NORMAL
- en: Of course, you may now wonder if this exercise can be solved using a for-loop.
    One could say “No, this is impossible! The step in the range() function must be
    an integer!” However, there is an easy trick that you can do to solve this exercise
    with a for-loop, as shown here.
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/my_exercise_header.png) file_29.6-1b'
  prefs: []
  type: TYPE_NORMAL
- en: 'for f in range(0, 1001, 5):'
  prefs: []
  type: TYPE_NORMAL
- en: fahrenheit = f / 10
  prefs: []
  type: TYPE_NORMAL
- en: kelvin = (fahrenheit + 459.67) / 1.8
  prefs: []
  type: TYPE_NORMAL
- en: print("Fahrenheit:", fahrenheit, "Kelvin:", kelvin)
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/notice.jpg)Generally speaking, division and multiplication are CPU-time
    consuming operations. Though this second approach works well, it is not the best
    option. The statement fahrenheit = f / 10 included within the for-loop may look
    innocent, but actually it is not, because the division f / 10 is executed 1001
    times! It is like having a sequence control structure of 1001 statements that
    perform 1001 divisions! Try to avoid division and multiplication operations within
    loops as much as possible!'
  prefs: []
  type: TYPE_NORMAL
- en: Exercise 29.6-2 Rice on a Chessboard
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: There is a myth about a poor man who invented chess. The King of India was so
    pleased with that new game that he offered to give the poor man anything he wished
    for. The poor but wise man told his King that he would like one grain of rice
    for the first square of the board, two grains for the second, four grains for
    the third and so on, doubled for each of the 64 squares of the game board. This
    seemed to the King to be a modest request, so he ordered his servants to bring
    the rice.
  prefs: []
  type: TYPE_NORMAL
- en: Write a Python program that calculates and displays how many grains of rice,
    and how many pounds of rice, will be on the chessboard in the end. Suppose that
    one pound of rice contains about 30,000 grains of rice.
  prefs: []
  type: TYPE_NORMAL
- en: Solution
  prefs: []
  type: TYPE_NORMAL
- en: Assume a chessboard of only 2 × 2 = 4 squares and a variable grains assigned
    the initial value 1 (this is the number of grains of the 1^(st) square). A for-loop
    that iterates three times can double the value of variable grains in each iteration,
    as shown in the next code fragment.
  prefs: []
  type: TYPE_NORMAL
- en: grains = 1
  prefs: []
  type: TYPE_NORMAL
- en: 'for i in range(3):'
  prefs: []
  type: TYPE_NORMAL
- en: grains = 2 * grains
  prefs: []
  type: TYPE_NORMAL
- en: The value of variable grains at the end of each iteration is shown in the next
    table.
  prefs: []
  type: TYPE_NORMAL
- en: '| Iteration | Value of grains |'
  prefs: []
  type: TYPE_TB
- en: '| 1st | 2 × 1 = 2 |'
  prefs: []
  type: TYPE_TB
- en: '| 2nd | 2 × 2 = 4 |'
  prefs: []
  type: TYPE_TB
- en: '| 3rd | 2 × 4 = 8 |'
  prefs: []
  type: TYPE_TB
- en: At the end of the 3^(rd) iteration, variable grains contains the value 8\. This
    value is not the total number of grains on the chessboard but only the number
    of grains on the 4^(th) square. If you need to find the total number of grains
    on the chessboard you can sum up the grains on all squares, that is, 1 + 2 + 4
    + 8 = 15.
  prefs: []
  type: TYPE_NORMAL
- en: In the real world a real chessboard contains 8 × 8 = 64 squares, thus you need
    to iterate for 63 times. The Python program is as follows.
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/my_exercise_header.png) file_29.6-2'
  prefs: []
  type: TYPE_NORMAL
- en: grains = 1
  prefs: []
  type: TYPE_NORMAL
- en: total = 1
  prefs: []
  type: TYPE_NORMAL
- en: 'for i in range(63):'
  prefs: []
  type: TYPE_NORMAL
- en: grains = 2 * grains
  prefs: []
  type: TYPE_NORMAL
- en: total += grains  #This is equivalent to total = total + grains
  prefs: []
  type: TYPE_NORMAL
- en: weight = total / 30000
  prefs: []
  type: TYPE_NORMAL
- en: print(total, weight)
  prefs: []
  type: TYPE_NORMAL
- en: 'In case you are wondering how big these numbers are, here is your answer: On
    the chessboard there will be 18,446,744,073,709,551,615 grains of rice; that is,
    614,891,469,123,651.8 pounds!'
  prefs: []
  type: TYPE_NORMAL
- en: Exercise 29.6-3 Just a Poll
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: A public opinion polling company asks 1000 citizens if they eat breakfast in
    the morning. Write a Python program that prompts the citizens to enter their gender
    (M for Male, F for Female, O for Other) and their answer to the question (Y for
    Yes, N for No, S for Sometimes), and then calculates and displays the number of
    citizens that gave “Yes” as an answer, as well as the percentage of women among
    the citizens that gave “No” as an answer. Using a loop control structure, the
    program must also validate data input and accept only values M, F or O for gender
    and Y, N, or S for answer.
  prefs: []
  type: TYPE_NORMAL
- en: Solution
  prefs: []
  type: TYPE_NORMAL
- en: The Python program is as follows.
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/my_exercise_header.png) file_29.6-3a'
  prefs: []
  type: TYPE_NORMAL
- en: CITIZENS = 1000
  prefs: []
  type: TYPE_NORMAL
- en: totalYes = 0
  prefs: []
  type: TYPE_NORMAL
- en: femaleNo = 0
  prefs: []
  type: TYPE_NORMAL
- en: 'for i in range(CITIZENS):'
  prefs: []
  type: TYPE_NORMAL
- en: 'while True:'
  prefs: []
  type: TYPE_NORMAL
- en: 'gender = input("Enter gender: ").lower()'
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: 'if gender == "m" or gender == "f" or gender == "o": break'
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: 'while True:'
  prefs: []
  type: TYPE_NORMAL
- en: answer = input("Do you eat breakfast in the morning? ").lower()
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: 'if answer == "y" or answer == "n" or answer == "s": break'
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: 'if answer == "y":'
  prefs: []
  type: TYPE_NORMAL
- en: totalYes += 1
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: 'if gender == "f" and answer == "n":'
  prefs: []
  type: TYPE_NORMAL
- en: femaleNo += 1
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: print(totalYes)
  prefs: []
  type: TYPE_NORMAL
- en: print(femaleNo * 100 / CITIZENS, "%", sep = "")
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/notice.jpg)Note how Python converts the user''s input to lowercase.'
  prefs: []
  type: TYPE_NORMAL
- en: Of course, after a little refinement, this program can become
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/my_exercise_header.png) file_29.6-3b'
  prefs: []
  type: TYPE_NORMAL
- en: CITIZENS = 1000
  prefs: []
  type: TYPE_NORMAL
- en: totalYes = 0
  prefs: []
  type: TYPE_NORMAL
- en: femaleNo = 0
  prefs: []
  type: TYPE_NORMAL
- en: 'for i in range(CITIZENS):'
  prefs: []
  type: TYPE_NORMAL
- en: 'while True:'
  prefs: []
  type: TYPE_NORMAL
- en: 'gender = input("Enter gender: ").lower()'
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: 'if gender in ["m", "f", "o"]: break'
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: 'while True:'
  prefs: []
  type: TYPE_NORMAL
- en: answer = input("Do you eat breakfast in the morning? ").lower()
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: 'if answer in ["y", "n", "s"]: break'
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: 'if answer == "y":'
  prefs: []
  type: TYPE_NORMAL
- en: totalYes += 1
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: 'elif gender == "f":'
  prefs: []
  type: TYPE_NORMAL
- en: femaleNo += 1
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: print(totalYes)
  prefs: []
  type: TYPE_NORMAL
- en: print(femaleNo * 100 / CITIZENS, "%", sep = "")
  prefs: []
  type: TYPE_NORMAL
- en: Exercise 29.6-4 Is the Message a Palindrome?
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: A palindrome is a word or sentence that reads the same both backwards and forward.
    (You may recall from [Exercise 22.5-4](chapter22.html#toc_26) that a number can
    also be a palindrome). Write a Python program that prompts the user to enter a
    word or sentence and then displays a message stating whether or not the user-provided
    word or sentence is a palindrome. Following are some palindrome words and messages.
  prefs: []
  type: TYPE_NORMAL
- en: ►Anna
  prefs: []
  type: TYPE_NORMAL
- en: ►Radar
  prefs: []
  type: TYPE_NORMAL
- en: ►Madam
  prefs: []
  type: TYPE_NORMAL
- en: ►A nut for a jar of tuna.
  prefs: []
  type: TYPE_NORMAL
- en: ►Dennis and Edna sinned.
  prefs: []
  type: TYPE_NORMAL
- en: ►Murder for a jar of red rum.
  prefs: []
  type: TYPE_NORMAL
- en: ►Borrow or rob?
  prefs: []
  type: TYPE_NORMAL
- en: ►Are we not drawn onward, we few, drawn onward to new era?
  prefs: []
  type: TYPE_NORMAL
- en: Solution
  prefs: []
  type: TYPE_NORMAL
- en: There are some things you should keep in mind before starting to compare the
    letters one by one and checking whether the first letter is the same as the last
    one, the second letter is the same as the last but one, and so forth.
  prefs: []
  type: TYPE_NORMAL
- en: ►In a given sentence or word, some letters may be in uppercase and some in lowercase.
    For example, in the sentence “A nut for a jar of tuna”, even though the first
    and last letters are the same, they are not considered equal. Thus, the program
    must first convert all the letters—for example, to lowercase—before it can start
    comparing them.
  prefs: []
  type: TYPE_NORMAL
- en: ►Removing characters like spaces, periods, question marks, and commas is crucial
    for the program to accurately compare the letters. For example, without this step,
    in the sentence “Borrow or rob?” the program will mistakenly assume it's not a
    palindrome, as it would attempt to compare the initial “B” with the final question
    mark “?”.
  prefs: []
  type: TYPE_NORMAL
- en: '►Assume that the examined sentence is “Borrow or rob?”. After changing all
    letters to lowercase and after removing all unwanted spaces and the question mark,
    the sentence becomes “borroworrob”. These letters and their corresponding position
    in the string are as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](img/chapter29-17.png)'
  prefs: []
  type: TYPE_IMG
- en: What you should realize here is that the for-loop should iterate for only half
    of the letters. Can you figure out why?
  prefs: []
  type: TYPE_NORMAL
- en: The program should start the iterations and compare the letter at position 0
    with the letter at position 10\. Then it should compare the letter at position
    1 with the letter at position 9, and so forth. The last iteration should be the
    one that compares the letters at positions 4 and 6\. It would be pointless to
    continue checking thereafter, since all letters have already been compared.
  prefs: []
  type: TYPE_NORMAL
- en: There are many solutions to this problem. Some of them are presented below.
    Comments written within the programs can help you fully understand the way they
    operate. However, if you still have doubts about how they operate you can use
    an IDE (IDLE or Visual Studio Code) to execute them step by step and observe the
    values of the variables in each step.
  prefs: []
  type: TYPE_NORMAL
- en: First approach
  prefs: []
  type: TYPE_NORMAL
- en: The solution is presented here.
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/my_exercise_header.png) file_29.6-4a'
  prefs: []
  type: TYPE_NORMAL
- en: 'message = input("Enter a message: ").lower()'
  prefs: []
  type: TYPE_NORMAL
- en: '#Create a new string which contains all except spaces, commas, periods, and
    question marks'
  prefs: []
  type: TYPE_NORMAL
- en: messageClean = ""
  prefs: []
  type: TYPE_NORMAL
- en: 'for letter in message:'
  prefs: []
  type: TYPE_NORMAL
- en: 'if letter != " " and letter != "," and letter != "." and letter != "?":'
  prefs: []
  type: TYPE_NORMAL
- en: messageClean += letter
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: j = len(messageClean) – 1  #This is the last position of messageClean
  prefs: []
  type: TYPE_NORMAL
- en: 'middlePos = j // 2         #This is the middle position of messageClean'
  prefs: []
  type: TYPE_NORMAL
- en: palindrome = True  #In the beginning, assume that sentence is palindrome
  prefs: []
  type: TYPE_NORMAL
- en: '#This for-loop compares letters one by one.'
  prefs: []
  type: TYPE_NORMAL
- en: 'for i in range(middlePos + 1):'
  prefs: []
  type: TYPE_NORMAL
- en: leftLetter = messageClean[i]
  prefs: []
  type: TYPE_NORMAL
- en: rightLetter = messageClean[j]
  prefs: []
  type: TYPE_NORMAL
- en: '#If at least one pair of letters fails to validate set variable palindrome
    to False'
  prefs: []
  type: TYPE_NORMAL
- en: 'if leftLetter != rightLetter:'
  prefs: []
  type: TYPE_NORMAL
- en: palindrome = False
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: j -= 1
  prefs: []
  type: TYPE_NORMAL
- en: '#If variable palindrome is still True'
  prefs: []
  type: TYPE_NORMAL
- en: 'if palindrome:'
  prefs: []
  type: TYPE_NORMAL
- en: print("The message is palindrome")
  prefs: []
  type: TYPE_NORMAL
- en: Second approach
  prefs: []
  type: TYPE_NORMAL
- en: The previous approach works fine, but let's assume that the user enters a very
    large sentence that is not a palindrome; for example, its second letter is not
    the same as the last but one. Unfortunately, in the previous approach, the last
    for-loop continues to iterate until the middle of the sentence despite the fact
    that the variable palindrome has been set to False, even from the second iteration.
    So, let's try to make this program even better. As you already know, you can break
    out of a loop before it completes all of its iterations using the break statement.
  prefs: []
  type: TYPE_NORMAL
- en: 'Furthermore, you can improve the previous approach in two ways:'
  prefs: []
  type: TYPE_NORMAL
- en: ►You can remove spaces, commas, periods, and question marks from the variable
    message, using the not in membership operator.
  prefs: []
  type: TYPE_NORMAL
- en: ►Instead of using the variable j to access the letters of variable messageClean
    on the right, you can use negative indexes.
  prefs: []
  type: TYPE_NORMAL
- en: The solution is shown here.
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/my_exercise_header.png) file_29.6-4b'
  prefs: []
  type: TYPE_NORMAL
- en: 'message = input("Enter a message: ").lower()'
  prefs: []
  type: TYPE_NORMAL
- en: '#Remove spaces, commas, periods and question marks using the "not in" membership
    operator'
  prefs: []
  type: TYPE_NORMAL
- en: messageClean = ""
  prefs: []
  type: TYPE_NORMAL
- en: 'for letter in message:'
  prefs: []
  type: TYPE_NORMAL
- en: 'if letter not in " ,.?":'
  prefs: []
  type: TYPE_NORMAL
- en: messageClean += letter
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: middlePos = (len(messageClean) - 1) // 2
  prefs: []
  type: TYPE_NORMAL
- en: palindrome = True
  prefs: []
  type: TYPE_NORMAL
- en: 'for i in range(middlePos + 1):'
  prefs: []
  type: TYPE_NORMAL
- en: 'if messageClean[i] != messageClean[-i - 1]:  #Right letter uses negative index'
  prefs: []
  type: TYPE_NORMAL
- en: palindrome = False
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: break
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: 'if palindrome:'
  prefs: []
  type: TYPE_NORMAL
- en: print("The message is palindrome")
  prefs: []
  type: TYPE_NORMAL
- en: Third approach
  prefs: []
  type: TYPE_NORMAL
- en: A more Pythonic and sophisticated way is to remove spaces, commas, periods,
    and question marks using the replace() method, and then just compare messageClean
    to its reversed value.
  prefs: []
  type: TYPE_NORMAL
- en: The solution is shown here.
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/my_exercise_header.png) file_29.6-4c'
  prefs: []
  type: TYPE_NORMAL
- en: 'message = input("Enter a message: ").lower()'
  prefs: []
  type: TYPE_NORMAL
- en: '#Create a new string which contains letters without spaces, commas, periods
    or question marks'
  prefs: []
  type: TYPE_NORMAL
- en: messageClean = message
  prefs: []
  type: TYPE_NORMAL
- en: 'for c in " ,.?":'
  prefs: []
  type: TYPE_NORMAL
- en: messageClean = messageClean.replace(c, "")
  prefs: []
  type: TYPE_NORMAL
- en: 'if messageClean == messageClean[::-1]:'
  prefs: []
  type: TYPE_NORMAL
- en: print("The message is palindrome")
  prefs: []
  type: TYPE_NORMAL
- en: Furthermore, since there are just four different characters that must be removed
    (spaces, commas, periods, and question marks) you can avoid the first loop if
    you just chain four replace() methods, as shown in the Python program that follows.
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/my_exercise_header.png) file_29.6-4d'
  prefs: []
  type: TYPE_NORMAL
- en: 'message = input("Enter a message: ").lower()'
  prefs: []
  type: TYPE_NORMAL
- en: '#Create a new string which contains letters without spaces, commas, periods
    or question marks'
  prefs: []
  type: TYPE_NORMAL
- en: messageClean = message.replace(" ", "").replace(",", "").replace(".", "").replace("?",
    "")
  prefs: []
  type: TYPE_NORMAL
- en: 'if messageClean == messageClean[::-1]:'
  prefs: []
  type: TYPE_NORMAL
- en: print("The message is palindrome")
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/notice.jpg)It is obvious that one problem can have many solutions.
    It is up to you to find the optimal one!'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/notice.jpg)If you wish to remove all the unwanted characters (spaces,
    commas, periods, question marks, ampersands, etc.), you can use the following
    code fragment instead. It keeps only the letters in the variable messageClean!'
  prefs: []
  type: TYPE_NORMAL
- en: '#Create a new string which contains only letters'
  prefs: []
  type: TYPE_NORMAL
- en: messageClean = ""
  prefs: []
  type: TYPE_NORMAL
- en: validChars = "abcdefghijklmnopqrstuvwxyz"
  prefs: []
  type: TYPE_NORMAL
- en: 'for char in message:'
  prefs: []
  type: TYPE_NORMAL
- en: 'if char in validChars:'
  prefs: []
  type: TYPE_NORMAL
- en: 'messageClean += char   #Concatenation'
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '29.7 Review Questions: True/False'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Choose true or false for each of the following statements.
  prefs: []
  type: TYPE_NORMAL
- en: 1)Data validation is the process of restricting data input, forcing the user
    to enter only valid values.
  prefs: []
  type: TYPE_NORMAL
- en: 2)You can use a definite loop to validate data input.
  prefs: []
  type: TYPE_NORMAL
- en: 3)To force a user to enter only positive numbers, without displaying any error
    messages, you can use the following code fragment.
  prefs: []
  type: TYPE_NORMAL
- en: 'while True:'
  prefs: []
  type: TYPE_NORMAL
- en: 'x = float(input("Enter a positive number: "))'
  prefs: []
  type: TYPE_NORMAL
- en: 'if x > 0: break'
  prefs: []
  type: TYPE_NORMAL
- en: 4)To force a user to enter numbers between 1 and 10, you can use the following
    code fragment.
  prefs: []
  type: TYPE_NORMAL
- en: 'x = float(input("Enter a number between 1 and 10: "))'
  prefs: []
  type: TYPE_NORMAL
- en: 'while x >= 1 and x <= 10:'
  prefs: []
  type: TYPE_NORMAL
- en: print("Wrong number")
  prefs: []
  type: TYPE_NORMAL
- en: 'x = float(input("Enter a number between 1 and 10: "))'
  prefs: []
  type: TYPE_NORMAL
- en: 5)In order to find the lowest number among 10 user-provided numbers, you can
    use the following code fragment.
  prefs: []
  type: TYPE_NORMAL
- en: minimum = 0
  prefs: []
  type: TYPE_NORMAL
- en: 'for i in range(10):'
  prefs: []
  type: TYPE_NORMAL
- en: w = float(input())
  prefs: []
  type: TYPE_NORMAL
- en: 'if w < minimum: minimum = w'
  prefs: []
  type: TYPE_NORMAL
- en: 6)In order to find the highest number among 10 user-provided numbers, you can
    use the following code fragment.
  prefs: []
  type: TYPE_NORMAL
- en: maximum = 0
  prefs: []
  type: TYPE_NORMAL
- en: 'for i in range(10):'
  prefs: []
  type: TYPE_NORMAL
- en: w = float(input())
  prefs: []
  type: TYPE_NORMAL
- en: 'if w > maximum: maximum = w'
  prefs: []
  type: TYPE_NORMAL
- en: 7)In order to find the highest number among 10 positive user-provided numbers,
    you can use the following code fragment.
  prefs: []
  type: TYPE_NORMAL
- en: maximum = 0
  prefs: []
  type: TYPE_NORMAL
- en: 'for i in range(10):'
  prefs: []
  type: TYPE_NORMAL
- en: w = float(input())
  prefs: []
  type: TYPE_NORMAL
- en: 'if w > maximum: maximum = w'
  prefs: []
  type: TYPE_NORMAL
- en: 29.8 Review Exercises
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Complete the following exercises.
  prefs: []
  type: TYPE_NORMAL
- en: 1)Design a flowchart and write the corresponding Python program that prompts
    the user to repeatedly enter non-negative values until their average value exceeds
    3000\. At the end, the program must display the total number of zeros entered.
  prefs: []
  type: TYPE_NORMAL
- en: 2)Write a Python program that prompts the user to enter an integer between 1
    and 20 and then displays all four-digit integers for which the sum of their digits
    is less than the user-provided integer. For example, if the user enters 15, the
    value 9301 is such a number, since
  prefs: []
  type: TYPE_NORMAL
- en: 9 + 3 + 0 + 1 < 15
  prefs: []
  type: TYPE_NORMAL
- en: '3)Write a Python program that displays all four-digit integers that satisfy
    all of the following conditions:'
  prefs: []
  type: TYPE_NORMAL
- en: ►the number's first digit is greater than its second digit
  prefs: []
  type: TYPE_NORMAL
- en: ►the number's second digit is equal to its third digit
  prefs: []
  type: TYPE_NORMAL
- en: ►the number's third digit is smaller than its fourth digit
  prefs: []
  type: TYPE_NORMAL
- en: For example, the values 7559, 3112, and 9889 are such numbers.
  prefs: []
  type: TYPE_NORMAL
- en: 4)Write a Python program that prompts the user to enter an integer and then
    displays the number of its digits.
  prefs: []
  type: TYPE_NORMAL
- en: 5)A student wrote the following code fragment which is supposed to validate
    data input, forcing the user to enter only values 0 and 1\. Identify any error(s)
    in the code fragment.
  prefs: []
  type: TYPE_NORMAL
- en: 'while x != 1 or x != 0:'
  prefs: []
  type: TYPE_NORMAL
- en: print("Error")
  prefs: []
  type: TYPE_NORMAL
- en: x = int(input())
  prefs: []
  type: TYPE_NORMAL
- en: 6)Using a loop control structure, write the code fragment that validates data
    input, forcing the user to enter a valid gender (M for Male, F for Female, O for
    Other). Moreover, it must validate correctly both for lowercase and uppercase
    letters.
  prefs: []
  type: TYPE_NORMAL
- en: 7)Write a Python program that prompts the user to enter a non-negative number
    and then calculates its square root. Using a loop control structure, the program
    must also validate data input and display an error message when the user enters
    any negative values. Additionally, the user has a maximum number of two retries.
    If the user enters more than three negative values, a message “Dude, you are dumb!”
    must be displayed and the program execution must end.
  prefs: []
  type: TYPE_NORMAL
- en: '8)The area of a circle can be calculated using the following formula:'
  prefs: []
  type: TYPE_NORMAL
- en: Area = π∙Radius²
  prefs: []
  type: TYPE_NORMAL
- en: Write a Python program that prompts the user to enter the length of the radius
    of a circle and then calculates and displays its area. The program must iterate
    as many times as the user wishes. At the end of each area calculation, the program
    must ask the user if they wish to calculate the area of another circle. If the
    answer is “yes” the program must repeat; it must end otherwise. Make your program
    accept the answer in all possible forms such as “yes”, “YES”, “Yes”, or even “YeS”.
  prefs: []
  type: TYPE_NORMAL
- en: Moreover, using a loop control structure, the program must validate data input
    and display an error message when the user enters any non-positive value for Radius.
  prefs: []
  type: TYPE_NORMAL
- en: 'Hint: Use the pi from the math module to get the value of π.'
  prefs: []
  type: TYPE_NORMAL
- en: 9)Write a Python program that prompts the user to enter the daily temperatures
    (in degrees Fahrenheit) recorded at the same hour each day in August and then
    calculates and displays the average as well as the highest temperature.
  prefs: []
  type: TYPE_NORMAL
- en: Since −459.67^o (on the Fahrenheit scale) is the lowest temperature possible
    (it is called absolute zero), using a loop control structure, the program must
    also validate data input and display an error message when the user enters a value
    lower than absolute zero.
  prefs: []
  type: TYPE_NORMAL
- en: 10)A scientist needs a software application to record the level of the sea based
    on values logged at specific times (HH:MM), in order to extract some useful information.
    Write a Python program that lets the scientist enter the sea level, along with
    the hour and minutes, repeatedly until the value 9999 is entered for the sea level.
    Then, the program must display both the highest and the lowest recorded sea levels,
    along with the corresponding hour and minutes at which these levels were recorded.
  prefs: []
  type: TYPE_NORMAL
- en: 11)In some countries, when someone sneezes, a number (an integer) is said aloud
    by another person. The sneezing person then adds up the digits of this number
    until they obtain a number between 1 and 26\. The letter corresponding to this
    number (1 for “A”, 2 for “B”, and so on) represents the first letter of the name
    of someone who might be thinking of them.
  prefs: []
  type: TYPE_NORMAL
- en: Write a Python program that prompts the user to enter the number said after
    the sneeze. It must then sum up the digits of the number until a number between
    1 and 26 is obtained, and display the corresponding letter in the English alphabet.
  prefs: []
  type: TYPE_NORMAL
- en: '12)Write a Python program that displays all possible integer values of x and
    y within the range −100 to +100 that validate the following formula:'
  prefs: []
  type: TYPE_NORMAL
- en: 5x + 3y² = 0
  prefs: []
  type: TYPE_NORMAL
- en: '13)Write a Python program that displays all possible integer values of x, y,
    and z within the range −10 to +10 that validate the following formula:'
  prefs: []
  type: TYPE_NORMAL
- en: .![Image](img/chapter29-18.png)
  prefs: []
  type: TYPE_NORMAL
- en: 14)Write a Python program that lets the user enter three positive integers and
    then finds their product using the Russian multiplication algorithm.
  prefs: []
  type: TYPE_NORMAL
- en: 15)Rewrite the Python program of [Exercise 29.5-4](#toc_22) to validate the
    data input using a loop control structure. If the user enters a non-positive integer,
    an error message must be displayed.
  prefs: []
  type: TYPE_NORMAL
- en: 16)Rewrite the Python program of [Exercise 29.5-5](#toc_23) to validate the
    data input using a loop control structure. If the user enters an integer less
    than or equal to 1, an error message must be displayed.
  prefs: []
  type: TYPE_NORMAL
- en: 17)Write a Python program that prompts the user to enter two positive integers
    into variables start and finish. The program must then find and display all Pythagorean
    triples (x, y, z) where x, y, and z are integers between start and finish such
    that x² + y² = z².
  prefs: []
  type: TYPE_NORMAL
- en: 'Hint: To make your program operate correctly, independent of which user-provided
    integer is the lowest, you can swap their values (if necessary) so that they are
    always in the proper order.'
  prefs: []
  type: TYPE_NORMAL
- en: 18)Write a Python program that prompts the user to enter two positive integers
    and then displays all prime integers between them. Using a loop control structure,
    the program must also validate data input and display an error message when the
    user enters a value less than +2.
  prefs: []
  type: TYPE_NORMAL
- en: 'Hint: To make your program operate correctly, independent of which user-provided
    integer is the lowest, you can swap their values (if necessary) so that they are
    always in the proper order.'
  prefs: []
  type: TYPE_NORMAL
- en: 19)A perfect number is a positive integer that is equal to the sum of its positive
    divisors, excluding the number itself. For example, the divisors of 6 are 1, 2,
    and 3 (excluding 6 itself), and 1 + 2 + 3 = 6, making 6 a perfect number. Write
    a Python program that prompts the user to enter a positive integer and displays
    a message indicating whether or not the number is perfect. Using a loop control
    structure, the program must also validate data input and display an error message
    when the user enters a non-positive integer.
  prefs: []
  type: TYPE_NORMAL
- en: 20)Write a Python program that prompts the user to enter two positive integers
    and then displays all perfect numbers between them. Using a loop control structure,
    the program must also validate data input and display an error message when the
    user enters a non-positive integer.
  prefs: []
  type: TYPE_NORMAL
- en: 'Hint: To make your program operate correctly, independent of which user-provided
    integer is the lowest, you can swap their values (if necessary) so that they are
    always in the proper order.'
  prefs: []
  type: TYPE_NORMAL
- en: 21)Write a Python program that prompts the user to enter two positive four-digit
    integers and then displays all integers between them that are palindromes. Using
    a loop control structure, the program must also validate data input and display
    an error message when the user enters any numbers other than four-digit ones.
  prefs: []
  type: TYPE_NORMAL
- en: 'Hint: To make your Python program operate correctly, independent of which user-provided
    integer is the lowest, you can swap their values (if necessary) so that they are
    always in the proper order.'
  prefs: []
  type: TYPE_NORMAL
- en: 22)Write a Python program that displays all possible RAM sizes between 1 byte
    and 1GByte, such as 1, 2, 4, 8, 16, 32, 64, 128, and so on.
  prefs: []
  type: TYPE_NORMAL
- en: 'Hint: 1GByte equals 2^(30) bytes, or 1073741824 bytes'
  prefs: []
  type: TYPE_NORMAL
- en: '23)Write a Python program that displays the following sequence of numbers:'
  prefs: []
  type: TYPE_NORMAL
- en: 1, 11, 23, 37, 53, 71, 91, 113, 137, … 401
  prefs: []
  type: TYPE_NORMAL
- en: '24)Write a Python program that displays the following sequence of numbers:'
  prefs: []
  type: TYPE_NORMAL
- en: −1, 1, −2, 2, −3, 3, −4, 4, … −100, 100
  prefs: []
  type: TYPE_NORMAL
- en: '25)Write a Python program that displays the following sequence of numbers:'
  prefs: []
  type: TYPE_NORMAL
- en: 1, 11, 111, 1111, 11111, … 11111111
  prefs: []
  type: TYPE_NORMAL
- en: '26)The Fibonacci^([[21]](footnotes.html#Endnote_21)) sequence is a series of
    numbers in the following sequence:'
  prefs: []
  type: TYPE_NORMAL
- en: 0, 1, 1, 2, 3, 5, 8, 13, 21, 34, 55, …
  prefs: []
  type: TYPE_NORMAL
- en: By definition, the first two terms are 0 and 1 and each subsequent term is the
    sum of the previous two.
  prefs: []
  type: TYPE_NORMAL
- en: Write a Python program that lets the user enter a positive integer and then
    displays as many Fibonacci terms as that user-provided integer.
  prefs: []
  type: TYPE_NORMAL
- en: 27)Write a Python program that lets the user enter a positive integer and then
    displays all Fibonacci terms that are less than that user-provided integer.
  prefs: []
  type: TYPE_NORMAL
- en: '28)Write a Python program that prompts the user to enter a positive integer
    N and then finds and displays the value of y in the following formula:'
  prefs: []
  type: TYPE_NORMAL
- en: .![Image](img/chapter29-19.png)
  prefs: []
  type: TYPE_NORMAL
- en: Moreover, using a loop control structure, the program must validate data input
    and display an error message when the user enters a value less than 1.
  prefs: []
  type: TYPE_NORMAL
- en: 29)Write a Python program that prompts the user to enter a positive integer
    N and then finds and displays the value of y in the following formula
  prefs: []
  type: TYPE_NORMAL
- en: .![Image](img/chapter29-20.png)
  prefs: []
  type: TYPE_NORMAL
- en: Moreover, using a loop control structure, the program must validate data input
    and display an error message when the user enters a non-positive value.
  prefs: []
  type: TYPE_NORMAL
- en: '30)Write a Python program that prompts the user to enter an integer N greater
    than 2 and then finds and displays the value of y in the following formula:'
  prefs: []
  type: TYPE_NORMAL
- en: .![Image](img/chapter29-21.png)
  prefs: []
  type: TYPE_NORMAL
- en: Moreover, using a loop control structure, the program must validate data input
    and display an error message when the user enters a value that is less than or
    equal to 2.
  prefs: []
  type: TYPE_NORMAL
- en: 'Hint: Note that beyond the term 1 / 3 the subsequent denominators increment
    by 2.'
  prefs: []
  type: TYPE_NORMAL
- en: '31)Write a Python program that prompts the user to enter a positive integer
    N and then finds and displays the value of y in the following formula:'
  prefs: []
  type: TYPE_NORMAL
- en: .![Image](img/chapter29-22.png)
  prefs: []
  type: TYPE_NORMAL
- en: Moreover, using a loop control structure, the program must validate data input
    and display an error message when the user enters a non-positive value.
  prefs: []
  type: TYPE_NORMAL
- en: 32)In mathematics, the factorial of a non-negative integer N is the product
    of all positive integers less than or equal to N, and it is denoted by N! The
    factorial of 0 is, by definition, equal to 1\. In mathematics, you can write
  prefs: []
  type: TYPE_NORMAL
- en: .![Image](img/chapter29-23.png)
  prefs: []
  type: TYPE_NORMAL
- en: For example, the factorial of 5 is written as 5! and is equal to 1 × 2 × 3 ×
    4 × 5 = 120.
  prefs: []
  type: TYPE_NORMAL
- en: Write a Python program that prompts the user to enter a non-negative integer
    N and then calculates its factorial.
  prefs: []
  type: TYPE_NORMAL
- en: 33)Write a Python program that lets the user enter a value for x and then calculates
    and displays the exponential function e^x using the Taylor^([[22]](footnotes.html#Endnote_22))
    series, shown next, with an accuracy of 0.00001.
  prefs: []
  type: TYPE_NORMAL
- en: .![Image](img/chapter29-24.png)
  prefs: []
  type: TYPE_NORMAL
- en: 'Hint: Keep in mind that ![Image](img/chapter29-25.png).'
  prefs: []
  type: TYPE_NORMAL
- en: 34)Write a Python program that lets the user enter a value for x and then calculates
    and displays the sine of x using the Taylor series, shown next, with an accuracy
    of 0.00001.
  prefs: []
  type: TYPE_NORMAL
- en: .![Image](img/chapter29-26.png)
  prefs: []
  type: TYPE_NORMAL
- en: 'Hint: Keep in mind that x is in radians and ![Image](img/chapter29-27.png).'
  prefs: []
  type: TYPE_NORMAL
- en: 35)Write a Python program that lets the user enter a value for x and then calculates
    and displays the cosine of x using the Taylor series, shown next, with an accuracy
    of 0.00001.
  prefs: []
  type: TYPE_NORMAL
- en: .![Image](img/chapter29-28.png)
  prefs: []
  type: TYPE_NORMAL
- en: 'Hint: Keep in mind that x is in radians and ![Image](img/chapter29-25.png).'
  prefs: []
  type: TYPE_NORMAL
- en: 36)Suppose that the letter A corresponds to the number 1, the letter B corresponds
    to the number 2, and so on. Write a Python program that prompts the user to enter
    two integers and then displays all alphabet letters that exist between them. For
    example, if the user enters 3 and 6, the program must display C, D, E, F. Using
    a loop control structure, the program must also validate data input and display
    a different error message for each type of input error when the user enters any
    negative, or any value greater than 26.
  prefs: []
  type: TYPE_NORMAL
- en: 'Hint: To make your Python program operate correctly, independent of which user-provided
    integer is the lowest, you can swap their values (if necessary) so that they are
    always in the proper order.'
  prefs: []
  type: TYPE_NORMAL
- en: 37)Write a Python program that randomly selects an integer between 1 and 100
    and assigns it to a variable. The program must then prompt the user to guess the
    number. If the user's guess is smaller than the secret number, the message “Your
    guess is smaller than my secret number. Try again!” must be displayed. If the
    user's guess is greater than the secret number, the message “Your guess is bigger
    than my secret number. Try again!” must be displayed. This process must repeat
    until the user correctly guesses the secret number. Once the user guesses correctly,
    the message “You found it!” must be displayed, along with the total number of
    attempts made by the user.
  prefs: []
  type: TYPE_NORMAL
- en: 38)Expand the previous exercise/game by making it operate for two players. The
    player that wins is the one that finds the random secret number in fewer attempts.
  prefs: []
  type: TYPE_NORMAL
- en: '39)The size of a TV screen always refers to its diagonal measurement. For example,
    a 40-inch TV screen is 40 inches diagonally, from one corner on top to the other
    corner on bottom. The old TV screens had a width-to-height aspect ratio of 4:3,
    which means that for every 3 inches in TV screen height, there were 4 inches in
    TV screen width. Today, most TV screens have a width-to-height aspect ratio of
    16:9, which means that for every 9 inches in TV screen height there are 16 inches
    in TV screen width. Using these aspect ratios and the Pythagorean Theorem, you
    can easily determine that:'
  prefs: []
  type: TYPE_NORMAL
- en: ►for all 4:3 TV screens
  prefs: []
  type: TYPE_NORMAL
- en: Width = Diagonal × 0.8
  prefs: []
  type: TYPE_NORMAL
- en: Height = Diagonal × 0.6
  prefs: []
  type: TYPE_NORMAL
- en: ►for all 16:9 TV screens
  prefs: []
  type: TYPE_NORMAL
- en: Width = Diagonal × 0.87
  prefs: []
  type: TYPE_NORMAL
- en: Height = Diagonal × 0.49
  prefs: []
  type: TYPE_NORMAL
- en: 'Write a Python program that displays the following menu:'
  prefs: []
  type: TYPE_NORMAL
- en: 1)4/3 TV Screen
  prefs: []
  type: TYPE_NORMAL
- en: 2)16/9 TV Screen
  prefs: []
  type: TYPE_NORMAL
- en: 3)Exit
  prefs: []
  type: TYPE_NORMAL
- en: and prompts the user to enter a choice (of 1, 2, or 3) as well as the diagonal
    screen size in inches. Then, the Python program must display the width and the
    height of the TV screen. This process must continue repeatedly, until the user
    selects choice 3 (Exit) from the menu.
  prefs: []
  type: TYPE_NORMAL
- en: '40)Write a Python program that prompts a teacher to enter the total number
    of students, their grades, and their gender (M for Male, F for Female, O for Other),
    and then calculates and displays all of the following:'
  prefs: []
  type: TYPE_NORMAL
- en: a)the average value of those who got an “A” (90 ‐ 100)
  prefs: []
  type: TYPE_NORMAL
- en: b)the average value of those who got a “B” (80 ‐ 89)
  prefs: []
  type: TYPE_NORMAL
- en: c)the average value of boys who got an “A” (90 ‐ 100)
  prefs: []
  type: TYPE_NORMAL
- en: d)the total number of girls that got less than “B”
  prefs: []
  type: TYPE_NORMAL
- en: e)the highest and lowest grade
  prefs: []
  type: TYPE_NORMAL
- en: f)the average grade of the whole class
  prefs: []
  type: TYPE_NORMAL
- en: 'Add all necessary checks to make the program satisfy the property of definiteness.
    Moreover, using a loop control structure, the program must validate data input
    and display an error message when the teacher enters any of the following:'
  prefs: []
  type: TYPE_NORMAL
- en: ►non-positive values for total number of students
  prefs: []
  type: TYPE_NORMAL
- en: ►negatives, or values greater than 100 for student grades
  prefs: []
  type: TYPE_NORMAL
- en: ►values other than M, F, or O for gender
  prefs: []
  type: TYPE_NORMAL
- en: 41)Write a Python program that calculates and displays the discount that a customer
    receives based on the amount of their order, according to the following table.
  prefs: []
  type: TYPE_NORMAL
- en: '| Amount | Discount |'
  prefs: []
  type: TYPE_TB
- en: '| $0 < amount < $20 | 0% |'
  prefs: []
  type: TYPE_TB
- en: '| $20 ≤ amount < $50 | 3% |'
  prefs: []
  type: TYPE_TB
- en: '| $50 ≤ amount < $100 | 5% |'
  prefs: []
  type: TYPE_TB
- en: '| $100 ≤ amount | 10% |'
  prefs: []
  type: TYPE_TB
- en: At the end of each discount calculation, the program must ask the user if they
    wish to calculate the discount of another amount. If the answer is “yes”, the
    program must repeat; it must end otherwise. Make your program accept the answer
    in all possible forms such as “yes”, “YES”, “Yes”, or even “YeS”.
  prefs: []
  type: TYPE_NORMAL
- en: Moreover, using a loop control structure the program must validate data input
    and display an error message when the user enters any non-positive value for amount.
  prefs: []
  type: TYPE_NORMAL
- en: 42)The LAV Electricity Company charges subscribers for their electricity consumption
    according to the following table (monthly rates for domestic accounts).
  prefs: []
  type: TYPE_NORMAL
- en: '| Kilowatt‑hours (kWh) | USD per kWh |'
  prefs: []
  type: TYPE_TB
- en: '| 0 ≤ kWh ≤ 400 | $0.11 |'
  prefs: []
  type: TYPE_TB
- en: '| 401 ≤ kWh ≤ 1500 | $0.22 |'
  prefs: []
  type: TYPE_TB
- en: '| 1501 ≤ kWh ≤ 3500 | $0.25 |'
  prefs: []
  type: TYPE_TB
- en: '| 3501 ≤ kWh | $0.50 |'
  prefs: []
  type: TYPE_TB
- en: Write a Python program that prompts the user to enter the total number of kWh
    consumed by a subscriber and then calculates and displays the total amount to
    pay. This process must repeat until the value −1 for kWh is entered.
  prefs: []
  type: TYPE_NORMAL
- en: Moreover, using a loop control structure, the program must validate data input
    and display an error message when the user enters any negative value for kWh.
    An exception for the value −1 must be made.
  prefs: []
  type: TYPE_NORMAL
- en: Transmission services and distribution charges, as well as federal, state, and
    local taxes, add a total of 25% to each bill.
  prefs: []
  type: TYPE_NORMAL
- en: Please note that the rates are progressive.
  prefs: []
  type: TYPE_NORMAL
