- en: '*Chapter 4*: URLs, Views, and Templates'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '*第4章*：URL、视图和模板'
- en: In this chapter, we will build the **URL** patterns that route to different
    **views**, processing a request sent to the server. One of the jobs of a view
    is to send processed information in the form of **context** to a **template**
    that will be used to render static or dynamically changing content. By the end
    of this chapter, we will have created several URL patterns for the user to visit
    and view data. Some examples will trigger errors or not-found exceptions on purpose
    to help demonstrate the concepts provided in this chapter.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将构建将路由到不同**视图**的**URL**模式，处理发送到服务器的请求。视图的一个工作是将处理过的信息以**上下文**的形式发送到将用于渲染静态或动态更改内容的**模板**。到本章结束时，我们将为用户创建几个URL模式以访问和查看数据。一些示例将故意触发错误或未找到异常，以帮助展示本章提供的概念。
- en: Django is based on what is called the **Model-Template-View** (**MTV**) architectural
    design pattern, which is similar to the well-known **Model-View-Controller** (**MVC**)
    design pattern used for a variety of popular web-based software systems today.
    The view in both of these architectural design patterns is what sometimes confuses
    people who are starting to learn Django and come from an MVC background. In both
    patterns, the model is the same, and both correspond to the tables within a database.
    In Django, the view is best compared to the controller used in the MVC design
    pattern, while the template in Django's MTV pattern is best compared to the view
    in an MVC design pattern.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: Django基于所谓的**模型-模板-视图**（**MTV**）架构设计模式，这与今天用于各种流行基于Web的软件系统的知名**模型-视图-控制器**（**MVC**）设计模式类似。在这两种架构设计模式中，视图是人们开始学习Django并来自MVC背景的人有时会感到困惑的部分。在这两种模式中，模型是相同的，并且两者都对应于数据库中的表。在Django中，视图最好与MVC设计模式中的控制器相比较，而Django的MTV模式中的模板最好与MVC设计模式中的视图相比较。
- en: We will begin this chapter by discussing URL patterns that let us tell Django
    what paths we want available on a website, within our project. A `.com`, `.org`,
    or `.edu` part of a URL. The path in `www.example.com/my-url-pattern/` would be
    `/my-url-pattern/`. We can tell Django to map different URL patterns to different
    views and we can point different URL patterns to the same view. Views are what
    process a request and return a response. Usually, a response is returned in the
    form of an HTML template, but a response can also be in the form of JSON, XML,
    or any other data type. Templates take context provided by a view and/or a context
    processor and then use that context data to render dynamic HTML in a client's
    browser. **Context** is actually a dictionary of dynamic variables that change
    as conditions and states change within your app. Data that lives in the database
    is also provided to the template through that same context. Views perform queries
    and/or communicate with caching systems and APIs to fetch data from a data storage
    device, used when rendering templates.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将以此章节开始，讨论URL模式，这些模式允许我们告诉Django我们希望在网站上可用的路径，在我们项目内部。一个URL的`.com`、`.org`或`.edu`部分。`www.example.com/my-url-pattern/`中的路径将是`/my-url-pattern/`。我们可以告诉Django将不同的URL模式映射到不同的视图，并且我们可以将不同的URL模式指向相同的视图。视图是处理请求并返回响应的部分。通常，响应以HTML模板的形式返回，但响应也可以是JSON、XML或其他数据类型。模板接受视图和/或上下文处理器提供的上下文，然后使用该上下文数据在客户端浏览器中渲染动态HTML。**上下文**实际上是一个动态变量的字典，这些变量会随着你的应用程序中条件和状态的改变而改变。存在于数据库中的数据也通过相同的上下文提供给模板。视图执行查询和/或与缓存系统和API通信，以从数据存储设备中获取数据，用于渲染模板。
- en: 'In this chapter, we will cover the following:'
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将涵盖以下内容：
- en: Configuring URL patterns
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 配置URL模式
- en: Mapping URL patterns
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 映射URL模式
- en: Resolving URLs
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 解析URL
- en: Resolving absolute URLs
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 解析绝对URL
- en: Working with complex views
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用复杂视图
- en: Working with templates
  id: totrans-10
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用模板
- en: Technical requirements
  id: totrans-11
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 技术要求
- en: 'To work with the code in this chapter, the following tools will need to be
    installed on your local machine:'
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 要在此章节中与代码一起工作，以下工具需要安装在你的本地机器上：
- en: Python version 3.9 – used as the underlying programming language for the project
  id: totrans-13
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Python版本3.9 - 作为项目的底层编程语言使用
- en: Django version 4.0 – used as the backend framework of the project
  id: totrans-14
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Django版本4.0 - 作为项目的后端框架使用
- en: pip package manager – used to manage third-party Python/Django packages
  id: totrans-15
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: pip包管理器 - 用于管理第三方Python/Django包
- en: We will continue to work with the solution created in [*Chapter 2*](B17243_02_ePub.xhtml#_idTextAnchor037),
    *Project Configuration*. However, it is not necessary to use the Visual Studio
    IDE. The main project itself can be run using another IDE or run independently
    using a terminal or command-line window from within the project root folder. This
    is where the `manage.py` file resides. Whatever editor or IDE you are using, a
    virtual environment will also be needed to work with the Django project. Instructions
    for how to create a project and virtual environment can be found in [*Chapter
    2*](B17243_02_ePub.xhtml#_idTextAnchor037), *Project Configuration*. You will
    need a database to store the data contained in your project. PostgreSQL was chosen
    for the examples in the previous chapter; however, any database type that you
    choose for your project can be used to work with the examples in this chapter.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将继续使用[*第2章*](B17243_02_ePub.xhtml#_idTextAnchor037)中“项目配置”中创建的解决方案。然而，没有必要使用Visual
    Studio IDE。主要项目本身可以使用其他IDE运行，或者从项目根目录中独立使用终端或命令行窗口运行。这就是`manage.py`文件所在的位置。无论你使用什么编辑器或IDE，都需要一个虚拟环境来与Django项目一起工作。有关如何创建项目和虚拟环境的说明可以在[*第2章*](B17243_02_ePub.xhtml#_idTextAnchor037)中“项目配置”中找到。你需要一个数据库来存储项目中的数据。在上一章的示例中选择了PostgreSQL；然而，你可以为你的项目选择任何数据库类型来与本章中的示例一起工作。
- en: 'We will also be using data that is in the form of a Django fixture, provided
    previously in [*Chapter 3*](B17243_03_ePub.xhtml#_idTextAnchor077), *Models, Relations,
    and Inheritance*, in the subsection titled *Loading the Chapter_3 data fixture*.
    Make sure the `chapter_3` fixture is loaded into your database. If this has already
    been done, then you may skip the next command. If you have already created the
    tables found in [*Chapter 3*](B17243_03_ePub.xhtml#_idTextAnchor077), *Models,
    Relations, and Inheritance*, and have not loaded that fixture yet, then run the
    following command, after activating your virtual environment:'
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还将使用[*第3章*](B17243_03_ePub.xhtml#_idTextAnchor077)中“模型、关系和继承”小节标题为“加载Chapter_3数据固定文件”中提供的Django固定数据。确保`chapter_3`固定文件已加载到你的数据库中。如果这已经完成，则可以跳过下一个命令。如果你已经创建了[*第3章*](B17243_03_ePub.xhtml#_idTextAnchor077)中“模型、关系和继承”中提到的表，并且尚未加载该固定文件，那么在激活你的虚拟环境后，运行以下命令：
- en: '[PRE0]'
  id: totrans-18
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'All of the code created in this chapter can be found in the GitHub repository
    for this book: [https://github.com/PacktPublishing/Becoming-an-Enterprise-Django-Developer](https://github.com/PacktPublishing/Becoming-an-Enterprise-Django-Developer).
    The bulk of the code used in this chapter can be found in the `/becoming_a_django_entdev/becoming_a_django_entdev/chapter_4/`
    directory.'
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 本章创建的所有代码都可以在本书的GitHub仓库中找到：[https://github.com/PacktPublishing/Becoming-an-Enterprise-Django-Developer](https://github.com/PacktPublishing/Becoming-an-Enterprise-Django-Developer)。本章使用的代码的大部分可以在`/becoming_a_django_entdev/becoming_a_django_entdev/chapter_4/`目录中找到。
- en: 'Check out the following video to see the *Code in Action*: [https://bit.ly/3A6AxNU](https://bit.ly/3A6AxNU).'
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 查看以下视频以查看*代码在实际应用中的效果*：[https://bit.ly/3A6AxNU](https://bit.ly/3A6AxNU)。
- en: Preparing for this chapter
  id: totrans-21
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 准备本章内容
- en: Start by creating a new app in your project called `chapter_4` by following
    the steps discussed in [*Chapter 2*](B17243_02_ePub.xhtml#_idTextAnchor037), *Project
    Configuration*, in the subsection titled *Creating a Django app*. As discussed
    in that section, don't forget to change the value of your `name =` variable for
    your app class found in the `/becoming_a_django_entdev/becoming_a_django_entdev/chapter_4/apps.py`
    file to now point to the path where you installed your app. Be sure to also include
    this app in your `INSTALLED_APPS` variable found in the `settings.py` file as
    well.
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，按照[*第2章*](B17243_02_ePub.xhtml#_idTextAnchor037)中“项目配置”小节标题为“创建Django应用”的步骤，在你的项目中创建一个名为`chapter_4`的新应用。正如该章节所述，不要忘记将你的应用类中的`name
    =`变量的值改为指向你安装应用路径。确保也将此应用包含在`settings.py`文件中的`INSTALLED_APPS`变量中。
- en: Configuring URL patterns
  id: totrans-23
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 配置URL模式
- en: Django controls and processes URL patterns in what it calls a `urls.py` file,
    which is specified as the `ROOT_URLCONF` variable, found in the `settings.py`
    file. Visual Studio automatically created the `ROOT_URLCONF` variable for us when
    we created a project and it should have also done so when executing the Django
    `startproject` command.
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: Django 通过它所称为的 `urls.py` 文件来控制和处理 URL 模式，该文件作为 `ROOT_URLCONF` 变量指定，位于 `settings.py`
    文件中。当创建项目时，Visual Studio 自动为我们创建了 `ROOT_URLCONF` 变量，并且在执行 Django `startproject`
    命令时也应该如此。
- en: 'If your project did not create this variable, add the following setting to
    your `settings.py` file:'
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你的项目没有创建此变量，请将以下设置添加到你的 `settings.py` 文件中：
- en: '[PRE1]'
  id: totrans-26
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: '[PRE2]'
  id: totrans-27
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: '[PRE3]'
  id: totrans-28
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: The `urls.py` file defined in the `ROOT_URLCONF` variable is what Django considers
    the `url.py` files can be linked together by importing them using an `import()`
    function. Django looks for only one thing in these `urls.py` files, a single variable
    named `urlpatterns`, which contains a set of URL patterns that have been defined
    for a project or reusable app. This file can contain many methods, classes, and
    other utilities that help you formulate those patterns.
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 在 `ROOT_URLCONF` 变量中定义的 `urls.py` 文件是 Django 认为可以通过使用 `import()` 函数导入来相互链接的
    `url.py` 文件。Django 在这些 `urls.py` 文件中只寻找一件事情，那就是一个名为 `urlpatterns` 的单个变量，它包含了一组为项目或可重用应用定义的
    URL 模式。此文件可以包含许多方法、类和其他实用工具，帮助你制定这些模式。
- en: Basic path functions
  id: totrans-30
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 基本路径函数
- en: 'Django provides us with a variety of path functions to build URL patterns.
    These functions create and return elements that will be included within any `urlpatterns`
    variable. The `path()` and `re_path()` functions can accept up to four positional
    arguments in the following order: `route`, `view`, `kwargs`, and `name`. The first
    two of these arguments are required and must be defined. The first argument, `route`,
    expects a string; this can be a simple string or a fairly complex string when
    combining path converters and using regular expressions. If you are using a method
    to perform logic of some kind for this argument, it just needs to return a string.
    The `route` argument is the path that Django is listening for and then mapping
    to the second argument, `view`. The `view` argument is used to tell Django how
    to process the `GET` request of a URL pattern. `view` can perform any kind of
    logic. The third argument is the `view`. The last argument, `name`, is a way to
    map URL patterns when using other functions, such as a reverse lookup.'
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: Django 提供了各种路径函数来构建 URL 模式。这些函数创建并返回将被包含在任何 `urlpatterns` 变量中的元素。`path()` 和
    `re_path()` 函数可以接受最多四个位置参数，顺序如下：`route`、`view`、`kwargs` 和 `name`。其中前两个参数是必需的，并且必须定义。第一个参数
    `route` 期望一个字符串；这可以是一个简单的字符串，也可以是一个相当复杂的字符串，当结合路径转换器和使用正则表达式时。如果你为这个参数使用某种方法来执行逻辑，它只需要返回一个字符串。`route`
    参数是 Django 监听并映射到第二个参数 `view` 的路径。`view` 参数用于告诉 Django 如何处理 URL 模式的 `GET` 请求。`view`
    可以执行任何类型的逻辑。第三个参数是 `view`。最后一个参数 `name` 是在与其他函数（如反向查找）使用时映射 URL 模式的一种方式。
- en: Let's go over some examples of using basic functions before we dive into more
    complicated URL patterns, using path converters.
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们深入更复杂的 URL 模式和路径转换器之前，让我们先看看一些使用基本函数的例子。
- en: Function – static()
  id: totrans-33
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 函数 – static()
- en: The `static()` function is provided by Django to help serve up static files
    when running a project locally and with debug mode turned on. These are files
    such as images, CSS, and JavaScript files that are placed in the `static` folder
    of a Django app. This function will enable access to those static folders, allowing
    you to run your project and add, delete, and edit those files all without having
    to run the `python manage.py collectstatic` command to reflect those changes in
    your browser. Of course, in the browser, you still have to hit refresh unless
    you have other tools/plugins installed in your browser to update a page when it
    detects changes to files that it is using.
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: Django 提供了 `static()` 函数，用于在本地运行项目且开启调试模式时提供静态文件服务。这些文件包括图像、CSS 和 JavaScript
    文件，它们被放置在 Django 应用程序的 `static` 文件夹中。此函数将启用对这些静态文件夹的访问，允许你在不运行 `python manage.py
    collectstatic` 命令的情况下，运行项目并添加、删除和编辑这些文件。当然，在浏览器中，除非你安装了其他工具/插件来更新使用中的文件变化时刷新页面，否则你仍然需要手动刷新。
- en: Static files
  id: totrans-35
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 静态文件
- en: 'To activate static files in your local environment, in your main `urls.py`
    file, add the following `import` statements and append the following function
    to the `urlpatterns` variable:'
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 要在本地环境中激活静态文件，在你的主 `urls.py` 文件中，添加以下 `import` 语句并将以下函数追加到 `urlpatterns` 变量中：
- en: '[PRE4]'
  id: totrans-37
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: '[PRE5]'
  id: totrans-38
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: '[PRE6]'
  id: totrans-39
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: '[PRE7]'
  id: totrans-40
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: '[PRE8]'
  id: totrans-41
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: '[PRE9]'
  id: totrans-42
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: '[PRE10]'
  id: totrans-43
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: In the preceding example, we imported the `settings.py` file to gain access
    to the values of the `STATIC_URL` and `STATIC_ROOT` variables. Since we installed
    the `pip` `whiteNoise` package, to work with Heroku as our host, we actually do
    not need to write the `static()` function depicted previously. This means we can
    skip writing the preceding code if we want to, but adding it will not hurt either
    and will allow your project to work on other hosts.
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的示例中，我们导入了 `settings.py` 文件以获取 `STATIC_URL` 和 `STATIC_ROOT` 变量的值。由于我们安装了
    `pip` 的 `whiteNoise` 包，为了与 Heroku 作为我们的主机一起工作，我们实际上不需要编写前面显示的 `static()` 函数。这意味着如果我们想的话，我们可以跳过编写前面的代码，但这也不会造成伤害，并且将允许你的项目在其他主机上工作。
- en: This can also be written using a conditional that checks whether `DEBUG` is
    enabled.
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 这也可以使用一个条件语句来编写，该语句检查 `DEBUG` 是否已启用。
- en: 'The alternative would be written as follows:'
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 替代方案可以写成如下：
- en: '[PRE11]'
  id: totrans-47
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: '[PRE12]'
  id: totrans-48
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: '[PRE13]'
  id: totrans-49
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: '[PRE14]'
  id: totrans-50
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: '[PRE15]'
  id: totrans-51
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: '[PRE16]'
  id: totrans-52
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: '[PRE17]'
  id: totrans-53
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: '[PRE18]'
  id: totrans-54
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: Please use only one of the examples depicted in this subsection and not both
    of them at the same time. You can comment out the unused one.
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 请只使用本小节中描述的示例之一，而不是同时使用两个。你可以注释掉未使用的那个。
- en: Let's configure media files next.
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们接下来配置媒体文件。
- en: Media files
  id: totrans-57
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 媒体文件
- en: Even with the `whitenoise` package, we still need to use the `static()` function
    to serve up media files. `FileField`, `ImageField`, or several other methods of
    uploading files to a media storage device. These files are also known as **User-Generated
    Content** (**UGC**) and they can range from anything such as an image to a PDF
    document, Excel document, Word document, audio file, or even movie file. The file
    that gets uploaded is placed in the media folder that we created and configured
    in [*Chapter 2*](B17243_02_ePub.xhtml#_idTextAnchor037)*,* *Project Configuration*.
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 即使有 `whitenoise` 包，我们仍然需要使用 `static()` 函数来提供媒体文件。`FileField`、`ImageField` 或将文件上传到媒体存储设备的其他几种方法。这些文件也被称为
    **用户生成内容**（**UGC**），它们可以是任何东西，如图像到 PDF 文档、Excel 文档、Word 文档、音频文件，甚至是电影文件。上传的文件被放置在我们创建和配置的媒体文件夹中，如
    [*第 2 章*](B17243_02_ePub.xhtml#_idTextAnchor037)*，* *项目配置*。
- en: 'To access these images when running a project locally, follow these steps:'
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 要在本地运行项目时访问这些图像，请按照以下步骤操作：
- en: 'In your main `urls.py` file, insert the following highlighted code:'
  id: totrans-60
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在你的主 `urls.py` 文件中，插入以下突出显示的代码：
- en: '[PRE19]'
  id: totrans-61
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE19]'
- en: This can also be added to the debug conditional statement shown in the previous
    subsection, titled *Static files*.
  id: totrans-62
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 这也可以添加到前一小节中显示的调试条件语句，标题为 *静态文件*。
- en: 'If you downloaded the code that came along with this book, a sample image has
    been included in the directory called `/media` and is used to test whether accessing
    media files is actually working. If the `/media` folder is not created at this
    time in your project, go ahead and create that in your IDE or file browser or
    by running the following command:'
  id: totrans-63
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果你下载了这本书附带代码，一个示例图像已经被包含在名为 `/media` 的目录中，并用于测试访问媒体文件是否实际可行。如果你的项目中此时没有创建 `/media`
    文件夹，请继续在你的 IDE 或文件浏览器中创建它，或者通过运行以下命令：
- en: '[PRE20]'
  id: totrans-64
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE20]'
- en: Copy the `/becoming_a_django_entdev/media/media.jpg` file into your project
    in the same directory.
  id: totrans-65
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将 `/becoming_a_django_entdev/media/media.jpg` 文件复制到你的项目中同一目录下。
- en: 'Run your project and attempt to navigate to the URL `http://localhost:8000/media/media.jpg`
    without the preceding code and you should get a 404 response. Then try it with
    the preceding code and you should see the media image shown here:'
  id: totrans-66
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 运行你的项目，并尝试导航到 URL `http://localhost:8000/media/media.jpg`（不使用前面的代码），你应该得到一个
    404 响应。然后尝试使用前面的代码，你应该看到这里显示的媒体图像：
- en: '![Figure 4.1 – Media sample image'
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: '![图 4.1 – 媒体示例图像'
- en: '](img/Figure_4.01_B17243.jpg)'
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: '![img/Figure_4.01_B17243.jpg]'
- en: Figure 4.1 – Media sample image
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 图 4.1 – 媒体示例图像
- en: Let's take these functions a step further and build our first path next.
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们进一步探讨这些函数，并构建我们的第一个路径。
- en: Function – path()
  id: totrans-71
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 函数 – path()
- en: A `path()` function takes in the `route`, `view`, `kwargs`, and `name` attributes
    and returns a single element to be included in the `urlpatterns` list. A `path()`
    function can be thought of as handling static paths as well as dynamic paths using
    path converters. If you want to use regular expressions to register a dynamic
    path converter, you will want to use the `re_path()` function instead.
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 一个 `path()` 函数接受 `route`、`view`、`kwargs` 和 `name` 属性，并返回一个要包含在 `urlpatterns`
    列表中的单个元素。`path()` 函数可以被视为处理静态路径以及使用路径转换器处理动态路径。如果你想使用正则表达式来注册动态路径转换器，你应该使用 `re_path()`
    函数。
- en: 'Follow these steps to work with the `path()` function in your project:'
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 按照以下步骤在你的项目中使用 `path()` 函数：
- en: 'First, run your project and navigate to the base URL of the project at `http://localhost:8000/`.
    You might be wondering why we are seeing a `Page not found (404)` message, as
    shown here:'
  id: totrans-74
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 首先，运行你的项目并导航到项目的基URL `http://localhost:8000/`。你可能想知道为什么我们会看到如这里所示的“页面未找到（404）”消息：
- en: '![Figure 4.2 – 404 with debug turned on'
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: '![图4.2 – 启用调试时的404]'
- en: '](img/Figure_4.02_B17243.jpg)'
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: '![Figure 4.02_B17243.jpg]'
- en: Figure 4.2 – 404 with debug turned on
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 图4.2 – 启用调试时的404
- en: When we activated the `static` and `media` URL patterns, we caused this error
    message to happen. This is the reason we are not seeing the famous Django success
    rocket ship that we are used to seeing. It's nothing to be alarmed about; it just
    means that we haven't created a URL pattern to handle the home page yet. This
    error message can be thought of as a reminder to create that home page, which
    we will do next.
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们激活了 `static` 和 `media` URL模式时，导致了这个错误消息的发生。这就是为什么我们没有看到我们习惯看到的著名的Django成功火箭船。这没有什么好担心的；这仅仅意味着我们还没有创建一个URL模式来处理主页。这个错误消息可以被视为创建主页的提醒，我们将在下一步完成。
- en: Using the `path()` function, we will define a single static URL pattern that
    will listen for the home page URL. Before we do that, let's create the HTML file
    that it will serve up. When we used Visual Studio to create the `chapter_4` app,
    a file named `index.html` was automatically created for us in the `/becoming_a_django_entdev/chapter_4/templates/chapter_4/`
    directory.
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 使用 `path()` 函数，我们将定义一个单一的静态URL模式，它将监听主页URL。在我们这样做之前，让我们创建它将提供服务的HTML文件。当我们使用Visual
    Studio创建 `chapter_4` 应用程序时，一个名为 `index.html` 的文件被自动创建在 `/becoming_a_django_entdev/chapter_4/templates/chapter_4/`
    目录中。
- en: If you do not have the `/chapter_4/templates/chapter_4/index.html` file in that
    directory, go ahead and create this file now, or copy the one provided with this
    book. Sometimes this file is not automatically created for us.
  id: totrans-80
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果你没有在 `/chapter_4/templates/chapter_4/index.html` 目录中找到该文件，现在就创建这个文件，或者复制本书提供的那个文件。有时这个文件不会自动为我们创建。
- en: The `index.html` file will be used as a custom home page and we will focus on
    just the URL pattern at this time; we will have dived into templates in more depth
    by the end of this chapter.
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: '`index.html` 文件将被用作自定义主页，我们目前将只关注URL模式；到本章结束时，我们将更深入地探讨模板。'
- en: Writing a URL pattern to listen for the home page is pretty easy compared to
    how complex other URL patterns can be to write. Django will try to match a URL
    to a pattern by starting from first to last in the order that they are placed
    within the `urlpatterns` list. It's usually best to include static URL patterns
    at the top and then place your dynamic patterns below them. If a static pattern
    is similar to a dynamic pattern, the static URL pattern will be matched first,
    which is likely what you want to happen.
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 相比于编写其他复杂的URL模式，编写监听主页的URL模式要简单得多。Django会尝试通过从 `urlpatterns` 列表中的第一个到最后一个的顺序来匹配URL与模式。通常最好将静态URL模式放在顶部，然后在其下方放置动态模式。如果静态模式与动态模式相似，静态URL模式将首先匹配，这可能是你想要的。
- en: 'In your main `/becoming_a_django_entdev/urls.py` file, add the following code:'
  id: totrans-83
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在你的主 `/becoming_a_django_entdev/urls.py` 文件中，添加以下代码：
- en: '[PRE21]'
  id: totrans-84
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE21]'
- en: The preceding `path()` function is used to listen for a route/path defined as
    nothing (`''`), and then we are using the built-in `TemplateView` class, provided
    by the `django.views.generic` library, to serve up the home page in template form.
    Since this is a static page and a static URL, meaning no content on the page will
    change and the URL itself will not change either, we do not need to write a view
    class to handle how the context of the page will change. Instead, we can skip
    creating the view in this example by using the `TemplateView` class. With a `TemplateView`
    class, we could still pass in keyword arguments and define the `name` argument
    if we wanted to. If we did want to pass in `kwargs`, that would be done using
    the following step.
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 之前的 `path()` 函数用于监听一个定义为空（`''`）的路由/路径，然后我们使用 `django.views.generic` 库提供的内置 `TemplateView`
    类，以模板形式提供主页。由于这是一个静态页面和一个静态URL，意味着页面上的内容不会改变，URL本身也不会改变，所以我们不需要编写一个视图类来处理页面上下文的变化。相反，我们可以通过使用
    `TemplateView` 类来跳过创建视图。使用 `TemplateView` 类，我们仍然可以传入关键字参数并定义 `name` 参数。如果我们想传入
    `kwargs`，那将是通过以下步骤完成的。
- en: 'Add `kwargs` to your home page:'
  id: totrans-86
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 为你的主页添加 `kwargs`：
- en: '[PRE22]'
  id: totrans-87
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'In the `/chapter_4/index.html` file that is provided with this book, a conditional
    will check whether `sub_title` has a value and then displays that value in your
    template. Copy that conditional into your file, as highlighted here:'
  id: totrans-88
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在本书提供的 `/chapter_4/index.html` 文件中，一个条件将检查 `sub_title` 是否有值，然后在模板中显示该值。将此条件复制到你的文件中，如下所示：
- en: '[PRE23]'
  id: totrans-89
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE23]'
- en: We will explain more about building templates before the end of this chapter,
    in the *Working with templates* section.
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将在本章结束前解释更多关于构建模板的内容，在 *与模板一起工作* 部分。
- en: One of the reasons we configured our project to handle static files in [*Chapter
    2*](B17243_02_ePub.xhtml#_idTextAnchor037), *Project Configuration*, and in this
    chapter, under the subsection titled *Static files*, was to access those files
    within a template, as is done in the example shown previously. The `{% load static
    %}` tag statement allows us to begin using the `static` template tag, such as
    `{% static 'chapter_4/home_page.jpg' %}`. The `{% static %}` tag returns a working
    URL, pointing to the image file at `http://localhost:8000/chapter_4/home_page.jpg`.
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将项目配置为处理静态文件的原因之一是在 [*第 2 章*](B17243_02_ePub.xhtml#_idTextAnchor037)，*项目配置*
    以及本章的 *静态文件* 小节中，以便在模板中访问这些文件，就像之前示例中展示的那样。`{% load static %}` 标签语句允许我们开始使用 `static`
    模板标签，例如 `{% static 'chapter_4/home_page.jpg' %}`。`{% static %}` 标签返回一个有效的 URL，指向
    `http://localhost:8000/chapter_4/home_page.jpg` 上的图像文件。
- en: 'Create the `/static/chapter_4/` folder in your project using the IDE, file
    browser, or the following command:'
  id: totrans-92
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用 IDE、文件浏览器或以下命令在你的项目中创建 `/static/chapter_4/` 文件夹：
- en: '[PRE24]'
  id: totrans-93
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE24]'
- en: Copy the `/chapter_4/home_page.jpg` file provided with the code of this book
    into your project.
  id: totrans-94
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将本书代码提供的 `/chapter_4/home_page.jpg` 文件复制到你的项目中。
- en: Django automatically searches the `static` folder found in each app of a project.
    It is common practice to override static files, such as images, CSS, and JavaScript
    files, of packages that are installed in your virtual environment by including
    the same path and filename in the static folder of any app in your project. The
    same principle also applies when working with template files.
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: Django 会自动搜索项目中每个应用中找到的 `static` 文件夹。通常的做法是在项目的任何应用中的静态文件夹中包含相同的路径和文件名来覆盖已安装在你的虚拟环境中的包的静态文件，如图像、CSS
    和 JavaScript 文件。同样的原则也适用于处理模板文件。
- en: In *step 5*, the highlighted `{{ sub_title }}` variable tag is the keyword argument
    that was passed into that URL pattern in *step 4*. A custom function/callable
    can also be used instead of hardcoding a value here. Any context variable can
    be recalled in a template using the bracket syntax, `{{ }}`. Objects such as a
    dictionary, list, set, and query set can all be accessed using a period for each
    key and subkey, as in `{{ context_variable.key.subkey }}`.
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 在 *步骤 5* 中，高亮的 `{{ sub_title }}` 变量标签是传递到 *步骤 4* 中的 URL 模式中的关键字参数。也可以使用自定义函数/可调用对象来代替这里硬编码的值。可以使用括号语法
    `{{ }}` 在模板中召回任何上下文变量。字典、列表、集合和查询集等对象都可以使用点来访问每个键和子键，例如 `{{ context_variable.key.subkey
    }}`。
- en: 'Now, run your project and you should no longer see a 404 debug message. Instead,
    you should see the following screenshot:'
  id: totrans-97
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，运行你的项目，你应该不再看到 404 调试信息。相反，你应该看到以下截图：
- en: '![Figure 4.3 – Project home page'
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: '![图 4.3 – 项目主页'
- en: '](img/Figure_4.03_B17243.jpg)'
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/Figure_4.03_B17243.jpg)'
- en: Figure 4.3 – Project home page
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 图 4.3 – 项目主页
- en: Next, let's work with the `include()` function to import URL patterns from other
    apps/packages.
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，让我们使用 `include()` 函数来导入其他应用/包的 URL 模式。
- en: Function – include()
  id: totrans-102
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 函数 – include()
- en: The `include()` function is used to import additional `urls.py` files that contain
    their own `urlpatterns` variable. This is how we can write URL patterns for reusable
    apps, and then include them for use in a project within `ROOT_URLCONF` of a site.
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 使用 `include()` 函数导入包含自己的 `urlpatterns` 变量的额外 `urls.py` 文件。这就是我们如何编写可重用应用的 URL
    模式，并在网站的 `ROOT_URLCONF` 中包含它们以供项目使用。
- en: 'Let''s use this to better organize our chapter-specific URL patterns by following
    these steps:'
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们按照以下步骤来更好地组织我们章节特定的 URL 模式：
- en: 'If this file was not already created for you, go ahead and create a `urls.py`
    file inside of your `/becoming_a_django_entdev/chapter_4/` folder, and then add
    the following URL pattern to that file:'
  id: totrans-105
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果这个文件还没有为你创建，请继续在 `/becoming_a_django_entdev/chapter_4/` 文件夹内创建一个 `urls.py`
    文件，然后向该文件添加以下 URL 模式：
- en: '[PRE25]'
  id: totrans-106
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'In the main `/becoming_a_django_entdev/urls.py` file that we have been using,
    comment out the previous patterns that we created in this chapter and add the
    following `path` statement:'
  id: totrans-107
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE26]'
  id: totrans-108
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE26]'
- en: Copy the `chapter_4.html` template file that is provided with the code of this
    book into your project, found in the `/becoming_a_django_entdev/chapter_4/templates/chapter_4/`
    directory.
  id: totrans-109
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Navigate to the URL `http://localhost:8000/chapter-4/`, and you should see
    a white page that only says **This is Chapter 4**, as shown in the following screenshot:'
  id: totrans-110
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![Figure 4.4 – URL pattern – include()'
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
- en: '](img/Figure_4.04_B17243.jpg)'
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
- en: Figure 4.4 – URL pattern – include()
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
- en: Now that we have the `include()` example working, we will put all new URL patterns
    in the `/chapter_4/urls.py` file and organize all future chapters in a similar
    manner.
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
- en: Now, let's practice redirecting URLs.
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
- en: Redirecting patterns
  id: totrans-116
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Instead of using the `TemplateView` class as we have been, we can write URL
    patterns to handle redirects from within the project, without having to configure
    them directly in a web server. This is convenient because in traditional web development,
    redirects are handled by the web server and it is much easier to manage in a project
    than it is in a web server. Redirects can be handled using the `RedirectView`
    class provided by Django.
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
- en: 'We are going to specify a redirect rule on the `http://localhost:8000/my_path/my_unwanted_url/`
    path to take us to `http://localhost:8000/my_wanted_url/` instead. Follow these
    steps to configure your redirect:'
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
- en: 'Add the following pattern to your existing `/chapter_4/urls.py` file:'
  id: totrans-119
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE27]'
  id: totrans-120
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE27]'
- en: Run your project and navigate to the URL `http://localhost:8000/my_path/my_unwanted_url/`.
    You should now be redirected to, and also see in the address bar of the browser,
    `http://localhost:8000/my_wanted_url/`. In the body of the page, you should see
    a 404 response because we have not yet defined a URL pattern for the `my_wanted_url`
    path. This is to be expected when performing this step.
  id: totrans-121
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Additional arguments can be included, such as stating that we want this to
    be a permanent or temporary redirect, by writing the path using the following
    example:'
  id: totrans-122
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE28]'
  id: totrans-123
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE28]'
- en: Django also allows us to define `pattern_name` and `query_string` as additional
    arguments of the `RedirectView` class.
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
- en: Note
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
- en: The preceding path has a hardcoded value of `http://localhost:8000/`, which
    can become a problem in a remote environment that is not your local machine. To
    overcome this, you will need to adopt the concept of global context variables
    discussed later in this chapter in the subsection titled *Creating a context processor*.
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
- en: Next, let's discuss using path converters to listen for dynamic path routes.
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
- en: Using path converters
  id: totrans-128
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: A `str`, `int`, `slug`, `uuid`, and `path`. These are preformatted converters
    that allow a variety of choices and permit strings and integers within a pattern.
    For example, the path converter called `path` is used in the following code to
    search for any variety of characters, numbers, and certain symbols that a URL
    can possess.
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: '`str`、`int`、`slug`、`uuid` 和 `path`。这些都是预格式化的转换器，允许多种选择，并允许在模式内使用字符串和整数。例如，`path`
    路径转换器在以下代码中用于搜索 URL 可以拥有的任何字符、数字和某些符号。'
- en: 'To practice using path converters, follow these steps:'
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 要练习使用路径转换器，请按照以下步骤操作：
- en: 'Add the following URL pattern to your `/chapter_4/urls.py` file:'
  id: totrans-131
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将以下 URL 模式添加到你的 `/chapter_4/urls.py` 文件中：
- en: '[PRE29]'
  id: totrans-132
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE29]'
- en: Now, navigate to the URL `http://localhost:8000/my_path/testing/`, and you should
    see the same home page that we saw before. We are seeing the same page because
    we are pointing to the same `index.html` file, just to see that it is working.
    Additionally, if we navigate to the URL `http://localhost:8000/my_path/2022/`,
    we will also see the same home page. This is to be expected. The one thing we
    won't see is the value of the `sub_title` keyword argument on this page because
    we did not pass that into this URL pattern. The conditional `{% if sub_title %}`
    statement found in that template is used to prevent breakage if no `sub_title`
    is provided.
  id: totrans-133
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，导航到 URL `http://localhost:8000/my_path/testing/`，你应该看到之前看到的主页。我们看到相同的页面，因为我们指向的是相同的
    `index.html` 文件，只是为了确认它正在工作。此外，如果我们导航到 URL `http://localhost:8000/my_path/2022/`，我们也会看到相同的主页。这是预期的。我们不会看到这个页面上的
    `sub_title` 关键字参数的值，因为我们没有将此参数传递给这个 URL 模式。在该模板中找到的 `{% if sub_title %}` 条件语句用于防止在没有
    `sub_title` 的情况下发生破坏。
- en: 'Change the existing `my_path` path converter shown in *step 1* from path to
    int and change `my_path` to `my_year_path`, as shown in the following code, allowing
    for the URL `http://localhost:8000/my_year_path/2022/` to work:'
  id: totrans-134
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将 *步骤 1* 中显示的现有 `my_path` 路径转换器从路径转换为 `int`，并将 `my_path` 更改为 `my_year_path`，如下面的代码所示，允许
    URL `http://localhost:8000/my_year_path/2022/` 正常工作：
- en: '[PRE30]'
  id: totrans-135
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE30]'
- en: Next, run your project again. With the `int` path converter, the URL `http://localhost:8000/my_year_path/testing/`
    should no longer work when we try to navigate to it. Instead, we should see the
    same 404 debug message that we saw earlier. It will only allow a numeric value
    of any length now. This means we should see the home page image when we visit
    the URL `http://localhost:8000/my_year_path/2/`, or any numeric value.
  id: totrans-136
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，再次运行你的项目。使用 `int` 路径转换器时，当我们尝试导航到 `http://localhost:8000/my_year_path/testing/`
    这个 URL 时，它将不再工作。相反，我们应该看到之前看到的相同的 404 调试信息。现在它只允许任何长度的数字值。这意味着当我们访问 URL `http://localhost:8000/my_year_path/2/`
    或任何数字值时，我们应该看到主页图片。
- en: When we wrote `int:my_year`, the `my_year` in this argument can be named anything
    we want. The same applies to the `my_pattern` in the `path:my_pattern` argument
    and in any other converter type. The second parameter is what is used to access
    that key word argument in a view class or method.
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们编写 `int:my_year` 时，此参数中的 `my_year` 可以命名为我们想要的任何名称。同样，`path:my_pattern` 参数中的
    `my_pattern` 以及任何其他转换类型中的 `my_pattern` 也适用。第二个参数是用于在视图类或方法中访问该关键字参数的内容。
- en: Let's write a custom path converter next.
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们接下来编写一个自定义路径转换器。
- en: Custom path converters
  id: totrans-139
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 自定义路径转换器
- en: A custom path converter is a way for us to write a class that uses a regular
    expression to define the path that Django listens for. The converter class is
    structured in a way to return the data type that is intended to be used in the
    view, such as an `int` data type used in the example of the previous subsection.
    This class also returns another string representation of the data type sent to
    the view that is intended to be used in the URL. For example, if we do not want
    `http://localhost:8000/my_year_path/2/` to be a valid URL and we only want to
    allow four-digit numbers, a custom path converter can be used to accomplish this.
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 自定义路径转换器是我们编写一个使用正则表达式来定义 Django 监听的路径的类的方式。转换器类以返回在视图中预期使用的数据类型的方式进行结构化，例如在上一小节示例中使用的
    `int` 数据类型。此类还返回数据类型的另一个字符串表示形式，该表示形式是预期用于 URL 的。例如，如果我们不希望 `http://localhost:8000/my_year_path/2/`
    是一个有效的 URL，并且我们只想允许四位数，可以使用自定义路径转换器来完成此操作。
- en: 'Follow these steps to create your custom path converter:'
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 按照以下步骤创建你的自定义路径转换器：
- en: In your `/chapter_4/` app directory, create a new file called `converters.py`.
  id: totrans-142
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在你的 `/chapter_4/` 应用程序目录中，创建一个名为 `converters.py` 的新文件。
- en: 'Inside the file, add the following class, with the two methods provided:'
  id: totrans-143
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在文件内部，添加以下类，包含提供的两个方法：
- en: '[PRE31]'
  id: totrans-144
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE31]'
- en: 'In your `/chapter_4/urls.py` file, add the following code, which registers
    the newly created converter class for use where it is highlighted in `<year:year>`
    in the following code block:'
  id: totrans-145
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在你的`/chapter_4/urls.py`文件中，添加以下代码，该代码注册了新创建的转换器类，以便在以下代码块中突出显示的`<year:year>`处使用：
- en: '[PRE32]'
  id: totrans-146
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE32]'
- en: Now, run your project and navigate to the URL `http://localhost:8000/my_year_path/2/`;
    you should see a 404 debug message. This occurs because the preceding pattern
    will only accept a four-digit integer now, including `0001` and `1111`, which
    is to be expected.
  id: totrans-147
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，运行你的项目并导航到URL `http://localhost:8000/my_year_path/2/`；你应该看到一个404调试信息。这是因为前面的模式现在只会接受四位数的整数，包括`0001`和`1111`，这是预期的。
- en: We can get even more in-depth by writing a method-based or class-based view
    and in that view compare whether a year is greater than, say, the year 1900, and
    if it is not, return a 404 response. We will discuss doing that soon in the section
    titled *Working with conditional responses* of this chapter.
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以通过编写基于方法或类的视图来进一步深入了解，在该视图中比较年份是否大于，比如说，1900年，如果不是，则返回404响应。我们将在本章的*处理条件响应*部分中很快讨论如何做。
- en: Next, let's practice working with regular expression paths.
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，让我们练习使用正则表达式路径。
- en: Function – re_path()
  id: totrans-150
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 函数 – re_path()
- en: A `re_path()` function, better known as a regular expression path function,
    is similar to a `path()` function but allows us to pass in a formatted regular
    expression string as the route parameter without the need to create a custom path
    converter.
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: '`re_path()`函数，也称为正则表达式路径函数，类似于`path()`函数，但允许我们传递一个格式化的正则表达式字符串作为路由参数，而无需创建自定义路径转换器。'
- en: 'For example, we could write the same year example as previously without the
    converter class. In your `/chapter_4/urls.py` file, add the path shown as follows,
    and comment out the previous `my_year_path`:'
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，我们可以像之前一样写出相同的年示例，而不使用转换器类。在你的`/chapter_4/urls.py`文件中，添加以下路径，并注释掉之前的`my_year_path`：
- en: '[PRE33]'
  id: totrans-153
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: '[PRE34]'
  id: totrans-154
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: '[PRE35]'
  id: totrans-155
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: '[PRE36]'
  id: totrans-156
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: '[PRE37]'
  id: totrans-157
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: '[PRE38]'
  id: totrans-158
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: '[PRE39]'
  id: totrans-159
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: '[PRE40]'
  id: totrans-160
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: '[PRE41]'
  id: totrans-161
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: '[PRE42]'
  id: totrans-162
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: '[PRE43]'
  id: totrans-163
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: '[PRE44]'
  id: totrans-164
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: '[PRE45]'
  id: totrans-165
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: '[PRE46]'
  id: totrans-166
  prefs: []
  type: TYPE_PRE
  zh: '[PRE46]'
- en: There is actually a difference between using a `re_path()` function and writing
    your own converter class. The difference is in the data type of the value of the
    pattern recognized when we use that value within a view class or method. With
    the `re_path()` function, the data type of this value when used in a view will
    always be a string, whereas the data type of the value when using a converter
    class will always be the data type defined by the `def to_python()` method of
    that class, meaning you can transform the data type to anything you want, if you
    need to.
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 使用`re_path()`函数和编写自己的转换器类之间实际上是有区别的。区别在于我们在视图类或方法中使用该值时识别到的模式值的类型。使用`re_path()`函数时，该值在视图中的数据类型始终是字符串，而使用转换器类时，该值的数据类型始终是该类`def
    to_python()`方法定义的数据类型，这意味着如果你需要，你可以将数据类型转换为任何你想要的类型。
- en: Before we illustrate the difference in data types between using a converter
    class and using the `re_path()` function, let's map a URL pattern to a simple
    view.
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们说明使用转换器类和使用`re_path()`函数之间的数据类型差异之前，让我们将一个URL模式映射到一个简单视图。
- en: Mapping URL patterns
  id: totrans-169
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 映射URL模式
- en: Writing custom views is a way for us to perform all of the tasks and services
    needed to render a page that includes all of the content that we want. Within
    a view, we can validate against business logic rules to determine how to handle
    a request.
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 编写自定义视图是我们执行渲染包含我们想要的所有内容的页面所需的所有任务和服务的一种方式。在视图中，我们可以根据业务逻辑规则进行验证，以确定如何处理请求。
- en: In this exercise, we will use the year pattern that we wrote earlier in this
    chapter, to only allow a year greater than 1900\. Anything less than that, we
    will tell Django to serve up a 404 response.
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个练习中，我们将使用本章前面写下的年模式，只允许年份大于1900。任何小于这个年份的，我们将告诉Django返回404响应。
- en: Using simple views
  id: totrans-172
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用简单视图
- en: A **simple view** is also known as a method-based view, which is a callable
    function in Python.
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: '**简单视图**也称为基于方法的视图，是Python中的一个可调用函数。'
- en: 'Follow these steps to map to a simple view in your project:'
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 按照以下步骤将映射到你的项目中的简单视图：
- en: 'In your `/chapter_4/urls.py` file, revert to using the same converter class
    that we wrote in the *Using path converters* subsection of this chapter. Reference
    a view that we will write next in a different file called `practice_view()`, as
    highlighted here:'
  id: totrans-175
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在你的`/chapter_4/urls.py`文件中，恢复使用本章*使用路径转换器*小节中编写的相同的转换器类。参考我们将在不同文件中编写的视图`practice_view()`，如下所示：
- en: '[PRE47]'
  id: totrans-176
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE47]'
- en: The thing we did differently from before is that we replaced the `TemplateView`
    class with a custom simple view class, called `practice_view`.
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 我们与之前不同的地方是，我们将 `TemplateView` 类替换为名为 `practice_view` 的自定义简单视图类。
- en: 'Create the view method called `practice_view()` in a `views.py` file in your
    `/becoming_a_django_entdev/chapter_4/` directory. Then, add the code shown here:'
  id: totrans-178
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在你的 `/becoming_a_django_entdev/chapter_4/` 目录下的 `views.py` 文件中创建一个名为 `practice_view()`
    的视图方法。然后，添加以下代码：
- en: '[PRE48]'
  id: totrans-179
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE48]'
- en: Copy the template file provided with the code of this book into your project,
    located at `/becoming_a_django_entdev/chapter_4/templates/chapter_4/my_practice_page.html`.
  id: totrans-180
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将本书代码中提供的模板文件复制到你的项目中，位于 `/becoming_a_django_entdev/chapter_4/templates/chapter_4/my_practice_page.html`。
- en: 'Navigate to the URL `http://localhost:8000/my_year_path/1066/` and you should
    see the practice page shown in the following screenshot:'
  id: totrans-181
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 导航到 URL `http://localhost:8000/my_year_path/1066/`，你应该能看到以下截图所示的练习页面：
- en: '![Figure 4.5 – Out-of-bounds year returns valid response'
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: '![图 4.5 – 超出范围的年份返回有效响应'
- en: '](img/Figure_4.05_B17243.jpg)'
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: '![图片 4.05_B17243](img/Figure_4.05_B17243.jpg)'
- en: Figure 4.5 – Out-of-bounds year returns valid response
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: 图 4.5 – 超出范围的年份返回有效响应
- en: We are almost there. The success message we see here is to be expected. What
    we actually want is to return a 404 response instead of a valid path, in order
    to comply with the business logic discussed earlier, to only allow a year greater
    than or equal to 1900\. Therefore, we need to use keyword arguments and conditional
    statements to perform custom validation when a request is processed, which we
    will do next.
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经接近完成了。这里看到的成功消息是预期的。我们实际上想要返回一个 404 响应而不是有效的路径，以便符合之前讨论的业务逻辑，只允许年份大于或等于
    1900。因此，我们需要使用关键字参数和条件语句在处理请求时执行自定义验证，我们将在下一步中这样做。
- en: Using kwargs in views
  id: totrans-186
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 在视图中使用 kwargs
- en: To access keyword arguments inside of a view method, we need to pass it in as
    a positional argument of that method. In the example, `def practice_view(request,
    year):`, `year` would be the positional keyword argument. Since we defined a path
    converter in the `urls.py` file with the name of `year`, we are required to include
    `year` as a positional argument when accessing a view with that same name. Without
    this argument, Django would give us an error during runtime.
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: 要在视图方法内部访问关键字参数，我们需要将其作为该方法的定位参数传递。在示例 `def practice_view(request, year):` 中，`year`
    将是定位关键字参数。由于我们在 `urls.py` 文件中定义了一个名为 `year` 的路径转换器，因此当访问具有相同名称的视图时，我们必须将 `year`
    作为定位参数包含在内。如果没有这个参数，Django 在运行时会给我们一个错误。
- en: 'Follow these steps to configure your `view` method:'
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: 按照以下步骤配置你的 `view` 方法：
- en: 'In your `/chapter_4/urls.py` file, use the following URL pattern along with
    the same path converter class that we created earlier. Comment out the other `my_year_path`
    patterns:'
  id: totrans-189
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在你的 `/chapter_4/urls.py` 文件中，使用以下 URL 模式，以及我们之前创建的相同的路径转换器类。注释掉其他 `my_year_path`
    模式：
- en: '[PRE49]'
  id: totrans-190
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE49]'
- en: 'In your `/chapter_4/views.py` file, write the new method provided here:'
  id: totrans-191
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在你的 `/chapter_4/views.py` 文件中，编写这里提供的新方法：
- en: '[PRE50]'
  id: totrans-192
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE50]'
- en: Copy the template file provided with the code of this book, found in `/becoming_a_django_entdev/chapter_4/templates/chapter_4/my_year.html`.
  id: totrans-193
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 复制本书代码中提供的模板文件，位于 `/becoming_a_django_entdev/chapter_4/templates/chapter_4/my_year.html`。
- en: 'Now, navigate to the URL `http://localhost:8000/my_year_path/2022/` and you
    should see a successful response. When we look at the terminal or command window,
    we will see that it is telling us the value of `year` is `2022` and that it is
    of an integer, `<class` `''int''>`, data type, as depicted in the following screenshot:'
  id: totrans-194
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，导航到 URL `http://localhost:8000/my_year_path/2022/`，你应该看到一个成功的响应。当我们查看终端或命令行窗口时，我们会看到它告诉我们
    `year` 的值是 `2022`，并且它是整数类型，`<class` `'int'>`，如图所示：
- en: '![](img/Figure_4.06_B17243.jpg)'
  id: totrans-195
  prefs: []
  type: TYPE_IMG
  zh: '![图片 4.06_B17243](img/Figure_4.06_B17243.jpg)'
- en: Figure 4.6 – Converter class – integer data type
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: 图 4.6 – 转换类 – 整数数据类型
- en: 'Change the URL pattern in your `/chapter_4/urls.py` file back to using the
    `re_path()` function instead of the custom `YearConverter` example, as shown:'
  id: totrans-197
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将你的 `/chapter_4/urls.py` 文件中的 URL 模式改回使用 `re_path()` 函数，而不是之前使用的自定义 `YearConverter`
    示例，如下所示：
- en: '[PRE51]'
  id: totrans-198
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE51]'
- en: You can comment out the `register_converter` that we previously used.
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以注释掉之前使用的 `register_converter`。
- en: 'Visit the URL `http://localhost:8000/my_year_path/2022/` one more time. You
    should see how the output will change from `<class` `''int''>` to `<class ''str''>`
    in your terminal or command-line window, as depicted here:'
  id: totrans-200
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 再次访问 URL `http://localhost:8000/my_year_path/2022/`。你应该能在你的终端或命令行窗口中看到输出如何从
    `<class` `'int'>` 变为 `<class 'str'>`，如图所示：
- en: '![](img/Figure_4.07_B17243.jpg)'
  id: totrans-201
  prefs: []
  type: TYPE_IMG
  zh: '![图片 4.07_B17243](img/Figure_4.07_B17243.jpg)'
- en: Figure 4.7 – Converter class – string data type
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
- en: Now, we can actually see the differences between writing a pattern using `re_path()`
    and the alternative, going through the steps to create a custom converter class.
    With the `re_path()` function, we now have to take additional steps in a view
    to convert a keyword argument into an integer before we can even check whether
    the `year` value is greater than a certain year. If we do not do that conversion,
    we would wind up with an error telling us **'>=' not supported between instances
    of 'str' and 'int'**. If the same regular expression pattern is used over and
    over again, it would mean converting a string into an integer many times, one
    time for each view that is being used by that pattern. This is what is known as
    the **Write Everything Twice** (**WET**) design principle and is usually frowned
    upon. Writing a converter class will solve that problem and allow you to write
    it just once according to the **Don't Repeat Yourself** (**DRY**) design principle.
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
- en: Let's work with conditional responses next.
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
- en: Working with conditional responses
  id: totrans-205
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Instead of returning a valid `TemplateResponse()` like we have been doing in
    previous exercises, we will finally check if the value of the `year` `kwarg` is
    greater than or equal to `1900`. If the `year` value is less than `1900`, we are
    going to raise a `Http404()` response. Using the URL pattern that uses the custom
    path converter `YearConverter` class that we wrote earlier, we will serve up an
    integer instead of a string as the data type of the keyword argument `year`, allowing
    us to perform mathematical operations using that value.
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
- en: 'Follow these steps to configure your conditional statements:'
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
- en: 'In your `/chapter_4/urls.py` file, add the following code, making sure to comment
    out or delete the other `my_year_path` patterns:'
  id: totrans-208
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE52]'
  id: totrans-209
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE52]'
- en: 'In your `/chapter_4/views.py` file, modify `practice_year_view()` to look like
    the following highlighted code:'
  id: totrans-210
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE53]'
  id: totrans-211
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE53]'
- en: 'Now, visit the URL `http://localhost:8000/my_year_path/1066/`, and you should
    see the following 404 message, which is intentional:'
  id: totrans-212
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![Figure 4.8 – Out-of-bounds year returns invalid response'
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
- en: '](img/Figure_4.08_B17243.jpg)'
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
- en: Figure 4.8 – Out-of-bounds year returns invalid response
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
- en: 'Next, visit a path with a year greater than `1900`, such as `http://localhost:8000/my_year_path/2022/`,
    and you should see a successful response, as on the year page depicted here:'
  id: totrans-216
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![Figure 4.9 – In-bounds year returns valid response'
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
- en: '](img/Figure_4.09_B17243.jpg)'
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
- en: Figure 4.9 – In-bounds year returns valid response
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
- en: Let's link models to our views and templates next.
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
- en: Linking models to views and templates
  id: totrans-221
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Using the same models that we created in [*Chapter 3*](B17243_03_ePub.xhtml#_idTextAnchor077),
    *Models, Relations, and Inheritance*, we can provide information about those objects
    within a template. We will write a URL pattern that will point to a new simple
    view method and display information about a vehicle.
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
- en: 'Follow these steps to display model information in your templates:'
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
- en: 'In your `/chapter_4/urls.py` file, include the following URL pattern:'
  id: totrans-224
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在你的 `/chapter_4/urls.py` 文件中，包含以下 URL 模式：
- en: '[PRE54]'
  id: totrans-225
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE54]'
- en: Our new view will listen for the primary key, also known as the ID, that is
    passed in to us as a keyword argument of that path converter. The ID is used to
    look up that object in the database, and if not found, it will serve up a 404
    response instead. Instead of writing `<int:id>`, we could target the path converter
    to listen for a string, such as the VIN using `<str:vin>`. Then, in the view where
    we perform the database query, search for a record matching the VIN instead of
    the ID of a vehicle. You are welcome to practice both options.
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的新视图将监听传递给我们的路径转换器的键，也称为 ID，作为该路径转换器的关键字参数。ID 用于在数据库中查找该对象，如果没有找到，则将提供 404
    响应。我们不必写 `<int:id>`，可以针对路径转换器监听字符串，例如 VIN，使用 `<str:vin>`。然后，在执行数据库查询的视图中，搜索与 VIN
    匹配的记录而不是车辆的 ID。欢迎你练习这两种选项。
- en: 'In your `/chapter_4/views.py` file, add the following `import` statement and
    `view` method:'
  id: totrans-227
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在你的 `/chapter_4/views.py` 文件中，添加以下 `import` 语句和 `view` 方法：
- en: '[PRE55]'
  id: totrans-228
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE55]'
- en: The preceding `import` statement uses two periods (`..`), which is Python path
    syntax, to navigate up one directory level and enter the sibling `chapter_3` folder,
    to access the models that are written in the `chapter_3` app. When you are working
    with many different apps in your project, this is common practice. The `try`/`except`
    block shown previously checks to see whether the requested object exists and if
    it does exist, a 404 response is raised.
  id: totrans-229
  prefs: []
  type: TYPE_NORMAL
  zh: 前面的 `import` 语句使用了两个点（`..`），这是 Python 路径语法，用于向上导航一个目录级别并进入同级的 `chapter_3` 文件夹，以便访问在
    `chapter_3` 应用中编写的模型。当你在一个项目中处理许多不同的应用时，这是一种常见的做法。之前显示的 `try`/`except` 块检查请求的对象是否存在，如果存在，则引发一个
    404 响应。
- en: Copy the template file that has been provided along with the code of this book,
    located at `/becoming_a_django_entdev/chapter_4/templates/chapter_4/my_vehicle.html`.
  id: totrans-230
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 复制与本书代码一起提供的模板文件，位于 `/becoming_a_django_entdev/chapter_4/templates/chapter_4/my_vehicle.html`。
- en: We can access any field in a model object from within the template by using
    the name of the context variable that we passed into `TemplateResponse`. For example,
    when used in a template file, the `vehicle` context variable would be written
    as `{{ vehicle.vin }}`. This is already done in the template file you just copied
    into your project.
  id: totrans-231
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以通过使用传递给 `TemplateResponse` 的上下文变量名称，从模板内部访问模型对象的任何字段。例如，当在模板文件中使用时，`vehicle`
    上下文变量将被写成 `{{ vehicle.vin }}`。这已经在你刚刚复制到项目中的模板文件中完成了。
- en: 'Run your project and navigate to `http://localhost:8000/vehicle/4/`. You should
    see vehicle detail information on this page, as shown in the following screenshot:'
  id: totrans-232
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 运行你的项目并导航到 `http://localhost:8000/vehicle/4/`。你应该在这个页面上看到车辆详细信息，如下面的截图所示：
- en: '![Figure 4.10 – Vehicle ID = 4'
  id: totrans-233
  prefs: []
  type: TYPE_NORMAL
  zh: '![图 4.10 – 车辆 ID = 4'
- en: '](img/Figure_4.10_B17243.jpg)'
  id: totrans-234
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/Figure_4.10_B17243.jpg)'
- en: Figure 4.10 – Vehicle ID = 4
  id: totrans-235
  prefs: []
  type: TYPE_NORMAL
  zh: 图 4.10 – 车辆 ID = 4
- en: If you change the ID in your URL, the vehicle will change. If you activated
    the VIN as the path converter, then you would navigate to `http://localhost:8000/vehicle/aa456789012345678/`
    in order to see the same results, using the data provided in the `chapter_3` data
    fixture.
  id: totrans-236
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你更改 URL 中的 ID，车辆将改变。如果你激活了 VIN 作为路径转换器，那么你将导航到 `http://localhost:8000/vehicle/aa456789012345678/`
    以查看相同的结果，使用 `chapter_3` 数据固定提供的数据。
- en: Now that we have views to work with, we can practice getting the reverse URL
    when providing only the `kwarg` of a path converter and the `name` attribute value.
  id: totrans-237
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们有了可以工作的视图，我们可以练习在只提供路径转换器的 `kwarg` 和 `name` 属性值时获取反向 URL。
- en: Resolving URLs
  id: totrans-238
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 解析 URL
- en: Resolving a URL is the process of taking a relative path or object and obtaining
    the URL that relates to a unique field such as a primary key. Django's reverse
    resolution of URL patterns is a method of generating a URL structure using argument
    values that we provide instead of hardcoding URL paths in places, which can break
    over time. We can use template tags and statements throughout the project to use
    the `name` argument of a URL pattern. This is encouraged as best practice and
    follows a DRY design principle, which is less prone to breakage as your project
    evolves.
  id: totrans-239
  prefs: []
  type: TYPE_NORMAL
  zh: 解析 URL 是将相对路径或对象转换为与唯一字段（如主键）相关的 URL 的过程。Django 的 URL 模式反向解析是一种使用我们提供的参数值生成
    URL 结构的方法，而不是在位置中硬编码 URL 路径，这可能会随时间而损坏。我们可以在整个项目中使用模板标签和语句来使用 URL 模式的 `name` 参数。这被鼓励作为最佳实践，并遵循
    DRY 设计原则，这使项目在演变过程中更不容易损坏。
- en: Let's discuss how to use the `name` attribute to get a reverse resolution pattern.
  id: totrans-240
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们讨论如何使用 `name` 属性来获取反向解析模式。
- en: Naming URL patterns
  id: totrans-241
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 命名 URL 模式
- en: Using the same custom `YearConverter` class and the same `my_year_path` URL
    pattern that we created earlier in this chapter, do the following to configure
    your URL pattern.
  id: totrans-242
  prefs: []
  type: TYPE_NORMAL
  zh: 使用与我们在本章前面创建的相同的自定义 `YearConverter` 类和相同的 `my_year_path` URL 模式，执行以下操作以配置您的
    URL 模式。
- en: 'In your `/chapter_4/urls.py` file, you should have the path shown in the following
    code block, using the highlighted `name` attribute:'
  id: totrans-243
  prefs: []
  type: TYPE_NORMAL
  zh: 在您的 `/chapter_4/urls.py` 文件中，您应该有如下代码块中显示的路径，使用突出显示的 `name` 属性：
- en: '[PRE56]'
  id: totrans-244
  prefs: []
  type: TYPE_PRE
  zh: '[PRE56]'
- en: '[PRE57]'
  id: totrans-245
  prefs: []
  type: TYPE_PRE
  zh: '[PRE57]'
- en: '[PRE58]'
  id: totrans-246
  prefs: []
  type: TYPE_PRE
  zh: '[PRE58]'
- en: '[PRE59]'
  id: totrans-247
  prefs: []
  type: TYPE_PRE
  zh: '[PRE59]'
- en: '[PRE60]'
  id: totrans-248
  prefs: []
  type: TYPE_PRE
  zh: '[PRE60]'
- en: '[PRE61]'
  id: totrans-249
  prefs: []
  type: TYPE_PRE
  zh: '[PRE61]'
- en: '[PRE62]'
  id: totrans-250
  prefs: []
  type: TYPE_PRE
  zh: '[PRE62]'
- en: '[PRE63]'
  id: totrans-251
  prefs: []
  type: TYPE_PRE
  zh: '[PRE63]'
- en: '[PRE64]'
  id: totrans-252
  prefs: []
  type: TYPE_PRE
  zh: '[PRE64]'
- en: '[PRE65]'
  id: totrans-253
  prefs: []
  type: TYPE_PRE
  zh: '[PRE65]'
- en: '[PRE66]'
  id: totrans-254
  prefs: []
  type: TYPE_PRE
  zh: '[PRE66]'
- en: '[PRE67]'
  id: totrans-255
  prefs: []
  type: TYPE_PRE
  zh: '[PRE67]'
- en: '[PRE68]'
  id: totrans-256
  prefs: []
  type: TYPE_PRE
  zh: '[PRE68]'
- en: '[PRE69]'
  id: totrans-257
  prefs: []
  type: TYPE_PRE
  zh: '[PRE69]'
- en: '[PRE70]'
  id: totrans-258
  prefs: []
  type: TYPE_PRE
  zh: '[PRE70]'
- en: '[PRE71]'
  id: totrans-259
  prefs: []
  type: TYPE_PRE
  zh: '[PRE71]'
- en: '[PRE72]'
  id: totrans-260
  prefs: []
  type: TYPE_PRE
  zh: '[PRE72]'
- en: Now we can use a `reverse()` function, which we will do next.
  id: totrans-261
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们可以使用 `reverse()` 函数，我们将在下一步中这样做。
- en: Using the reverse() function
  id: totrans-262
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用 reverse() 函数
- en: The `reverse()` function provides us with the relative URL of an object, providing
    the `name` attribute value. In our view, we will write several `print` statements
    to tell us the relative path of objects when provided with different input arguments.
  id: totrans-263
  prefs: []
  type: TYPE_NORMAL
  zh: '`reverse()` 函数为我们提供了对象的相对 URL，提供了 `name` 属性值。在我们的视图中，我们将编写几个 `print` 语句来告诉我们当提供不同的输入参数时对象的相对路径。'
- en: 'Follow these steps to configure your `view` method:'
  id: totrans-264
  prefs: []
  type: TYPE_NORMAL
  zh: 按照以下步骤配置您的 `view` 方法：
- en: 'In your `/chapter_4/views.py` file, add the following `import` statement, below
    the existing `import` statements:'
  id: totrans-265
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在您的 `/chapter_4/views.py` 文件中，在现有的 `import` 语句下方添加以下 `import` 语句：
- en: '[PRE73]'
  id: totrans-266
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE73]'
- en: 'In your `/chapter_4/views.py` file, and in the same `practice_year_view()`
    method, go ahead and include the following `print` statements. Make sure these
    are placed before your conditional statement that executes the `return`/`raise`
    calls:'
  id: totrans-267
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在您的 `/chapter_4/views.py` 文件中，并在相同的 `practice_year_view()` 方法中，继续包含以下 `print`
    语句。确保这些语句放置在执行 `return`/`raise` 调用的条件语句之前：
- en: '[PRE74]'
  id: totrans-268
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE74]'
- en: 'Run your project and navigate to any URL using this pattern, such as `http://localhost:8000/my_year_path/2022/`.
    What will be printed in your terminal or command-line window is the formatted
    relative path for each of the URLs, as shown in the following screenshot:'
  id: totrans-269
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 运行您的项目并使用此模式导航到任何 URL，例如 `http://localhost:8000/my_year_path/2022/`。在您的终端或命令行窗口中打印的内容将是每个
    URL 的格式化相对路径，如下面的屏幕截图所示：
- en: '![Figure 4.11 – Naming URL – view usage'
  id: totrans-270
  prefs: []
  type: TYPE_NORMAL
  zh: '![图 4.11 – 命名 URL – 视图使用'
- en: '](img/Figure_4.11_B17243.jpg)'
  id: totrans-271
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/Figure_4.11_B17243.jpg)'
- en: Figure 4.11 – Naming URL – view usage
  id: totrans-272
  prefs: []
  type: TYPE_NORMAL
  zh: 图 4.11 – 命名 URL – 视图使用
- en: The `reverse()` method is how we can look up a URL, using the arguments that
    are passed into that function. The `reverse()` method can be imported and used
    anywhere within a project, not just within a view class or method. This method
    takes in two positional arguments, the first being the name of a URL pattern,
    such as `year_url` highlighted in the preceding example, and is required. The
    second positional argument is the keyword arguments that get passed into the `reverse()`
    method, which is sometimes required. If there is more than one path converter
    defined for a URL pattern, they would be included in the `reverse()` method in
    the order in which they were created for that pattern and separated by a comma.
    Remember that the position of the keyword arguments pertaining to each path converter
    is important and follows the order in which keyword arguments were created for
    that URL pattern.
  id: totrans-273
  prefs: []
  type: TYPE_NORMAL
  zh: '`reverse()` 方法是我们如何通过传递给该函数的参数来查找 URL。`reverse()` 方法可以在项目的任何地方导入和使用，而不仅仅是视图类或方法内部。此方法接受两个位置参数，第一个是
    URL 模式的名称，例如前一个示例中突出显示的 `year_url`，这是必需的。第二个位置参数是传递给 `reverse()` 方法的关键字参数，有时也是必需的。如果为
    URL 模式定义了多个路径转换器，它们将按照为该模式创建的顺序包含在 `reverse()` 方法中，并用逗号分隔。请记住，与每个路径转换器相关的关键字参数的位置很重要，并且遵循为该
    URL 模式创建关键字参数的顺序。'
- en: Using the {% url %} template tag
  id: totrans-274
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用 {% url %} 模板标签
- en: 'The `{% url arg1 arg2 %}` template tag works just like the `reverse()` method,
    except used directly in a template. This tag also takes in two positional arguments,
    just like the `reverse()` method does. The first argument listens for the name
    of the URL pattern and the second is the arguments list. These arguments are separated
    with a space when using this template tag. Additional arguments are provided in
    the order the path converters were created for that URL pattern. When using the
    `{% url %}` tag, it is acceptable to include arguments written with and without
    keyword syntax. For example, both of the following tags and how they are used
    are valid:'
  id: totrans-275
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE75]'
  id: totrans-276
  prefs: []
  type: TYPE_PRE
  zh: '[PRE75]'
- en: '[PRE76]'
  id: totrans-277
  prefs: []
  type: TYPE_PRE
  zh: '[PRE76]'
- en: '[PRE77]'
  id: totrans-278
  prefs: []
  type: TYPE_PRE
  zh: '[PRE77]'
- en: The second example in the preceding code block would be used if we had actually
    created three path converters for the URL pattern, being `year`, `month`, and
    `day`.
  id: totrans-279
  prefs: []
  type: TYPE_NORMAL
- en: 'They can also be replaced by using context variables, if we created the three
    context variables called `year`, `month`, and `day` to be used in a template,
    as shown in the following code block:'
  id: totrans-280
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE78]'
  id: totrans-281
  prefs: []
  type: TYPE_PRE
  zh: '[PRE78]'
- en: '[PRE79]'
  id: totrans-282
  prefs: []
  type: TYPE_PRE
  zh: '[PRE79]'
- en: The code shown previously was for illustrative purposes only and will break
    if you try to use it without building the related URL patterns and views.
  id: totrans-283
  prefs: []
  type: TYPE_NORMAL
- en: 'Follow these steps to configure your project for this exercise:'
  id: totrans-284
  prefs: []
  type: TYPE_NORMAL
- en: 'In your existing `/chapter_4/my_year.html` file, uncomment the following hyperlinks
    that have been provided with the code of the book when you copied this file into
    your project or add them manually as shown. They are formatted using the Django
    `{% url %}` template tag:'
  id: totrans-285
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE80]'
  id: totrans-286
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE80]'
- en: 'Run your project and navigate to the same URL, `http://localhost:8000/my_year_path/2022/`,
    and you should now see what is depicted in the following screenshot, with the
    hyperlinks rendered to the page:'
  id: totrans-287
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![Figure 4.12 – Naming URL – template usage'
  id: totrans-288
  prefs: []
  type: TYPE_NORMAL
- en: '](img/Figure_4.12_B17243.jpg)'
  id: totrans-289
  prefs: []
  type: TYPE_NORMAL
- en: Figure 4.12 – Naming URL – template usage
  id: totrans-290
  prefs: []
  type: TYPE_NORMAL
- en: Each hyperlink that is rendered points to the correlating relative path at `href="/my_year_path/####/"`.
    We can continue modifying these two examples to format absolute URLs instead of
    relative URLs. This means we will include the `www.example.com` part of the URL.
    We will discuss that in the section titled *Resolving absolute URLs* later in
    this chapter. Let's process trailing slashes next.
  id: totrans-291
  prefs: []
  type: TYPE_NORMAL
- en: Processing trailing slashes
  id: totrans-292
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In Django, we can use the `re_path()` function in combination with the custom
    `YearConverter` class to write one URL pattern accepting a path with and without
    a trailing slash, `/`. What this means is that we can write a URL to listen for
    `www.example.com/my_path/` and will also allow `www.example.com/my_path` to render
    a success, essentially combining two paths into one statement.
  id: totrans-293
  prefs: []
  type: TYPE_NORMAL
- en: 'To process your trailing slashes, in your `/chapter_4/urls.py` file, add the
    following path and comment out all other `my_year_path` examples:'
  id: totrans-294
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE81]'
  id: totrans-295
  prefs: []
  type: TYPE_PRE
  zh: '[PRE81]'
- en: '[PRE82]'
  id: totrans-296
  prefs: []
  type: TYPE_PRE
  zh: '[PRE82]'
- en: '[PRE83]'
  id: totrans-297
  prefs: []
  type: TYPE_PRE
  zh: '[PRE83]'
- en: '[PRE84]'
  id: totrans-298
  prefs: []
  type: TYPE_PRE
  zh: '[PRE84]'
- en: '[PRE85]'
  id: totrans-299
  prefs: []
  type: TYPE_PRE
  zh: '[PRE85]'
- en: '[PRE86]'
  id: totrans-300
  prefs: []
  type: TYPE_PRE
  zh: '[PRE86]'
- en: '[PRE87]'
  id: totrans-301
  prefs: []
  type: TYPE_PRE
  zh: '[PRE87]'
- en: '[PRE88]'
  id: totrans-302
  prefs: []
  type: TYPE_PRE
  zh: '[PRE88]'
- en: '[PRE89]'
  id: totrans-303
  prefs: []
  type: TYPE_PRE
  zh: '[PRE89]'
- en: '[PRE90]'
  id: totrans-304
  prefs: []
  type: TYPE_PRE
  zh: '[PRE90]'
- en: '[PRE91]'
  id: totrans-305
  prefs: []
  type: TYPE_PRE
  zh: '[PRE91]'
- en: '[PRE92]'
  id: totrans-306
  prefs: []
  type: TYPE_PRE
  zh: '[PRE92]'
- en: '[PRE93]'
  id: totrans-307
  prefs: []
  type: TYPE_PRE
  zh: '[PRE93]'
- en: '[PRE94]'
  id: totrans-308
  prefs: []
  type: TYPE_PRE
  zh: '[PRE94]'
- en: '[PRE95]'
  id: totrans-309
  prefs: []
  type: TYPE_PRE
  zh: '[PRE95]'
- en: '[PRE96]'
  id: totrans-310
  prefs: []
  type: TYPE_PRE
  zh: '[PRE96]'
- en: '[PRE97]'
  id: totrans-311
  prefs: []
  type: TYPE_PRE
  zh: '[PRE97]'
- en: '[PRE98]'
  id: totrans-312
  prefs: []
  type: TYPE_PRE
  zh: '[PRE98]'
- en: '[PRE99]'
  id: totrans-313
  prefs: []
  type: TYPE_PRE
  zh: '[PRE99]'
- en: '`route` is defined in the `re_path()` function as `r''^my_year_path/(?P<year>[0-9]+)/?$''`,
    which constructs the path in a way that will listen for an optional forward slash.
    `year` is also written using just the tag name. If we were to write the statement
    using `<year:year>` as we did in previous exercises, then we would receive the
    following error message in the terminal or command-line window:'
  id: totrans-314
  prefs: []
  type: TYPE_NORMAL
  zh: '`route`在`re_path()`函数中定义为`r''^my_year_path/(?P<year>[0-9]+)/?$''`，它以这种方式构建路径，以便监听可选的前斜杠。`year`也仅使用标签名编写。如果我们像在之前的练习中那样使用`<year:year>`来编写这个语句，那么我们将在终端或命令行窗口收到以下错误信息：'
- en: '[PRE100]'
  id: totrans-315
  prefs: []
  type: TYPE_PRE
  zh: '[PRE100]'
- en: 'Since we are listening for a trailing slash via the use of regular expression
    operations, there is no need to modify values in the `settings.py` file, such
    as `APPEND_SLASH`. In order to actually use the `APPEND_SLASH` variable, Django
    requires the `common` middleware to be installed. You can learn more about using
    this approach instead of the regular expression approach here: https://docs.djangoproject.com/en/4.0/ref/settings/#append-slash.
    Using the regular expression basic structure shown previously, we don''t need
    to worry about middleware.'
  id: totrans-316
  prefs: []
  type: TYPE_NORMAL
  zh: 由于我们通过正则表达式操作监听尾随斜杠，因此无需修改`settings.py`文件中的值，如`APPEND_SLASH`。为了实际使用`APPEND_SLASH`变量，Django需要安装`common`中间件。您可以在以下链接中了解更多关于使用此方法而不是正则表达式方法的信息：https://docs.djangoproject.com/en/4.0/ref/settings/#append-slash。使用之前显示的正则表达式基本结构，我们不需要担心中间件。
- en: Now that we have resolved relative URLs, let's resolve absolute URLs next.
  id: totrans-317
  prefs: []
  type: TYPE_NORMAL
  zh: 既然我们已经解决了相对URL，接下来让我们解决绝对URL。
- en: Resolving absolute URLs
  id: totrans-318
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 解决绝对URL
- en: 'An absolute URL includes the scheme, host, and port of a URL, as in the following
    format, `scheme://host:port/path?query`. This is an example of an absolute URL:
    [https://www.example.com:8000/my_path?query=my_query_value](https://www.example.com:8000/my_path?query=my_query_value).'
  id: totrans-319
  prefs: []
  type: TYPE_NORMAL
  zh: 一个绝对URL包括URL的方案、主机和端口号，如下所示，`scheme://host:port/path?query`。这是一个绝对URL的例子：[https://www.example.com:8000/my_path?query=my_query_value](https://www.example.com:8000/my_path?query=my_query_value)。
- en: Next, we will resolve an absolute URL while introducing the practice of using
    custom context processors.
  id: totrans-320
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们将介绍使用自定义上下文处理器的实践，同时解决一个绝对URL。
- en: Creating a context processor
  id: totrans-321
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 创建上下文处理器
- en: 'Context processors are useful in many ways: they provide context that is shared
    globally among all templates and views within a project. Alternatively, the context
    being created in a view can only be used by the template that the view is using
    and no other templates. In the next example, we will create and then activate
    a custom global context processor where we will add the base URL of the site.
    We will call the context variable `base_url`, referring to `scheme://host:port`
    of the URL found throughout this project''s site.'
  id: totrans-322
  prefs: []
  type: TYPE_NORMAL
  zh: 上下文处理器在许多方面都很有用：它们提供了在项目中的所有模板和视图中共享的全局上下文。或者，在视图中创建的上下文只能由使用该视图的模板使用，而不能由其他模板使用。在下一个示例中，我们将创建并激活一个自定义的全局上下文处理器，我们将添加站点的基URL。我们将上下文变量命名为`base_url`，指的是整个项目站点中找到的URL的`scheme://host:port`。
- en: 'Follow these steps to create your context processor:'
  id: totrans-323
  prefs: []
  type: TYPE_NORMAL
  zh: 按照以下步骤创建您的上下文处理器：
- en: In the same folder as your `settings.py` file, create a new file called `context_processors.py`.
  id: totrans-324
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在您的`settings.py`文件所在的同一文件夹中，创建一个名为`context_processors.py`的新文件。
- en: 'Inside this file, place the code provided as follows, which will construct
    the `http://localhost:8000` portion of the site based on the environment we are
    running the project on:'
  id: totrans-325
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在此文件中，放置以下提供的代码，这将根据我们在其上运行项目的环境构建站点的`http://localhost:8000`部分：
- en: '[PRE101]'
  id: totrans-326
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE101]'
- en: Context is returned as a dictionary of key-value pairs, where we can pack as
    many keys as we would like to.
  id: totrans-327
  prefs: []
  type: TYPE_NORMAL
  zh: 上下文作为键值对的字典返回，我们可以打包我们想要的任意多的键。
- en: 'To register this context processor for inclusion during runtime, we need to
    add it to the `settings.py` file, under the `TEMPLATES` variable. Include the
    path to your `global_context()` method, as shown:'
  id: totrans-328
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 为了在运行时注册此上下文处理器，我们需要将其添加到`settings.py`文件中的`TEMPLATES`变量下。包括您的`global_context()`方法的路径，如下所示：
- en: '[PRE102]'
  id: totrans-329
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE102]'
- en: Place your custom context processor below any existing `context_processors`
    in the preceding list.
  id: totrans-330
  prefs: []
  type: TYPE_NORMAL
  zh: 将您的自定义上下文处理器放置在前面列表中的任何现有`context_processors`下面。
- en: Context processors can be broken down into individual apps within a project
    as well. Include each additional context processor that you create inside the
    preceding list and in the order desired. Additional global context processor variables
    have been included with the code of this book for extra practice as well.
  id: totrans-331
  prefs: []
  type: TYPE_NORMAL
- en: Let's use our newly created `base_url` context in a template next.
  id: totrans-332
  prefs: []
  type: TYPE_NORMAL
- en: Using context processor data in a template
  id: totrans-333
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Using a `{% url %}` template tag, we can modify hyperlinks to use the context
    that we just made available in the previous example as a context processor called
    `global_context()`.
  id: totrans-334
  prefs: []
  type: TYPE_NORMAL
- en: 'Follow these steps to configure your template:'
  id: totrans-335
  prefs: []
  type: TYPE_NORMAL
- en: 'In your `/chapter_4/urls.py` file, add the following path and comment out all
    other `my_year_path` examples:'
  id: totrans-336
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE103]'
  id: totrans-337
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE103]'
- en: 'In your `my_year.html` file, write/uncomment the following hyperlink examples:'
  id: totrans-338
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE104]'
  id: totrans-339
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE104]'
- en: Navigate to `http://localhost:8000/my_year_path/2022/` one more time. Your `href`
    attribute on each hyperlink will now look like `href="http://localhost:8000/my_year_path/####/"`
    instead of what it was rendering before, as `href="/my_year_path/####/"`.
  id: totrans-340
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: When we added the `{{ base_url }}` template variable, we referenced the dictionary
    key of the context that was provided.
  id: totrans-341
  prefs: []
  type: TYPE_NORMAL
- en: From the request object
  id: totrans-342
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'In this exercise, we will resolve the absolute URL using a `request` object.
    Follow these steps to do that in your project:'
  id: totrans-343
  prefs: []
  type: TYPE_NORMAL
- en: 'In your `/chapter_4/views.py` file, in your existing `practice_year_view()`
    method, include the following `print` statements. These statements will use the
    `build_absolute_uri()` method provided in your `request` object, as part of the
    Django framework. This will return to us the absolute URL of the reverse lookup:'
  id: totrans-344
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE105]'
  id: totrans-345
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE105]'
- en: The preceding `print` statements also utilize the `reverse()` method found in
    the `django.urls` library.
  id: totrans-346
  prefs: []
  type: TYPE_NORMAL
- en: 'Run your project and navigate to `http://localhost:8000/my_year_path/2022/`.
    You should see the following paths printed in your terminal or command-line window:'
  id: totrans-347
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![Figure 4.13 – Naming URL – view usage – absolute URL'
  id: totrans-348
  prefs: []
  type: TYPE_NORMAL
- en: '](img/Figure_4.13_B17243.jpg)'
  id: totrans-349
  prefs: []
  type: TYPE_NORMAL
- en: Figure 4.13 – Naming URL – view usage – absolute URL
  id: totrans-350
  prefs: []
  type: TYPE_NORMAL
- en: Note
  id: totrans-351
  prefs: []
  type: TYPE_NORMAL
- en: The relative path of the current page can be retrieved from the `request` object
    using `print(request.path)`. On this page, it would return `/my_year_path/2022/`.
    Using `print(request.build_absolute_uri())` without the `reverse()` lookup function
    will return the absolute path of that particular request.
  id: totrans-352
  prefs: []
  type: TYPE_NORMAL
- en: Let's practice looking up absolute URLs from within a model class next.
  id: totrans-353
  prefs: []
  type: TYPE_NORMAL
- en: From within a model class
  id: totrans-354
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: We will be expanding on the same `vehicle_view()` method for this next example,
    to get a formatted URL from an existing object. We are going to work in the same
    `/chapter_3/models.py` file that we worked on in [*Chapter 3*](B17243_03_ePub.xhtml#_idTextAnchor077),
    *Models, Relations, and Inheritance*.
  id: totrans-355
  prefs: []
  type: TYPE_NORMAL
- en: 'Follow these steps to configure your model class:'
  id: totrans-356
  prefs: []
  type: TYPE_NORMAL
- en: 'In your `/chapter_3/models.py` file, add the following two methods (`get_url()`
    and `get_absolute_url()`) to your existing `Vehicle` model class:'
  id: totrans-357
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE106]'
  id: totrans-358
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE106]'
- en: These methods import the `reverse()` function that was introduced earlier in
    this section to get the URL of the object in reference. The `import` statements
    are added to the methods themselves instead of at the top of this document to
    allow for better performance handling when using these model class methods. The
    first method, `get_url()`, is used to return a relative URL path to that object,
    while the other method, `get_absolute_url()`, is intended to return the absolute
    path to that object.
  id: totrans-359
  prefs: []
  type: TYPE_NORMAL
- en: 'In your `/chapter_4/views.py` file, in the existing `vehicle_view()` method,
    add the following `print` statements as part of the `else` catch, just after the
    `except` catch:'
  id: totrans-360
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE107]'
  id: totrans-361
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE107]'
- en: The `else` catch means the `Vehicle` object that it was searching for was found
    without errors. Remember to leave the same `return` statement that we previously
    wrote at the end of this `vehicle_view()` method.
  id: totrans-362
  prefs: []
  type: TYPE_NORMAL
- en: 'Run your project and navigate to `http://localhost:8000/vehicle/4/`. In your
    terminal or command-line window, you should see the two different relative and
    absolute paths to the object that we looked up in the `vehicle_view()` method,
    as shown:'
  id: totrans-363
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![Figure 4.14 – Model URLs'
  id: totrans-364
  prefs: []
  type: TYPE_NORMAL
- en: '](img/Figure_4.14_B17243.jpg)'
  id: totrans-365
  prefs: []
  type: TYPE_NORMAL
- en: Figure 4.14 – Model URLs
  id: totrans-366
  prefs: []
  type: TYPE_NORMAL
- en: We have been practicing with simple views, otherwise known as method-based views.
    Many projects need views to provide a bit more power and usability, which can
    be achieved with class-based views, which we will create next.
  id: totrans-367
  prefs: []
  type: TYPE_NORMAL
- en: Working with complex views
  id: totrans-368
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: A view method will suffice for a lot of different situations. For more robust
    and large-scale projects, we can apply a few tricks to make these views more adaptable
    in complicated use cases. Class-based views are used when writing adaptable and
    reusable applications.
  id: totrans-369
  prefs: []
  type: TYPE_NORMAL
- en: Class-based views
  id: totrans-370
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: With class-based views, we can write code that can be reused and extended easily.
    Just like when we extended models in [*Chapter 3*](B17243_03_ePub.xhtml#_idTextAnchor077),
    *Models, Relations, and Inheritance*, we can extend view classes in the exact
    same way, whereas function-based view methods cannot provide this ability. Two
    templates have been provided with the source code of this book to be used in the
    next exercise. These two files are the exact same file as the `my_vehicle.html`
    file, except that the title of the `<h1>` tag in each has been changed to **VehicleView
    Class 1** and **VehicleView Class 2** so that when we run the following examples,
    we can see the differences between them.
  id: totrans-371
  prefs: []
  type: TYPE_NORMAL
- en: 'Follow these steps to configure your class-based views:'
  id: totrans-372
  prefs: []
  type: TYPE_NORMAL
- en: Copy the files called `my_vehicle_class_1.html` and `my_vehicle_class_2.html`
    in the `/becoming_a_django_entdev/chapter_4/templates/chapter_4/` directory of
    the code provided with this book into your project at the same directory.
  id: totrans-373
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'In your `/chapter_4/urls.py` file, add the following `import` statement and
    URL pattern:'
  id: totrans-374
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE108]'
  id: totrans-375
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE108]'
- en: Don't forget to comment out the old `/vehicle/` URL patterns that were written
    before experimenting with this one.
  id: totrans-376
  prefs: []
  type: TYPE_NORMAL
- en: 'In your `/chapter_4/views.py` file, create the class-based view called `VehicleView`
    and add the `import` statements, as shown:'
  id: totrans-377
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE109]'
  id: totrans-378
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE109]'
- en: 'Add the following `get()` method to your `VehicleView` class:'
  id: totrans-379
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE110]'
  id: totrans-380
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE110]'
- en: 'Add the following `post()` method and import to your `VehicleView` class:'
  id: totrans-381
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE111]'
  id: totrans-382
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE111]'
- en: Run your project and navigate to `http://localhost:8000/vehicle/4/`. You should
    see the main title is displayed as **VehicleView Class 1** now.
  id: totrans-383
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Next, modify the URL pattern to overload `template_name`, using the following
    example:'
  id: totrans-384
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE112]'
  id: totrans-385
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE112]'
- en: Now, rerun your project and navigate to the URL at `http://localhost:8000/vehicle/4/`.
    You should see the title on the page displayed as **VehicleView Class 2** this
    time.
  id: totrans-386
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The `def get()` submethod depicted in *step 4* is where all of the code in the
    method-based view is moved to. It's also the only required method. Other optional
    methods, such as `def post()`, are used when working with form objects, when a
    postback response is executed. It can also be used to redirect the user to a success
    page, which is illustrated in the code of *step 5*, but you will never get Django
    to trigger this redirect with how we are using this class now, which is to be
    expected. We will discuss this in more depth later in [*Chapter 5*](B17243_05_ePub.xhtml#_idTextAnchor152),
    *Django Forms*. When we are working with positional keyword arguments of a URL,
    they are passed into the view class, where the `id` attribute is written in the
    preceding `get()` method. If you have more than one keyword argument, they would
    be added after `id` in the order that they exist in that URL pattern.
  id: totrans-387
  prefs: []
  type: TYPE_NORMAL
- en: We performed *step 7* and *step 8* just to check that this is working and to
    see how we can still override default settings just like we did earlier in this
    chapter. Let's extend our class-based views next, also known as inheritance.
  id: totrans-388
  prefs: []
  type: TYPE_NORMAL
- en: Extending class-based views
  id: totrans-389
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Extending class-based views, also known as inheritance, is done in the exact
    same way as when we extended model classes in [*Chapter 3*](B17243_03_ePub.xhtml#_idTextAnchor077),
    *Models, Relations, and Inheritance*. We can display the same title on the page
    by extending the first class into a second class, eliminating the need to define
    `template_name` in the URL pattern itself, among many other benefits.
  id: totrans-390
  prefs: []
  type: TYPE_NORMAL
- en: 'Follow these steps to extend your class:'
  id: totrans-391
  prefs: []
  type: TYPE_NORMAL
- en: 'In your `/chapter_4/urls.py` file, comment out the previous URL patterns and
    write a new one using the code provided, where we are using `VehicleView2` as
    the view class now:'
  id: totrans-392
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE113]'
  id: totrans-393
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE113]'
- en: 'Next, in your `/chapter_4/views.py` file, add the following `VehicleView2`
    class constructed from the `VehicleView` class:'
  id: totrans-394
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE114]'
  id: totrans-395
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE114]'
- en: Run your project and navigate to the URL `http://localhost:8000/vehicle/4/`.
    You should see the same title, **VehicleView Class 2**, displayed on the page.
  id: totrans-396
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The preceding example is just a very simple extension of the existing `VehicleView`
    class that demonstrates how to extend a view class. The only thing we are changing/overriding
    in this exercise is the `template_name` variable in order to demonstrate this
    concept.
  id: totrans-397
  prefs: []
  type: TYPE_NORMAL
- en: Next, let's learn what asynchronous views are used for.
  id: totrans-398
  prefs: []
  type: TYPE_NORMAL
- en: Asynchronous views
  id: totrans-399
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Django also offers support of asynchronous views, a feature first introduced
    in Django 3.1\. Asynchronous views are views that can be processed in individual
    processing threads and run together at the same time. These are used to build
    better multithreaded apps. Traditional Django projects use the **Web Server Gateway
    Interface** (**WSGI**) by default. To actually use asynchronous function- and
    class-based views, we need to configure a project and the server to use the **Asynchronous
    Server Gateway Interface** (**ASGI**) instead of WSGI. Since this requires quite
    a bit more work to configure the server and potentially the hosting provider,
    we will skip providing any examples for this section, but if this is something
    you want or need in your project, you can get started here: [https://docs.djangoproject.com/en/4.0/topics/async/](https://docs.djangoproject.com/en/4.0/topics/async/).'
  id: totrans-400
  prefs: []
  type: TYPE_NORMAL
- en: Up to now, we have been using templates that have been pre-built and provided
    with the code of this book in order to demonstrate core programming concepts.
    Next, let's explore what it takes to actually build those templates on our own.
  id: totrans-401
  prefs: []
  type: TYPE_NORMAL
- en: Working with templates
  id: totrans-402
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The Django template language provides us with a set of template tags and template
    filters that are used to perform simple actions directly within a template. It
    makes it easy to perform simple logic operations, such as Python operations. Tags
    and filters are actually two different things that closely resemble each other.
    The Django template language can be closely compared to Shopify''s Liquid syntax
    and is similar to the Razor syntax used in ASP.NET frameworks, but the Django
    template language is a bit easier to use and read. Django also allows us to create
    custom tags and filters for use within a project. Custom filters are most commonly
    used to transform a single context variable. Custom tags provide for more robust
    and complex use cases. For a complete breakdown of all of the template tags and
    template filters that exist, read the official Django documentation about them
    here: [https://docs.djangoproject.com/en/4.0/ref/templates/builtins/](https://docs.djangoproject.com/en/4.0/ref/templates/builtins/).'
  id: totrans-403
  prefs: []
  type: TYPE_NORMAL
- en: Next, we will touch briefly on the features and capabilities of the most commonly
    used template tags and filters that are available.
  id: totrans-404
  prefs: []
  type: TYPE_NORMAL
- en: Template tags
  id: totrans-405
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: We can structure a template to feel more like an app by breaking it down into
    smaller components. Those components can then be used interchangeably within other
    templates. For example, we can write a base template that contains the `<head>`
    and `<body>` elements of a page and then break apart subtemplates that structure
    the body content of each of those templates. Areas can be created in the `<head>`
    and `<body>` of a document where we can pass dynamic text and HTML into them,
    such as the `<title>` tag.
  id: totrans-406
  prefs: []
  type: TYPE_NORMAL
- en: For the next example, let's use the `{% block %}`, `{% extend %}`, and `{% include
    %}` template tags to create two template files, demonstrating how to break templates
    down into manageable pieces.
  id: totrans-407
  prefs: []
  type: TYPE_NORMAL
- en: 'Follow these steps to configure your template tags:'
  id: totrans-408
  prefs: []
  type: TYPE_NORMAL
- en: 'In your `/chapter_4/urls.py` file, comment out the other paths and include
    the following path:'
  id: totrans-409
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE115]'
  id: totrans-410
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE115]'
- en: 'In your `/chapter_4/views.py` file, create the following class-based view called
    `TestPageView`, using the code provided here:'
  id: totrans-411
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE116]'
  id: totrans-412
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE116]'
- en: In the `TestPageView` class, we are defining a default `template_name` as `'chapter_4/pages/test_page_1.html'`.
    In the `get()` method, we pass in hardcoded context variables to be used in this
    demonstration. In a real-world scenario, this information would be generated after
    performing logic that is written to generate those values.
  id: totrans-413
  prefs: []
  type: TYPE_NORMAL
- en: 'Create the `/becoming_a_django_entdev/chapter_4/templates/chapter_4/pages/test_page_1.html`
    file and add the following code:'
  id: totrans-414
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE117]'
  id: totrans-415
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE117]'
- en: This template starts with the `{% extends %}` template tag, which states that
    we want to actually start with the `/chapter_4/base/base_template_1.html` file,
    even though we specified the `test_page_1.html` file in our view class. Then,
    everywhere there is a `{% block %}` tag found in this file, we override or append
    to that same `{% block %}` found in the `base_template_1.html` file that we are
    extending. We are passing the value of `{{ title }}`, which was defined in the
    view, into the `{% block page_title %}` tag of the `/chapter_4/pages/test_page_1.html`
    file. The `{{ block.super }}` tag can be used to keep what is found in that same
    block of the `base_template_1.html` file. Without this tag, all code inside the
    parent block will be overwritten. HTML can be written inside of any block; the
    `{% block body_content %}` block, shown in *step 5* that follows, is where the
    bulk of the page content will be found.
  id: totrans-416
  prefs: []
  type: TYPE_NORMAL
- en: 'Create the `/chapter_4/base/base_template_1.html` file and add the code shown
    here:'
  id: totrans-417
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE118]'
  id: totrans-418
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE118]'
- en: 'In the same `/chapter_4/base/base_template_1.html` file that you just created,
    insert the body code provided next, just below your existing closing `</head>`
    tag:'
  id: totrans-419
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE119]'
  id: totrans-420
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE119]'
- en: Copy the `/chapter_4/headers/header_1.html` and `/chapter_4/footers/footer_1.html`
    files provided with the code of this book into your project in the same directory.
  id: totrans-421
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Copy the `/chapter_4/static/chapter_4/css/site.css` and `/chapter_4/static/chapter_4/js/site-js.js`
    files provided with the code of this book into your project at the same directory.
  id: totrans-422
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Run your project and navigate to `http://localhost:8000/test_page_1/`. You
    should see the following information in your browser window:'
  id: totrans-423
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![Figure 4.15 – Extending templates'
  id: totrans-424
  prefs: []
  type: TYPE_NORMAL
- en: '](img/Figure_4.15_B17243.jpg)'
  id: totrans-425
  prefs: []
  type: TYPE_NORMAL
- en: Figure 4.15 – Extending templates
  id: totrans-426
  prefs: []
  type: TYPE_NORMAL
- en: In the preceding steps, the main HTML of the page is broken down into a header,
    body content, and footer format. The `{% include %}` tags used previously demonstrate
    different ways of working with those files. Adding a `with` attribute to any `{%
    include %}` tag is how we can pass context into that file from the parent template.
    That is what is done to the preceding footer file. This means making context available
    without the need for a context processor or by writing code twice. The preceding
    HTML is structured in a way that allows us to get fancy by modifying everything
    within the `{% block site_container %}` tag, if we wanted or needed to. In order
    to do that, we would write the `{% block site_container %}` block again in the
    file that extends this template file and write the modified code there. That is
    essentially what *step 3* did for us, with the `{% block body_content %}` tag.
  id: totrans-427
  prefs: []
  type: TYPE_NORMAL
- en: Let's work with template filters next.
  id: totrans-428
  prefs: []
  type: TYPE_NORMAL
- en: Template filters
  id: totrans-429
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Template filters are a way to transform the value of a context variable. They
    can do things such as make a string upper or lowercase using the `{{ context_variable|upper
    }}` or `{{ context_variable|lower }}` filters. They can be used to find the number
    of items in a list using the `{{ my_list|length }}` filter or even format time
    with a `{{ my_time|time:"` `n/j/Y" }}` filter. When using a `time` filter, it
    is not necessary to specify the `:" n/j/Y"` argument of that filter. Even without
    these specifications, Django will default to the setting specified in your `settings.py`
    file as the `TIME_FORMAT` variable. To learn about all of the filters that are
    available, visit the official Django documentation found here: https://docs.djangoproject.com/en/4.0/ref/templates/builtins/#built-in-filter-reference.'
  id: totrans-430
  prefs: []
  type: TYPE_NORMAL
- en: Let's check out custom tags and filters next.
  id: totrans-431
  prefs: []
  type: TYPE_NORMAL
- en: Custom tags and filters
  id: totrans-432
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Earlier, in *Figure 4.10*, we saw that the value of the make of the vehicle
    was displayed as the number **3**. This is a perfect example of how we can write
    a custom filter that takes in a numeric value and returns the string representation
    of that value.
  id: totrans-433
  prefs: []
  type: TYPE_NORMAL
- en: 'Follow these steps to create your custom filter:'
  id: totrans-434
  prefs: []
  type: TYPE_NORMAL
- en: Create a new folder in the `/becoming_a_django_entdev/chapter_4/` directory
    called `templatetags`.
  id: totrans-435
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Create a new file in this folder called `chapter_4.py` and inside this file,
    place the following code:'
  id: totrans-436
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE120]'
  id: totrans-437
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE120]'
- en: Here, we are writing a very simple method called `vehicle_make()` that takes
    in the numeric value of `3` and returns to us the string representation of `Chevrolet`,
    when used in a template. In this method, we are using Python path syntax to import
    the `MAKE_CHOICES` variable, which we created in [*Chapter 3*](B17243_03_ePub.xhtml#_idTextAnchor077),
    *Models, Relations, and Inheritance*, in the subsection titled *Mutable versus
    immutable objects*.
  id: totrans-438
  prefs: []
  type: TYPE_NORMAL
- en: 'Make sure you have uncommented previous URL patterns and use the one shown
    in the following code block:'
  id: totrans-439
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE121]'
  id: totrans-440
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE121]'
- en: 'In your existing `/chapter_4/my_vehicle.html` file, change `{{ vehicle.make
    }}` to the statement we can see highlighted in the following code block, and add
    the `chapter_4` template tag library to your `{% load %}` tag:'
  id: totrans-441
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE122]'
  id: totrans-442
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE122]'
- en: In order to use the template filter that we registered, we import it into the
    HTML file using the `{% load chapter_4 %}` tag, where the name of the template
    tag set that we are loading is the name of the Python file that we created in
    any `templatetags` folder of an app.
  id: totrans-443
  prefs: []
  type: TYPE_NORMAL
- en: Now, making sure your project is running, you can navigate to the URL at `http://localhost:8000/vehicle/4/`
    to see that our vehicle now says **Chevrolet**.
  id: totrans-444
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Creating custom template tags instead of custom filters can be done by changing
    `@register.filter(name = ''my_filter'')` to `@register.tag(name = ''my_tag'')`.
    In this scenario, the tag can be used in a template similar to `{% my_tag %}`.
    To learn more about the complexities of writing your own template tags and how
    they can be useful in your project, visit the official documentation on that subject
    found here: https://docs.djangoproject.com/en/4.0/howto/custom-template-tags/#writing-custom-template-tags.'
  id: totrans-445
  prefs: []
  type: TYPE_NORMAL
- en: Next, let's add some custom error pages.
  id: totrans-446
  prefs: []
  type: TYPE_NORMAL
- en: Error page templates
  id: totrans-447
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Django provides a very easy way to create your own custom error page templates
    for errors such as 400, 403, 404, and 500\. Other errors, such as a `templates`
    directories, `400.html`, `403.html`, `404.html`, and `500.html`, as long as they
    are not placed in a subfolder. These four template files have been provided with
    the code of this book and follow the same design pattern as depicted in the subsection
    titled *Template tags* of this chapter. In order to see a custom debug template,
    we must turn off `DEBUG` in the `settings.py` file.
  id: totrans-448
  prefs: []
  type: TYPE_NORMAL
- en: 'Follow these steps to configure your error pages:'
  id: totrans-449
  prefs: []
  type: TYPE_NORMAL
- en: Copy the four error page template files found in the `/becoming_a_django_entdev/chapter_4/templates/`
    directory provided with the code of this book into the same directory of your
    project. Those four files are `400.html`, `403.html`, `404.html`, and `500.html`,
    and also copy the `base_error.html` file found in the same directory.
  id: totrans-450
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'In your `settings.py` file, change the following value to `False`:'
  id: totrans-451
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE123]'
  id: totrans-452
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE123]'
- en: 'Make sure your virtual environment is activated and run the `collectstatic`
    command shown here, in order to have access to the static files that have been
    created up to this point in time:'
  id: totrans-453
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE124]'
  id: totrans-454
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE124]'
- en: With `DEBUG` turned off, we have to run the `collectstatic` command in order
    to see changes reflect in the browser every time a static file is changed.
  id: totrans-455
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Now, run your project and navigate to any non-existent URL on the site, a URL
    that we have not created a URL pattern for yet, such as `http://localhost:8000/asdfasdf`.
    You should see the following message in your browser window instead of the debug
    error message we are used to seeing, such as in *Figure 4.2*:'
  id: totrans-456
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![Figure 4.16 – Custom error page'
  id: totrans-457
  prefs: []
  type: TYPE_NORMAL
- en: '](img/Figure_4.16_B17243.jpg)'
  id: totrans-458
  prefs: []
  type: TYPE_NORMAL
- en: Figure 4.16 – Custom error page
  id: totrans-459
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  id: totrans-460
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: By now, we have constructed what might feel like an entire project, but in reality,
    an application will consist of so much more than what was covered in this chapter.
    What we do have is a way to route URL paths to views and render different contexts
    in each template used. We learned how we can query the database in a view to get
    the data that we want to render in a template. We even covered the different ways
    we can handle and process an error page or simply redirect a URL to another path.
    We even used class-based views to write reusable class structures, making a project
    more adaptable to change in the long run.
  id: totrans-461
  prefs: []
  type: TYPE_NORMAL
- en: In the next chapter, we will discuss how we can use form objects in combination
    with the function-based and class-based views and templates we learned how to
    create in this chapter.
  id: totrans-462
  prefs: []
  type: TYPE_NORMAL
