<html><head></head><body>
<div id="sbo-rt-content"><div id="_idContainer236">
<h1 class="chapter-number" id="_idParaDest-173"><a id="_idTextAnchor173"/>11</h1>
<h1 id="_idParaDest-174"><a id="_idTextAnchor174"/>Introducing ROS</h1>
<p>In this chapter, we introduce the <strong class="bold">Robot Operating System</strong> (<strong class="bold">ROS</strong>), a powerful tool for developing<a id="_idIndexMarker834"/> robotics applications. We will explore the significance of ROS in the field of robotics and detail the process of setting up ROS on a Raspberry Pi 4. This involves replacing the standard Raspberry Pi OS with Ubuntu, due to Ubuntu’s compatibility and optimization for specific versions <span class="No-Break">of ROS.</span></p>
<p>We will start our hands-on exercises setting up and<a id="_idIndexMarker835"/> running <strong class="bold">TurtleSim</strong>, a user-friendly ROS simulator. We will do this to gain knowledge of basic ROS concepts and operations. Starting with simple keyboard controls, we will learn how to command and maneuver a virtual robot within the simulator environment. We will follow this up by progressing to controlling the TurtleSim simulator with <strong class="bold">Message Queuing Telemetry Transport</strong> (<strong class="bold">MQTT</strong>) messages<a id="_idIndexMarker836"/> as we start to bridge the gap between simulation and <span class="No-Break">real-world application.</span></p>
<p>Building on the skills developed through working with TurtleSim will prepare us for constructing our advanced IoT robot named A.R.E.S. (short for Advanced Robot Eyes for Security). A.R.E.S. is the final and most sophisticated project of the book and will comprise the <span class="No-Break">remaining chapters.</span></p>
<p>We will cover the following topics in <span class="No-Break">this chapter:</span></p>
<ul>
<li><span class="No-Break">Exploring ROS</span></li>
<li>Installing Ubuntu and ROS onto our <span class="No-Break">Raspberry Pi</span></li>
<li>Running and controlling a <span class="No-Break">simulated robot</span></li>
</ul>
<p><span class="No-Break">Let’s begin!</span></p>
<h1 id="_idParaDest-175"><a id="_idTextAnchor175"/>Technical requirements</h1>
<p> The following are the requirements for completing <span class="No-Break">this chapter:</span></p>
<ul>
<li>Intermediate knowledge of <span class="No-Break">Python programming</span></li>
<li>Basic knowledge of the Linux <span class="No-Break">command line</span></li>
<li>A CloudAMQP account for the MQTT <span class="No-Break">server instance</span></li>
<li>Late-model Raspberry Pi 4 or any computer capable of installing Ubuntu (Ubuntu installed on a Mac mini was used in <span class="No-Break">this chapter)</span></li>
<li>microSD card and microSD – <span class="No-Break">USB adapter</span></li>
</ul>
<p>The code for this chapter may be <span class="No-Break">found here:</span></p>
<p><a href="https://github.com/PacktPublishing/Internet-of-Things-Programming-Projects-2nd-Edition/tree/main/Chapter11"><span class="No-Break">https://github.com/PacktPublishing/-Internet-of-Things-Programming-Projects-2nd-Edition/tree/ma<span id="_idTextAnchor176"/><span id="_idTextAnchor177"/>in/Chapter11</span></a></p>
<h1 id="_idParaDest-176"><a id="_idTextAnchor178"/>Exploring ROS</h1>
<p>In this section, we will <a id="_idIndexMarker837"/>explore the basics of ROS. This section is <a id="_idIndexMarker838"/>by no means an in-depth replacement for the excellent documentation that may be found on the ROS website <span class="No-Break">at </span><a href="https://www.ros.org/"><span class="No-Break">www.ros.org</span></a><span class="No-Break">.</span></p>
<p>ROS is an <strong class="bold">Open Source Software</strong> (<strong class="bold">OSS</strong>) development kit for robotics applications, providing a <a id="_idIndexMarker839"/>standard platform that bridges the gap between research and production. Designed to speed up the robotics development process, ROS simplifies the creation of robotic systems. It is 100% open source and <span class="No-Break">commercially friendly.</span></p>
<p>Our goal here is to establish a common knowledge base, equipping us with the essential concepts and tools of ROS needed for this chapter’s project and, eventually, our A.R.E.S. robot. We will start by outlining the main project of this chapter: the control of the ROS TurtleSim virtual robot using <span class="No-Break">MQTT messaging.</span></p>
<h2 id="_idParaDest-177"><a id="_idTextAnchor179"/>Reviewing our TurtleSim controller ROS application</h2>
<p>TurtleSim is a<a id="_idIndexMarker840"/> lightweight robot simulator provided by ROS and is primarily used as an educational tool for learning ROS concepts. It offers a simple interface for teaching the basics of ROS, allowing users to experiment with commands and observe the behavior of a simulated robot in a safe and <span class="No-Break">controlled environment.</span></p>
<p>For the main project in this chapter, we will control a TurtleSim instance with MQTT messages as we command the robot to draw a circle or stop moving based on the message we transmit to the <strong class="source-inline">move</strong> topic of our <span class="No-Break">MQTT instance.</span></p>
<p>In <span class="No-Break"><em class="italic">Figure 11</em></span><em class="italic">.1</em>, we see our application illustrated. Messages created using the MQTT-Explorer in Windows are sent to the <strong class="source-inline">circle</strong> node we create in ROS. Based on the message, either <strong class="source-inline">draw_circle</strong> or <strong class="source-inline">stop</strong>, we send a <strong class="source-inline">cmd_vel</strong> topic ROS message to a TurtleSim instance. This internal messaging uses publishers and subscribers and is like the way <a id="_idIndexMarker841"/>MQTT communication <span class="No-Break">is performed:</span></p>
<div>
<div class="IMG---Figure" id="_idContainer217">
<img alt="Figure 11.1 – Using MQTT messages to control a simulated robot" height="462" src="image/B21282_11_1.jpg" width="1193"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 11.1 – Using MQTT messages to control a simulated robot</p>
<p>For the application in this chapter, we will be sending messages directly using the MQTT-Explorer app. In the next chapter, we will build an IoT joystick with a Raspberry Pi Pico W and use it to control the <span class="No-Break">simulated robot.</span></p>
<p>Now that we’ve outlined our chapter’s goals, let’s step back to gain a basic understanding of ROS concepts. This overview will provide us with a fundamental insight into its architecture and role <span class="No-Break">in robotics.</span></p>
<h2 id="_idParaDest-178"><a id="_idTextAnchor180"/>Understanding ROS node communication</h2>
<p>ROS supports<a id="_idIndexMarker842"/> a wide range of applications and platforms, including Linux, Windows, macOS, and embedded systems, making it highly versatile. Its modular framework is based on the concepts of nodes, topics, services, and actions. Nodes in ROS are individual processes that perform specific computations, and topics serve as communication channels where nodes exchange messages using a <span class="No-Break">publisher-subscriber mechanism.</span></p>
<p>For our <a id="_idIndexMarker843"/>application, we will be using a topic and publisher-subscriber model to send <strong class="source-inline">vel_msg</strong> messages of the <strong class="source-inline">cmd_vel</strong> topic from our custom <strong class="source-inline">circle</strong> node to an instance of a TurtleSim virtual robot. Although a publisher may have many subscribers, we will only be using one instance of TurtleSim to subscribe to the publisher we will build in our custom node. We see this illustrated in the <span class="No-Break">following diagram:</span></p>
<div>
<div class="IMG---Figure" id="_idContainer218">
<img alt="Figure 11.2 – A view of the publisher-subscriber model inside ROS" height="390" src="image/B21282_11_2.jpg" width="1317"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 11.2 – A view of the publisher-subscriber model inside ROS</p>
<p>Services in ROS offer a way for nodes to perform request-response interactions, useful for tasks that require immediate feedback. Actions provide a means for executing long-running tasks that require continuous feedback and the possibility of cancellation. We will not be using<a id="_idIndexMarker844"/> services or actions for <span class="No-Break">our application.</span></p>
<p>Now that we have a little understanding of ROS node communication, let’s look at the project structure <span class="No-Break">in ROS.</span></p>
<h2 id="_idParaDest-179"><a id="_idTextAnchor181"/>Investigating ROS project structure and organization</h2>
<p>The <a id="_idIndexMarker845"/>structure of a ROS project is<a id="_idIndexMarker846"/> organized for the efficient development and management of robotics applications. At its core, a ROS project is built around the concept of packages and workspaces, which are essential for organizing the various components of a robotics project. The following list summarizes the key concepts for a <span class="No-Break">ROS project:</span></p>
<ul>
<li><strong class="bold">Packages and workspaces</strong>: A ROS workspace is a directory (or a folder) where ROS packages are developed and compiled. Each package, typically a directory within the workspace, represents a specific functionality or component of the robot, such as sensors, actuators, algorithms, or even a collection of related nodes. Packages can contain ROS nodes, libraries, datasets, configuration files, or anything that constitutes an independent and <span class="No-Break">reusable module.</span></li>
<li><strong class="bold">ROS nodes and communication</strong>: Within these packages, the primary executable units are the nodes. Each node is designed to perform a specific task, such as <a id="_idIndexMarker847"/>controlling a <a id="_idIndexMarker848"/>motor, processing sensor data, or performing computations. Nodes communicate with each other over topics, services, or actions. Topics allow for asynchronous, publish-subscribe communication, ideal for streaming data such as sensor readings or control commands. Services provide synchronous, request-response interaction, useful for tasks that need immediate feedback. Actions are suited for long-running tasks that require continuous feedback and the possibility of cancellation. As mentioned, we will be creating a custom node to communicate with the TurtleSim simulator using topics and the <span class="No-Break">publish-subscribe method.</span></li>
<li><strong class="bold">Build system and package management</strong>: ROS uses a build system (such as <strong class="source-inline">catkin</strong> in ROS 1 or <strong class="source-inline">colcon</strong> in ROS 2) to compile and manage packages. The build system handles dependencies and integrates packages into the ROS ecosystem. We will be using <strong class="source-inline">colcon</strong> to compile <span class="No-Break">our project.</span></li>
<li><strong class="bold">Parameter server and launch files</strong>: The parameter server in ROS is a shared, multi-variable dictionary accessible by nodes at runtime, allowing them to configure parameters dynamically. Launch files are another crucial aspect of ROS projects. They are XML/YAML files that specify which nodes to run, set parameters, and configure the node network for a specific use case, such as launching a robot in a simulation environment. We will not be using launch files for our application and will instead launch both the TurtleSim simulator and our custom node using the <strong class="source-inline">ros2 </strong><span class="No-Break"><strong class="source-inline">run</strong></span><span class="No-Break"> command.</span></li>
</ul>
<p>We will construct our<a id="_idIndexMarker849"/> workspaces, build<a id="_idIndexMarker850"/> our packages, and execute our program directly from the command line. Before we do this, let’s explore how ROS distributions align with <span class="No-Break">Ubuntu versions.</span></p>
<h2 id="_idParaDest-180"><a id="_idTextAnchor182"/>Aligning ROS distributions with Ubuntu LTS versions</h2>
<p>Each <a id="_idIndexMarker851"/>ROS distribution is paired with a designated Ubuntu <strong class="bold">Long-Term Support</strong> (<strong class="bold">LTS</strong>) version, a <a id="_idIndexMarker852"/>strategy that guarantees stability and compatibility as it gives ROS developers a consistent code base to <span class="No-Break">work with.</span></p>
<p>The ROS release policy is clear: one Ubuntu LTS version per ROS release, with no new Ubuntu version support after the release. To take advantage of this pairing of Ubuntu with ROS, we will install Ubuntu 22.04 and the Humble Hawksbill version of ROS 2 onto our Raspberry Pi 4 (for those of us who wish to run Ubuntu on a computer other than a Raspberry Pi, we may skip the <span class="No-Break">next section).</span></p>
<p>We will start by flashing Ubuntu onto a microSD card using the Raspberry <span class="No-Break">Pi Imager.</span></p>
<h1 id="_idParaDest-181"><a id="_idTextAnchor183"/>Installing Ubuntu and ROS onto our Raspberry Pi</h1>
<p>In this section, we will walk through the steps of installing Ubuntu 22.04 and ROS Humble Hawksbill on our Raspberry Pi 4. This involves choosing the correct Ubuntu image, flashing it onto a microSD card using the Raspberry Pi Imager, and setting up the Raspberry Pi to boot <span class="No-Break">with Ubuntu.</span></p>
<p class="callout-heading">Why are we using a Raspberry Pi 4 and not a Raspberry Pi 5?</p>
<p class="callout">At the time of writing, the Raspberry Pi 5 does not support Ubuntu 22.04 and thus the latest version <span class="No-Break">of ROS.</span></p>
<p>We will start by launching the Raspberry Pi Imager on a computer of <span class="No-Break">our choice.</span></p>
<h2 id="_idParaDest-182"><a id="_idTextAnchor184"/>Installing Ubuntu on our Raspberry Pi 4</h2>
<p>To install <a id="_idIndexMarker853"/>Ubuntu onto our Raspberry Pi 4, we will use the Raspberry Pi Imager to burn the operating system onto a microSD card, which we will install on our Pi. The Raspberry Pi Imager is a tool created by the Raspberry Pi Foundation and is used to simplify the process of imaging microSD cards with the Raspberry Pi operating system and other <span class="No-Break">compatible systems.</span></p>
<p>The Raspberry Pi Imager is available for Windows, macOS, and Linux and may even be installed on the Raspberry <span class="No-Break">Pi itself.</span></p>
<p class="callout-heading">Using the Raspberry Pi Imager on a Raspberry Pi</p>
<p class="callout">We may use the<a id="_idIndexMarker854"/> Raspberry Pi Imager on our <a id="_idIndexMarker855"/>Raspberry Pi to burn an image onto a microSD card. The process involves using an SD card reader connected to the Raspberry Pi’s USB port. We may install the imager from a Terminal in the Raspberry Pi OS with the <strong class="source-inline">sudo apt install </strong><span class="No-Break"><strong class="source-inline">rpi-imager</strong></span><span class="No-Break"> command.</span></p>
<p>To burn <a id="_idIndexMarker856"/>Ubuntu onto a microSD card for use with a Raspberry Pi, we do <span class="No-Break">the following:</span></p>
<ol>
<li>Using an internet browser, we navigate to the following website to download the Raspberry <span class="No-Break">Pi Imager:</span><p class="list-inset"><a href="https://www.raspberrypi.com/software/"><span class="No-Break">https://www.raspberrypi.com/software/</span></a></p></li>
<li>To begin the imaging process, we insert a microSD card into a USB microSD adapter and then connect the adapter to a USB port on <span class="No-Break">our computer:</span></li>
</ol>
<div>
<div class="IMG---Figure" id="_idContainer219">
<img alt="Figure 11.3 – A USB microSD adapter with microSD card inserted" height="222" src="image/B21282_11_3.jpg" width="1221"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 11.3 – A USB microSD adapter with microSD card inserted</p>
<ol>
<li value="3">Next, we install the Raspberry Pi Imager software on our computer. Once installed, launching the imager will bring up its main screen, ready for us to select an operating system image and the target microSD card for <span class="No-Break">the installation:</span></li>
</ol>
<div>
<div class="IMG---Figure" id="_idContainer220">
<img alt="Figure 11.4 – Raspberry Pi Imager" height="412" src="image/B21282_11_4.jpg" width="799"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 11.4 – Raspberry Pi Imager</p>
<ol>
<li value="4">Under <strong class="bold">Raspberry Pi Device</strong>, we select <span class="No-Break"><strong class="bold">NO FILTERING</strong></span><span class="No-Break">.</span></li>
<li>For <strong class="bold">Operating System</strong>, we select <strong class="bold">Other General Purpose OS</strong>, then <strong class="bold">Ubuntu</strong>, then <strong class="bold">Ubuntu Desktop 22.04.3 </strong><span class="No-Break"><strong class="bold">LTS (64-BIT)</strong></span><span class="No-Break">.</span></li>
<li>We <a id="_idIndexMarker857"/>then click on the <strong class="bold">CHOOSE STORAGE</strong> button and select the microSD card we inserted into <span class="No-Break">our computer.</span></li>
<li>Our selections should look like <span class="No-Break">the following:</span></li>
</ol>
<div>
<div class="IMG---Figure" id="_idContainer221">
<img alt="Figure 11.5 – Raspberry Pi Imager after selections" height="422" src="image/B21282_11_5.jpg" width="932"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 11.5 – Raspberry Pi Imager after selections</p>
<p class="callout-heading">Selecting the correct version of Ubuntu</p>
<p class="callout">At the time of <a id="_idIndexMarker858"/>writing, the latest version of ROS 2 supports Ubuntu 22.04. Therefore, in our example, we will use Ubuntu 22.04 LTS, even though the most recent version of Ubuntu is 23.10. For future iterations of ROS 2, it’s important to select the version of Ubuntu that corresponds with the ROS 2 release <span class="No-Break">in use.</span></p>
<ol>
<li value="8">To start the burning process, we click on the <strong class="bold">NEXT</strong> button and click on the <strong class="bold">Yes</strong> button on the <strong class="bold">Warning</strong> dialog <span class="No-Break">to continue.</span></li>
<li>Once the <a id="_idIndexMarker859"/>writing process is complete, the Raspberry Pi Imager will perform a verification to ensure the image has been correctly written to the microSD card. Upon successful verification, we should see a <strong class="bold">Write Successful</strong> screen, indicating that the microSD card is now ready to be used in our Raspberry Pi with the newly installed <span class="No-Break">operating system.</span></li>
<li>With the image burned onto our microSD card, we then proceed to install the card onto our Raspberry Pi and follow the steps to complete the installation of Ubuntu onto the <span class="No-Break">Raspberry Pi.</span></li>
</ol>
<p>With Ubuntu now running on our Raspberry Pi, the next step is to install the appropriate version of ROS. Despite its name, ROS isn’t an operating system. Instead, it functions as a middleware or software<a id="_idIndexMarker860"/> framework, providing tools and libraries for building and managing <span class="No-Break">robotic applications.</span></p>
<h2 id="_idParaDest-183"><a id="_idTextAnchor185"/>Adding ROS to our Ubuntu installation</h2>
<p>Recapping <a id="_idIndexMarker861"/>our <em class="italic">Exploring ROS</em> section, we<a id="_idIndexMarker862"/> emphasized the importance of matching each ROS distribution with a specific Ubuntu LTS version to ensure stability. Having installed Ubuntu 22.04 on our Raspberry Pi, we’re now ready to <span class="No-Break">install ROS.</span></p>
<p>As of this writing, there are two ROS versions compatible with Ubuntu 22.04: Humble Hawksbill and Iron Irwini. Humble Hawksbill is<a id="_idIndexMarker863"/> an LTS version, meaning it’s designed for stability and extended support, ideal for longer-term projects and those seeking a stable development environment. Iron Irwini, on the other hand, is a non-LTS version, typically featuring more cutting-edge changes but with a shorter support <span class="No-Break">life cycle.</span></p>
<p>We will use Humble Hawksbill for our application as we desire stability over new features for what we <span class="No-Break">are doing.</span></p>
<p class="callout-heading">Important note</p>
<p class="callout">The ROS installation instructions provided here are current as of the time of writing. However, it’s recommended to consult the official web page for the most up-to-date guidance, as there may be updates <span class="No-Break">or changes.</span></p>
<p>To install Humble Hawksbill <a id="_idIndexMarker864"/>on our Raspberry Pi, we do <span class="No-Break">the following:</span></p>
<ol>
<li>To view the latest versions of ROS, we navigate to the <span class="No-Break">following website:</span><p class="list-inset"><a href="https://www.ros.org/blog/getting-started/"><span class="No-Break">https://www.ros.org/blog/getting-started/</span></a></p></li>
<li>To view the current versions of ROS, we scroll down to the <strong class="bold">Installation</strong> section of the page where we see <span class="No-Break">the following:</span></li>
</ol>
<div>
<div class="IMG---Figure" id="_idContainer222">
<img alt="Figure 11.6 – Current versions of ROS" height="314" src="image/B21282_11_6.jpg" width="925"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 11.6 – Current versions of ROS</p>
<ol>
<li value="3">To <a id="_idIndexMarker865"/>proceed, we click on <a id="_idIndexMarker866"/>the <strong class="bold">Install</strong> link under the <strong class="bold">Humble </strong><span class="No-Break"><strong class="bold">Hawksbill</strong></span><span class="No-Break"> section.</span><p class="list-inset">This will bring us to the Humble Hawksbill <span class="No-Break">installation page.</span></p></li>
<li>To install Humble Hawksbill for Ubuntu, we click on the <strong class="bold">Debian packages</strong> link (highlighted with a red box in the following figure) under <strong class="bold">Ubuntu Linux – Jammy </strong><span class="No-Break"><strong class="bold">Jellyfish (22.04)</strong></span><span class="No-Break">:</span></li>
</ol>
<div>
<div class="IMG---Figure" id="_idContainer223">
<img alt="Figure 11.7 – Binary packages for ROS" height="403" src="image/B21282_11_7.jpg" width="825"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 11.7 – Binary packages for ROS</p>
<ol>
<li value="5">To set the locale in Ubuntu, we simply copy the commands from the <strong class="bold">Set locale</strong> section of the web page. This can be done quickly by clicking the <strong class="bold">Copy</strong> icon on the top right of the code box, which appears when we hover over it. We then paste and execute these commands into the Ubuntu Terminal to complete the locale <span class="No-Break">setting process:</span></li>
</ol>
<div>
<div class="IMG---Figure" id="_idContainer224">
<img alt="Figure 11.8 – Setting the locale in Ubuntu" height="319" src="image/B21282_11_8.jpg" width="842"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 11.8 – Setting the locale in Ubuntu</p>
<ol>
<li value="6">To <a id="_idIndexMarker867"/>configure our <a id="_idIndexMarker868"/>system to access and authenticate the ROS software repository, we copy, paste, and execute the code from each section under the <strong class="bold">Setup </strong><span class="No-Break"><strong class="bold">Sources</strong></span><span class="No-Break"> section:</span></li>
</ol>
<div>
<div class="IMG---Figure" id="_idContainer225">
<img alt="Figure 11.9 – Configuring our Ubuntu installation for access to the ROS software repository" height="495" src="image/B21282_11_9.jpg" width="807"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 11.9 – Configuring our Ubuntu installation for access to the ROS software repository</p>
<ol>
<li value="7">To update our system’s packages, we type the following command into <span class="No-Break">the Terminal:</span><pre class="source-code">
<strong class="bold">sudo apt update</strong></pre></li> <li>We then upgrade the packages on our system with the <span class="No-Break">following command:</span><pre class="source-code">
<strong class="bold">sudo apt upgrade</strong></pre></li> <li>We will be using the desktop version of ROS. We install it with the <span class="No-Break">following command:</span><pre class="source-code">
<strong class="bold">sudo apt install ros-humble-desktop</strong></pre></li> <li>As we<a id="_idIndexMarker869"/> will be creating our own <a id="_idIndexMarker870"/>nodes, we will need the ROS development tools. We install these tools with the <span class="No-Break">following command:</span><pre class="source-code">
<strong class="bold">sudo apt install ros-dev-tools</strong></pre></li> </ol>
<p>With ROS and the ROS development tools installed, we are now ready to explore. We will start off with a simple <span class="No-Break">publish-subscribe example.</span></p>
<h2 id="_idParaDest-184"><a id="_idTextAnchor186"/>Testing our ROS installation</h2>
<p>We <a id="_idIndexMarker871"/>may test our new ROS installation with different components, regardless of the programming languages used to write these components. A common approach to this, and the approach we will take, is to use a simple publisher-subscriber model where the publisher is written in C++ and the subscriber <span class="No-Break">in Python.</span></p>
<p>In <span class="No-Break">Figure 11</span>.10, the nodes shown are part of the ROS desktop installation. The figure highlights a <strong class="bold">Publisher</strong> node, written in C++, which sends a Hello World: message followed by a sequential number to the chatter topic. The <strong class="bold">Subscriber</strong> node is written in Python and subscribes to the <span class="No-Break">chatter topic:</span></p>
<div>
<div class="IMG---Figure" id="_idContainer226">
<img alt="Figure 11.10 – ROS publisher-subscriber using C++ publisher and Python subscriber" height="352" src="image/B21282_11_10.jpg" width="1182"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 11.10 – ROS publisher-subscriber using C++ publisher and Python subscriber</p>
<p>To run the <a id="_idIndexMarker872"/>example, we do <span class="No-Break">the following:</span></p>
<ol>
<li>In Ubuntu, we open a new Terminal and type in the <span class="No-Break">following command:</span><pre class="source-code">
<strong class="bold">source /opt/ros/humble/setup.bash</strong></pre><p class="list-inset">We use this command to initialize the ROS environment for the current Terminal session, thereby enabling ROS commands and <span class="No-Break">package usage.</span></p></li> <li>To launch the publisher, we type <span class="No-Break">the following:</span><pre class="source-code">
<strong class="bold">ros2 run demo_nodes_cpp talker</strong></pre><p class="list-inset">With this command, we launch the ROS 2 node named <strong class="source-inline">talker</strong> from the <strong class="source-inline">demo_nodes_cpp</strong> package. We should observe messages printed to <span class="No-Break">the console:</span></p></li> </ol>
<div>
<div class="IMG---Figure" id="_idContainer227">
<img alt="Figure 11.11 – Output from running the talker node" height="353" src="image/B21282_11_11.jpg" width="1152"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 11.11 – Output from running the talker node</p>
<p class="list-inset">We can <a id="_idIndexMarker873"/>see from the Terminal that an output of <strong class="source-inline">Hello World:</strong> followed by an incrementing number is published by the <strong class="source-inline">talker</strong> node. Although we can’t tell from the output, the topic our node is publishing to is the <span class="No-Break"><strong class="source-inline">chatter</strong></span><span class="No-Break"> topic.</span></p>
<ol>
<li value="3">To receive the messages, we open a new Terminal in Ubuntu and launch the Python subscriber node with the <span class="No-Break">following commands:</span><pre class="source-code">
<strong class="bold">source /opt/ros/humble/setup.bash</strong>
<strong class="bold">ros2 run demo_nodes_py listener</strong></pre><p class="list-inset">With every new Terminal we open, we must source the ROS installation to enable ROS commands. We should observe an acknowledgment of the published messages in our <span class="No-Break">new Terminal:</span></p></li> </ol>
<div>
<div class="IMG---Figure" id="_idContainer228">
<img alt="Figure 11.12 – Receiving messages from the talker node" height="440" src="image/B21282_11_12.jpg" width="1266"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 11.12 – Receiving messages from the talker node</p>
<p>With this, we<a id="_idIndexMarker874"/> have successfully installed and tested our ROS installation. In the next section, we will run a simulated robot and control it through <span class="No-Break">MQTT messages.</span></p>
<h1 id="_idParaDest-185"><a id="_idTextAnchor187"/>Running and controlling a simulated robot</h1>
<p>In this section, we<a id="_idIndexMarker875"/> explore the use of TurtleSim, a lightweight and user-friendly tool within ROS for simulating a robot’s movements and behaviors. TurtleSim serves as an excellent educational resource, especially for beginners <a id="_idIndexMarker876"/>in ROS, to understand basic concepts such as node interactions, message passing, and simple <span class="No-Break">robotic commands.</span></p>
<p>By using TurtleSim, we will learn how to create a ROS node to control a virtual robot. We will control the TurtleSim robot with MQTT messages. In the upcoming chapters, we will use what we learn here to convert our robot into a physical robot we will <span class="No-Break">call A.R.E.S.</span></p>
<p>We’ll begin by launching a TurtleSim node within Ubuntu and then control it using a separate <span class="No-Break">ROS node.</span></p>
<h2 id="_idParaDest-186"><a id="_idTextAnchor188"/>Launching and testing TurtleSim</h2>
<p>As mentioned, TurtleSim is<a id="_idIndexMarker877"/> designed to help new users familiarize themselves with ROS functionalities such as nodes, topics, and services through a simple interface. By running TurtleSim, we can simulate a robot’s movement and behavior in a <span class="No-Break">controlled environment.</span></p>
<p>To <a id="_idIndexMarker878"/>launch TurtleSim, we do <span class="No-Break">the following:</span></p>
<ol>
<li>In Ubuntu, we open a new Terminal and type in the <span class="No-Break">following commands:</span><pre class="source-code">
<strong class="bold">source /opt/ros/humble/setup.bash</strong>
<strong class="bold">ros2 run turtlesim turtlesim_node</strong></pre><p class="list-inset">The first command initializes the ROS environment, while the second runs the <strong class="source-inline">turtlesim_node</strong> node from the <strong class="source-inline">turtlesim</strong> package. Once these commands are executed, a TurtleSim window should appear, displaying a graphic of a simulated turtle positioned in the center of <span class="No-Break">the screen:</span></p></li> </ol>
<div>
<div class="IMG---Figure" id="_idContainer229">
<img alt="Figure 11.13 – TurtleSim robot" height="369" src="image/B21282_11_13.jpg" width="750"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 11.13 – TurtleSim robot</p>
<ol>
<li value="2">To control <a id="_idIndexMarker879"/>the turtle, we use another node. To do this, we open another Terminal in Ubuntu and execute the <span class="No-Break">following commands:</span><pre class="source-code">
<strong class="bold">source /opt/ros/humble/setup.bash</strong>
<strong class="bold">ros2 run turtlesim turtle_teleop_key</strong></pre><p class="list-inset">The first command initializes the ROS environment, while the second executes the <strong class="source-inline">turtle_teleop_key</strong> node from the <strong class="source-inline">turtlesim</strong> package. This node allows us to control the TurtleSim robot with our keyboard. Our Terminal should look like <span class="No-Break">the following:</span></p></li> </ol>
<div>
<div class="IMG---Figure" id="_idContainer230">
<img alt="Figure 11.14 – Running the turtle_teleop_key node" height="354" src="image/B21282_11_14.jpg" width="1399"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 11.14 – Running the turtle_teleop_key node</p>
<ol>
<li value="3">We may <a id="_idIndexMarker880"/>move our TurtleSim robot simply by holding down the arrow keys on our keyboard. We may also rotate our robot using any of the keys listed in <span class="No-Break">the Terminal:</span></li>
</ol>
<div>
<div class="IMG---Figure" id="_idContainer231">
<img alt="Figure 11.15 – Results of moving the TurtleSim robot" height="427" src="image/B21282_11_15.jpg" width="876"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 11.15 – Results of moving the TurtleSim robot</p>
<ol>
<li value="4">To visualize node and topic connections in ROS, we can use <strong class="source-inline">rqt_graph</strong>, a graphical tool that displays how nodes interact. It’s especially helpful for debugging and deciphering the network within a ROS system. To launch<strong class="source-inline"> rqt_graph</strong>, we enter the following commands in a new <span class="No-Break">Ubuntu Terminal:</span><pre class="source-code">
<strong class="bold">source /opt/ros/humble/setup.bash</strong>
<strong class="bold">rqt_graph</strong></pre></li> <li>The first <a id="_idIndexMarker881"/>command initializes the ROS environment, while the second loads the <strong class="source-inline">rqt_graph</strong> tool. We should see the <span class="No-Break">following window:</span></li>
</ol>
<div>
<div class="IMG---Figure" id="_idContainer232">
<img alt="Figure 11.16 – Using the rqt_graph tool in ROS" height="389" src="image/B21282_11_16.jpg" width="1154"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 11.16 – Using the rqt_graph tool in ROS</p>
<ol>
<li value="6">From our graph, the <strong class="source-inline">cmd_vel</strong> topic is a key communication channel in ROS that connects the <strong class="source-inline">teleop_turtle</strong> node, acting as a controller, to the <strong class="source-inline">turtlesim</strong> node, which simulates the robot. In our ROS graph, we refer to the TurtleSim instance as <strong class="source-inline">turtle1</strong>, and it’s this name we use to identify the specific turtle being controlled when interacting with the <strong class="source-inline">cmd_vel</strong> topic. The graph also shows <strong class="source-inline">rotate_absolute</strong> actions. For our basic robot control application, we are only interested in <strong class="source-inline">cmd_vel</strong> <span class="No-Break">topic communications.</span></li>
</ol>
<p class="callout-heading">Why do we launch turtle_teleop_key but view teleop_turtle?</p>
<p class="callout">The difference between the <strong class="source-inline">teleop_turtle</strong> node name in the <strong class="source-inline">rqt_graph</strong> tool and the <strong class="source-inline">ros2 run turtlesim turtle_teleop_key</strong> command stems from the framework’s naming conventions and structure. The <strong class="source-inline">turtle_teleop_key</strong> command refers to the executable file in ROS that, when run, initializes a ROS node. This node is internally named <strong class="source-inline">teleop_turtle</strong> within the ROS environment for communication and identification. This approach allows flexibility in ROS, where a single executable can launch different nodes, and node names can be dynamically changed for specific needs or configurations. The node name is essential for network communication, such as publishing to topics, while the executable name is just for starting <span class="No-Break">the node.</span></p>
<p>Our exercise demonstrates<a id="_idIndexMarker882"/> how we may control a robot using a node – in this case, the <strong class="source-inline">teleop_turtle</strong> node, which allows us to control the TurtleSim robot with our keyboard. In the next section, we will create our own node, which will allow us to control the robot via <span class="No-Break">MQTT messaging.</span></p>
<h2 id="_idParaDest-187"><a id="_idTextAnchor189"/>Creating an ROS workspace and package</h2>
<p>In ROS 2, the <a id="_idIndexMarker883"/>structure and creation of <a id="_idIndexMarker884"/>packages are critical for organizing, distributing, and compiling our code. The creation of a package in ROS 2 involves using <strong class="source-inline">ament</strong> as the build system and <strong class="source-inline">colcon</strong> as the build tool. We have the option to create packages in either C++ <span class="No-Break">or Python.</span></p>
<p>The contents of a ROS 2 package vary depending on whether it’s a CMake or Python package. Typically, a CMake package includes a <strong class="source-inline">CMakeLists.txt</strong> file and a <strong class="source-inline">package.xml</strong> file, along with directories for source code and package headers. A Python package, on the other hand, will include <strong class="source-inline">package.xml</strong> and <strong class="source-inline">setup.py</strong> files and a directory with the same name as the package containing an <strong class="source-inline">__init__.py</strong> file, among others. For our application, we will <span class="No-Break">use Python.</span></p>
<p>We can have multiple packages in a ROS 2 workspace, each in its own folder, and these packages can be of different build types. It’s recommended to keep packages within the <strong class="source-inline">src</strong> folder of our workspace to <span class="No-Break">maintain organization.</span></p>
<p>In the following figure, we can see the structure of the ROS workspace we will build, with the dot (<strong class="source-inline">.</strong>) representing the root directory of the workspace. The workspace is simply a directory in our filesystem. Under the <strong class="source-inline">src</strong> folder, we have our single package <span class="No-Break">called </span><span class="No-Break"><strong class="source-inline">mqtt_robot</strong></span><span class="No-Break">:</span></p>
<div>
<div class="IMG---Figure" id="_idContainer233">
<img alt="Figure 11.17 – ROS workspace structure" height="532" src="image/B21282_11_17.jpg" width="1487"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 11.17 – ROS workspace structure</p>
<p>To build our<a id="_idIndexMarker885"/> ROS application, we will <a id="_idIndexMarker886"/>begin by creating a workspace, a Linux directory that includes a <strong class="source-inline">src</strong> subfolder for organizing our application’s <span class="No-Break">ROS packages.</span></p>
<p>To do so, we do <span class="No-Break">the following:</span></p>
<ol>
<li>We open an Ubuntu Terminal and execute the following command in our <span class="No-Break">home directory:</span><pre class="source-code">
<strong class="bold">mkdir -p ch11_ws/src</strong></pre></li> </ol>
<p class="callout-heading">Important note</p>
<p class="callout">Creating our workspace in the home directory simplifies future navigation, as we can use the <strong class="source-inline">~</strong> character as a shortcut in <span class="No-Break">our commands.</span></p>
<p class="list-inset">With this command, we create a workspace. The <strong class="source-inline">-p</strong> flag in the <strong class="source-inline">mkdir</strong> command ensures that any necessary parent directories are created as part of the new <span class="No-Break">directory path.</span></p>
<ol>
<li value="2">With the<a id="_idIndexMarker887"/> folder created, we<a id="_idIndexMarker888"/> navigate to the <strong class="source-inline">src</strong> folder with the <span class="No-Break">following command:</span><pre class="source-code">
<strong class="bold">cd ch11_ws/src</strong></pre></li> <li>To initialize our ROS environment, we execute the <span class="No-Break">following command:</span><pre class="source-code">
<strong class="bold">source /opt/ros/humble/setup.bash</strong></pre></li> <li>We then create our package by executing the <span class="No-Break">following command:</span><pre class="source-code">
<strong class="bold">ros2 pkg create --build-type ament_python --license Apache-2.0 --node-name draw_circle mqtt_robot --license Apache-2.0</strong></pre><p class="list-inset">In the command we use to build our package, we specify the Apache <span class="No-Break">2.0 License.</span></p></li> </ol>
<p class="callout-heading">What is the Apache 2.0 License?</p>
<p class="callout">This license is<a id="_idIndexMarker889"/> an open source license that allows for commercial and non-commercial use and modification, with the requirement to disclose major changes in distributed versions and the explicit grant of patent rights to users. In our case, this disclosure requirement applies only if we were to modify the existing code of the build tools or other Apache 2.0 licensed software, not to the new code we write ourselves after the <span class="No-Break">package creation.</span></p>
<ol>
<li value="5">With this line, we created a new package named <strong class="source-inline">mqtt_robot</strong> with the Python build type and generated a node named <strong class="source-inline">draw_circle</strong>. To view the new file structure, we execute the <span class="No-Break"><strong class="source-inline">tree</strong></span><span class="No-Break"> command:</span></li>
</ol>
<div>
<div class="IMG---Figure" id="_idContainer234">
<img alt="Figure 11.18 – Workspace file structure under the src directory" height="631" src="image/B21282_11_18.jpg" width="1319"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 11.18 – Workspace file structure under the src directory</p>
<p>With <a id="_idIndexMarker890"/>our <strong class="source-inline">ch11_ws</strong> workspace<a id="_idIndexMarker891"/> and <strong class="source-inline">mqtt_robot</strong> package created; we are now ready to start modifying the generated code for our purposes. We will start with the <span class="No-Break"><strong class="source-inline">draw_circle.py</strong></span><span class="No-Break"> script.</span></p>
<h2 id="_idParaDest-188"><a id="_idTextAnchor190"/>Modifying the generated Python code</h2>
<p>After the code <a id="_idIndexMarker892"/>generation of our package, we are presented with a folder called <strong class="source-inline">mqtt_robot</strong> under the <strong class="source-inline">src</strong> folder. This folder represents our package. Inside is another folder with the same name, <strong class="source-inline">mqtt_robot</strong>. It is in this second <strong class="source-inline">mqtt_robot</strong> folder where we find the main Python code for <span class="No-Break">our application.</span></p>
<p>To create the logic for our application, we will modify the <strong class="source-inline">draw_circle.py</strong> script. To do so, we do <span class="No-Break">the following:</span></p>
<ol>
<li>For our application, we require the <strong class="source-inline">paho-mqtt</strong> library for MQTT communications. In an Ubuntu Terminal, we type the following command to install <span class="No-Break">the library:</span><pre class="source-code">
<strong class="bold">pip install paho-mqtt</strong></pre></li> <li>We <a id="_idIndexMarker893"/>then navigate to the folder that contains the <strong class="source-inline">draw_circle.py</strong> script with the <span class="No-Break">following command:</span><pre class="source-code">
<strong class="bold">cd ~/ch11_ws/src/mqtt_robot/mqtt_robot</strong></pre></li> <li>To open the <strong class="source-inline">draw_circle.py</strong> file in a text editor, we execute the <span class="No-Break">following command:</span><pre class="source-code">
<strong class="bold">gedit draw_circle.py</strong></pre></li> <li>We start by deleting<a id="_idIndexMarker894"/> all the code. We then start our new code <span class="No-Break">with imports:</span><pre class="source-code">
import rclpy
from rclpy.node import Node
from geometry_msgs.msg import Twist
import paho.mqtt.client as mqtt</pre><p class="list-inset">In our code, we have <span class="No-Break">the following:</span></p><ol><li class="upper-roman"><strong class="source-inline">import rclpy</strong>: Imports the ROS 2 client library for Python, allowing the script to interact with ROS 2 functionalities and create ROS <span class="No-Break">2 nodes.</span></li><li class="upper-roman"><strong class="source-inline">from rclpy.node import Node</strong>: Imports the <strong class="source-inline">Node</strong> class from the <strong class="source-inline">rclpy</strong> module, enabling the script to define custom nodes for ROS <span class="No-Break">2 applications.</span></li><li class="upper-roman"><strong class="source-inline">from geometry_msgs.msg import Twist</strong>: Imports the <strong class="source-inline">Twist</strong> message type from the <strong class="source-inline">geometry_msgs</strong> package; we use this for sending commands to move the <span class="No-Break">TurtleSim robot.</span></li><li class="upper-roman"><strong class="source-inline">import paho.mqtt.client as mqtt</strong>: Imports the Paho MQTT client library we will use for MQTT <span class="No-Break">protocol communication.</span></li></ol></li> <li>We define an <strong class="source-inline">MQTTMessage</strong> class, which includes an initialization method and a method to set a flag. The <strong class="source-inline">__init__()</strong> method initializes the <strong class="source-inline">should_draw_circle</strong> attribute as <strong class="source-inline">False</strong>, and the <strong class="source-inline">set_flag()</strong> method updates <a id="_idIndexMarker895"/>this attribute to <strong class="source-inline">True</strong> when our class receives the <strong class="source-inline">draw_circle</strong> message. We set <strong class="source-inline">should_draw_circle</strong> to <strong class="source-inline">False</strong> when a <strong class="source-inline">stop</strong> message <span class="No-Break">is received:</span><pre class="source-code">
class MQTTMessage:
    def __init__(self):
        self.should_draw_circle = False
    def set_flag(self, message):
        if message == 'draw_circle':
            self.should_draw_circle = True
        elif message == 'stop':
            self.should_draw_circle = False</pre></li> <li>We derive<a id="_idIndexMarker896"/> the <strong class="source-inline">CircleMover</strong> class from ROS 2’s <strong class="source-inline">Node</strong> class. This class is designed for controlling the movement of a simulated turtle in TurtleSim based on MQTT messages. The class initializes with an MQTT message handler, sets up a publisher for the <strong class="source-inline">turtle1/cmd_vel</strong> topic to control movement, and configures an MQTT client for connecting to a broker and handling <span class="No-Break">incoming messages:</span><pre class="source-code">
class CircleMover(Node):
    def __init__(self, mqtt_message):
        super().__init__('circle_mover')
        self.mqtt_message = mqtt_message
        self.publisher = self.create_publisher(
                         Twist, 'turtle1/cmd_vel', 10)
        timer = 0.1  # seconds
        self.timer = self.create_timer( timer,
                     self.timer_callback)
        self.vel_msg = Twist()
        # Initialize MQTT Client and set up callbacks
        self.mqtt_client = mqtt.Client()
        self.mqtt_client.on_connect = self.on_connect
        self.mqtt_client.on_message = self.on_message
        self.mqtt_client.username_pw_set("username",
                                         "password")
        self.mqtt_client.connect("
                           driver.cloudmqtt.com",
                           port, 60)
        self.mqtt_client.loop_start()
    def on_connect(self, client, userdata, flags, rc):
        client.subscribe("move")
    def on_message(self, client, userdata, msg):
        self.mqtt_message.set_flag(
                            msg.payload.decode())</pre></li> <li>The <strong class="source-inline">timer_callback()</strong> function inside the class determines the turtle’s movement based <a id="_idIndexMarker897"/>on the <strong class="source-inline">should_draw_circle</strong> flag set by MQTT messages, enabling dynamic control of the turtle <span class="No-Break">through MQTT:</span><pre class="source-code">
    def timer_callback(self):
        if self.mqtt_message.should_draw_circle:
            self.vel_msg.linear.x = 1.0
            self.vel_msg.angular.z = 1.0
        else:
            self.vel_msg.linear.x = 0.0
            self.vel_msg.angular.z = 0.0
        self.publisher.publish(self.vel_msg)</pre></li> <li>To <a id="_idIndexMarker898"/>complete our code, we define a <strong class="source-inline">main()</strong> function for our ROS 2 Python script, which initializes the ROS client library, creates an instance of the <strong class="source-inline">MQTTMessage</strong> class, and then an instance of the <strong class="source-inline">CircleMover</strong> class using the MQTT message handler. It runs the ROS node with the <strong class="source-inline">rclpy.spin()</strong> method, keeping the node active and <a id="_idIndexMarker899"/>responding to callbacks. Upon termination, it destroys the node and shuts down the ROS client library. We use the <strong class="source-inline">main()</strong> function as the entry point for our script, executing it when the script is <span class="No-Break">run directly:</span><pre class="source-code">
def main(args=None):
    rclpy.init(args=args)
    mqtt_message = MQTTMessage()
    circle_mover = CircleMover(mqtt_message)
    rclpy.spin(circle_mover)
    circle_mover.destroy_node()
    rclpy.shutdown()
if __name__ == '__main__':
    main()</pre></li> <li>With our code completed, we save the file using the same <span class="No-Break">name, </span><span class="No-Break"><strong class="source-inline">draw_circle.py</strong></span><span class="No-Break">.</span></li>
</ol>
<p>Our next step <a id="_idIndexMarker900"/>is to update the <strong class="source-inline">package.xml</strong> file to include Python library dependencies for <span class="No-Break">our code.</span></p>
<h2 id="_idParaDest-189"><a id="_idTextAnchor191"/>Updating package.xml</h2>
<p>The <strong class="source-inline">package.xml</strong> file in <a id="_idIndexMarker901"/>ROS is a descriptor that includes <a id="_idIndexMarker902"/>essential information about a ROS package, such as its name, version, maintainers, licenses, and dependencies. Crucial for the build process, it informs the <strong class="source-inline">colcon</strong> build tool about the dependencies needed for compiling the package. It is created and maintained by <span class="No-Break">the developer.</span></p>
<p>For our purposes, we will modify <strong class="source-inline">package.xml</strong> to inform it of the Python libraries our code needs <span class="No-Break">to compile.</span></p>
<p>To do so, we do <span class="No-Break">the following:</span></p>
<ol>
<li>We open an Ubuntu Terminal and navigate to the folder containing the <span class="No-Break"><strong class="source-inline">package.xml</strong></span><span class="No-Break"> file:</span><pre class="source-code">
<strong class="bold">cd ~/ch11_ws/src/mqtt_robot</strong></pre></li> <li>To open <strong class="source-inline">package.xml</strong> in a text editor, we execute the <span class="No-Break">following command:</span><pre class="source-code">
<strong class="bold">gedit package.xml</strong></pre></li> <li>We update the XML by adding the following lines before the last <span class="No-Break">tag (</span><span class="No-Break"><strong class="source-inline">&lt;/package&gt;</strong></span><span class="No-Break">):</span><pre class="source-code">
  &lt;exec_depend&gt;rclpy&lt;/exec_depend&gt;
  &lt;exec_depend&gt;paho-mqtt&lt;/exec_depend&gt;</pre></li> <li>These lines indicate to the compiler that <strong class="source-inline">rclpy</strong> (Python client library for ROS) and <strong class="source-inline">paho-mqtt</strong> (used for MQTT communications) are execution dependencies for the ROS package, meaning these packages are required for running the ROS nodes contained in the package. We save our changes and close <span class="No-Break">the editor.</span></li>
</ol>
<p>With<a id="_idIndexMarker903"/> updates to <strong class="source-inline">package.xml</strong>, we are now ready to compile our code and run our <span class="No-Break">new node.</span></p>
<h2 id="_idParaDest-190"><a id="_idTextAnchor192"/>Compiling and running our code</h2>
<p>To<a id="_idIndexMarker904"/> compile our code, we use the <strong class="source-inline">colcon</strong> ROS tool, a command-line tool used for compiling ROS packages, handling dependencies, and orchestrating builds across multiple packages in the workspace. For our application, we require it to compile only <span class="No-Break">one package.</span></p>
<p>To compile and<a id="_idIndexMarker905"/> execute our new code, we do <span class="No-Break">the following:</span></p>
<ol>
<li>In Ubuntu, we open a new Terminal and source our ROS <span class="No-Break">2 environment:</span><pre class="source-code">
<strong class="bold">source /opt/ros/humble/setup.bash</strong></pre></li> <li>We then navigate to the root of <span class="No-Break">our workspace:</span><pre class="source-code">
<strong class="bold">cd ~/ch11_ws</strong></pre></li> <li>To compile our code, we execute the <span class="No-Break">following command:</span><pre class="source-code">
<strong class="bold">colcon build</strong></pre></li> </ol>
<p class="callout-heading">Why do we create a package from the src folder but compile from the root?</p>
<p class="callout">It’s worth noting that package creation and compilation in a ROS workspace occur at different levels. While we create individual packages within the <strong class="source-inline">src</strong> folder of a workspace, compilation is done from the workspace’s root folder. This distinction is key: creating packages is a localized action within <strong class="source-inline">src</strong>, but compiling with <strong class="source-inline">colcon</strong> at the workspace root ensures all packages within <strong class="source-inline">src</strong> are <span class="No-Break">built together.</span></p>
<ol>
<li value="4">Upon completion, a message confirming a successful build will appear in <span class="No-Break">the Terminal.</span></li>
<li>With our code compiled, it is time to source our new ROS environment. We do this with the <span class="No-Break">following command:</span><pre class="source-code">
<strong class="bold">source ~/ch11_ws/install/setup.bash</strong></pre></li> <li>This is like <a id="_idIndexMarker906"/>how we source the ROS environment. To run our node, we execute the <span class="No-Break">following command:</span><pre class="source-code">
<strong class="bold">ros2 run mqtt_robot draw_circle</strong></pre></li> <li>Here, we<a id="_idIndexMarker907"/> are running our new node, <strong class="source-inline">draw_circle</strong>, from the package we created, <strong class="source-inline">mqtt_robot</strong>. Upon execution, our Terminal will enter a wait state, ready to respond to incoming events <span class="No-Break">or actions.</span></li>
<li>If not already running, we launch a <span class="No-Break">TurtleSim instance.</span></li>
</ol>
<p>We may notice that nothing is happening. The turtle in TurtleSim is not moving, and the Terminal where we launched our node is in a waiting state. To make the turtle move, we need to send an MQTT message to our <span class="No-Break">new node.</span></p>
<p>Let’s do <span class="No-Break">that now.</span></p>
<h2 id="_idParaDest-191"><a id="_idTextAnchor193"/>Controlling our robot with an MQTT message</h2>
<p>We see a <a id="_idIndexMarker908"/>high-level overview of our application in <span class="No-Break"><em class="italic">Figure 11</em></span><em class="italic">.1</em>, where an MQTT message using MQTT-Explorer directs our<a id="_idIndexMarker909"/> ROS-simulated robot. The <strong class="source-inline">draw_circle</strong> message prompts the turtle to draw a circle, while <strong class="source-inline">stop</strong> halts its movement. This forms the foundational basis for our project, which we’ll expand with additional features in the <span class="No-Break">upcoming chapters.</span></p>
<p>To control the TurtleSim robot from an MQTT message, we do <span class="No-Break">the following:</span></p>
<ol>
<li>Using the MQTT-Explorer app in Windows, we publish a <strong class="source-inline">draw_circle</strong> message to the <span class="No-Break"><strong class="source-inline">move</strong></span><span class="No-Break"> topic.</span></li>
<li>Upon sending, we should observe that our TurtleSim robot starts to move in <span class="No-Break">a circle:</span></li>
</ol>
<div>
<div class="IMG---Figure" id="_idContainer235">
<img alt="Figure 11.19 – TurtleSim robot moving from MQTT message" height="451" src="image/B21282_11_19.jpg" width="877"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 11.19 – TurtleSim robot moving from MQTT message</p>
<ol>
<li value="3">To stop the robot, we send a <strong class="source-inline">stop</strong> message under the <strong class="source-inline">move</strong> topic using the <span class="No-Break">MQTT-Explorer app.</span></li>
<li>We <a id="_idIndexMarker910"/>should observe that the<a id="_idIndexMarker911"/> TurtleSim robot <span class="No-Break">stops moving.</span></li>
</ol>
<p>Our demonstration of controlling a virtual robot using MQTT messages lays the groundwork for applying these learned concepts to our upcoming real robot <span class="No-Break">project, A.R.E.S.</span></p>
<h1 id="_idParaDest-192"><a id="_idTextAnchor194"/>Summary</h1>
<p>In this chapter, we began our exploration into ROS. We started by setting up ROS on a Raspberry Pi 4, going for Ubuntu over the standard Raspberry Pi OS for better compatibility <span class="No-Break">with ROS.</span></p>
<p>Our hands-on journey started with TurtleSim, a user-friendly ROS simulator. We learned basic ROS operations and concepts, starting with keyboard controls to maneuver a virtual robot. We then advanced to using MQTT messages for control, bridging the gap between simulation and <span class="No-Break">real-world application.</span></p>
<p>This experience with TurtleSim is foundational for our main project, A.R.E.S., an advanced IoT robot that will be developed in the <span class="No-Break">upcoming chapters.</span></p>
<p>In the next chapter, we will return to building IoT devices as we build an MQTT joystick to control our <span class="No-Break">TurtleSim robot.</span></p>
</div>
</div></body></html>