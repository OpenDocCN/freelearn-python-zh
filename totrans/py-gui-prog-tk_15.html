<html><head></head><body>
  <div><h1 class="chapterNumber">15</h1>
    <h1 id="_idParaDest-411" class="chapterTitle">Visualizing Data Using the Canvas Widget</h1>
    <p class="normal">With months of experimental data logged in the database, it's time to begin the process of visualizing and interpreting it. Rather than exporting data into a spreadsheet to create charts and graphs, your fellow analysts have asked whether the program itself can create graphical data visualizations. Indeed it can! To implement this feature, you're going to need to learn about Tkinter's <code class="Code-In-Text--PACKT-">Canvas</code> widget.</p>
    <p class="normal">In this chapter, you'll implement data visualizations as you learn the following topics:</p>
    <ul>
      <li class="bullet">In <em class="italic">Drawing and animation with Tkinter's Canvas</em>, you'll learn to use the <code class="Code-In-Text--PACKT-">Canvas</code> widget for drawing and animation</li>
      <li class="bullet">In <em class="italic">Creating simple graphs using Canvas</em>, we'll build a simple line graph using the Tkinter <code class="Code-In-Text--PACKT-">Canvas</code></li>
      <li class="bullet">In <em class="italic">Advanced graphs using Matplotlib</em>, we'll learn to integrate the Matplotlib library for more powerful charting and graphic capabilities</li>
    </ul>
    <h1 id="_idParaDest-412" class="title">Drawing and animation with Tkinter's Canvas</h1>
    <p class="normal">The <code class="Code-In-Text--PACKT-">Canvas</code> widget is undoubtedly one of the most powerful widgets available in Tkinter. It can be used<a id="_idIndexMarker1464"/> to build anything from custom widgets and views to complete user<a id="_idIndexMarker1465"/> interfaces. </p>
    <p class="normal">As the name implies, a <code class="Code-In-Text--PACKT-">Canvas</code> widget is a blank area on which figures and images can be drawn. To understand its basic usage, let's create a small demo script.</p>
    <p class="normal">Begin the script by creating a root window and a <code class="Code-In-Text--PACKT-">Canvas</code> object:</p>
    <pre class="programlisting code"><code class="hljs-code"># simple_canvas_demo.py
import tkinter as tk
root = tk.Tk()
canvas = tk.Canvas(
  root, background='black',
  width=1024, height=768
)
canvas.pack()
</code></pre>
    <p class="normal">Creating a <code class="Code-In-Text--PACKT-">Canvas</code> object is just like creating any other Tkinter widget. In addition to the parent widget and <code class="Code-In-Text--PACKT-">background</code> argument, we can also specify <code class="Code-In-Text--PACKT-">width</code> and <code class="Code-In-Text--PACKT-">height</code> arguments to set the size of the <code class="Code-In-Text--PACKT-">Canvas</code>. Setting the size of a <code class="Code-In-Text--PACKT-">Canvas</code> widget is important, because it defines not only the size<a id="_idIndexMarker1466"/> of the widget but also the <strong class="keyword">viewport</strong>; that is, the area<a id="_idIndexMarker1467"/> in which our drawn objects will be<a id="_idIndexMarker1468"/> visible. We can actually draw anywhere on the <code class="Code-In-Text--PACKT-">Canvas</code>'s virtually infinite surface, but only the area inside the viewport will be visible.</p>
    <div><p class="Tip--PACKT-">We'll learn how to see the area outside the viewport below in the <em class="italic">Scrolling the Canvas</em> section.</p>
    </div>
    <h2 id="_idParaDest-413" class="title">Drawing on the Canvas</h2>
    <p class="normal">Once we have a <code class="Code-In-Text--PACKT-">Canvas</code> object, we can start drawing items on it using its many <code class="Code-In-Text--PACKT-">create_()</code> methods. These methods allow us to draw shapes, lines, images, and text. Let's explore these methods in more detail as we develop the <code class="Code-In-Text--PACKT-">simple_canvas_demo.py</code> script.</p>
    <h3 id="_idParaDest-414" class="title">Rectangles and squares</h3>
    <p class="normal">Rectangles or squares<a id="_idIndexMarker1469"/> can be drawn on the <code class="Code-In-Text--PACKT-">Canvas</code> using<a id="_idIndexMarker1470"/> the <code class="Code-In-Text--PACKT-">create_rectangle()</code> method, like so:</p>
    <pre class="programlisting code"><code class="hljs-code"># simple_canvas_demo.py
canvas.create_rectangle(240, 240, 260, 260, fill='orange')
</code></pre>
    <p class="normal">The first four arguments of <code class="Code-In-Text--PACKT-">create_rectangle()</code> are the coordinates of the upper-left and lower-right corners, counted in pixels from the upper-left corner of the <code class="Code-In-Text--PACKT-">Canvas</code>. Each <code class="Code-In-Text--PACKT-">create_()</code> method begins with positional arguments that define the position and size of the shape. Following those, we can specify a variety of keyword arguments to describe other aspects of the shape; for example, the <code class="Code-In-Text--PACKT-">fill</code> option used here specifies the color of the inside of the object.</p>
    <div><p class="Information-Box--PACKT-">It's vital to understand that vertical coordinates on the <code class="Code-In-Text--PACKT-">Canvas</code>, unlike coordinates on a typical chart, extend <em class="italic">down</em> from the top. For example, the coordinate (200, 100) is 100 pixels <em class="italic">above</em> (200, 200). The same is true for coordinates on all Tkinter widgets, and in many other GUI programming environments as well.</p>
    </div>
    <p class="normal">Coordinates can also be specified as tuple pairs, like so:</p>
    <pre class="programlisting code"><code class="hljs-code">canvas.create_rectangle(
  (300, 240), (320, 260),
  fill='#FF8800'
)
</code></pre>
    <p class="normal">Although this requires<a id="_idIndexMarker1471"/> more characters, it improves readability<a id="_idIndexMarker1472"/> considerably. The <code class="Code-In-Text--PACKT-">create_rectangle()</code> method supports several other keyword arguments to configure the rectangle's fill and outline, including the following:</p>
    <table id="table001-11" class="No-Table-Style">
      <colgroup>
        <col/>
        <col/>
        <col/>
      </colgroup>
      <tbody>
        <tr class="No-Table-Style">
          <td class="No-Table-Style">
            <p class="Table-Column-Heading--PACKT-">Argument</p>
          </td>
          <td class="No-Table-Style">
            <p class="Table-Column-Heading--PACKT-">Values</p>
          </td>
          <td class="No-Table-Style">
            <p class="Table-Column-Heading--PACKT-">Description</p>
          </td>
        </tr>
        <tr class="No-Table-Style">
          <td class="No-Table-Style">
            <p class="Table-Column-Content--PACKT-"><code class="Code-In-Text--PACKT-">dash</code></p>
          </td>
          <td class="No-Table-Style">
            <p class="Table-Column-Content--PACKT-">Tuple of integers</p>
          </td>
          <td class="No-Table-Style">
            <p class="Table-Column-Content--PACKT-">Defines a dash pattern (see below) for the outline</p>
          </td>
        </tr>
        <tr class="No-Table-Style">
          <td class="No-Table-Style">
            <p class="Table-Column-Content--PACKT-"><code class="Code-In-Text--PACKT-">outline</code></p>
          </td>
          <td class="No-Table-Style">
            <p class="Table-Column-Content--PACKT-">Color string</p>
          </td>
          <td class="No-Table-Style">
            <p class="Table-Column-Content--PACKT-">Specifies a color for the border</p>
          </td>
        </tr>
        <tr class="No-Table-Style">
          <td class="No-Table-Style">
            <p class="Table-Column-Content--PACKT-"><code class="Code-In-Text--PACKT-">width</code></p>
          </td>
          <td class="No-Table-Style">
            <p class="Table-Column-Content--PACKT-">Integer</p>
          </td>
          <td class="No-Table-Style">
            <p class="Table-Column-Content--PACKT-">Specifies a width for the border</p>
          </td>
        </tr>
        <tr class="No-Table-Style">
          <td class="No-Table-Style">
            <p class="Table-Column-Content--PACKT-"><code class="Code-In-Text--PACKT-">stipple</code></p>
          </td>
          <td class="No-Table-Style">
            <p class="Table-Column-Content--PACKT-">Bitmap name</p>
          </td>
          <td class="No-Table-Style">
            <p class="Table-Column-Content--PACKT-">Name of a bitmap pattern to use for the fill</p>
          </td>
        </tr>
      </tbody>
    </table>
    <p class="normal">Dashed or dotted lines can be defined on <code class="Code-In-Text--PACKT-">Canvas</code> objects using a <strong class="keyword">dash pattern</strong>. This is a tuple of integers that describes<a id="_idIndexMarker1473"/> the number of pixels before switching between line and blank. For example, a <code class="Code-In-Text--PACKT-">dash</code> value of <code class="Code-In-Text--PACKT-">(5, 1, 2, 1)</code> would produce a repeating pattern of five pixels of line, one blank pixel, two pixels of line, and one blank.</p>
    <p class="normal">The <code class="Code-In-Text--PACKT-">stipple</code> value allows you to specify a bitmap to be used for filling the shape instead of a solid fill. Tkinter comes with some built-in bitmap files, such as <code class="Code-In-Text--PACKT-">gray75</code>, <code class="Code-In-Text--PACKT-">gray50</code>, <code class="Code-In-Text--PACKT-">gray25</code>, and <code class="Code-In-Text--PACKT-">gray12</code> (each of which is filled with evenly spaced pixels at the specified percentage), or you can load in a <code class="Code-In-Text--PACKT-">.xbm</code> file of your own using the format <code class="Code-In-Text--PACKT-">@filename.xbm</code>.</p>
    <h3 id="_idParaDest-415" class="title">Ovals, circles, and arcs</h3>
    <p class="normal">In addition to rectangles, we can also create ovals and circles using the <code class="Code-In-Text--PACKT-">create_oval()</code> method. Add an oval<a id="_idIndexMarker1474"/> to the demo as follows:</p>
    <pre class="programlisting code"><code class="hljs-code">canvas.create_oval(
  (350, 200), (450, 250), fill='blue'
)
</code></pre>
    <p class="normal">As with creating a rectangle, we begin by specifying the coordinates to describe the shape; however, this time the coordinates<a id="_idIndexMarker1475"/> determine the upper-left and lower-right corners of its <strong class="keyword">bounding box</strong>. A bounding box is the smallest rectangle that will contain an item. For example, in the case of this oval, the bounding box has corners at <code class="Code-In-Text--PACKT-">(350, 200)</code> and <code class="Code-In-Text--PACKT-">(450, 250)</code>. To make a circle, of course, we simply define an oval with a square bounding box.</p>
    <p class="normal"><code class="Code-In-Text--PACKT-">create_oval()</code> allows the<a id="_idIndexMarker1476"/> same keyword arguments as <code class="Code-In-Text--PACKT-">create_rectangle()</code> to configure the fill and outline of the shape.</p>
    <p class="normal">If we want to draw<a id="_idIndexMarker1477"/> only a sector of the oval, we can use the <code class="Code-In-Text--PACKT-">create_arc()</code> method. This method works identically to <code class="Code-In-Text--PACKT-">create_oval()</code>, but also takes <code class="Code-In-Text--PACKT-">extent</code> and <code class="Code-In-Text--PACKT-">start</code> keyword<a id="_idIndexMarker1478"/> arguments. The <code class="Code-In-Text--PACKT-">start</code> argument specifies the number of degrees from the origin at the left middle of the circle to the point where the drawing starts, and the <code class="Code-In-Text--PACKT-">extent</code> argument specifies how many degrees counter-clockwise the arc will extend. For example, an <code class="Code-In-Text--PACKT-">extent</code> of <code class="Code-In-Text--PACKT-">90</code> and <code class="Code-In-Text--PACKT-">start</code> of <code class="Code-In-Text--PACKT-">180</code> will draw a quarter of the oval starting at the right side and going to the bottom, as shown here:</p>
    <figure class="mediaobject"><img src="img/Image77828.png" alt=""/></figure>
    <p class="packt_figref">Figure 15.1: Drawing an arc</p>
    <p class="normal">Let's add an arc to our demo:</p>
    <pre class="programlisting code"><code class="hljs-code">canvas.create_arc(
  (100, 200), (200, 300),
  fill='yellow', extent=315, start=25
)
</code></pre>
    <h3 id="_idParaDest-416" class="title">Lines</h3>
    <p class="normal">We can also draw lines<a id="_idIndexMarker1479"/> on the <code class="Code-In-Text--PACKT-">Canvas</code> using the <code class="Code-In-Text--PACKT-">create_line()</code> method. As with rectangles, ovals, and arcs, we begin by specifying coordinates to define the line. Unlike with the shapes, the coordinates do not define a bounding box, but rather a set of points that define the line.</p>
    <p class="normal">Let's add a line to our demo script, like so:</p>
    <pre class="programlisting code"><code class="hljs-code">canvas.create_line(
  (0, 180), (1024, 180),
  width=5, fill='cyan'
)
</code></pre>
    <p class="normal">In this example, a straight line will be drawn from the first point at <code class="Code-In-Text--PACKT-">(0, 180)</code> to the second at <code class="Code-In-Text--PACKT-">(1024, 180)</code>. The <code class="Code-In-Text--PACKT-">fill</code> argument in this case defines the color of the line, and <code class="Code-In-Text--PACKT-">width</code> determines how wide it is.</p>
    <p class="normal">The <code class="Code-In-Text--PACKT-">create_line()</code> method is not limited to a single line between two points. We can specify any number of coordinate pairs as positional arguments, and Tkinter will connect them all from first to last. For example, add this to the demo:</p>
    <pre class="programlisting code"><code class="hljs-code">canvas.create_line(
  (0, 320), (500, 320), (500, 768), (640, 768),
  (640, 320), (1024, 320),
  width=5, fill='cyan'
)
</code></pre>
    <p class="normal">This time we've created a more complex line with six points.</p>
    <p class="normal">Some of the additional arguments for <code class="Code-In-Text--PACKT-">create_line()</code> are shown here:</p>
    <table id="table002-10" class="No-Table-Style">
      <colgroup>
        <col/>
        <col/>
        <col/>
      </colgroup>
      <tbody>
        <tr class="No-Table-Style">
          <td class="No-Table-Style">
            <p class="Table-Column-Heading--PACKT-">Argument</p>
          </td>
          <td class="No-Table-Style">
            <p class="Table-Column-Heading--PACKT-">Values</p>
          </td>
          <td class="No-Table-Style">
            <p class="Table-Column-Heading--PACKT-">Description</p>
          </td>
        </tr>
        <tr class="No-Table-Style">
          <td class="No-Table-Style">
            <p class="Table-Column-Content--PACKT-"><code class="Code-In-Text--PACKT-">arrow</code></p>
          </td>
          <td class="No-Table-Style">
            <p class="Table-Column-Content--PACKT-"><code class="Code-In-Text--PACKT-">FIRST</code>, <code class="Code-In-Text--PACKT-">LAST</code>, or <code class="Code-In-Text--PACKT-">BOTH</code></p>
          </td>
          <td class="No-Table-Style">
            <p class="Table-Column-Content--PACKT-">If specified, will draw arrows at the end of the line. Default is no value, indicating no arrows.</p>
          </td>
        </tr>
        <tr class="No-Table-Style">
          <td class="No-Table-Style">
            <p class="Table-Column-Content--PACKT-"><code class="Code-In-Text--PACKT-">capstyle</code></p>
          </td>
          <td class="No-Table-Style">
            <p class="Table-Column-Content--PACKT-"><code class="Code-In-Text--PACKT-">BUTT</code>, <code class="Code-In-Text--PACKT-">PROJECTING</code>, or <code class="Code-In-Text--PACKT-">ROUND</code></p>
          </td>
          <td class="No-Table-Style">
            <p class="Table-Column-Content--PACKT-">Specifies the style for the end of the line. Default is <code class="Code-In-Text--PACKT-">BUTT</code>.</p>
          </td>
        </tr>
        <tr class="No-Table-Style">
          <td class="No-Table-Style">
            <p class="Table-Column-Content--PACKT-"><code class="Code-In-Text--PACKT-">dash</code></p>
          </td>
          <td class="No-Table-Style">
            <p class="Table-Column-Content--PACKT-">Tuple of integers</p>
          </td>
          <td class="No-Table-Style">
            <p class="Table-Column-Content--PACKT-">Defines the dash style for the line.</p>
          </td>
        </tr>
        <tr class="No-Table-Style">
          <td class="No-Table-Style">
            <p class="Table-Column-Content--PACKT-"><code class="Code-In-Text--PACKT-">joinstyle</code></p>
          </td>
          <td class="No-Table-Style">
            <p class="Table-Column-Content--PACKT-"><code class="Code-In-Text--PACKT-">ROUND</code>, <code class="Code-In-Text--PACKT-">BEVEL</code>, or <code class="Code-In-Text--PACKT-">MITER</code></p>
          </td>
          <td class="No-Table-Style">
            <p class="Table-Column-Content--PACKT-">Specifies the style of corner joins. Default is <code class="Code-In-Text--PACKT-">ROUND</code>.</p>
          </td>
        </tr>
        <tr class="No-Table-Style">
          <td class="No-Table-Style">
            <p class="Table-Column-Content--PACKT-"><code class="Code-In-Text--PACKT-">smooth</code></p>
          </td>
          <td class="No-Table-Style">
            <p class="Table-Column-Content--PACKT-">Boolean</p>
          </td>
          <td class="No-Table-Style">
            <p class="Table-Column-Content--PACKT-">Whether to draw the line with spline curves or straight lines. Default is <code class="Code-In-Text--PACKT-">False</code> (straight lines).</p>
          </td>
        </tr>
        <tr class="No-Table-Style">
          <td class="No-Table-Style">
            <p class="Table-Column-Content--PACKT-"><code class="Code-In-Text--PACKT-">tags</code></p>
          </td>
          <td class="No-Table-Style">
            <p class="Table-Column-Content--PACKT-">Tuple of strings</p>
          </td>
          <td class="No-Table-Style">
            <p class="Table-Column-Content--PACKT-">Any number of tags to assign to the line.</p>
          </td>
        </tr>
      </tbody>
    </table>
    <h3 id="_idParaDest-417" class="title">Polygons</h3>
    <p class="normal">The <code class="Code-In-Text--PACKT-">Canvas</code> also allows us to draw arbitrary polygons; it works in a similar fashion to lines, in which each coordinate<a id="_idIndexMarker1480"/> defines a point that will be connected to draw the outline of the polygon. The difference is that the last point and the first point will also be connected to form a closed shape.</p>
    <p class="normal">Add a polygon to our demo script like so:</p>
    <pre class="programlisting code"><code class="hljs-code">canvas.create_polygon(
  (350, 225), (350,  300), (375, 275), (400, 300),
  (425, 275), (450, 300), (450, 225),
  fill='blue'
)
</code></pre>
    <p class="normal">Note that, unlike with <code class="Code-In-Text--PACKT-">create_line()</code>, the <code class="Code-In-Text--PACKT-">fill</code> argument defines the color of the polygon's interior, not the color of the outline. The appearance of the polygon's outline can be configured using the same arguments that <code class="Code-In-Text--PACKT-">create_rectangle()</code> and <code class="Code-In-Text--PACKT-">create_oval()</code> use.</p>
    <h3 id="_idParaDest-418" class="title">Text</h3>
    <p class="normal">In addition to simple shapes, we can also place<a id="_idIndexMarker1481"/> text directly on the <code class="Code-In-Text--PACKT-">Canvas</code>.</p>
    <p class="normal">For example, let's add some text to our demo:</p>
    <pre class="programlisting code"><code class="hljs-code">canvas.create_text(
  (500, 100), text='Insert a Quarter',
  fill='yellow', font='TkDefaultFont 64'
)
</code></pre>
    <p class="normal">The single coordinate argument determines the point where the text will be anchored to the <code class="Code-In-Text--PACKT-">Canvas</code>. By default, the text is attached at its own center point to the anchor point. In this case, that means that the middle of our string (somewhere around the "a") will be at <code class="Code-In-Text--PACKT-">x=500</code>, <code class="Code-In-Text--PACKT-">y=100</code>. However, the <code class="Code-In-Text--PACKT-">anchor</code> argument can be used to specify which part of the text item is attached to the anchor point; it can be any of the cardinal direction constants (<code class="Code-In-Text--PACKT-">N</code>, <code class="Code-In-Text--PACKT-">NW</code>, <code class="Code-In-Text--PACKT-">W</code>, and so on) or <code class="Code-In-Text--PACKT-">CENTER</code>, which is the default.</p>
    <p class="normal">The <code class="Code-In-Text--PACKT-">fill</code> argument in this case determines the color of the text, and we can use <code class="Code-In-Text--PACKT-">font</code> to determine the font properties<a id="_idIndexMarker1482"/> of the text. Tkinter 8.6 and later also offers an <code class="Code-In-Text--PACKT-">angle</code> argument that can rotate the text by the given number of degrees.</p>
    <h3 id="_idParaDest-419" class="title">Images</h3>
    <p class="normal">Of course, we aren't limited to just drawing lines and simple shapes on the <code class="Code-In-Text--PACKT-">Canvas</code>; we can also place raster images<a id="_idIndexMarker1483"/> using the <code class="Code-In-Text--PACKT-">create_image()</code> method. This method allows us to place a <code class="Code-In-Text--PACKT-">PhotoImage</code> or <code class="Code-In-Text--PACKT-">BitmapImage</code> object on the <code class="Code-In-Text--PACKT-">Canvas</code>, like so:</p>
    <pre class="programlisting code"><code class="hljs-code"># simple_canvas_demo.py
smiley = tk.PhotoImage(file='smile.gif')
canvas.create_image((570, 250), image=smiley)
</code></pre>
    <p class="normal">As with text, the image is attached to the anchor coordinate at its center by default, but the <code class="Code-In-Text--PACKT-">anchor</code> argument can be used to change that to any side or corner of the image's bounding box.</p>
    <h3 id="_idParaDest-420" class="title">Tkinter widgets</h3>
    <p class="normal">The last thing we can place on the <code class="Code-In-Text--PACKT-">Canvas</code> is another Tkinter widget. Of course, since the <code class="Code-In-Text--PACKT-">Canvas</code> is a widget, we can<a id="_idIndexMarker1484"/> just do this using a geometry manager like <code class="Code-In-Text--PACKT-">pack()</code> or <code class="Code-In-Text--PACKT-">grid()</code>, but we gain a lot more control if we add it as a <code class="Code-In-Text--PACKT-">Canvas</code> item using <code class="Code-In-Text--PACKT-">create_window()</code>.</p>
    <p class="normal">To add a widget using <code class="Code-In-Text--PACKT-">create_window()</code>, the widget need only be a child of a widget on the same parent window as the <code class="Code-In-Text--PACKT-">Canvas</code> widget. We can then pass a reference to the widget to the method's <code class="Code-In-Text--PACKT-">window</code> argument. We can also specify a <code class="Code-In-Text--PACKT-">width</code> and <code class="Code-In-Text--PACKT-">height</code> argument to determine the size of the window area to which the widget will be added; the widget will expand into that area by default.</p>
    <p class="normal">For example, let's add a quit button to the demo:</p>
    <pre class="programlisting code"><code class="hljs-code">quit = tk.Button(
  root, text='Quit', bg='black', fg='cyan', font='TkFixedFont 24',
  activeforeground='black', activebackground='cyan',  
  command=root.quit
)
canvas.create_window((100, 700), height=100, width=100, window=quit)
</code></pre>
    <p class="normal">Just as with text and images, the widget is anchored to the given coordinate at its center by default, and the <code class="Code-In-Text--PACKT-">anchor</code> argument<a id="_idIndexMarker1485"/> can be used to attach it at a side or corner instead.</p>
    <h3 id="_idParaDest-421" class="title">Canvas items and state</h3>
    <p class="normal">Note the use of the <code class="Code-In-Text--PACKT-">activeforeground</code> and <code class="Code-In-Text--PACKT-">activebackground</code> arguments in the code example above. Just like widgets, <code class="Code-In-Text--PACKT-">Canvas</code> items<a id="_idIndexMarker1486"/> can have various states set that can be used to dynamically<a id="_idIndexMarker1487"/> change the appearance. The table below shows the available states for items, and what result they have:</p>
    <table id="table003-9" class="No-Table-Style">
      <colgroup>
        <col/>
        <col/>
        <col/>
      </colgroup>
      <tbody>
        <tr class="No-Table-Style">
          <td class="No-Table-Style">
            <p class="Table-Column-Heading--PACKT-">State</p>
          </td>
          <td class="No-Table-Style">
            <p class="Table-Column-Heading--PACKT-">Trigger</p>
          </td>
          <td class="No-Table-Style">
            <p class="Table-Column-Heading--PACKT-">Result</p>
          </td>
        </tr>
        <tr class="No-Table-Style">
          <td class="No-Table-Style">
            <p class="Table-Column-Content--PACKT-"><code class="Code-In-Text--PACKT-">normal</code></p>
          </td>
          <td class="No-Table-Style">
            <p class="Table-Column-Content--PACKT-">Default</p>
          </td>
          <td class="No-Table-Style">
            <p class="Table-Column-Content--PACKT-">Normal appearance</p>
          </td>
        </tr>
        <tr class="No-Table-Style">
          <td class="No-Table-Style">
            <p class="Table-Column-Content--PACKT-"><code class="Code-In-Text--PACKT-">disabled</code></p>
          </td>
          <td class="No-Table-Style">
            <p class="Table-Column-Content--PACKT-">Manual setting</p>
          </td>
          <td class="No-Table-Style">
            <p class="Table-Column-Content--PACKT-">Disabled appearance</p>
          </td>
        </tr>
        <tr class="No-Table-Style">
          <td class="No-Table-Style">
            <p class="Table-Column-Content--PACKT-"><code class="Code-In-Text--PACKT-">active</code></p>
          </td>
          <td class="No-Table-Style">
            <p class="Table-Column-Content--PACKT-">Mouse hovers over</p>
          </td>
          <td class="No-Table-Style">
            <p class="Table-Column-Content--PACKT-">Active appearance</p>
          </td>
        </tr>
        <tr class="No-Table-Style">
          <td class="No-Table-Style">
            <p class="Table-Column-Content--PACKT-"><code class="Code-In-Text--PACKT-">hidden</code></p>
          </td>
          <td class="No-Table-Style">
            <p class="Table-Column-Content--PACKT-">Manual setting</p>
          </td>
          <td class="No-Table-Style">
            <p class="Table-Column-Content--PACKT-">Not shown</p>
          </td>
        </tr>
      </tbody>
    </table>
    <p class="normal">All drawn items (that is, not images) have state-based versions of their <code class="Code-In-Text--PACKT-">fill</code>, <code class="Code-In-Text--PACKT-">outline</code>, <code class="Code-In-Text--PACKT-">dash</code>, <code class="Code-In-Text--PACKT-">width</code>, <code class="Code-In-Text--PACKT-">stipple</code>, and <code class="Code-In-Text--PACKT-">outlinestipple</code> arguments, which are simply the argument with <code class="Code-In-Text--PACKT-">active</code> or <code class="Code-In-Text--PACKT-">disabled</code> prefixed to it. For example, <code class="Code-In-Text--PACKT-">activefill</code> sets the <code class="Code-In-Text--PACKT-">fill</code> value when the item is hovered over by the mouse, while <code class="Code-In-Text--PACKT-">disabledoutline</code> sets the outline color when the item is set to a <code class="Code-In-Text--PACKT-">disabled</code> state. Image items have <code class="Code-In-Text--PACKT-">disabledimage</code> and <code class="Code-In-Text--PACKT-">activeimage</code> arguments that can be set to display a different image when the item is disabled or active.</p>
    <p class="normal">The <code class="Code-In-Text--PACKT-">active</code> state is automatically set when an item is hovered over by the mouse; the <code class="Code-In-Text--PACKT-">disabled</code> and <code class="Code-In-Text--PACKT-">hidden</code> states can be set using the <code class="Code-In-Text--PACKT-">Canvas.itemconfigure()</code> method, which is discussed below in the <em class="italic">Canvas object methods</em> section.</p>
    <h2 id="_idParaDest-422" class="title">Canvas object methods</h2>
    <p class="normal"><code class="Code-In-Text--PACKT-">Canvas</code> items are not represented by a Python object; instead, the return value of any <code class="Code-In-Text--PACKT-">create_()</code> method<a id="_idIndexMarker1488"/> is an integer that uniquely identifies the item in the context of the <code class="Code-In-Text--PACKT-">Canvas</code> object. To manipulate <code class="Code-In-Text--PACKT-">Canvas</code> items after they've been created, we need to save that identification value and pass it to various <code class="Code-In-Text--PACKT-">Canvas</code> methods.</p>
    <p class="normal">For example, we could save the ID of the image we added, then bind the image to a callback using the <code class="Code-In-Text--PACKT-">Canvas.tag_bind()</code> method:</p>
    <pre class="programlisting code"><code class="hljs-code"># simple_canvas_demo.py
<strong class="hljs-slc">image_item = </strong>canvas.create_image((570, 250), image=smiley)
<strong class="hljs-slc">canvas.tag_bind(</strong>
<strong class="hljs-slc">  image_item,</strong>
<strong class="hljs-slc">  </strong><strong class="hljs-string-slc">'&lt;Button-1&gt;'</strong><strong class="hljs-slc">,</strong>
<strong class="hljs-slc">  </strong><strong class="hljs-keyword-slc">lambda</strong><strong class="hljs-slc"> e: canvas.delete(image_item)</strong>
<strong class="hljs-slc">)</strong>
</code></pre>
    <p class="normal">Here, we've used the <code class="Code-In-Text--PACKT-">tag_bind()</code> method to bind a left-mouse click on our image object to the <code class="Code-In-Text--PACKT-">Canvas</code>'s <code class="Code-In-Text--PACKT-">delete()</code> method, which (when given an item identifier) deletes the item.</p>
    <p class="normal">The <code class="Code-In-Text--PACKT-">Canvas</code> object has<a id="_idIndexMarker1489"/> many methods that can operate on a <code class="Code-In-Text--PACKT-">Canvas</code> item; some of the more useful ones are listed in this table:</p>
    <table id="table004-7" class="No-Table-Style">
      <colgroup>
        <col/>
        <col/>
        <col/>
      </colgroup>
      <tbody>
        <tr class="No-Table-Style">
          <td class="No-Table-Style">
            <p class="Table-Column-Heading--PACKT-">Method</p>
          </td>
          <td class="No-Table-Style">
            <p class="Table-Column-Heading--PACKT-">Arguments</p>
          </td>
          <td class="No-Table-Style">
            <p class="Table-Column-Heading--PACKT-">Description</p>
          </td>
        </tr>
        <tr class="No-Table-Style">
          <td class="No-Table-Style">
            <p class="Table-Column-Content--PACKT-"><code class="Code-In-Text--PACKT-">bbox()</code></p>
          </td>
          <td class="No-Table-Style">
            <p class="Table-Column-Content--PACKT-">Item ID</p>
          </td>
          <td class="No-Table-Style">
            <p class="Table-Column-Content--PACKT-">Returns a tuple describing the bounding box of the item.</p>
          </td>
        </tr>
        <tr class="No-Table-Style">
          <td class="No-Table-Style">
            <p class="Table-Column-Content--PACKT-"><code class="Code-In-Text--PACKT-">coords()</code></p>
          </td>
          <td class="No-Table-Style">
            <p class="Table-Column-Content--PACKT-">Item ID, coordinates</p>
          </td>
          <td class="No-Table-Style">
            <p class="Table-Column-Content--PACKT-">If only the ID is provided, returns the coordinates of the item. Otherwise, moves the item to the given coordinates.</p>
          </td>
        </tr>
        <tr class="No-Table-Style">
          <td class="No-Table-Style">
            <p class="Table-Column-Content--PACKT-"><code class="Code-In-Text--PACKT-">delete()</code></p>
          </td>
          <td class="No-Table-Style">
            <p class="Table-Column-Content--PACKT-">Item ID</p>
          </td>
          <td class="No-Table-Style">
            <p class="Table-Column-Content--PACKT-">Deletes the item from the <code class="Code-In-Text--PACKT-">Canvas</code>.</p>
          </td>
        </tr>
        <tr class="No-Table-Style">
          <td class="No-Table-Style">
            <p class="Table-Column-Content--PACKT-"><code class="Code-In-Text--PACKT-">find_overlapping()</code></p>
          </td>
          <td class="No-Table-Style">
            <p class="Table-Column-Content--PACKT-">Box coordinates</p>
          </td>
          <td class="No-Table-Style">
            <p class="Table-Column-Content--PACKT-">Returns a list of item IDs that overlap the box described by the coordinates.</p>
          </td>
        </tr>
        <tr class="No-Table-Style">
          <td class="No-Table-Style">
            <p class="Table-Column-Content--PACKT-"><code class="Code-In-Text--PACKT-">itemcget()</code></p>
          </td>
          <td class="No-Table-Style">
            <p class="Table-Column-Content--PACKT-">Item ID, option</p>
          </td>
          <td class="No-Table-Style">
            <p class="Table-Column-Content--PACKT-">Returns the value of <code class="Code-In-Text--PACKT-">option</code> for the given item.</p>
          </td>
        </tr>
        <tr class="No-Table-Style">
          <td class="No-Table-Style">
            <p class="Table-Column-Content--PACKT-"><code class="Code-In-Text--PACKT-">itemconfigure()</code></p>
          </td>
          <td class="No-Table-Style">
            <p class="Table-Column-Content--PACKT-">Item ID, option</p>
          </td>
          <td class="No-Table-Style">
            <p class="Table-Column-Content--PACKT-">Sets one or more configuration options on the specified item.</p>
          </td>
        </tr>
        <tr class="No-Table-Style">
          <td class="No-Table-Style">
            <p class="Table-Column-Content--PACKT-"><code class="Code-In-Text--PACKT-">move()</code></p>
          </td>
          <td class="No-Table-Style">
            <p class="Table-Column-Content--PACKT-">Item ID, X, Y</p>
          </td>
          <td class="No-Table-Style">
            <p class="Table-Column-Content--PACKT-">Moves the item on the <code class="Code-In-Text--PACKT-">Canvas</code> relative to its current position by the given <code class="Code-In-Text--PACKT-">X</code> and <code class="Code-In-Text--PACKT-">Y</code> amounts.</p>
          </td>
        </tr>
        <tr class="No-Table-Style">
          <td class="No-Table-Style">
            <p class="Table-Column-Content--PACKT-"><code class="Code-In-Text--PACKT-">type()</code></p>
          </td>
          <td class="No-Table-Style">
            <p class="Table-Column-Content--PACKT-">Item ID</p>
          </td>
          <td class="No-Table-Style">
            <p class="Table-Column-Content--PACKT-">Returns a string describing the type of object (rectangle, oval, arc, and so on).</p>
          </td>
        </tr>
      </tbody>
    </table>
    <p class="normal">Note that any of these methods<a id="_idIndexMarker1490"/> that take an item ID can also take a <strong class="keyword">tag</strong>. Recall from <em class="chapterRef">Chapter 9</em>, <em class="italic">Improving the Look with Styles and Themes</em>, that a tag is just a string that can be assigned to an item when created, allowing us to refer to multiple items at once. The <code class="Code-In-Text--PACKT-">Canvas</code> has two tags built in by default, <code class="Code-In-Text--PACKT-">all</code> and <code class="Code-In-Text--PACKT-">current</code>. As you might expect, <code class="Code-In-Text--PACKT-">all</code> refers to all items on the <code class="Code-In-Text--PACKT-">Canvas</code>, and <code class="Code-In-Text--PACKT-">current</code> refers to the item that currently has focus. </p>
    <p class="normal">All <code class="Code-In-Text--PACKT-">create_()</code> methods<a id="_idIndexMarker1491"/> allow the option of specifying a tuple of tag strings to attach to the object. </p>
    <p class="normal">By the way, if you haven't yet, add <code class="Code-In-Text--PACKT-">root.mainloop()</code> to the demo script and execute it to see what we've drawn!</p>
    <h2 id="_idParaDest-423" class="title">Scrolling the Canvas</h2>
    <p class="normal">As mentioned earlier, the width and height of a <code class="Code-In-Text--PACKT-">Canvas</code> widget determines the size of the viewport, but<a id="_idIndexMarker1492"/> the actual drawable area on the widget stretches endlessly out in all directions. To actually see objects outside the viewport area, we need to enable scrolling.</p>
    <p class="normal">To see how this works, let's create a scrollable starfield; open a new file called <code class="Code-In-Text--PACKT-">canvas_scroll.py</code> and let's begin like so:</p>
    <pre class="programlisting code"><code class="hljs-code"># canvas_scroll.py
import tkinter as tk
from random import randint, choice
# Create root and canvas
root = tk.Tk()
width = 1024
height = 768
canvas = tk.Canvas(
  root, background='black',
  width=width, height=height,
)
canvas.grid(row=0, column=0)
</code></pre>
    <p class="normal">Here, we've imported <code class="Code-In-Text--PACKT-">tkinter</code> and some functions from <code class="Code-In-Text--PACKT-">random</code>, then created a root window and a <code class="Code-In-Text--PACKT-">Canvas</code> object with a viewport size of 1024x768. Finally, we've placed the <code class="Code-In-Text--PACKT-">Canvas</code> on the root window using <code class="Code-In-Text--PACKT-">grid()</code>.</p>
    <p class="normal">Now, let's draw some "stars":</p>
    <pre class="programlisting code"><code class="hljs-code">colors = ['#FCC', '#CFC', '#CCF', '#FFC', '#FFF', '#CFF']
for _ in range(1000):
  x = randint(0, width * 2)
  y = randint(0, height * 2)
  z = randint(1, 10)
  c = choice(colors)
  canvas.create_oval((x - z, y - z), (x + z, y + z), fill=c)
</code></pre>
    <p class="normal">We begin by defining a list of color values, then start a <code class="Code-In-Text--PACKT-">for</code> loop that will iterate 1000 times. Inside the loop, we'll generate random <code class="Code-In-Text--PACKT-">X</code> and <code class="Code-In-Text--PACKT-">Y</code> coordinates, a random size (<code class="Code-In-Text--PACKT-">Z</code>), and choose one of the colors at random. We'll then have the <code class="Code-In-Text--PACKT-">Canvas</code> draw a circle centered on the random point filled with the random color.</p>
    <p class="normal">Notice that the ranges supplied for <code class="Code-In-Text--PACKT-">X</code> and <code class="Code-In-Text--PACKT-">Y</code> are double the size of the <code class="Code-In-Text--PACKT-">Canvas</code> object. Because of this, the loop<a id="_idIndexMarker1493"/> will be creating circles out to the right and down from our viewport area.</p>
    <p class="normal">To enable scrolling of the <code class="Code-In-Text--PACKT-">Canvas</code>, we first have to define a <code class="Code-In-Text--PACKT-">scrollregion</code> value for it, like so:</p>
    <pre class="programlisting code"><code class="hljs-code">canvas.configure(scrollregion=(0, 0, width * 2, height * 2))
</code></pre>
    <p class="normal">The <code class="Code-In-Text--PACKT-">scrollregion</code> value is a tuple of four integers that describe the bounding box of the area we want to be able to scroll. Essentially, the first two integers are the <code class="Code-In-Text--PACKT-">X</code> and <code class="Code-In-Text--PACKT-">Y</code> coordinates of the upper-left corner of the box, and the second two are the coordinates of the lower right.</p>
    <p class="normal">To actually scroll the <code class="Code-In-Text--PACKT-">Canvas</code>, we'll need some <code class="Code-In-Text--PACKT-">Scrollbar</code> widgets. We've already encountered these in <em class="chapterRef">Chapter 8</em>, <em class="italic">Navigating Records with Treeview and Notebook</em>, remember that to use them we need to create the widgets, add them to the layout, and connect the appropriate callbacks so that the scrollbars can communicate with the widget being scrolled.</p>
    <p class="normal">Add the following code to the script:</p>
    <pre class="programlisting code"><code class="hljs-code">xscroll = tk.Scrollbar(
  root,
  command=canvas.xview,
  orient=tk.HORIZONTAL
)
xscroll.grid(row=1, column=0, sticky='new')
yscroll = tk.Scrollbar(root, command=canvas.yview)
yscroll.grid(row=0, column=1, sticky='nsw')
canvas.configure(yscrollcommand=yscroll.set)
canvas.configure(xscrollcommand=xscroll.set)
</code></pre>
    <p class="normal">Here, we've created two <code class="Code-In-Text--PACKT-">Scrollbar</code> widgets, one for horizontal scrolling and one for vertical. We've added them to the layout just below and to the right of the <code class="Code-In-Text--PACKT-">Canvas</code>, respectively. Then, we connect each scrollbar's <code class="Code-In-Text--PACKT-">command</code> argument to the <code class="Code-In-Text--PACKT-">Canvas</code>'s <code class="Code-In-Text--PACKT-">xview</code> or <code class="Code-In-Text--PACKT-">yview</code> method, and configure the <code class="Code-In-Text--PACKT-">Canvas</code>'s <code class="Code-In-Text--PACKT-">yscrollcommand</code> and <code class="Code-In-Text--PACKT-">xscrollcommand</code> arguments to call the respective scrollbar's <code class="Code-In-Text--PACKT-">set()</code> method.</p>
    <p class="normal">Finish off this script with<a id="_idIndexMarker1494"/> a call to <code class="Code-In-Text--PACKT-">root.mainloop()</code> and execute it; you should see something like the picture here:</p>
    <figure class="mediaobject"><img src="img/B17578_15_02.png" alt="Figure 15.1: Scrolling through the stars!"/></figure>
    <p class="packt_figref">Figure 15.2: Scrolling through the stars!</p>
    <div><p class="Tip--PACKT-">A handy trick to properly configure the scroll region after drawing runtime-defined points on the <code class="Code-In-Text--PACKT-">Canvas</code> (for example, drawing based on user input) is to set <code class="Code-In-Text--PACKT-">scrollregion</code> to the output of <code class="Code-In-Text--PACKT-">canvas.bbox('all')</code> after creating the items. When passed a tag of <code class="Code-In-Text--PACKT-">all</code>, the <code class="Code-In-Text--PACKT-">bbox()</code> method returns a bounding box that contains the entirety of all items on the <code class="Code-In-Text--PACKT-">Canvas</code>. You can set this value directly to <code class="Code-In-Text--PACKT-">scrollregion</code> to make sure all your items can be viewed.</p>
    </div>
    <h2 id="_idParaDest-424" class="title">Animating Canvas objects</h2>
    <p class="normal">Tkinter's <code class="Code-In-Text--PACKT-">Canvas</code> widget doesn't have a built-in animation framework, but we can still create simple animations<a id="_idIndexMarker1495"/> by combining its <code class="Code-In-Text--PACKT-">move()</code> method with our understanding of the event queue.</p>
    <p class="normal">To demonstrate this, we'll create a bug race simulator, in which two bugs (represented by colored circles) will race haphazardly toward a finish line on the other side of the screen. Like real bugs, they won't have any notion that they're in a race and will move relatively randomly, the winner being whichever bug incidentally hits the finish line first.</p>
    <p class="normal">To begin, open a new Python file<a id="_idIndexMarker1496"/> and start with a basic object-oriented pattern, like so:</p>
    <pre class="programlisting code"><code class="hljs-code"># bug_race.py
import tkinter as tk
class App(tk.Tk):
  def __init__(self, *args, **kwargs):
    super().__init__(*args, **kwargs)
    self.canvas = tk.Canvas(self, background='black')
    self.canvas.pack(fill='both', expand=1)
    self.geometry('800x600')
App().mainloop()
</code></pre>
    <p class="normal">This is just a simple OOP Tkinter boilerplate application with a <code class="Code-In-Text--PACKT-">Canvas</code> object added to the root window. This will be the basic platform on which we'll build our game code.</p>
    <h3 id="_idParaDest-425" class="title">Setting up the playing field</h3>
    <p class="normal">Now that we have the basic framework, let's set up the playing field. We want to be able to reset the playing field<a id="_idIndexMarker1497"/> after each round, so rather than doing this in the initializer, we'll create a separate method called <code class="Code-In-Text--PACKT-">setup()</code>, as follows:</p>
    <pre class="programlisting code"><code class="hljs-code">  def setup(self):
    self.canvas.left = 0
    self.canvas.top = 0
    self.canvas.right = self.canvas.winfo_width()
    self.canvas.bottom = self.canvas.winfo_height()
    self.canvas.center_x = self.canvas.right // 2
    self.canvas.center_y = self.canvas.bottom // 2
    self.finish_line = self.canvas.create_rectangle(
      (self.canvas.right - 50, 0),
      (self.canvas.right, self.canvas.bottom),
      fill='yellow', stipple='gray50'
    )
</code></pre>
    <p class="normal">The <code class="Code-In-Text--PACKT-">setup()</code> method begins by calculating some relative locations on the <code class="Code-In-Text--PACKT-">Canvas</code> object and saving them as instance properties, which will simplify the placement of objects on the <code class="Code-In-Text--PACKT-">Canvas</code> object. Calculating these at runtime means we can resize the window between rounds for a longer or shorter racecourse.</p>
    <p class="normal">The finish line is implemented<a id="_idIndexMarker1498"/> as a rectangle across the right edge of the window. Note the use of the <code class="Code-In-Text--PACKT-">stipple</code> argument to specify a bitmap that will overlay the solid color to give it some texture; in this case, <code class="Code-In-Text--PACKT-">gray50</code> is a built-in bitmap that alternates filled and transparent pixels. This gives us something a little more interesting than a flat color.</p>
    <p class="normal">Add a call to <code class="Code-In-Text--PACKT-">setup()</code> at the end of <code class="Code-In-Text--PACKT-">App.__init__()</code> as follows:</p>
    <pre class="programlisting code"><code class="hljs-code"># bug_race.py, in App.__init__()
        self.canvas.wait_visibility()
        self.setup()
</code></pre>
    <p class="normal">Because <code class="Code-In-Text--PACKT-">setup()</code> relies on the width and height values of the <code class="Code-In-Text--PACKT-">Canvas</code> object, we need to make sure it isn't called until the operating system's window manager has drawn and sized the window. The simplest way of doing this is to call <code class="Code-In-Text--PACKT-">wait_visibility()</code> on the <code class="Code-In-Text--PACKT-">Canvas</code> object, which will block execution until the object has been drawn.</p>
    <h3 id="_idParaDest-426" class="title">Setting our players</h3>
    <p class="normal">Now that we have<a id="_idIndexMarker1499"/> the playing field, we need to create our players. We'll create a <code class="Code-In-Text--PACKT-">Racer</code> class to represent a player; start it like so:</p>
    <pre class="programlisting code"><code class="hljs-code"># bug_race.py
class Racer:
  def __init__(self, canvas, color):
    self.canvas = canvas
    self.name = f"{color.title()} player"
    size = 50
    self.id = canvas.create_oval(
      (canvas.left, canvas.center_y),
      (canvas.left + size, canvas.center_y + size),
      fill=color
    )
</code></pre>
    <p class="normal">The <code class="Code-In-Text--PACKT-">Racer</code> class will be created with a reference to the <code class="Code-In-Text--PACKT-">Canvas</code> object and a color string, from which its color<a id="_idIndexMarker1500"/> and name will be derived. We'll draw the racer initially at the middle left of the screen and make it 50 pixels in size. Finally, we save a reference to its item ID string in <code class="Code-In-Text--PACKT-">self.id</code>.</p>
    <p class="normal">Now, back in <code class="Code-In-Text--PACKT-">App.setup()</code>, we'll create two racers by adding the following:</p>
    <pre class="programlisting code"><code class="hljs-code"># bug_race.py, in App.setup()
    self.racers = [
      Racer(self.canvas, 'red'),
      Racer(self.canvas, 'green')
    ]
</code></pre>
    <p class="normal">At this point, all the objects in our game are set up. Run the program and you should see a yellow-stippled finish line on the right and a green circle on the left (the red circle will be hidden under the green, since they're at the same coordinates).</p>
    <h3 id="_idParaDest-427" class="title">Animating the racers</h3>
    <p class="normal">To animate our racers, we're going to use the <code class="Code-In-Text--PACKT-">Canvas.move()</code> method. As we learned earlier, <code class="Code-In-Text--PACKT-">move()</code> takes an item ID, a number of <code class="Code-In-Text--PACKT-">X</code> pixels, and a number of <code class="Code-In-Text--PACKT-">Y</code> pixels, and moves the item<a id="_idIndexMarker1501"/> by that amount. By combining this with the <code class="Code-In-Text--PACKT-">random.randint()</code> function and some simple logic, we can generate a series of moves that will send each racer on a meandering path toward the finish line.</p>
    <p class="normal">A simple implementation may look like this:</p>
    <pre class="programlisting code"><code class="hljs-code">from random import randint
# inside Racer
  def move_racer(self):
    x = randint(0, 100)
    y = randint(-50, 50)
    t = randint(500, 2000)
    self.canvas.after(t, self.canvas.move, self.id, x, y)
    if self.canvas.bbox(self.id)[0] &lt; self.canvas.right:
      self.canvas.after(t, self.move_racer)
</code></pre>
    <p class="normal">This method generates a random forward <code class="Code-In-Text--PACKT-">X</code> movement, a random up-or-down <code class="Code-In-Text--PACKT-">Y</code> movement, and a random time interval. We then use the <code class="Code-In-Text--PACKT-">after()</code> method to schedule a call to <code class="Code-In-Text--PACKT-">move()</code> for the generated <code class="Code-In-Text--PACKT-">X</code> and <code class="Code-In-Text--PACKT-">Y</code> movements after the random time interval. The <code class="Code-In-Text--PACKT-">if</code> statement determines whether the racer's bounding box is currently at or beyond the right side of the screen; if this test<a id="_idIndexMarker1502"/> evaluates to <code class="Code-In-Text--PACKT-">False</code>, we schedule another call to <code class="Code-In-Text--PACKT-">move_racer()</code>.</p>
    <p class="normal">This method gets the racers to the finish line, but it isn't quite what we want. The problem is that <code class="Code-In-Text--PACKT-">move()</code> acts instantaneously, causing the bug to jump across the screen in jerky movements rather than moving smoothly.</p>
    <p class="normal">To make the bugs move smoothly, we're going to need to take a more complex approach:</p>
    <ol>
      <li class="numbered">First, we'll calculate a series of linear moves, each with a random delta <code class="Code-In-Text--PACKT-">x</code>, delta <code class="Code-In-Text--PACKT-">y</code>, and interval, that will reach the finish line</li>
      <li class="numbered">Then, we'll break each individual move into a number of steps determined by dividing the movement interval into a regular animation frame interval</li>
      <li class="numbered">Next, we'll add each step of each movement to a queue</li>
      <li class="numbered">Finally, we'll call a method once each animation frame interval that will pull the next step from the queue and pass it to <code class="Code-In-Text--PACKT-">move()</code></li>
    </ol>
    <p class="normal">Let's start by defining our frame interval; in the <code class="Code-In-Text--PACKT-">Racer</code> class, create a class attribute for this:</p>
    <pre class="programlisting code"><code class="hljs-code">class Racer:
  FRAME_RES = 50
</code></pre>
    <p class="normal"><code class="Code-In-Text--PACKT-">FRAME_RES</code> (short for frame resolution) defines the number of milliseconds between each <code class="Code-In-Text--PACKT-">Canvas.move()</code> call. 50 milliseconds gives us 20 frames per second and should be sufficient for smooth movements.</p>
    <p class="normal">Next, we need to import the <code class="Code-In-Text--PACKT-">Queue</code> class and create an instance inside the <code class="Code-In-Text--PACKT-">Racer</code> object's initializer:</p>
    <pre class="programlisting code"><code class="hljs-code"># bug_race.py, at top
from queue import Queue
# inside Racer.__init__()
    self.movement_queue = Queue()
</code></pre>
    <p class="normal">Now, we will create the method<a id="_idIndexMarker1503"/> that will plot the course to the finish line:</p>
    <pre class="programlisting code"><code class="hljs-code"># bug_race.py, inside Racer
  def plot_course(self):
    start_x = self.canvas.left
    start_y = self.canvas.center_y
    total_dx, total_dy = (0, 0)
    while start_x + total_dx &lt; self.canvas.right:
      dx = randint(0, 100)
      dy = randint(-50, 50)
      target_y = start_y + total_dy + dy
      if not (self.canvas.top &lt; target_y &lt; self.canvas.bottom):
        dy = -dy
      total_dx += dx
      total_dy += dy
      time = randint(500, 2000)
      self.queue_move(dx, dy, time)
</code></pre>
    <p class="normal">This method plots a course from the left center of the <code class="Code-In-Text--PACKT-">Canvas</code> to a random point on the right side by generating random <code class="Code-In-Text--PACKT-">x</code> and <code class="Code-In-Text--PACKT-">y</code> movements until the total change in <code class="Code-In-Text--PACKT-">x</code> is greater than the width of the <code class="Code-In-Text--PACKT-">Canvas</code> object. The change in <code class="Code-In-Text--PACKT-">x</code> will always be positive, keeping our bugs moving toward the finish line, but the change in <code class="Code-In-Text--PACKT-">y</code> can be positive or negative, to allow both upward and downward movement. To keep our bugs on the screen, we constrain the total <code class="Code-In-Text--PACKT-">y</code> movements by negating any change in <code class="Code-In-Text--PACKT-">y</code> that would put the player outside the top or bottom bounds of the <code class="Code-In-Text--PACKT-">Canvas</code>.</p>
    <p class="normal">In addition to the random <code class="Code-In-Text--PACKT-">dx</code> and <code class="Code-In-Text--PACKT-">dy</code> values, we generate a random time interval for the move to take, between half a second and two seconds. Finally, the generated <code class="Code-In-Text--PACKT-">dx</code>, <code class="Code-In-Text--PACKT-">dy</code>, and <code class="Code-In-Text--PACKT-">time</code> values are passed to a <code class="Code-In-Text--PACKT-">queue_move()</code> method.</p>
    <p class="normal">The <code class="Code-In-Text--PACKT-">queue_move()</code> method will need to break the large move into individual frames of movement that describe how the racer should<a id="_idIndexMarker1504"/> move in one <code class="Code-In-Text--PACKT-">FRAME_RES</code> interval. To make this calculation, we will need a <strong class="keyword">partition function</strong>, a mathematical function that will break an integer <code class="Code-In-Text--PACKT-">N</code> into <code class="Code-In-Text--PACKT-">K</code> approximately equal integers. For example, if we wanted to break <code class="Code-In-Text--PACKT-">-10</code> into four parts, our function should return a list like <code class="Code-In-Text--PACKT-">[-2, -2, -3, -3]</code>.</p>
    <p class="normal">Let's create <code class="Code-In-Text--PACKT-">partition()</code> as a static method on <code class="Code-In-Text--PACKT-">Racer</code>:</p>
    <pre class="programlisting code"><code class="hljs-code"># bug_race.py, inside Racer
  @staticmethod
  def partition(n, k):
    """Return a list of k integers that sum to n"""
    if n == 0:
      return [0] * k
</code></pre>
    <p class="normal">We start the method with<a id="_idIndexMarker1505"/> the easy case: when <code class="Code-In-Text--PACKT-">n</code> is <code class="Code-In-Text--PACKT-">0</code>, return a list of <code class="Code-In-Text--PACKT-">k</code> zeros.</p>
    <p class="normal">Now, we'll deal with the more complicated cases:</p>
    <pre class="programlisting code"><code class="hljs-code">    base_step = n // k
    parts = [base_step] * k
    for i in range(n % k):
      parts[i] += 1
    return parts
</code></pre>
    <p class="normal">For a non-zero <code class="Code-In-Text--PACKT-">n</code>, we first calculate the <code class="Code-In-Text--PACKT-">base_step</code> by dividing <code class="Code-In-Text--PACKT-">n</code> by <code class="Code-In-Text--PACKT-">k</code> using floor division, which rounds our result down to the nearest integer. Then, we create a list of length <code class="Code-In-Text--PACKT-">k</code> that is made up of <code class="Code-In-Text--PACKT-">base_step</code> values. Next, we need to distribute the remainder of <code class="Code-In-Text--PACKT-">n / k</code> among this list as evenly as we can. To accomplish this, we will add 1 to the first <code class="Code-In-Text--PACKT-">n % k</code> items in the parts list.</p>
    <p class="normal">Follow the math here using our example of <code class="Code-In-Text--PACKT-">n = -10</code> and <code class="Code-In-Text--PACKT-">k = 4</code>:</p>
    <ul>
      <li class="bullet">The base step is calculated as <code class="Code-In-Text--PACKT-">-10 / 4 = -3</code> (remember, floor division always rounds down, so <code class="Code-In-Text--PACKT-">-2.5</code> gets rounded to <code class="Code-In-Text--PACKT-">-3</code>).</li>
      <li class="bullet">We then create a list of four base step values: <code class="Code-In-Text--PACKT-">[-3, -3, -3, -3]</code>.</li>
      <li class="bullet"><code class="Code-In-Text--PACKT-">-10 % 4 = 2</code>, so we add <code class="Code-In-Text--PACKT-">1</code> to the first two items in the list.</li>
      <li class="bullet">We arrive at an answer of <code class="Code-In-Text--PACKT-">[-2, -2, -3, -3]</code>. Perfect!</li>
    </ul>
    <div><p class="Information-Box--PACKT-">Operations like this partition function are part of <strong class="keyword">discrete mathematics</strong>, a branch of mathematics<a id="_idIndexMarker1506"/> that deals with operations on whole numbers. Discrete mathematics is often used for solving spatial problems such as those encountered in drawing and animation.</p>
    </div>
    <p class="normal">Now that we have the partition method, we can write the <code class="Code-In-Text--PACKT-">queue_move()</code> method:</p>
    <pre class="programlisting code"><code class="hljs-code">  def queue_move(self, dx, dy, time):
    num_steps = time // self.FRAME_RES
    steps = zip(
      self.partition(dx, num_steps),
      self.partition(dy, num_steps)
    )
    for step in steps:
      self.movement_queue.put(step)
</code></pre>
    <p class="normal">We first determine the necessary number of steps in this move by dividing the time interval by <code class="Code-In-Text--PACKT-">FRAME_RES</code> using floor division. We then create a list of <code class="Code-In-Text--PACKT-">X</code> moves and a list of <code class="Code-In-Text--PACKT-">Y</code> moves by passing <code class="Code-In-Text--PACKT-">dx</code> and <code class="Code-In-Text--PACKT-">dy</code> each to our <code class="Code-In-Text--PACKT-">partition()</code> method. Those two lists are combined with <code class="Code-In-Text--PACKT-">zip()</code> to form<a id="_idIndexMarker1507"/> a single list of <code class="Code-In-Text--PACKT-">(dx, dy)</code> pairs, which we iterate to add each pair to the animation queue.</p>
    <p class="normal">To make the animation actually happen, we'll need a method to check the queue and make each move; we'll call it <code class="Code-In-Text--PACKT-">next_move()</code>:</p>
    <pre class="programlisting code"><code class="hljs-code">  def next_move(self):
    if not self.movement_queue.empty():
      nextmove = self.movement_queue.get()
      self.canvas.move(self.id, *nextmove)      
</code></pre>
    <p class="normal">The <code class="Code-In-Text--PACKT-">next_move()</code> method first checks the queue for a movement step. If there is one, <code class="Code-In-Text--PACKT-">canvas.move()</code> is called with the racer's ID and the <code class="Code-In-Text--PACKT-">X</code> and <code class="Code-In-Text--PACKT-">Y</code> values for the step. When the game starts, this method will be called repeatedly from the <code class="Code-In-Text--PACKT-">App</code> object until one of the racers has won.</p>
    <p class="normal">Finally, we need to add a call to <code class="Code-In-Text--PACKT-">plot_course()</code> to the <code class="Code-In-Text--PACKT-">Racer</code> class's initializer, like so:</p>
    <pre class="programlisting code"><code class="hljs-code"># bug_race.py, at the end of Racer.__init__()
    self.plot_course()
</code></pre>
    <p class="normal">Thus, as soon as a <code class="Code-In-Text--PACKT-">Racer</code> object is created, it will plot the course to the finish line, and wait for the <code class="Code-In-Text--PACKT-">App</code> class to tell it to move.</p>
    <h3 id="_idParaDest-428" class="title">Running the game loop and detecting a win condition</h3>
    <p class="normal">To actually run the game, we need<a id="_idIndexMarker1508"/> to start a game loop. Of course, we know from <em class="chapterRef">Chapter 14</em>, <em class="italic">Asynchronous Programming with Thread and Queue</em>, that we can't simply use a Python <code class="Code-In-Text--PACKT-">for</code> or <code class="Code-In-Text--PACKT-">while</code> loop, since this would block Tkinter drawing operations and simply make the game freeze up until it was over. Instead, we need to create a method that executes a single "frame" of the game animation, then schedules itself on the Tkinter event loop to run again.</p>
    <p class="normal">That method begins like this:</p>
    <pre class="programlisting code"><code class="hljs-code"># bug_race.py, inside App
  def execute_frame(self):
    for racer in self.racers:
      racer.next_move()
</code></pre>
    <p class="normal">It begins by iterating through the racer objects and executing their <code class="Code-In-Text--PACKT-">next_move() </code>methods. After moving<a id="_idIndexMarker1509"/> each racer, our next step is to determine if one of them has crossed the finish line and won.</p>
    <p class="normal">To detect this condition, we need to check whether a racer is overlapping with the finish line item. </p>
    <p class="normal">Collision detection<a id="_idIndexMarker1510"/> between items is slightly awkward with the Tkinter <code class="Code-In-Text--PACKT-">Canvas</code> widget. We have to pass a set of bounding box coordinates to <code class="Code-In-Text--PACKT-">find_overlapping()</code>, which returns a tuple of item identifiers that overlap with the bounding box.</p>
    <p class="normal">Let's create an <code class="Code-In-Text--PACKT-">overlapping()</code> method for our <code class="Code-In-Text--PACKT-">Racer</code> class:</p>
    <pre class="programlisting code"><code class="hljs-code"># bug_race.py, inside Racer
  @property
  def overlapping(self):
    bbox = self.canvas.bbox(self.id)
    overlappers = self.canvas.find_overlapping(*bbox)
    return [x for x in overlappers if x!=self.id]
</code></pre>
    <p class="normal">This method retrieves the bounding box of the <code class="Code-In-Text--PACKT-">Racer</code> item using the <code class="Code-In-Text--PACKT-">Canvas</code>'s <code class="Code-In-Text--PACKT-">bbox()</code> method. It then fetches a tuple of items overlapping this bounding box using <code class="Code-In-Text--PACKT-">find_overlapping()</code>. Since this would include the ID of the <code class="Code-In-Text--PACKT-">Racer</code> item itself, we'll filter that out of the tuple using a list comprehension. The result is a list of items overlapping with this <code class="Code-In-Text--PACKT-">Racer</code> object's <code class="Code-In-Text--PACKT-">Canvas</code> item. Since this method doesn't require any arguments and only returns a value, we've made it a property.</p>
    <p class="normal">Back in our <code class="Code-In-Text--PACKT-">execute_frame()</code> method, we'll check each racer to see if it has crossed the finish line:</p>
    <pre class="programlisting code"><code class="hljs-code"># bug_race.py, inside App
  def execute_frame(self):
    for racer in self.racers:
      racer.next_move()
      <strong class="hljs-keyword-slc">if</strong><strong class="hljs-slc"> self.finish_line </strong><strong class="hljs-keyword-slc">in</strong><strong class="hljs-slc"> racer.overlapping:</strong>
        <strong class="hljs-slc">self.declare_winner(racer)</strong>
        <strong class="hljs-keyword-slc">return</strong>
    <strong class="hljs-slc">self.after(Racer.FRAME_RES, self.execute_frame)</strong>
</code></pre>
    <p class="normal">If the <code class="Code-In-Text--PACKT-">finish_line</code> ID is in the list returned by the racer's <code class="Code-In-Text--PACKT-">overlapping()</code> method, the racer has hit the finish line and will be declared the winner by calling a <code class="Code-In-Text--PACKT-">declare_winner()</code> method and returning from the method. </p>
    <p class="normal">If no player was declared the winner, the <code class="Code-In-Text--PACKT-">execute_frame()</code> method is scheduled to run again after <code class="Code-In-Text--PACKT-">Racer.FRAME_RES</code> milliseconds. This effectively<a id="_idIndexMarker1511"/> implements a game loop using the<a id="_idIndexMarker1512"/> Tkinter event loop, which will run until one racer wins.</p>
    <p class="normal">We handle a win condition in the <code class="Code-In-Text--PACKT-">declare_winner()</code> method:</p>
    <pre class="programlisting code"><code class="hljs-code">  def declare_winner(self, racer):
    wintext = self.canvas.create_text(
      (self.canvas.center_x, self.canvas.center_y),
      text=f'{racer.name} wins!\nClick to play again.',
      fill='white',
      font='TkDefaultFont 32',
      activefill='violet'
    )
    self.canvas.tag_bind(wintext, '&lt;Button-1&gt;', self.reset)
</code></pre>
    <p class="normal">In this method, we've just created a text item declaring <code class="Code-In-Text--PACKT-">racer.name</code> as the winner in the center of the <code class="Code-In-Text--PACKT-">Canvas</code>. The <code class="Code-In-Text--PACKT-">activefill</code> argument causes the color to appear violet when the mouse is hovered over it, indicating to the user that this text is clickable.</p>
    <p class="normal">When that text is clicked, it calls the <code class="Code-In-Text--PACKT-">reset()</code> method:</p>
    <pre class="programlisting code"><code class="hljs-code">  def reset(self, *args):
    self.canvas.delete('all')
    self.setup()
</code></pre>
    <p class="normal">The <code class="Code-In-Text--PACKT-">reset()</code> method needs to clear off the <code class="Code-In-Text--PACKT-">Canvas</code>, so it calls the <code class="Code-In-Text--PACKT-">delete()</code> method with an argument of <code class="Code-In-Text--PACKT-">all</code>. Remember that <code class="Code-In-Text--PACKT-">all</code> is a built-in tag that applies to all items on the <code class="Code-In-Text--PACKT-">Canvas</code>, so this line effectively deletes all <code class="Code-In-Text--PACKT-">Canvas</code> items. Once the <code class="Code-In-Text--PACKT-">Canvas</code> is clear, we call <code class="Code-In-Text--PACKT-">setup()</code> to reset and restart the game.</p>
    <p class="normal">The last thing we need to do is make sure the game starts whenever <code class="Code-In-Text--PACKT-">setup()</code> is called. To do that, add a call to <code class="Code-In-Text--PACKT-">execute_frame()</code> to the end of <code class="Code-In-Text--PACKT-">setup()</code>:</p>
    <pre class="programlisting code"><code class="hljs-code"># bug_race.py, in App.setup()
  def setup():
    # ...
    self.execute_frame()
</code></pre>
    <p class="normal">The game is now complete; run the script<a id="_idIndexMarker1513"/> and you should see<a id="_idIndexMarker1514"/> something like this:</p>
    <figure class="mediaobject"><img src="img/B17578_15_03.png" alt=""/></figure>
    <p class="packt_figref">Figure 15.3: The bug race game. Red wins!</p>
    <p class="normal">While not exactly simple, animation in Tkinter can provide smooth and satisfactory results with some careful planning and a bit of math. Enough games, though; let's get back to the lab and figure out how to use the Tkinter <code class="Code-In-Text--PACKT-">Canvas</code> widget to visualize data.</p>
    <h1 id="_idParaDest-429" class="title">Creating simple graphs using Canvas</h1>
    <p class="normal">The first graph we want to produce is a simple line graph that shows the growth of our plants over time. Each lab<a id="_idIndexMarker1515"/> has varying climate conditions, and we want to see how those conditions<a id="_idIndexMarker1516"/> are affecting the growth of all plants, so the chart will have one line per lab showing the average of the median height measurements for all plots in the lab over the days of the experiment.</p>
    <p class="normal">We'll start by creating a model method to return the raw data, then create a <code class="Code-In-Text--PACKT-">Canvas</code>-based line-chart view, and finally create an application callback to pull the data and send it to the chart view.</p>
    <h2 id="_idParaDest-430" class="title">Creating the model method</h2>
    <p class="normal">Working with another data analyst at ABQ, you develop a SQL query that determines the day number<a id="_idIndexMarker1517"/> of a plot check by subtracting its date from the oldest date in the <code class="Code-In-Text--PACKT-">plot_checks</code> table, then<a id="_idIndexMarker1518"/> pulls <code class="Code-In-Text--PACKT-">lab_id</code> and the average of <code class="Code-In-Text--PACKT-">median_height</code> for all plants in the given lab on the given day. The query looks like this:</p>
    <pre class="programlisting code"><code class="hljs-code">SELECT
  date - (SELECT min(date) FROM plot_checks) AS "Day",
  lab_id,
  avg(median_height) AS "Average Height (cm)"
FROM plot_checks
GROUP BY date, lab_id
ORDER BY "Day", lab_id;
</code></pre>
    <p class="normal">The query returns a table of data that looks something like this:</p>
    <table id="table005-5" class="No-Table-Style _idGenTablePara-1">
      <colgroup>
        <col/>
        <col/>
        <col/>
      </colgroup>
      <tbody>
        <tr class="No-Table-Style">
          <td class="No-Table-Style">
            <p class="Table-Column-Heading--PACKT-">Day</p>
          </td>
          <td class="No-Table-Style">
            <p class="Table-Column-Heading--PACKT-">lab_id</p>
          </td>
          <td class="No-Table-Style">
            <p class="Table-Column-Heading--PACKT-">Average Height (cm)</p>
          </td>
        </tr>
        <tr class="No-Table-Style">
          <td class="No-Table-Style">
            <p class="Table-Column-Content--PACKT-">0</p>
          </td>
          <td class="No-Table-Style">
            <p class="Table-Column-Content--PACKT-">A</p>
          </td>
          <td class="No-Table-Style">
            <p class="Table-Column-Content--PACKT-">1.4198750000000000</p>
          </td>
        </tr>
        <tr class="No-Table-Style">
          <td class="No-Table-Style">
            <p class="Table-Column-Content--PACKT-">0</p>
          </td>
          <td class="No-Table-Style">
            <p class="Table-Column-Content--PACKT-">B</p>
          </td>
          <td class="No-Table-Style">
            <p class="Table-Column-Content--PACKT-">1.3320000000000000</p>
          </td>
        </tr>
        <tr class="No-Table-Style">
          <td class="No-Table-Style">
            <p class="Table-Column-Content--PACKT-">0</p>
          </td>
          <td class="No-Table-Style">
            <p class="Table-Column-Content--PACKT-">C</p>
          </td>
          <td class="No-Table-Style">
            <p class="Table-Column-Content--PACKT-">1.5377500000000000</p>
          </td>
        </tr>
        <tr class="No-Table-Style">
          <td class="No-Table-Style">
            <p class="Table-Column-Content--PACKT-">1</p>
          </td>
          <td class="No-Table-Style">
            <p class="Table-Column-Content--PACKT-">A</p>
          </td>
          <td class="No-Table-Style">
            <p class="Table-Column-Content--PACKT-">1.7266250000000000</p>
          </td>
        </tr>
        <tr class="No-Table-Style">
          <td class="No-Table-Style">
            <p class="Table-Column-Content--PACKT-">1</p>
          </td>
          <td class="No-Table-Style">
            <p class="Table-Column-Content--PACKT-">B</p>
          </td>
          <td class="No-Table-Style">
            <p class="Table-Column-Content--PACKT-">1.8503750000000000</p>
          </td>
        </tr>
        <tr class="No-Table-Style">
          <td class="No-Table-Style">
            <p class="Table-Column-Content--PACKT-">1</p>
          </td>
          <td class="No-Table-Style">
            <p class="Table-Column-Content--PACKT-">C</p>
          </td>
          <td class="No-Table-Style">
            <p class="Table-Column-Content--PACKT-">1.4633750000000000</p>
          </td>
        </tr>
      </tbody>
    </table>
    <p class="normal">Using this query, let's create a new <code class="Code-In-Text--PACKT-">SQLModel</code> method<a id="_idIndexMarker1519"/> called <code class="Code-In-Text--PACKT-">get_growth_by_lab()</code> to return the needed data:</p>
    <pre class="programlisting code"><code class="hljs-code"># models.py, inside SQLModel
  def get_growth_by_lab(self):
    query = (
      'SELECT date - (SELECT min(date) FROM plot_checks) AS "Day", '
      'lab_id, avg(median_height) AS "Avg Height (cm)" '
      'FROM plot_checks '
      'GROUP BY date, lab_id ORDER BY "Day", lab_id;'
    )
    return self.query(query)
</code></pre>
    <p class="normal">This is a fairly straightforward<a id="_idIndexMarker1520"/> method; it just runs the query and returns the results. Recall that the <code class="Code-In-Text--PACKT-">SQLModel.query()</code> method returns results as a list of dictionaries; in this case, each of the dictionaries<a id="_idIndexMarker1521"/> contains three fields: <code class="Code-In-Text--PACKT-">Day</code>, <code class="Code-In-Text--PACKT-">lab_id</code>, and <code class="Code-In-Text--PACKT-">Avg Height (cm)</code>. Now we just need to develop a chart view that can visualize this data for the user.</p>
    <h2 id="_idParaDest-431" class="title">Creating the chart view</h2>
    <p class="normal">The chart view we're going<a id="_idIndexMarker1522"/> to create will need to take the data structure from our model method<a id="_idIndexMarker1523"/> and use it to plot a line chart. Head over to <code class="Code-In-Text--PACKT-">views.py</code>, where we'll create the <code class="Code-In-Text--PACKT-">LineChartView</code> class:</p>
    <pre class="programlisting code"><code class="hljs-code"># views.py
class LineChartView(tk.Canvas):
  """A generic view for plotting a line chart"""
  margin = 20
  colors = [
    'red', 'orange', 'yellow', 'green',
    'blue', 'purple', 'violet'
  ]
</code></pre>
    <p class="normal"><code class="Code-In-Text--PACKT-">LineChartView</code> is a subclass of <code class="Code-In-Text--PACKT-">Canvas</code>, so we'll be able to draw items directly on it. This view will not only contain the data plots, but the axes, labels, and legend as well. It will be constructed for re-usability, so we're going to design it without any specific reference to the data we're charting in this instance. Ideally, we'd like to be able to send arbitrary datasets to it to generate line graphs. The two class attributes defined here provide a default value for the <code class="Code-In-Text--PACKT-">margin</code> around the chart (in pixels) and a list of <code class="Code-In-Text--PACKT-">colors</code> to use for each subsequent line plot. The growth<a id="_idIndexMarker1524"/> chart we're making only has three plots (one for each lab), but the additional colors allow us to specify up to seven. You could provide additional colors in this list if you wanted to use it for charts with more than seven plots.</p>
    <p class="normal">Now, we'll begin the initializer method:</p>
    <pre class="programlisting code"><code class="hljs-code"># views.py, inside LineChartView
  def __init__(
    self, parent, data, plot_size,
    x_field, y_field, plot_by_field
  ):
    self.data = data
    self.x_field = x_field
    self.y_field = y_field
    self.plot_by_field = plot_by_field
</code></pre>
    <p class="normal">Apart from the usual parent widget<a id="_idIndexMarker1525"/> argument, we've specified<a id="_idIndexMarker1526"/> these additional positional arguments:</p>
    <ul>
      <li class="bullet"><code class="Code-In-Text--PACKT-">data</code> will be our list of dictionaries containing the data from the query.</li>
      <li class="bullet"><code class="Code-In-Text--PACKT-">plot_size</code> will be a tuple of integers specifying the width and height of the plot area in pixels.</li>
      <li class="bullet"><code class="Code-In-Text--PACKT-">x_field</code> and <code class="Code-In-Text--PACKT-">y_field</code> will be the field names to use for the <code class="Code-In-Text--PACKT-">X</code> and <code class="Code-In-Text--PACKT-">Y</code> values of the plot. For the growth chart this will be <code class="Code-In-Text--PACKT-">Day</code> and <code class="Code-In-Text--PACKT-">Avg Height (cm)</code>, respectively.</li>
      <li class="bullet"><code class="Code-In-Text--PACKT-">plot_by_field</code> will be the field whose value will be used to categorize the rows into individual plots. For the growth chart, this will be <code class="Code-In-Text--PACKT-">lab_id</code>, since we want one line plot for each lab.</li>
    </ul>
    <p class="normal">All these values are stored to instance variables so we can access them from our methods.</p>
    <p class="normal">We're going to implement the plot area of this widget as a second <code class="Code-In-Text--PACKT-">Canvas</code> placed on the <code class="Code-In-Text--PACKT-">LineChartView</code>. The size of the <code class="Code-In-Text--PACKT-">LineChartView</code> then will need to be the size of the chart plus the margins around the outside where the axes and labels will be drawn. We'll calculate that size, then pass it to the <code class="Code-In-Text--PACKT-">LineChartView</code> superclass initializer, as follows:</p>
    <pre class="programlisting code"><code class="hljs-code">    self.plot_width, self.plot_height = plot_size
    view_width = self.plot_width + (2 * self.margin)
    view_height = self.plot_height + (2 * self.margin)
    super().__init__(
      parent, width=view_width,
      height=view_height, background='lightgrey'
    )
</code></pre>
    <p class="normal">Note that we've saved the<a id="_idIndexMarker1527"/> plot area's width and height as instance variables, as we'll need them<a id="_idIndexMarker1528"/> in some of our methods.</p>
    <p class="normal">Now that we've initialized the superclass, we can begin drawing on the main <code class="Code-In-Text--PACKT-">Canvas</code>; to begin, let's draw the axes:</p>
    <pre class="programlisting code"><code class="hljs-code">    self.origin = (self.margin, view_height - self.margin)
   # X axis
    self.create_line(
      self.origin,
      (view_width - self.margin, view_height - self.margin)
    )
    # Y axis
    self.create_line(
      self.origin, (self.margin, self.margin), width=2
    )
</code></pre>
    <p class="normal">Our chart's origin will be <code class="Code-In-Text--PACKT-">self.margin</code> pixels from the bottom-left corner, and we'll draw the <code class="Code-In-Text--PACKT-">X</code> and <code class="Code-In-Text--PACKT-">Y</code> axes as simple black lines moving right and up from the origin to the edge of the chart. Remember that the <code class="Code-In-Text--PACKT-">Canvas</code> <code class="Code-In-Text--PACKT-">Y</code> coordinates count down from the top, not up from the bottom, so the <code class="Code-In-Text--PACKT-">Y</code> coordinate for the origin is the height of the view area minus the margin.</p>
    <p class="normal">Next, we'll label the axes:</p>
    <pre class="programlisting code"><code class="hljs-code">    self.create_text(
      (view_width // 2, view_height - self.margin),
      text=x_field, anchor='n'
    )
    self.create_text(
       (self.margin, view_height // 2),
       text=y_field, angle=90, anchor='s'
    )
</code></pre>
    <p class="normal">Here, we're creating the text items set to the labels for the <code class="Code-In-Text--PACKT-">X</code> and <code class="Code-In-Text--PACKT-">Y</code> axes, using the field names passed into the object for the text labels. Note the use of <code class="Code-In-Text--PACKT-">anchor</code> to set which side of the text's bounding box is attached to the coordinates provided. In the case of the <code class="Code-In-Text--PACKT-">X</code> axis, for instance, we've specified <code class="Code-In-Text--PACKT-">n</code> (north), so the top of our text will be under the <code class="Code-In-Text--PACKT-">X</code>-axis line. For the <code class="Code-In-Text--PACKT-">Y</code>-axis label, we want<a id="_idIndexMarker1529"/> the text to be sideways, so we've specified <code class="Code-In-Text--PACKT-">angle=90</code> to rotate it. Also, note that we've used south (<code class="Code-In-Text--PACKT-">s</code>) as the <code class="Code-In-Text--PACKT-">anchor</code> position for the rotated text; even though it's rotated, the cardinal directions here are relative to the object <em class="italic">before</em> rotation. Thus, "south" will always be the bottom of the text as normally written, even if the object is rotated.</p>
    <p class="normal">With the axes labeled, we need to create a second <code class="Code-In-Text--PACKT-">Canvas</code> that will contain the plot area:</p>
    <pre class="programlisting code"><code class="hljs-code">    self.plot_area = tk.Canvas(
      self, background='#555',
      width=self.plot_width, height=self.plot_height
    )
    self.create_window(
      self.origin, window=self.plot_area, anchor='sw'
    )
</code></pre>
    <p class="normal">This <code class="Code-In-Text--PACKT-">Canvas</code> object is where the actual plots will be drawn. While we could draw our plots on the <code class="Code-In-Text--PACKT-">LineChartView</code> directly, embedding a second <code class="Code-In-Text--PACKT-">Canvas</code> makes it easier to calculate the coordinate points for the plot, since we won't have to factor in the margin. It also allows us to use a different background color for a nicer look.</p>
    <p class="normal">Before we can draw data on the chart, we need to create a method that can do so. Let's create a private instance method called <code class="Code-In-Text--PACKT-">_plot_line()</code> to draw a single line plot on the chart, which begins like this:</p>
    <pre class="programlisting code"><code class="hljs-code">  def _plot_line(self, data, color):
    max_x = max([row[0] for row in data])
    max_y = max([row[1] for row in data])
    x_scale = self.plot_width / max_x
    y_scale = self.plot_height / max_y
</code></pre>
    <p class="normal">This method will receive a <code class="Code-In-Text--PACKT-">data</code> argument containing the <code class="Code-In-Text--PACKT-">X</code> and <code class="Code-In-Text--PACKT-">Y</code> points for the line as a list of tuples. Since our chart<a id="_idIndexMarker1530"/> is a fixed number of pixels, and our data values may have any arbitrary range, the first thing we need to do is scale the data to fit just inside the size of our chart. To do this, we first find the maximum values of the <code class="Code-In-Text--PACKT-">X</code> and <code class="Code-In-Text--PACKT-">Y</code> fields, then create a scaling ratio for each axis by dividing the set height of the chart by the maximum value (note that this assumes the minimum value is 0. This particular chart class isn't designed to handle negative values).</p>
    <p class="normal">Once we have the scale values, we can then transform our data points to coordinates by using a list comprehension that multiplies each data point by the scale value, as follows:</p>
    <pre class="programlisting code"><code class="hljs-code">    coords = [
      (round(x * x_scale), self.plot_height - round(y * y_scale))
      for x, y in data
    ]
</code></pre>
    <p class="normal">Note that we are rounding<a id="_idIndexMarker1531"/> the values, since we can't plot to fractional pixel values. Also, once<a id="_idIndexMarker1532"/> again, since data is usually graphed with the origin in the bottom left, but coordinates on the <code class="Code-In-Text--PACKT-">Canvas</code> measure from the top left, we'll need to flip the <code class="Code-In-Text--PACKT-">Y</code> coordinates; this is done in our list comprehension as well by subtracting the new <code class="Code-In-Text--PACKT-">Y</code> value from the plot height.</p>
    <p class="normal">These coordinates can now be passed to <code class="Code-In-Text--PACKT-">create_line()</code> along with a reasonable width and the color argument passed in by the caller, like so:</p>
    <pre class="programlisting code"><code class="hljs-code">    self.plot_area.create_line(
      *coords, width=4, fill=color, smooth=True
    )
</code></pre>
    <p class="normal">Note that we've also used the <code class="Code-In-Text--PACKT-">smooth</code> argument to round out the curve a bit and make it appear more organic.</p>
    <p class="normal">To use this method, we need to head back to the initializer and do some calculations. Since the <code class="Code-In-Text--PACKT-">_plot_line()</code> method only handles one plot at a time, we'll need to filter out our data by the <code class="Code-In-Text--PACKT-">plot_by_field</code> field and render the lines one at a time.</p>
    <p class="normal">Add this code at the end of <code class="Code-In-Text--PACKT-">LineChartView.__init__()</code>:</p>
    <pre class="programlisting code"><code class="hljs-code"># views.py, in LineChartView.__init__()
    plot_names = sorted(set([
      row[self.plot_by_field]
      for row in self.data
    ]))
    color_map = list(zip(plot_names, self.colors))
</code></pre>
    <p class="normal">First, we get the individual plot names by retrieving the unique <code class="Code-In-Text--PACKT-">plot_by_field</code> values from the data. These are sorted and cast to a <code class="Code-In-Text--PACKT-">set</code> object so that we only have the unique values. Then, we create a color mapping using <code class="Code-In-Text--PACKT-">zip()</code> to build a list of name-to-color tuples. Since <code class="Code-In-Text--PACKT-">zip()</code> returns a generator and we're going to want to use this map more than once, it's cast to a <code class="Code-In-Text--PACKT-">list</code> object.</p>
    <p class="normal">Now, let's plot our lines:</p>
    <pre class="programlisting code"><code class="hljs-code">    for plot_name, color in color_map:
      dataxy = [
        (row[x_field], row[y_field])
        for row in data
        if row[plot_by_field] == plot_name
      ]
      self._plot_line(dataxy, color)
</code></pre>
    <p class="normal">For each distinct plot name<a id="_idIndexMarker1533"/> and color, we first format the data into a list of (<code class="Code-In-Text--PACKT-">X</code>, <code class="Code-In-Text--PACKT-">Y</code>) pairs using a list<a id="_idIndexMarker1534"/> comprehension. Then we call <code class="Code-In-Text--PACKT-">_plot_line()</code> with the data and the color. Our lines are now plotted!</p>
    <p class="normal">One last thing we need is a legend, to tell the user what each color on the chart represents. Without that, this chart would be meaningless to the user. To create it, we'll write a <code class="Code-In-Text--PACKT-">_draw_legend()</code> method:</p>
    <pre class="programlisting code"><code class="hljs-code"># views.py, inside LineChartView
  def _draw_legend(self, color_map):
    for i, (label, color) in enumerate(color_map):
      self.plot_area.create_text(
        (10, 10 + (i * 20), text=label, fill=color, anchor='w'
      )
</code></pre>
    <p class="normal">Our method takes the color map list that we created in the initializer and iterates over it, using the <code class="Code-In-Text--PACKT-">enumerate()</code> function to also generate an incrementing number for each iteration. For each mapping, we simply draw a text item containing the label text with the associated fill color. This is drawn starting at ten pixels from the top-left corner of the chart, with each item twenty pixels below the last.</p>
    <p class="normal">Finally, let's call this method from the initializer:</p>
    <pre class="programlisting code"><code class="hljs-code"># views.py, inside LineChartView.__init__()
    self._draw_legend(color_map)
</code></pre>
    <p class="normal">The <code class="Code-In-Text--PACKT-">LineChartView</code> is ready to go; now we just need to create the supporting code to invoke it.</p>
    <h2 id="_idParaDest-432" class="title">Updating the application</h2>
    <p class="normal">Back in the <code class="Code-In-Text--PACKT-">Application</code> class, create<a id="_idIndexMarker1535"/> a new method for showing our chart:</p>
    <pre class="programlisting code"><code class="hljs-code"># application.py, in Application
  def show_growth_chart(self, *_):
    data = self.model.get_growth_by_lab()
    popup = tk.Toplevel()
    chart = v.LineChartView(
      popup, data, (800, 400),
      'Day', 'Avg Height (cm)', 'lab_id'
    )
    chart.pack(fill='both', expand=1)
</code></pre>
    <p class="normal">The first order of business is to fetch the data from our <code class="Code-In-Text--PACKT-">get_growth_by_lab()</code> method. Then, we build a <code class="Code-In-Text--PACKT-">TopLevel</code> widget to hold our <code class="Code-In-Text--PACKT-">LineChartView</code> object. On this widget, we add the <code class="Code-In-Text--PACKT-">LineChartView</code> object, configuring it to be <code class="Code-In-Text--PACKT-">800</code> by <code class="Code-In-Text--PACKT-">400</code> pixels and specifying the fields for <code class="Code-In-Text--PACKT-">X</code> (<code class="Code-In-Text--PACKT-">Day</code>), <code class="Code-In-Text--PACKT-">Y</code> (<code class="Code-In-Text--PACKT-">Avg Height (cm)</code>), and the <code class="Code-In-Text--PACKT-">plot_by_field</code> value (<code class="Code-In-Text--PACKT-">lab_id</code>). This chart gets packed into the <code class="Code-In-Text--PACKT-">Toplevel</code>.</p>
    <div><p class="Information-Box--PACKT-">The <code class="Code-In-Text--PACKT-">Toplevel</code> widget creates a new, blank window outside the root window. You should use it as a base for new windows that aren't simple dialogs or message boxes.</p>
    </div>
    <p class="normal">With this method complete, add it to the <code class="Code-In-Text--PACKT-">event_callbacks</code> dictionary in the <code class="Code-In-Text--PACKT-">Application</code> initializer:</p>
    <pre class="programlisting code"><code class="hljs-code"># application.py, inside Application.__init__()
    event_callbacks = {
      #...
      '&lt;&lt;ShowGrowthChart&gt;&gt;': self.show_growth_chart
     }
</code></pre>
    <p class="normal">Finally, we need to add a menu item to launch the chart. Add the following method to the <code class="Code-In-Text--PACKT-">GenericMainMenu</code> class:</p>
    <pre class="programlisting code"><code class="hljs-code">  def _add_growth_chart(self, menu):
    menu.add_command(
      label='Show Growth Chart',
      command=self._event('&lt;&lt;ShowGrowthChart&gt;&gt;')
    )
</code></pre>
    <p class="normal">Then use this method<a id="_idIndexMarker1536"/> in each menu class's <code class="Code-In-Text--PACKT-">_build_menu()</code> method to add this option to the <strong class="screenText">Tools</strong> menu. For example:</p>
    <pre class="programlisting code"><code class="hljs-code"># mainmenu.py, in any class's _build_menu() method
    self._add_growth_chart(self._menus['Tools'])
</code></pre>
    <p class="normal">When you call your function, you should see something like this:</p>
    <figure class="mediaobject"><img src="img/B17578_15_04.png" alt="The growth chart on Ubuntu Linux"/></figure>
    <p class="packt_figref">Figure 15.4: The growth chart on Ubuntu Linux</p>
    <div><p class="Tip--PACKT-">Your graph won't look like much without some sample data. Unless you just like doing data entry, there is a script for loading sample data in the <code class="Code-In-Text--PACKT-">sql</code> directory. Run this script against your database before testing your chart. </p>
    </div>
    <h1 id="_idParaDest-433" class="title">Advanced graphs using Matplotlib</h1>
    <p class="normal">Our line graph is pretty, but it still<a id="_idIndexMarker1537"/> needs considerable work to be a truly professional-looking visualization: it lacks a scale, grid lines, zoom capabilities, and other features<a id="_idIndexMarker1538"/> that would make it a completely useful chart.</p>
    <p class="normal">We could spend a lot of time making it more complete, but there's a faster way to get much more satisfactory graphs and charts in our Tkinter application: Matplotlib.</p>
    <p class="normal">Matplotlib is a third-party Python library for generating professional-quality, interactive graphs of all types. It's a vast library with many add-ons, and we won't cover much of its actual usage, but we will look at how to integrate Matplotlib charts into a Tkinter application. To demonstrate this, we'll create a bubble chart showing the yield of each plot as it relates to humidity and temperature.</p>
    <p class="normal">You should be able to install the <code class="Code-In-Text--PACKT-">matplotlib</code> library using <code class="Code-In-Text--PACKT-">pip</code> with this command:</p>
    <pre class="programlisting con"><code class="hljs-con">$ pip install --user matplotlib
</code></pre>
    <p class="normal">For complete<a id="_idIndexMarker1539"/> instructions on installation, please see <a href="https://matplotlib.org/users/installing.html">https://matplotlib.org/users/installing.html</a>.</p>
    <h2 id="_idParaDest-434" class="title">Data model method</h2>
    <p class="normal">Before we can make a chart, we'll need another <code class="Code-In-Text--PACKT-">SQLModel</code> method to extract the data for the chart. Once again, you've<a id="_idIndexMarker1540"/> been provided with a SQL query that returns the<a id="_idIndexMarker1541"/> required data:</p>
    <pre class="programlisting code"><code class="hljs-code">SELECT
  seed_sample,
  MAX(fruit) AS yield,
  AVG(humidity) AS avg_humidity,
  AVG(temperature) AS avg_temperature
FROM plot_checks
WHERE NOT equipment_fault
GROUP BY lab_id, plot, seed_sample
</code></pre>
    <p class="normal">The purpose of this chart is to find the sweet spot of temperature and humidity for each seed sample. Therefore, we need one row per plot that includes the maximum fruit measurement, average humidity and temperature at the plot column, and the seed sample. Since we don't want any bad data, we'll filter out rows that have an Equipment Fault.</p>
    <p class="normal">The query returns data that looks something like this:</p>
    <table id="table006-4" class="No-Table-Style">
      <colgroup>
        <col/>
        <col/>
        <col/>
        <col/>
      </colgroup>
      <tbody>
        <tr class="No-Table-Style">
          <td class="No-Table-Style">
            <p class="Table-Column-Heading--PACKT-">seed_sample</p>
          </td>
          <td class="No-Table-Style">
            <p class="Table-Column-Heading--PACKT-">yield</p>
          </td>
          <td class="No-Table-Style">
            <p class="Table-Column-Heading--PACKT-">avg_humidity</p>
          </td>
          <td class="No-Table-Style">
            <p class="Table-Column-Heading--PACKT-">avg_temperature</p>
          </td>
        </tr>
        <tr class="No-Table-Style">
          <td class="No-Table-Style">
            <p class="Table-Column-Content--PACKT-">AXM480</p>
          </td>
          <td class="No-Table-Style">
            <p class="Table-Column-Content--PACKT-">11</p>
          </td>
          <td class="No-Table-Style">
            <p class="Table-Column-Content--PACKT-">27.7582142857142857</p>
          </td>
          <td class="No-Table-Style">
            <p class="Table-Column-Content--PACKT-">23.7485714285714286</p>
          </td>
        </tr>
        <tr class="No-Table-Style">
          <td class="No-Table-Style">
            <p class="Table-Column-Content--PACKT-">AXM480</p>
          </td>
          <td class="No-Table-Style">
            <p class="Table-Column-Content--PACKT-">20</p>
          </td>
          <td class="No-Table-Style">
            <p class="Table-Column-Content--PACKT-">27.2146428571428571</p>
          </td>
          <td class="No-Table-Style">
            <p class="Table-Column-Content--PACKT-">23.8032142857142857</p>
          </td>
        </tr>
        <tr class="No-Table-Style">
          <td class="No-Table-Style">
            <p class="Table-Column-Content--PACKT-">AXM480</p>
          </td>
          <td class="No-Table-Style">
            <p class="Table-Column-Content--PACKT-">15</p>
          </td>
          <td class="No-Table-Style">
            <p class="Table-Column-Content--PACKT-">26.2896428571428571</p>
          </td>
          <td class="No-Table-Style">
            <p class="Table-Column-Content--PACKT-">23.6750000000000000</p>
          </td>
        </tr>
        <tr class="No-Table-Style">
          <td class="No-Table-Style">
            <p class="Table-Column-Content--PACKT-">AXM478</p>
          </td>
          <td class="No-Table-Style">
            <p class="Table-Column-Content--PACKT-">31</p>
          </td>
          <td class="No-Table-Style">
            <p class="Table-Column-Content--PACKT-">27.2928571428571429</p>
          </td>
          <td class="No-Table-Style">
            <p class="Table-Column-Content--PACKT-">23.8317857142857143</p>
          </td>
        </tr>
        <tr class="No-Table-Style">
          <td class="No-Table-Style">
            <p class="Table-Column-Content--PACKT-">AXM477</p>
          </td>
          <td class="No-Table-Style">
            <p class="Table-Column-Content--PACKT-">39</p>
          </td>
          <td class="No-Table-Style">
            <p class="Table-Column-Content--PACKT-">27.1003571428571429</p>
          </td>
          <td class="No-Table-Style">
            <p class="Table-Column-Content--PACKT-">23.7360714285714286</p>
          </td>
        </tr>
        <tr class="No-Table-Style">
          <td class="No-Table-Style">
            <p class="Table-Column-Content--PACKT-">AXM478</p>
          </td>
          <td class="No-Table-Style">
            <p class="Table-Column-Content--PACKT-">39</p>
          </td>
          <td class="No-Table-Style">
            <p class="Table-Column-Content--PACKT-">26.8550000000000000</p>
          </td>
          <td class="No-Table-Style">
            <p class="Table-Column-Content--PACKT-">23.7632142857142857</p>
          </td>
        </tr>
      </tbody>
    </table>
    <p class="normal">To provide this data<a id="_idIndexMarker1542"/> to the application, let's put the query into another model<a id="_idIndexMarker1543"/> method called <code class="Code-In-Text--PACKT-">get_yield_by_plot()</code>:</p>
    <pre class="programlisting code"><code class="hljs-code"># models.py, in SQLModel
  def get_yield_by_plot(self):
    query = (
      'SELECT seed_sample, MAX(fruit) AS yield, '
      'AVG(humidity) AS avg_humidity, '
      'AVG(temperature) AS avg_temperature '
      'FROM plot_checks WHERE NOT equipment_fault '
      'GROUP BY lab_id, plot, seed_sample'
    )
    return self.query(query)
</code></pre>
    <p class="normal">That's all the model needs, so let's move on to the views.</p>
    <h2 id="_idParaDest-435" class="title">Creating the bubble chart view</h2>
    <p class="normal">To integrate Matplotlib into a Tkinter<a id="_idIndexMarker1544"/> application, there are several module<a id="_idIndexMarker1545"/> imports we need to make into <code class="Code-In-Text--PACKT-">views.py</code>.</p>
    <p class="normal">The first is <code class="Code-In-Text--PACKT-">matplotlib</code> itself:</p>
    <pre class="programlisting code"><code class="hljs-code">import matplotlib
matplotlib.use('TkAgg')
</code></pre>
    <p class="normal">It may seem odd to execute methods in the import section of a script, and your code editor or IDE may even complain about it. According to Matplotlib's documentation, though, <code class="Code-In-Text--PACKT-">use()</code> should be called before other modules are imported from <code class="Code-In-Text--PACKT-">matplotlib</code> to tell it which rendering backend it should use. In this case, we want the <code class="Code-In-Text--PACKT-">TkAgg</code> backend, which is made to integrate into Tkinter.</p>
    <div><p class="Information-Box--PACKT-">Matplotlib has backends<a id="_idIndexMarker1546"/> for a variety of GUI toolkits such as PyQt, wxWidgets, and Gtk3, as well as backends for non-GUI situations (for example, rendering plots directly to a file) like SVG rendering or web usage. See the documentation at <a href="https://matplotlib.org/stable/api/index_backend_api.html">https://matplotlib.org/stable/api/index_backend_api.html</a> for more details.</p>
    </div>
    <p class="normal">Now that we've set the<a id="_idIndexMarker1547"/> backend, we can import a few other items from <code class="Code-In-Text--PACKT-">matplotlib</code>:</p>
    <pre class="programlisting code"><code class="hljs-code">from matplotlib.figure import Figure
from matplotlib.backends.backend_tkagg import (
  FigureCanvasTkAgg,
  NavigationToolbar2Tk
)
</code></pre>
    <p class="normal">The <code class="Code-In-Text--PACKT-">Figure</code> class represents <a id="_idIndexMarker1548"/>the basic drawing area on which <code class="Code-In-Text--PACKT-">matplotlib</code> charts can be drawn. The <code class="Code-In-Text--PACKT-">FigureCanvasTkAgg</code> class is an interface between the <code class="Code-In-Text--PACKT-">Figure</code> and the Tkinter <code class="Code-In-Text--PACKT-">Canvas</code>, and <code class="Code-In-Text--PACKT-">NavigationToolbar2Tk</code> allows us to place a pre-made navigation toolbar for the <code class="Code-In-Text--PACKT-">Figure</code> object on our GUI.</p>
    <p class="normal">To see how these fit together, let's start our <code class="Code-In-Text--PACKT-">YieldChartView</code> class in <code class="Code-In-Text--PACKT-">views.py</code>:</p>
    <pre class="programlisting code"><code class="hljs-code"># views.py
class YieldChartView(tk.Frame):
  def __init__(self, parent, x_axis, y_axis, title):
    super().__init__(parent)
    self.figure = Figure(figsize=(6, 4), dpi=100)
    self.canvas_tkagg = FigureCanvasTkAgg(self.figure, master=self)
</code></pre>
    <p class="normal">After calling the superclass initializer to create the <code class="Code-In-Text--PACKT-">Frame</code> object, we create a <code class="Code-In-Text--PACKT-">Figure</code> object to hold our chart. Instead of a size in pixels, the <code class="Code-In-Text--PACKT-">Figure</code> object takes a size in inches and a dots-per-inch (<code class="Code-In-Text--PACKT-">dpi</code>) setting. In this case, our arguments of 6 by 4 inches and 100 dots per inch result in a 600-by-400-pixel <code class="Code-In-Text--PACKT-">Figure</code> object. Next, we create a <code class="Code-In-Text--PACKT-">FigureCanvasTkAgg</code> object that will be used to connect our <code class="Code-In-Text--PACKT-">Figure</code> object with a Tkinter <code class="Code-In-Text--PACKT-">Canvas</code>.</p>
    <p class="normal">The <code class="Code-In-Text--PACKT-">FigureCanvasTkAgg</code> object is not itself a <code class="Code-In-Text--PACKT-">Canvas</code> object or subclass, but it contains a <code class="Code-In-Text--PACKT-">Canvas</code> object we can place in our application. A reference to this <code class="Code-In-Text--PACKT-">Canvas</code> object can be retrieved using the <code class="Code-In-Text--PACKT-">FigureCanvasTkAgg</code> object's <code class="Code-In-Text--PACKT-">get_tk_widget()</code> method. We'll go ahead and get a reference to the <code class="Code-In-Text--PACKT-">Canvas</code> and pack it into the <code class="Code-In-Text--PACKT-">YieldChartView</code> widget:</p>
    <pre class="programlisting code"><code class="hljs-code">    canvas = self.canvas_tkagg.get_tk_widget()
    canvas.pack(fill='both', expand=True)
</code></pre>
    <p class="normal">Next, we'll add the toolbar and attach it to our <code class="Code-In-Text--PACKT-">FigureCanvasTkAgg</code> object:</p>
    <pre class="programlisting code"><code class="hljs-code">    self.toolbar = NavigationToolbar2Tk(self.canvas_tkagg, self)
</code></pre>
    <p class="normal">Note that we don't need to use a geometry manager to add the toolbar; instead we just pass the <code class="Code-In-Text--PACKT-">FigureCanvasTkAgg</code> object<a id="_idIndexMarker1549"/> and the parent widget (<code class="Code-In-Text--PACKT-">self</code>, which is our <code class="Code-In-Text--PACKT-">YiedChartView</code> object in this case) to the toolbar's initializer, and this will attach<a id="_idIndexMarker1550"/> it to our <code class="Code-In-Text--PACKT-">Figure</code>.</p>
    <p class="normal">The next step is to set up the axes:</p>
    <pre class="programlisting code"><code class="hljs-code">    self.axes = self.figure.add_subplot(1, 1, 1)
    self.axes.set_xlabel(x_axis)
    self.axes.set_ylabel(y_axis)
    self.axes.set_title(title)
</code></pre>
    <p class="normal">In <code class="Code-In-Text--PACKT-">matplotlib</code>, an <code class="Code-In-Text--PACKT-">Axes</code> object represents a single set of <code class="Code-In-Text--PACKT-">X</code> and <code class="Code-In-Text--PACKT-">Y</code> axes on which data can be plotted, and is created using the <code class="Code-In-Text--PACKT-">Figure.add_subplot()</code> method. The three integers passed to <code class="Code-In-Text--PACKT-">add_subplot()</code> establish that this is the first set of axes out of one row of one column of subplots. Our figure could conceivably contain multiple subplots arranged in a table-like format, but we only need one, thus we're passing all 1s here. After it's created, we set the labels on the <code class="Code-In-Text--PACKT-">Axes</code> object.</p>
    <p class="normal">To create a bubble chart, we're going<a id="_idIndexMarker1551"/> to use the <strong class="keyword">scatter plot</strong> feature of Matplotlib, using the size of each dot to indicate the fruit yield. We'll also color code the dots to indicate which seed sample the data point represents.</p>
    <p class="normal">Let's implement a method to draw our scatter plots:</p>
    <pre class="programlisting code"><code class="hljs-code">  def draw_scatter(self, data, color, label):
    x, y, size = zip(*data)
    scaled_size = [(s ** 2)//2 for s in size]
    scatter = self.axes.scatter(
      x, y, scaled_size,
      c=color, label=label, alpha=0.5
    )
</code></pre>
    <p class="normal">The data passed in should contain three columns per record, and we're breaking those out into three separate lists containing the <code class="Code-In-Text--PACKT-">x</code>, <code class="Code-In-Text--PACKT-">y</code>, and <code class="Code-In-Text--PACKT-">size</code> values. Next, we're going to amplify the differences between the <code class="Code-In-Text--PACKT-">size</code> values to make them more apparent by squaring each value then dividing it by two. This isn't strictly necessary, but it helps make the chart more readable when differences are relatively small.</p>
    <p class="normal">Finally, we draw the data onto the <code class="Code-In-Text--PACKT-">axes</code> object by calling <code class="Code-In-Text--PACKT-">scatter()</code>, also passing along the color and label values<a id="_idIndexMarker1552"/> for the dots, and making them semi-transparent with the <code class="Code-In-Text--PACKT-">alpha</code> argument.</p>
    <div><p class="Tip--PACKT-"><code class="Code-In-Text--PACKT-">zip(*data)</code> is a Python idiom for breaking a list of n-length tuples into n lists of values, essentially the reverse of <code class="Code-In-Text--PACKT-">zip(x, y, s)</code>.</p>
    </div>
    <p class="normal">To draw a legend for our <code class="Code-In-Text--PACKT-">Axes</code> object, we need two things: a list of our scatter objects and a list of their labels. To get<a id="_idIndexMarker1553"/> these, we'll have to create a couple of blank lists in <code class="Code-In-Text--PACKT-">__init__()</code> and append the appropriate values to them whenever <code class="Code-In-Text--PACKT-">draw_scatter()</code> is called.</p>
    <p class="normal">In <code class="Code-In-Text--PACKT-">__init__()</code>, add some empty lists:</p>
    <pre class="programlisting code"><code class="hljs-code"># views.py, in YieldChartView.__init__()
    self.scatters = list()
    self.scatter_labels = list()
</code></pre>
    <p class="normal">Now, at the end of <code class="Code-In-Text--PACKT-">draw_scatter()</code>, append the lists and update the <code class="Code-In-Text--PACKT-">legend()</code> method:</p>
    <pre class="programlisting code"><code class="hljs-code"># views.py, in YieldChartView.draw_scatter()
    self.scatters.append(scatter)
    self.scatter_labels.append(label)
    self.axes.legend(self.scatters, self.scatter_labels)
</code></pre>
    <p class="normal">Note that we can call <code class="Code-In-Text--PACKT-">legend()</code> repeatedly and it will simply destroy and redraw the legend each time.</p>
    <h2 id="_idParaDest-436" class="title">Updating the Application class</h2>
    <p class="normal">Back in <code class="Code-In-Text--PACKT-">Application</code>, let's create<a id="_idIndexMarker1554"/> the method to show our yield data chart. </p>
    <p class="normal">Start by creating a method to display a <code class="Code-In-Text--PACKT-">Toplevel</code> widget with our chart view:</p>
    <pre class="programlisting code"><code class="hljs-code"># application.py, inside Application
  def show_yield_chart(self, *_):
     popup = tk.Toplevel()
     chart = v.YieldChartView(
        popup,
       'Average plot humidity', 'Average plot temperature',
       'Yield as a product of humidity and temperature'
     )
     chart.pack(fill='both', expand=True)
</code></pre>
    <p class="normal">Now let's set up the data for our scatters:</p>
    <pre class="programlisting code"><code class="hljs-code">    data = self.data_model.get_yield_by_plot()
    seed_colors = {
      'AXM477': 'red', 'AXM478': 'yellow',
      'AXM479': 'green', 'AXM480': 'blue'
    }
</code></pre>
    <p class="normal">We've retrieved the yield data<a id="_idIndexMarker1555"/> from the data model and created a dictionary that will hold the colors we want to use for each seed sample. Now we just need to iterate through the seed samples and draw the scatters:</p>
    <pre class="programlisting code"><code class="hljs-code">    for seed, color in seed_colors.items():
      seed_data = [
        (x['avg_humidity'], x['avg_temperature'], x['yield'])
        for x in data if x['seed_sample'] == seed
      ]
      chart.draw_scatter(seed_data, color, seed)
</code></pre>
    <p class="normal">Once again, we're formatting and filtering down our data using a list comprehension, providing average humidity for <code class="Code-In-Text--PACKT-">x</code>, average temperature for <code class="Code-In-Text--PACKT-">y</code>, and yield for <code class="Code-In-Text--PACKT-">s</code>.</p>
    <p class="normal">Add the method to the callbacks dictionary and create a menu item for it just under the growth chart option.</p>
    <p class="normal">Your bubble chart should look something like this:</p>
    <figure class="mediaobject"><img src="img/B17578_15_05.png" alt=""/></figure>
    <p class="packt_figref">Figure 15.5: Our scatter plot showing how seed samples performed under different conditions</p>
    <p class="normal">Take a moment to play with this chart using the navigation toolbar. Notice how you can zoom and pan, adjust the<a id="_idIndexMarker1556"/> size of the chart, and save the image. These powerful tools are provided by Matplotlib automatically, and make for very professional-looking charts.</p>
    <p class="normal">This wraps up our charting needs for the time being, but as you've seen it's quite simple to integrate Matplotlib's powerful charts and graphs into our application. And, of course, with enough effort, the sky is the limit with generating visualizations using the <code class="Code-In-Text--PACKT-">Canvas</code> widget.</p>
    <h1 id="_idParaDest-437" class="title">Summary</h1>
    <p class="normal">In this chapter, you learned about Tkinter's graphical capabilities. You learned about the <code class="Code-In-Text--PACKT-">Canvas</code> widget, and how to draw shapes, lines, images, text, and widgets on it. You implemented animations on the <code class="Code-In-Text--PACKT-">Canvas</code> by queuing item movements in the Tkinter event queue. You implemented a simple line chart class using a plain <code class="Code-In-Text--PACKT-">Canvas</code> to provide basic data visualization for SQL query results. Finally, you learned how to integrate the powerful Matplotlib library with its wide variety of charts and graphs into your application.</p>
    <p class="normal">In the next chapter, we'll learn how to package up our application for distribution. We'll learn how to arrange the directory for distribution as Python code, and how to use third-party tools to create executables across Windows, macOS, and Linux.</p>
  </div>
</body></html>