["```py\nclass testable:\n    def method1(self, number):\n        number += 4\n        number **= 0.5\n        number *= 7\n        return number\n\n    def method2(self, number):\n        return ((number * 2) ** 1.27) * 0.3\n\n    def method3(self, number):\n        return self.method1(number) + self.method2(number)\n\n    def method4(self):\n        return 1.713 * self.method3(id(self))\n```", "```py\nclass class_one:\n    def __init__(self, arg1, arg2):\n        self.arg1 = int(arg1)\n        self.arg2 = arg2\n\n    def method1(self, x):\n        return x * self.arg1\n\n    def method2(self, x):\n        return self.method1(self.arg2) * x\n```", "```py\nWe want a class that implements a PID controller for a single variable. The measurement, setpoint, and output should all be real numbers.\n\nWe need to be able to adjust the setpoint at runtime, but we want it to have a memory, so that we can easily return to the previous setpoint.\n\n```", "```py\n    >>> import pid\n\n    >>> controller = pid.PID(P=0.5, I=0.5, D=0.5, setpoint=0)\n\n    >>> controller.gains\n    (0.5, 0.5, 0.5)\n    >>> controller.setpoint\n    [0.0]\n    >>> controller.previous_time is None\n    True\n    >>> controller.previous_error\n    0.0\n    >>> controller.integrated_error\n    0.0\n    ```", "```py\n    >>> import time\n    >>> real_time = time.time\n    >>> time.time = (float(x) for x in xrange(1, 1000)).next\n    >>> pid = reload(pid)\n    >>> controller = pid.PID(P=0.5, I=0.5, D=0.5, setpoint=0)\n    >>> controller.measure(12)\n    -6.0\n    >>> controller.measure(6)\n    -3.0\n    >>> controller.measure(3)\n    -4.5\n    >>> controller.measure(-1.5)\n    -0.75\n    >>> controller.measure(-2.25)\n    -1.125\n    >>> time.time = real_time\n    ```", "```py\n    >>> pid = reload(pid)\n    >>> controller = pid.PID(P = 0.5, I = 0.5, D = 0.5, setpoint = 0)\n\n    >>> controller.push_setpoint(7)\n    >>> controller.setpoint\n    [0.0, 7.0]\n\n    >>> controller.push_setpoint(8.5)\n    >>> controller.setpoint\n    [0.0, 7.0, 8.5]\n\n    >>> controller.pop_setpoint()\n    8.5\n    >>> controller.setpoint\n    [0.0, 7.0]\n\n    >>> controller.pop_setpoint()\n    7.0\n    >>> controller.setpoint\n    [0.0]\n\n    >>> controller.pop_setpoint()\n    Traceback (most recent call last):\n    ValueError: PID controller must have a setpoint\n\n    ```", "```py\n    from time import time\n\n    class PID:\n        def __init__(self, P, I, D, setpoint):\n            self.gains = (float(P), float(I), float(D))\n            self.setpoint = [float(setpoint)]\n            self.previous_time = None\n            self.previous_error = 0.0\n            self.integrated_error = 0.0\n\n        def push_setpoint(self, target):\n            self.setpoint.append(float(target))\n\n        def pop_setpoint(self):\n            if len(self.setpoint) > 1:\n                return self.setpoint.pop()\n            raise ValueError('PID controller must have a setpoint')\n\n        def measure(self, value):\n            now = time()\n            P, I, D = self.gains\n\n            err = value - self.setpoint[-1]\n\n            result = P * err\n            if self.previous_time is not None:\n                delta = now - self.previous_time\n                self.integrated_error +q= err * delta\n                result += I * self.integrated_error\n                result += D * (err - self.previous_error) / delta\n\n            self.previous_error = err\n            self.previous_time = now\n\n            return result\n    ```", "```py\n            err = self.setpoint[-1] â€“ value\n    ```", "```py\n    We want a class that implements a PID controller for a single variable. The measurement, setpoint, and output should all be real numbers. The constructor should accept an initial measurement value in addition to the gains and setpoint.\n\n    >>> import time\n    >>> real_time = time.time\n    >>> time.time = (float(x) for x in xrange(1, 1000)).next\n    >>> import pid\n    >>> controller = pid.PID(P=0.5, I=0.5, D=0.5, setpoint=0,\n    ...                      initial=12)\n    >>> controller.gains\n    (0.5, 0.5, 0.5)\n    >>> controller.setpoint\n    [0.0]\n    >>> controller.previous_time\n    1.0\n    >>> controller.previous_error\n    -12.0\n    >>> controller.integrated_error\n    0.0\n    >>> time.time = real_time\n\n    The constructor should also optionally accept a parameter specifying when the initial measurement was taken.\n\n    >>> pid = reload(pid)\n    >>> controller = pid.PID(P=0.5, I=0.5, D=0.5, setpoint=1,\n    ...                      initial=12, when=43)\n    >>> controller.gains\n    (0.5, 0.5, 0.5)\n    >>> controller.setpoint\n    [1.0]\n    >>> controller.previous_time\n    43.0\n    >>> controller.previous_error\n    -11.0\n    >>> controller.integrated_error\n    0.0\n\n    >>> real_time = time.time\n    >>> time.time = (float(x) for x in xrange(1, 1000)).next\n    >>> pid = reload(pid)\n    >>> controller = pid.PID(P=0.5, I=0.5, D=0.5, setpoint=0,\n    ...                      initial=12)\n    >>> controller.calculate_response(6)\n    -3.0\n    >>> controller.calculate_response(3)\n    -4.5\n    >>> controller.calculate_response(-1.5)\n    -0.75\n    >>> controller.calculate_response(-2.25)\n    -1.125\n    >>> time.time = real_time\n\n    The calculate_response method should be willing to accept a parameter specifying at what time the call is happening.\n\n    >>> pid = reload(pid)\n    >>> controller = pid.PID(P=0.5, I=0.5, D=0.5, setpoint=0,\n    ...                      initial=12, when=1)\n    >>> controller.calculate_response(6, 2)\n    -3.0\n    >>> controller.calculate_response(3, 3)\n    -4.5\n    >>> controller.calculate_response(-1.5, 4)\n    -0.75\n    >>> controller.calculate_response(-2.25, 5)\n    -1.125\n\n    We need to be able to adjust the setpoint at runtime, but we want it to have a memory, so that we can easily return to the previous setpoint.\n\n    >>> pid = reload(pid)\n    >>> controller = pid.PID(P=0.5, I=0.5, D=0.5, setpoint=0,\n    ...                      initial=12)\n    >>> controller.push_setpoint(7)\n    >>> controller.setpoint\n    [0.0, 7.0]\n    >>> controller.push_setpoint(8.5)\n    >>> controller.setpoint\n    [0.0, 7.0, 8.5]\n    >>> controller.pop_setpoint()\n    8.5\n    >>> controller.setpoint\n    [0.0, 7.0]\n    >>> controller.pop_setpoint()\n    7.0\n    >>> controller.setpoint\n    [0.0]\n    >>> controller.pop_setpoint()\n    Traceback (most recent call last):\n    ValueError: PID controller must have a setpoint\n\n    ```", "```py\n    from time import time\n\n    class PID:\n        def __init__(self, P, I, D, setpoint, initial, when=None):\n            self.gains = (float(P), float(I), float(D))\n            self.setpoint = [float(setpoint)]\n\n            if when is None:\n                self.previous_time = time()\n            else:\n                self.previous_time = float(when)\n\n            self.previous_error = self.setpoint[-1] - float(initial)\n            self.integrated_error = 0.0\n\n        def calculate_response(self, value, now=None):\n            if now is None:\n                now = time()\n            else:\n                now = float(now)\n\n            P, I, D = self.gains\n            err = self.setpoint[-1] - value\n            result = P * err\n            delta = now - self.previous_time\n            self.integrated_error += err * delta\n            result += I * self.integrated_error\n            result += D * (err - self.previous_error) / delta\n\n            self.previous_error = err\n            self.previous_time = now\n\n            return result\n    ```", "```py\n    It's important that the P, I and D gains not be negative.\n\n    >>> pid = reload(pid)\n    >>> controller = pid.PID(P=-0.5, I=0.5, D=0.5, setpoint=0,\n    ...                      initial=12)\n    Traceback (most recent call last):\n    ValueError: PID controller gains must be non-negative\n\n    >>> pid = reload(pid)\n    >>> controller = pid.PID(P=0.5, I=-0.5, D=0.5, setpoint=0,\n    ...                      initial=12)\n    Traceback (most recent call last):\n    ValueError: PID controller gains must be non-negative\n\n    >>> pid = reload(pid)\n    >>> controller = pid.PID(P=0.5, I=0.5, D=-0.5, setpoint=0,\n    ...                      initial=12)\n    Traceback (most recent call last):\n    ValueError: PID controller gains must be non-negative\n    ```", "```py\n    if P < 0 or I < 0 or D < 0:\n      raise ValueError('PID controller gains must be non-negative')\n    ```", "```py\n    We want to be able to use complex numbers as the measurement and setpoint for the PID controller.\n\n    >>> pid = reload(pid)\n    >>> controller = pid.PID(P=0.5, I=0.5, D=0.5,\n    ...      setpoint = 1 + 1j,\n    ...      initial = 9.4852813742385695+9.4852813742385695j,\n    ...      when = 1)\n    >>> controller.calculate_response(5.2426406871192848+5.2426406871192848j, 2)\n    (-2.1213203435596424-2.1213203435596424j)\n\n    >>> controller.calculate_response(3.1213203435596424+3.1213203435596424j, 3)\n    (-3.1819805153394638-3.1819805153394638j)\n\n    >>> controller.calculate_response(-0.060660171779821193-0.060660171779821193j, 4)\n    (-0.53033008588991093-0.53033008588991093j)\n\n    >>> controller.calculate_response(-0.5909902576697319-0.5909902576697319j, 5)\n    (-0.79549512883486606-0.79549512883486606j)\n    ```", "```py\n    def __init__(self, P, I, D, setpoint, initial, when=None):\n        self.gains = (float(P), float(I), float(D))\n\n        if P < 0 or I < 0 or D < 0:\n            raise ValueError('PID controller gains must be non-negative')\n\n        if not isinstance(setpoint, complex):\n            setpoint = float(setpoint)\n\n        if not isinstance(initial, complex):\n            initial = float(initial)\n\n        self.setpoint = [setpoint]\n\n        if when is None:\n            self.previous_time = time()\n        else:\n            self.previous_time = float(when)\n\n        self.previous_error = self.setpoint[-1] - initial\n        self.integrated_error = 0.0\n    ```", "```py\nThe library consists of three classes, one representing bank accounts, one representing people, and one representing monetary transactions. Person objects should be able to draw on zero or more accounts, and account objects should be accessible to one or more people. Transactions should represent the transfer of a certain amount of money between one person and another, by transferring the money from an account accessible by the first person to an account accessible by the second.\nAttempts to create invalid transactions should fail.\nAfter having been created, it should be possible to execute a transaction to perform the actual transfer between accounts.\nAll monies should be represented as fixed point numbers, not floating point.\n```"]