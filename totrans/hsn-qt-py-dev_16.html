<html><head></head><body>
        <section>

                            <header>
                    <h1 class="header-title">Implementing Databases</h1>
                </header>
            
            <article>
                
<p class="mce-root">All applications operate with data; this is the essence of any process in the world of technology. Reusable data storage provides great opportunities for operations, because if data stored from an application's previous operations is not used, an app will restart its processes each time it runs. In relation to the Qt app that we have been building in this book, on startup, the application will be empty and will not display any earlier information. In a sense, it is a pure real-time application, which can be used with web operations such as scraping, or for simple communication and monitoring. There is always a need to save something for use again later, however. The examples that were implemented in <a href="427e029e-38a6-4167-b146-402bd66ff25e.xhtml">Chapter 13</a>, <em>Creating Layouts</em>, are very primitive and don't allow us to reuse data in a more convenient way. This chapter will therefore introduce more convenient ways of reusing data.</p>
<p class="mce-root">In this chapter, we'll look at various instruments for working with various types of data storage, such as files, SQL, and NoSQL. These instruments will <span>mostly </span>be third-party packages, but whenever possible, Qt library based modules and classes will also be provided. This chapter does not cover the SQL language, as it is an implementation of the databases in the application.</p>
<p class="mce-root">This chapter will cover the following topics:</p>
<ul>
<li>Storage with files</li>
<li>CSV</li>
<li>SQL</li>
<li>NoSQL</li>
</ul>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Storage with files</h1>
                </header>
            
            <article>
                
<p>In <a href="427e029e-38a6-4167-b146-402bd66ff25e.xhtml">Chapter 13</a>, <em>Creating Layouts</em>, we demonstrated how to save data to a text file and later reuse it in an ordinary task, such as saving color settings for an application. The Python standard library has some other tools for saving various information. Saving text files and retrieving strings from these files is a simple, but limited way, of doing this. In some cases, it's preferable to save objects and retrieve them for specific tasks. The Python standard library includes modules <span>such as <kbd>pickle</kbd> and <kbd>shelve</kbd></span> that can help with the serialization and de-serialization of objects, and how to write and read them. With Python and the bindings of the Qt library, these modules can easily <span>be </span>implemented in our application. We will talk about this in the following section.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">The pickle module</h1>
                </header>
            
            <article>
                
<p>The <kbd>pickle</kbd> module of the Python standard library has binary protocols for serializing and de-serializing Python objects. This tool can save objects in a file that can be retrieved for various tasks in an application. Python objects that can be saved include lists, tuples, dictionaries, and more. Any Python objects can be saved to a file, but saving dictionaries, for example, allows us to use a data structure that has keys and values. Note that only pickleable objects of dicts, lists, tuples, and so on can be pickled. So, let's add the <kbd>pickle</kbd> module functionality to our application with the following steps:</p>
<ol>
<li>Create a <kbd>data/</kbd> folder in the <kbd>App/App_PySide2/</kbd> and <kbd>App/App_PyQt5/</kbd> directories. We need to add the following lines to the <kbd>u_tools.py</kbd> file, which will represent various methods for working with  data in the application. To use the <kbd>pickle</kbd> module in our application, we need to add a line with an import statement.<br/>
<br/>
In the <kbd>import</kbd> section of the <kbd>u_tools.py</kbd> <span>file, add the following statement:</span></li>
</ol>
<pre style="padding-left: 60px">...<br/>import pickle<br/>...</pre>
<p style="padding-left: 60px">This module includes the <kbd>dump()</kbd> and <kbd>load()</kbd> functions to serialize or de-serialize Python objects. These functions write the object to a file object and then load the object from a file.</p>
<ol start="2">
<li>Add the <kbd>pickle_dump()</kbd> function, which <span>will serialize objects, </span>to the <kbd>UTools</kbd> class of the <kbd>u_tools.py</kbd> file with the following code:</li>
</ol>
<pre style="padding-left: 60px">...<br/>class UTools(object):<br/><br/>    def __init__(self):<br/>        ...<br/><br/>    def pickle_dump(self, obj=None, filename=None,<br/>                      proto=1, fimps=None):<br/>        fobj = open(filename, 'wb')<br/>        if fimps is not None:<br/>            pickle.dump(obj, fobj, proto, fimps)<br/>        else:<br/>            pickle.dump(obj, fobj)<br/>        fobj.close()<br/>...</pre>
<p style="padding-left: 60px">This function will open the file in binary mode to write and dump the object, and will include parameters in relation to the relevant version of Python.</p>
<ol start="3">
<li>Now we need to add the <kbd>pickle_load()</kbd> function, which will de-serialize the object, to the <kbd>UTools</kbd> class, as follows:</li>
</ol>
<pre style="padding-left: 60px">...<br/>    ...<br/>    def pickle_load(self, filename=None, fimps=None,<br/>                        enc="ASCII", err="strict"):<br/>        fobj = open(filename, 'rb')<br/>        if fimps is not None:<br/>            pl = pickle.load(fobj, fimps, encoding=enc,<br/>                                             errors=err)<br/>        else:<br/>            pl = pickle.load(fobj)<br/>        fobj.close()<br/>        return pl<br/>...</pre>
<p style="padding-left: 60px">This function will open the file in binary mode for reading and will load the object from a file, with parameters related to the version of Python you are using. We now need to make some changes in the application files for easier opening and data-saving operations. Open the <kbd>u_window.py</kbd> file and add some lines to the top panel.</p>
<ol start="4">
<li>Add the following new selection options in the data section of the top panel:</li>
</ol>
<pre style="padding-left: 60px">...<br/>class UWindow(UWin):<br/><br/>    def __init__(self, parent=None):<br/>        ...<br/>        self.mb3 = UMenu(self.menubar)<br/>        self.mb3.addAction("Pickle")<br/>        self.mb3.addAction("Shelve")<br/>        self.mb3.addAction("CSV")<br/>        self.mb3.addAction("Pandas")<br/>        self.mb3.addAction("SQLite")<br/>        self.mb3.addAction("PostgreSQL")<br/>        self.mb3.addAction("MySQL")<br/>        self.mb3.addAction("MongoDB")<br/>        self.mb3.addAction("CouchDB")<br/>        self.mb3.setTitle("&amp;Data")<br/>        ...<br/>        self.mb4.setTitle("&amp;Options")<br/>        ...<br/>        self.mb5.setTitle("&amp;Help")<br/>        ...<br/>        self.menubar.addMenu(self.mb5)<br/>...</pre>
<p class="mce-root" style="padding-left: 60px">These additional selection options will be used later on in this chapter. We now need to change the <kbd>UApp</kbd> class of the <kbd>u_app.py</kbd> file to be able to use the dump and load operations.</p>
<ol start="5">
<li>Now, insert the <kbd>Save</kbd> button in the <kbd>__init__()</kbd> function of the <kbd>UApp</kbd> class with a connection to the slots that will be used to save the data, as follows:</li>
</ol>
<pre style="padding-left: 60px">...<br/>class UApp(UWindow, UTools):<br/><br/>    def __init__(self, parent=None):<br/>        ...<br/>        self.push_but1 = UBut1(self.frame2)<br/>        self.push_but1.setText("Save")<br/>        self.push_but2 = UBut1(self.frame2)<br/>        self.push_but2.setText("Ok")<br/>        ...<br/>        self.layfr2_1 = QtWidgets.QGridLayout()<br/>        self.layfr2_1.addWidget(self.push_but1, 0, 0, 1, 1)<br/>        self.layfr2_1.addWidget(self.push_but2, 0, 1, 1, 1)<br/>        ...<br/>        self.mb1.triggered.connect(self.files)<br/>        self.mb3.triggered.connect(self.data)<br/>        self.mb4.triggered.connect(self.options)<br/>        self.push_but1.clicked.connect(self.save_data)<br/>        # self.push_but2.clicked.connect()<br/>        ...<br/>        self.actx = ""<br/>    ...<br/>...</pre>
<p class="mce-root" style="padding-left: 60px">At the bottom of the <kbd>__init__()</kbd> function, we've added a variable with an empty string that will be used to save data if the tool has not been opened before.</p>
<ol start="6">
<li>Now add the <kbd>data()</kbd> function, which will be used to <span>load the pickled objects,</span> to the <kbd>UApp</kbd> class, as follows:</li>
</ol>
<pre style="padding-left: 60px">...<br/>    ...<br/>    def data(self, action):<br/>        self.text_edit.clear()<br/>        self.actx = action.text()<br/>        if self.actx == "Pickle":<br/>            try:<br/>                txtdata = self.pickle_load(<br/>                                    filename=r"data/u_data.py") <br/>                self.text_edit.append(str(txtdata))<br/>                self.stat_bar.showMessage(self.actx + " opened")<br/>            except Exception as err:<br/>                self.stat_bar.showMessage(<br/>                                     self.actx + ' ' + str(err))<br/>    ...<br/>...</pre>
<p style="padding-left: 60px">The instruction of this function will use the function to load data from a file, or it will set an error to the status bar of the application. The loaded data will be appended to the <kbd>text edit</kbd> field.</p>
<ol start="7">
<li>Now add the following <kbd>save_data()</kbd> function:</li>
</ol>
<pre style="padding-left: 60px">...<br/>    ...<br/>    def save_data(self):<br/>        self.error = ''<br/>        uname = self.line_ed1.text()<br/>        umail = self.line_ed2.text()<br/>        upass = self.line_ed3.text()<br/>        udata = self.text_edit.toPlainText()<br/>        if (uname != '') and (umail != '') and (upass != ''):<br/>            if self.actx == "Pickle":<br/>                self.user_data1(uname, umail, upass, udata)<br/>            else:<br/>                self.user_data1(uname, umail, upass, udata)<br/>            if self.error != '':<br/>                self.stat_bar.showMessage(<br/>                         self.actx + ' ' + str(self.error))<br/>            else:<br/>                self.stat_bar.showMessage(<br/>                                      self.actx + " saved")<br/>    ...<br/>...</pre>
<p style="padding-left: 60px">This function will provide saving operations to files, databases, and so on. It will also check whether the used line edit fields are empty, as well as calling the <kbd>user_data1()</kbd> function.</p>
<ol start="8">
<li class="mce-root">Next, add the <kbd>user_data1()</kbd> function at the end of the <kbd>UApp</kbd> class, as follows:</li>
</ol>
<pre style="padding-left: 60px">...<br/>    ...<br/>    def user_data1(self, uname, umail, upass, udata):<br/>        try:<br/>            dictd = {"User Name": uname,<br/>                     "User email": umail,<br/>                     "User password": upass,<br/>                     "User data": udata}<br/>            self.pickle_dump(obj=dictd,<br/>                         filename=r"data/u_data.py")<br/>        except Exception as err:<br/>            self.error = err<br/>...</pre>
<p style="padding-left: 60px">This function will use the <kbd>pickle_dump()</kbd> function of the <kbd>UTools</kbd> class to save data to a file. Also <span>available </span>in the <kbd>pickle</kbd> module are the <kbd>dumps()</kbd> and <kbd>loads()</kbd> functions, which return a byte object instead of writing it to a file and read the objects, respectively. Classes such as <kbd>pickle.Pickler()</kbd> and <kbd>pickle.Unpickler()</kbd> can be used to pickle and unpickle data. The Python standard library's <kbd>pickletools</kbd> <span>module </span>extends the <kbd>pickle</kbd> module's functionality with additional functions that analyze pickled data. The <kbd>pickle</kbd> module is very useful for tasks such as data persistence in machine learning models and implementing them in an application.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">The shelve module</h1>
                </header>
            
            <article>
                
<p>The <kbd>shelve</kbd> module creates dictionary-like objects <span>using the </span><kbd>pickle</kbd><span> and </span><kbd>dbm</kbd><span> modules </span>that can be saved in a file and opened accordingly. So, let's add the <kbd>shelve_open()</kbd> function to the <kbd>UTools</kbd> class of the <kbd>u_tools.py</kbd> files:</p>
<ol>
<li>First, add the following module to the import section of the <kbd>u_tools.py</kbd> file:</li>
</ol>
<pre style="padding-left: 60px">...<br/>import shelve<br/>...</pre>
<ol start="2">
<li>Add the <kbd>shelve_open()</kbd> function to the <kbd>UTools</kbd> class of the <kbd>u_tools.py</kbd> file, as follows:</li>
</ol>
<pre style="padding-left: 60px">...<br/>class UTools(object):<br/><br/>    def __init__(self):<br/>        ...<br/>    def shelve_open(self, filename=None, flag='c',<br/>                    proto=None, writeback=False):<br/>        return shelve.open(filename, flag, proto, writeback)<br/>...</pre>
<p class="mce-root" style="padding-left: 60px">This function will write and read the data to and from a database. The parameters can be specified by using this function in the application. In the <kbd>UApp</kbd> class of the <kbd>u_app.py</kbd> file, we now need to add the <kbd>shelve</kbd> tool to open and save files.</p>
<p class="mce-root"/>
<ol start="3">
<li>Add <span>the <kbd>shelve</kbd> module functionality to </span>the <kbd>data()</kbd> function of the <kbd>UApp</kbd> class, as follows:</li>
</ol>
<pre style="padding-left: 60px">...<br/>    ...<br/>    def data(self, action):<br/>        ...<br/>        if self.actx == "Pickle":<br/>              ...<br/>        if self.actx == "Shelve":<br/>            try:<br/>                db = self.shelve_open(filename="data/u_data")<br/>                self.text_edit.append("%s\n%s\n%s\n%s" % (<br/>                        db.get("User Name"),<br/>                        db.get("User email"),<br/>                        db.get("User password"),<br/>                        db.get("User data")))<br/>                self.stat_bar.showMessage(<br/>                                       self.actx + " opened")<br/>            except Exception as err:<br/>                self.stat_bar.showMessage(<br/>                                  self.actx + ' ' + str(err))<br/>        ...<br/>    ...<br/>...</pre>
<p style="padding-left: 60px"><span>The </span><kbd>shelve_open()</kbd><span> function of the </span><kbd>UTools</kbd><span> class w</span>ill be used to connect to the database. The <kbd>get()</kbd> <span>method </span>will get the data from the specified field of the database.</p>
<ol start="4">
<li>Next, add the following option to the <kbd>save_data()</kbd> function:</li>
</ol>
<pre style="padding-left: 60px">...<br/>    ...<br/>    def save_data(self):<br/>        ...<br/>            if self.actx == "Pickle":<br/>                ...<br/>            elif self.actx == "Shelve":<br/>                self.user_data2(uname, umail, upass, udata)<br/>            ...<br/>        ...<br/>    ...<br/>...</pre>
<p style="padding-left: 60px">This instruction will call the <kbd>user_data2()</kbd> function with the data specified in its parameters.</p>
<p class="mce-root"/>
<ol start="5">
<li>Now add the <kbd>user_data2()</kbd> function to the end of the <kbd>UApp</kbd> class, as follows:</li>
</ol>
<pre style="padding-left: 60px">...<br/>    ...<br/>    def user_data2(self, uname, umail, upass, udata):<br/>        try:<br/>            db = self.shelve_open(filename="data/u_data")<br/>            db["User Name"] = uname<br/>            db["User email"] = umail<br/>            db["User password"] = upass<br/>            db["User data"] = udata<br/>            db.close()<br/>        except Exception as err:<br/>            self.error = err<br/>...</pre>
<p style="padding-left: 60px">This function will write the data to the database.</p>
<p>The object of the <kbd>shelve_open()</kbd> function provides methods that are similar to the following dictionary methods:</p>
<ul>
<li><kbd>db.keys()</kbd>: This returns all the keys of an object.</li>
<li><kbd>db.values()</kbd>: This returns all the values of an object.</li>
<li><kbd>db.items()</kbd>: This returns an iterable object with tuples, including key/value pairs.</li>
<li><kbd>db.get(key)</kbd>: This returns the value related to the key in a parameter.</li>
<li><kbd>db.update({key: value})</kbd>: This adds elements to a <span>database </span>object.</li>
</ul>
<p>The following <span>flags are also </span>available:</p>
<ul>
<li><kbd>r</kbd>: Reading.</li>
<li><strong><kbd>w</kbd></strong>: Reading and writing.</li>
<li><strong><kbd>c</kbd></strong>: Reading and writing; if the file does not exist, it will be created (this is the default flag).</li>
<li><kbd>n</kbd>: Reading and writing; if the file does not exist, it will be created; if the file exists, it will be rewritten.</li>
</ul>
<p>As you can see, the <kbd>pickle</kbd> and <kbd>shelve</kbd> modules provide some convenient ways of organizing data. They are also useful in applications that work with machine learning algorithms. In reality, however, there may be tasks that require a broader approach and the need to use common tools and databases. In the following sections, we will try to describe these common tools.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">CSV</h1>
                </header>
            
            <article>
                
<p>A <strong>Comma Separated Values</strong> (<strong>CSV</strong>) file is a type of text file that uses a comma to separate values and stores data in a table as a plain text file. This is a very popular kind of file and is often used as a source of data in machine learning applications, and data science generally. CSV files allow us to create and operate with large datasets, which can often contain billions of values. The tables of data used with popular office applications such as Microsoft Excel and LibreOffice Calc appear in similar spreadsheets, and these applications can open CSV files, but the Python standard library has a module that creates and operates with CSV files. We'll also look at some special tools, such as pandas.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">The csv module</h1>
                </header>
            
            <article>
                
<p>The Python standard library includes the <kbd>csv</kbd> module for manipulating CSV files. To show you how to use this module effectively, we'll provide an example of writing and reading CSV files:</p>
<ol>
<li>First, add <span>the following lines </span>to the <kbd>import</kbd> section of the <kbd>u_tools.py</kbd> file:</li>
</ol>
<pre style="padding-left: 60px">...<br/>import csv<br/>import os<br/>...</pre>
<ol start="2">
<li>After the <kbd>import</kbd> section, add the following path to this file:</li>
</ol>
<pre style="padding-left: 60px">...<br/>pathf = os.path.dirname(os.path.abspath(__file__))<br/>...</pre>
<p style="padding-left: 60px">With this line, we can get the directory path to the application file to the working directory of our application.</p>
<ol start="3">
<li><span> In the </span><kbd>UTools</kbd><span> class of the </span><kbd>u_tools.py</kbd><span> file, add the following functions, which will write and read CSV files</span>:</li>
</ol>
<pre style="padding-left: 60px">...<br/>class UTools(object):<br/>    ...<br/>    def csv_write(self, csvfile=None, fieldnames=None, mode='a',<br/>            newline='', rowdata=None, dialect=csv.excel,<br/>            delimiter=' ', quotechar='|', lineterminator='\r\n'):<br/>    csvpath = os.path.exists(r"%s/%s" % (pathf, csvfile))<br/>    csvf = open(csvfile, mode)<br/>    csvw = csv.DictWriter(csvf, fieldnames=fieldnames,<br/>                    dialect=dialect,delimiter=delimiter,<br/>                    lineterminator=lineterminator)<br/>    if csvpath is False:<br/>        csvw.writeheader()<br/>    csvdict = {k: v for (k, v) in zip(fieldnames, rowdata)}<br/>    csvw.writerow(csvdict)<br/>...</pre>
<p style="padding-left: 60px">The preceding functions will write data to the CSV file. If the specified file does not exist, the header will be added to the data.</p>
<ol start="4">
<li>Now, add the following function to read CSV files:</li>
</ol>
<pre style="padding-left: 60px">...<br/>    ...<br/>    def csv_read(self, csvfile=None, mode='r',<br/>                                    dialect=csv.excel):<br/>        csvf = open(csvfile, mode)<br/>        csvr = csv.DictReader(csvf, dialect=dialect,<br/>                                        delimiter=' ')<br/>        return csvr<br/>...</pre>
<p style="padding-left: 60px">This function will read a CSV file with the Python standard library's <kbd>csv</kbd><span> </span>module and will return the <kbd>DictReader</kbd> object with data.</p>
<p>In the <kbd>UApp</kbd> class of the <kbd>u_app.py</kbd> file, we now need to add the tool for opening and saving CSV files:</p>
<ol>
<li>First, add <span>the <strong><kbd>csv</kbd></strong> module functionality </span>to the <kbd>data()</kbd> function of the <kbd>UApp</kbd> class, as follows:</li>
</ol>
<pre style="padding-left: 60px">...<br/>    ...<br/>    def data(self, action):<br/>        ...<br/>        if self.actx == "Shelve":<br/>            ...<br/>        if self.actx == "CSV":<br/>            try:<br/>                for row in self.csv_read(<br/>                                  csvfile="data/tests.csv"): <br/>                    self.text_edit.append("%s %s %s %s" % (<br/>                            row["User_Name"],<br/>                            row["User_email"],<br/>                            row["User_password"],<br/>                            row["User_data"]))<br/>                self.stat_bar.showMessage(<br/>                                     self.actx + " opened")<br/>            except Exception as err:<br/>                self.stat_bar.showMessage(<br/>                                self.actx + ' ' + str(err))<br/>        ...<br/>    ...<br/>...</pre>
<p style="padding-left: 60px">This function will read the rows of the <kbd>DataReader</kbd> object that will be returned when <span>the <kbd>csv_read()</kbd> function of the <kbd>UTools</kbd> class is c</span>alled.</p>
<ol start="2">
<li>Next, add<span> the following instruction</span> to the <kbd>save_data()</kbd> function:</li>
</ol>
<pre style="padding-left: 60px">...<br/>    ...<br/>    def save_data(self):<br/>        ...<br/>            ...<br/>            elif self.actx == "Shelve":<br/>                ...<br/>            elif self.actx == "CSV":<br/>                self.user_data3(uname, umail, upass, udata)<br/>            ...<br/>        ...<br/>    ...<br/>...</pre>
<p style="padding-left: 60px">This function will call the <kbd>user_data3()</kbd> function with the data specified in its parameters.</p>
<ol start="3">
<li>Now add the <kbd>user_data3()</kbd> function to the end of the <kbd>UApp</kbd> class, as follows:</li>
</ol>
<pre style="padding-left: 60px">...<br/>    ...<br/>    def user_data3(self, uname, umail, upass, udata):<br/>        fnames = ["User_Name", "User_email",<br/>                  "User_password", "User_data"]<br/>        rdata = [uname, umail, upass, udata[:140]]<br/>        try:<br/>            for row in self.csv_read(<br/>                             csvfile="data/tests.csv"):<br/>                if (row["User_Name"] == rdata[0]) and (<br/>                        row["User_password"] == rdata[2]):<br/>                    rdata = None<br/>        except Exception:<br/>            pass<br/>        if rdata is not None:<br/>            try: <br/>                self.csv_write(csvfile="data/tests.csv",<br/>                               fieldnames=fnames,<br/>                               rowdata=rdata, delimiter=' ',<br/>                               lineterminator='\n')<br/>            except Exception as err: <br/>                self.error = err<br/>...</pre>
<p style="padding-left: 60px">The function will try to write the data to the CSV file. If the specified data exists in the file, this data will not be written. The preceding example shows us what is possible using Python's <kbd>csv</kbd> module for reading and writing CSV files, although some of these lines are optional and can be rewritten.</p>
<p style="padding-left: 60px">There are, however, some lines we need to pay attention to. Lines with statements that pass exceptions are not recommended, because when errors occur, they will not provide us with any information about the error or tell us what happened. This can be solved by changing these lines in relation to Python 2.x/3.x. (As mentioned earlier, PyQt5 uses Python 3.x and PySide2 uses Python 2.x.)</p>
<p>We can write the following lines for PyQt5 exception handling:</p>
<pre>except Exception as err:<br/>    print(err)</pre>
<p>The following lines are for PySide2 exception handling:</p>
<pre>except Exception as err:<br/>    print err</pre>
<p><span>Note that more concrete exceptions, such as <kbd>FileNotFoundError</kbd> or <kbd>PermissionError</kbd> (3.x),</span> can be used. The full list of built-in exceptions is available in the official Python documentation, and they are different for each Python version.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">pandas</h1>
                </header>
            
            <article>
                
<p>When working with CSV files i<span>n a professional sense, you should </span>use the most popular toolset for working with data: <strong>pandas</strong>. This toolset allows us to handle large datasets, manipulate data, and analyze and represent data in almost any field of data science. This package, along with SciPy, NumPy, and Matplotlib, forms the basis of scientific Python. As mentioned in its official source, pandas is a library that provides high-performance, easy-to-use data structures and data analysis tools for the Python programming language. For more information on the wide functionality of the pandas library, visit <a href="http://pandas.pydata.org/">http://pandas.pydata.org/</a>.</p>
<p>We'll now take a look at this great tool in action by using it with CSV files. pandas can be installed in the following way:</p>
<pre>with pip<br/>&gt; pip install pandas<br/>or with conda<br/>&gt; conda install pandas</pre>
<p>Note that the latest <span>versions of </span>Anaconda include pandas as the default installed package, as well as NumPy, SciPy, Matplotlib, scikit-learn, and many others.</p>
<p>In this section, we will go through a short example of how to write and read files with pandas:</p>
<ol>
<li>After it has been installed, you need to import the pandas library. To do this, add the following <kbd>import</kbd> statement to the <kbd>u_tools.py</kbd> file:</li>
</ol>
<pre style="padding-left: 60px">...<br/>import pandas<br/>...</pre>
<ol start="2">
<li>Next, add the <kbd>pandas_write()</kbd> function to the <kbd>UTools</kbd> class of the <kbd>u_tools.py</kbd> file, as follows:</li>
</ol>
<pre style="padding-left: 60px">...<br/>class UTools(object):<br/>    ...<br/>    def pandas_write(self, filename=None, writer="csv",<br/>            data=None, columns=None, index=None, dtype=object):<br/>        df = pandas.DataFrame(data, columns=columns,<br/>                                index=index, dtype=dtype)<br/>        df.index.name = "rows\columns"<br/>        if writer == "csv":<br/>            df.to_csv(filename)<br/>        if writer == "excel":<br/>            df.to_excel(filename)<br/>        if writer == "html":<br/>            df.to_html(filename)<br/>        if writer == "json":<br/>            df.to_json(filename)<br/>        return (df, writer)<br/>...</pre>
<p style="padding-left: 60px">The preceding function can write data to various files, such as CSV, Excel, HTML, and JSON, depending on the specified filename and the extension (the type), and the type specified in the <kbd>writer</kbd> parameter.</p>
<ol start="3">
<li>Now add the following <kbd>pandas_read()</kbd> function, which will read the file depending on the specified parameters:</li>
</ol>
<pre style="padding-left: 60px">...<br/>    ...<br/>    def pandas_read(self, filename=None, reader="csv", sep=',',<br/>                delimiter=None, engine='python', maxrows=999):<br/>        if reader == "csv":<br/>            df = pandas.read_csv(filename, engine=engine)<br/>        if reader == "excel":<br/>            df = pandas.read_excel(filename)<br/>        if reader == "html":<br/>            df = pandas.read_html(filename)<br/>        if reader == "json":<br/>            df = pandas.read_json(filename)<br/>        pandas.options.display.max_rows = maxrows<br/>        return (df, reader)<br/>...</pre>
<p style="padding-left: 60px"><span>This function can read data from various files, such as CSV, Excel, HTML, and JSON, depending on the specified filename and the extension (the type), and the type specified in the <kbd>reader</kbd> parameter. </span></p>
<ol start="4">
<li><span>In the </span><kbd>UApp</kbd><span> class of the </span><kbd>u_app.py</kbd><span> file, add the pandas tool for opening and saving files. </span>Add <span>the pandas functionality to </span>the <kbd>data()</kbd> function of the <kbd>UApp</kbd> class, as follows:</li>
</ol>
<pre style="padding-left: 60px">...<br/>    ...<br/>    def data(self, action):<br/>        ...<br/>        if self.actx == "CSV":<br/>            ...<br/>        if self.actx == "Pandas":<br/>            try:<br/>                pread = self.pandas_read(<br/>                              filename="data/ptests.csv",<br/>                                   reader="csv", sep=',') <br/>                self.text_edit.append(str(pread[0]))<br/>                self.stat_bar.showMessage(<br/>                                   self.actx + " opened")<br/>            except Exception as err:<br/>                self.stat_bar.showMessage(<br/>                              self.actx + ' ' + str(err))<br/>        ...<br/>    ...<br/>...</pre>
<p style="padding-left: 60px">This instruction will call the function for reading CSV file with pandas. It will either append read data to the text field or display an error message in the status bar of the application.</p>
<ol start="5">
<li>Next, add the <span>following instruction </span>to the <kbd>save_data()</kbd> function:</li>
</ol>
<pre style="padding-left: 60px">...<br/>    ...<br/>    def save_data(self):<br/>        ...<br/>            ...<br/>            elif self.actx == "CSV":<br/>                ...<br/>            elif self.actx == "Pandas":<br/>                self.user_data4(uname, umail, upass, udata)<br/>            ...<br/>        ...<br/>    ...<br/>...</pre>
<p style="padding-left: 60px">This instruction will call the <kbd>user_data4()</kbd><span> function with the data specified in the parameters.</span></p>
<ol start="6">
<li>Add the <kbd>user_data4()</kbd> function to the end of the <kbd>UApp</kbd> class, as follows:</li>
</ol>
<pre style="padding-left: 60px">...<br/>    ...<br/>    def user_data4(self, uname, umail, upass, udata):<br/>        try:<br/>            ucolumns = ["User_Name", "User_email",<br/>                        "User_password", "User_data"]<br/>            uindex = [i for i in range(1000)]<br/>            udata = {"User_Name": range(0, 1000),<br/>                     "User_email": range(0, 1000),<br/>                     "User_password": range(0, 1000),<br/>                     "User_data": range(0, 1000)}<br/>            self.pandas_write(filename="data/ptests.csv",<br/>                           writer="csv", data=udata,<br/>                           columns=ucolumns, index=uindex)<br/>        except Exception as err:<br/>            self.error = err<br/>...</pre>
<p style="padding-left: 60px">This function does not use the data retrieved in the parameters; instead, it uses the data generated with the <kbd>range()</kbd> function, which is used for each column in the table. We're now in a position to run the <kbd>u_app.py</kbd> file and take a look at the results. When the <kbd>Save</kbd> button is clicked, a file will be created with data. You can change the extension of the filename to <kbd>data/tests.xlsx</kbd> and change the writer to Excel as an experiment, if you wish. As you can see, this small amount of code provides a lot of functionality in comparison to our CSV example. Note that other functions, such as <kbd>to_html()</kbd>, are optional and simply demonstrate the functionality of the pandas library.</p>
<p>Pandas is the recommended tool for data manipulation in applications because it has the widest toolset. On the other hand, the application can, unsurprisingly, often become slow. Importing pandas and writing the total number of values costs memory resources; in <a href="0e64461d-9420-4c73-9607-25e90f854793.xhtml">Chapter 16</a>, <em>Threading and Multiprocessing</em>, we will try to solve this problem.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">SQL</h1>
                </header>
            
            <article>
                
<p>In this section, we'll look at databases based on <strong>Structured Query Language</strong> (<strong>SQL</strong>). SQL is a domain-specific language that's used to manipulate databases by managing data in <strong>Relational Database Management Systems</strong> (<strong>RDBMS</strong>) and stream processing in <strong>Relational</strong> <strong>Data Stream Management Systems</strong> (<strong>RDSMS</strong>). We will not dive into SQL theory, as you can learn more about that by reading the relevant documentation. In this section, we will just cover the most valuable parts of GUI applications.</p>
<p>Databases, whether SQL or NoSQL-based, provide other approaches to storing data than previously discussed. In earlier examples, we have saved data to files and <span>retrieved it </span>by creating a data structure. However, using CSV files in this way is not always the most efficient approach. In some applications, we may require a database that is convenient and also provides management functionality. In other words, we need to create a SQL (or NoSQL) database for storing and managing data.</p>
<p>In order to get the most out of this book, readers must have some basic knowledge of SQL and its main statements, such as <kbd>CREATE</kbd>, <kbd>INSERT</kbd>, <kbd>SELECT</kbd>, <kbd>UPDATE</kbd>, and <kbd>DELETE</kbd>. In the next section, we will start by looking at the main third-party SQL databases before moving on to discover what the Qt library makes possible.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">SQLite</h1>
                </header>
            
            <article>
                
<p>SQLite is an SQL database library that implements a small and fast SQL database engine <span>using the C language</span>. It is a straightforward database to use; its strengths are its simplicity and portability. This database can be easily implemented with applications for almost any device, and is the most widely used database in the world. Importantly, this database is also included in the Python standard library modules, and consequently can be used with PyQt and PySide bindings.</p>
<p>We don't need to download it, install it, or go through a complicated process to start using this database; we just need to import it in a file, whenever we need it, with the following steps:</p>
<ol>
<li><span> First, add the following line i</span>n the <kbd>u_defaults.py</kbd> file's <kbd>import</kbd> section:</li>
</ol>
<pre style="padding-left: 60px">...<br/>import sqlite3<br/>...</pre>
<ol start="2">
<li><span>Open the </span><kbd>u_defaults.py</kbd><span> file and add the following lines to create a database. </span>After the <kbd>import</kbd> <span>section, add the following path:</span></li>
</ol>
<pre style="padding-left: 60px">...<br/>pathf = os.path.dirname(os.path.abspath(__file__))<br/>...</pre>
<ol start="3">
<li>Then, after the function that writes colors to the file, add the following lines:</li>
</ol>
<pre style="padding-left: 60px">...<br/>dbcon = sqlite3.connect("%s/data/u_db.sqlite" % dbpath)<br/>dbcursor = dbcon.cursor()<br/>sql_query = """CREATE TABLE IF NOT EXISTS u_dbtable (<br/>                info_date DEFAULT CURRENT_TIMESTAMP,<br/>                user_name TEXT UNIQUE,<br/>                user_email TEXT UNIQUE,<br/>                user_passw TEXT,<br/>                user_data TEXT UNIQUE);"""<br/>dbcursor.execute(sql_query) <br/>dbcursor.close()<br/>dbcon.close()<br/>...</pre>
<p style="padding-left: 60px">Creating the connection to a database and its cursor, writing and executing an SQL query, and then closing the cursor with the database is a standard way of working with the SQL database.</p>
<p style="padding-left: 60px">Now, if we run the <kbd>u_app.py</kbd> file, the SQLite database with the table should exist and be ready to use. Note that the file of the database will be created in the <kbd>data/</kbd> folder of the application's directories.</p>
<p style="padding-left: 60px">We now want to provide some operations to this database, such as inserting or selecting values.</p>
<ol start="4">
<li>So, in the <kbd>u_tools.py</kbd> files' <kbd>import</kbd> section, add the following line:</li>
</ol>
<pre style="padding-left: 60px">...<br/>import sqlite3<br/>...</pre>
<ol start="5">
<li><span>Add the following function, which will insert values into the database, </span>to the <kbd>UTools</kbd> class of the <kbd>u_tools.py</kbd> file:</li>
</ol>
<pre style="padding-left: 60px">...<br/>class UTools(object):<br/>    ...<br/>    def sqlite_insert(self, username=None, email=None,<br/>                        passw=None, data=None):<br/>        dbcon = sqlite3.connect("%s/data/u_db.sqlite" % pathf)<br/>        dbcursor = dbcon.cursor()<br/>        sql_query = """INSERT INTO u_dbtable (user_name, user_email,<br/>                    user_passw, user_data) VALUES (?, ?, ?, ?);"""<br/>        udata = (str(username), str(email), str(passw), str(data))<br/>        dbcursor.execute(sql_query, udata)<br/>        dbcon.commit()<br/>        dbcursor.close()<br/>        dbcon.close()<br/>...</pre>
<p style="padding-left: 60px">The preceding function realizes a connection to the SQLite database for inserting specified values.</p>
<ol start="6">
<li>Next, add the function that will select values for the database, as follows:</li>
</ol>
<pre style="padding-left: 60px">...<br/>    ...<br/>    def sqlite_select(self):<br/>        dbcon = sqlite3.connect("%s/data/u_db.sqlite" % pathf)<br/>        dbcursor = dbcon.cursor()<br/>        sql_query = """SELECT info_date, user_name,<br/>                        user_email, user_passw,<br/>                        user_data FROM u_dbtable;"""<br/>        dbcursor.execute(sql_query)<br/>        dbdata = dbcursor.fetchall()<br/>        dbcursor.close()<br/>        dbcon.close()<br/>        return dbdata<br/>...</pre>
<p style="padding-left: 60px">The preceding function will select values from the database depending on the specific SQL query. </p>
<ol start="7">
<li>In the <kbd>UApp</kbd> class of the <kbd>u_app.py</kbd> file, add the SQLite functionality for inserting or selecting database values<span> to the</span> <kbd>data()</kbd> <span>function of the</span> <kbd>UApp</kbd> <span>class, as follows:</span></li>
</ol>
<pre style="padding-left: 60px">...<br/>    ...<br/>    def data(self, action):<br/>        ...<br/>        if self.actx == "Pandas":<br/>            ...<br/>        if self.actx == "SQLite":<br/>            try: <br/>                dbdata = self.sqlite_select()<br/>                for dtx in dbdata:<br/>                    self.text_edit.append(<br/>                               "%s\n%s\n%s\n%s\n%s" % (<br/>                                dtx[0], dtx[1],dtx[2],<br/>                                dtx[3], dtx[4]))<br/>                self.stat_bar.showMessage(<br/>                                 self.actx + " opened")<br/>            except Exception as err:<br/>                self.stat_bar.showMessage(<br/>                            self.actx + ' ' + str(err))<br/>        ...<br/>    ...<br/>...</pre>
<p style="padding-left: 60px">The preceding function will use the <kbd>sqlite_select()</kbd> function of the <kbd>UTools</kbd> class to select values from the database.</p>
<ol start="8">
<li>Next, add the following code to the <kbd>save_data()</kbd> function:</li>
</ol>
<pre style="padding-left: 60px">...<br/>    ...<br/>    def save_data(self):<br/>        ...<br/>            ...<br/>            elif self.actx == "Pandas":<br/>                ...<br/>            elif self.actx == "SQLite":<br/>                self.user_data5(uname, umail, upass, udata)<br/>            ...<br/>        ...<br/>    ...<br/>...</pre>
<p style="padding-left: 60px">The preceding instruction will call the <kbd>user_data5()</kbd> function with the data specified in the parameters.</p>
<ol start="9">
<li>Now add the <kbd>user_data5()</kbd> function to the end of the <kbd>UApp</kbd> class, as follows:</li>
</ol>
<pre style="padding-left: 60px">...<br/>    ...<br/>    def user_data5(self, uname, umail, upass, udata):<br/>        try:<br/>            self.sqlite_insert(username=uname, email=umail,<br/>                               passw=upass, data=udata)<br/>        except Exception as err:<br/>            self.error = err<br/>...</pre>
<p style="padding-left: 60px">The preceding function will write the specified data to the SQLite database.</p>
<p style="padding-left: 60px">We now know how to use the SQLite3 database in our application by inserting and selecting values. Note that some users may find SQLite less secure than other databases, but it also has a number of benefits. SQLite's flexibility, simplicity, and reliability, among other benefits means it is still recommended for use in applications.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">PostgreSQL</h1>
                </header>
            
            <article>
                
<p>PostgreSQL is a high-management relational database system and can be defined as an <strong>Object-Relational Database Management System (ORDBMS)</strong>. At the moment, it is the most <span>commonly </span>used database in cases related to big data and industrial tasks. As a database, PostgreSQL provides wide functionality. To implement this database in our application, we first need to download and install it to our remote or local device. PostgreSQL can be easily downloaded from the official source, <a href="https://www.postgresql.org">https://www.postgresql.org</a>, for any platform.</p>
<p>To install this database, we need to follow the <span>installation </span>instructions and provide a password before it can connect. After everything is downloaded and installed, we need to configure PostgreSQL before we can begin using it. The following steps demonstrate how to do this:</p>
<ol>
<li>First, initialize the database cluster. To do this, open a command line or Terminal and change the current directory to the <kbd>data/</kbd> folder of the application directory, as follows:</li>
</ol>
<pre style="padding-left: 60px"><strong>&gt; cd Path/to/the/App/App_Pyside2/data</strong><br/>or<br/><strong>&gt; cd Path/to/the/App/App_PyQt5/data</strong></pre>
<ol start="2">
<li>Next, <span>initialize the </span>database cluster, as follows:</li>
</ol>
<pre style="padding-left: 60px"><strong>&gt; Path/to/the/installed/PostgreSQL/bin/initdb postgresdb</strong></pre>
<p style="padding-left: 60px">The database cluster <span>will be initialized </span>as a folder called <kbd>postgresdb</kbd>, or a place (a storage area on disk) where the database will be created. When initialization is complete, the following message should appear in the command-line or Terminal window:</p>
<pre style="padding-left: 60px"><strong>...Success. You can now start the database server using:</strong><br/><strong>...Path/to/the/installed/PostgreSQL/bin/pg_ctl -D postgresdb -l logfile start</strong></pre>
<ol start="3">
<li>Now, start the server with a copy of the preceding line in the command line or Terminal:</li>
</ol>
<pre style="padding-left: 60px"><strong>&gt; Path/to/the/installed/PostgreSQL/bin/pg_ctl -D postgresdb -l logfile start</strong></pre>
<p style="padding-left: 60px">The result should look as follows:</p>
<pre style="padding-left: 60px"><strong>...waiting for server to start.... done</strong><br/><strong>...server started</strong></pre>
<p style="padding-left: 60px">We have now started the server and database cluster in the required directory. Note that we must start the server each time we want to use the database. After rebooting or reinstalling the operating system, this server can be stopped, so we need to <span>enable the server to start automatically when the environment is started</span>. You can find out how to do this by reading the official documentation or other third-party sources applicable to your operating system.</p>
<ol start="4">
<li>Now create the PostgreSQL database with the following command:</li>
</ol>
<pre style="padding-left: 60px"><strong>&gt; Path/to/the/installed/PostgreSQL/bin/createdb psqldb</strong></pre>
<ol start="5">
<li>Create a table in the database. To do this, open the following <kbd>psql</kbd> shell in the command line or Terminal:</li>
</ol>
<pre style="padding-left: 60px"><strong>&gt; Path/to/the/installed/PostgreSQL/bin/psql psqldb</strong></pre>
<ol start="6">
<li>Input the following SQL query for table creation:</li>
</ol>
<pre style="padding-left: 60px"><strong>psqldb=# CREATE TABLE u_dbtable (</strong><br/><strong>psqldb(# info_date TIMESTAMP DEFAULT NOW(),</strong><br/><strong>psqldb(# user_name TEXT UNIQUE,</strong><br/><strong>psqldb(# user_email TEXT UNIQUE,</strong><br/><strong>psqldb(# user_passw TEXT,</strong><br/><strong>psqldb(# user_data TEXT UNIQUE);</strong></pre>
<p style="padding-left: 60px">The result should be as follows:</p>
<pre style="padding-left: 60px"><strong>psqldb(# ...;</strong><br/><strong>CREATE TABLE</strong></pre>
<p>So, we have now <span>created </span><span>a PostgreSQL database with a table for our application. PostgreSQL has various functionalities that give users the ability to configure and manage databases, such as <kbd>dropdb</kbd>, <kbd>dropuser</kbd>, and <kbd>psql</kbd> (command-line interface). These can all be found in the <kbd>bin/</kbd> folder of the PostgreSQL installation.</span></p>
<p><span>The next step is to use this database in our application. The Python standard library doesn't include PostgreSQL, so it needs to be downloaded and installed through a third-party package adapter, for example,</span> <kbd>psycopg</kbd><span>. To do this, use the following command:</span></p>
<pre><strong>&gt; pip install psycopg2</strong></pre>
<p>We can now use PostgreSQL with any Python-based application. To implement this functionality, add  the following lines to the <kbd>u_tools.py</kbd><span> files:</span></p>
<ol>
<li>In the <kbd>u_tools.py</kbd> file, add <span>the following import statement </span>to the <kbd>import</kbd> section:</li>
</ol>
<pre style="padding-left: 60px">...<br/>import psycopg2<br/>...</pre>
<ol start="2">
<li>Then, in the <kbd>UTools</kbd> class of the <kbd>u_tools.py</kbd> file, add a function that inserts values into the PostgreSQL database, as follows:</li>
</ol>
<pre style="padding-left: 60px">...<br/>class UTools(object):<br/>    ...<br/>    def psql_insert(self, username=None, email=None,<br/>                     passw=None, data=None):<br/>        dbcon = psycopg2.connect(dbname="psqldb")<br/>        dbcursor = dbcon.cursor()<br/>        sql_query = """INSERT INTO u_dbtable (user_name,<br/>                user_email, user_passw,<br/>                user_data) VALUES (%s, %s, %s, %s);"""<br/>        udata = (str(username), str(email),<br/>                     str(passw), str(data))<br/>        dbcursor.execute(sql_query, udata)<br/>        dbcon.commit()<br/>        dbcursor.close()<br/>        dbcon.close()<br/>...</pre>
<p style="padding-left: 60px">As you can see from the preceding example, SQL databases are very similar, and the function quickly realizes it's using a PostgreSQL database in the application. This function will insert values into the database.</p>
<ol start="3">
<li>Add the following function, which selects values from the PostgreSQL database:</li>
</ol>
<pre style="padding-left: 60px">...<br/>    ...<br/>    def psql_select(self):<br/>        dbcon = psycopg2.connect(dbname="psqldb")<br/>        dbcursor = dbcon.cursor()<br/>        sql_query = """SELECT info_date, user_name, user_email,<br/>                    user_passw, user_data FROM u_dbtable;"""<br/>        dbcursor.execute(sql_query)<br/>        dbdata = dbcursor.fetchall()<br/>        dbcursor.close()<br/>        dbcon.close()<br/>        return dbdata<br/>...</pre>
<p style="padding-left: 60px">The preceding function will select values from the PostgreSQL database dependent on the specified SQL query.</p>
<ol start="4">
<li><span> In the </span><kbd>UApp</kbd><span> class of the </span><kbd>u_app.py</kbd><span> file, add the PostgreSQL tool </span>for inserting and selecting database values. Add <span>the PostgreSQL functionality </span><span>to the</span> <kbd>data()</kbd> <span>function of the</span> <kbd>UApp</kbd> <span>class, as follows:</span></li>
</ol>
<pre style="padding-left: 60px">...<br/>    ...<br/>    def data(self, action):<br/>        ...<br/>        if self.actx == "SQLite":<br/>            ...<br/>        if self.actx == "PostgreSQL":<br/>            try:<br/>                dbdata = self.psql_select()<br/>                for dtx in dbdata:<br/>                    self.text_edit.append(<br/>                               "%s\n%s\n%s\n%s\n%s" % (<br/>                                dtx[0], dtx[1], dtx[2],<br/>                                       dtx[3], dtx[4]))<br/>                self.stat_bar.showMessage(<br/>                                 self.actx + " opened")<br/>            except Exception as err:<br/>                self.stat_bar.showMessage(<br/>                            self.actx + ' ' + str(err))<br/>        ...<br/>    ...<br/>...</pre>
<p style="padding-left: 60px">The preceding instruction uses the <kbd>psql_select()</kbd> function of the <kbd>UTools</kbd> class to select the data from the database and append it to the text edit field.</p>
<ol start="5">
<li>Now, add the <kbd>user_data6()</kbd> function to the <kbd>save_data()</kbd> function, as follows:</li>
</ol>
<pre style="padding-left: 60px">...<br/>    ...<br/>    def save_data(self):<br/>        ...<br/>            ...<br/>            elif self.actx == "SQLite":<br/>                ...<br/>            elif self.actx == "PostgreSQL":<br/>                self.user_data6(uname, umail, upass, udata)<br/>            ...<br/>        ...<br/>    ...<br/>...</pre>
<p style="padding-left: 60px">The preceding instruction will call the <kbd>user_data6()</kbd><span> function with the specified parameters.</span></p>
<ol start="6">
<li>Next, add the <kbd>user_data6()</kbd> function to the end of the <kbd>UApp</kbd> class, as follows:</li>
</ol>
<pre>...<br/>    ...<br/>    def user_data6(self, uname, umail, upass, udata):<br/>        try:<br/>            self.psql_insert(username=uname, email=umail,<br/>                                 passw=upass, data=udata)<br/>        except Exception as err:<br/>            self.error = err<br/>...</pre>
<p>The preceding instruction calls the <kbd>psql_insert()</kbd> function to insert user data into the database. The PostgreSQL database is now integrated and ready to use!</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">MySQL</h1>
                </header>
            
            <article>
                
<p>The MySQL database requires special attention. MySQL is an open source RDBMS that combines the simplicity and reliability of SQLite with slightly less functionality than PostgreSQL. In addition, MySQL is a component of the <strong>Linux-Apache-MySQL-Python|PHP|Perl (LAMP)</strong> web application software stack, which is very important for development.</p>
<p>Integrating this database in our application is very easy. We can either download and install a binary package of MySQL or a zipped archive. Using a binary package, we can easily install the database by following the instructions provided by the graphical installer. With a zipped archive, we need to use the documentation available at <a href="https://www.mysql.com">https://www.mysql.com</a> and initialize the non-install MySQL package.</p>
<p>Once everything is downloaded and installed, we can create a database with a table using the following steps:</p>
<ol>
<li>First, open a client console, enter the password for the root user, and type a SQL query similar to the following:</li>
</ol>
<pre style="padding-left: 60px"><strong>mysql&gt; CREATE DATABASE mysqldb;</strong></pre>
<ol start="2">
<li>Now, pass the following command to check all available databases:</li>
</ol>
<pre style="padding-left: 60px"><strong>mysql&gt; SHOW DATABASES;<br/></strong></pre>
<p style="padding-left: 60px">The output of the preceding command is as follows:</p>
<p class="CDPAlignCenter CDPAlign"><img src="assets/91b44329-db4e-46fe-b75f-b36a5bc8cbc5.png" style="width:42.92em;height:31.00em;"/></p>
<p style="padding-left: 60px">The preceding screenshot displays the databases available for us to use.</p>
<p style="padding-left: 60px">We can now create a table for the <kbd>mysqldb</kbd> database, but we need to select the database first. Note that choosing to use the database is required before you can use it.</p>
<p class="mce-root"/>
<ol start="3">
<li>Input the following command:</li>
</ol>
<pre style="padding-left: 60px"><strong>mysql&gt; USE mysqldb;</strong></pre>
<ol start="4">
<li>Create the query for adding a table to the database with the following code:</li>
</ol>
<pre style="padding-left: 60px"><strong>mysql&gt; CREATE TABLE u_dbtable (</strong><br/><strong>    -&gt; info_date TIMESTAMP DEFAULT CURRENT_TIMESTAMP,</strong><br/><strong>    -&gt; user_name VARCHAR(140) UNIQUE,</strong><br/><strong>    -&gt; user_email VARCHAR(270) UNIQUE,</strong><br/><strong>    -&gt; user_passw TEXT,</strong><br/><strong>    -&gt; user_data TEXT);</strong></pre>
<ol start="5">
<li>Now, display the tables in the database with the following command:</li>
</ol>
<pre style="padding-left: 60px"><strong>mysql&gt; SHOW TABLES;</strong></pre>
<ol start="6">
<li><span>Check which user is connecting</span> to the database with the following command:</li>
</ol>
<pre style="padding-left: 60px"><strong>mysql&gt; SELECT CURRENT_USER();</strong></pre>
<p>Like PostgreSQL, the Python standard library does not include MySQL—it needs to be downloaded and installed via a third-party package adapter such as PyMySQL. To do so, enter the following command on the command line or Terminal:</p>
<pre style="padding-left: 60px"><strong>&gt; pip install PyMySQL</strong></pre>
<p>Now we can start using the MySQL database with a Python-based application. We use the MySQL database in the <kbd>u_tools.py</kbd><span> file:</span></p>
<ol>
<li>In the <kbd>u_tools.py</kbd> file, add <span>the following <kbd>import</kbd> statement</span> to the <kbd>import</kbd> section:</li>
</ol>
<pre style="padding-left: 60px">...<br/>import pymysql<br/>...</pre>
<ol start="2">
<li>As before, add <span>the function that will insert values into the MySQL database table </span>to the <kbd>UTools</kbd> class of the <kbd>u_tools.py</kbd> file, as follows:</li>
</ol>
<pre style="padding-left: 60px">...<br/>class UTools(object):<br/>    ...<br/>    def mysql_insert(self, username=None, email=None,<br/>                        passw=None, data=None):<br/>        dbcon = pymysql.connect(host="localhost", user="root",<br/>                        password="rootpassword", db="mysqldb")<br/>        dbcursor = dbcon.cursor()<br/>        sql_query = """INSERT INTO u_dbtable (user_name,<br/>                    user_email, user_passw,<br/>                    user_data) VALUES (%s, %s, %s, %s);"""<br/>        udata = (str(username), str(email),<br/>                    str(passw), str(data))<br/>        dbcursor.execute(sql_query, udata)<br/>        dbcon.commit()<br/>        dbcursor.close()<br/>        dbcon.close()<br/>...</pre>
<p style="padding-left: 60px">The preceding function will connect to the MySQL database and insert user data.</p>
<ol start="3">
<li>Add the following function, which will be used to select values from the MySQL database:</li>
</ol>
<pre style="padding-left: 60px">...<br/>    ...<br/>    def mysql_select(self):<br/>        dbcon = pymysql.connect(host="localhost", user="root",<br/>                        password="rootpassword", db="mysqldb")<br/>        dbcursor = dbcon.cursor()<br/>        sql_query = """SELECT info_date, user_name, user_email,<br/>                      user_passw, user_data FROM u_dbtable;"""<br/>        dbcursor.execute(sql_query)<br/>        dbdata = dbcursor.fetchall()<br/>        dbcursor.close()<br/>        dbcon.close()<br/>        return dbdata<br/>...</pre>
<p style="padding-left: 60px">The preceding function will connect to and select user data from the MySQL database. </p>
<ol start="4">
<li><span>In the </span><kbd>UApp</kbd><span> class of the </span><kbd>u_app.py</kbd><span> file, add the MySQL tool </span>for inserting and selecting database values. Add <span>the MySQL functionality</span> <span>to the</span> <kbd>data()</kbd> <span>function of the</span> <kbd>UApp</kbd> <span>class, as follows:</span></li>
</ol>
<pre style="padding-left: 60px">...<br/>    ...<br/>    def data(self, action):<br/>        ...<br/>        if self.actx == "PostgreSQL":<br/>            ...<br/>        if self.actx == "MySQL":<br/>            try:<br/>                dbdata = self.mysql_select()<br/>                for dtx in dbdata:<br/>                    self.text_edit.append(<br/>                                 "%s\n%s\n%s\n%s\n%s" % (<br/>                                  dtx[0], dtx[1], dtx[2],<br/>                                         dtx[3], dtx[4]))<br/>                self.stat_bar.showMessage(<br/>                                   self.actx + " opened")<br/>            except Exception as err:<br/>                self.stat_bar.showMessage(<br/>                              self.actx + ' ' + str(err))<br/>        ...<br/>    ...<br/>...</pre>
<p style="padding-left: 60px">The preceding instruction will use the <kbd>mysql_select()</kbd> function for reading user data from the database and append it to the text field.</p>
<ol start="5">
<li>Next, add the following code to the <kbd>save_data()</kbd> function:</li>
</ol>
<pre style="padding-left: 60px">...<br/>    ...<br/>    def save_data(self):<br/>        ...<br/>            ...<br/>            elif self.actx == "PostgreSQL":<br/>                ...<br/>            elif self.actx == "MySQL":<br/>                self.user_data7(uname, umail, upass, udata)<br/>            ...<br/>        ...<br/>    ...<br/>...</pre>
<p style="padding-left: 60px">The preceding instruction will call the <span><kbd>user_data7()</kbd></span><strong><span> </span></strong><span>function with the specified user data in its parameters.</span></p>
<ol start="6">
<li>Add the <kbd>user_data7()</kbd> function to the end of the <kbd>UApp</kbd> class, as follows:</li>
</ol>
<pre style="padding-left: 60px">...<br/>    ...<br/>    def user_data7(self, uname, umail, upass, udata):<br/>        try:<br/>            self.mysql_insert(username=uname, email=umail,<br/>                              passw=upass, data=udata)<br/>        except Exception as err:<br/>            self.error = err<br/>...</pre>
<p style="padding-left: 60px">The preceding instruction will use the <kbd>mysql_insert()</kbd> function of the <kbd>UTools</kbd> class to insert values into the MySQL database. The MySQL database <span>operations </span>are now available!</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Qt SQL</h1>
                </header>
            
            <article>
                
<p>In the Qt library, the Qt SQL module provides SQL database integration with GUI applications. This module includes classes that realize the driver, API, and user interface layers for SQL databases. The driver-related classes that are currently available are <kbd>QSqlDriver</kbd>, <kbd>QSqlDriverCreatorBase</kbd>, and <kbd>QSqlResult</kbd>. For the API, there are classes such as <kbd>QSqlDatabase</kbd>, <kbd>QSqlQuery</kbd>, <kbd>QSqlField</kbd>, <kbd>QSqlIndex</kbd>, <kbd>QSqlRecord</kbd>, and <kbd>QSqlError</kbd>. Classes that implement the user interface layer include <kbd>QSqlQueryModel</kbd>, <kbd>QSqlTableModel</kbd>, and <kbd>QSqlRelationalTableModel</kbd>. To use this module in our application, we need to add the following lines to the <kbd>u_tools.py</kbd> files:</p>
<ol>
<li>Add the following code to the <kbd>import</kbd> section of the PyQt5 <kbd>u_tools.py</kbd> file:</li>
</ol>
<pre style="padding-left: 60px">...<br/>from PyQt5 import QtSql<br/>...</pre>
<ol start="2">
<li class="mce-root"><span>Ad</span><span>d the following code to the <kbd>import</kbd> section of the</span> PySide2 <kbd>u_tools.py</kbd> file:</li>
</ol>
<pre style="padding-left: 60px">...<br/>from PySide2 import QtSql<br/>...</pre>
<p>Let's now look at some of the classes included in the <kbd>QtSql</kbd> module for working with SQL databases in our application.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">QSqlDatabase</h1>
                </header>
            
            <article>
                
<p>This class realizes the SQL API layer and <span>creates connections to</span> the databases in the application. The declaration syntax of this class is as follows:</p>
<pre><strong>sql_db</strong> = QtSql.QSqlDatabase()</pre>
<p>The <kbd>QSqlDatabase</kbd> class improves functionality with the following functions.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">add</h1>
                </header>
            
            <article>
                
<p>The <kbd>sql_db.addDatabase(str, str)</kbd> function adds the database to a list of connections, along with its driver type (the first parameter) and the connection name (the second parameter).</p>
<p>The driver types that can be specified for the database connection are as follows:</p>
<ul>
<li><kbd>"QSQLITE"</kbd>: SQLite3 or above.</li>
<li><kbd>"QSQLITE2"</kbd>: SQLite2.</li>
<li><kbd>"QPSQL"</kbd>: PostgreSQL driver.</li>
<li><kbd>"QMYSQL"</kbd>: MySQL driver.</li>
<li><kbd>"QODBC"</kbd>: ODBC driver (includes Microsoft SQL Server).</li>
<li><kbd>"QOCI"</kbd>: Oracle Call Interface driver.</li>
<li><kbd>"QDB2"</kbd>: IBM DB2.</li>
<li><kbd>"QIBASE"</kbd>: Borland InterBase driver.</li>
<li><kbd>"QTDS"</kbd>: Sybase Adaptive Server.</li>
</ul>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">set</h1>
                </header>
            
            <article>
                
<p>The following functions set the parameters and properties of the database connection:</p>
<p><kbd>sql_db.setConnectOptions(str)</kbd>: This sets the database-specific options specified in a parameter.</p>
<p><kbd>sql_db.setDatabaseName(str)</kbd>: This sets the name of <span>the database, </span>specified in the parameter, of the database connection.</p>
<p><kbd>sql_db.setHostName(str)</kbd>: This sets the hostname, as specified in the parameter.</p>
<p><kbd>sql_db.setNumericalPrecisionPolicy(QtSql.QSql.NumericalPrecisionPolicy)</kbd>: This sets the numerical precision policy, as specified in the parameter.</p>
<p class="mce-root"/>
<p><kbd>sql_db.setPassword(str)</kbd>: This sets the password, as specified in the parameter.</p>
<p><kbd>sql_db.setPort(int)</kbd>: This sets the port, as specified in the parameter.</p>
<p><kbd>sql_db.setUserName(str)</kbd>: This sets the username, as specified in the parameter.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">is</h1>
                </header>
            
            <article>
                
<p>The following functions return a Boolean value (<kbd>b<span>ool</span></kbd><span>) related to the database's connection state:</span></p>
<p><kbd>sql_db.isDriverAvailable(str)</kbd>: This returns <kbd>True</kbd> if the driver specified in the parameter is available.</p>
<p><kbd>sql_db.isOpen()</kbd>: This returns <kbd>True</kbd> if this database connection is open; otherwise, it returns <kbd>False</kbd>.</p>
<p><kbd>sql_db.isOpenError()</kbd>: This returns <kbd>True</kbd> if an <span>error occurs when the database connection </span>opens.</p>
<p><kbd>sql_db.isValid()</kbd>: This returns <kbd>True</kbd> if the <kbd>QtSql.QSqlDatabase</kbd> object has a valid driver.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">functional</h1>
                </header>
            
            <article>
                
<p>The following functions relate to the current values of the database connection, changes in functionality, and so on:</p>
<p><kbd>sql_db.cloneDatabase(QtSql.QSqlDatabase, str)</kbd>: This clones the database connection (the first parameter) and stores it as a connection name (the second parameter).</p>
<p><kbd>sql_db.close()</kbd>: This closes this database connection.</p>
<p><kbd>sql_db.commit()</kbd>: This commits a transaction to the database, such as <kbd>INSERT</kbd> operations.</p>
<p><kbd>sql_db.connectionName()</kbd>: This returns the connection name of the database connection.</p>
<p><kbd>sql_db.connectionNames()</kbd>: This returns a list of the connection names of the database connection.</p>
<p><kbd>sql_db.connectOptions()</kbd>: This returns the connection options that are used with the database connection.</p>
<p><kbd>sql_db.contains(str)</kbd>: This returns <kbd>True</kbd> if the list of connections contains the connection name specified in the parameter.</p>
<p><kbd>sql_db.database(str, bool)</kbd>: This returns the database connection of the <kbd>QtSql.QSqlDatabase</kbd> type, with the connection name (the first parameter); if <kbd>open</kbd> (the second parameter) is <kbd>True</kbd>, the unopened database connection will open.</p>
<p><kbd>sql_db.databaseName()</kbd>: This returns the name of the database for the database connection.</p>
<p><kbd>sql_db.driver()</kbd>: This returns the database driver of the <kbd>QtSql.QSqlDriver</kbd> type used for the database connection.</p>
<p><kbd>sql_db.driverName()</kbd>: This returns the name of the driver that is used for the database connection.</p>
<p><kbd>sql_db.drivers()</kbd>: This returns the list of all <span>available </span>drivers.</p>
<p><span><kbd>sql_db.exec_(str)</kbd></span>: This executes a SQL statement and returns an object of the <kbd>QtSql.QSqlQuery</kbd> type.</p>
<p><kbd>sql_db.hostName()</kbd>: This returns the hostname of the database connection.</p>
<p><kbd>sql_db.lastError()</kbd>: This returns the last error that occurred within the database.</p>
<p><kbd>sql_db.numericalPrecisionPolicy()</kbd>: This returns the default precision policy of the <kbd>QtSql.QSql.NumericalPrecisionPolicy</kbd> type for the database connection.</p>
<p><kbd>sql_db.open()</kbd>: This opens the database connection with the current connection values.</p>
<p><kbd>sql_db.open(str, str)</kbd>: This opens the database connection with the <span>specified </span>username (the first parameter) and password (the second parameter).</p>
<p><kbd>sql_db.password()</kbd>: This returns the password of the database connection.</p>
<p><kbd>sql_db.port()</kbd>: This returns the port of the database connection.</p>
<p><kbd>sql_db.primaryIndex(str)</kbd>: This returns the primary index for the table specified in the parameter.</p>
<p><kbd>sql_db.record(str)</kbd>: This returns the record of the <kbd>QtSql.QSqlRecord</kbd> type, populated with the names of the fields in the table specified in the parameter.</p>
<p><kbd>sql_db.registerSqlDriver(str, QtSql.QSqlDriverCreatorBase)</kbd>: This registers the SQL driver (the second parameter) with a name (the first parameter).</p>
<p><kbd>sql_db.removeDatabase(str)</kbd><strong>:</strong> This removes the database connection with the name specified in the parameter.</p>
<p><kbd>sql_db.rollback()</kbd>: This rolls back <span>database </span>transactions.</p>
<p><kbd>sql_db.tables(QtSql.QSql.TableType)</kbd>: This returns a list of the tables in the database used with the database connection.</p>
<p><kbd>sql_db.transaction()</kbd>: This begins a transaction with the database, such as inserting values.</p>
<p><kbd>sql_db.userName()</kbd>: This returns the username of the database connection.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">QSqlQuery</h1>
                </header>
            
            <article>
                
<p>The <kbd>QSqlQuery</kbd> class executes SQL statements and database-specific commands related to operations with databases in the application.  The declaration syntax of this class is as follows:</p>
<pre><strong>sql_query</strong> = QtSql.QSqlQuery()</pre>
<p>The <kbd>QSqlQuery</kbd> class improves functionality with the following functions.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">add</h1>
                </header>
            
            <article>
                
<p>This <kbd>add</kbd> function adds SQL queries.</p>
<p>The  <kbd>sql_query.addBindValue(object, PySide2.QtSql.QSql.ParamType)</kbd> function adds the binding value (the first parameter) to the list of values, using the type (the second parameter).</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">set</h1>
                </header>
            
            <article>
                
<p>The following functions set the parameters and properties of the SQL queries:</p>
<p><kbd>sql_query.setForwardOnly(bool)</kbd>: If this parameter is <kbd>True</kbd>, it sets forward-only mode.</p>
<p><kbd>sql_query.setNumericalPrecisionPolicy(QtSql.QSql.NumericalPrecisionPolicy)</kbd>: This sets the numerical precision policy, specified in the parameter, that will be used for querying.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">is</h1>
                </header>
            
            <article>
                
<p>The following functions return a Boolean value (<kbd>bool</kbd>) related to the SQL query's state:</p>
<p><kbd>sql_query.isActive()</kbd>: This returns <kbd>True</kbd> if the query is active.</p>
<p><kbd>sql_query.isForwardOnly()</kbd>: This returns <kbd>True</kbd> if the result set can <span>only </span>be scrolled in a forward direction.</p>
<p><kbd>sql_query.isNull(int)</kbd>: This returns <kbd>True</kbd> if the query is not active nor positioned on a valid record, if there is no field specified in the parameter, or if this field is <kbd>null</kbd>.</p>
<p><kbd>sql_query.isNull(str)</kbd>: This returns <kbd>True</kbd> if this query is not active, not positioned on a valid record, if there is no field with the name specified in the parameter, or if this field is <kbd>null</kbd>.</p>
<p><kbd>sql_query.isSelect()</kbd>: This returns <kbd>True</kbd> if the current query uses the SQL <kbd>SELECT</kbd> statement to retrieve values from the database.</p>
<p><kbd>sql_query.isValid()</kbd>: This returns <kbd>True</kbd> if this query is positioned on a valid record.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">functional</h1>
                </header>
            
            <article>
                
<p>The following functions relate to the current values of SQL queries, changes in functionality, and so on:</p>
<p><kbd>sql_query.at()</kbd>: This returns the <span>current </span>internal position for the query.</p>
<p><kbd>sql_query.bindValue(str, object, QtSql.QSql.ParamType)</kbd>: This sets the placeholder (the first parameter) that will be bound to the value (the second parameter) in the statement, using the type (the third parameter).</p>
<p><kbd>sql_query.bindValue(int, object, QtSql.QSql.ParamType)</kbd>: This sets the placeholder in the position (the first parameter) that will be bound to the value (the second parameter) in the statement, using the type (the third parameter).</p>
<p><kbd>sql_query.boundValue(str)</kbd>: This returns the bound value for the placeholder specified in the parameter.</p>
<p><kbd>sql_query.boundValue(int)</kbd>: This returns the bound value for the placeholder at the position specified in the parameter.</p>
<p><kbd>sql_query.boundValues()</kbd>: This returns a dictionary with bound values.</p>
<p><kbd>sql_query.clear()</kbd>: This clears the results of the query.</p>
<p><kbd>sql_query.driver()</kbd>: This returns the database driver of the <kbd>QtSql.QSqlDriver</kbd> type that was used with the query.</p>
<p><kbd>sql_query.exec_()</kbd>: This executes the prepared query statement and returns <kbd>True</kbd> if it was successful.</p>
<p><kbd>sql_query.exec_(str)</kbd>: This executes the query statement specified in the parameter and returns <kbd>True</kbd> if it was successful.</p>
<p><kbd>sql_query.execBatch(QtSql.QSqlQuery.BatchExecutionMode)</kbd>: This executes the query statement in a batch, with the execution mode specified in the parameter<span>. </span>The available modes include <strong><kbd>QtSql.QSqlQuery.ValuesAsRows</kbd></strong><span>—</span><kbd>0</kbd><span>, which updates multiple rows, and </span><kbd>QtSql.QSqlQuery.ValuesAsColumns</kbd><span>—</span><kbd>1</kbd>, <span>which updates a single row.</span></p>
<p><kbd>sql_query.executedQuery()</kbd>: This returns the last successfully executed query.</p>
<p><kbd>sql_query.finish()</kbd>: This function instructs that no more data will be fetched from a query until the query is  re-executed.</p>
<p><kbd>sql_query.first()</kbd>: This retrieves the first record in a  result, and positions the query on the retrieved record.</p>
<p><kbd>sql_query.last()</kbd>: This retrieves the last record in a result, and positions the query on the retrieved record.</p>
<p><kbd>sql_query.lastError()</kbd>: This returns the last error of the <kbd>QtSql.QSqlError</kbd> type that occurred with the query.</p>
<p><kbd>sql_query.lastInsertId()</kbd>: This returns the ID of the object for the last inserted row.</p>
<p><kbd>sql_query.lastQuery()</kbd>: This returns the text of the last query.</p>
<p><kbd>sql_query.next()</kbd>: This retrieves the next record in the result.</p>
<p><kbd>sql_query.nextResult()</kbd>: This discards the result set of a query, and if it's available, it navigates to the next result.</p>
<p><kbd>sql_query.numericalPrecisionPolicy()</kbd>: This returns the precision policy of the <kbd>QtSql.QSql.NumericalPrecisionPolicy</kbd> type that is currently used.</p>
<p><kbd>sql_query.numRowsAffected()</kbd>: This returns the number of rows in relation to the result of the SQL statement.</p>
<p><kbd>sql_query.prepare(str)</kbd>: This prepares the SQL query statement specified in the parameter for execution.</p>
<p><kbd>sql_query.previous()</kbd>: This retrieves the previous record in the result.</p>
<p><kbd>sql_query.record()</kbd>: This returns the record of the <kbd>QtSql.QSqlRecord</kbd> type that contains the field information for this query.</p>
<p><kbd>sql_query.result()</kbd>: This returns the result of the <kbd>QtSql.QSqlResult</kbd> type related to the query.</p>
<p><kbd>sql_query.seek(int, bool)</kbd>: This retrieves the record at a specific index (the first parameter) in accordance with the second parameter.</p>
<p><kbd>sql_query.size()</kbd>: This returns the number of rows in the result.</p>
<p><kbd>sql_query.value(int)</kbd>: This returns the value of the field at the index specified in the parameter of the current record.</p>
<p><kbd>sql_query.value(str)</kbd>: This returns the value of field with the name specified in the parameter of the current record.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Qt SQL example</h1>
                </header>
            
            <article>
                
<p>Let's now take a look at an example of the <kbd>QtSql</kbd> module in action in our application. First, we need to open the <kbd>u_tools.py</kbd> files and add the following lines to them:</p>
<ol>
<li><span>Add <kbd>QSqlDatabase</kbd>, which will open an existing database or create a new database if one doesn't exist, to </span>the <kbd>__init__()</kbd> function of the <kbd>UTools</kbd> class, as follows:</li>
</ol>
<pre style="padding-left: 60px">...<br/>class UTools(object):<br/><br/>    def __init__(self):<br/>        ...<br/>        self.qtsql_db = QtSql.QSqlDatabase.addDatabase('QSQLITE')<br/>        self.qtsql_db.setDatabaseName("data/u_db.sqlite")<br/>        self.qtsql_db.open()<br/>    ...<br/>...</pre>
<p style="padding-left: 60px">The name of the database driver is defined in the <kbd>addDatabase()</kbd> method. A<span>nother driver c</span>an be used if available. This method sets the name and opens the database.</p>
<ol start="2">
<li>Next, add the function that will insert values into the opened SQLite database, as follows:</li>
</ol>
<pre style="padding-left: 60px">...<br/>    ...<br/>    def sql_qt_insert(self, username=None, email=None,<br/>                                passw=None, data=None):<br/>        query = QtSql.QSqlQuery(self.qtsql_db)<br/>        query.prepare("""INSERT INTO u_dbtable (user_name,<br/>                        user_email, user_passw, user_data)<br/>                        VALUES (:user_name, :user_email,<br/>                        :user_passw, :user_data);""")<br/>        query.bindValue(":user_name", username)<br/>        query.bindValue(":user_email", email)<br/>        query.bindValue(":user_passw", passw)<br/>        query.bindValue(":user_data", data)<br/>        query.exec_()<br/>...</pre>
<p style="padding-left: 60px">The preceding function uses the <strong><kbd>QSqlQuery</kbd></strong> class to create the SQL query and bind user data by inserting values.</p>
<ol start="3">
<li>Add the following function, which will select values from the database:</li>
</ol>
<pre style="padding-left: 60px">...<br/>    ...<br/>    def sql_qt_select(self):<br/>        query = QtSql.QSqlQuery(self.qtsql_db)<br/>        query.exec_("""SELECT * FROM u_dbtable;""")<br/>        return query<br/>...</pre>
<p style="padding-left: 60px">The preceding function will select the user data dependent on the query and return it.</p>
<ol start="4">
<li><span>In the </span><kbd>UApp</kbd><span> class of the </span><kbd>u_app.py</kbd><span> files, add the <kbd>QtSQL</kbd> tool </span>for inserting and selecting database values.<span> </span>Add <span>the <kbd>QtSql</kbd> module functionality </span><span>to the</span> <kbd>data()</kbd> <span>function of the</span> <kbd>UApp</kbd> <span>class, as follows:</span></li>
</ol>
<pre style="padding-left: 60px">...<br/>    ...<br/>    def data(self, action):<br/>        ...<br/>        if self.actx == "MySQL":<br/>            ...<br/>        if self.actx == "QtSQL":<br/>            try:<br/>                dbdata = self.sql_qt_select()<br/>                while dbdata.next():<br/>                    self.text_edit.append(<br/>                             "%s\n%s\n%s\n%s\n%s" % ( <br/>                              dbdata.value(0),<br/>                              dbdata.value(1),<br/>                              dbdata.value(2),<br/>                              dbdata.value(3),<br/>                              dbdata.value(4)))<br/>                self.stat_bar.showMessage(<br/>                               self.actx + " opened")<br/>            except Exception as err:<br/>                self.stat_bar.showMessage(<br/>                          self.actx + ' ' + str(err))<br/>        ...<br/>    ...<br/>...</pre>
<p class="mce-root" style="padding-left: 60px">The preceding instruction uses the <kbd>sql_qt_select()</kbd> function to select user data from the database and append the returned result to the text field.</p>
<ol start="5">
<li>Next, add the following to the <kbd>save_data()</kbd> function:</li>
</ol>
<pre style="padding-left: 60px">...<br/>    ...<br/>    def save_data(self):<br/>        ...<br/>            ...<br/>            elif self.actx == "MySQL":<br/>                ...<br/>            elif self.actx == "QtSQL":<br/>                self.user_data8(uname, umail, upass, udata)<br/>            ...<br/>        ...<br/>    ...<br/>...</pre>
<p style="padding-left: 60px">The preceding instruction calls the <kbd>user_data8()</kbd><strong> </strong>function with the specified user data parameters.</p>
<ol start="6">
<li>Now add the <kbd>user_data8()</kbd> function to the end of the <kbd>UApp</kbd> class, as follows:</li>
</ol>
<pre style="padding-left: 60px">...<br/>    ...<br/>    def user_data8(self, uname, umail, upass, udata):<br/>        try:<br/>            self.sql_qt_insert(username=uname,<br/>                               email=umail,<br/>                               passw=upass,<br/>                               data=udata)<br/>        except Exception as err:<br/>            self.error = err<br/>...</pre>
<p style="padding-left: 60px">The preceding function will call the <kbd>sql_qt_insert()</kbd> function of the <kbd>UTools</kbd> class to insert user data into the SQLite database. This example demonstrates the use of the <kbd>QtSql</kbd> module in practice. As you can see, it differs from standard third-party instruments, and this construction may be hard to understand. At the time of writing, by default, this module only has a <kbd>"QSQLITE"</kbd> driver, so others will need to be loaded and configured additionally. Whether you use this module instead of third-party database instruments is up to you.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">NoSQL</h1>
                </header>
            
            <article>
                
<p class="mce-root">NoSQL databases are other modern mechanisms for storing data. NoSQL is referred to as not-SQL, or not-relational, as data is modeled in a different way to the tabular relations in relational SQL databases. NoSQL databases are usually used in big data and real-time web applications. Another popular definition of NoSQL is <em>Not only SQL.</em> This means NoSQL databases can support SQL or sit alongside SQL databases.</p>
<p class="mce-root">Implementing NoSQL databases in our application may simplify document storage and make data handling easier, so let's a look at some short examples of how to use <span>the most popular NoSQL databases</span> in the GUI.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">MongoDB</h1>
                </header>
            
            <article>
                
<p>MongoDB is an open source database for NoSQL document storage. This database records documents as a data structure with field/value pairs. These documents are similar to the JSON objects we created in the <em>pandas</em> section. MongoDB values include documents, arrays, and arrays of documents. To use MongoDB, you need to download and install <span><span>it </span></span>from the official source, <a href="https://mongodb.com">https://mongodb.com</a>, using the documentation provided. It is also recommended that you download and install the additional development tools available.</p>
<p>Similar to previous sections, create the <kbd>MongoDB_1/</kbd>  folder in both the <kbd>App/App_PySide2/data/</kbd> and <kbd>App/App_PyQt5/data/</kbd> directories, where the database will be located:</p>
<ol>
<li>First, run a command similar to the following in your command line or Terminal, depending on your operating system:</li>
</ol>
<pre style="padding-left: 60px"><strong>&gt; cd /Path/To/The/Installed/MongoDB/bin</strong></pre>
<ol start="2">
<li>Find the executable files, such as <kbd>mongod</kbd> (for Linux) or <kbd>mongod.exe</kbd> (for Windows), and run the following command:</li>
</ol>
<pre style="padding-left: 60px"><strong>&gt; mongod --dbpath=/Path/To/The/App/App_PySide2/data/MongoDB_1</strong></pre>
<ol start="3">
<li>To connect to MongoDB, use commands such as <kbd>mongo</kbd> or <kbd>mongo.exe</kbd> in the new command line or Terminal, as follows:</li>
</ol>
<pre style="padding-left: 60px"><strong>&gt; /Path/To/The/installed/MongoDB/bin/mongo</strong></pre>
<ol start="4">
<li>An adapter is required for using MongoDB with Python; in this case, <kbd>pymongo</kbd>. Install the adapter with <kbd>pip</kbd>, as follows:</li>
</ol>
<pre class="mce-root" style="padding-left: 60px"><strong>&gt; python -m pip install pymongo</strong></pre>
<p>Now we can use the MongoDB functionality with our application!</p>
<p>It's time to add some lines to the <kbd>u_tools.py</kbd><span> files:</span></p>
<ol>
<li>Open the <kbd>u_tools.py</kbd> files and add <span>the following line </span>to the <kbd>import</kbd> section:</li>
</ol>
<pre style="padding-left: 60px">...<br/>import pymongo<br/>...</pre>
<ol start="2">
<li>Add <span>the following function</span> to the <kbd>UTools</kbd> class of the <kbd>u_tools.py</kbd> files. This will <span>insert values into the MongoDB database:</span></li>
</ol>
<pre style="padding-left: 60px">...<br/>    ...<br/>    def mongo_insert(self, username=None, email=None,<br/>                                passw=None, data=None):<br/>        client = pymongo.MongoClient('localhost', 27017)<br/>        db = client['umongodb']<br/>        post = {"User Name": username, "Email": email,<br/>                "Password": passw, "Data": data}<br/>        posts = db.posts<br/>        posts.insert_one(post)<br/>...</pre>
<p style="padding-left: 60px">The preceding function creates a connection to the MongoDB database with the host and port specified. </p>
<ol start="3">
<li>Add the function that will be used to select values from MongoDB, as follows:</li>
</ol>
<pre style="padding-left: 60px">...<br/>    ...<br/>    def mongo_select(self):<br/>        client = pymongo.MongoClient('localhost', 27017)<br/>        db = client['umongodb']<br/>        dbdata = db.posts.find()<br/>        return dbdata<br/>...</pre>
<p style="padding-left: 60px">The name of the database in this example is specified as <kbd>'umongodb'</kbd>. This function returns all user data from within the database. </p>
<ol start="4">
<li><span>In the </span><kbd>UApp</kbd><span> class of the </span><kbd>u_app.py</kbd><span> files, add the MongoDB tool </span>for inserting and selecting database values. Add <span>the MongoDB functionality </span><span>to the</span> <kbd>data()</kbd> <span>function of the</span> <kbd>UApp</kbd> <span>class, as follows:</span></li>
</ol>
<pre style="padding-left: 60px">...<br/>    ...<br/>    def data(self, action):<br/>        ...<br/>        if self.actx == "QtSQL":<br/>            ...<br/>        if self.actx == "MongoDB":<br/>            try:<br/>                dbdata = self.mongo_select()<br/>                for dtx in dbdata:<br/>                    self.text_edit.append(<br/>                            "%s\n%s\n%s\n%s" % (<br/>                             dtx["User Name"],<br/>                             dtx["Email"],<br/>                             dtx["Password"],<br/>                             dtx["Data"]))<br/>                self.stat_bar.showMessage(<br/>                           self.actx + " opened")<br/>            except Exception as err:<br/>                self.stat_bar.showMessage(<br/>                      self.actx + ' ' + str(err))<br/>        ...<br/>    ...<br/>...</pre>
<p style="padding-left: 60px">The preceding instruction uses the <kbd>mongo_select()</kbd> function to read data from the database and append it to the text field.</p>
<ol start="5">
<li>Now, add the following to the <kbd>save_data()</kbd> function:</li>
</ol>
<pre style="padding-left: 60px">...<br/>    ...<br/>    def save_data(self):<br/>        ...<br/>            ...<br/>            elif self.actx == "QtSQL":<br/>                ...<br/>            elif self.actx == "MongoDB":<br/>                self.user_data9(uname, umail, upass, udata)<br/>            ...<br/>        ...<br/>    ...<br/>...</pre>
<p style="padding-left: 60px">The <kbd>elif</kbd> instruction will use the <kbd>user_data9()</kbd><span> function with the specified parameters.</span></p>
<ol start="6">
<li>Now add the <kbd>user_data9()</kbd> function to the end of the <kbd>UApp</kbd> class, as follows:</li>
</ol>
<pre style="padding-left: 60px">...<br/>    ...<br/>    def user_data9(self, uname, umail, upass, udata):<br/>        try:<br/>            self.mongo_insert(username=uname,<br/>                              email=umail,<br/>                              passw=upass,<br/>                              data=udata)<br/>        except Exception as err:<br/>            self.error = err<br/>...</pre>
<p style="padding-left: 60px">The preceding function will be used to insert data into the database. It is a simple, short, and basic example of the implementation of Mongo in our application. To learn about all the capabilities and advantages of MongoDB in more detail, it's recommended that you read Mongo's official documentation.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">CouchDB</h1>
                </header>
            
            <article>
                
<p>Another popular type of NoSQL data storage is Apache CouchDB. This database uses mechanisms that are <span>similar to the ones </span>described in the previous section, but improves them with additional features. CouchDB is a modern tool for the web implementation of stored documents. If you're using the HTTP and JSON data formats, this database is the preferred choice.</p>
<p>To use this database in your application, you need to download and install it by following the instructions at <a href="http://couchdb.apache.org/">http://couchdb.apache.org/</a> for the appropriate operating system. When everything that is required is installed and configured, it's time to start CouchDB. To configure and start this database, it is recommended that you use additional documentation from your operating system, because the steps required may be different.</p>
<p>With CouchDB open, it's time to enter <kbd>http://127.0.0.1:5984/_utils/</kbd> in the search line of the web browser. A page explaining Couch database management, with additional instructions, should appear. It's now time to create a database called <kbd>u_couchdb</kbd> using the functionality of this web page. Once the database is created, you can create a document. To do this, click on the <span class="packt_screen">Create Document</span> button on the web page and add the following lines:</p>
<pre>{<br/>    "_id": "0e2484058a69f09841325dfa0d000b4e",<br/>    "User Name": "user",<br/>    "User email": "user@email.com",<br/>    "User password": "userpassword",<br/>    "User Data": "Hello CouchDB !!!"<br/>}</pre>
<p>Note that <kbd>_id</kbd> will be different. When the document is created, the first record of the database should appear on the web page. To implement these operations with Python, additional instruments to connect to Couch Database are needed, for example, the <kbd>CouchDB</kbd> package. Install this using the following command with <kbd>pip</kbd>:</p>
<pre><strong>&gt; pip install CouchDB</strong></pre>
<p>Now open the <kbd>u_tools.py</kbd> files and add some lines to realize <span>the functionality in the application:</span></p>
<ol>
<li>Add the following code to the <kbd>import</kbd> section of the <kbd>u_tools.py</kbd><span> file:</span></li>
</ol>
<pre style="padding-left: 60px">...<br/>import couchdb<br/>...</pre>
<ol start="2">
<li>Next, add <span>the following function </span>to the <kbd>UTools</kbd> class of the <kbd>u_tools.py</kbd> files:</li>
</ol>
<pre style="padding-left: 60px">...<br/>class UTools(object):<br/>    ...<br/>    def couch_insert(self, username=None, email=None,<br/>                                passw=None, data=None):<br/>        couch = couchdb.Server("http://127.0.0.1:5984/")<br/>        db = couch["u_couchdb"]<br/>        dbdata = {"User Name": username,<br/>                  "User email": email,<br/>                  "User password": passw,<br/>                  "User Data": data}<br/>        db.save(dbdata)<br/>...</pre>
<p style="padding-left: 60px">The preceding function will connect to the database with the specified URL (host and port) and insert values into CouchDB.</p>
<ol start="3">
<li>Now, add the function that will be used to select values from the database, as follows:</li>
</ol>
<pre style="padding-left: 60px">...<br/>    ...<br/>    def couch_select(self):<br/>        couch = couchdb.Server("http://127.0.0.1:5984/")<br/>        db = couch["u_couchdb"]<br/>        return db<br/>...</pre>
<p style="padding-left: 60px">The preceding function will connect to the database, select the available values, and return data. In the <kbd>UApp</kbd> class of the <kbd>u_app.py</kbd> files, add the CouchDB tool for inserting and selecting database values.</p>
<ol start="4">
<li>Add <span>the CouchDB functionality </span>to the <kbd>data()</kbd> function of the <kbd>UApp</kbd> class, as follows:</li>
</ol>
<pre style="padding-left: 60px">...<br/>    ...<br/>    def data(self, action):<br/>        ...<br/>        if self.actx == "MongoDB":<br/>            ...<br/>        if self.actx == "CouchDB":<br/>            try:<br/>                dbdata = self.couch_select()<br/>                for dtx in dbdata.view("_all_docs",<br/>                                       include_docs=True):<br/>                    self.text_edit.append(<br/>                                     "%s\n%s\n%s\n%s" % (<br/>                                  dtx["doc"]["User Name"],<br/>                                 dtx["doc"]["User email"],<br/>                              dtx["doc"]["User password"],<br/>                                 dtx["doc"]["User Data"]))<br/>                self.stat_bar.showMessage(<br/>                                    self.actx + " opened")<br/>            except Exception as err:<br/>                self.stat_bar.showMessage(<br/>                               self.actx + ' ' + str(err))<br/>        ...<br/>    ...<br/>...</pre>
<p style="padding-left: 60px">The preceding instruction uses the <kbd>couch_select()</kbd> function of the <kbd>UTools</kbd> class to select the user data from CouchDB.</p>
<ol start="5">
<li>Now, add the following code to the <kbd>save_data()</kbd> function:</li>
</ol>
<pre style="padding-left: 60px">...<br/>    ...<br/>    def save_data(self):<br/>        ...<br/>            ...<br/>            elif self.actx == "MongoDB":<br/>                ...<br/>            elif self.actx == "CouchDB":<br/>                self.user_data10(uname, umail, upass, udata)<br/>            ...<br/>        ...<br/>    ...<br/>...</pre>
<p style="padding-left: 60px">The preceding instruction uses the <kbd>user_data10()</kbd><span> function with the specified user data parameters.</span></p>
<ol start="6">
<li>Now add the <kbd>user_data10()</kbd> function to the end of the <kbd>UApp</kbd> class, as follows:</li>
</ol>
<pre style="padding-left: 60px">...<br/>    ...<br/>    def user_data10(self, uname, umail, upass, udata):<br/>        try:<br/>            self.couch_insert(username=uname,<br/>                              email=umail,<br/>                              passw=upass,<br/>                              data=udata)<br/>        except Exception as err:<br/>            self.error = err<br/>...</pre>
<p style="padding-left: 60px">The preceding function will call the <kbd>couch_insert()</kbd> function of the <kbd>UTools</kbd> class to insert the specified user data into the database. When the <kbd>u_app.py</kbd> files are run, you can communicate with CouchDB to insert values and select them in the documents, which will be represented on the web page of the Fauxton utility provided by the CouchDB functionality.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Summary</h1>
                </header>
            
            <article>
                
<p>This chapter introduced the most important part of <span>constructing an </span>application—data manipulation. <span>In this chapter, we also explained the first steps of handling data in an application. </span>As we have outlined in this chapter, the construction of implementations are somewhat similar, and their use is optional, so we will now move forward and concentrate on extending the GUI application's functionality. </p>
<p>The next chapter will explain the <span>communication </span>mechanism between an application and its user. In the Qt library, this is done with signals, slots, and events.</p>


            </article>

            
        </section>
    </body></html>