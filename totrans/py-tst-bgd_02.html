<html><head></head><body><div class="chapter" title="Chapter&#xA0;2.&#xA0;Doctest: The Easiest Testing Tool"><div class="titlepage"><div><div><h1 class="title"><a id="ch02"/>Chapter 2. Doctest: The Easiest Testing Tool</h1></div></div></div><a class="indexterm" id="id11"/><p>
<span class="emphasis"><em>This chapter will introduce you to a fantastic tool called doctest. Doctest is a program that ships with Python that lets you write down what you expect from your code in a way that's easy for both people and computers to read. Doctest files can often be created just by copying the text out of a Python interactive shell and pasting it into a file. Doctest will often be the fastest and easiest way to write tests for your software.</em></span>
</p><p>In this chapter, we shall:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">Learn the doctest language and syntax</li><li class="listitem" style="list-style-type: disc">Write doctests embedded in text files</li><li class="listitem" style="list-style-type: disc">Write doctests embedded in Python docstrings</li></ul></div><div class="section" title="Basic doctest"><div class="titlepage"><div><div><h1 class="title"><a id="ch02lvl1sec12"/>Basic doctest</h1></div></div></div><a class="indexterm" id="id12"/><p>Doctest will be the mainstay of your testing toolkit. You'll be using it for tests, of course, but also for things that you may not think of as tests right now. For example, program specifications and API documentation both benefit from being written as doctests and checked alongside your other tests.</p><p>Like program source code, doctest tests are written in plain text. Doctest extracts the tests and ignores the rest of the text, which means that the tests can be embedded in human-readable explanations or discussions. This is the feature that makes doctest so suitable for non-classical uses such as program specifications.</p></div></div>
<div class="section" title="Time for action &#x2013; creating and running your first doctest"><div class="titlepage"><div><div><h1 class="title"><a id="ch02lvl1sec13"/>Time for action – creating and running your first doctest</h1></div></div></div><a class="indexterm" id="id13"/><p>We'll create a simple doctest, to demonstrate the fundamentals of using doctest.</p><div class="orderedlist"><ol class="orderedlist arabic"><li class="listitem">Open a new text file in your editor, and name it <code class="literal">test.txt</code>.</li><li class="listitem">Insert the following text into the file:<div class="informalexample"><pre class="programlisting">This is a simple doctest that checks some of Python's arithmetic
operations.

&gt;&gt;&gt; 2 + 2
4

&gt;&gt;&gt; 3 * 3
10</pre></div></li><li class="listitem">We can now run the doctest. The details of how we do that depend on which version of Python we're using. At the command prompt, change to the directory where you saved <code class="literal">test.txt</code>.</li><li class="listitem">If you are using Python 2.6 or higher, type:<a class="indexterm" id="id14"/><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong>$ python -m doctest test.txt</strong></span>
</pre></div></li><li class="listitem">If you are using python 2.5 or lower, the above command may seem to work, but it won't produce the expected result. This is because Python 2.6 is the first version in which doctest looks for test file names on the command line when you invoke it this way.</li><li class="listitem">If you're using an older version of Python, you can run your doctest by typing:<div class="informalexample"><pre class="programlisting">$ python -c "__import__('doctest').testfile('test.txt')"</pre></div></li><li class="listitem"><a class="indexterm" id="id15"/>When the test is run, you should see output as shown in the following screen:<div class="mediaobject"><img alt="Time for action – creating and running your first doctest" src="graphics/8846_02_01.jpg"/></div></li></ol></div><div class="section" title="What just happened?"><div class="titlepage"><div><div><h2 class="title"><a id="ch02lvl2sec10"/>
<span class="emphasis"><em>What just happened?</em></span>
</h2></div></div></div><p>You wrote a doctest file that describes a couple of arithmetic operations, and executed it to check whether Python behaved as the tests said it should. You ran the tests by telling Python to execute doctest on the files that contained the tests.</p><p>In this case, Python's behavior differed from the tests because according to the tests, three times three equals ten! However, Python disagrees on that. As doctest expected one thing and Python did something different, doctest presented you with a nice little error report showing where to find the failed test, and how the actual result differed from the expected result. At the bottom of the report, is a summary showing how many tests failed in each file tested, which is helpful when you have more than one file containing tests.</p><p>Remember, doctest files are for computer and human consumption. Try to write the test code in a way that human readers can easily understand, and add in plenty of plain language commentary.</p></div><div class="section" title="The syntax of doctests"><div class="titlepage"><div><div><h2 class="title"><a id="ch02lvl2sec11"/>The syntax of doctests</h2></div></div></div><p><a class="indexterm" id="id16"/>You might have guessed from looking at the previous example: doctest recognizes tests by looking for sections of text that look like they've been copied and pasted from a Python interactive session. Anything that can be expressed in Python is valid within a doctest.</p><p>Lines that start with a <code class="literal">&gt;&gt;&gt;</code> prompt are sent to a Python interpreter. Lines that start with a <code class="literal">...</code> prompt are sent as continuations of the code from the previous line, allowing you to embed complex block statements into your doctests. Finally, any lines that don't start with <code class="literal">&gt;&gt;&gt;</code> or <code class="literal">...</code>, up to the next blank line or <code class="literal">&gt;&gt;&gt;</code> prompt, represent the output expected from the statement. The output appears as it would in an interactive Python session, including both the return value and the one printed to the console. If you don't have any output lines, doctest assumes it to mean that the statement is expected to have no visible result on the console.</p><p>Doctest ignores anything in the file that isn't part of a test, which means that you can place explanatory text, HTML, line-art diagrams, or whatever else strikes your fancy in between your tests. We took advantage of that in the previous doctest, to add an explanatory sentence before the test itself.</p></div></div>
<div class="section" title="Time for action &#x2013; writing a more complex test"><div class="titlepage"><div><div><h1 class="title"><a id="ch02lvl1sec14"/>Time for action – writing a more complex test</h1></div></div></div><p><a class="indexterm" id="id17"/>We'll write another test (you can add it to <code class="literal">test.txt</code> if you like) which shows off most of the details of doctest syntax.</p><div class="orderedlist"><ol class="orderedlist arabic"><li class="listitem">Insert the following text into your doctest file (<code class="literal">test.txt</code>), separated from the existing tests by at least one blank line:<div class="informalexample"><pre class="programlisting">Now we're going to take some more of doctest's syntax for a spin.

&gt;&gt;&gt; import sys
&gt;&gt;&gt; def test_write():
...     sys.stdout.write("Hello\n")
...     return True
&gt;&gt;&gt; test_write()
Hello
True</pre></div><p>Think about it for a moment: What does this do? Do you expect the test to pass, or to fail?</p></li><li class="listitem"><a class="indexterm" id="id18"/>Run doctest on the test file, just as we discussed before. Because we added the new tests to the same file containing the tests from before, we still see the notification that three times three does not equal ten. Now, though, we also see that five tests were run, which means our new tests ran and succeeded.<div class="mediaobject"><img alt="Time for action – writing a more complex test" src="graphics/8846_02_02.jpg"/></div></li></ol></div><div class="section" title="What just happened?"><div class="titlepage"><div><div><h2 class="title"><a id="ch02lvl2sec12"/>
<span class="emphasis"><em>What just happened?</em></span>
</h2></div></div></div><p>As far as doctest is concerned, we added three tests to the file.</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">The first one says that when we <code class="literal">import sys</code>, nothing visible should happen.</li><li class="listitem" style="list-style-type: disc">The second test says that when we define the <code class="literal">test_write</code> function, nothing visible should happen.</li><li class="listitem" style="list-style-type: disc">The third test says that when we call the <code class="literal">test_write</code> function, <span class="strong"><strong>Hello</strong></span> and <span class="strong"><strong>True</strong></span> should appear on the console, in that order, on separate lines.</li></ul></div><p>Since all three of these tests pass, doctest doesn't bother to say much about them. All it did was increase the number of tests reported at the bottom from two to five.</p></div><div class="section" title="Expecting exceptions"><div class="titlepage"><div><div><h2 class="title"><a id="ch02lvl2sec13"/>Expecting exceptions</h2></div></div></div><p><a class="indexterm" id="id19"/>That's all well and good for testing that things work as expected, but it is just as important to make sure that things fail when they're supposed to fail. Put another way; sometimes your code is supposed to raise an exception, and you need to be able to write tests that check that behavior as well.</p><p>Fortunately, doctest follows nearly the same principle in dealing with exceptions, that it does with everything else; it looks for text that looks like a Python interactive session. That means it looks for text that looks like a Python exception report and traceback, matching it against any exception that gets raised.</p><p>Doctest does handle exceptions a little differently from other tools. It doesn't just match the text precisely and report a failure if it doesn't match. Exception tracebacks tend to contain many details that are not relevant to the test, but which can change unexpectedly. Doctest deals with this by ignoring the traceback entirely: it's only concerned with the first line—<span class="strong"><strong>Traceback (most recent call last)</strong></span>—which tells it that you expect an exception, and the part after the traceback, which tells it which exception you expect. Doctest only reports a failure if one of these parts does not match.</p><p>That's helpful for a second reason as well: manually figuring out what the traceback would look like, when you're writing your tests would require a significant amount of effort, and would gain you nothing. It's better to simply omit them.</p></div></div>
<div class="section" title="Time for action &#x2013; expecting an exception"><div class="titlepage"><div><div><h1 class="title"><a id="ch02lvl1sec15"/>Time for action – expecting an exception</h1></div></div></div><p><a class="indexterm" id="id20"/>This is yet another test that you can add to <code class="literal">test.txt</code>, this time testing some code that ought to raise an exception.</p><div class="orderedlist"><ol class="orderedlist arabic"><li class="listitem">Insert the following text into your doctest file (Please note that the last line of this text has been wrapped due to the constraints of the book's format, and should be a single line):<div class="informalexample"><pre class="programlisting">Here we use doctest's exception syntax to check that Python is correctly enforcing its grammar.

&gt;&gt;&gt; def faulty():
...     yield 5
...     return 7
Traceback (most recent call last):
SyntaxError: 'return' with argument inside generator (&lt;doctest test.txt[5]&gt;, line 3)</pre></div></li><li class="listitem">The test is supposed to raise an exception, so it will fail if it doesn't raise the exception, or if it raises the wrong exception. Make sure you have your mind wrapped around that: if the test code executes successfully, the test fails, because it expected an exception.</li><li class="listitem">Run the tests using doctest and the following screen will be displayed:<div class="mediaobject"><img alt="Time for action – expecting an exception" src="graphics/8846_02_03.jpg"/></div><a class="indexterm" id="id21"/></li></ol></div><div class="section" title="What just happened?"><div class="titlepage"><div><div><h2 class="title"><a id="ch02lvl2sec14"/>
<span class="emphasis"><em>What just happened?</em></span>
</h2></div></div></div><p>Since Python doesn't allow a function to contain both yield statements and return statements with values, having the test to define such a function caused an exception. In this case, the exception was a <code class="literal">SyntaxError</code> with the expected value. As a result, doctest considered it a match with the expected output, and thus the test passed. When dealing with exceptions, it is often desirable to be able to use a wildcard matching mechanism. Doctest provides this facility through its ellipsis directive, which we'll discuss later.</p></div><div class="section" title="Expecting blank lines in the output"><div class="titlepage"><div><div><h2 class="title"><a id="ch02lvl2sec15"/>Expecting blank lines in the output</h2></div></div></div><p><a class="indexterm" id="id22"/>Doctest uses the first blank line to identify the end of the expected output. So what do you do, when the expected output actually contains a blank line?</p><p>Doctest handles this situation by matching a line that contains only the text <code class="literal">&lt;BLANKLINE&gt;</code> in the expected output, with a real blank line in the actual output.</p></div><div class="section" title="Using directives to control doctest"><div class="titlepage"><div><div><h2 class="title"><a id="ch02lvl2sec16"/>Using directives to control doctest</h2></div></div></div><p><a class="indexterm" id="id23"/>Sometimes, the default behavior of doctest makes writing a particular test inconvenient. That's where doctest directives come to our rescue. Directives are specially formatted comments that you place after the source code of a test, which tell doctest to alter its default behavior in some way.</p><p>A directive comment begins with <code class="literal"># doctest:</code>, after which comes a comma-separated list of options, that either enable or disable various behaviors. To enable a behavior, write a <code class="literal">+</code> (plus symbol) followed by the behavior name. To disable a behavior, white a <code class="literal">–</code> (minus symbol) followed by the behavior name.</p><div class="section" title="Ignoring part of the result"><div class="titlepage"><div><div><h3 class="title"><a id="ch02lvl3sec01"/>Ignoring part of the result</h3></div></div></div><p>It's fairly common that only part of the output of a test is actually relevant to determining whether the test passes. By using the <code class="literal">+ELLIPSIS</code> directive, you can make doctest treat the text <code class="literal">...</code> (called an ellipsis) in the expected output as a wildcard, which will match any text in the output.</p><p>When you use an ellipsis, doctest will scan ahead until it finds text matching whatever comes after the ellipsis in the expected output, and continue matching from there. This can lead to surprising results such as an ellipsis matching against a 0-length section of the actual output, or against multiple lines. For this reason, it needs to be used thoughtfully.</p></div></div></div>
<div class="section" title="Time for action &#x2013; using ellipsis in tests"><div class="titlepage"><div><div><h1 class="title"><a id="ch02lvl1sec16"/>Time for action – using ellipsis in tests</h1></div></div></div><p><a class="indexterm" id="id24"/>
<a class="indexterm" id="id25"/>We'll use the ellipsis in a few different tests, to get a better feel for what it does and how to use it.</p><div class="orderedlist"><ol class="orderedlist arabic"><li class="listitem">Insert the following text into your doctest file:<div class="informalexample"><pre class="programlisting">Next up, we're exploring the ellipsis.

&gt;&gt;&gt; sys.modules # doctest: +ELLIPSIS
{...'sys': &lt;module 'sys' (built-in)&gt;...}

&gt;&gt;&gt; 'This is an expression that evaluates to a string'
... # doctest: +ELLIPSIS
'This is ... a string'
&gt;&gt;&gt; 'This is also a string' # doctest: +ELLIPSIS
'This is ... a string'

&gt;&gt;&gt; import datetime
&gt;&gt;&gt; datetime.datetime.now().isoformat() # doctest: +ELLIPSIS
    '...-...-...T...:...:...'</pre></div></li><li class="listitem">Run the tests using doctest and the following screen is displayed:.<div class="mediaobject"><img alt="Time for action – using ellipsis in tests" src="graphics/8846_02_04.jpg"/></div></li><li class="listitem">None of these tests would pass without the ellipsis. Think about that, and then try making some changes and see if they produce the results you expect.</li></ol></div><div class="section" title="What just happened?"><div class="titlepage"><div><div><h2 class="title"><a id="ch02lvl2sec17"/>
<span class="emphasis"><em><a class="indexterm" id="id26"/>
<a class="indexterm" id="id27"/>What just happened?
</em></span>
</h2></div></div></div><p>We just saw how to enable ellipsis matching. In addition, we saw a couple of variations on where the doctest directive comment can be placed, including on a block continuation line by itself.</p><p>We got a chance to play with the ellipsis a little bit, and hopefully saw why it should be used carefully. Look at that last test. Can you imagine any output that wasn't an ISO-formatted time stamp, but that it would match anyway?</p><div class="section" title="Ignoring whitespace"><div class="titlepage"><div><div><h3 class="title"><a id="ch02lvl3sec02"/>Ignoring whitespace</h3></div></div></div><p><a class="indexterm" id="id28"/>Sometimes, whitespace (spaces, tabs, newlines, and their ilk) are more trouble than they're worth. Maybe you want to be able to break a single line of expected output across several lines in your test file, or maybe you're testing a system that uses lots of whitespace but doesn't convey any useful information with it.</p><p>Doctest gives you a way to "normalize" whitespace, turning any sequence of  whitespace characters, in both the expected output and in the actual output, into a single space. It then checks whether these normalized versions match.</p></div></div></div>
<div class="section" title="Time for action &#x2013; normalizing whitespace"><div class="titlepage"><div><div><h1 class="title"><a id="ch02lvl1sec17"/>Time for action – normalizing whitespace</h1></div></div></div><p>We'll write a couple tests that demonstrate how whitespace normalization works.</p><div class="orderedlist"><ol class="orderedlist arabic"><li class="listitem">Insert the following text into your doctest file:<div class="informalexample"><pre class="programlisting">Next, a demonstration of whitespace normalization.

&gt;&gt;&gt; [1, 2, 3, 4, 5, 6, 7, 8, 9]
... # doctest: +NORMALIZE_WHITESPACE
[1, 2, 3,
 4, 5, 6,
 7, 8, 9]

&gt;&gt;&gt; sys.stdout.write("This text\n contains weird     spacing.")
... # doctest: +NORMALIZE_WHITESPACE
This text contains weird spacing.</pre></div></li><li class="listitem">Run the tests using doctest and the following screen is displayed:<div class="mediaobject"><img alt="Time for action – normalizing whitespace" src="graphics/8846_02_05.jpg"/></div></li><li class="listitem">Notice how one of the tests inserts extra whitespace in the expected output, while the other one ignores extra whitespace in the actual output. When you use <code class="literal">+NORMALIZE_WHITESPACE</code>, you gain a lot of flexibility with regard to how things are formatted in the text file.</li></ol></div><div class="section" title="Skipping an example entirely"><div class="titlepage"><div><div><h2 class="title"><a id="ch02lvl3sec03"/>Skipping an example entirely</h2></div></div></div><p>On some <a class="indexterm" id="id29"/>occasions, doctest would recognize some text as an example to be checked, when in truth you want it to be simply text. This situation is rarer than it might at first seem, because usually there's no harm in letting doctest check everything it can. In fact, it is usually helpful to have doctest check everything it can. For those times when you want to limit what doctest checks, though, there's the <code class="literal">+SKIP</code> directive.</p></div></div>
<div class="section" title="Time for action &#x2013; skipping tests"><div class="titlepage"><div><div><h1 class="title"><a id="ch02lvl1sec18"/>Time<a class="indexterm" id="id30"/> for action – skipping tests
</h1></div></div></div><p>This <a class="indexterm" id="id31"/>is an example of how to skip a test:</p><div class="orderedlist"><ol class="orderedlist arabic"><li class="listitem">Insert the following text into your doctest file:<div class="informalexample"><pre class="programlisting">Now we're telling doctest to skip a test

&gt;&gt;&gt; 'This test would fail.' # doctest: +SKIP
If it were allowed to run.</pre></div></li><li class="listitem">Run the tests using doctest and the following screen will be displayed:<div class="mediaobject"><img alt="Timedoctest, controllingexample, skipping for action – skipping tests" src="graphics/8846_02_05.jpg"/></div></li><li class="listitem">Notice that the test didn't fail, and that the number of tests that were run did not change.</li></ol></div><div class="section" title="What just happened?"><div class="titlepage"><div><div><h2 class="title"><a id="ch02lvl2sec19"/>
<span class="emphasis"><em>What just happened?</em></span>
</h2></div></div></div><p>The <a class="indexterm" id="id32"/>skip directive transformed what would have been a test, into plain text(as far as doctest is concerned). Doctest never ran the test, and in fact never counted it as a test at all.</p><p>There are several situations where skipping a test might be a good idea. Sometimes, you have a test which doesn't pass (which you know doesn't pass), but which simply isn't something that should be addressed at the moment. Using the <code class="literal">skip</code> directive lets you ignore the test for a while. Sometimes, you have a section of human readable text that looks like a test to the doctest parser, even though it's really only for human consumption. The <code class="literal">skip</code> directive can be used to mark that code as not for actual testing.</p><div class="section" title="Other doctest directives"><div class="titlepage"><div><div><h3 class="title"><a id="ch02lvl3sec04"/>Other doctest directives</h3></div></div></div><p><a class="indexterm" id="id33"/>
<a class="indexterm" id="id34"/>There are a number of other directives that can be issued to adjust the behavior of doctest. They are fully documented at <a class="ulink" href="http://docs.python.org/library/doctest.html#option-flags-and-directives">http://docs.python.org/library/doctest.html#option-flags-and-directives</a>, but here is a quick overview:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc"><code class="literal">+DONT_ACCEPT_TRUE_FOR_1</code>, which makes doctest treat <code class="literal">True</code> and <code class="literal">1</code> as different values, instead of treating them as matching as it normally does.</li><li class="listitem" style="list-style-type: disc"><code class="literal">+DONT_ACCEPT_BLANKLINE</code>, which makes doctest forget about the special meaning of <code class="literal">&lt;BLANKLINE&gt;</code>.</li><li class="listitem" style="list-style-type: disc"><code class="literal">+IGNORE_EXCEPTION_DETAIL</code>, which makes doctest treat exceptions as matches if the exception type is the same, regardless of whether the rest of the exception matches.</li><li class="listitem" style="list-style-type: disc"><code class="literal">+REPORT_UDIFF</code>, which makes doctest use <code class="literal">unified diff</code> format when it displays a failed test. This is useful if you are used to reading the <code class="literal">unified diff</code> format, which is by far the most common diff format within the open source community.</li><li class="listitem" style="list-style-type: disc"><code class="literal">+REPORT_CDIFF</code>, which makes doctest use <code class="literal">context diff</code> format when it displays a failed test. This is useful if you are used to reading the <code class="literal">context diff</code> format.</li><li class="listitem" style="list-style-type: disc"><code class="literal">+REPORT_NDIFF</code>, which makes doctest use <code class="literal">ndiff</code> format when it displays a failed test. This is usefull if you are used to reading the <code class="literal">ndiff</code> format.</li><li class="listitem" style="list-style-type: disc"><code class="literal">+REPORT_ONLY_FIRST_FAILURE</code> makes doctest avoid printing out failure reports on those tests after it is applied, if a failure report has already been printed. The tests are still executed, and doctest still keeps track of whether they failed or not. Only the report is changed by using this flag.</li></ul></div></div></div><div class="section" title="Execution scope"><div class="titlepage"><div><div><h2 class="title"><a id="ch02lvl2sec20"/>Execution scope</h2></div></div></div><p><a class="indexterm" id="id35"/>
<a class="indexterm" id="id36"/>When doctest is running the tests from text files, all the tests from the same file are run in the same execution scope. That means that if you import a module or bind a variable in one test, that module or variable is still available in later tests. We took advantage of this fact several times in the tests written so far in this chapter: the <code class="literal">sys</code> module was only imported once, for example, although it was used in several tests.</p><p>That behavior is not necessarily beneficial, because tests need to be isolated from each other. We don't want them to contaminate each other, because if a test depends on something that another test does, or if it fails because of something that another test does, those two tests are in some sense turned into one test that covers a larger section of your code. You don't want that to happen, because knowing which test has failed doesn't give you as much information about what went wrong and where it happened.</p><p>So, how can we give each test its own execution scope? There are a few ways to do it. One would be to simply place each test in its own file, along with whatever explanatory text that is needed. This works beautifully, but running the tests can be a pain unless you have a tool to find and run all of them. We'll talk about one such tool (called nose) later.</p><p>Another way to give each test its own execution scope, is to define each test within a function, as shown below:</p><div class="informalexample"><pre class="programlisting">&gt;&gt;&gt; def test1():
...     import frob
...     return frob.hash('qux')
&gt;&gt;&gt; test1()
77</pre></div><p>By doing that, the only thing that ends up in the shared scope is the test function (named <code class="literal">test1</code> here). The <a class="indexterm" id="id37"/>
<a class="indexterm" id="id38"/><code class="literal">frob</code> module, and any other names bound inside the function, are isolated.</p><p>The <a class="indexterm" id="id39"/>third way is to exercise caution with the names you create, and be sure to set them to known values at the beginning of each test section. In many ways this is the easiest approach, but it's also the one that places the most burden on you, because you have to keep track of what's in the scope.</p><p>Why does doctest behave this way, instead of isolating tests from each other? Doctest files are intended not just for computers to read, but also for humans. They often form a sort of narrative, flowing from one thing to the next. It would break the narrative to be constantly repeating what came before. In other words, this approach is a compromise between being a document and being a test framework, a middle ground that works for both humans and computers.</p><p>The other framework that we study in depth in this book (called simply unittest) works at a more formal level, and enforces the separation between tests.</p></div><div class="section" title="Pop quiz – doctest syntax"><div class="titlepage"><div><div><h2 class="title"><a id="ch02lvl2sec21"/>Pop quiz – doctest syntax</h2></div></div></div><p>There is no answer key for these questions. Try your answers in doctest and see if you're right!</p><div class="orderedlist"><ol class="orderedlist arabic"><li class="listitem">How does doctest recognize the beginning of a test expression?</li><li class="listitem">How does doctest know where the expected output of a text expression begins and ends?</li><li class="listitem">How would you tell doctest that you want to break a long expected output across multiple lines, even though that's not how the test actually outputs it?</li><li class="listitem">Which parts of an exception report are ignored by doctest?</li><li class="listitem">When you bind a variable in a test file, what code can "see" that variable?</li><li class="listitem">Why do we care what code can see a variable created by a test?</li><li class="listitem">How can we make doctest not care what a section of output contains?</li></ol></div></div><div class="section" title="Have a go hero – from English to doctest"><div class="titlepage"><div><div><h2 class="title"><a id="ch02lvl2sec22"/>Have a go hero – from English to doctest</h2></div></div></div><p>Time to stretch your wings a bit! I'm going to give you a description of a single function, in English. Your job is to copy the description into a new text file, and then add tests that describe all the requirements in a way in which the computer can understand and check.</p><p>Try to make the doctests that are not just for the computer. Good doctests tend to clarify things for human readers as well. By and large, that means that you present them to human readers as examples interspersed with the text.</p><p>Without further ado, here is the English description:</p><div class="informalexample"><pre class="programlisting">The fib(N) function takes a single integer as its only parameter N. If N is 0 or 1, the function returns 1. If N is less than 0, the function raises a ValueError. Otherwise, the function returns the sum of fib(N – 1) and fib(N – 2). The returned value will never be less than 1. On versions of Python older than 2.2, and if N is at least 52, the function will raise an OverflowError. A naïve implementation of this function would get very slow as N increased.</pre></div><p>I'll give you a hint and point out that the last sentence—about the function being slow—isn't really testable. As computers get faster, any test you write that depends on an arbitrary definition of "slow" will eventually fail. Also, there's no good way to test the difference between a slow function and a function stuck in an infinite loop, so there's no point in trying. If you find yourself needing to do that, it's best to back off and try a different solution.</p><div class="note" style="" title="Note"><div class="inner"><h3 class="title"><a id="note02"/>Note</h3><p>Not being able to tell whether a function is stuck or just slow is called the Halting Problem by computer scientists. We know that it can't be solved unless we someday discover a fundamentally better kind of computer. Faster computers won't do the trick, and neither will quantum computers, so don't hold your breath!</p></div></div></div></div>
<div class="section" title="Embedding doctests in Python docstrings"><div class="titlepage"><div><div><h1 class="title"><a id="ch02lvl1sec19"/>Embedding doctests in Python docstrings</h1></div></div></div><a class="indexterm" id="id40"/><a class="indexterm" id="id41"/><p>Doctests aren't confined to simple text files. You can put doctests into Python's docstrings.</p><p>Why would you want to do that? There are a couple of reasons. First of all, docstrings are an important part of the usability of Python code (but only if they tell the truth). If the behavior of a function, method, or module changes and the docstring doesn't get updated, then the docstring becomes misinformation, and a hindrance rather than a help. If the docstring contains a couple of doctest examples, then the out-of-date docstrings can be located automatically. Another reason for placing doctest examples into docstrings is simply that it can be very convenient. This practice keeps the tests, documentation and code all in the same place, where it can all be located easily.</p><p>If the docstring becomes home to too many tests, this can destroy its utility as documentation. This should be avoided; if you find yourself with so many tests in the docstrings that they aren't useful as a quick reference, move most of them to a separate file. <a class="indexterm" id="id42"/>
<a class="indexterm" id="id43"/>
</p></div>
<div class="section" title="Time for action &#x2013; embedding a doctest in a docstring"><div class="titlepage"><div><div><h1 class="title"><a id="ch02lvl1sec20"/>Time for action – embedding a doctest in a docstring</h1></div></div></div><a class="indexterm" id="id44"/><a class="indexterm" id="id45"/><p>We'll embed a test right inside the Python source file that it tests, by placing it inside a docstring.</p><div class="orderedlist"><ol class="orderedlist arabic"><li class="listitem">Create a file called <code class="literal">test.py</code> with the following contents:<div class="informalexample"><pre class="programlisting">def testable(x):
    r"""
    The `testable` function returns the square root of its
    parameter, or 3, whichever is larger.
    &gt;&gt;&gt; testable(7)
    3.0
    &gt;&gt;&gt; testable(16)
    4.0
    &gt;&gt;&gt; testable(9)
    3.0
    &gt;&gt;&gt; testable(10) == 10 ** 0.5
    True
    """
    if x &lt; 9:
        return 3.0
    return x ** 0.5</pre></div></li><li class="listitem">At the command prompt, change to the directory where you saved <code class="literal">test.py</code> and then run the tests by typing:<div class="informalexample"><pre class="programlisting">
<span class="strong"><strong>$ python -m doctest test.py</strong></span>
</pre></div><div class="note" style="" title="Note"><div class="inner"><h3 class="title"><a id="note03"/>Note</h3><p>As mentioned earlier before, if you have an older version of Python, this isn't going to work for you. Instead, you need to type <code class="literal">python -c "__import__('doctest').testmod(__import__('test'))"</code>
</p></div></div></li><li class="listitem">If everything worked, you shouldn't see anything at all. If you want some confirmation that doctest is doing something, turn on verbose reporting by changing the command to:<a class="indexterm" id="id46"/><a class="indexterm" id="id47"/><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong>python -m doctest -v test.py</strong></span>
</pre></div></li></ol></div><div class="note" style="" title="Note"><div class="inner"><h3 class="title"><a id="note04"/>Note</h3><p>For older versions of Python, instead use <code class="literal">python -c "__import__('doctest').testmod(__import__('test'), verbose=True)"</code>
</p></div></div><div class="section" title="What just happened?"><div class="titlepage"><div><div><h2 class="title"><a id="ch02lvl2sec23"/>
<span class="emphasis"><em>What just happened?</em></span>
</h2></div></div></div><p>You put the doctest right inside the docstring of the function it was testing. This is a good place for tests that also show a user how to do something. It's not a good place for detailed, low-level tests (the above example, which was quite detailed for illustrative purposes, is skirting the edge of being too detailed), because docstrings need to serve as API documentation. You can see the reason for this just by looking back at the example, where the doctests take up most of the room in the docstring, without telling the readers any more than they would have learned from a single test.</p><p>Any test that will serve as good API documentation is a good candidate for including in the docstrings.</p><p>Notice the use of a raw string for the docstring (denoted by the <code class="literal">r</code> character before the first triple-quote). Using raw strings for your docstrings is a good habit to get into, because you usually don't want escape sequences—e.g. <code class="literal">\n</code> for newline—to be interpreted by the Python interpreter. You want them to be treated as text, so that they are correctly passed on to doctest.<a class="indexterm" id="id48"/>
</p></div><div class="section" title="Doctest directives"><div class="titlepage"><div><div><h2 class="title"><a id="ch02lvl2sec24"/>Doctest directives</h2></div></div></div><a class="indexterm" id="id49"/><p>Embedded doctests can accept exactly the same directives as doctests in text files can, using exactly the same syntax. Because of this, all of the doctest directives that we discussed before can also be used to affect the way embedded doctests are evaluated.</p></div><div class="section" title="Execution scope"><div class="titlepage"><div><div><h2 class="title"><a id="ch02lvl2sec25"/>Execution scope</h2></div></div></div><a class="indexterm" id="id50"/><p>Doctests embedded in docstrings have a somewhat different execution scope than doctests in text files do. Instead of having a single scope for all of the tests in the file, doctest creates a single scope for each docstring. All of the tests that share a docstring, also share an execution scope, but they're isolated from tests in other docstrings.</p><p>The separation of each docstring into its own execution scope often means that we don't need to put much thought into isolating doctests, when they're embedded in docstrings. That is fortunate, since docstrings are primarily intended for documentation, and the tricks needed to isolate the tests might obscure the meaning.</p></div></div>
<div class="section" title="Putting it in practice: an AVL tree"><div class="titlepage"><div><div><h1 class="title"><a id="ch02lvl1sec21"/>Putting it in practice: an AVL tree</h1></div></div></div><a class="indexterm" id="id51"/><p>We'll walk step-by-step through the process of using doctest to create a testable specification for a data structure called an AVL Tree. An AVL tree is a way to organize key-value pairs, so that they can be quickly located by key. In other words, it's a lot like Python's built-in dictionary type. The name AVL references the initials of the people who invented this data structure.</p><p>As its name suggests, an AVL tree organizes the keys that are stored in it into a tree <a class="indexterm" id="id52"/>structure, with each key having up to two <span class="strong"><strong>child</strong></span> keys—one <span class="strong"><strong>child</strong></span> key that is less than the <span class="strong"><strong>parent</strong></span> key by comparison, and one that is more. In the following picture, the key <span class="strong"><strong>Elephant</strong></span> has two child keys, <span class="strong"><strong>Goose</strong></span> has one, and <span class="strong"><strong>Aardvark</strong></span> and <span class="strong"><strong>Frog</strong></span> both have none.</p><div class="mediaobject"><img alt="Putting it in practice: an AVL tree" src="graphics/8846_02_06.jpg"/></div><p>The AVL tree is special, because it keeps one side of the tree from getting much taller than the other, which means that users can expect it to perform reliably and efficiently no matter what. In the previous image, an AVL tree would reorganize to stay balanced if <span class="strong"><strong>Frog</strong></span> gained a child.</p><p>We'll write tests for an AVL tree implementation here, rather than writing the implementation itself. Therefore, we'll elaborate over the details of <span class="emphasis"><em>how</em></span> an AVL tree works, in favor of looking at what it should do when it works right.</p><div class="note" style="" title="Note"><div class="inner"><h3 class="title"><a id="note05"/>Note</h3><p>If you want to know more about AVL Trees, you will find many good references on the Internet. Wikipedia's entry on the subject is a good place to start with: <a class="ulink" href="http://en.wikipedia.org/wiki/AVL_tree">http://en.wikipedia.org/wiki/AVL_tree</a>.</p></div></div><p><a class="indexterm" id="id53"/>We'll start with a plain language specification, and then interject tests between the paragraphs.</p><div class="note" style="" title="Note"><div class="inner"><h3 class="title"><a id="tip02"/>Tip</h3><p>You don't have to actually type all of this into a text file; it is here for you to read and to think about. It's also available in the code download that accompanies this book.</p></div></div><div class="section" title="English specification"><div class="titlepage"><div><div><h2 class="title"><a id="ch02lvl2sec26"/>English specification</h2></div></div></div><p><a class="indexterm" id="id54"/>The first step is to describe what the desired result should be, in normal language. This might be something that you do for yourself, or something that somebody else does for you. If you're working for somebody, hopefully you and your employer can sit down together and work this part out.</p><p>In this case, there's not much to work out, because AVL Trees have been fully described for decades. Even so, the description here isn't quite like one you'd find anywhere else. This capacity for ambiguity is exactly the reason why a plain language specification isn't good enough. We need an unambiguous specification, and that's exactly what the tests in a doctest file can give us.</p><p>The following text goes in a file called <code class="literal">AVL.txt</code>, (which you can find in its final form in the accompanying code archive. At this stage of the process, the file contains only the normal language specification.):</p><div class="informalexample"><pre class="programlisting">An AVL Tree consists of a collection of nodes organized in a binary tree structure. Each node has left and right children, each of which may be either None or another tree node. Each node has a key, which must be comparable via the less-than operator. Each node has a value. Each node also has a height number, measuring how far the node is from being a leaf of the tree -- a node with height 0 is a leaf.

The binary tree structure is maintained in ordered form, meaning that of a node's two children, the left child has a key that compares less than the node's key and the right child has a key that compares greater than the node's key.

The binary tree structure is maintained in a balanced form, meaning that for any given node, the heights of its children are either the same or only differ by 1.

The node constructor takes either a pair of parameters representing a key and a value, or a dict object representing the key-value pairs with which to initialize a new tree.

The following methods target the node on which they are called, and can be considered part of the internal mechanism of the tree:

Each node has a recalculate_height method, which correctly sets the height number.

Each node has a make_deletable method, which exchanges the positions of the node and one of its leaf descendants, such that the the tree ordering of the nodes remains correct.

Each node has rotate_clockwise and rotate_counterclockwise methods. Rotate_clockwise takes the node's right child and places it where the node was, making the node into the left child of its own former child. Other nodes in the vicinity are moved so as to maintain the tree ordering. The opposite operation is performed by rotate_counterclockwise.

Each node has a locate method, taking a key as a parameter, which searches the node and its descendants for a node with the specified key, and either returns that node or raises a KeyError.

The following methods target the whole tree rooted at the current node. The intent is that they will be called on the root node:

<a class="indexterm" id="id55"/>
<a class="indexterm" id="id56"/>Each node has a get method taking a key as a parameter, which locates the value associated with the specified key and returns it, or raises KeyError if the key is not associated with any value in the tree.

Each node has a set method taking a key and a value as parameters, and associating the key and value within the tree.

Each node has a remove method taking a key as a parameter, and removing the key and its associated value from the tree. It raises KeyError if no values was associated with that key.</pre></div></div><div class="section" title="Node data"><div class="titlepage"><div><div><h2 class="title"><a id="ch02lvl2sec27"/>Node data</h2></div></div></div><p><a class="indexterm" id="id57"/>
<a class="indexterm" id="id58"/>The first three paragraphs of the specification describe the member variables of a AVL tree node, and tell us what the valid values for the variables are. They also tell us how tree height should be measured and define what a balanced tree means. It's our job now to take up those ideas, and encode them into tests that the computer can eventually use to check our code.</p><p>We could check these specifications by creating a node and then testing the values, but that would really just be a test of the constructor. It's important to test the constructor, but what we really want to do is to incorporate checks that the node variables are left in a valid state into our tests of each member function.</p><p>To that end, we'll define a function that our tests can call to check that the state of a node is valid. We'll define that function just after the third paragraph:</p><div class="note" style="" title="Note"><div class="inner"><h3 class="title"><a id="note06"/>Note</h3><p>Notice that this test is written as if the AVL tree implementation already existed. It tries to import an <code class="literal">avl_tree</code> module containing an <code class="literal">AVL</code> class, and it tries to use the <code class="literal">AVL</code> class is specific ways. Of course, at the moment there is no <code class="literal">avl_tree</code> module, so the test will fail. That's as it should be. All that the failure means is that, when the time comes to implement the tree, we should do so in a module called <code class="literal">avl_tree</code>, with contents that function as our test assumes. Part of the benefit of testing like this is being able to test-drive your code before you even write it.</p></div></div><div class="informalexample"><pre class="programlisting">&gt;&gt;&gt; from avl_tree import AVL
<a class="indexterm" id="id59"/>
&gt;&gt;&gt; def valid_state(node):
...     if node is None:
...         return
...     if node.left is not None:
...         assert isinstance(node.left, AVL)
...         assert node.left.key &lt; node.key
...         left_height = node.left.height + 1
...     else:
...         left_height = 0
...
...     if node.right is not None:
...         assert isinstance(node.right, AVL)
...         assert node.right.key &gt; node.key
...         right_height = node.right.height + 1
...     else:
...         right_height = 0
...
...     assert abs(left_height - right_height) &lt; 2
...     node.key &lt; node.key
...     node.value

&gt;&gt;&gt; def valid_tree(node):
...     if node is None:
...         return
...     valid_state(node)
...     valid_tree(node.left)
...     valid_tree(node.right)</pre></div><p><a class="indexterm" id="id60"/>
<a class="indexterm" id="id61"/>Notice that we didn't actually call those functions yet. They aren't tests, per se, but tools that we'll use to simplify writing tests. We define them here, rather than in the Python module that we're going to test, because they aren't conceptually part of the tested code, and because anyone who reads the tests will need to be able to see what the helper functions do.</p></div><div class="section" title="Constructor"><div class="titlepage"><div><div><h2 class="title"><a id="ch02lvl2sec28"/>Constructor</h2></div></div></div><p><a class="indexterm" id="id62"/>
<a class="indexterm" id="id63"/>The fourth paragraph describes the constructor for an AVL node: The node constructor takes either a pair of parameters representing a key and a value, or a <code class="literal">dict</code> object representing the key-value pairs with which to initialize a new tree.</p><p>The constructor has two possible modes of operation:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">it can either create a single initialized node</li><li class="listitem" style="list-style-type: disc">or it can create and initialize a whole tree of nodes. The test for the single node mode is easy:<div class="informalexample"><pre class="programlisting">&gt;&gt;&gt; valid_state(AVL(2, 'Testing is fun'))</pre></div></li></ul></div><p>The other mode of the constructor is a problem, because it is almost certain that it will be implemented by creating an initial tree node and then calling its set method to add the rest of the nodes. Why is that a problem? Because we don't want to test the set method here: this test should be focused entirely on whether the constructor works correctly, <span class="emphasis"><em>when everything it depends on works</em></span>.</p><div class="note" style="" title="Note"><div class="inner"><h3 class="title"><a id="tip03"/>Tip</h3><p>In other words, the tests should be able to assume that everything outside of the specific chunk of code being tested works correctly.</p></div></div><p>However, that's not always a valid assumption. So, how can we write tests for things that call on code outside of what's being tested?</p><p>There is a solution for this problem, about which we'll learn in Chapter 4. For now, we'll just leave the second mode of operation of the constructor untested.</p></div><div class="section" title="Recalculate height"><div class="titlepage"><div><div><h2 class="title"><a id="ch02lvl2sec29"/>Recalculate height</h2></div></div></div><p><a class="indexterm" id="id64"/>
<a class="indexterm" id="id65"/>The <code class="literal">recalculate_height</code> method is described in the fifth paragraph.</p><p>To test it, we'll need a tree for it to operate on, and we don't want to use the second mode of the constructor to create it. After all, that mode isn't tested at all yet, and even if it were, we want this test to be independent of it. We would prefer to make the test entirely independent of the constructor, but in this case we need to make a small exception to the rule(since it's difficult to create an object without calling its constructor in some way).</p><p>What we'll do is define a function that builds a specific tree and returns it. This function will be useful in several of our later tests as well. Using this function, testing <code class="literal">recalculate_height</code> will be easy.</p><div class="informalexample"><pre class="programlisting">&gt;&gt;&gt; def make_test_tree():
...     root = AVL(7, 'seven')
...     root.height = 2
...     root.left = AVL(3, 'three')
...     root.left.height = 1
...     root.left.right = AVL(4, 'four')
...     root.right = AVL(10, 'ten')
...     return root

&gt;&gt;&gt; tree = make_test_tree()
&gt;&gt;&gt; tree.height = 0
&gt;&gt;&gt; tree.recalculate_height()
&gt;&gt;&gt; tree.height
2</pre></div><p><a class="indexterm" id="id66"/>
<a class="indexterm" id="id67"/>The <code class="literal">make_test_tree</code> function builds a tree by manually constructing each part of it and hooking it together into a structure that looks like this:</p><div class="mediaobject"><img alt="Recalculate height" src="graphics/8846_02_07.jpg"/></div></div><div class="section" title="Make deletable"><div class="titlepage"><div><div><h2 class="title"><a id="ch02lvl2sec30"/>Make deletable</h2></div></div></div><p>You<a class="indexterm" id="id68"/> can't delete a node that has children, because that would leave the node's children disconnected from the rest of the tree. If we delete the <span class="strong"><strong>Elephant</strong></span> node from the bottom of the tree, what do we do about <span class="strong"><strong>Aardvark</strong></span>, <span class="strong"><strong>Goose</strong></span>, and <span class="strong"><strong>Frog</strong></span>? If we delete <span class="strong"><strong>Goose</strong></span>, how do we find <span class="strong"><strong>Frog</strong></span> afterwards?</p><div class="mediaobject"><img alt="Make deletable" src="graphics/8846_02_06.jpg"/></div><p>The way around that is to have the node swap places with it's largest leaf descendant on the left side (or its smallest leaf descendant on the right side, but we'll not do it that way).</p><p>We'll test this by using the same <code class="literal">make_test_tree</code> function that we defined before to create a new tree to work on, and then checking that <code class="literal">make_deletable</code> swaps correctly:</p><div class="informalexample"><pre class="programlisting">Each node has a make_deletable method, which exchanges the positions of the node and one of its leaf descendants, such that the the tree ordering of the nodes remains correct.

&gt;&gt;&gt; tree = make_test_tree()
&gt;&gt;&gt; target = tree.make_deletable()
&gt;&gt;&gt; (tree.value, tree.height)
('four', 2)
&gt;&gt;&gt; (target.value, target.height)
('seven', 0)</pre></div><div class="note" style="" title="Note"><div class="inner"><h3 class="title"><a id="note07"/>Note</h3><p><a class="indexterm" id="id69"/>Something to notice here is that the <code class="literal">make_deletable</code> function isn't supposed to delete the node that it's called on. It's supposed to move that node into a position where it could be safely deleted. It must do this reorganization of the tree, without violating any of the constraints that define an AVL tree structure.</p></div></div></div><div class="section" title="Rotation"><div class="titlepage"><div><div><h2 class="title"><a id="ch02lvl2sec31"/>Rotation</h2></div></div></div><p>The<a class="indexterm" id="id70"/>
<a class="indexterm" id="id71"/> two rotate functions perform a somewhat tricky manipulation of the links in a tree. You probably found the plain language description of what they do, a bit confusing. This is one of those times when a little bit of code makes a whole lot more sense than any number of sentences.</p><p>While tree rotation is usually defined in terms of rearranging the links between nodes in the tree, we'll check whether it worked by looking at the values (rather than by looking directly at the left and right links). This allows the implementation to swap the contents of nodes—rather than the nodes themselves—when it wishes. After all, it's not important to the specification which operation happens, so we shouldn't rule out a perfectly reasonable implementation choice.</p><p>The first part of the test code for rotation just creates a tree and verifies that it looks like we expect it to:</p><div class="informalexample"><pre class="programlisting">&gt;&gt;&gt; tree = make_test_tree()
&gt;&gt;&gt; tree.value
'seven'
&gt;&gt;&gt; tree.left.value
'three'</pre></div><p>Once we have a tree to work with, we try a rotation operation and check that the result still looks like it should:</p><div class="informalexample"><pre class="programlisting">&gt;&gt;&gt; tree.rotate_counterclockwise()
&gt;&gt;&gt; tree.value
'three'
&gt;&gt;&gt; tree.left
None
&gt;&gt;&gt; tree.right.value
'seven'
&gt;&gt;&gt; tree.right.left.value
'four'
&gt;&gt;&gt; tree.right.right.value
'ten'
&gt;&gt;&gt; tree.right.left.value
'four'
&gt;&gt;&gt; tree.left is None
True</pre></div><p>Finally, we rotate back in the other direction, and check that the final result is the same as the original tree, as we expect it to be:</p><div class="informalexample"><pre class="programlisting">&gt;&gt;&gt; tree.rotate_clockwise()
&gt;&gt;&gt; tree.value
'seven'
&gt;&gt;&gt; tree.left.value
'three'
&gt;&gt;&gt; tree.left.right.value
'four'
&gt;&gt;&gt; tree.right.value
'ten'
&gt;&gt;&gt; tree.right.left is None
True
&gt;&gt;&gt; tree.left.left is None
True<a class="indexterm" id="id72"/>
<a class="indexterm" id="id73"/>
</pre></div></div><div class="section" title="Locating a node"><div class="titlepage"><div><div><h2 class="title"><a id="ch02lvl2sec32"/>Locating a node</h2></div></div></div><a class="indexterm" id="id74"/><a class="indexterm" id="id75"/><p>The <code class="literal">locate</code> method is expected to return a node, or raise a <code class="literal">KeyError</code> exception, depending on whether the key exists in the tree or not. We'll use our specially built tree again, so that we know exactly what the tree's structure looks like.</p><div class="informalexample"><pre class="programlisting">&gt;&gt;&gt; tree = make_test_tree()
&gt;&gt;&gt; tree.locate(4).value
'four'
&gt;&gt;&gt; tree.locate(17) # doctest: +ELLIPSIS
Traceback (most recent call last):
KeyError: …</pre></div><p>The <code class="literal">locate</code> method is intended to facilitate insertion, deletion, and lookup of values based on their keys, but it's not a high-level interface. It returns a node object, because it's easy to implement the higher-level operations, if you have a function the finds the right <a class="indexterm" id="id76"/>
<a class="indexterm" id="id77"/>node for you.</p></div><div class="section" title="Testing the rest of the specification"><div class="titlepage"><div><div><h2 class="title"><a id="ch02lvl2sec33"/>Testing the rest of the specification</h2></div></div></div><p>Like the second mode of the constructor, testing the rest of the specification involves testing code that depends on things outside of itself, which we'll cover in Chapter 4.</p></div></div>
<div class="section" title="Summary"><div class="titlepage"><div><div><h1 class="title"><a id="ch02lvl1sec22"/>Summary</h1></div></div></div><p>We learned the syntax of doctest, and went through several examples describing how to use it. After that, we took a real-world specification for the AVL tree, and examined how to formalize it as a set of doctests, so that we could use it to automatically check the correctness of an implementation.</p><p>Specifically, we covered doctest's default syntax, and the directives that alter it, how to write doctests in text files, how to write doctests in Python docstrings, and what it feels like to use doctest to turn a specification into tests.</p><p>Now that we've learned about doctest, we're ready to talk about how to use doctest to do unit testing—which is the topic of the next chapter.</p></div></body></html>