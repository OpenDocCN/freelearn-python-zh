<html><head></head><body>
  <div><div><div><div><div><h1 class="title"><a id="ch02"/>Chapter 2. Responding to Events</h1></div></div></div><p>In this chapter, we will cover:</p><div><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">Handling events</li><li class="listitem" style="list-style-type: disc">Understanding event propagation</li><li class="listitem" style="list-style-type: disc">Handling Key events</li><li class="listitem" style="list-style-type: disc">Using UpdateUI events</li><li class="listitem" style="list-style-type: disc">Playing with the mouse</li><li class="listitem" style="list-style-type: disc">Creating custom event classes</li><li class="listitem" style="list-style-type: disc">Managing event handlers with EventStack</li><li class="listitem" style="list-style-type: disc">Validating input with validators</li><li class="listitem" style="list-style-type: disc">Handling Apple events</li></ul></div><div><div><div><div><h1 class="title"><a id="ch02lvl1sec01"/>Introduction</h1></div></div></div><p>In an event-driven system, events are used to connect actions within the framework to callback functions that are linked to those events. Applications that are built upon an event-driven framework make use of these events in order to know when to respond to actions that are initiated by the user or the system. In a user interface, events are the way to know when a button is clicked, when a menu has been selected, or any other one of a wide variety of actions that a user could take while interacting with the applications interface.<a id="id58" class="indexterm"/>
</p><p>As you can see, knowing how to respond to events that occur during the life of an application is a crucial part of creating a functional application. So let's dive into the event-driven world of wxPython.<a id="id59" class="indexterm"/>
</p></div></div></div>


  <div><div><div><div><div><h1 class="title"><a id="ch02lvl1sec02"/>Handling events</h1></div></div></div><p>wxPython is an event-driven system. The usage of this system is pretty straightforward and regular across the framework. The basic patterns of working with events are the same regardless of the type of control or event that your application will interact with. This recipe will introduce the basics of working in wxPython's event system.<a id="id60" class="indexterm"/>
</p><div><div><div><div><h2 class="title"><a id="ch02lvl2sec01"/>How to do it...</h2></div></div></div><p>Let's create a simple<code class="literal"> Frame</code> with two buttons in it to show how to work with events:<a id="id61" class="indexterm"/>
</p><div><pre class="programlisting">class MyFrame(wx.Frame):
    def __init__(self, parent, id=wx.ID_ANY, title="", 
                 pos=wx.DefaultPosition, size=wx.DefaultSize,
                 style=wx.DEFAULT_FRAME_STYLE,
                 name="MyFrame"):
        super(MyFrame, self).__init__(parent, id, title,
                                      pos, size, style, name)

        # Attributes
        self.panel = wx.Panel(self)

        self.btn1 = wx.Button(self.panel, label="Push Me")
        self.btn2 = wx.Button(self.panel, label="push me too")

        sizer = wx.BoxSizer(wx.HORIZONTAL)
        sizer.Add(self.btn1, 0, wx.ALL, 10)
        sizer.Add(self.btn2, 0, wx.ALL, 10)
        self.panel.SetSizer(sizer)

        self.Bind(wx.EVT_BUTTON, self.OnButton, self.btn1)
        self.Bind(wx.EVT_BUTTON,
                  lambda event:
                  self.btn1.Enable(not self.btn1.Enabled),
                  self.btn2)

    def OnButton(self, event):
        """Called when self.btn1 is clicked"""
        event_id = event.GetId()
        event_obj = event.GetEventObject()
        print "Button 1 Clicked:"
        print "ID=%d" % event_id
        print "object=%s" % event_obj.GetLabel()

</pre></div></div><div><div><div><div><h2 class="title"><a id="ch02lvl2sec02"/>How it works...</h2></div></div></div><p>The lines of code to take notice of in this recipe are the two<code class="literal"> Bind</code> calls. The<code class="literal"> Bind</code> method is used to associate an event handler function with an event that may be sent to a control. Events always propagate up the window hierarchy and never down. In this example, we bound the button event to the<code class="literal"> Frame</code>, but the events will originate from the<code class="literal"> Button</code> objects that are children of the<code class="literal"> Panel</code>. The<code class="literal"> Frame</code> object is at the top of the hierarchy containing the<code class="literal"> Panel</code>, which in turn contains the two<code class="literal"> Buttons</code>. Because of this, since the event callback is not handled by the<code class="literal"> Button</code> or the<code class="literal"> Panel</code>, it will propagate to the<code class="literal"> Frame</code> where our<code class="literal"> OnButton</code> handler will be called.<a id="id62" class="indexterm"/>
</p><p>The<code class="literal"> Bind</code> method takes two required parameters:<a id="id63" class="indexterm"/>
</p><div><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">The event binder object (<code class="literal">EVT_FOO</code>)</li><li class="listitem" style="list-style-type: disc">A callable object that takes an event object as its first parameter. This is the event handler function that will be called when the event occurs.</li></ul></div><p>The optional parameters are for specifying the originating control to bind the event handler to. We bound one handler for each of our buttons in this example by specifying the<code class="literal"> Button</code> objects as the third parameter to<code class="literal"> Bind</code>.</p><p>
<code class="literal">EVT_BUTTON</code> is the event binder for when a<code class="literal"> Button</code> is clicked by the user of the application. When the first button is clicked, the event handler<code class="literal"> OnButton</code> will be called to notify our program that this action occurred. The event object will be passed to the handler function as its first parameter. The event object has a number of methods that can be used to get information about the event and what control it came from. Each event may have different data available, depending on the type of event that is related to the type of control it originated from.</p><p>For our second<code class="literal"> Button</code>, we used a<code class="literal"> lambda</code> function as a shorthand way of creating an event-handler function without needing to define a new function. This is a handy way of handling events that only need to perform simple actions.<a id="id64" class="indexterm"/>
</p></div><div><div><div><div><h2 class="title"><a id="ch02lvl2sec03"/>See also</h2></div></div></div><div><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">The<em> Application object</em> recipe in<a class="link" href="ch01.html" title="Chapter 1. Getting Started with wxPython"> Chapter 1</a>,<em> Getting Started with wxPython</em> talks about the MainLoop, which is at the core of the event system.</li><li class="listitem" style="list-style-type: disc">The<em> Understanding the window hierarchy</em> recipe in<a class="link" href="ch01.html" title="Chapter 1. Getting Started with wxPython"> Chapter 1</a>,<em> Getting Started with wxPython</em> describes the window containment hierarchy.</li><li class="listitem" style="list-style-type: disc">The<em> Creating Stock Buttons</em> recipe in<a class="link" href="ch03.html" title="Chapter 3. Basic Building Blocks of a User Interface"> Chapter 3</a>,<em> Basic Building Blocks of a User Interface</em> explains Buttons in detail.</li><li class="listitem" style="list-style-type: disc">The<em> Using a BoxSizer</em> recipe in<a class="link" href="ch07.html" title="Chapter 7. Window Layout and Design"> Chapter 7</a>,<em> Window Layout and Design</em> explains how to use the<code class="literal"> BoxSizer</code> class to lay out controls.</li></ul></div></div></div></div>


  <div><div><div><div><div><h1 class="title"><a id="ch02lvl1sec03"/>Understanding event propagation</h1></div></div></div><p>There are two main types of Event Objects in wxPython, each with its own distinct behavior:</p><div><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">Events</li><li class="listitem" style="list-style-type: disc">Command Events</li></ul></div><p>Basic<code class="literal"> Events</code> are events that do not propagate upwards in the window hierarchy. Instead, they stay local to the window that they were sent to or originated in. The second type,<code class="literal"> CommandEvents</code>, are the more common type of events, and differ from regular events in that they propagate up the window parental hierarchy until they are handled or reach the end of the line at the application object. This recipe will explore how to work with, understand, and control the propagation of events.<a id="id65" class="indexterm"/>
</p><div><div><div><div><h2 class="title"><a id="ch02lvl2sec04"/>How to do it...</h2></div></div></div><p>To explore how events propagate, lets create another simple application:<a id="id66" class="indexterm"/>
</p><div><pre class="programlisting">import wx

ID_BUTTON1 = wx.NewId()
ID_BUTTON2 = wx.NewId()

class MyApp(wx.App):
    def OnInit(self):
        self.frame = MyFrame(None, title="Event Propagation")
        self.SetTopWindow(self.frame)
        self.frame.Show()

        self.Bind(wx.EVT_BUTTON, self.OnButtonApp)

        return True

    def OnButtonApp(self, event):
        event_id = event.GetId()
        if event_id == ID_BUTTON1:
            print "BUTTON ONE Event reached the App Object"

class MyFrame(wx.Frame):
    def __init__(self, parent, id=wx.ID_ANY, title="", 
                 pos=wx.DefaultPosition, size=wx.DefaultSize,
                 style=wx.DEFAULT_FRAME_STYLE,
                 name="MyFrame"):
        super(MyFrame, self).__init__(parent, id, title,
                                      pos, size, style, name)

        # Attributes
        self.panel = MyPanel(self)

        self.btn1 = wx.Button(self.panel, ID_BUTTON1,
                              "Propagates")
        self.btn2 = wx.Button(self.panel, ID_BUTTON2,
                              "Doesn't Propagate")

        sizer = wx.BoxSizer(wx.HORIZONTAL)
        sizer.Add(self.btn1, 0, wx.ALL, 10)
        sizer.Add(self.btn2, 0, wx.ALL, 10)
        self.panel.SetSizer(sizer)

        self.Bind(wx.EVT_BUTTON, self.OnButtonFrame)

    def OnButtonFrame(self, event):
        event_id = event.GetId()
        if event_id == ID_BUTTON1:
            print "BUTTON ONE event reached the Frame"
            event.Skip()
        elif event_id == ID_BUTTON2:
            print "BUTTON TWO event reached the Frame"
        
class MyPanel(wx.Panel):
    def __init__(self, parent):
        super(MyPanel, self).__init__(parent)

        self.Bind(wx.EVT_BUTTON, self.OnPanelButton)

    def OnPanelButton(self, event):
        event_id = event.GetId()
        if event_id == ID_BUTTON1:
            print "BUTTON ONE event reached the Panel"
            event.Skip()
        elif event_id == ID_BUTTON2:
            print "BUTTON TWO event reached the Panel"
            # Not skipping the event will cause its 
            # propagation to end here
if __name__ == "__main__":
    app = MyApp(False)
    app.MainLoop()

</pre></div><p>Running this will create an application with two buttons on it. Click each of the buttons to see how the events propagate differently.</p></div><div><div><div><div><h2 class="title"><a id="ch02lvl2sec05"/>How it works...</h2></div></div></div><p>The chain of event handlers that will be called starts at the object that the event originates from. In this case, it will be one of our two buttons. Each level in the window hierarchy of this application has a general event handler bound to it, that will receive any button events.<a id="id68" class="indexterm"/>
</p><p>Clicking the first button will show that all of the event handlers get called. This is because for the first button we called the event's<code class="literal"> Skip</code> method. Calling<code class="literal"> Skip</code> on an event will tell it to continue propagating to the next level of event handlers in the hierarchy. This will be apparent, as three statements will be printed to the console. On the other hand, clicking the second button will result in only one event handler being called, because<code class="literal"> Skip</code> is not called.</p></div><div><div><div><div><h2 class="title"><a id="ch02lvl2sec06"/>See also</h2></div></div></div><div><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">The<em> Handling events</em> recipe in this chapter explains how event handlers work.</li><li class="listitem" style="list-style-type: disc">The<em> Understanding the window hierarchy</em> recipe in<a class="link" href="ch01.html" title="Chapter 1. Getting Started with wxPython"> Chapter 1</a>,<em> Getting Started with wxPython</em> describes the window hierarchy that events propagate through.</li></ul></div></div></div></div>


  <div><div><div><div><div><h1 class="title"><a id="ch02lvl1sec04"/>Handling Key events</h1></div></div></div><p>
<code class="literal">KeyEvents</code> are events that are associated with keyboard actions. Many controls can accept keyboard events. Each time that a key is pressed on the keyboard, there will be two or three events sent to the control that has the keyboard focus, depending on what key was pressed. This recipe will create a simple text editor window, in order to demonstrate how to use<code class="literal"> KeyEvents</code> to filter text that is added to a<code class="literal"> TextCtrl</code>.<a id="id69" class="indexterm"/>
</p><div><div><div><div><h2 class="title"><a id="ch02lvl2sec07"/>How to do it...</h2></div></div></div><p>To see some<code class="literal"> KeyEvents</code> in action, let's make a simple window that has a<code class="literal"> TextCtrl</code> on it:</p><div><pre class="programlisting">class MyFrame(wx.Frame):
    def __init__(self, parent, *args, **kwargs):
        super(MyFrame, self).__init__(parent, *args, **kwargs)

        # Attributes
        self.panel = wx.Panel(self)
        self.txtctrl = wx.TextCtrl(self.panel, 
                                   style=wx.TE_MULTILINE)

        # Layout
        sizer = wx.BoxSizer(wx.HORIZONTAL)
        sizer.Add(self.txtctrl, 1, wx.EXPAND)
        self.panel.SetSizer(sizer)
        self.CreateStatusBar() # For output display

        # Event Handlers
        self.txtctrl.Bind(wx.EVT_KEY_DOWN, self.OnKeyDown)
        self.txtctrl.Bind(wx.EVT_CHAR, self.OnChar)
        self.txtctrl.Bind(wx.EVT_KEY_UP, self.OnKeyUp)

    def OnKeyDown(self, event):
        """KeyDown event is sent first"""
        print "OnKeyDown Called"
        # Get information about the event and log it to
        # the StatusBar for display.
        key_code = event.GetKeyCode()
        raw_code = event.GetRawKeyCode()
        modifiers = event.GetModifiers()
        msg = "key:%d,raw:%d,modifers:%d" % \
              (key_code, raw_code, modifiers)
        self.PushStatusText("KeyDown: " + msg)

        # Must Skip the event to allow OnChar to be called
        event.Skip()

    def OnChar(self, event):
        """The Char event comes second and is
        where the character associated with the
        key is put into the control.
        """
        print "OnChar Called"
        modifiers = event.GetModifiers()
        key_code = event.GetKeyCode()
        # Beep at the user if the Shift key is down
        # and disallow input.
        if modifiers &amp; wx.MOD_SHIFT:
            wx.Bell()
        elif chr(key_code) in "aeiou":elif unichr(key_code) in   "aeiou":
            # When a vowel is pressed append a
            # question mark to the end.
            self.txtctrl.AppendText("?")
        else:
            # Let the text go in to the buffer
            event.Skip()

    def OnKeyUp(self, event):
        """KeyUp comes last"""
        print "OnKeyUp Called"
        event.Skip()

</pre></div><p>When typing in this window, it will not allow text to be entered when the<em> Shift</em> key is pressed and it will turn all vowels into question marks.<a id="id72" class="indexterm"/>
</p></div><div><div><div><div><h2 class="title"><a id="ch02lvl2sec08"/>How it works...</h2></div></div></div><p>The<code class="literal"> KeyEvents</code> are sent by the system in the following order:<a id="id73" class="indexterm"/>
</p><div><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc"><code class="literal">EVT_KEY_DOWN</code></li><li class="listitem" style="list-style-type: disc"><code class="literal">EVT_CHAR</code> (only for keys that have a character associated with them)</li><li class="listitem" style="list-style-type: disc"><code class="literal">EVT_KEY_UP</code></li></ul></div><p>It's important to notice that we called<code class="literal"> Bind</code> on our<code class="literal"> TextCtrl</code> and not the<code class="literal"> Frame</code>. This is necessary because the<code class="literal"> KeyEvents</code> will only be sent to the control that has the keyboard focus, which in this window will be<code class="literal"> TextCtrl</code>.</p><p>Each<code class="literal"> KeyEvent</code> has a number of attributes attached to it in order to specify what key was pressed and what other modifier keys were held down during the event, such as the<em> Shift, Alt</em>, and<em> Ctrl</em> keys.</p><p>Calling<code class="literal"> Skip</code> on the event allows the control to process it and for the next handler in the chain to be called. For example, not skipping the event in the<code class="literal"> EVT_KEY_DOWN</code> handler will block the<code class="literal"> EVT_CHAR</code> and<code class="literal"> EVT_KEY_UP</code> handlers from being called.</p><p>In this sample, when a key on the keyboard is pressed, our<code class="literal"> OnKeyDown</code> handler will be called first. All we do there is<code class="literal"> print</code> a message to<code class="literal"> stdout</code> and display some information about the event in the<code class="literal"> StatusBar</code>, before calling<code class="literal"> Skip</code>. Then, in our<code class="literal"> OnChar</code> handler, we do some simple filtering of uppercase letters by checking to see if the<em> Shift key</em> is in the event's modifiers mask. If it is, we beep at the user and don't call<code class="literal"> Skip</code> on the event, in order to prevent the character from appearing in the<code class="literal"> TextCtrl</code>. Also, as an example of modifying what the event does, we perform a check for vowels by converting the raw key code into a character string and if the key was for a vowel, we simply insert a question mark into the<code class="literal"> TextCtrl</code> instead. Finally, if the event was skipped in the<code class="literal"> OnChar</code> handler, our<code class="literal"> OnKeyUp</code> handler will be called, where we simply print a message to<code class="literal"> stdout</code> to show it was called.</p></div><div><div><div><div><h2 class="title"><a id="ch02lvl2sec09"/>There's more...</h2></div></div></div><p>Some controls require the<code class="literal"> wx.WANTS_CHARS</code> style flag to be specified in their constructor in order to receive character events. The<code class="literal"> Panel</code> class is the most common example that requires this special style flag in order to receive<code class="literal"> EVT_CHAR</code> events. Often, this is used to perform special processing when creating a new custom control type that is derived from a<code class="literal"> Panel</code>.</p></div><div><div><div><div><h2 class="title"><a id="ch02lvl2sec10"/>See also</h2></div></div></div><div><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">The<em> Validating input with validators</em> recipe in this chapter uses<code class="literal"> KeyEvents</code> to perform input validation.</li></ul></div></div></div></div>


  <div><div><div><div><div><h1 class="title"><a id="ch02lvl1sec05"/>Using UpdateUI events</h1></div></div></div><p>
<code class="literal">UpdateUIEvents</code> are events that are sent by the framework on a regular basis in order to allow an application to update the state of its controls. These are useful for performing tasks such as changing when a control is enabled or disabled, based on the application's business logic. This recipe will show how to use<code class="literal"> UpdateUIEvents</code> to update the state of menu items, depending on the current context of the UI.<a id="id74" class="indexterm"/>
</p><div><div><div><div><h2 class="title"><a id="ch02lvl2sec11"/>How to do it...</h2></div></div></div><p>In this example, we create a simple window with an<code class="literal"> Edit Menu</code> and a<code class="literal"> TextCtrl</code>. The<code class="literal"> Edit Menu</code> has three items in it that will be enabled or disabled based on the current selection status in the<code class="literal"> TextCtrl</code> by using<code class="literal"> UpdateUIEvents</code>.<a id="id75" class="indexterm"/>
</p><div><pre class="programlisting">class TextFrame(wx.Frame):
    def __init__(self, parent, *args, **kwargs):
        super(TextFrame, self).__init__(parent,
                                        *args,
                                        **kwargs)

        # Attributes
        self.panel = wx.Panel(self)
        self.txtctrl = wx.TextCtrl(self.panel,
                                   value="Hello World",
                                   style=wx.TE_MULTILINE)

        # Layout
        sizer = wx.BoxSizer(wx.HORIZONTAL)
        sizer.Add(self.txtctrl, 1, wx.EXPAND)
        self.panel.SetSizer(sizer)
        self.CreateStatusBar() # For output display

        # Menu
        menub = wx.MenuBar()
        editm = wx.Menu()
        editm.Append(wx.ID_COPY, "Copy\tCtrl+C")
        editm.Append(wx.ID_CUT, "Cut\tCtrl+X")
        editm.Append(ID_CHECK_ITEM, "Selection Made?",
                     kind=wx.ITEM_CHECK)
        menub.Append(editm, "Edit")
        self.SetMenuBar(menub)

        # Event Handlers
        self.Bind(wx.EVT_UPDATE_UI, self.OnUpdateEditMenu)

    def OnUpdateEditMenu(self, event):
        event_id = event.GetId()
        sel = self.txtctrl.GetSelection()
        has_sel = sel[0] != sel[1]
        if event_id in (wx.ID_COPY, wx.ID_CUT):
            event.Enable(has_sel)
        elif event_id == ID_CHECK_ITEM:
            event.Check(has_sel)
        else:
            event.Skip()

</pre></div></div><div><div><div><div><h2 class="title"><a id="ch02lvl2sec12"/>How it works...</h2></div></div></div><p>
<code class="literal">UpdateUIEvents</code> are sent periodically by the framework during idle time to allow the application to check if the state of a control needs to be updated. Our<code class="literal"> TextFrame</code> class has three menu items in its Edit Menu that will be managed by our<code class="literal"> OnUpdateUI</code> event handler. In<code class="literal"> OnUpdateUI</code>, we check the event's ID to see which object the event is being sent for, and then call the appropriate<code class="literal"> UpdateUIEvent</code> method on the event to change the state of the control. The states of each of our menu items are dependent upon whether there is a selection in the<code class="literal"> TextCtrl</code> or not. Calling the<code class="literal"> GetSelection</code> method of<code class="literal"> TextCtrl</code> will return a tuple with the start and end positions of the selection. When the two positions differ, there is a selection in the control and we will<code class="literal"> Enable</code> the<code class="literal"> Copy</code> and<code class="literal"> Cut</code> items, or in the case of our<code class="literal"> Selection Made</code> item we will set the check mark. If there is no selection, then the items will become disabled or un-checked.<a id="id77" class="indexterm"/>
</p><p>It's important to call the method on the event object to update the control and not the method on the control itself, as it will allow for it to be updated far more efficiently. See the wxPython API documentation for<code class="literal"> UpdateUIEvent</code> to see the full listing of what methods are available.</p></div><div><div><div><div><h2 class="title"><a id="ch02lvl2sec13"/>There's more...</h2></div></div></div><p>There are some static methods available in the<code class="literal"> UpdateUIEvent</code> class that allow applications to change the behavior of how the events are delivered. Most notable are the following two methods:</p><div><ol class="orderedlist arabic"><li class="listitem"><code class="literal">wx.UpdateUIEvent.SetUpdateInterval</code></li></ol></div><div><ol class="orderedlist arabic"><li class="listitem"><code class="literal">wx.UpdateUIEvent.SetMode</code></li></ol></div><p>
<code class="literal">SetUpdateInterval</code> can be used to configure how often the<code class="literal"> UpdateUIEvents</code> are sent. It takes a number of milliseconds as an argument. This is useful if you find that there is a noticeable amount of overhead in handling<code class="literal"> UpdateUIEvents</code> in your application. You can use this to slow down the rate at which these events are sent.</p><p>
<code class="literal">SetMode</code> can be used configure the behavior of what windows will receive the events, by setting one of the following modes:<a id="id78" class="indexterm"/>
</p><div><table border="1"><colgroup><col style="text-align: left"/><col style="text-align: left"/></colgroup><thead><tr><th style="text-align: left" valign="bottom">
<p>Mode</p>
</th><th style="text-align: left" valign="bottom">
<p>Description</p>
</th></tr></thead><tbody><tr><td style="text-align: left" valign="top">
<p>
<code class="literal">wx.UPDATE_UI_PROCESS_ALL</code>
</p>
</td><td style="text-align: left" valign="top">
<p>Process<code class="literal"> UpdateUI</code> events for all windows</p>
</td></tr><tr><td style="text-align: left" valign="top">
<p>
<code class="literal">wx.UPDATE_UI_PROCESS_SPECIFIED</code>
</p>
</td><td style="text-align: left" valign="top">
<p>Only process<code class="literal"> UpdateUI</code> events for the windows that have the<code class="literal"> WS_EX_PROCESS_UI_UPDATES</code> extra style flag set.</p>
</td></tr></tbody></table></div></div><div><div><div><div><h2 class="title"><a id="ch02lvl2sec14"/>See also</h2></div></div></div><div><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">The<em> Managing event handlers with EventStack</em> recipe in this chapter shows a way to manage<code class="literal"> UpdateUI</code> events in a centralized way.</li></ul></div></div></div></div>


  <div><div><div><div><div><h1 class="title"><a id="ch02lvl1sec06"/>Playing with the mouse</h1></div></div></div><p>
<code class="literal">MouseEvents</code> can be used to interact with the mouse-position changes and mouse-button clicks that a user makes within a window. This recipe will provide a quick crash course on some of the common mouse events that are available for use in a program.<a id="id79" class="indexterm"/>
</p><div><div><div><div><h2 class="title"><a id="ch02lvl2sec15"/>How to do it...</h2></div></div></div><p>Here as an example, we will create a simple Frame class that has a<code class="literal"> Panel</code> and a Button to see how to interact with<code class="literal"> MouseEvents</code>.</p><div><pre class="programlisting">class MouseFrame(wx.Frame):
    def __init__(self, parent, *args, **kwargs):
        super(MouseFrame, self).__init__(parent,
                                         *args,
                                         **kwargs)

        # Attributes
        self.panel = wx.Panel(self)
        self.btn = wx.Button(self.panel)

        # Event Handlers
        self.panel.Bind(wx.EVT_ENTER_WINDOW, self.OnEnter)
        self.panel.Bind(wx.EVT_LEAVE_WINDOW, self.OnLeave)
        self.panel.Bind(wx.EVT_LEFT_UP, self.OnLeftUp)
        self.panel.Bind(wx.EVT_LEFT_DOWN, self.OnLeftDown)

    def OnEnter(self, event):
        """Called when the mouse enters the panel"""
        self.btn.SetForegroundColour(wx.BLACK)
        self.btn.SetLabel("EVT_ENTER_WINDOW")
        self.btn.SetInitialSize()

    def OnLeave(self, event):
        """Called when the mouse leaves the panel"""
        self.btn.SetLabel("EVT_LEAVE_WINDOW")
        self.btn.SetForegroundColour(wx.RED)

    def OnLeftDown(self, event):
        """Called for left down clicks on the Panel"""
        self.btn.SetLabel("EVT_LEFT_DOWN")
        
    def OnLeftUp(self, event):
        """Called for left clicks on the Panel"""
        position = event.GetPosition()
        self.btn.SetLabel("EVT_LEFT_UP")
        # Move the button
        self.btn.SetPosition(position - (25, 25))
</pre></div></div><div><div><div><div><h2 class="title"><a id="ch02lvl2sec16"/>How it works...</h2></div></div></div><p>In this recipe, we made use of the events for when the mouse cursor enters the<code class="literal"> Panel</code> and for when the left mouse button is clicked on the<code class="literal"> Panel</code>, to modify our<code class="literal"> Button</code>. When the mouse cursor enters a window's area, an<code class="literal"> EVT_ENTER_WINDOW</code> event will be sent to it; conversely, it will receive an<code class="literal"> EVT_LEAVE_WINDOW</code> event when the cursor leaves the window. When the mouse enters or leaves the Panel's area, we update the Button's label to show what happened. When our<code class="literal"> Panel</code> receives a left click event, we move the<code class="literal"> Button</code> to where the click took place.<a id="id82" class="indexterm"/>
</p><p>The important thing to notice is that we called<code class="literal"> Bind</code> on the<code class="literal"> Panel</code> directly and not on the<code class="literal"> Frame</code>. This is important because<code class="literal"> MouseEvents</code> are not<code class="literal"> CommandEvents</code> so they will only be sent to the window they originated from, and will not propagate up the containment hierarchy.</p></div><div><div><div><div><h2 class="title"><a id="ch02lvl2sec17"/>There's more...</h2></div></div></div><p>There are a large number of<code class="literal"> MouseEvents</code> that can be used to interact with other mouse actions. The following table contains a quick reference to each of them:</p><div><table border="1"><colgroup><col style="text-align: left"/><col style="text-align: left"/></colgroup><thead><tr><th style="text-align: left" valign="bottom">
<p>MouseEvents</p>
</th><th style="text-align: left" valign="bottom">
<p>Description</p>
</th></tr></thead><tbody><tr><td style="text-align: left" valign="top">
<p>
<code class="literal">wx.EVT_MOUSEWHEEL</code>
</p>
</td><td style="text-align: left" valign="top">
<p>Sent for mouse wheel scroll events. See the<code class="literal"> GetWheelRotation</code> and<code class="literal"> GetWheelDelta</code> methods that belong to the<code class="literal"> MouseEvent</code> class for working with this event.</p>
</td></tr><tr><td style="text-align: left" valign="top">
<p>
<code class="literal">wx.EVT_LEFT_DCLICK</code>
</p>
</td><td style="text-align: left" valign="top">
<p>Sent for left mouse button double-clicks.</p>
</td></tr><tr><td style="text-align: left" valign="top">
<p>
<code class="literal">wx.EVT_RIGHT_DOWN</code>
</p>
</td><td style="text-align: left" valign="top">
<p>Sent when the right mouse button is pressed down.</p>
</td></tr><tr><td style="text-align: left" valign="top">
<p>
<code class="literal">wx.EVT_RIGHT_UP</code>
</p>
</td><td style="text-align: left" valign="top">
<p>Sent when the right mouse button is released.</p>
</td></tr><tr><td style="text-align: left" valign="top">
<p>
<code class="literal">wx.EVT_RIGHT_DCLICK</code>
</p>
</td><td style="text-align: left" valign="top">
<p>Sent for right mouse button double-clicks.</p>
</td></tr><tr><td style="text-align: left" valign="top">
<p>
<code class="literal">wx.EVT_MIDDLE_DOWN</code>
</p>
</td><td style="text-align: left" valign="top">
<p>Sent when the middle mouse button is pressed down.</p>
</td></tr><tr><td style="text-align: left" valign="top">
<p>
<code class="literal">wx.EVT_MIDDLE_UP</code>
</p>
</td><td style="text-align: left" valign="top">
<p>Sent when the middle mouse button is released.</p>
</td></tr><tr><td style="text-align: left" valign="top">
<p>
<code class="literal">wx.EVT_MIDDLE_DCLICK</code>
</p>
</td><td style="text-align: left" valign="top">
<p>Sent for middle mouse button double-clicks.</p>
</td></tr><tr><td style="text-align: left" valign="top">
<p>
<code class="literal">wx.EVT_MOTION</code>
</p>
</td><td style="text-align: left" valign="top">
<p>Sent every time the mouse cursor moves within the window.</p>
</td></tr><tr><td style="text-align: left" valign="top">
<p>
<code class="literal">wx.EVT_MOUSE_EVENTS</code>
</p>
</td><td style="text-align: left" valign="top">
<p>This event binder can be used to get notifications for all mouse related events.</p>
</td></tr></tbody></table></div></div><div><div><div><div><h2 class="title"><a id="ch02lvl2sec18"/>See also</h2></div></div></div><div><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">The<em> Understanding event propagation</em> recipe in this chapter discusses how different types of events propagate.</li></ul></div></div></div></div>


  <div><div><div><div><div><h1 class="title"><a id="ch02lvl1sec07"/>Creating custom event classes</h1></div></div></div><p>Sometimes it is necessary to define your own event types to signal custom actions and/or transport data from one place in the application to another. This recipe will show two ways of creating your own custom event class.<a id="id83" class="indexterm"/>
</p><div><div><div><div><h2 class="title"><a id="ch02lvl2sec19"/>How to do it...</h2></div></div></div><p>In this little snippet, we define two new event types using two different methods:</p><div><pre class="programlisting">import wx
import wx.lib.newevent

# Our first custom event
MyEvent, EVT_MY_EVENT = wx.lib.newevent.NewCommandEvent()

# Our second custom event
myEVT_TIME_EVENT = wx.NewEventType()
EVT_MY_TIME_EVENT = wx.PyEventBinder(myEVT_TIME_EVENT, 1)
class MyTimeEvent(wx.PyCommandEvent):
    def __init__(self, id=0, time="12:00:00"):
         evttype = myEVT_TIME_EVENT
        super(MyTimeEvent, self).__init__(evttype, id)wx.PyCommandEvent.__init__(self, myEVT_TIME_EVENT, id)

        # Attributes
        self.time = time

    def GetTime(self):
        return self.time

</pre></div></div><div><div><div><div><h2 class="title"><a id="ch02lvl2sec20"/>How it works...</h2></div></div></div><p>The first example shows the easiest way to create a custom event class. The<code class="literal"> NewCommandEvent</code> function from the wx.lib.newevent module will return a tuple that contains a new event class and an event binder for that class. The class definition that is returned can be used to construct an event object. This method of creating a new event type is of most use when you just want a new event type and don't need to send any custom data with the event.<a id="id86" class="indexterm"/>
</p><p>In order to make use of an event object, the object needs to be sent for processing by the event loop. There are two ways to do this, one of which is the<code class="literal"> PostEvent</code> function.<code class="literal"> PostEvent</code> takes two arguments: the first is the window that should receive the event, and the second is the event itself. For example, the following two lines of code could be used to create and send an instance of our custom<code class="literal"> MyEvent</code> to a<code class="literal"> Frame:</code>
</p><div><pre class="programlisting">event = MyEvent(eventID)
wx.PostEvent(myFrame, event)
</pre></div><p>The second way to send an event for processing is to use a window's<code class="literal"> ProcessEvent</code> method:</p><div><pre class="programlisting">event = MyEvent(eventID)
myFrame.GetEventHandler().ProcessEvent(event)
</pre></div><p>The difference between the two is that<code class="literal"> PostEvent</code> will put the event into the application's event queue to have it processed on the next iteration of the<code class="literal"> MainLoop</code>, whereas<code class="literal"> ProcessEvent</code> will cause the event to be processed right then.</p><p>The second approach shows how to derive a new event type from the<code class="literal"> PyCommandEvent</code> base class. In order to create an event in this way, there are three things that need to be done.<a id="id87" class="indexterm"/>
</p><div><ol class="orderedlist arabic"><li class="listitem">Define a new event type using the<code class="literal"> NewEventType</code> function.</li><li class="listitem">Create the event binder object for binding event handlers with the<code class="literal"> PyEventBinder</code> class. This object takes the event type as its first argument.</li></ol></div><div><ol class="orderedlist arabic"><li class="listitem">Define the event class that is used for creating the event object.</li></ol></div><p>This<code class="literal"> MyTimeEvent</code> class can hold a custom value that we are using to send a formatted time string. It is necessary to derive this from<code class="literal"> PyCommandEvent</code> so that the custom Python data and methods that we are attaching to this object will pass through the event system.</p><p>These events can now be sent to any event handler object, by using the<code class="literal"> PostEvent</code> function or the windows<code class="literal"> ProcessEvent</code> method. Either of these methods will cause the event to be dispatched to the event handler(s) that has been associated with the event by calling<code class="literal"> Bind</code>.</p></div><div><div><div><div><h2 class="title"><a id="ch02lvl2sec21"/>See also</h2></div></div></div><div><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">The<em> Understanding inheritance limitations</em> recipe in<a class="link" href="ch01.html" title="Chapter 1. Getting Started with wxPython"> Chapter 1</a>,<em> Getting Started with wxPython</em> explains the need for the Py versions of some classes.</li><li class="listitem" style="list-style-type: disc">The<em> Handling events</em> recipe in this chapter discusses the use of event handlers.</li></ul></div></div></div></div>


  <div><div><div><div><div><h1 class="title"><a id="ch02lvl1sec08"/>Managing event handlers with EventStack</h1></div></div></div><p>
<code class="literal">EventStack</code> is a module in<code class="literal"> wx.lib</code> that provides a mix in class for the wx application object that can be used to help manage event handlers for<code class="literal"> Menu</code> and<code class="literal"> UpdateUI</code> events. It can be useful in programs that have multiple top-level windows or that need to switch the context of which handlers are called depending on the control that has the focus. This recipe will present a simple framework for managing events in<code class="literal"> Frame-based</code> applications that make use of the<code class="literal"> AppEventHandlerMixin</code> class. A full working example, showing how to use this recipe's classes, is included in the example code that accompanies this recipe.<a id="id88" class="indexterm"/>
</p><div><div><div><div><h2 class="title"><a id="ch02lvl2sec22"/>How to do it...</h2></div></div></div><p>With this code, we define two classes that work together. First we define an<code class="literal"> App</code> base class that uses the<code class="literal"> AppEventHandlerMixin</code>.</p><div><pre class="programlisting">
import wx
import wx.lib.eventStack as eventStack 

class EventMgrApp(wx.App, eventStack.AppEventHandlerMixin):
    """Application object base class that
    event handler managment.
    """
    def __init__(self, *args, **kwargs):
        eventStack.AppEventHandlerMixin.__init__(self)
        wx.App.__init__(self, *args, **kwargs)

class EventMgrFrame(wx.Frame):
    """Frame base class that provides event
    handler managment.
    """
    def __init__(self, parent, *args, **kwargs):
        super(EventMgrFrame, self).__init__(parent,
                                            *args,
                                            **kwargs)

        # Attributes
        self._menu_handlers = []
        self._ui_handlers = []

        # Event Handlers
        self.Bind(wx.EVT_ACTIVATE, self._OnActivate)

    def _OnActivate(self, event):
        """Pushes/Pops event handlers"""
        app = wx.GetApp()
        active = event.GetActive()
        if active:
            mode = wx.UPDATE_UI_PROCESS_SPECIFIED
            wx.UpdateUIEvent.SetMode(mode)
            self.SetExtraStyle(wx.WS_EX_PROCESS_UI_UPDATES)

            # Push this instances handlers
            for handler in self._menu_handlers:
                app.AddHandlerForID(*handler)

            for handler in self._ui_handlers:
                app.AddUIHandlerForID(*handler)
        else:
            self.SetExtraStyle(0)
            wx.UpdateUIEvent.SetMode(wx.UPDATE_UI_PROCESS_ALL)
            # Pop this instances handlers
            for handler in self._menu_handlers:
                app.RemoveHandlerForID(handler[0])

            for handler in self._ui_handlers:
                app.RemoveUIHandlerForID(handler[0])

    def RegisterMenuHandler(self, event_id, handler):
        """Register a MenuEventHandler
        @param event_id: MenuItem ID
        @param handler: Event handler function
        """
        self._menu_handlers.append((event_id, handler))

    def RegisterUpdateUIHandler(self, event_id, handler):
        """Register a controls UpdateUI handler
        @param event_id: Control ID
        @param handler: Event handler function
        """
        self._ui_handlers.append((event_id, handler))
<a id="id90" class="indexterm"/>
</pre></div></div><div><div><div><div><h2 class="title"><a id="ch02lvl2sec23"/>How it works...</h2></div></div></div><p>The<code class="literal"> EventMgrApp</code> class is just a base class for creating an application object that uses<code class="literal"> AppEventHandlerMixin</code>. This<code class="literal"> mixin</code> provides methods for adding and removing event handlers for the<code class="literal"> MenuEvent</code> and<code class="literal"> UpdateUIEvent</code> handlers.<a id="id91" class="indexterm"/>
</p><p>The<code class="literal"> EventMgrFrame</code> class is a base class for frames to derive from. This class will handle adding, removing, and binding event handlers that are registered using either its<code class="literal"> RegisterMenuHandler</code> or<code class="literal"> RegisterUpdateUIHandler</code> methods. These methods take care of adding the event handlers to the stack that will be pushed or popped as the<code class="literal"> Frame</code> is activated or deactivated. The<code class="literal"> AppEventHandlerMixin</code> will internally manage Binding and Unbinding of these handlers.</p></div><div><div><div><div><h2 class="title"><a id="ch02lvl2sec24"/>See also</h2></div></div></div><div><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">The<em> Using UpdateUI events</em> recipe in this chapter discusses<code class="literal"> UpdateUI</code> events in detail.</li></ul></div></div></div></div>


  <div><div><div><div><div><h1 class="title"><a id="ch02lvl1sec09"/>Validating input with validators</h1></div></div></div><p>
<code class="literal">Validators</code> are a general type of helper class for validating data and filtering events that are input to a control. Most controls that accept user input can dynamically have a<code class="literal"> Validator</code> associated with them. This recipe will show how to create a<code class="literal"> Validator</code> that checks if the data that has been entered into a window is an integer that is within a given range of values.<a id="id92" class="indexterm"/>
</p><div><div><div><div><h2 class="title"><a id="ch02lvl2sec25"/>How to do it...</h2></div></div></div><p>Here we will define a Validator for a<code class="literal"> TextCtrl</code> that can be used to validate that the value input is an integer and between a given range.</p><div><pre class="programlisting">import wx
import sys

class IntRangeValidator(wx.PyValidator):
    """An integer range validator for a TextCtrl"""
    def __init__(self, min_=0, max_=sys.maxint):
        """Initialize the validator
        @keyword min: min value to accept
        @keyword max: max value to accept

        """
        super(IntRangeValidator, self).__init__()
        assert min_ &gt;= 0, "Minimum Value must be &gt;= 0"
        self._min = min_
        self._max = max_

        # Event managment
        self.Bind(wx.EVT_CHAR, self.OnChar)

    def Clone(self):
        """Required override"""
        return IntRangeValidator(self._min, self._max)

    def Validate(self, win):
        """Override called to validate the window's value.
        @return: bool
        """
        txtCtrl = self.GetWindow()
        val = txtCtrl.GetValue()
        isValid = False
        if val.isdigit():
            digit = int(val)
            if digit &gt;= self._min and digit &lt;= self._max:
                isValid = True

        if not isValid:
            # Notify the user of the invalid value
            msg = "Value must be between %d and %d" % \
                  (self._min, self._max)
            wx.MessageBox(msg,
                          "Invalid Value",
                          style=wx.OK|wx.ICON_ERROR)

        return isValid

    def OnChar(self, event):
        txtCtrl = self.GetWindow()
        key = event.GetKeyCode()
        isDigit = False
        if key &lt; 256:
            isDigit = chr(key).isdigit()

        if key in (wx.WXK_RETURN,
                   wx.WXK_DELETE,
                   wx.WXK_BACK) or \
           key &gt; 255 or isDigit:
            if isDigit:
                # Check if in range
                val = txtCtrl.GetValue()
                digit = chr(key)
                pos = txtCtrl.GetInsertionPoint()
                if pos == len(val):
                    val += digit
                else:
                    val = val[:pos] + digit + val[pos:]

                val = int(val)
                if val &lt; self._min or val &gt; self._max:
                    if not wx.Validator_IsSilent():
                        wx.Bell()
                    return
                
            event.Skip()
            return

        if not wx.Validator_IsSilent():
            # Beep to warn about invalid input
            wx.Bell()

        return

    def TransferToWindow(self):
         """Overridden to skip data transfer"""
         return True

    def TransferFromWindow(self):
         """Overridden to skip data transfer"""
         return True

</pre></div></div><div><div><div><div><h2 class="title"><a id="ch02lvl2sec26"/>How it works...</h2></div></div></div><p>
<code class="literal">Validator</code> classes have a number of virtual methods that need to be overridden in order for them to function properly. Hence, it is important to derive a subclass from the<code class="literal"> PyValidator</code> class, instead of<code class="literal"> Validator</code>, in order to get access to the virtual method aware version of the class.<a id="id95" class="indexterm"/>
</p><p>All<code class="literal"> Validator</code> subclasses must override the<code class="literal"> Clone</code> method. This method simply needs to return a copy of the<code class="literal"> Validator</code>.</p><p>The<code class="literal"> Validate</code> method is called to check if the value is valid or not. This method will be called if the control is the child of a modal dialog, prior to calling<code class="literal"> EndModal</code> for an<code class="literal"> Ok</code> button. This is a good time to notify the user of any issues with the input.</p><p>
<code class="literal">Validators</code> can also bind to any events that their window may bind to and can be used to filter the events. The events will be sent to the<code class="literal"> OnChar</code> method of the<code class="literal"> Validator</code> before they are sent to the window, allowing the<code class="literal"> Validator</code> to filter which events are allowed to get to the control.</p><p>The<code class="literal"> TransferToWindow</code> and<code class="literal"> TransferFromWindow</code> methods can be overridden if you wish to only do the validation in a<code class="literal"> Dialog</code> at the time when the<code class="literal"> Dialog</code> is being shown or closed.<code class="literal"> TransferToWindow</code> will be called when a<code class="literal"> Dialog</code> is shown, and<code class="literal"> TransferFromWIndow</code> will be called when the<code class="literal"> Dialog</code> is closed. Returning<code class="literal"> True</code> from either of the methods indicates that the data is valid, and returning<code class="literal"> False</code> will indicate that there is invalid data.</p></div><div><div><div><div><h2 class="title"><a id="ch02lvl2sec27"/>See also</h2></div></div></div><div><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">The<em> Understanding inheritance limitations</em> recipe in<a class="link" href="ch01.html" title="Chapter 1. Getting Started with wxPython"> Chapter 1</a>,<em> Getting Started with wxPython</em> discusses the use of the Py versions of classes and overriding virtual methods.</li><li class="listitem" style="list-style-type: disc">The<em> Handling Key events</em> recipe in this chapter discusses<code class="literal"> KeyEvents</code> in detail.</li></ul></div></div></div></div>


  <div><div><div><div><div><h1 class="title"><a id="ch02lvl1sec10"/>Handling Apple events</h1></div></div></div><p>AppleEvents are high-level system events used by the Macintosh operating system to pass information between processes. For an application to handle things such as opening files that are dropped on the application icon, it is necessary to handle these events. The wxPython application object has some built-in support for some of the most common events, by way of virtual overrides in the application object. This recipe will show how to create an application object that can make use of the built-in and somewhat hidden-event callback functions.<a id="id96" class="indexterm"/>
</p><div><h3 class="title"><a id="note04"/>Note</h3><p>This is an OS X specific recipe, and will have will have no effect on other platforms.</p></div><div><div><div><div><h2 class="title"><a id="ch02lvl2sec28"/>How to do it...</h2></div></div></div><p>This little sample application shows all of the built-in callback methods available in the<code class="literal"> App</code> for handling some of the commonly needed<code class="literal"> AppleEvents</code>.</p><div><pre class="programlisting">import wx

class MyApp(wx.App):
    def OnInit(self):
        self.frame = MyFrame(None, title="AppleEvents")
        self.SetTopWindow(self.frame)
        self.frame.Show()

        return True

    def MacNewFile(self):
        """Called for an open-application event"""
        self.frame.PushStatusText("MacNewFile Called")

    def MacOpenFile(self, filename):
        """Called for an open-document event"""
        self.frame.PushStatusText("MacOpenFile: %s" % \
                                  filename)

    def MacOpenURL(self, url):
        """Called for a get-url event"""
        self.frame.PushStatusText("MacOpenURL: %s" % url)

    def MacPrintFile(self, filename):
        """Called for a print-document event"""
        self.frame.PushStatusText("MacPrintFile: %s" % \
                                   filename)

    def MacReopenApp(self):
        """Called for a reopen-application event"""
        self.frame.PushStatusText("MacReopenApp")
        # Raise the application from the Dock
        if self.frame.IsIconized():
            self.frame.Iconize(False)
        self.frame.Raise()

</pre></div></div><div><div><div><div><h2 class="title"><a id="ch02lvl2sec29"/>How it works...</h2></div></div></div><p>There are five built-in handler methods for some of the common<code class="literal"> AppleEvents</code>. All that needs to be done to use them in your application is to override them in your application object, as previously shown. Since what an application does in response to these events is highly application-specific, this recipe does not do much, other than report to the frame's status bar when the method is called.<a id="id98" class="indexterm"/>
</p><p>The two most-common events that should be implemented are the<code class="literal"> MacOpenFile</code> and<code class="literal"> MacReopenApp</code> methods, as these are necessary to get standard expected behavior in an application on OS X.<code class="literal"> MacOpenFile</code> is called when a user drops a file on an application's Dock icon. When this happens, it will be passed the path of the file as an argument.<code class="literal"> MacReopenApp</code> is called when a user left-clicks on the Dock icon of a running application. As shown in the recipe, this is used to bring an application to the front and/or raise it from a minimized state in the Dock.<a id="id99" class="indexterm"/>
</p></div><div><div><div><div><h2 class="title"><a id="ch02lvl2sec30"/>There's more...</h2></div></div></div><p>It is possible to add support for more<code class="literal"> AppleEvents</code> to a wxPython application, although it is not a particularly easy task as it requires writing a native extension module to catch the event, block the wx<code class="literal"> EventLoop</code>, and then restore the Python interpreter's state back to wx after handling the event. There is a pretty good example that can be used as a starting point in the wxPython Wiki (see<a class="ulink" href="http://wiki.wxpython.org/Catching%20AppleEvents%20in%20wxMAC)"> http://wiki.wxpython.org/Catching%20AppleEvents%20in%20wxMAC)</a>, if you find yourself needing to venture down this route.</p></div><div><div><div><div><h2 class="title"><a id="ch02lvl2sec31"/>See also</h2></div></div></div><div><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">The<em> Understanding inheritance limitations</em> recipe in<a class="link" href="ch01.html" title="Chapter 1. Getting Started with wxPython"> Chapter 1</a>,<em> Getting Started with wxPython</em> includes more information on overriding virtual methods.</li><li class="listitem" style="list-style-type: disc">The<em> Optimizing for OS X</em> recipe in<a class="link" href="ch12.html" title="Chapter 12. Building and Managing Applications for Distribution"> Chapter 12</a>,<em> Application Infrastructure</em> includes more information on making wxPython applications work well on OS X.</li></ul></div></div></div></div>
</body></html>