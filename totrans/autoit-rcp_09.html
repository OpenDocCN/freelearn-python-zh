<html><head></head><body><div class="chapter" title="Chapter&#xA0;9.&#xA0;Imagining Images"><div class="titlepage"><div><div><h1 class="title"><a id="ch09"/>Chapter 9. Imagining Images</h1></div></div></div><p>We work with images almost on a daily basis. Uploading images to your Facebook profile page, or manipulating images while developing your mobile or web applications; there are abundant use cases. With so many advancements in the field of computer vision, imaging has become a critical field. Working with images is trivial with Python.</p><p>In this chapter, we will cover the following recipes:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">Converting images</li><li class="listitem" style="list-style-type: disc">Resizing, cropping, and generating thumbnails</li><li class="listitem" style="list-style-type: disc">Copy-pasting and watermarking images</li><li class="listitem" style="list-style-type: disc">Image differences and comparison</li><li class="listitem" style="list-style-type: disc">Face detection</li><li class="listitem" style="list-style-type: disc">Imaging as a business process</li></ul></div><div class="section" title="Introduction"><div class="titlepage"><div><div><h1 class="title"><a id="ch09lvl1sec72"/>Introduction</h1></div></div></div><p>Images in the electronic world are a series of bits comprised of 0s and 1s. They are an electronic snapshot of a scene or a document. Even paintings or photographs can be digitized to form images. Let's go deeper into images and understand how they're structured.</p><p>Every image is sampled and is represented by a grid of dots called <span class="strong"><strong>pixels</strong></span>. These pixels represent the smallest controllable elements of a picture shown on the screen. The greater the number of pixels available in an image, the more accurate is the representation of the image on the device screen.</p><p>The intensity of each pixel is variable. In the digital world, the color of an image is represented by three or four intensities of different colors: <span class="strong"><strong>red, green, and blue</strong></span> (<span class="strong"><strong>RGB</strong></span>) or <span class="strong"><strong>cyan, magenta, yellow, and black</strong></span> (<span class="strong"><strong>CMYK</strong></span>), respectively. Computer programs often represent colors in RGBA format, where A stands for alpha (or the transparency of a color). Each pixel is represented in the binary representation in the RGBA format and is stored by the computer as a sequence. The computer then reads this sequence for display and, in some cases, converts it to its analog version for printing. Let's look at specific image attributes in detail.</p><div class="section" title="Image attributes"><div class="titlepage"><div><div><h2 class="title"><a id="ch09lvl2sec203"/>Image attributes</h2></div></div></div><p>Let's have a look at some of the image attributes:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc"><span class="strong"><strong>Image size</strong></span>: As you learned earlier, computer images are stored as a series of 0s and 1s and are measured in pixels (rectangular dots). The file size of an image is calculated based on the number of pixels it contains and the amount of color information that is stored. The file size is, in fact, the space taken up by the image on the computer hard drive.</li><li class="listitem" style="list-style-type: disc"><span class="strong"><strong>Bit depth</strong></span>: It is the number of bits used to indicate the color of a single pixel. This concept can be defined as the bits per pixel, which denotes the number of bits used to describe a pixel. The greater the bit depth of an image, greater the number of colors it can store. A 1-bit image can store only two (2^1) colors--0 and 1--and is hence black and white in color. When compared with it, an 8-bit image can store 256 (2^8) colors.</li><li class="listitem" style="list-style-type: disc"><span class="strong"><strong>Image resolution</strong></span>: Resolution refers to the number of pixels in an image. Resolution is sometimes identified by the width and height of the image. For example, an image of 1,920 by 1,024 pixel resolution contains 1,966,080 pixels or is a 1.9-megapixel image.</li><li class="listitem" style="list-style-type: disc"><span class="strong"><strong>Image quality</strong></span>: It can be changed based on the information an image stores. Not all images need to store all the pixels to represent an image. For instance, a continuous block of blue sea in a picture need not have all the pixels, and the image can be compressed to reduce the disk space of the image without compromising on the image quality. This reduction in disk space is termed as compression. A higher compression means noticeable loss of detail. A typical compression type used in today's world is the JPG compression, which reduces the size and also sacrifices the image's quality.</li><li class="listitem" style="list-style-type: disc"><span class="strong"><strong>Image formats</strong></span>: Images are stored in a computer with different extensions. Formats such as BMP or TIF are not compressed at all; hence, they occupy more disk space. Files such as JPG can be compressed and you can also choose the compression level. Hence, TIF images are lossless and JPG compression is termed as lossy compression. It is interesting to note that lossy compressions make use of humans' inability to differentiate minor differences in shades. Multiple lossy conversions will result in image degradation, whereas multiple lossless conversions will preserve the image quality. But generally, it's a trade-off between image degradation and size when it comes to compression.</li></ul></div><p>OK, that's a good start. In this chapter, we will go through some more concepts of images and look at the various operations that you can perform on images with Python. We'll take a look at multiple modules that will help us manipulate images the way we need them. At the end of the chapter, we will also look at a typical business process that can be automated with the knowledge we built with the recipes covered in the chapter.</p><p>During the course of this chapter, we will use the following Python modules:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc"><code class="literal">Pillow</code> (<a class="ulink" href="https://pypi.python.org/pypi/Pillow">https://pypi.python.org/pypi/Pillow</a>)</li><li class="listitem" style="list-style-type: disc"><code class="literal">scipy</code> (<a class="ulink" href="https://www.scipy.org/">https://www.scipy.org/</a>)</li><li class="listitem" style="list-style-type: disc"><code class="literal">opencv</code> (<a class="ulink" href="https://pypi.python.org/pypi/opencv-python">https://pypi.python.org/pypi/opencv-python</a>)</li></ul></div></div></div></div>
<div class="section" title="Converting images"><div class="titlepage"><div><div><h1 class="title"><a id="ch09lvl1sec73"/>Converting images</h1></div></div></div><p>Let's begin our journey of images with simple examples. But before going on, let's build our virtual environment.</p><div class="orderedlist"><ol class="orderedlist arabic"><li class="listitem">We will build the virtual environment using the <code class="literal">virtualenv</code> command and also activate it:<pre class="programlisting">
<span class="strong"><strong>chetans-MacBookPro:~ Chetan$ cd book/ch10/</strong></span>
<span class="strong"><strong>chetans-MacBookPro:ch10 Chetan$ virtualenv ch10</strong></span>
<span class="strong"><strong>New python executable in ch10/bin/python2.7</strong></span>
<span class="strong"><strong>Also creating executable in ch10/bin/python</strong></span>
<span class="strong"><strong>Installing setuptools, pip, wheel...done.</strong></span>
<span class="strong"><strong>chetans-MacBookPro:ch10 Chetan$ source ch10/bin/activate</strong></span>
<span class="strong"><strong>(ch10)chetans-MacBookPro:ch10 Chetan$</strong></span>
</pre></li><li class="listitem">Nice! So, we now have an independent environment to work on our recipes for this chapter. For the first set of examples, we will use Python's Pillow module. Let's install this module first before going to the recipe. We will use our favorite <code class="literal">python-pip</code> to install the Pillow module:<pre class="programlisting">
<span class="strong"><strong>(ch10)chetans-MacBookPro:ch10 Chetan$ pip install pillow</strong></span>
<span class="strong"><strong>You are using pip version 7.1.0, however version 8.1.2 is&#13;
        available.</strong></span>
<span class="strong"><strong>You should consider upgrading via the 'pip install --upgrade&#13;
        pip' command.</strong></span>
<span class="strong"><strong>Collecting pillow</strong></span>
<span class="strong"><strong>      Downloading Pillow-3.4.2.tar.gz (10.8MB)</strong></span>
<span class="strong"><strong>      100% |████████████████████████████████| 10.8MB 39kB/s </strong></span>
<span class="strong"><strong>Building wheels for collected packages: pillow</strong></span>
<span class="strong"><strong>      Running setup.py bdist_wheel for pillow</strong></span>
<span class="strong"><strong>Installing collected packages: pillow</strong></span>
<span class="strong"><strong>Successfully installed pillow-3.4.2</strong></span>
</pre></li></ol></div><p>So, we now have our environment, and the <code class="literal">Pillow</code> module is also installed. We're now ready to work with the recipe.</p><div class="section" title="How to do it..."><div class="titlepage"><div><div><h2 class="title"><a id="ch09lvl2sec204"/>How to do it...</h2></div></div></div><p>In this section, we will deal with converting images to a different format.</p><div class="orderedlist"><ol class="orderedlist arabic"><li class="listitem">First, let's just download an image that can be used as a sample image to perform all our operations. I love sunsets and that's the reason I have used a sunset image for most of the recipes in this chapter. This is how it looks. I store it on my laptop and name it <code class="literal">beach_sunset.png</code>:<p>
</p><div class="mediaobject"><img alt="How to do it..." src="graphics/image_09_001.jpg"/></div><p>
</p></li><li class="listitem">Now, let's go ahead and write the Python code to convert this image to the JPEG format. The following code does exactly what we need. We store the Python code in a file named <code class="literal">convert.py</code>:<pre class="programlisting">
<span class="strong"><strong>from PIL import Image</strong></span>
<span class="strong"><strong>img = Image.open('beach_sunset.png')</strong></span>
<span class="strong"><strong>img.save('beach-sunset-conv.jpg','jpeg')</strong></span>
</pre><p>When you run this program with Python's <code class="literal">convert.py</code> command it will take the original PNG image, convert it into JPG format, and store it as <code class="literal">beach-susnset-conv.jpg</code>.</p></li><li class="listitem">Neat! Now, let's perform one more operation on this image and convert it to grayscale (black and white format). It's common for people to convert images to black and white format to give them a nostalgic look; this can be easily achieved with the following set of command lines:<pre class="programlisting">        from PIL import Image &#13;
        img = Image.open('beach_sunset.png').convert('L') &#13;
        img.show() &#13;
        img.save('beach-sunset-gray.png','png') &#13;
</pre><p>Now, when you run this program, you will see another image generated on your disk, with the name <code class="literal">beach-sunset-gray.png</code>, which looks as follows:</p><p>
</p><div class="mediaobject"><img alt="How to do it..." src="graphics/image_09_002.jpg"/></div><p>
</p></li><li class="listitem">Cool, let's go further and perform a few more operations such as rotating and flipping the image. These actions are often used in fun websites where you can simply play around with your images. The following code will help you rotate the images by 180 degrees:<pre class="programlisting">        from PIL import Image &#13;
        img = Image.open('sunset.jpg') &#13;
        img.rotate(180).save('sunset180deg.jpg') &#13;
</pre><p>If you run this code with our base image, you will see an image rotated by 180 degrees, that is, the image is seen upside down, as shown here:</p><p>
</p><div class="mediaobject"><img alt="How to do it..." src="graphics/image_09_003.jpg"/></div><p>
</p></li><li class="listitem">While rotating images is nice, it'd be awesome fun if we could flip the images. PIL doesn't disappoint here and provides you with the options of flipping the images horizontally and vertically. The following code will help us perform the flipping operations:<pre class="programlisting">        from PIL import Image &#13;
        img = Image.open('sunset.jpg') &#13;
        img.transpose(Image.FLIP_LEFT_RIGHT).save(&#13;
                      'sunset_horizontal_flip.png')&#13;
        img.transpose(Image.FLIP_TOP_BOTTOM).save(&#13;
                         'sunset_vertical_flip.png') &#13;
</pre><p>Now, if you run this piece of code, it will generate two images. The following image is the same as the original image, but is flipped horizontally (as if there is a mirror kept on the right side of the image). Note how the mountain has moved to the right of the image:</p><p>
</p><div class="mediaobject"><img alt="How to do it..." src="graphics/image_09_004.jpg"/></div><p>
</p><p>The following screenshot is a mirror image of the original image, which is flipped vertically. Notice, the mountain is still on the left-hand side of the image but it's upside down. Similar is the fate of the setting sun. Is it looking like sunrise?</p><p>
</p><div class="mediaobject"><img alt="How to do it..." src="graphics/image_09_005.jpg"/></div><p>
</p></li></ol></div></div><div class="section" title="How it works..."><div class="titlepage"><div><div><h2 class="title"><a id="ch09lvl2sec205"/>How it works...</h2></div></div></div><p>In this section, we dealt with two different image formats: PNG and JPEG. <span class="strong"><strong>Portable Network Graphics</strong></span> (<span class="strong"><strong>PNG</strong></span>) files are non-lossy files, compressing photographic images without degrading quality. It is an excellent file format for Internet graphics; it can be used with multiple backgrounds, and it supports transparency. For the image used in first code example, <code class="literal">beach_sunset.png</code>, the file size is 550KB.</p><p>
<span class="strong"><strong>Joint Photographic Experts Group</strong></span> (<span class="strong"><strong>JPEG</strong></span>) uses lossy compression techniques to compress images. JPGs compress images by reducing the sections of images to pixels or tiles. JPG images can be compressed at a ratio of N:1, depending on the settings. Since images get compressed easily and can reduce the Internet bandwidth for accessing images on the Internet, JPG has become a standard for images on the Internet. For the converted image, I see the file size is 450KB--almost 20% smaller size than the PNG files.</p><p>Now, let's understand the Python code. We import the <code class="literal">Image</code> class from the <code class="literal">PIL</code> module. The <code class="literal">Image</code> class is responsible for opening, loading, and converting images, among other operations such as saving images on the disk. In our example, we open the PNG image with the <code class="literal">open()</code> method and save the image in the JPEG format with the <code class="literal">save()</code> method.</p><p>In the second example, we convert the image to the black and white format. Just as we have the RGB and CMYK formats, we also have the <span class="emphasis"><em>L</em></span> format, which denotes black and white. While converting the image to the <span class="emphasis"><em>L</em></span> format, it uses the ITU-R luma format, where <span class="emphasis"><em>L=R*299/1000 + G*587/1000 + B*114/1000</em></span>.</p><p>In terms of Python code, again we use the <code class="literal">Image</code> class to <code class="literal">open()</code> the file and use the <code class="literal">convert()</code> method with its argument as <span class="emphasis"><em>L</em></span> to convert the image to black and white. Finally, we save the file on the disk with <code class="literal">save()</code> method. Here we maintain the file format to PNG.</p><p>In the third example, we use the same <code class="literal">Image</code> class and <code class="literal">open()</code> the image to get the <code class="literal">img</code> object. This object is then used to call the <code class="literal">rotate()</code> method with the angle of rotation being the argument. In our example, we rotated the image by 180 degrees and finally called <code class="literal">save()</code> to save the rotated image on the disk with the name, <code class="literal">sunset180deg.jpg</code>.</p><p>In the last example, we make use of the <code class="literal">transpose()</code> method of the <code class="literal">PIL</code> module and flip the images both ways, that is, left-right and top-bottom, using the attributes <code class="literal">Image.FLIP_LEFT_RIGHT</code> and <code class="literal">Image.FLIP_TOP_BOTTOM</code>, and then save the flipped images with the names <code class="literal">sunset_horizontal_flip.png</code> and <code class="literal">sunset_vertical_flip.png</code>, respectively.</p></div><div class="section" title="There's more..."><div class="titlepage"><div><div><h2 class="title"><a id="ch09lvl2sec206"/>There's more...</h2></div></div></div><p>The Pillow module has many more methods that help us perform more complex operations on our images, such as resizing, pasting, cropping, and what not. We will look at them in the next recipe of this chapter.</p></div></div>
<div class="section" title="Resizing, cropping, and generating thumbnails"><div class="titlepage"><div><div><h1 class="title"><a id="ch09lvl1sec74"/>Resizing, cropping, and generating thumbnails</h1></div></div></div><p>Operations such as resizing images and cropping them to get a selected part of the image are very common, but these operations may become tedious when tried programmatically. See how we can achieve these tasks.</p><div class="section" title="Getting ready"><div class="titlepage"><div><div><h2 class="title"><a id="ch09lvl2sec207"/>Getting ready</h2></div></div></div><p>In this recipe, we will use the <code class="literal">Pillow</code> library to resize and crop images. As we already have the Pillow module installed, we don't have to worry about any installations. Let's jump into doing stuff.</p></div><div class="section" title="How to do it..."><div class="titlepage"><div><div><h2 class="title"><a id="ch09lvl2sec208"/>How to do it...</h2></div></div></div><div class="orderedlist"><ol class="orderedlist arabic"><li class="listitem">First, let's look at how to resize an image to the given dimensions. Create a Python file, <code class="literal">resize.py</code>, and paste the following code snippet:<pre class="programlisting">        from PIL import Image &#13;
        img = Image.open('sunset.jpg') &#13;
        resized = img.resize((256,256)) &#13;
        resized.save('sunset-resize.jpg', 'jpeg') &#13;
</pre></li><li class="listitem">Also, download an image from the Internet and name it sunset.jpg. My image looks like this:<p>
</p><div class="mediaobject"><img alt="How to do it..." src="graphics/image_09_006.jpg"/></div><p>
</p></li><li class="listitem">Now, run the Python code with the <code class="literal">python resize.py</code> command, and look at your disk for the image, <code class="literal">sunset-resize.jpg</code>. You'll see that the image gets resized and looks similar to the following screenshot:<p>
</p><div class="mediaobject"><img alt="How to do it..." src="graphics/image_09_007.jpg"/></div><p>
</p><p>The image also has the dimensions of 256 pixels by 256 pixels as expected:</p><p>
</p><div class="mediaobject"><img alt="How to do it..." src="graphics/image_09_008.jpg"/></div><p>
</p></li><li class="listitem">Another operation often needed in programming is to generate thumbnails for images. Thumbnails are used as the preview of an original image and are typically used in movie review websites or book publishing websites. Let's see if we can easily generate thumbnails with the Pillow module. Create a Python file and add this piece of code:<pre class="programlisting">        import os, sys &#13;
        from PIL import Image &#13;
 &#13;
        size = 128, 128 &#13;
        infile = "sunset.jpg" &#13;
        outfile = os.path.splitext(infile)[0] + ".thumbnail.jpg" &#13;
        if infile != outfile: &#13;
            try: &#13;
                im = Image.open(infile) &#13;
                im.thumbnail(size, Image.BICUBIC) &#13;
                im.save(outfile, "JPEG") &#13;
            except IOError: &#13;
                print "cannot create thumbnail for '%s'" % infile &#13;
</pre><p>Now, if you run this piece of code, you will get an image, <code class="literal">sunset.thumbnail.jpg</code>, which is a thumbnail of the original image and will look as shown in the screenshot below. If you look at the size of the image, it will not be 128 x 128 (for me, it's 128 x 80 pixels). We will cover the reasons for this in a bit.</p><p>Nice! So, we have the thumbnail generated for the image and it can be used on a website as a profile thumbnail or a preview image:</p><p>
</p><div class="mediaobject"><img alt="How to do it..." src="graphics/image_09_009.jpg"/></div><p>
</p></li><li class="listitem">Another operation that we will cover in this recipe is the cropping of images. The following code does exactly what we need:<pre class="programlisting">        from PIL import Image &#13;
        img = Image.open('sunset.jpg') &#13;
        cropImg = img.crop((965, 700, 1265, 960)) &#13;
        cropImg.save('sunset-crop.jpg') &#13;
</pre><p>If you run the preceding Python snippet, you will see an image generated on your disk, <code class="literal">sunset-crop.jpg</code>, which has a cropped image of the sun from the original sunset image. This is how it looks:</p><p>
</p><div class="mediaobject"><img alt="How to do it..." src="graphics/image_09_010.jpg"/></div><p>
</p></li></ol></div><p>It was nice to see how we could perform multiple operations on the images with Pillow so easily and so intuitively. But how do these operations work; what are the methods used? Let's look at them.</p></div><div class="section" title="How it works..."><div class="titlepage"><div><div><h2 class="title"><a id="ch09lvl2sec209"/>How it works...</h2></div></div></div><p>In this recipe, we again used Pillow's <code class="literal">Image</code> class to resize and crop images and generate thumbnails from our original image.</p><p>In the first code snippet, we opened the sunset.jpg image with the <code class="literal">open()</code> method. We then used the <code class="literal">resize()</code> method with a tuple argument listing the width and height of the resized image. We then used the <code class="literal">save()</code> method with the filename, <code class="literal">sunset-esize.jpg</code> and the JPEG file format to save the file on the disk.</p><p>In the second snippet, we opened the image with the <code class="literal">open()</code> method and got an image object. We then used the <code class="literal">thumbnail()</code> method of the <code class="literal">Image</code> class on the image object for generating the thumbnail. The <code class="literal">thumbnail()</code> method takes the size of the image (we used 128 x 128) and uses the BICUBIC image filtering mechanism. Finally, we saved the image with the <code class="literal">save()</code> method with the target filename set to <code class="literal">sunset.thumbnail.jpg</code>. We looked at the size of the thumbnail and figured that it's not exactly 128 x 128; in fact, it's 128 x 80. This is because PIL keeps the width of the image to 128 pixels and then recalculates the height to maintain the aspect ratio of the image.</p><p>And in the third example, we cropped the image with the <code class="literal">crop()</code> method of the <code class="literal">Image</code> class from the Pillow module. The <code class="literal">crop()</code> method takes all the four coordinates from where the image needs to be carved out from the original image. In our example, we have given the coordinates <code class="literal">left = 965</code>, <code class="literal">top = 700</code>, <code class="literal">right = 1265</code>, <code class="literal">bottom = 960</code> to crop the original image and the result obtained is the image of the sun as we saw in the examples.</p></div><div class="section" title="There's more..."><div class="titlepage"><div><div><h2 class="title"><a id="ch09lvl2sec210"/>There's more...</h2></div></div></div><p>In the thumbnail generation example, I briefly mentioned filters that are applied to images for better clarity. I'm not covering these in detail in this chapter, but if you're interested, you can look at them in detail at <a class="ulink" href="http://pillow.readthedocs.io/en/3.0.x/releasenotes/2.7.0.html#default-filter-for-thumbnails">http://pillow.readthedocs.io/en/3.0.x/releasenotes/2.7.0.html#default-filter-for-thumbnails</a>.</p></div></div>
<div class="section" title="Copy-pasting and watermarking images"><div class="titlepage"><div><div><h1 class="title"><a id="ch09lvl1sec75"/>Copy-pasting and watermarking images</h1></div></div></div><p>In this recipe, we will cover one operation that is highly used by designers and marketers, that is, watermarking images. We will also see an interesting use of copy-pasting images over one another. Let's go ahead and look at them.</p><div class="section" title="Getting ready"><div class="titlepage"><div><div><h2 class="title"><a id="ch09lvl2sec211"/>Getting ready</h2></div></div></div><p>In this recipe, we will continue to use Pillow to copy-paste images, but we will use another Python module, <code class="literal">wand</code>, for watermarking. So, as is the normal practice, let's install the <code class="literal">wand</code> module first before we start writing any code. We install wand with our favorite tool, Python's <code class="literal">pip</code>:</p><pre class="programlisting">
<span class="strong"><strong>(ch10)chetans-MacBookPro:ch10 Chetan$ pip install wand</strong></span>
<span class="strong"><strong>You are using pip version 7.1.0, however version 8.1.2 is&#13;
        available.</strong></span>
<span class="strong"><strong>You should consider upgrading via the 'pip install --upgrade&#13;
        pip' command.</strong></span>
<span class="strong"><strong>Collecting wand</strong></span>
<span class="strong"><strong>      Downloading Wand-0.4.3.tar.gz (65kB)</strong></span>
<span class="strong"><strong>        100% |████████████████████████████████| 65kB 101kB/s </strong></span>
<span class="strong"><strong>Building wheels for collected packages: wand</strong></span>
<span class="strong"><strong>      Running setup.py bdist_wheel for wand</strong></span>
<span class="strong"><strong>      Stored in directory:&#13;
      &#13;
             /Users/chetan/Library/Caches/pip/wheels/77/&#13;
             c2/a3/6cfc4bb3e21c3103df1ce72d7d301b1965657ee6f81cd3738c</strong></span>
<span class="strong"><strong>Successfully built wand</strong></span>
<span class="strong"><strong>Installing collected packages: wand</strong></span>
<span class="strong"><strong>Successfully installed wand-0.4.3</strong></span>
</pre><p>Installed the module already? OK then, let's dive in.</p></div><div class="section" title="How to do it..."><div class="titlepage"><div><div><h2 class="title"><a id="ch09lvl2sec212"/>How to do it...</h2></div></div></div><div class="orderedlist"><ol class="orderedlist arabic"><li class="listitem">First, let's look at how to perform the copy-paste operation with Pillow. Remember, from the previous sections we have two images: the original image, <code class="literal">sunset.jpg</code>, and the image of the sun that was cropped from the original image, <code class="literal">sunset-crop.jpg</code>. We will use these images in the following Python code:<pre class="programlisting">        from PIL import Image &#13;
        img = Image.open('sunset-crop.jpg') &#13;
        pasteImg = Image.open('sunset.jpg') &#13;
        pasteImg.paste(img, (0,0)) &#13;
        pasteImg.save('pasted.jpg') &#13;
</pre></li><li class="listitem">Let's store the code in a file by the name, <code class="literal">copy_paste.py</code>, and run the code with the Python command, <code class="literal">copy_paste.py</code>. Once we run the code, we will see a new file being generated, called <code class="literal">pasted.jpg</code>, which looks like the following screenshot:<p>
</p><div class="mediaobject"><img alt="How to do it..." src="graphics/image_09_011.jpg"/></div><p>
</p><p>What we have managed to do is copy the cropped image, paste it on the original image, and save the pasted image as <code class="literal">pasted.jpg</code>. Cool, isn't it?</p><p>Now, let's look at an interesting example that has commercial use. In this example, we will add a watermark to an existing image and store it under a different name. But before we get into the Python code, let's look at how the watermark image looks:</p><p>
</p><div class="mediaobject"><img alt="How to do it..." src="graphics/image_09_012.jpg"/></div><p>
</p><p>The following Python code helps us in adding the preceding watermark to our original <code class="literal">sunset.jpg</code> image file:</p><pre class="programlisting">        from wand.image import Image &#13;
 &#13;
        with Image(filename='sunset.jpg') as background: &#13;
        with Image(filename='watermark.jpg') as watermark: &#13;
          background.watermark(image=watermark, transparency=0.25,&#13;
          left=560, top=300) &#13;
        background.save(filename='result.jpg') &#13;
</pre></li><li class="listitem">Run this code and you will see a <code class="literal">result.jpg</code> file being generated in your project. It will look similar to the following screenshot. Look at how the image is watermarked with the <span class="strong"><strong>Copyrighted Image</strong></span> text on top:<p>
</p><div class="mediaobject"><img alt="How to do it..." src="graphics/image_09_013.jpg"/></div><p>
</p></li></ol></div></div><div class="section" title="How it works..."><div class="titlepage"><div><div><h2 class="title"><a id="ch09lvl2sec213"/>How it works...</h2></div></div></div><p>For the first code snippet, we used the <code class="literal">PIL</code> module and the Image class to <code class="literal">open()</code> the cropped image and original image and get the file handles of both the files, namely: <code class="literal">img</code> and <code class="literal">pasteImg</code>.</p><p>As the name suggests, we opened the cropped image <code class="literal">img</code> and pasted it on <code class="literal">pasteImg</code>, using the file handles.</p><p>For pasting the image, we used Pillow's <code class="literal">paste()</code> module and passed the <code class="literal">img</code> file handle to it as the source image. We also passed the coordinates where the cropped image is to be pasted on the original image. Since we have chosen the coordinates to be (0, 0), the cropped image is pasted on the upper-left corner of the original image. Finally, we saved this image as <code class="literal">pasted.jpg</code>.</p><p>In the second example, we opened the original image, <code class="literal">sunset.jpg</code>, and the watermark image, <code class="literal">watermark.jpg</code>, and created the file handles, <code class="literal">background</code> and <code class="literal">watermark</code>, respectively. We then used the <code class="literal">wand</code> module's <code class="literal">watermark()</code> method to add the watermark to the original image.</p><p>The <code class="literal">watermark()</code> method works on the background image object (in this case, background, our original image object). It uses image as the <code class="literal">keyword</code> argument, which indicates the object of the watermark image. You can also set the transparency of the watermark image, where <code class="literal">0</code> indicates that the watermark is completely visible while <code class="literal">1</code> indicates that it is invisible. Another useful thing you can achieve with the <code class="literal">watermark()</code> method is that you can choose the location of the watermark on the original image. In this example, we have chosen it to be at the coordinates <code class="literal">560</code> from the left and <code class="literal">300</code> from the top.</p><p>Cool; that's it in this recipe. Let's go ahead and see what we have in store in the remaining recipes of this chapter.</p></div></div>
<div class="section" title="Image differences and comparison"><div class="titlepage"><div><div><h1 class="title"><a id="ch09lvl1sec76"/>Image differences and comparison</h1></div></div></div><p>You must have definitely used a text-based search or even implemented one. But do you know, you can now even perform an image-based search? Of course, Google does that quite nicely. How do you think it does that? If you have to implement one yourself, you better know how to compare two images. Based on your use case, you may also want to get a <code class="literal">diff</code> or the difference between two images. In this recipe, we will cover two use cases:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">How to get the difference between two images and store the difference as an image</li><li class="listitem" style="list-style-type: disc">How to objectively compare two images with scientific methods</li></ul></div><div class="section" title="Getting ready"><div class="titlepage"><div><div><h2 class="title"><a id="ch09lvl2sec214"/>Getting ready</h2></div></div></div><p>In this recipe, we will continue using Pillow to compare images. Along with our <code class="literal">Image</code> class, we will also use the <code class="literal">ImageChops</code> class to get the difference between two images. We will use the <code class="literal">scipy</code> module to compare the images at the pixel level.</p><div class="orderedlist"><ol class="orderedlist arabic"><li class="listitem">We already have the Pillow module installed, so let's go ahead and install the <code class="literal">scipy</code> module using Python <code class="literal">pip</code>. On Mac OS X machine, you'll need to have a compiler to install the <code class="literal">scipy</code> module. We will install the GCC compiler on Mac with Mac's <code class="literal">brew</code> command:<pre class="programlisting">
<span class="strong"><strong>        (ch10)chetans-MacBookPro:ch10 Chetan$ brew install gcc &#13;
        Warning: Building gcc from source: &#13;
        The bottle needs the Xcode CLT to be installed. &#13;
        ==&gt; Using the sandbox &#13;
        ==&gt; Downloading https://ftpmirror.gnu.org/gcc/gcc-6.2.0/gcc-&#13;
        6.2.0.tar.bz2 &#13;
        Already downloaded: /Users/chetan/Library/Caches/Homebrew/gcc-&#13;
        6.2.0.tar.bz2 &#13;
        ==&gt; Downloading&#13;
        https://raw.githubusercontent.com/Homebrew/formula-&#13;
        patches/e9e0ee09389a54cc4c8fe1c24ebca3cd765ed0ba/gcc/6.1.0-&#13;
        jit.patch &#13;
        Already downloaded: /Users/chetan/Library/Caches/Homebrew/gcc--&#13;
        patch-     863957f90a934ee8f89707980473769cff47&#13;
        ca0663c3906992da6afb242fb220.patch &#13;
        ==&gt; Patching &#13;
        ==&gt; Applying 6.1.0-jit.patch &#13;
        patching file gcc/jit/Make-lang.in &#13;
        ==&gt; ../configure --build=x86_64-apple-darwin15.5.0 --&#13;
            prefix=/usr/local/Cellar/gcc/6.2.0 --&#13;
            libdir=/usr/local/Cellar/gcc/6.2.0/lib/gcc/6 --enable-&#13;
            languages=c,c++,objc,obj-c++,fortran&#13;
            ==&gt; make bootstrap &#13;
 &#13;
 &#13;
        ==&gt; make install &#13;
        ==&gt; Caveats &#13;
        GCC has been built with multilib support. Notably, &#13;
            OpenMP may not&#13;
        work: &#13;
            https://gcc.gnu.org/bugzilla/show_bug.cgi?id=60670 &#13;
        If you need OpenMP support you may want to&#13;
        brew reinstall gcc --without-multilib &#13;
        ==&gt; Summary &#13;
          /usr/local/Cellar/gcc/6.2.0: 1,436 files, 282.6M, built in 70&#13;
          minutes 47 seconds &#13;
          (ch10)chetans-MacBookPro:ch10 Chetan$ &#13;
</strong></span>
</pre></li><li class="listitem">Now that we have GCC installed, let's install <code class="literal">scipy</code> with <code class="literal">python-pip</code>. This is how the installation logs look on my system:<pre class="programlisting">
<span class="strong"><strong>        (ch10)chetans-MacBookPro:ch10 Chetan$ pip install scipy &#13;
        You are using pip version 7.1.0, however version 8.1.2 is&#13;
        available. &#13;
        You should consider upgrading via the 'pip install --upgrade&#13;
        pip' &#13;
        command. &#13;
        Collecting scipy &#13;
          Using cached scipy-0.18.1.tar.gz &#13;
        Building wheels for collected packages: scipy &#13;
          Running setup.py bdist_wheel for scipy &#13;
 &#13;
 &#13;
          Stored in directory: &#13;
             /Users/chetan/Library/Caches/pip/wheels/33/&#13;
             c4/f5/e00fe242696eba9e5f63cd0f30eaf5780b8c98067eb164707c &#13;
        Successfully built scipy &#13;
        Installing collected packages: scipy &#13;
        Successfully installed scipy-0.18.1 &#13;
</strong></span>
</pre></li></ol></div></div><div class="section" title="How to do it..."><div class="titlepage"><div><div><h2 class="title"><a id="ch09lvl2sec215"/>How to do it...</h2></div></div></div><div class="orderedlist"><ol class="orderedlist arabic"><li class="listitem">Now that the modules are already installed, let's start utilizing them for our needs. First, let's look at getting the difference between two images and storing the difference as an image itself. The following code does this operation:<pre class="programlisting">        from PIL import Image, ImageChops &#13;
 &#13;
        def differnce_images(path_one, path_two, diff_save_location): &#13;
            image_one = Image.open(path_one) &#13;
            image_two = Image.open(path_two) &#13;
 &#13;
            diff = ImageChops.difference(image_one, image_two) &#13;
 &#13;
            if diff.getbbox() is None: &#13;
                print "No difference in the images" &#13;
                return &#13;
            else: &#13;
                print diff.getbbox()&#13;
                diff.save(diff_save_location) &#13;
 &#13;
        differnce_images('sunset.jpg','pasted.jpg', &#13;
                         'diff.jpg') &#13;
</pre><p>In the preceding code example, we calculated the difference between the original image, <code class="literal">sunset.jpg</code>, and the copy-pasted image, <code class="literal">pasted.jpg</code> (if you remember the previous recipe, <code class="literal">pasted.jpg</code> is obtained after pasting the cropped sun image on the original sunset image). This is how the difference image looks:</p><p>
</p><div class="mediaobject"><img alt="How to do it..." src="graphics/image_09_014.jpg"/></div><p>
</p><p>Observe how the difference is only the cropped image of the sun since the base original image remains the same. Cool! What does the black region indicate? We will talk about it in the <span class="emphasis"><em>How it works...</em></span> section.</p></li><li class="listitem">Now, let's move ahead and look at calculating the difference between images in an objective manner. For this, we will use the <code class="literal">scipy</code> module. The following code example will help us with what we need:<pre class="programlisting">        from scipy.misc import imread &#13;
        from scipy.linalg import norm &#13;
 &#13;
        def compare_images(img1, img2): &#13;
            diff = img1 - img2 &#13;
            z_norm = norm(diff.ravel(), 0) &#13;
            return z_norm &#13;
 &#13;
        img1 = imread("sunset.jpg").astype(float) &#13;
        img2 = imread("pasted.jpg").astype(float) &#13;
        z_norm = compare_images(img1, img2) &#13;
        print "Pixel Difference:", z_norm &#13;
</pre><p>If we run the preceding Python code, we will get the difference in pixels in both these images. The output of our example is as follows:</p><pre class="programlisting">
<span class="strong"><strong>Pixel Difference: 246660.0</strong></span>
</pre></li></ol></div></div><div class="section" title="How it works..."><div class="titlepage"><div><div><h2 class="title"><a id="ch09lvl2sec216"/>How it works...</h2></div></div></div><p>In the first code snippet of this section, we calculated the difference between the two images using the <code class="literal">ImageChops</code> class of the Pillow library. As usual, we opened both the images with the <code class="literal">open()</code> method and got the image objects <code class="literal">image_one</code> and <code class="literal">image_two</code>, respectively.</p><p>We then used the <code class="literal">difference()</code> method of the <code class="literal">ImageChops</code> class and passed the image objects as arguments to this method. The <code class="literal">difference()</code> method returns the <code class="literal">diff</code> object, which essentially is the object representing the difference between the two images.</p><p>Finally, we saved the difference as an image on the disk with the name, <code class="literal">diff.jpg</code>. We also used the <code class="literal">getbbox()</code> method on the <code class="literal">diff</code> object, which calculates the bounding box of the nonzero regions in the image. Here nonzero regions indicate the pixels where the difference between <code class="literal">sunset.jpg</code> and <code class="literal">pasted.jpg</code> is 0.</p><p>Now, if you look at <code class="literal">diff.jpg</code>, it contains a huge black region. These are the pixels where the difference is 0, hence the color black. For same images, the <code class="literal">getbbox()</code> method returns <code class="literal">None</code>.</p><p>In the second example, we compared the two images based on zero norm, which indicates the number of pixels not equal to zero, or in other words, indicates how many pixels differ between the two images. For comparing images, we first read both the images using the <code class="literal">imread()</code> method of the <code class="literal">scipy</code> module. Both the image objects are <code class="literal">img1</code> and <code class="literal">img2</code>.</p><p>We then calculated the difference between the two images with <code class="literal">diff = img1 - img2</code>. This difference returned is of the <code class="literal">ndarray</code> type of <code class="literal">scipy</code>. When we pass this difference to the <code class="literal">norm()</code> method, it returns the number of pixels that are different between images.</p></div><div class="section" title="There's more..."><div class="titlepage"><div><div><h2 class="title"><a id="ch09lvl2sec217"/>There's more...</h2></div></div></div><p>There are multiple ways of comparing images, which we haven't covered in this chapter. I suggest you do a deeper reading into this if you're really interested. But for all practical purposes, I think this chapter should suffice.</p></div></div>
<div class="section" title="Face detection"><div class="titlepage"><div><div><h1 class="title"><a id="ch09lvl1sec77"/>Face detection</h1></div></div></div><p>We covered a lot of operations on images in the preceding sections. In this recipe, let's delve deeper and cover an advanced operation such as face detection in images.</p><div class="section" title="Getting ready"><div class="titlepage"><div><div><h2 class="title"><a id="ch09lvl2sec218"/>Getting ready</h2></div></div></div><p>In this recipe, we will use Python's <code class="literal">opencv</code> module, so let's start by installing the required module.</p><div class="orderedlist"><ol class="orderedlist arabic"><li class="listitem">For using <code class="literal">opencv</code> Python bindings, we have to first install <code class="literal">opencv</code> on our computer. On my Mac OS X machine, I use the <code class="literal">brew</code> utility to install <code class="literal">opencv</code> this way:<pre class="programlisting">        (ch10)chetans-MacBookPro:ch10 Chetan$ brew install &#13;
        homebrew/science/opencv &#13;
        ==&gt; Tapping homebrew/science &#13;
        Cloning into '/usr/local/Homebrew/Library/Taps/homebrew/homebrew-&#13;
        science'... &#13;
        ... &#13;
        ... &#13;
        ==&gt; Summary &#13;
          /usr/local/Cellar/opencv/2.4.13.1: 277 files, 35.5M &#13;
</pre></li><li class="listitem">Just installing <code class="literal">opencv</code> on your computer doesn't help. You also need to point the <code class="literal">cv2.so</code> (<code class="literal">.so</code> stands for shared object or library) to glue it with a virtual environment using the following commands:<pre class="programlisting">        cd ch10/lib/python2.7/site-packages/  &#13;
        ln -s /usr/local/Cellar/opencv/2.4.13.1/lib/python2.7/site-&#13;
        packages/cv.py &#13;
        ln -s /usr/local/Cellar/opencv/2.4.13.1/lib/python2.7/site- &#13;
        packages/cv2.so &#13;
</pre></li></ol></div><p>Cool! So, we now have <code class="literal">opencv</code> installed, which is required for our examples in this recipe.</p></div><div class="section" title="How to do it..."><div class="titlepage"><div><div><h2 class="title"><a id="ch09lvl2sec219"/>How to do it...</h2></div></div></div><div class="orderedlist"><ol class="orderedlist arabic"><li class="listitem">Go to your favorite editor, create a Python file, and name it <code class="literal">face_detection.py</code>. Now, copy the following code into the Python file:<pre class="programlisting">        import cv2 &#13;
 &#13;
        face_cascade = cv2.CascadeClassifier('haarcascade.xml') &#13;
        original_image_path = 'Chetan.jpeg' &#13;
 &#13;
        image = cv2.imread(original_image_path) &#13;
 &#13;
        faces = face_cascade.detectMultiScale( &#13;
            image, scaleFactor=1.1, minNeighbors=3, &#13;
            minSize=(30, 30), flags=cv2.cv.CV_HAAR_SCALE_IMAGE) &#13;
 &#13;
        for (x, y, w, h) in faces: &#13;
            cv2.rectangle(image, (x, y), (x + w, y + h), (0, 255, 0), 2) &#13;
 &#13;
        cv2.imwrite('chetan_face.jpg', image) &#13;
</pre></li><li class="listitem">Now, create an XML file by the name <code class="literal">haarcascade.xml</code> and copy the contents from the code repository of this book. In my example, I am using one of the pictures of myself, <code class="literal">Chetan.jpeg</code>, but you can use any of your pictures for this example. Here's how <code class="literal">Chetan.jpeg</code> looks:<p>
</p><div class="mediaobject"><img alt="How to do it..." src="graphics/image_09_015.jpg"/></div><p>
</p></li><li class="listitem">Now, let's run the Python code and see if our code is able to recognize my face from the image. We run the code with the command <code class="literal">python face_detection.py</code> and it generates an image, <code class="literal">Chetan_face.jpg</code>, which looks like the following. Indeed, it did detect my face.<p>
</p><div class="mediaobject"><img alt="How to do it..." src="graphics/image_09_016.jpg"/></div><p>
</p></li></ol></div></div><div class="section" title="How it works..."><div class="titlepage"><div><div><h2 class="title"><a id="ch09lvl2sec220"/>How it works...</h2></div></div></div><p>In our recipe, we used the <code class="literal">opencv</code> module to first create a cascade classifier object with the <code class="literal">haarcascade.xml</code> file. We called this object <code class="literal">face_cascade</code>.</p><p>Object detection using Haar's feature-based cascade classifiers is an effective object detection method proposed by Paul Viola and Michael Jones in 2001. It is a machine learning-based approach, where a cascade function is trained from a lot of positive and negative images. It is then used to detect objects in other images.</p><p>Haar features are fed into a standard XML file, which is what we used in our code example. You can actually train your classifier to detect the objects you wish. For instance, eye detection uses another classifier.</p><p>Next, we read the original base image, <code class="literal">Chetan.jpeg</code>, using the <code class="literal">opencv</code> module's <code class="literal">imread()</code> method and defined the smallest window for detection.</p><p>In fact, Haar cascade classifier works on a sliding window approach and hence needs the smallest window for detection. The classifier also needs to have <code class="literal">minNeighbors</code> configured.</p><p>Settings such as these are configured in the <code class="literal">detectMultiScale()</code> method of the cascade object. We have set <code class="literal">minSize=(30,30)</code> and <code class="literal">minNeighbors=3</code>.</p><p>Finally, we stored the detected image on the disk and the original image has a green rectangle as an indication of face detection on the image.</p></div><div class="section" title="There's more..."><div class="titlepage"><div><div><h2 class="title"><a id="ch09lvl2sec221"/>There's more...</h2></div></div></div><p>We looked at a very simple example of face detection with <code class="literal">opencv</code> and learned a bit about classifiers. <code class="literal">opencv</code> has more things that you may want to learn about.</p><p>Here's a link to a resource that you will find interesting to read: <a class="ulink" href="http://docs.opencv.org/trunk/index.html">http://docs.opencv.org/trunk/index.html</a>.</p></div></div>
<div class="section" title="Imaging as a business process"><div class="titlepage"><div><div><h1 class="title"><a id="ch09lvl1sec78"/>Imaging as a business process</h1></div></div></div><p>Peter is an IT manager at MBI Inc, a big corporation. His company has been in existence for long enough for a majority of the contractual finance documents, standard operating procedures, and supply chain documents to be paper-based. He is tasked with this humongous responsibility of making his company go paperless.</p><p>This means that he is responsible for eliminating the hassle and cost of managing paper archives. With the imaging knowledge we have gathered so far (and we will learn more) in this chapter, let's see if we can help Peter.</p><p>If you carefully analyze, Peter needs to achieve two important tasks:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">Scan the papers and store them in an electronic format as images</li><li class="listitem" style="list-style-type: disc">Generate text files from these documents so that they can be easily indexed</li></ul></div><div class="section" title="Getting ready"><div class="titlepage"><div><div><h2 class="title"><a id="ch09lvl2sec222"/>Getting ready</h2></div></div></div><p>For this exercise, let's start by installing the required modules. We will need the following modules:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc"><code class="literal">scikit-image</code> (<a class="ulink" href="http://scikit-image.org/">http://scikit-image.org/</a>)</li><li class="listitem" style="list-style-type: disc"><code class="literal">pyimagesearch</code> (<a class="ulink" href="http://www.pyimagesearch.com/">http://www.pyimagesearch.com/</a>)</li><li class="listitem" style="list-style-type: disc"><code class="literal">tessaract</code> and <code class="literal">pytesseract</code> (<a class="ulink" href="https://pypi.python.org/pypi/pytesseract/">https://pypi.python.org/pypi/pytesseract/</a>)</li></ul></div><p>Let's start installing the modules:</p><div class="orderedlist"><ol class="orderedlist arabic"><li class="listitem">Let's first start with <code class="literal">scikit-image</code>:<pre class="programlisting">
<span class="strong"><strong>(ch10)chetans-MacBookPro:ch10 Chetan$ pip install scikit-image</strong></span>
<span class="strong"><strong>You are using pip version 7.1.0, however version 8.1.2 is&#13;
        available.</strong></span>
<span class="strong"><strong>You should consider upgrading via the 'pip install --upgrade&#13;
        pip' command.</strong></span>
<span class="strong"><strong>Collecting scikit-image</strong></span>
<span class="strong"><strong>      Downloading scikit-image-0.12.3.tar.gz (20.7MB)</strong></span>
<span class="strong"><strong>        100% |████████████████████████████████| 20.7MB 19kB/s </strong></span>
<span class="strong"><strong>Requirement already satisfied (use --upgrade to upgrade):&#13;
        six&gt;=1.7.3 in ./lib/python2.7/site-packages (from scikit-image)</strong></span>
<span class="strong"><strong>Collecting networkx&gt;=1.8 (from scikit-image)</strong></span>
<span class="strong"><strong>      Downloading networkx-1.11-py2.py3-none-any.whl (1.3MB)</strong></span>
<span class="strong"><strong>        100% |████████████████████████████████| 1.3MB 325kB/s </strong></span>
<span class="strong"><strong>Requirement already satisfied (use --upgrade to upgrade): &#13;
        pillow&gt;=2.1.0 in ./lib/python2.7/site-packages (from scikit-&#13;
        image)</strong></span>
<span class="strong"><strong>Collecting dask[array]&gt;=0.5.0 (from scikit-image)</strong></span>
<span class="strong"><strong>      Downloading dask-0.11.1-py2.py3-none-any.whl (375kB)</strong></span>
<span class="strong"><strong>        100% |████████████████████████████████| 376kB 946kB/s </strong></span>
<span class="strong"><strong>Collecting decorator&gt;=3.4.0 (from networkx&gt;=1.8-&gt;scikit-image)</strong></span>
<span class="strong"><strong>    Using cached decorator-4.0.10-py2.py3-none-any.whl</strong></span>
<span class="strong"><strong>Collecting toolz&gt;=0.7.2 (from dask[array]&gt;=0.5.0-&gt;scikit-image)</strong></span>
<span class="strong"><strong>  Using cached toolz-0.8.0.tar.gz</strong></span>
<span class="strong"><strong>Requirement already satisfied (use --upgrade to upgrade):&#13;
        numpy in &#13;
        ./lib/python2.7/site-packages (from dask[array]&gt;=0.5.0-&gt;scikit-&#13;
        image)</strong></span>
<span class="strong"><strong>Building wheels for collected packages: scikit-image, toolz</strong></span>
<span class="strong"><strong>      Running setup.py bdist_wheel for scikit-image</strong></span>
<span class="strong"><strong>      Stored in directory:&#13;
/Users/chetan/Library/Caches/pip/wheels/d5/e8/77/925fe026d562a74a0bccf1c7dd47d00f5f6ab2d395f247e674</strong></span>
<span class="strong"><strong>      Running setup.py bdist_wheel for toolz</strong></span>
<span class="strong"><strong>      Stored in directory: /Users/chetan/Library/Caches/pip/wheels/b0/84/bf/7089262387e8ea60bdefb1fdb84d2ee99427f6d09c9c7ba37d</strong></span>
<span class="strong"><strong>Successfully built scikit-image toolz</strong></span>
<span class="strong"><strong>Installing collected packages: decorator, networkx, toolz,&#13;
        dask,&#13;
        scikit-image</strong></span>
<span class="strong"><strong>Successfully installed dask-0.11.1 decorator-4.0.10 networkx-&#13;
        1.11 &#13;
        scikit-image-0.12.3 toolz-0.8.0</strong></span>
</pre></li><li class="listitem">Next, let's install <code class="literal">pyimagesearch</code>. This is a nice set of libraries developed by Adrian Rosebrock. He has his work open-sourced at <a class="ulink" href="https://github.com/jrosebr1">https://github.com/jrosebr1</a>. We, in fact, leverage the scanner example of <code class="literal">pyimagesearch</code> in this code recipe.</li><li class="listitem">Lastly, let's install <code class="literal">tesseract</code> and <code class="literal">pytesseract</code>. We need to install <code class="literal">tesseract</code>, an <span class="strong"><strong>Optical Character Reader</strong></span> (<span class="strong"><strong>OCR</strong></span>) module, and <code class="literal">pytesseract</code>, a Python module to work with the OCR module:<pre class="programlisting">
<span class="strong"><strong>(ch10)chetans-MacBookPro:ch10 Chetan$ brew install tesseract</strong></span>
<span class="strong"><strong>==&gt; <span class="strong"><strong>Auto-updated Homebrew!</strong></span>
</strong></span>
<span class="strong"><strong>Updated 4 taps (homebrew/core, homebrew/dupes, homebrew/python,&#13;
        homebrew/science).</strong></span>
<span class="strong"><strong>..</strong></span>
<span class="strong"><strong>..</strong></span>
<span class="strong"><strong>..</strong></span>
<span class="strong"><strong>==&gt; <span class="strong"><strong>Installing dependencies for tesseract: leptonica</strong></span>
</strong></span>
<span class="strong"><strong>==&gt; <span class="strong"><strong>Installing tesseract dependency: leptonica</strong></span>
</strong></span>
<span class="strong"><strong>==&gt; <span class="strong"><strong>Downloading https://homebrew.bintray.com/bottles/leptonica-&#13;
        1.73.el_capitan.bottle.tar.gz&#13;
</strong></span>
</strong></span>
<span class="strong"><strong>#######################################################&#13;
          ################    # 100.0%</strong></span>
<span class="strong"><strong>==&gt; <span class="strong"><strong>Pouring leptonica-1.73.el_capitan.bottle.tar.gz</strong></span>
</strong></span>
<span class="strong"><strong>   /usr/local/Cellar/leptonica/1.73: 50 files, 5.4M</strong></span>
<span class="strong"><strong>==&gt; <span class="strong"><strong>Installing tesseract</strong></span>
</strong></span>
<span class="strong"><strong>==&gt; <span class="strong"><strong>Downloading https://homebrew.bintray.com/bottles/tesseract-&#13;
        3.04.01_2.el_capitan.bottle.tar.gz</strong></span>
</strong></span>
<span class="strong"><strong>########################################################&#13;
          ###############    # 100.0%</strong></span>
<span class="strong"><strong>==&gt; <span class="strong"><strong>Pouring tesseract-3.04.01_2.el_capitan.bottle.tar.gz</strong></span>
</strong></span>
<span class="strong"><strong>  /usr/local/Cellar/tesseract/3.04.01_2: 76 files, 39M</strong></span>
<span class="strong"><strong>(ch10)chetans-MacBookPro:ch10 Chetan$ pip install pytesseract</strong></span>
<span class="strong"><strong>Collecting pytesseract</strong></span>
<span class="strong"><strong>      Downloading pytesseract-0.1.6.tar.gz (149kB)</strong></span>
<span class="strong"><strong>        100% |████████████████████████████████| 151kB 201kB/s </strong></span>
<span class="strong"><strong>Building wheels for collected packages: pytesseract</strong></span>
<span class="strong"><strong>      Running setup.py bdist_wheel for pytesseract</strong></span>
<span class="strong"><strong>      Stored in directory: &#13;
          /Users/chetan/Library/Caches/pip/wheels/f2/27/64/&#13;
          a8fa99a36b38980aaf8d1d2c87f5dd6b5a0a274b8706e3df36</strong></span>
<span class="strong"><strong>Successfully built pytesseract</strong></span>
<span class="strong"><strong>Installing collected packages: pytesseract</strong></span>
<span class="strong"><strong>Successfully installed pytesseract-0.1.6</strong></span>
</pre></li></ol></div><p>OK, cool! Now, let's look at the code in the <span class="emphasis"><em>How to do it...</em></span> section.</p></div><div class="section" title="How to do it..."><div class="titlepage"><div><div><h2 class="title"><a id="ch09lvl2sec223"/>How to do it...</h2></div></div></div><div class="orderedlist"><ol class="orderedlist arabic"><li class="listitem">Go to your favorite editor, create a Python file, and name it <code class="literal">scanner.py</code>. For Peter, it would be all about his financial documents, which are in the image format, but for the sake of this example, it'll be an image that I have handy with me. Here's how my image looks. It's the picture of a newspaper article on Andy Murray and I'm trying to digitalize it:<p>
</p><div class="mediaobject"><img alt="How to do it..." src="graphics/image_09_017-e1485235547936.jpg"/></div><p>
</p></li><li class="listitem">Now, copy the following code in <code class="literal">scanner.py</code> and run the code with the command, <code class="literal">python scanner.py</code>:<pre class="programlisting">
<span class="strong"><strong>
<span class="strong"><strong>        from </strong></span>pyimagesearch.transform <span class="strong"><strong>import </strong></span>four_point_transform&#13;
</strong></span>
<span class="strong"><strong>
<span class="strong"><strong>        from </strong></span>pyimagesearch <span class="strong"><strong>import </strong></span>imutils&#13;
</strong></span>
<span class="strong"><strong>
<span class="strong"><strong>        from </strong></span>skimage.filters i<span class="strong"><strong>mport </strong></span>threshold_adaptive</strong></span> &#13;
        import cv2 &#13;
 &#13;
 &#13;
        image = cv2.imread("images/murray.jpg") &#13;
        ratio = image.shape[0] / 500.0 &#13;
        orig = image.copy() &#13;
        image = imutils.resize(image, height = 500) &#13;
        gray = cv2.cvtColor(image, cv2.COLOR_BGR2GRAY) &#13;
        gray = cv2.GaussianBlur(gray, (5, 5), 0) &#13;
        edged = cv2.Canny(gray, 75, 200) &#13;
        cv2.imwrite('scan_edge.jpg', edged) &#13;
 &#13;
 &#13;
        (cnts, _) = cv2.findContours(edged.copy(), cv2.RETR_LIST,&#13;
        cv2.CHAIN_APPROX_SIMPLE) &#13;
        cnts = sorted(cnts, key = cv2.contourArea, reverse = True)[:5]&#13;
        for c in cnts: &#13;
           peri = cv2.arcLength(c, True) &#13;
           approx = cv2.approxPolyDP(c, 0.02 * peri, True) &#13;
           if len(approx) == 4: &#13;
              screenCnt = approx &#13;
              break &#13;
        cv2.drawContours(image,  &#13;
                [screenCnt], -1, (0, 255, 0), 2) &#13;
        cv2.imwrite('scan_contours.jpg', image) &#13;
 &#13;
 &#13;
        warped = four_point_transform(orig, screenCnt.reshape(4, 2) *&#13;
        ratio) &#13;
        warped = cv2.cvtColor(warped, cv2.COLOR_BGR2GRAY) &#13;
        warped = threshold_adaptive(warped, 251, offset = 10) &#13;
        warped = warped.astype("uint8") * 255 &#13;
        cv2.imwrite('scanned.jpg', warped) &#13;
 &#13;
        print "Printing the contents of the image:" &#13;
        from PIL import Image &#13;
        img = Image.open("scanned.jpg") &#13;
        import pytesseract &#13;
<span class="strong"><strong>
<span class="strong"><strong>        print</strong></span>(pytesseract.image_to_string(img))</strong></span>
</pre><p>Once you run the Python code, you will see three images being created on your hard disk. The first one is the edge-detected image, which, in my case, looks as follows. It's saved as <code class="literal">scan_edge.jpg</code>:</p><p>
</p><div class="mediaobject"><img alt="How to do it..." src="graphics/image_09_018.jpg"/></div><p>
</p></li><li class="listitem">Next, we get another image, which detects the whole area of the image where text is found. This is called the contours image and is generated as <code class="literal">scan_contours.jpg</code>. See how it highlights the portion of the image where text is available:<p>
</p><div class="mediaobject"><img alt="How to do it..." src="graphics/image_09_019.jpg"/></div><p>
</p></li><li class="listitem">Finally, we get the scanned copy of our news article on Andy Murray, and it is saved as <code class="literal">scanned.jpg</code>. Look how well the news article got scanned in the following screenshot:<p>
</p><div class="mediaobject"><img alt="How to do it..." src="graphics/image_09_020.jpg"/></div><p>
</p><p>Cool, this is the exact thing we wanted to achieve when we first started, isn't it? Give this to Peter and he will be very happy. He might be thinking of some costly consulting companies or scanners to do this job, while we could do it quickly and that too for free!</p></li><li class="listitem">As if this was not enough, we have done more for Peter here. If you run the program, you will also get a text output, which gives out the text of the complete article. Using this text, Peter can choose to classify the documents and index them accordingly:<pre class="programlisting">
<span class="strong"><strong>Printing the contents of the image:</strong></span>
<span class="strong"><strong>Vienna: Andy Murray's pm"</strong></span>
<span class="strong"><strong>suitof the world No. Iranking</strong></span>
<span class="strong"><strong>was severely tested by Slovak</strong></span>
<span class="strong"><strong>leﬁ-hander Martin Klizan in</strong></span>
<span class="strong"><strong>his Vienna openeron Wednwo</strong></span>
<span class="strong"><strong>day before the British star</strong></span>
<span class="strong"><strong>clinched a 6-3, 64 (57), 6-0 win.</strong></span>
<span class="strong"><strong>The 29-year-old Wimble-</strong></span>
<span class="strong"><strong>don and Olympic champion,</strong></span>
<span class="strong"><strong>who is closing in on Novak</strong></span>
<span class="strong"><strong>, Djokovic's top ranking, took</strong></span>
<span class="strong"><strong>his season record to 66 wins</strong></span>
<span class="strong"><strong>and just ninelosses. ﬂ</strong></span>
</pre></li></ol></div><p>Awesome! Let's look at the internals of our program in the "How it works" section.</p></div><div class="section" title="How it works..."><div class="titlepage"><div><div><h2 class="title"><a id="ch09lvl2sec224"/>How it works...</h2></div></div></div><p>In our recipe, we started by taking a picture of our newspaper article. We named this as <code class="literal">murray.jpg</code>. I used a simple camera phone to take this image. We then went ahead and read the image using the <code class="literal">opencv</code> module's <code class="literal">imread()</code> method.</p><p>We also computed the ratio of the original height to the new height, cloned the original image, and resized it. We used the <code class="literal">copy()</code> method to clone our image, and we used the <code class="literal">resize()</code> method to resize it to a new height.</p><p>We then converted the image to the grayscale format with the <code class="literal">cvtColor()</code> method and then applied the Gaussian filter to blur the image.</p><p>We subjected the blurred image to detect the edges of the text using the <code class="literal">Canny()</code> method and finally stored the edge-detected image as <code class="literal">scan_edge.jpg</code>.</p><p>Next, we found the contours of the image using the <code class="literal">findContours()</code> method and stored the outline of the image as <code class="literal">scan_contours.jpg</code>.</p><p>We then ran a couple of transforms on the image. The four-point transform helped us get a top-down view of the original image. For this, we used the <code class="literal">four_point_transform()</code> method.</p><p>We also converted the image to grayscale and then thresholded it to give a black and white paper style feel. The <code class="literal">cvtColor()</code> method converts the image to grayscale and the <code class="literal">threshold_adaptive()</code> method applies the appropriate thresholds. And we're done; the image is now ready and is already scanned and saved as <code class="literal">scanned.jpg</code>.</p><p>But, as we saw in the previous section, we also printed the text of the newspaper column. This we could achieve by first reading the scanned image with Pillow's <code class="literal">Image</code> class and with the <code class="literal">pytessaract</code> module by using the <code class="literal">image_to_string()</code> method on the image object.</p><p>Cool, so we have automated the business process of converting paper-based documents into the electronic format and added a facility to index the files so that they can be easily fed into the company's ERP processes. Peter is damn happy with you! Congrats!</p></div><div class="section" title="There's more..."><div class="titlepage"><div><div><h2 class="title"><a id="ch09lvl2sec225"/>There's more...</h2></div></div></div><p>We looked at OCR to extract text data from scanned images, but there are many more things that can be achieved, such as intelligent character recognition (extracts hand-written text) and barcode recognition (recognition of many types of barcodes), among others. Also, in this chapter we haven't dealt much with image filtering. If you're really interested, you can do lot of reading on these topics, which is beyond the scope of this chapter.</p></div></div></body></html>