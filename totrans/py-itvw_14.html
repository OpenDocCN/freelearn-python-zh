<html><head></head><body><div class="chapter" title="Chapter&#xA0;14.&#xA0;Steven Lott"><div class="titlepage"><div><div><h1 class="title"><a id="ch14"/>Chapter 14. Steven Lott</h1></div></div></div><div class="mediaobject"><img src="graphics/B08180_15_01.jpg" alt="Steven Lott"/></div><p>Steven Lott<a id="id365" class="indexterm"/> is an American software developer and author. He is an associate for the bank holding company Capital One and uses Python to build APIs for new products. Previously, he worked as a solution architect for CTG, which provides IT services. In 2003, Steven started using his talent<a id="id366" class="indexterm"/> for solving problems with <a id="id367" class="indexterm"/>Python to write books. He has since authored titles including <span class="emphasis"><em>Modern Python Cookbook</em></span>, <span class="emphasis"><em>Python for Secrets Agents</em></span>, and <span class="emphasis"><em>Functional Python Programming</em></span>. Steven <a id="id368" class="indexterm"/>creates educational content for the Python community and writes a tech blog.</p><div class="blockquote"><blockquote class="blockquote"><p>
<span class="strong"><strong>Discussion themes: Python pros and cons, Python books, v3.6.</strong></span>
</p><p>
<span class="strong"><strong>Catch up with Steven Lott here: @s_lott</strong></span>
</p></blockquote></div><p>
<span class="strong"><strong>Mike Driscoll</strong></span>: So<a id="id369" class="indexterm"/> why did you become a programmer?</p><p>
<span class="strong"><strong>Steven Lott</strong></span>: I started programming in the 1970s, when computers were rare. My school had two Olivetti Programma 101 calculators and an IBM 1620 computer.</p><p>It was empowering being able to create useful behavior on these machines, such as simulating random events, drawing things and trying to design new kinds of games. A responsive and autonomous device was the ultimate toy, even when doing math homework. The idea of building things that were new and useful via software was compelling. Also, I had <a id="id370" class="indexterm"/>a bunch of friends who hung around in the computer room.</p><p>
<span class="strong"><strong>Driscoll</strong></span>: How did you<a id="id371" class="indexterm"/> start using Python?</p><p>
<span class="strong"><strong>Lott</strong></span>: In the late 90s, as object-oriented programming was building momentum, I started tracking the popular languages.</p><p>I had a Macintosh with the port of Smalltalk-80, the THINK C++ compiler and a JDK 1.1. I made regular searches for emerging object-oriented programming technology and eventually found Python.</p><div class="blockquote"><blockquote class="blockquote"><p>
<span class="strong"><strong>Steven Lott: 'The barriers to entry for Python were so much lower than the other languages that I had learned.'</strong></span>
</p></blockquote></div><p>The barriers to entry for Python were so much lower than the other languages that I had learned. There was only a runtime and no complex toolchain required to build software. Python was replacing Perl, AWK, sed, and grep with one tool that handled a variety of use cases. By 2000, I was trying to build useful and working applications in Python.</p><p>
<span class="strong"><strong>Driscoll</strong></span>: What did you like about Python?</p><p>
<span class="strong"><strong>Lott</strong></span>: At first, I was drawn to the<a id="id372" class="indexterm"/> elegant simplicity of Python. The standard library provided an amazing array of tools. As I learned more, the vast ecosystem of modules and packages outside of the standard library showed me how much could be done.</p><p>I used Python at work because I could solve a problem quickly. The language was wonderful for complex data wrangling problems. In many cases, success stemmed from getting started quickly and discovering the nuances and complications of a problem as early as possible. Python encourages you to fail quickly and start again on a new course.</p><div class="blockquote"><blockquote class="blockquote"><p>
<span class="strong"><strong>Steven Lott: 'Python encourages you to fail quickly and start again on a new course.'</strong></span>
</p></blockquote></div><p>The more that I learn about NumPy, the more that I see Python as a kind of universal container for code. The NumPy libraries are based on C (and Fortran), so having a Python wrapper makes them widely available and useful.</p><p>The underlying reason for using Python wasn't clear to me until Guido van Rossum's keynote speech at PyCon 2016. Python's biggest strength stems from the community. Python's open source nature creates and encourages a community effort to build cool new things.</p><div class="blockquote"><blockquote class="blockquote"><p>
<span class="strong"><strong>Steven Lott: 'Python's biggest strength stems from the community.'</strong></span>
</p></blockquote></div><p>Python has numerous <a id="id373" class="indexterm"/>other strengths, such as its wide adoption as a language. Python is used in numerous contexts: scientists are using it to analyze truly gigantic datasets and it's used to build scalable web services too. Python is also used recreationally by home hackers who are integrating their Alexa, Nest, and Arduino-based temperature sensors.</p><p>Another strength of Python is sometimes called <span class="emphasis"><em>batteries included</em></span>. With a single download, you have all the tools you want. If you want to learn the language, then you can start with the distribution for your computer. If you want to do data science, then you can start with the Anaconda distribution, which is where lots of packages are bundled.</p><p>The Python Software Foundation (PSF) makes active steps to be as inclusive as possible. The philosophy is that everyone should be able to learn and share their findings. Python's community believes that nobody should be excluded. We're all using Python to solve problems, so we all need help.</p><p>
<span class="strong"><strong>Driscoll</strong></span>: What are <a id="id374" class="indexterm"/>Python's weaknesses as a language?</p><p>
<span class="strong"><strong>Lott</strong></span>: I've collected a few lists of Python's weaknesses. Some of them are utterly farcical and I've seen many sentiments which make no sense at all. A few complaints about Python are meaningful.</p><p>Overall, I've learned that most problems that are blamed on the Python language being slow are more often than not due to ineffective algorithm and data structure choices.</p><div class="blockquote"><blockquote class="blockquote"><p>
<span class="strong"><strong>Steven Lott: 'Python's core runtime is remarkably fast.'</strong></span>
</p></blockquote></div><p>Python's core runtime is remarkably fast. Fortran and C are considerably faster because they have optimizing compilers, that produce code focused on the underlying chipset. The SciPy and NumPy use of binary code wrapped in Python addresses this concern nicely.</p><p>Another issue is the opportunity for <a id="id375" class="indexterm"/>confusion when using Python. The orthogonality between language statements and data structures means that lists, sets, and dictionaries have some overlapping features. The immensely sophisticated implementation of Python data structures makes it possible to make a bad choice and get correct answers, but have horribly inefficient code.</p><p>Lastly, a weakness for Python is the possibility of creating inheritance problems. Everything is dynamic, so it can be difficult for tools like Pylint to discern meaningful method redefinitions from spelling mistakes with similar-looking method names and plain bad design.</p><p>The <code class="literal">collections.abc</code> module<a id="id376" class="indexterm"/> has decorators that can be used to organize code and provide some help with checking redefinitions. The type definitions in the <code class="literal">typing</code> module allow mypy to locate potential problems.</p><p>
<span class="strong"><strong>Driscoll</strong></span>: So how did you end up becoming an author of Python books?</p><p>
<span class="strong"><strong>Lott</strong></span>: Most roles in my career more or less just happened to me, but becoming a writer was a conscious decision.</p><p>In this case, I had decided that there could be value in teaching the Python language and the associated software engineering skills. I started to collect notes for a book in 2002. By 2010, I had tried self-publishing several books on Python.</p><div class="blockquote"><blockquote class="blockquote"><p>
<span class="strong"><strong>Steven Lott: 'Over a few years, I answered thousands of questions about Python and somehow built up a large reputation.'</strong></span>
</p></blockquote></div><p>When Stack Overflow started, I was an early participant. There were many interesting Python questions. The questions showed gaps where more information was needed about Python specifically and software engineering in general. Over a few years, I answered thousands of questions about Python and somehow built up a large reputation.</p><p>
<span class="strong"><strong>Driscoll</strong></span>: What have you <a id="id377" class="indexterm"/>learned in the writing process?</p><p>
<span class="strong"><strong>Lott</strong></span>: I've learned about the difficulty of creating meaningful and interesting examples. An example needs to have a story arc and a problem that requires a solution.</p><p>Stories require drama and conflict, and that doesn't often surface when thinking about data structures and algorithms. I spend more time wandering around trying to think of examples than doing any other part of the writing process. A lot of the problems that I come up with are too large and complex.</p><p>A snippet of code is <a id="id378" class="indexterm"/>difficult to describe if it doesn't solve a problem.</p><p>For example, the traveling salesman problem has a compelling story arc that characterizes graph traversal. Having a story provides a framework for remembering the essential problem and seeing how the solution works. Pure code doesn't help anyone to understand why the language construct is important. Code only exists to solve a problem, so it's imperative to describe the problem.</p><div class="blockquote"><blockquote class="blockquote"><p>
<span class="strong"><strong>Steven Lott: 'Pure code doesn't help anyone to understand why the language construct is important. Code only exists to solve a problem, so it's imperative to describe the problem.'</strong></span>
</p></blockquote></div><p>Creating stories requires the time to view the problem from a distance, which is essential for summarizing and abstracting out needless details. Finding the right details requires a deep understanding. I know that I've failed when the description of the code becomes long and complex, involving tangential topics.</p><p>
<span class="strong"><strong>Driscoll</strong></span>: What are the pros and cons of self-publishing<a id="id379" class="indexterm"/> your books versus using a regular publisher?</p><p>
<span class="strong"><strong>Lott</strong></span>: The difference between <a id="id380" class="indexterm"/>self-publishing and using a publisher is editing. The way that Python handles documentation testing (via the <code class="literal">doctest</code> module) means that the technical aspects of the content can be validated automatically. I've become better at this, but there are still some testing gaps in my published code.</p><p>Other challenges are grammar, usage, clarity, precision, color, unity, coherence, and concision. With Packt Publishing, there's a pipeline of editors who ask questions and notice the incomprehensible parts, long before my book lands in the hands of a reader.</p><p>When I self-published, I did what seemed best to me. Publishers manage costs, prices, and revenue streams adroitly. My job is to know Python and Packt Publishing handles the rest.</p><p>
<span class="strong"><strong>Driscoll</strong></span>: Have you <a id="id381" class="indexterm"/>learned anything from your readers? If so, what?</p><p>
<span class="strong"><strong>Lott</strong></span>: My readers have taught me the importance of using the Python <code class="literal">doctest</code> tool for checking each example in the body of a book. Readers have spotted numerous errors from code that I didn't check properly.</p><p>
<span class="strong"><strong>Driscoll</strong></span>: What has been your <a id="id382" class="indexterm"/>favorite interaction with a reader?</p><p>
<span class="strong"><strong>Lott</strong></span>: I work for a tech company in Northern Virginia. A co-worker was surprised to find out that I'd written <span class="emphasis"><em>Mastering Object-Oriented Python</em></span>. They had bought the book based on recommendations and read the outline, without really looking at the author's name.</p><p>
<span class="strong"><strong>Driscoll</strong></span>: So which of your books has been the most popular? Why do you think that people buy one book over another?</p><p>
<span class="strong"><strong>Lott</strong></span>: My most <a id="id383" class="indexterm"/>successful book has been <span class="emphasis"><em>Python for Secret Agents</em></span>. It seems like the fun factor is part of that. If a book has a wide variety of fun exercises and problems, then readers can see how Python applies to the problems that they know and want to solve. If the book is too narrowly focused on one problem domain, or too abstract, then the practical applications become hard to envision.</p><p>
<span class="strong"><strong>Driscoll</strong></span>: What new and exciting trends<a id="id384" class="indexterm"/> are you seeing in Python?</p><p>
<span class="strong"><strong>Lott</strong></span>: Python 3.6 is fast and getting faster. The developers working on foundational algorithms have done impressive things.</p><div class="blockquote"><blockquote class="blockquote"><p>
<span class="strong"><strong>Steven Lott: 'Python 3.6 is fast and getting faster. The developers working on foundational algorithms have done impressive things.'</strong></span>
</p></blockquote></div><p>The new internal data structures for the <code class="literal">dict</code> save memory and run faster. This kind of internal re-engineering is exciting. There are huge benefits that come from having an upgrade with few visible changes to the language.</p><p>Another exciting direction that Python is going in is connected to the mypy project and the type hints. You have a handy quality tool that doesn't involve a profound change to the language, or the development tools. This can help you to write more reliable code, without introducing significant overheads. If mypy becomes part of Pylint or Pyflakes, then that will help even more.</p><p>As an Arduino maker, I often<a id="id385" class="indexterm"/> collect data for later analysis using Python-based tools. My current project involves a customized GPS tracker, which will be used on a boat to monitor its position while at anchor. An alarm will sound when the vessel is drifting. There are numerous other examples of Internet of things (IoT) projects, where Python is an important part of the overall effort to build something new and useful.</p><p>
<span class="strong"><strong>Driscoll</strong></span>: Do you see Python becoming a popular language for embedded programming now that MicroPython is becoming popular?</p><p>
<span class="strong"><strong>Lott</strong></span>: Yes, MicroPython<a id="id386" class="indexterm"/> and the pyboard are exciting new developments. Raspberry Pis also <a id="id387" class="indexterm"/>run Python nicely.</p><div class="blockquote"><blockquote class="blockquote"><p>
<span class="strong"><strong>Steven Lott: 'MicroPython and the pyboard are exciting new developments.'</strong></span>
</p></blockquote></div><p>Processors continue to become faster and smaller, which means that more sophisticated languages can be used. One of the first computers that I ever used had 20K of memory and was the size of an upright piano. My first Apple II Plus had 64K of memory and covered the top of a desk. A pyboard has 1M of ROM and 192K of RAM in a package which is just over two square inches.</p><p>
<span class="strong"><strong>Driscoll</strong></span>: Thank you, Steven Lott.</p></div></body></html>