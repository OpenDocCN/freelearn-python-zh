<html><head></head><body>
  <div id="sbo-rt-content"><div class="chapter" title="Chapter 9. Working with the Cloud"><div class="titlepage"><div><div><h1 class="title"><a id="ch09"/>Chapter 9. Working with the Cloud</h1></div></div></div><p>In this chapter, we will take advantage of many cloud services to publish and visualize data collected for sensors and to establish bi-directional communications between Internet-connected things. We will cover the following topics:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">Publishing data to the cloud with dweepy and <code class="literal">dweet.io</code></li><li class="listitem" style="list-style-type: disc">Building a web-based dashboard with freeboard.io</li><li class="listitem" style="list-style-type: disc">Sending and receiving data in real time through Internet with PubNub</li><li class="listitem" style="list-style-type: disc">Publishing messages with commands through the PubNub cloud</li><li class="listitem" style="list-style-type: disc">Working with bi-directional communications between IoT devices and other devices</li><li class="listitem" style="list-style-type: disc">Publishing messages to the cloud with a Python PubNub client</li><li class="listitem" style="list-style-type: disc">Using the MQTT protocol with Mosquitto and Eclipse Paho</li><li class="listitem" style="list-style-type: disc">Publishing messages to a Mosquitto broker with a Python client</li></ul></div><div class="section" title="Publishing data to the cloud with dweepy"><div class="titlepage"><div><div><h1 class="title"><a id="ch09lvl1sec84"/>Publishing data to the cloud with dweepy</h1></div></div></div><p>In <a class="link" href="ch08.html" title="Chapter 8. Displaying Information and Performing Actions">Chapter 8</a>, <span class="emphasis"><em>Displaying Information and Performing Actions</em></span>, we worked with a digital temperature <a id="id423" class="indexterm"/>and humidity sensor combined with displays and a servo. Now, we want to take advantage of two cloud services to<a id="id424" class="indexterm"/> build a real time and interactive web-based dashboard that allows us to watch gauges with the following information in a web browser:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">Ambient temperature measured in degrees Fahrenheit (ºF)</li><li class="listitem" style="list-style-type: disc">Ambient temperature measured in degrees Celsius (ºC)</li><li class="listitem" style="list-style-type: disc">Ambient humidity level expressed in percentage (%)</li></ul></div><p>First, we will take advantage of <code class="literal">dweet.io</code> to publish the data retrieved from the sensors and make it available to different computers and devices all over the world. The <code class="literal">dweet.io</code> data<a id="id425" class="indexterm"/> sharing utility allows us to easily publish data or messages and alerts from IoT devices and then use other devices to subscribe to this data. The <code class="literal">dweet.io</code> data sharing utility defines itself as something similar to Twitter for social machines. You can read more about <a id="id426" class="indexterm"/>
<code class="literal">dweet.io</code> in its Webpage: <a class="ulink" href="http://dweet.io">http://dweet.io</a>.</p><div class="note" title="Note" style=""><div class="inner"><h3 class="title"><a id="tip61"/>Tip</h3><p>In our example, we will take advantage of the free services offered by <code class="literal">dweet.io</code> and we won't use some advanced features that provide privacy for our data but also require a paid subscription. Our data will be available to anyone that can access the <code class="literal">dweet.io</code> web page because we are not working with locked dweets.</p></div></div><p>The <code class="literal">dweet.io</code> data<a id="id427" class="indexterm"/> sharing utility provides a <a id="id428" class="indexterm"/>Web api that we can send data from our IoT device, known as <span class="emphasis"><em>thing</em></span> in <code class="literal">dweet.io</code> documentation. First, we have to chose a unique name for our thing. It is <a id="id429" class="indexterm"/>convenient to combine a string with a <span class="strong"><strong>GUID</strong></span> (short for <span class="strong"><strong>Global Unique Identifier</strong></span>). Another option is to click on the <span class="strong"><strong>Try It Now</strong></span> button on the main <code class="literal">dweet.io</code> web page and grab the name that the web page chooses for our thing. This way, we are sure that the name is unique and nobody else is using this name for another thing to publish data with <code class="literal">dweet.io</code>.</p><p>Once we have chosen a unique name for our thing, we can start publishing data, a process known as <code class="literal">dweeting</code>. We just need to compose a POST HTTP verb with the desired JSON data in the body and with the following request URL: <code class="literal">https://dweet.io/dweet/for/my-thing-name</code>. We must replace <code class="literal">my-thing-name</code> with the name we have chosen for our thing. In our examples, we will use <code class="literal">iot_python_chapter_09_01_gaston_hillar</code> to name our IoT device that will publish temperature and humidity values, that is, the thing that will dweet. Thus, we have to compose a POST HTTP verb with the desired JSON data in the body and with the following request URL: <code class="literal">https://dweet.io/dweet/for/iot_python_chapter_09_01_gaston_hillar</code>. Make sure you replace the name with the name you have chosen for your thing.</p><p>Dweepy is a simple Python client for <code class="literal">dweet.io</code> that allows us to easily publish data to <code class="literal">dweet.io</code> with Python. Instead of manually building and sending an HTTP request to a specific URL with Python, we can use the methods provided by this useful module. The following is the Web page<a id="id430" class="indexterm"/> for the Dweepy module: <a class="ulink" href="https://pypi.python.org/pypi/dweepy/0.2.0">https://pypi.python.org/pypi/dweepy/0.2.0</a>. Under the hoods, Dweepy uses the popular features provided by the popular <code class="literal">requests</code> module to build and send the HTTP requests.</p><div class="note" title="Note" style=""><div class="inner"><h3 class="title"><a id="tip62"/>Tip</h3><p>One of the nice things of working with Python as our main programming language for IoT is that there is always a package that makes things easy for us in Python.</p></div></div><p>In <a class="link" href="ch02.html" title="Chapter 2. Working with Python on Intel Galileo Gen 2">Chapter 2</a>, <span class="emphasis"><em>Working with Python on Intel Galileo Gen 2</em></span>, we installed <code class="literal">pip</code> installer to easily install additional Python 2.7.3 packages in the Yocto Linux that we are running on the board. Now, we <a id="id431" class="indexterm"/>will use <code class="literal">pip</code> installer to <a id="id432" class="indexterm"/>install Dweepy 0.2.0. We just need to run the following command in the SSH terminal to install the package:</p><div class="informalexample"><pre class="programlisting">pip install dweepy</pre></div><p>The last lines for the output will indicate that the <code class="literal">dweepy</code> package has been successfully installed. Don't worry about the error messages related to building wheel and the insecure platform warning:</p><div class="informalexample"><pre class="programlisting">Collecting dweepy
Downloading dweepy-0.2.0.tar.gz
Requirement already satisfied (use --upgrade to upgrade): requests&lt;3,&gt;=2 in /usr/lib/python2.7/site-packages (from dweepy)
Installing collected packages: dweepy
  Running setup.py install for dweepy
Successfully installed dweepy-0.2.0</pre></div><p>We will take the code we wrote in the previous chapter when we read temperature and humidity values from the sensor and we will use this code as a baseline to add the new features. The code file for the sample was <code class="literal">iot_python_chapter_08_03.py</code>.</p><p>We will use the recently installed <code class="literal">dweepy</code> module to publish data to <code class="literal">dweet.io</code> and make it available as a data source for another cloud service that will allow us to build a web-based dashboard. We will add the necessary lines to our loop and it will publish the measured values every 10 seconds. The code file for the sample is <code class="literal">iot_python_chapter_09_01.py</code>.</p><div class="informalexample"><pre class="programlisting">import pyupm_th02 as upmTh02
import pyupm_i2clcd as upmLcd
import pyupm_servo as upmServo
import dweepy
import time

if __name__ == "__main__":
    temperature_and_humidity_sensor = \
        TemperatureAndHumiditySensor(0)
    oled = TemperatureAndHumidityOled(0)
    temperature_servo = TemperatureServo(3)
<span class="strong"><strong>    # Don't forget to replace the thing_name value</strong></span>
<span class="strong"><strong>    # with your own thing name</strong></span>
<span class="strong"><strong>    thing_name = "iot_python_chapter_09_01_gaston_hillar"</strong></span>
    while True:
        temperature_and_humidity_sensor.\
            measure_temperature_and_humidity()
        oled.print_temperature(
            temperature_and_humidity_sensor.temperature_fahrenheit,
            temperature_and_humidity_sensor.temperature_celsius)
        oled.print_humidity(
            temperature_and_humidity_sensor.humidity)
        temperature_servo.print_temperature(
            temperature_and_humidity_sensor.temperature_fahrenheit)
<span class="strong"><strong>        # Push data to dweet.io</strong></span>
<span class="strong"><strong>        dweet = {"temperature_celsius": "{:5.2f}".format(temperature_and_humidity_sensor.temperature_celsius),</strong></span>
<span class="strong"><strong>                 "temperature_fahrenheit": "{:5.2f}".format(temperature_and_humidity_sensor.temperature_fahrenheit),</strong></span>
<span class="strong"><strong>                 "humidity_level_percentage": "{:5.2f}".format(temperature_and_humidity_sensor.humidity)}</strong></span>
<span class="strong"><strong>        dweepy.dweet_for(thing_name, dweet)</strong></span>
        print("Ambient temperature in degrees Celsius: {0}".
              format(temperature_and_humidity_sensor.temperature_celsius))
        print("Ambient temperature in degrees Fahrenheit: {0}".
              format(temperature_and_humidity_sensor.temperature_fahrenheit))
        print("Ambient humidity: {0}".
              format(temperature_and_humidity_sensor.humidity))
        # Sleep 10 seconds (10000 milliseconds)
        time.sleep(10)</pre></div><p>The<a id="id433" class="indexterm"/> highlighted lines show the changes made to the <code class="literal">__main__</code> method compared with the previous version. The first highlighted<a id="id434" class="indexterm"/> line creates a local variable named <code class="literal">thing_name</code> that saves a string with the name we have chosen for our thing to use with <code class="literal">dweet.io</code>. Remember that you have to replace the string with the name you have chosen for your thing before running the sample code.</p><p>Then, the code runs a loop forever and the first highlighted line creates a dictionary and saves it in the <code class="literal">dweet</code> local variable. The dictionary defines the key-value pairs that we want to send as JSON data to <code class="literal">dweet.io</code> for our thing. The following are the keys the code will send:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc"><code class="literal">temperature_celsius</code></li><li class="listitem" style="list-style-type: disc"><code class="literal">temperature_fahrenheit</code></li><li class="listitem" style="list-style-type: disc"><code class="literal">humidity_level_percentage</code></li></ul></div><p>The <a id="id435" class="indexterm"/>values for the previously enumerated<a id="id436" class="indexterm"/> keys are the values retrieved by the sensor converted to strings. Once the dictionary with the desired JSON data is built, the code calls the <code class="literal">dweepy.dweet_for</code> method with <code class="literal">thing_name</code> and <code class="literal">dweet</code> as arguments, that is, the thing name and the JSON data we want to publish for the specified thing name. Under the hoods, the <code class="literal">dweepy.dweet_for</code> method uses the <code class="literal">requests</code> module to compose a POST HTTP verb with the <code class="literal">dweet</code> dictionary as the desired JSON data in the body and with the following request URL: <code class="literal">https://dweet.io/dweet/for/</code> followed by the thing name specified in the <code class="literal">thing_name</code> local variable. This way, the code dweets the temperature and humidity values retrieved from the sensor in different units.</p><p>The following line will start the example.</p><div class="informalexample"><pre class="programlisting">python iot_python_chapter_09_01.py</pre></div><p>After you run the example, turn on an air conditioner or a heating system, to generate a change in the ambient temperature and humidity. This way, we will notice changes in the data that is being published every 10 seconds.</p><p>Wait around 20 seconds and open the following URL in any Web browser: <code class="literal">http://dweet.io/follow/iot_python_chapter_09_01_gaston_hillar</code>. Don't forget to replace <code class="literal">iot_python_chapter_09_01_gaston_hillar</code> with the name you have chosen for your thing. In this case, we can enter the URL in any device connected to the Internet. We don't need the device to be in the same LAN than the board because the values are published with <code class="literal">dweet.io</code> and they are available everywhere.</p><p>The <span class="strong"><strong>Visual</strong></span> view will display a line graph with the humidity level and the temperature values as they were changing over time. The right-hand side will display the latest value that was published. The view will be refreshed automatically when the Python code dweets new values. The following picture shows a screenshot with the <span class="strong"><strong>Visual</strong></span> view:</p><div class="mediaobject"><img src="images/B05042_09_01.jpg" alt="Publishing data to the cloud with dweepy"/></div><p>Click on the <span class="strong"><strong>Raw</strong></span> view and the page will display the latest JSON data that the Python code <a id="id437" class="indexterm"/>running on the board has published and<a id="id438" class="indexterm"/> received by <code class="literal">dweet.io</code> for our thing. The following lines show an example of the latest JSON data that was received and that was shown in the previous picture: </p><div class="informalexample"><pre class="programlisting">{
  "humidity_level_percentage": 20.01,
  "temperature_celsius": 19.56,
  "temperature_fahrenheit": 67.21
}</pre></div><p>In <a class="link" href="ch04.html" title="Chapter 4. Working with a RESTful API and Pulse Width Modulation">Chapter 4</a>, <span class="emphasis"><em>Working with a RESTful API and Pulse Width Modulation</em></span>, we installed HTTPie, a command-line HTTP client written in Python that makes is easy to send HTTP requests and uses a syntax that is easier than curl (also known as cURL). We can run the following HTTPie command in any computer or device to retrieve the latest dweet made for our thing.</p><div class="informalexample"><pre class="programlisting">http -b https://dweet.io:443/get/latest/dweet/for/iot_python_chapter_09_01_gaston_hillar</pre></div><p>The previous command will compose and send the following HTTP request: <code class="literal">GET https://dweet.io:443/get/latest/dweet/for/iot_python_chapter_09_01_gaston_hillar</code>. The <code class="literal">dweet.io</code> API will return the latest dweet for the specified thing. The <a id="id439" class="indexterm"/>following<a id="id440" class="indexterm"/> lines show a sample response from <code class="literal">dweet.io</code>. The JSON data is included in the value for the <code class="literal">content</code> key. </p><div class="informalexample"><pre class="programlisting">{
    "by": "getting", 
    "the": "dweets", 
    "this": "succeeded", 
    "with": [
        {
            "content": {
                "humidity_level_percentage": 19.92, 
                "temperature_celsius": 20.06, 
                "temperature_fahrenheit": 68.11
            }, 
            "created": "2016-03-27T00:11:12.598Z", 
            "thing": "iot_python_chapter_09_01_gaston_hillar"
        }
    ]
}</pre></div><p>We can run the following HTTPie command in any computer or device to retrieve all of the saved dweets for our thing.</p><div class="informalexample"><pre class="programlisting">http -b https://dweet.io:443/get/ dweets/for/iot_python_chapter_09_01_gaston_hillar</pre></div><p>The previous command will compose and send the following HTTP request: <code class="literal">GET https://dweet.io:443/get/ dweets/for/iot_python_chapter_09_01_gaston_hillar</code>. The <code class="literal">dweet.io</code> API will return the saved dweets from its long term storage for the specified thing. The following lines show a sample response from <code class="literal">dweet.io</code>. Notice that there are limitations in the number of dweets stored in the long term storage and in the returned values.</p><div class="informalexample"><pre class="programlisting">{
    "by": "getting", 
    "the": "dweets", 
    "this": "succeeded", 
    "with": [
         {
            "content": {
                "humidity_level_percentage": 19.94, 
                "temperature_celsius": 20.01, 
                "temperature_fahrenheit": 68.02
            }, 
            "created": "2016-03-27T00:11:00.554Z", 
            "thing": "iot_python_chapter_09_01_gaston_hillar"
        }, 
        {
            "content": {
                "humidity_level_percentage": 19.92, 
                "temperature_celsius": 19.98, 
                "temperature_fahrenheit": 67.96
            }, 
            "created": "2016-03-27T00:10:49.823Z", 
            "thing": "iot_python_chapter_09_01_gaston_hillar"
        }, 
        {
            "content": {
                "humidity_level_percentage": 19.92, 
                "temperature_celsius": 19.95, 
                "temperature_fahrenheit": 67.91
            }, 
            "created": "2016-03-27T00:10:39.123Z", 
            "thing": "iot_python_chapter_09_01_gaston_hillar"
        }, 
        {
            "content": {
                "humidity_level_percentage": 19.91, 
                "temperature_celsius": 19.9, 
                "temperature_fahrenheit": 67.82
            }, 
            "created": "2016-03-27T00:10:28.394Z", 
            "thing": "iot_python_chapter_09_01_gaston_hillar"
        }
    ]
}</pre></div></div></div></div>


  <div id="sbo-rt-content"><div class="section" title="Building a web-based dashboard with Freeboard"><div class="titlepage"><div><div><h1 class="title"><a id="ch09lvl1sec85"/>Building a web-based dashboard with Freeboard</h1></div></div></div><p>The <code class="literal">dweet.io</code> data <a id="id441" class="indexterm"/>sharing utility allowed us to easily publish data to the cloud with just a few lines of code. Now, we are ready to use <code class="literal">dweet.io</code> and our thing name as a data source to build a real-time web-based dashboard. We<a id="id442" class="indexterm"/> will take advantage of freeboard.io to visualize the data collected with the sensor and published to <code class="literal">dweet.io</code> in many gauges and make the dashboard available to different computers and devices all over the world. Freeboard.io allows us to build a dashboard by selecting data sources and dragging and dropping customizable widgets. Freeboard.io defines itself as a cloud-based service that allows us to visualize the Internet of Things. You can <a id="id443" class="indexterm"/>read more about freeboard.io in its Webpage: <a class="ulink" href="http://freeboard.io">http://freeboard.io</a>.</p><div class="note" title="Note" style=""><div class="inner"><h3 class="title"><a id="tip63"/>Tip</h3><p>In our example, we will take advantage of the free services offered by freeboard.io and we won't use some advanced features that provide privacy for our dashboards but also require a paid subscription. Our dashboard will be available to anyone that has the unique URL for it because we are not working with private dashboards.</p></div></div><p>Freeboard requires us to sign up and create an account with a valid e-mail and a password before we can build a web-based dashboard. We aren't required to enter any credit card or payment information. If you already have an account at freeboard.io, you can skip the next step.</p><p>Go to <a class="ulink" href="http://freeboard.io">http://freeboard.io</a> in your Web browser and click <span class="strong"><strong>Start Now</strong></span>. You can achieve the same goal by visiting <a class="ulink" href="https://freeboard.io/signup">https://freeboard.io/signup</a>. Enter your desired user name in <span class="strong"><strong>Pick a Username</strong></span>, your e-mail in <span class="strong"><strong>Enter Your Email</strong></span> and the desired password in <span class="strong"><strong>Create a Password</strong></span>. Once you have filled up all the fields, click <span class="strong"><strong>Create My Account</strong></span>.</p><p>Once you created your account, you can go to <a class="ulink" href="http://freeboard.io">http://freeboard.io</a> in your Web browser and click <span class="strong"><strong>Login</strong></span>. You can achieve the same goal by visiting <a class="ulink" href="https://freeboard.io/login">https://freeboard.io/login</a>. Then, enter your user name or e-mail and password, and click <span class="strong"><strong>Sign In</strong></span>. Freeboard will display your freeboards, also known as dashboards.</p><p>Enter <code class="literal">Ambient temperature and humidity</code> in the <span class="strong"><strong>enter a name</strong></span> textbox at the left hand side of the <span class="strong"><strong>Create New</strong></span> button and then click on this button. Freeboard.io will display an empty dashboard with many buttons that allow us to add panes and data sources, among other things. The following picture shows a screenshot with the empty dashboard.</p><div class="mediaobject"><img src="images/B05042_09_02.jpg" alt="Building a web-based dashboard with Freeboard"/></div><p>Click <a id="id444" class="indexterm"/>on <span class="strong"><strong>Add</strong></span> below <span class="strong"><strong>Datasources</strong></span> and the Website will open the <span class="strong"><strong>Datasource</strong></span> dialog box. Select <span class="strong"><strong>Dweet.io</strong></span> in the <span class="strong"><strong>Type</strong></span> dropdown<a id="id445" class="indexterm"/> and the dialog box will display the fields required to define a <code class="literal">dweet.io</code> datasource.</p><p>Enter <code class="literal">Ambient temperature and humidity</code> in <span class="strong"><strong>Name</strong></span> and the thing name we have been using for <code class="literal">dweet.io</code> in <span class="strong"><strong>Thing Name</strong></span>. Remember that we were using <code class="literal">iot_python_chapter_09_01_gaston_hillar</code> to name our IoT device but you had replaced it with a different name. If the name you enter doesn't match the name you used when working with <code class="literal">dweet.io</code>, the datasource won't have the appropriate data. The following picture shows a screenshot with the configuration for the <code class="literal">dweet.io</code> datasource that uses the sample thing name.</p><div class="mediaobject"><img src="images/B05042_09_03.jpg" alt="Building a web-based dashboard with Freeboard"/></div><p>Click <span class="strong"><strong>Save</strong></span> and <a id="id446" class="indexterm"/>the datasource will appear listed below <span class="strong"><strong>Datasources</strong></span>. As the board is running the Python code that is dweeting, the time shown below <span class="strong"><strong>Last Updated</strong></span> will change every 10 seconds. If the time doesn't change every 10 seconds, it means that the datasource has a wrong configuration or that the board is not running the Python code that is dweeting anymore.</p><p>Click <a id="id447" class="indexterm"/>on <span class="strong"><strong>Add pane</strong></span> to add a new empty pane to the dashboard. Then, click on the plus sign (<span class="strong"><strong>+</strong></span>) at the upper right corner of the new empty pane and Freeboard will display the <span class="strong"><strong>Widget</strong></span> dialog box.</p><p>Select <span class="strong"><strong>Gauge</strong></span> in the <span class="strong"><strong>Type</strong></span> dropdown and the dialog box will display the fields required to add a gauge widget to the pane within the dashboard. Enter <code class="literal">Temperature in degrees Fahrenheit</code> in <span class="strong"><strong>Title</strong></span>.</p><p>Click <span class="strong"><strong>+ Datasource</strong></span> at the right-hand side of the <span class="strong"><strong>Value</strong></span> textbox, select <span class="strong"><strong>Ambient Temperature and humidity</strong></span> and then select <span class="strong"><strong>temperature_fahrenheit</strong></span>. After you make the selections the following text will appear in the <span class="strong"><strong>Value</strong></span> textbox: <code class="literal">datasources ["Ambient temperature and humidity"] ["temperature_fahrenheit"]</code>.</p><p>Enter <code class="literal">ºF</code> in <span class="strong"><strong>Units</strong></span>, <code class="literal">-30</code> in <span class="strong"><strong>Minimum</strong></span> and <code class="literal">130</code> in <span class="strong"><strong>Maximum</strong></span>. Then, click <span class="strong"><strong>Save</strong></span> and Freeboard will close the dialog box and add the new gauge to the previously created pane within the dashboard. The gauge will display the latest value that the code running in the board dweeted for the ambient temperature in degrees Fahrenheit, that is, the value for the <code class="literal">temperature_fahrenheit</code> key in the JSON data that the code has published for the last time <a id="id448" class="indexterm"/>to <code class="literal">dweet.io</code>. The following picture shows the <span class="strong"><strong>Ambient temperature and humidity</strong></span> datasource displaying the last updated time and the gauge showing the latest value for the ambient temperature measured in degrees Fahrenheit.</p><div class="mediaobject"><img src="images/B05042_09_04.jpg" alt="Building a web-based dashboard with Freeboard"/></div><p>Click<a id="id449" class="indexterm"/> on <span class="strong"><strong>Add pane</strong></span> to add another new empty pane to the dashboard. Then, click on the plus sign (<span class="strong"><strong>+</strong></span>) at the upper right corner of the new empty pane and Freeboard will display the <span class="strong"><strong>Widget</strong></span> dialog box.</p><p>Select <span class="strong"><strong>Gauge</strong></span> in the <span class="strong"><strong>Type</strong></span> dropdown and the dialog box will display the fields required to add a gauge widget to the pane within the dashboard. Enter <code class="literal">Humidity level in percentage</code> in <span class="strong"><strong>Title</strong></span>.</p><p>Click <span class="strong"><strong>+ Datasource</strong></span> at the right-hand side of the <span class="strong"><strong>Value</strong></span> textbox, select <span class="strong"><strong>Ambient Temperature and humidity</strong></span> and then select <span class="strong"><strong>humidity_level_percentage</strong></span>. After you make the selections the following text will appear in the <span class="strong"><strong>Value</strong></span> textbox: <code class="literal">datasources ["Ambient temperature and humidity"] ["humidity_level_percentage"]</code>.</p><p>Enter <code class="literal">%</code> in <span class="strong"><strong>Units</strong></span>, <code class="literal">0</code> in <span class="strong"><strong>Minimum</strong></span> and <code class="literal">100</code> in <span class="strong"><strong>Maximum</strong></span>. Then, click <span class="strong"><strong>Save</strong></span> and Freeboard will close the dialog box and add the new gauge to the previously created pane within the dashboard. The gauge will display the latest value that the code running in the board dweeted for the ambient humidity level in percentage, that is, the value for the <code class="literal">humidity_level_percentage</code> key in the JSON data that the code has published for the last time to <code class="literal">dweet.io</code>.</p><p>Now, click <a id="id450" class="indexterm"/>on the plus sign (<span class="strong"><strong>+</strong></span>) at the <a id="id451" class="indexterm"/>upper right corner of the pane that is displaying the temperature in degrees Fahrenheit and Freeboard will display the <span class="strong"><strong>Widget</strong></span> dialog box.</p><p>Select <span class="strong"><strong>Gauge</strong></span> in the <span class="strong"><strong>Type</strong></span> dropdown and the dialog box will display the fields required to add a gauge widget to the pane within the dashboard. Enter <code class="literal">Temperature in degrees Celsius</code> in <span class="strong"><strong>Title</strong></span>.</p><p>Click <span class="strong"><strong>+ Datasource</strong></span> at the right-hand side of the <span class="strong"><strong>Value</strong></span> textbox, select <span class="strong"><strong>Ambient Temperature and humidity</strong></span> and then select <span class="strong"><strong>temperature_celsius</strong></span>. After you make the selections the following text will appear in the <span class="strong"><strong>Value</strong></span> textbox: <code class="literal">datasources ["Ambient temperature and humidity"] ["temperature_celsius"]</code>.</p><p>Enter <code class="literal">ºC</code> in <span class="strong"><strong>Units</strong></span>, <code class="literal">-40</code> in <span class="strong"><strong>Minimum</strong></span> and <code class="literal">55</code> in <span class="strong"><strong>Maximum</strong></span>. Then, click <span class="strong"><strong>Save</strong></span> and Freeboard will close the dialog box and add the new gauge to the previously existing pane within the dashboard. This way, the pane will display two gauges, with the temperature expressed in two different units. The new gauge will display the latest value that the code running in the board dweeted for the ambient temperature in degrees Celsius, that is, the value for the <code class="literal">temperature_celsius</code> key in the JSON data that the code has published for the last time to <code class="literal">dweet.io</code>.</p><p>Now, click on the configuration icon at the right-hand side of the <span class="strong"><strong>+</strong></span> button of the pane that displays both temperatures. Freeboard will display the <span class="strong"><strong>Pane</strong></span> dialog box. Enter <code class="literal">Temperature</code> in <span class="strong"><strong>Title</strong></span> and click <span class="strong"><strong>Save</strong></span>.</p><p>Click on the configuration icon at the right-hand side of the <span class="strong"><strong>+</strong></span> button of the pane that displays the humidity level. Freeboard will display the <span class="strong"><strong>Pane</strong></span> dialog box. Enter <code class="literal">Humidity</code> in <span class="strong"><strong>Title</strong></span> and click <span class="strong"><strong>Save</strong></span>.</p><p>Drag and drop the panes to locate the <span class="strong"><strong>Humidity</strong></span> pane at the left-hand side of the <span class="strong"><strong>Temperature</strong></span> pane. The following picture shows the dashboard we built, with two panes and three gauges that refresh the data automatically when the code running on the Intel Galileo Gen 2 board dweets new data.</p><div class="mediaobject"><img src="images/B05042_09_05.jpg" alt="Building a web-based dashboard with Freeboard"/></div><div class="note" title="Note" style=""><div class="inner"><h3 class="title"><a id="tip64"/>Tip</h3><p>We can access the recently built dashboard in any device by entering the URL that our Web browser is displaying at the time we are working with the dashboard. The URL is composed of the <code class="literal">https://freeboard.io/board/</code> prefix followed by letters and numbers. For example, in case the URL is <code class="literal">https://freeboard.io/board/EXAMPLE</code>, we just need to enter it in any Web browser running on any device or computer connected to the Internet and we can watch the gauges and they will be refreshed as new data is being publishes from our Intel Galileo Gen 2 board to <code class="literal">dweet.io</code>.</p></div></div><p>The <a id="id452" class="indexterm"/>combination of <code class="literal">dweet.io</code> as our datasource <a id="id453" class="indexterm"/>and freeboard.io as our web-based dashboard made it easy for us to monitor the data retrieved from the sensor wired to our Intel Galileo Gen 2 board with any device that provides a Web browser. The<a id="id454" class="indexterm"/> combination of these two cloud-based services for IoT is just one example of how we can easily combine different services. There is <a id="id455" class="indexterm"/>an increase in the number of IoT cloud-based services, which can be used in our solutions.</p></div></div>


  <div id="sbo-rt-content"><div class="section" title="Sending and receiving data in real-time through Internet with PubNub"><div class="titlepage"><div><div><h1 class="title"><a id="ch09lvl1sec86"/>Sending and receiving data in real-time through Internet with PubNub</h1></div></div></div><p>In <a class="link" href="ch04.html" title="Chapter 4. Working with a RESTful API and Pulse Width Modulation">Chapter 4</a>, <span class="emphasis"><em>Working with a RESTful API and Pulse Width Modulation</em></span>, we developed and <a id="id456" class="indexterm"/>consumed a RETful API that allows us to control electronic components connected to our Intel Galileo Gen 2 board through HTTP requests. Now, we want to send and receive data in real-time through the <a id="id457" class="indexterm"/>Internet and a RESTful API is not the most appropriate option to do this. Instead, we will work with a publish/subscribe model based on a protocol that is lighter than the HTTP protocol. Specifically, we will use a service based on the <a id="id458" class="indexterm"/>
<span class="strong"><strong>MQTT</strong></span> (short for <span class="strong"><strong>MQ Telemetry Transport</strong></span>) protocol.</p><p>The MQTT protocol is a<a id="id459" class="indexterm"/> <span class="strong"><strong>machine-to-machine</strong></span> (short for <span class="strong"><strong>M2M</strong></span>) and Internet of Things connectivity protocol. MQTT is a lightweight messaging protocol that runs on top of the TCP/IP protocol and works with a publish-subscribe mechanism. It is possible for any device to subscribe to a specific channel (also known as topic) and it will receive all the messages published to this channel. In addition, the device can publish message to this or other channel. The protocol is becoming very popular in IoT and M2M projects. You can read more about the MQTT protocol in the following <a id="id460" class="indexterm"/>Webpage: <a class="ulink" href="http://mqtt.org">http://mqtt.org</a>.</p><p>PubNub provides many cloud-based services and one of them allows us to easily stream data and signal any device in real-time, working with the MQTT protocol under the hoods. We will take advantage of this PubNub service to send and receive data in real-time through Internet and make it easy to control our Intel Galileo Gen 2 board through the Internet. As PubNub provides a Python API with high quality documentation and examples, it is extremely easy to use the service in Python. PubNub defines itself as the global data stream network for IoT, Mobile and Web applications. You can read more about<a id="id461" class="indexterm"/> PubNub in its Webpage: <a class="ulink" href="http://www.pubnub.com">http://www.pubnub.com</a>.</p><div class="note" title="Note" style=""><div class="inner"><h3 class="title"><a id="tip65"/>Tip</h3><p>In our example, we will take advantage of the free services offered by PubNub and we won't use some advanced features and additional services that might empower our IoT project connectivity requirements but also require a paid subscription.</p></div></div><p>PubNub <a id="id462" class="indexterm"/>requires us to sign up and create an account with a valid e-mail and a password before we can create an application within PubNub that allows us to start using their free services. We aren't required to enter <a id="id463" class="indexterm"/>any credit card or payment information. If you already have an account at PubNub, you can skip the next step.</p><p>Once you created your account PubNub will redirect you to the <span class="strong"><strong>Admin Portal</strong></span> that lists your PubNub applications. It is necessary to generate your PubNub publish and subscribe keys in order to send and receive messages in the network. A new pane will represent the application in the Admin portal. The following screenshot shows the Temperature Control application pane in the PubNub Admin portal:</p><div class="mediaobject"><img src="images/B05042_09_06.jpg" alt="Sending and receiving data in real-time through Internet with PubNub"/></div><p>Click on the <span class="strong"><strong>Temperature Control</strong></span> pane and PubNub will display the <span class="strong"><strong>Demo Keyset</strong></span> pane that has been automatically generated for the application. Click on this pane and PubNub will display the publish, subscribe, and secret keys. We must copy and paste each of these keys to use them in our code that will publish messages and subscribe to them. The following screenshot shows the prefixes for the keys and the remaining characters have been erased in the image:</p><div class="mediaobject"><img src="images/B05042_09_07.jpg" alt="Sending and receiving data in real-time through Internet with PubNub"/></div><p>In order<a id="id464" class="indexterm"/> to copy the secret key, you must click on the eye icon at the right-hand side of the key and PubNub will make all the characters visible.</p><p>In <a class="link" href="ch02.html" title="Chapter 2. Working with Python on Intel Galileo Gen 2">Chapter 2</a>, <span class="emphasis"><em>Working with Python on Intel Galileo Gen 2</em></span>, we installed <code class="literal">pip</code> installer to easily <a id="id465" class="indexterm"/>install additional Python 2.7.3 packages in the Yocto Linux that we are running on the board. Now, we will use <code class="literal">pip</code> installer to install PubNub Python SDK 3.7.6. We just need to run the following command in the SSH terminal to install the package. Notice that it can take a few minutes to complete the installation.</p><div class="informalexample"><pre class="programlisting">pip install pubnub</pre></div><p>The last lines for the output will indicate that the <code class="literal">pubnub</code> package has been successfully installed. Don't worry about the error messages related to building wheel and the insecure platform warning.</p><div class="informalexample"><pre class="programlisting">  Downloading pubnub-3.7.6.tar.gz
Collecting pycrypto&gt;=2.6.1 (from pubnub)
  Downloading pycrypto-2.6.1.tar.gz (446kB)
    100% |################################| 446kB 25kB/s 
Requirement already satisfied (use --upgrade to upgrade): requests&gt;=2.4.0 in /usr/lib/python2.7/site-packages (from pubnub)
Installing collected packages: pycrypto, pubnub
  Running setup.py install for pycrypto
Installing collected packages: pycrypto, pubnub
  Running setup.py install for pycrypto
Running setup.py install for pubnub
Successfully installed pubnub-3.7.6 pycrypto-2.6.1</pre></div><p>We <a id="id466" class="indexterm"/>will take the code we wrote in the previous chapter when we read temperature and humidity values from the sensor, we printed <a id="id467" class="indexterm"/>the values in an OLED matrix and rotated a servo's shaft to display the measured temperature expressed in degrees Fahrenheit with the shaft. The code file for the sample was <code class="literal">iot_python_chapter_08_03.py</code>. We will use this code as a baseline to add new features that will allow us to perform the following actions with PubNub messages sent to a specific channel from any device that has a Web browser:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">Rotate the servo's shaft to display a temperature value in degrees Fahrenheit received as part of the message.</li><li class="listitem" style="list-style-type: disc">Display a line of text received as part of the message at the bottom of the OLED matrix.</li></ul></div><p>We will use the recently installed <code class="literal">pubnub</code> module to subscribe to a specific channel and run code when we receive messages in the channel. We will create a <code class="literal">MessageChannel</code> class to represent the communications channel, configure the PubNub subscription and declare the code for the callbacks that are going to be executed when certain events are fired. The code file for the sample is <code class="literal">iot_python_chapter_09_02.py</code>. Remember that we use the code file <code class="literal">iot_python_chapter_08_03.py</code> as a baseline, and therefore, we will add the class to the existing code in this file and we will create a new Python file. Don't forget to replace the strings assigned to the <code class="literal">publish_key</code> and <code class="literal">subscribe_key</code> local variables in the <code class="literal">__init__</code> method with the values you have retrieved from the previously explained PubNub key generation process.</p><div class="informalexample"><pre class="programlisting">import time
from pubnub import Pubnub

class MessageChannel:
    command_key = "command"

    def __init__(self, channel, temperature_servo, oled):
        self.temperature_servo = temperature_servo
        self.oled = oled
        self.channel = channel
        # Publish key is the one that usually starts with the "pub-c-" prefix
        # Do not forget to replace the string with your publish key
        publish_key = "pub-c-xxxxxxxx-xxxx-xxxx-xxxx-xxxxxxxxxxxx"
        # Subscribe key is the one that usually starts with the "sub-c" prefix
        # Do not forget to replace the string with your subscribe key
        subscribe_key = "sub-c-xxxxxxxx-xxxx-xxxx-xxxx-xxxxxxxxxxxx"
        self.pubnub = Pubnub(publish_key=publish_key, subscribe_key=subscribe_key)
        self.pubnub.subscribe(channels=self.channel,
                              callback=self.callback,
                              error=self.callback,
                              connect=self.connect,
                              reconnect=self.reconnect,
                              disconnect=self.disconnect)

    def callback(self, message, channel):
        if channel == self.channel:
            if self.__class__.command_key in message:
                if message[self.__class__.command_key] == "print_temperature_fahrenheit":
                    self.temperature_servo.print_temperature(message["temperature_fahrenheit"])
                elif message[self.__class__.command_key] == "print_information_message":
                    self.oled.print_line(11, message["text"])
            print("I've received the following message: {0}".format(message))

    def error(self, message):
        print("Error: " + str(message))

    def connect(self, message):
        print("Connected to the {0} channel".
              format(self.channel))
        print(self.pubnub.publish(
            channel=self.channel,
            message="Listening to messages in the Intel Galileo Gen 2 board"))

    def reconnect(self, message):
        print("Reconnected to the {0} channel".
              format(self.channel))

    def disconnect(self, message):
        print("Disconnected from the {0} channel".
              Format(self.channel))</pre></div><p>The <code class="literal">MessageChannel</code> class declares the <code class="literal">command_key</code> class attribute that defines the key<a id="id468" class="indexterm"/> string that defines what the code will understand as the command. Whenever we receive a message that includes the specified key string, we know that the value associated to this key in the dictionary will indicate the command that the message wants the code running in the board to be processed. Each command requires additional key-value pairs that provide the necessary information to execute the command.</p><p>We have <a id="id469" class="indexterm"/>to specify the PubNub channel name, the <code class="literal">TemperatureServo</code> instance the <code class="literal">Oled</code> instance in the <code class="literal">channel</code>, <code class="literal">temperature_servo</code>, and <code class="literal">oled</code> required arguments. The constructor, that is, the <code class="literal">__init__</code> method, saves the received arguments in three attributes with the same names. The <code class="literal">channel</code> argument specifies the PubNub channel to which we are going to subscribe to listen to the messages that other devices send to this channel. We will also publish messages to this channel, and therefore, we will be both a subscriber and a publisher for this channel.</p><div class="note" title="Note" style=""><div class="inner"><h3 class="title"><a id="tip66"/>Tip</h3><p>In this case, we will only subscribe to one channel. However, it is very important to know that we are not limited to subscribe to a single channel, we might subscribe to many channels.</p></div></div><p>Then, the constructor declares two local variables: <code class="literal">publish_key</code> and <code class="literal">subscribe_key</code>. These local variables save the publish and subscribe keys that we had generated with the PubNub Admin portal. Then, the code creates a new <code class="literal">Pubnub</code> instance with <code class="literal">publish_key</code> and <code class="literal">subscribe_key</code> as the arguments, and saves the reference for the new instance in the <code class="literal">pubnub</code> attribute. Finally, the code calls the <code class="literal">subscribe</code> method for the new instance to subscribe to data on the channel saved in the <code class="literal">channel</code> attribute. Under the hoods, the <code class="literal">subscribe</code> method makes the client create an open TCP socket to the PubNub network that includes an MQTT broker and starts listening to messages on the specified channel. The call to this method specifies many methods declared in the <code class="literal">MessageChannel</code> class for the following named arguments:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc"><code class="literal">callback</code>: Specifies<a id="id470" class="indexterm"/> the function that will be called when there is a new message received from the channel</li><li class="listitem" style="list-style-type: disc"><code class="literal">error</code>: Specifies<a id="id471" class="indexterm"/> the function that will be called on an error event</li><li class="listitem" style="list-style-type: disc"><code class="literal">connect</code>: Specifies <a id="id472" class="indexterm"/>the function that will be called when a successful connection is established with the PubNub cloud</li><li class="listitem" style="list-style-type: disc"><code class="literal">reconnect</code>: Specifies<a id="id473" class="indexterm"/> the function that will be called when a successful re-connection is completed with the PubNub cloud</li><li class="listitem" style="list-style-type: disc"><code class="literal">disconnect</code>: Specifies <a id="id474" class="indexterm"/>the function that will be called when the client disconnects from the PubNub cloud</li></ul></div><p>This <a id="id475" class="indexterm"/>way, whenever one of the previously enumerated events occur, the specified method will be executed. The <code class="literal">callback</code> method receives two arguments: <code class="literal">message</code> and <code class="literal">channel</code>. First, the method checks whether the received <code class="literal">channel</code> matches the value in the <code class="literal">channel</code> attribute. In this case, whenever the <code class="literal">callback</code> method is executed, the value in the <code class="literal">channel</code> argument will always match the value in the <code class="literal">channel</code> attribute because we just subscribed to one channel. However, in case we subscribe to more than one channel, is is always necessary to check which is the channel in which the message was sent and in which we are receiving the message.</p><p>Then, the <a id="id476" class="indexterm"/>code checks whether the <code class="literal">command_key</code> class attribute is included in the <code class="literal">message</code> dictionary. If the expression evaluates to <code class="literal">True</code>, it means that the message includes a command that we have to process. However, before we can process the command, we have to check which is the command, and therefore, it is necessary to retrieve the value associated with the key equivalent to the <code class="literal">command_key</code> class attribute. The code is capable of running code when the value is any of the following two commands:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc"><code class="literal">print_temperature_fahrenheit</code>: The<a id="id477" class="indexterm"/> command must specify the temperature value expressed in degrees Fahrenheit in the value of the <code class="literal">temperature_fahrenheit</code> key. The code calls the <code class="literal">self.temperature_servo.print_temperature</code> method with the temperature value retrieved from the dictionary as an argument. This way, the code moves the servo's shaft based on the specified temperature value in the message that includes the command.</li><li class="listitem" style="list-style-type: disc"><code class="literal">print_information_message</code>: The<a id="id478" class="indexterm"/> command must specify the line of text that has to be displayed at the bottom of the OLED matrix in the value of the <code class="literal">print_information_message</code> key. The code calls the <code class="literal">self.oled.print_line</code> method with <code class="literal">11</code> and the text value retrieved from the dictionary as arguments. This way, the code displays the text received in the message that includes the command at the bottom of the OLED matrix.</li></ul></div><p>No matter whether the message included a valid command or not, the method prints the raw message that it received in the console output.</p><p>The <code class="literal">connect</code> method<a id="id479" class="indexterm"/> prints a message indicating that a connection has been established with the channel. Then, the method prints the results of calling the <code class="literal">self.pubnub.publish</code> method that publishes a message in the channel name saved in <code class="literal">self.channel</code> with the following message: <code class="literal">"Listening to messages in the Intel Galileo Gen 2 board"</code>. In this case, the call to this method runs with a synchronous execution. We will work with asynchronous execution for this method in our next example.</p><p>At<a id="id480" class="indexterm"/> this time, we are already subscribed to this channel, and therefore, we will receive the previously published message and the callback method will be executed with this message as an argument. However, as the message doesn't include the key that identifies a command, the code in the callback method will just display the received message and it won't process any of the previously analyzed commands.</p><p>The other methods declared in the <code class="literal">MessageChannel</code> class just display information to the console output about the event that has occurred.</p><p>Now, we will use the previously coded <code class="literal">MessageChannel</code> class to create a new version of the <code class="literal">__main__</code> method that uses the PubNub cloud to receive and process commands. The new version doesn't rotate the servo's shaft when the ambient temperature changes, instead, it will do this when it receives the appropriate command from any device connected to PubNub cloud. The following lines show the new version of the <code class="literal">__main__</code> method. The code file for the sample is <code class="literal">iot_python_chapter_09_02.py</code>.</p><div class="informalexample"><pre class="programlisting">if __name__ == "__main__":
    temperature_and_humidity_sensor = \
        TemperatureAndHumiditySensor(0)
    oled = TemperatureAndHumidityOled(0)
    temperature_servo = TemperatureServo(3)
<span class="strong"><strong>    message_channel = MessageChannel("temperature", temperature_servo, oled)</strong></span>
    while True:
        temperature_and_humidity_sensor.\
            measure_temperature_and_humidity()
        oled.print_temperature(
            temperature_and_humidity_sensor.temperature_fahrenheit,
            temperature_and_humidity_sensor.temperature_celsius)
        oled.print_humidity(
            temperature_and_humidity_sensor.humidity)
        print("Ambient temperature in degrees Celsius: {0}".
              format(temperature_and_humidity_sensor.temperature_celsius))
        print("Ambient temperature in degrees Fahrenheit: {0}".
              format(temperature_and_humidity_sensor.temperature_fahrenheit))
        print("Ambient humidity: {0}".
              format(temperature_and_humidity_sensor.humidity))
        # Sleep 10 seconds (10000 milliseconds)
        time.sleep(10)</pre></div><p>The <a id="id481" class="indexterm"/>highlighted line creates an instance of the previously coded <code class="literal">MessageChannel</code> class with <code class="literal">"temperature"</code>, <code class="literal">temperature_servo</code>, and <code class="literal">oled</code> as the arguments. The constructor will subscribe to the <code class="literal">temperature</code> channel in the PubNub cloud, and therefore, we must send the messages to this channel in<a id="id482" class="indexterm"/> order to send the commands that the code will process with an asynchronous execution. The loop will read the values from the sensor and print the values to the console as in the previous version of the code, and therefore, we will have code running in the loop and we will also have code listening to the messages in the <code class="literal">temperature</code> channel in the PubNub cloud. We will start the example later because we want to subscribe to the channel in the PubNub debug console before we run the code in the board.</p></div></div>


  <div id="sbo-rt-content"><div class="section" title="Publishing messages with commands through the PubNub cloud"><div class="titlepage"><div><div><h1 class="title"><a id="ch09lvl1sec87"/>Publishing messages with commands through the PubNub cloud</h1></div></div></div><p>Now, we <a id="id483" class="indexterm"/>will take advantage of the PubNub console to send messages with commands to the <code class="literal">temperature</code> channel and make the Python code running on the board process these commands. In case you have logged out of PubNub, login again and click on the <span class="strong"><strong>Temperature Control</strong></span> pane in the <span class="strong"><strong>Admin Portal</strong></span>. PubNub will display the <span class="strong"><strong>Demo Keyset</strong></span> pane.</p><p>Click on the <span class="strong"><strong>Demo Keyset</strong></span> pane and PubNub will display the publish, subscribe, and secret keys. This way, we select the keyset that we want to use for our PubNub application.</p><p>Click <a id="id484" class="indexterm"/>on <span class="strong"><strong>Debug Console</strong></span> on the sidebar located the left-hand side of the screen. PubNub will create a client for a default channel and subscribe to this channel using the secret keys we have selected in the previous step. We want to subscribe to the <code class="literal">temperature</code> channel, and therefore, enter <code class="literal">temperature</code> in the <span class="strong"><strong>Default Channel</strong></span> textbox within a pane that includes the <span class="strong"><strong>Add client</strong></span> button at the bottom. Then, click on <span class="strong"><strong>Add client</strong></span> and PubNub will add a new pane with a random client name as a title and the channel name, <code class="literal">temperature</code>, in the second line. PubNub makes the client subscribe to this channel and we will be able to receive messages published to this channel and send messages to this channel. The following picture shows the pane for the generated client named <span class="strong"><strong>Client-ot7pi</strong></span>, subscribed to the <code class="literal">temperature</code> channel. Notice that the client name will be different when you follow the explained steps.</p><div class="mediaobject"><img src="images/B05042_09_08.jpg" alt="Publishing messages with commands through the PubNub cloud"/></div><p>The <a id="id485" class="indexterm"/>client pane displays the output generated when PubNub subscribed the client to the channel. PubNub returns a formatted response for each command. In this case, it indicates that the status is equal to <code class="literal">Subscribed</code> and the channel name is <code class="literal">temperature</code>.</p><div class="informalexample"><pre class="programlisting">[1,"Subscribed","temperature"]</pre></div><p>Now, it is time to start running the example in the Intel Galileo Gen 2 board. The following line will start the example in the SSH console:</p><div class="informalexample"><pre class="programlisting">python iot_python_chapter_09_02.py</pre></div><p>After you run the example, go to the Web browser in which you are working with the PubNub debug console. You will see the following message listed in the previously created client:</p><div class="informalexample"><pre class="programlisting">"Listening to messages in the Intel Galileo Gen 2 board"</pre></div><p>The <a id="id486" class="indexterm"/>Python code running in the board published this message, specifically, the <code class="literal">connect</code> method in the <code class="literal">MessageChannel</code> class sent this message after the application established a connection with the PubNub cloud. The following picture shows the message listed in the previously created client. Notice that the icon at the left-hand side of the text indicates it is a message. The other message was a debug message with the results of subscribing to the channel.</p><div class="mediaobject"><img src="images/B05042_09_09.jpg" alt="Publishing messages with commands through the PubNub cloud"/></div><p>At the bottom of the client pane, you will see the following text and the <span class="strong"><strong>Send</strong></span> button at the right-hand side:</p><div class="informalexample"><pre class="programlisting">{"text":"Enter Message Here"}</pre></div><p>Now, we will replace the previously shown text with a message. Enter the following JSON code and click <span class="strong"><strong>Send</strong></span>:</p><div class="informalexample"><pre class="programlisting">{"command":"print_temperature_fahrenheit", "temperature_fahrenheit": 50 }</pre></div><div class="note" title="Note" style=""><div class="inner"><h3 class="title"><a id="tip67"/>Tip</h3><p>The text editor where you enter the message has some issues in certain browsers. Thus, it is convenient to use your favorite text editor to enter the JSON code, copy it and then past it to replace the text that is included by default in the text for the message to be sent.</p></div></div><p>After <a id="id487" class="indexterm"/>you click <span class="strong"><strong>Send</strong></span>, the following lines will appear in the client log. The first line is a debug message with the results of publishing the message and indicates that the message has been sent. The formatted response includes a number (<code class="literal">1</code> message), the status (<code class="literal">Sent</code>) and a time token. The second line is the message that arrives to the channel because we are subscribed to the <code class="literal">temperature</code> channel, that is, we also receive the message we sent.</p><div class="informalexample"><pre class="programlisting">[1,"Sent","14594756860875537"]
{
  "command": "print_temperature_fahrenheit",
  "temperature_fahrenheit": 50
}</pre></div><p>The following picture shows the messages and debug messages log for the PubNub client after we clicked the <span class="strong"><strong>Send</strong></span> button:</p><div class="mediaobject"><img src="images/B05042_09_10.jpg" alt="Publishing messages with commands through the PubNub cloud"/></div><p>After you publish the previous message, you will see the following output in the SSH console for the Intel Galileo Gen 2 board. You will notice the servo's shaft rotates to 50 degrees.</p><div class="informalexample"><pre class="programlisting">I've received the following message: {u'command': u'print_temperature_fahrenheit', u'temperature_fahrenheit': 50}</pre></div><p>Now, enter the following JSON code and click <span class="strong"><strong>Send</strong></span>:</p><div class="informalexample"><pre class="programlisting">{"command":"print_information_message", "text": "Client ready"}</pre></div><p>After <a id="id488" class="indexterm"/>you click <span class="strong"><strong>Send</strong></span>, the following lines will appear in the client log. The first line is a debug message with the previously explained formatted response with the results of publishing the message and indicates that the message has been sent. The second line is the message that arrives to the channel because we are subscribed to the <code class="literal">temperature</code> channel, that is, we also receive the message we sent.</p><div class="informalexample"><pre class="programlisting"> [1,"Sent","14594794434885921"]
 {
  "command": "print_information_message",
  "text": "Client ready"
}</pre></div><p>The following picture shows the messages and debug messages log for the PubNub client after we clicked the <span class="strong"><strong>Send</strong></span> button.</p><div class="mediaobject"><img src="images/B05042_09_11.jpg" alt="Publishing messages with commands through the PubNub cloud"/></div><p>After <a id="id489" class="indexterm"/>you publish the previous message, you will see the following output in the SSH console for the Intel Galileo Gen 2 board. You will see the following text displayed at the bottom of the OLED matrix: <code class="literal">Client ready</code>.</p><div class="informalexample"><pre class="programlisting">I've received the following message: {u'text': u'Client ready', u'command': u'print_information_message'}</pre></div><p>When we published the two messages with the commands, we have definitely noticed a problem. We don't know whether the command was processed or not in the code that is running on the IoT device, that is, in the Intel Galileo Gen 2 board. We know that the board started listening messages in the temperature channel, but we don't receive any kind of response from the IoT device after the command has been processed.</p></div></div>


  <div id="sbo-rt-content"><div class="section" title="Working with bi-directional communications"><div class="titlepage"><div><div><h1 class="title"><a id="ch09lvl1sec88"/>Working with bi-directional communications</h1></div></div></div><p>We <a id="id490" class="indexterm"/>can easily add a few lines of code to publish a message to the same channel in which we are receiving messages to indicate that the command has been successfully processed. We will use our previous example as a baseline and we will create a new version of the <code class="literal">MessageChannel</code> class. The code file was <code class="literal">iot_python_chapter_09_02.py</code>. Don't forget to replace the strings assigned to the <code class="literal">publish_key</code> and <code class="literal">subscribe_key</code> local variables in the <code class="literal">__init__</code> method with<a id="id491" class="indexterm"/> the values you have retrieved from the previously explained PubNub key generation process. The following lines show the new version of the <code class="literal">MessageChannel</code> class that publishes a message after a command has been successfully processed. The code file for the sample is <code class="literal">iot_python_chapter_09_03.py</code>.</p><div class="informalexample"><pre class="programlisting">import time
from pubnub import Pubnub

class MessageChannel:
    command_key = "command"
<span class="strong"><strong>    successfully_processed_command_key = "successfully_processed_command"</strong></span>

    def __init__(self, channel, temperature_servo, oled):
        self.temperature_servo = temperature_servo
        self.oled = oled
        self.channel = channel
        # Do not forget to replace the string with your publish key
        publish_key = "pub-c-xxxxxxxx-xxxx-xxxx-xxxx-xxxxxxxxxxxx"
        # Subscribe key is the one that usually starts with the "sub-c" prefix
        # Do not forget to replace the string with your subscribe key
        subscribe_key = "sub-c-xxxxxxxx-xxxx-xxxx-xxxx-xxxxxxxxxxxx"
        self.pubnub = Pubnub(publish_key=publish_key, subscribe_key=subscribe_key)
        self.pubnub.subscribe(channels=self.channel,
                              callback=self.callback,
                              error=self.callback,
                              connect=self.connect,
                              reconnect=self.reconnect,
                              disconnect=self.disconnect)

<span class="strong"><strong>    def callback_response_message(self, message):</strong></span>
<span class="strong"><strong>        print("I've received the following response from PubNub cloud: {0}".format(message))</strong></span>

<span class="strong"><strong>    def error_response_message(self, message):</strong></span>
<span class="strong"><strong>        print("There was an error when working with the PubNub cloud: {0}".format(message))</strong></span>

<span class="strong"><strong>    def publish_response_message(self, message):</strong></span>
<span class="strong"><strong>        response_message = {</strong></span>
<span class="strong"><strong>            self.__class__.successfully_processed_command_key:</strong></span>
<span class="strong"><strong>                message[self.__class__.command_key]}</strong></span>
<span class="strong"><strong>        self.pubnub.publish(</strong></span>
<span class="strong"><strong>            channel=self.channel,</strong></span>
<span class="strong"><strong>            message=response_message,</strong></span>
<span class="strong"><strong>            callback=self.callback_response_message,</strong></span>
<span class="strong"><strong>            error=self.error_response_message)</strong></span>

    def callback(self, message, channel):
        if channel == self.channel:
            print("I've received the following message: {0}".format(message))
            if self.__class__.command_key in message:
                if message[self.__class__.command_key] == "print_temperature_fahrenheit":
                    self.temperature_servo.print_temperature(message["temperature_fahrenheit"])
<span class="strong"><strong>                    self.publish_response_message(message)</strong></span>
                elif message[self.__class__.command_key] == "print_information_message":
                    self.oled.print_line(11, message["text"])
<span class="strong"><strong>                    self.publish_response_message(message)</strong></span>

    def error(self, message):
        print("Error: " + str(message))

    def connect(self, message):
        print("Connected to the {0} channel".
              format(self.channel))
        print(self.pubnub.publish(
            channel=self.channel,
            message="Listening to messages in the Intel Galileo Gen 2 board"))

    def reconnect(self, message):
        print("Reconnected to the {0} channel".
              format(self.channel))

    def disconnect(self, message):
        print("Disconnected from the {0} channel".
              format(self.channel))</pre></div><p>The <a id="id492" class="indexterm"/>highlighted lines in the previous code for the new version of the <code class="literal">MessageChannel</code> class show the changes we made in the code. First, the code declares the <code class="literal">successfully_processed_command_key</code> class attribute that defines the key string that defines what the code will use as a successfully processed command key in a response message published to the channel. Whenever we publish a message that includes the specified key string, we know that the value associated to this key in the dictionary will indicate the command that the board has successfully processed.</p><p>The code declares the following three new methods:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc"><code class="literal">callback_response_message</code>: This <a id="id493" class="indexterm"/>method will be used as the callback that will be executed when a successfully processed command response message is published to the channel. The method just prints the formatted response that PubNub returns when a message has been successfully published in the channel. In this case, the <code class="literal">message</code> argument doesn't hold the original message that has been published, it holds the formatted response. We use <code class="literal">message</code> for the argument name to keep consistency with the PubNub API.</li><li class="listitem" style="list-style-type: disc"><code class="literal">error_response_message</code>: This<a id="id494" class="indexterm"/> method will be used as the callback that will be executed when an error occurs when trying to publish a successfully processed command response message to the channel. The method just prints the error message that PubNub returns when a message hasn't been successfully published in the channel.</li><li class="listitem" style="list-style-type: disc"><code class="literal">publish_response_message</code>: This <a id="id495" class="indexterm"/>method receives the message with the command that was successfully processed in the <code class="literal">message</code> argument. The code creates a <code class="literal">response_message</code> dictionary with the <code class="literal">successfully_processed_command_key</code> class attribute as the key and the value of the key specified in the <code class="literal">command_key</code> class attribute for the message dictionary as the value. Then, the code calls the <code class="literal">self.pubnub.publish</code> method to publish the <code class="literal">response_message</code> dictionary to the channel saved in the <code class="literal">channel</code> attribute. The call to this method specifies <code class="literal">self.callback_response_message</code> as the callback to be executed when the message is successfully published and <code class="literal">self.error_response_message</code> as the callback to be executed when an error occurred during the publishing process. When we specify a callback, the publish method works with an asynchronous execution, and therefore, the execution is non-blocking. The publication of the message and the callbacks that are specified will run in a different thread. </li></ul></div><p>Now, the <a id="id496" class="indexterm"/>
<code class="literal">callback</code> method defined in the <code class="literal">MessageChannel</code> class adds a call to the <code class="literal">publish_response_message</code> method with the message that included the command that has been successfully processed (<code class="literal">message</code>) as an argument. As previously explained, the <code class="literal">publish_response_message</code> method is non-blocking and will return immediately while the successfully processed message is published in another thread.</p><p>Now, it is time to start running the example in the Intel Galileo Gen 2 board. The following line will start the example in the SSH console:</p><div class="informalexample"><pre class="programlisting">python iot_python_chapter_09_03.py</pre></div><p>After you run the example, go to the Web browser in which you are working with the PubNub debug console. You will see the following message listed in the previously created client:</p><div class="informalexample"><pre class="programlisting">"Listening to messages in the Intel Galileo Gen 2 board"</pre></div><p>Enter the following JSON code and click <span class="strong"><strong>Send</strong></span>:</p><div class="informalexample"><pre class="programlisting">{"command":"print_temperature_fahrenheit", "temperature_fahrenheit": 90 }</pre></div><p>After you click <span class="strong"><strong>Send</strong></span>, the following lines will appear in the client log. The last message has been published by the board to the channel and indicates that the <code class="literal">print_temperature_fahrenheit</code> command has been successfully processed.</p><div class="informalexample"><pre class="programlisting">[1,"Sent","14595406989121047"]
{
  "command": "print_temperature_fahrenheit",
  "temperature_fahrenheit": 90
}
{
  "successfully_processed_command": "print_temperature_fahrenheit"
}</pre></div><p>The following picture shows the messages and debug messages log for the PubNub client after we clicked the <span class="strong"><strong>Send</strong></span> button:</p><div class="mediaobject"><img src="images/B05042_09_12.jpg" alt="Working with bi-directional communications"/></div><p>After you <a id="id497" class="indexterm"/>publish the previous message, you will see the following output in the SSH console for the Intel Galileo Gen 2 board. You will notice the servo's shaft rotates to 90 degrees. The board also receives the successfully processed command message because it is subscribed to the channel in which the message has been published.</p><div class="informalexample"><pre class="programlisting">I've received the following message: {u'command': u'print_temperature_fahrenheit', u'temperature_fahrenheit': 90}
I've received the following response from PubNub cloud: [1, u'Sent', u'14595422426124592']
I've received the following message: {u'successfully_processed_command': u'print_temperature_fahrenheit'}</pre></div><p>Now, enter the following JSON code and click <span class="strong"><strong>Send</strong></span>:</p><div class="informalexample"><pre class="programlisting">{"command":"print_information_message", "text": "2nd message"}</pre></div><p>After you click <span class="strong"><strong>Send</strong></span>, the following lines will appear in the client log. The last message has been published by the board to the channel and indicates that the <code class="literal">print_information_message</code> command has been successfully processed.</p><div class="informalexample"><pre class="programlisting">[1,"Sent","14595434708640961"]
{
  "command": "print_information_message",
  "text": "2nd message"
}
{
  "successfully_processed_command": "print_information_message"
}</pre></div><p>The <a id="id498" class="indexterm"/>following picture shows the messages and debug messages log for the PubNub client after we clicked the <span class="strong"><strong>Send</strong></span> button.</p><div class="mediaobject"><img src="images/B05042_09_13.jpg" alt="Working with bi-directional communications"/></div><p>After you publish the previous message, you will see the following output in the SSH console for the Intel Galileo Gen 2 board. You will see the following text displayed at the bottom of the OLED matrix: <code class="literal">2nd message</code>. The board also receives the successfully processed command message because it is subscribed to the channel in which the message has been published.</p><div class="informalexample"><pre class="programlisting">I've received the following message: {u'text': u'2nd message', u'command': u'print_information_message'}
2nd message
I've received the following response from PubNub cloud: [1, u'Sent', u'14595434710438777']
I've received the following message: {u'successfully_processed_command': u'print_information_message'}</pre></div><p>We can <a id="id499" class="indexterm"/>work with the different SDKs provided by PubNub to subscribe and publish to a channel. We can also make different IoT devices talk to themselves by publishing messages to channels and processing them. In this case, we just created a few commands and we didn't add detailed information about the device that has to process the command or the device that has generated a specific message. A more complex API would require commands that include more information and security.</p></div></div>


  <div id="sbo-rt-content"><div class="section" title="Publishing messages to the cloud with a Python PubNub client"><div class="titlepage"><div><div><h1 class="title"><a id="ch09lvl1sec89"/>Publishing messages to the cloud with a Python PubNub client</h1></div></div></div><p>So far, we<a id="id500" class="indexterm"/> have been using the PubNub debug console to publish messages to the <code class="literal">temperature</code> channel and make the <a id="id501" class="indexterm"/>Python code running in the Intel Galileo Gen 2 board process them. Now, we are going to code a Python client that will publish messages to the <code class="literal">temperature</code> channel. This way, we will be able to design applications that can talk to IoT devices with Python code in the publisher and in the subscriber devices.</p><p>We can run the Python client on another Intel Galileo Gen 2 board or in any device that has Python 2.7.x installed. In addition, the code will run with Python 3.x. For example, we can run the Python client in our computer. We just need to make sure that we install the <code class="literal">pubnub</code> module we have previously installed with pip in the Python version that is running in the Yocto Linux for the board.</p><p>We will create a <code class="literal">Client</code> class to represent a PubNub client, configure the PubNub subscription, make it easy to publish a message with a command and the required values for the command and declare the code for the callbacks that are going to be executed when certain events are fired. The code file for the sample is <code class="literal">iot_python_chapter_09_04.py</code>. Don't forget to replace the strings assigned to the <code class="literal">publish_key</code> and <code class="literal">subscribe_key</code> local variables in the <code class="literal">__init__</code> method with the values you have retrieved from the previously explained PubNub key generation process. The following lines show the code for the <code class="literal">Client</code> class:</p><div class="informalexample"><pre class="programlisting">import time
from pubnub import Pubnub


class Client:
    command_key = "command"

    def __init__(self, channel):
        self.channel = channel
        # Publish key is the one that usually starts with the "pub-c-" prefix
        publish_key = "pub-c-xxxxxxxx-xxxx-xxxx-xxxx-xxxxxxxxxxxx"
        # Subscribe key is the one that usually starts with the "sub-c" prefix
        # Do not forget to replace the string with your subscribe key
        subscribe_key = "sub-c-xxxxxxxx-xxxx-xxxx-xxxx-xxxxxxxxxxxx"
        self.pubnub = Pubnub(publish_key=publish_key, subscribe_key=subscribe_key)
        self.pubnub.subscribe(channels=self.channel,
                              callback=self.callback,
                              error=self.callback,
                              connect=self.connect,
                              reconnect=self.reconnect,
                              disconnect=self.disconnect)

    def callback_command_message(self, message):
        print("I've received the following response from PubNub cloud: {0}".format(message))

    def error_command_message(self, message):
        print("There was an error when working with the PubNub cloud: {0}".format(message))

<span class="strong"><strong>    def publish_command(self, command_name, key, value):</strong></span>
<span class="strong"><strong>        command_message = {</strong></span>
<span class="strong"><strong>            self.__class__.command_key: command_name,</strong></span>
<span class="strong"><strong>            key: value}</strong></span>
<span class="strong"><strong>        self.pubnub.publish(</strong></span>
<span class="strong"><strong>            channel=self.channel,</strong></span>
<span class="strong"><strong>            message=command_message,</strong></span>
<span class="strong"><strong>            callback=self.callback_command_message,</strong></span>
<span class="strong"><strong>            error=self.error_command_message)</strong></span>

    def callback(self, message, channel):
        if channel == self.channel:
            print("I've received the following message: {0}".format(message))

    def error(self, message):
        print("Error: " + str(message))

    def connect(self, message):
        print("Connected to the {0} channel".
              format(self.channel))
        print(self.pubnub.publish(
            channel=self.channel,
            message="Listening to messages in the PubNub Python Client"))

    def reconnect(self, message):
        print("Reconnected to the {0} channel".
              format(self.channel))

    def disconnect(self, message):
        print("Disconnected from the {0} channel".
              format(self.channel))</pre></div><p>The <code class="literal">Client</code> class declares the <code class="literal">command_key</code> class attribute that defines the key string that defines what the code understands as a command in the messages. Our main goal is to <a id="id502" class="indexterm"/>build and publish command messages to a specified channel. We have to specify the PubNub channel name in the <code class="literal">channel</code> required argument. The constructor, that is, the <code class="literal">__init__</code> method, saves the received argument in an attribute with the same name. We will be both a subscriber and a publisher for this channel.</p><p>Then, the<a id="id503" class="indexterm"/> constructor declares two local variables: <code class="literal">publish_key</code> and <code class="literal">subscribe_key</code>. These local variables save the publish and subscribe keys we had generated with the PubNub Admin portal. Then, the code creates a new <code class="literal">Pubnub</code> instance with <code class="literal">publish_key</code> and <code class="literal">subscribe_key</code> as the arguments, and saves the reference for the new instance in the <code class="literal">pubnub</code> attribute. Finally, the code calls the <code class="literal">subscribe</code> method for the new instance to subscribe to data on the channel saved in the <code class="literal">channel</code> attribute. The call to this method specifies many methods declared in the <code class="literal">Client</code> class as we did for our previous examples.</p><p>The <code class="literal">publish_command</code> method receives a command name, the key and the value that provide the necessary information to execute the command in the <code class="literal">command_name</code>, <code class="literal">key</code> and <code class="literal">value</code> required arguments. In this case, we don't target the command to a specific IoT device and all the devices that subscribe to the channel and run the code in our previous example will process the commands that we publish. We can use the code as a baseline to work with more complex examples in which we have to generate commands that target specific IoT devices. Obviously, it is also necessary to improve the security.</p><p>The <a id="id504" class="indexterm"/>method creates a dictionary and saves it in the <code class="literal">command_message</code> local variable. The <code class="literal">command_key</code> class attribute is the first key for the dictionary and the <code class="literal">command_name</code> received as an argument, the value that composes the first key-value pair. Then, the code calls the <code class="literal">self.pubnub.publish</code> method to publish the <code class="literal">command_message</code> dictionary to the channel saved in the <code class="literal">channel</code> attribute. The call to this method specifies <code class="literal">self.callback_command_message</code> as the callback to be executed when the message is successfully published and <code class="literal">self.error_command_message</code> as the callback to be executed when <a id="id505" class="indexterm"/>an error occurred during the publishing process. As happened in our previous example, when we specify a callback, the <code class="literal">publish</code> method works with an asynchronous execution.</p><p>Now, we will use the previously coded <code class="literal">Client</code> class to write a <code class="literal">__main__</code> method that uses the PubNub cloud to publish two commands that our board will process. The following lines show the code for the <code class="literal">__main__</code> method. The code file for the sample is <code class="literal">iot_python_chapter_09_04.py</code>.</p><div class="informalexample"><pre class="programlisting">if __name__ == "__main__":
    client = Client("temperature")
    client.publish_command(
        "print_temperature_fahrenheit",
        "temperature_fahrenheit",
        45)
    client.publish_command(
        "print_information_message",
        "text",
        "Python IoT"
    )
    # Sleep 60 seconds (60000 milliseconds)
    time.sleep(60)</pre></div><p>The code in the <code class="literal">__main__</code> method is very easy to understand. The code creates an instance of the <code class="literal">Client</code> class with <code class="literal">"temperature"</code> as an argument to become both a subscriber and a publisher for this channel in the PubNub cloud. The code saves the new instances in the <code class="literal">client</code> local variable.</p><p>The code calls the <code class="literal">publish_command</code> method with the necessary arguments to build and publish the <code class="literal">print_temperature_fahrenheit</code> command with a temperature value of <code class="literal">45</code>. The method will publish the command with an asynchronous execution. Then, the code calls the <code class="literal">publish_command</code> method again with the necessary arguments to build and publish the <code class="literal">print_information_message</code> command with a text value of <code class="literal">"Python IoT"</code>. The method will publish the second command with an asynchronous execution.</p><p>Finally, the <a id="id506" class="indexterm"/>code sleeps for 1 minute (60 seconds) in order to make it possible for the asynchronous executions to successfully publish the commands. The different callbacks defined in the <code class="literal">Client</code> class will be executed as the different events fire. As we are also subscribed to the channel, we will also receive the messages we publish in the <code class="literal">temperature</code> channel.</p><p>Keep the <a id="id507" class="indexterm"/>Python code we have executed in our previous example running on the board. We want the board to process our commands. In addition, keep the Web browser in which you are working with the PubNub debug console opened because we also want to see all the messages in the log.</p><p>The following line will start the example for the Python client in any computer or device that you want to use as a client. It is possible to run the code in another SSH terminal in case you want to use the same board as a client.</p><div class="informalexample"><pre class="programlisting">python iot_python_chapter_09_04.py</pre></div><p>After you run the example, you will see the following output in the Python console that runs the Python client, that is, the <code class="literal">iot_python_chapter_09_04.py</code> Python script.</p><div class="informalexample"><pre class="programlisting">Connected to the temperature channel
I've received the following response from PubNub cloud: [1, u'Sent', u'14596508980494876']
I've received the following response from PubNub cloud: [1, u'Sent', u'14596508980505581']
[1, u'Sent', u'14596508982165140']
I've received the following message: {u'text': u'Python IoT', u'command': u'print_information_message'}
I've received the following message: {u'command': u'print_temperature_fahrenheit', u'temperature_fahrenheit': 45}
I've received the following message: Listening to messages in the PubNub Python Client
I've received the following message: {u'successfully_processed_command': u'print_information_message'}
I've received the following message: {u'successfully_processed_command': u'print_temperature_fahrenheit'}</pre></div><p>The code used the PubNub Python SDK to build and publish the following two command messages in the <code class="literal">temperature</code> channel:</p><div class="informalexample"><pre class="programlisting">{"command":"print_temperature_fahrenheit", "temperature_fahrenheit": "45"}
{"command":"print_information_message", "text": "Python IoT"}</pre></div><p>As we <a id="id508" class="indexterm"/>are also subscribed to the temperature channel, we receive the messages we sent with an asynchronous execution. Then, we received the successfully processed command messages <a id="id509" class="indexterm"/>for the two command messages. The board has processed the commands and published the messages to the <code class="literal">temperature</code> channel.</p><p>After you run the example, go to the Web browser in which you are working with the PubNub debug console. You will see the following messages listed in the previously created client:</p><div class="informalexample"><pre class="programlisting">[1,"Subscribed","temperature"]
"Listening to messages in the Intel Galileo Gen 2 board"
{
  "text": "Python IoT",
  "command": "print_information_message"
}
{
  "command": "print_temperature_fahrenheit",
  "temperature_fahrenheit": 45
}
"Listening to messages in the PubNub Python Client"
{
  "successfully_processed_command": "print_information_message"
}
{
  "successfully_processed_command": "print_temperature_fahrenheit"
}</pre></div><p>The following picture shows the last messages displayed in the log for the PubNub client after we run the previous example:</p><div class="mediaobject"><img src="images/B05042_09_14.jpg" alt="Publishing messages to the cloud with a Python PubNub client"/></div><p>You will <a id="id510" class="indexterm"/>see the following<a id="id511" class="indexterm"/> text displayed at the bottom of the OLED matrix: <code class="literal">Python IoT</code>. In addition, the servo's shaft will rotate to 45 degrees.</p><div class="note" title="Note" style=""><div class="inner"><h3 class="title"><a id="tip68"/>Tip</h3><p>We can use the PubNub SDKs available in different programming languages to create applications and apps that publish and receive messages in the PubNub cloud and interact with IoT devices. In this case, we worked with the Python SDK to create a client that publishes commands. It is possible to create mobile apps that publish commands and easily build an app that can interact with our IoT device.</p></div></div></div></div>


  <div id="sbo-rt-content"><div class="section" title="Using MQTT with Mosquitto and Eclipse Paho"><div class="titlepage"><div><div><h1 class="title"><a id="ch09lvl1sec90"/>Using MQTT with Mosquitto and Eclipse Paho</h1></div></div></div><p>Mosquitto is <a id="id512" class="indexterm"/>an <a id="id513" class="indexterm"/>open source message broker that implements the versions 3.1 and 3.1.1 of the MQTT protocol, and therefore, allows us to work with messages using the publish/subscribe model. Mosquitto is an iot.eclipse.org project and is provided with the Eclipse Public Project (EPL)/EDL license. The following is the Web page for <a id="id514" class="indexterm"/>Mosquitto: <a class="ulink" href="http://mosquitto.org">http://mosquitto.org</a>.</p><p>The <a id="id515" class="indexterm"/>Eclipse Paho project provides an open source client implementation of MQTT. The project includes a Python client, also known as the Paho Python Client or Eclipse Paho MQTT Python client library. This Python client has been contributed from the Mosquitto project and was originally the Mosquitto Python Client. The following is the Web page for the <a id="id516" class="indexterm"/>Eclipse Paho project: <a class="ulink" href="http://www.eclipse.org/paho">http://www.eclipse.org/paho</a>. The <a id="id517" class="indexterm"/>following is the Web page for the Eclipse Paho MQTT Python client library, that is, the <a id="id518" class="indexterm"/>paho-mqtt module: <a class="ulink" href="https://pypi.python.org/pypi/paho-mqtt/1.1">https://pypi.python.org/pypi/paho-mqtt/1.1</a>.</p><p>In <a class="link" href="ch02.html" title="Chapter 2. Working with Python on Intel Galileo Gen 2">Chapter 2</a>, <span class="emphasis"><em>Working </em></span><a id="id519" class="indexterm"/>
<span class="emphasis"><em>with Python on Intel Galileo Gen 2</em></span>, we installed <code class="literal">pip</code> installer to easily install additional Python 2.7.3 packages in the Yocto Linux that we are running on the board. Now, we will use <code class="literal">pip</code> installer to install paho-mqtt 1.1. We just need to run the following command in the SSH terminal to install the package. </p><div class="informalexample"><pre class="programlisting">pip install paho-mqtt</pre></div><p>The last lines for the output will indicate that the <code class="literal">paho-mqtt</code> package has been successfully installed. Don't worry about the error messages related to building wheel and the insecure platform warning.</p><div class="informalexample"><pre class="programlisting">Collecting paho-mqtt
  Downloading paho-mqtt-1.1.tar.gz (41kB)
    100% |################################| 45kB 147kB/s
Installing collected packages: paho-mqtt
  Running setup.py install for paho-mqtt
Successfully installed paho-mqtt-1.1</pre></div><div class="note" title="Note" style=""><div class="inner"><h3 class="title"><a id="tip69"/>Tip</h3><p>Eclipse allows us to use a publically accessible sandbox server for the Eclipse IoT projects at <a class="ulink" href="http://iot.eclipse.org">iot.eclipse.org</a>, port 1883. In the following examples, we will use this sandbox server as our Mosquitto message broker. This way, we don't have to setup a Mosquitto message broker to test the examples and learn how to work with the Paho Python Client. However, in a real-life application, we should setup a Mosquitto message broker and use it for our project.</p></div></div><p>We will take the code we wrote in the previous chapter when we read temperature and humidity values from the sensor, we printed the values in an OLED matrix and rotated a servo's shaft to display the measured temperature expressed in degrees Fahrenheit with the shaft. The code file for the sample was <code class="literal">iot_python_chapter_08_03.py</code>. We will use this code as a baseline to add the same features that we added when we worked with the PubNub cloud. However, in this case, we will use the Paho Python Client and the publically accessible sandbox server that provides us with a Mosquitto message broker. We will be able to perform the following actions with MQTT messages sent to a specific topic from any device that can publish MQTT messages in the topic to which we are subscribed:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">Rotate the servo's shaft to display a temperature value in degrees Fahrenheit received as part of the message</li><li class="listitem" style="list-style-type: disc">Display a line of text received as part of the message at the bottom of the OLED matrix</li></ul></div><div class="note" title="Note" style=""><div class="inner"><h3 class="title"><a id="tip70"/>Tip</h3><p>The Paho Python Client uses the topic name instead of channel. You can think of a topic as a channel.</p></div></div><p>We will <a id="id520" class="indexterm"/>use the recently installed <code class="literal">paho-mqtt</code> module to subscribe to a specific topic and run code when we receive messages in the topic. We will create a <code class="literal">MessageTopic</code> class to represent the communications topic, configure the MQTT client, the subscription to the client and declare the code for the callbacks that are going to be executed when certain events are fired. The code file for the sample is <code class="literal">iot_python_chapter_09_05.py</code>. Remember that we use the code file <code class="literal">iot_python_chapter_08_03.py</code> as a baseline, and therefore, we will add the class to the existing code in this file and we will create a new Python file. Don't forget to replace the strings assigned to the <code class="literal">topic</code> class attribute with your unique topic name. As the Mosquitto broker we are using is public, you should use a unique topic to make sure you only receive the messages you publish.</p><div class="informalexample"><pre class="programlisting">import time
import paho.mqtt.client as mqtt
import json


class MessageTopic:
    command_key = "command"
    successfully_processed_command_key = "successfully_processed_command"
    # Replace with your own topic name
    topic = "iot-python-gaston-hillar/temperature"
    active_instance = None

    def __init__(self, temperature_servo, oled):
        self.temperature_servo = temperature_servo
        self.oled = oled
        self.client = mqtt.Client()
        self.client.on_connect = MessageTopic.on_connect
        self.client.on_message = MessageTopic.on_message
        self.client.connect(host="iot.eclipse.org",
                            port=1883,
                            keepalive=60)
        MessageTopic.active_instance = self

    def loop(self):
        self.client.loop()

    @staticmethod
    def on_connect(client, userdata, flags, rc):
        print("Connected to the {0} topic".
              format(MessageTopic.topic))
        subscribe_result = client.subscribe(MessageTopic.topic)
        publish_result_1 = client.publish(
            topic=MessageTopic.topic,
            payload="Listening to messages in the Intel Galileo Gen 2 board")

    @staticmethod
    def on_message(client, userdata, msg):
        if msg.topic == MessageTopic.topic:
            print("I've received the following message: {0}".format(str(msg.payload)))
            try:
                message_dictionary = json.loads(msg.payload)
                if MessageTopic.command_key in message_dictionary:
                    if message_dictionary[MessageTopic.command_key] == "print_temperature_fahrenheit":
                        MessageTopic.active_instance.temperature_servo.print_temperature(
                            message_dictionary["temperature_fahrenheit"])
                        MessageTopic.active_instance.publish_response_message(
                            message_dictionary)
                    elif message_dictionary[MessageTopic.command_key] == "print_information_message":
                        MessageTopic.active_instance.oled.print_line(
                            11, message_dictionary["text"])
                        MessageTopic.active_instance.publish_response_message(message_dictionary)
            except ValueError:
                # msg is not a dictionary
                # No JSON object could be decoded
                pass

    def publish_response_message(self, message):
        response_message = json.dumps({
            self.__class__.successfully_processed_command_key:
                message[self.__class__.command_key]})
        result = self.client.publish(topic=self.__class__.topic,
                                payload=response_message)
        return result</pre></div><p>The <code class="literal">MessageTopic</code> class declares the <code class="literal">command_key</code> class attribute that defines the key string that <a id="id521" class="indexterm"/>defines what the code will understand as the command. Whenever we receive a message that includes the specified key string, we know that the value associated to this key in the dictionary will indicate the command that the message wants the code running in the board to be processed. In this case, we don't receive messages as dictionaries, and therefore, it is necessary to convert them from strings to dictionaries when they are not just a string.</p><p>The code declares the <code class="literal">successfully_processed_command_key</code> class attribute that defines the key string that defines what the code will use as a successfully processed command key in a response message published to the topic. Whenever we publish a message that includes the specified key string, we know that the value associated to this key in the dictionary will indicate the command that the board has successfully processed.</p><p>We have to specify the <code class="literal">TemperatureServo</code> instance and the <code class="literal">Oled</code> instance in the <code class="literal">temperature_servo</code> and <code class="literal">oled</code> required arguments. The constructor, that is, the <code class="literal">__init__</code> method, saves the received arguments in two attributes with the same names. The <code class="literal">topic</code> class attribute argument specifies the Mosquitto topic to which we are going to subscribe to listen to the messages that other devices send to this topic. We will also publish messages to this topic, and therefore, we will be both a subscriber and a publisher for this channel.</p><p>Then, the <a id="id522" class="indexterm"/>constructor creates an instance of the <code class="literal">mqtt.Client</code> class that represents an MQTT client and we will use to communicate with an MQTT broker. As we create the instance with the default parameters, we will create an instance of <code class="literal">paho.mqtt.client.MQTTv31</code> and we will work with MQTT version 3.1.</p><p>The code also saves a reference to this instance in the <code class="literal">active_instance</code> class attribute because we have to access the instance in static methods that we will be specified as callbacks for the different events that the MQTT client fires.</p><p>Then, the code assigns the <code class="literal">self.client.on_connect</code> attribute to the <code class="literal">on_connect</code> static method and the <code class="literal">self.client.on_message</code> attribute to the <code class="literal">on_message</code> static method. Static methods do not receive either <code class="literal">self</code> of <code class="literal">cls</code> as the first argument, and therefore, we can use them as callbacks with the required number of arguments.</p><p>Finally, the constructor calls the <code class="literal">self.client.connect</code> method and specifies the publically accessible sandbox server for the Eclipse IoT projects at iot.eclipse.org, port 1883, in the arguments. This way, the code asks the MQTT client to establish a connection to the specified MQTT broker. In case you decide to use your own Mosquitto broker, you just need to change the values for the <code class="literal">host</code> and <code class="literal">port</code> arguments, according to the configuration for the Mosquitto broker. The <code class="literal">connect</code> method runs with an asynchronous execution, and therefore, it is a non-blocking call.</p><p>After a connection has been successfully established with the MQTT broker, the specified callback in the <code class="literal">self.client.on_connect</code> attribute will be executed, that is, the <code class="literal">on_connect</code> static method (marked with the <code class="literal">@staticmethod</code> decorator). This static method receives the <code class="literal">mqtt.Client</code> instance that established the connection with the MQTT broker in the <code class="literal">client</code> argument. The code calls the <code class="literal">client.subscribe</code> method with <code class="literal">MessageTopic.topic</code> as an argument to subscribe to the topic specified in the <code class="literal">topic</code> class attribute.</p><div class="note" title="Note" style=""><div class="inner"><h3 class="title"><a id="tip71"/>Tip</h3><p>In this case, we will only subscribe to one topic. However, it is very important to know that we are not limited to subscribe to a single topic, we might subscribe to many topics with a single call to the <code class="literal">subscribe</code> method.</p></div></div><p>Finally, the code calls the <code class="literal">client.publish</code> method with <code class="literal">MessageTopic.topic</code> as the <code class="literal">topic</code> argument and a message string in the <code class="literal">payload</code> argument. This way, we publish a string message that says <code class="literal">"Listening to messages in the Intel Galileo Gen 2 board"</code> to the topic specified in the <code class="literal">topic</code> class attribute.</p><p>Whenever<a id="id523" class="indexterm"/> there is a new message received in the topic to which we have subscribed, the specified callback in the <code class="literal">self.client.on_messsage</code> attribute will be executed, that is, the <code class="literal">on_message</code> static method (marked with the <code class="literal">@staticmethod</code> decorator). This static method receives the <code class="literal">mqtt.Client</code> instance that established the connection with the MQTT broker in the <code class="literal">client</code> argument and an <code class="literal">mqtt.MQTTMessage</code> instance in the <code class="literal">msg</code> argument. The <code class="literal">mqtt.MQTTMessage</code> class describes an incoming message. First, the static method checks whether the <code class="literal">msg.topic</code> attribute, that indicates the topic in which the message has been received, matches the value in the <code class="literal">topic</code> class attribute. In this case, whenever the <code class="literal">on_message</code> method is executed, the value in <code class="literal">msg.topic</code> will always match the value in the <code class="literal">topic</code> class attribute because we just subscribed to one topic. However, in case we subscribe to more than one topic, is is always necessary to check which is the topic in which the message was sent and in which we are receiving the message.</p><p>The code prints the message that has been received, that is, the <code class="literal">msg.payload</code> attribute. Then, the code assigns the result of the <code class="literal">json.loads</code> function to deserialize <code class="literal">msg.payload</code> to a Python object and assigns the results to the <code class="literal">message_dictionary</code> local variable. In case the contents of <code class="literal">msg.payload</code> are not JSON, a <code class="literal">ValueError</code> exception will be captured and no more code will be executed in the method. In case the contents of <code class="literal">msg.payload</code> are JSON, we will have a dictionary in the <code class="literal">message_dictionary</code> local variable.</p><p>Then, the code checks whether the <code class="literal">command_key</code> class attribute is included in the <code class="literal">message_dictionary</code> dictionary. If the expression evaluates to <code class="literal">True</code>, it means that the JSON message converted to a dictionary includes a command that we have to process. However, before we can process the command, we have to check which is the command, and therefore, it is necessary to retrieve the value associated with the key equivalent to the <code class="literal">command_key</code> class attribute. The code is capable of running specific code when the value is any of the two commands that we used in our previous example when we worked with the PubNub cloud.</p><p>The code uses the <code class="literal">active_instance</code> class attribute that has a reference to the active <code class="literal">MessageTopic</code> instance to call the necessary methods for either the <code class="literal">temperature_servo</code> or the <code class="literal">oled</code> attribute based on the command that has to be processed. We had to declare the callbacks as static methods, and therefore, we use this class attribute to access the active instance.</p><p>Once the command has been successfully processed, the code calls the <code class="literal">publish_response_message</code> for the <code class="literal">MessageTopic</code> instance saved in the <code class="literal">active_instance</code> class attribute. This method receives the message dictionary that has been received with the command in the <code class="literal">message</code> argument. The method calls the <code class="literal">json.dumps</code> function to serialize a dictionary to a JSON formatted string with the response message that indicates the command has been successfully processed. Finally, the <a id="id524" class="indexterm"/>code calls the <code class="literal">client.publish</code> method with the <code class="literal">topic</code> class attribute as the <code class="literal">topic</code> argument and the JSON formatted string (<code class="literal">response_message</code>) in the <code class="literal">payload</code> argument.</p><div class="note" title="Note" style=""><div class="inner"><h3 class="title"><a id="tip72"/>Tip</h3><p>In this case, we are not evaluating the response from the <code class="literal">publish</code> method. In addition, we are using the default value for the <code class="literal">qos</code> argument that specifies the desired quality of service. In more advanced scenarios, we should add code to check the results of the method and probably adding code on the <code class="literal">on_publish</code> callback that is fired when a message is successfully published.</p></div></div><p>Now, we will use the previously coded <code class="literal">MessageTopic</code> class to create a new version of the <code class="literal">__main__</code> method that uses the Mosquitto broker and the MQTT client to receive and process commands. The new version doesn't rotate the servo's shaft when the ambient temperature changes, instead, it will do this when it receives the appropriate command from any device connected to the Mosquitto broker. The following lines show the new version of the <code class="literal">__main__</code> method. The code file for the sample is <code class="literal">iot_python_chapter_09_05.py</code>.</p><div class="informalexample"><pre class="programlisting">if __name__ == "__main__":
    temperature_and_humidity_sensor = \
        TemperatureAndHumiditySensor(0)
    oled = TemperatureAndHumidityOled(0)
    temperature_servo = TemperatureServo(3)
<span class="strong"><strong>    message_topic = MessageTopic(temperature_servo, oled)</strong></span>
    while True:
        temperature_and_humidity_sensor.\
            measure_temperature_and_humidity()
        oled.print_temperature(
            temperature_and_humidity_sensor.temperature_fahrenheit,
            temperature_and_humidity_sensor.temperature_celsius)
        oled.print_humidity(
            temperature_and_humidity_sensor.humidity)
        print("Ambient temperature in degrees Celsius: {0}".
              format(temperature_and_humidity_sensor.temperature_celsius))
        print("Ambient temperature in degrees Fahrenheit: {0}".
              format(temperature_and_humidity_sensor.temperature_fahrenheit))
        print("Ambient humidity: {0}".
              format(temperature_and_humidity_sensor.humidity))
        # Sleep 10 seconds (10000 milliseconds) but process messages every 1 second
<span class="strong"><strong>        for i in range(0, 10):</strong></span>
<span class="strong"><strong>            message_channel.loop()</strong></span>
<span class="strong"><strong>            time.sleep(1)</strong></span>
</pre></div><p>The <a id="id525" class="indexterm"/>highlighted line creates an instance of the previously coded <code class="literal">MessageTopic</code> class with <code class="literal">temperature_servo</code> and <code class="literal">oled</code> as the arguments. The constructor will subscribe to the <code class="literal">"iot-python-gaston-hillar/temperature"</code> topic in the Mosquitto broker, and therefore, we must publish messages to this topic in order to send the commands that the code will process. The loop will read the values from the sensor and print the values to the console as in the previous version of the code, and therefore, we will have code running in the loop and we will also have code listening to the messages in the <code class="literal">"iot-python-gaston-hillar/temperature"</code> topic in the Mosquitto broker. The last lines of the loop call the <code class="literal">message_channel.loop</code> method 10 times and sleep 1 second each time between the calls. The <code class="literal">loop</code> method calls the loop method for the MQTT client to and ensures communication with the broker is carried out. Think about the call to the loop method as synchronizing your mailbox. Any pending messages to the published in the outgoing box will be sent and any incoming messages will arrive to the inbox and the events that we have previously analyzed will be fired.</p><div class="note" title="Note" style=""><div class="inner"><h3 class="title"><a id="tip73"/>Tip</h3><p>There is also a threaded interface that we can run by calling the <code class="literal">loop_start</code> method for the MQTT client. This way, we can avoid multiple calls to the <code class="literal">loop</code> method.</p></div></div><p>The following line will start the example.</p><div class="informalexample"><pre class="programlisting">python iot_python_chapter_09_05.py</pre></div><p>Keep the code running in the board. We will start receiving messages later because we have to write the code that will publish messages to this topic and send the commands to be processed.</p></div></div>


  <div id="sbo-rt-content"><div class="section" title="Publishing messages to a Mosquitto broker with a Python client"><div class="titlepage"><div><div><h1 class="title"><a id="ch09lvl1sec91"/>Publishing messages to a Mosquitto broker with a Python client</h1></div></div></div><p>We <a id="id526" class="indexterm"/>have the code that is going to be running in the Intel Galileo Gen 2 board to process the command messages received from the Mosquitto message broker. Now, we are going to code a Python client that will publish messages to the <code class="literal">"iot-python-gaston-hillar/temperature"</code> channel. This way, we will be able to design applications that can talk to IoT devices with MQTT messages. Specifically, the applications will be able to communicate through a Mosquitto message broker with Python code in the publisher and in the subscriber devices.</p><p>We can run the Python client on another Intel Galileo Gen 2 board or in any device that has Python 2.7.x installed. In addition, the code will run with Python 3.x. For example, we can run the Python client in our computer. We just need to make sure that we install the <code class="literal">pubnub</code> module we have previously installed with pip in the Python version that is running in the Yocto Linux for the board.</p><p>We will create many functions that we will assign as the callbacks to the events in the MQTT client. In addition, we will declare variables and a helper function to make it easy to publish a message with a command and the required values for the command. The code file for the sample is <code class="literal">iot_python_chapter_09_06.py</code>. Don't forget to replace the string assigned to the <code class="literal">topic</code> variable with the topic name you have specified in the previous code. The following lines show the code that defines the variables and the functions:</p><div class="informalexample"><pre class="programlisting">command_key = "command"
topic = "iot-python-gaston-hillar/temperature"


def on_connect(client, userdata, flags, rc):
    print("Connected to the {0} topic".
          format(topic))
    subscribe_result = client.subscribe(topic)
    publish_result_1 = client.publish(
        topic=topic,
        payload="Listening to messages in the Paho Python Client")
    publish_result_2 = publish_command(
        client,
        topic,
        "print_temperature_fahrenheit",
        "temperature_fahrenheit",
        45)
    publish_result_3 = publish_command(
        client,
        topic,
        "print_information_message",
        "text",
        "Python IoT")


def on_message(client, userdata, msg):
    if msg.topic == topic:
        print("I've received the following message: {0}".format(str(msg.payload)))


def publish_command(client, topic, command_name, key, value):
    command_message = json.dumps({
        command_key: command_name,
        key: value})
    result = client.publish(topic=topic,
                            payload=command_message)
    return result</pre></div><p>The <a id="id527" class="indexterm"/>code declares the <code class="literal">command_key</code> variable that defines the key string that indicates what the code understands as a command in the messages. Our main goal is to build and publish command messages to the topic specified in the <code class="literal">topic</code> variable. We will be both a subscriber and a publisher for this topic.</p><p>The <code class="literal">on_connect</code> function is the callback that will be executed once a successful connection has been established with the Mosquitto MQTT broker. The code calls the <code class="literal">subscribe</code> method for the MQTT client received in the <code class="literal">client</code> argument and then calls the <code class="literal">publish</code> method to send the following string message to the topic: <code class="literal">"Listening to messages in the Paho Python Client"</code>
</p><p>The code calls the <code class="literal">publish_command</code> function with the necessary arguments to build and publish the <code class="literal">print_temperature_fahrenheit</code> command with a temperature value of 45. Finally, the code calls the <code class="literal">publish_command</code> function again with the necessary arguments to build and publish the <code class="literal">print_information_message</code> command with a text value of <code class="literal">"Python IoT"</code>.</p><p>The <code class="literal">publish_command</code> function receives the MQTT client, the topic, the command name, the key and the value that provide the necessary information to execute the command in the <code class="literal">client</code>, <code class="literal">topic</code>, <code class="literal">command_name</code>, <code class="literal">key</code> and <code class="literal">value</code> required arguments. In this case, we don't target the command to a specific IoT device and all the devices that subscribe to the topic and run the code in our previous example will process the commands that we publish. We can use the code as a baseline to work with more complex examples in which we have to generate commands that target specific IoT devices. As happened in our previous examples, it is also necessary to improve the security.</p><p>The<a id="id528" class="indexterm"/> function creates a dictionary and saves the results of serializing the dictionary to a JSON formatted string in the <code class="literal">command_message</code> local variable. The <code class="literal">command_key</code> variable is the first key for the dictionary and the <code class="literal">command_name</code> received as an argument, the value that composes the first key-value pair. Then, the code calls the <code class="literal">client.publish</code> method to publish the <code class="literal">command_message</code> JSON formatted string to the topic received as an argument.</p><p>The <code class="literal">on_message</code> function will be executed each time a new message arrives to the topic to which we have subscribed. The function just prints the raw string with the payload of the received message. </p><p>Now, we will use the previously coded <code class="literal">functions</code> to write a <code class="literal">__main__</code> method that publishes the two commands included in MQTT messages that our board will process. The following lines show the code for the <code class="literal">__main__</code> method. The code file for the sample is <code class="literal">iot_python_chapter_09_06.py</code>.</p><div class="informalexample"><pre class="programlisting">if __name__ == "__main__":
    client = mqtt.Client()
    client.on_connect = on_connect
    client.on_message = on_message
    client.connect(host="iot.eclipse.org",
                   port=1883,
                   keepalive=60)
    client.loop_forever()</pre></div><p>The code in the <code class="literal">__main__</code> method is very easy to understand. The code creates an instance of the <code class="literal">mqtt.Client</code> class that represents an MQTT client and we will use it to communicate with an MQTT broker. As we create the instance with the default parameters, we will create an instance of <code class="literal">paho.mqtt.client.MQTTv31</code> and we will work with MQTT version 3.1.</p><p>Then, the code assigns the <code class="literal">client.on_connect</code> attribute to the previously coded <code class="literal">on_connect</code> function and the <code class="literal">client.on_message</code> attribute to the <code class="literal">on_message</code> function. The code calls the <code class="literal">client.connect</code> method and specifies the publically accessible sandbox server for the Eclipse IoT projects at iot.eclipse.org, port 1883, in the arguments. This way, the code asks the MQTT client to establish a connection to the specified MQTT broker. In case you decide to use your own Mosquitto broker, you just need to change the values for the <code class="literal">host</code> and <code class="literal">port</code> arguments, according to the configuration for the Mosquitto broker. Remember that the <code class="literal">connect</code> method runs with an asynchronous execution, and therefore, it is a non-blocking call.</p><p>After a <a id="id529" class="indexterm"/>connection has been successfully established with the MQTT broker, the specified callback in the <code class="literal">client.on_connect</code> attribute will be executed, that is, the <code class="literal">on_connect</code> function. The function receives the <code class="literal">mqtt.Client</code> instance that established the connection with the MQTT broker in the <code class="literal">client</code> argument. As previously explained, the function subscribes to a topic and schedules the publication of three messages to it.</p><p>Finally, the code calls the <code class="literal">client.loop_forever</code> method that calls the loop method for us in an infinite blocking loop. At this point, we only want to run the MQTT client loop in our program. The scheduled messages will be published and we will receive the messages with the successfully executed command details after the board processes the commands.</p><p>Keep the Python code we have executed in our previous example running on the board. We want the board to process our commands. The following line will start the example for the Python client in any computer or device that you want to use as a client. It is possible to run the code in another SSH terminal in case you want to use the same board as a client.</p><div class="informalexample"><pre class="programlisting">python iot_python_chapter_09_06.py</pre></div><p>After you run the example, you will see the following output in the Python console that runs the Python client, that is, the <code class="literal">iot_python_chapter_09_06.py</code> Python script.</p><div class="informalexample"><pre class="programlisting">Connected to the iot-python-gaston-hillar/temperature topic
I've received the following message: Listening to messages in the Paho Python Client
I've received the following message: {"command": "print_temperature_fahrenheit", "temperature_fahrenheit": 45}
I've received the following message: {"text": "Python IoT", "command": "print_information_message"}
I've received the following message: {"successfully_processed_command": "print_temperature_fahrenheit"}
I've received the following message: {"successfully_processed_command": "print_information_message"}</pre></div><p>The code used the Eclipse Paho MQTT Python client library to build and publish the following two command messages in the <code class="literal">"iot-python-gaston-hillar/temperature"</code> topic in the Mosquitto broker:</p><div class="informalexample"><pre class="programlisting">{"command":"print_temperature_fahrenheit", "temperature_fahrenheit": "45"}
{"command":"print_information_message", "text": "Python IoT"}</pre></div><p>As we <a id="id530" class="indexterm"/>are also subscribed to the <code class="literal">"iot-python-gaston-hillar/temperature"</code> topic, we receive the messages we sent. Then, we received the successfully processed command messages for the two command messages. The board has processed the commands and published the messages to the <code class="literal">"iot-python-gaston-hillar/temperature"</code> topic.</p><p>You will see the following messages in the output for the SSH terminal that is running the code for the board that processes the commands, that is, the <code class="literal">iot_python_chapter_09_05.py</code> Python script:</p><div class="informalexample"><pre class="programlisting">I've received the following message: Listening to messages in the Intel Galileo Gen 2 board
I've received the following message: Listening to messages in the Paho Python Client
I've received the following message: {"command": "print_temperature_fahrenheit", "temperature_fahrenheit": 45}
I've received the following message: {"text": "Python IoT", "command": "print_information_message"}
I've received the following message: {"successfully_processed_command": "print_temperature_fahrenheit"}
I've received the following message: {"successfully_processed_command": "print_information_message"}</pre></div><p>You will see the following text displayed at the bottom of the OLED matrix: <code class="literal">Python IoT</code>. In addition, the servo's shaft will rotate to 45 degrees.</p></div></div>


  <div id="sbo-rt-content"><div class="section" title="Test your knowledge"><div class="titlepage"><div><div><h1 class="title"><a id="ch09lvl1sec92"/>Test your knowledge</h1></div></div></div><div class="orderedlist"><ol class="orderedlist arabic"><li class="listitem">MQTT is:<div class="orderedlist"><ol class="orderedlist arabic"><li class="listitem">A heavyweight messaging protocol that runs on top of the TCP/IP protocol and works with a publish-subscribe mechanism.</li><li class="listitem">A lightweight messaging protocol that runs on top of the TCP/IP protocol and works with a publish-subscribe mechanism.</li><li class="listitem">An equivalent to HTTP.</li></ol></div></li><li class="listitem">Mosquitto is:<div class="orderedlist"><ol class="orderedlist arabic"><li class="listitem">An open source message broker that implements the versions 3.1 and 3.1.1 of the MQTT protocol.</li><li class="listitem">A closed source message broker that implements the versions 3.1 and 3.1.1 of the MQTT protocol.</li><li class="listitem">An open source message broker that implements a RESTful API.</li></ol></div></li><li class="listitem">The Eclipse Paho project provides:<div class="orderedlist"><ol class="orderedlist arabic"><li class="listitem">An open source client implementation of HTTP.</li><li class="listitem">An open source client implementation of <code class="literal">dweet.io</code>.</li><li class="listitem">An open source client implementation of MQTT.</li></ol></div></li><li class="listitem">Which of the following Python modules is the Paho Python Client?<div class="orderedlist"><ol class="orderedlist arabic"><li class="listitem">paho-client-pip.</li><li class="listitem">paho-mqtt.</li><li class="listitem">paho-http.</li></ol></div></li><li class="listitem">Dweepy is:<div class="orderedlist"><ol class="orderedlist arabic"><li class="listitem">A simple Python client for <code class="literal">dweet.io</code> that allows us to easily publish data to <code class="literal">dweet.io</code> with Python.</li><li class="listitem">A simple Python client for Mosquitto that allows us to easily publish messages to a Mosquitto message broker.</li><li class="listitem">A simple Python client for PubNub cloud that allows us to easily publish messages to the PubNub cloud.</li></ol></div></li></ol></div></div></div>


  <div id="sbo-rt-content"><div class="section" title="Summary"><div class="titlepage"><div><div><h1 class="title"><a id="ch09lvl1sec93"/>Summary</h1></div></div></div><p>In this chapter, we combined many cloud-based services that allowed us to easily publish data collected from sensors and visualize it in a web-based dashboard. We realized that there is always a Python API, and therefore, it is easy to write Python code that interacts with popular cloud-based services.</p><p>We worked with the MQTT protocol and its publish/subscribe model to process commands in our board and indicate when the commands were successfully processed through messages. First, we worked with the PubNub cloud that works with the MQTT protocol under the hoods. Then, we developed the same example with Mosquitto and Eclipse Paho. Now, we know how we can write applications that can establish bi-directional communications with our IoT devices. In addition, we know how we can make IoT devices communicate with other IoT devices.</p><p>Now that we are able to take advantage of many cloud services and we worked with the MQTT protocol, we will learn how to analyze huge amounts of data, which is the topic of the next chapter.</p></div></div>
</body></html>