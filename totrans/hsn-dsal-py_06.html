<html><head></head><body>
  <div><h1 class="chapterNumber">6</h1>
    <h1 id="_idParaDest-133" class="chapterTitle">Trees</h1>
    <p class="normal">A <strong class="keyWord">tree</strong> is a<a id="_idIndexMarker469"/> hierarchical form of data structure. Data structures such as lists, queues, and stacks are linear in that the items are stored in a sequential way. However, a tree is a non-linear data structure, as<a id="_idIndexMarker470"/> there is a <strong class="keyWord">parent-child relationship</strong> between the items. The top of the tree’s data structure is <a id="_idIndexMarker471"/>known as a <strong class="keyWord">root node</strong>. This is the ancestor of all other nodes in the tree.</p>
    <p class="normal">Tree data structures are very important, owing to their use in various applications, such as parsing expressions, efficient searches, and priority queues. Certain document types, such as <code class="inlineCode">XML</code> and <code class="inlineCode">HTML</code>, can also be represented in a tree. </p>
    <p class="normal">In this chapter, we will cover the following topics:</p>
    <ul>
      <li class="bulletList">Terms and definitions of trees</li>
      <li class="bulletList">Binary trees and binary search trees</li>
      <li class="bulletList">Tree traversal</li>
      <li class="bulletList">Binary search trees</li>
    </ul>
    <h1 id="_idParaDest-134" class="heading-1">Terminology</h1>
    <p class="normal">Let’s consider some of the terminology associated with tree data structures.</p>
    <p class="normal">To understand trees, we need to first understand the basic concepts related to them. A tree is a <a id="_idIndexMarker472"/>data structure in which data is organized in a hierarchical form. </p>
    <p class="normal"><em class="italic">Figure 6.1</em> contains a typical tree consisting of character nodes lettered <code class="inlineCode">A</code> through to <code class="inlineCode">M</code>:</p>
    <figure class="mediaobject"><img src="img/B17217_06_01.png" alt=""/></figure>
    <p class="packt_figref">Figure 6.1: Example tree data structure </p>
    <p class="normal">Here is a list of terms associated with a tree:</p>
    <ul>
      <li class="bulletList"><strong class="keyWord">Node</strong>: Each <a id="_idIndexMarker473"/>circled letter in the preceding diagram represents a node. A <a id="_idIndexMarker474"/>node is any data structure that stores data.</li>
      <li class="bulletList"><strong class="keyWord">Root node</strong>: The root node<a id="_idIndexMarker475"/> is the first node from which all other nodes in the tree descend from. In other words, a root node is a node that does not have a parent node. In every tree, there is always one unique root node. The root node<a id="_idIndexMarker476"/> is node <code class="inlineCode">A</code> in the above example tree.</li>
      <li class="bulletList"><strong class="keyWord">Subtree</strong>: A subtree<a id="_idIndexMarker477"/> is a tree whose nodes descend from some other tree. For <a id="_idIndexMarker478"/>example, nodes <code class="inlineCode">F</code>, <code class="inlineCode">K</code>, and <code class="inlineCode">L</code> form a subtree of the original tree.</li>
      <li class="bulletList"><strong class="keyWord">Degree</strong>: The<a id="_idIndexMarker479"/> total number of children of a given node is called the <strong class="keyWord">degree of the node</strong>. A tree consisting of only one node has a degree of 0. The degree of node <code class="inlineCode">A</code> in the preceding diagram is 2, the degree of node <code class="inlineCode">B</code> is 3, the degree of node <code class="inlineCode">C</code> is 3, and, the degree of node <code class="inlineCode">G</code> is 1.</li>
      <li class="bulletList"><strong class="keyWord">Leaf node</strong>: The leaf node<a id="_idIndexMarker480"/> does not have any children and is the terminal node of the<a id="_idIndexMarker481"/> given tree. The degree of the leaf node is always 0. In the preceding diagram, the nodes <code class="inlineCode">J</code>, <code class="inlineCode">E</code>, <code class="inlineCode">K</code>, <code class="inlineCode">L</code>, <code class="inlineCode">H</code>, <code class="inlineCode">M</code>, and <code class="inlineCode">I</code> are all leaf nodes.</li>
      <li class="bulletList"><strong class="keyWord">Edge</strong>: The <a id="_idIndexMarker482"/>connection among any given two nodes in the tree is called an edge. The <a id="_idIndexMarker483"/>total number of edges in a given tree will be a maximum of one less than the total nodes in the tree. An example edge is shown in <em class="italic">Figure 6.1</em>.</li>
      <li class="bulletList"><strong class="keyWord">Parent</strong>: A node<a id="_idIndexMarker484"/> that has a subtree is the parent node<a id="_idIndexMarker485"/> of that subtree. For example, node <code class="inlineCode">B</code> is the parent of nodes <code class="inlineCode">D</code>, <code class="inlineCode">E</code>, and <code class="inlineCode">F</code>, and node <code class="inlineCode">F</code> is the parent of nodes <code class="inlineCode">K</code> and <code class="inlineCode">L</code>.</li>
      <li class="bulletList"><strong class="keyWord">Child</strong>: This is a <a id="_idIndexMarker486"/>node that is descendant from a parent node. For example, nodes <code class="inlineCode">B</code> and <code class="inlineCode">C</code> are children of parent node <code class="inlineCode">A</code>, while nodes <code class="inlineCode">H</code>, <code class="inlineCode">G</code>, and <code class="inlineCode">I</code> are the <a id="_idIndexMarker487"/>children of parent node <code class="inlineCode">C</code>. </li>
      <li class="bulletList"><strong class="keyWord">Sibling</strong>: All nodes with the <a id="_idIndexMarker488"/>same parent node are siblings. For example, node <code class="inlineCode">B</code> is the <a id="_idIndexMarker489"/>sibling of node <code class="inlineCode">C</code>, and, similarly, nodes <code class="inlineCode">D</code>, <code class="inlineCode">E</code>, and <code class="inlineCode">F</code> are also siblings. </li>
      <li class="bulletList"><strong class="keyWord">Level</strong>: The root<a id="_idIndexMarker490"/> node of the tree is considered to be at level 0. The children of the root node are considered to be at level 1, and the children of the nodes at level 1 are considered to be at level 2, and so on. For example, in <em class="italic">Figure 6.1</em>, root node <code class="inlineCode">A</code> is at level 0, nodes <code class="inlineCode">B</code> and <code class="inlineCode">C</code> are at level 1, and nodes <code class="inlineCode">D</code>, <code class="inlineCode">E</code>, <code class="inlineCode">F</code>, <code class="inlineCode">H</code>, <code class="inlineCode">G</code>, and <code class="inlineCode">I</code> are at level 2.</li>
      <li class="bulletList"><strong class="keyWord">Height of a tree</strong>: The <a id="_idIndexMarker491"/>total number of nodes in the longest path of the tree is the height of the tree. For example, in <em class="italic">Figure 6.1</em>, the height of the tree is 4, as the longest paths, <code class="inlineCode">A</code>-<code class="inlineCode">B</code>-<code class="inlineCode">D</code>-<code class="inlineCode">J</code>, <code class="inlineCode">A</code>-<code class="inlineCode">C</code>-<code class="inlineCode">G</code>-<code class="inlineCode">M</code>, and <code class="inlineCode">A</code>-<code class="inlineCode">B</code>-<code class="inlineCode">F</code>-<code class="inlineCode">K</code>, all have a total number of four nodes each.</li>
      <li class="bulletList"><strong class="keyWord">Depth</strong>: The <a id="_idIndexMarker492"/>depth of a node is the number of edges from the root of the tree to that node. In the preceding tree example, the depth of node <code class="inlineCode">H</code> is 2.</li>
    </ul>
    <p class="normal">In linear data structures, data items are stored in sequential order, whereas non-linear data structures store data items in a non-linear order, where a data item can be connected to more than one other data item. All of the data items in linear data structures, such as <em class="italic">arrays</em>, <em class="italic">lists</em>, <em class="italic">stacks</em>, and <em class="italic">queues</em>, can be traversed in one pass, whereas this is not possible in the case of non-linear data structures such as trees; they store the data differently from other linear data structures.</p>
    <p class="normal">In a tree data structure, the nodes are arranged in a parent-child relationship. There should not be any cycle among the nodes in trees. The tree structure has nodes to form a hierarchy, and a tree that has no nodes is <a id="_idIndexMarker493"/>called an <strong class="keyWord">empty tree</strong>.</p>
    <p class="normal">First, we’ll discuss one of the most important kind of trees, that is, the <strong class="keyWord">binary tree</strong>.</p>
    <h1 id="_idParaDest-135" class="heading-1">Binary trees</h1>
    <p class="normal">A binary tree<a id="_idIndexMarker494"/> is a collection of nodes, where the nodes in the tree can have zero, one, or <a id="_idIndexMarker495"/>two child nodes. A simple binary tree<a id="_idIndexMarker496"/> has a<a id="_idIndexMarker497"/> maximum of two children, that is, the left child and the right child. </p>
    <p class="normal">For example, in the binary <a id="_idIndexMarker498"/>tree shown in <em class="italic">Figure 6.2</em>, there is a root node that has two children (a left child, a right child):</p>
    <figure class="mediaobject"><img src="img/B17217_06_02.png" alt=""/></figure>
    <p class="packt_figref">Figure 6.2: Example of a binary tree</p>
    <p class="normal">The nodes in the binary tree are organized in the form of the left subtree and right subtree. For example, a tree of five nodes is shown in <em class="italic">Figure 6.3</em> that has a root node, <code class="inlineCode">R</code>, and two subtrees, i.e. left subtree, <code class="inlineCode">T1</code>, and right subtree, <code class="inlineCode">T2</code>:</p>
    <figure class="mediaobject"><img src="img/B17217_06_03.png" alt=""/></figure>
    <p class="packt_figref">Figure 6.3: An example binary tree of five nodes</p>
    <p class="normal">A regular binary tree<a id="_idIndexMarker499"/> has no other rules as to how elements are arranged in the<a id="_idIndexMarker500"/> tree. It should only satisfy the condition that each node should have a maximum of two children.</p>
    <p class="normal">A tree is <a id="_idIndexMarker501"/>called a <strong class="keyWord">full binary </strong>tree<a id="_idIndexMarker502"/> if all the nodes of a binary tree have either zero or two children, and if there is no node that has one child. An example of a full<a id="_idIndexMarker503"/> binary tree is shown in <em class="italic">Figure 6.4</em>:</p>
    <figure class="mediaobject"><img src="img/B17217_06_04.png" alt=""/></figure>
    <p class="packt_figref">Figure 6.4: An example of a full binary tree</p>
    <p class="normal">A perfect binary tree<a id="_idIndexMarker504"/> has all the nodes in the binary tree filled, and it doesn’t <a id="_idIndexMarker505"/>have space vacant for any new nodes; if we add new nodes, they can only be added by increasing the tree’s height. A sample perfect binary tree is shown in <em class="italic">Figure 6.5</em>:</p>
    <figure class="mediaobject"><img src="img/B17217_06_05.png" alt=""/></figure>
    <p class="packt_figref">Figure 6.5: An example of a perfect binary tree</p>
    <p class="normal">A <strong class="keyWord">complete binary tree</strong> is filled with all possible nodes except with a possible exception at the lowest level of the tree. All <a id="_idIndexMarker506"/>nodes are also filled on the left side. A <a id="_idIndexMarker507"/>complete binary tree is shown in <em class="italic">Figure 6.6</em>:</p>
    <figure class="mediaobject"><img src="img/B17217_06_06.png" alt=""/></figure>
    <p class="packt_figref">Figure 6.6: An example of a complete binary tree</p>
    <p class="normal">A binary tree can be balanced or unbalanced. In a <a id="_idIndexMarker508"/>balanced binary tree, the difference in height of the left and right subtrees for every node in the tree is no more than 1. A <a id="_idIndexMarker509"/>balanced tree is shown in <em class="italic">Figure 6.7</em>:</p>
    <figure class="mediaobject"><img src="img/B17217_06_07.png" alt=""/></figure>
    <p class="packt_figref">Figure 6.7: An example of a balanced tree</p>
    <p class="normal">An unbalanced binary tree<a id="_idIndexMarker510"/> is a binary tree that has a difference of more than 1<a id="_idIndexMarker511"/> between the right subtree and left subtree. An example of an unbalanced tree is shown in <em class="italic">Figure 6.8</em>:</p>
    <figure class="mediaobject"><img src="img/B17217_06_08.png" alt=""/></figure>
    <p class="packt_figref">Figure 6.8: An example of an unbalanced tree</p>
    <p class="normal">Next, we’ll discuss the details of the implementation of a simple binary tree.</p>
    <h2 id="_idParaDest-136" class="heading-2">Implementation of tree nodes</h2>
    <p class="normal">As we have already <a id="_idIndexMarker512"/>discussed in previous chapters, a node consists of data items and references to other nodes. </p>
    <p class="normal">In a binary tree node, each node will contain data items and two references that will point to their left and right children, respectively. Let’s look at the following code for building a binary tree <code class="inlineCode">Node</code> class in Python:</p>
    <pre class="programlisting code"><code class="hljs-code">class Node:
    def __init__(self, data):
        self.data = data
        self.right_child = None
        self.left_child = None
</code></pre>
    <p class="normal">To better understand the working of this class, let’s first create a binary tree of four nodes—<code class="inlineCode">n1</code>, <code class="inlineCode">n2</code>, <code class="inlineCode">n3</code>, and <code class="inlineCode">n4</code>—as shown in <em class="italic">Figure 6.9</em>:</p>
    <figure class="mediaobject"><img src="img/B17217_06_09.png" alt=""/></figure>
    <p class="packt_figref">Figure 6.9: An example binary tree of four nodes</p>
    <p class="normal">For this, we firstly create four nodes—<code class="inlineCode">n1</code>, <code class="inlineCode">n2</code>, <code class="inlineCode">n3</code>, and <code class="inlineCode">n4</code>:</p>
    <pre class="programlisting code"><code class="hljs-code">n1 = Node("root node")
n2 = Node("left child node")
n3 = Node("right child node")
n4 = Node("left grandchild node")
</code>
Figure 6.9</em>:</pre>
    <pre class="programlisting code"><code class="hljs-code">n1.left_child = n2
n1.right_child = n3
n2.left_child = n4
</code></pre>
    <p class="normal">Here, we have created a<a id="_idIndexMarker514"/> very simple tree structure of four nodes. After creating a tree, one of the most important operations that is to be applied to trees is <strong class="keyWord">traversal</strong>. Next, we’ll understand how we can traverse the tree.</p>
    <h2 id="_idParaDest-137" class="heading-2">Tree traversal</h2>
    <p class="normal">The method to visit all the nodes in a<a id="_idIndexMarker515"/> tree is called <strong class="keyWord">tree traversal</strong>. In the case of a linear data structure, data element traversal is straightforward since all the items are stored in a sequential manner, so each data item is visited only once. However, in the case of non-linear data structures, such as trees and graphs, traversal algorithms are important. To understand traversing, let’s traverse the left subtree of the binary tree we created in the previous section. For this, we start from the root node, print out the node, and move down the tree to the next left node. We keep doing this until we have reached the end of the left subtree, like so:</p>
    <pre class="programlisting code"><code class="hljs-code">current = n1
while current:
    print(current.data)
    current = current.left_child
</code></pre>
    <p class="normal">The output of traversing the preceding code block is as follows:</p>
    <pre class="programlisting con"><code class="hljs-con">root node
left child node
left grandchild node
</code></pre>
    <p class="normal">There are multiple ways to process and traverse the tree that depend upon the sequence of visiting the root node, left subtree, or right subtree. Mainly, there are two kinds of approaches, firstly, one in which we start from a node and traverse every available child node, and then continue to traverse to the next sibling. There are three possible variations of this method, namely, <strong class="keyWord">in-order</strong>, <strong class="keyWord">pre-order</strong>, and <strong class="keyWord">post-order</strong>. Another approach to traverse the tree is to start from the root node and then visit all the nodes on each level, and process the nodes level by level. We will discuss each approach in the following sections.</p>
    <h3 id="_idParaDest-138" class="heading-3">In-order traversal</h3>
    <p class="normal">In-order tree traversal <a id="_idIndexMarker516"/>works as follows: we start traversing the left<a id="_idIndexMarker517"/> subtree recursively, and once the left subtree is visited, the root node is visited, and then finally the right subtree is visited recursively. It has the following three steps:</p>
    <ul>
      <li class="bulletList">We start traversing the left subtree and call an ordering function recursively</li>
      <li class="bulletList">Next, we visit the root node</li>
      <li class="bulletList">Finally, we traverse the right subtree and call an ordering function recursively</li>
    </ul>
    <p class="normal">So, in a nutshell, for in-order tree traversal, we visit the nodes in the tree in the order of left subtree, root, then the right subtree.</p>
    <p class="normal">Let’s consider an example <a id="_idIndexMarker518"/>tree shown in <em class="italic">Figure 6.10</em> to understand<a id="_idIndexMarker519"/> in-order tree traversal:</p>
    <figure class="mediaobject"><img src="img/B17217_06_10.png" alt=""/></figure>
    <p class="packt_figref">Figure 6.10: An example binary tree for in-order tree traversal</p>
    <p class="normal">In the binary tree shown in <em class="italic">Figure 6.10</em>, the working of the in-order traversal is as follows: first, we recursively visit the left subtree of the root node <code class="inlineCode">A</code>. The left subtree of node <code class="inlineCode">A</code> has node <code class="inlineCode">B</code> as the root node, so we again go to the left subtree of root node <code class="inlineCode">B</code>, that is, node <code class="inlineCode">D</code>. We recursively go to the left subtree of root node <code class="inlineCode">D</code> so that we get the left child of root node <code class="inlineCode">D</code>. We visit the left child, <code class="inlineCode">G</code>, then visit the root node, <code class="inlineCode">D</code>, and then visit the right child, <code class="inlineCode">H</code>.</p>
    <p class="normal">Next, we visit node <code class="inlineCode">B</code> and then visit node <code class="inlineCode">E</code>. In this manner, we have visited the left subtree of root node <code class="inlineCode">A</code>. Next, we visit root node <code class="inlineCode">A</code>. After that, we visit the right subtree of root node <code class="inlineCode">A</code>. Here, we first go to the left subtree of root node <code class="inlineCode">C</code>, which is null, so next, we visit node <code class="inlineCode">C</code>, and then we visit the right child of node <code class="inlineCode">C</code>, that is, node <code class="inlineCode">F</code>.</p>
    <p class="normal">Therefore, the in-order traversal for this example tree is <code class="inlineCode">G</code>-<code class="inlineCode">D</code>-<code class="inlineCode">H</code>-<code class="inlineCode">B</code>-<code class="inlineCode">E</code>-<code class="inlineCode">A</code>-<code class="inlineCode">C</code>-<code class="inlineCode">F</code>.</p>
    <p class="normal">The Python implementation of a recursive function to return an in-order listing of nodes in a tree is as follows:</p>
    <pre class="programlisting code"><code class="hljs-code">def inorder(root_node):
    current = root_node
    if current is None:
        return
    inorder(current.left_child)
    print(current.data)
    inorder(current.right_child)
inorder(n1)
</code></pre>
    <p class="normal">Firstly, we check if the current node is null or empty. If it is not empty, we traverse the tree. We visit the node by printing the visited node. In this case, we first recursively call the <code class="inlineCode">inorder</code> function with <code class="inlineCode">current.left_child</code>, then we visit the root node, and finally, we recursively call the <code class="inlineCode">inorder</code> function with <code class="inlineCode">current.right_child</code>.</p>
    <p class="normal">Finally, when we <a id="_idIndexMarker520"/>apply the above in-order traversal algorithm on the <a id="_idIndexMarker521"/>above sample tree of four nodes. With <code class="inlineCode">n1</code> as the root node, we get the following output:</p>
    <pre class="programlisting con"><code class="hljs-con">left grandchild node
left child node
root node
right child node
</code></pre>
    <p class="normal">Next, we will discuss pre-order traversal.</p>
    <h3 id="_idParaDest-139" class="heading-3">Pre-order traversal</h3>
    <p class="normal">Pre-order tree traversal<a id="_idIndexMarker522"/> traverses the tree in the order of the <a id="_idIndexMarker523"/>root node, the left subtree, and then the right subtree. It works as follows:</p>
    <ol class="numberedList" style="list-style-type: decimal;">
      <li class="numberedList" value="1">We start traversing with the root node</li>
      <li class="numberedList">Next, we traverse the left subtree and call an ordering function with the left subtree recursively</li>
      <li class="numberedList">Next, we visit the right subtree and call an ordering function with the right subtree recursively</li>
    </ol>
    <p class="normal">Consider the example tree shown in <em class="italic">Figure 6.11</em> to understand pre-order traversal:</p>
    <figure class="mediaobject"><img src="img/B17217_06_11.png" alt=""/></figure>
    <p class="packt_figref">Figure 6.11: An example tree to understand pre-order traversal</p>
    <p class="normal">The pre-order <a id="_idIndexMarker524"/>traversal for the example binary tree shown in <em class="italic">Figure 6.11</em> works as follows: first, we visit root node <code class="inlineCode">A</code>. Next, we go to the left subtree of root node <code class="inlineCode">A</code>. The left subtree of node <code class="inlineCode">A</code> has node <code class="inlineCode">B</code> as the root, so we visit this root node, and then go to the left subtree of root node <code class="inlineCode">B</code>, node <code class="inlineCode">D</code>. We visit node <code class="inlineCode">D</code> and then the left <a id="_idIndexMarker525"/>subtree of root node <code class="inlineCode">D</code>, and then we visit the left child, <code class="inlineCode">G</code>, which is the subtree of root node <code class="inlineCode">D</code>. Since there is no child of node <code class="inlineCode">G</code>, we visit the right subtree. We visit the right child of the subtree of root node <code class="inlineCode">D</code>, node <code class="inlineCode">H</code>. Next, we visit the right child of the subtree of root node <code class="inlineCode">B</code>, node <code class="inlineCode">E</code>.</p>
    <p class="normal">In this manner, we have visited root node <code class="inlineCode">A</code> and the left subtree of root node <code class="inlineCode">A</code>. Next, we visit the right subtree of root node <code class="inlineCode">A</code>. Here, we visit root node <code class="inlineCode">C</code>, and then we go to the left subtree of root node <code class="inlineCode">C</code>, which is null, so we visit the right child of node <code class="inlineCode">C</code>, node <code class="inlineCode">F</code>.</p>
    <p class="normal">The pre-order traversal for this example tree would be <code class="inlineCode">A</code>-<code class="inlineCode">B</code>-<code class="inlineCode">D</code>-<code class="inlineCode">G</code>-<code class="inlineCode">H</code>-<code class="inlineCode">E</code>-<code class="inlineCode">C</code>-<code class="inlineCode">F</code>.</p>
    <p class="normal">The recursive function for the pre-order tree traversal is as follows:</p>
    <pre class="programlisting code"><code class="hljs-code">def preorder(root_node):
    current = root_node
    if current is None:
        return
    print(current.data)
    preorder(current.left_child)
    preorder(current.right_child)
preorder(n1)
</code></pre>
    <p class="normal">First, we check if the current node is null or empty. If it is empty, it means the tree is an empty tree, and if the current node is not empty, then we traverse the tree using the pre-order algorithm. The pre-order traversal algorithm traverses the tree in the order of root, left subtree, and right subtree recursively, as shown in the above code. Finally, when we apply the above pre-order traversal algorithm on the above sample tree of four nodes <a id="_idIndexMarker526"/>with <code class="inlineCode">n1</code> node as the root node, we get the following<a id="_idIndexMarker527"/> output:</p>
    <pre class="programlisting con"><code class="hljs-con">root node
left child node
left grandchild node
right child node
</code></pre>
    <p class="normal">Next, we will discuss post-order traversal.</p>
    <h3 id="_idParaDest-140" class="heading-3">Post-order traversal</h3>
    <p class="normal">Post-order tree traversal <a id="_idIndexMarker528"/>works<a id="_idIndexMarker529"/> as follows:</p>
    <ol class="numberedList" style="list-style-type: decimal;">
      <li class="numberedList" value="1">We start traversing the left subtree and call an ordering function recursively</li>
      <li class="numberedList">Next, we traverse the right subtree and call an ordering function recursively</li>
      <li class="numberedList">Finally, we visit the root node</li>
    </ol>
    <p class="normal">So, in a nutshell, for post-order tree traversal, we visit the nodes in the tree in the order of the left subtree, the right subtree, and finally the root node.</p>
    <p class="normal">Consider the following example tree shown in <em class="italic">Figure 6.12</em> to understand post-order tree traversal:</p>
    <figure class="mediaobject"><img src="img/B17217_06_12.png" alt=""/></figure>
    <p class="packt_figref">Figure 6.12: An example tree to understand pre-order traversal</p>
    <p class="normal">In the <a id="_idIndexMarker530"/>preceding figure, <em class="italic">Figure 6.12</em>, we first visit the left subtree of root node <code class="inlineCode">A</code> recursively. We get to the last left subtree, that is, root node <code class="inlineCode">D</code>, and then we visit the node to the left of it, which is node <code class="inlineCode">G</code>. We visit the right child, <code class="inlineCode">H</code>, after this, and then we<a id="_idIndexMarker531"/> visit root node <code class="inlineCode">D</code>. Following the same rule, we next visit the right child of node <code class="inlineCode">B</code>, node <code class="inlineCode">E</code>. Then, we visit node <code class="inlineCode">B</code>. Following on from this, we traverse the right subtree of node <code class="inlineCode">A</code>. Here, we first reach the last right subtree and visit node <code class="inlineCode">F</code>, and then we visit node <code class="inlineCode">C</code>. Finally, we visit root node <code class="inlineCode">A</code>.</p>
    <p class="normal">The post-order traversal for this example tree would be <code class="inlineCode">G</code>-<code class="inlineCode">H</code>-<code class="inlineCode">D</code>-<code class="inlineCode">E</code>-<code class="inlineCode">B</code>-<code class="inlineCode">F</code>-<code class="inlineCode">C</code>-<code class="inlineCode">A</code>.</p>
    <p class="normal">The implementation of the post-order method for tree traversal is as follows:</p>
    <pre class="programlisting code"><code class="hljs-code">def postorder( root_node):
    current = root_node
    if current is None:
        return
    postorder(current.left_child)
    postorder(current.right_child)
    print(current.data)
postorder(n1)
</code></pre>
    <p class="normal">First, we check if the current node is null or empty. If it is not empty, we traverse the tree using the <a id="_idIndexMarker532"/>post-order algorithm as discussed, and finally, when we apply the above post-order traversal <a id="_idIndexMarker533"/>algorithm on the above sample tree of four nodes with <code class="inlineCode">n1</code> as the root node. We get the following output:</p>
    <pre class="programlisting con"><code class="hljs-con">left grandchild node
left child node
right child node
root node
</code></pre>
    <p class="normal">Next, we will discuss level-order traversal.</p>
    <h3 id="_idParaDest-141" class="heading-3">Level-order traversal</h3>
    <p class="normal">In this <a id="_idIndexMarker534"/>traversal method, we start by visiting the root of the tree before <a id="_idIndexMarker535"/>visiting every node on the next level of the tree. Then, we move on to the next level in the tree, and so on. This kind of tree traversal is how breadth-first traversal in a graph works, as it broadens the tree by traversing all the nodes in a level before going deeper into the tree.</p>
    <p class="normal">Let’s consider the following example tree and traverse it:</p>
    <figure class="mediaobject"><img src="img/B17217_06_13.png" alt=""/></figure>
    <p class="packt_figref">Figure 6.13: An example tree to understand level-order traversal</p>
    <p class="normal">In <em class="italic">Figure 6.13</em>, we start by visiting the root node at level 0, which is the node with a value of <code class="inlineCode">4</code>. We visit this node by printing out its value. Next, we move to level 1 and visit all the nodes at this level, which are the nodes with the values <code class="inlineCode">2</code> and <code class="inlineCode">8</code>. Finally, we move to the next level in the tree, that is, level 3, and we visit all the nodes at this level, which are <code class="inlineCode">1</code>, <code class="inlineCode">3</code>, <code class="inlineCode">5</code>, and <code class="inlineCode">10</code>. Thus, the level-order tree traversal for this tree is as follows: <code class="inlineCode">4</code>, <code class="inlineCode">2</code>, <code class="inlineCode">8</code>, <code class="inlineCode">1</code>, <code class="inlineCode">3</code>, <code class="inlineCode">5</code>, and <code class="inlineCode">10</code>.</p>
    <p class="normal">This level-order tree traversal is implemented using a queue data structure. We start by visiting the root node, and we push it into a queue. The node at the front of the queue is accessed (dequeued), which can then be either printed or stored for later use. After adding the root node, the left child node is added to the queue, followed by the right node. Thus, when traversing at any given level of the tree, all the data items of that level are firstly inserted in the queue from left to right. After that, all the nodes are visited from the queue one by one. This process is repeated for all the levels of the tree.</p>
    <p class="normal">The traversal of the preceeding tree using this algorithm will enqueue root node <code class="inlineCode">4</code>, dequeue it, and visit the node. Next, nodes <code class="inlineCode">2</code> and <code class="inlineCode">8</code> are enqueued, as they are the left and right nodes at the next level. Node <code class="inlineCode">2</code> is dequeued so that it can be visited. Next, its left and right nodes, nodes <code class="inlineCode">1</code> and <code class="inlineCode">3</code>, are enqueued. At this point, the node at the front of the queue is node <code class="inlineCode">8</code>. We dequeue and visit node <code class="inlineCode">8</code>, after which we enqueue its left and right nodes. This process continues until the queue is empty.</p>
    <p class="normal">The Python<a id="_idIndexMarker536"/> implementation of breadth-first traversal is as follows. We<a id="_idIndexMarker537"/> enqueue the root node and keep a list of the visited nodes in the <code class="inlineCode">list_of_nodes</code> list. The <code class="inlineCode">dequeue</code> class is used to maintain a queue:</p>
    <pre class="programlisting code"><code class="hljs-code">from collections import deque
class Node:
    def __init__(self, data):
        self.data = data
        self.right_child = None
        self.left_child = None
        
n1 = Node("root node")
n2 = Node("left child node")
n3 = Node("right child node")
n4 = Node("left grandchild node")
n1.left_child = n2
n1.right_child = n3
n2.left_child = n4
 
def level_order_traversal(root_node):
    list_of_nodes = []
    traversal_queue = deque([root_node])
    while len(traversal_queue) &gt; 0:
        node = traversal_queue.popleft()
        list_of_nodes.append(node.data)
        if node.left_child:
            traversal_queue.append(node.left_child)
            if node.right_child:
                traversal_queue.append(node.right_child)
    return list_of_nodes
print(level_order_traversal(n1))
</code></pre>
    <p class="normal">If the number of elements in <code class="inlineCode">traversal_queue</code> is greater than zero, the body of the loop is executed. The node at the front of the queue is popped off and added to the <code class="inlineCode">list_of_nodes</code> list. The first <code class="inlineCode">if</code> statement will <code class="inlineCode">enqueue</code> the left child node if the <code class="inlineCode">node</code> provided with a left <a id="_idIndexMarker538"/>node exists. The second <code class="inlineCode">if</code> statement does the same for <a id="_idIndexMarker539"/>the right child node. Further, the <code class="inlineCode">list_of_nodes</code> list is returned in the last statement.</p>
    <p class="normal">The output of the above code is as follows:</p>
    <pre class="programlisting con"><code class="hljs-con">['root node', 'left child node', 'right child node', 'left grandchild node']
</code></pre>
    <p class="normal">We have discussed different tree traversal algorithms; we can use any of these algorithms depending upon the application. In-order traversal is very useful when we need sorted contents from a tree. This also applies if we need items in descending order, which we can do by reversing the order, such as right subtree, root, and then left subtree. This is known as reverse in-order traversal. And, if we need to inspect the root before any leaves, we use pre-order traversal. Likewise, if we need to inspect the leaf nodes before the root nodes.</p>
    <p class="normal">The following are some important <a id="_idIndexMarker540"/>applications of binary trees:</p>
    <ol class="numberedList" style="list-style-type: decimal;">
      <li class="numberedList" value="1">Binary trees as expression trees are used in compilers</li>
      <li class="numberedList">It is also used in Huffman coding in data compression</li>
      <li class="numberedList">Binary search trees are used for efficient searching, insertion, and deletion of a list of items</li>
      <li class="numberedList"><strong class="keyWord">Priority Queue</strong> (<strong class="keyWord">PQ</strong>), which<a id="_idIndexMarker541"/> is used for finding and deleting minimum or maximum items in a collection of elements in logarithm time in the <a id="_idIndexMarker542"/>worst case</li>
    </ol>
    <p class="normal">Next, let us discuss expression trees.</p>
    <h2 id="_idParaDest-142" class="heading-2">Expression trees</h2>
    <p class="normal">An expression tree<a id="_idIndexMarker543"/> is a special kind of binary tree that can be used to represent <a id="_idIndexMarker544"/>arithmetic expressions. An arithmetic<a id="_idIndexMarker545"/> expression is represented by a combination of operators and operands, where the operators can be unary or binary. Here, the operator shows which operation we want to perform, and the operator tells us what data items we want to apply those operations to. If the operator is applied to one operand, then it is called a unary operator, and if it is applied to two operands, it is called a binary operator.</p>
    <p class="normal">An arithmetic expression<a id="_idIndexMarker546"/> can also be represented using a binary tree, which is also known as an expression tree. The <strong class="keyWord">infix</strong> notation<a id="_idIndexMarker547"/> is a commonly used notation to express arithmetic expressions where the operators are placed in between the operands. It is a commonly used method of representing an arithmetic expression. In an expression tree, all the leaf nodes contain operands and non-leaf nodes contain the operators. It is also worth noting that an expression tree will have one of its subtrees (right or left) empty in the case of a unary operator.</p>
    <p class="normal">The<a id="_idIndexMarker548"/> arithmetic expression is shown using three notations: <strong class="keyWord">infix</strong>, <strong class="keyWord">postfix</strong>, or <strong class="keyWord">prefix</strong>. The<a id="_idIndexMarker549"/> in-order<a id="_idIndexMarker550"/> traversal of an expression tree produces the infix notation. For example, the <a id="_idIndexMarker551"/>expression tree for <code class="inlineCode">3 + 4</code> would look as shown in <em class="italic">Figure 6.14</em>:</p>
    <figure class="mediaobject"><img src="img/B17217_06_14.png" alt=""/></figure>
    <p class="packt_figref">Figure 6.14: An expression tree for the expression 3 + 4</p>
    <p class="normal">In this example, the operator is inserted (infixed) between the operands, as <code class="inlineCode">3 + 4</code>. When necessary, parentheses can be used to build a more complex expression. For example, for <code class="inlineCode">(4 + 5) * (5 - 3)</code>, we would get the following:</p>
    <figure class="mediaobject"><img src="img/B17217_06_15.png" alt=""/></figure>
    <p class="packt_figref">Figure 6.15: An expression tree for the expression (4 + 5) * (5-3)</p>
    <p class="normal">Prefix notation<a id="_idIndexMarker552"/> is commonly referred to as <em class="italic">Polish</em> notation. In this notation, the operator comes before its <a id="_idIndexMarker553"/>operands. For example, the arithmetic expression to add two numbers, 3 and 4, would be shown as <code class="inlineCode">+ 3 4</code>. Let’s consider another example, <code class="inlineCode">(3 + 4) * 5</code>. This can also be represented as <code class="inlineCode">* (+ 3 4) 5</code> in prefix notation. The pre-order traversal of an expression tree results in the prefix notation of the arithmetic expression. For example, consider the expression tree shown in <em class="italic">Figure 6.16</em>:</p>
    <figure class="mediaobject"><img src="img/B17217_06_16.png" alt=""/></figure>
    <p class="packt_figref">Figure 6.16: An example expression tree to understand pre-order traversal</p>
    <p class="normal">The pre-order traversal of the expression tree shown in <em class="italic">Figure 6.16</em> will give the expression in prefix notation as <code class="inlineCode">+- 8 3 3</code>.</p>
    <p class="normal">Postfix, or <strong class="keyWord">reverse Polish notation</strong> (<strong class="keyWord">RPN</strong>), places <a id="_idIndexMarker554"/>the operator after its <a id="_idIndexMarker555"/>operands, such as <code class="inlineCode">3 4 +</code>. The post-order traversal of the expression<a id="_idIndexMarker556"/> tree shown in <em class="italic">Figure 6.17</em> gives the postfix notation of the arithmetic expression.</p>
    <figure class="mediaobject"><img src="img/B17217_06_17.png" alt=""/></figure>
    <p class="packt_figref">Figure 6.17: An example expression tree to understand post-order traversal</p>
    <p class="normal">The postfix <a id="_idIndexMarker557"/>notation for the preceding expression tree is <code class="inlineCode">8 3 -3 +</code>. We have<a id="_idIndexMarker558"/> now discussed expression trees. It is easy to evaluate an expression tree for the given arithmetic expression using the reverse Polish notation since it provides faster calculations.</p>
    <h3 id="_idParaDest-143" class="heading-3">Parsing a reverse Polish expression</h3>
    <p class="normal">To create an <a id="_idIndexMarker559"/>expression tree from the postfix notation, a <a id="_idIndexMarker560"/>stack is used. In this, we process one symbol at a time; if the symbol is an operand, then its references are pushed in to the stack, and if the symbol is an operator, then we pop two pointers from the stack and form a new subtree, whose root is the operator. The first reference popped from the stack is the right child of the subtree, and the second reference becomes the left child of the subtree. Further, a reference to this new subtree is pushed into the stack. In this manner, all the symbols of the postfix notation are processed to create the expression tree.</p>
    <p class="normal">Let’s take an example of <code class="inlineCode">4 5 + 5 3 - *</code>.</p>
    <p class="normal">Firstly, we push symbols <code class="inlineCode">4</code> and <code class="inlineCode">5</code> onto the stack, and then we process the next symbol <code class="inlineCode">+</code> as shown in <em class="italic">Figure 6.18</em>:</p>
    <figure class="mediaobject"><img src="img/B17217_06_18.png" alt=""/></figure>
    <p class="packt_figref">Figure 6.18: Operands 4 and 5 are pushed onto the stack</p>
    <p class="normal">When the new <a id="_idIndexMarker561"/>symbol <code class="inlineCode">+</code> is read, it is made into a root node of a new<a id="_idIndexMarker562"/> subtree, and then two references are popped from the stack, and the topmost reference is added as the right of the root node, and the next popped reference is added as the left child of the subtree, as shown in <em class="italic">Figure 6.19</em>:</p>
    <figure class="mediaobject"><img src="img/B17217_06_19.png" alt=""/></figure>
    <p class="packt_figref">Figure 6.19: Operator + is processed in creating an expression tree</p>
    <p class="normal">The next<a id="_idIndexMarker563"/> symbols are <code class="inlineCode">5</code> and <code class="inlineCode">3</code>, and they are pushed into the stack. Next, when a new symbol is an operator (<code class="inlineCode">-</code>), it is created as the root of the new subtree, and two top references are popped and added to the right and left child of this <a id="_idIndexMarker564"/>root respectively, as shown in <em class="italic">Figure 6.20</em>. Then, the reference to this subtree is pushed to the stack:</p>
    <figure class="mediaobject"><img src="img/B17217_06_20.png" alt=""/></figure>
    <p class="packt_figref">Figure 6.20: Operator (-) is processed in creating an expression tree</p>
    <p class="normal">The next <a id="_idIndexMarker565"/>symbol is the operator <code class="inlineCode">*</code>; as we have done so far, this will be created as the root, and then two references will be popped from the stack, as shown in <em class="italic">Figure 6.21</em>. The final tree is then shown in <em class="italic">Figure 6.21</em>:</p>
    <figure class="mediaobject"><img src="img/B17217_06_21.png" alt=""/></figure>
    <p class="packt_figref">Figure 6.21: Operator (*) is processed in creating an expression tree</p>
    <p class="normal">To learn<a id="_idIndexMarker566"/> how to implement this algorithm in Python, we will look<a id="_idIndexMarker567"/> at building a tree for an expression written in postfix notation. For this, we need a tree node implementation; it can be defined as follows:</p>
    <pre class="programlisting code"><code class="hljs-code">class TreeNode:
    def __init__(self, data=None):
        self.data = data
        self.right = None
        self.left = None
</code></pre>
    <p class="normal">The following is the code for the implementation of the stack class that we will be using:</p>
    <pre class="programlisting code"><code class="hljs-code">class Stack:
    def __init__(self):
        self.elements = []
        
    def push(self, item):
        self.elements.append(item)
    
    def pop(self):
        return self.elements.pop()
</code></pre>
    <p class="normal">In order to build the tree, we are going to enlist the items with the help of a stack. Let’s take an example of an arithmetic expression and set up our stack:</p>
    <pre class="programlisting code"><code class="hljs-code">expr = "4 5 + 5 3 - *".split()
stack = Stack()
</code></pre>
    <p class="normal">In the first statement, the <code class="inlineCode">split()</code> method splits on whitespace by default. The <code class="inlineCode">expr</code> is a list with the values <code class="inlineCode">4</code>, <code class="inlineCode">5</code>, <code class="inlineCode">+</code>, <code class="inlineCode">5</code>, <code class="inlineCode">3</code>, <code class="inlineCode">-</code>, and <code class="inlineCode">*</code>.</p>
    <p class="normal">Each element of the <code class="inlineCode">expr</code> list is going to be either an operator or an operand. If we get an operand, then we embed it in a tree node and push it onto the stack. If we get an operator, we embed the operator into a tree node and pop its two operands into the node’s right and left children. Here, we have to take care to ensure that the first <code class="inlineCode">pop</code> reference goes into the right child.</p>
    <p class="normal">In continuation of the previous code snippet, the below code is a loop to build the tree:</p>
    <pre class="programlisting code"><code class="hljs-code">for term in expr:
    if term in "+-*/":
        node = TreeNode(term)
        node.right = stack.pop()
        node.left = stack.pop()
    else:
        node = TreeNode(int(term))
    stack.push(node)
</code></pre>
    <p class="normal">Notice that <a id="_idIndexMarker568"/>we perform a conversion from <code class="inlineCode">string</code> to <code class="inlineCode">int</code> in the case of an<a id="_idIndexMarker569"/> operand. You could use <code class="inlineCode">float()</code> instead, if you wish to support floating-point operands.</p>
    <p class="normal">At the end of this operation, we should have one single element in the stack, and that holds the full tree. </p>
    <p class="normal">If we want to evaluate the expression, we can use the following function:</p>
    <pre class="programlisting code"><code class="hljs-code">def calc(node):
    if node.data == "+":
        return calc(node.left) + calc(node.right)
    elif node.data == "-":
        return calc(node.left) - calc(node.right)
    elif node.data == "*":
        return calc(node.left) * calc(node.right)
    elif node.data == "/":
        return calc(node.left) / calc(node.right)
    else:
        return node.data
</code></pre>
    <p class="normal">In the preceding code, we pass a node to the function. If the node contains an operand, then we simply return that value. If we get an operator, then we perform the operation that the operator represents on the node’s two children. However, since one or more of the children could also contain either operators or operands, we call the <code class="inlineCode">calc()</code> function recursively on the two child nodes (bearing in mind that all the children of every node are also nodes).</p>
    <p class="normal">Now, we just need to pop the root node off the stack and pass it onto the <code class="inlineCode">calc()</code> function. Then, we should have the result of the calculation:</p>
    <pre class="programlisting code"><code class="hljs-code">root = stack.pop()
result = calc(root)
print(result)
</code></pre>
    <p class="normal">Running this program should yield the result <code class="inlineCode">18</code>, which is the result of <code class="inlineCode">(4 + 5) * (5 - 3)</code>.</p>
    <p class="normal">Expression <a id="_idIndexMarker570"/>trees are very useful in representing and evaluating complex <a id="_idIndexMarker571"/>expressions easily. It is also useful to evaluate the postfix, prefix, and infix expression. It can be used to find out the associativity of the operators in the given expression.</p>
    <p class="normal">In the next section, we will discuss the binary search tree, which is a special kind of binary tree.</p>
    <h1 id="_idParaDest-144" class="heading-1">Binary search trees</h1>
    <p class="normal">A <strong class="keyWord">binary search tree</strong> (<strong class="keyWord">BST</strong>) is a<a id="_idIndexMarker572"/> special kind of binary tree. It is one of the most important<a id="_idIndexMarker573"/> and commonly used data structures in computer science applications. A binary search tree is a tree that is structurally a binary tree, and stores data in its nodes very efficiently. It provides very fast search, insertion, and deletion operations.</p>
    <p class="normal">A binary tree is called a binary search tree if the value at any node in the tree is greater than the values in all the nodes of its left subtree, and less than (or equal to) the values of all the nodes of the right subtree. For example, if <code class="inlineCode">K1</code>, <code class="inlineCode">K2</code>, and <code class="inlineCode">K3</code> are key values in a tree of three nodes (as shown in <em class="italic">Figure 6.22</em>), then it should satisfy the following conditions:</p>
    <ul>
      <li class="bulletList">The key values <em class="italic">K2&lt;=K1</em></li>
      <li class="bulletList">The key values <em class="italic">K3&gt;K1</em></li>
    </ul>
    <p class="normal">The following figure depicts the above condition of the binary search tree:</p>
    <figure class="mediaobject"><img src="img/B17217_06_22.png" alt=""/></figure>
    <p class="packt_figref">Figure 6.22: An example of a binary search tree</p>
    <p class="normal">Let’s consider <a id="_idIndexMarker574"/>another example so that we have a better understanding of <a id="_idIndexMarker575"/>binary search trees. Consider the binary search tree shown in <em class="italic">Figure 6.23</em>:</p>
    <figure class="mediaobject"><img src="img/B17217_06_23.png" alt=""/></figure>
    <p class="packt_figref">Figure 6.23: Binary search tree of six nodes</p>
    <p class="normal">In this tree, all the nodes in the left subtree are less than (or equal to) the value of the parent node. All the nodes in the right subtree of this node are also greater than that of the parent node. </p>
    <p class="normal">To see if the above example tree fulfills the properties of a binary search tree, we see that all the nodes in the left subtree of the root node have a value less than <code class="inlineCode">5</code>. Likewise, all the nodes in the right subtree have a value that is greater than <code class="inlineCode">5</code>. This property applies to all the nodes in the tree with no exceptions. For example, if we take another node with the value <code class="inlineCode">3</code>, we can see that the values for all the left subtree nodes are less than the value <code class="inlineCode">3</code> and the values for all the right subtree nodes are greater than <code class="inlineCode">3</code>.</p>
    <p class="normal">Considering another example of a binary tree. Let’s check to see if it is a binary search tree. Despite the fact that the following diagram, <em class="italic">Figure 6.24</em>, looks similar to the previous diagram, it does not qualify as a binary search tree, as node <code class="inlineCode">7</code> is greater than the root node <code class="inlineCode">5</code>; even though it is located in the left subtree of the root node. Node <code class="inlineCode">4</code> is to the right subtree of its parent node <code class="inlineCode">7</code>, which is also violating a rule of binary search trees. Thus, the following figure, <em class="italic">Figure 6.24</em>, is not a binary search tree:</p>
    <figure class="mediaobject"><img src="img/B17217_06_24.png" alt=""/></figure>
    <p class="packt_figref">Figure 6.24: An example of a binary tree that is not a binary search tree</p>
    <p class="normal">Let’s begin the <a id="_idIndexMarker576"/>implementation of a binary search tree in Python. Since we <a id="_idIndexMarker577"/>need to keep track of the root node of the tree, we start by creating a <code class="inlineCode">Tree</code> class that holds a reference to the root node:</p>
    <pre class="programlisting code"><code class="hljs-code">class Tree:
    def __init__(self):
        self.root_node = None
</code></pre>
    <p class="normal">That’s all it takes to maintain the state of a tree. Now, let’s examine the main operations used within the binary seach tree.</p>
    <h2 id="_idParaDest-145" class="heading-2">Binary search tree operations</h2>
    <p class="normal">The operations<a id="_idIndexMarker578"/> that can be performed on a binary search tree are <code class="inlineCode">insert</code>, <code class="inlineCode">delete</code>, <code class="inlineCode">finding min</code>, <code class="inlineCode">finding max</code>, and <code class="inlineCode">searching</code>. We discuss them in detail one by one in the following sections.</p>
    <h3 id="_idParaDest-146" class="heading-3">Inserting nodes</h3>
    <p class="normal">One of the most important <a id="_idIndexMarker579"/>operations to implement on a binary search tree is to insert data items in the tree. In order to insert a new element into a binary search tree, we have to ensure that the properties of the binary search tree are not violated after adding the new element.</p>
    <p class="normal">In order to insert a new element, we start by comparing the value of the new node with the root node: if the value is less than the root value, then the new element will be inserted into the left subtree; otherwise, it will be inserted into the right subtree. In this manner, we go to the end of the tree to insert the new element.</p>
    <p class="normal">Let’s create a binary search tree by inserting data items <code class="inlineCode">5</code>, <code class="inlineCode">3</code>, <code class="inlineCode">7</code>, and <code class="inlineCode">1</code> in the tree. Consider the following:</p>
    <ol class="numberedList" style="list-style-type: decimal;">
      <li class="numberedList" value="1"><strong class="keyWord">Insert 5</strong>: We start with the first data item, <code class="inlineCode">5</code>. To do this, we will create a node with its data attribute set to <code class="inlineCode">5</code>, since it is the first node.</li>
      <li class="numberedList"><strong class="keyWord">Insert 3</strong>: Now, we want to add the second node with a value of <code class="inlineCode">3</code> so that the data value of <code class="inlineCode">3</code> is compared with the existing node value, <code class="inlineCode">5</code>, of the root node. Since the node value <code class="inlineCode">3</code> is less than <code class="inlineCode">5</code>, it will be placed in the left subtree of node <code class="inlineCode">5</code>. The binary search tree will look as shown in <em class="italic">Figure 6.25</em>: <figure class="mediaobject"><img src="img/B17217_06_25.png" alt=""/></figure>
        <p class="packt_figref">Figure 6.25: Step 2 of the insertion operation in an example binary search tree</p>
        <p class="normal">Here, the tree satisfies the binary search tree rule, where all the nodes in the left subtree are less than the parent.</p>
      </li>
    </ol>
    <ol class="numberedList" style="list-style-type: decimal;">
      <li class="numberedList" value="3"><strong class="keyWord">Insert 7</strong>: To add another node with a value of <code class="inlineCode">7</code> to the tree, we start from the root node with value <code class="inlineCode">5</code> and make a comparison, as shown in <em class="italic">Figure 6.26</em>. Since <code class="inlineCode">7</code> is greater than <code class="inlineCode">5</code>, the node with a value of <code class="inlineCode">7</code> is placed to the right of this root:</li>
    </ol>
    <figure class="mediaobject"><img src="img/B17217_06_26.png" alt=""/></figure>
    <p class="packt_figref">Figure 6.26: Step 3 of the insertion operation in an example binary search tree</p>
    <ol class="numberedList" style="list-style-type: decimal;">
      <li class="numberedList" value="4"><strong class="keyWord">Insert 1</strong>: Next, we<a id="_idIndexMarker580"/> add another node with the value <code class="inlineCode">1</code>. Starting from the root of the tree, we make a comparison between <code class="inlineCode">1</code> and <code class="inlineCode">5</code>, as shown in <em class="italic">Figure 6.27</em>:</li>
    </ol>
    <figure class="mediaobject"><img src="img/B17217_06_27.png" alt=""/></figure>
    <p class="packt_figref">Figure 6.27: Step 4 of the insertion operation in an example binary search tree</p>
    <p class="normal">This comparison shows that <code class="inlineCode">1</code> is less than <code class="inlineCode">5</code>, so we go to the left subtree of <code class="inlineCode">5</code>, which has a node with a value of <code class="inlineCode">3</code>, as shown in <em class="italic">Figure 6.28</em>:</p>
    <figure class="mediaobject"><img src="img/B17217_06_28.png" alt=""/></figure>
    <p class="packt_figref">Figure 6.28: Comparison of node 1 and node 3 in an example binary search tree</p>
    <p class="normal">When we compare <code class="inlineCode">1</code> against <code class="inlineCode">3</code>, <code class="inlineCode">1</code> is less than <code class="inlineCode">3</code>, so we move a level below node <code class="inlineCode">3</code> and to its left, as shown in <em class="italic">Figure 6.28</em>. However, there is no node there. Therefore, we create a node with a value of <code class="inlineCode">1</code> and associate it with the left pointer of node <code class="inlineCode">3</code> to obtain the final tree. Here, we have the final binary search tree of <code class="inlineCode">4</code> nodes, as shown in <em class="italic">Figure 6.29</em>:</p>
    <figure class="mediaobject"><img src="img/B17217_06_29.png" alt=""/></figure>
    <p class="packt_figref">Figure 6.29: Final step of the insertion operation in an example binary search tree</p>
    <p class="normal">We can see that this example contains only integers or numbers. So, if we need to store string data in a binary search tree, the strings would be compared alphabetically. </p>
    <p class="normal">If we wanted to store any custom data types inside a binary search tree, we would have to make sure that the binary search tree class supports ordering.</p>
    <p class="normal">The Python<a id="_idIndexMarker581"/> implementation of the <code class="inlineCode">insert</code> method to add the nodes in the binary search tree is given as follows:</p>
    <pre class="programlisting code"><code class="hljs-code">class Node:
    def __init__(self, data):
        self.data = data
        self.right_child = None
        self.left_child = None
class Tree:
    def __init__(self):
        self.root_node = None
    def insert(self, data):
        node = Node(data)
        if self.root_node is None:
            self.root_node = node
            return self.root_node
        else:
            current = self.root_node
            parent = None
            while True:
                parent = current
                if node.data &lt; parent.data:
                    current = current.left_child
                    if current is None:
                        parent.left_child = node
                        return self.root_node
                else:
                    current = current.right_child
                    if current is None:
                        parent.right_child = node
                        return self.root_node
</code></pre>
    <p class="normal">In the above code, we first declare the <code class="inlineCode">Node</code> class with the <code class="inlineCode">Tree</code> class. All the operations that can be applied to the tree are defined in the <code class="inlineCode">Tree</code> class. Let’s understand the steps of the <code class="inlineCode">insert</code> method. We begin with a function declaration:</p>
    <pre class="programlisting code"><code class="hljs-code">    def insert(self, data):
</code></pre>
    <p class="normal">Next, we encapsulate the data in a node using the <code class="inlineCode">Node</code> class. We check whether we have a root node or not. If we don’t have a root node in the tree, the new node becomes the root node and then root node is returned:</p>
    <pre class="programlisting code"><code class="hljs-code">        node = Node(data)
        if self.root_node is None:
            self.root_node = node
            return self.root_node
        else:
</code></pre>
    <p class="normal">Further, in <a id="_idIndexMarker582"/>order to insert a new element, we have to traverse the tree and reach the correct position where we can insert the new element in a way that the properties of the binary search tree are not violated. For this, we keep track of the current node while traversing the tree as well as its parent. The <code class="inlineCode">current</code> variable is always used to track where a new node will be inserted:</p>
    <pre class="programlisting code"><code class="hljs-code">        current = self.root_node
        parent = None
        while True:
            parent = current
</code></pre>
    <p class="normal">Here, we must perform a comparison. If the data held in the new node is less than the data held in the current node, then we check whether the current node has a left child node. If it doesn’t, this is where we insert the new node. Otherwise, we keep traversing:</p>
    <pre class="programlisting code"><code class="hljs-code">            if node.data &lt; parent.data:
                current = current.left_child
                if current is None:
                    parent.left_child = node
                    return self.root_node
</code></pre>
    <p class="normal">After this, we need to take care of the greater than (or equal to) case. If the current node doesn’t have a right child node, then the new node is inserted as the right child node. Otherwise, we move down and continue looking for an insertion point:</p>
    <pre class="programlisting code"><code class="hljs-code">            else:
                current = current.right_child
                if current is None:
                    parent.right_child = node
                    return self.root_node
</code></pre>
    <p class="normal">Now, in order to <a id="_idIndexMarker583"/>see what we have inserted in the binary search tree, we can use any of the existing tree traversal algorithms. Let’s implement the in-order traversal, which should be defined in the <code class="inlineCode">Tree</code> class. The code is as follows:</p>
    <pre class="programlisting code"><code class="hljs-code">    def inorder(self, root_node):
        current = root_node
        if current is None:
            return
        self.inorder(current.left_child)
        print(current.data)
        self.inorder(current.right_child)
</code></pre>
    <p class="normal">Now, let us take an example to insert a few elements (e.g. elements <code class="inlineCode">5</code>, <code class="inlineCode">2</code>, <code class="inlineCode">7</code>, <code class="inlineCode">9</code>, and <code class="inlineCode">1</code>) in a binary search tree, as shown in <em class="italic">Figure 6.24</em>, and then we can use the in-order traversal algorithm to see what we have inserted in the tree:</p>
    <pre class="programlisting code"><code class="hljs-code">tree = Tree()
r = tree.insert(5)
r = tree.insert(2)
r = tree.insert(7)
r = tree.insert(9)
r = tree.insert(1)
 
tree.inorder(r)
</code></pre>
    <p class="normal">The output of the above code is as follows:</p>
    <pre class="programlisting con"><code class="hljs-con">1
2
5
7
9
</code></pre>
    <p class="normal">Insertion of a <a id="_idIndexMarker584"/>node in a binary search tree takes <code class="inlineCode">O(h)</code>, where <code class="inlineCode">h</code> is the height of the tree.</p>
    <h3 id="_idParaDest-147" class="heading-3">Searching the tree</h3>
    <p class="normal">A binary search tree is a <a id="_idIndexMarker585"/>tree data structure in which all the nodes in the left subtree of a node have lower key values and the right subtree has greater key values. Thus, searching for an element with a given key value is quite easy. Let’s consider an example binary search tree that has nodes <code class="inlineCode">1</code>, <code class="inlineCode">2</code>, <code class="inlineCode">3</code>, <code class="inlineCode">4</code>, <code class="inlineCode">8</code>, <code class="inlineCode">5</code>, and <code class="inlineCode">10</code>, as shown in <em class="italic">Figure 6.30</em>:</p>
    <figure class="mediaobject"><img src="img/B17217_06_30.png" alt=""/></figure>
    <p class="packt_figref">Figure 6.30: An example binary search tree with seven nodes</p>
    <p class="normal">In the preceding tree shown in <em class="italic">Figure 6.30</em>, if we wish to search for a node with a value of <code class="inlineCode">5</code>, for example, then we start from the root node and compare the root with our desired value. As node <code class="inlineCode">5</code> is a greater value than the root node’s value of <code class="inlineCode">4</code>, we move to the right subtree. In the right subtree, we have node <code class="inlineCode">8</code> as the root node, so we compare node <code class="inlineCode">5</code> with node <code class="inlineCode">8</code>. As the node to be searched has a smaller value than node <code class="inlineCode">8</code>, we move it to the left subtree. When we move to the left subtree, we compare the left subtree node <code class="inlineCode">5</code> with the required node value of <code class="inlineCode">5</code>. This is a match, so we return <code class="inlineCode">"item found"</code>.</p>
    <p class="normal">Here is the <a id="_idIndexMarker586"/>implementation of the searching method in a binary search tree, which is being defined in the <code class="inlineCode">Tree</code> class:</p>
    <pre class="programlisting code"><code class="hljs-code">    def search(self, data):
        current = self.root_node
        while True:
            if current is None:
                print("Item not found")
                return None
            elif current.data is data:
                print("Item found", data)
                return data
            elif current.data &gt; data:
                current = current.left_child
            else:
                current = current.right_child
</code></pre>
    <p class="normal">In the preceding code, we return the data if it was found, or <code class="inlineCode">None</code> if the data wasn’t found. We start searching from the root node. Next, if the data item to be searched for doesn’t exist in the tree, we return <code class="inlineCode">None</code>. If we find the data, it is returned.</p>
    <p class="normal">If the data that we are searching for is less than that of the current node, we go down the tree to the left. Furthermore, in the <code class="inlineCode">else</code> part of the code, we check if the data we are looking for is greater than the data held in the current node, which means that we go down the tree to the right. </p>
    <p class="normal">Finally, the below code can be used to create an example binary search tree with some values between 1 and 10. Then, we search for a data item with the value <code class="inlineCode">9</code>, and also all the numbers in that range. The ones that exist in the tree get printed:</p>
    <pre class="programlisting code"><code class="hljs-code">tree = Tree()
tree.insert(5)
tree.insert(2)
tree.insert(7)
tree.insert(9)
tree.insert(1)
tree.search(9)
</code></pre>
    <p class="normal">The output of the above code is as follows:</p>
    <pre class="programlisting con"><code class="hljs-con">Item found 9
</code></pre>
    <p class="normal">In the above<a id="_idIndexMarker587"/> code, we see the items that were present in the tree have been correctly found; the rest of the items could not be found in the range 1 to 10. In the next section, we discuss the deletion of a node in binary search tree.</p>
    <h3 id="_idParaDest-148" class="heading-3">Deleting nodes</h3>
    <p class="normal">Another important operation on a<a id="_idIndexMarker588"/> binary search tree is the deletion or removal of nodes. There are three possible scenarios that we need to take care of during this process. The node that we want to remove might have the following:</p>
    <ul>
      <li class="bulletList"><strong class="keyWord">No children</strong>: If there is no leaf node, directly remove the node</li>
      <li class="bulletList"><strong class="keyWord">One child</strong>: In this case, we swap the value of that node with its child, and then delete the node</li>
      <li class="bulletList"><strong class="keyWord">Two children</strong>: In this case, we first find the in-order successor or predecessor, swap their values, and then delete that node</li>
    </ul>
    <p class="normal">The first scenario is the easiest to handle. If the node about to be removed has no children, we can simply remove it from its parent. In <em class="italic">Figure 6.31</em>, suppose we want to delete node <code class="inlineCode">A</code>, which has no children. In this case, we can simply delete it from its parent (node <code class="inlineCode">Z</code>):</p>
    <figure class="mediaobject"><img src="img/B17217_06_31.png" alt=""/></figure>
    <p class="packt_figref">Figure 6.31: Deletion operation when deleting a node with no children</p>
    <p class="normal">In the second scenario, when the node we want to remove has one child, the parent of that node is made to point to the child of that particular node. Let’s take a look at the following diagram, where we want to delete node <code class="inlineCode">6</code>, which has one child, node <code class="inlineCode">5</code>, as shown in <em class="italic">Figure 6.32</em>:</p>
    <figure class="mediaobject"><img src="img/B17217_06_32.png" alt=""/></figure>
    <p class="packt_figref">Figure 6.32: Deletion operation when deleting a node with one child</p>
    <p class="normal">In order to <a id="_idIndexMarker589"/>delete node <code class="inlineCode">6</code>, which has node <code class="inlineCode">5</code> as its only child, we point the left pointer of node <code class="inlineCode">9</code> to node <code class="inlineCode">5</code>. Here, we need to ensure that the child and parent relationship follows the properties of a binary search tree.</p>
    <p class="normal">In the third scenario, when the node we want to delete has two children, in order to delete it, we first find a successor node, then move the content of the successor node into the node to be deleted. The successor node is the node that has the minimum value in the right subtree of the node to be deleted; it will be the first element when we apply the in-order traversal on the right subtree of the node to be deleted.</p>
    <p class="normal">Let’s understand it with the example tree shown in <em class="italic">Figure 6.33</em>, where we want to delete node <code class="inlineCode">9</code>, which has two children:</p>
    <figure class="mediaobject"><img src="img/B17217_06_33.png" alt=""/></figure>
    <p class="packt_figref">Figure 6.33: Deletion operation when deleting a node with two children</p>
    <p class="normal">In the example tree shown in <em class="italic">Figure 6.33</em>, we find the smallest element in the right subtree of the node (i.e. the first element in the in-order traversal in the right subtree) which is node <code class="inlineCode">12</code>. After that, we replace the value of node <code class="inlineCode">9</code> with the value <code class="inlineCode">12</code> and remove node <code class="inlineCode">12</code>. Node <code class="inlineCode">12</code> has no children, so we apply the rule for removing nodes without children accordingly.</p>
    <p class="normal">To<a id="_idIndexMarker590"/> implement the above algorithm using Python, we need to write a helper method to get the node that we want to delete along with the reference to its parent node. We have to write a separate method because we do not have any reference to the parent in the <code class="inlineCode">Node</code> class. This helper method <code class="inlineCode">get_node_with_parent</code> is similar to the <code class="inlineCode">search</code> method, which finds the node to be deleted, and returns that node with its parent node:</p>
    <pre class="programlisting code"><code class="hljs-code">    def get_node_with_parent(self, data):
        parent = None
        current = self.root_node
        if current is None:
            return (parent, None)
        while True:
            if current.data == data:
                return (parent, current)
            elif current.data &gt; data:
                parent = current
                current = current.left_child
            else:
                parent = current
                current = current.right_child
        return (parent, current)
</code></pre>
    <p class="normal">The only difference is that before we update the current variable inside the loop, we store its parent with <code class="inlineCode">parent = current</code>. The method to do the actual removal of a node begins with this search:</p>
    <pre class="programlisting code"><code class="hljs-code">    def remove(self, data):
        parent, node = self.get_node_with_parent(data)
        if parent is None and node is None:
            return False
        # Get children count
        children_count = 0
        if node.left_child and node.right_child:
            children_count = 2
        elif (node.left_child is None) and (node.right_child is None):
            children_count = 0
        else:
            children_count = 1
</code></pre>
    <p class="normal">We pass <a id="_idIndexMarker591"/>the parent and the found nodes to <code class="inlineCode">parent</code> and <code class="inlineCode">node</code>, respectively, with the <code class="inlineCode">parent</code>, <code class="inlineCode">node = self.get_node_with_parent(data)</code> line. It is important to know the number of children that the node has that we want to delete, and we do so in the <code class="inlineCode">if</code> statement.</p>
    <p class="normal">Once we know the number of children a node has that we want to delete, we need to handle various conditions in which a node can be deleted. The first part of the <code class="inlineCode">if</code> statement handles the case where the node has no children:</p>
    <pre class="programlisting code"><code class="hljs-code">        if children_count == 0:
            if parent:
                if parent.right_child is node:
                    parent.right_child = None
                else:
                    parent.left_child = None
            else:
                self.root_node = None
</code></pre>
    <p class="normal">In cases where the node to be deleted has only one child, the <code class="inlineCode">elif</code> part of the <code class="inlineCode">if</code> statement does the following:</p>
    <pre class="programlisting code"><code class="hljs-code">        elif children_count == 1:
            next_node = None
            if node.left_child:
                next_node = node.left_child
            else:
                next_node = node.right_child
            if parent:
                if parent.left_child is node:
                    parent.left_child = next_node
                else:
                    parent.right_child = next_node
            else:
                self.root_node = next_node
</code></pre>
    <p class="normal"><code class="inlineCode">next_node</code> is <a id="_idIndexMarker592"/>used to keep track of that single node, which is the child of the node that is to be deleted. We then connect <code class="inlineCode">parent.left_child</code> or <code class="inlineCode">parent.right_child</code> to <code class="inlineCode">next_node</code>.</p>
    <p class="normal">Lastly, we handle the condition where the node we want to delete has two children:</p>
    <pre class="programlisting code"><code class="hljs-code">        else:
            parent_of_leftmost_node = node
            leftmost_node = node.right_child
            while leftmost_node.left_child:
                parent_of_leftmost_node = leftmost_node
                leftmost_node = leftmost_node.left_child
            node.data = leftmost_node.data
</code></pre>
    <p class="normal">In finding the in-order successor, we move to the right node with <code class="inlineCode">leftmost_node = node.right_child</code>. As long as a left node exists, <code class="inlineCode">leftmost_node.left_child</code> will be <code class="inlineCode">True</code> and the <code class="inlineCode">while</code> loop will run. When we get to the leftmost node, it will either be a leaf node (meaning that it will have no child node) or have a right child.</p>
    <p class="normal">We update the node that’s about to be removed with the value of the in-order successor with <code class="inlineCode">node.data = leftmost_node.data</code>:</p>
    <pre class="programlisting code"><code class="hljs-code">            if parent_of_leftmost_node.left_child == leftmost_node:
                parent_of_leftmost_node.left_child = leftmost_node.right_child
            else:
                parent_of_leftmost_node.right_child = leftmost_node.right_child
</code></pre>
    <p class="normal">The preceding statement allows us to properly attach the parent of the leftmost node with any child node. Observe how the right-hand side of the equals sign stays unchanged. This is because the in-order successor can only have a right child as its only child.</p>
    <p class="normal">The following <a id="_idIndexMarker593"/>code demonstrates how to use the remove method in the <code class="inlineCode">Tree</code> class:</p>
    <pre class="programlisting code"><code class="hljs-code">tree = Tree()
tree.insert(5)
tree.insert(2)
tree.insert(7)
tree.insert(9)
tree.insert(1)
tree.search(9)
tree.remove(9)
tree.search(9)
</code></pre>
    <p class="normal">The output of the above code is:</p>
    <pre class="programlisting con"><code class="hljs-con">Item found 9
Item not found
</code></pre>
    <p class="normal">In the above<a id="_idIndexMarker594"/> code, when we search for item <code class="inlineCode">9</code>, it is available in the tree, and after the remove method, item <code class="inlineCode">9</code> is not present in the tree. In the worst-case scenario, the <code class="inlineCode">remove</code> operation takes <code class="inlineCode">O(h)</code>, where <code class="inlineCode">h</code> is the height of the tree.</p>
    <h3 id="_idParaDest-149" class="heading-3">Finding the minimum and maximum nodes</h3>
    <p class="normal">The structure <a id="_idIndexMarker595"/>of the binary search tree makes<a id="_idIndexMarker596"/> searching a node that has a maximum or a minimum value very easy. To find a node that has the smallest value in the tree, we start traversal from the root of the tree and visit the left node each time until we reach the end of the tree. Similarly, we traverse the right subtree recursively until we reach the end to find the node with the biggest value in the tree.</p>
    <p class="normal">For example, consider <em class="italic">Figure 6.34</em>, in order to search for the minimum and maximum elements.</p>
    <figure class="mediaobject"><img src="img/B17217_06_34.png" alt=""/></figure>
    <p class="packt_figref">Figure 6.34: Finding the minimum and maximum nodes in a binary search tree</p>
    <p class="normal">Here, we start by moving down the tree from root node <code class="inlineCode">6</code> to <code class="inlineCode">3</code>, and then from node <code class="inlineCode">3</code> to <code class="inlineCode">1</code> to find the node with the smallest value. Similarly, to find the maximum value node from the tree, we go down from the root along the right-hand side of the tree, so we go from node <code class="inlineCode">6</code> to node <code class="inlineCode">8</code> and then node <code class="inlineCode">8</code> to node <code class="inlineCode">10</code> to find the node with the largest value.</p>
    <p class="normal">The Python <a id="_idIndexMarker597"/>implementation of the method that <a id="_idIndexMarker598"/>returns the minimum value of any node is as follows:</p>
    <pre class="programlisting code"><code class="hljs-code">    def find_min(self):
        current = self.root_node
        while current.left_child:
            current = current.left_child
        return current.data
</code></pre>
    <p class="normal">The <code class="inlineCode">while</code> loop continues to get the left node and visits it until the last left node points to <code class="inlineCode">None</code>. It is a very simple method.</p>
    <p class="normal">Similarly, the following is the code of the method that returns the maximum node:</p>
    <pre class="programlisting code"><code class="hljs-code">    def find_max(self):
        current = self.root_node
        while current.right_child:
            current = current.right_child
        return current.data
</code></pre>
    <p class="normal">The following code demonstrates how to use the <code class="inlineCode">find_min</code> and <code class="inlineCode">find_max</code> methods in the <code class="inlineCode">Tree</code> class:</p>
    <pre class="programlisting code"><code class="hljs-code">tree = Tree()
tree.insert(5)
tree.insert(2)
tree.insert(7)
tree.insert(9)
tree.insert(1)
print(tree.find_min())
print(tree.find_max())
</code></pre>
    <p class="normal">The output of the above code is as shown below:</p>
    <pre class="programlisting con"><code class="hljs-con">1
9
</code></pre>
    <p class="normal">The output <a id="_idIndexMarker599"/>of the above code, <code class="inlineCode">1</code> and <code class="inlineCode">9</code>, are the <a id="_idIndexMarker600"/>minimum and maximum values. The minimum value in the tree is <code class="inlineCode">1</code> and the maximum is <code class="inlineCode">9</code>. The running time complexity to find the minimum or maximum value in a binary search tree is <code class="inlineCode">O(h)</code>, where <code class="inlineCode">h</code> is the height of the tree.</p>
    <h2 id="_idParaDest-150" class="heading-2">Benefits of a binary search tree</h2>
    <p class="normal">A<a id="_idIndexMarker601"/> binary search tree is, in general, a better choice compared to arrays and linked lists when we are mostly interested in accessing the elements frequently in any application. A binary search tree is fast for most operations, such as searching, insertion, and deletion, whereas arrays provide fast searching, but are comparatively slow regarding insertion and deletion operations. In a similar fashion, linked lists are efficient in performing insertion and deletion operations, but are slower when performing the search operation. The best-case running time complexity for searching an element from a binary search tree is <code class="inlineCode">O(log n)</code>, and the worst-case time complexity is <code class="inlineCode">O(n)</code>, whereas both best-case and worst-case time complexity for searching in lists is <code class="inlineCode">O(n)</code>.</p>
    <p class="normal">The following table provides a comparison of the array, linked list, and binary search tree data structures:</p>
    <table id="table001-4" class="table-container">
      <tbody>
        <tr>
          <td class="table-cell">
            <p class="normal"><strong class="keyWord">Properties</strong></p>
          </td>
          <td class="table-cell">
            <p class="normal"><strong class="keyWord">Array</strong></p>
          </td>
          <td class="table-cell">
            <p class="normal"><strong class="keyWord">Linked list</strong></p>
          </td>
          <td class="table-cell">
            <p class="normal"><strong class="keyWord">BST</strong></p>
          </td>
        </tr>
        <tr>
          <td class="table-cell">
            <p class="normal">Data structure</p>
          </td>
          <td class="table-cell">
            <p class="normal">Linear.</p>
          </td>
          <td class="table-cell">
            <p class="normal">Linear.</p>
          </td>
          <td class="table-cell">
            <p class="normal">Non-linear.</p>
          </td>
        </tr>
        <tr>
          <td class="table-cell">
            <p class="normal">Ease of use</p>
          </td>
          <td class="table-cell">
            <p class="normal">Easy to create and use. Average-case complexity for search, insert, and delete is <code class="inlineCode">O(n)</code>.</p>
          </td>
          <td class="table-cell">
            <p class="normal">Insertion and deletion are fast, especially with the doubly linked list.</p>
          </td>
          <td class="table-cell">
            <p class="normal">Access of elements, insertion, and deletion is fast with the average-case complexity of <code class="inlineCode">O(log n)</code>.</p>
          </td>
        </tr>
        <tr>
          <td class="table-cell">
            <p class="normal">Access complexity</p>
          </td>
          <td class="table-cell">
            <p class="normal">Easy to access elements. Complexity is <code class="inlineCode">O(1)</code>.</p>
          </td>
          <td class="table-cell">
            <p class="normal">Only sequential access is possible, so slow. Average- and worst-case complexity are <code class="inlineCode">O(n)</code>.</p>
          </td>
          <td class="table-cell">
            <p class="normal">Access is fast, but slow when the tree is unbalanced, with a worst-case complexity of <code class="inlineCode">O(n)</code>.</p>
          </td>
        </tr>
        <tr>
          <td class="table-cell">
            <p class="normal">Search complexity</p>
          </td>
          <td class="table-cell">
            <p class="normal">Average- and worst-case complexity are <code class="inlineCode">O(n)</code>.</p>
          </td>
          <td class="table-cell">
            <p class="normal">It is slow due to sequential searching. Average- and worst-case complexity are <code class="inlineCode">O(n)</code>.</p>
          </td>
          <td class="table-cell">
            <p class="normal">Worst-case complexity for searching is <code class="inlineCode">O(n)</code>.</p>
          </td>
        </tr>
        <tr>
          <td class="table-cell">
            <p class="normal">Insertion complexity</p>
          </td>
          <td class="table-cell">
            <p class="normal">Insertion is slow. Average- and worst-case complexity are <code class="inlineCode">O(n)</code>.</p>
          </td>
          <td class="table-cell">
            <p class="normal">Average- and worst-case complexity are <code class="inlineCode">O(1)</code>.</p>
          </td>
          <td class="table-cell">
            <p class="normal">The worst-case complexity for insertion is <code class="inlineCode">O(n)</code>.</p>
          </td>
        </tr>
        <tr>
          <td class="table-cell">
            <p class="normal">Deletion complexity</p>
          </td>
          <td class="table-cell">
            <p class="normal">Deletion is slow. Average- and worst-case complexity are <code class="inlineCode">O(n)</code>.</p>
          </td>
          <td class="table-cell">
            <p class="normal">Average- and worst-case complexity are <code class="inlineCode">O(1)</code>.</p>
          </td>
          <td class="table-cell">
            <p class="normal">The worst-case complexity for deletion is <code class="inlineCode">O(n)</code>.</p>
          </td>
        </tr>
      </tbody>
    </table>
    <p class="normal">Let’s <a id="_idIndexMarker602"/>consider an example to understand when the binary search tree is a good choice to store the data. Let’s assume that we have the following data nodes—<code class="inlineCode">5</code>, <code class="inlineCode">3</code>, <code class="inlineCode">7</code>, <code class="inlineCode">1</code>, <code class="inlineCode">4</code>, <code class="inlineCode">6</code>, and <code class="inlineCode">9</code>, as shown in <em class="italic">Figure 6.35</em>. If we use a list to store this data, the worst-case scenario will require us to search through the entire list of seven elements to find the item. So, it will require six comparisons to search for item <code class="inlineCode">9</code> in this data node, as shown in <em class="italic">Figure 6.35</em>:</p>
    <figure class="mediaobject"><img src="img/B17217_06_35.png" alt=""/></figure>
    <p class="packt_figref">Figure 6.35: An example list of seven elements requires six comparisons if stored in a list</p>
    <p class="normal">However, if we <a id="_idIndexMarker603"/>use a binary search tree to store these values, as shown in the following diagram, in the worst-case scenario, we will require two comparisons to search for item <code class="inlineCode">9</code>, as shown in <em class="italic">Figure 6.36</em>:</p>
    <figure class="mediaobject"><img src="img/B17217_06_36.png" alt=""/></figure>
    <p class="packt_figref">Figure 6.36: An example list of seven elements requires three comparisons if stored in a binary search tree</p>
    <p class="normal">However, it is important to note that the efficiency of searching also depends on how we built the binary search tree. If the tree hasn’t been constructed properly, it can be slow. For example, if we had inserted the elements into the tree in the order <code class="inlineCode">1</code>, <code class="inlineCode">3</code>, <code class="inlineCode">4</code>, <code class="inlineCode">5</code>, <code class="inlineCode">6</code>, <code class="inlineCode">7</code>, <code class="inlineCode">9</code>, as shown in <em class="italic">Figure 6.37</em>, then the tree would not be more efficient than the list:</p>
    <figure class="mediaobject"><img src="img/B17217_06_37.png" alt=""/></figure>
    <p class="packt_figref">Figure 6.37: A binary search tree constructed with elements in the order 1, 3, 4, 5, 6, 7,9</p>
    <p class="normal">Depending <a id="_idIndexMarker604"/>upon the sequence of the nodes added to the tree, it is possible that we may have a binary tree that is unbalanced. Thus, it is important to use a method that can make the tree a self-balancing tree, which in turn will improve the <code class="inlineCode">search</code> operation. Therefore, we should note that a binary search tree is a good choice if the binary tree is balanced.</p>
    <h1 id="_idParaDest-151" class="heading-1">Summary</h1>
    <p class="normal">In this chapter, we discussed an important data structure, i.e. tree data structures. Tree data structures in general provide better performance compared to linear data structures in <code class="inlineCode">search</code>, <code class="inlineCode">insert</code>, and <code class="inlineCode">deletion</code> operations. We have also discussed how to apply various operations to tree data structures. We studied binary trees, which can have a maximum of two children for each node. Further, we learned about binary search trees and discussed how we can apply different operations to them. Binary search trees are very useful when we want to develop a real-world application in which the retrieval or searching of data elements is an important operation. We need to ensure that the tree is balanced for the good performance of binary search tree. We will discuss priority queues and heaps in the next chapter.</p>
    <h1 id="_idParaDest-152" class="heading-1">Exercises</h1>
    <ol class="numberedList" style="list-style-type: decimal;">
      <li class="numberedList" value="1">Which of the following is a true about binary trees:<ol class="alphabeticList" style="list-style-type: lower-alpha;">
          <li class="alphabeticList" value="1">Every binary tree is either complete or full</li>
          <li class="alphabeticList">Every complete binary tree is also a full binary tree</li>
          <li class="alphabeticList">Every full binary tree is also a complete binary tree</li>
          <li class="alphabeticList">No binary tree is both complete and full</li>
          <li class="alphabeticList">None of the above</li>
        </ol>
      </li>
      <li class="numberedList">Which of the tree traversal algorithms visit the root node last? <p class="normal">Consider this binary search tree:</p>
      </li>
    </ol>
    <figure class="mediaobject"><img src="img/B17217_06_38.png" alt=""/></figure>
    <p class="packt_figref">Figure 6.38: Sample binary search tree</p>
    <ol class="numberedList" style="list-style-type: decimal;">
      <li class="numberedList" value="3">Suppose we remove the root node <code class="inlineCode">8</code>, and we wish to replace it with any node from the left subtree, then what will be the new root?</li>
      <li class="numberedList">What will be the <code class="inlineCode">inorder</code>, <code class="inlineCode">postorder</code> and <code class="inlineCode">preorder</code> traversal of the following tree?</li>
    </ol>
    <figure class="mediaobject"><img src="img/B17217_06_39.png" alt=""/></figure>
    <p class="packt_figref">Figure 6.39: Example tree</p>
    <ol class="numberedList" style="list-style-type: decimal;">
      <li class="numberedList" value="5">How do you find out if two trees are identical?</li>
      <li class="numberedList">How many leaves are there in the tree mentioned in <em class="italic">question number 4</em>?</li>
      <li class="numberedList">What is the relation between a perfect binary tree’s height and the number of nodes in that tree?</li>
    </ol>
    <h1 class="heading-1">Join our community on Discord</h1>
    <p class="normal">Join our community’s Discord space for discussions with the author and other readers: <a href="https://packt.link/MEvK4">https://packt.link/MEvK4</a></p>
    <p class="normal"><img src="img/QR_Code1421249772551223062.png" alt=""/></p>
  </div>
</body></html>