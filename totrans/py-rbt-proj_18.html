<html><head></head><body><div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">Making a Robotic Arm</h1>
                </header>
            
            <article>
                
<p>Finally, we are where most of us have wanted to be since the start of this book. Making a robotic arm! In this chapter, we will learn the concepts behind the working of a robotic arm. Undoubtedly, we will also be making a robotic arm for our personal use as well that can do limitless things for us.</p>


            </article>

            
        </section>
    </div>
<div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">Basics of a robotic arm</h1>
                </header>
            
            <article>
                
<p class="mce-root">If you see a human body, then one of the most distinctive parts that makes us able to be different than most other species is the arm. It is the part of the body that we use to do most of the work.</p>
<p class="mce-root">The human arm is a very complex mechanism of joints and muscles that work in tandem to give it the dexterity that we know it for. Take an example of our shoulder joint. If you pay attention, then you will notice that it has the ability to move up and down, right and left, and even rotate on its own axis, and all this while it just has one single joint, which we know as a ball joint.</p>
<p class="mce-root">When we talk about a robotic arm on a robot, we are undoubtedly talking about a complex arrangement of actuators with the body, otherwise known as a chassis, to get the desired motion in a three-dimensional space.</p>
<p class="mce-root">Now, let's understand some of the basic parts of any robotic arm. The first parts are the actuators. We can use motors to control the robotic arm; however, as we have studied earlier, using the motors we have used before will not be the ideal solution for it as it cannot hold its position neither does it have a feedback mechanism. So we are left with only one option, that is, to use servo motors. As we know, they have a handful of torque and have the ability to know where it is and to hold its position for as long as we want.</p>
<p class="mce-root">The second part of the robot is the chassis, that is, the part that holds all the motors together and provides structural support to the robot. This has to be made in such a way that it provides motion in all the desirable axis to any given joint. This is important as a single servo can only provide motion in one single axis. However, there are multiple places in which complex arrangement can be used to make the robot traverse in multiple axes. Also, the chassis should be rigid, which is extremely important. As we all know, all the material on this planet have certain level of flexibility. Also, the construction of the material depends on how noncompliant the material would be. This serves a very important purpose of repeatability.</p>
<p class="mce-root">Now, what is repeatability? As you might have seen in industries or any manufacturing units, the robots are installed and they do the same task over and over again. This is possible as the robots are programmed to perform a specific set of functions under specific circumstances. Now, let's say that the chassis of the robot is not rigid. In such a case, even if the servos are 100% precise and get to the exact same position over and over again, still the robot may actually differ from its actual goal position. This happens as there may be some flexibility in the chassis, which is why the final position may differ. Hence, a right chassis is a must. It becomes even more important when we are talking about large robots, as even the slightest of deformation can lead to a very large change in the final position of the arm.</p>
<p class="mce-root">One very common terminology which we use while talking about the robot arm is the end effector. This is basically the end of the robot arm, which will be doing all the final work for us. End effector in the case of a real human arm can be considered the hand. This is at the top of the arm and all the movement of the arm is basically to articulate the position of the hand in a three-dimensional space. Also, it is the hand that picks up the objects or does the necessary physical action. Hence, the term end effector.</p>
<p class="mce-root">Now, as the robotic arm is moving in a three dimensional space, it becomes a real big problem to define the axis in which the motion is happening. Hence, instead of using the axis to define the motion, we generally use the type of motion being performed, which gives us a realistic idea of what the motion is and in which axis it may be on. To analyze the motion, we use the concept of <strong>Yaw Pitch and Roll</strong> (<strong>YPR</strong>).</p>
<div class="mce-root CDPAlignCenter CDPAlign"><img src="Images/020cfeaf-75d1-4fc0-94a3-559df1142150.png" style="width:47.75em;height:17.00em;"/></div>
<p>The preceding diagram will clear most of the doubts about YPR. This concept is generally used in aircrafts; however, it is an essential part of a robotic hand as well. So, as you can see from the preceding figure, when the nose of the plane goes up or down, it will be considered as pitch movement. Similarly, if the aircraft changes the heading, then the <strong>Yaw</strong> can be considered to change accordingly—the <strong>Yaw</strong> is nothing but the movement of aircraft in the <em>y</em> axis. Finally, we have something called <strong>Roll</strong>. It is used to understand the angel of rotation. As you can see, all these three entities are independent to each other and chasing any of it will not have any effect on the other. This concept is also useful as no matter what the orientation of the aircraft is, the YPR would still be unchanged and very much understandable. Hence, we take this concept straight from the aircraft directly to our robots.</p>
<p class="mce-root">Finally, how can we forget about the processing unit? It is the unit that commands all the actuators and does the coordination and the decision making. This processing unit in our case is Raspberry Pi, which will command all the actuators. <span>All of these preceding components make up a robotic arm.</span></p>


            </article>

            
        </section>
    </div>
<div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">Degrees of freedom</h1>
                </header>
            
            <article>
                
<p>Not every robotic arm is the same. They have different load ratings, that is, the maximum load that the end effector can take, the speed and reach, that is, how far the end effector can reach. However, one very important part of a robotic arm is the number of motors it has. So, for every axis, you need at least one motor to make the robot traverse in that axis. For example, a human arm has three-dimensional freedom in the shoulder joint. Hence, to mimic that joint, you will need a motor for every axis, that is, a minimum of three motors are required for the arm to move in all the three axis, independently. Similarly, when we talk about the elbow joint of our hand, it can only traverse in two dimensions. That is the closing and opening of the arm and the finally the rotation of the arm—the elbow does not move in the third dimension. Hence, to replicate its motion, we need at least two motors, so that we an move the robot in the <em>w</em> axis.</p>
<p>From what we have understood so far, we can safely assume that the more the number of motors, the more dexterous the robot would also be. This is mostly the case; however, you may use multiple motors to make the robot turn in a single axis itself. In such a scenario, the basic concept of counting the number of actuators to determine the dexterity of the robot will not work. So how do we determine how dexterous the robot is?</p>
<p>We have a concept called <strong>degrees of freedom</strong> (<strong>DOF</strong>). If I go by the standard definition, then I can be very sure that you will be left confused as to what it actually means. If you are not convinced, then try finding out on Google yourself. A DOF, in very simple and plain English, is a joint that can independently move on any given axis. So, for example, if we are talking about a shoulder joint, then we have movement in all the three axis. Hence, the degrees of freedom would be three. Now, let's take into consideration the elbow joint of our arm. As it can only move in pitch and roll, hence there are two DOFs that we end up with. If we connect the shoulder joint with the elbow joint, then the DOF will be added up and the whole system would be called to have six DOFs. Keep in mind that this definition is a very simplified one. There are multiple complexities that you will encounter should you choose to dig deeper.</p>
<p>Now, most of the robotic arms that you will encounter would be having close to six DOFs. Though you may say that it is less than what human arms have, in practicality, it does most of the work and obviously having less DOFs means less number of motors leading to lower cost and obviously lower complexity in programming. Hence, we try to use as few DOFs as possible.</p>
<div class="CDPAlignCenter CDPAlign"><img src="Images/669abc29-fff7-42bb-891e-f2696ae96e1e.png" style="width:26.08em;height:27.08em;"/></div>
<p>Now, in the preceding diagram, you can see a typical robotic arm which has six DOFs. The base actuator marked by number <strong>1</strong> gives the freedom of rolling and altering the pitch. The elbow actuators marked by number <strong>2</strong> add only one DOF of the pitch to the robot. Furthermore, joint number <strong>3</strong> is has the ability to travel in <strong>Pitch &amp; Roll</strong>. Finally, we have the end actuator as the gripper here; the gripper in itself has one DOF. So, cumulatively, we can say that the robot is a six-DOF robot.</p>


            </article>

            
        </section>
    </div>
<div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">Power house</h1>
                </header>
            
            <article>
                
<p class="mce-root">There is one unit that we have been using in all our projects, but I want to emphasize on it in this chapter. This unit is the power unit. The reason we are talking about it is because in this chapter we will be controlling multiple servos. When we are talking about multiple servos, naturally we will be talking about a lot of power consumption. In the robot arm, we have six servo motors. Now, depending upon the make and model of the motor, the power consumption will vary. But keeping yourself on a safer side and assuming every servo's power consumption to be around 1 amp would be a good idea. Most of the power supply you would be using might not be able to give you this much of burst current. So what should we do?</p>
<p class="mce-root">We can take the easy approach of taking a higher power output. But, instead, we can take the unconventional route. We can have a battery that can deliver this much of power when needed. But, the question is, will any battery solve our purpose? Obviously, the answer would be no.</p>
<p class="mce-root">There are multiple types of batteries that exist. These batteries can be distinguished based on the following parameters:</p>
<ul>
<li>Voltage</li>
<li>Capacity</li>
<li>Power to weight ratio</li>
<li>Maximum charge and discharge rate</li>
<li>Chemical composition</li>
</ul>
<p>These are covered in detail in the upcoming subsections.</p>


            </article>

            
        </section>
    </div>
<div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">Voltage</h1>
                </header>
            
            <article>
                
<p>Voltage is the overall potential difference that the battery can create. Every battery has a specific voltage that it delivers. One thing to remember is that this voltage will vary slightly based on the charge condition of the battery. That is, when a 12V battery is fully charged, it may be giving an output of 12.6V. However, when it gets fully discharged, it may reach up to 11.4V. So, what battery voltage means is the nominal voltage that the battery would be providing.</p>


            </article>

            
        </section>
    </div>
<div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">Capacity</h1>
                </header>
            
            <article>
                
<p>Now, the second parameter is the capacity. Generally, when you buy a battery, you will see its capacity in <strong>milliampere hour</strong> (<strong>mAh</strong>) or in <strong>ampere hours</strong> (<strong>Ah</strong>). This is a very simple term. Let me explain this term to you using an example. Let's say you have a battery with a capacity of 5 Ah. Now, if I draw 5 amperes continuously for 1 hour, then the battery will be completely discharged. On the contrary, if I draw 10 amperes continuously, then the battery will be discharged in half an hour. With this, we can also derive the overall power that the battery has using the following simple formula: <em>Overall Power in Watts</em> = <em>Nominal Voltage of Battery x Overall battery capacity of battery in amperes</em></p>
<p>Hence, if you have a battery of 12V, which has a capacity of 10 Ah, then the overall capacity in watts will be 120 watts.</p>


            </article>

            
        </section>
    </div>
<div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">Power-to-weight ratio</h1>
                </header>
            
            <article>
                
<p>In the previous chapter, we have understood that weight plays a very crucial role in robotics and if we increase the weight of the robot, then the force required to move it can exponentially go up. Hence, the concept of power to weight ratio comes into play. We always prefer a battery, which is extremely lightweight and delivers a large sum of power in respect to the weight. The equation for the power-to-weight ratio can be defined as follows: <em>Power to weight ratio in watt hour/kg</em> = <em>Maximum Power in watts / Overall weight of battery in kg.</em></p>
<p>Now, let's say a battery is providing a power of 500 watts and the weight is 5 kg, then the power to weight ratio will be 100 Wh/kg. <span>The higher the power to weight ratio, the better the battery is.</span></p>


            </article>

            
        </section>
    </div>
<div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">Maximum charge and discharge rate</h1>
                </header>
            
            <article>
                
<p>This is perhaps one of the most crucial parts of the battery. Often the batteries are capable of running the robot for a span of 1 hour. However, the power consumption of robots is not constant. Let's say for 90% of the time, our robotic arm is consuming 2 amperes of power, so the battery capacity is of 2 Ah. However, at some points of time during the operation, the robot needs all the motors to work on peak power. The peak power consumption of the robot is around 6 amperes. Now, the question is, will the battery of 2 Ah be able to provide 6 amperes power to the robot?</p>
<p>This is a very practical challenge. You may say, it is better to go with a battery that is much bigger than a 2 Ah battery. But, as you know, it will increase the weight phenomenally. So what's the solution?</p>
<p>There is something called peak discharge current. This is denoted by <em>C</em> rating. So, if our battery is of 1 C rating then a 2 Ah battery will only be able to give us a maximum of 2 Ah of power supply at any given time. However, if the battery is of 10 C rating, then it should be able to provide a burst power supply of up to 20 amperes. These days, you can find batteries that can give a burst power supply of up to 100 C or even more. The reason we have this is because the peak power consumption of robots can be exponentially higher than their constant power consumption. If, at any point, the battery is not able to pull ample amount of power, then the robot would behave erroneously and can even shut down.</p>
<p>The second part of this story is the charge rating. This is the maximum charge current that you can provide to the battery. It is also denoted by the same C rating. So, if the C rating is 0.5, then you can provide a max of 1 ampere of charge to a 2 Ah battery.</p>
<p>In other words, the fastest you can charge a battery would be in 2 hours.</p>


            </article>

            
        </section>
    </div>
<div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">Chemical composition</h1>
                </header>
            
            <article>
                
<div>
<p>There are different types of batteries that you can find on the market these are broadly segregated by their chemical composition. All of these batteries have their own pros and cons. Hence, we cannot say that one is better than the other. It is always a trade-off between various factors. The following is a list of batteries you can find on the market along with their pros and cons:</p>
</div>
<table style="border-collapse: collapse;width: 100%" border="1">
<tbody>
<tr>
<td><strong>Battery</strong></td>
<td><strong>Peak power output</strong></td>
<td><strong>Power-to-weight ratio</strong></td>
<td><strong>Price</strong></td>
</tr>
<tr>
<td>Wet cell</td>
<td>Low</td>
<td>Extremely low</td>
<td>Cheapest</td>
</tr>
<tr>
<td>Nickel metal hydride</td>
<td>Medium</td>
<td>Low</td>
<td>Cheap</td>
</tr>
<tr>
<td>Lithium ion</td>
<td>High</td>
<td>Good</td>
<td>High</td>
</tr>
<tr>
<td>Lithium polymer</td>
<td>Extremely high</td>
<td>Extremely good</td>
<td>Extremely high</td>
</tr>
</tbody>
</table>
<p> </p>
<p>As you can see from this table, the peak power output is something which we highly want and so is the good power-to-weight ratio; hence, spending a good amount of money on a lithium polymer battery makes sense.</p>
<p>These batteries, at a minimum, have a 20 C rating with a power-to-weight ratio around five times higher than the normal wet cell batteries. However, they can be up to 10 times more expensive than the normal wet cell batteries.</p>
<p>Now we know which batteries to choose for those higher current requirements. A lithium polymer battery of 11.1V and 2200 mAh will not cost you more than $20 and will provide you with immense power that you may never need. So, we have the power supply issue sorted. Now it's time to go ahead and make the robotic hand operational.</p>


            </article>

            
        </section>
    </div>
<div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">Finding the limits</h1>
                </header>
            
            <article>
                
<p>The robotic arm kit is a fairly easy one to procure from eBay or Amazon. This is not very difficult to assemble and will require a few hours to prepare. Some of the robotic arm kits might not ship with servo motors, in which case, you may have to order it separately. I would say go for the kit that comes bundled with the servos, as there can be compatibility issues if you choose to order servos separately.</p>
<p>As you know, these servos will work using PWM and it's not hard to control them either. So, let's go straight onto it and see what we can do. Once you have assembled the robotic arm kit, connect the wires of the servos as follows:</p>
<div class="CDPAlignCenter CDPAlign"><img src="Images/1e6e7e16-abbc-4a09-8c34-617e30707833.png" style="width:32.00em;height:49.92em;"/></div>
<p>Now, firstly, we need to know what are the maximum physical limits of every single servo connected on our robot. There are various techniques to do that. The very basic one is to measure it physically. This method can be good but you won't be able to ever utilize the full potential of the servo motor as you would be having some degree of error in measuring. Hence, the value you put in the servo will be slightly less than what you think it can go to. The second method is by manually feeding the data and finding out the exact angle. So, let's go ahead with the second way of doing things and upload the following code:</p>
<pre class="mce-root"><span>import RPi.GPIO as GPIO<br/></span><span>import time<br/><br/></span><span>GPIO.setmode(GPIO.BCM)<br/></span><span>GPIO.setup(14,GPIO.OUT)<br/></span><span>GPIO.setup(16,GPIO.OUT)<br/></span><span>GPIO.setup(18,GPIO.OUT)<br/></span><span>GPIO.setup(20,GPIO.OUT)<br/></span><span>GPIO.setup(21,GPIO.OUT)<br/></span><span>GPIO.setup(22,GPIO.OUT)<br/></span><span><br/> <br/></span><span>GPIO.setwarnings(False)<br/><br/></span><span>pwm1 = GPIO.PWM(14, 50)<br/></span><span>pwm2 = GPIO.PWM(16, 50)<br/></span><span>pwm3 = GPIO.PWM(18, 50)<br/></span><span>pwm4 = GPIO.PWM(20, 50)<br/></span><span>pwm5 = GPIO.PWM(21, 50)<br/></span><span>pwm6 = GPIO.PWM(22, 50)<br/></span><span> <br/></span><span>pwm1.start(0)<br/></span><span>pwm2.start(0)<br/></span><span>pwm3.start(0)<br/></span><span>pwm4.start(0)<br/></span><span>pwm5.start(0)<br/></span><span>pwm6.start(0)<br/></span><span><br/>def cvt_angle(angle):</span><span><br/></span>    dc = float(angle/90) + 0.5<br/>    return dc<span><br/><br/></span><span>while 1:<br/><br/></span><span> j = input('select servo')</span><span><br/><br/></span><span> if j == 1:<br/><br/> </span><span> i = input('select value to rotate')<br/></span><span> </span><span> pwm1.ChangeDutyCycle(cvt_angle(i))<br/></span><span>  time.sleep(2)<br/>  pwm1.ChangeDutyCycle(cvt_angle(90))<br/><br/></span><span> elif j ==2:<br/> <br/></span><span>  i = input('select value to rotate')</span><span><br/></span><span>  </span><span>pwm2.ChangeDutyCycle(cvt_angle(i))<br/></span><span>  time.sleep(2)<br/></span><span>  pwm2.ChangeDutyCycle(cvt_angle(90))<br/></span><span><br/><br/></span><span> elif j ==3:<br/></span><span><br/></span><span> i = input('select value to rotate')<br/> </span><span>pwm3.ChangeDutyCycle(cvt_angle(i))<br/></span><span> time.sleep(2)<br/></span><span> pwm3.ChangeDutyCycle(cvt_angle(90))</span><span><br/><br/></span><span> elif j ==4:</span><span> <br/><br/></span><span> i = input('select value to rotate')<br/></span><span> </span><span>pwm4.ChangeDutyCycle(cvt_angle(i))<br/></span><span> time.sleep(2)<br/></span><span> pwm4.ChangeDutyCycle(cvt_angle(90))</span><span><br/><br/></span><span> elif j ==5:<br/></span><span> <br/></span><span> i = input('select value to rotate')<br/></span><span> </span><span>pwm5.ChangeDutyCycle(cvt_angle(i))<br/></span><span> time.sleep(2)<br/></span><span> pwm5.ChangeDutyCycle(cvt_angle(90))</span><span><br/><br/></span><span> elif j ==6:<br/></span><span> <br/></span><span> i = input('select value to rotate')</span><span><br/></span><span> </span><span>pwm6.ChangeDutyCycle(cvt_angle(i))<br/></span><span> time.sleep(2)<br/></span><span> pwm6.ChangeDutyCycle(cvt_angle(90))</span><span> }</span></pre>
<p>Now, let's see what this code is doing. This code may look pretty elaborate, but what it is doing is extremely simple.</p>
<pre class="mce-root"><span>    j = input('select servo from 1-6')</span></pre>
<p>Using the preceding line of code, we are printing the statement for the user <kbd>select servo from 1-6</kbd>. When the user enters a value of the servo, this value gets stored in a variable <kbd>j</kbd>:</p>
<pre class="mce-root"><span> if j == 1:<br/><br/> </span><span> i = input('select value to rotate')<br/></span><span> </span><span> pwm1.ChangeDutyCycle(cvt_angle(i))<br/></span><span>  time.sleep(2)<br/></span><span>  pwm1.ChangeDutyCycle(cvt_angle(90))</span><span> </span></pre>
<p>This <kbd>if</kbd> condition here checks for the value of <kbd>j</kbd>. If in this line, <kbd>j=1</kbd>, then it will run the code corresponding to the servo number <kbd>1</kbd>. Inside this code, the first line will print <kbd>select value to rotate</kbd>. Once this is done, the program will then wait for user input. Once the user inputs any value, then it will be stored in a variable called <kbd>I</kbd>. Thereafter, using the <kbd>cvt_angle(i)</kbd> <span>function, </span>the value which the user has input into the system will be converted to its corresponding duty cycle value. This duty cycle value will be fetched to the <kbd>pwm1.ChangeDutyCycle()</kbd> argument thereby giving the robot that very certain angle in the particular joint that you want. Due to the <kbd>time.sleep(2)</kbd> <span>function,</span> the servo will wait to go over to the next line. Thereafter, we are using the line <kbd>pwm1.ChangeDutyCycle(cvt_angle(90))</kbd>, which will bring it back to 90 degrees.</p>
<p>You may ask, why are we doing this? This is for a very important reason. Let's say you have given it a command to go beyond its physical limit. If that's the case, then the servo will keep on trying to move in that direction<span> no matter what.</span> However, due to the physical constrain, it will not be able to go ahead. Once this happens, then, within a few seconds, you will see blue smoke coming out of your servo indicating its death. The problem is that making such type of errors is very easy and the loss is quite noticeable. Hence, to prevent this, we quickly bring it back to the central position where it does not have any possibility of burning up.</p>
<p>Now, as per the preceding code, the same is done for servos 1-6 through the robot. Now that you know what is happening, it's time to take a pen and a paper and start giving servos the angular values. Do remember that the final goal of this code is to find out the maximum limits. So, let's start doing it starting from 90 degrees onwards. Give it a value on either side and not down until which value you can take it. Make a list on a paper as we will require it for our next code.</p>


            </article>

            
        </section>
    </div>
<div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">Making the robot safe</h1>
                </header>
            
            <article>
                
<p>In the previous part of the chapter, with our multiple attempts, we have been able to find the maximum positions for each of the servos. Now it's time to use these values. In this chapter, we will be programming the servos for what its absolute maximums are. In this program, we will make sure that servos will never need to travel even a degree beyond the defined parameters on both the sides. If the user gives a value beyond it, then it will simply choose to ignore the user inputs instead of causing self damage.</p>
<p>So, let's see how to get it done. There are some parts of this program, where the numeric values have been bold. These are the values that you need to replace with the values which we have noted in the previous section of this chapter. For example, for servo 1, the values noted down are <kbd>23</kbd> and <kbd>170</kbd> as the maximum values for either side. Hence, the change in the code will be from <kbd>if a[0] &lt; 160 and a[0] &gt; 30</kbd> to <kbd>ifa[0] &lt; 170 and a[0] &gt; 23</kbd>. Similarly, for every servo, the same procedure has to be followed:</p>
<pre class="mce-root"><span>import RPi.GPIO as GPIO<br/></span><span>import time<br/><br/></span><span>GPIO.setmode(GPIO.BCM)<br/></span><span>GPIO.setup(14,GPIO.OUT)<br/></span><span>GPIO.setup(16,GPIO.OUT)<br/></span><span>GPIO.setup(18,GPIO.OUT)<br/></span><span>GPIO.setup(20,GPIO.OUT)<br/></span><span>GPIO.setup(21,GPIO.OUT)<br/></span><span>GPIO.setup(22,GPIO.OUT)<br/></span><span><br/> <br/></span><span>GPIO.setwarnings(False)<br/><br/></span><span>pwm1 = GPIO.PWM(14, 50)<br/></span><span>pwm2 = GPIO.PWM(16, 50)<br/></span><span>pwm3 = GPIO.PWM(18, 50)<br/></span><span>pwm4 = GPIO.PWM(20, 50)<br/></span><span>pwm5 = GPIO.PWM(21, 50)<br/></span><span>pwm6 = GPIO.PWM(22, 50)<br/></span><span> <br/></span><span>pwm1.start(cvt_angle(90))<br/></span><span>pwm2.start(cvt_angle(90))<br/></span><span>pwm3.start(cvt_angle(90))<br/></span><span>pwm4.start(cvt_angle(90))<br/></span><span>pwm5.start(cvt_angle(90))<br/></span><span>pwm6.start(cvt_angle(90))</span><br/><br/>def cvt_angle(angle):<br/>    dc = float(angle/90) + 0.5<br/>    return dc<br/><br/>while True:<br/><br/>    a = raw_input("enter a list of 6 values")<br/>    <br/>    if a[0] &lt; <strong>160</strong> and  a[0] &gt; <strong>30</strong>:<br/>        <span>pwm1.ChangeDutyCycle(cvt_angle(a[0]))<br/><br/></span>    if a[1] &lt; <strong>160</strong> and  a[1] &gt; <strong>30</strong>:<span><br/>        </span><span>pwm2.ChangeDutyCycle(cvt)angle(a[1]))<br/><br/></span>    if a[0] &lt; <strong>160</strong> and  a[0] &gt; <strong>30</strong>:<span><br/>        pwm3.ChangeDutyCycle(cvt_angle(a[2]))<br/><br/></span>    if a[0] &lt; <strong>160</strong> and  a[0] &gt; <strong>30</strong>:<span><br/>        pwm4.ChangeDutyCycle(cvt_angle(a[3]))<br/><br/></span>    if a[0] &lt; <strong>160</strong> and  a[0] &gt; <strong>30</strong>:<span><br/>        pwm5.ChangeDutyCycle(cvt_angle(a[4]))<br/><br/></span>    if a[0] &lt; <strong>160</strong> and  a[0] &gt; <strong>30</strong>:<span><br/>        pwm6.ChangeDutyCycle(cvt_angle(a[5]))}</span></pre>
<p>Now, in this code, we have done something very rudimentary. You can safely say that all we have done is put the <kbd>ChangeDutyCycle()</kbd> function inside an <kbd>if</kbd> statement. This <kbd>if</kbd> statement will govern whether the servo will move or stay still in its own position. To some, it may seem very naive to have this program in a special section. But, trust me, it is not. This statement will now be used as a part of every program from here on. All the code written for the movement of the servos will have to check the final values going to the servos through this <kbd>if</kbd> statement; hence, a basic visualization of code is extremely necessary.</p>
<p>Now that the explanation is done, it's time for you to give different commands and see whether they are working within the safe working limits.</p>


            </article>

            
        </section>
    </div>
<div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">Programming multiple frames</h1>
                </header>
            
            <article>
                
<p>In the previous chapter, we have learned the basics of how to make sure that the robot is working under safe limits. In this chapter, we will be looking at how a robot can be made to do different activities at a click of a button, instead of typing the values one by one.</p>
<p>To do this, we will need to understand some advanced concepts of motion. Whenever you watch any video or play any video games, then you must have come across the term <strong>frames per second</strong> (<strong>FPS</strong>). If you haven't heard this term, then let me explain it for you. Every video made right now is actually made by still images. These still images are captured by cameras that click 25-30 times in a second. When these images are played back on the screen at the same rate at which they are captured, it forms a smooth video.</p>
<p>Similarly, in robots, we do have the concept of frames. These frames, however, are not images but instead multiple steps that the robot has to follow to achieve a specific motion. In a simple robotic program, there could be simply two frames, that is, the initial frame and the final frame. These two frames will correspond to the i<span>nitial </span>position or the final position.</p>
<p>However, in the real world, this is not always possible, as whenever the robot goes directly from the initial position to the final position, it tends a specific path with a specific curvature. However, there can be obstacles in that path or this path would not be desired as the path that needs to be followed could be a different one. Hence, we need frames. These frames not only define the robot's motion from the initial position to the final position, but also break down the transition from these two positions into multiple steps making the robot follow the desired path.</p>
<p>This can be referred as frame programming, which we will cover in this chapter. One thing to keep in mind is that more the number of frames, smoother will be the functioning of the robot. Do you remember the CCTV footage we saw? We could say it's not smooth and has a lot of jerkiness. This is due to the low frame rate of the CCTV camera. Instead of working on 30 FPS, they work on 15 FPS. This is done to reduce the storage space of the video. However, if you see the latest videos, there are some games and videos with much higher frame rate than normal. Some of our latest camera works on 60 FPS, making the video even smoother and enjoyable to watch. The same will be the case with the robot. The more the number of frames, the smoother and controlled the motion would be. However, make sure you don't go into overkill.</p>
<p>Now, to move from one position to another, we will have to put the values of the angles of every single servos in the very beginning. Once fetched, it will automatically start to execute these values one by one. To do this, go ahead and write the following code:</p>
<pre class="mce-root"><span>import RPi.GPIO as GPIO<br/></span><span>import time<br/><br/></span><span>GPIO.setmode(GPIO.BCM)<br/></span><span>GPIO.setup(14,GPIO.OUT)<br/></span><span>GPIO.setup(16,GPIO.OUT)<br/></span><span>GPIO.setup(18,GPIO.OUT)<br/></span><span>GPIO.setup(20,GPIO.OUT)<br/></span><span>GPIO.setup(21,GPIO.OUT)<br/></span><span>GPIO.setup(22,GPIO.OUT)<br/></span><span><br/> <br/></span><span>GPIO.setwarnings(False)<br/><br/></span><span>pwm1 = GPIO.PWM(14, 50)<br/></span><span>pwm2 = GPIO.PWM(16, 50)<br/></span><span>pwm3 = GPIO.PWM(18, 50)<br/></span><span>pwm4 = GPIO.PWM(20, 50)<br/></span><span>pwm5 = GPIO.PWM(21, 50)<br/></span><span>pwm6 = GPIO.PWM(22, 50)<br/></span><span> <br/></span><span>pwm1.start(0)<br/></span><span>pwm2.start(0)<br/></span><span>pwm3.start(0)<br/></span><span>pwm4.start(0)<br/></span><span>pwm5.start(0)<br/></span><span>pwm6.start(0)</span><br/><br/>def cvt_angle(angle):<br/>    dc = float(angle/90) + 0.5<br/>    return dc<br/><br/>prev0 = 90<br/>prev1 = 90<br/>prev2 = 90<br/>prev3 = 90<br/>prev4 = 90<br/>prev5 = 90 <br/><br/>while True:<br/><br/>    a = raw_input("enter a list of 6 values for motor 1")<br/>    b = raw_input("enter a list of 6 values for motor 2")<br/>    c = raw_input("enter a list of 6 values for motor 3")<br/>    d = raw_input("enter a list of 6 values for motor 4")<br/>    e = raw_input("enter a list of 6 values for motor 5")<br/>    f = raw_input("enter a list of 6 values for motor 6")<br/><br/><br/>    for i in range(6):<br/><br/>        if a[i] &gt; 10 and a[i]&lt; 180 :  <br/>            <span>pwm1.ChangeDutyCycle(cvt_angle(a[i]))<br/><br/></span>        if b[i] &gt; 10 and b[i] &lt; 180:<br/><span>            </span><span>pwm2.ChangeDutyCycle(cvt_angle(b[i]))<br/><br/>        if c[i] &gt; 10 and c[i] &lt; 180:</span><br/><span>            pwm3.ChangeDutyCycle(cvt_angle(c[i]))<br/><br/>        if d[i] &gt; 10 and d[i] &lt; 180:</span><br/><span>            pwm4.ChangeDutyCycle(cvt_angle(d[i]))<br/><br/>        if e[i] &gt; 10 and e[i] &lt; 180:</span><br/><span>           pwm5.ChangeDutyCycle(cvt_angle(e[i]))<br/><br/>        if f[i] &gt; 10 and f[i] &lt; 180:</span><br/><span>           pwm6.ChangeDutyCycle(cvt_angle(f[i]))<br/><br/><br/></span></pre>
<p>In this program, you can see that we have replicated the previous program with some very minor changes. So, let's see what these changes are:</p>
<pre class="mce-root">    a = raw_input("enter a list of 6 values for motor 1")<br/>    b = raw_input("enter a list of 6 values for motor 2")<br/>    c = raw_input("enter a list of 6 values for motor 3")<br/>    d = raw_input("enter a list of 6 values for motor 4")<br/>    e = raw_input("enter a list of 6 values for motor 5")<br/>    f = raw_input("enter a list of 6 values for motor 6")</pre>
<p>Here, we are taking the input values for each servo and storing it in a different list. For servo 1, the list <kbd>a</kbd> will be used; similarly, <kbd>b</kbd> will be used for servo 2, and so on until <kbd>f</kbd>. In the preceding lines of code, the robot will prompt the user to fill in the six frame values for <kbd>motor 1</kbd>. Then, it will ask six values for <kbd>motor 2</kbd> and similarly until <kbd>motor 6</kbd>:</p>
<pre class="mce-root">    for i in range(6):</pre>
<p>The entire program for giving PWM to the servo is concentrated in this for loop. This loop will check the value of <kbd>i</kbd> and increment it every time. The value of <kbd>i</kbd> will start from <kbd>1</kbd> and the loop will run and increment the value of <kbd>i</kbd> until it reaches <kbd>6</kbd>.</p>
<pre class="mce-root">        if a[i] &gt; 10 and a[i]&lt; 180 :  <br/>            <span>pwm1.ChangeDutyCycle(cvt_angle(a[i]))</span></pre>
<p>In this line of the program, the value contained in the list is headed based on the value of <kbd>1</kbd>. So, for the first time it will read the value of <kbd>a[1]</kbd>, which will correspond to the first value of the list <kbd>a[]</kbd>. This value should be between the safe working limits, hence the <kbd>if</kbd> loop. If it is within safe working limits, then the program in the <kbd>if</kbd> condition will work, else it won't. Inside the <kbd>if</kbd> loop, we have a simple statement: <kbd>pwm1.ChangeDutyCycle(cvt_angle(a[I]))</kbd>. This will simply take the value of <kbd>a[1]</kbd> and convert it into the corresponding PWM value and fetch it to the <kbd>ChangeDutyCycle()</kbd> function, which will change the PWM for servo 1.</p>
<p>A similar program is made for the rest of the servos as well going on from servo 1 to servo 6. Hence, all of these will read the values of their corresponding list one by one and change the angle of the servo the way the user has programmed it. Furthermore, as the loop gets executed, the value of <kbd>i</kbd> will increase, hence making the program read the different values fetched in the list. Every value of the servo in the list will correspond to a different frame, hence parsing the robot through it.</p>
<p>So go ahead and have some fun making your robot do some awesome moves. Just take care that you be gentle to it!</p>


            </article>

            
        </section>
    </div>
<div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">Speed control</h1>
                </header>
            
            <article>
                
<p>It's amazing to have made a robotic arm so easily, and with just a bit of code, we are now able to control it the way we want. However, there is one problem you might have noticed, that is, the robot is moving the way we want but not at the speed at which we want it to move. This is a very common problem while using the digital PWM-based servos.</p>
<p>These servos do not have a built-in speed control. Their control system is programmed to move the servo as fast as they can to reach the goal position. Hence, to control the speed, we will have to play with the program itself and give it a smooth linear progression.</p>
<p>The speed control can be done through a few different techniques. So, without much talking, let's go and see the code. Before you write it, read it and go through the code once and then see the following explanation to it. Thereafter, you will have a better idea of what we are doing. This will make writing the code faster and easier. So, let's take a look at it:</p>
<pre class="mce-root"><span>import RPi.GPIO as GPIO<br/></span><span>import time<br/><br/></span><span>GPIO.setmode(GPIO.BCM)<br/></span><span>GPIO.setup(14,GPIO.OUT)<br/></span><span>GPIO.setup(16,GPIO.OUT)<br/></span><span>GPIO.setup(18,GPIO.OUT)<br/></span><span>GPIO.setup(20,GPIO.OUT)<br/></span><span>GPIO.setup(21,GPIO.OUT)<br/></span><span>GPIO.setup(22,GPIO.OUT)<br/></span><span><br/> <br/></span><span>GPIO.setwarnings(False)<br/><br/></span><span>pwm1 = GPIO.PWM(14, 50)<br/></span><span>pwm2 = GPIO.PWM(16, 50)<br/></span><span>pwm3 = GPIO.PWM(18, 50)<br/></span><span>pwm4 = GPIO.PWM(20, 50)<br/></span><span>pwm5 = GPIO.PWM(21, 50)<br/></span><span>pwm6 = GPIO.PWM(22, 50)<br/></span><span> <br/></span><span>pwm1.start(0)<br/></span><span>pwm2.start(0)<br/></span><span>pwm3.start(0)<br/></span><span>pwm4.start(0)<br/></span><span>pwm5.start(0)<br/></span><span>pwm6.start(0)</span><br/><br/>def cvt_angle(angle):<br/>    dc = float(angle/90) + 0.5<br/>    return dc<br/><br/>prev0 = 90<br/>prev1 = 90<br/>prev2 = 90<br/>prev3 = 90<br/>prev4 = 90<br/>prev5 = 90 <br/><br/><span>pwm1.ChangeDutyCycle(cvt_angle(prev0))<br/></span><span>pwm2.ChangeDutyCycle(cvt_angle(prev1))<br/></span><span>pwm3.ChangeDutyCycle(cvt_angle(prev2))<br/></span><span>pwm4.ChangeDutyCycle(cvt_angle(prev3))<br/></span><span>pwm5.ChangeDutyCycle(cvt_angle(prev4))<br/></span><span>pwm6.ChangeDutyCycle(cvt_angle(prev5))<br/></span><br/><br/>while True:<br/><br/> a = raw_input("enter a list of 6 values for motor 1")<br/> b = raw_input("enter a list of 6 values for motor 2")<br/> c = raw_input("enter a list of 6 values for motor 3")<br/> d = raw_input("enter a list of 6 values for motor 4")<br/> e = raw_input("enter a list of 6 values for motor 5")<br/> f = raw_input("enter a list of 6 values for motor 6")<br/><br/>    speed = raw_input("enter one of the following speed 0.1, 0.2, 0.5, 1")<br/><br/><br/> for i in range(6):<br/><br/>   while prev0 =! a[i] and prev1 =! b[i] and prev2 =! c[i] and prev3 =! d[i] and prev4 =! e[i] and prev 5 =! f[i]<br/><br/>     if a[i] &gt; 10 and a[i]&lt; 180 : <br/> <br/>        if prev0 &gt; a[i]<br/>            prev0 = prev0 - speed<br/><br/>         if prev0 &lt; a[i]<br/>             prev0 = prev0 + speed<br/><br/>         if prev0 = a[i]<br/>             prev0 = prev0 <br/><br/>         <span>pwm1.ChangeDutyCycle(cvt_angle(prev0))<br/><br/><br/><br/></span>    if b[i] &gt; 10 and b[i] &lt; 180:<br/><br/>        if prev2 &gt; b[i]<br/>            prev2 = prev2 - speed<br/><br/>         if prev2 &lt; b[i]<br/>             prev2 = prev2 + speed<br/><br/>         if prev2 = b[i]<br/>            prev2 = prev2<br/><br/><span>         </span><span>pwm2.ChangeDutyCycle(cvt_angle(b[i]))<br/><br/><br/>    if c[i] &gt; 10 and c[i] &lt; 180:<br/><br/>        </span>if prev3 &gt; c[i]<br/>             prev3 = prev3 - speed<br/><br/>        if prev3 &lt; c[i]<br/>            prev3 = prev3 + speed<br/><br/>        if prev3 = c[i]<br/>             prev3 = prev3<br/><br/><span>         pwm3.ChangeDutyCycle(cvt_angle(c[i]))<br/><br/><br/><br/>    if d[i] &gt; 10 and d[i] &lt; 180:<br/><br/>        </span>if prev4 &gt; d[i]<br/>             prev4 = prev4 - speed<br/><br/>        if prev4 &lt; d[i]<br/>            prev4 = prev4 + speed<br/><br/>        if prev4 = d[i]<br/>             prev4 = prev4<br/><br/><span>    pwm4.ChangeDutyCycle(cvt_angle(d[i]))<br/><br/><br/><br/>     if e[i] &gt; 10 and e[i] &lt; 180:<br/>         </span>if prev5 &gt; e[i]<br/>             prev5 = prev5 - speed<br/><br/>        if prev0 &lt; e[i]<br/>            prev5 = prev5 + speed<br/><br/>        if prev5 = e[i]<br/>             prev5 = prev5<br/><br/><span>     pwm5.ChangeDutyCycle(cvt_angle(e[i]))<br/><br/><br/><br/>     if f[i] &gt; 10 and f[i] &lt; 180:<br/><br/>         </span>if prev6 &gt; f[i]<br/>            prev6 = prev6 - speed<br/><br/>         if prev6 &lt; f[i]<br/>            prev6 = prev6 + speed<br/><br/>        if prev6 = f[i]<br/>            prev6 = prev6<br/><br/><span>     pwm6.ChangeDutyCycle(cvt_angle(f[i]))<br/><br/><br/> flag = 0 </span></pre>
<p>In this program, there are quite a few things. We should go through them one by one to have an understanding of it. So, let's see what we are doing:</p>
<pre class="mce-root">prev0 = 90<br/>prev1 = 90<br/>prev2 = 90<br/>prev3 = 90<br/>prev4 = 90<br/>prev5 = 90 </pre>
<p>Here, we have defined six new variables with the name <kbd>prev0</kbd> to <kbd>prev5</kbd> and all of them have been allowed a value of <kbd>90</kbd>. The term <kbd>prev</kbd> here stands for previous, so this will be there to indicate the previous value.</p>
<pre class="mce-root">        while prev0 =! a[i] and prev1 =! b[i] and prev2 =! c[i] and prev3 =! d[i]   and prev4 =! e[i] and prev 5 =! f[i]</pre>
<p>After the code line <kbd>for i in range 6</kbd>, we have the preceding line of code, which is basically checking the value of <kbd>a[i]</kbd> with <kbd>prev0</kbd>. Similarly, it is checking the values of <kbd>b[i]</kbd> with <kbd>prev1</kbd> and so on. Until the time all of these are not true the <kbd>while</kbd> loop will be true and will loop the program inside it until the condition is not false. That is, all the <kbd>prev</kbd> values are exactly equal to the values of the corresponding values of the list.</p>
<p>Again, this may seem a little odd to you, but, trust me, it will be quite useful, which we will see in a while:</p>
<pre class="mce-root">     if a[i] &gt; 10 and a[i]&lt; 180 : <br/> <br/>         if prev0 &gt; a[i]<br/>             prev0 = prev0 - speed<br/><br/>         if prev0 &lt; a[i]<br/>             prev0 = prev0 + speed<br/><br/>         if prev0 = a[i]<br/>             prev0 = prev0 <br/><br/>         <span>pwm1.ChangeDutyCycle(cvt_angle(prev0))</span></pre>
<p>Now, here comes the real deal. This is the main program that will control the speed of the servo. In this, the first line is simple; it will check whether the value given to it is valid, that is, between the safe limits. Once that is done, it will then check whether the value of <kbd>a[Ii]</kbd> is less than or greater than the previous value. If it is greater than <kbd>a[i]</kbd>, then it will take in the previous value and decrement it with the speed specified by the user. If it is less than the value of <kbd>a[i]</kbd>, then it will increment the previous value with the speed specified.</p>
<p>So, if you look at it, the code is simply incrementing or decrementing the previous value every time the <kbd>while</kbd> loop is running. Now, the <kbd>while</kbd> loop will run until the value of <kbd>prev</kbd> is equal to the corresponding list value. That is, the loop will keep incrementing the value until it reaches the specified position.</p>
<p>Hence, lower the value of the speed, lower will be the increments every single time, thereby slowing down the speed all together.</p>
<p>This is the same process which will happen for all other servos as well. It may sound very complicated, but it is not! Programming is easy and will continue to remain easy each time you break it down into small pieces and understand them one by one!</p>


            </article>

            
        </section>
    </div>
<div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">Summary</h1>
                </header>
            
            <article>
                
<p>In this chapter, we have understood the basics of robotic arm, its power source, and its programming. With a very simple program, we were able to find out the limits of the servos and then apply these limits to make sure the servo did not damage itself. We got a basic idea of what frames are and did some programming based on frames. Finally, we also went ahead and controlled the speed of the servo using our very own program on a basic level.</p>


            </article>

            
        </section>
    </div></body></html>