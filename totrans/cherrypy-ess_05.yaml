- en: Chapter 5. A Photoblog Application
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we are going to explain what the next few chapters will put
    in place to develop a photoblog application. In the first half of this chapter,
    we will review the goals and features of this application from a high-level perspective
    without going into too much detail. In the second half, we will define the entities
    that our application will manipulate and introduce the concept of object-relational
    mappers, which aim at reducing the impedance mismatch between relational database
    and object-oriented software design. We will briefly present the most common Python
    ORMs and then develop our application data access layer based on the Dejavu ORM.
  prefs: []
  type: TYPE_NORMAL
- en: A Photoblog Application
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In the previous chapters, we have reviewed CherryPy's design and features in
    detail but we haven't demonstrated its use in the context of a web application.
    The next few chapters will undertake this task by going through the development
    of a photoblog application.
  prefs: []
  type: TYPE_NORMAL
- en: A photoblog is like a regular blog except that the principal content is not
    text but photographs. The main reason for choosing a photoblog is that the range
    of features to be implemented is small enough so that we can concentrate on their
    design and implementation.
  prefs: []
  type: TYPE_NORMAL
- en: 'The goals behind going through this application are as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: To see how to slice the development of a web application into meaningful layers
    and therefore show that a web application is not very different from a rich application
    sitting on your desktop.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: To show that the separation of concerns can also be applied to the web interface
    itself by using principles grouped under the name of Ajax.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: To introduce common Python packages for dealing with common aspects of web development
    such as database access, HTML templating, JavaScript handling, etc.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Photoblog Entities
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: As mentioned earlier, the photoblog will try to stay as simple as possible in
    order to focus on the other aspects of developing a web application. In this section,
    we will briefly describe the entities our photoblog will manipulate as well as
    their attributes and relations with each other.
  prefs: []
  type: TYPE_NORMAL
- en: 'In a nutshell our photoblog application will use the following entities and
    they will be associated as shown in the following figure:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Photoblog Entities](img/1848_05_01.jpg)'
  prefs: []
  type: TYPE_IMG
- en: This figure is not what our application will look like but it shows the entities
    our application will manipulate. One photoblog will contain several albums, which
    in turn will host as many films as required, which will carry the photographs.
  prefs: []
  type: TYPE_NORMAL
- en: 'In other words, we will design our application with the following entity structure:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Entity:** Photoblog'
  prefs: []
  type: TYPE_NORMAL
- en: '**Role:** This entity will be the root of the application.'
  prefs: []
  type: TYPE_NORMAL
- en: '**Attributes:**'
  prefs: []
  type: TYPE_NORMAL
- en: '`name:` A unique identifier for the blog'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`title:` A public label for the blog'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Relations:**'
  prefs: []
  type: TYPE_NORMAL
- en: One photoblog will have zero to many albums
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Entity:** Album'
  prefs: []
  type: TYPE_NORMAL
- en: '**Role:** An album carries a story told by the photographs as an envelope.'
  prefs: []
  type: TYPE_NORMAL
- en: '**Attributes:**'
  prefs: []
  type: TYPE_NORMAL
- en: '`name:` A unique identifier for the album'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`title:` A public label for the album'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`author:` The name of the album''s author'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`description:` A simple description of the album used in feeds'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`story:` A story attached to the album'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`created:` A timestamp of when the album is being created'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`modified:` A timestamp of when the album is being modified'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`blog_id:` A reference to the blog handling the album'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Relations:**'
  prefs: []
  type: TYPE_NORMAL
- en: One album will reference zero to several films
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Entity:** Film'
  prefs: []
  type: TYPE_NORMAL
- en: '**Role:** A film gathers a set of photographs.'
  prefs: []
  type: TYPE_NORMAL
- en: '**Attributes:**'
  prefs: []
  type: TYPE_NORMAL
- en: '`name:` A unique identifier for the film'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`title:` A public label for the film'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`created:` A timestamp of when the film is being created'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`modified:` A timestamp of when the film is being modified'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`album_id:` A reference to the album'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Relations:**'
  prefs: []
  type: TYPE_NORMAL
- en: A film will reference zero to several photographs
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Entity:** Photo'
  prefs: []
  type: TYPE_NORMAL
- en: '**Role:** The unit of our application is a photograph.'
  prefs: []
  type: TYPE_NORMAL
- en: '**Attributes:**'
  prefs: []
  type: TYPE_NORMAL
- en: '`name:` A unique identifier for the photo'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`legend:` A legend associated with the photograph'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`filename:` The base name of the photograph on the hard-disk'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`filesize:` The size in bytes of the photograph'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`width:` Width of the photograph in pixels'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`height:` Height of the photograph in pixels'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`created:` A timestamp of when the photograph is being created'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`modified:` A timestamp of when the photograph is being modified'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`film_id:` A reference to the film carrying the photograph'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Relations:** None'
  prefs: []
  type: TYPE_NORMAL
- en: 'Functionally, the photoblog application will provide APIs to manipulate those
    entities via the traditional **CRUD** interface: **Create, Retrieve, Update**,
    and **Delete**. We will elaborate more on this in[Chapter 6](ch06.html "Chapter 6. Web
    Services").'
  prefs: []
  type: TYPE_NORMAL
- en: Now that we have briefly introduced what kind of application we will be developing
    throughout the following chapters we can move on to the next section and start
    reviewing our options to handle the database aspect of the application. But first
    a quick glossary of the terms this chapter will use.
  prefs: []
  type: TYPE_NORMAL
- en: Vocabulary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Here is a list of the terms we will be using:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Persistence: Persistence is the concept of data items outliving the execution
    of programs manipulating them. Simply put, it is the process of storing data in
    long lasting memory medium such as a disk.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Database: A database is a collection of organized data. There are different
    organization models: hierarchical, network, relational, object-oriented, etc.
    A database holds the logical representation of its data.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Database Management System (DBMS): A DBMS is a group of related software applications
    to manipulate data in a database. A DBMS platform should offer the following among
    other features:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Persistence of the data
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: A query language to manipulate data
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: Concurrency control
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: Security control
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: Integrity control
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: Transaction capabilities
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: We will use **DBMSes** as the plural of DBMS.
  prefs: []
  type: TYPE_NORMAL
- en: DBMSes Overview
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this section, we will quickly review the different kinds of existing DBMSes.
    The goal is to quickly introduce their main characteristics.
  prefs: []
  type: TYPE_NORMAL
- en: Relational Database Management System (RDBMS)
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Of all DBMSes, the RDBMS is the most common, whether it is in small applications
    or multi-national infrastructure. An RDBMS comes with a database based on the
    concepts of the relational model, a mathematical model that permits the logical
    representation of a collection of data through relations. A relational database
    should be a concrete implementation of the relational model. However, modern relational
    databases follow the model only to a certain degree.
  prefs: []
  type: TYPE_NORMAL
- en: The following table shows the correlation between the terms of the relational
    model and the relational database implementation.
  prefs: []
  type: TYPE_NORMAL
- en: '| Relational Model | Relational Database |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| Relation | Table |'
  prefs: []
  type: TYPE_TB
- en: '| Attribute | Column |'
  prefs: []
  type: TYPE_TB
- en: '| Tuple | Row |'
  prefs: []
  type: TYPE_TB
- en: Relational databases support a set of types to define the domain of scope a
    column can use. However, there are only a limited number of supported types, which
    can be an issue with complex data types as allowed in objected-oriented design.
  prefs: []
  type: TYPE_NORMAL
- en: '**Structure Query Language** more commonly known as **SQL** is the language
    used to define, manipulate, or control data within a relational database.'
  prefs: []
  type: TYPE_NORMAL
- en: The following table is a quick summary of SQL keywords and their contexts.
  prefs: []
  type: TYPE_NORMAL
- en: '| Context | Keywords |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| Data manipulation | SELECT, INSERT, UPDATE, DELETE |'
  prefs: []
  type: TYPE_TB
- en: '| Data definition | CREATE, DROP, ALTER |'
  prefs: []
  type: TYPE_TB
- en: '| Data control | GRANT, REVOKE |'
  prefs: []
  type: TYPE_TB
- en: '| Transaction | START, COMMIT, ROLLBACK |'
  prefs: []
  type: TYPE_TB
- en: A construction of these keywords is called an SQL statement. When executed,
    an SQL statement returns a collection of rows of the data matching the query or
    nothing.
  prefs: []
  type: TYPE_NORMAL
- en: The relational model algebra uses the relation composition to compose operations
    across different sets; this is translated in the relational database context by
    **joins**. Joining tables allows complex queries to be shaped to filter out data.
  prefs: []
  type: TYPE_NORMAL
- en: 'SQL provides the following three kinds of joins:'
  prefs: []
  type: TYPE_NORMAL
- en: '| Union Type | Description |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| INNER JOIN | Intersection between two tables. |'
  prefs: []
  type: TYPE_TB
- en: '| LEFT OUTER JOIN | Limits the result set by the left table. So all results
    from the left table will be returned with their matching result in the right table.
    If no matching result is found, it will return a NULL value. |'
  prefs: []
  type: TYPE_TB
- en: '| RIGHT OUTER JOIN | Same as the LEFT OUTER JOIN except that the tables are
    reversed. |'
  prefs: []
  type: TYPE_TB
- en: There is no RDBMS written in Python but most RDBMSes can be accessed via a corresponding
    Python library.
  prefs: []
  type: TYPE_NORMAL
- en: Object-Oriented Database Management System (OODBMS)
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: An OODBMS uses the object-oriented model to organize and store information.
    In other words, an OODBMS allows objects to be stored without having to be mapped
    into a different data structure like the relational database. This implies a great
    consistency between the database persisting the data and the application layers
    encapsulating it. In fact, the persistence mechanism is unobtrusive to the developer.
  prefs: []
  type: TYPE_NORMAL
- en: XML Database Management System (XMLDBMS)
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '**Native XML Databases** (**NXDs**) use XML documents as the unit of data they
    store and manipulate. XMLDBMSes on top of NXDs are optimized in this sense and
    provide native support for standard XML selection and querying languages such
    as XPath and XQuery. Some modern RDBMSes offer XML support through transparent
    conversion between the XML and relational data model leveraging the introduction
    of an XML database requirement.'
  prefs: []
  type: TYPE_NORMAL
- en: Object-Relational Mapping
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: For the last fifteen years the software industry has moved towards a generalized
    use of the object-oriented modeling paradigm in the different layers of software
    application development. One of the last bastions that have resisted against this
    wave has been the database domain. Nonetheless, over the years quite an important
    amount of work has been conducted with success in order to develop OODBMSes for
    filling the gap of managing data. In spite of that OODBMSes have not taken off
    enough to steal RDBMS's thunder.
  prefs: []
  type: TYPE_NORMAL
- en: 'There are several factors behind this:'
  prefs: []
  type: TYPE_NORMAL
- en: Cost of changing the market. For decades RDBMSes have been the DBMSes of predilection
    to store and organize data. Most businesses have built their infrastructure around
    RDBMSes and changing that state is an immense task and only few are ready to pay
    for such a risk.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Cost of migrating existing data. Even if a company is ready to step into that
    direction for new projects, it is unlikely it will for the existing infrastructure
    as the cost of migration and integration would be too high.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Lack of unified query language.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Lack of third-party software such as reporting tools based on OODBMS.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Lack of experts. Finding a database administrator for a RDBMS is much easier
    than for an ODBMS.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Object-Relational Mappers** (**ORMs**) succeeded because they were an efficient
    and cost-effective answer to some of the enumerated issues. The principle behind
    object-relational mapping is to reduce the impedance mismatch between the two
    models with minimum intrusion. ORMs allow the database designer and administrator
    to keep their beloved RDBMSes while proposing an objected-oriented interface to
    a certain extent to the software developer. ORM is an extra layer between the
    database and the application which translates an object into a database row and
    vice versa.'
  prefs: []
  type: TYPE_NORMAL
- en: It is important to bear in mind though that ORM can alleviate the problem only
    to a certain degree and that in some cases the differences between the relational
    and object design cannot be met without some compromise on both sides. For example,
    most ORMs correlate a database table into a class, which works fine when the number
    of entities and their relationships stay at a basic level. Unfortunately, this
    one-to-one relationship between a table and a class does not always work well
    in more complex object-oriented design. In such cases the impedance mismatch between
    the relational and object-oriented models may force designers to make concessions
    that could have negative impacts in the long run in regards to extending and maintaining
    the software.
  prefs: []
  type: TYPE_NORMAL
- en: Python Object-Relational Mappers
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: This section will introduce three ORMs in a very basic example in order to provide
    a basic understanding of how they work and their differences. The purpose is not
    to declare one of these ORMs the winner but to give you an idea of their design
    and features.
  prefs: []
  type: TYPE_NORMAL
- en: 'The three ORMs we will cover are:'
  prefs: []
  type: TYPE_NORMAL
- en: SQLObject from Ian Bicking
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: SQLAlchemy from Michael Bayer
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Dejavu from Robert Brewer
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Although great care has been taken in this section, it may happen that by the
    time you read this chapter these products might have changed a bit. You will have
    to refer to their official documentation.
  prefs: []
  type: TYPE_NORMAL
- en: 'In the following example we will map the following entities:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Artist: An artist is made of a name. An artist can have zero or several albums.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Album: An album is made of a title and a release year. An album is associated
    to an artist and can have zero or more songs.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Song: A song is made of a name and a position within the album. A song is associated
    to an album.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: This example should be seen as a stripped down version of our photoblog entity
    set that we defined at the start of this chapter in order to focus on the actual
    features of each ORM rather than on the entities themselves.
  prefs: []
  type: TYPE_NORMAL
- en: 'Step 1: **Mapping the entities**'
  prefs: []
  type: TYPE_NORMAL
- en: '**SQLObject**'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: The first point to note is that SQLObject does not require a separate declaration
    of the mapping that is done within the class itself. Each class must inherit from
    the unobtrusive `SQLObject` class to be manageable by SQLObject and the attributes
    will be mapped transparently by SQLObject into the table's columns. SQLObject
    automatically adds an attribute `id` to hold the unique identifier of each object.
    This means that every table mapped by SQLObject must have a primary key.
  prefs: []
  type: TYPE_NORMAL
- en: '`ForeignKey` or `MultipleJoin` are examples of how to define the relationships
    between entities. Note that they need the name of the class as a string and not
    the class object itself. This allows the declaration of relationships without
    the prior existence of each class within the scope of the module. In other words
    `Artist` and `Album` could be declared in two different modules without the problem
    of cross imports.'
  prefs: []
  type: TYPE_NORMAL
- en: SQLObject offers a useful feature when specifying `alternateID` as a parameter
    in one of the class attributes. By using it, SQLObject adds a new method to the
    class of the form `byAttributeName` as shown in the example above. Note also how
    you can specify at that level the way rows must be ordered when being retrieved.
  prefs: []
  type: TYPE_NORMAL
- en: Finally bear in mind that by default SQLObject auto-commits to the database
    each modification made to an attribute, which can increase the network overhead
    as well as break the database integrity if an error occurs. To work around this
    behavior SQLObject offers the `set` method on an SQLObject object that performs
    one single `UPDATE` query for all the modifications limiting the required bandwidth.
    Moreover, SQLObject supports the concept of transactions, allowing us to ensure
    that operations are atomic to the database and can then be rolled back if an error
    occurs. Note that the transactions have to be explicitly requested by the developer.
  prefs: []
  type: TYPE_NORMAL
- en: '**SQLAlchemy**'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: SQLAlchemy uses a declarative mapping style as you can see. The first step is
    to express tables into their Python syntax counterpart. Then we need to declare
    the class our application will manipulate. Note how they don't need to inherit
    from an `SQLAlchemy` class even though they must inherit from the built-in Python
    object class. Eventually, we map both aspects through the `mapper` function, which
    also allows us to inform SQLAlchemy of the relationships between entities.
  prefs: []
  type: TYPE_NORMAL
- en: You will notice how the identifier of each table is explicitly declared unlike
    SQLObject and Dejavu. Similarly you do not specify at that level how fetched rows
    must be ordered as this will be specified at the query level.
  prefs: []
  type: TYPE_NORMAL
- en: '**Dejavu**'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: Like SQLObject, Dejavu does lots of work under the hood. Each class participating
    in the mapping must inherit from `Unit`. The attributes of the class represent
    the columns of the table. Only the relationship between the entities is done through
    a more declarative interface.
  prefs: []
  type: TYPE_NORMAL
- en: One difference between Dejavu and the other two is that it does not provide
    the cascade delete feature. This means that this has to be accomplished from the
    class itself by defining an `on_forget()` method and specifying what tasks should
    be done when deleting a unit. This might look at first sight like a drawback but
    offers, in fact, a fine granularity on how you propagate a cascade delete.
  prefs: []
  type: TYPE_NORMAL
- en: 'Step 2: **Setting up the access to the database**'
  prefs: []
  type: TYPE_NORMAL
- en: '**SQLObject**'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: '**SQLAlchemy**'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: '**Dejavu**'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: 'Step 3: **Manipulating tables**'
  prefs: []
  type: TYPE_NORMAL
- en: '**SQLObject**'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: '**SQLAlchemy**'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: '**Dejavu**'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: 'Step 4: **Loading data**'
  prefs: []
  type: TYPE_NORMAL
- en: '**SQLObject**'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: '**SQLAlchemy**'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: Note the fact that each object is created independently from the other and their
    relationship is fulfilled in a second step, e.g. the `append()` method on the
    `grace.songs` object.
  prefs: []
  type: TYPE_NORMAL
- en: In the same declarative spirit as above SQLAlchemy does not commit automatically
    by default to the database. Instead it delays the operation until you `flush`
    the current session of work.
  prefs: []
  type: TYPE_NORMAL
- en: '**Dejavu**'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: Dejavu provides the concept of sandboxes in which you can isolate the entities
    you manipulate. Also note that newly created units do not exist for their relatives
    until you call the `sandbox.memorize()` method, which puts the unit into the sandbox.
  prefs: []
  type: TYPE_NORMAL
- en: Like SQLAlchemy, Dejavu delays the commit operation until you explicitly call
    the `sandbox.flush_all()` method.
  prefs: []
  type: TYPE_NORMAL
- en: 'Step 5: **Manipulating data**'
  prefs: []
  type: TYPE_NORMAL
- en: First we define a function that will take an artist and display the albums'
    songs.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: '**SQLObject**'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: '**SQLAlchemy**'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: '**Dejavu**'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: Choosing an object-relational mapper is a difficult task as it is usually after
    using one for a while that you can really measure the impact it has on the development
    design and process. As previously stated, it is critical to acknowledge that ORMs
    do not remove the impedance mismatch between the relational and object-oriented
    model.
  prefs: []
  type: TYPE_NORMAL
- en: SQLObject has a low-learning curve and quite a big community, which makes it
    suitable for developers debuting in the use of ORM. The project is aiming at its
    next version, which will fix a fair number of bad design decisions made in its
    early life while slowly abandoning the current version.
  prefs: []
  type: TYPE_NORMAL
- en: SQLAlchemy has based its design on the Hibernate ORM from the Java world and
    has thus avoided lots of pitfalls that SQLObject has not. Its declarative syntax
    will not please every pythoner but its flexibility and good documentation have
    placed SQLAlchemy as a very serious candidate in the field.
  prefs: []
  type: TYPE_NORMAL
- en: Dejavu is a fairly unknown ORM and thus has a small community. It is well documented
    and comes with relevant example cases. Its strength resides in its capacity to
    move away from the underlying relational database layer by providing a very high-level
    interface using common Python idioms.
  prefs: []
  type: TYPE_NORMAL
- en: For instance, SQLObject and SQLAlchemy do use terms such as `table, column`,
    or `select` while Dejavu refers to `storage` and `unit` providing a better abstraction
    to the underlying mechanisms.
  prefs: []
  type: TYPE_NORMAL
- en: This is also true when it comes to the process of building queries. Unlike SQLObject
    and SQLAlchemy, which stay very close to SQL by providing a Python interface to
    SQL statements, Dejavu provides an interface independent of SQL. Review the section
    on manipulating data for an example.
  prefs: []
  type: TYPE_NORMAL
- en: These are the reasons why our photoblog application will use Dejavu instead
    of SQLObject or SQLAlchemy. However, keep in mind that they are all good and powerful
    ORMs.
  prefs: []
  type: TYPE_NORMAL
- en: Photoblog Application Entity Modeling
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: First we define what we will call a `storage` module providing a simple interface
    to some common operations like the connection to the database.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: In this case, we import the `dejavu` module and we create one global instance
    of the `Arena` class. The `arena` will be our interface between the underlying
    storage manager and the business logic layer.
  prefs: []
  type: TYPE_NORMAL
- en: The `connect` function adds a storage manager to the `arena` object for a PostgreSQL
    RDBMS and then registers all imported entities so that the `arena` object knows
    what entities it will manage. (Please refer to the Dejavu documentation for a
    list of supported database managers and how to declare them within the `add_store()`
    method.) Once we have this module we can start mapping entities.
  prefs: []
  type: TYPE_NORMAL
- en: Mapping Entities
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Mapping the entities is done through the following process:'
  prefs: []
  type: TYPE_NORMAL
- en: Creating a class that inherits from `Unit`
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Adding attributes using the `UnitProperty` class
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Setting up the relationship between units
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Entity:** Photoblog'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: '**Entity:** Album'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: '**Entity:** Film'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: '**Entity:** Photo'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: Units and UnitProperties
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In the previous section, we mapped our entities into units that Dejavu will
    manage. All our classes inherit from the `Unit` base class. This class does not
    provide much apart from automatically adding an `ID` property to the class, which
    is the reason why we do not explicitly provide one in any of our units. Nonetheless
    by inheriting from the `Unit` class you allow Dejavu to register and handle your
    class.
  prefs: []
  type: TYPE_NORMAL
- en: 'The next step is obviously to add properties to your classes via the `UnitProperty`
    class, which has the following signature:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: The `type` parameter is a Python type. Dejavu takes care of translating it into
    the appropriate SQL equivalent type transparently.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The `index` parameter indicates whether the column should be indexed by the
    RDBMS if it supports it.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The `hints` parameter is a dictionary to help Dejavu storage managers to optimize
    the creation of the column. Dejavu has three built-in hints but you can provide
    yours if you create your own storage manager:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`bytes:` Indicates the number of bytes to be used for a unicode property, 0
    meaning unlimited.'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '`scale:` Number of digits to the right of the decimal point in a numeric column.'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '`precision:` Total number of digits in a numeric column.'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: The `key` parameter is the property canonical name.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The `default` parameter indicates the default value to be used.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Properties will map into the columns of a table in the relational database.
  prefs: []
  type: TYPE_NORMAL
- en: Associating Units
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Associating units is the means of giving a shape to your design. Entities are
    bricks, relations are the mortar.
  prefs: []
  type: TYPE_NORMAL
- en: 'Dejavu supports the following common relationships:'
  prefs: []
  type: TYPE_NORMAL
- en: One to one (1, 1)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: One to many (1, n)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Many to one (n, 1)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'In each case you provide the signature as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: 'Therefore the relation between `Film` and `Photo` is:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: The `nearClass` is `Film`, the `nearKey` is `ID` (property of the `nearClass`),
    the `farClass` is `Photo`, and the `farKey` is `film_id` (property of the `farClass`).
  prefs: []
  type: TYPE_NORMAL
- en: Dejavu does not provide a native many-to-many relationship but this is achievable
    through a third unit class and a one-to-one relationship.
  prefs: []
  type: TYPE_NORMAL
- en: The Sandbox Interface
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The `sandbox` object manages memory dedicated to units in a protected way. A
    `sandbox` is where units spend their life. There are two ways to create `sandboxes:`
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: The former version is the most common and is the one we will use throughout
    this book.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s review a few key methods of the `sandbox` interface:'
  prefs: []
  type: TYPE_NORMAL
- en: '`memorize:` When you create a new instance of a unit, it exists only in memory
    and is separated from the storage manager. You need to call the `memorize` method
    to make it part of the `sandbox`. This will also set the `ID` of the unit. Additionally
    this will reserve a place in the underlying database by issuing an `INSERT INTO
    SQL` statement.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`forget:` In order to tell the store manager to stop managing a unit you must
    call the `forget` method. This will delete it from the `sandbox` and from the
    storage manager.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`repress:` In some cases you may wish to clear the unit from the `sandbox`
    but not from the store manager. In such cases you should use the `repress` method.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`recall, xrecall:` These two methods allow you to retrieve units based on filters
    (as we will explain in the section *Querying Units)*. The difference between `recall`
    and `xrecall` is that the latter yields results in an iterating fashion whereas
    the former loads everything into a list at once.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`unit:` Both the previous methods are powerful ones to retrieve a set of data
    but they can be heavy when you simply look for one unit based on a value of its
    properties. This is what the `unit` method provides.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`flush_all:` Once you have manipulated your units you have to call `flush_all`
    in order to make those changes to the physical back end.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: As you can see, the interface provided by the `Sandbox` class is quite simple,
    straightforward, and yet powerful as the next section will demonstrate.
  prefs: []
  type: TYPE_NORMAL
- en: Querying Units
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We have seen so far how to map our entities into units as well as how to manipulate
    those units. This section will explain in detail how to query the storage manager
    for units based on criteria.
  prefs: []
  type: TYPE_NORMAL
- en: Within Dejavu querying is done through an `Expression` instance. The `Expression`
    class is a filter for units. Let's take an example to explain how this works.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: The first step is to create a function that returns a `bool`. That function
    is usually a `lambda` as there is no need to pollute the Python namespace with
    meaningless names. Then we pass it to one of the `sandbox` methods such as `recall`
    or `xrecall`, which will create a `logic.Expression` instance and apply it.
  prefs: []
  type: TYPE_NORMAL
- en: Expressions show their value when filtering against complex queries such as
    the one involving JOIN. For example, if you want to join between units you would
    use Python operators between the units themselves.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: As you can see, the first parameter of the method takes an aggregation of the
    unit classes that will take part in the join. Dejavu gives you the opportunity
    of using Python operators to declare aggregation between units.
  prefs: []
  type: TYPE_NORMAL
- en: When composing between units, the order is important while constructing the
    `filter` function. In the previous example the `lambda` function parameters will
    match the order of the composed units. This behavior is mirrored by the result
    returned by the `recall()` method, which will provide a list of `Album` and `Photo`
    items.
  prefs: []
  type: TYPE_NORMAL
- en: Below are the Dejavu representations of SQL JOINs.
  prefs: []
  type: TYPE_NORMAL
- en: '| Join Type | Operator | Description |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| Inner | & or + | All related pairs of both classes will be returned. |'
  prefs: []
  type: TYPE_TB
- en: '| Left Outer | << | All related pairs of both classes will be returned. In
    addition, if any Unit in class1 has no match in class2, we return a single row
    with Unit1 and a **null Unit** (a Unit, all of whose properties are None). |'
  prefs: []
  type: TYPE_TB
- en: '| Right Outer | >> | All related pairs of both classes will be returned. In
    addition, if any Unit in class2 has no match in class1, we return a single row
    with a null Unit (a Unit, all of whose properties are None) and Unit2. |'
  prefs: []
  type: TYPE_TB
- en: 'There is no limitation from Dejavu regarding the aggregation you build. For
    instance you can write:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: Extending the Data Access Layer
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In the previous sections, we have defined the mapping between our entities and
    the classes our application will manipulate. As they stand these classes are not
    very useful; in this section we will see how to extend them to provide more functionalities.
    To keep this section concise, we will only discuss the `Album` class.
  prefs: []
  type: TYPE_NORMAL
- en: 'Methods to be added to the Album class:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: As you can see, the `Album` class now contains enough methods to allow manipulation
    of `Album` instances. The other photoblog entities share the same idea and will
    provide similar interfaces.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: This chapter has introduced the backbone of our photoblog application through
    the description of its entities and how they are mapped in their Python counterparts.
    Our next chapter will review how to manipulate those entities from our CherryPy
    handlers to build the external interface of our application.
  prefs: []
  type: TYPE_NORMAL
