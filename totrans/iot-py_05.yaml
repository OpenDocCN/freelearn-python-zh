- en: Chapter 5. Working with Digital Inputs, Polling and Interrupts
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In this chapter, we will use digital inputs to make it possible for users to
    interact with the board while we process the HTTP requests. We will:'
  prefs: []
  type: TYPE_NORMAL
- en: Understand the difference between pull-up and pull-down resistors to connect
    pushbuttons
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Wire digital input pins with pushbuttons
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Use polling to check the pushbutton status with the `mraa` and `wiring-x86`
    libraries
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Combine polling to read digital inputs while running a RESTful API
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Write code that maintains consistency when we provide shared features with electronic
    components and APIs
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Use interrupts and the `mraa` library to detect pressed pushbuttons
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Understand the differences, advantages, and trade-offs between polling and interrupts
    to detect changes in digital inputs
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Understanding pushbuttons and pullup resistors
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'We controlled the brightness levels for red, green, and blue LEDs with a RESTful
    API. Then, we replaced the three LEDs with a single RGB LED and generated lights
    of different colors with the same RESTful API. Now, we want to make it possible
    for the users to change the brightness level for the three components with two
    pushbuttons added to the breadboard:'
  prefs: []
  type: TYPE_NORMAL
- en: A pushbutton to turn off all the colors, that is, to set all the colors to a
    brightness level equal to 0
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A pushbutton to set all the colors to their maximum brightness levels, that
    is, to set all the colors to a brightness level equal to 255
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: When the user presses the pushbutton, also known as a microswitch, it acts like
    a wire, and therefore, it lets the current flow through the circuit in which it
    is incorporated. When the pushbutton isn't pressed, the circuit in which it is
    incorporated is interrupted. Thus, whenever the user releases the pushbutton,
    the circuit is interrupted. Obviously, we don't want to short circuit the connection
    whenever the user presses a pushbutton, and therefore, we will analyze the different
    possible ways to safely connect a pushbutton to an Intel Galileo Gen 2 board.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following picture shows one of the ways in which we can connect a pushbutton
    to an Intel Galileo Gen 2 board and uses the GPIO pin number **0** as an input
    to determine whether the pushbutton is pressed or not. The Fritzing file for the
    sample is `iot_fritzing_chapter_05_01.fzz` and the following picture is the breadboard
    view:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Understanding pushbuttons and pullup resistors](img/B05042_05_01.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'The following picture shows the schematic with the electronic components represented
    as symbols:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Understanding pushbuttons and pullup resistors](img/B05042_05_02.jpg)'
  prefs: []
  type: TYPE_IMG
- en: As seen in the previous schematic, the GPIO pin labeled **D0/RX**, in the board's
    symbol, is connected to a 120Ω resistor with 5% tolerance (brown red brown gold),
    and wired to the **IOREF** pin. We already know that the pin labeled **IOREF**
    provides us the IOREF voltage, that is, 5V in our actual configuration. As we
    might want to work with other voltage configuration in the future, we can always
    work with the IOREF pin instead of specifically using the **5V** or the **3V3**
    pins. The GPIO pin labeled **D0/RX** in the board's symbol is also connected to
    the **S1** pushbutton, wired to the 120Ω resistor and **GND** (ground).
  prefs: []
  type: TYPE_NORMAL
- en: Tip
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The configuration is known as a voltage divider and the 120Ω resistor is called
    a pull-up resistor.
  prefs: []
  type: TYPE_NORMAL
- en: The pull-up resistor limits the electric current when we press the **S1** pushbutton.
    As an effect of the pull-up resistor, if we press the **S1** pushbutton, we will
    read a low value (0V) in the GPIO pin labeled **D0/RX**. When we release the S1
    pushbutton, we will read a high value, that is, the IOREF voltage (5V in our actual
    configuration).
  prefs: []
  type: TYPE_NORMAL
- en: The situation might be confusing because we read a low value when the button
    in pressed. However, we can write object-oriented code to encapsulate the behavior
    for a pushbutton and work with easier to understand states that isolate the way
    in which the pull-up resistor works.
  prefs: []
  type: TYPE_NORMAL
- en: 'It is also possible to work with a pull-down resistor. We can connect the 120Ω
    resistor to ground and transform it from a pull-up resistor into a pull-down resistor.
    The following picture shows how we can connect a pushbutton to an Intel Galileo
    Gen 2 board with a pull-down resistor and use the GPIO pin number **0** as an
    input to determine whether the pushbutton is pressed or not. The Fritzing file
    for the sample is `iot_fritzing_chapter_05_02.fzz` and the following picture is
    the breadboard view:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Understanding pushbuttons and pullup resistors](img/B05042_05_03.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'The following picture shows the schematic with the electronic components represented
    as symbols:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Understanding pushbuttons and pullup resistors](img/B05042_05_04.jpg)'
  prefs: []
  type: TYPE_IMG
- en: As seen in the previous schematic, in this case, the GPIO pin labeled **D0/RX**
    in the board's symbol is connected to the **S1** pushbutton and the **IOREF**
    pin. The other connector of the S1 pushbutton is wired to the 120Ω resistor and
    this resistor is wired to **GND** (ground).
  prefs: []
  type: TYPE_NORMAL
- en: Tip
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: In this configuration, the 120Ω resistor is called a pull-down resistor.
  prefs: []
  type: TYPE_NORMAL
- en: The pull-down resistor limits the electric current when we press the **S1**
    pushbutton. As an effect of the pull-down resistor, if we press the **S1** pushbutton,
    we will read a high value, that is, the IOREF voltage (5V in our actual configuration)
    in the GPIO pin labeled **D0/RX**. When we release the **S1** pushbutton, we will
    read a low value (0V). Thus, the pull-down resistor works with the inverse values
    we read when we use a pull-up resistor.
  prefs: []
  type: TYPE_NORMAL
- en: Wiring digital input pins with pushbuttons
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Now, we will use the following pins to connect the two pushbuttons and we will
    work with pull-up resistors:'
  prefs: []
  type: TYPE_NORMAL
- en: Pin **1** (labeled **D1/TX**) to connect the pushbutton that turns off the three
    colors
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Pin **0** (labeled **D0/RX**) to connect the pushbutton that sets the three
    colors to their maximum brightness levels
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'After we finish the necessary wirings, we will write the Python code to check
    whether each pushbutton was pressed while keeping our RESTful API working as expected.
    This way, we will make it possible for the user to interact with the RGB LED with
    the pushbuttons and also with the RESTful API. We need the following additional
    parts to work with this example:'
  prefs: []
  type: TYPE_NORMAL
- en: Two pushbuttons with two pins
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Two 120Ω resistors with 5% tolerance (brown red brown gold)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The following diagram shows the components connected to the breadboard, the
    necessary wirings and the wirings from the Intel Galileo Gen 2 board to the breadboard.
    The Fritzing file for the sample is `iot_fritzing_chapter_05_03.fzz` and the following
    picture is the breadboard view:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Wiring digital input pins with pushbuttons](img/B05042_05_05.jpg)'
  prefs: []
  type: TYPE_IMG
- en: The following picture shows the schematic with the electronic components represented
    as symbols.
  prefs: []
  type: TYPE_NORMAL
- en: '![Wiring digital input pins with pushbuttons](img/B05042_05_06.jpg)'
  prefs: []
  type: TYPE_IMG
- en: As seen in the previous schematic, we added two pushbuttons (**S1** and **S2**)
    and two 120Ω pull-up resistors (**R4** and **R5**). The GPIO pin labeled **D0/RX**
    in the board's symbol is connected to the **S2** pushbutton and the **R4** resistor
    is its pull-up resistor. The GPIO pin labeled **D1/TX** in the board's symbol
    is connected to the **S1** pushbutton and the R5 resistor is its pull-up resistor.
    This way, GPIO pin number 0 will be low when the **S2** pushbutton is pressed
    and GPIO pin number 1 will be low when the **S1** pushbutton is pressed. The **S1**
    pushbutton is located at the left-hand side in the breadboard while the **S2**
    pushbutton is located at the right-hand side.
  prefs: []
  type: TYPE_NORMAL
- en: Now, it is time to insert the components in the breadboard and make all the
    necessary wirings. Don't forget to shutdown the Yocto Linux, wait for all the
    onboard LEDs to turn off, and unplug the power supply from the Intel Galileo Gen
    2 board before adding or removing any wire from the board's pins.
  prefs: []
  type: TYPE_NORMAL
- en: Reading pushbutton statuses with digital inputs and the mraa library
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We will create a new `PushButton` class to represent a pushbutton connected
    to our board that can use either a pull-up or a pull-down resistor. The following
    lines show the code for the new `PushButton` class that works with the `mraa`
    library. The code file for the sample is `iot_python_chapter_05_01.py`.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: We have to specify the pin number to which the pushbutton is connected when
    we create an instance of the `PushButton` class in the `pin` required argument.
    In case we don't specify additional values, the optional `pull_up` argument will
    be `True` and the instance will work as if the pushbutton were connected with
    a pull-up resistor. If we work with a pull-down resistor, we must pass `False`
    in the `pull_up` argument. The constructor, that is, the `__init__` method, creates
    a new `mraa.Gpio` instance with the received `pin` as its `pin` argument, saves
    its reference in the `gpio` attribute and calls its `dir` method to configure
    the pin to be an input pin (`mraa.DIR_IN`).
  prefs: []
  type: TYPE_NORMAL
- en: 'The class defines the following two properties:'
  prefs: []
  type: TYPE_NORMAL
- en: '`is_pressed`: Calls the `read` method for the related `mraa.Gpio` instance
    to retrieve the value from the pin and saved it in the `push_button_status` variable.
    If the pushbutton is connected with a pull-up resistor (`self.pull_up` is `True`),
    the code will return `True`, indicating that the pushbutton is pressed if the
    value in `push_button_status` is `0` (low value). If the pushbutton is connected
    with a pull-down resistor (`self.pull_up` is `False`), the code will return `True`,
    indicating that the pushbutton is pressed if the value in `push_button_status`
    is `1` (high value).'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`is_released`: Returns the inverted result of the `is_pressed` property.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Now, we can write code that uses the new `PushButton` class to create one instance
    for each of the two pushbuttons and easily check whether they are pressed or not.
    The new class handles whether the pushbuttons are connected with pull-up or pull-down
    resistors, and therefore, we just need to check the value of the `is_pressed`
    or `is_released` properties without worrying about the specific details about
    their connection.
  prefs: []
  type: TYPE_NORMAL
- en: We will integrate the code that considers the statuses of the two pushbuttons
    in our RESTful API later. First, we will isolate the two pushbuttons in a simple
    example to understand how we can read their statuses. In this case, we will use
    polling, that is, a loop that will check whether the pushbuttons are pressed or
    not. If a pushbutton is pressed, we want the code to print a message in the console
    output indicating the specific pushbutton that is being pressed.
  prefs: []
  type: TYPE_NORMAL
- en: The following lines show the Python code that performs the previously explained
    actions. The code file for the sample is `iot_python_chapter_05_01.py`.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: 'The first two lines create two instances of the previously coded `PushButton`
    class. The **S1** pushbutton is connected to GPIO pin number 1 and the **S2**
    pushbutton is connected to GPIO pin number 0\. In both cases, the code doesn''t
    specify a value for the `pull_up` argument. Thus, the constructor, that is, the
    `__init__` method, will use the default value for this argument, `True`, and the
    instance will be configured for a pushbutton connected with a pull-up resistor.
    We need to worry about this when we create the two instances, and then, we work
    with the names of the variables that hold the instances: `s1_push_button` and
    `s2_push_button`.'
  prefs: []
  type: TYPE_NORMAL
- en: Then, the code runs in a loop forever, that is, until you interrupt the execution
    by pressing *Ctrl* + *C* or the button to stop the process, in case you are using
    a Python IDE with remote development features to run the code in your board.
  prefs: []
  type: TYPE_NORMAL
- en: The first line within the `while` loop checks the value of the `is_pressed`
    property for the `PushButton` instance named `s1_push_button` is `True`. A `True`
    value means that the pushbutton is pressed at this time, and therefore, the code
    prints a message to the console output indicating that the S1 pushbutton is being
    pressed. The next lines within the while loop follow the same procedure for the
    `PushButton` instance named `s2_push_button`.
  prefs: []
  type: TYPE_NORMAL
- en: After we check the statuses for both the pushbuttons, a call to `time.sleep`
    with `0.5` as the value for the second argument delays the execution for 500 milliseconds,
    that is, 0.5 seconds.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following line will start the example; don''t forget that you need to transfer
    the Python source code file to the Yocto Linux with an SFTP client:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: 'After you run the example, perform the following actions:'
  prefs: []
  type: TYPE_NORMAL
- en: Press the S1 pushbutton for 1 second
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Press the S2 pushbutton for 1 second
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Press both the S1 and S2 pushbuttons for one second
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'As a result of the previous actions, you will see the following output:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: In this case, we are reading digital inputs with polling. The `mraa` library
    also allows us to work with interrupts and declare interrupt handlers with Python.
    This way, whenever a user presses a button, the event generates an interrupt and
    the `mraa` library calls the specified interrupt handler. If you have ever worked
    with event-based programming, you can think about events and event handlers instead
    of interrupts and interrupt handlers and you will easily understand how things
    work.
  prefs: []
  type: TYPE_NORMAL
- en: The interrupt handlers run in a different thread, and the code you can write
    for them has many limitations. For example, you cannot use the basic types within
    interrupt handlers. Thus, in this case, it doesn't make sense to work with interrupts
    and polling makes things easier for us due to the tasks that we have to execute
    when the user presses any of the two buttons.
  prefs: []
  type: TYPE_NORMAL
- en: 'Reading digital inputs with polling as in the previous example has the following
    advantages compared with the usage of interrupts for the same task:'
  prefs: []
  type: TYPE_NORMAL
- en: The code is easy to understand and read
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The flow is easy to understand and we don't have to worry about code running
    in callbacks
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: We can write all the necessary code to perform actions when the button is pressed
    without worrying about specific limitations related to interrupt callbacks
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: We don't have to worry about code running in multiple threads
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'However, reading digital inputs with polling has the following disadvantages
    compared with the usage of interrupts for the same task:'
  prefs: []
  type: TYPE_NORMAL
- en: If we don't keep the pushbutton pressed for a specific amount of time, the code
    might not detect that the pushbutton has been pressed.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: If we keep the pushbutton pressed for a long time, the code will behave as if
    the pushbutton was pressed many times. Sometimes, we don't want this situation
    to happen.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The loop consumes more resources that we can require for other tasks compared
    with an interrupt triggered event.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: In this case, we want users to keep any of the two buttons pressed for at least
    half a second, and therefore, we don't need the advantages of interrupts. However,
    we will use interrupts later in this chapter.
  prefs: []
  type: TYPE_NORMAL
- en: Reading pushbutton statuses and running a RESTful API
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Now, we will integrate the code that checks the statuses of the two pushbuttons
    in our RESTful API. We want to be able to make HTTP requests to the RESTful API
    and we also want to be able to use the two buttons we have added to the breadboard.
  prefs: []
  type: TYPE_NORMAL
- en: We have to make Tornado run a periodic callback and write the code that checks
    the statuses of the two pushbuttons in this callback. We will take the code we
    wrote in the previous chapter when we created the last version of our RESTful
    API with the `mraa` library and we will use this code as a baseline to add the
    new features. The code file for the sample was `iot_python_chapter_04_03.py`.
  prefs: []
  type: TYPE_NORMAL
- en: We will add two class attributes and three class methods to the existing `BoardInteraction`
    class. The code file for the sample is `iot_python_chapter_05_02.py`.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: 'The previous code adds two class attributes to the `BoardInteraction` class:
    `reset_push_button` and `max_brightness_push_button`. The `reset_push_button`
    class attribute is an instance of `PushButton` with its `pin` attribute set to
    `1`. This way, the instance can check the status of the pushbutton connected to
    GPIO pin number 1\. The `max_brightness_push_button` class attribute is an instance
    of `PushButton` with its `pin` attribute set to `0`, and therefore, this instance
    can check the status of the pushbutton connected to GPIO pin number 0\. In addition,
    the previous code adds the following class methods to the `BoardInteraction` class:'
  prefs: []
  type: TYPE_NORMAL
- en: '`set_min_brightness`: Calls the `set_brightness` method with `0` as an argument
    for the three `AnalogLed` instances saved in the `red_led`, `green_led` and `blue_led`
    class attributes. This way, the three components of the RGB LED will be turned
    off.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`set_max_brightness`: Calls the `set_brightness` method with `255` as an argument
    for the three `AnalogLed` instances saved in the `red_led`, `green_led` and `blue_led`
    class attributes. This way, the three components of the RGB LED will be turned
    on with their maximum brightness levels.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`check_push_buttons_callback`: First, checks whether the reset pushbutton is
    pressed by evaluating the value of the `is_pressed` property for the `PushButton`
    instance that represents the reset pushbutton, that is, `cls.reset_push_button`.
    In case the value for the property is `True`, the code prints a message indicating
    that you are pressing the reset pushbutton and calls the previously described
    `cls.set_min_brightness` class method to turn off the three components of the
    RGB LED. Then, the code checks whether the maximum brightness pushbutton is pressed
    by evaluating the value of the `is_pressed` property for the `PushButton` instance
    that represents the maximum brightness pushbutton, that is, `cls.max_brightness_push_button`.
    In case the value for the property is `True`, the code prints a message indicating
    that you are pressing the maximum brightness pushbutton and calls the previously
    described `cls.set_max_brightness` class method to turn on the three components
    of the RGB LED with their maximum brightness levels.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Tip
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: It is necessary to add the `@classmethod` decorator before the class method
    header to declare class methods in Python. Instance methods receive `self` as
    the first argument, but class methods receive the current class as the first argument
    and the parameter name is usually called `cls`. In the previous code, we have
    been using `cls` to access the class attributes and class methods for the `BoardInteraction`
    class.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following lines show the new classes that we must add to our existing code
    to make it possible to set the minimum and maximum brightness with HTTP requests.
    We want to be able to have the same features we can command with pushbuttons available
    in our RESTful API. The code adds the following two classes: `PutMinBrightnessHandler`
    and `PutMaxBrightnessHandler`. The code file for the sample is `iot_python_chapter_05_02.py`.'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: 'The code declares the following two subclasses of `tornado.web.RequestHandler`:'
  prefs: []
  type: TYPE_NORMAL
- en: '`PutMinBrightnessHandler`: Defines the `put` method that calls the `set_min_brightness`
    class method for the `BoardInteraction` class. Then, the code returns a response
    with the minimum brightness levels that have been translated to output duty cycle
    percentages in the PWM pins to which the red, green and blue anodes of the RGB
    LED are connected to.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`PutMaxBrightnessHandler`: Defines the `put` method that calls the `set_max_brightness`
    class method for the `BoardInteraction` class. Then, the code returns a response
    with the maximum brightness levels that have been translated to output duty cycle
    percentages in the PWM pins to which the red, green and blue anodes of the RGB
    LED are connected to.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Now, it is necessary to add the highlighted lines to the code that creates an
    instance of the `tornado.web.Application` class named `application` with the list
    of request handlers that make up the Web application, that is, the tuples of regular
    expressions and subclasses of `tornado.web.RequestHandler`. The code file for
    the sample is `iot_python_chapter_05_02.py`.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: As shown in our previous example, the code creates an instance of the `tornado.web.Application`
    class named `application` with the list of request handlers that make up the Web
    application, that is, the tuples of regular expressions and subclasses of `tornado.web.RequestHandler`.
  prefs: []
  type: TYPE_NORMAL
- en: Finally, it is necessary to replace the `__main__` method with a new one because
    we want to run a periodic callback to check whether any of the two pushbuttons
    was pressed. The code file for the sample is `iot_python_chapter_05_02.py`.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: As happened in the previous examples, the `__main__` method calls the `application.listen`
    method to build an HTTP server for the application with the defined rules on the
    port number `8888`. Then, the code retrieves the global `IOLoop` instance and
    saves it in the `ioloop` local variable. We have to use the instance as one of
    the arguments to create a `tornado.ioloop.PeriodicCallback` instance named `periodic_callback`.
  prefs: []
  type: TYPE_NORMAL
- en: The `PeriodicCallback` instance allows us to schedule a specified callback to
    be called periodically. In this case, we specify the `BoardInteraction.check_push_buttons_callback`
    class method as the callback that will be called every 500 milliseconds. This
    way, we instruct Tornado to run the `BoardInteraction.check_push_buttons_callback`
    class method every 500 milliseconds. In case the method takes more than 500 milliseconds
    to complete its execution, Tornado will skip subsequent invocations to get back
    on schedule. After the code creates the `PeriodicCallback` instance, the next
    line calls its `start` method.
  prefs: []
  type: TYPE_NORMAL
- en: Finally, the call to `ioloop.start()` starts the server created with `application.listen`.
    This way, the Web application will process the received requests and will also
    run a callback to check whether the buttons are pressed.
  prefs: []
  type: TYPE_NORMAL
- en: The following line will start the HTTP server and our new version of the RESTful
    API. Don't forget that you need to transfer the Python source code file to the
    Yocto Linux with an SFTP client.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: 'After you run the example, press the pushbutton that sets the colors to their
    maximum brightness for one second. The RGB LED will display a white light and
    you will see the following output:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, press the pushbutton that sets the colors to their minimum brightness
    for one second. The RGB LED will turn off and you will see the following output:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: 'With the new RESTful API we can compose the following HTTP verb and request
    URL:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: 'The previous request path will match the previously added tuple (`regexp`,
    `request_class`) `(r"/putmaxbrightness", PutMaxBrightnessHandler)` and Tornado
    will call the `PutMaxBrightnessHandler.put` method. The RGB LED will display a
    white light, as happened when you pressed the maximum brightness button. The following
    lines show the response from the HTTP server with the brightness levels that have
    been set for the three LEDs:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: 'The following HTTP verb and request URL will turn off the RGB LED, as happened
    when we pressed the pushbutton that sets the colors to their minimum brightness:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: 'The following lines show the response from the HTTP server with the brightness
    levels that have been set for the three LEDs:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: Now, press the pushbutton that sets the colors to their maximum brightness for
    one second. The RGB LED will display a white light. Then, the following three
    HTTP verbs and request URLs will retrieve the brightness level for each of the
    colors. All the requests will return `255` as the current value. We set the brightness
    level with the pushbutton, but the code has the same effect as if we were making
    API calls to change the colors. We kept the consistency for our application.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: 'If we work with HTTPie, the following commands will do the job:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: 'The following lines show the responses from the three requests:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: We created methods that we could use in both an API call and when the user presses
    the pushbuttons. We can process HTTP requests and run actions when the user presses
    pushbuttons. As we build our RESTful API with Tornado, we had to create and configure
    a `PeriodicCallback` instance to make it possible to check whether the pushbuttons
    are pressed every 500 milliseconds.
  prefs: []
  type: TYPE_NORMAL
- en: Tip
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: It is very important to take into account consistency when we add features that
    we can control with pushbuttons or other electronic components that interact with
    the board. In this case, we made sure that when the user pressed the pushbuttons
    and changed the brightness values for the three colors, the brightness values
    read with API calls were exactly the values set. We worked with object-oriented
    code and with the same methods, and therefore, it was easy to keep consistency.
  prefs: []
  type: TYPE_NORMAL
- en: Reading digital inputs with the wiring-x86 library
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: So far, we have been using the `mraa` library to read digital inputs. However,
    in the first chapter, we also installed the `wiring-x86` library. We can change
    just a few lines of our object-oriented code to replace the `mraa` library with
    the `wiring-x86` one to check whether the pushbuttons were pressed.
  prefs: []
  type: TYPE_NORMAL
- en: We will take the code we wrote in the previous chapter when we created the last
    version of our RESTful API with the `wiring-x86` library and we will use this
    code as a baseline to add the new features. The code file for the sample was `iot_python_chapter_04_04.py`.
  prefs: []
  type: TYPE_NORMAL
- en: First, we will create a new version of the `PushButton` class to represent a
    pushbutton connected to our board that can use either a pull-up or a pull-down
    resistor. The following lines show the code for the new `PushButton` class that
    works with the `wiring-x86` library. The code file for the sample is `iot_python_chapter_05_03.py`.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: We just needed to change a few lines from the previous code of the `PushButton`
    class, that is, the version that worked with the `mraa` library. The new lines
    that interact with the `wiring-x86` library are highlighted in the previous code.
    The constructor, that is, the `__init__` method receives the same argument as
    the `PushButton` class that worked with the `mraa` library. In this case, this
    method saves a reference to the `Board.gpio` class attribute in `self.gpio`. Then,
    the code determines the value of the `pin_mode` local variable based on the value
    of the `pull_up` parameter. If `pull_up` is `true`, the value will be `self.gpio.INPUT_PULLUP`
    and `self.gpio.INPUT_PULLDOWN` otherwise. Finally, the constructor calls the `self.gpio.pinMode`
    method with the received `pin` as its `pin` argument and `pin_mode` as its mode
    argument. This way, we configure the pin to be a digital input pin with the appropriate
    pull-up or pull-down resistor. All the `PushButton` instances will save a reference
    to the same `Board.gpio` class attribute that created an instance of the `GPIO`
    class, specifically, the `wiringx86.GPIOGalileoGen2` class with its `debug` argument
    set to `False` to avoid unnecessary debug information for the low-level communications.
  prefs: []
  type: TYPE_NORMAL
- en: The `is_pressed` property calls the `digitalRead` method for the GPIO instance
    (`self.gpio`) to set retrieve the digital value for the pin configured as a digital
    input. The `self.pin` attribute specifies the `pin` value for the `analogRead`
    method call. The rest of the code for the `is_pressed` property and the `PushButton`
    class remains the same as the version that works with the `mraa` library.
  prefs: []
  type: TYPE_NORMAL
- en: Then, it is necessary to make the same edits we made in the previous example
    to create the new version of the `BoardInteraction` class, add the `PutMinBrightnessHandler`
    and `PutMaxBrightnessHandler` classes, create the `tornado.web.Application` instance
    and the new version of the `__main__` method that created and configured the `PeriodicCallback`
    instance. Thus, the rest of the code for our RESTful API remains the same one
    that we have used for the previous example. There is no need to make changes to
    the rest of the code because it will automatically work with the new `PushButton`
    class and there were no changes in the arguments for its constructor or its properties.
  prefs: []
  type: TYPE_NORMAL
- en: The following line will start the HTTP server and our new version of the RESTful
    API that works with the `wiring-x86` library. Don't forget that you need to transfer
    the Python source code file to the Yocto Linux with an SFTP client, as explained
    in the previous chapter.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: Tip
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: We can press the pushbuttons and then make the same HTTP requests we made in
    our previous example to check that we can achieve exactly the same results with
    the `wiring-x86` library.
  prefs: []
  type: TYPE_NORMAL
- en: Using interrupts to detect pressed pushbuttons
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Previously, we analyzed the advantages of disadvantages of reading digital inputs
    with polling as in the previous examples compared with the usage of interrupts
    for the same task. If we keep any of the pushbuttons pressed for a long time,
    the code behaves as if the pushbutton was pressed many times. Now, we don't want
    this situation to happen, and therefore, we will use interrupts instead of polling
    to detect when the pushbuttons are pressed.
  prefs: []
  type: TYPE_NORMAL
- en: Before we start editing our code, it is necessary to make changes to our existing
    wirings. The problem is that not all the GPIO pins support interrupts. In fact,
    pins number 0 and 1 don't support interrupts and we have our pushbuttons connected
    to them. In [Chapter 1](ch01.html "Chapter 1. Understanding and Setting up the
    Base IoT Hardware"), *Understanding and Setting up the Base IoT Hardware* when
    we learned about the I/O pins included in the Intel Galileo Gen 2 board, we understood
    that the pins labeled with a tilde symbol (**~**) as a prefix for the number can
    be used as PWM output pins. The fact is that the pins labeled with a tilde symbol
    (**~**) as a prefix for the number also supports interrupts.
  prefs: []
  type: TYPE_NORMAL
- en: Thus, we can move the wire that connects the reset pushbutton that turns off
    the three colors from pin **1** to pin **~11**, and move the wire that connects
    the pushbutton that sets the three colors to their maximum brightness from pin
    **0** to pin **~10**.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following diagram shows the components connected to the breadboard, the
    necessary wirings and the wirings from the Intel Galileo Gen 2 board to the breadboard.
    The Fritzing file for the sample is `iot_fritzing_chapter_05_04.fzz` and the following
    picture is the breadboard view:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Using interrupts to detect pressed pushbuttons](img/B05042_05_07.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'The following picture shows the schematic with the electronic components represented
    as symbols:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Using interrupts to detect pressed pushbuttons](img/B05042_05_08.jpg)'
  prefs: []
  type: TYPE_IMG
- en: The GPIO pin labeled **D10 PWM/SS** in the board's symbol is connected to the
    **S2** pushbutton and the **R4** resistor is its pull-up resistor. The GPIO pin
    labeled **D11 PWM/MOSI** in the board's symbol is connected to the **S1** pushbutton
    and the **R5** resistor is its pull-up resistor. This way, GPIO pin number 10
    will be low when the **S2** pushbutton is pressed and GPIO pin number 11 will
    be low when the **S1** pushbutton is pressed.
  prefs: []
  type: TYPE_NORMAL
- en: Tip
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The signal will fall from high to low when the pushbutton is pressed, and therefore,
    we are interested in the interrupt that is generated when the signal falls because
    it indicates that the pushbutton has been pressed. If the user keeps the pushbutton
    pressed, the signal won't fall many times, and the GPIO pin will stay in the low
    level. Thus, only one interrupt will be fired when we are observing the fall from
    high to low and we won't have multiple calls to the interrupt handler code even
    if the user keeps the button pressed for a long time.
  prefs: []
  type: TYPE_NORMAL
- en: Remember that the **S1** pushbutton is located at the left-hand side in the
    breadboard while the **S2** pushbutton is located at the right-hand side. Now,
    it is time to make the changes to the wirings. Don't forget to shutdown the Yocto
    Linux, wait for all the onboard LEDs to turn off, and unplug the power supply
    from the Intel Galileo Gen 2 board before removing any wire from the board's pins.
    After we finish the changes in the wirings, we will write the Python code to detect
    when the user presses the pushbuttons with interrupts instead of working with
    polling.
  prefs: []
  type: TYPE_NORMAL
- en: We will take the code we wrote in the previous example when we created the last
    version of our RESTful API with the `mraa` library and we will use this code as
    a baseline to add the new features. The code file for the sample was `iot_python_chapter_05_02.py`.
  prefs: []
  type: TYPE_NORMAL
- en: We will create a new `PushButtonWithInterrupt` class to represent a pushbutton
    connected to our board that can use either a pull-up or a pull-down resistor and
    will specify the callback that needs to be called when the button is pressed,
    that is, the interrupt handler. When the button is pressed, an interrupt will
    occur and the specified callback will be executed as the interrupt handler. The
    following lines show the code for the new `PushButtonWithInterrupt` class that
    works with the `mraa` library. The code file for the sample is `iot_python_chapter_05_04.py`.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: 'We have to specify the following arguments when we create an instance of the
    `PushButtonWithInterrupt` class:'
  prefs: []
  type: TYPE_NORMAL
- en: The pin number to which the pushbutton is connected in the `pin` argument
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The function that will be called when the interrupt is triggered, that is, the
    interrupt handler function, in the `pyfunc` argument
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The arguments that will be passed to the interrupt handler function, in the
    `args` argument
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: In case we don't specify additional values, the optional `pull_up` argument
    will be `True` and the instance will work as if the pushbutton were connected
    with a pull-up resistor. If we work with a pull-down resistor, we must pass `False`
    in the `pull_up` argument.
  prefs: []
  type: TYPE_NORMAL
- en: The constructor, that is, the `__init__` method, creates a new `mraa.Gpio` instance
    with the received `pin` as its `pin` argument, saves its reference in the `gpio`
    attribute and calls its `dir` method to configure the pin to be an input pin (`mraa.DIR_IN`).
    Then, the code determines the value of the `mode` local variable based on the
    value of the `pull_up` parameter. If `pull_up` is `true`, the value will be `mraa.EDGE_FALLING`
    and `mraa.EDGE_RISING` otherwise. The `mode` local variable holds the edge mode
    that will trigger the interrupt. When we work with pull-up resistors and the user
    presses a pushbutton, the signal will fall from high to low, and therefore, we
    want an edge falling scenario to trigger the interrupt that indicates the button
    has been pressed.
  prefs: []
  type: TYPE_NORMAL
- en: Then, the code calls the `self.gpio.isr` method with the received `pin` as its
    `pin` argument, the local `mode` variable as its `mode` argument, and the received
    `pyfunc` and `args` as its `pyfunc` and `args` arguments. This way, we set the
    callback to be called when the pin value changes because a pushbutton was pressed.
    As we determined the appropriate value for the `mode` local variable before, we
    will configure the appropriate edge mode that will trigger an interrupt when the
    button is pressed based on the usage of pull-up or pull-down resistors. As previously
    explained, not all the GPIO pins support interrupts, and therefore, it is necessary
    to check the results of calling the `self.gpio.isr` method. In case an interrupt
    handler has already been set to the pin with a previous call to the `self.gpio.isr`
    method wouldn't return an `mraa.SUCCESS` value.
  prefs: []
  type: TYPE_NORMAL
- en: The `PushButtonWithInterrupt` class also declares a `__del__` method that will
    be called before Python removes an instance of this class from memory, that is,
    when the object becomes inaccessible and gets deleted by the garbage-collection
    mechanism. The method just calls the `self.gpio.isrExit` method to remove the
    interrupt handler associated to the pin.
  prefs: []
  type: TYPE_NORMAL
- en: We will replace the two class attributes in the existing `BoardInteraction`
    class. Instead of working with `PushButton` instances, we will work with `PushButtonWithInterrupt`
    instances. The class methods declared in the class remain the same as in the code
    we are using as a baseline but they aren't included in the next lines. The code
    file for the sample is `iot_python_chapter_05_04.py`.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: 'The highlighted lines of code declare two class attributes for the `BoardInteraction`
    class: `reset_push_button` and `max_brightness_push_button`. The `reset_push_button`
    class attribute is an instance of `PushButtonWithInterrupt` with its `pin` attribute
    set to `11` and its interrupt handler set to the `set_min_brightness_callback`
    function that we will declare later. This way, the instance will make all the
    necessary configurations to call the `set_min_brightness_callback` function when
    the user presses the pushbutton connected to GPIO pin number 11\. The `max_brightness_push_button`
    class attribute is an instance of `PushButtonWithInterrupt` with its `pin` attribute
    set to `10`, and therefore, will make all the necessary configurations to call
    the `set_max_brightness_callback` function when the user presses the pushbutton
    connected to GPIO pin number 10.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, it is necessary to declare the functions that will be called when the
    interrupts are triggered: `set_min_brightness_callback` and `set_max_brightness_callback`.
    Notice that the functions are declared as functions and they aren''t methods of
    any class.'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: Both functions declared in the previous code print a message indicating that
    a specific button has been pressed and call either the `BoardInteraction.set_max_brightness`
    or the `BoardInteraction.set_min_brightness` class method. We already know these
    class methods from our previous examples and we didn't have to make any changes
    to them.
  prefs: []
  type: TYPE_NORMAL
- en: Finally, it is necessary to replace the `__main__` method with a new one because
    we don't need to run a periodic callback anymore. Now, our `PushButtonWithInterrupt`
    instances configure the interrupt handlers that will be called whenever a pushbutton
    is pressed. The code file for the sample is `iot_python_chapter_05_04.py`.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: When the `__main__` method starts running, the `BoardInteraction` class already
    executed the code that creates the two `PushButtonWithInterrupt` instances, and
    therefore, the interrupt handlers will run whenever we press a pushbutton. The
    `__main__` method just builds and starts the HTTP server.
  prefs: []
  type: TYPE_NORMAL
- en: The following line will start the HTTP server and our new version of the RESTful
    API. Don't forget that you need to transfer the Python source code file to the
    Yocto Linux with an SFTP client.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: 'After you run the example, press the pushbutton that sets the colors to their
    maximum brightness for 5 seconds. The RGB LED will display a white light and you
    will see the following output:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: You were pressing the pushbutton for 5 seconds but the output displayed the
    messages indicating that you were pressing the button just once. The GPIO pin
    number 10 signal went from high to low once when you pressed the button, and therefore,
    the `mraa.EDGE_FALLING` interrupt was fired and the configured interrupt handler
    (`set_max_brightness_callback`) was executed. You kept the pushbutton pressed,
    but the signal stayed in the low value, and therefore, the interrupt wasn't triggered
    again.
  prefs: []
  type: TYPE_NORMAL
- en: Tip
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Obviously, when you want to run code just once when a pushbutton is pressed
    even for a long time, the usage of interrupt handlers provides the necessary precision
    that polling makes more complex to achieve.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, press the pushbutton that sets the colors to their minimum brightness
    for 10 seconds. The RGB LED will turn off and you will see the following output:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: As happened with the other pushbutton, you were pressing the pushbutton for
    many seconds but the output displayed the messages indicating that you were pressing
    the button just once. The GPIO pin number 11 signal went from high to low once
    when you pressed the button, and therefore, the `mraa.EDGE_FALLING` interrupt
    was fired and the configured interrupt handler (`set_min_brightness_callback`)
    was executed.
  prefs: []
  type: TYPE_NORMAL
- en: Tip
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: We can make the same HTTP requests we made in our previous examples to check
    that we can achieve exactly the same results with the new code that works with
    interrupt handlers while running the HTTP server.
  prefs: []
  type: TYPE_NORMAL
- en: We can process HTTP requests and run interrupt handlers when the user presses
    pushbuttons. We improved accuracy compared with the previous version in which
    the code acted as if the pushbuttons were pressed many times when the user kept
    the pushbuttons for a long time. In addition, we removed the periodic callback.
  prefs: []
  type: TYPE_NORMAL
- en: Tip
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Whenever we have to read digital inputs, we can decide between working with
    polling or interrupt handlers based on the specific requirements we have for our
    projects. Sometimes, interrupt handlers are the best solution but in other cases
    polling is more suitable. It is very important to know that the `wiring-x86` library
    doesn't allow us to work with interrupt handlers for digital inputs, and therefore,
    in case we decide to use them, we have to work with the `mraa` library.
  prefs: []
  type: TYPE_NORMAL
- en: Test your knowledge
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'As an effect of using a pull-up resistor with a pushbutton, we will read the
    following value when the pushbutton is pressed in the GPIO pin to which it is
    connected:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: A low value (0V).
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: A high value, that is, the IOREF voltage.
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: A value between 1V and 3.3V.
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: 'As an effect of using a pull-up resistor with a pushbutton, we will read the
    following value when the pushbutton is released in the GPIO pin to which it is
    connected:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: A low value (0V).
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: A high value, that is, the IOREF voltage.
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: A value between 1V and 3.3V.
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: 'If we check a pushbutton status by reading the GPIO pin value to which it is
    connected with polling, the loop runs every 0.5 seconds and the user keeps the
    pushbutton pressed for 3 seconds:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The code will behave as if the pushbutton was pressed more than once.
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: The code will behave as if the pushbutton was pressed just once.
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: The code will behave as if the pushbutton was never pressed.
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: 'We have an interrupt handler for a pushbutton with the interrupt edge mode
    set to `mraa.EDGE_FALLING`, and the pushbutton is connected with a pull-up resistor.
    If the user keeps the pushbutton pressed for 3 seconds:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The code will behave as if the pushbutton was pressed more than once.
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: The code will behave as if the pushbutton was pressed just once.
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: The code will behave as if the pushbutton was never pressed.
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: 'In the Intel Galileo Gen 2 board, the pins labeled with the following symbol
    as a prefix for the number can be configured with interrupt handlers for digital
    inputs in the `mraa` library:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Hash sign (**#**).
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: Dollar sign (**$**).
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: Tilde symbol (**~**).
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we understood the difference between pull-up and pull-down
    resistors to wire pushbuttons and read their status with the `mraa` and `wiring-x86`
    libraries. We understood the difference between reading the pushbutton statuses
    with polling and working with interrupts and interrupt handlers.
  prefs: []
  type: TYPE_NORMAL
- en: We created consistent code that allowed the user to perform the same actions
    with either pushbuttons in the breadboard or HTTP request. We combined code that
    reacts to changes in the statuses of the pushbuttons with a RESTful API built
    with Tornado Web server. As in the previous chapters, we took advantage of Python's
    object-oriented features and we created classes to encapsulate pushbuttons and
    the necessary configurations with the `mraa` and `wiring-x86` libraries. Our code
    is easy to read and understand and we can easily switch the underlying low-level
    library.
  prefs: []
  type: TYPE_NORMAL
- en: Now that we were able to read digital inputs in different ways and configurations
    that made is possible for users to interact with our IoT device while it processed
    HTTP requests, we can work with more complex communications capabilities included
    in the board and take advantage of its storage, which are the topics of the next
    chapter.
  prefs: []
  type: TYPE_NORMAL
