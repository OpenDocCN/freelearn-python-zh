- en: '10'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Patterns for Testing
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In the previous chapters, we covered architectural patterns and patterns for
    specific use cases such as concurrency or performance.
  prefs: []
  type: TYPE_NORMAL
- en: In this chapter, we will explore design patterns that are particularly useful
    for testing. These patterns help in isolating components, making tests more reliable,
    and promoting code reusability.
  prefs: []
  type: TYPE_NORMAL
- en: 'In this chapter, we’re going to cover the following main topics:'
  prefs: []
  type: TYPE_NORMAL
- en: The Mock Object pattern
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The Dependency Injection pattern
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Technical requirements
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: See the requirements presented in [*Chapter 1*](B21896_01.xhtml#_idTextAnchor017).
  prefs: []
  type: TYPE_NORMAL
- en: The Mock Object pattern
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The **Mock Object** pattern is a powerful tool for isolating components during
    testing by simulating their behavior. Mock objects help create controlled testing
    environments and verify interactions between components.
  prefs: []
  type: TYPE_NORMAL
- en: 'The Mock Object pattern provides three features:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Isolation**: Mocks isolate the unit of code being tested, ensuring that tests
    run in a controlled environment where dependencies are predictable and do not
    have external side effects.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '**Behavior verification**: By using mock objects, you can verify that certain
    behaviors happen during a test, such as method calls or property accesses.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '**Simplification**: They simplify the setup of tests by replacing complex real
    objects that might require significant setup of their own.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Comparison with stubs
  prefs: []
  type: TYPE_NORMAL
- en: Stubs also replace real implementations but are used only to provide indirect
    input to the code under test. Mocks, by contrast, can also verify interactions,
    making them more flexible in many testing scenarios.
  prefs: []
  type: TYPE_NORMAL
- en: Real-world examples
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'We can think of the following analog concepts or tools in the real world:'
  prefs: []
  type: TYPE_NORMAL
- en: A flight simulator, which is a tool designed to replicate the experience of
    flying an actual airplane. It allows pilots to learn how to handle various flight
    scenarios in a controlled and safe environment.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A **cardiopulmonary resuscitation** (**CPR**) dummy, which is used to teach
    students how to perform CPR effectively. It simulates the human body to provide
    a realistic yet controlled setting for learning.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A crash test dummy, which is used by car manufacturers to simulate human reactions
    to vehicle collisions. It provides valuable data on the impacts and safety features
    of a car without putting actual human lives at risk.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Use cases for the Mock Object pattern
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In **unit testing**, mock objects are used to replace complex, unreliable, or
    unavailable dependencies of the code being tested. This allows developers to focus
    solely on the unit itself rather than its interactions with external systems.
    For example, when testing a service that fetches data from an API, a mock object
    can simulate the API by returning predefined responses, ensuring that the service
    can handle various data scenarios or errors without needing to interact with the
    actual API.
  prefs: []
  type: TYPE_NORMAL
- en: While similar to unit testing, **integration testing** with mock objects focuses
    on the interaction between components rather than individual units. Mocks can
    be used to simulate components that have not been developed yet or are too costly
    to involve in every test. For example, in a microservices architecture, a mock
    can represent a service that is under development or temporarily unavailable,
    allowing other services to be tested in terms of how they integrate and communicate
    with it.
  prefs: []
  type: TYPE_NORMAL
- en: The Mock Object pattern is also useful for **behavior verification**. This use
    case involves verifying that certain interactions between objects occur as expected.
    Mock objects can be programmed to expect specific calls, arguments, and even order
    of interactions, which makes them powerful tools for behavioral testing; for example,
    testing whether a controller, in a **Model View Controller** (**MVC**) architecture,
    correctly calls authentication and logging services before processing a user request.
    Mocks can verify that the controller makes the right calls in the right order,
    such as checking credentials before attempting to log the request.
  prefs: []
  type: TYPE_NORMAL
- en: Implementing the Mock Object pattern
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Imagine we have a function that logs messages to a file. We can mock the file-writing
    mechanism to ensure our logging function writes the expected content to the log
    without writing to a file. Let’s see how this can be implemented using Python’s
    `unittest` module.
  prefs: []
  type: TYPE_NORMAL
- en: 'First, we import what we need for the example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'Then, we create a class representing a simple logger that writes messages to
    a file specified during initialization:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: 'Next, we create a test case class that inherits from the `unittest.TestCase`
    class, as usual. In this class, we need the `test_log()` method to test the logger’s
    `log()` method, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: 'Next, we are going to mock the Python built-in `open()` function directly within
    the test scope. Mocking the function is done using `unittest.mock.patch()`, which
    temporarily replaces the target object, `builtins.open`, with a mock object (the
    result of calling `mock_open()`). With the context manager we get from calling
    the `unittest.mock.patch()` function, we create a `Logger` object and call its
    `.log()` method, which should trigger the `open()` function:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: About builtins
  prefs: []
  type: TYPE_NORMAL
- en: According to Python documentation, the `builtins` module provides direct access
    to all built-in identifiers of Python; for example, `builtins.open` is the full
    name for the `open()` built-in function. See [https://docs.python.org/3/library/builtins.html](https://docs.python.org/3/library/builtins.html).
  prefs: []
  type: TYPE_NORMAL
- en: About mock_open
  prefs: []
  type: TYPE_NORMAL
- en: When you call `mock_open()`, it returns a Mock object that is configured to
    behave like the built-in `open()` function. This mock is set up to simulate file
    operations such as reading and writing.
  prefs: []
  type: TYPE_NORMAL
- en: About unittest.mock.patch
  prefs: []
  type: TYPE_NORMAL
- en: 'It is used to replace objects with mocks during testing. Its arguments include
    `target` to specify the object to replace, and optional arguments: `new` for an
    optional replacement object, `spec` and `autospec` to limit the mock to the real
    object’s attributes for accuracy, `spec_set` for a stricter attribute specification,
    `side_effect` to define conditional behavior or exceptions, `return_value` for
    setting a fixed response, and `wraps` to allow the original object’s behavior
    while modifying certain aspects. These options enable precise control and flexibility
    in testing scenarios.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, we check that the log file was opened correctly, which we do using two
    verifications. For the first one, we use the `assert_called_once_with()` method
    on the mock object, to check that the `open()` function was called with the expected
    parameters. For the second one, we need more tricks from `unittest.mock.mock_open`;
    our `m_open` mock object, which was obtained by calling the `mock_open()` function,
    is also a callable object that behaves like a factory for creating new mock file
    handles each time it’s called. We use that to obtain a new file handle, and then
    we use `assert_called_once_with()` on the `write()` method call on that file handle,
    which helps us check if the `write()` method was called with the correct message.
    This part of the test function is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: 'Finally, we call `unitest.main()`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: 'To execute the example (in the `ch10/mock_object.py` file), as usual, run the
    following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: 'You should get an output like the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: That was a quick demonstration of using mocking to simulate parts of a system
    within a unit test. We can see that this approach isolates side effects (that
    is, file I/O), ensuring that the unit tests do not create or require actual files.
    It allows testing the internal behavior of the class without altering the class
    structure for testing purposes.
  prefs: []
  type: TYPE_NORMAL
- en: The Dependency Injection pattern
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The Dependency Injection pattern involves passing the dependencies of a class
    as external entities rather than creating them within the class. This promotes
    loose coupling, modularity, and testability.
  prefs: []
  type: TYPE_NORMAL
- en: Real-world examples
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'We come across the following examples in real life:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Electrical appliances and power outlets**: Various electrical appliances
    can be plugged into different power outlets to use electricity without needing
    direct and permanent wiring'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Lenses on cameras**: A photographer can change lenses on a camera to suit
    different environments and needs without changing the camera itself'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Modular train systems**: In a modular train system, individual cars (such
    as sleeper, diner, or baggage cars) can be added or removed depending on the needs
    of each journey'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Use cases for the Dependency Injection pattern
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In web applications, injecting database connection objects into components such
    as repositories or services enhances modularity and maintainability. This practice
    allows for an easy switch between different database engines or configurations
    without the need to alter the component’s code directly. It also significantly
    simplifies the process of unit testing by enabling the injection of mock database
    connections, thereby testing various data scenarios without affecting the live
    databases.
  prefs: []
  type: TYPE_NORMAL
- en: Another type of use case is managing configuration settings across various environments
    (development, testing, production, and so on). By dynamically injecting settings
    into modules, **dependency injection** (**DI**) reduces coupling between the modules
    and their configuration sources. This flexibility makes it easier to manage and
    switch environments without needing extensive reconfiguration. In unit testing,
    this means you can inject specific settings to test how modules perform under
    different configurations, ensuring robustness and functionality.
  prefs: []
  type: TYPE_NORMAL
- en: Implementing the Dependency Injection pattern – using a mock object
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In this first example, we’ll create a simple scenario where a `WeatherService`
    class depends on a `WeatherApiClient` interface to fetch weather data. For the
    example’s unit test code, we will inject a mock version of this API client.
  prefs: []
  type: TYPE_NORMAL
- en: 'We start by defining the interface any weather API client implementation should
    conform to, using Python’s `Protocol` feature:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: 'Then, we add a `RealWeatherApiClient` class that implements that interface
    and that would interact with our weather service. In a real scenario, in the provided
    `fetch_weather()` method, we would perform a call to a weather service, but we
    want to keep the example simple and focus on the main concepts of this chapter;
    so, we provide a simulation, simply returning a string that represents the weather
    data result. The code is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: 'Next, we create a weather service, which uses an object that implements the
    `WeatherApiClient` interface to fetch weather data:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: 'Finally, we are ready to inject the API client’s dependency through the `WeatherService`
    constructor. We add code that helps manually test the example, using the real
    service, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: 'This part of our example (in the `ch10/dependency_injection/di_with_mock.py`
    file) can be manually tested by using the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: 'You should get the following output:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: import unittest
  prefs: []
  type: TYPE_NORMAL
- en: from di_with_mock import WeatherService
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: 'class MockWeatherApiClient:'
  prefs: []
  type: TYPE_NORMAL
- en: 'def fetch_weather(self, location):'
  prefs: []
  type: TYPE_NORMAL
- en: return f"Mock weather data for {location}"
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: 'class TestWeatherService(unittest.TestCase):'
  prefs: []
  type: TYPE_NORMAL
- en: 'def test_get_weather(self):'
  prefs: []
  type: TYPE_NORMAL
- en: mock_api = MockWeatherApiClient()
  prefs: []
  type: TYPE_NORMAL
- en: weather_service = WeatherService(mock_api)
  prefs: []
  type: TYPE_NORMAL
- en: self.assertEqual(
  prefs: []
  type: TYPE_NORMAL
- en: weather_service.get_weather("Anywhere"),
  prefs: []
  type: TYPE_NORMAL
- en: '"Mock weather data for Anywhere",'
  prefs: []
  type: TYPE_NORMAL
- en: )
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: 'if __name__ == "__main__":'
  prefs: []
  type: TYPE_NORMAL
- en: unittest.main()
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: .
  prefs: []
  type: TYPE_NORMAL
- en: '---------------------------------------------------------'
  prefs: []
  type: TYPE_NORMAL
- en: Ran 1 test in 0.000s
  prefs: []
  type: TYPE_NORMAL
- en: OK
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: from typing import Protocol
  prefs: []
  type: TYPE_NORMAL
- en: 'class NotificationSender(Protocol):'
  prefs: []
  type: TYPE_NORMAL
- en: 'def send(self, message: str):'
  prefs: []
  type: TYPE_NORMAL
- en: '"""Send a notification with the given message"""'
  prefs: []
  type: TYPE_NORMAL
- en: '...'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: 'class EmailSender:'
  prefs: []
  type: TYPE_NORMAL
- en: 'def send(self, message: str):'
  prefs: []
  type: TYPE_NORMAL
- en: 'print(f"Sending Email: {message}")'
  prefs: []
  type: TYPE_NORMAL
- en: 'class SMSSender:'
  prefs: []
  type: TYPE_NORMAL
- en: 'def send(self, message: str):'
  prefs: []
  type: TYPE_NORMAL
- en: 'print(f"Sending SMS: {message}")'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: 'class NotificationService:'
  prefs: []
  type: TYPE_NORMAL
- en: 'sender: NotificationSender = None'
  prefs: []
  type: TYPE_NORMAL
- en: 'def notify(self, message):'
  prefs: []
  type: TYPE_NORMAL
- en: self.sender.send(message)
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: 'def inject_sender(sender_cls):'
  prefs: []
  type: TYPE_NORMAL
- en: 'def decorator(cls):'
  prefs: []
  type: TYPE_NORMAL
- en: cls.sender = sender_cls()
  prefs: []
  type: TYPE_NORMAL
- en: return cls
  prefs: []
  type: TYPE_NORMAL
- en: return decorator
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: '@inject_sender(EmailSender)'
  prefs: []
  type: TYPE_NORMAL
- en: 'class NotificationService:'
  prefs: []
  type: TYPE_NORMAL
- en: 'sender: NotificationSender = None'
  prefs: []
  type: TYPE_NORMAL
- en: 'def notify(self, message):'
  prefs: []
  type: TYPE_NORMAL
- en: self.sender.send(message)
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: 'if __name__ == "__main__":'
  prefs: []
  type: TYPE_NORMAL
- en: service = NotificationService()
  prefs: []
  type: TYPE_NORMAL
- en: service.notify("Hello, this is a test notification!")
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: python ch10/dependency_injection/di_with_decorator.py
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: 'Sending Email: Hello, this is a test notification!'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: 'Sending SMS: Hello, this is a test notification!'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: import unittest
  prefs: []
  type: TYPE_NORMAL
- en: from di_with_decorator import (
  prefs: []
  type: TYPE_NORMAL
- en: NotificationSender,
  prefs: []
  type: TYPE_NORMAL
- en: NotificationService,
  prefs: []
  type: TYPE_NORMAL
- en: inject_sender,
  prefs: []
  type: TYPE_NORMAL
- en: )
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: 'class EmailSenderStub:'
  prefs: []
  type: TYPE_NORMAL
- en: 'def __init__(self):'
  prefs: []
  type: TYPE_NORMAL
- en: self.messages_sent = []
  prefs: []
  type: TYPE_NORMAL
- en: 'def send(self, message: str):'
  prefs: []
  type: TYPE_NORMAL
- en: self.messages_sent.append(message)
  prefs: []
  type: TYPE_NORMAL
- en: 'class SMSSenderStub:'
  prefs: []
  type: TYPE_NORMAL
- en: 'def __init__(self):'
  prefs: []
  type: TYPE_NORMAL
- en: self.messages_sent = []
  prefs: []
  type: TYPE_NORMAL
- en: 'def send(self, message: str):'
  prefs: []
  type: TYPE_NORMAL
- en: self.messages_sent.append(message)
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: 'class TestNotifService(unittest.TestCase):'
  prefs: []
  type: TYPE_NORMAL
- en: 'def test_notify_with_email(self):'
  prefs: []
  type: TYPE_NORMAL
- en: email_stub = EmailSenderStub()
  prefs: []
  type: TYPE_NORMAL
- en: service = NotificationService()
  prefs: []
  type: TYPE_NORMAL
- en: service.sender = email_stub
  prefs: []
  type: TYPE_NORMAL
- en: service.notify("Test Email Message")
  prefs: []
  type: TYPE_NORMAL
- en: self.assertIn(
  prefs: []
  type: TYPE_NORMAL
- en: '"Test Email Message",'
  prefs: []
  type: TYPE_NORMAL
- en: email_stub.messages_sent,
  prefs: []
  type: TYPE_NORMAL
- en: )
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: '@inject_sender(SMSSenderStub)'
  prefs: []
  type: TYPE_NORMAL
- en: 'class CustomNotificationService:'
  prefs: []
  type: TYPE_NORMAL
- en: 'sender: NotificationSender = None'
  prefs: []
  type: TYPE_NORMAL
- en: 'def notify(self, message):'
  prefs: []
  type: TYPE_NORMAL
- en: self.sender.send(message)
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: 'def test_notify_with_sms(self):'
  prefs: []
  type: TYPE_NORMAL
- en: sms_stub = SMSSenderStub()
  prefs: []
  type: TYPE_NORMAL
- en: '@inject_sender(SMSSenderStub)'
  prefs: []
  type: TYPE_NORMAL
- en: 'class CustomNotificationService:'
  prefs: []
  type: TYPE_NORMAL
- en: 'sender: NotificationSender = None'
  prefs: []
  type: TYPE_NORMAL
- en: 'def notify(self, message):'
  prefs: []
  type: TYPE_NORMAL
- en: self.sender.send(message)
  prefs: []
  type: TYPE_NORMAL
- en: service = CustomNotificationService()
  prefs: []
  type: TYPE_NORMAL
- en: service.sender = sms_stub
  prefs: []
  type: TYPE_NORMAL
- en: service.notify("Test SMS Message")
  prefs: []
  type: TYPE_NORMAL
- en: self.assertIn(
  prefs: []
  type: TYPE_NORMAL
- en: '"Test SMS Message", sms_stub.messages_sent'
  prefs: []
  type: TYPE_NORMAL
- en: )
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: 'if __name__ == "__main__":'
  prefs: []
  type: TYPE_NORMAL
- en: unittest.main()
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: ..
  prefs: []
  type: TYPE_NORMAL
- en: '---------------------------------------------------------'
  prefs: []
  type: TYPE_NORMAL
- en: Ran 2 tests in 0.000s
  prefs: []
  type: TYPE_NORMAL
- en: OK
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs: []
  type: TYPE_PRE
