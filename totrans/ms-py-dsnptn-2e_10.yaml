- en: '10'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '10'
- en: Patterns for Testing
  id: totrans-1
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 测试模式
- en: In the previous chapters, we covered architectural patterns and patterns for
    specific use cases such as concurrency or performance.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的章节中，我们介绍了架构模式和针对特定用例（如并发或性能）的模式。
- en: In this chapter, we will explore design patterns that are particularly useful
    for testing. These patterns help in isolating components, making tests more reliable,
    and promoting code reusability.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将探讨特别适用于测试的设计模式。这些模式有助于隔离组件，使测试更加可靠，并促进代码重用。
- en: 'In this chapter, we’re going to cover the following main topics:'
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将介绍以下主要主题：
- en: The Mock Object pattern
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 模拟对象模式
- en: The Dependency Injection pattern
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 依赖注入模式
- en: Technical requirements
  id: totrans-7
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 技术要求
- en: See the requirements presented in [*Chapter 1*](B21896_01.xhtml#_idTextAnchor017).
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 请参阅在[*第一章*](B21896_01.xhtml#_idTextAnchor017)中提出的需求。
- en: The Mock Object pattern
  id: totrans-9
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 模拟对象模式
- en: The **Mock Object** pattern is a powerful tool for isolating components during
    testing by simulating their behavior. Mock objects help create controlled testing
    environments and verify interactions between components.
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: '**模拟对象**模式是一种在测试期间通过模拟其行为来隔离组件的强大工具。模拟对象有助于创建受控的测试环境并验证组件之间的交互。'
- en: 'The Mock Object pattern provides three features:'
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 模拟对象模式提供了三个功能：
- en: '**Isolation**: Mocks isolate the unit of code being tested, ensuring that tests
    run in a controlled environment where dependencies are predictable and do not
    have external side effects.'
  id: totrans-12
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**隔离**：模拟将正在测试的代码单元隔离，确保测试在受控环境中运行，其中依赖项是可预测的，并且没有外部副作用。'
- en: '**Behavior verification**: By using mock objects, you can verify that certain
    behaviors happen during a test, such as method calls or property accesses.'
  id: totrans-13
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**行为验证**：通过使用模拟对象，您可以在测试期间验证某些行为是否发生，例如方法调用或属性访问。'
- en: '**Simplification**: They simplify the setup of tests by replacing complex real
    objects that might require significant setup of their own.'
  id: totrans-14
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**简化**：它们通过替换可能需要大量设置的复杂真实对象来简化测试的设置。'
- en: Comparison with stubs
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 与存根的比较
- en: Stubs also replace real implementations but are used only to provide indirect
    input to the code under test. Mocks, by contrast, can also verify interactions,
    making them more flexible in many testing scenarios.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 存根也替换了真实实现，但仅用于向被测试的代码提供间接输入。相比之下，模拟可以验证交互，使它们在许多测试场景中更加灵活。
- en: Real-world examples
  id: totrans-17
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 现实世界示例
- en: 'We can think of the following analog concepts or tools in the real world:'
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以想到以下现实世界的类比概念或工具：
- en: A flight simulator, which is a tool designed to replicate the experience of
    flying an actual airplane. It allows pilots to learn how to handle various flight
    scenarios in a controlled and safe environment.
  id: totrans-19
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 飞行模拟器，这是一种旨在复制实际驾驶飞机体验的工具。它允许飞行员在受控和安全的环境中学习如何处理各种飞行场景。
- en: A **cardiopulmonary resuscitation** (**CPR**) dummy, which is used to teach
    students how to perform CPR effectively. It simulates the human body to provide
    a realistic yet controlled setting for learning.
  id: totrans-20
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**心肺复苏**（**CPR**）模拟人，用于教授学生如何有效地进行心肺复苏。它模拟人体以提供一个真实但受控的学习环境。'
- en: A crash test dummy, which is used by car manufacturers to simulate human reactions
    to vehicle collisions. It provides valuable data on the impacts and safety features
    of a car without putting actual human lives at risk.
  id: totrans-21
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 碰撞测试模拟人，由汽车制造商用于模拟人类对车辆碰撞的反应。它提供了关于汽车碰撞影响和安全特性的宝贵数据，而无需冒实际人类生命危险。
- en: Use cases for the Mock Object pattern
  id: totrans-22
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 模拟对象模式的用例
- en: In **unit testing**, mock objects are used to replace complex, unreliable, or
    unavailable dependencies of the code being tested. This allows developers to focus
    solely on the unit itself rather than its interactions with external systems.
    For example, when testing a service that fetches data from an API, a mock object
    can simulate the API by returning predefined responses, ensuring that the service
    can handle various data scenarios or errors without needing to interact with the
    actual API.
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 在**单元测试**中，模拟对象用于替换被测试代码的复杂、不可靠或不可用的依赖项。这允许开发者仅关注单元本身，而不是它与外部系统的交互。例如，当测试一个从API获取数据的服务时，模拟对象可以通过返回预定义的响应来模拟API，确保服务能够处理各种数据场景或错误，而无需与实际API交互。
- en: While similar to unit testing, **integration testing** with mock objects focuses
    on the interaction between components rather than individual units. Mocks can
    be used to simulate components that have not been developed yet or are too costly
    to involve in every test. For example, in a microservices architecture, a mock
    can represent a service that is under development or temporarily unavailable,
    allowing other services to be tested in terms of how they integrate and communicate
    with it.
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然与单元测试类似，但使用模拟对象的**集成测试**侧重于组件之间的交互，而不是单个单元。模拟可以用来模拟尚未开发或成本过高而无法参与每个测试的组件。例如，在微服务架构中，模拟可以代表一个正在开发或暂时不可用的服务，允许其他服务在如何集成和与其通信方面进行测试。
- en: The Mock Object pattern is also useful for **behavior verification**. This use
    case involves verifying that certain interactions between objects occur as expected.
    Mock objects can be programmed to expect specific calls, arguments, and even order
    of interactions, which makes them powerful tools for behavioral testing; for example,
    testing whether a controller, in a **Model View Controller** (**MVC**) architecture,
    correctly calls authentication and logging services before processing a user request.
    Mocks can verify that the controller makes the right calls in the right order,
    such as checking credentials before attempting to log the request.
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 模拟对象模式对于**行为验证**也非常有用。此用例涉及验证对象之间是否发生预期的某些交互。模拟对象可以被编程为期望特定的调用、参数甚至交互顺序，这使得它们成为行为测试的强大工具；例如，测试控制器在**模型-视图-控制器**（**MVC**）架构中在处理用户请求之前是否正确地调用了身份验证和日志记录服务。模拟可以验证控制器是否以正确的顺序进行了正确的调用，例如在尝试记录请求之前检查凭证。
- en: Implementing the Mock Object pattern
  id: totrans-26
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 实现模拟对象模式
- en: Imagine we have a function that logs messages to a file. We can mock the file-writing
    mechanism to ensure our logging function writes the expected content to the log
    without writing to a file. Let’s see how this can be implemented using Python’s
    `unittest` module.
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 假设我们有一个将消息记录到文件的函数。我们可以模拟文件写入机制，以确保我们的日志记录函数将预期的内容写入日志，而不写入文件。让我们看看如何使用Python的`unittest`模块来实现这一点。
- en: 'First, we import what we need for the example:'
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们导入示例中需要的模块：
- en: '[PRE0]'
  id: totrans-29
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'Then, we create a class representing a simple logger that writes messages to
    a file specified during initialization:'
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们创建一个表示简单日志记录器的类，该记录器将消息写入初始化期间指定的文件：
- en: '[PRE1]'
  id: totrans-31
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'Next, we create a test case class that inherits from the `unittest.TestCase`
    class, as usual. In this class, we need the `test_log()` method to test the logger’s
    `log()` method, as follows:'
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们创建一个继承自`unittest.TestCase`类的测试用例类，就像通常一样。在这个类中，我们需要`test_log()`方法来测试日志记录器的`log()`方法，如下所示：
- en: '[PRE2]'
  id: totrans-33
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'Next, we are going to mock the Python built-in `open()` function directly within
    the test scope. Mocking the function is done using `unittest.mock.patch()`, which
    temporarily replaces the target object, `builtins.open`, with a mock object (the
    result of calling `mock_open()`). With the context manager we get from calling
    the `unittest.mock.patch()` function, we create a `Logger` object and call its
    `.log()` method, which should trigger the `open()` function:'
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们将在测试范围内直接模拟Python内置的`open()`函数。模拟函数是通过使用`unittest.mock.patch()`来完成的，它临时用模拟对象（调用`mock_open()`的结果）替换了目标对象，即`builtins.open`。通过调用`unittest.mock.patch()`函数获得的上下文管理器，我们创建一个`Logger`对象并调用其`.log()`方法，这应该会触发`open()`函数：
- en: '[PRE3]'
  id: totrans-35
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: About builtins
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 关于`builtins`
- en: According to Python documentation, the `builtins` module provides direct access
    to all built-in identifiers of Python; for example, `builtins.open` is the full
    name for the `open()` built-in function. See [https://docs.python.org/3/library/builtins.html](https://docs.python.org/3/library/builtins.html).
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 根据Python文档，`builtins`模块提供了对Python所有内置标识符的直接访问；例如，`builtins.open`是`open()`内置函数的全名。见[https://docs.python.org/3/library/builtins.html](https://docs.python.org/3/library/builtins.html)。
- en: About mock_open
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 关于`mock_open`
- en: When you call `mock_open()`, it returns a Mock object that is configured to
    behave like the built-in `open()` function. This mock is set up to simulate file
    operations such as reading and writing.
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 当你调用`mock_open()`时，它返回一个配置为像内置的`open()`函数一样行为的Mock对象。此模拟被设置为模拟文件操作，如读取和写入。
- en: About unittest.mock.patch
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 关于`unittest.mock.patch`
- en: 'It is used to replace objects with mocks during testing. Its arguments include
    `target` to specify the object to replace, and optional arguments: `new` for an
    optional replacement object, `spec` and `autospec` to limit the mock to the real
    object’s attributes for accuracy, `spec_set` for a stricter attribute specification,
    `side_effect` to define conditional behavior or exceptions, `return_value` for
    setting a fixed response, and `wraps` to allow the original object’s behavior
    while modifying certain aspects. These options enable precise control and flexibility
    in testing scenarios.'
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 它用于在测试期间用模拟对象替换对象。它的参数包括 `target`，用于指定要替换的对象，以及可选参数：`new` 用于可选的替换对象，`spec` 和
    `autospec` 用于将模拟限制在真实对象的属性上以提高准确性，`spec_set` 用于更严格的属性指定，`side_effect` 用于定义条件行为或异常，`return_value`
    用于设置固定的响应，`wraps` 用于在修改某些方面时允许原始对象的行为。这些选项使测试场景中的精确控制和灵活性成为可能。
- en: 'Now, we check that the log file was opened correctly, which we do using two
    verifications. For the first one, we use the `assert_called_once_with()` method
    on the mock object, to check that the `open()` function was called with the expected
    parameters. For the second one, we need more tricks from `unittest.mock.mock_open`;
    our `m_open` mock object, which was obtained by calling the `mock_open()` function,
    is also a callable object that behaves like a factory for creating new mock file
    handles each time it’s called. We use that to obtain a new file handle, and then
    we use `assert_called_once_with()` on the `write()` method call on that file handle,
    which helps us check if the `write()` method was called with the correct message.
    This part of the test function is as follows:'
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们检查日志文件是否正确打开，我们使用两种验证方法来完成。对于第一个验证，我们在模拟对象上使用 `assert_called_once_with()`
    方法，以检查 `open()` 函数是否以预期的参数被调用。对于第二个验证，我们需要从 `unittest.mock.mock_open` 中获取更多技巧；我们的
    `m_open` 模拟对象，通过调用 `mock_open()` 函数获得，也是一个可调用对象，每次被调用时都像是一个创建新模拟文件句柄的工厂。我们使用它来获取一个新的文件句柄，然后在该文件句柄上的
    `write()` 方法调用上使用 `assert_called_once_with()`，这有助于我们检查 `write()` 方法是否以正确的消息被调用。测试函数的这一部分如下：
- en: '[PRE4]'
  id: totrans-43
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'Finally, we call `unitest.main()`:'
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们调用 `unitest.main()`：
- en: '[PRE5]'
  id: totrans-45
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'To execute the example (in the `ch10/mock_object.py` file), as usual, run the
    following command:'
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 要执行示例（在 `ch10/mock_object.py` 文件中），像往常一样，运行以下命令：
- en: '[PRE6]'
  id: totrans-47
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'You should get an output like the following:'
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 你应该得到以下输出：
- en: '[PRE7]'
  id: totrans-49
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: That was a quick demonstration of using mocking to simulate parts of a system
    within a unit test. We can see that this approach isolates side effects (that
    is, file I/O), ensuring that the unit tests do not create or require actual files.
    It allows testing the internal behavior of the class without altering the class
    structure for testing purposes.
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 这只是一个快速演示，展示了如何在单元测试中使用模拟来模拟系统的一部分。我们可以看到，这种方法隔离了副作用（即文件I/O），确保单元测试不会创建或需要实际文件。它允许测试类的内部行为，而不需要为了测试目的而改变类的结构。
- en: The Dependency Injection pattern
  id: totrans-51
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 依赖注入模式
- en: The Dependency Injection pattern involves passing the dependencies of a class
    as external entities rather than creating them within the class. This promotes
    loose coupling, modularity, and testability.
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 依赖注入模式涉及将类的依赖项作为外部实体传递，而不是在类内创建它们。这促进了松散耦合、模块化和可测试性。
- en: Real-world examples
  id: totrans-53
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 现实世界的例子
- en: 'We come across the following examples in real life:'
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 在现实生活中，我们会遇到以下例子：
- en: '**Electrical appliances and power outlets**: Various electrical appliances
    can be plugged into different power outlets to use electricity without needing
    direct and permanent wiring'
  id: totrans-55
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**电器和电源插座**：各种电器可以插入不同的电源插座，使用电力而无需直接和永久布线'
- en: '**Lenses on cameras**: A photographer can change lenses on a camera to suit
    different environments and needs without changing the camera itself'
  id: totrans-56
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**相机镜头**：摄影师可以在不改变相机本身的情况下，根据不同的环境和需求更换相机的镜头'
- en: '**Modular train systems**: In a modular train system, individual cars (such
    as sleeper, diner, or baggage cars) can be added or removed depending on the needs
    of each journey'
  id: totrans-57
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**模块化列车系统**：在模块化列车系统中，可以根据每次旅行的需求添加或移除单个车厢（如卧铺车厢、餐厅车厢或行李车厢）'
- en: Use cases for the Dependency Injection pattern
  id: totrans-58
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 依赖注入模式的用例
- en: In web applications, injecting database connection objects into components such
    as repositories or services enhances modularity and maintainability. This practice
    allows for an easy switch between different database engines or configurations
    without the need to alter the component’s code directly. It also significantly
    simplifies the process of unit testing by enabling the injection of mock database
    connections, thereby testing various data scenarios without affecting the live
    databases.
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 在Web应用程序中，将数据库连接对象注入到组件（如仓库或服务）中，可以增强模块化和可维护性。这种做法允许轻松地在不同的数据库引擎或配置之间切换，而无需直接修改组件的代码。它还通过允许注入模拟数据库连接，从而简化了单元测试过程，从而在不影响实时数据库的情况下测试各种数据场景。
- en: Another type of use case is managing configuration settings across various environments
    (development, testing, production, and so on). By dynamically injecting settings
    into modules, **dependency injection** (**DI**) reduces coupling between the modules
    and their configuration sources. This flexibility makes it easier to manage and
    switch environments without needing extensive reconfiguration. In unit testing,
    this means you can inject specific settings to test how modules perform under
    different configurations, ensuring robustness and functionality.
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 另一种使用场景是管理跨各种环境（开发、测试、生产等）的配置设置。通过动态将设置注入到模块中，**依赖注入**（**DI**）减少了模块与其配置源之间的耦合。这种灵活性使得在不进行大量重新配置的情况下，更容易管理和切换环境。在单元测试中，这意味着你可以注入特定的设置来测试模块在不同配置下的表现，确保其健壮性和功能。
- en: Implementing the Dependency Injection pattern – using a mock object
  id: totrans-61
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 实现依赖注入模式 - 使用模拟对象
- en: In this first example, we’ll create a simple scenario where a `WeatherService`
    class depends on a `WeatherApiClient` interface to fetch weather data. For the
    example’s unit test code, we will inject a mock version of this API client.
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个第一个例子中，我们将创建一个简单的场景，其中`WeatherService`类依赖于`WeatherApiClient`接口来获取天气数据。对于示例的单元测试代码，我们将注入该API客户端的模拟版本。
- en: 'We start by defining the interface any weather API client implementation should
    conform to, using Python’s `Protocol` feature:'
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 我们首先定义任何天气API客户端实现应遵守的接口，使用Python的`Protocol`功能：
- en: '[PRE8]'
  id: totrans-64
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'Then, we add a `RealWeatherApiClient` class that implements that interface
    and that would interact with our weather service. In a real scenario, in the provided
    `fetch_weather()` method, we would perform a call to a weather service, but we
    want to keep the example simple and focus on the main concepts of this chapter;
    so, we provide a simulation, simply returning a string that represents the weather
    data result. The code is as follows:'
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们添加一个`RealWeatherApiClient`类，该类实现了该接口，并将与我们的天气服务进行交互。在实际场景中，在提供的`fetch_weather()`方法中，我们会调用天气服务，但为了使示例简单并专注于本章的主要概念；所以我们提供了一个模拟，简单地返回一个表示天气数据结果的字符串。代码如下：
- en: '[PRE9]'
  id: totrans-66
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'Next, we create a weather service, which uses an object that implements the
    `WeatherApiClient` interface to fetch weather data:'
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们创建一个天气服务，它使用实现`WeatherApiClient`接口的对象来获取天气数据：
- en: '[PRE10]'
  id: totrans-68
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'Finally, we are ready to inject the API client’s dependency through the `WeatherService`
    constructor. We add code that helps manually test the example, using the real
    service, as follows:'
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们准备好通过`WeatherService`构造函数注入API客户端的依赖。我们添加代码来帮助手动测试示例，使用以下真实服务：
- en: '[PRE11]'
  id: totrans-70
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'This part of our example (in the `ch10/dependency_injection/di_with_mock.py`
    file) can be manually tested by using the following command:'
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的示例的这一部分（在`ch10/dependency_injection/di_with_mock.py`文件中）可以通过以下命令手动测试：
- en: '[PRE12]'
  id: totrans-72
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'You should get the following output:'
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 你应该得到以下输出：
- en: '[PRE13]'
  id: totrans-74
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: import unittest
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 导入unittest模块
- en: from di_with_mock import WeatherService
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: from di_with_mock import WeatherService
- en: '[PRE14]'
  id: totrans-77
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'class MockWeatherApiClient:'
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 'class MockWeatherApiClient:'
- en: 'def fetch_weather(self, location):'
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 'def fetch_weather(self, location):'
- en: return f"Mock weather data for {location}"
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: return f"为 {location} 的模拟天气数据"
- en: '[PRE15]'
  id: totrans-81
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'class TestWeatherService(unittest.TestCase):'
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 'class TestWeatherService(unittest.TestCase):'
- en: 'def test_get_weather(self):'
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 'def test_get_weather(self):'
- en: mock_api = MockWeatherApiClient()
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: mock_api = MockWeatherApiClient()
- en: weather_service = WeatherService(mock_api)
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: weather_service = WeatherService(mock_api)
- en: self.assertEqual(
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: self.assertEqual(
- en: weather_service.get_weather("Anywhere"),
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: weather_service.get_weather("Anywhere"),
- en: '"Mock weather data for Anywhere",'
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: '"为任何地方的模拟天气数据",'
- en: )
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: )
- en: '[PRE16]'
  id: totrans-90
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'if __name__ == "__main__":'
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 'if __name__ == "__main__":'
- en: unittest.main()
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: unittest.main()
- en: '[PRE17]'
  id: totrans-93
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: .
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: .
- en: '---------------------------------------------------------'
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: '---------------------------------------------------------'
- en: Ran 1 test in 0.000s
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 执行了1个测试，耗时0.000秒
- en: OK
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: OK
- en: '[PRE18]'
  id: totrans-98
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: from typing import Protocol
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: from typing import Protocol
- en: 'class NotificationSender(Protocol):'
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
- en: 'def send(self, message: str):'
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
- en: '"""Send a notification with the given message"""'
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
- en: '...'
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  id: totrans-104
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'class EmailSender:'
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
- en: 'def send(self, message: str):'
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
- en: 'print(f"Sending Email: {message}")'
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
- en: 'class SMSSender:'
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
- en: 'def send(self, message: str):'
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
- en: 'print(f"Sending SMS: {message}")'
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  id: totrans-111
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'class NotificationService:'
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
- en: 'sender: NotificationSender = None'
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
- en: 'def notify(self, message):'
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
- en: self.sender.send(message)
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  id: totrans-116
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'def inject_sender(sender_cls):'
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
- en: 'def decorator(cls):'
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
- en: cls.sender = sender_cls()
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
- en: return cls
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
- en: return decorator
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  id: totrans-122
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: '@inject_sender(EmailSender)'
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
- en: 'class NotificationService:'
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
- en: 'sender: NotificationSender = None'
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
- en: 'def notify(self, message):'
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
- en: self.sender.send(message)
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  id: totrans-128
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'if __name__ == "__main__":'
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
- en: service = NotificationService()
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
- en: service.notify("Hello, this is a test notification!")
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  id: totrans-132
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: python ch10/dependency_injection/di_with_decorator.py
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  id: totrans-134
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'Sending Email: Hello, this is a test notification!'
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  id: totrans-136
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: 'Sending SMS: Hello, this is a test notification!'
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  id: totrans-138
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: import unittest
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
- en: from di_with_decorator import (
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
- en: NotificationSender,
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
- en: NotificationService,
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
- en: inject_sender,
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
- en: )
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  id: totrans-145
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: 'class EmailSenderStub:'
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
- en: 'def __init__(self):'
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
- en: self.messages_sent = []
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
- en: 'def send(self, message: str):'
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
- en: self.messages_sent.append(message)
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
- en: 'class SMSSenderStub:'
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
- en: 'def __init__(self):'
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
- en: self.messages_sent = []
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
- en: 'def send(self, message: str):'
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
- en: self.messages_sent.append(message)
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  id: totrans-156
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: 'class TestNotifService(unittest.TestCase):'
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
- en: 'def test_notify_with_email(self):'
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
- en: email_stub = EmailSenderStub()
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
- en: service = NotificationService()
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
- en: service.sender = email_stub
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
- en: service.notify("Test Email Message")
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
- en: self.assertIn(
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
- en: '"Test Email Message",'
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
- en: email_stub.messages_sent,
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
- en: )
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  id: totrans-167
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: '@inject_sender(SMSSenderStub)'
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
- en: 'class CustomNotificationService:'
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
- en: 'sender: NotificationSender = None'
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
- en: 'def notify(self, message):'
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
- en: self.sender.send(message)
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  id: totrans-173
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: 'def test_notify_with_sms(self):'
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
- en: sms_stub = SMSSenderStub()
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
- en: '@inject_sender(SMSSenderStub)'
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
- en: 'class CustomNotificationService:'
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
- en: 'sender: NotificationSender = None'
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
- en: 'def notify(self, message):'
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
- en: self.sender.send(message)
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
- en: service = CustomNotificationService()
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
- en: service.sender = sms_stub
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
- en: service.notify("Test SMS Message")
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
- en: self.assertIn(
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
- en: '"Test SMS Message", sms_stub.messages_sent'
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
- en: )
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  id: totrans-187
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: 'if __name__ == "__main__":'
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
- en: unittest.main()
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  id: totrans-190
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: ..
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
- en: '---------------------------------------------------------'
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
- en: Ran 2 tests in 0.000s
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
- en: OK
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE34]'
  id: totrans-195
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
