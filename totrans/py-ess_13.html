<html><head></head><body><div class="chapter" title="Chapter&#xA0;13.&#xA0;Metaprogramming and Decorators"><div class="titlepage"><div><div><h1 class="title"><a id="ch13"/>Chapter 13. Metaprogramming and Decorators</h1></div></div></div><p>The bulk of what we've covered has been programming—writing Python statements to process data. We can also use Python to process Python instead of processing data. We'll call this<a class="indexterm" id="id660"/> metaprogramming. We'll look at two aspects: decorators and metaclasses.</p><p>A decorator<a class="indexterm" id="id661"/> is a function that accepts a function as an argument and returns a function. We can use this to add features to a function without repeating the feature in several different function definitions. A decorator prevents copy-and-paste programming. We often use this for logging, audit, or security purposes; these are things that will cut across a number of class or function definitions.</p><p>A metaclass<a class="indexterm" id="id662"/> definition will extend the essential object creation that happens when we make an instance of a class. Implicitly, the special method name of <code class="literal">__new__()</code> is used to create a bare object that is subsequently initialized by the <code class="literal">__init__()</code> method of the class. A metaclass allows us to change some of the fundamental features of object creation.</p><div class="section" title="Simple metaprogramming with decorators"><div class="titlepage"><div><div><h1 class="title"><a id="ch13lvl1sec113"/>Simple metaprogramming with decorators</h1></div></div></div><p>Python<a class="indexterm" id="id663"/> has a few built-in decorators that will modify a function or a method of a class. For example, in <a class="link" href="ch11.html" title="Chapter 11. Class Definitions">Chapter 11</a>, <span class="emphasis"><em>Class Definitions</em></span>, we saw <code class="literal">@staticmethod</code> and <code class="literal">@property</code>, which are used to alter the behavior<a class="indexterm" id="id664"/> of a method in a class. The <code class="literal">@staticmethod</code> decorator changes a function to work on the class instead of an instance of the class. The <code class="literal">@property</code> decorator makes evaluating a no-argument method available via the <a class="indexterm" id="id665"/>same syntax as an attribute.</p><p>A function decorator that's available in the <code class="literal">functools</code> module is <code class="literal">@lru_cache</code>. This modifies a function to add memoization. Having cached results can be a significant speed-up. It looks like this:</p><div class="informalexample"><pre class="programlisting">from functools import lru_cache
from glob import glob
import os

@lru_cache(100)
def find_source(directory):
    return glob(os.path.join(directory,"*.py"))</pre></div><p>In this example, we've imported the <code class="literal">@lru_cache</code> decorator. We've also imported the <code class="literal">glob.glob()</code> function and the <code class="literal">os</code> module so that we can use <code class="literal">os.path.join()</code> to create filenames irrespective of OS-specific punctuation.</p><p>We've<a class="indexterm" id="id666"/> provided a size parameter to the <code class="literal">@lru_cache()</code> decorator. The parameterized decorator modifies the <code class="literal">find_source()</code> function by adding a cache that will hold 100 previous results. This can speed up a program that does a lot of work with the local file system. The <span class="strong"><strong>last recently used</strong></span> (<span class="strong"><strong>LRU</strong></span>) algorithm <a class="indexterm" id="id667"/>assures that recent requests are preserved and older requests are quietly forgotten to limit the cache to the requested size.</p><p>The <code class="literal">@lru_cache</code> decorator<a class="indexterm" id="id668"/> embodies a reusable optimization that can be applied to a variety of functions. We have separated the memoization aspect from other aspects of a function's implementation.</p><p>The <span class="emphasis"><em>Python Standard Library</em></span> defines a few decorators. For more examples of decorator metaprogramming, see<a class="indexterm" id="id669"/> the Python Decorator Library page, <a class="ulink" href="https://wiki.python.org/moin/PythonDecoratorLibrary">https://wiki.python.org/moin/PythonDecoratorLibrary</a>.</p></div></div>
<div class="section" title="Defining our own decorator"><div class="titlepage"><div><div><h1 class="title"><a id="ch13lvl1sec114"/>Defining our own decorator</h1></div></div></div><p>In some <a class="indexterm" id="id670"/>cases, we can extract a common aspect from a number of functions. Concerns like security, audit, or logging are common examples of something we might want to implement consistently across many functions or classes.</p><p>Let's look at a way to support enhanced debugging. Our goal is to have a simple annotation that we can use to provide consistent, detailed output from several unrelated functions. We'd like to create a module with definitions like this:</p><div class="informalexample"><pre class="programlisting">@debug_log
def some_function(ksloc):
    return 2.4*ksloc**1.05
@debug_log
def another_function(ksloc, a=3.6, b=1.20):
    return a*ksloc**b</pre></div><p>We've defined two simple functions that will be wrapped by a decorator to provide consistent debugging output.</p><p>A decorator is a function that accepts a function as an argument and returns a function as a result. What we've shown in the preceding piece of code is evaluated as follows:</p><div class="informalexample"><pre class="programlisting">&gt;&gt;&gt; def some_function(ksloc):
...    return 2.4*ksloc**1.05
&gt;&gt;&gt;  some_function = debug_log(debug_log)</pre></div><p>When we<a class="indexterm" id="id671"/> apply a decorator to a function, we're implicitly evaluating the decorator function with an original function as the argument. This will create the decorated function as a result. Using a decorator creates a result with the same name as the original function—the decorated version replaces the original.</p><p>For this to work, we'll need to write a decorator that creates the debugging log entries. This must be generic so that it will work for any function. As we noted in <a class="link" href="ch07.html" title="Chapter 7. Basic Function Definitions">Chapter 7</a>, <span class="emphasis"><em>Basic Function Definitions</em></span>, we can use the <code class="literal">*</code> and <code class="literal">**</code> modifiers to collect "all other" positional arguments and all other keyword arguments into a single sequence or a single dictionary. This allows us to write completely generic decorators.</p><p>Here's the <code class="literal">@debug_log</code> decorator function:</p><div class="informalexample"><pre class="programlisting">import logging
from functools import wraps
def debug_log(func):
    log= logging.getLogger(func.__name__)
    @wraps(func)
    def decorated(*args, **kw):
        log.debug("&gt;&gt;&gt; call(*{0}, **{1})".format(args, kw))
        try:
            result= func(*args, **kw)
            log.debug("&lt;&lt;&lt; return {}".format(result))
            return result
        except Exception as ex:
            log.exception( "*** {}".format(ex) )
            raise
    return decorated</pre></div><p>The body of the decorator definition does three things. First, it creates a logger based on the original function's name, <code class="literal">func.__name__</code>. Second, it defines an entirely new function, named <code class="literal">decorated()</code>, which is based on the original function. Finally, it returns that new function.</p><p>Note that we used a decorator from the <code class="literal">functools</code> library, <code class="literal">@wraps</code>, to show that the new decorator function wraps the original function. This will assure that the name and docstring are properly copied from the original function to the decorated function. The decorated version will be indistinguishable from the original.</p><p>We can use these functions normally:</p><div class="informalexample"><pre class="programlisting">&gt;&gt;&gt; round(some_function(25),3)
70.477</pre></div><p>The decoration has no impact on the value of the function. It has a small performance impact.</p><p>If we have <a class="indexterm" id="id672"/>logging enabled, and we set the logging level to <code class="literal">DEBUG</code>, we'll see additional output in the log. The preceding example would lead to the following in the logger's output:</p><div class="informalexample"><pre class="programlisting">DEBUG:some_function:&gt;&gt;&gt; call(*(25,), **{})
DEBUG:some_function:&lt;&lt;&lt; return 70.47713658528114</pre></div><p>This shows the debugging detail produced by this decorator. The log shows the argument values and the result value. If there's an exception, we'll see the argument values as well as the exception message, which can be more useful than the default behavior of just showing the exception message.</p><p>An easy way to enable the logger is to include the following in the application:</p><div class="informalexample"><pre class="programlisting">import sys
logging.basicConfig(stream=sys.stderr, level=logging.DEBUG)</pre></div><p>This will direct the log output to the standard error stream. It will also include all messages that have a severity level above the debug level. We can change this level setting to a value like <code class="literal">logging.INFO</code> to silence the debugging messages, leaving informational messages intact.</p><p>A decorator that also accepts parameters values—in a manner similar to the <code class="literal">@lru_cache</code> decorator—is more complex. The argument values are first applied to create a decorator. The decorator that results from this initial binding is then used to build the decorated function from the original function.</p></div>
<div class="section" title="More complex metaprogramming with metaclasses"><div class="titlepage"><div><div><h1 class="title"><a id="ch13lvl1sec115"/>More complex metaprogramming with metaclasses</h1></div></div></div><p>In <a class="indexterm" id="id673"/>some cases, the default features built into a class aren't appropriate for our particular application. We can see a few common situations where we might want to extend the default behavior of object construction.</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">We can use a metaclass to preserve some of the original source code that defined a class. By default, each class object uses <code class="literal">dict</code> to store the various methods and class-level attributes. We might want to use an ordered dictionary to retain the original source code ordering for class-level attributes. An example of this is shown in the <span class="emphasis"><em>Python Standard Library</em></span>, section 3.3.3.5.</li><li class="listitem" style="list-style-type: disc">The <span class="strong"><strong>abstract base classes</strong></span> (<span class="strong"><strong>ABC</strong></span>) rely on a <code class="literal">metaclass __new__()</code> method to <a class="indexterm" id="id674"/>confirm that the concrete subclass is complete when we attempt to create an instance of the class. If we fail to provide all of the required methods in a subclass of an ABC, we can't create an instance of that subclass.</li><li class="listitem" style="list-style-type: disc">Metaclasses can be used to simplify object serialization. A metaclass can incorporate information required for XML or JSON representation of an instance.</li><li class="listitem" style="list-style-type: disc">We <a class="indexterm" id="id675"/>can use a metaclass to inject additional attributes into an object. Because a metaclass provides the implementation of the <code class="literal">__new__()</code> method used to create an empty object, it is able to inject attributes before the <code class="literal">__init__()</code> method is evaluated. For some immutable classes, such as tuples, there is no <code class="literal">__init__()</code> method, and a subclass of the tuple must use the <code class="literal">__new__()</code> method to set the value.</li></ul></div><p>The default metaclass is <code class="literal">type</code>. This is used by application classes to create the new, bare object prior to the <code class="literal">__init__()</code> method being invoked. The built-in <code class="literal">type.__new__()</code> method requires four argument values—the metaclass, the application class name, the base classes for the application class, and a namespace of system-defined initial values.</p><p>When we create a metaclass, we'll override the <code class="literal">__new__()</code> method. We'll still use the <code class="literal">type.__new__()</code> method to create the bare object. We can then extend or modify this bare object before returning the object.</p><p>Here's a metaclass that inserts a logger prior to <code class="literal">__init__()</code>:</p><div class="informalexample"><pre class="programlisting">import logging
class Logged(type):
    def __new__(cls, name, bases, namespace, **kwds):
        result = type.__new__(cls, name, bases, dict(namespace))
        result.logger= logging.getLogger(name)
        return result</pre></div><p>We've defined a class that extends the built-in <code class="literal">type</code> class. We've defined an overriding special method, <code class="literal">__new__()</code>. The special method uses the superclass <code class="literal">type.__new__()</code> method to create the bare object, which is assigned to the <code class="literal">result</code> variable.</p><p>Once we have the bare object, we can create a logger and inject this logger into the bare object. This <code class="literal">self.logger</code> attribute will be available from the very first line of the <code class="literal">__init__()</code> method in each class that's created using this metaclass.</p><p>We can create application classes that leverage this metaclass, like this:</p><div class="informalexample"><pre class="programlisting">class Machine(metaclass=Logged):
    def __init__(self, machine_id, base, cost_each):
        self.logger.info("creating {0} at {1}+{2}".format(
            machine_id, base, cost_each))
        self.machine_id= machine_id
        self.base= base
        self.cost_each= cost_each
    def application(self, units):
        total= self.base + self.cost_each*units
        self.logger.debug("Applied {units} ==&gt; {total}".format(
            total=total, units=units, **self.__dict__))
        return total</pre></div><p>We've<a class="indexterm" id="id676"/> defined a class that explicitly depends on the <code class="literal">Logged</code> metaclass. If we don't include the <code class="literal">metaclass</code> keyword parameter, the default metaclass of <code class="literal">type</code> will be used. In this class, the <code class="literal">logger</code> attribute was created before the <code class="literal">__init__()</code> method was invoked. This allows us to use the logger in the <code class="literal">__init__()</code> method without any further overhead.</p></div>
<div class="section" title="Summary"><div class="titlepage"><div><div><h1 class="title"><a id="ch13lvl1sec116"/>Summary</h1></div></div></div><p>In this chapter, we've looked at two common metaprogramming techniques. The first is writing decorator functions—these can be used to transform an original function to add new features. The second is using a metaclass to extend the default behavior of class definitions.</p><p>We can use these techniques to develop application features that cut across many functions and classes. Writing a feature once and applying it to a number of classes assures us of consistency and can help during debugging, as well as upgrades or refactoring.</p><p>In <a class="link" href="ch14.html" title="Chapter 14. Fit and Finish – Unit Testing, Packaging, and Documentation">Chapter 14</a>, <span class="emphasis"><em>Fit and Finish – Unit Testing, Packaging, and Documentation</em></span>, we'll look at a number of features that characterize a complete Python project. Rather than address technical language features, we'll look at ways we can use Python features to create polished, complete solutions.</p></div></body></html>