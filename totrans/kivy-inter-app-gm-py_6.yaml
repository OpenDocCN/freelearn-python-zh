- en: Chapter 6. Kivy Player – a TED Video Streamer
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第6章. Kivy播放器 – TED视频流器
- en: 'In this chapter, we will learn how to search, display, and control videos.
    We will integrate knowledge from previous chapters to build a responsive application
    with the ability to adjust to different screens and maximize the use of space.
    We will produce an enhanced **video** widget with controls and subtitle support,
    and learn how to display a search result query from the TED API services ([developer.ted.com](http://developer.ted.com)).
    Here are the main topics that we will cover in this chapter:'
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将学习如何搜索、显示和控制视频。我们将整合前几章的知识，构建一个能够适应不同屏幕并最大化空间使用的响应式应用程序。我们将制作一个带有控件和字幕支持的增强型**视频**小部件，并学习如何显示来自TED
    API服务的搜索结果查询（[developer.ted.com](http://developer.ted.com)）。以下是本章我们将涵盖的主要主题：
- en: Control the progression of a streamed video
  id: totrans-2
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 控制流媒体视频的播放进度
- en: Use the progression of a video to display subtitles at the right moment
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用视频的进度在正确的时间显示字幕
- en: Apply strategies and components to make our application responsive
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 应用策略和组件使我们的应用程序响应
- en: Display and navigate a local file directory tree
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 显示和导航本地文件目录树
- en: Use the Kivy inspector to debug our applications
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用Kivy检查器调试我们的应用程序
- en: Add scroll functionality to a list of results obtained from an Internet query
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 向从互联网查询得到的列表结果添加滚动功能
- en: This chapter wraps up a lot of knowledge acquired so far. We will be reviewing
    and combining the use of properties, events, animations, touches, behaviors, layouts,
    and even graphics. At the same time, we will introduce new widgets that will complement
    your knowledge, and serve as good examples of new programming situations. We will
    also review the Kivy inspector that will help us detect GUI bugs. At the end of
    this chapter, we will finish with a professional looking interface.
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 本章总结了迄今为止获得的大量知识。我们将回顾和结合使用属性、事件、动画、触摸、行为、布局，甚至图形。同时，我们将介绍新的小部件，这些小部件将补充您的知识，并作为新编程情况的好例子。我们还将回顾Kivy检查器，它将帮助我们检测GUI错误。在本章结束时，我们将完成一个看起来专业的界面。
- en: Video – play, pause, and stop
  id: totrans-9
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 视频 – 播放、暂停和停止
- en: 'We will start with simple code in this section, and then gradually include
    functionality until we get a complete video player. In this section, we will discuss
    how to use the **`Video`** widget in order to stream a *video* from the Internet.
    Let''s start with the code in the `video.kv` file:'
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们将从简单的代码开始，然后逐步添加功能，直到我们得到一个完整的视频播放器。在本节中，我们将讨论如何使用**`Video`**小部件从互联网上流式传输**视频**。让我们从`video.kv`文件中的代码开始：
- en: '[PRE0]'
  id: totrans-11
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: In this code, we initially create a constant value with the **`set`** directive
    (line 2). This directive allows us to have global values that we can use inside
    the Kivy language scope. For example, we set the `source` property of the `Video`
    class with the value of the `_default_video` constant (line 7).
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 在此代码中，我们最初使用**`set`**指令创建一个常量值（第2行）。此指令允许我们在Kivy语言范围内使用全局值。例如，我们使用`_default_video`常量的值设置`Video`类的`source`属性（第7行）。
- en: We set up three properties for the **`Video`** class. The **`allow_stretch`**
    property (line 5) allows the video to stretch according to the screen size available.
    The **`color`** property (line 6) will tint the video black, to serve as a foreground
    when the *video* is not playing (and a background for the *cover* image). The
    **`source`** property (line 7) contains the URL (or filename) of the video we
    want to play. These three properties actually belong to the **`Image`** widget,
    which is the base class for `Video`. This makes sense if we think of a video as
    a sequence of images (accompanied by a sound).
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 我们为**`Video`**类设置了三个属性。**`allow_stretch`**属性（第5行）允许视频根据可用的屏幕大小进行拉伸。**`color`**属性（第6行）将使视频变黑，当**视频**未播放时用作前景（以及**封面**图像的背景）。**`source`**属性（第7行）包含我们想要播放的视频的URL（或文件名）。这三个属性实际上属于**`Image`**小部件，它是`Video`的基础类。如果我们把视频看作是一系列图像（伴随声音），这就有意义了。
- en: Tip
  id: totrans-14
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 小贴士
- en: 'For test purposes, if you want to avoid constantly downloading the video from
    the Internet (or if the URL is not available anymore), you can replace the URL
    in `default_video` with a sample file that is included with the code: `samples/BigBuckBunny.ogg`.'
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 为了测试目的，如果您想避免不断从互联网下载视频（或者如果URL已经不可用），您可以将`default_video`中的URL替换为与代码一起提供的示例文件：`samples/BigBuckBunny.ogg`。
- en: We will use the **`Factory`** class to use the technique that we learned about
    in [Chapter 4](ch04.html "Chapter 4. Improving the User Experience"), *Improving
    the User Experience*. Back then, we used the **`Factory`** class to replace the
    `Line` vertex instruction with our personalized implementation, a ticker `Line`.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将使用 **`Factory`** 类来使用我们在 [第 4 章](ch04.html "第 4 章。改进用户体验") 中学到的技术，*改进用户体验*。当时，我们使用
    **`Factory`** 类来替换 `Line` 顶点指令，使用我们的个性化实现，一个滚动的 `Line`。
- en: Note
  id: totrans-17
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: The **`Factory`** class follows an oriented-object software design pattern called
    a factory pattern. A factory pattern returns default new objects (instances) of
    a subset of classes according to the called identifier, usually a method, but
    in the case of the Kivy languate we just use a name. ([http://en.wikipedia.org/wiki/Factory_%28object-oriented_programming%29](http://en.wikipedia.org/wiki/Factory_%28object-oriented_programming%29)).
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: '**`Factory`** 类遵循一种面向对象的软件设计模式，称为工厂模式。工厂模式根据调用标识符（通常是方法）返回默认的新对象（实例）的子集类。在
    Kivy 语言的情况下，我们只使用一个名称。([http://en.wikipedia.org/wiki/Factory_%28object-oriented_programming%29](http://en.wikipedia.org/wiki/Factory_%28object-oriented_programming%29))。'
- en: 'We will do something similar now, but this time we will personalize our `Video`
    widget:'
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在将做类似的事情，但这次我们将个性化我们的 `Video` 小部件：
- en: '[PRE1]'
  id: totrans-20
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: The `video.py` file will import the Kivy `Video` widget with an alias name `KivyVideo`
    (line 9). We will now be able to create our personalized widget (lines 16 to 32)
    using the `Video` class name and not a less attractive alternative name such as
    `MyVideo`. At the end of the file, we replace the default `Video` widget with
    our personalized `Video` to the `Factory` (lines 34 and 35). From now on, the
    referenced `Video` class in the Kivy language will correspond to our implementation
    in this file.
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: '`video.py` 文件将导入 Kivy 的 `Video` 小部件，并使用别名 `KivyVideo`（第 9 行）。现在我们将能够使用 `Video`
    类名称（而不是不那么吸引人的替代名称，如 `MyVideo`）创建我们的个性化小部件（第 16 行至 32 行）。在文件末尾，我们将默认的 `Video`
    小部件替换为我们的个性化 `Video` 并将其添加到 `Factory` 中（第 34 行和 35 行）。从现在起，Kivy 语言中引用的 `Video`
    类将对应于我们在此文件中的实现。'
- en: 'We created four methods (**`on_state`**, **`on_eos`**, **`_on_load`**, and
    **`on_source`**) in the `Video` class. All of them correspond to events:'
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在 `Video` 类中创建了四个方法（**`on_state`**、**`on_eos`**、**`_on_load`** 和 **`on_source`**）。所有这些都对应于事件：
- en: 'The **`on_state`** method (line 18) is called when the state of the *video*
    changes among its three possible states: playing (`''play''`), paused (`''pause''`),
    or stopped (`''stop''`). We make sure that when the video is stopped, it is re-positioned
    at the beginning with the **`seek`** method (line 20).'
  id: totrans-23
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 当视频在其三种可能状态（播放 `'play'`）、暂停 (`'pause'`) 或停止 (`'stop'`) 之间改变状态时，会调用 **`on_state`**
    方法（第 18 行）。我们确保当视频停止时，使用 **`seek`** 方法（第 20 行）将其重新定位到开始位置。
- en: The **`on_eos`** method (line 23) will be called when the **end of stream**
    (**EOS**) has been reached. We will make sure that the state is set to `stop`
    when this occurs (line 19).
  id: totrans-24
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 当达到 **流结束**（**EOS**）时，将调用 **`on_eos`** 方法（第 23 行）。当发生这种情况时，我们将确保将状态设置为 `stop`（第
    19 行）。
- en: We also need to remember that we tinted the video with black color using the
    `color` property in the Kivy language (line 6). Therefore, we need to put light
    (`1,1,1,1`) on the video in order to be able to see it (line 29). The method **`_on_load`**
    (line 27) is called when the video is loaded into memory and ready to play. We
    use this method in order to set the proper (and original Kivy default) `color`
    property.
  id: totrans-25
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们还需要记住，我们使用 Kivy 语言的 `color` 属性（第 6 行）将视频染成了黑色。因此，我们需要在视频上放置亮光（`1,1,1,1`）才能看到它（第
    29 行）。当视频被加载到内存中并准备好播放时，会调用 **`_on_load`** 方法（第 27 行）。我们使用此方法来设置适当的（以及原始 Kivy
    默认的）`color` 属性。
- en: Note
  id: totrans-26
  prefs:
  - PREF_IND
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: Remember in [Chapter 2](ch02.html "Chapter 2. Graphics – the Canvas"), *Graphics
    – the Canvas* that the `color` property of an `Image` widget (base class of the
    `Video` class) acts as a tint or light over the display. The same effect occurs
    for the `Video` widget.
  id: totrans-27
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 记住 [第 2 章](ch02.html "第 2 章。图形 – 画布")，*图形 – 画布* 中，`Image` 小部件（`Video` 类的基类）的
    `color` 属性在显示上充当着染色或光照。对于 `Video` 小部件，也会发生同样的效果。
- en: Finally, the **`on_source`** method, also inherited from the `Image` class,
    will restore the black tint on top of the video when the source of the video is
    changed.
  id: totrans-28
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 最后，从 `Image` 类继承的 **`on_source`** 方法将在更改视频源时在视频上方恢复黑色染色。
- en: 'Let''s proceed to create a `kivyplayer.py` file to execute our application,
    and also play, pause, and stop our video:'
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们继续创建一个 `kivyplayer.py` 文件来执行我们的应用程序，并播放、暂停和停止我们的视频：
- en: '[PRE2]'
  id: totrans-30
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'For now, we will control the video with touches. In the `build` method (line
    43), we have bound the `on_touch_down` event (line 45) of the video to the `touch_down`
    method (lines 48 to 54). One touch will play or pause the video according to its
    current **`state`** property (lines 49 and 52). The state property controls whether
    the video is in one of three possible states. If it is playing, it will pause
    it; otherwise (paused or stopped), it will play it. We will use the **`double_tap`**
    key that indicates a double touch (double tap or double click) in order to stop
    the video. Next time we touch the screen, the video will start from the beginning.
    Now, run the application (`Python kivyplayer.py`), and see how, as soon as you
    click on the screen, Kivy starts streaming Dan Gilbert''s video, *The Surprising
    Science of Happiness*, from TED ([http://www.ted.com/](http://www.ted.com/)):'
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 目前，我们将通过触摸来控制视频。在`build`方法（第43行）中，我们将视频的`on_touch_down`事件（第45行）绑定到`touch_down`方法（第48至54行）。一次触摸将根据视频当前的**`state`**属性（第49和52行）播放或暂停视频。状态属性控制视频是否处于三种可能状态之一。如果它在播放，则将其暂停；否则（暂停或停止），则播放它。我们将使用**`double_tap`**键来表示双击（双击或双击），以停止视频。下次我们触摸屏幕时，视频将从开头开始。现在，运行应用程序（`Python
    kivyplayer.py`），看看当你点击屏幕时，Kivy是如何立即开始从TED流式传输Dan Gilbert的视频《幸福的惊人科学》的（[http://www.ted.com/](http://www.ted.com/))：
- en: '![Video – play, pause, and stop](img/B04244_06_01.jpg)'
  id: totrans-32
  prefs: []
  type: TYPE_IMG
  zh: '![视频 – 播放、暂停和停止](img/B04244_06_01.jpg)'
- en: AsyncImage – creating a cover for the video
  id: totrans-33
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: AsyncImage – 为视频创建封面
- en: 'In this section, we will learn how to put up a *cover* that will be displayed
    when the video is not playing. This image will serve as a decoration when the
    video hasn''t started, and in the case of the TED video, it is usually an image
    that involves the speaker. Let''s start introducing a few changes in the code
    of `video.kv`:'
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们将学习如何设置一个将在视频不播放时显示的**封面**。当视频尚未开始时，此图像将作为装饰，在TED视频中，通常涉及演讲者的图像。让我们从在`video.kv`代码中引入一些更改开始：
- en: '[PRE3]'
  id: totrans-35
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: In this code, we created another constant (`_default_image`) with the **`set`**
    directive (line 60), and a related property (`image`) for the `Video` class that
    references the constant (line 64). We also created the `cover` property (line
    63) to reference `AsyncImage` that we added to the `Video` class (line 66), and
    that will serve as the cover for the video.
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 在此代码中，我们使用**`set`**指令（第60行）创建了一个另一个常量（`_default_image`），并为`Video`类创建了一个相关属性（`image`），该属性引用了常量（第64行）。我们还创建了`cover`属性（第63行），以引用我们添加到`Video`类中的`AsyncImage`（第66行），它将作为视频的封面。
- en: Note
  id: totrans-37
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: The main difference between `Image` and `AsyncImage` is that the **`AsyncImage`**
    widget allows us to continue using the program while the image is loading, instead
    of blocking the application until the image is completely downloaded.
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: '`Image`和`AsyncImage`之间的主要区别在于，**`AsyncImage`**小部件允许我们在图片加载时继续使用程序，而不是在图片完全下载之前阻塞应用程序。'
- en: 'This is important, since we download the image from the Internet and it could
    be a big file. When you run the code, you will notice that a waiting image will
    appear while the image is loading:'
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 这很重要，因为我们从互联网上下载图像，它可能是一个大文件。当你运行代码时，你会注意到在图像加载时会出现一个等待的图像：
- en: '![AsyncImage – creating a cover for the video](img/B04244_06_02.jpg)'
  id: totrans-40
  prefs: []
  type: TYPE_IMG
  zh: '![AsyncImage – 为视频创建封面](img/B04244_06_02.jpg)'
- en: We also set some of the `AsyncImage` properties. We initialized the `source`
    property (line 68) with the new property (`root.image`) that we created in the
    `Video` widget to reference the cover image (line 64). Remember that this will
    internally bind the properties, meaning that each time that we change the `image`
    property, the `source` property will be updated to the same value. Line 69 repeats
    the same idea in order to keep the cover's `size` property equal to the dimensions
    of the video.
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还设置了一些`AsyncImage`属性。我们使用新属性（`root.image`）（第68行）初始化了`source`属性，该属性我们在`Video`小部件中创建，以引用封面图像（第64行）。请记住，这将内部绑定属性，这意味着每次我们更改`image`属性时，`source`属性都将更新为相同的值。第69行重复了相同的思想，以保持封面的`size`属性与视频的尺寸相等。
- en: Tip
  id: totrans-42
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 小贴士
- en: 'For test purposes, you can replace the URL in `default_image` with the following
    sample file included with the code:'
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 为了测试目的，您可以将`default_image`中的URL替换为代码中包含的以下示例文件：
- en: '`samples/BigBuckBunny.png`.'
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: '`samples/BigBuckBunny.png`。'
- en: 'We will introduce some changes to our `Video` widget in order to make sure
    that the cover is removed (hidden) when the video is being played:'
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将对我们的`视频`小部件进行一些修改，以确保在播放视频时封面被移除（隐藏）：
- en: '[PRE4]'
  id: totrans-46
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: We changed the **`on_state`** method to uncover the video when it is playing
    (line 79), and cover it again when the video is stopped (line 82) using the *opacity*
    property.
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将 **`on_state`** 方法改为在视频播放时（第 79 行）揭示视频，并在视频停止时（第 82 行）再次使用 *不透明度* 属性覆盖它。
- en: Tip
  id: totrans-48
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 提示
- en: Avoid removing widgets that are declared in the `.kv` file. Most of the time,
    these widgets have internal bounds with other widgets (for example, property bounds),
    and can cause unexpected runtime errors related to missing internal references
    and inconsistent bound properties.
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 避免移除在 `.kv` 文件中声明的部件。大多数情况下，这些部件与其他部件（例如，属性边界）有内部边界，并可能导致与缺失内部引用和不一致的边界属性相关的意外运行时错误。
- en: Instead of removing widgets, there are several alternatives; for example, firstly,
    use the **`opacity`** property to make a widget invisible, secondly, make the
    widget area equal to zero using the `size` property (`size = (0,0)`), and thirdly,
    use the `pos` property to place the widget in a location that will never be displayed
    (`pos= (99999,999999)`). We chose the first approach; in this case, it is the
    most elegant. We set the **`opacity`** property of `AsyncImage` to make it visible
    (`opacity = 1`) or invisible (`opacity = 0`).
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 与移除部件相比，有几种替代方案；例如，首先，使用 **`opacity`** 属性使部件不可见，其次，使用 `size` 属性将部件区域设置为零（`size
    = (0,0)`），最后，使用 `pos` 属性将部件放置在一个永远不会显示的位置（`pos= (99999,999999)`）。我们选择了第一种方法；在这种情况下，这是最优雅的。我们将
    `AsyncImage` 的 **`opacity`** 属性设置为使其可见（`opacity = 1`）或不可见（`opacity = 0`）。
- en: Tip
  id: totrans-51
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 提示
- en: Even though controlling the cover with the opacity to make it invisible may
    be the most elegant solution here, you have to be careful because the widget is
    still there, occupying space on the screen. Depending on the situation, you might
    have to extend the strategy. For example, if the widget captures some touch events,
    you can combine the **`opacity`** and **`disabled`** properties to hide and disable
    the widget.
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管使用不透明度控制覆盖以使其不可见可能是这里最优雅的解决方案，但你必须小心，因为部件仍然存在，占据了屏幕上的空间。根据情况，你可能需要扩展策略。例如，如果部件捕获了一些触摸事件，你可以结合
    **`opacity`** 和 **`disabled`** 属性来隐藏和禁用部件。
- en: We also created the `image` property (line 75), and used its `on_image` associated
    event (line 85) to make sure that the opacity is restored (line 86) if the image
    is changed. Now, an image of Dan Gilbert will appear when you run the application
    (`python kivyplayer.py`).
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还创建了 `image` 属性（第 75 行），并使用其 `on_image` 关联事件（第 85 行）确保在更改图像时恢复不透明度（第 86 行）。现在，当你运行应用程序时（`python
    kivyplayer.py`），将出现丹·吉尔伯特的图像。
- en: Subtitles – tracking the video progression
  id: totrans-54
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 字幕 – 跟踪视频进度
- en: 'Let''s add subtitles to our application. We will do this in four simple steps:'
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们在我们的应用程序中添加字幕。我们将通过四个简单的步骤来完成这项工作：
- en: Create a `Subtitle` widget (`subtitle.kv`) derived from the `Label` class that
    will display the subtitles
  id: totrans-56
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个从 `Label` 类派生的 `Subtitle` 部件（`subtitle.kv`），用于显示字幕
- en: Place a `Subtitle` instance (`video.kv`) on top of the video widget
  id: totrans-57
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在视频部件上方放置一个 `Subtitle` 实例（`video.kv`）
- en: Create a `Subtitles` class (`subtitles.py`) that will read and parse a subtitle
    file
  id: totrans-58
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个 `Subtitles` 类（`subtitles.py`），用于读取和解析字幕文件
- en: Track the `Video` progression (`video.py`) to display the corresponding subtitle
  id: totrans-59
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 跟踪 `Video` 进度（`video.py`）以显示相应的字幕
- en: 'The *Step 1* involves the creation of a new widget in the `subtitle.kv` file:'
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: '*步骤 1* 包括在 `subtitle.kv` 文件中创建一个新的部件：'
- en: '[PRE5]'
  id: totrans-61
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: There are two interesting elements in this code. The first one is the definition
    of the size property (line 92). We define it as 20 pixels bigger than the **`texture_size`**
    width and height. The **`texture_size`** property indicates the size of the text
    determined by the font size and text, and we use it to adjust the `Subtitles`
    widget size to its content.
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 这段代码中有两个有趣的元素。第一个是大小属性的定义（第 92 行）。我们将其定义为比 **`texture_size`** 宽度和高度大 20 像素。**`texture_size`**
    属性表示由字体大小和文本确定的文本大小，我们使用它来调整 `Subtitles` 部件的大小以适应其内容。
- en: Note
  id: totrans-63
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: The **`texture_size`** is a read-only property because its value is calculated
    and dependent on other parameters, such as font size and height for text display.
    This means that we will read from this property but not write on it.
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: '**`texture_size`** 是一个只读属性，因为它的值是根据其他参数计算的，例如字体大小和文本显示的高度。这意味着我们将从这个属性中读取，但不会在其上写入。'
- en: The second element is the creation of the `bcolor` property (line 94) to store
    a background color, and how the `rgba` color of the rectangle has been bound to
    it (line 97). The `Label` widget (like many other widgets) doesn't have a background
    color, and creating a rectangle is the usual way to create such features. We add
    the `bcolor` property in order to change the color of the rectangle from outside
    the instance.
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 第二个元素是创建`bcolor`属性（第94行）以存储背景颜色，以及如何将矩形的`rgba`颜色绑定到它（第97行）。`Label`小部件（像许多其他小部件一样）没有背景颜色，创建一个矩形是创建此类功能的常用方法。我们添加`bcolor`属性是为了从实例外部更改矩形的颜色。
- en: Tip
  id: totrans-66
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 提示
- en: We cannot directly modify parameters of the vertex instructions; however, we
    can create properties that control parameters inside the vertex instructions.
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 我们不能直接修改顶点指令的参数；然而，我们可以创建控制顶点指令内部参数的属性。
- en: 'Let''s move on to *Step 2* mentioned earlier. We need to add a `Subtitle` instance
    to our current `Video` widget in the `video.kv` file:'
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们继续之前提到的*第2步*。我们需要在`video.kv`文件中向当前的`Video`小部件添加一个`Subtitle`实例：
- en: '[PRE6]'
  id: totrans-69
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: We added another constant variable called `_default_surl` (line 103), which
    contains the link to the URL with the corresponding subtitle TED video file. We
    set this value to the `surl` property (line 106), which we just created to store
    the subtitles' URL. We added the `slabel` property (line 107), that references
    the `Subtitle` instance through its ID (line 111). Then we made sure that the
    subtitle is centered (line 112).
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 我们添加了一个名为`_default_surl`的另一个常量变量（第103行），其中包含对应TED视频字幕文件的URL链接。我们将此值设置为`surl`属性（第106行），这是我们刚刚创建的用于存储字幕URL的属性。我们添加了`slabel`属性（第107行），通过其ID引用`Subtitle`实例（第111行）。然后我们确保字幕居中（第112行）。
- en: 'In order to start *Step 3* (parse the subtitle file), we need to take a look
    at the format of the TED subtitles:'
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 为了开始*第3步*（解析字幕文件），我们需要查看TED字幕的格式：
- en: '[PRE7]'
  id: totrans-72
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'TED uses a very simple JSON format ([https://en.wikipedia.org/wiki/JSON](https://en.wikipedia.org/wiki/JSON))
    with a list of `captions`. Each `caption` contains four keys but we will only
    use `duration`, `content`, and `startTime`. We need to parse this file, and luckily
    Kivy provides a **`UrlRequest`** class (line 121) that will do most of the work
    for us. Here is the code for `subtitles.py` that creates the `Subtitles` class:'
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: TED使用一个非常简单的JSON格式（[https://en.wikipedia.org/wiki/JSON](https://en.wikipedia.org/wiki/JSON)），其中包含一个字幕列表。每个`caption`包含四个键，但我们只会使用`duration`、`content`和`startTime`。我们需要解析这个文件，幸运的是，Kivy提供了一个**`UrlRequest`**类（第121行），它将为我们完成大部分工作。以下是创建`Subtitles`类的`subtitles.py`代码：
- en: '[PRE8]'
  id: totrans-74
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: The constructor of the `Subtitles` class will receive a URL (line 125) as a
    parameter. Then, it will make the petition to instantiate the **`UrlRequest`**
    class (line 127). The first parameter of the class instantiation is the URL of
    the petition, and the second is the method that is called when the result of the
    petition is returned (downloaded). Once the request returns the result, the method
    `got_subtitles` is called(line 129). The **`UrlRequest`** extracts the JSON and
    places it in the second parameter of `got_subtitles`. All we had to do is put
    the captions in a class attribute, which we called `subtitles` (line 130).
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: '`Subtitles`类的构造函数将接收一个URL（第125行）作为参数。然后，它将发出请求以实例化**`UrlRequest`**类（第127行）。类实例化的第一个参数是请求数据的URL，第二个参数是当请求数据返回（下载）时调用的方法。一旦请求返回结果，就会调用`got_subtitles`方法（第129行）。**`UrlRequest`**提取JSON并将其放置在`got_subtitles`的第二个参数中。我们只需将字幕放入一个类属性中，我们称之为`subtitles`（第130行）。'
- en: The `next` method (line 132) receives the seconds (`secs`) as a parameter and
    will traverse the loaded JSON dictionary in order to search for the corresponding
    subtitle that belongs to that time. As soon as it finds one, the method returns
    it. We subtracted `12000` microseconds (line 134, `ms = secs*1000 - 12000`) because
    the TED videos have an introduction of approximately 12 seconds before the talk
    starts.
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: '`next`方法（第132行）接收秒数（`secs`）作为参数，并将遍历加载的JSON字典以查找对应于该时间的字幕。一旦找到，该方法就返回它。我们减去了`12000`微秒（第134行，`ms
    = secs*1000 - 12000`），因为TED视频在演讲开始前大约有12秒的介绍。'
- en: 'Everything is ready for *Step 4*, in which we put the pieces together in order
    to see the subtitles working. Here are the modifications to the header of the
    `video.py` file:'
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 一切都为*第4步*做好了准备，在这一步中，我们将所有部件组合起来以查看字幕是否工作。以下是`video.py`文件头部的修改：
- en: '[PRE9]'
  id: totrans-78
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'We imported `StringProperty` and added the corresponding property (line 142).
    We will use this property by the end of this chapter when we we can switch TED
    talks from the GUI. For now, we will just use `_default_surl` defined in `video.kv`
    (line 150). We also loaded the `subtitle.kv` file (line 146). Now, let''s analyze
    the rest of the changes to the `video.py` file:'
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 我们导入了`StringProperty`并添加了相应的属性（第142行）。在本章结束时，我们将使用此属性在GUI中切换TED演讲。目前，我们只需使用在`video.kv`中定义的`_default_surl`（第150行）。我们还加载了`subtitle.kv`文件（第146行）。现在，让我们分析对`video.py`文件的其他更改：
- en: '[PRE10]'
  id: totrans-80
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: We introduced a few code lines to the `on_source` method in order to initialize
    the subtitles attribute with a `Subtitles` instance (line 154) using the `surl`
    property and initialize the `sub` attribute that contains the currently displayed
    subtitle (line 155), if any.
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在`on_source`方法中添加了一些代码行，以便使用`surl`属性初始化字幕属性为`Subtitles`实例（第154行），并初始化包含当前显示字幕的`sub`属性（如果有的话）（第155行）。
- en: Now, let's study how we keep track of the progression to display the corresponding
    subtitle. When the video plays inside the `Video` widget, the `on_position` event
    is triggered every second. Therefore, we implemented the logic to display the
    subtitles in the `on_position` method (lines 157 to 165). Each time the `on_position`
    method is called (each second), we ask the `Subtitles` instance (line 158) for
    the next subtitle. If nothing is returned, we clear the subtitle with the `clear_subtitle`
    method (line 160). If there is already a subtitle in the current second (line
    161), then we make sure that there is no subtitle being displayed, or that the
    returned subtitle is not the one that we already display (line 164). If the conditions
    are met, we display the subtitle using the `display_subtitle` method (line 165).
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们研究如何跟踪进度以显示相应的字幕。当视频在`Video`小部件内播放时，每秒都会触发`on_position`事件。因此，我们在`on_position`方法（第157至165行）中实现了显示字幕的逻辑。每次调用`on_position`方法（每秒），我们都会要求`Subtitles`实例（第158行）提供下一个字幕。如果没有返回任何内容，我们使用`clear_subtitle`方法（第160行）清除字幕。如果当前秒已经有一个字幕（第161行），那么我们确保没有字幕正在显示，或者返回的字幕不是我们已显示的字幕（第164行）。如果条件满足，我们使用`display_subtitle`方法（第165行）显示字幕。
- en: 'Notice that the `clear_subtitle` (lines 167 to 171) and `display_subtitle`
    (lines 173 to 176) methods use the `bcolor` property in order to hide the subtitle.
    This is another trick to make a widget invisible without removing it from its
    parent. Let''s take a look at the current result of our videos and subtitles in
    the following screenshot:'
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 注意到`clear_subtitle`（第167至171行）和`display_subtitle`（第173至176行）方法使用`bcolor`属性来隐藏字幕。这是在不从其父元素中删除的情况下使小部件不可见的另一个技巧。让我们看看以下屏幕截图中我们的视频和字幕的当前结果：
- en: '![Subtitles – tracking the video progression](img/B04244_06_03.jpg)'
  id: totrans-84
  prefs: []
  type: TYPE_IMG
  zh: '![字幕 – 跟踪视频进度](img/B04244_06_03.jpg)'
- en: Control bar – adding buttons to control the video
  id: totrans-85
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 控制栏 – 添加按钮以控制视频
- en: In this section, we will work on user interaction with the application. Right
    now, we control the video with touches on the screen that play, pause, and stop
    the video. However, this is not very intuitive for a new user of our application.
    So, let's add some buttons to improve the usability of our application.
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们将处理用户与应用程序的交互。目前，我们通过在屏幕上触摸来控制视频，实现播放、暂停和停止视频。然而，这对我们应用程序的新用户来说并不直观。因此，让我们添加一些按钮来提高我们应用程序的可用性。
- en: 'We will use `Image` widgets enhanced with `ToggleButtonBehaviour` and `ToggleBehaviour`
    classes in order to create buttons for a *play*/*pause* button and a *stop* button,
    respectively. Here is a cropped screenshot of the simple *control bar* that we
    will be implementing in this section:'
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将使用带有`ToggleButtonBehaviour`和`ToggleBehaviour`类的`Image`小部件来创建*播放*/*暂停*按钮和*停止*按钮。以下是本节中将实现的简单*控制栏*的截屏：
- en: '![Control bar – adding buttons to control the video](img/B04244_06_04.jpg)'
  id: totrans-88
  prefs: []
  type: TYPE_IMG
  zh: '![控制栏 – 添加按钮以控制视频](img/B04244_06_04.jpg)'
- en: 'Let''s start defining our two widgets for `controlbar.kv`. We will cover each
    widget one by one. Let''s start with the header of the file and the `ControlBar`
    class definition:'
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们从定义我们的两个`controlbar.kv`小部件开始。我们将逐一介绍每个小部件。让我们从文件的标题和`ControlBar`类定义开始：
- en: '[PRE11]'
  id: totrans-90
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'We derived the `ControlBar` class from the `GridLayout` class and set some
    familiar properties. We also created a reference to the *play*/*pause* button,
    and one new property (`progress`) that will track the percentage (from 0 to 1)
    of the progress of the video. Let''s continue with the first embedded widget,
    `VideoPlayPause`:'
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 我们从`GridLayout`类派生了`ControlBar`类，并设置了一些熟悉的属性。我们还创建了对*播放*/*暂停*按钮的引用，以及一个新属性（`progress`），它将跟踪视频的进度百分比（从0到1）。让我们继续处理第一个嵌入的小部件，`VideoPlayPause`：
- en: '[PRE12]'
  id: totrans-92
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'As we will see in `controlbar.py`, `VideoPlayPause` is a combination of `Image`
    and `ToggleButtonBehavior`. We implemented the `source` property (line 192) in
    a way that changes the image of the widget according to the changes in the `state`
    property, `normal` and `down`. Let''s now see the code for `VideoStop`:'
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我们在`controlbar.py`中将要看到的，`VideoPlayPause`是`Image`和`ToggleButtonBehavior`的组合。我们以这种方式实现了`source`属性（第192行），即根据`state`属性的变化（`normal`和`down`）改变小部件的图像。现在让我们看看`VideoStop`的代码：
- en: '[PRE13]'
  id: totrans-94
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'Apart from defining some familiar properties, we have bound the event `on_press`
    to the `stop` method (line 197), which will be shown in the corresponding `controlbar.py`
    file. Notice that we are assuming that the parent of the root contains a reference
    to the video (`root.parent.video`). We will continue working under this assumption
    in `controlbar.py`:'
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 除了定义一些熟悉的属性外，我们还把事件`on_press`绑定到了`stop`方法（第197行），这将在相应的`controlbar.py`文件中展示。请注意，我们假设根的父元素包含对视频的引用（`root.parent.video`）。我们将在`controlbar.py`中继续这个假设：
- en: '[PRE14]'
  id: totrans-96
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: This code imports the necessary classes as well as `'controlbar.kv'` (lines
    198 to 203). Then, using multiple inheritance, it defines the `VideoPlayPause`
    and `VideoStop` classes as a combination of the `Image` class and the appropriate
    behavior (lines 205 and 208). The `VideoStop` class contains the `stop` method,
    which is called when the button is pressed (line 208). This will set the *play*/*pause*
    button state to normal and stop the video (line 212).
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 此代码导入了必要的类以及`'controlbar.kv'`（第198到203行）。然后，使用多重继承，它将`VideoPlayPause`和`VideoStop`类定义为`Image`类和适当行为的组合（第205和208行）。`VideoStop`类包含一个`stop`方法，当按钮被按下时调用（第208行）。这将把*播放*/*暂停*按钮状态设置为正常并停止视频（第212行）。
- en: 'We will also define a *video controller*, which will be the parent of the *control
    bar* and *video*, in the `videocontroller.kv` file:'
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还将在`videocontroller.kv`文件中定义一个*视频控制器*，它将是*控制栏*和*视频*的父元素：
- en: '[PRE15]'
  id: totrans-99
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'First, we defined five properties for `VideoContoller` (lines 215 to 219):
    `video`, `control_bar`, `play_pause`, `control_bar_width`, and `playing`. The
    first three properties reference components of the interface, `control_bar_width`
    will be used to externally control the width of the *control bar*, and the `playing`
    property will indicate whether the video is playing or not (line 219).'
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们为`VideoContoller`定义了五个属性（第215到219行）：`video`、`control_bar`、`play_pause`、`control_bar_width`和`playing`。前三个属性引用界面组件，`control_bar_width`将用于外部控制*控制栏*的宽度，而`playing`属性将指示视频是否正在播放（第219行）。
- en: We then added a `Video` instance (line 221), whose state will depend on the
    state of the *play*/*pause* button (line 223), and a `ControlBar` instance. The
    `width` property of the *control bar* will be controlled by `control_bar_width`
    (line 227) that we previously created (line 218), and the `progress` property
    will be expressed as a percentage of the duration (line 228).
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们添加了一个`Video`实例（第221行），其状态将取决于*播放*/*暂停*按钮的状态（第223行），以及一个`ControlBar`实例。*控制栏*的`width`属性将由我们之前创建的`control_bar_width`（第227行）控制，而`progress`属性将以持续时间的百分比表示（第228行）。
- en: 'Now, we need to create the `VideoController` class in its respective `videocontroller.py`
    file:'
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们需要在各自的`videocontroller.py`文件中创建`VideoController`类：
- en: '[PRE16]'
  id: totrans-103
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'We just included the necessary imports, and defined `VideoController` as a
    derived class of `FloatLayout`. The `kivyplayer.py` file also has to be updated
    in order to display a `VideoController` instance instead of `Video`:'
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 我们只包含了必要的导入，并将`VideoController`定义为`FloatLayout`的派生类。`kivyplayer.py`文件也必须更新，以便显示`VideoController`实例而不是`Video`：
- en: '[PRE17]'
  id: totrans-105
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: Feel free to run an application again to test the *play*/*pause* and *stop*
    buttons. The next section will introduce a *progression bar* to our application.
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 随意再次运行应用程序以测试*播放*/*暂停*和*停止*按钮。下一节将向我们的应用程序引入*进度条*。
- en: Slider – including a progression bar
  id: totrans-107
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 滑块 - 包括进度条
- en: 'In this section, we will introduce a new widget called **`Slider`**. This widget
    will serve as a *progression bar*, but at the same time it will allow the user
    to forward and reverse the video. We will integrate the *progression bar* into
    the *control bar*, as shown in the following cropped screenshot:'
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们将介绍一个新的小部件，称为 **`Slider`**。这个小部件将作为 *进度条*，同时允许用户快进和倒退视频。我们将 *进度条* 集成到
    *控制栏* 中，如下面的裁剪截图所示：
- en: '![Slider – including a progression bar](img/B04244_06_05.jpg)'
  id: totrans-109
  prefs: []
  type: TYPE_IMG
  zh: '![Slider – including a progression bar](img/B04244_06_05.jpg)'
- en: 'As you can see, `Slider` appears to the left of the *play*/*pause* and *stop*
    buttons. Let''s change `controlbar.kv` to add `Slider` to reflect this order.
    Let''s start with the header of the file and the `ControlBar` class definition:'
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 如您所见，`Slider` 出现在 *播放*/*暂停* 和 *停止* 按钮的左侧。让我们将 `controlbar.kv` 修改为添加 `Slider`
    以反映这种顺序。让我们从文件的标题和 `ControlBar` 类的定义开始：
- en: '[PRE18]'
  id: totrans-111
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: '`VideoSlider` will keep the **`value`** property updated with the progression
    of the video. The **`value`** property indicates the location of the slider on
    the bar, and the **`max`** property is the maximum value that it can take. In
    this case, `1` is appropriate because we express the progression as a percentage
    (from 0 to 1) of the duration (line 255).'
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: '`VideoSlider` 将使用视频的进度来更新其 **`value`** 属性。**`value`** 属性表示滑块在条上的位置，而 **`max`**
    属性是它可以取的最大值。在这种情况下，`1` 是合适的，因为我们用从 0 到 1 的百分比（表示持续时间）来表示进度（第255行）。'
- en: 'Let''s now add the definition of `VideoSlider` in the `controlbar.py` file:'
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们将 `VideoSlider` 的定义添加到 `controlbar.py` 文件中：
- en: '[PRE19]'
  id: totrans-114
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'Controlling the progression of the video with a slider is tricky because the
    video and the slider need to constantly update each other. The video updates the
    slider to indicate its progress, and the slider updates the video when the user
    wants to forward or reverse the video. This creates an entangled logic, in which
    we have to take into account the following considerations:'
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 使用滑块控制视频的进度很棘手，因为视频和滑块需要不断互相更新。视频通过更新滑块来指示其进度，而当用户想要快进或倒退视频时，滑块会更新视频。这创建了一个复杂的逻辑，我们必须考虑以下因素：
- en: We need to use touch events because we want to make sure it is the user who
    is moving the slider and not the video progression.
  id: totrans-116
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们需要使用触摸事件，因为我们想确保是用户在移动滑块，而不是视频进度。
- en: There seems to be an infinite loop; we update the slider, the slider uploads
    the video, and the video updates the slider.
  id: totrans-117
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 似乎存在一个无限循环；我们更新了滑块，滑块上传了视频，然后视频又更新了滑块。
- en: The user might not necessarily just click on the slider, he could potentially
    drag it, and during the dragging time, the video updates the slider again.
  id: totrans-118
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 用户可能不仅会点击滑块，还可能拖动它，在拖动过程中，视频会再次更新滑块。
- en: 'For these reasons, we need to execute the following steps:'
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 由于这些原因，我们需要执行以下步骤：
- en: Pause the video before updating the progression (line 267).
  id: totrans-120
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在更新进度之前暂停视频（第267行）。
- en: Not update the slider directly with the value property, but instead update the
    video progression with the `seek` method (line 275).
  id: totrans-121
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 不要直接使用值属性更新滑块，而是使用 `seek` 方法（第275行）更新视频进度。
- en: Use the two events `on_touch_down` (line 262) and `on_touch_up` (line 270),
    in order to safely change the progression percentage of the video.
  id: totrans-122
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用两个事件 `on_touch_down`（第262行）和 `on_touch_up`（第270行），以便安全地更改视频的进度百分比。
- en: In the `on_touch_down` method (lines 262 to 268), we have stored the current
    state of the video (line 265), and a reference to the touch (line 266), and then
    we have paused the video (line 267). If we don't pause the video, the progression
    of the video could affect the slider (remember that the `value` of slider is bound
    to the `progression` property in line 254) before we update the video to the progression
    of the slider. In the `on_touch_up` event, we made sure that the touch instance
    corresponds to the one that we stored in the `on_touch_down` method (lines 272
    and 273). Then, we set the video to the right place according to the position
    of the slider, with the **`seek`** method (line 275). Finally, we re-established
    the previous state of the video if it was different from `stop` (lines 276 and
    277).
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 在`on_touch_down`方法（第262至268行）中，我们存储了视频的当前状态（第265行），以及触摸的引用（第266行），然后我们暂停了视频（第267行）。如果我们不暂停视频，在更新视频到滑块的进度之前，视频的进度可能会影响滑块（记住滑块的`value`在第254行绑定到`progression`属性）。在`on_touch_up`事件中，我们确保触摸实例与我们在`on_touch_down`方法中存储的实例相对应（第272和273行）。然后，我们使用**`seek`**方法（第275行）根据滑块的位置设置视频到正确的位置。最后，如果视频的状态与`stop`不同，我们重新建立视频的先前状态（第276和277行）。
- en: Feel free to run the application again. You can also experiment with the slider
    and different options to update the video. Try, for example, a real-time update
    while you drag the slider through the `on_touch_move` event.
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 随意再次运行应用程序。您还可以通过不同的选项和滑块来更新视频进行实验。例如，尝试在拖动滑块通过`on_touch_move`事件时实时更新。
- en: Animation – hiding a widget
  id: totrans-125
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 动画 – 隐藏小部件
- en: 'In this section, we will make the *control bar* disappear when the video starts
    playing in order to watch the video without visual distractions. We need to change
    the `videocontroller.py` file in order to animate the `ControlBar` instance:'
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们将使*控制栏*在视频开始播放时消失，以便在没有视觉干扰的情况下观看视频。我们需要更改`videocontroller.py`文件以动画化`ControlBar`实例：
- en: '[PRE20]'
  id: totrans-127
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: Along with the necessary imports at the beginning of the file (lines 280 and
    281), we introduced the `playing` property (line 284) and two methods associated
    with the `on_playing` event and the `on_touch_down` event. The `playing` property
    was already defined in the Kivy language (line 219), but remember that, due to
    the file parsing order, we also need to define it in the Python language if we
    want to use the property in the same class.
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 除了文件开头必要的导入（第280和281行）之外，我们还引入了`playing`属性（第284行）以及与`on_playing`事件和`on_touch_down`事件相关的两个方法。`playing`属性已经在Kivy语言中定义（第219行），但请记住，由于文件解析顺序，如果我们想在同一类中使用该属性，我们还需要在Python语言中定义它。
- en: When the `playing` property changes, the `on_playing` event is triggered (line
    286). This method starts an animation (line 290) and disables the *control bar*
    when the video is playing (line 289). The animation will hide the *control bar*
    at the bottom of the screen. The `on_playing` method will also restore the *control
    bar* (lines 292 to 294), when the video is not playing so it will be visible again.
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 当`playing`属性改变时，会触发`on_playing`事件（第286行）。此方法开始一个动画（第290行）并在视频播放时禁用*控制栏*（第289行）。动画将隐藏屏幕底部的*控制栏*。当视频不播放时，`on_playing`方法也会恢复*控制栏*（第292至294行），使其再次可见。
- en: Since the *control bar* will be hidden when the video is playing, we need an
    alternate way to stop the video (different from the **Stop** button). This is
    the reason we included the `on_touch_down` event (line 296). As soon as we touch
    the screen, the animation, if it exists, is cancelled (line 298), and the *play*/*pause*
    button is set to `'normal'` (line 300). This will pause the video and therefore,
    trigger the `on_playing` event (in this case, because it stopped playing) that
    we just defined.
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 由于*控制栏*将在视频播放时隐藏，我们需要一种替代方法来停止视频（不同于**停止**按钮）。这就是为什么我们包括了`on_touch_down`事件（第296行）。一旦我们触摸屏幕，如果存在动画，动画将被取消（第298行），并将**播放**/*暂停*按钮设置为`'normal'`（第300行）。这将暂停视频并因此触发我们刚刚定义的`on_playing`事件（在这种情况下，因为它停止了播放）。
- en: You can now run the application again and appreciate how the *control bar* slowly
    disappears down the bottom of the screen as soon as we press the **Play**/**Pause**
    button.
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 您现在可以再次运行应用程序并欣赏当我们按下**播放**/**暂停**按钮时，*控制栏*如何缓慢地消失到屏幕底部。
- en: Kivy inspector – debugging interfaces
  id: totrans-132
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Kivy检查器 – 调试界面
- en: 'Sometimes, we encounter problems when we implement our interfaces, and it can
    be difficult to understand what went wrong, especially when many of the widgets
    don''t have a graphic display. In this section, we will use the application that
    we created in this chapter to introduce the Kivy **inspector**, a simple tool
    to debug interfaces. In order to start the inspector, you run the following command:
    `python kivyplayer.py –m inspector`. You won''t notice any difference at the beginning
    but if you press *Ctrl* + *E*, a bar will appear at the bottom of the screen,
    just like the one in the left screenshot of the following image:'
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 有时，我们在实现我们的界面时会遇到问题，特别是当许多部件没有图形显示时，理解出了什么问题可能很困难。在本节中，我们将使用本章中创建的应用程序来介绍Kivy
    **检查器**，这是一个简单的调试界面的工具。为了启动检查器，您运行以下命令：`python kivyplayer.py –m inspector`。一开始您可能不会注意到任何区别，但如果您按下*Ctrl*
    + *E*，屏幕底部将出现一个栏，就像以下图像左图中的那样：
- en: '![Kivy inspector – debugging interfaces](img/B04244_06_06.jpg)'
  id: totrans-134
  prefs: []
  type: TYPE_IMG
  zh: '![Kivy检查器 – 调试界面](img/B04244_06_06.jpg)'
- en: If we press the button **Move to Top** (the first from left to right in the
    bar), the bar will move to the top of the screen as you can see in the right screenshot,
    a more convenient position for our particular application. The second button **Inspect**
    activates or deactivates the inspector behavior. We can now highlight components
    by clicking on them.
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们按下**移至顶部**按钮（从左到右数第一个），则栏将移动到屏幕顶部，正如您在右图中所见，这对于我们的特定应用来说是一个更方便的位置。第二个按钮**检查**激活或关闭检查器行为。我们现在可以通过点击来高亮显示组件。
- en: 'For example, if you click on the *play*/*pause* button, the video won''t play;
    instead, the button will be highlighted with a red tone as you can see in the
    following left screenshot:'
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，如果您点击*播放*/*暂停*按钮，视频将不会播放；相反，按钮将以红色高亮显示，正如您在下面的左图中所见：
- en: '![Kivy inspector – debugging interfaces](img/B04244_06_07.jpg)'
  id: totrans-137
  prefs: []
  type: TYPE_IMG
  zh: '![Kivy检查器 – 调试界面](img/B04244_06_07.jpg)'
- en: 'Moreover, if we want to visualize the widget that is currently highlighted,
    we just have to press the button **Parent** (third left to right on the bar).
    In the right screenshot, you can see how the *control bar* (parent of the *play*/*pause*
    button) is highlighted instead. You should also notice how the long button (fourth
    left to right on the bar) shows the class that the highlighted instance belongs
    to. If we click on this button, the entire list of properties for that widget
    will be displayed, as shown in the following left screenshot:'
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，如果我们想可视化当前高亮的部件，我们只需按下**父级**按钮（从左到右数第三个）。在右图中，您可以看到*控制栏*（*播放*/*暂停*按钮的父级）被高亮显示。您还应该注意，长按钮（从左到右数第四个）显示了高亮实例所属的类。如果我们点击此按钮，将显示该部件的所有属性列表，如以下左图所示：
- en: '![Kivy inspector – debugging interfaces](img/B04244_06_08.jpg)'
  id: totrans-139
  prefs: []
  type: TYPE_IMG
  zh: '![Kivy检查器 – 调试界面](img/B04244_06_08.jpg)'
- en: Finally, when we select one of the properties, we are able to modify it. For
    example, in the right screenshot, we modified the width property of the *control
    bar*, and we can see how the *control bar* immediately adjusts to the changes.
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，当我们选择一个属性时，我们能够修改它。例如，在右图中，我们修改了*控制栏*的宽度属性，我们可以看到*控制栏*立即调整到这些变化。
- en: Remember that since the Kivy widgets are kept as simple as possible, it means
    that a lot of the times they are invisible because a more complex graphic to display
    means an unnecessary overload. However, this behavior makes it difficult for us
    to find errors in the GUI. So when our interface does not display what we expect,
    the inspector becomes very handy to help us understand the underlying tree structure
    of the GUI.
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 请记住，由于Kivy部件尽可能简单，这意味着很多时候它们是不可见的，因为更复杂的图形显示意味着不必要的过载。然而，这种行为使得我们难以在GUI中找到错误。所以当我们的界面没有显示我们期望的内容时，检查器就变得非常有用，帮助我们理解GUI的底层树结构。
- en: ActionBar – a responsive bar
  id: totrans-142
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: ActionBar – 一个响应式栏
- en: 'A new set of widgets were introduced in Kivy 1.8.0, all of them related to
    the **`ActionBar`** widget. This widget resembles the Android''s action bar. This
    will not only give your applications a modern and professional look, but it also
    includes more subtle properties such as responsiveness to small screens. Depending
    on the `ActionBar` widget hierarchy and components, the different widgets will
    collapse in order to adapt to the screen space available in the device. First,
    let''s take a look at the final result of our planned `ActionBar`:'
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: Kivy 1.8.0 引入了一套新的小部件，它们都与 **`ActionBar`** 小部件相关。这个小部件类似于 Android 的操作栏。这不仅会给您的应用程序带来现代和专业的外观，而且还包括更多细微的特性，如对小型屏幕的响应性。根据
    `ActionBar` 小部件的层次结构和组件，不同的小部件将折叠以适应设备中可用的屏幕空间。首先，让我们看看我们计划中的 `ActionBar` 的最终结果：
- en: '![ActionBar – a responsive bar](img/B04244_06_09.jpg)'
  id: totrans-144
  prefs: []
  type: TYPE_IMG
  zh: '![ActionBar – a responsive bar](img/B04244_06_09.jpg)'
- en: 'We add the Kivy language code to produce the previous bar in a new file `kivyplayer.kv`,
    as presented here:'
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将 Kivy 语言代码添加到新文件 `kivyplayer.kv` 中，如下所示：
- en: '[PRE21]'
  id: totrans-146
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'The hierarchy of the previous code is complicated, so it is also presented
    in the following diagram:'
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 之前代码的层次结构很复杂，因此它也以以下图的形式呈现：
- en: '![ActionBar – a responsive bar](img/B04244_06_10.jpg)'
  id: totrans-148
  prefs: []
  type: TYPE_IMG
  zh: '![ActionBar – a responsive bar](img/B04244_06_10.jpg)'
- en: As you can see in the preceding diagram, the **KivyPlayer** contains two main
    components, the `VideoController` that we created two sections ago, and the **ActionBar**.
    If you remember, we created the property playing for the `VideoController` (line
    219), so we bound the associated event `on_playing` to the method `hide_bars`
    (line 311) that later on will basically hide the action bar. Right now, let's
    focus our attention to the hierarchy of `ActionBar`.
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 如您在前面的图中所见，**KivyPlayer** 包含两个主要组件，我们在上一节中创建的 `VideoController` 以及 **ActionBar**。如果您还记得，我们为
    `VideoController` 创建了 `playing` 属性（第 219 行），并将其关联事件 `on_playing` 绑定到 `hide_bars`
    方法（第 311 行），该方法将基本隐藏操作栏。现在，让我们将注意力集中在 `ActionBar` 的层次结构上。
- en: 'An **`ActionBar`** will always contain one **`ActionView`**. In this case,
    we just add an `ActionView` with three widgets: `ActionListButton`, **`ActionToggleButton`**,
    and **`ActionGroup`**. All of them inherit from **`ActionItem`**.'
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: '**`ActionBar`** 总是包含一个 **`ActionView`**。在这种情况下，我们添加了一个包含三个小部件的 `ActionView`：`ActionListButton`、**`ActionToggleButton`**
    和 **`ActionGroup`**。所有这些小部件都继承自 **`ActionItem`**。'
- en: Note
  id: totrans-151
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: An **`ActionView`** should contain only widgets that inherit from **`ActionItem`**.
    We can create our own action items by inheriting from `ActionItem`.
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: '**`ActionView`** 应该只包含继承自 **`ActionItem`** 的小部件。我们可以通过继承 `ActionItem` 来创建自己的操作项。'
- en: The **`ActionGroup`** groups `ActionItem` instances in order to organize the
    responsive display. In this case, it contains one **`ActionButton`** instance
    and one `ActionTextInput` instance. `ActionListButton` and `ActionTextInput` are
    personalized widgets that we have to create. `ActionListButton` will inherit from
    **`ActionPrevious`** and `ToggleButtonBehaviour`, whereas `ActionTextInput` inherits
    from **`TextInput`** and **`ActionItem`**.
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: '**`ActionGroup`** 将 `ActionItem` 实例分组，以便组织响应式显示。在这种情况下，它包含一个 **`ActionButton`**
    实例和一个 `ActionTextInput` 实例。`ActionListButton` 和 `ActionTextInput` 是我们需要创建的个性化小部件。`ActionListButton`
    将继承自 **`ActionPrevious`** 和 `ToggleButtonBehaviour`，而 `ActionTextInput` 继承自 **`TextInput`**
    和 **`ActionItem`**。'
- en: Before continuing, there are a few new properties in the code that deserve an
    explanation. The **`use_separator`** property of `ActionView` (line 317) indicates
    whether a separator will be used before every `ActionGroup`. The `title` property
    (line 321), which displays a title in the component of `ActionListButton`, is
    inherited from `ActionPrevious`. `ActionPrevious` is just a button with some extra
    GUI features (such as the title, but also the Kivy icon that could be modified
    with **`app_icon`**), but, more importantly, its parent (`ActionView`) will keep
    a reference to it with the **`action_previous`** property.
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 在继续之前，代码中有几个新的属性值得解释。`ActionView` 的 **`use_separator`** 属性（第 317 行）表示是否在每个 `ActionGroup`
    前使用分隔符。`title` 属性（第 321 行），它在 `ActionListButton` 的组件中显示标题，是从 `ActionPrevious`
    继承的。`ActionPrevious` 只是一个带有一些额外 GUI 特性（如标题，还可以通过 **`app_icon`** 修改 Kivy 图标）的按钮，但更重要的是，它的父级（`ActionView`）将使用
    **`action_previous`** 属性保留对其的引用。
- en: 'Let''s now see the definition of `ActionTextInput` in the `actiontextinput.kv`
    file:'
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们来看看 `actiontextinput.kv` 文件中 `ActionTextInput` 的定义：
- en: '[PRE22]'
  id: totrans-156
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: As we said before, `ActionTextInput` inherits from **`TextInput`** and **`ActionItem`**,
    The **`TextInput`** widget is a simple widget that displays a text input field
    in which the user can write. It inherits directly from the `Widget` class and
    the **`FocusBehaviour`** class, which was introduced in Kivy 1.9.0\. The multiple
    inheritance notations that we used (line 333) are new to us.
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我们之前所说，`ActionTextInput`继承自**`TextInput`**和**`ActionItem`**，**`TextInput`**小部件是一个简单的显示文本输入字段的小部件，用户可以在其中写入。它直接从`Widget`类和Kivy
    1.9.0中引入的**`FocusBehaviour`**类继承。我们使用的多重继承表示法（第333行）对我们来说是新的。
- en: Note
  id: totrans-158
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: In order to use multiple inheritance in the Kivy language, we use the notation
    `<DerivedClass@BaseClass1+BaseClass2>`.
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 为了在Kivy语言中使用多重继承，我们使用表示法`<DerivedClass@BaseClass1+BaseClass2>`。
- en: The **`TextInput`** widget is one of the most flexible widgets in Kivy and contains
    a lot of properties that can be used to configure it. We used the `background_color`,
    `foreground_color`, and `cursor_color` properties (lines 334 to 336) to set the
    background, foreground, and cursor color, respectively. The `hint_text` property
    will display a hint background text, which will disappear when `TextInput` gains
    focus (for example, when we click or touch it). The `multiline` property will
    indicate whether `TextInput` will accept multiple lines, and will also activate
    the `on_text_validate` event when we hit the *Enter* key, and that we use in the
    `kivyplayer.kv` file (line 331).
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: '**`TextInput`**小部件是Kivy中最灵活的小部件之一，它包含许多可以用来配置它的属性。我们使用了`background_color`、`foreground_color`和`cursor_color`属性（第334至336行）来分别设置背景、前景和光标颜色。`hint_text`属性将显示提示背景文本，当`TextInput`获得焦点时（例如，当我们点击或触摸它时）将消失。`multiline`属性将指示`TextInput`是否接受多行，并且当按下*Enter*键时，它将激活`on_text_validate`事件，我们在`kivyplayer.kv`文件（第331行）中使用它。'
- en: 'Notice that we also added a few references in `KivyPlayer` (lines 305 to 307).
    We use those references on the Python side of `KivyPlayer`, which is `kivyplayer.py`.
    We will cover this code in three fragments:'
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，我们还向`KivyPlayer`（第305至307行）添加了一些引用。我们在`KivyPlayer`的Python端使用这些引用，即`kivyplayer.py`。我们将在三个片段中介绍这段代码：
- en: '[PRE23]'
  id: totrans-162
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: In this fragment, we added all the necessary imports of the code. We also loaded
    the `actiontextinput.kv` file, and defined the `ActionListButton` class inherited
    from `ToggleButtonBehaviour` and `ActionPrevious`, as we indicated before.
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个片段中，我们添加了所有必要的代码导入。我们还加载了`actiontextinput.kv`文件，并定义了从`ToggleButtonBehaviour`和`ActionPrevious`继承的`ActionListButton`类，正如我们之前所指示的。
- en: 'In fragment 2 of `kivyplayer.py`, we added all the necessary methods that are
    called on by `ActionItems`:'
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 在`kivyplayer.py`的片段2中，我们添加了所有由`ActionItems`调用的必要方法：
- en: '[PRE24]'
  id: totrans-165
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'For this section, we just implemented the `hide_bars` and `toggle_mute` methods.
    The `hide_bars` method (lines 360 to 371) hides the *action bar* when the video
    is playing in a similar way as we hid the *control bar* before. The `toggle_button`
    method (lines 372 to 382) uses the **`volume`** property to toggle between the
    full volume and mute state. The fragment 3 of the code just contains the final
    commands to run the code:'
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 对于本节，我们只是实现了`hide_bars`和`toggle_mute`方法。`hide_bars`方法（第360至371行）在视频播放时以类似我们之前隐藏*控制栏*的方式隐藏*操作栏*。`toggle_button`方法（第372至382行）使用**`volume`**属性在满音量和静音状态之间切换。代码的片段3只包含运行代码的最终命令：
- en: '[PRE25]'
  id: totrans-167
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'You can now run the application again. You might want to resize the window
    to see how the *action bar* reorganizes the components according to the screen
    size. Here are two examples for medium (left) and small (right) size:'
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 您现在可以再次运行应用程序。您可能想要调整窗口大小，看看*操作栏*如何根据屏幕大小重新组织组件。以下是中等（左侧）和小型（右侧）尺寸的两个示例：
- en: '![ActionBar – a responsive bar](img/B04244_06_11.jpg)'
  id: totrans-169
  prefs: []
  type: TYPE_IMG
  zh: '![ActionBar – 一个响应式栏](img/B04244_06_11.jpg)'
- en: LoadDialog – displaying a directory of files
  id: totrans-170
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: LoadDialog – 显示文件目录
- en: 'In this section, we will discuss how to display a directory tree in Kivy in
    order to select a file. First, we will define the interface in `loaddialog.kv`:'
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们将讨论如何在Kivy中显示目录树以选择文件。首先，我们将在`loaddialog.kv`中定义界面：
- en: '[PRE26]'
  id: totrans-172
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: 'There is nothing new in this code except for the use of the **`FileChooserListView`**
    widget. It will display the directory tree of files. The *path* property (line
    398) will indicate the base path of where to start displaying the files. Apart
    from this, we add the **Cancel** (line 402)and **Load** buttons (line 405), and
    they call respective functions in the `LoadDialog` class that is defined in the
    `loaddialog.py` file:'
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 这段代码中除了使用了**`FileChooserListView`**控件之外，没有其他新内容。它将显示文件的目录树。`path`属性（第398行）将指示开始显示文件的基准路径。除此之外，我们还添加了**取消**（第402行）和**加载**按钮（第405行），它们调用定义在`loaddialog.py`文件中的`LoadDialog`类的相应函数：
- en: '[PRE27]'
  id: totrans-174
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: 'There are actually no explicitly defined parameters in this class definition,
    just a couple of properties. We will assign methods to these properties in the
    `kivyplayer.py` file, and Kivy/Python will call them respectively:'
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个类定义中实际上没有明确定义的参数，只有几个属性。我们将在`kivyplayer.py`文件中将方法分配给这些属性，Kivy/Python将分别调用它们：
- en: '[PRE28]'
  id: totrans-176
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: 'If you remember, the **Open List** button of the `ActionBar` instance calls
    the `show_load_list` method (line 329). This method will create an instance of
    `LoadDialog` (line 420), and will send, as parameters of the constructor, two
    others methods: `load_list` (line 424) and `dismiss_popup` (line 427). These methods
    will be assigned to the `load` and `cancel` properties. Once the instance is created,
    we display it in a `Popup` (instance line 421 and 422).'
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你记得，`ActionBar`实例的**打开列表**按钮调用`show_load_list`方法（第329行）。这个方法将创建一个`LoadDialog`实例（第420行），并将两个其他方法作为构造函数的参数发送：`load_list`（第424行）和`dismiss_popup`（第427行）。这些方法将被分配给`load`和`cancel`属性。一旦实例创建完成，我们将在`Popup`中显示它（实例行421和422）。
- en: 'Now, the `load_list` method will be called, when we click on the **Load** button
    of `LoadDialog` (line 420), and the `dismiss_popup` method when the **Cancel**
    button is pressed. Don''t forget to add the corresponding imports in `kivyplayer.py`:'
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，当我们在`LoadDialog`的**加载**按钮（第420行）上点击时，将调用`load_list`方法，当按下**取消**按钮时，将调用`dismiss_popup`方法。不要忘记在`kivyplayer.py`中添加相应的导入：
- en: '[PRE29]'
  id: totrans-179
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: 'Here is the resulting screenshot, where we can appreciate the tree directory:'
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: 下面是生成的截图，我们可以欣赏到树状目录：
- en: '![LoadDialog – displaying a directory of files](img/B04244_06_12.jpg)'
  id: totrans-181
  prefs: []
  type: TYPE_IMG
  zh: '![LoadDialog – 显示文件目录](img/B04244_06_12.jpg)'
- en: ScrollView – displaying a list of videos
  id: totrans-182
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: ScrollView – 显示视频列表
- en: 'In this section, we will display the results of a search performed on the TED
    video site in a *side bar* that we can scroll up and down, as shown in the following
    screenshot:'
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们将展示在TED视频网站上执行搜索的结果，这些结果将显示在一个可以上下滚动的**侧边栏**中，如下面的截图所示：
- en: '![ScrollView – displaying a list of videos](img/B04244_06_13.jpg)'
  id: totrans-184
  prefs: []
  type: TYPE_IMG
  zh: '![ScrollView – 显示视频列表](img/B04244_06_13.jpg)'
- en: 'Let''s start defining the components of the side bar in the `sidebar.kv` file:'
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们在`sidebar.kv`文件中开始定义侧边栏的组件：
- en: '[PRE30]'
  id: totrans-186
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: The `ListItem` class inherits from `ToggleButton`. The `text_size` property
    will establish a boundary for the text. If the titles of the videos are too long,
    two lines will be used instead. The `Sidebar` class inherits from **`ScrollView`**,
    which will allow scrolling down the list of videos, similar to the way we scrolled
    the files in `LoadDialog` of the last section. The `GridLayout` instance inside
    `Sidebar` is the actual widget that will contain and organize the `ListItem` instances.
    This is referenced by `Sidebar` in the `playlist` property (line 442)
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: '`ListItem`类继承自`ToggleButton`。`text_size`属性将为文本设置边界。如果视频的标题过长，将使用两行显示。`Sidebar`类继承自**`ScrollView`**，这将允许滚动视频列表，类似于我们在上一节`LoadDialog`中滚动文件的方式。`Sidebar`内部的`GridLayout`实例是实际包含和组织`ListItem`实例的控件。这通过`Sidebar`的`playlist`属性（第442行）进行引用。'
- en: Tip
  id: totrans-188
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 小贴士
- en: The contained element inside `ScrollView` has to be allowed to be bigger than
    `ScrollView` in order to scroll. Set `size_hint_y` to `None` if you want to add
    vertical scrolling or `size_hint_x` to `None` if you want to add horizontal scrolling.
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: 在`ScrollView`内部的包含元素必须允许比`ScrollView`更大，以便可以滚动。如果你想添加垂直滚动，将`size_hint_y`设置为`None`；如果你想添加水平滚动，将`size_hint_x`设置为`None`。
- en: 'Let''s continue with the definition of the sidebar on the Python file (`sidebar.py`):'
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们继续在Python文件（`sidebar.py`）中定义侧边栏的定义：
- en: '[PRE31]'
  id: totrans-191
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: 'This file provides the implementation of the `ListItem` class. There are three
    parameters in the constructor (line 473): an instance of the `video` widget, the
    `meta` filename that contains metadata of the video as provided by TED videos,
    and `surl` that contains the subtitle URL. When the `state` property of the `ListItem`
    widget changes, the `on_state` method (line 474) is called. This method will open
    the file provided by TED in a JSON format and extract the necessary information
    to update the video widget properties. We included in the code of this section,
    a collection of TED metadata files in the results folder, in order to test the
    code before you include your own API. For example, `results/97.json` contains
    the metadata for the video of Dan Gilbert we have been using so far. You can verify
    the JSON structure of the lines 477 and 478 in this subtitle file.'
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: 此文件提供了`ListItem`类的实现。构造函数中有三个参数（第473行）：一个`video`小部件的实例、包含视频元数据的`meta`文件名，这些元数据由TED视频提供，以及包含字幕URL的`surl`。当`ListItem`小部件的`state`属性发生变化时，会调用`on_state`方法（第474行）。此方法将打开TED提供的JSON格式的文件，并提取更新视频小部件属性所需的信息。我们在本节代码中包含了一个TED元数据文件集合，位于结果文件夹中，以便在您包含自己的API之前测试代码。例如，`results/97.json`包含我们迄今为止使用的丹·吉尔伯特视频的元数据。您可以在该字幕文件的第477行和第478行验证JSON结构。
- en: 'Now, we need to add a `Sidebar` instance to `KivyPlayer` in the `kivyplayer.kv`
    file:'
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们需要在`kivyplayer.kv`文件中将一个`Sidebar`实例添加到`KivyPlayer`中：
- en: '[PRE32]'
  id: totrans-194
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: 'We have added the `Sidebar` instance and defined some `position` properties
    based on the other elements of the screen (lines 495 to 498). We also adjusted
    `width` of the *control bar* to `side_bar` (line 480). When `Sidebar` is displayed,
    then the *control bar* will adjust automatically to the available space. We control
    the display of the sidebar with the `ActionListButton` class (line 512), which
    we are going to define in `kivyplayer.py`:'
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已添加`Sidebar`实例并基于屏幕上的其他元素定义了一些`position`属性（第495行至第498行）。我们还调整了`控制栏`的`width`为`side_bar`（第480行）。当`Sidebar`显示时，则`控制栏`将自动调整到可用空间。我们使用`ActionListButton`类（第512行）控制侧边栏的显示，我们将在`kivyplayer.py`中定义此类：
- en: '[PRE33]'
  id: totrans-196
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: 'The animation of the sidebar is similar to the others we have seen in this
    chapter. We also included two global variables: `_surl` and `_meta` (lines 509
    and 510). These are strings that will serve as templates for the subtitles and
    metadata files. Notice that `%s` inside the strings will be replaced. We also
    introduced a constructor (`__init__`) to the `KivyPlayer` class definition (line
    522 and 524). Line 524 is necessary to guarantee that the `GridLayout` instance
    (inside `ScrollView`) adapts to its height and therefore, allows scrolling.'
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: 侧边栏的动画与我们本章中看到的类似。我们还包含了两个全局变量：`_surl`和`_meta`（第509行和第510行）。这些字符串将作为字幕和元数据文件的模板。请注意，字符串中的`%s`将被替换。我们还向`KivyPlayer`类定义中引入了一个构造函数（`__init__`）（第522行和第524行）。第524行是必要的，以确保`GridLayout`实例（在`ScrollView`内部）适应其高度，从而允许滚动。
- en: 'We now need to add the `ListItem` instances to the `Sidebar` widget. In order
    to do this, we will define the `load_list` method (line 525) and the `load_from_json`
    method (line 532) in `kivyplayer.py`:'
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们需要将`ListItem`实例添加到`Sidebar`小部件中。为此，我们将在`kivyplayer.py`中定义`load_list`方法（第525行）和`load_from_json`方法（第532行）：
- en: '[PRE34]'
  id: totrans-199
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: We included a `results.json` file that contains an example search result list
    obtained from the TED site. This result is in the JSON format, which you can check
    in the file. We need to open this file and display its content in the *side bar*.
    In order to do this, we select the `result.json` file with the `LoadDialog` display
    using the **Open List** button. Once selected, the `load_list` method is called.
    The method opens the data and loads the JSON data (line 527). Once loaded, it
    calls the `load_from_json` method (line 528). In this method, we create a `ListItem`
    instance (line 539) per result obtained from the search on the TED site, and add
    the instances to the playlist (that is, the `GridLayout` instance inside the *side
    bar* (line 451)). The lines 537 and 538 are a common way of concatenating strings
    in Python. It replaces `%s` which are present in strings (lines 509 and 510) with
    the corresponding parameters after `%`. Now, we will see the results as a side
    bar list in our application when we open the `results.json` file as was shown
    in the screenshot at the beginning of this section.
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: 我们包含了一个 `results.json` 文件，其中包含从 TED 网站获取的示例搜索结果列表。这个结果以 JSON 格式呈现，您可以在文件中查看。我们需要打开这个文件，并在
    *侧边栏* 中显示其内容。为了做到这一点，我们使用 `LoadDialog` 显示选择 `result.json` 文件，并使用 **打开列表** 按钮进行选择。一旦选择，就会调用
    `load_list` 方法。该方法打开数据并加载 JSON 数据（第 527 行）。一旦加载，它就会调用 `load_from_json` 方法（第 528
    行）。在这个方法中，我们为从 TED 网站搜索得到的结果创建一个 `ListItem` 实例（第 539 行），并将这些实例添加到播放列表中（即 *侧边栏*
    内的 `GridLayout` 实例，第 451 行）。第 537 行和 538 行是 Python 中连接字符串的常见方式。它将字符串中存在的 `%s`
    替换为 `%` 后面的相应参数。现在，当我们打开 `results.json` 文件时，就像本节开头截图所示，我们将在应用程序中以侧边栏列表的形式看到结果。
- en: Search – query the TED Developer API
  id: totrans-201
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 搜索 – 查询 TED 开发者 API
- en: This final section will introduce a few changes to the code so that we can search
    the TED site.
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: 本节最后将介绍一些代码更改，以便我们能够搜索 TED 网站。
- en: Tip
  id: totrans-203
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 小贴士
- en: 'The first thing you need to do is to get an API key from the TED site using
    the following link:'
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: 您需要做的第一件事是从 TED 网站使用以下链接获取 API 密钥：
- en: '[http://developer.ted.com/member/register](http://developer.ted.com/member/register).'
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: '[http://developer.ted.com/member/register](http://developer.ted.com/member/register)。'
- en: 'A TED API key is an alphanumeric number (something like `''1a3bc2''`) that
    allows you to query the TED website directly, and get requests in the JSON format
    we have been using throughout the last section. Once you receive your API key
    in your e-mail account, you can modify `kivyplayer.py` and put it in an `_api
    global` variable. For now, we can use a placeholder like this in the `kivyplayer.py`
    file:'
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: TED API 密钥是一个字母数字编号（例如 `'1a3bc2'`），它允许您直接查询 TED 网站，并获取我们上一节中使用的 JSON 格式的请求。一旦您在电子邮件账户中收到
    API 密钥，您就可以修改 `kivyplayer.py` 文件，并将其放入 `_api` 全局变量中。目前，我们可以在 `kivyplayer.py` 文件中使用如下占位符：
- en: '[PRE35]'
  id: totrans-207
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: 'Also, in `kivyplayer.py`, we need to introduce a global variable that contains
    the search template (_`search`), and replace the content of the `_meta` global
    variable:'
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，在 `kivyplayer.py` 文件中，我们需要引入一个包含搜索模板（_`search`_）的全局变量，并替换 `_meta` 全局变量的内容：
- en: '[PRE36]'
  id: totrans-209
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: 'Notice that the `_meta` variable now has two `%`. Therefore, we will need to
    replace the `meta = meta % t[''id'']` code line with `meta = _meta % (t[''id''],
    _api)` inside the `load_from_json` method (line 533). Also, since we are not opening
    a file, we also need to replace the way we load the JSON in the `ListItem` class
    since we don''t have a file anymore, but a URL. First, we need to import the `URLRequest`
    class (`from kivy.network.urlrequest import UrlRequest`) at the beginning of the
    `sidebar.py` file, and then modify the `on_state` method to use the `URLRequest`
    class as we learned with the subtitles:'
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，现在 `_meta` 变量有两个 `%`。因此，我们需要在 `load_from_json` 方法（第 533 行）中将 `meta = meta
    % t['id']` 代码行替换为 `meta = _meta % (t['id'], _api)`。另外，由于我们不再打开文件，我们还需要修改 `ListItem`
    类中加载 JSON 的方式，因为我们现在没有文件，而是一个 URL。首先，我们需要在 `sidebar.py` 文件的开始处导入 `URLRequest`
    类（`from kivy.network.urlrequest import UrlRequest`），然后修改 `on_state` 方法以使用 `URLRequest`
    类，就像我们学习字幕时做的那样：
- en: '[PRE37]'
  id: totrans-211
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: 'We also need to import the `URLRequest` class in `kivyplayer.py`, in order
    to implement the `search` method in the `KivyPlayer` class definition:'
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还需要在 `kivyplayer.py` 中导入 `URLRequest` 类，以便在 `KivyPlayer` 类定义中实现 `search` 方法：
- en: '[PRE38]'
  id: totrans-213
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: 'Now, you can go and check whether you received your TED API key. Once you have
    replaced the `_api` variable, you will be able to use the search box in the action
    bar to query the TED API. You can now use the search on `ActionTextInput`:'
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，您可以检查是否收到了 TED API 密钥。一旦您替换了 `_api` 变量，您将能够使用操作栏中的搜索框查询 TED API。您现在可以使用 `ActionTextInput`
    进行搜索：
- en: '![Search – query the TED Developer API](img/B04244_06_14.jpg)'
  id: totrans-215
  prefs: []
  type: TYPE_IMG
  zh: '![搜索 – 查询TED开发者API](img/B04244_06_14.jpg)'
- en: Tip
  id: totrans-216
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 小贴士
- en: Keep in mind that the API key you just created can identify you and your application
    as a user of the TED site. All the activity registered with that API is your responsibility.
    *You shouldn't give this API Key to anyone.*
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
  zh: 请记住，您刚刚创建的API密钥可以识别您和您的应用程序作为TED网站的用户。所有通过该API注册的活动都是您的责任。*您不应该将此API密钥告诉任何人。*
- en: Controlling the use of your API Key involves setting up your own server, where
    the API key is safely stored. This server will act as a proxy ([https://en.wikipedia.org/wiki/Proxy_server](https://en.wikipedia.org/wiki/Proxy_server))
    of your application, and it should limit the queries. For example, it should avoid
    abusive behavior such as a massive number of queries.
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
  zh: 控制您的API密钥的使用涉及设置自己的服务器，其中API密钥被安全存储。该服务器将作为您应用程序的代理 ([https://en.wikipedia.org/wiki/Proxy_server](https://en.wikipedia.org/wiki/Proxy_server))，并应限制查询。例如，它应避免大量查询等滥用行为。
- en: Summary
  id: totrans-219
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: 'In this chapter, we created an application that integrates many Kivy components.
    We discussed how to control a video and how to associate different elements of
    the screen with it. We explored different Kivy widgets and implemented a complex
    interaction to display a scrollable list of elements. Here is the list of new
    classes and components that we used in this chapter:'
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们创建了一个集成了许多Kivy组件的应用程序。我们讨论了如何控制视频以及如何将屏幕的不同元素与之关联。我们探索了不同的Kivy小部件，并实现了复杂的交互来显示可滚动的元素列表。以下是本章中我们使用的新类和组件列表：
- en: '`Video`: The `allow_stretch` and `source` properties inherited from `Image`;
    the `state` and `progress` properties; the `_on_load`, `on_eos`, `on_source` and
    `on_state`, `on_position`, `seek` methods'
  id: totrans-221
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Video`: 从 `Image` 继承的 `allow_stretch` 和 `source` 属性；`state` 和 `progress` 属性；`_on_load`、`on_eos`、`on_source`
    和 `on_state`、`on_position`、`seek` 方法'
- en: '`AsyncImage`: The `source` property inherited from `Image`; the `opacity` (inherited
    from `Widget`) property'
  id: totrans-222
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`AsyncImage`: 从 `Image` 继承的 `source` 属性；从 `Widget` 继承的 `opacity` 属性'
- en: '`Label`: The `texture_size` property'
  id: totrans-223
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Label`: `texture_size` 属性'
- en: '`Slider`: The `value` and `max` properties     `Touch`: The `double_tap` key'
  id: totrans-224
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Slider`: `value` 和 `max` 属性     `Touch`: `double_tap` 键'
- en: The Kivy Inspector class
  id: totrans-225
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Kivy检查器类
- en: The `ActionBar`, `ActionView`, `ActionItem` `ActionPrevious`, `ActionToggleButton`
    `ActionGroup`, and `ActionButton` classes, with `use_separator` of `ActionView`
    and title of `ActionPrevious` properties
  id: totrans-226
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`ActionBar`、`ActionView`、`ActionItem`、`ActionPrevious`、`ActionToggleButton`、`ActionGroup`
    和 `ActionButton` 类，以及 `ActionView` 的 `use_separator` 属性和 `ActionPrevious` 的标题属性'
- en: '`Textinput`: The `background_color`, `foreground_color`, `cursor_color` and
    `multiLine` properties'
  id: totrans-227
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Textinput`: `background_color`、`foreground_color`、`cursor_color` 和 `multiLine`
    属性'
- en: '`FileChooserListView`: The `path` property'
  id: totrans-228
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`FileChooserListView`: `path` 属性'
- en: The `ScrollView` class
  id: totrans-229
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`ScrollView` 类'
- en: As a side result of the way this chapter, we have obtained an organized is an
    enhanced `Video` widget that we can use in other applications. This `Video` widget
    incorporates synchronization of subtitles that we receive in a JSON format file
    with the progression of the video and a responsive *control bar*.
  id: totrans-230
  prefs: []
  type: TYPE_NORMAL
  zh: 作为本章的副产品，我们获得了一个经过优化的 `Video` 小部件，我们可以在其他应用程序中使用它。这个 `Video` 小部件将我们以JSON格式文件接收的子标题与视频的进度同步，并具有响应式的
    *控制栏*。
- en: We have mastered the use of the `Video` widget. We learned how to control its
    progression and add subtitles to it. We also covered how to query the TED Developer
    API in order to get a result lists, and we have practiced our skills manipulating
    the JSON format. We also learned how to use the Kivy debugger in order to detect
    errors in our interfaces.
  id: totrans-231
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经掌握了 `Video` 小部件的使用。我们学习了如何控制其进度并添加字幕。我们还介绍了如何查询TED开发者API以获取结果列表，并练习了操作JSON格式的技能。我们还学习了如何使用Kivy调试器来检测界面中的错误。
- en: We also made an effort to make our `KivyPlayer` application look professional.
    We optimized the use of the screen by introducing animations that hide the GUI
    components when unnecessary. As part of this process, we used many Kivy elements
    to make our widget consistent, and we reviewed interesting topics such as behaviors,
    the factory, animations, touch events, and the use of properties in order to create
    versatile components.
  id: totrans-232
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还努力使我们的 `KivyPlayer` 应用看起来更专业。我们通过引入隐藏GUI组件的动画来优化屏幕的使用，这些动画在不需要时隐藏。在这个过程中，我们使用了许多Kivy元素来使我们的小部件保持一致，并审查了诸如行为、工厂、动画、触摸事件以及属性的使用等有趣的主题，以便创建多功能组件。
- en: The beginning is at the end, so it is now your turn to start your own applications.
    I really hope that what you have learned from this book will help you to implement
    your ideas and start your own application.
  id: totrans-233
  prefs: []
  type: TYPE_NORMAL
  zh: 开始即是结束，因此现在轮到你自己开始自己的应用了。我真心希望，你从这本书中学到的知识能帮助你实现你的想法，并开始你自己的应用。
