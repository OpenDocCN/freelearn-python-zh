- en: Chapter 6. Kivy Player – a TED Video Streamer
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In this chapter, we will learn how to search, display, and control videos.
    We will integrate knowledge from previous chapters to build a responsive application
    with the ability to adjust to different screens and maximize the use of space.
    We will produce an enhanced **video** widget with controls and subtitle support,
    and learn how to display a search result query from the TED API services ([developer.ted.com](http://developer.ted.com)).
    Here are the main topics that we will cover in this chapter:'
  prefs: []
  type: TYPE_NORMAL
- en: Control the progression of a streamed video
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Use the progression of a video to display subtitles at the right moment
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Apply strategies and components to make our application responsive
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Display and navigate a local file directory tree
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Use the Kivy inspector to debug our applications
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Add scroll functionality to a list of results obtained from an Internet query
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: This chapter wraps up a lot of knowledge acquired so far. We will be reviewing
    and combining the use of properties, events, animations, touches, behaviors, layouts,
    and even graphics. At the same time, we will introduce new widgets that will complement
    your knowledge, and serve as good examples of new programming situations. We will
    also review the Kivy inspector that will help us detect GUI bugs. At the end of
    this chapter, we will finish with a professional looking interface.
  prefs: []
  type: TYPE_NORMAL
- en: Video – play, pause, and stop
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'We will start with simple code in this section, and then gradually include
    functionality until we get a complete video player. In this section, we will discuss
    how to use the **`Video`** widget in order to stream a *video* from the Internet.
    Let''s start with the code in the `video.kv` file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: In this code, we initially create a constant value with the **`set`** directive
    (line 2). This directive allows us to have global values that we can use inside
    the Kivy language scope. For example, we set the `source` property of the `Video`
    class with the value of the `_default_video` constant (line 7).
  prefs: []
  type: TYPE_NORMAL
- en: We set up three properties for the **`Video`** class. The **`allow_stretch`**
    property (line 5) allows the video to stretch according to the screen size available.
    The **`color`** property (line 6) will tint the video black, to serve as a foreground
    when the *video* is not playing (and a background for the *cover* image). The
    **`source`** property (line 7) contains the URL (or filename) of the video we
    want to play. These three properties actually belong to the **`Image`** widget,
    which is the base class for `Video`. This makes sense if we think of a video as
    a sequence of images (accompanied by a sound).
  prefs: []
  type: TYPE_NORMAL
- en: Tip
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'For test purposes, if you want to avoid constantly downloading the video from
    the Internet (or if the URL is not available anymore), you can replace the URL
    in `default_video` with a sample file that is included with the code: `samples/BigBuckBunny.ogg`.'
  prefs: []
  type: TYPE_NORMAL
- en: We will use the **`Factory`** class to use the technique that we learned about
    in [Chapter 4](ch04.html "Chapter 4. Improving the User Experience"), *Improving
    the User Experience*. Back then, we used the **`Factory`** class to replace the
    `Line` vertex instruction with our personalized implementation, a ticker `Line`.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The **`Factory`** class follows an oriented-object software design pattern called
    a factory pattern. A factory pattern returns default new objects (instances) of
    a subset of classes according to the called identifier, usually a method, but
    in the case of the Kivy languate we just use a name. ([http://en.wikipedia.org/wiki/Factory_%28object-oriented_programming%29](http://en.wikipedia.org/wiki/Factory_%28object-oriented_programming%29)).
  prefs: []
  type: TYPE_NORMAL
- en: 'We will do something similar now, but this time we will personalize our `Video`
    widget:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: The `video.py` file will import the Kivy `Video` widget with an alias name `KivyVideo`
    (line 9). We will now be able to create our personalized widget (lines 16 to 32)
    using the `Video` class name and not a less attractive alternative name such as
    `MyVideo`. At the end of the file, we replace the default `Video` widget with
    our personalized `Video` to the `Factory` (lines 34 and 35). From now on, the
    referenced `Video` class in the Kivy language will correspond to our implementation
    in this file.
  prefs: []
  type: TYPE_NORMAL
- en: 'We created four methods (**`on_state`**, **`on_eos`**, **`_on_load`**, and
    **`on_source`**) in the `Video` class. All of them correspond to events:'
  prefs: []
  type: TYPE_NORMAL
- en: 'The **`on_state`** method (line 18) is called when the state of the *video*
    changes among its three possible states: playing (`''play''`), paused (`''pause''`),
    or stopped (`''stop''`). We make sure that when the video is stopped, it is re-positioned
    at the beginning with the **`seek`** method (line 20).'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The **`on_eos`** method (line 23) will be called when the **end of stream**
    (**EOS**) has been reached. We will make sure that the state is set to `stop`
    when this occurs (line 19).
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: We also need to remember that we tinted the video with black color using the
    `color` property in the Kivy language (line 6). Therefore, we need to put light
    (`1,1,1,1`) on the video in order to be able to see it (line 29). The method **`_on_load`**
    (line 27) is called when the video is loaded into memory and ready to play. We
    use this method in order to set the proper (and original Kivy default) `color`
    property.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_IND
  - PREF_H3
  type: TYPE_NORMAL
- en: Remember in [Chapter 2](ch02.html "Chapter 2. Graphics – the Canvas"), *Graphics
    – the Canvas* that the `color` property of an `Image` widget (base class of the
    `Video` class) acts as a tint or light over the display. The same effect occurs
    for the `Video` widget.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Finally, the **`on_source`** method, also inherited from the `Image` class,
    will restore the black tint on top of the video when the source of the video is
    changed.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Let''s proceed to create a `kivyplayer.py` file to execute our application,
    and also play, pause, and stop our video:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: 'For now, we will control the video with touches. In the `build` method (line
    43), we have bound the `on_touch_down` event (line 45) of the video to the `touch_down`
    method (lines 48 to 54). One touch will play or pause the video according to its
    current **`state`** property (lines 49 and 52). The state property controls whether
    the video is in one of three possible states. If it is playing, it will pause
    it; otherwise (paused or stopped), it will play it. We will use the **`double_tap`**
    key that indicates a double touch (double tap or double click) in order to stop
    the video. Next time we touch the screen, the video will start from the beginning.
    Now, run the application (`Python kivyplayer.py`), and see how, as soon as you
    click on the screen, Kivy starts streaming Dan Gilbert''s video, *The Surprising
    Science of Happiness*, from TED ([http://www.ted.com/](http://www.ted.com/)):'
  prefs: []
  type: TYPE_NORMAL
- en: '![Video – play, pause, and stop](img/B04244_06_01.jpg)'
  prefs: []
  type: TYPE_IMG
- en: AsyncImage – creating a cover for the video
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In this section, we will learn how to put up a *cover* that will be displayed
    when the video is not playing. This image will serve as a decoration when the
    video hasn''t started, and in the case of the TED video, it is usually an image
    that involves the speaker. Let''s start introducing a few changes in the code
    of `video.kv`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: In this code, we created another constant (`_default_image`) with the **`set`**
    directive (line 60), and a related property (`image`) for the `Video` class that
    references the constant (line 64). We also created the `cover` property (line
    63) to reference `AsyncImage` that we added to the `Video` class (line 66), and
    that will serve as the cover for the video.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The main difference between `Image` and `AsyncImage` is that the **`AsyncImage`**
    widget allows us to continue using the program while the image is loading, instead
    of blocking the application until the image is completely downloaded.
  prefs: []
  type: TYPE_NORMAL
- en: 'This is important, since we download the image from the Internet and it could
    be a big file. When you run the code, you will notice that a waiting image will
    appear while the image is loading:'
  prefs: []
  type: TYPE_NORMAL
- en: '![AsyncImage – creating a cover for the video](img/B04244_06_02.jpg)'
  prefs: []
  type: TYPE_IMG
- en: We also set some of the `AsyncImage` properties. We initialized the `source`
    property (line 68) with the new property (`root.image`) that we created in the
    `Video` widget to reference the cover image (line 64). Remember that this will
    internally bind the properties, meaning that each time that we change the `image`
    property, the `source` property will be updated to the same value. Line 69 repeats
    the same idea in order to keep the cover's `size` property equal to the dimensions
    of the video.
  prefs: []
  type: TYPE_NORMAL
- en: Tip
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'For test purposes, you can replace the URL in `default_image` with the following
    sample file included with the code:'
  prefs: []
  type: TYPE_NORMAL
- en: '`samples/BigBuckBunny.png`.'
  prefs: []
  type: TYPE_NORMAL
- en: 'We will introduce some changes to our `Video` widget in order to make sure
    that the cover is removed (hidden) when the video is being played:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: We changed the **`on_state`** method to uncover the video when it is playing
    (line 79), and cover it again when the video is stopped (line 82) using the *opacity*
    property.
  prefs: []
  type: TYPE_NORMAL
- en: Tip
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Avoid removing widgets that are declared in the `.kv` file. Most of the time,
    these widgets have internal bounds with other widgets (for example, property bounds),
    and can cause unexpected runtime errors related to missing internal references
    and inconsistent bound properties.
  prefs: []
  type: TYPE_NORMAL
- en: Instead of removing widgets, there are several alternatives; for example, firstly,
    use the **`opacity`** property to make a widget invisible, secondly, make the
    widget area equal to zero using the `size` property (`size = (0,0)`), and thirdly,
    use the `pos` property to place the widget in a location that will never be displayed
    (`pos= (99999,999999)`). We chose the first approach; in this case, it is the
    most elegant. We set the **`opacity`** property of `AsyncImage` to make it visible
    (`opacity = 1`) or invisible (`opacity = 0`).
  prefs: []
  type: TYPE_NORMAL
- en: Tip
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Even though controlling the cover with the opacity to make it invisible may
    be the most elegant solution here, you have to be careful because the widget is
    still there, occupying space on the screen. Depending on the situation, you might
    have to extend the strategy. For example, if the widget captures some touch events,
    you can combine the **`opacity`** and **`disabled`** properties to hide and disable
    the widget.
  prefs: []
  type: TYPE_NORMAL
- en: We also created the `image` property (line 75), and used its `on_image` associated
    event (line 85) to make sure that the opacity is restored (line 86) if the image
    is changed. Now, an image of Dan Gilbert will appear when you run the application
    (`python kivyplayer.py`).
  prefs: []
  type: TYPE_NORMAL
- en: Subtitles – tracking the video progression
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Let''s add subtitles to our application. We will do this in four simple steps:'
  prefs: []
  type: TYPE_NORMAL
- en: Create a `Subtitle` widget (`subtitle.kv`) derived from the `Label` class that
    will display the subtitles
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Place a `Subtitle` instance (`video.kv`) on top of the video widget
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Create a `Subtitles` class (`subtitles.py`) that will read and parse a subtitle
    file
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Track the `Video` progression (`video.py`) to display the corresponding subtitle
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'The *Step 1* involves the creation of a new widget in the `subtitle.kv` file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: There are two interesting elements in this code. The first one is the definition
    of the size property (line 92). We define it as 20 pixels bigger than the **`texture_size`**
    width and height. The **`texture_size`** property indicates the size of the text
    determined by the font size and text, and we use it to adjust the `Subtitles`
    widget size to its content.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The **`texture_size`** is a read-only property because its value is calculated
    and dependent on other parameters, such as font size and height for text display.
    This means that we will read from this property but not write on it.
  prefs: []
  type: TYPE_NORMAL
- en: The second element is the creation of the `bcolor` property (line 94) to store
    a background color, and how the `rgba` color of the rectangle has been bound to
    it (line 97). The `Label` widget (like many other widgets) doesn't have a background
    color, and creating a rectangle is the usual way to create such features. We add
    the `bcolor` property in order to change the color of the rectangle from outside
    the instance.
  prefs: []
  type: TYPE_NORMAL
- en: Tip
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: We cannot directly modify parameters of the vertex instructions; however, we
    can create properties that control parameters inside the vertex instructions.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s move on to *Step 2* mentioned earlier. We need to add a `Subtitle` instance
    to our current `Video` widget in the `video.kv` file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: We added another constant variable called `_default_surl` (line 103), which
    contains the link to the URL with the corresponding subtitle TED video file. We
    set this value to the `surl` property (line 106), which we just created to store
    the subtitles' URL. We added the `slabel` property (line 107), that references
    the `Subtitle` instance through its ID (line 111). Then we made sure that the
    subtitle is centered (line 112).
  prefs: []
  type: TYPE_NORMAL
- en: 'In order to start *Step 3* (parse the subtitle file), we need to take a look
    at the format of the TED subtitles:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: 'TED uses a very simple JSON format ([https://en.wikipedia.org/wiki/JSON](https://en.wikipedia.org/wiki/JSON))
    with a list of `captions`. Each `caption` contains four keys but we will only
    use `duration`, `content`, and `startTime`. We need to parse this file, and luckily
    Kivy provides a **`UrlRequest`** class (line 121) that will do most of the work
    for us. Here is the code for `subtitles.py` that creates the `Subtitles` class:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: The constructor of the `Subtitles` class will receive a URL (line 125) as a
    parameter. Then, it will make the petition to instantiate the **`UrlRequest`**
    class (line 127). The first parameter of the class instantiation is the URL of
    the petition, and the second is the method that is called when the result of the
    petition is returned (downloaded). Once the request returns the result, the method
    `got_subtitles` is called(line 129). The **`UrlRequest`** extracts the JSON and
    places it in the second parameter of `got_subtitles`. All we had to do is put
    the captions in a class attribute, which we called `subtitles` (line 130).
  prefs: []
  type: TYPE_NORMAL
- en: The `next` method (line 132) receives the seconds (`secs`) as a parameter and
    will traverse the loaded JSON dictionary in order to search for the corresponding
    subtitle that belongs to that time. As soon as it finds one, the method returns
    it. We subtracted `12000` microseconds (line 134, `ms = secs*1000 - 12000`) because
    the TED videos have an introduction of approximately 12 seconds before the talk
    starts.
  prefs: []
  type: TYPE_NORMAL
- en: 'Everything is ready for *Step 4*, in which we put the pieces together in order
    to see the subtitles working. Here are the modifications to the header of the
    `video.py` file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: 'We imported `StringProperty` and added the corresponding property (line 142).
    We will use this property by the end of this chapter when we we can switch TED
    talks from the GUI. For now, we will just use `_default_surl` defined in `video.kv`
    (line 150). We also loaded the `subtitle.kv` file (line 146). Now, let''s analyze
    the rest of the changes to the `video.py` file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: We introduced a few code lines to the `on_source` method in order to initialize
    the subtitles attribute with a `Subtitles` instance (line 154) using the `surl`
    property and initialize the `sub` attribute that contains the currently displayed
    subtitle (line 155), if any.
  prefs: []
  type: TYPE_NORMAL
- en: Now, let's study how we keep track of the progression to display the corresponding
    subtitle. When the video plays inside the `Video` widget, the `on_position` event
    is triggered every second. Therefore, we implemented the logic to display the
    subtitles in the `on_position` method (lines 157 to 165). Each time the `on_position`
    method is called (each second), we ask the `Subtitles` instance (line 158) for
    the next subtitle. If nothing is returned, we clear the subtitle with the `clear_subtitle`
    method (line 160). If there is already a subtitle in the current second (line
    161), then we make sure that there is no subtitle being displayed, or that the
    returned subtitle is not the one that we already display (line 164). If the conditions
    are met, we display the subtitle using the `display_subtitle` method (line 165).
  prefs: []
  type: TYPE_NORMAL
- en: 'Notice that the `clear_subtitle` (lines 167 to 171) and `display_subtitle`
    (lines 173 to 176) methods use the `bcolor` property in order to hide the subtitle.
    This is another trick to make a widget invisible without removing it from its
    parent. Let''s take a look at the current result of our videos and subtitles in
    the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Subtitles – tracking the video progression](img/B04244_06_03.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Control bar – adding buttons to control the video
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this section, we will work on user interaction with the application. Right
    now, we control the video with touches on the screen that play, pause, and stop
    the video. However, this is not very intuitive for a new user of our application.
    So, let's add some buttons to improve the usability of our application.
  prefs: []
  type: TYPE_NORMAL
- en: 'We will use `Image` widgets enhanced with `ToggleButtonBehaviour` and `ToggleBehaviour`
    classes in order to create buttons for a *play*/*pause* button and a *stop* button,
    respectively. Here is a cropped screenshot of the simple *control bar* that we
    will be implementing in this section:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Control bar – adding buttons to control the video](img/B04244_06_04.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Let''s start defining our two widgets for `controlbar.kv`. We will cover each
    widget one by one. Let''s start with the header of the file and the `ControlBar`
    class definition:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: 'We derived the `ControlBar` class from the `GridLayout` class and set some
    familiar properties. We also created a reference to the *play*/*pause* button,
    and one new property (`progress`) that will track the percentage (from 0 to 1)
    of the progress of the video. Let''s continue with the first embedded widget,
    `VideoPlayPause`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: 'As we will see in `controlbar.py`, `VideoPlayPause` is a combination of `Image`
    and `ToggleButtonBehavior`. We implemented the `source` property (line 192) in
    a way that changes the image of the widget according to the changes in the `state`
    property, `normal` and `down`. Let''s now see the code for `VideoStop`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: 'Apart from defining some familiar properties, we have bound the event `on_press`
    to the `stop` method (line 197), which will be shown in the corresponding `controlbar.py`
    file. Notice that we are assuming that the parent of the root contains a reference
    to the video (`root.parent.video`). We will continue working under this assumption
    in `controlbar.py`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: This code imports the necessary classes as well as `'controlbar.kv'` (lines
    198 to 203). Then, using multiple inheritance, it defines the `VideoPlayPause`
    and `VideoStop` classes as a combination of the `Image` class and the appropriate
    behavior (lines 205 and 208). The `VideoStop` class contains the `stop` method,
    which is called when the button is pressed (line 208). This will set the *play*/*pause*
    button state to normal and stop the video (line 212).
  prefs: []
  type: TYPE_NORMAL
- en: 'We will also define a *video controller*, which will be the parent of the *control
    bar* and *video*, in the `videocontroller.kv` file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: 'First, we defined five properties for `VideoContoller` (lines 215 to 219):
    `video`, `control_bar`, `play_pause`, `control_bar_width`, and `playing`. The
    first three properties reference components of the interface, `control_bar_width`
    will be used to externally control the width of the *control bar*, and the `playing`
    property will indicate whether the video is playing or not (line 219).'
  prefs: []
  type: TYPE_NORMAL
- en: We then added a `Video` instance (line 221), whose state will depend on the
    state of the *play*/*pause* button (line 223), and a `ControlBar` instance. The
    `width` property of the *control bar* will be controlled by `control_bar_width`
    (line 227) that we previously created (line 218), and the `progress` property
    will be expressed as a percentage of the duration (line 228).
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, we need to create the `VideoController` class in its respective `videocontroller.py`
    file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: 'We just included the necessary imports, and defined `VideoController` as a
    derived class of `FloatLayout`. The `kivyplayer.py` file also has to be updated
    in order to display a `VideoController` instance instead of `Video`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: Feel free to run an application again to test the *play*/*pause* and *stop*
    buttons. The next section will introduce a *progression bar* to our application.
  prefs: []
  type: TYPE_NORMAL
- en: Slider – including a progression bar
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In this section, we will introduce a new widget called **`Slider`**. This widget
    will serve as a *progression bar*, but at the same time it will allow the user
    to forward and reverse the video. We will integrate the *progression bar* into
    the *control bar*, as shown in the following cropped screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Slider – including a progression bar](img/B04244_06_05.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'As you can see, `Slider` appears to the left of the *play*/*pause* and *stop*
    buttons. Let''s change `controlbar.kv` to add `Slider` to reflect this order.
    Let''s start with the header of the file and the `ControlBar` class definition:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: '`VideoSlider` will keep the **`value`** property updated with the progression
    of the video. The **`value`** property indicates the location of the slider on
    the bar, and the **`max`** property is the maximum value that it can take. In
    this case, `1` is appropriate because we express the progression as a percentage
    (from 0 to 1) of the duration (line 255).'
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s now add the definition of `VideoSlider` in the `controlbar.py` file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: 'Controlling the progression of the video with a slider is tricky because the
    video and the slider need to constantly update each other. The video updates the
    slider to indicate its progress, and the slider updates the video when the user
    wants to forward or reverse the video. This creates an entangled logic, in which
    we have to take into account the following considerations:'
  prefs: []
  type: TYPE_NORMAL
- en: We need to use touch events because we want to make sure it is the user who
    is moving the slider and not the video progression.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: There seems to be an infinite loop; we update the slider, the slider uploads
    the video, and the video updates the slider.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The user might not necessarily just click on the slider, he could potentially
    drag it, and during the dragging time, the video updates the slider again.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'For these reasons, we need to execute the following steps:'
  prefs: []
  type: TYPE_NORMAL
- en: Pause the video before updating the progression (line 267).
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Not update the slider directly with the value property, but instead update the
    video progression with the `seek` method (line 275).
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Use the two events `on_touch_down` (line 262) and `on_touch_up` (line 270),
    in order to safely change the progression percentage of the video.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: In the `on_touch_down` method (lines 262 to 268), we have stored the current
    state of the video (line 265), and a reference to the touch (line 266), and then
    we have paused the video (line 267). If we don't pause the video, the progression
    of the video could affect the slider (remember that the `value` of slider is bound
    to the `progression` property in line 254) before we update the video to the progression
    of the slider. In the `on_touch_up` event, we made sure that the touch instance
    corresponds to the one that we stored in the `on_touch_down` method (lines 272
    and 273). Then, we set the video to the right place according to the position
    of the slider, with the **`seek`** method (line 275). Finally, we re-established
    the previous state of the video if it was different from `stop` (lines 276 and
    277).
  prefs: []
  type: TYPE_NORMAL
- en: Feel free to run the application again. You can also experiment with the slider
    and different options to update the video. Try, for example, a real-time update
    while you drag the slider through the `on_touch_move` event.
  prefs: []
  type: TYPE_NORMAL
- en: Animation – hiding a widget
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In this section, we will make the *control bar* disappear when the video starts
    playing in order to watch the video without visual distractions. We need to change
    the `videocontroller.py` file in order to animate the `ControlBar` instance:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: Along with the necessary imports at the beginning of the file (lines 280 and
    281), we introduced the `playing` property (line 284) and two methods associated
    with the `on_playing` event and the `on_touch_down` event. The `playing` property
    was already defined in the Kivy language (line 219), but remember that, due to
    the file parsing order, we also need to define it in the Python language if we
    want to use the property in the same class.
  prefs: []
  type: TYPE_NORMAL
- en: When the `playing` property changes, the `on_playing` event is triggered (line
    286). This method starts an animation (line 290) and disables the *control bar*
    when the video is playing (line 289). The animation will hide the *control bar*
    at the bottom of the screen. The `on_playing` method will also restore the *control
    bar* (lines 292 to 294), when the video is not playing so it will be visible again.
  prefs: []
  type: TYPE_NORMAL
- en: Since the *control bar* will be hidden when the video is playing, we need an
    alternate way to stop the video (different from the **Stop** button). This is
    the reason we included the `on_touch_down` event (line 296). As soon as we touch
    the screen, the animation, if it exists, is cancelled (line 298), and the *play*/*pause*
    button is set to `'normal'` (line 300). This will pause the video and therefore,
    trigger the `on_playing` event (in this case, because it stopped playing) that
    we just defined.
  prefs: []
  type: TYPE_NORMAL
- en: You can now run the application again and appreciate how the *control bar* slowly
    disappears down the bottom of the screen as soon as we press the **Play**/**Pause**
    button.
  prefs: []
  type: TYPE_NORMAL
- en: Kivy inspector – debugging interfaces
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Sometimes, we encounter problems when we implement our interfaces, and it can
    be difficult to understand what went wrong, especially when many of the widgets
    don''t have a graphic display. In this section, we will use the application that
    we created in this chapter to introduce the Kivy **inspector**, a simple tool
    to debug interfaces. In order to start the inspector, you run the following command:
    `python kivyplayer.py –m inspector`. You won''t notice any difference at the beginning
    but if you press *Ctrl* + *E*, a bar will appear at the bottom of the screen,
    just like the one in the left screenshot of the following image:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Kivy inspector – debugging interfaces](img/B04244_06_06.jpg)'
  prefs: []
  type: TYPE_IMG
- en: If we press the button **Move to Top** (the first from left to right in the
    bar), the bar will move to the top of the screen as you can see in the right screenshot,
    a more convenient position for our particular application. The second button **Inspect**
    activates or deactivates the inspector behavior. We can now highlight components
    by clicking on them.
  prefs: []
  type: TYPE_NORMAL
- en: 'For example, if you click on the *play*/*pause* button, the video won''t play;
    instead, the button will be highlighted with a red tone as you can see in the
    following left screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Kivy inspector – debugging interfaces](img/B04244_06_07.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Moreover, if we want to visualize the widget that is currently highlighted,
    we just have to press the button **Parent** (third left to right on the bar).
    In the right screenshot, you can see how the *control bar* (parent of the *play*/*pause*
    button) is highlighted instead. You should also notice how the long button (fourth
    left to right on the bar) shows the class that the highlighted instance belongs
    to. If we click on this button, the entire list of properties for that widget
    will be displayed, as shown in the following left screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Kivy inspector – debugging interfaces](img/B04244_06_08.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Finally, when we select one of the properties, we are able to modify it. For
    example, in the right screenshot, we modified the width property of the *control
    bar*, and we can see how the *control bar* immediately adjusts to the changes.
  prefs: []
  type: TYPE_NORMAL
- en: Remember that since the Kivy widgets are kept as simple as possible, it means
    that a lot of the times they are invisible because a more complex graphic to display
    means an unnecessary overload. However, this behavior makes it difficult for us
    to find errors in the GUI. So when our interface does not display what we expect,
    the inspector becomes very handy to help us understand the underlying tree structure
    of the GUI.
  prefs: []
  type: TYPE_NORMAL
- en: ActionBar – a responsive bar
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'A new set of widgets were introduced in Kivy 1.8.0, all of them related to
    the **`ActionBar`** widget. This widget resembles the Android''s action bar. This
    will not only give your applications a modern and professional look, but it also
    includes more subtle properties such as responsiveness to small screens. Depending
    on the `ActionBar` widget hierarchy and components, the different widgets will
    collapse in order to adapt to the screen space available in the device. First,
    let''s take a look at the final result of our planned `ActionBar`:'
  prefs: []
  type: TYPE_NORMAL
- en: '![ActionBar – a responsive bar](img/B04244_06_09.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'We add the Kivy language code to produce the previous bar in a new file `kivyplayer.kv`,
    as presented here:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: 'The hierarchy of the previous code is complicated, so it is also presented
    in the following diagram:'
  prefs: []
  type: TYPE_NORMAL
- en: '![ActionBar – a responsive bar](img/B04244_06_10.jpg)'
  prefs: []
  type: TYPE_IMG
- en: As you can see in the preceding diagram, the **KivyPlayer** contains two main
    components, the `VideoController` that we created two sections ago, and the **ActionBar**.
    If you remember, we created the property playing for the `VideoController` (line
    219), so we bound the associated event `on_playing` to the method `hide_bars`
    (line 311) that later on will basically hide the action bar. Right now, let's
    focus our attention to the hierarchy of `ActionBar`.
  prefs: []
  type: TYPE_NORMAL
- en: 'An **`ActionBar`** will always contain one **`ActionView`**. In this case,
    we just add an `ActionView` with three widgets: `ActionListButton`, **`ActionToggleButton`**,
    and **`ActionGroup`**. All of them inherit from **`ActionItem`**.'
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: An **`ActionView`** should contain only widgets that inherit from **`ActionItem`**.
    We can create our own action items by inheriting from `ActionItem`.
  prefs: []
  type: TYPE_NORMAL
- en: The **`ActionGroup`** groups `ActionItem` instances in order to organize the
    responsive display. In this case, it contains one **`ActionButton`** instance
    and one `ActionTextInput` instance. `ActionListButton` and `ActionTextInput` are
    personalized widgets that we have to create. `ActionListButton` will inherit from
    **`ActionPrevious`** and `ToggleButtonBehaviour`, whereas `ActionTextInput` inherits
    from **`TextInput`** and **`ActionItem`**.
  prefs: []
  type: TYPE_NORMAL
- en: Before continuing, there are a few new properties in the code that deserve an
    explanation. The **`use_separator`** property of `ActionView` (line 317) indicates
    whether a separator will be used before every `ActionGroup`. The `title` property
    (line 321), which displays a title in the component of `ActionListButton`, is
    inherited from `ActionPrevious`. `ActionPrevious` is just a button with some extra
    GUI features (such as the title, but also the Kivy icon that could be modified
    with **`app_icon`**), but, more importantly, its parent (`ActionView`) will keep
    a reference to it with the **`action_previous`** property.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s now see the definition of `ActionTextInput` in the `actiontextinput.kv`
    file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: As we said before, `ActionTextInput` inherits from **`TextInput`** and **`ActionItem`**,
    The **`TextInput`** widget is a simple widget that displays a text input field
    in which the user can write. It inherits directly from the `Widget` class and
    the **`FocusBehaviour`** class, which was introduced in Kivy 1.9.0\. The multiple
    inheritance notations that we used (line 333) are new to us.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: In order to use multiple inheritance in the Kivy language, we use the notation
    `<DerivedClass@BaseClass1+BaseClass2>`.
  prefs: []
  type: TYPE_NORMAL
- en: The **`TextInput`** widget is one of the most flexible widgets in Kivy and contains
    a lot of properties that can be used to configure it. We used the `background_color`,
    `foreground_color`, and `cursor_color` properties (lines 334 to 336) to set the
    background, foreground, and cursor color, respectively. The `hint_text` property
    will display a hint background text, which will disappear when `TextInput` gains
    focus (for example, when we click or touch it). The `multiline` property will
    indicate whether `TextInput` will accept multiple lines, and will also activate
    the `on_text_validate` event when we hit the *Enter* key, and that we use in the
    `kivyplayer.kv` file (line 331).
  prefs: []
  type: TYPE_NORMAL
- en: 'Notice that we also added a few references in `KivyPlayer` (lines 305 to 307).
    We use those references on the Python side of `KivyPlayer`, which is `kivyplayer.py`.
    We will cover this code in three fragments:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: In this fragment, we added all the necessary imports of the code. We also loaded
    the `actiontextinput.kv` file, and defined the `ActionListButton` class inherited
    from `ToggleButtonBehaviour` and `ActionPrevious`, as we indicated before.
  prefs: []
  type: TYPE_NORMAL
- en: 'In fragment 2 of `kivyplayer.py`, we added all the necessary methods that are
    called on by `ActionItems`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: 'For this section, we just implemented the `hide_bars` and `toggle_mute` methods.
    The `hide_bars` method (lines 360 to 371) hides the *action bar* when the video
    is playing in a similar way as we hid the *control bar* before. The `toggle_button`
    method (lines 372 to 382) uses the **`volume`** property to toggle between the
    full volume and mute state. The fragment 3 of the code just contains the final
    commands to run the code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: 'You can now run the application again. You might want to resize the window
    to see how the *action bar* reorganizes the components according to the screen
    size. Here are two examples for medium (left) and small (right) size:'
  prefs: []
  type: TYPE_NORMAL
- en: '![ActionBar – a responsive bar](img/B04244_06_11.jpg)'
  prefs: []
  type: TYPE_IMG
- en: LoadDialog – displaying a directory of files
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In this section, we will discuss how to display a directory tree in Kivy in
    order to select a file. First, we will define the interface in `loaddialog.kv`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: 'There is nothing new in this code except for the use of the **`FileChooserListView`**
    widget. It will display the directory tree of files. The *path* property (line
    398) will indicate the base path of where to start displaying the files. Apart
    from this, we add the **Cancel** (line 402)and **Load** buttons (line 405), and
    they call respective functions in the `LoadDialog` class that is defined in the
    `loaddialog.py` file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: 'There are actually no explicitly defined parameters in this class definition,
    just a couple of properties. We will assign methods to these properties in the
    `kivyplayer.py` file, and Kivy/Python will call them respectively:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: 'If you remember, the **Open List** button of the `ActionBar` instance calls
    the `show_load_list` method (line 329). This method will create an instance of
    `LoadDialog` (line 420), and will send, as parameters of the constructor, two
    others methods: `load_list` (line 424) and `dismiss_popup` (line 427). These methods
    will be assigned to the `load` and `cancel` properties. Once the instance is created,
    we display it in a `Popup` (instance line 421 and 422).'
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, the `load_list` method will be called, when we click on the **Load** button
    of `LoadDialog` (line 420), and the `dismiss_popup` method when the **Cancel**
    button is pressed. Don''t forget to add the corresponding imports in `kivyplayer.py`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: 'Here is the resulting screenshot, where we can appreciate the tree directory:'
  prefs: []
  type: TYPE_NORMAL
- en: '![LoadDialog – displaying a directory of files](img/B04244_06_12.jpg)'
  prefs: []
  type: TYPE_IMG
- en: ScrollView – displaying a list of videos
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In this section, we will display the results of a search performed on the TED
    video site in a *side bar* that we can scroll up and down, as shown in the following
    screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![ScrollView – displaying a list of videos](img/B04244_06_13.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Let''s start defining the components of the side bar in the `sidebar.kv` file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: The `ListItem` class inherits from `ToggleButton`. The `text_size` property
    will establish a boundary for the text. If the titles of the videos are too long,
    two lines will be used instead. The `Sidebar` class inherits from **`ScrollView`**,
    which will allow scrolling down the list of videos, similar to the way we scrolled
    the files in `LoadDialog` of the last section. The `GridLayout` instance inside
    `Sidebar` is the actual widget that will contain and organize the `ListItem` instances.
    This is referenced by `Sidebar` in the `playlist` property (line 442)
  prefs: []
  type: TYPE_NORMAL
- en: Tip
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The contained element inside `ScrollView` has to be allowed to be bigger than
    `ScrollView` in order to scroll. Set `size_hint_y` to `None` if you want to add
    vertical scrolling or `size_hint_x` to `None` if you want to add horizontal scrolling.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s continue with the definition of the sidebar on the Python file (`sidebar.py`):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: 'This file provides the implementation of the `ListItem` class. There are three
    parameters in the constructor (line 473): an instance of the `video` widget, the
    `meta` filename that contains metadata of the video as provided by TED videos,
    and `surl` that contains the subtitle URL. When the `state` property of the `ListItem`
    widget changes, the `on_state` method (line 474) is called. This method will open
    the file provided by TED in a JSON format and extract the necessary information
    to update the video widget properties. We included in the code of this section,
    a collection of TED metadata files in the results folder, in order to test the
    code before you include your own API. For example, `results/97.json` contains
    the metadata for the video of Dan Gilbert we have been using so far. You can verify
    the JSON structure of the lines 477 and 478 in this subtitle file.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, we need to add a `Sidebar` instance to `KivyPlayer` in the `kivyplayer.kv`
    file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: 'We have added the `Sidebar` instance and defined some `position` properties
    based on the other elements of the screen (lines 495 to 498). We also adjusted
    `width` of the *control bar* to `side_bar` (line 480). When `Sidebar` is displayed,
    then the *control bar* will adjust automatically to the available space. We control
    the display of the sidebar with the `ActionListButton` class (line 512), which
    we are going to define in `kivyplayer.py`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: 'The animation of the sidebar is similar to the others we have seen in this
    chapter. We also included two global variables: `_surl` and `_meta` (lines 509
    and 510). These are strings that will serve as templates for the subtitles and
    metadata files. Notice that `%s` inside the strings will be replaced. We also
    introduced a constructor (`__init__`) to the `KivyPlayer` class definition (line
    522 and 524). Line 524 is necessary to guarantee that the `GridLayout` instance
    (inside `ScrollView`) adapts to its height and therefore, allows scrolling.'
  prefs: []
  type: TYPE_NORMAL
- en: 'We now need to add the `ListItem` instances to the `Sidebar` widget. In order
    to do this, we will define the `load_list` method (line 525) and the `load_from_json`
    method (line 532) in `kivyplayer.py`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs: []
  type: TYPE_PRE
- en: We included a `results.json` file that contains an example search result list
    obtained from the TED site. This result is in the JSON format, which you can check
    in the file. We need to open this file and display its content in the *side bar*.
    In order to do this, we select the `result.json` file with the `LoadDialog` display
    using the **Open List** button. Once selected, the `load_list` method is called.
    The method opens the data and loads the JSON data (line 527). Once loaded, it
    calls the `load_from_json` method (line 528). In this method, we create a `ListItem`
    instance (line 539) per result obtained from the search on the TED site, and add
    the instances to the playlist (that is, the `GridLayout` instance inside the *side
    bar* (line 451)). The lines 537 and 538 are a common way of concatenating strings
    in Python. It replaces `%s` which are present in strings (lines 509 and 510) with
    the corresponding parameters after `%`. Now, we will see the results as a side
    bar list in our application when we open the `results.json` file as was shown
    in the screenshot at the beginning of this section.
  prefs: []
  type: TYPE_NORMAL
- en: Search – query the TED Developer API
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: This final section will introduce a few changes to the code so that we can search
    the TED site.
  prefs: []
  type: TYPE_NORMAL
- en: Tip
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'The first thing you need to do is to get an API key from the TED site using
    the following link:'
  prefs: []
  type: TYPE_NORMAL
- en: '[http://developer.ted.com/member/register](http://developer.ted.com/member/register).'
  prefs: []
  type: TYPE_NORMAL
- en: 'A TED API key is an alphanumeric number (something like `''1a3bc2''`) that
    allows you to query the TED website directly, and get requests in the JSON format
    we have been using throughout the last section. Once you receive your API key
    in your e-mail account, you can modify `kivyplayer.py` and put it in an `_api
    global` variable. For now, we can use a placeholder like this in the `kivyplayer.py`
    file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs: []
  type: TYPE_PRE
- en: 'Also, in `kivyplayer.py`, we need to introduce a global variable that contains
    the search template (_`search`), and replace the content of the `_meta` global
    variable:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs: []
  type: TYPE_PRE
- en: 'Notice that the `_meta` variable now has two `%`. Therefore, we will need to
    replace the `meta = meta % t[''id'']` code line with `meta = _meta % (t[''id''],
    _api)` inside the `load_from_json` method (line 533). Also, since we are not opening
    a file, we also need to replace the way we load the JSON in the `ListItem` class
    since we don''t have a file anymore, but a URL. First, we need to import the `URLRequest`
    class (`from kivy.network.urlrequest import UrlRequest`) at the beginning of the
    `sidebar.py` file, and then modify the `on_state` method to use the `URLRequest`
    class as we learned with the subtitles:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE37]'
  prefs: []
  type: TYPE_PRE
- en: 'We also need to import the `URLRequest` class in `kivyplayer.py`, in order
    to implement the `search` method in the `KivyPlayer` class definition:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE38]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, you can go and check whether you received your TED API key. Once you have
    replaced the `_api` variable, you will be able to use the search box in the action
    bar to query the TED API. You can now use the search on `ActionTextInput`:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Search – query the TED Developer API](img/B04244_06_14.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Tip
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Keep in mind that the API key you just created can identify you and your application
    as a user of the TED site. All the activity registered with that API is your responsibility.
    *You shouldn't give this API Key to anyone.*
  prefs: []
  type: TYPE_NORMAL
- en: Controlling the use of your API Key involves setting up your own server, where
    the API key is safely stored. This server will act as a proxy ([https://en.wikipedia.org/wiki/Proxy_server](https://en.wikipedia.org/wiki/Proxy_server))
    of your application, and it should limit the queries. For example, it should avoid
    abusive behavior such as a massive number of queries.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In this chapter, we created an application that integrates many Kivy components.
    We discussed how to control a video and how to associate different elements of
    the screen with it. We explored different Kivy widgets and implemented a complex
    interaction to display a scrollable list of elements. Here is the list of new
    classes and components that we used in this chapter:'
  prefs: []
  type: TYPE_NORMAL
- en: '`Video`: The `allow_stretch` and `source` properties inherited from `Image`;
    the `state` and `progress` properties; the `_on_load`, `on_eos`, `on_source` and
    `on_state`, `on_position`, `seek` methods'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`AsyncImage`: The `source` property inherited from `Image`; the `opacity` (inherited
    from `Widget`) property'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`Label`: The `texture_size` property'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`Slider`: The `value` and `max` properties     `Touch`: The `double_tap` key'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The Kivy Inspector class
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The `ActionBar`, `ActionView`, `ActionItem` `ActionPrevious`, `ActionToggleButton`
    `ActionGroup`, and `ActionButton` classes, with `use_separator` of `ActionView`
    and title of `ActionPrevious` properties
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`Textinput`: The `background_color`, `foreground_color`, `cursor_color` and
    `multiLine` properties'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`FileChooserListView`: The `path` property'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The `ScrollView` class
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: As a side result of the way this chapter, we have obtained an organized is an
    enhanced `Video` widget that we can use in other applications. This `Video` widget
    incorporates synchronization of subtitles that we receive in a JSON format file
    with the progression of the video and a responsive *control bar*.
  prefs: []
  type: TYPE_NORMAL
- en: We have mastered the use of the `Video` widget. We learned how to control its
    progression and add subtitles to it. We also covered how to query the TED Developer
    API in order to get a result lists, and we have practiced our skills manipulating
    the JSON format. We also learned how to use the Kivy debugger in order to detect
    errors in our interfaces.
  prefs: []
  type: TYPE_NORMAL
- en: We also made an effort to make our `KivyPlayer` application look professional.
    We optimized the use of the screen by introducing animations that hide the GUI
    components when unnecessary. As part of this process, we used many Kivy elements
    to make our widget consistent, and we reviewed interesting topics such as behaviors,
    the factory, animations, touch events, and the use of properties in order to create
    versatile components.
  prefs: []
  type: TYPE_NORMAL
- en: The beginning is at the end, so it is now your turn to start your own applications.
    I really hope that what you have learned from this book will help you to implement
    your ideas and start your own application.
  prefs: []
  type: TYPE_NORMAL
