<html><head></head><body>
  <div><div><div><div><div><h1 class="title"><a id="ch09"/>Chapter 9. Grok and the ZODB</h1></div></div></div><p>As we stressed right from the first chapter, one of the most important pieces of Grok is the ZODB. The capability to store objects transparently has allowed us to create a complete application without having to think about persisting its data.</p><p>Although Grok takes care of what little ZODB interaction our application needs behind the scenes, there are a few more things that the ZODB can do, and we will review them in this chapter. In particular, we will see:</p><div><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">How the ZODB works</li><li class="listitem" style="list-style-type: disc">What ZODB storage is</li><li class="listitem" style="list-style-type: disc">How to add file attachments to our application by using Blob support</li><li class="listitem" style="list-style-type: disc">How to pack the database and why this is recommended</li><li class="listitem" style="list-style-type: disc">How to use the ZODB outside Grok</li></ul></div><div><div><div><div><h1 class="title"><a id="ch09lvl1sec01"/>How the ZODB works</h1></div></div></div><p>Before we get into the details of how to use other ZODB functionality, let's talk a bit more about how ZODB works.<a id="id269" class="indexterm"/>
</p><p>Simply put, the ZODB is a persistence system for Python objects. Its objective is to make persistence as transparent as possible, so that any changes to objects can automatically be saved to disk and read again when they are needed.<a id="id270" class="indexterm"/>
</p><p>ZODB is an object database, which means that instead of partitioning objects into one or more tables according to a data schema, the objects themselves are written to the database in their current state. In a relational database system, once a row of data is read from the database, the program still needs to reassemble the columns of information to get a real object instance. In an object database system, an object instance is immediately there when you fetch it from the database.<a id="id271" class="indexterm"/>
</p><div><div><div><div><h2 class="title"><a id="ch09lvl2sec01"/>Transparency</h2></div></div></div><p>Because it's possible to store objects directly into the database as they are, very little effort is needed to make an object ZODB aware. In other words, objects are stored transparently. Due to this, although there are some cases where a little more work is needed, objects can generally be persisted in the database simply by meeting one simple requirement: to subclass from the<code class="literal"> persistent.Persistent</code> class provided by the ZODB.<a id="id272" class="indexterm"/>
</p><p>When instances of persistent objects are modified, they are marked by the ZODB mechanisms, and the changes can be written to the database, if the user requests this. Of course, more than one modification could be requested at the same time. A group of one or more changes to stored objects is known as a<strong> transaction</strong>, and when the objects are written, the transaction is said to have been<strong> committed.</strong>
<a id="id273" class="indexterm"/>
</p><p>A transaction can also be aborted, so that modifications to objects made since the last commit are forgotten. It's also possible to roll back an already committed transaction, leaving the database in a previous state.</p></div><div><div><div><div><h2 class="title"><a id="ch09lvl2sec02"/>ACID properties</h2></div></div></div><p>If you have worked with relational databases, all this talk about transactions should be familiar to you. You might also know that transactional systems need to make sure that the database never gets into an inconsistent state, which they do by supporting four properties, known by the acronym<strong> ACID:</strong>
<a id="id274" class="indexterm"/>
</p><div><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc"><strong>Atomicity:</strong><p>Either all of the modifications grouped in a transaction will be written to the database or, if something makes this impossible, the whole transaction will be aborted. This ensures that in the event of a write error or a hardware glitch, the database will remain in the previous state and avoid inconsistencies.
<a id="id275" class="indexterm"/>
</p></li><li class="listitem" style="list-style-type: disc"><strong>Consistency:</strong><p>For write transactions, this means that no transaction will be allowed if it would leave the database in an inconsistent state. For read transactions, this means that a read operation will see the database in the consistent state it was at the beginning of the transaction, regardless of other transactions taking place at that time.
<a id="id276" class="indexterm"/>
</p></li><li class="listitem" style="list-style-type: disc"><strong>Isolation:</strong><p>When changes are made to the database by two different programs, they will not be able to see each other's transactions until they commit their own.
<a id="id277" class="indexterm"/>
</p></li><li class="listitem" style="list-style-type: disc"><strong>Durability:</strong><p>This simply means that the data will be safely stored once the transaction is committed. A software or hardware crash after that will not cause any information to be lost.
<a id="id278" class="indexterm"/>
</p></li></ul></div></div><div><div><div><div><h2 class="title"><a id="ch09lvl2sec03"/>Other ZODB features</h2></div></div></div><p>In addition to being ACID compliant, the ZODB provides several other features that make it a really good option for industrial-strength data management.<a id="id279" class="indexterm"/>
</p><div><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc"><strong>In memory caching:</strong><p>Every time an object is read from the database, it is kept on a cache in memory, so that subsequent accesses to this object consume less resources and time. The ZODB manages the cache transparently, and automatically removes the objects that have not been accessed for a long time. The size of the cache can be configured, so that machines with more memory can take better advantage of it.
<a id="id280" class="indexterm"/>
</p></li><li class="listitem" style="list-style-type: disc"><strong>Undo:</strong><p>The ZODB provides a very simple mechanism for rolling back any committed transaction, which is possible because it keeps track of the database state before and after every transaction. This makes it possible to undo the changes in a transaction, even if more transactions have been committed after it. Of course, if the objects involved in this transaction that we need to undo have changed in later transactions, it will not be possible to undo it because of consistency requirements.
<a id="id281" class="indexterm"/>
</p></li><li class="listitem" style="list-style-type: disc"><strong>History:</strong><p>As every transaction is kept in the database, it is possible to see an object as it was in previous transactions, and compare it with its current state. This allows a developer to quickly implement simple versioning functionality.
<a id="id282" class="indexterm"/>
</p></li><li class="listitem" style="list-style-type: disc"><strong>Save points:</strong><p>As changes made during a single transaction are kept in memory until the transaction is committed, memory usage can skyrocket during a transaction where lots of objects are modified at the same time (say, a for loop that changes a property on 100,000 objects). Save points allow us to commit part of a transaction before it has finished, so that changes are written to the database and the memory that the changes had occupied is released. These changes in the save points are not really committed until the whole transaction is completed, so that if it is aborted, any save points will be rolled back as well.
<a id="id283" class="indexterm"/>
</p></li><li class="listitem" style="list-style-type: disc"><strong>Blobs (Binary large objects):</strong><p>Binary large objects, such as images or office documents, do not need all of the versioning facilities that the ZODB offers. In fact, if they were handled as regular object properties, blobs would make the size of a database increase greatly, and generally slow things down. That's why the ZODB uses a special storage for blobs, which makes it feasible to easily handle large files up to a few hundred megabytes without performance problems.
<a id="id284" class="indexterm"/>
</p></li><li class="listitem" style="list-style-type: disc"><strong>Packing:</strong><p>As we have seen, the ZODB keeps all versions of the objects stored in it. This means that the database grows with every object modification and can reach really large sizes, which may slow it down. The ZODB allows us to remove old revisions of stored objects via a procedure known as packing the database. The packing routine is flexible enough to allow only objects older than a specified number of days to be removed, keeping the newer revisions.
<a id="id285" class="indexterm"/>
</p></li><li class="listitem" style="list-style-type: disc"><strong>Pluggable storages:</strong><p>By default, the ZODB stores the database in a single file. The program that manages this is called a file storage. However, the ZODB is built in such a way that other storages can be plugged in without needing to modify it. This feature can be used to store ZODB data in other media or formats, as we'll see later in more detail.
<a id="id286" class="indexterm"/>
</p></li></ul></div></div><div><div><div><div><h2 class="title"><a id="ch09lvl2sec04"/>ZEO</h2></div></div></div><p>
<strong>ZEO</strong> stands for<strong> Zope Enterprise Objects</strong> and is a network storage for the ZODB. By using ZEO, any number of Grok instances can connect to the same ZODB. ZEO can be used to provide scalability, because the load can be distributed between several ZEO clients instead of only one.<a id="id287" class="indexterm"/>
</p><p>We'll learn more about ZEO in Chapter 14.</p></div></div></div></div>


  <div><div><div><div><div><h1 class="title"><a id="ch09lvl1sec02"/>Using the ZODB</h1></div></div></div><p>To store objects, the ZODB makes use of a root object, which is basically a container for other objects. Contained objects, in turn, can also act as containers, which means that the ZODB structure can be expressed using a tree.<a id="id288" class="indexterm"/>
</p><div><div><div><div><h2 class="title"><a id="ch09lvl2sec05"/>The rules of persistence</h2></div></div></div><p>Not all object modifications can be automatically detected and transparently written to the database. As we saw earlier in this book, there are some rules about how to make an object persistent and what conditions require additional work:<a id="id289" class="indexterm"/>
</p><div><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">Inherit from<code class="literal"> persistent.Persistent</code> (a class defined in the ZODB code) or one of its subclasses.</li><li class="listitem" style="list-style-type: disc">Class instances have to be related to each other in a hierarchical structure. The ZODB has a root object, and this object contains other objects, which can in turn contain further objects, thereby forming a tree.</li><li class="listitem" style="list-style-type: disc">When modifying mutable attributes of persistent objects that are not persistent themselves, the persistence machinery has to be notified, by setting the special<code class="literal"> _p_changed</code> attribute of the instance to<code class="literal"> True</code>.</li></ul></div></div><div><div><div><div><h2 class="title"><a id="ch09lvl2sec06"/>Traversal</h2></div></div></div><p>To get to a particular object inside the database, the ZODB always starts with the root object and recursively goes inside any containers until it finds the object. This is called<strong> traversal</strong>, because every containing object in the visited object's path has to be touched to get to it.<a id="id290" class="indexterm"/>
</p><p>This means that a unique object can be identified by its path within the database. By design, URL paths can be mapped pretty well to a ZODB structure, so when we have a URL in Grok, every element of its path usually represents an object that has to be traversed to get to a specific object. The exception is sometimes the last element of the path, which can also represent a view.</p></div><div><div><div><div><h2 class="title"><a id="ch09lvl2sec07"/>How Grok uses the ZODB</h2></div></div></div><p>We haven't had to do anything directly with the ZODB so far, because Grok has already set up everything to take advantage of the ZODB's transparency. Grok's models and containers already inherit from<code class="literal"> persistence.Persistent</code>, so modifications to any of our model objects are automatically saved to the database.<a id="id291" class="indexterm"/>
</p><p>In addition, Grok's URL-resolving mechanism uses traversal to get to the persisted objects, so we don't have to keep track of where we put what, in order for Grok to get us the correct object.</p><p>However, Grok can't help us avoid the ZODB requirement to signal the persistence machinery about changes to mutable objects. Remember, whenever changes are made to mutable attributes, the application needs to inform the ZODB that there has been a change. This is done by setting the special<code class="literal"> _p_changed</code> attribute of the instance to<code class="literal"> True:</code>
</p><div><pre class="programlisting">self.context.p_changed_ = True
</pre></div><p>If you use regular Python mutable objects, such as lists and dictionaries, you have to remember this rule, which is not a lot to ask for, but still can be easy to forget. For precisely this reason, the ZODB package includes a couple of replacements for these built-in Python types:<a id="id292" class="indexterm"/>
</p><div><pre class="programlisting">From persistent.list import PersistentList
From persistent.dict import PersistentDict
</pre></div><p>These two types are exact equivalents of the built-in Python types, except they take care of setting<code class="literal"> p_changed</code> when needed. Consider using them if you need a list or a dictionary in your applications.</p></div></div></div>


  <div><div><div><div><div><h1 class="title"><a id="ch09lvl1sec03"/>Adding Blob support to our application</h1></div></div></div><p>Many applications need to allow external files to be uploaded and stored, be it office documents, images, multimedia, or other kinds of files. As processing these files by using the ZODB can prove costly in terms of resources and bandwidth, it's better that we show how to take advantage of the ZODB Blob support now.<a id="id293" class="indexterm"/>
</p><div><div><div><div><h2 class="title"><a id="ch09lvl2sec08"/>Adding messages to projects</h2></div></div></div><p>Right now, the projects in our application have only tasks. This was enough when we had a single-user application, but now that multiple users can log in and have different roles, a mechanism for communicating with other users about the state of the tasks would come in handy.<a id="id294" class="indexterm"/>
</p><p>Let's add a<strong> messages</strong> tab to the project view, where anyone can post a message. A message will have a title, the message text, and optionally will allow users to upload a file.<a id="id295" class="indexterm"/>
</p><div><div><div><div><h3 class="title"><a id="ch09lvl3sec01"/>The megrok.form package</h3></div></div></div><p>We could add some code to enable a Grok form field to use blobs, but sometimes, it's a lot easier to find a package that already does what we need, and then integrate that into our project instead.<a id="id296" class="indexterm"/>
</p><p>As Grok uses the Zope Toolkit, there are hundreds of packages available to choose from. There are also many packages that have been created specifically for Grok. Just go to the Python Package Index (PyPI) page and you will see that there are a lot of packages ready for downloading.</p><p>In this case, there is a package that does exactly what we need, which is to make the use of blobs easy. This package is called<code class="literal"> megrok.form</code>, and we are going to integrate it into our project. It is available at <a class="ulink" href="http://pypi.python.org/pypi/megrok.form">http://pypi.python.org/pypi/megrok.form</a>.</p></div><div><div><div><div><h3 class="title"><a id="ch09lvl3sec02"/>Adding an external package to our project</h3></div></div></div><p>Integrating a package from the PyPI is fairly easy with Grok. The first step is to add it to the project install requirements, which are specified inside the<code class="literal"> setup.py</code> file at the root of our project. Find this file, and change the<code class="literal"> install_requires</code> assignment to look like this:<a id="id297" class="indexterm"/>
</p><div><pre class="programlisting">install_requires=['setuptools',
'grok',
'grokui.admin',
'z3c.testsetup',
'megrok.form',
# Add extra requirements here
],
</pre></div><p>Next, run<code class="literal"> bin/buildout</code> from the command line. The<code class="literal"> megrok.form</code> package and its dependencies will be downloaded and installed into the project. In this case, we added<code class="literal"> megrok.form</code>, but of course, we could pick any other package from PyPI and add it to our project in the same way.<a id="id298" class="indexterm"/>
</p></div><div><div><div><div><h3 class="title"><a id="ch09lvl3sec03"/>How blob support is configured in Grok</h3></div></div></div><p>By default, Grok is preconfigured to use the blob storage, so it's simple to take advantage of it. You can see how this configuration is done if you take a look at the<code class="literal"> zope.conf</code> file in the<code class="literal"> parts/etc/</code> directory of our project. The relevant section looks like this:<a id="id299" class="indexterm"/>
</p><div><pre class="programlisting">&lt;blobstorage&gt;
&lt;filestorage&gt;
path /&lt;your directory&gt;/todo/parts/data/Data.fs
&lt;/filestorage&gt;
blob-dir /&lt;your directory&gt;/todo/parts/data/blobs
&lt;/blobstorage&gt;
</pre></div></div><div><div><div><div><h3 class="title"><a id="ch09lvl3sec04"/>The messaging class and schema</h3></div></div></div><p>Now that we have the supporting packages and configuration that we need, let's get the<strong> messages</strong> tab going. We'll go through the code quickly, as most of the concepts have been used earlier in our application.<a id="id300" class="indexterm"/>
</p><p>First, we add a<code class="literal"> Message</code> class that will store the messages and their attachments. The context of this class will be the<code class="literal"> Project</code> class, as we want messages to be stored by project. Of course, we start by defining the interface for the class:</p><div><pre class="programlisting">class IMessage(interface.Interface):
subject = schema.TextLine(title=u'Subject')
message = schema.Text(title=u'Message text')
attachment = BlobFile(title=u'Attachment',required=False)
</pre></div><p>We keep it simple, by adding only<code class="literal"> subject, message</code>, and<code class="literal"> attachment</code> fields. Note that the field where we'll store the attachment is declared as a<code class="literal"> BlobFile</code>. For this declaration to work, we of course need to include the following import at the top of the file:</p><div><pre class="programlisting">from megrok.form.fields import BlobFile
</pre></div><p>Now, find the actual class definition, where we just implement the interface, and add a<code class="literal"> searchableText</code> method, to allow messages to appear in search results:</p><div><pre class="programlisting">class Message(grok.Model):
grok.implements(IMessage, IMetadata, ISearchable)
subject = u''
message = u''
content_type = 'message'
def searchableText(self):
return self.subject+self.message
</pre></div><p>We need a form for creating the messages and uploading the attachment, so that's our next step. This will create an<code class="literal"> add_message</code> form that will require the<code class="literal"> todo.changeitems</code> permission to be used. The fields come from the interface defined earlier, and we use the template for custom edit forms that we created in Chapter 5.</p><div><pre class="programlisting">class AddMessageForm(grok.AddForm):
grok.context(Project)
grok.name('add_message')
grok.require('todo.changeitems')
form_fields = grok.AutoFields(IMessage)
label = "Add a new message"
template = grok.PageTemplateFile('custom_edit_form.pt')
</pre></div><p>The key part of the form is the add action, where the message is created and its properties are set with the values from the form. Notice that both messages and lists use the same<code class="literal"> next_id</code> counter for their name, so the<code class="literal"> content_type</code> class attribute becomes very important. This will be used to get only messages or only lists, depending upon the view:<a id="id301" class="indexterm"/>
</p><div><pre class="programlisting">@grok.action('Add message')
def add(self,**data):
message = Message()
message.creator = self.request.principal.title
message.creation_date = datetime.datetime.now()
message.modification_date = datetime.datetime.now()
message.project = self.context
message.project_name = self.context.__name__
self.applyData(message,**data)
id = str(self.context.next_id)
self.context.next_id = self.context.next_id+1
self.context[id] = message
return self.redirect(self.url('messages'))
def setUpWidgets(self, ignore_request=False):
super(AddMessageForm,self).setUpWidgets(ignore_request)
self.widgets['subject'].displayWidth = 50
self.widgets['message'].height = 12
</pre></div><p>You can see this form in action in the following screenshot:</p><div><img src="img/7481_09_01.jpg" alt="The messaging class and schema"/></div></div><div><div><div><div><h3 class="title"><a id="ch09lvl3sec05"/>The message viewlet</h3></div></div></div><p>Next, we create the view and viewlet for showing the messages. The view performs a catalog search by using the content type. Of course, we first need to add to our<code class="literal"> ProjectIndexes</code> class (from Chapter 6), so that it gets indexed, as now there are two different kinds of objects that can be stored inside a project (messages and lists). We also have to change the catalog search of<code class="literal"> todo</code> lists to use this new index. Here is the view code:<a id="id302" class="indexterm"/>
</p><div><pre class="programlisting">class ProjectMessages(grok.View):
grok.context(Project)
grok.name('messages')
grok.require('todo.view')
grok.template('master')
def update(self):
catalog = getUtility(ICatalog)
self.messages = catalog.searchResults (content_type=('message','message'), project_name=(self.context.__name__,self.context.__name__))
</pre></div><p>For the viewlet, we simply define a template and set the view to the one that we just created:</p><div><pre class="programlisting">class ProjectMessagesViewlet(grok.Viewlet):
grok.viewletmanager(Main)
grok.context(Project)
grok.template('projectmessages_viewlet')
grok.view(ProjectMessages)
</pre></div></div><div><div><div><div><h3 class="title"><a id="ch09lvl3sec06"/>The message list template</h3></div></div></div><p>The project messages viewlet uses a new template named<code class="literal"> projectmessages_viewlet</code>. We will show a couple of links at the top that will function more or less like tabs, for switching between list and messages views:<a id="id303" class="indexterm"/>
</p><div><pre class="programlisting">&lt;div id="project"&gt;
&lt;h1 id="apptitle" onclick="editTitle();" tal:content="context/title"&gt;To-Do list manager&lt;/h1&gt;
&lt;ul id="project-tabs"&gt;
&lt;li&gt;&lt;a tal:attributes="href python:view.url('index')" title="Project lists"&gt;Lists&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a tal:attributes="href python:view.url('messages')" title="Project messages"&gt;Messages&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;h2&gt;Here you can add new messages relating to this project.&lt;/h2&gt;
&lt;p class="create"&gt;&lt;a href="add_message"&gt;Create a new message&lt;/a&gt;&lt;/p&gt;
</pre></div><p>After that, we show the messages and their contents by using a "repeat" structure. The most important part of the template for the purposes of this chapter is the link for downloading the attachment, which uses the<code class="literal"> view.url</code> method to point to the download view. Note that a message may not include an attachment, which is why the paragraph with the link has a condition for either showing it or not:</p><div><pre class="programlisting">&lt;tal:block repeat="message view/messages"&gt;
&lt;div class="message"&gt;
&lt;h3&gt;&lt;span tal:replace="message/subject"&gt;subject&lt;/span&gt;
&lt;a tal:define="url python:view.url('deletemessage')" tal:attributes="href string:${url}?message=${message/__name__}"&gt; &lt;img border="0" tal:attributes="src static/bin_closed.png" /&gt;&lt;/a&gt;
&lt;/h3&gt;
&lt;p class="message_info" tal:content="string:By ${message/creator}, on ${message/creation_date}"&gt; info &lt;/p&gt;
&lt;p tal:content="message/message"&gt;text&lt;/p&gt;
&lt;p tal:condition="message/attachment"&gt; &lt;a tal:attributes="href python:view.url(message,'download')"&gt; Download attachment &lt;/a&gt; ( &lt;span tal:replace="message/attachment/filename"&gt;filename &lt;/span&gt;, &lt;span tal:replace="message/attachment/size"&gt;size&lt;/span&gt; bytes ) &lt;/p&gt;
&lt;/div&gt;
&lt;/tal:block&gt;
&lt;/div&gt;
</pre></div><p>Some CSS styles were added to the project as well. These are not shown here. Please check the source code for this book to see what they are.<a id="id304" class="indexterm"/>
</p></div><div><div><div><div><h3 class="title"><a id="ch09lvl3sec07"/>Downloading an attachment</h3></div></div></div><p>The last step is to add a view for downloading an attachment. We do not need to show a template here; we have to return the file. This is how it is done:<a id="id305" class="indexterm"/>
</p><div><pre class="programlisting">class Download(grok.View):
grok.context(Message)
grok.require('todo.changeitems')
def update(self):
self.data = self.context.attachment.data
self.filename = self.context.attachment.filename
def render(self):
self.response.setHeader('Content-Disposition', 'attachment; filename=%s;' % self.filename)
return self.data
</pre></div><p>First, we get the filename and the file data from the attachment in question, in the<code class="literal"> update</code> method. Then, in the<code class="literal"> render</code> method, we set the<code class="literal"> Content-Disposition response</code> header to<code class="literal"> attachment</code> and pass the filename to it, so that the browser will know which file to download by using its original name, directly. Finally, we return the file data.<a id="id306" class="indexterm"/>
</p></div><div><div><div><div><h3 class="title"><a id="ch09lvl3sec08"/>Testing the Blob support</h3></div></div></div><p>We are now ready to run the application. The following screenshot shows the way it should look. Try adding a few messages and files, and then take a look at the contents of the<code class="literal"> blob</code> directory that you specified in the<code class="literal"> zope.conf</code> file. You should see a<code class="literal"> blobs</code> directory containing one directory for each file that you uploaded.<a id="id307" class="indexterm"/>
</p><div><img src="img/7481_09_02.jpg" alt="Testing the Blob support"/></div></div></div></div></div>


  <div><div><div><div><div><h1 class="title"><a id="ch09lvl1sec04"/>Taking advantage of transactions</h1></div></div></div><p>We have been saying from the beginning of this chapter that the ZODB is transactional, but so far we haven't seen the benefits that we get from this. Possibly the most important benefit is the ability to roll back, or undo, a transaction.</p><div><div><div><div><h2 class="title"><a id="ch09lvl2sec09"/>Using zope.app.undo</h2></div></div></div><p>As Grok handles the transaction commits for us, we haven't had the chance to show it, but we'll now see how to undo and even redo transactions. The easiest way to show this is to use the<code class="literal"> zope.app.undo</code> package available in the PyPI. We will add it to the project in the same way that we inserted<code class="literal"> megrok.form</code>, earlier in this chapter. Edit the<code class="literal"> setup.py</code> file at the root of the project and add the following code to it:<a id="id308" class="indexterm"/>
</p><div><pre class="programlisting">install_requires=['setuptools',
'grok',
'grokui.admin',
'z3c.testsetup',
'megrok.form',
'zope.app.undo',
# Add extra requirements here
],
</pre></div><p>Now rerun<code class="literal"> bin/buildout</code> to let Grok download and install the package. No other action is needed to enable it just restart the application.</p></div><div><div><div><div><h2 class="title"><a id="ch09lvl2sec10"/>Testing the undo functionality</h2></div></div></div><p>Create an instance of the todo application, and add a project. Then add a list inside that project, with the title<code class="literal"> test undo</code>. Now delete the list that you have just created. You will see an empty project once again.<a id="id309" class="indexterm"/>
</p><p>To undo the transaction, we'll have to use the Grok management interface, which we used earlier, when learning about the catalog, in Chapter 6. Point your browser to the following URL: <a class="ulink" href="http://localhost:8080/todo/@@undoMore.html">http://localhost:8080/todo/@@undoMore.html</a>.</p><p>You should see a list of transactions, similar to the one in the next screenshot. The screen shows the last ten transactions for the todo application instance visited. The transaction at the top is the last one committed. To revert it, simply select the checkbox to its left, and then click on the<strong> Undo</strong> button at the bottom of the screen.</p><p>Now go back to your project. The list that you deleted is magically back there. If you go back to the list, you'll notice that the undo operation itself is now listed as a transaction, so you can "redo" the old transaction, by undoing the transaction that is now at the top.</p><p>"Undo" is a powerful feature, and the one that can make you look like a hero in the eyes of your application users. It's also possible to undo multiple transactions at the same time. However, a transaction can only be undone if the objects on which it operated have not been modified by a later transaction. This means that undoing a mistake is something that has to be done quickly, before new transactions can complicate things.<a id="id310" class="indexterm"/>
</p><div><img src="img/7481_09_03.jpg" alt="Testing the undo functionality"/></div></div></div></div>


  <div><div><div><div><div><h1 class="title"><a id="ch09lvl1sec05"/>ZODB maintenance</h1></div></div></div><p>As with any other database system, the ZODB needs some maintenance, from time to time. The main thing that can happen is that the database size will grow to occupy a large amount of disk space, causing some tasks to become slower.<a id="id311" class="indexterm"/>
</p><div><div><div><div><h2 class="title"><a id="ch09lvl2sec11"/>File storage</h2></div></div></div><p>As we mentioned before, the ZODB keeps track of all of the versions of a stored object, which makes ZODB grow every time an object changes. Packing allows the ZODB to get rid of older versions of objects, thus reducing the database size.<a id="id312" class="indexterm"/>
</p><p>The database is usually contained in a file named<code class="literal"> Data.fs</code>, which is located under<code class="literal"> parts/data</code> in our<code class="literal"> project</code> directory.</p><p>Packing is a process that can take some time, and thus it runs on a separate thread. A backup copy of the database file is created before the packing starts, in case something goes wrong, so be aware that you will need to have at least as much free disk space as the current size of the ZODB, in order to be able to pack it.</p><p>In Grok, the easiest way to pack the database is to go to the administration interface and click on the<strong> Server Control</strong> link. This will take you to a control panel where the option to pack the current database is shown (see the next screenshot). To pack the database, simply select the number of days beyond which object revisions should be removed. The packing process will be started, and when it's finished, there will be a message at the top of the control panel notifying you of this.</p><div><img src="img/7481_09_04.jpg" alt="File storage"/></div></div><div><div><div><div><h2 class="title"><a id="ch09lvl2sec12"/>Automatic packing</h2></div></div></div><p>In most cases, packing will be a good thing to do frequently, unless for some reason you absolutely need to keep track of every revision of every object, ever. Packing the database once a week, for example, could be a good way to keep the database size in check and also to make tasks such as backing up, easier and faster.<a id="id313" class="indexterm"/>
</p><p>Of course, manually packing the database every time could be a burden to an administrator, and is easily forgotten, so an automatic way of performing the packing comes in handy.</p><p>Packing is an expensive operation, and doing it from outside Grok requires a separate database connection, which is why using ZEO is a good idea, even if our scalability demands do not call for it. As ZEO allows multiple connections, packing can be done from another ZEO client, without needing to stop the regular service.</p><p>This task is so necessary that the Grok installation already makes a script available to pack the ZODB by using ZEO. It's called<code class="literal"> zeopack</code>, and can be found under the<code class="literal"> bin</code> directory of the main Grok installation. To use it, simply make sure that the ZEO server is running, and then call the script with the host and port of the site:<a id="id314" class="indexterm"/>
</p><div><pre class="programlisting"><strong>$ bin/zeopack -h localhost -p 8080
</strong>
</pre></div><p>This script call could be added to a UNIX cron script to perform the task weekly, or as frequently as needed.</p></div><div><div><div><div><h2 class="title"><a id="ch09lvl2sec13"/>Backing up</h2></div></div></div><p>As with all important data handling services, backups are greatly encouraged when using the ZODB. Exactly how often to make backups can vary depending on the type of application, but it should be done regularly.<a id="id315" class="indexterm"/>
</p><p>The Grok installation includes a script, called<code class="literal"> repozo</code>, to facilitate backups. This script allows incremental or full backups to be taken, and can be used both for backing up and restoring a<code class="literal"> Data.fs</code> file. To backup our database, we can first create a directory, called<code class="literal"> backups</code> inside our Grok main directory and then use:</p><div><pre class="programlisting"><strong>$ bin/repozo -B -r backups -f todo/parts/data/Data.fs
</strong>
</pre></div><p>The<code class="literal"> -B</code> option means to perform a backup action. The<code class="literal"> -f</code> options gives the path to the<code class="literal"> Data.fs</code> file that we want to backup. The first time,<code class="literal"> repozo</code> will make a full backup to the<code class="literal"> backups</code> directory (specified by the<code class="literal"> -r</code> option). Further calls will result in incremental backups unless the database has been packed after the last backup.</p><p>To recover a<code class="literal"> Data.fs</code> file from a<code class="literal"> repozo</code> backup, we use the<code class="literal"> -R</code> option:</p><div><pre class="programlisting"><strong>$ bin/repozo -R -r backups -o RecoveredData.fs
</strong>
</pre></div><p>This command will recover the latest backup and output the recovered file to<code class="literal"> RecoveredData.fs</code> (specified by the<code class="literal"> -o</code> option). It's also possible to recover a backup from a specified date, by using the<code class="literal"> -D</code> option with a date in the format "yyyy-mm-dd".</p></div><div><div><div><div><h2 class="title"><a id="ch09lvl2sec14"/>Using the ZODB without Grok</h2></div></div></div><p>The ZODB is a very powerful package, and there is no reason why we couldn't use it on regular applications outside Grok, too. In fact, many simple applications that are usually developed by using a relational database (mainly because that's what most developers are used to) can be even simpler if the ZODB is used.<a id="id316" class="indexterm"/>
</p><p>To show how easy it is to work with the ZODB from Python, we'll show a simple example. All that's needed to follow along is to have Python installed, and to use<code class="literal"> easy_install</code> to get the ZODB3 egg, or download the ZODB package from <a class="ulink" href="http://pypi.python.org/pypi/ZODB3">http://pypi.python.org/pypi/ZODB3</a>.</p><p>Create a file named<code class="literal"> zodb_demo.py</code>. First, let's create a small class that will take care of opening and closing the connection to a<code class="literal"> FileStorage</code>. Add the following code at the start of your<code class="literal"> zodb_demo.py</code> file:</p><div><pre class="programlisting">from ZODB import FileStorage, DB
import transaction
class ZODBHandler(object):
def __init__(self, path):
self.storage = FileStorage.FileStorage(path)
self.db = DB(self.storage)
self.connection = self.db.open()
self.dbroot = self.connection.root()
def close(self):
self.connection.close()
self.db.close()
self.storage.close()
</pre></div><p>First, we make a few imports.<code class="literal"> FileStorage</code> is needed to define the file where the database will be stored,<code class="literal"> DB</code> is the actual ZODB library, and<code class="literal"> transaction</code> is used for committing changes to the database.</p><p>Next, we create a class named<code class="literal"> ZODBHandler</code> that will take a file path and initialize a file storage for our ZODB. If the file passed in the path exists, it will be used as the database; if it does not exist, it will be created. Either way, we don't have to worry about this, as<code class="literal"> FileStorage</code> takes care of it for us. With this, we have a storage that we can pass to the<code class="literal"> DB</code> class on the following line. After that, we can open a connection and once this is done, we get the root object of the database and store it in<code class="literal"> dbroot</code>. From there, we can work with the database, as we will see shortly.</p><p>The other thing that our ZODB handler does, is close the connection and storage when we have finished using them, by means of a<code class="literal"> close</code> method that we can call when we want.</p><p>We can now initialize a database, and start writing data to it:</p><div><pre class="programlisting">if __name__ == _'_main__':
db = ZODBHandler('./Data.fs')
dbroot = db.dbroot
dbroot['pi'] = 3.14159265358979323
dbroot['planet'] = 'Earth'
dbroot['primes'] = [1, 2, 3, 5, 7, 11]
dbroot['pycon'] = { 2009: 'Chicago', 2010: 'Atlanta' }
transaction.commit()
</pre></div><p>We pass our handler a path that will create a file named<code class="literal"> Data.fs</code> in the current directory. Next, we get the root object of the database that is stored there. We then add several objects, just to show that any Python object that is pickable can be stored in the database. Finally, we need to commit the transaction, in order to actually save the changes.</p><p>To fetch an object from the database, we simply need to refer to it by its key, much like a dictionary works:</p><div><pre class="programlisting">print dbroot['primes']
</pre></div><p>Deleting an object is also quite easy:</p><div><pre class="programlisting">del dbroot['planet']
transaction.commit()
</pre></div><p>Of course, most applications will not use built-in Python objects, but will create their own classes that subclass from<code class="literal"> persistent.Persistent</code>. Insert the following class definition before the<code class="literal"> if</code> statement, above:</p><div><pre class="programlisting">from persistent import Persistent
class Project(Persistent):
def __init__(self, title, kind, description):
self.title = title
self.kind = kind
self.description = description
</pre></div><p>We can now store projects transparently in our database. Append the following lines at the end of the program:</p><div><pre class="programlisting">dbroot['project 1'] = Project('test project', 'business', 'A simple test project')
dbroot['project 2'] = Project('another project', 'personal', 'a personal project')
transaction.commit()
print dbroot['project 1'].title
dbroot['project 1'].title = 'new title'
transaction.commit()
</pre></div><p>This is a very simple example, but hopefully you can see the potential for creating interesting ZODB-backed applications. No SQL is needed, just plain Python objects.</p></div></div></div>


  <div><div><div><div><div><h1 class="title"><a id="ch09lvl1sec06"/>Summary</h1></div></div></div><p>In this chapter, we have learned more about the ZODB, and learned how to take advantage of its features, such as blob handling. We also learned a bit about ZODB maintenance and the need to pack the database frequently. Finally, we tried our hand at using the ZODB outside Grok, as a regular Python library.</p></div></div>
</body></html>