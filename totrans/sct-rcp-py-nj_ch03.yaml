- en: Working with Decorators
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In this chapter, we will talk about decorators for functions and classes, which
    allow the decorating of functions and classes with more details. In this chapter,
    we will cover the following:'
  prefs: []
  type: TYPE_NORMAL
- en: Reviewing functions
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Introducing decorators
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Using function decorators
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Using class decorators
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Examples of decorators
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Using the decorators module
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Introduction
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Decorators in Python are any callable objects that can modify a function or
    class. They allow some additional functionality similar to other languages, such
    as declaring a method as a class or static method.
  prefs: []
  type: TYPE_NORMAL
- en: A class method is one that is called on a class rather than a particular instance.
    A static method is similar, but would be applied to all instances of a class,
    not just a specific instance. An instance method is the traditional method when
    dealing with OOP in Python.
  prefs: []
  type: TYPE_NORMAL
- en: When a call to a function or a class is made, it is passed to a decorator and
    the decorator returns a modified function/class. These modified objects generally
    include calls to the originally called object.
  prefs: []
  type: TYPE_NORMAL
- en: In this chapter, decorators can be used with functions and methods, but usually
    only the term *functions* will be used for brevity. *Method* will be used when
    explicitly talking about classes.
  prefs: []
  type: TYPE_NORMAL
- en: Reviewing functions
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Because it is important to understand how functions work when we deal with decorators,
    we'll take a quick look at them. First, we need to remember that everything in
    Python is an object, including functions.
  prefs: []
  type: TYPE_NORMAL
- en: 'Functions are created in Python by using the `def` keyword and naming the function;
    input arguments are optional. Following is a basic function for reference:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: How to do it...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Functions can have multiple names, that is, in addition to the function name
    itself, the function can be assigned to one or more variables. Each name has the
    same capabilities of the underlying function:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: 'Functions can be used as arguments for other functions. Some Python built-in
    functions, such as `map` and `filter`, use this feature to do their jobs:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: 'Functions can be nested within other functions:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: 'Functions can be used as parameters to other functions. This is because function
    parameters are actually references to an object, and, since functions are objects,
    functions (actually references to the function object) can be used as parameters:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: 'Functions can return functions. Again, this is because the return value of
    a function is a reference to an object:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: Nested functions have access to the scope of their parent functions; this is
    also called **closure**. It is important to recognize that this access is read-only;
    nested functions cannot write out or assign variables to the outer scope.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'In practice, this is no different than assigning arguments to function variables;
    the input argument is simply being passed to another, enclosed function rather
    than a variable:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: How it works...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Functions and their object-oriented cousins, methods, are the workhorses of
    many programming languages. They allow code reuse, as a function can be called
    multiple times from different locations within the code. They can even be called
    from different programs, if the language supports it, for example, Python imports.
  prefs: []
  type: TYPE_NORMAL
- en: Functions also allow abstraction of work. At their most basic level, a function
    is similar to a black box; all a developer needs to know is what data to feed
    a function and how the function deals with that data, that is, whether a value
    is returned. The actual algorithm within the function doesn't necessarily need
    to be known to use it, as long as the results are consistent.
  prefs: []
  type: TYPE_NORMAL
- en: It is possible to write a program without functions, but it will require the
    entire program to be processed serially. Any functionality that needs to be repeated
    must be copy and pasted every time. This is why even the earliest, high-level
    programming languages included subroutines, which allowed the developer to jump
    out of the main logic flow to process some data, and then return back to the main
    flow. Prior to this, subroutines had to be implemented using a special call sequence
    to store the return address to the main code.
  prefs: []
  type: TYPE_NORMAL
- en: Introducing decorators
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: With that out of the way, we can talk about decorators. Decorators wrap a function
    in another function that modifies the original in some way, such as adding functionality,
    modifying arguments or results, and so on. Decorators are identified by the `@foo`
    nomenclature on the line above a function/method definition.
  prefs: []
  type: TYPE_NORMAL
- en: The workhorse of a decorator function is defining the `wrapper` function within
    it. In this case, the `wrapper` function is a nested function that actually does
    the modification work, though the decorator name is what is called.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Define the decorator function:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: 'Define the main function:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: 'Use the main function as a variable and assign the decorator as its value:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: 'Call the main function:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: 'The whole program looks like `decorator.py`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: 'When ran, the code prints the following:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/28244834-ff32-42b3-a63e-d748d793b201.png)'
  prefs: []
  type: TYPE_IMG
- en: 'To eliminate the line `a_funct = fun_decorator(a_funct)`, we can use syntactic
    sugar (the `@` symbol) to annotate that the main function is modified by a decorator,
    as shown below in `decorator.py`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: 'The decorated function acts the same as when it was a variable:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/c7d3c982-f296-40f6-9e8a-0ced39075383.png)'
  prefs: []
  type: TYPE_IMG
- en: How it works...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: When a function with a decorator is called, the call is caught by the decorator
    function, which then does its work. After it is complete, it hands off to the
    original function, which completes the job. Essentially, everything we discussed
    about preceding functions comes into play when working with decorators.
  prefs: []
  type: TYPE_NORMAL
- en: '**Syntactic sugar** is special syntax within a programming language, designed
    to make life easier for a programmer by making code easier to read or write. Syntactic
    sugar expressions are identified by seeing if the code functionality is lost if
    the sugar goes away. In the case of decorators, we''ve already demonstrated that
    decorator functionality can be maintained without the `@` decorator; we just have
    to manually assign the decorator function to the main function variable.'
  prefs: []
  type: TYPE_NORMAL
- en: Decorated functions can be made permanent by using the first method, that is,
    if a decorated function is assigned to a variable, that variable can be used to
    call the decorated function every time, rather than the original function.
  prefs: []
  type: TYPE_NORMAL
- en: 'Methods can use decorators as well as functions. While any decorator can be
    made, there are a couple of standard decorators available to modify the methods
    for use with classes as well as instances. The following bullet points summarize
    the different methods covered:'
  prefs: []
  type: TYPE_NORMAL
- en: Instance methods are the normal-use methods when working with classes. They
    take an `object(self)` call, where `self` identifies a particular instance to
    work with.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Static methods are more universal, being able to work with all instances of
    a class as well as the class itself.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Class methods operate on the class itself; instances are not affected.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Using function decorators
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Function decorators obviously apply to functions. The `@foo` decorator line
    is placed on the line prior to the function definition. The syntactic sugar takes
    one function and runs its results through another automatically; at the end of
    processing, the original function call''s name is applied to the final result.
    To the system, it looks like the original function call provided the result directly.
    Below is a demonstration of what a decorator looks like:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: When the Python interpreter gets to this code block, `my_function()` is processed
    and the result is passed to the function that `@foo_decorator` points to. The
    decorator function is processed and the result is substituted for the original `my_function()`
    results. In essence, the decorator hijacks the function call, modifying the original
    result and substituting the modification for the result the original function
    would have provided.
  prefs: []
  type: TYPE_NORMAL
- en: Decorator code modification can be in the form of management or augmentation
    of the original call. Once a function has done its work, the decorator takes over
    and does something to the original result, returning the modified code instead.
  prefs: []
  type: TYPE_NORMAL
- en: This concept is reiterated because it is the most important part of decorators;
    at face value, decorators look complicated and it can be difficult to figure out
    how code works when decorators are involved.
  prefs: []
  type: TYPE_NORMAL
- en: Decorators can obviously be applied to any function that relates to the decorators
    modification goals. It is therefore in the programmer's best interest to create
    decorators that are generic enough that they can be used by multiple functions;
    otherwise, you may as well just make the function do what the end result is, rather
    than waste time on a decorator that will be used only once.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'This walk through shows how to create a decorator that can be used to check
    arguments passed to a function. This can be handled in a number of different ways,
    such as `if...else` checks, `assert` statements, and so on, but, by using a decorator,
    we can use this code on any function that operates the same way:'
  prefs: []
  type: TYPE_NORMAL
- en: First, we have to decide what the decorator will do. For this use case, the
    decorator function will look at arguments being passed to a function and check
    whether the values passed are integers.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Write the decorator function just as you would write any other function:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: 'Write the function that will be decorated. In this case, we are simply going
    to calculate some measurements of a circle when the radius is provided:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: 'Add the remainder of the code, such as importing libraries and printing results.
    The following is `arg_check.py`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: How it works...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'When a value is provided as input to the function `circle_measures()`, the
    decorator `@arg_check` checks to see whether the value is an integer and if it
    is positive. If it meets the requirements, the function is allowed to finish and
    the results are printed, as shown in the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/497b5d31-9fa0-4c2b-a38c-afadbac2b7a1.png)'
  prefs: []
  type: TYPE_IMG
- en: 'If the argument passed to the function is negative, then an exception is raised,
    as shown in the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/5d9aba7f-9d88-40ee-9c2f-958358921970.png)'
  prefs: []
  type: TYPE_IMG
- en: 'If the argument passed in is not an integer, an alternate exception is raised,
    as shown in the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/ad548d61-40b3-4905-a798-af9af4111daf.png)'
  prefs: []
  type: TYPE_IMG
- en: 'This code relies on the value passed to the function behind-the-scenes; there
    is no mechanism to allow user input. Accepting user input actually makes it slightly
    more complicated. The change is simple enough, simply adding the input call and
    passing the value to the `circle_measures()` call:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: 'However, since the input is captured as a string, direct input to the function
    would always error out, as shown in the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/e7a7244b-f7f9-480f-a29e-641b6bd31577.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Casting the user input to a integer, that is, `diameter, circumference, area
    = circle_measures(int(r))`, at first glance, eliminates this problem, as the number
    will always be an integer. However, it just causes another problem if the value
    provided by the user doesn''t actually convert to an integer, as shown in the
    following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/730b69b3-eeec-4985-87f8-779d2ae6d7e3.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Obviously, with a little bit of work, all issues could be resolved, but this
    example shows a few things:'
  prefs: []
  type: TYPE_NORMAL
- en: It can be easier to make a program work when you don't have to account for all
    possible input values.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Decorators can actually make life easier, if some thought is put into how to
    write their wrapper function.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Effective testing of software is a critical piece of software development; testing
    for edge cases and potential out-of-bounds data input can reveal interesting things
    and prevent potential security issues.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Using class decorators
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Starting with Python 2.6, decorators have been made to work with classes. In
    this case, rather than just applying solely to functions, class decorators can
    be used on individual instances of classes or can be used on the class itself.
    They are frequently used to make a developer's logic intentions more obvious.
    They can also help minimize errors when it comes to calling methods or when dealing
    with objects.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Class methods can be decorated as well. Instance methods are the most common
    form of methods, that is, functions in classes. Here is `cat_class.py` with a
    few methods to work with:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: 'To utilize this class, create an instance of `Cat`, providing the initial parameters:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: 'Next, call the methods to ensure that they work:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/c7c22727-14a4-464a-b599-7977ef401e44.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Notice that the methods are tied to a particular instance; they cannot be called
    on the generic `Cat` class:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/f8460196-44ab-4f62-b87b-626e4fb6882c.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Static methods are methods that apply to all instances. They are denoted by
    the `@staticmethod` decorator prior to a method definition. Also, the method itself
    does not require a `self` argument in the definition (`static_method.py`):'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: 'Static methods can be applied to both instances and the class itself:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/1b2a88c3-332e-428b-a3cc-d4d3a0a91d0d.png)'
  prefs: []
  type: TYPE_IMG
- en: Notice that on lines 29 and 31, calling the static method without parentheses
    returns the memory location of the method; the method is not bound to an instance,
    but is available to the class as well. Only when parentheses are used (lines 30
    and 32) will the correct return object be displayed.
  prefs: []
  type: TYPE_NORMAL
- en: 'Class methods are identified by the `@classmethod` decorator prior to creating
    the method. In addition, the method argument is `cls` instead of `self`. The following
    code can be added after the static method in the previous example (`class_method.py`):'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, when instance is made, the class it comes from is checked. If the generic `Cat` class
    is the generator, a message will be printed. If a subclass of `Cat` is used, then
    the name of the class is printed:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/bfa5d66b-d6ff-4066-a352-9a4a282835e7.png)'
  prefs: []
  type: TYPE_IMG
- en: Examples of decorators
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Frameworks, such as for web development or graphical interface design, frequently
    have decorators to automate functionality for a developer. While a developer can
    access parts of a framework directly, such as modules and functions, using decorators
    to facilitate this process makes a programmer's life easier.
  prefs: []
  type: TYPE_NORMAL
- en: For example, many web frameworks include a decorator, `@login_required`, to
    ensure that a user is authenticated with the website before being allowed to do
    anything on the site. While login and authentication capabilities could be coded
    by the developer, the framework includes that functionality because it is such
    an integral part of how websites work.
  prefs: []
  type: TYPE_NORMAL
- en: Because it is such an important part of website functionality and is frequently
    used, having a well-developed authentication method should be provided by the
    framework. Much like cryptography, leaving it up to developers to properly implement
    can lead to trouble, as it is easier to do it wrong than to do it right.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: To utilize this recipe, you will have to install the Flask web framework. However,
    the following Flask example doesn't cover everything regarding how to use Flask;
    the installation is simply to ensure that no errors occur. Flask itself can take
    an entire book to cover. This section is designed to show how decorators are used
    in the real world to accomplish a variety of tasks and is not intended to show
    a working Flask website.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Flask does not include a login decorator function, but the documentation does
    provide an example of how to roll your own ([http://flask.pocoo.org/docs/0.12/patterns/viewdecorators/](http://flask.pocoo.org/docs/0.12/patterns/viewdecorators/)).
    This should not be used for production use, even if it copies the Flask functionality,
    as you would then be responsible for ensuring that any modifications to your code
    don''t affect the login functionality:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Import the `wraps` function from the Python standard library''s `functools`
    module. This is necessary to retain the original function''s data:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: 'A number of Flask tools need to be imported. `g` is a Flask application global,
    a special object that is only valid for the active request and returns a different
    value for each request. `request` is the default request object in Flask; it remembers
    the matched endpoint and view arguments. `redirect` returns an HTTP 30x redirection
    code to send the client to the correct destination. `url_for` creates a URL for
    the given endpoint (a web page created by a function call):'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: 'Write the login decorator function:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: 'When implementing the login decorator, it is the last decorator to be used
    prior to writing the main function:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: 'One possible use of a decorator is to set up a timing function to time other
    functions. That way, you don''t have to call `time` from the command line when
    running a script. The following code should be written to a file and not entered
    into an interactive Python prompt (`time_decorator_creation.py`):'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: 'The `time_decorator` can be used with any function to provide the time it takes
    for the function to complete. The following code should be written to the same
    file as the preceding decorator (`time_dec.py`):'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: 'Running the preceding code results in the following:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/8f1b249f-39ec-45d7-9d47-6feaf219d718.png)'
  prefs: []
  type: TYPE_IMG
- en: 'This example (from [https://www.python.org/dev/peps/pep-0318/#examples](https://www.python.org/dev/peps/pep-0318/#examples))
    shows how to add attributes to a function. One use case may be automatically adding
    data to a function, such as metadata (`add_attributes.py`):'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: 'Another example from the PEP-318 documentation is to create a decorator that
    enforces function argument and return types. This is useful when programatically
    running scripts that accept/return arguments, but you cannot guarantee the object
    types that may be input (`function_enforcement.py`):'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: 'If you write unit tests using the `nose` library, the following example (from [https://stackoverflow.com/users/9567/torsten-marek](https://stackoverflow.com/users/9567/torsten-marek)),
    demonstrates how a decorator can automatically pass parameters into a unit test
    function (the full code is not provided, just the implementation on the final
    function call):'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: How it works...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Once the `Flask` modules are imported, the login decorator function provides
    the main logic for handling user authentication. The Python standard library's `@wraps()`
    decorator call does the same thing we have done previously with the `def wrapper()`
    function, except we are utilizing the `functools.wraps` function provided by `Flask`.
    This is necessary because the login decorator wraps and replaces the original
    function; without a wrapper, that original data would be lost during the handover.
  prefs: []
  type: TYPE_NORMAL
- en: The `decorated_function()` takes any number of arguments, either as positional
    or keyword:value pairs. This function first checks to see whether the global object `g.user`
    is `None`, that is, a user not logged in. If this is the case, the user is automatically
    redirected to the `login` page. Because of how Flask works, each page URL is actually
    a function call; the function's name dictates the URI path (more information on
    Flask functionality is provided later).
  prefs: []
  type: TYPE_NORMAL
- en: If the user is already logged in, then the `f()` function (the original function
    called) is called with the arguments the login decorator received. Finally, the
    decorator function ends, returning logic control back to the original function.
  prefs: []
  type: TYPE_NORMAL
- en: There's more...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Here is a real-world example, `long_flask_program.py` from a blog project this
    author created, using the Flask web framework as part of an online mentoring curriculum
    ([https://github.com/crystalattice/Blogful](https://github.com/crystalattice/Blogful)):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: 'In the preceding example, three decorators are applied to the function entries:
    `@app.route("/")`, `@app.route("/page/<int:page>")`, and `@login_required`. The
    decorators are built into Flask and are accessed via the Flask API. `@app.route()` captures
    URL requests and determines which function to call in relation to the URL. `@login_required` comes
    from the Flask login extension and ensures that a user is logged in prior to processing
    a function; if not, the user is redirected to a login screen.'
  prefs: []
  type: TYPE_NORMAL
- en: The `entries` function simply populates a web page with the entries in a blog's
    database. `@app.route("/")` specifies that, when the root URL is provided for
    the website, the browser will be brought to the `entries` function, which will
    process the request and display the blog entries (for the Flask framework, each
    function call in the `views.py` file becomes a URL address. Thus, `entries` would
    appear to a browser as `www.blog_website.com/entries`).
  prefs: []
  type: TYPE_NORMAL
- en: The decorator `@app.route("/page/<int:page>")` specifies that with a URL with
    the resource locator ending in `/page/#`, such as `www.blog_website.com/page/2`,
    the decorator redirects the page request to `entries` and displays the blog posts
    for the indicated page, in this case page 2.
  prefs: []
  type: TYPE_NORMAL
- en: '`entries` defaults to the first page, as shown in the argument passed to it.
    The `default_entries` and `max_entries` dictate how many pages are available on
    the site. Obviously, changing or removing those values can make the blog site
    dump all entries to a single page.'
  prefs: []
  type: TYPE_NORMAL
- en: The `@login_required` decorator catches calls or redirects to the `entries` function
    and makes a pit stop to Flask's authentication module. The user's session is queried
    to see whether the user has authenticated with the system; if not, the user is
    informed that authentication is required prior to accessing the site.
  prefs: []
  type: TYPE_NORMAL
- en: While functionality for the site could be set up without using decorators, it
    hopefully can be seen that using decorators makes it much easier to deal with
    website access. In this case, anytime the web server is told to send a page of
    blog posts to the browser, the URL is parsed to see whether it matches either
    the root "`/`" directory, or a specific page number. If so, then authentication
    is checked. If the user is logged into the site, then the blog post entries are
    finally displayed in the browser.
  prefs: []
  type: TYPE_NORMAL
- en: For this particular program, decorators are also available to catch requests
    to add and delete blog posts, display a particular blog entry (rather than an
    entire page), edit entries, display the login page, and logout a user.
  prefs: []
  type: TYPE_NORMAL
- en: '`decorator_args.py`, below, is from another portion of the Flask blog application,
    showing how one decorator can be used to do different things, depending on the
    arguments passed to it:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: In these examples, both `/entry/add` and `/login` URI calls accept either a
    `GET` or `POST` HTTP request for the database. In the case of a `GET` request,
    the database is queried and the desired information is returned to the screen. If
    the HTTP request is a `POST`, the appropriate decorator is called and the data
    provided in the request is input to the database.
  prefs: []
  type: TYPE_NORMAL
- en: In both cases, the decorator function is effectively the same call; the only
    difference is whether it is a `GET` or `POST` request that is made. The decorator
    knows what to do, based on those arguments.
  prefs: []
  type: TYPE_NORMAL
- en: 'When dealing with login authentication, a better option is to use the [https://flask-login.readthedocs.io/en/latest/](https://flask-login.readthedocs.io/en/latest/) extension,
    which provides the following features:'
  prefs: []
  type: TYPE_NORMAL
- en: Store active user's session ID
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Easy user login and logout
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Restricts views to logged in and logged out users
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Handles "remember me" functionality
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Protects session cookies
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Integration with other Flask extensions
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Using the decorators module
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: With all the functionality that decorators provide, and their common use among
    Python packages, it's inevitable that someone would create a package just for
    decorators. [https://pypi.python.org/pypi/decorator](https://pypi.python.org/pypi/decorator) provides
    a `pip` installable package to help when working with decorators.
  prefs: []
  type: TYPE_NORMAL
- en: The `decorator` module is a very stable (more than 10 years old) tool that provides
    the ability to preserve decorated functions across different Python versions.
    The aim of the module is to simplify decorator usage, reduce boilerplate code,
    and enhance program readability and maintainability.
  prefs: []
  type: TYPE_NORMAL
- en: 'Decorators can be broken down into two main types: signature-preserving and
    signature-changing. The preserving decorators take a function call and return
    a function as the output, without changing anything about the function call''s
    signature. These decorators are the most common type.'
  prefs: []
  type: TYPE_NORMAL
- en: Signature-changing decorators accept a function call, but change the signature
    when output, or simply return non-callable objects. `@staticmethod` and `@classmethod`,
    discussed previously, are examples of signature-changing decorators.
  prefs: []
  type: TYPE_NORMAL
- en: Identifying a function's signature is provided by Python's introspection capabilities.
    In essence, a signature provides all necessary information about a function, that
    is, input and output parameters, default arguments, and so on, so that a developer,
    or the program, knows how to use a function.
  prefs: []
  type: TYPE_NORMAL
- en: This module is designed to provide generic *factory of generators* to hide the
    complexity of making signature-preserving decorators. Preserving decorators, while
    more common, are not necessarily easy to code from scratch, especially if the
    decorator needs to accept all functions with any signature.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'A common use of decorators, outside of frameworks, is to memoize functions.
    Memoization caches the results of a function call to a dictionary; if the function
    is called again with the same arguments, the result is pulled from the cache rather
    than rerunning the function again. Many memoization functions and decorators have
    been created, but most don''t preserve the signature. The following examples are
    taken from the `decorator` module''s documentation ([http://decorator.readthedocs.io/en/latest/tests.documentation.html](http://decorator.readthedocs.io/en/latest/tests.documentation.html)):'
  prefs: []
  type: TYPE_NORMAL
- en: 'A memoization decorator can be written to cache the input arguments to a dictionary
    (`memoize_dec.py`):'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: 'A simple function, with one input argument, works just fine (`memoize_funct.py`):'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs: []
  type: TYPE_PRE
- en: The problem comes when Python introspection tools, such as `pydoc` get involved.
    These introspection tools will see that the decorator states that any number of
    arguments can be accepted, as it is a generic function signature. However, the
    reality is that the main function (`f1()`) only accepts one argument. Trying to
    use more than one argument will result in an error.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'If the `decorate` function from the `decorator` modules is used, this problem
    is alleviated. `decorate` takes two arguments: a caller function that describes
    the decorator''s functionality and the main function to be called.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'In this case, the new decorator becomes two separate functions. The first one
    is the `main` decorator function, that is, the wrapper (`call_dec.py`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs: []
  type: TYPE_PRE
- en: 'The second function is the actual decorator that will be called (`def_memoize.py`):'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs: []
  type: TYPE_PRE
- en: Having two separate functions makes the decorator remove the need for nested
    functions (making it easier to walk through the logic flow) and the developer
    is forced to explicitly pass the desired function for decoration; closures are
    no longer required.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'The following code is a simple sleep timer to simulate data processing (`run_memoize.py`):'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE37]'
  prefs: []
  type: TYPE_PRE
- en: When the `data_simulator()` function is called for the first time, it will take
    the full two seconds to run, due to the sleep function call. However, when it
    is called in the future, the `done` response will be instantaneous because it
    is being pulled from the cache, rather than actually being processed.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: How it works...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The initial `memoize_uw()` decorator creates a blank dictionary to use as the
    cache. The enclosed `memoize()` function takes any number of arguments and looks
    to see whether any of them is a keyword; if so, a frozen set is used to take the
    arguments and use them as values for the keywords. If there are no keywords provided,
    then a new key:value item is created.
  prefs: []
  type: TYPE_NORMAL
- en: If the keyword is not already in the cache dictionary, then a new item is placed
    in the cache; otherwise, the cached item is pulled from the cache and becomes
    a return value. Finally, the entire decorator closes out and the final value is
    returned to the main program.
  prefs: []
  type: TYPE_NORMAL
- en: In the new `_memoize()` function, the same functionality is provided but, as
    the caller function to the decorator, its argument signature must be in the form
    of `(f, *args, **kw)`. It must also call the original function with the arguments;
    this is demonstrated with the line `cache[key] = func(*args, **kw)`.
  prefs: []
  type: TYPE_NORMAL
- en: The new `memoize()` decorator implements the cache as an empty dictionary, like
    before, but uses the `decorate()` function to return the `_memoize()` results
    to the original function.
  prefs: []
  type: TYPE_NORMAL
- en: There's more...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Honestly, there's a lot of moving parts here that can get confusing quickly,
    especially for inexperienced Python programmers. A lot of practice and documentation
    referencing is required to get a handle on both decorators and the `decorator` module.
  prefs: []
  type: TYPE_NORMAL
- en: Do you have to use decorators? No. They are just designed to make the life of
    a programmer easier. Plus, you should know about them because a lot of third-party
    libraries and packages, particularly web and GUI frameworks, utilize them.
  prefs: []
  type: TYPE_NORMAL
- en: Once you get a handle on decorators in general, the `decorator` module will
    probably make more sense, as well as show itself to be useful in minimizing hand-coded
    decorators. There is a lot of functionality included in the module that this book
    doesn't cover, such as converting a caller function directly into a decorator,
    class decorators, and dealing with blocking calls, that is, a process that won't
    allow the program to continue until the process is resolved.
  prefs: []
  type: TYPE_NORMAL
- en: See also
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: You can also refer to the *Using class decorators *recipe of this chapter.
  prefs: []
  type: TYPE_NORMAL
