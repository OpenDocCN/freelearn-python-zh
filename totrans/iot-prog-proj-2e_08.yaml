- en: '8'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Creating an IoT Alarm Dashboard
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In today’s digitalized age, IoT has revolutionized security, transforming basic
    alarm dashboards into comprehensive, real-time security monitors. In [*Chapter
    6*](B21282_06.xhtml#_idTextAnchor091), we started constructing an IoT alarm system
    by building an IoT alarm module that could detect motion and relay MQTT messages.
    [*Chapter 7*](B21282_07.xhtml#_idTextAnchor107), introduced two versions of the
    IoT button: the first uses the M5Stack ATOM Matrix with an LCD matrix screen,
    and the second incorporates an OLED screen, buzzer, arcade-style button for arming
    our IoT alarm module, and a toggle switch for disarming:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 8.1 – IoT alarm system](img/B21282_08_01.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 8.1 – IoT alarm system
  prefs: []
  type: TYPE_NORMAL
- en: In this chapter, we will use our Raspberry Pi 5 with a 7-inch touchscreen to
    serve as our IoT alarm dashboard (*Figure 8**.1*). This dashboard will let us
    arm and disarm our IoT alarm module, review the latest MQTT notification, and
    observe a map pinpointing the location where our alarm was activated. It will
    subscribe and publish to the same MQTT topic, `IoTAlarm`, as the other IoT alarm
    system devices – that is, the IoT alarm module, the M5Stack ATOM Matrix IoT button,
    and the Raspberry Pi Pico W IoT button.
  prefs: []
  type: TYPE_NORMAL
- en: The IoT alarm dashboard completes our advanced IoT alarm system. Our system
    utilizes IoT technology and the internet’s vast reach for global application deployment.
  prefs: []
  type: TYPE_NORMAL
- en: 'We will cover the following topics in this chapter:'
  prefs: []
  type: TYPE_NORMAL
- en: Exploring IoT alarm dashboards
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Creating a Raspberry Pi 5 IoT alarm dashboard
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Building the external alarm buzzer stand
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Running our application
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Let’s begin!
  prefs: []
  type: TYPE_NORMAL
- en: Technical requirements
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The following are the requirements for completing this chapter:'
  prefs: []
  type: TYPE_NORMAL
- en: Intermediate knowledge of Python programming
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A late model Raspberry Pi, such as the Raspberry Pi 5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A Raspberry Pi branded 7-inch touchscreen with a compatible case
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 1x SFM-27 active buzzer
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 2x M2 5mm screws
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 2x M4 20mm bolts
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 2x M4 nuts
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 1x M5 20mm bolt
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 1x M5 nut
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Composite (multi-wire) cable with USB plug (a discarded USB charging cable works
    well)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Hot glue gun
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Access to a 3D printer or 3D printer service to print an optional case
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The code for this chapter can be found here:'
  prefs: []
  type: TYPE_NORMAL
- en: '[https://github.com/PacktPublishing/-Internet-of-Things-Programming-Projects-2nd-Edition/tree/main/Chapter8](https://github.com/PacktPublishing/-Internet-of-Things-Programming-Projects-2nd-Edition/tree/main/Chapter8)'
  prefs: []
  type: TYPE_NORMAL
- en: Exploring IoT alarm dashboards
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: IoT’s true strength is its limitless capabilities, as seen in IoT alarm dashboards.
    Integrating devices such as the Raspberry Pi 5 with the expansive network of IoT
    opens up new possibilities, especially in security systems. Using the Raspberry
    Pi in alarm systems, whether for homes or businesses, offers immense innovation
    potential. This versatile device opens up possibilities for advanced security
    solutions beyond traditional alarm systems.
  prefs: []
  type: TYPE_NORMAL
- en: Using IoT alarm dashboards for industrial processes
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In modern industrial settings, monitoring safety and efficiency is essential.
    The industrial IoT alarm dashboard, which is typically integrated into a control
    room, provides an overview of the facility’s operations. It shows real-time metrics
    and system statuses and sends alarms if equipment deviates from standard parameters.
  prefs: []
  type: TYPE_NORMAL
- en: 'The dashboard’s strength lies in its ability to detect and communicate issues
    quickly via the Internet. For example, in a petrochemical plant, sensors on a
    tank send data to the dashboard, as illustrated in *Figure 8**.2*. Here, sensors
    on the tank publish “temp” and “level” MQTT messages to indicate the temperature
    of the liquid in the tank and the level, respectively. The Raspberry Pi has been
    set up to subscribe to these messages and passes this information onto the web
    interface and analog meter. If the tank’s level drops or its temperature changes
    drastically, the system flags this discrepancy:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 8.2 – Industrial IoT application](img/B21282_08_02.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 8.2 – Industrial IoT application
  prefs: []
  type: TYPE_NORMAL
- en: Alarms alert the team, allowing for prompt action to be taken to ensure worker
    safety and prevent potential hazards. The dashboard can also initiate automated
    responses, such as shutting down affected areas.
  prefs: []
  type: TYPE_NORMAL
- en: Beyond safety, the IoT dashboard enhances operational efficiency. Analyzing
    long-term data can help industries predict maintenance needs, reducing downtimes.
    The dashboard can also connect to supply systems, updating raw material levels
    and product counts. By using data from various sources, industries can improve
    safety and efficiency.
  prefs: []
  type: TYPE_NORMAL
- en: Exploring the IoT security alarm dashboard
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: For modern security, the integration of IoT has redefined the capabilities of
    alarm dashboards. These aren’t the traditional systems of the past; IoT-enhanced
    alarm dashboards are dynamic, offering remote access and responsive actions. For
    instance, with the rise of smart homes and businesses, a breach in security doesn’t
    just trigger a loud siren but can instantly notify homeowners through their mobile
    devices, initiate real-time video footage capture, and even communicate with local
    law enforcement, all powered by IoT connectivity.
  prefs: []
  type: TYPE_NORMAL
- en: 'Armed with our Raspberry Pi 5 and its 7-inch touchscreen display, we will build
    an alarm dashboard (*Figure 8**.3*) for our IoT alarm system. With this dashboard,
    we can arm and disarm our IoT alarm module using a 4-digit pin. Our dashboard
    will display the latest `IoTAlarm` MQTT message and provide a map of the area
    where our alarm has been triggered:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 8.3 – IoT alarm dashboard](img/B21282_08_03.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 8.3 – IoT alarm dashboard
  prefs: []
  type: TYPE_NORMAL
- en: Since our Raspberry Pi 5 doesn’t have a built-in buzzer, we will add an external
    one that we will connect via the GPIO port using a composite (multi-wire) cable.
    This external buzzer will sit in a custom-designed 3D-printed stand and play a
    melody whenever our armed IoT alarm module is triggered.
  prefs: []
  type: TYPE_NORMAL
- en: We will start our development by upgrading the code for our IoT alarm module
    so that it works with the map feature of the IoT alarm dashboard.
  prefs: []
  type: TYPE_NORMAL
- en: Creating a Raspberry Pi 5 alarm dashboard
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Since its release in late 2023, the Raspberry Pi 5 has set a new standard for
    compact computing, enabling developers to build more efficient and powerful applications
    across various domains.
  prefs: []
  type: TYPE_NORMAL
- en: The Raspberry Pi 5 boasts an advanced processor that enhances our IoT alarm
    dashboard’s data processing speed and multitasking capabilities. Its robust software
    support and extensive Python support offer unparalleled programming flexibility,
    tailored to the IoT alarm system’s needs. Paired with the 7-inch touchscreen,
    our Raspberry Pi 5 provides us with a user-friendly and efficient interface for
    our system.
  prefs: []
  type: TYPE_NORMAL
- en: We will begin developing our IoT alarm dashboard by modifying the IoT alarm
    module code from [*Chapter 6*](B21282_06.xhtml#_idTextAnchor091) so that it publishes
    the `location` data on the `IoTAlarm` MQTT topic. This data will enable our dashboard
    to identify the geographic position of the IoT alarm module with precision once
    it’s armed and activated.
  prefs: []
  type: TYPE_NORMAL
- en: Modifying the IoT alarm module code
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '*Figure 8**.1* shows a slightly modified version of our IoT alarm module with
    the addition of a `location` message that sends geolocation data to our IoT alarm
    dashboard. In this case, we could integrate a GPS module, like the shown one in
    *Figure 8**.4*, into our IoT alarm module:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 8.4 – The GPS module next to a Raspberry Pi Pico](img/B21282_08_04.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 8.4 – The GPS module next to a Raspberry Pi Pico
  prefs: []
  type: TYPE_NORMAL
- en: GPS test code
  prefs: []
  type: TYPE_NORMAL
- en: This chapter’s GitHub repository contains test code for a BN-180 GPS module
    and a Raspberry Pi Pico.
  prefs: []
  type: TYPE_NORMAL
- en: 'However, despite its compact size and ability to easily connect to the Raspberry
    Pi Pico W, its value is limited as our IoT alarm module is for indoor use, and
    the GPS would struggle to obtain a strong signal:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 8.5 – Worldwide deployment of the IoT alarm module](img/B21282_08_05.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 8.5 – Worldwide deployment of the IoT alarm module
  prefs: []
  type: TYPE_NORMAL
- en: Instead, we’ll embed the GPS coordinates directly into our IoT alarm module’s
    code, operating under the assumption that the module’s location will remain static
    post-deployment. As the code requires Wi-Fi configuration updates, it’s straightforward
    to adjust the GPS details when we deploy the IoT alarm module on-site. This geolocation
    data will be published within the `location` message as part of enhancing our
    module code. This approach allows us to deploy our IoT alarm modules globally,
    as illustrated in *Figure 8**.5*.
  prefs: []
  type: TYPE_NORMAL
- en: To publish the geolocation information, we will modify the `motion_handler()`
    method from the `main.py` file, which is stored on our IoT alarm module.
  prefs: []
  type: TYPE_NORMAL
- en: The advantage of using MicroPython over C with microcontrollers
  prefs: []
  type: TYPE_NORMAL
- en: While MicroPython runs slower than C, its adaptability is evident when it comes
    to modifying the code for the IoT alarm module. With C, changes require recompilation
    and external code tracking. MicroPython, however, can be edited directly on the
    microcontroller, bypassing filesystem searches during alterations.
  prefs: []
  type: TYPE_NORMAL
- en: 'To modify the code, we must do the following:'
  prefs: []
  type: TYPE_NORMAL
- en: First, we connect our Raspberry Pi Pico W to a USB port on your computer and
    launch Thonny.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Then, we activate the MicroPython environment on our Pico W by selecting it
    from the bottom right-hand side of the screen:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![Figure 8.6 – Selecting MicroPython and Pico in Thonny (Windows version shown)](img/B21282_08_06.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 8.6 – Selecting MicroPython and Pico in Thonny (Windows version shown)
  prefs: []
  type: TYPE_NORMAL
- en: 'Under the `main.py` file to open it:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![Figure 8.7 – Selecting the main.py file](img/B21282_08_07.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 8.7 – Selecting the main.py file
  prefs: []
  type: TYPE_NORMAL
- en: 'Then, we rewrite the `motion_handler()` method so that it reads as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Our only change here is the addition of another publish method on the `mqtt_client`
    object. In the new `publish()` method, we create a message called `location` that
    provides the approximate GPS coordinates of the CN Tower in Toronto, Canada.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: IoT alarm module geolocation
  prefs: []
  type: TYPE_NORMAL
- en: We’ve designed our IoT alarm module to be permanently installed at an indoor
    location – that is, the hard-coded geolocation. We are using the CN Tower in Toronto,
    Canada as an example. You’re encouraged to provide your own unique GPS coordinates.
  prefs: []
  type: TYPE_NORMAL
- en: We then save our changes to our Raspberry Pi Pico W.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: We’ll see the impact of this adjustment when we set up and launch the IoT alarm
    dashboard on our Raspberry Pi 5 in the upcoming section.
  prefs: []
  type: TYPE_NORMAL
- en: Writing the dashboard code
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: For the IoT alarm dashboard, we’ll use the Raspberry Pi 5, the Raspberry Pi
    7-inch touchscreen, and its compatible case. This configuration is like what we
    established in [*Chapter 4*](B21282_04.xhtml#_idTextAnchor068), with the addition
    of an external buzzer exclusive to the IoT alarm dashboard.
  prefs: []
  type: TYPE_NORMAL
- en: We’ll begin by setting up our development environment and installing the packages
    required for our code.
  prefs: []
  type: TYPE_NORMAL
- en: Setting up our development environment
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'We will use a Python virtual environment for our development. As there are
    libraries that only work with the root installation of Python, we will use system
    packages in our Python virtual environment. To do so, we must do the following:'
  prefs: []
  type: TYPE_NORMAL
- en: On our Raspberry Pi 5, we open a Terminal application.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'To store our project files, we create a new directory by running the following
    command:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Then, we navigate to the new directory:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Next, we create a new Python virtual environment for our project:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'With our new Python virtual environment created, we source into it with the
    following command:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '![Figure 8.8 – Terminal showing the use of the dashboard-env environment](img/B21282_08_08.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 8.8 – Terminal showing the use of the dashboard-env environment
  prefs: []
  type: TYPE_NORMAL
- en: 'Next, we install the extra packages that are required for our code:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'With the extra packages installed, we close the Terminal:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: We are now ready to load up Thonny. To do so, we click on the **Menu** icon
    in the Raspberry Pi taskbar, navigate to the **Programming** category, and select
    **Thonny**.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: By default, Thonny uses the Raspberry Pi’s built-in version of Python. For our
    project, we will use the Python virtual environment we just created. To start,
    we need to view the project files by clicking on **View** and selecting **Files**
    if it isn’t already selected.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: In the `Files` section, we locate and open the `dashboard-env` directory.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Then, right-click on the `pyvenv.cfg` file and select the **Activate virtual**
    **environment** option:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![Figure 8.9 – Activating a Python virtual environment in Thonny](img/B21282_08_09.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 8.9 – Activating a Python virtual environment in Thonny
  prefs: []
  type: TYPE_NORMAL
- en: Activating the Python virtual environment
  prefs: []
  type: TYPE_NORMAL
- en: In the steps above we activated the Python virtual environment by clicking on
    the `pyvenv.cfg` file. The step was outlined this way to show an alternative way
    to activate the Python virtual environment than the way shown in previous chapters.
  prefs: []
  type: TYPE_NORMAL
- en: With our project folder created, our Python virtual environment set up, and
    the packages we need for our project installed, we can start writing the code
    for our IoT alarm dashboard. We will divide our code into two files – one for
    the GUI that creates the dashboard and the other to activate the buzzer. But before
    we do, we must wire up the buzzer to the GPIO port of our Raspberry Pi 5.
  prefs: []
  type: TYPE_NORMAL
- en: Wiring up the buzzer
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'For our project, we will use an SFM-27 active buzzer. We wire the buzzer with
    the positive wire (red) connected to GPIO 4 and the negative wire (black) connected
    to GND on the Raspberry Pi 5\. We have the option of installing the buzzer into
    a custom case, something we’ll cover later in this chapter. For our code development
    and testing purposes, it is enough to wire the SFM-127 active buzzer directly
    to the Raspberry Pi 5:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 8.10 – Wiring the buzzer to the Raspberry Pi 5’s GPIO port](img/B21282_08_10.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 8.10 – Wiring the buzzer to the Raspberry Pi 5’s GPIO port
  prefs: []
  type: TYPE_NORMAL
- en: With the buzzer connected to our Raspberry Pi 5, it is now time to write and
    test the buzzer code. We will use this code to activate the buzzer when our dashboard
    receives a `buzzer` message from the MQTT server.
  prefs: []
  type: TYPE_NORMAL
- en: Writing and testing the buzzer code
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: We write our buzzer code using Thonny on our Raspberry Pi 5, which has a 7-inch
    screen. For more screen space to assist in coding, we can add another monitor
    through the Raspberry Pi 5’s mini-HDMI port, creating a dual-monitor setup.
  prefs: []
  type: TYPE_NORMAL
- en: 'To write and test our buzzer code, do the following:'
  prefs: []
  type: TYPE_NORMAL
- en: We launch Thonny by clicking on the **Menu** icon in the Raspberry Pi taskbar,
    navigating to the **Programming** category, and selecting **Thonny**.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: We then activate the `dashboard-env` Python virtual environment.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Once inside Thonny, we create a new tab by selecting **File** and then **New**
    or by hitting *Ctrl* + *N* on your keyboard.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'In our new file, we enter the following code:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: We save the file as `buzzer.py` in the `dashboard` project folder on our Raspberry
    Pi 5.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Before we test our code, let’s examine it:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: We start by importing the `TonalBuzzer` class from the `gpiozero` module.
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: Then, we import the `Tone` class from `gpiozero.tones`.
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: We finish our imports by importing the `sleep` function from the `time` module.
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Next, we define a `BuzzerMelody` class: Initializer (`__init__()`) accepts
    a pin and a list of notes with their durations. The list has a default melody.
    Within the initializer, we do the following:'
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: Initialize a `TonalBuzzer` object with the provided pin
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: Set the melody
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Then, we define the `play_melody()` method. In this method, we do the following:'
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: Iterate through the melody notes
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: Play each note for its specified duration
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: Ensure the buzzer stops after the notes are played
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: Add a brief pause between notes
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: 'If the script is executed as the main program, we do the following:'
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: Create an instance of the `BuzzerMelody` class with pin 4
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: Play the melody using the `play_melody()` method
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: We run the code in Thonny by clicking on the green run button, hitting *F5*
    on your keyboard, or clicking on the **Run** menu option at the top and then **Run**
    **current script**.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: We should hear a melody play from our buzzer.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: With our buzzer code in place, it’s time to write our main dashboard code using
    Kivy.
  prefs: []
  type: TYPE_NORMAL
- en: Creating our Kivy dashboard
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: As mentioned previously, we will be using the Raspberry Pi 5’s 7-inch touchscreen
    to display our dashboard. The use of this screen is optional as we may use a standard
    monitor with our Raspberry Pi.
  prefs: []
  type: TYPE_NORMAL
- en: 'To write and test our Kivy dashboard code, follow these steps:'
  prefs: []
  type: TYPE_NORMAL
- en: Launch Thonny by clicking on the **Menu** icon in the Raspberry Pi taskbar,
    navigating to the **Programming** category, and selecting **Thonny**.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: We then activate the `dashboard-env` Python virtual environment.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Once inside Thonny, create a new tab by selecting **File** and then **New**
    or by hitting *Ctrl* + *N* on your keyboard.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'We will start our code with the necessary imports:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Let’s examine this code:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '`kivy.config`: Our code imports the configuration settings from Kivy to tailor
    the application’s behavior.'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '`fullscreen`: We configure the application to run in fullscreen mode.'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '`borderless`: Our settings eliminate the window border.'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '`kivy.app`: Our code accesses the primary application class from Kivy that’s
    used for initializing and operating Kivy apps.'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '`kivy.uix.floatlayout`: We import `FloatLayout`, a flexible layout mechanism
    that places widgets based on relative coordinates.'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '`kivy.uix.label`: Our code uses the `Label` widget, letting us display text
    within the application.'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '`kivy.uix.button`: We integrate the `Button` widget so that it can be used
    with our keypad.'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '`kivy.clock`: We utilize the `Clock` class to schedule specific functions to
    run at timed intervals.'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '`Threading`: To ensure smooth multitasking, our code uses threading for parallel
    operations. We use threading to run the `start_mqtt()` method in a separate thread.'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '`paho.mqtt.client`: We use the MQTT client library in our code to communicate
    with our MQTT server.'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '`kivy_garden.mapview`: Our code pulls in classes for presenting maps (`MapView`)
    and interactive map markers (`MapMarkerPopup`). We use these classes to visually
    represent the exact location on the map where the alarm has been triggered.'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '`buzzer.BuzzerMelody`: We import the `BuzzerMelody` class so that we can activate
    the external buzzer.'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Then, set the variable declarations for our code:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'From here, we must define the `AlarmDashboard` class, which inherits from the
    `FloatLayout` class, and define the initialization method:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Let’s examine this code:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: First, we initialize specific attributes, such as the default password (`password_toggle`),
    the currently entered password (`entered_password`), a system status flag (`system_armed`),
    a lockout status (`lockout`), and the last received message (`last_message`).
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: Then, we set up an MQTT client with a unique `client_id` and provide it with
    the necessary authentication details using the `username_pw_set` method.
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: The `on_message` attribute of the client is set to a method named `on_message()`,
    which our code will use to handle incoming MQTT messages.
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: We start the MQTT connection on a separate thread using the `start_mqtt` method
    to avoid blocking the main application.
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: The `init_widgets` method, which we’ll define later, is called to initialize
    and arrange the user interface elements.
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: Lastly, we initialize the `buzzer` attribute with an instance of the `BuzzerMelody`
    class, setting it up on GPIO pin 4.
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Now, use the `on_message()` method to handle messages coming from our MQTT
    server:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Let’s examine this code:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Upon receiving a message, our code decodes the message payload from bytes to
    a string
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: The most recent message is stored with the `Last` `message:` prefix
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: If the received message starts with `location:`, it extracts latitude and longitude
    values
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: These values are then used to update the displayed map, scheduling the `update_map()`
    method
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: If the message that’s received is `arm`, the system’s status is updated to `armed`
    via the `update_system_status()` method
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: If the message that’s received is `disarm`, the system’s status is updated to
    `disarmed` via the `update_system_status()` method
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: If the message that’s received is `buzzer`, a melody is played through the `buzzer`
    instance via the `play_melody()` method
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: Regardless of the message’s content, the message that’s displayed is updated
    using the `update_message_display()` method
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: Using the lambda() function in our code
  prefs: []
  type: TYPE_NORMAL
- en: The `lambda()` function is used as an anonymous, inline function in Python.
    It’s typically used for brief operations that are expressed in a single statement.
    Specifically, in our code, the `lambda()` function pairs with Kivy’s `Clock.schedule_once()`
    method to delay certain method executions. By using the `Clock.schedule_once()`
    method, a function can be scheduled to run after a specified delay. When `0` is
    given as its second argument, it indicates the function should be called immediately
    on the next frame.
  prefs: []
  type: TYPE_NORMAL
- en: 'Each instance of the `lambda()` function in our code follows the `lambda dt:
    some_method(arguments)` pattern. Here, `dt` represents the time that’s elapsed
    since the last frame. It’s an argument that `Clock.schedule_once()` automatically
    provides. For example, `Clock.schedule_once(lambda dt: self.update_map(lat, lon),
    0)` schedules the `self.update_map(lat, lon)` method for execution on the upcoming
    frame, with the already parsed `lat` and `lon` values as its arguments. Essentially,
    these `lambda()` functions act as a conduit, passing arguments to methods and
    setting them up for execution on the next frame via Kivy’s scheduling mechanism.
    Utilizing the `Clock()` function ensures that our UI updates remain smooth and
    synchronized with the display’s refresh rate, and also prevents blocking of the
    main thread, thus enhancing the responsiveness of the application.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Our code defines a method called `update_map()`, whose purpose is to update
    the displayed map in two main ways:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Let’s examine this code:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Our code adjusts the center of the map to the new latitude and longitude coordinates,
    which are provided as arguments (`lat` and `lon`).
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: Then, it places a marker (specifically an interactive marker that can show a
    popup) on the map at the specified coordinates. This marker indicates the exact
    location of the IoT alarm module that triggered the alarm.
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: 'The `update_system_status()` method updates the status message on our dashboard
    based on the value of `is_armed`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Then, our code defines a method named `start_mqtt()` that sets up and initiates
    the MQTT communication for the application:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Let’s examine this code:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: The method connects the MQTT client to the specified MQTT server using the given
    server address (`MQTT_SERVER`) and port number (`MQTT_PORT`).
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: Once connected, the client subscribes to a specific topic (`TOPIC`), meaning
    it will start listening for messages that are published on that topic.
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: Finally, the `loop_forever()` method of the client is called, which keeps the
    MQTT client continuously checking for incoming messages and handling them for
    as long as the application runs.
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Our code defines a method named `init_widgets()` for initializing and placing
    various user interface components on our dashboard. We will start with the **keypad**
    **initialization** process:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Here, a keypad layout is set up with buttons arranged in a 3x3 grid. The positions
    of these buttons are specified using the `positions` list, where each tuple represents
    the relative `x` and `y` coordinates. As we loop through these positions, we create
    a button with a corresponding number and bind its `on_press` event to the `handle_key_press()`
    method, which will capture the button press actions. Each button, once initialized,
    is added to the dashboard using the `add_widget()` method.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Now, write the code for the **system** **status label**:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: This label displays the status of the system, indicating whether it is armed
    or disarmed. It’s styled with a specific text size, color, and positioning. Once
    initialized, the label is added to the dashboard.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Next, set up a label for the **MQTT** **message display**:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Here, a label has been set up to display incoming MQTT messages. It has a default
    text of `Waiting for message...` and is styled similarly to the system status
    label. Once it’s been created, it’s added to the dashboard.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Finally, add a **MapView widget**:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Here, we initialize a `MapView` widget to display geographical locations. It’s
    preset to a specific zoom level and initial latitude and longitude coordinates.
    This map view allows us to visualize locations on a map. Once initialized, it’s
    added to our dashboard.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'The `update_message_display()` method is used to refresh or update the text
    that’s displayed in the `message_display` widget to show the latest message that’s
    been received by the system:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'The `handle_key_press()` method manages the user’s interactions with the virtual
    keypad when inputting the alarm system’s passcode, determines the validity of
    the entered code, and adjusts the alarm system’s status based on the passcode
    input:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Let’s examine this code:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '`self.entered_password` string, representing the user’s current passcode input.'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '`handle_key_press()` method verifies if it matches the predefined alarm system
    code. If the code is correct, the following occurs:'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: The alarm system’s status toggles between `armed` and `disarmed`.
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: A corresponding message (`arm` or `disarm`) is sent to the `IoTAlarm` topic.
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: '`lockout` mode:'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: A timer is initiated to end the lockout state after a specified duration (5
    seconds in this case).
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: The code that was entered is reset in anticipation of another attempt.
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: 'The `end_lockout()` function is designed to terminate the lockout state of
    the system. Setting the `lockout` attribute to `False` ensures that subsequent
    operations or interactions that were restricted during the lockout are now permitted:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'At this point, our code introduces the main application class, `MyApp`, which
    is built upon Kivy’s App framework. Inside this class, the `build()` method constructs
    and returns an instance of `AlarmDashboard`. If we run this code directly (not
    imported into another script), the `if __name__ == ''__main__'':` check ensures
    that a new `MyApp` instance is created and launched, initiating the entire alarm
    application:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Save our code as `dashboard.py` in the project folder.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: With our dashboard code written and our buzzer tested, it is time to build the
    custom stand for our buzzer. As always, this is optional; we may run our application
    without encasing the buzzer into a stand. However, doing so makes our application
    more professional-looking, enhances user experience, and offers a more polished
    presentation, ensuring that the buzzer is positioned securely and easily accessible
    when needed.
  prefs: []
  type: TYPE_NORMAL
- en: Building the external alarm buzzer stand
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Encasing our buzzer in a custom stand enhances our IoT alarm dashboard. In this
    section, we will build the stand. We will start by identifying the parts that
    make up our custom buzzer stand before we assemble it.
  prefs: []
  type: TYPE_NORMAL
- en: Identifying the parts
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The parts that make up the custom buzzer stand can be made with either a 3D
    printer or a 3D printing service such as Shapeways ([https://www.shapeways.com](https://www.shapeways.com)).
  prefs: []
  type: TYPE_NORMAL
- en: 'These parts are shown in *Figure 8**.11*:'
  prefs: []
  type: TYPE_NORMAL
- en: '*A*: This is a 3D-printed version of the `Stand.stl` file, which is located
    in the `Build Files/Buzzer Stand` folder of this chapter’s GitHub repository.
    This version of the file was 3D printed using a liquid resin 3D printer and was
    subsequently painted. For those of us who prefer to use an FDM printer, the split
    stand located under `Build Files/Split Stand` would be a better option:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '![Figure 8.11 – Parts of the custom buzzer stand](img/B21282_08_11.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 8.11 – Parts of the custom buzzer stand
  prefs: []
  type: TYPE_NORMAL
- en: '*B*: This is our standard hook. It’s a liquid resin 3D-printed version of the
    `Hook.stl` file, which is located in the `Build Files` folder of this chapter’s
    GitHub repository.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*C*: This is the standard SFM-127 active buzzer that this stand was designed
    to hold.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*D*: This is a painted FDM 3D-printed version of the `Front.stl` file, which
    is also located in the `Build` `Files` folder.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*E*: An FDM 3D printer was used to create a version of the `Back.stl` file.
    This part connects the front (*D*) to the stand (*A*) using the hook (*B*).'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Not shown: A multi-conductor cable such as a discarded USB cable.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Not shown: 2x M4 20mm bolts.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Not shown: 2x M3 10mm bolts.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Not shown: 2x M2 5mm bolts.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Not shown: 1x M5 20mm bolt.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Not shown: 1x M5 nut.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Not shown: 2x female jumper terminals for connecting the buzzer to the GPIO
    port.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Which type of 3D printer should be used to create the parts?
  prefs: []
  type: TYPE_NORMAL
- en: In *Figure 8**.9*, parts were created using both FDM and liquid resin 3D printers.
    The choice of printer depends on the user’s experience and the part’s design.
    Flat parts, such as *E* and *D* in *Figure 8**.10*, are ideal for FDM printers.
    Ornamental designs, such as part *A*, benefit from liquid resin printers. While
    hook (*B*) can use either method, we chose a liquid resin printer with an engineering-grade
    resin (Siraya Tech Blu) for added strength.
  prefs: []
  type: TYPE_NORMAL
- en: With our parts identified, it is time to build our custom buzzer stand.
  prefs: []
  type: TYPE_NORMAL
- en: Building the stand
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'To build the custom buzzer stand, we must follow the steps shown in *Figure
    8**.12*:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 8.12 – Steps to build the custom buzzer stand](img/B21282_08_12.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 8.12 – Steps to build the custom buzzer stand
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s take a closer look:'
  prefs: []
  type: TYPE_NORMAL
- en: Using two M4 10mm bolts, secure the buzzer (see *C* in *Figure 8**.11*) to the
    front casing (see *D* in *Figure 8**.11*). The bolts should screw tightly into
    the buzzer. If they’re loose, we may tighten them with two M4 nuts.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Using a multi-conductor cable, such as a discarded USB cable, solder two wires
    to the buzzer (see *C* in *Figure 8**.11*).
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Thread the multi-conductor cable through the hole on the front casing (see *D*
    in *Figure 8**.11*) and apply glue via a hot glue gun to secure the cable to the
    casing.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Using the same two wires (red and black, in our example) of the multi-conductor
    cable, crimp two female jumper terminals to the ends of the wire. An option here
    is to solder pre-existing jumper cables to the end instead of crimping.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Then, secure the hook (see *B* in *Figure 8**.11*) to the back plate (see *E*
    in *Figure 8**.11*) by either using two M2 5mm screws or epoxy glue.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Using two M3 10mm bolts, secure the back plate (see *E* in *Figure 8**.11*)
    to the front casing (see *D* in *Figure 8**.11*).
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Using an M5 20mm bolt and M5 nut, secure the assembled casing to the stand (see
    *A* in *Figure 8**.11*).
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: With the custom stand built, we may re-connect our buzzer to the GPIO port of
    the Raspberry Pi 5 by following the wiring diagram shown in *Figure 8**.10*.
  prefs: []
  type: TYPE_NORMAL
- en: We are now ready to test our application.
  prefs: []
  type: TYPE_NORMAL
- en: Running our application
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'It’s now time for the moment we have been building toward over the last few
    chapters: testing our entire IoT alarm system. With the IoT alarm dashboard built,
    our IoT alarm system is complete:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 8.13 – Completed IoT alarm system](img/B21282_08_13.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 8.13 – Completed IoT alarm system
  prefs: []
  type: TYPE_NORMAL
- en: We started by building the IoT alarm module (see *E* in *Figure 8**.13*) in
    [*Chapter 6*](B21282_06.xhtml#_idTextAnchor091), before proceeding to build IoT
    buttons (see *A* and *D* in *Figure 8**.13*) in [*Chapter 7*](B21282_07.xhtml#_idTextAnchor107).
    In this chapter, we used the Raspberry Pi 5 with an active buzzer (see *B* and
    *C* in *Figure 8**.13*), a Raspberry Pi 7-inch screen and case (see *B* in *Figure
    8**.13*), a keyboard (see *F* in *Figure 8**.13*), and a mouse (see *G* in *Figure
    8**.13*) to build the IoT alarm dashboard.
  prefs: []
  type: TYPE_NORMAL
- en: 'To test the IoT alarm dashboard, we simply need to arm the IoT alarm module
    and activate it by moving an object in front of its PIR sensor. To do so, follow
    these steps:'
  prefs: []
  type: TYPE_NORMAL
- en: To arm the IoT alarm module, using our mouse, we type the four-digit PIN code
    (1234) into the keypad of the IoT alarm dashboard.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: We should observe that the IoT alarm module goes into armed mode by the long
    blinking of the LED. To activate the alarm, we wave our hands in front of the
    PIR sensor.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: After a few seconds, we should hear the buzzer on the IoT alarm module, followed
    by the buzzers on the IoT button (version 2) and the IoT alarm dashboard.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'We should also observer that a map of Toronto with a marker at the CN Tower
    should be displayed on the screen of the IoT alarm dashboard:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![Figure 8.14 – IoT alarm dashboard showing the location where the alarm was
    activated](img/B21282_08_14.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 8.14 – IoT alarm dashboard showing the location where the alarm was activated
  prefs: []
  type: TYPE_NORMAL
- en: Having successfully tested the IoT alarm system, we’ve concluded the second
    part of this book. Throughout this journey, we’ve explored internet-based device
    communication and harnessed the capabilities of the Raspberry Pi Pico W microcontroller
    and Raspberry Pi 5 computer. This foundation will be invaluable for the advanced
    projects in this book.
  prefs: []
  type: TYPE_NORMAL
- en: If we really want a challenge, we could position each component of the IoT alarm
    system as far apart as possible, perhaps by giving a component to a friend in
    another city. Doing such an activity will help us appreciate not only IoT but
    our internet-connected world in general.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we completed our IoT alarm system by building an IoT alarm
    dashboard. We began by understanding IoT alarm dashboards and their usage by considering
    an example of the level and temperature of a tank. Throughout this chapter, we
    went through the step-by-step process of setting up, coding, and testing our IoT
    alarm dashboard, including adding a custom stand for an external buzzer.
  prefs: []
  type: TYPE_NORMAL
- en: We constructed a dashboard for our IoT alarm system using Kivy on the Raspberry
    Pi 5\. The dashboard integrated map functionality to pinpoint the location of
    any activated IoT alarm module.
  prefs: []
  type: TYPE_NORMAL
- en: 'As we close this section on the IoT alarm system, we look forward to the next
    exciting challenge: building a remote monitoring station using LoRa. This next
    section will introduce us to long-range communication, broadening our understanding
    and capabilities in IoT projects.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Part 3: Creating a LoRa-Enabled IoT Monitoring Station'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this part, we will create a remote environmental monitoring station, using
    LoRa to collect and transmit data on temperature and humidity and transmit it
    over the internet. We will use this data to control an analog weather indicator.
  prefs: []
  type: TYPE_NORMAL
- en: 'This part has the following chapters:'
  prefs: []
  type: TYPE_NORMAL
- en: '[*Chapter 9*](B21282_09.xhtml#_idTextAnchor140), *Understanding LoRa*'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[*Chapter 10*](B21282_10.xhtml#_idTextAnchor157), *Integrating LoRa with the
    Internet*'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
