- en: '9'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '9'
- en: Network Code Testing Framework
  id: totrans-1
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 网络代码测试框架
- en: One important aspect when developing code is to add testing; we discussed and
    reviewed some code test strategies in [*Chapter 5*](B18165_05.xhtml#_idTextAnchor127),
    *Do’s and Don’ts for Network Programming*. But we have not investigated techniques
    that are unique to network automation, such as building a network testing environment
    where we can do some real testing with our network automation code.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 在开发代码时，一个重要的方面是添加测试；我们在[*第五章*](B18165_05.xhtml#_idTextAnchor127)，“网络编程的优缺点”中讨论和回顾了一些代码测试策略。但我们还没有研究网络自动化特有的技术，例如构建一个网络测试环境，我们可以使用网络自动化代码进行一些实际测试。
- en: This chapter will focus on techniques for building a network testing framework
    that can be used for testing your network automation code. We are also going to
    look into advanced techniques that can be added to make your testing framework
    even more useful and reliable.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 本章将重点介绍构建网络测试框架的技术，该框架可用于测试您的网络自动化代码。我们还将探讨可以添加到测试框架中以使其更加有用和可靠的先进技术。
- en: 'Here are the topics we are going to cover in this chapter:'
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 下面是本章将要涉及的主题：
- en: Using software for testing
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用软件进行测试
- en: Using device emulation
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用设备仿真
- en: Connecting devices for testing
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 连接设备进行测试
- en: Using advanced testing techniques
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用高级测试技术
- en: By the end of this chapter, you should have enough information to build and
    use a testing framework that will add significant value to your network automation
    project.
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 到本章结束时，您应该有足够的信息来构建和使用一个测试框架，这将为您网络自动化项目带来显著的价值。
- en: Technical requirements
  id: totrans-10
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 技术要求
- en: The source code described in this chapter is stored in this book’s GitHub repository
    at [https://github.com/PacktPublishing/Network-Programming-and-Automation-Essentials/tree/main/Chapter09](https://github.com/PacktPublishing/Network-Programming-and-Automation-Essentials/tree/main/Chapter09).
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 本章中描述的源代码存储在本书的GitHub仓库中，网址为[https://github.com/PacktPublishing/Network-Programming-and-Automation-Essentials/tree/main/Chapter09](https://github.com/PacktPublishing/Network-Programming-and-Automation-Essentials/tree/main/Chapter09)。
- en: Using software for testing
  id: totrans-12
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用软件进行测试
- en: Some companies, when buying network devices, buy additional devices to be used
    for testing purposes. These extra devices are normally installed in a separate
    environment to replicate part of the production network for testing. Before one
    test is performed, the devices are connected and configured to replicate a particular
    part of the network. Once the tests are finished, the setup is then removed and
    another configuration with different connections may take place to perform tests
    for another part of the network. There are several reasons why these tests are
    necessary, such as testing new software, validating a new configuration, verifying
    an update, checking performance, qualifying a new network design, and testing
    new functionality, among others.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 一些公司在购买网络设备时，会额外购买一些设备用于测试目的。这些额外的设备通常安装在独立的环境中，以复制生产网络的一部分进行测试。在进行测试之前，设备会被连接并配置，以复制网络的一部分。一旦测试完成，设置就会被移除，然后进行不同的配置，以对网络的其他部分进行测试。进行这些测试的原因有很多，例如测试新软件、验证新配置、验证更新、检查性能、评估新的网络设计以及测试新功能等。
- en: But the main problem is that the testing environment is costly, slow to set
    up, and cannot be used by multiple test engineers in parallel. It also demands
    the physical presence of a specialized technician who will eventually have to
    sort new cable connections, perform hardware updates, add or remove network cards,
    and sometimes update the operating systems of the devices.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 但主要问题是测试环境成本高昂，设置缓慢，不能由多个测试工程师并行使用。它还要求有专业技术人员在场，最终需要整理新的电缆连接、执行硬件更新、添加或移除网络卡，有时还需要更新设备的操作系统。
- en: The physical testing environment is ultimately inevitable, but a few tests can
    be performed by using software instead of physical hardware. The tests that can
    be performed by software will depend on the requirement of the test. Tests that
    evaluate software configuration, verify design concepts, validate routing behavior,
    and validate new features and perhaps router stability might be performed by software.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 物理测试环境最终是不可避免的，但可以通过使用软件而不是物理硬件来执行一些测试。软件可以执行的测试将取决于测试的要求。评估软件配置、验证设计概念、验证路由行为、验证新功能以及可能的路由稳定性测试可能由软件执行。
- en: In addition, software can be used to make connections between network devices,
    which also speeds up the setup process. But one area won’t be able to be tested,
    which is network stress and performance, such as measuring maximum throughput
    or capacity.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，软件可以用来在网络设备之间建立连接，这也会加快设置过程。但有一个区域无法进行测试，那就是网络压力和性能，例如测量最大吞吐量或容量。
- en: There are several techniques we can use to use software for network testing,
    and most of them will be done using simulation and emulation. But what are the
    differences between emulation and simulation? Let’s discuss this now.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以使用几种技术来使用软件进行网络测试，其中大部分将使用模拟和仿真来完成。但仿真和模拟之间的区别是什么？现在让我们来讨论这个问题。
- en: Differences between emulation and simulation
  id: totrans-18
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 仿真和模拟之间的区别
- en: Emulation and simulation have their meanings commonly mixed it up. Although
    mistaking them is not that important, it is good to understand their meaning so
    that you can understand their limitations and capabilities when using them.
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 模拟和仿真的含义常常被混淆。虽然弄混它们并不是那么重要，但了解它们的含义是好的，这样你就可以在使用时理解它们的局限性和能力。
- en: In the case of emulation, it is when you use software to mimic the physical
    aspects of the entity you want to test. So, in our network automation, it would
    be a router, a switch, or a network connection (link).
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 在仿真的情况下，是指你使用软件来模拟你想要测试的实体的物理方面。因此，在我们的网络自动化中，它可能是一个路由器、交换机或网络连接（链路）。
- en: Therefore, using a router emulation implies that all necessary hardware, such
    as network ports, console ports, CPU, and memory, must be mocked by software so
    that the operating system of the router can run seamlessly as if it were running
    in real hardware. One example of a router emulator is **Dynamips** (there are
    more details at [https://github.com/GNS3/dynamips](https://github.com/GNS3/dynamips)).
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，使用路由器仿真意味着所有必要的硬件，如网络端口、控制台端口、CPU和内存，必须由软件模拟，以便路由器的操作系统可以无缝运行，就像它在真实硬件上运行一样。一个路由器仿真器的例子是**Dynamips**（更多详情请见[https://github.com/GNS3/dynamips](https://github.com/GNS3/dynamips)）。
- en: On the other hand, a simulator is built to mimic some functionalities of the
    entity that you want to test. In the case of a router, normally, only particular
    functions are simulated, not all the functions of the router. Because of the characteristics
    of being smaller, a simulator can accomplish results much faster and can scale
    up to thousands in comparison to an emulator. Two popular examples of software
    used for simulating networks are **ns-3** ([https://www.nsnam.org/](https://www.nsnam.org/))
    and **NetworkX** ([https://networkx.org/](https://networkx.org/)).
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 另一方面，仿真器是为了模拟你想要测试的实体的某些功能而构建的。在路由器的例子中，通常只模拟特定的功能，而不是路由器的所有功能。由于仿真器体积更小，它可以更快地完成结果，并且与仿真器相比，可以扩展到数千个。两个用于模拟网络的流行软件示例是**ns-3**
    ([https://www.nsnam.org/](https://www.nsnam.org/))和**NetworkX** ([https://networkx.org/](https://networkx.org/))。
- en: Now that we know the differences between emulation and simulation, let’s dive
    a bit deeper into emulation.
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 既然我们已经了解了仿真和模拟之间的区别，那么让我们更深入地探讨一下仿真。
- en: Using device emulation
  id: totrans-24
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用设备仿真
- en: 'The best use case for using emulation in our network automation would be for
    routers. With router emulation, we can test several features of the router without
    having it physically. But router emulation is perhaps the hardest to accomplish
    and the costliest in terms of resources. As an example, let’s explore how a popular
    Cisco router emulator works, called Dynamips. *Figure 9.1* represents a Cisco
    router being emulated by using Dynamips on a Linux host:'
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的网络自动化中使用仿真的最佳用例可能是路由器。通过路由器仿真，我们可以在不实际拥有它的情况下测试路由器的几个功能。但路由器仿真可能是最难以实现且在资源方面成本最高的。作为一个例子，让我们探讨一个流行的Cisco路由器仿真器的工作原理，称为Dynamips。*图9.1*展示了使用Dynamips在Linux主机上仿真的Cisco路由器：
- en: '![Figure 9.1 – Cisco router emulation](img/B18165_09_001.jpg)'
  id: totrans-26
  prefs: []
  type: TYPE_IMG
  zh: '![图9.1 – Cisco路由器仿真](img/B18165_09_001.jpg)'
- en: Figure 9.1 – Cisco router emulation
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 图9.1 – Cisco路由器仿真
- en: As illustrated, Dynamips is a software layer that emulates the hardware for
    Cisco routers. Dynamips can emulate some Cisco hardware such as network ports,
    CPU, memory, auxiliary ports, and console ports. Dynamips was created by Christophe
    Fillot in 2005 to emulate the MIPS processor architecture for Cisco routers. Today,
    Dynamips is supported and maintained by the GNS network simulation team, more
    details of which can be found at [https://github.com/GNS3/dynamips](https://github.com/GNS3/dynamips).
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 如上图所示，Dynamips 是一个软件层，用于模拟 Cisco 路由器的硬件。Dynamips 可以模拟一些 Cisco 硬件，例如网络端口、CPU、内存、辅助端口和控制台端口。Dynamips
    由 Christophe Fillot 在 2005 年创建，用于模拟 Cisco 路由器的 MIPS 处理器架构。如今，Dynamips 由 GNS 网络模拟团队支持和维护，更多详情可以在
    [https://github.com/GNS3/dynamips](https://github.com/GNS3/dynamips) 找到。
- en: Dynamips works like a virtual machine in that it will only run a Cisco operating
    system. To emulate a MIPs processor, Dynamips consumes a lot of CPU and memory.
    For instance, to run a legacy Cisco router 7200, Dynamips will allocate a minimum
    of 256 MB of RAM, plus 16 MB of cache. CPU is also heavily used to run the router
    by translating instruction by instruction. Earlier versions of Dynamips overloaded
    the CPU host, but with the introduction of a capability called **idle-PC**, the
    CPU consumption was reduced by a significant amount.
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: Dynamips 的工作方式类似于虚拟机，它只会运行 Cisco 操作系统。为了模拟 MIPS 处理器，Dynamips 会消耗大量的 CPU 和内存。例如，要运行传统的
    Cisco 路由器 7200，Dynamips 至少需要分配 256 MB 的 RAM，以及 16 MB 的缓存。CPU 也被大量使用来运行路由器，通过逐条指令进行翻译。Dynamips
    的早期版本过度使用了 CPU 主机，但随着名为 **idle-PC** 的功能的引入，CPU 消耗量显著减少。
- en: Other routers can be emulated but will need an emulator that provides the necessary
    hardware emulation for the CPU platform you require. Juniper routers can be emulated
    by using Juniper Olive. Juniper Olive is FreeBSD modified to load the Juniper
    router operational system called JunOS. With emulation, you can also run legacy
    routers by using a hardware emulator that can provide legacy CPU architecture.
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 其他路由器也可以进行模拟，但需要提供所需 CPU 平台的必要硬件模拟的模拟器。可以使用 Juniper Olive 来模拟 Juniper 路由器。Juniper
    Olive 是修改过的 FreeBSD，用于加载 Juniper 路由器操作系统 JunOS。通过模拟，您还可以使用能够提供传统 CPU 架构的硬件模拟器来运行传统路由器。
- en: 'The following diagram illustrates a system running with four emulations, two
    Cisco routers, one Juniper router, and one legacy OpenWRT router:'
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 下图展示了运行四个模拟的系统，包括两个 Cisco 路由器、一个 Juniper 路由器和一个传统 OpenWRT 路由器：
- en: '![Figure 9.2 – Four emulations on one system](img/B18165_09_002.jpg)'
  id: totrans-32
  prefs: []
  type: TYPE_IMG
  zh: '![图 9.2 – 单个系统上的四个模拟](img/B18165_09_002.jpg)'
- en: Figure 9.2 – Four emulations on one system
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 图 9.2 – 单个系统上的四个模拟
- en: The connection between these routers in the preceding diagram is created on
    the operating system host. The host can provide a more complex software link emulation
    to provide connectivity or just copy traffic from one end and send it to another
    end for point-to-point connections. More on these connections will be explained
    later in this chapter in the *Connecting devices for testing* section.
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 前图中这些路由器之间的连接是在操作系统主机上创建的。主机可以提供更复杂的软件链路模拟以提供连接，或者只是从一端复制流量并发送到另一端以实现点对点连接。关于这些连接的更多内容将在本章的
    *连接设备进行测试* 部分中解释。
- en: Note that with emulation, it is possible to completely isolate the router, thus
    providing a completely different architecture. In *Figure 9.2*, Dynamips provides
    a MIPS CPU architecture to emulate Cisco 7200, Qemu provides a 32-bit CPU architecture
    to emulate a legacy OpenWRT router, VMware provides a 64-bit x86 CPU architecture
    to emulate a Juniper router, and Qemu provides a 64-bit x86 CPU architecture to
    emulate a Cisco XRv 9000.
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，通过模拟，可以完全隔离路由器，从而提供完全不同的架构。在 *图 9.2* 中，Dynamips 提供了 MIPS CPU 架构来模拟 Cisco
    7200，Qemu 提供了 32 位 CPU 架构来模拟传统 OpenWRT 路由器，VMware 提供了 64 位 x86 CPU 架构来模拟 Juniper
    路由器，而 Qemu 提供了 64 位 x86 CPU 架构来模拟 Cisco XRv 9000。
- en: The host that’s used for emulating these routers is Linux with a 6.1.4 kernel,
    but it could be another kernel or another operating system such as Windows that’s
    capable of running the emulators. The consumption of CPU and memory for *Figure
    9.2* is quite high – Cisco 9000 requires at least 4 vCPUs and 16 GB of RAM, Juniper
    requires a minimum of 2 vCPUs and 512 MB of RAM, Legacy OpenWRT requires a minimum
    of 1 vCPU, and Cisco 7200 requires a minimum of 2 vCPUs and around 300 MB.
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 用于仿真这些路由器的宿主操作系统是Linux，内核版本为6.1.4，但也可以是其他内核或其他操作系统，例如能够运行仿真器的Windows。*图9.2*的CPU和内存消耗相当高——Cisco
    9000至少需要4个vCPU和16GB的RAM，Juniper至少需要2个vCPU和512MB的RAM，Legacy OpenWRT至少需要1个vCPU，而Cisco
    7200至少需要2个vCPU和大约300MB。
- en: Therefore, creating a large network using router emulation is hard, and perhaps
    impossible because of limited resources. One way to scale up the emulation is
    to share the hardware drivers, memory, and CPU by using some sort of operating
    system isolation, such as using Linux containers or FreeBSD jails. But with container
    setup, you will have to use the same version of the kernel and the same CPU architecture
    for all routers. Therefore, if your router runs on an ARM processor, and your
    host is an x86 processor, Linux containers won’t work. To work, the containers
    and the host must use the same CPU architecture.
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，使用路由器仿真创建大型网络是困难的，也许由于资源有限，甚至是不可能的。扩展仿真的一个方法是通过某种操作系统隔离来共享硬件驱动程序、内存和CPU，例如使用Linux容器或FreeBSD监狱。但是，在容器设置中，您必须为所有路由器使用相同的内核版本和相同的CPU架构。因此，如果您的路由器运行在ARM处理器上，而您的宿主机是x86处理器，Linux容器将无法工作。为了工作，容器和宿主机必须使用相同的CPU架构。
- en: Now, let’s have a look at how to scale emulation using containers.
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们看看如何使用容器扩展仿真。
- en: Scaling up emulation with containers
  id: totrans-39
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用容器扩展仿真
- en: Emulation will scale up if you share resources from the host dynamically. However,
    that requires your router to run as a program on a Linux host that can be isolated
    as a container. That is perhaps a big limitation as most commercial routers do
    not run on Linux and can’t be containerized. Choosing open source routers gives
    you the advantage of it being easy to move to a container-based architecture.
    Some big companies have chosen to move away from commercial operating system routers
    and migrate to a Linux-based routing architecture, which facilitates the creation
    of the emulated network.
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您动态地从宿主机共享资源，仿真可以扩展。然而，这要求您的路由器作为程序在Linux宿主机上运行，并且可以作为一个容器进行隔离。这或许是一个很大的限制，因为大多数商业路由器不运行在Linux上，也不能进行容器化。选择开源路由器可以让你享受到它易于迁移到基于容器架构的优势。一些大型公司已经选择放弃商业操作系统路由器，并迁移到基于Linux的路由架构，这有助于创建仿真的网络。
- en: Despite the commercial limitations, some vendors provide versions that can be
    containerized, such as Arista, Cisco, Juniper, and Nokia. This includes Cisco
    XRv and CSRv versions, Juniper vMX and vQFX, Arista vEOS, and Nokia VSR. One project
    that explores these capabilities is **vrnetlab** (there are more details at [github.com/vrnetlab/vrnetlab](http://github.com/vrnetlab/vrnetlab)).
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管存在商业限制，一些供应商提供了可容器化的版本，例如Arista、Cisco、Juniper和Nokia。这包括Cisco XRv和CSRv版本、Juniper
    vMX和vQFX、Arista vEOS和Nokia VSR。一个探索这些功能的项目是**vrnetlab**（更多详情请见[github.com/vrnetlab/vrnetlab](http://github.com/vrnetlab/vrnetlab))。
- en: There are a bunch of network tests that can be done, even if the routers are
    not the same as production, such as network design tests, topology migration tests,
    IP filter-based tests, and topology failover tests, among others. The reason is
    that most topologies run standard protocols and can be translated into an open
    source network platform. If you are using SDN and OpenFlow, that is also true.
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 即使路由器与生产环境不同，也可以进行一系列网络测试，例如网络设计测试、拓扑迁移测试、基于IP过滤器的测试和拓扑故障转移测试等。原因是大多数拓扑运行标准协议，可以转换为开源网络平台。如果您使用SDN和OpenFlow，这也同样适用。
- en: 'The following diagram illustrates how you could run four emulated routers using
    containers:'
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 以下图表说明了您如何使用容器运行四个仿真的路由器：
- en: '![Figure 9.3 – Running emulation with containers](img/B18165_09_003.jpg)'
  id: totrans-44
  prefs: []
  type: TYPE_IMG
  zh: '![图9.3 – 使用容器运行仿真](img/B18165_09_003.jpg)'
- en: Figure 9.3 – Running emulation with containers
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 图9.3 – 使用容器运行仿真
- en: As you can see in the preceding figure, the containers share CPU, memory, and
    network ports with the Linux host (green rectangle), but with isolation within
    the container. Each container isolates the shared resources from other containers,
    but they use the same Linux kernel, same drivers, and same CPU architecture. Different
    runtime libraries can be used, but the kernel and CPU architecture must be the
    same. Each container will have its own routing table, and programs running on
    the same container will share the same routing table but will not share the routing
    tables between containers unless using a routing protocol.
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 如前图所示，容器与Linux主机（绿色矩形）共享CPU、内存和网络端口，但在容器内部是隔离的。每个容器将共享资源与其他容器隔离，但它们使用相同的Linux内核、相同的驱动程序和相同的CPU架构。可以使用不同的运行时库，但内核和CPU架构必须相同。每个容器将有自己的路由表，运行在相同容器上的程序将共享相同的路由表，但除非使用路由协议，否则不会共享容器之间的路由表。
- en: You could also run a virtual machine inside a container, but then you are not
    saving resources, and the limitations shown previously are the same. So, if you
    want to scale up, you have to share the hardware resources with all containers,
    not emulate another layer like in *Figure 9.2*.
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: '你也可以在容器内运行虚拟机，但这样你并没有节省资源，之前显示的限制仍然是相同的。所以，如果你想扩展，你必须与所有容器共享硬件资源，而不是像*图9.2*中那样模拟另一层。 '
- en: 'In the example in *Figure 9.3*, there are four routers – one FRRouting, one
    OpenWRT, one Quagga, and one DD-WRT. All these routers are open source and can
    be containerized. But they are not necessarily one program running, but instead
    a group of programs. Quagga and FFRouting run several programs that do different
    tasks, such as `bgpd`, `ospfd`, and `zebra`. References to these open source routers
    can be obtained from the following sources:'
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 在*图9.3*的示例中，有四个路由器——一个FRRouting，一个OpenWRT，一个Quagga和一个DD-WRT。所有这些路由器都是开源的，并且可以被容器化。但它们不一定是一个程序在运行，而是一组程序。Quagga和FRRouting运行了几个执行不同任务的程序，例如`bgpd`、`ospfd`和`zebra`。这些开源路由器的参考资料可以从以下来源获得：
- en: 'FRRouting: [https://frrouting.org/](https://frrouting.org/)'
  id: totrans-49
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 'FRRouting: [https://frrouting.org/](https://frrouting.org/)'
- en: 'OpenWRT: [https://openwrt.org/docs/guide-user/virtualization/lxc](https://openwrt.org/docs/guide-user/virtualization/lxc
    )'
  id: totrans-50
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 'OpenWRT: [https://openwrt.org/docs/guide-user/virtualization/lxc](https://openwrt.org/docs/guide-user/virtualization/lxc)'
- en: 'Quagga: [https://www.nongnu.org/quagga/](https://www.nongnu.org/quagga/)'
  id: totrans-51
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 'Quagga: [https://www.nongnu.org/quagga/](https://www.nongnu.org/quagga/)'
- en: 'DD-WRT: [https://dd-wrt.com/](https://dd-wrt.com/)'
  id: totrans-52
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 'DD-WRT: [https://dd-wrt.com/](https://dd-wrt.com/)'
- en: You will need some connectivity capability to be able to connect the emulated
    routers. Now, let’s discuss the techniques we can use to connect devices in a
    network.
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 你将需要一些连接能力来连接模拟的路由器。现在，让我们讨论我们可以用来连接网络设备的技术。
- en: Connecting devices for testing
  id: totrans-54
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 测试设备连接
- en: Ensuring the connectivity of our devices for tests is important for obtaining
    a proper network environment for testing. There are several different ways to
    connect devices for testing, such as physical cables and software. Physical cables
    always have two caveats – they require technical personnel at the site and take
    time to implement. Via software, there is only one limitation – the maximum data
    throughput, which is normally a fraction of a physical cable. Therefore, if your
    tests require high data throughput, you might need to use physical wires instead.
    There is a workaround to this limitation that we are going to explain later in
    this chapter when we look at advanced techniques.
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 确保我们的设备在测试中的连通性对于获得适当的测试网络环境非常重要。有几种不同的方式可以连接测试设备，例如物理电缆和软件。物理电缆总是有两个缺点——它们需要现场的技术人员，并且需要时间来实现。通过软件，只有一个限制——最大数据吞吐量，这通常是一个物理电缆的一部分。因此，如果你的测试需要高数据吞吐量，你可能需要使用物理电缆。我们将在此章的后面部分解释这个限制的解决方案，当我们查看高级技术时。
- en: The environment for using devices for testing is also known as a network testing
    laboratory or just a network lab. To explain how we can connect devices in our
    lab, let’s describe the three possible ways to connect devices in a lab.
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 使用设备进行测试的环境也被称为网络测试实验室，或者简称为网络实验室。为了解释我们如何在实验室中连接设备，让我们描述在实验室中连接设备的三种可能方式。
- en: Using physical wires to connect
  id: totrans-57
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用物理电缆连接
- en: In a test environment, a physical connection normally consists of wires that
    connect the ports of network devices. They are normally optical cables, coaxial
    cables, or twisted pair cables. If you have two devices, the cables are simple
    and will pass from one device to the other. However, if you are planning to have
    a lab with several racks and dozens of devices, you might want to use a patch
    cord and a patch panel instead of passing wires through the racks. The idea of
    using a patch panel is that the technician will only need to use patch cords to
    connect the devices, which makes the connection setup a bit faster and easier
    to remove later.
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 在测试环境中，物理连接通常由连接网络设备端口的线缆组成。它们通常是光纤电缆、同轴电缆或双绞线电缆。如果您有两个设备，电缆很简单，将从一个设备传递到另一个设备。然而，如果您计划拥有一个包含几个机架和数十个设备的实验室，您可能希望使用配线线缆和配线面板，而不是通过机架传递线缆。使用配线面板的想法是，技术人员只需使用配线线缆来连接设备，这使得连接设置更快，并且以后更容易移除。
- en: 'It is important to understand how the patch panel and patch cords work in the
    physical lab because it will help us to understand the software version later.
    The following diagram illustrates the patch panels for connecting two racks with
    four routers each:'
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 理解配线面板和配线线缆在物理实验室中的工作原理非常重要，因为它将帮助我们理解软件版本。以下图表展示了连接两个机架（每个机架有四个路由器）的配线面板：
- en: '![Figure 9.4 – Connecting routers using patch panels](img/B18165_09_004.jpg)'
  id: totrans-60
  prefs: []
  type: TYPE_IMG
  zh: '![图9.4 – 使用配线面板连接路由器](img/B18165_09_004.jpg)'
- en: Figure 9.4 – Connecting routers using patch panels
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 图9.4 – 使用配线面板连接路由器
- en: Note that in the preceding figure, the orange and blue wires represent permanent
    wires and will never be removed. The red and green lines represent the patch cords
    that are used to connect devices but can be removed and reconnected easily for
    a different topology setup. The blue lines in rack 1 are connecting routers R0,
    R1, R2, and R3 to patch panel P1, similar to rack 2, which connects routers R10,
    R11, R12, and R13 to patch panel P11\. The orange lines represent the permanent
    wires that connect patch panel P0 to patch panel P10.
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，在前面的图中，橙色和蓝色线代表永久线，永远不会被移除。红色和绿色线代表用于连接设备的配线线缆，但可以轻松移除和重新连接以进行不同的拓扑配置。机架1中的蓝色线将路由器R0、R1、R2和R3连接到配线面板P1，类似于机架2，它将路由器R10、R11、R12和R13连接到配线面板P11。橙色线代表连接配线面板P0到配线面板P10的永久线。
- en: Whenever a topology setup is required, the technician just needs patch cords
    to set up connections between the routers. The number of ports on each patch panel
    will depend on the number of available network ports on each router. As an example,
    for *Figure 9.4*, let’s suppose that each router in rack 1 has five network ports
    available. Therefore, patch panel P1 needs to have at least 20 ports to allow
    connections to all routers on rack 1.
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 每当需要拓扑配置时，技术人员只需使用配线线缆来设置路由器之间的连接。每个配线面板上的端口数量将取决于每个路由器上可用的网络端口数量。例如，对于*图9.4*，假设机架1中的每个路由器都有五个网络端口可用。因此，配线面板P1至少需要20个端口，以便连接机架1上的所有路由器。
- en: In *Figure 9.4*, there are three patch cords. The green one in rack 1 connects
    two devices inside rack 1, which could be, for instance, R0 and R1\. The other
    two red patch cords are used to interconnect devices between rack 1 and rack 2,
    which could be, for instance, between R0 and R10.
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 在*图9.4*中，有三条配线线缆。机架1中的绿色线缆连接机架1内的两个设备，例如R0和R1。其他两条红色配线线缆用于连接机架1和机架2之间的设备，例如R0和R10之间。
- en: Now, let’s see how we can link devices using software connections.
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们看看如何使用软件连接来连接设备。
- en: Using software to connect
  id: totrans-66
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用软件连接
- en: For the explanation in this subsection, we are going to assume all routers are
    software-emulated routers. A hybrid setup with software and real devices will
    be explained in the next subsection.
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 在本小节的解释中，我们将假设所有路由器都是软件模拟的路由器。软件和真实设备混合配置将在下一小节中解释。
- en: Several software techniques can be used to interconnect emulated routers, and
    they will also depend on the operating system that is used as the host. For our
    example, we are going to use Linux as the host. For Windows, FreeBSD, or macOS,
    you might need different techniques.
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 可以使用几种软件技术来互连模拟路由器，并且它们也将取决于作为主机的操作系统。在我们的例子中，我们将使用Linux作为主机。对于Windows、FreeBSD或macOS，您可能需要不同的技术。
- en: The methods to connect emulated routers will also depend on which emulation
    you are using. They may differ depending on whether you are using Dynamips, VirtualBox,
    VMware, Qemu, or Linux containers.
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 连接仿真路由器的方法也将取决于你使用的仿真类型。它们可能因你使用的是Dynamips、VirtualBox、VMware、Qemu还是Linux容器而有所不同。
- en: Let’s explore a few methods to connect emulated routers using Linux.
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们探索一些使用Linux连接仿真路由器的方法。
- en: Using TUN/TAP interfaces
  id: totrans-71
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 使用TUN/TAP接口
- en: In Linux, TUN/TAP interfaces are software interfaces that are used to receive
    and send network traffic, but they are not connected to any network. The interface
    is called TUN/TAP because the device can be either configured to work only on
    layer 3, which is called TUN mode, or on layer 2, which is called TAP interface
    mode. Both modes use the same Linux device driver (accessible via `/dev/net/tun`),
    just with a different flag. The flag to use TAP mode is `IFF_TAP`, whereas the
    flag to use TUN is `IFF_TUN`. More details on the kernel driver for TUN/TAPc can
    be found at [https://www.kernel.org/doc/html/v5.8/networking/tuntap.html](https://www.kernel.org/doc/html/v5.8/networking/tuntap.html).
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 在Linux中，TUN/TAP接口是用于接收和发送网络流量的软件接口，但它们没有连接到任何网络。该接口被称为TUN/TAP，因为设备可以被配置为仅工作在第三层，这被称为TUN模式，或者工作在第二层，这被称为TAP接口模式。两种模式都使用相同的Linux设备驱动程序（通过`/dev/net/tun`访问），只是使用了不同的标志。使用TAP模式的标志是`IFF_TAP`，而使用TUN的标志是`IFF_TUN`。有关TUN/TAP的内核驱动程序的更多详细信息，请参阅[https://www.kernel.org/doc/html/v5.8/networking/tuntap.html](https://www.kernel.org/doc/html/v5.8/networking/tuntap.html)。
- en: 'Linux provides an easy interface for creating and removing TUN/TAP interfaces;
    you can use the `ip tuntap` command for this. The following is an example of creating
    a tap interface:'
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: Linux提供了一个简单的接口来创建和删除TUN/TAP接口；你可以使用`ip tuntap`命令来完成此操作。以下是一个创建tap接口的示例：
- en: '[PRE0]'
  id: totrans-74
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: TAP interfaces are preferable to use compared to TUN interfaces, as they work
    at layer 2 and receive and send packets like real Ethernet interfaces.
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 与TUN接口相比，TAP接口更可取，因为它们工作在第二层，像真实以太网接口一样接收和发送数据包。
- en: Now, let’s see how we can use `veth` interfaces.
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们看看我们如何使用`veth`接口。
- en: Using veth interfaces
  id: totrans-77
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 使用veth接口
- en: 'The network in a Linux container is isolated and has a namespace number associated
    with it. To connect to them, you will need to use veth interfaces. veth interfaces
    can be associated with the namespace and can be created on their own or with a
    peer in a point-to-point configuration. When creating a veth with a peer, you
    will need to associate the two namespaces, one for each side of the veth peering.
    Once the peer has been set, any information that is written to one side of the
    veth peer will be sent to the other side, which is a fast and easy way to interconnect
    emulated routers when using Linux containers. We are going to use them a lot in
    our examples. Here is an example of how to create a veth peer interface:'
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: Linux容器中的网络是隔离的，并且与一个与之关联的命名空间编号。要连接到它们，你需要使用veth接口。veth接口可以与命名空间关联，可以独立创建，也可以在点对点配置中与对等接口一起创建。当创建带有对等接口的veth时，你需要将两个命名空间关联起来，每个veth对等的一侧一个。一旦设置了对等接口，任何写入veth对等一侧的信息都将发送到另一侧，这是在Linux容器中使用时快速且简单地将仿真路由器互连的方法。在我们的示例中，我们将大量使用它们。以下是如何创建veth对等接口的示例：
- en: '[PRE1]'
  id: totrans-79
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: In this example, two containers are being used, which are identified by the
    `41784` and `41634` network namespaces. A peer is created with interface names
    `A` and `B`, but the communication between the containers will only be possible
    after associating the interface name with the network namespace using `ip link
    set <ifname> netns <namespace>`, as in this example. The interface names can be
    the same but need to be renamed only after being associated with the namespace.
    This is because, before the association, the veth interfaces are in the host,
    and therefore in the same namespace, which won’t allow multiple interfaces with
    the same name to be created.
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个示例中，使用了两个容器，它们分别由`41784`和`41634`网络命名空间标识。创建了一个带有接口名称`A`和`B`的对等接口，但容器之间的通信只有在使用`ip
    link set <ifname> netns <namespace>`命令将接口名称与网络命名空间关联后才会成为可能，就像这个示例中一样。接口名称可以相同，但需要在与命名空间关联后重命名。这是因为，在关联之前，veth接口位于主机上，因此处于相同的命名空间，这不会允许创建具有相同名称的多个接口。
- en: Now, let’s learn how we can use software bridges.
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们学习如何使用软件桥接。
- en: Using software bridges
  id: totrans-82
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 使用软件桥接
- en: 'Software bridges are used to interconnect software and hardware network ports,
    which can be added and removed like a real network switch. The Linux kernel has
    a native software bridge that can be used by using the `bridge` command or by
    adding the `bridge-utils` package and using the `brctl` command. When a software
    bridge is created, it requires a name that is also attributed to a network interface
    that will or will not have an IP address. The following is an example of creating
    a bridge and associating three interfaces with it:'
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 软件桥接用于连接软件和硬件网络端口，这些端口可以像真实网络交换机一样添加和删除。Linux内核有一个本地的软件桥接，可以通过使用`bridge`命令或添加`bridge-utils`包并使用`brctl`命令来使用。当创建一个软件桥接时，它需要一个名称，这个名称也分配给一个将或不会分配IP地址的网络接口。以下是一个创建桥接并将其与三个接口关联的示例：
- en: '[PRE2]'
  id: totrans-84
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'As explained previously, the `Mybridge` bridge is also associated with a network
    interface on the Linux host. This can be seen by running the `ip link` command,
    as shown here:'
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 如前所述，`Mybridge`桥接也与Linux主机上的一个网络接口相关联。可以通过运行`ip link`命令来查看，如下所示：
- en: '[PRE3]'
  id: totrans-86
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: Linux native bridges are fast and simple, but there are advanced configurations
    that cannot be performed by them. To be able to use more advanced commands, the
    recommendation is to use **OpenvSwitch**, also known as **OvS** (there are more
    details at [https://www.openvswitch.org/](https://www.openvswitch.org/)).
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: Linux原生桥接快速简单，但有一些高级配置无法由它们执行。为了能够使用更高级的命令，建议使用**OpenvSwitch**，也称为**OvS**（更多详情请见[https://www.openvswitch.org/](https://www.openvswitch.org/))。
- en: Using VXLAN
  id: totrans-88
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 使用VXLAN
- en: Linux bridges, TAP, and veth interfaces are used locally inside the Linux host
    to create a connection between emulated routers, but it won’t work to interconnect
    emulated routers that are running in a different host. There are a few techniques
    that could be used to connect emulated routers across hosts, such as pseudowires,
    L2TP, and layer 2 VPNs, among others, but the best would be VXLAN.
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: Linux桥接、TAP和veth接口在Linux主机内部本地使用，用于在仿真路由器之间建立连接，但将运行在不同主机上的仿真路由器相互连接是不行的。有一些技术可以用来在主机之间连接仿真路由器，例如伪线、L2TP和第二层VPN等，但最好的选择是VXLAN。
- en: VXLAN works as a layer 2 tunnel that extends the local bridge to another remote
    device, which can be another Linux host, a network switch, or a router. With VXLAN,
    it is also possible to connect emulated routers to real routers as if they are
    connected by a wire on a back-to-back connection. As we are going to see later
    in this section, VXLAN is going to be used for hybrid labs where a connection
    between real routers and emulated routers is used.
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 'VXLAN作为一个第二层隧道，将本地桥接扩展到另一个远程设备，这可以是另一个Linux主机、网络交换机或路由器。使用VXLAN，还可以将仿真路由器连接到真实路由器，就像它们通过背对背连接的线缆连接一样。正如我们将在本节后面看到的那样，VXLAN将被用于混合实验室，其中使用真实路由器和仿真路由器之间的连接。 '
- en: VLAN is a well-known protocol and was explained in [*Chapter 2*](B18165_02.xhtml#_idTextAnchor041),
    Original VLANs have 12 bits of identification, which allows for up to 4,096 VLAN
    IDs. But VLAN tagging (IEEE 802.1Q) adds an extra 12 bits, so that’s up to 24
    bits for identifying a VLAN on a normal Ethernet layer 2 frame using VLAN tagging.
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: VLAN是一个众所周知的协议，在[*第2章*](B18165_02.xhtml#_idTextAnchor041)中进行了解释。原始VLAN有12位标识符，允许最多有4,096个VLAN
    ID。但VLAN标记（IEEE 802.1Q）增加了额外的12位，因此在正常以太网第二层帧中使用VLAN标记时，VLAN的标识符可达24位。
- en: 'VXLAN is independent of VLAN or VLAN tagging, using a header identifier with
    24 bits and UDP as transport with port number `4789`. An original Ethernet frame
    that uses a VXLAN tunnel will need an extra 54 bytes of overhead for the tunnel.
    So, if your network MTU is 1,500 bytes, the maximum MTU of payload that can be
    carried inside the tunnel will be reduced by 54 bytes. It is recommended to increase
    MTU when using VXLAN. The following diagram shows an example of protocol encapsulation
    for VXLAN:'
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: VXLAN独立于VLAN或VLAN标记，使用24位的头部标识符，并使用UDP作为传输协议，端口号为`4789`。使用VXLAN隧道的一个原始以太网帧将需要额外的54字节开销。因此，如果您的网络MTU为1,500字节，隧道内可以携带的最大有效载荷MTU将减少54字节。建议在使用VXLAN时增加MTU。以下图示显示了VXLAN的协议封装示例：
- en: '![Figure 9.5 – VXLAN encapsulation](img/B18165_09_005.jpg)'
  id: totrans-93
  prefs: []
  type: TYPE_IMG
  zh: '![图9.5 – VXLAN封装](img/B18165_09_005.jpg)'
- en: Figure 9.5 – VXLAN encapsulation
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 图9.5 – VXLAN封装
- en: A VXLAN connects endpoints, known as **Virtual Tunnel Endpoints** (**VTEPs**).
    A device that works with VXLAN when receiving an Ethernet frame on a VTEP will
    then add the VXLAN header, UDP, and IP and will send it toward the other VTEP
    destination.
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: VXLAN连接端点，称为**虚拟隧道端点**（**VTEPs**）。当在VTEP上接收到以太网帧时，与VXLAN一起工作的设备将添加VXLAN头部、UDP和IP，并将其发送到另一个VTEP目标。
- en: Now, let’s see how we would set up a hybrid lab using software connections and
    physical wires.
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们看看我们如何使用软件连接和物理线缆设置混合实验室。
- en: Building a hybrid lab
  id: totrans-97
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 构建混合实验室
- en: A hybrid lab is necessary whenever you want to combine emulated routers with
    physical routers. The main reason you will need such a configuration is when testing
    the performance of a real router and adding complexity such as an extra 500 routers
    in the OSPF backbone. It is also useful to test connections with different complex
    topologies, such as an external BGP with flapping routes. All extra anomalies
    can be automated and added using the emulated environment, helping the test gain
    agility and accuracy.
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 每当你想要将模拟路由器与物理路由器结合使用时，混合实验室是必要的。你需要这种配置的主要原因是当测试真实路由器的性能并添加复杂性，例如在OSPF骨干中额外添加500个路由器时。测试与不同复杂拓扑结构的连接，例如具有波动路由的外部BGP，也非常有用。所有额外的异常都可以通过模拟环境自动化和添加，从而帮助测试获得敏捷性和准确性。
- en: With a hybrid lab, you could have a few real routers connected to an unlimited
    number of emulated routers, perhaps building an entire network emulation that
    can be connected to real routers for closer production environment testing. Again,
    anomalies can be easily introduced automatically in the emulation, with precision,
    including packet loss, latency, and jitter. Therefore, your network automation
    skills are going to be the key to the success of a hybrid lab.
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 使用混合实验室，你可以将少量真实路由器连接到无限数量的模拟路由器，也许可以构建一个可以连接到真实路由器进行更接近生产环境测试的整个网络仿真。再次强调，异常可以自动引入仿真中，包括数据包丢失、延迟和抖动。因此，你的网络自动化技能将成为混合实验室成功的关键。
- en: 'The following diagram shows an example of a hybrid lab connecting four emulated
    routers to two real routers:'
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 以下图表显示了混合实验室连接四个模拟路由器到两个真实路由器的示例：
- en: '![Figure 9.6 – Connectivity example for a hybrid lab](img/B18165_09_006.jpg)'
  id: totrans-101
  prefs: []
  type: TYPE_IMG
  zh: '![图9.6 – 混合实验室的连接示例](img/B18165_09_006.jpg)'
- en: Figure 9.6 – Connectivity example for a hybrid lab
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 图9.6 – 混合实验室的连接示例
- en: Note that in the preceding figure, the purple lines represent the physical cables
    that connect Linux host 1, Linux host 2, router A, and router B to network switch
    1\. VXLAN is used between these devices to allow the setup of any connection between
    these devices. Linux host 2 uses only container-emulated routers, and therefore
    veth interfaces. Linux host 1 uses a tap interface to connect emulated router
    2, which could be, for instance, Dynamips with a Cisco-emulated router.
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，在前面的图中，紫色线条代表连接Linux主机1、Linux主机2、路由器A和路由器B到网络交换机1的物理电缆。VXLAN用于这些设备之间，以允许在这些设备之间设置任何连接。Linux主机2仅使用容器模拟路由器，因此使用veth接口。Linux主机1使用tap接口连接模拟路由器2，例如Dynamips与Cisco模拟路由器。
- en: 'The following diagram shows a more complex hybrid setup:'
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 以下图表显示了更复杂的混合设置：
- en: '![Figure 9.7 – A more complex hybrid lab setup](img/B18165_09_007.jpg)'
  id: totrans-105
  prefs: []
  type: TYPE_IMG
  zh: '![图9.7 – 更复杂的混合实验室设置](img/B18165_09_007.jpg)'
- en: Figure 9.7 – A more complex hybrid lab setup
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 图9.7 – 更复杂的混合实验室设置
- en: As you can see in the preceding figure, there are 3,000 emulated routers and
    6 physical routers connected via VXLAN switches and software VXLAN bridges. The
    setup looks clean and straightforward, but it can create very complex connections
    and topologies. The VXLAN switches work as patch panels that can be configured
    by software. It is also necessary to have a real router with all interfaces connected
    to a VXLAN switch so that it can work as a patch panel for that router, such as
    router A connected to VXLAN switch 2.
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 如前图所示，有3,000个模拟路由器和6个物理路由器通过VXLAN交换机和软件VXLAN桥连接。设置看起来干净利落，但它可以创建非常复杂的连接和拓扑。VXLAN交换机充当可由软件配置的跳线面板。还需要一个真实路由器，其所有接口都连接到VXLAN交换机，以便它可以作为该路由器的跳线面板，例如路由器A连接到VXLAN交换机2。
- en: Now, let’s discuss how we can add an OOB network.
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们讨论我们如何添加一个OOB网络。
- en: Adding an OOB network to your lab
  id: totrans-109
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 在你的实验室中添加一个OOB网络
- en: One important problem we need to pay attention to is how we access devices without
    needing to have any network connection. And the answer to this problem is to use
    an OOB network, or out-of-band management network, as we discussed in [*Chapter
    1*](B18165_01.xhtml#_idTextAnchor015).
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 我们需要关注的一个重要问题是，我们如何在不需要任何网络连接的情况下访问设备。这个问题的答案是使用OOB网络，即带外管理网络，正如我们在[*第一章*](B18165_01.xhtml#_idTextAnchor015)中讨论的那样。
- en: Adding some sort of access to devices that do not require any network connection
    helps when performing catastrophic tests, such as when routers must be removed
    or turned off. There are several ways to access an emulated router, which is done
    by accessing the host where the emulation is running. For real routers, the way
    to access them is via a console or auxiliary ports, which is normally performed
    using serial communication. Therefore, to allow automation for all devices, you
    will require a serial port server device that will allow remote access via IP
    and SSH. Once connected to the serial port server via SSH, you will be able to
    access the router via a serial port from the port server. One example of this
    port server is the product Avocent ACS8000, which has 32 serial ports and can
    be accessed via IP using an Ethernet port or a 4G mobile network ([https://www.amazon.com/Avocent-ACS8000-Management-Cellular-ACS8032-NA-DAC-400/dp/B099XFB39R](https://www.amazon.com/Avocent-ACS8000-Management-Cellular-ACS8032-NA-DAC-400/dp/B099XFB39R)).
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 为那些不需要任何网络连接的设备添加某种形式的访问，有助于进行灾难性测试，例如当路由器必须被移除或关闭时。有几种方法可以访问模拟路由器，这通过访问运行模拟的主机来完成。对于真实路由器，访问它们的方式是通过控制台或辅助端口，这通常是通过串行通信来完成的。因此，为了允许所有设备的自动化，您将需要一个串行端口服务器设备，它将允许通过IP和SSH进行远程访问。一旦通过SSH连接到串行端口服务器，您将能够通过端口服务器通过串行端口访问路由器。这个端口服务器的一个例子是Avocent
    ACS8000产品，它有32个串行端口，可以通过以太网端口或4G移动网络通过IP访问([https://www.amazon.com/Avocent-ACS8000-Management-Cellular-ACS8032-NA-DAC-400/dp/B099XFB39R](https://www.amazon.com/Avocent-ACS8000-Management-Cellular-ACS8032-NA-DAC-400/dp/B099XFB39R))。
- en: Now, let’s use some advanced techniques to enhance our network code testing.
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们使用一些高级技术来增强我们的网络代码测试。
- en: Using advanced testing techniques
  id: totrans-113
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用高级测试技术
- en: I created this section to explore some methods that can be used for testing
    that are not commonly used but might be somehow useful. These techniques are perhaps
    not used much today but might become mainstream in the future, so keep an eye
    on how things evolve.
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 我创建了这个部分来探讨一些可以用于测试但不太常见但可能以某种方式有用的方法。这些技术可能现在不太常用，但未来可能会成为主流，所以请密切关注事情的发展。
- en: First, let’s see how we can use time dilation in our network code testing.
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，让我们看看我们如何在网络代码测试中使用时间膨胀。
- en: Using time dilation
  id: totrans-116
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用时间膨胀
- en: When building your test environment, you might face requirements for testing
    that are physically impossible to do in a lab with emulated routers, such as measuring
    protocol convergence time or sending large amounts of data between devices. The
    reason these high-performance tests are physically impossible using emulation
    is that the CPU and I/O on an emulated router are smaller and limited compared
    to real routers. One way to overcome this limitation is to use **time dilation**.
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 在构建您的测试环境时，您可能会遇到在实验室中使用模拟路由器物理上无法完成的测试要求，例如测量协议收敛时间或在不同设备之间发送大量数据。这些高性能测试在模拟中物理上不可能实现的原因是，模拟路由器上的CPU和I/O比真实路由器小且有限。克服这种限制的一种方法就是使用**时间膨胀**。
- en: Time dilation is a technique that changes the CPU clock of the emulated environment
    in such a way that the emulated router will run slower compared to an emulation
    without time dilation. From the host’s perspective, the emulated router with time
    dilation will use fewer resources, as it is not running as fast as the emulated
    router without time dilation. But from the emulated router’s perspective, which
    uses time dilation, everything seems to run at normal speed, but in reality, is
    much slower.
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 时间膨胀是一种技术，它以这种方式改变模拟环境中的CPU时钟，使得模拟路由器相对于没有时间膨胀的模拟运行得更慢。从主机的角度来看，具有时间膨胀的模拟路由器将使用更少的资源，因为它运行的速度不如没有时间膨胀的模拟路由器快。但从使用时间膨胀的模拟路由器的角度来看，一切似乎都以正常速度运行，但实际上要慢得多。
- en: Imagine you want to test the time it takes for an application to copy files
    between two ends using network emulation. In a real network, these devices will
    have 10 GE interfaces that can have up to 10 Gbps. But in an emulation environment,
    they might have only 100 Mbps available or even less. To overcome these limitations,
    one technique is to put all emulations, including the application, in a time dilation
    environment that has a **time dilation factor** (or **TDF**) of 1,000 or more.
    With a TDF of 1,000, the CPU and I/O, including network interfaces, will be capable
    of performing more work from the emulated network and application perspective.
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 假设你想测试使用网络仿真来复制文件所需的时间。在真实网络中，这些设备将具有 10 GE 接口，可以达到 10 Gbps。但在仿真环境中，它们可能只有 100
    Mbps 可用，甚至更少。为了克服这些限制，一种技术是将所有仿真，包括应用程序，放入一个时间膨胀环境，该环境具有 1,000 或更高的**时间膨胀因子**（或**TDF**）。具有
    1,000 的 TDF，CPU 和 I/O，包括网络接口，将能够从仿真的网络和应用程序的角度执行更多的工作。
- en: For network testing, normally, TDF is greater than 1, but it is also possible
    to use one smaller than 1, meaning that the emulation will run faster than the
    host. The applications that use lower than 1 TDF are normally used when tests
    need to go faster and CPU constraints do not exist. For example, a TDF of 0.1
    will run 10 times faster, but the implementation is normally not trivial and sometimes
    not possible because it relies on shortening the waiting time.
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 对于网络测试，通常 TDF 大于 1，但也可以使用小于 1 的 TDF，这意味着仿真将比主机运行得更快。使用小于 1 TDF 的应用程序通常用于测试需要更快进行且不存在
    CPU 限制的情况。例如，TDF 为 0.1 将运行 10 倍更快，但实现通常不是微不足道的，有时甚至不可能，因为它依赖于缩短等待时间。
- en: 'The University of San Diego has done some work on time dilation based on a
    paper called *To Infinity and Beyond: Time-Warped Network Emulation*, which does
    have some implementation code for Xen and Linux kernel. Details can be found at
    [https://www.sysnet.ucsd.edu/projects/time-dilation](https://www.sysnet.ucsd.edu/projects/time-dilation).
    Other implementations for time dilation focus on virtual machines and use Qemu
    to manipulate time; one implementation is from the University of North Carolina,
    where they created a project called *Adaptive Time Dilation*. Details can be found
    at [https://research.ece.ncsu.edu/wireless/MadeInWALAN/AdaptiveTimeDilation](https://research.ece.ncsu.edu/wireless/MadeInWALAN/AdaptiveTimeDilation).'
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 圣地亚哥大学基于一篇名为《无限与超越：时间扭曲网络仿真》的论文进行了一些关于时间膨胀的研究，这篇论文确实为 Xen 和 Linux 内核提供了一些实现代码。详细信息可以在[https://www.sysnet.ucsd.edu/projects/time-dilation](https://www.sysnet.ucsd.edu/projects/time-dilation)找到。其他时间膨胀的实现专注于虚拟机，并使用
    Qemu 来操作时间；一个实现来自北卡罗来纳大学，他们创建了一个名为 *自适应时间膨胀* 的项目。详细信息可以在[https://research.ece.ncsu.edu/wireless/MadeInWALAN/AdaptiveTimeDilation](https://research.ece.ncsu.edu/wireless/MadeInWALAN/AdaptiveTimeDilation)找到。
- en: One advantage of using time dilation is that TDF can be adjusted every time
    you perform a test in your environment. A low TDF will impose more CPU and I/O
    limitations and might be useful to test how the application and network would
    perform in low-performance conditions, giving a lower-bound test result. A high
    TDF would give enough CPU and I/O resources to test the application and network
    in an ideal world without resource limitations, giving an upper-bound test result.
    Adjusting TDF to a certain mid value would give you the resources compatible with
    a real network with a real application, giving a test result that’s closer to
    reality.
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 使用时间膨胀的一个优点是，每次你在环境中进行测试时，TDF 都可以进行调整。低 TDF 将会施加更多的 CPU 和 I/O 限制，这可能有助于测试应用程序和网络在低性能条件下的表现，从而得到一个下限测试结果。高
    TDF 将提供足够的 CPU 和 I/O 资源，以便在没有资源限制的理想世界中测试应用程序和网络，从而得到一个上限测试结果。将 TDF 调整到某个中间值将为你提供与真实网络和真实应用程序兼容的资源，从而得到一个更接近现实的测试结果。
- en: Now, let’s see how we can use monkey testing on network code testing.
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们看看我们如何可以在网络代码测试中使用猴子测试。
- en: Using monkey testing
  id: totrans-124
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用猴子测试
- en: In software development, monkey testing is used when an application requires
    testing and there is no formal definition of what to test. Monkey testing generates
    random inputs and evaluates the outputs.
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 在软件开发中，当应用程序需要测试但没有正式的定义要测试什么时，会使用猴子测试。猴子测试生成随机输入并评估输出。
- en: The idea of monkey testing is to find problems with the code that were not expected
    by the software developer. In our case, we can use monkey testing to evaluate
    the network automation tools and the network itself. In some sense, penetration
    testing would be considered part of monkey testing, but more related to finding
    security holes, not failures.
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 猴子测试的思路是找出软件开发者没有预料到的代码问题。在我们的情况下，我们可以使用猴子测试来评估网络自动化工具和网络本身。在某种程度上，渗透测试会被认为是猴子测试的一部分，但更多地与发现安全漏洞有关，而不是失败。
- en: One great example of monkey testing is the Netflix implementation called **Chaos
    Monkey** (there are more details at [https://github.com/Netflix/chaosmonkey](https://github.com/Netflix/chaosmonkey)).
    Chaos Monkey is written in Go and used for randomly terminating containers and
    virtual machines. With a few modifications, it can be used to shut down interfaces
    and network links. It is based on chaos engineering (there are more details at
    [http://principlesofchaos.org/](http://principlesofchaos.org/)). Chaos Monkey
    is a good example of monkey testing that can be added to our network automation
    testing infrastructure.
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 一个很好的猴子测试例子是Netflix的**Chaos Monkey**实现（更多详情请访问[https://github.com/Netflix/chaosmonkey](https://github.com/Netflix/chaosmonkey)）。Chaos
    Monkey是用Go编写的，用于随机终止容器和虚拟机。经过一些修改，它可以用来关闭接口和网络链接。它基于混沌工程（更多详情请访问[http://principlesofchaos.org/](http://principlesofchaos.org/)）。Chaos
    Monkey是猴子测试的一个好例子，可以添加到我们的网络自动化测试基础设施中。
- en: Now, let’s explore how we could use **artificial intelligence** (**AI**) for
    network code testing.
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们探讨如何使用**人工智能**（**AI**）进行网络代码测试。
- en: Using artificial intelligence
  id: totrans-129
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用人工智能
- en: 'Products that use AI for software development are in their early stages, but
    they will become reality soon. Today, it is possible to generate code via AI platforms
    such as **ChatGPT** (there’s more at [https://chat.openai.com/auth/login](https://chat.openai.com/auth/login)).
    Normally, the code generated by the AI is simple and not necessarily optimized,
    but it is an important milestone toward having to AI write code. The following
    is an example of the output of using ChatGPT to write unit tests:'
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 使用AI进行软件开发的产品还处于早期阶段，但它们很快将成为现实。今天，通过AI平台如**ChatGPT**（更多信息请访问[https://chat.openai.com/auth/login](https://chat.openai.com/auth/login)）可以生成代码。通常，AI生成的代码简单且不一定优化，但它是在AI编写代码的必要里程碑。以下是用ChatGPT编写单元测试的输出示例：
- en: '[PRE4]'
  id: totrans-131
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: Note that the question was very simple and did not specify the language or packages,
    such as Python or to use the `unittest` and `mock` packages. The AI figured out
    the language and the packages to import by itself. However, it introduced a small
    outdated import. Since Python 3.3, `mock` has to be imported as `from unittest
    import mock`, instead of `import mock`.
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，这个问题非常简单，并没有指定语言或包，例如Python或使用`unittest`和`mock`包。AI自己推断出了语言和要导入的包。然而，它引入了一个小的过时导入。自从Python
    3.3以来，`mock`必须导入为`from unittest import mock`，而不是`import mock`。
- en: Although the unit test written previously was not complete and contained a small
    error, it is a huge step toward having computers automate tests during development.
    It can be used today to help developers improve their code.
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管之前编写的单元测试并不完整且包含一个小错误，但它是在开发过程中让计算机自动化测试迈出的巨大一步。它今天就可以用来帮助开发者改进他们的代码。
- en: Some commercial products are already offering AI solutions for software development.
    For instance, GitHub has a product called **Copilot** that offers pair programming
    with AI (there are more details at [github.com/features/copilot](http://github.com/features/copilot)).
    Copilot claims that it can write unit tests for you, which is an amazing achievement.
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 一些商业产品已经提供AI软件开发的解决方案。例如，GitHub有一个名为**Copilot**的产品，提供与AI的配对编程（更多详情请访问[github.com/features/copilot](http://github.com/features/copilot)）。Copilot声称它可以为你编写单元测试，这是一个惊人的成就。
- en: More and more companies will start offering solutions for code development,
    and for sure writing unit tests will be the first milestone to be accomplished
    by AI platforms. Unit tests consume a lot of the developer’s time, in most cases
    taking even more time to write than the code itself. Keep an eye on the market
    for network automation test tools that use AI – it will make development more
    robust and faster.
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 越来越多的公司将开始提供代码开发的解决方案，并且可以肯定的是，编写单元测试将是AI平台要实现的第一里程碑。单元测试消耗了开发者大量的时间，在大多数情况下，编写单元测试的时间甚至比编写代码本身还要多。关注市场上使用AI的网络自动化测试工具——这将使开发更加稳健和快速。
- en: Now, let’s see how we can add network simulation to enhance network code testing.
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们看看如何添加网络模拟以增强网络代码测试。
- en: Using network simulation
  id: totrans-137
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用网络模拟
- en: Network simulation, in contrast to network emulation, uses software to simulate
    part of the behavior of the network. Most network simulators are used either to
    simulate network protocol behaviors or to predict and calculate traffic demands
    and network paths. It can also be used to calculate resources, such as memory
    and network capacity on devices, but not much more beyond that.
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 网络模拟与网络仿真的不同之处在于，它使用软件来模拟网络部分行为。大多数网络模拟器要么用于模拟网络协议行为，要么用于预测和计算流量需求和网络路径。它还可以用于计算资源，例如设备上的内存和网络容量，但除此之外并不多。
- en: One of the very popular Python packages that is used for network simulation
    is **NetworkX** (there are more details at [https://networkx.org/](https://networkx.org/)),
    which is a graph manipulation library. With NetworkX, it is possible to create
    a large network with thousands of nodes and millions of links using much fewer
    resources than when using network emulation. Simulating a large network using
    NetworkX is possible if you wish to run several tests that will be performed much
    faster than using emulation. However, the tests will evaluate the behavior of
    the network due to link and node failures, not the control plane (routing protocols)
    or the operating system of the routers.
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 在网络模拟中，Python中非常流行的Python包之一是**NetworkX**（更多详情请见[https://networkx.org/](https://networkx.org/)），这是一个图操作库。使用NetworkX，可以创建一个包含数千个节点和数百万个链接的大型网络，所需资源比使用网络仿真少得多。如果您希望运行多个测试，这些测试将比使用仿真运行得更快，那么使用NetworkX模拟大型网络是可能的。然而，这些测试将评估网络由于链路和节点故障的行为，而不是控制平面（路由协议）或路由器的操作系统。
- en: Another useful application of network simulation is to test a network access
    list table path for a particular IP prefix. Once the network simulation has been
    built, it is possible to determine where a certain IP packet would flow in terms
    of normal and failure conditions. The simulation must be built using the network
    router configuration tables, and perhaps can be updated regularly to match production.
    Note that this kind of test will demand the creation of a network graph for each
    IP prefix to be tested, and the access list for each interface will dictate the
    inclusion (or not) of the link in the IP prefix graph.
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 网络模拟的另一个有用应用是测试特定IP前缀的网络访问列表路径。一旦网络模拟构建完成，就可以确定某个IP数据包在正常和故障条件下的流向。模拟必须使用网络路由器配置表来构建，并且可能需要定期更新以匹配生产环境。请注意，此类测试将需要为每个要测试的IP前缀创建一个网络图，并且每个接口的访问列表将决定链路是否包含在IP前缀图中。
- en: 'The following figure shows the topology that we are going to build using NetworkX
    as an example:'
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 以下图示展示了我们将使用NetworkX构建的拓扑结构，作为示例：
- en: '![Figure 9.8 – Topology to be used with NetworkX](img/B18165_09_008.jpg)'
  id: totrans-142
  prefs: []
  type: TYPE_IMG
  zh: '![图9.8 – 使用NetworkX的拓扑](img/B18165_09_008.jpg)'
- en: Figure 9.8 – Topology to be used with NetworkX
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 图9.8 – 使用NetworkX的拓扑
- en: 'This topology is also described in the `Chapter09/NetworkX/topology.yaml` file,
    which is included in the GitHub repo of this book. The following code reads this
    file and creates a NetworkX graph with this topology:'
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 此拓扑也在本书GitHub仓库中的`Chapter09/NetworkX/topology.yaml`文件中描述，以下代码读取此文件并使用此拓扑创建一个NetworkX图：
- en: '[PRE5]'
  id: totrans-145
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'After loading the topology, a series of tests can be done to evaluate the behavior
    of the network. For instance, we could remove the link between `cpe-a` and `acc-a`
    and see whether there is connectivity between `pc-a` and `internet`. As the process
    of adding and removing edges is more interactive, the best platform to use NetworkX
    for testing would be a Jupyter notebook (as described in *Chapter 6*). The following
    screenshot shows the output of the Jupyter notebook, showing the test of removing
    a link and testing connectivity between `pc-a` and `internet`:'
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 在加载拓扑后，可以进行一系列测试以评估网络的行为。例如，我们可以移除`cpe-a`和`acc-a`之间的链路，并查看`pc-a`和`internet`之间是否存在连接性。由于添加和删除边的操作更加交互式，使用NetworkX进行测试的最佳平台将是Jupyter笔记本（如第6章所述）。以下截图显示了Jupyter笔记本的输出，显示了移除链路并测试`pc-a`和`internet`之间连接性的测试结果：
- en: '![Figure 9.9 – Jupyter notebook output example](img/B18165_09_009.jpg)'
  id: totrans-147
  prefs: []
  type: TYPE_IMG
  zh: '![图9.9 – Jupyter笔记本输出示例](img/B18165_09_009.jpg)'
- en: Figure 9.9 – Jupyter notebook output example
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 图9.9 – Jupyter笔记本输出示例
- en: As you can see, if you remove the link between `cpe-a` and `acc-a` (`edge 1,2`),
    `pc-a` loses connectivity to `internet`. The `node_connectivity()` method returns
    an `integer` that, if greater than zero, indicates there is connectivity between
    nodes (more details on this method and other connectivity algorithms can be found
    at [https://networkx.org/documentation/stable/reference/algorithms/connectivity.html](https://networkx.org/documentation/stable/reference/algorithms/connectivity.html)).
    A series of additional tests can be found in the `Chapter09/NetworkX/example.ipynb`
    file.
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 如您所见，如果您移除 `cpe-a` 和 `acc-a`（边缘1，2）之间的链接，`pc-a` 将失去与 `internet` 的连接。`node_connectivity()`
    方法返回一个 `整数`，如果大于零，表示节点之间存在连接性（有关此方法和其他连接性算法的更多详细信息，请参阅[https://networkx.org/documentation/stable/reference/algorithms/connectivity.html](https://networkx.org/documentation/stable/reference/algorithms/connectivity.html)）。一系列附加测试可以在
    `Chapter09/NetworkX/example.ipynb` 文件中找到。
- en: A combination of network simulation and network emulation can be used to increase
    the capacity and speed of your code testing. A mechanism must be included to build
    the emulation and create the simulation using the same configuration. In addition,
    some tests can be performed first on simulation and, if required, repeated in
    the emulation to be validated.
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 网络模拟和网络仿真的组合可以用来提高代码测试的容量和速度。必须包含一个机制来构建仿真和创建使用相同配置的模拟。此外，一些测试可以先在模拟中进行，如果需要，可以在仿真中重复以进行验证。
- en: Using traffic control
  id: totrans-151
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用流量控制
- en: Using traffic shaping (or traffic control), it is possible to add complexity
    to our emulation by adding some physical characteristics that are present in real
    links and multi-to-multi-point networks. With traffic shaping, we can add latency
    to specific connections, introduce packet loss, add random limitations, add network
    congestion, add jitter, and much more. On Linux, it can be easily obtained by
    using the built-in `tc` command.
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 通过使用流量整形（或流量控制），我们可以通过添加一些真实链路和多对多点网络中存在的物理特性来增加我们的仿真的复杂性。使用流量整形，我们可以向特定连接添加延迟，引入丢包，添加随机限制，添加网络拥塞，添加抖动等。在Linux上，可以通过使用内置的
    `tc` 命令轻松实现。
- en: TC is implemented in Linux by using schedulers or `tc` and qdiscs can be found
    at [https://tldp.org/HOWTO/Traffic-Control-HOWTO](https://tldp.org/HOWTO/Traffic-Control-HOWTO)).
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: TC 通过在Linux中使用调度器或 `tc` 实现，qdiscs 可以在[https://tldp.org/HOWTO/Traffic-Control-HOWTO](https://tldp.org/HOWTO/Traffic-Control-HOWTO)找到。
- en: 'The following is an example of using a `qdisc` called `netem` to add 10 ms
    of latency to the loopback interface:'
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是一个使用名为 `netem` 的 `qdisc` 添加10毫秒延迟到环回接口的示例：
- en: '[PRE6]'
  id: totrans-155
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: This example adds 10 ms to reach the `lo` interface in each way, so the round-trip
    time is double, which appears in the results as a 21.4 ms average.
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 此示例在每个方向上添加了10毫秒以达到 `lo` 接口，因此往返时间是双倍，这在结果中表现为21.4毫秒的平均值。
- en: 'Here is another example, showing how to add 5% packet loss using `netem`:'
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 这里是另一个示例，展示了如何使用 `netem` 添加5%的丢包率：
- en: '[PRE7]'
  id: totrans-158
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: In this test example, the result was 4% of packet loss instead of 5% as configured.
    This is because `netem` uses random selection to obtain packet loss, and it will
    require a larger testing sample to get closer to 5% – for example, 1,000 packets
    instead of 100, which was used in the preceding test.
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个测试示例中，结果是4%的丢包率，而不是配置的5%。这是因为 `netem` 使用随机选择来获取丢包率，需要更大的测试样本才能接近5% - 例如，1000个数据包而不是前一个测试中使用的100个。
- en: Other more complex network behaviors can be added to the interface using `netem`,
    such as burst control, maximum capacity, network congestion, and random latency
    variance, among others. More details on it can be found at [https://wiki.linuxfoundation.org/networking/netem](https://wiki.linuxfoundation.org/networking/netem).
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 使用 `netem` 可以在接口中添加更复杂的网络行为，例如突发控制、最大容量、网络拥塞和随机延迟变化等。更多详细信息可以在[https://wiki.linuxfoundation.org/networking/netem](https://wiki.linuxfoundation.org/networking/netem)找到。
- en: There are lots of other schedulers besides `netem`, such as `choke`, `codel`,
    `hhf`, and `ATM`. A list of all classless and classful qdiscs available can be
    obtained on the `tc` man page, which can be visualized by just typing `man tc`
    (the HTML version can be found at [https://manpages.debian.org/buster/iproute2/tc.8.en.html](https://manpages.debian.org/buster/iproute2/tc.8.en.html)).
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 除了 `netem` 之外，还有很多其他的调度器，如 `choke`、`codel`、`hhf` 和 `ATM`。所有无类和有类 qdiscs 的列表可以在
    `tc` 手册页上找到，只需输入 `man tc` 即可查看（HTML版本可以在[https://manpages.debian.org/buster/iproute2/tc.8.en.html](https://manpages.debian.org/buster/iproute2/tc.8.en.html)找到）。
- en: Hopefully, you have got the most out of this section and have started wondering
    whether some of these advanced techniques could be added to your project. Adding
    one of these techniques will likely make your project more reliable and closer
    to a real production environment.
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 希望您已经充分利用了这一部分，并开始思考是否可以将这些高级技术添加到您的项目中。添加其中之一可能会使您的项目更加可靠，并更接近真实的生产环境。
- en: Summary
  id: totrans-163
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: The goal of this chapter was to introduce you to how to build and use a proper
    infrastructure to test your automation code using software. You learned how software
    can be used to effectively test your automation code, how to use simulation and
    emulation, how to connect real and emulated devices, and finally, how advanced
    techniques can be incorporated.
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 本章的目标是向您介绍如何使用软件构建和使用适当的基础设施来测试您的自动化代码。您学习了如何有效地使用软件来测试您的自动化代码，如何使用模拟和仿真，如何连接真实和仿真设备，以及最后，如何融入高级技术。
- en: Adding some of the techniques described in this chapter will add superpowers
    to your network automation code project. From now on, it will be unbeatable.
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 在您的网络自动化代码项目中添加本章描述的一些技术将赋予您的项目超能力。从现在开始，它将无与伦比。
- en: In the next chapter, we are going to get hands-on in a network lab and wrap
    up this book with a few additional remarks.
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章中，我们将亲自动手在网络实验室中进行操作，并以一些额外的评论结束这本书。
