- en: '9'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Network Code Testing Framework
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: One important aspect when developing code is to add testing; we discussed and
    reviewed some code test strategies in [*Chapter 5*](B18165_05.xhtml#_idTextAnchor127),
    *Do’s and Don’ts for Network Programming*. But we have not investigated techniques
    that are unique to network automation, such as building a network testing environment
    where we can do some real testing with our network automation code.
  prefs: []
  type: TYPE_NORMAL
- en: This chapter will focus on techniques for building a network testing framework
    that can be used for testing your network automation code. We are also going to
    look into advanced techniques that can be added to make your testing framework
    even more useful and reliable.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here are the topics we are going to cover in this chapter:'
  prefs: []
  type: TYPE_NORMAL
- en: Using software for testing
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Using device emulation
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Connecting devices for testing
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Using advanced testing techniques
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: By the end of this chapter, you should have enough information to build and
    use a testing framework that will add significant value to your network automation
    project.
  prefs: []
  type: TYPE_NORMAL
- en: Technical requirements
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The source code described in this chapter is stored in this book’s GitHub repository
    at [https://github.com/PacktPublishing/Network-Programming-and-Automation-Essentials/tree/main/Chapter09](https://github.com/PacktPublishing/Network-Programming-and-Automation-Essentials/tree/main/Chapter09).
  prefs: []
  type: TYPE_NORMAL
- en: Using software for testing
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Some companies, when buying network devices, buy additional devices to be used
    for testing purposes. These extra devices are normally installed in a separate
    environment to replicate part of the production network for testing. Before one
    test is performed, the devices are connected and configured to replicate a particular
    part of the network. Once the tests are finished, the setup is then removed and
    another configuration with different connections may take place to perform tests
    for another part of the network. There are several reasons why these tests are
    necessary, such as testing new software, validating a new configuration, verifying
    an update, checking performance, qualifying a new network design, and testing
    new functionality, among others.
  prefs: []
  type: TYPE_NORMAL
- en: But the main problem is that the testing environment is costly, slow to set
    up, and cannot be used by multiple test engineers in parallel. It also demands
    the physical presence of a specialized technician who will eventually have to
    sort new cable connections, perform hardware updates, add or remove network cards,
    and sometimes update the operating systems of the devices.
  prefs: []
  type: TYPE_NORMAL
- en: The physical testing environment is ultimately inevitable, but a few tests can
    be performed by using software instead of physical hardware. The tests that can
    be performed by software will depend on the requirement of the test. Tests that
    evaluate software configuration, verify design concepts, validate routing behavior,
    and validate new features and perhaps router stability might be performed by software.
  prefs: []
  type: TYPE_NORMAL
- en: In addition, software can be used to make connections between network devices,
    which also speeds up the setup process. But one area won’t be able to be tested,
    which is network stress and performance, such as measuring maximum throughput
    or capacity.
  prefs: []
  type: TYPE_NORMAL
- en: There are several techniques we can use to use software for network testing,
    and most of them will be done using simulation and emulation. But what are the
    differences between emulation and simulation? Let’s discuss this now.
  prefs: []
  type: TYPE_NORMAL
- en: Differences between emulation and simulation
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Emulation and simulation have their meanings commonly mixed it up. Although
    mistaking them is not that important, it is good to understand their meaning so
    that you can understand their limitations and capabilities when using them.
  prefs: []
  type: TYPE_NORMAL
- en: In the case of emulation, it is when you use software to mimic the physical
    aspects of the entity you want to test. So, in our network automation, it would
    be a router, a switch, or a network connection (link).
  prefs: []
  type: TYPE_NORMAL
- en: Therefore, using a router emulation implies that all necessary hardware, such
    as network ports, console ports, CPU, and memory, must be mocked by software so
    that the operating system of the router can run seamlessly as if it were running
    in real hardware. One example of a router emulator is **Dynamips** (there are
    more details at [https://github.com/GNS3/dynamips](https://github.com/GNS3/dynamips)).
  prefs: []
  type: TYPE_NORMAL
- en: On the other hand, a simulator is built to mimic some functionalities of the
    entity that you want to test. In the case of a router, normally, only particular
    functions are simulated, not all the functions of the router. Because of the characteristics
    of being smaller, a simulator can accomplish results much faster and can scale
    up to thousands in comparison to an emulator. Two popular examples of software
    used for simulating networks are **ns-3** ([https://www.nsnam.org/](https://www.nsnam.org/))
    and **NetworkX** ([https://networkx.org/](https://networkx.org/)).
  prefs: []
  type: TYPE_NORMAL
- en: Now that we know the differences between emulation and simulation, let’s dive
    a bit deeper into emulation.
  prefs: []
  type: TYPE_NORMAL
- en: Using device emulation
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The best use case for using emulation in our network automation would be for
    routers. With router emulation, we can test several features of the router without
    having it physically. But router emulation is perhaps the hardest to accomplish
    and the costliest in terms of resources. As an example, let’s explore how a popular
    Cisco router emulator works, called Dynamips. *Figure 9.1* represents a Cisco
    router being emulated by using Dynamips on a Linux host:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 9.1 – Cisco router emulation](img/B18165_09_001.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 9.1 – Cisco router emulation
  prefs: []
  type: TYPE_NORMAL
- en: As illustrated, Dynamips is a software layer that emulates the hardware for
    Cisco routers. Dynamips can emulate some Cisco hardware such as network ports,
    CPU, memory, auxiliary ports, and console ports. Dynamips was created by Christophe
    Fillot in 2005 to emulate the MIPS processor architecture for Cisco routers. Today,
    Dynamips is supported and maintained by the GNS network simulation team, more
    details of which can be found at [https://github.com/GNS3/dynamips](https://github.com/GNS3/dynamips).
  prefs: []
  type: TYPE_NORMAL
- en: Dynamips works like a virtual machine in that it will only run a Cisco operating
    system. To emulate a MIPs processor, Dynamips consumes a lot of CPU and memory.
    For instance, to run a legacy Cisco router 7200, Dynamips will allocate a minimum
    of 256 MB of RAM, plus 16 MB of cache. CPU is also heavily used to run the router
    by translating instruction by instruction. Earlier versions of Dynamips overloaded
    the CPU host, but with the introduction of a capability called **idle-PC**, the
    CPU consumption was reduced by a significant amount.
  prefs: []
  type: TYPE_NORMAL
- en: Other routers can be emulated but will need an emulator that provides the necessary
    hardware emulation for the CPU platform you require. Juniper routers can be emulated
    by using Juniper Olive. Juniper Olive is FreeBSD modified to load the Juniper
    router operational system called JunOS. With emulation, you can also run legacy
    routers by using a hardware emulator that can provide legacy CPU architecture.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following diagram illustrates a system running with four emulations, two
    Cisco routers, one Juniper router, and one legacy OpenWRT router:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 9.2 – Four emulations on one system](img/B18165_09_002.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 9.2 – Four emulations on one system
  prefs: []
  type: TYPE_NORMAL
- en: The connection between these routers in the preceding diagram is created on
    the operating system host. The host can provide a more complex software link emulation
    to provide connectivity or just copy traffic from one end and send it to another
    end for point-to-point connections. More on these connections will be explained
    later in this chapter in the *Connecting devices for testing* section.
  prefs: []
  type: TYPE_NORMAL
- en: Note that with emulation, it is possible to completely isolate the router, thus
    providing a completely different architecture. In *Figure 9.2*, Dynamips provides
    a MIPS CPU architecture to emulate Cisco 7200, Qemu provides a 32-bit CPU architecture
    to emulate a legacy OpenWRT router, VMware provides a 64-bit x86 CPU architecture
    to emulate a Juniper router, and Qemu provides a 64-bit x86 CPU architecture to
    emulate a Cisco XRv 9000.
  prefs: []
  type: TYPE_NORMAL
- en: The host that’s used for emulating these routers is Linux with a 6.1.4 kernel,
    but it could be another kernel or another operating system such as Windows that’s
    capable of running the emulators. The consumption of CPU and memory for *Figure
    9.2* is quite high – Cisco 9000 requires at least 4 vCPUs and 16 GB of RAM, Juniper
    requires a minimum of 2 vCPUs and 512 MB of RAM, Legacy OpenWRT requires a minimum
    of 1 vCPU, and Cisco 7200 requires a minimum of 2 vCPUs and around 300 MB.
  prefs: []
  type: TYPE_NORMAL
- en: Therefore, creating a large network using router emulation is hard, and perhaps
    impossible because of limited resources. One way to scale up the emulation is
    to share the hardware drivers, memory, and CPU by using some sort of operating
    system isolation, such as using Linux containers or FreeBSD jails. But with container
    setup, you will have to use the same version of the kernel and the same CPU architecture
    for all routers. Therefore, if your router runs on an ARM processor, and your
    host is an x86 processor, Linux containers won’t work. To work, the containers
    and the host must use the same CPU architecture.
  prefs: []
  type: TYPE_NORMAL
- en: Now, let’s have a look at how to scale emulation using containers.
  prefs: []
  type: TYPE_NORMAL
- en: Scaling up emulation with containers
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Emulation will scale up if you share resources from the host dynamically. However,
    that requires your router to run as a program on a Linux host that can be isolated
    as a container. That is perhaps a big limitation as most commercial routers do
    not run on Linux and can’t be containerized. Choosing open source routers gives
    you the advantage of it being easy to move to a container-based architecture.
    Some big companies have chosen to move away from commercial operating system routers
    and migrate to a Linux-based routing architecture, which facilitates the creation
    of the emulated network.
  prefs: []
  type: TYPE_NORMAL
- en: Despite the commercial limitations, some vendors provide versions that can be
    containerized, such as Arista, Cisco, Juniper, and Nokia. This includes Cisco
    XRv and CSRv versions, Juniper vMX and vQFX, Arista vEOS, and Nokia VSR. One project
    that explores these capabilities is **vrnetlab** (there are more details at [github.com/vrnetlab/vrnetlab](http://github.com/vrnetlab/vrnetlab)).
  prefs: []
  type: TYPE_NORMAL
- en: There are a bunch of network tests that can be done, even if the routers are
    not the same as production, such as network design tests, topology migration tests,
    IP filter-based tests, and topology failover tests, among others. The reason is
    that most topologies run standard protocols and can be translated into an open
    source network platform. If you are using SDN and OpenFlow, that is also true.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following diagram illustrates how you could run four emulated routers using
    containers:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 9.3 – Running emulation with containers](img/B18165_09_003.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 9.3 – Running emulation with containers
  prefs: []
  type: TYPE_NORMAL
- en: As you can see in the preceding figure, the containers share CPU, memory, and
    network ports with the Linux host (green rectangle), but with isolation within
    the container. Each container isolates the shared resources from other containers,
    but they use the same Linux kernel, same drivers, and same CPU architecture. Different
    runtime libraries can be used, but the kernel and CPU architecture must be the
    same. Each container will have its own routing table, and programs running on
    the same container will share the same routing table but will not share the routing
    tables between containers unless using a routing protocol.
  prefs: []
  type: TYPE_NORMAL
- en: You could also run a virtual machine inside a container, but then you are not
    saving resources, and the limitations shown previously are the same. So, if you
    want to scale up, you have to share the hardware resources with all containers,
    not emulate another layer like in *Figure 9.2*.
  prefs: []
  type: TYPE_NORMAL
- en: 'In the example in *Figure 9.3*, there are four routers – one FRRouting, one
    OpenWRT, one Quagga, and one DD-WRT. All these routers are open source and can
    be containerized. But they are not necessarily one program running, but instead
    a group of programs. Quagga and FFRouting run several programs that do different
    tasks, such as `bgpd`, `ospfd`, and `zebra`. References to these open source routers
    can be obtained from the following sources:'
  prefs: []
  type: TYPE_NORMAL
- en: 'FRRouting: [https://frrouting.org/](https://frrouting.org/)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'OpenWRT: [https://openwrt.org/docs/guide-user/virtualization/lxc](https://openwrt.org/docs/guide-user/virtualization/lxc
    )'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Quagga: [https://www.nongnu.org/quagga/](https://www.nongnu.org/quagga/)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'DD-WRT: [https://dd-wrt.com/](https://dd-wrt.com/)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: You will need some connectivity capability to be able to connect the emulated
    routers. Now, let’s discuss the techniques we can use to connect devices in a
    network.
  prefs: []
  type: TYPE_NORMAL
- en: Connecting devices for testing
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Ensuring the connectivity of our devices for tests is important for obtaining
    a proper network environment for testing. There are several different ways to
    connect devices for testing, such as physical cables and software. Physical cables
    always have two caveats – they require technical personnel at the site and take
    time to implement. Via software, there is only one limitation – the maximum data
    throughput, which is normally a fraction of a physical cable. Therefore, if your
    tests require high data throughput, you might need to use physical wires instead.
    There is a workaround to this limitation that we are going to explain later in
    this chapter when we look at advanced techniques.
  prefs: []
  type: TYPE_NORMAL
- en: The environment for using devices for testing is also known as a network testing
    laboratory or just a network lab. To explain how we can connect devices in our
    lab, let’s describe the three possible ways to connect devices in a lab.
  prefs: []
  type: TYPE_NORMAL
- en: Using physical wires to connect
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In a test environment, a physical connection normally consists of wires that
    connect the ports of network devices. They are normally optical cables, coaxial
    cables, or twisted pair cables. If you have two devices, the cables are simple
    and will pass from one device to the other. However, if you are planning to have
    a lab with several racks and dozens of devices, you might want to use a patch
    cord and a patch panel instead of passing wires through the racks. The idea of
    using a patch panel is that the technician will only need to use patch cords to
    connect the devices, which makes the connection setup a bit faster and easier
    to remove later.
  prefs: []
  type: TYPE_NORMAL
- en: 'It is important to understand how the patch panel and patch cords work in the
    physical lab because it will help us to understand the software version later.
    The following diagram illustrates the patch panels for connecting two racks with
    four routers each:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 9.4 – Connecting routers using patch panels](img/B18165_09_004.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 9.4 – Connecting routers using patch panels
  prefs: []
  type: TYPE_NORMAL
- en: Note that in the preceding figure, the orange and blue wires represent permanent
    wires and will never be removed. The red and green lines represent the patch cords
    that are used to connect devices but can be removed and reconnected easily for
    a different topology setup. The blue lines in rack 1 are connecting routers R0,
    R1, R2, and R3 to patch panel P1, similar to rack 2, which connects routers R10,
    R11, R12, and R13 to patch panel P11\. The orange lines represent the permanent
    wires that connect patch panel P0 to patch panel P10.
  prefs: []
  type: TYPE_NORMAL
- en: Whenever a topology setup is required, the technician just needs patch cords
    to set up connections between the routers. The number of ports on each patch panel
    will depend on the number of available network ports on each router. As an example,
    for *Figure 9.4*, let’s suppose that each router in rack 1 has five network ports
    available. Therefore, patch panel P1 needs to have at least 20 ports to allow
    connections to all routers on rack 1.
  prefs: []
  type: TYPE_NORMAL
- en: In *Figure 9.4*, there are three patch cords. The green one in rack 1 connects
    two devices inside rack 1, which could be, for instance, R0 and R1\. The other
    two red patch cords are used to interconnect devices between rack 1 and rack 2,
    which could be, for instance, between R0 and R10.
  prefs: []
  type: TYPE_NORMAL
- en: Now, let’s see how we can link devices using software connections.
  prefs: []
  type: TYPE_NORMAL
- en: Using software to connect
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: For the explanation in this subsection, we are going to assume all routers are
    software-emulated routers. A hybrid setup with software and real devices will
    be explained in the next subsection.
  prefs: []
  type: TYPE_NORMAL
- en: Several software techniques can be used to interconnect emulated routers, and
    they will also depend on the operating system that is used as the host. For our
    example, we are going to use Linux as the host. For Windows, FreeBSD, or macOS,
    you might need different techniques.
  prefs: []
  type: TYPE_NORMAL
- en: The methods to connect emulated routers will also depend on which emulation
    you are using. They may differ depending on whether you are using Dynamips, VirtualBox,
    VMware, Qemu, or Linux containers.
  prefs: []
  type: TYPE_NORMAL
- en: Let’s explore a few methods to connect emulated routers using Linux.
  prefs: []
  type: TYPE_NORMAL
- en: Using TUN/TAP interfaces
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: In Linux, TUN/TAP interfaces are software interfaces that are used to receive
    and send network traffic, but they are not connected to any network. The interface
    is called TUN/TAP because the device can be either configured to work only on
    layer 3, which is called TUN mode, or on layer 2, which is called TAP interface
    mode. Both modes use the same Linux device driver (accessible via `/dev/net/tun`),
    just with a different flag. The flag to use TAP mode is `IFF_TAP`, whereas the
    flag to use TUN is `IFF_TUN`. More details on the kernel driver for TUN/TAPc can
    be found at [https://www.kernel.org/doc/html/v5.8/networking/tuntap.html](https://www.kernel.org/doc/html/v5.8/networking/tuntap.html).
  prefs: []
  type: TYPE_NORMAL
- en: 'Linux provides an easy interface for creating and removing TUN/TAP interfaces;
    you can use the `ip tuntap` command for this. The following is an example of creating
    a tap interface:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: TAP interfaces are preferable to use compared to TUN interfaces, as they work
    at layer 2 and receive and send packets like real Ethernet interfaces.
  prefs: []
  type: TYPE_NORMAL
- en: Now, let’s see how we can use `veth` interfaces.
  prefs: []
  type: TYPE_NORMAL
- en: Using veth interfaces
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'The network in a Linux container is isolated and has a namespace number associated
    with it. To connect to them, you will need to use veth interfaces. veth interfaces
    can be associated with the namespace and can be created on their own or with a
    peer in a point-to-point configuration. When creating a veth with a peer, you
    will need to associate the two namespaces, one for each side of the veth peering.
    Once the peer has been set, any information that is written to one side of the
    veth peer will be sent to the other side, which is a fast and easy way to interconnect
    emulated routers when using Linux containers. We are going to use them a lot in
    our examples. Here is an example of how to create a veth peer interface:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: In this example, two containers are being used, which are identified by the
    `41784` and `41634` network namespaces. A peer is created with interface names
    `A` and `B`, but the communication between the containers will only be possible
    after associating the interface name with the network namespace using `ip link
    set <ifname> netns <namespace>`, as in this example. The interface names can be
    the same but need to be renamed only after being associated with the namespace.
    This is because, before the association, the veth interfaces are in the host,
    and therefore in the same namespace, which won’t allow multiple interfaces with
    the same name to be created.
  prefs: []
  type: TYPE_NORMAL
- en: Now, let’s learn how we can use software bridges.
  prefs: []
  type: TYPE_NORMAL
- en: Using software bridges
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Software bridges are used to interconnect software and hardware network ports,
    which can be added and removed like a real network switch. The Linux kernel has
    a native software bridge that can be used by using the `bridge` command or by
    adding the `bridge-utils` package and using the `brctl` command. When a software
    bridge is created, it requires a name that is also attributed to a network interface
    that will or will not have an IP address. The following is an example of creating
    a bridge and associating three interfaces with it:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: 'As explained previously, the `Mybridge` bridge is also associated with a network
    interface on the Linux host. This can be seen by running the `ip link` command,
    as shown here:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: Linux native bridges are fast and simple, but there are advanced configurations
    that cannot be performed by them. To be able to use more advanced commands, the
    recommendation is to use **OpenvSwitch**, also known as **OvS** (there are more
    details at [https://www.openvswitch.org/](https://www.openvswitch.org/)).
  prefs: []
  type: TYPE_NORMAL
- en: Using VXLAN
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Linux bridges, TAP, and veth interfaces are used locally inside the Linux host
    to create a connection between emulated routers, but it won’t work to interconnect
    emulated routers that are running in a different host. There are a few techniques
    that could be used to connect emulated routers across hosts, such as pseudowires,
    L2TP, and layer 2 VPNs, among others, but the best would be VXLAN.
  prefs: []
  type: TYPE_NORMAL
- en: VXLAN works as a layer 2 tunnel that extends the local bridge to another remote
    device, which can be another Linux host, a network switch, or a router. With VXLAN,
    it is also possible to connect emulated routers to real routers as if they are
    connected by a wire on a back-to-back connection. As we are going to see later
    in this section, VXLAN is going to be used for hybrid labs where a connection
    between real routers and emulated routers is used.
  prefs: []
  type: TYPE_NORMAL
- en: VLAN is a well-known protocol and was explained in [*Chapter 2*](B18165_02.xhtml#_idTextAnchor041),
    Original VLANs have 12 bits of identification, which allows for up to 4,096 VLAN
    IDs. But VLAN tagging (IEEE 802.1Q) adds an extra 12 bits, so that’s up to 24
    bits for identifying a VLAN on a normal Ethernet layer 2 frame using VLAN tagging.
  prefs: []
  type: TYPE_NORMAL
- en: 'VXLAN is independent of VLAN or VLAN tagging, using a header identifier with
    24 bits and UDP as transport with port number `4789`. An original Ethernet frame
    that uses a VXLAN tunnel will need an extra 54 bytes of overhead for the tunnel.
    So, if your network MTU is 1,500 bytes, the maximum MTU of payload that can be
    carried inside the tunnel will be reduced by 54 bytes. It is recommended to increase
    MTU when using VXLAN. The following diagram shows an example of protocol encapsulation
    for VXLAN:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 9.5 – VXLAN encapsulation](img/B18165_09_005.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 9.5 – VXLAN encapsulation
  prefs: []
  type: TYPE_NORMAL
- en: A VXLAN connects endpoints, known as **Virtual Tunnel Endpoints** (**VTEPs**).
    A device that works with VXLAN when receiving an Ethernet frame on a VTEP will
    then add the VXLAN header, UDP, and IP and will send it toward the other VTEP
    destination.
  prefs: []
  type: TYPE_NORMAL
- en: Now, let’s see how we would set up a hybrid lab using software connections and
    physical wires.
  prefs: []
  type: TYPE_NORMAL
- en: Building a hybrid lab
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: A hybrid lab is necessary whenever you want to combine emulated routers with
    physical routers. The main reason you will need such a configuration is when testing
    the performance of a real router and adding complexity such as an extra 500 routers
    in the OSPF backbone. It is also useful to test connections with different complex
    topologies, such as an external BGP with flapping routes. All extra anomalies
    can be automated and added using the emulated environment, helping the test gain
    agility and accuracy.
  prefs: []
  type: TYPE_NORMAL
- en: With a hybrid lab, you could have a few real routers connected to an unlimited
    number of emulated routers, perhaps building an entire network emulation that
    can be connected to real routers for closer production environment testing. Again,
    anomalies can be easily introduced automatically in the emulation, with precision,
    including packet loss, latency, and jitter. Therefore, your network automation
    skills are going to be the key to the success of a hybrid lab.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following diagram shows an example of a hybrid lab connecting four emulated
    routers to two real routers:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 9.6 – Connectivity example for a hybrid lab](img/B18165_09_006.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 9.6 – Connectivity example for a hybrid lab
  prefs: []
  type: TYPE_NORMAL
- en: Note that in the preceding figure, the purple lines represent the physical cables
    that connect Linux host 1, Linux host 2, router A, and router B to network switch
    1\. VXLAN is used between these devices to allow the setup of any connection between
    these devices. Linux host 2 uses only container-emulated routers, and therefore
    veth interfaces. Linux host 1 uses a tap interface to connect emulated router
    2, which could be, for instance, Dynamips with a Cisco-emulated router.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following diagram shows a more complex hybrid setup:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 9.7 – A more complex hybrid lab setup](img/B18165_09_007.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 9.7 – A more complex hybrid lab setup
  prefs: []
  type: TYPE_NORMAL
- en: As you can see in the preceding figure, there are 3,000 emulated routers and
    6 physical routers connected via VXLAN switches and software VXLAN bridges. The
    setup looks clean and straightforward, but it can create very complex connections
    and topologies. The VXLAN switches work as patch panels that can be configured
    by software. It is also necessary to have a real router with all interfaces connected
    to a VXLAN switch so that it can work as a patch panel for that router, such as
    router A connected to VXLAN switch 2.
  prefs: []
  type: TYPE_NORMAL
- en: Now, let’s discuss how we can add an OOB network.
  prefs: []
  type: TYPE_NORMAL
- en: Adding an OOB network to your lab
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: One important problem we need to pay attention to is how we access devices without
    needing to have any network connection. And the answer to this problem is to use
    an OOB network, or out-of-band management network, as we discussed in [*Chapter
    1*](B18165_01.xhtml#_idTextAnchor015).
  prefs: []
  type: TYPE_NORMAL
- en: Adding some sort of access to devices that do not require any network connection
    helps when performing catastrophic tests, such as when routers must be removed
    or turned off. There are several ways to access an emulated router, which is done
    by accessing the host where the emulation is running. For real routers, the way
    to access them is via a console or auxiliary ports, which is normally performed
    using serial communication. Therefore, to allow automation for all devices, you
    will require a serial port server device that will allow remote access via IP
    and SSH. Once connected to the serial port server via SSH, you will be able to
    access the router via a serial port from the port server. One example of this
    port server is the product Avocent ACS8000, which has 32 serial ports and can
    be accessed via IP using an Ethernet port or a 4G mobile network ([https://www.amazon.com/Avocent-ACS8000-Management-Cellular-ACS8032-NA-DAC-400/dp/B099XFB39R](https://www.amazon.com/Avocent-ACS8000-Management-Cellular-ACS8032-NA-DAC-400/dp/B099XFB39R)).
  prefs: []
  type: TYPE_NORMAL
- en: Now, let’s use some advanced techniques to enhance our network code testing.
  prefs: []
  type: TYPE_NORMAL
- en: Using advanced testing techniques
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: I created this section to explore some methods that can be used for testing
    that are not commonly used but might be somehow useful. These techniques are perhaps
    not used much today but might become mainstream in the future, so keep an eye
    on how things evolve.
  prefs: []
  type: TYPE_NORMAL
- en: First, let’s see how we can use time dilation in our network code testing.
  prefs: []
  type: TYPE_NORMAL
- en: Using time dilation
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: When building your test environment, you might face requirements for testing
    that are physically impossible to do in a lab with emulated routers, such as measuring
    protocol convergence time or sending large amounts of data between devices. The
    reason these high-performance tests are physically impossible using emulation
    is that the CPU and I/O on an emulated router are smaller and limited compared
    to real routers. One way to overcome this limitation is to use **time dilation**.
  prefs: []
  type: TYPE_NORMAL
- en: Time dilation is a technique that changes the CPU clock of the emulated environment
    in such a way that the emulated router will run slower compared to an emulation
    without time dilation. From the host’s perspective, the emulated router with time
    dilation will use fewer resources, as it is not running as fast as the emulated
    router without time dilation. But from the emulated router’s perspective, which
    uses time dilation, everything seems to run at normal speed, but in reality, is
    much slower.
  prefs: []
  type: TYPE_NORMAL
- en: Imagine you want to test the time it takes for an application to copy files
    between two ends using network emulation. In a real network, these devices will
    have 10 GE interfaces that can have up to 10 Gbps. But in an emulation environment,
    they might have only 100 Mbps available or even less. To overcome these limitations,
    one technique is to put all emulations, including the application, in a time dilation
    environment that has a **time dilation factor** (or **TDF**) of 1,000 or more.
    With a TDF of 1,000, the CPU and I/O, including network interfaces, will be capable
    of performing more work from the emulated network and application perspective.
  prefs: []
  type: TYPE_NORMAL
- en: For network testing, normally, TDF is greater than 1, but it is also possible
    to use one smaller than 1, meaning that the emulation will run faster than the
    host. The applications that use lower than 1 TDF are normally used when tests
    need to go faster and CPU constraints do not exist. For example, a TDF of 0.1
    will run 10 times faster, but the implementation is normally not trivial and sometimes
    not possible because it relies on shortening the waiting time.
  prefs: []
  type: TYPE_NORMAL
- en: 'The University of San Diego has done some work on time dilation based on a
    paper called *To Infinity and Beyond: Time-Warped Network Emulation*, which does
    have some implementation code for Xen and Linux kernel. Details can be found at
    [https://www.sysnet.ucsd.edu/projects/time-dilation](https://www.sysnet.ucsd.edu/projects/time-dilation).
    Other implementations for time dilation focus on virtual machines and use Qemu
    to manipulate time; one implementation is from the University of North Carolina,
    where they created a project called *Adaptive Time Dilation*. Details can be found
    at [https://research.ece.ncsu.edu/wireless/MadeInWALAN/AdaptiveTimeDilation](https://research.ece.ncsu.edu/wireless/MadeInWALAN/AdaptiveTimeDilation).'
  prefs: []
  type: TYPE_NORMAL
- en: One advantage of using time dilation is that TDF can be adjusted every time
    you perform a test in your environment. A low TDF will impose more CPU and I/O
    limitations and might be useful to test how the application and network would
    perform in low-performance conditions, giving a lower-bound test result. A high
    TDF would give enough CPU and I/O resources to test the application and network
    in an ideal world without resource limitations, giving an upper-bound test result.
    Adjusting TDF to a certain mid value would give you the resources compatible with
    a real network with a real application, giving a test result that’s closer to
    reality.
  prefs: []
  type: TYPE_NORMAL
- en: Now, let’s see how we can use monkey testing on network code testing.
  prefs: []
  type: TYPE_NORMAL
- en: Using monkey testing
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In software development, monkey testing is used when an application requires
    testing and there is no formal definition of what to test. Monkey testing generates
    random inputs and evaluates the outputs.
  prefs: []
  type: TYPE_NORMAL
- en: The idea of monkey testing is to find problems with the code that were not expected
    by the software developer. In our case, we can use monkey testing to evaluate
    the network automation tools and the network itself. In some sense, penetration
    testing would be considered part of monkey testing, but more related to finding
    security holes, not failures.
  prefs: []
  type: TYPE_NORMAL
- en: One great example of monkey testing is the Netflix implementation called **Chaos
    Monkey** (there are more details at [https://github.com/Netflix/chaosmonkey](https://github.com/Netflix/chaosmonkey)).
    Chaos Monkey is written in Go and used for randomly terminating containers and
    virtual machines. With a few modifications, it can be used to shut down interfaces
    and network links. It is based on chaos engineering (there are more details at
    [http://principlesofchaos.org/](http://principlesofchaos.org/)). Chaos Monkey
    is a good example of monkey testing that can be added to our network automation
    testing infrastructure.
  prefs: []
  type: TYPE_NORMAL
- en: Now, let’s explore how we could use **artificial intelligence** (**AI**) for
    network code testing.
  prefs: []
  type: TYPE_NORMAL
- en: Using artificial intelligence
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Products that use AI for software development are in their early stages, but
    they will become reality soon. Today, it is possible to generate code via AI platforms
    such as **ChatGPT** (there’s more at [https://chat.openai.com/auth/login](https://chat.openai.com/auth/login)).
    Normally, the code generated by the AI is simple and not necessarily optimized,
    but it is an important milestone toward having to AI write code. The following
    is an example of the output of using ChatGPT to write unit tests:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: Note that the question was very simple and did not specify the language or packages,
    such as Python or to use the `unittest` and `mock` packages. The AI figured out
    the language and the packages to import by itself. However, it introduced a small
    outdated import. Since Python 3.3, `mock` has to be imported as `from unittest
    import mock`, instead of `import mock`.
  prefs: []
  type: TYPE_NORMAL
- en: Although the unit test written previously was not complete and contained a small
    error, it is a huge step toward having computers automate tests during development.
    It can be used today to help developers improve their code.
  prefs: []
  type: TYPE_NORMAL
- en: Some commercial products are already offering AI solutions for software development.
    For instance, GitHub has a product called **Copilot** that offers pair programming
    with AI (there are more details at [github.com/features/copilot](http://github.com/features/copilot)).
    Copilot claims that it can write unit tests for you, which is an amazing achievement.
  prefs: []
  type: TYPE_NORMAL
- en: More and more companies will start offering solutions for code development,
    and for sure writing unit tests will be the first milestone to be accomplished
    by AI platforms. Unit tests consume a lot of the developer’s time, in most cases
    taking even more time to write than the code itself. Keep an eye on the market
    for network automation test tools that use AI – it will make development more
    robust and faster.
  prefs: []
  type: TYPE_NORMAL
- en: Now, let’s see how we can add network simulation to enhance network code testing.
  prefs: []
  type: TYPE_NORMAL
- en: Using network simulation
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Network simulation, in contrast to network emulation, uses software to simulate
    part of the behavior of the network. Most network simulators are used either to
    simulate network protocol behaviors or to predict and calculate traffic demands
    and network paths. It can also be used to calculate resources, such as memory
    and network capacity on devices, but not much more beyond that.
  prefs: []
  type: TYPE_NORMAL
- en: One of the very popular Python packages that is used for network simulation
    is **NetworkX** (there are more details at [https://networkx.org/](https://networkx.org/)),
    which is a graph manipulation library. With NetworkX, it is possible to create
    a large network with thousands of nodes and millions of links using much fewer
    resources than when using network emulation. Simulating a large network using
    NetworkX is possible if you wish to run several tests that will be performed much
    faster than using emulation. However, the tests will evaluate the behavior of
    the network due to link and node failures, not the control plane (routing protocols)
    or the operating system of the routers.
  prefs: []
  type: TYPE_NORMAL
- en: Another useful application of network simulation is to test a network access
    list table path for a particular IP prefix. Once the network simulation has been
    built, it is possible to determine where a certain IP packet would flow in terms
    of normal and failure conditions. The simulation must be built using the network
    router configuration tables, and perhaps can be updated regularly to match production.
    Note that this kind of test will demand the creation of a network graph for each
    IP prefix to be tested, and the access list for each interface will dictate the
    inclusion (or not) of the link in the IP prefix graph.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following figure shows the topology that we are going to build using NetworkX
    as an example:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 9.8 – Topology to be used with NetworkX](img/B18165_09_008.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 9.8 – Topology to be used with NetworkX
  prefs: []
  type: TYPE_NORMAL
- en: 'This topology is also described in the `Chapter09/NetworkX/topology.yaml` file,
    which is included in the GitHub repo of this book. The following code reads this
    file and creates a NetworkX graph with this topology:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: 'After loading the topology, a series of tests can be done to evaluate the behavior
    of the network. For instance, we could remove the link between `cpe-a` and `acc-a`
    and see whether there is connectivity between `pc-a` and `internet`. As the process
    of adding and removing edges is more interactive, the best platform to use NetworkX
    for testing would be a Jupyter notebook (as described in *Chapter 6*). The following
    screenshot shows the output of the Jupyter notebook, showing the test of removing
    a link and testing connectivity between `pc-a` and `internet`:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 9.9 – Jupyter notebook output example](img/B18165_09_009.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 9.9 – Jupyter notebook output example
  prefs: []
  type: TYPE_NORMAL
- en: As you can see, if you remove the link between `cpe-a` and `acc-a` (`edge 1,2`),
    `pc-a` loses connectivity to `internet`. The `node_connectivity()` method returns
    an `integer` that, if greater than zero, indicates there is connectivity between
    nodes (more details on this method and other connectivity algorithms can be found
    at [https://networkx.org/documentation/stable/reference/algorithms/connectivity.html](https://networkx.org/documentation/stable/reference/algorithms/connectivity.html)).
    A series of additional tests can be found in the `Chapter09/NetworkX/example.ipynb`
    file.
  prefs: []
  type: TYPE_NORMAL
- en: A combination of network simulation and network emulation can be used to increase
    the capacity and speed of your code testing. A mechanism must be included to build
    the emulation and create the simulation using the same configuration. In addition,
    some tests can be performed first on simulation and, if required, repeated in
    the emulation to be validated.
  prefs: []
  type: TYPE_NORMAL
- en: Using traffic control
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Using traffic shaping (or traffic control), it is possible to add complexity
    to our emulation by adding some physical characteristics that are present in real
    links and multi-to-multi-point networks. With traffic shaping, we can add latency
    to specific connections, introduce packet loss, add random limitations, add network
    congestion, add jitter, and much more. On Linux, it can be easily obtained by
    using the built-in `tc` command.
  prefs: []
  type: TYPE_NORMAL
- en: TC is implemented in Linux by using schedulers or `tc` and qdiscs can be found
    at [https://tldp.org/HOWTO/Traffic-Control-HOWTO](https://tldp.org/HOWTO/Traffic-Control-HOWTO)).
  prefs: []
  type: TYPE_NORMAL
- en: 'The following is an example of using a `qdisc` called `netem` to add 10 ms
    of latency to the loopback interface:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: This example adds 10 ms to reach the `lo` interface in each way, so the round-trip
    time is double, which appears in the results as a 21.4 ms average.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here is another example, showing how to add 5% packet loss using `netem`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: In this test example, the result was 4% of packet loss instead of 5% as configured.
    This is because `netem` uses random selection to obtain packet loss, and it will
    require a larger testing sample to get closer to 5% – for example, 1,000 packets
    instead of 100, which was used in the preceding test.
  prefs: []
  type: TYPE_NORMAL
- en: Other more complex network behaviors can be added to the interface using `netem`,
    such as burst control, maximum capacity, network congestion, and random latency
    variance, among others. More details on it can be found at [https://wiki.linuxfoundation.org/networking/netem](https://wiki.linuxfoundation.org/networking/netem).
  prefs: []
  type: TYPE_NORMAL
- en: There are lots of other schedulers besides `netem`, such as `choke`, `codel`,
    `hhf`, and `ATM`. A list of all classless and classful qdiscs available can be
    obtained on the `tc` man page, which can be visualized by just typing `man tc`
    (the HTML version can be found at [https://manpages.debian.org/buster/iproute2/tc.8.en.html](https://manpages.debian.org/buster/iproute2/tc.8.en.html)).
  prefs: []
  type: TYPE_NORMAL
- en: Hopefully, you have got the most out of this section and have started wondering
    whether some of these advanced techniques could be added to your project. Adding
    one of these techniques will likely make your project more reliable and closer
    to a real production environment.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The goal of this chapter was to introduce you to how to build and use a proper
    infrastructure to test your automation code using software. You learned how software
    can be used to effectively test your automation code, how to use simulation and
    emulation, how to connect real and emulated devices, and finally, how advanced
    techniques can be incorporated.
  prefs: []
  type: TYPE_NORMAL
- en: Adding some of the techniques described in this chapter will add superpowers
    to your network automation code project. From now on, it will be unbeatable.
  prefs: []
  type: TYPE_NORMAL
- en: In the next chapter, we are going to get hands-on in a network lab and wrap
    up this book with a few additional remarks.
  prefs: []
  type: TYPE_NORMAL
