- en: '6'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Decorators – Enabling Code Reuse by Decorating
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, you are going to learn about Python decorators. The previous
    chapters have already shown the usage of a few decorators, but you will now find
    out more about them. Decorators are essentially function/class wrappers that can
    be used to modify the input, output, or even the function/class itself before
    executing it. This type of wrapping can just as easily be achieved by having a
    separate function that calls the inner function, or via inheriting small feature
    classes commonly called **mixins**. As is the case with many Python constructs,
    decorators are not the only way to reach the goal but are definitely convenient
    in many cases.
  prefs: []
  type: TYPE_NORMAL
- en: While you can get along fine without knowing too much about decorators, they
    give you a lot of “reuse power” and are therefore used heavily in framework libraries
    such as web frameworks. Python actually comes bundled with some useful decorators,
    most notably the `@property`, `@classmethod`, and `@staticmethod` decorators.
  prefs: []
  type: TYPE_NORMAL
- en: 'There are, however, some particularities to take note of: wrapping a function
    creates a new function and makes it harder to reach the inner function and its
    properties. One example of this is the `help(function)` functionality of Python;
    by default, you, your editor, and your documentation generator can lose function
    properties such as the help text and the module the function exists in.'
  prefs: []
  type: TYPE_NORMAL
- en: This chapter will cover the usage of both function and class decorators, as
    well as the intricate details you need to know when decorating functions within
    classes.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following are the topics covered:'
  prefs: []
  type: TYPE_NORMAL
- en: Decorating functions
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Decorating class functions
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Decorating classes
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Useful decorators in the Python Standard Library
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Decorating functions
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Decorators are functions or classes that wrap other functions and/or classes.
    In its most basic form, you can view a regular function call as `add(1, 2)`, which
    transforms into `decorator(add(1, 2))` when applying a decorator. There’s slightly
    more to it, but we will come to that later. Let’s implement that `decorator()`
    function:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'To make the syntax easier to use, Python has a special syntax for this case.
    So, instead of adding a line such as the preceding one below the function, you
    can decorate a function using the `@` operator as a shortcut:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: 'This example shows the simplest and most useless decorator you can get: simply
    returning the input function and doing nothing else.'
  prefs: []
  type: TYPE_NORMAL
- en: 'From this, you might wonder what the use of a decorator is and what is so special
    about them. Some possibilities of decorators are:'
  prefs: []
  type: TYPE_NORMAL
- en: Registering a function/class
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Modifying function/class input
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Modifying function/class output
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Logging function calls/class instantiations
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: All of these will be covered later in this chapter, but let’s start simple for
    now.
  prefs: []
  type: TYPE_NORMAL
- en: 'Our first decorator will show how we can modify both the input and the output
    of a function call. Additionally, it adds some `logging` calls so we can see what
    is happening:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: This should show you how powerful decorators can be. We can modify, add, and/or
    remove arguments. We can modify the return value or even call a completely different
    function if we want to. And we can easily log all behavior if needed, which can
    be very useful when debugging. Instead of `return function(...)`, we can return
    something completely different if we wish.
  prefs: []
  type: TYPE_NORMAL
- en: More extensive examples of how to log using decorators are covered in *Chapter
    12,* *Debugging – Solving the Bugs*.
  prefs: []
  type: TYPE_NORMAL
- en: Generic function decorators
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The decorator we wrote earlier explicitly used the `a` and `b` arguments so
    it only works with functions that have a signature very similar to taking `a`
    and `b` arguments. If we want to make the generator more generic, we can replace
    `a, b` with `*args` and `**kwargs` to get the arguments and keyword arguments,
    respectively. That introduces a new problem, however. We either need to make sure
    to only use regular arguments or keyword arguments, or the checking will become
    increasingly difficult:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: 'As can be seen, in this case, keyword arguments are broken. To work around
    this issue, we have a few different methods. We can change the arguments to positional-only
    or keyword-only arguments:'
  prefs: []
  type: TYPE_NORMAL
- en: This code uses positional-only arguments (the `/` as the last function argument),
    which have been supported since Python 3.8\. For older versions, you can emulate
    this behavior using `*args` instead of explicit arguments.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: 'Or we can make Python automatically take care of this by fetching the signature
    and binding it to the given arguments:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: By using this method, the function has become a lot more versatile. We could
    easily add arguments to the `add` function and still be sure that the decorator
    functions.
  prefs: []
  type: TYPE_NORMAL
- en: The importance of functools.wraps
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Whenever you are writing a decorator, always be sure to add `functools.wraps`
    to wrap the inner function. Without wrapping it, you will lose all properties
    from the original function, which can lead to confusion and unexpected behavior.
    Take a look at the following code without `functools.wraps`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, our `add` method has no documentation anymore and the name is gone. It
    has been renamed `_decorator`. Since we are indeed calling `_decorator`, this
    is understandable, but it’s very inconvenient for code that relies on this information.
    Now we will try the same code with a minor difference; we will use `functools.wraps`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: 'Without any further changes, we now have documentation and the expected function
    name. The working of `functools.wraps` is nothing magical; it copies and updates
    several attributes. Specifically, the following attributes are copied:'
  prefs: []
  type: TYPE_NORMAL
- en: '`__doc__`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`__name__`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`__module__`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`__annotations__`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`__qualname__`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Also, `__dict__` is updated using `_decorator.__dict__.update(add.__dict__)`,
    and a new property called `__wrapped__` is added, which contains the original
    function (`add,` in this case). The actual `wraps` function is available in the
    `functools.py` file of your Python distribution.
  prefs: []
  type: TYPE_NORMAL
- en: Chaining or nesting decorators
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Since we’re wrapping functions, there is nothing stopping us from adding multiple
    wrappers. The order is important to keep in mind, though, because the decorators
    are initialized starting from the inside, but are called starting from the outside.
    Additionally, the teardown starts from the inside again:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: As you can see in the output, the decorators are called from outer to inner
    before running the function and running from inner to outer when processing the
    results.
  prefs: []
  type: TYPE_NORMAL
- en: Registering functions using decorators
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: We have seen how calls can be tracked, arguments can be modified, and return
    values can be changed. Now it is time to see how we can use decorators to register
    a function that can be useful for registering plugins, callbacks, and so on.
  prefs: []
  type: TYPE_NORMAL
- en: One situation where this is very useful is a user interface. Let us assume we
    have a GUI that has a button that can be clicked. By creating a system that can
    register callbacks, we can make the button fire a “clicked” signal and connect
    functions to that event.
  prefs: []
  type: TYPE_NORMAL
- en: 'To create an event manager like that, we will now create a class that keeps
    track of all of the registered functions and allows the firing of events:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: Firstly, we create the `EventRegistry` class to handle all of the events and
    store all the callbacks. After that, we register a few functions with the registry.
    Lastly, we fire a few events to see if it works as expected.
  prefs: []
  type: TYPE_NORMAL
- en: 'While this example is rather basic, this pattern can be applied to many scenarios:
    handling events for a web server, letting plugins register themselves for events,
    letting plugins register themselves in an application, and so on.'
  prefs: []
  type: TYPE_NORMAL
- en: Memoization using decorators
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Memoization is a simple trick for remembering results to make code run a lot
    faster in specific scenarios. The basic trick here is to store a mapping of the
    input and expected output so that you have to calculate a value only once. One
    of the most common examples of this technique is the naïve (recursive) Fibonacci
    function.
  prefs: []
  type: TYPE_NORMAL
- en: 'The Fibonacci sequence starts from 0 or 1 (depending how you look at it) and
    each consecutive number consists of the sum of the previous two numbers. To illustrate
    the pattern starting from the additions of the initial `0` and `1`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: 'I will now show how you can build a very basic memoization function decorator,
    and how it can be used:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: 'The memoize decorator has to be used without arguments and the cache can be
    introspected as well:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: 'When arguments are given, it breaks because the decorator is not built to support
    them:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: 'Additionally, the arguments need to be hashable to work with this implementation:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: While examples with a small `n` will work easily without memoization, for larger
    numbers it will run for an extremely long time. For `n=2`, the function would
    execute `fibonacci(n - 1)` and `fibonacci(n - 2)` recursively, resulting in exponential
    time complexity. For `n=30`, the Fibonacci function would already be called 2,692,537
    times; at `n=50`, it will stall or even crash your system.
  prefs: []
  type: TYPE_NORMAL
- en: Without memoization, the call stack becomes a tree that very quickly grows.
    To illustrate, let’s assume we want to calculate `fibonacci(4)`.
  prefs: []
  type: TYPE_NORMAL
- en: First, `fibonacci(4)` calls `fibonacci(3)` and `fibonacci(2)`. There’s nothing
    special here.
  prefs: []
  type: TYPE_NORMAL
- en: Now, `fibonacci(3)` calls `fibonacci(2)` and `fibonacci(1)`. You will notice
    that we got `fibonacci(2)` for the second time now. `fibonacci(4)` also executed
    it.
  prefs: []
  type: TYPE_NORMAL
- en: That split with each call is exactly the problem. Each function call starts
    two new function calls, which means it doubles for every call. And those double
    again and again until we have reached the end of the calculation.
  prefs: []
  type: TYPE_NORMAL
- en: Because the memoized version caches the results and only needs to calculate
    every number once, it doesn’t even break a sweat and only needs to execute `31`
    times for `n=30`.
  prefs: []
  type: TYPE_NORMAL
- en: This decorator also shows how a context can be attached to a function itself.
    In this case, the cache property becomes an attribute of the internal (wrapped
    `fibonacci`) function so that an extra `memoize` decorator for a different object
    won’t clash with any of the other decorated functions.
  prefs: []
  type: TYPE_NORMAL
- en: Note, however, that implementing the memoization function yourself is generally
    not that useful anymore since Python introduced `lru_cache` (**least recently
    used cache**) in Python 3.2\. The `lru_cache` is similar to the preceding memoize
    decorator function but a bit more advanced. It maintains a fixed cache size (`128`
    by default) to save memory, and stores statistics so you can check whether the
    cache size should be increased.
  prefs: []
  type: TYPE_NORMAL
- en: If you are only looking for statistics and have no need for caching, you can
    also set the `maxsize` to `0`. Or if you want to forego the LRU algorithm and
    save everything, you can pass `None` as `maxsize`. With a fixed size, the `lru_cache`
    will keep only the most recently accessed items and discard the oldest once it
    is full.
  prefs: []
  type: TYPE_NORMAL
- en: In most cases, I would suggest using `lru_cache` over your own decorator, but
    if you always need to store all items or if you need to process the keys before
    storing them, you can always roll your own. At the very least, it is useful to
    know how to write a decorator like this.
  prefs: []
  type: TYPE_NORMAL
- en: 'To demonstrate how `lru_cache` works internally, we will calculate `fibonacci(100)`,
    which would keep our computer busy until the end of the universe without any caching.
    Moreover, to make sure that we can actually see how many times the `fibonacci`
    function is being called, we’ll add an extra decorator that keeps track of the
    count, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: You might wonder why we need only 101 calls with a cache size of `3`. That’s
    because we recursively require only `n - 1` and `n - 2`, so we have no need for
    a larger cache in this case. If your cache is not performing as expected, the
    cache size might be the culprit.
  prefs: []
  type: TYPE_NORMAL
- en: 'Additionally, this example shows the usage of two decorators for a single function.
    You can see these as the layers of an onion. When calling `fibonacci`, the execution
    order is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '`functools.lru_cache`'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '`counter`'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '`fibonacci`'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Returning the values works in the reverse order, of course; `fibonacci` returns
    its value to `counter`, which passes the value along to `lru_cache`.
  prefs: []
  type: TYPE_NORMAL
- en: Decorators with (optional) arguments
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The previous examples mostly used simple decorators without any arguments. As
    you have already seen with `lru_cache`, decorators can accept arguments as well
    since they are just regular functions, but this adds an extra layer to a decorator.
    This means that we need to check the decorator arguments to see if they are the
    decorated method or a regular argument. The only caveat is that the optional argument
    should not be callable. If the argument has to be callable, you will need to pass
    it as a keyword argument instead.
  prefs: []
  type: TYPE_NORMAL
- en: 'The upcoming code shows a decorator that has an optional (keyword) argument
    to the decorator:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: This decorator uses the `callable()` test to see whether the argument is a callable
    such as a function. This method works in many cases, but if for some reason your
    argument to the `add()` decorator is callable, this will break because it will
    be called instead of the function.
  prefs: []
  type: TYPE_NORMAL
- en: Whenever you have the choice available, I recommend that you either have a decorator
    with arguments or without them. Having optional arguments makes the flow of the
    function less obvious and slightly harder to debug when issues arise.
  prefs: []
  type: TYPE_NORMAL
- en: Creating decorators using classes
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Similar to how we create regular function decorators, it is also possible to
    create decorators using classes instead. As is always the case with classes, this
    makes storing data, inheriting, and reuse more convenient than with functions.
    After all, a function is just a callable object and a class can implement the
    callable interface as well. The following decorator works similarly to the `debug`
    decorator we used earlier, but uses a class instead of a regular function:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: The only notable difference between functions and classes is that `functools.wraps`
    is now replaced with `functools.update_wrapper` in the `__init__` method.
  prefs: []
  type: TYPE_NORMAL
- en: Since class methods have a `self` argument in addition to the regular arguments,
    you might wonder whether decorators will function in that scenario. The next section
    will cover decorator usage within classes.
  prefs: []
  type: TYPE_NORMAL
- en: Decorating class functions
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Decorating class functions is very similar to regular functions, but you need
    to be aware of the required first argument, `self`—the class instance. You have
    most likely already used a few class function decorators. The `classmethod`, `staticmethod`,
    and `property` decorators, for example, are used in many different projects. To
    explain how all this works, we will build our own versions of the `classmethod`,
    `staticmethod`, and `property` decorators. First, let’s look at a simple decorator
    for class functions to demonstrate the difference from regular decorators:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: As is the case with regular functions, the class function decorator now gets
    passed along `self` as the instance. Nothing unexpected!
  prefs: []
  type: TYPE_NORMAL
- en: Skipping the instance – classmethod and staticmethod
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The difference between a `classmethod` and a `staticmethod` is fairly simple.
    The `classmethod` passes a class object instead of a class instance (`self`),
    and `staticmethod` skips both the class and the instance entirely. This effectively
    makes `staticmethod` very similar to a regular function outside of a class.
  prefs: []
  type: TYPE_NORMAL
- en: In the following examples, we will use `pprint.pprint(... width=60)` to account
    for the width of the book. Additionally, `locals()` is a Python built-in that
    shows all local variables. Similarly, a `globals()` function is also available.
  prefs: []
  type: TYPE_NORMAL
- en: 'Before we recreate `classmethod` and `staticmethod`, we need to take a look
    at the expected behavior of these methods:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: 'The following examples will use the example above to illustrate the difference
    between a regular (class instance) method, a `classmethod`, and a `staticmethod`.
    Be wary of the difference between `spam` (lowercase) the instance and `Spam` (capitalized)
    the class:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: In particular, the last example is rather tricky. Because we passed some arguments
    to the function, these have automatically been passed as the `self` argument.
    Similarly, the last example shows how you can use this argument handling to call
    a method using a given instance. `Spam.some_instancemethod(spam)` is identical
    to `spam.some_instancemethod()`.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now let’s look at the `classmethod`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: The main difference here is that instead of `self` we now have `cls`, which
    contains the class (`Spam`) instead of the instance (`spam`).
  prefs: []
  type: TYPE_NORMAL
- en: The names `self` and `cls` are conventions and are not enforced in any way.
    You could easily call them `s` and `c` or something completely different instead.
  prefs: []
  type: TYPE_NORMAL
- en: Next up is the `staticmethod`. The `staticmethod` behaves identically to a regular
    function outside of a class.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: 'Before we can continue with decorators, you need to be aware of how Python
    descriptors function. Descriptors can be used to modify the binding behavior of
    object attributes. This means that if a descriptor is used as the value of an
    attribute, you can modify which value is being set, got, and deleted when these
    operations are called on the attribute. Here is a basic example of this behavior:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: As you can see, whenever we set or get values from `sandwich.spam`, it actually
    calls `__get__` or `__set__` on `Spam`, which has access not only to its own variables,
    but also the calling class. A very useful feature for automatic conversions and
    type checking, the `property` decorator we will see in the next section is just
    a more convenient implementation of this technique.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now that you know how descriptors work, we can continue with creating the `classmethod`
    and `staticmethod` decorators. For these two, we simply need to modify `__get__`
    instead of `__call__` so that we can control which type of instance (or none at
    all) is passed along:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: The `ClassMethod` decorator still features a sub-function to actually produce
    a working decorator. Looking at the function, you can most likely guess how it
    functions. Instead of passing `instance` as the first argument to `self.method`,
    it passes `cls`.
  prefs: []
  type: TYPE_NORMAL
- en: '`StaticMethod` is even simpler, because it completely ignores both the `instance`
    and the `cls`. It can just return the original method unmodified. Because it returns
    the original method without any modifications, we have no need for the `functools.wraps`
    call either.'
  prefs: []
  type: TYPE_NORMAL
- en: Properties – Smart descriptor usage
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The `property` decorator is probably the most used decorator in Python land.
    It allows you to add getters/setters to existing instance properties so that you
    can add validators and modify your values before setting them to your instance
    properties.
  prefs: []
  type: TYPE_NORMAL
- en: The `property` decorator can be used both as an assignment and as a decorator.
    The following example shows both syntaxes so that you know what to expect from
    the `property` decorator.
  prefs: []
  type: TYPE_NORMAL
- en: Python 3.8 added `functools.cached_property`, which functions the same as `property`
    but executes only once per instance.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: 'Similar to how we implemented the `classmethod` and `staticmethod` decorators,
    we need the Python descriptors again. This time, we require the full power of
    the descriptors, not just `__get__` but `__set__` and `__delete__` as well. For
    brevity, however, we will skip handling the documentation and some error handling:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: That doesn’t look all that complicated, does it? The descriptors make up most
    of the code, which is fairly straight to the point. Only the `getter`/`setter`/`deleter`
    functions might look a bit strange, but they’re actually fairly straightforward
    as well.
  prefs: []
  type: TYPE_NORMAL
- en: To make sure the `property` still works as expected, the class returns a new
    `Property` instance while copying the other methods. The only small caveat to
    make this work here is the `return self` in the `__get__` method.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: As expected, our `Property` decorator works as it should. But note that this
    is a more limited version of the built-in `property` decorator; our version has
    no checking for edge cases.
  prefs: []
  type: TYPE_NORMAL
- en: 'Naturally, being Python, there are more methods of achieving the effect of
    properties. In the previous examples, you saw the bare descriptor implementation,
    and in our previous example, you saw the `property` decorator. Now we will look
    at a generic solution by implementing `__getattr__` or `__getattribute__`. Here’s
    a simple demonstration:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: The `__getattr__` method looks for existing attributes, for example, it checks
    whether the key exists in `instance.__dict__`, and is called only if it does not
    exist. That’s why we never see a `__getattr__` for the registry attribute. The
    `__getattribute__` method is called in all cases, which makes it a bit more dangerous
    to use. With the `__getattribute__` method, you will need a specific exclusion
    for `registry` since it will be executed infinitely through recursion if you try
    to access `self.registry`.
  prefs: []
  type: TYPE_NORMAL
- en: There is rarely a need to look at descriptors, but they are used by several
    internal Python processes, such as the `super()` method when inheriting classes.
  prefs: []
  type: TYPE_NORMAL
- en: Now that you know how to create decorators for regular functions and class methods,
    let’s continue by decorating entire classes.
  prefs: []
  type: TYPE_NORMAL
- en: Decorating classes
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Python 2.6 introduced the class decorator syntax. As is the case with the function
    decorator syntax, this is not really a new technique either. Even without the
    syntax, a class can be decorated simply by executing `DecoratedClass = decorator(RegularClass)`.
    After the previous sections, you should be familiar with writing decorators. Class
    decorators are no different from regular ones, except for the fact that they take
    a class instead of a function. As is the case with functions, this happens at
    declaration time and *not* at instantiating/calling time.
  prefs: []
  type: TYPE_NORMAL
- en: Because there are quite a few alternative ways to modify how classes work, such
    as standard inheritance, mixins, and metaclasses (read more in *Chapter 8*, *Metaclasses
    – Making Classes (Not Instances) Smarter*), class decorators are never strictly
    needed. This does not reduce their usefulness, but it does offer an explanation
    of why you will most likely not see too many examples of class decorating in the
    wild.
  prefs: []
  type: TYPE_NORMAL
- en: Singletons – Classes with a single instance
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Singletons are classes that always allow only a single instance to exist. So,
    instead of getting an instance specifically for your call, you always get the
    same one. This can be very useful for things such as a database connection pool,
    where you don’t want to keep opening connections all of the time but want to reuse
    the original ones:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: As you can see in the `a is b` comparison, both objects have the same identity,
    so we can conclude that they are indeed the same object. As is the case with regular
    decorators, due to the `functools.wraps` functionality, we can still access the
    original class through `Spam.__wrapped__` if needed.
  prefs: []
  type: TYPE_NORMAL
- en: The `is` operator compares objects by identity, which is implemented as the
    memory address in CPython. If `a is b` returns `True`, we can conclude that both
    `a` and `b` are the same instance.
  prefs: []
  type: TYPE_NORMAL
- en: Total ordering – Making classes sortable
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: At some point or the other, you have probably needed to sort data structures.
    While this is easily achievable using the key parameter of the `sorted` function,
    there is a more convenient way if you need to do this often—by implementing the
    `__gt__`, `__ge__`, `__lt__`, `__le__`, and `__eq__` functions. That seems a bit
    verbose, doesn’t it? If you want the best performance, it’s still a good idea,
    but if you can take a tiny performance hit and some slightly more complicated
    stack traces, then `total_ordering` might be a nice alternative.
  prefs: []
  type: TYPE_NORMAL
- en: 'The `total_ordering` class decorator can implement all required sort functions
    based on a class that possesses an `__eq__` function and one of the comparison
    functions (`__lt__`, `__le__`, `__gt__`, or `__ge__`). This means you can seriously
    shorten your function definitions. Let’s compare the regular function definition
    and the function definition using the `total_ordering` decorator:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: 'As you can see, without `functools.total_ordering`, it’s quite a bit of work
    to create a fully sortable class. Now we will test whether they actually sort
    in a similar way:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, you might be wondering, “Why isn’t there a class decorator to make a class
    sortable using a specified key property?” Well, that might indeed be a good idea
    for the `functools` library, but it isn’t there yet. So, let’s see how we would
    implement something like it while still using `functools.total_ordering`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: Certainly, this greatly simplifies the making of a sortable class. And if you
    would rather have your own key function instead of `getattr`, it’s even easier.
    Simply replace the `getattr(self, attr)` call with `key_function(self)`, do that
    for `other` as well, and change the argument for the decorator to your function.
    You can even use that as the base function and implement `sort_by_attribute` by
    simply passing a wrapped `getattr` function.
  prefs: []
  type: TYPE_NORMAL
- en: Now that you know how to create all types of decorators, let’s look at a few
    useful decorator examples bundled with Python.
  prefs: []
  type: TYPE_NORMAL
- en: Useful decorators
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In addition to the ones already mentioned in this chapter, Python comes bundled
    with a few other useful decorators. There are some that aren’t in the standard
    library (yet?).
  prefs: []
  type: TYPE_NORMAL
- en: Single dispatch – Polymorphism in Python
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: If you’ve used C++ or Java before, you’re probably used to having ad hoc polymorphism
    available—different functions being called depending on the argument types. Python
    being a dynamically typed language, most people would not expect the possibility
    of a single dispatch pattern. Python, however, is a language that is not only
    dynamically typed but also strongly typed, which means we can rely on the type
    we receive.
  prefs: []
  type: TYPE_NORMAL
- en: 'A dynamically typed language does not require strict type definitions. While
    a language such as C would require the following to declare an integer:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: 'Python simply accepts that our value has a type:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs: []
  type: TYPE_PRE
- en: 'Although with type hinting we could also do:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs: []
  type: TYPE_PRE
- en: 'As opposed to languages such as JavaScript and PHP, however, Python does very
    little implicit type conversion. In Python, the following will return an error,
    whereas JavaScript would execute it without any problems:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs: []
  type: TYPE_PRE
- en: In Python, the result is a `TypeError`. In JavaScript, it’s `'spam5'`.
  prefs: []
  type: TYPE_NORMAL
- en: The idea of single dispatch is that depending on the type you pass, the correct
    function is called. Since `str + int` results in an error in Python, this can
    be very convenient to automatically convert your arguments before passing them
    to your function. This can be useful for separating the actual workings of your
    function from the type conversions.
  prefs: []
  type: TYPE_NORMAL
- en: 'Since Python 3.4, there is a decorator that makes it easily possible to implement
    the single dispatch pattern in Python. This decorator is useful if you need to
    execute different functions depending on the `type()` of your input variable.
    Here is a basic example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE37]'
  prefs: []
  type: TYPE_PRE
- en: The `singledispatch` decorator automatically calls the correct function for
    the type passed as the first argument. As you can see in the example, this works
    both when using type annotations and if explicit types are passed to the `register`
    function.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s see how we could make a simplified version of this method ourselves:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE38]'
  prefs: []
  type: TYPE_PRE
- en: Naturally, this method is a bit basic and it uses a single global registry,
    which limits its application. But this exact pattern can be used for registering
    plugins or callbacks.
  prefs: []
  type: TYPE_NORMAL
- en: When naming the functions, make sure that you do not overwrite the original
    `singledispatch` function. If you named `show_int` as just `show_type`, it would
    overwrite the initial `show_type` function. This would make it impossible to access
    the original `show_type` function and make all `register` operations after that
    fail as well.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, a slightly more useful example—differentiating between a filename and
    a file handler:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE39]'
  prefs: []
  type: TYPE_PRE
- en: So now we have a single `write_as_json` function; it calls the right code depending
    on the type. If it’s a `str` or `bytes` object, it will automatically open the
    file and call the regular version of `write_as_json`, which accepts file objects.
  prefs: []
  type: TYPE_NORMAL
- en: Writing a decorator that does this is not that hard to do, of course, but it’s
    still quite convenient to have the `singledispatch` decorator in the base library.
    It most certainly beats manually checking the given argument types with a list
    of `isinstance()` `if`/`elif`/`elif`/`else` statements.
  prefs: []
  type: TYPE_NORMAL
- en: To see which function will be called, you can use the `write_as_json.dispatch`
    function with a specific type. When passing along a `str`, you will get the `write_as_json_filename`
    function. It should be noted that the names of the dispatched functions are completely
    arbitrary. They are accessible as regular functions, of course, but you can name
    them anything you like.
  prefs: []
  type: TYPE_NORMAL
- en: 'To check the registered types, you can access the registry, which is a dictionary,
    through `write_as_json.registry`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE40]'
  prefs: []
  type: TYPE_PRE
- en: contextmanager — with statements made easy
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Using the `contextmanager` class, we can make the creation of a context wrapper
    very easy. Context wrappers are used whenever you use a `with` statement. One
    example is the `open` function, which works as a context wrapper as well, allowing
    you to use the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE41]'
  prefs: []
  type: TYPE_PRE
- en: 'Let’s just assume for now that the `open` function is not usable as a context
    manager and that we need to build our own function to do this. The standard method
    of creating a context manager is by creating a class that implements the `__enter__`
    and `__exit__` methods:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE42]'
  prefs: []
  type: TYPE_PRE
- en: 'While that works perfectly, it’s a tad verbose. With `contextlib.contextmanager`,
    we can have the same behavior in just a few lines:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE43]'
  prefs: []
  type: TYPE_PRE
- en: Simple, right? However, I should mention that for this specific case—the closing
    of objects—there is a dedicated function in `contextlib`, and it is even easier
    to use.
  prefs: []
  type: TYPE_NORMAL
- en: With `file` objects, database connections, and connections, it is important
    to always have a `close()` call to clean up resources. In the case of a `file`,
    it tells the operating system to write the data to disk (as opposed to temporary
    buffers), and in the case of network connections and database connections, it
    releases the network connection and related resources on both ends. With database
    connections, it will also notify the server that the connection is no longer needed
    so that part is also handled gracefully.
  prefs: []
  type: TYPE_NORMAL
- en: Without these calls, you can quickly run into “too many open files” or “too
    many connections” errors.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s demonstrate it with the most basic example of when `closing()` would
    be useful:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE44]'
  prefs: []
  type: TYPE_PRE
- en: For a `file` object, you can usually also use `with open(...)` because it is
    a context manager by itself, but if some other part of the code handles the opening,
    you don’t always have that luxury, and in those cases, you will need to close
    it yourself. Additionally, some objects such as requests made by `urllib` don’t
    support automatic closing in that manner and benefit from this function.
  prefs: []
  type: TYPE_NORMAL
- en: But wait; there’s more! In addition to being usable in a `with` statement, the
    results of a `contextmanager` are actually usable as decorators since Python 3.2\.
    In older Python versions, the `contextmanager` was simply a small wrapper, but
    since Python 3.2 it’s based on the `ContextDecorator` class, which makes it a
    decorator.
  prefs: []
  type: TYPE_NORMAL
- en: 'The `open_context_manager` context manager isn’t really suitable as a decorator
    since it has a `yield <value>` as opposed to an empty `yield` (more about that
    in *Chapter 7*, *Generators and Coroutines – Infinity, One Step at a Time*), but
    we can think of other functions:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE45]'
  prefs: []
  type: TYPE_PRE
- en: There are quite a few nice use cases for this, but at the very least, it’s just
    a convenient way to wrap a function in a context without all the (nested) `with`
    statements.
  prefs: []
  type: TYPE_NORMAL
- en: Validation, type checks, and conversions
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'While checking for types is usually not the best way to go in Python, at times
    it can be useful if you know that you will need a specific type (or something
    that can be cast to that type). To facilitate this, Python 3.5 introduced a type
    hinting system so that you can do the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE46]'
  prefs: []
  type: TYPE_PRE
- en: In some cases, it can be useful to change these hints into requirements. Instead
    of using an `isinstance()`, we will simply try to enforce the types by casting,
    which is more along the lines of duck-typing.
  prefs: []
  type: TYPE_NORMAL
- en: 'The essence of duck-typing is: if it looks like a duck, walks like a duck,
    and quacks like a duck, it might be a duck. Essentially, this means that we don’t
    care if the value is a `duck` or something else, only if it supports the `quack()`
    method that we need.'
  prefs: []
  type: TYPE_NORMAL
- en: 'To enforce the type hints, we can create a decorator:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE47]'
  prefs: []
  type: TYPE_PRE
- en: This is a fairly simple yet very versatile type enforcer that should work with
    most type annotations.
  prefs: []
  type: TYPE_NORMAL
- en: Useless warnings – How to ignore them safely
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'When writing in Python, warnings are often very useful when you’re actually
    writing the code. When executing it, however, it is not useful to get that same
    message every time you run your script/application. So, let’s create some code
    that allows easy hiding of the expected warnings, but not all of them so that
    we can easily catch new ones:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE48]'
  prefs: []
  type: TYPE_PRE
- en: Using this method, we can catch the first (expected) warning and still see the
    second (unexpected) warning.
  prefs: []
  type: TYPE_NORMAL
- en: Now that you have seen some examples of useful decorators, it is time to continue
    with a few exercises and see how much you can write yourself.
  prefs: []
  type: TYPE_NORMAL
- en: Exercises
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Decorators have a huge range of uses, so you can probably think of some yourself
    after reading this chapter, but you can easily elaborate on some of the decorators
    we wrote earlier:'
  prefs: []
  type: TYPE_NORMAL
- en: Extend the `track` function to monitor execution time.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Extend the `track` function with min/max/average execution time and call count.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Modify the memoization function to function with unhashable types.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Modify the memoization function to have a cache per function instead of a global
    one.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Create a version of `functools.cached_property` that can be recalculated as
    needed.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Create a single-dispatch decorator that considers all or a configurable number
    of arguments instead of only the first one.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Enhance the `type_check` decorator to include additional checks such as requiring
    a number to be greater than or less than a given value.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Example answers for these exercises can be found on GitHub: [https://github.com/mastering-python/exercises](Chapter_6.xhtml).
    You are encouraged to submit your own solutions and learn about alternative solutions
    from others.'
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: This chapter showed you some of the places where decorators can be used to make
    our code simpler and add some fairly complex behavior to very simple functions.
    Truthfully, most decorators are more complex than the regular function would have
    been by simply adding the functionality directly, but the added advantage of applying
    the same pattern to many functions and classes is generally well worth it.
  prefs: []
  type: TYPE_NORMAL
- en: 'Decorators have so many uses to make your functions and classes smarter and
    more convenient to use:'
  prefs: []
  type: TYPE_NORMAL
- en: Debugging
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Validation
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Argument convenience (pre-filling or converting arguments)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Output convenience (converting the output to a specific type)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The most important takeaway of this chapter should be to never forget `functools.wraps`
    when wrapping a function. Debugging decorated functions can be rather difficult
    because of (unexpected) behavior modification, but losing attributes as well can
    make that problem much worse.
  prefs: []
  type: TYPE_NORMAL
- en: The next chapter will show you how and when to use `generators` and `coroutines`.
    This chapter has already shown you the usage of the `with` statement briefly,
    but `generators` and `coroutines` go much further with this. We will still be
    using decorators often, both in this book and when using Python in general, so
    make sure you have a good understanding of how they work.
  prefs: []
  type: TYPE_NORMAL
- en: Join our community on Discord
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Join our community’s Discord space for discussions with the author and other
    readers: [https://discord.gg/QMzJenHuJf](https://discord.gg/QMzJenHuJf)'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/QR_Code156081100001293319171.png)'
  prefs: []
  type: TYPE_IMG
