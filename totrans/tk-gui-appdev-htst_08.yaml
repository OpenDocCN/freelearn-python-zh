- en: Appendix A. Miscellaneous Tips
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We are now into the final section of the book. Let's conclude by discussing
    concepts that do form a common theme in many GUI applications but did not appear
    in our applications.
  prefs: []
  type: TYPE_NORMAL
- en: Mission Briefing
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The topics covered here include:'
  prefs: []
  type: TYPE_NORMAL
- en: Tracing Tkinter variables
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Widget traversal
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Validating user input
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Formatting widget data
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: More on fonts
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Working with Unicode characters
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Tkinter class hierarchy
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Custom-made mixins
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Tips for code cleanup and program optimization
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Distributing the Tkinter application
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Limitations of Tkinter
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Tkinter alternatives
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Getting interactive help
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Tkinter in Python 3.*x*
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Tracing Tkinter variables
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: When you specify a Tkinter variable as a `textvariable` for a widget `(textvariable
    = myvar)`, the widget automatically gets updated whenever the value of the variable
    changes. However, there might be times when, in addition to updating the widget,
    you need to do some extra processing at the time of reading or writing (or modifying)
    the variable.
  prefs: []
  type: TYPE_NORMAL
- en: Tkinter provides a method to attach a callback method that would be triggered
    every time the value of a variable is accessed. Thus, the callback acts as a **variable
    observer** . The callback method is named `trace_variable(self, mode, callback)`,
    or simply `trace(self, mode, callback)`.
  prefs: []
  type: TYPE_NORMAL
- en: The mode argument can take any one of `'r'`, `'w'`, `'u'` values, which stand
    for read, write, or undefined. Depending upon the mode specifications, the callback
    method is triggered if the variable is read or written.
  prefs: []
  type: TYPE_NORMAL
- en: 'The callback method gets three arguments by default. The arguments in order
    of their position are:'
  prefs: []
  type: TYPE_NORMAL
- en: Name of the Tkinter variable
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The index of the variable, if the Tkinter variable is an array, else an empty
    string
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The access modes (`'w'`, '`r'`, or '`u'`)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Note that the triggered callback function may also modify the value of the variable.
    This modification does not, however, trigger any additional callbacks.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s see a small example of variable tracing in Tkinter, where writing into
    the Tkinter variable into an entry widget triggers a callback function (refer
    to the `8.01 trace variable.py` Python file available in the code bundle):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'The description of the preceding code is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: This code creates a trace variable on the Tkinter variable `myvar` in the write
    (`"w"`) mode
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The trace variable is attached to a callback method named `trace_when_myvar_written`
    (this means that every time the value of `myvar` is changed, the callback method
    will be triggered)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Now, every time you write into the entry widget, it modifies the value of `myvar`.
    Because we have set a trace on `myvar`, it triggers the callback method, which
    in our example, simply prints the new value into the console.
  prefs: []
  type: TYPE_NORMAL
- en: 'The code creates a GUI window similar to the one shown here:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Tracing Tkinter variables](img/7941OT_08_01.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'It also produces a console output in IDLE, which shows like the following once
    you start typing in the GUI window:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'The trace on a variable is active until it is explicitly deleted. You can delete
    a trace using:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: Widget traversal
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: When a GUI has more than one widget, a given widget can come under focus by
    an explicit mouse-click on the widget. Alternatively, the focus can be shifted
    to another given widget by pressing the *Tab* key on the keyboard in the order
    the widgets were created in the program.
  prefs: []
  type: TYPE_NORMAL
- en: It is therefore vital to create widgets in the order we want the user to traverse
    through them, or else the user will have a tough time navigating between the widgets
    using the keyboard.
  prefs: []
  type: TYPE_NORMAL
- en: Different widgets are designed to behave differently to different keyboard strokes.
    Let's therefore spend some time trying to understand the rules of traversing through
    widgets using the keyboard.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s look at the code of the `8.02 widget traversal.py` Python file to understand
    the keyboard traversal behavior for different widgets. Once you run the mentioned
    `.py` file, it shows a window something like the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Widget traversal](img/7941OT_08_02.jpg)'
  prefs: []
  type: TYPE_IMG
- en: The code is simple. It adds an entry widget, a few buttons, a few radio buttons,
    a text widget, and a scale widget. However, it also demonstrates some of the most
    important keyboard traversal behaviors for these widgets.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here are some important points to note (refer to `8.02 widget traversal.py`):'
  prefs: []
  type: TYPE_NORMAL
- en: The *Tab* key can be used to traverse forward, and *Shift* + *Tab* can be used
    to traverse backwards.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The text widget cannot be traversed using the *Tab* key. This is because the
    text widget can contain tab characters as its content. Instead, the text widget
    can be traversed using *Ctrl* + *Tab*.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Buttons on the widget can be pressed using the spacebar. Similarly, check buttons
    and radio buttons can also be toggled using the spacebar.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: You can go up and down the items in a Listbox widget using the up and down arrows.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The Scale widget responds to both the left and right keys or up and down keys.
    Similarly, the Scrollbar widget responds to both the left/right or up/down keys,
    depending on their orientation.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Most of the widgets (except Frame, Label, and Menus) get an outline by default
    when they have the focus set on them. This outline normally displays as a thin
    black border around the widget. You can even set the Frame and Label widgets to
    show this outline by specifying the `highlightthickness` option to a non-zero
    `Integer` value for these widgets.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: We change the color of the outline using `highlightcolor= 'red'` in our code.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Frame, Label, and Menu are not included in the tab navigation path. However,
    they can be included in the navigation path by using the `takefocus = 1` option.
    You can explicitly exclude a widget from the tab navigation path by setting the
    `takefocus= 0` option.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The *Tab* key traverses widgets in the order they were created. It visits a
    parent widget first (unless it is excluded using `takefocus = 0`) followed by
    all its children widgets.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: You can use `widget.focus_force()` to force the input focus to the widget.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Validating user input
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Let's now discuss input data validation.
  prefs: []
  type: TYPE_NORMAL
- en: Most of the applications we have developed in our book are point and click-based
    (drum machine, chess, drawing application), where validation of user input is
    not required.
  prefs: []
  type: TYPE_NORMAL
- en: However, data validation is a *must* in programs like our phonebook application,
    where the user enters some data, and we store it in a database.
  prefs: []
  type: TYPE_NORMAL
- en: Ignoring the user input validation can be dangerous in such applications because
    input data can be misused for SQL injection. In general, any application where
    an user can enter textual data, is a good candidate for validating user input.
    In fact, it is almost considered a maxim not to trust user inputs.
  prefs: []
  type: TYPE_NORMAL
- en: A wrong user input may be intentional or accidental. In either case, if you
    fail to validate or sanitize the data, you may cause unexpected error in your
    program. In worst cases, user input can be used to inject harmful code that may
    be capable of crashing a program or wiping out an entire database.
  prefs: []
  type: TYPE_NORMAL
- en: Widgets such as Listbox, Combobox, and Radiobuttons allow limited input options,
    and hence, cannot normally be misused to input wrong data. On the other hand,
    widgets such as Entry widget, Spinbox widget, and Text widget allow a large possibility
    of user inputs, and hence, need to be validated for correctness.
  prefs: []
  type: TYPE_NORMAL
- en: To enable validation on a widget, you need to specify an additional option of
    the form `validate = 'validationmode'` to the widget.
  prefs: []
  type: TYPE_NORMAL
- en: 'For example, if you want to enable validation on an entry widget, you begin
    by specifying the validate option as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: 'The validation can occur in one of the following **validation modes**:'
  prefs: []
  type: TYPE_NORMAL
- en: '| Validation Mode | Explanation |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| `none` | This is the default mode. No validation occurs if `validate` is
    set to `"none"` |'
  prefs: []
  type: TYPE_TB
- en: '| `focus` | When `validate` is set to `"focus"`, the `validate` command is
    called twice; once when the widget receives `focus` and once when the `focus`
    is lost |'
  prefs: []
  type: TYPE_TB
- en: '| `focusin` | The `validate` command is called when the widget receives `focus`
    |'
  prefs: []
  type: TYPE_TB
- en: '| `focusout` | The `validate` command is called when the widget loses `focus`
    |'
  prefs: []
  type: TYPE_TB
- en: '| `key` | The `validate` command is called when the entry is `edited` |'
  prefs: []
  type: TYPE_TB
- en: '| `all` | The `validate` command is called in all the above cases |'
  prefs: []
  type: TYPE_TB
- en: The code of the `8.03 validation mode demo.py` file demonstrates all these validation
    modes by attaching them to a single validation method. Note the different ways
    different Entry widgets respond to different events. Some Entry widgets call the
    validation method on focus events while others call the validation method at the
    time of entering key strokes into the widget, while still others use a combination
    of focus and key events.
  prefs: []
  type: TYPE_NORMAL
- en: 'Although we did set the validation mode to trigger the `validate` method, we
    need some sort of data to validate against our rules. This is passed to the `validate`
    method using **percent substitution**. For instance, we passed the mode as an
    argument to our `validate` method by performing a percent substitution on the
    `validate` command, as shown in the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: 'We followed by passing the value of `v` as an argument to our validate method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: 'In addition to `%V`, Tkinter recognizes the following percent substitutions:'
  prefs: []
  type: TYPE_NORMAL
- en: '| Percent substitutions | Explanation |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| `%d` | Type of action that occurred on the widget—`1` for insert, `0` for
    delete, and `-1` for focus, forced, or textvariable validation. |'
  prefs: []
  type: TYPE_TB
- en: '| `%i` | Index of `char` string inserted or deleted, if any, else it will be
    `-1`. |'
  prefs: []
  type: TYPE_TB
- en: '| `%P` | The value of the entry if the edit is allowed. If you are configuring
    the Entry widget to have a new textvariable, this will be the value of that textvariable.
    |'
  prefs: []
  type: TYPE_TB
- en: '| `%s` | The current value of entry, prior to editing. |'
  prefs: []
  type: TYPE_TB
- en: '| `%S` | The text string being inserted/deleted, if any, `{}` otherwise. |'
  prefs: []
  type: TYPE_TB
- en: '| `%v` | The type of validation currently set. |'
  prefs: []
  type: TYPE_TB
- en: '| `%V` | The type of validation that triggered the callback method (key, focusin,
    focusout, and forced). |'
  prefs: []
  type: TYPE_TB
- en: '| `%W` | The name of the Entry widget. |'
  prefs: []
  type: TYPE_TB
- en: These validations provide us with the necessary data we can use to validate
    the input.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s now pass all these data and just print them through a dummy `validate`
    method just to see the kind of data we can expect to get for carrying out our
    validations (refer to the code of `8.04 percent substitutions demo.py`):'
  prefs: []
  type: TYPE_NORMAL
- en: Tip
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Take particular note of data returned by `%P` and `%s`, because they pertain
    to the actual data entered by the user in the Entry widget.
  prefs: []
  type: TYPE_NORMAL
- en: In most cases, you will be checking either of these two data against your validation
    rules.
  prefs: []
  type: TYPE_NORMAL
- en: Now that we have a background of rules of data validation, let's see two practical
    examples that demonstrate input validation.
  prefs: []
  type: TYPE_NORMAL
- en: Key Validation
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Let''s assume that we have a form that asks for a user''s name. We want the
    user to input only alphabets or space characters in the name. Thus, any number
    or special character is not to be allowed, as shown in the following screenshot
    of the widget:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Key Validation](img/7941OT_08_03.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'This is clearly a case of `''key''` validation mode, because we want to check
    if an entry is valid after every key press. The percent substitution that we need
    to check is `%S`, because it yields the text string being inserted or deleted
    in the Entry widget. Accordingly, the code that validates the entry widget is
    as follows (refer to `8.05 key validation.py`):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: 'The description of the preceding code is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: We first register two options `validatecommand` (`vcmd`) and `invalidcommand`
    (`invcmd`).
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: In our example, `validatecommand` is registered to call the `validate_data`
    method, and the `invalidcommand` option is registered to call another method named
    `invalid_name`.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The `validatecommand` option specifies a method to be evaluated which would
    validate the input. The validation method must return a Boolean value, where a
    `True` signifies that the data entered is valid, and a `False` return value signifies
    that data is invalid.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: If the validate method returns `False` (invalid data), no data is added to the
    Entry widget and the script registered for `invalidcommand` is evaluated. In our
    case, a `False` validation would call the `invalid_name` method. The `invalidcommand`
    method is generally responsible for displaying error messages or setting back
    the focus to the Entry widget.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Let's look at the code `register(self, func, subst=None, needcleanup=1)`.
  prefs: []
  type: TYPE_NORMAL
- en: The `register` method returns a newly created `Tcl` function. If this function
    is called, the Python function `func` is executed. If an optional function `subst`
    is provided it is executed before `func`.
  prefs: []
  type: TYPE_NORMAL
- en: Focus Out Validation
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The previous example demonstrated validation in `'key'` mode. This means that
    the validation method was called after every key press to check if the entry was
    valid.
  prefs: []
  type: TYPE_NORMAL
- en: However, there are situations when you might want to check the entire string
    entered into the widget, rather than checking individual key stroke entries.
  prefs: []
  type: TYPE_NORMAL
- en: For example, if an Entry widget accepts a valid e-mail address, we would ideally
    like to check the validity after the user has entered the entire e-mail address,
    and not after every key stroke entry. This would qualify as validation in `'focusout'`
    mode.
  prefs: []
  type: TYPE_NORMAL
- en: '![Focus Out Validation](img/7941OT_08_04.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Check out the code of `8.06 focus out validation.py` for a demonstration on
    e-mail validation in the `focusout` mode:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: 'The description of the preceding code is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: 'The code has a lot of similarities to the previous validation example. However,
    note the following differences:'
  prefs: []
  type: TYPE_NORMAL
- en: The validate mode is set to `'focusout'` in contrast to the `'key'` mode in
    the previous example. This means that the validation would be done only when the
    Entry widget loses `focus`.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: This program uses data provided by the `%P` percentage substitution, in contrast
    to `%S`, as used in the previous example. This is understandable as `%P` provides
    the value entered in the Entry widget, but `%S` provides the value of the last
    key stroke.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'This program uses regular expressions to check if the entered value corresponds
    to a valid e-mail format. Validation usually relies on regular expressions and
    a whole lot of explanation to cover this topic, but it is out of the scope of
    this project and the book. For more information on regular expression modules,
    visit the following link:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[http://docs.python.org/2/library/re.html](http://docs.python.org/2/library/re.html)'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: This concludes our discussion on input validation in Tkinter. Hopefully, you
    should now be able to implement input validation to suit your custom needs.
  prefs: []
  type: TYPE_NORMAL
- en: Formatting widget data
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Several input data such as date, time, phone number, credit card number, website
    URL, IP number, and so on have an associated display format. For instance, date
    is better represented in a MM/DD/YYYY format.
  prefs: []
  type: TYPE_NORMAL
- en: Fortunately, it is easy to format the data in the required format as the user
    enters them in the widget (refer to `8.07 formatting entry widget to display date.py`).
    The mentioned Python file formats the user input automatically to insert forward
    slashes at the required places to display user-entered date in the MM/DD/YYYY
    format.
  prefs: []
  type: TYPE_NORMAL
- en: '![Formatting widget data](img/7941OT_08_05.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: 'The description of the preceding code is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: The Entry widget is bound to the key press event, where every new key press
    calls the related callback `format_date_entry_widget` method.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: First, the `format_date_entry_widget` method breaks down the entered text into
    an equivalent list by the name `entrylist`, also ignoring any slash `'/'` symbol
    if entered by the user.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: It then iterates through the `self.slashpositions` list and inserts the slash
    symbol at all required positions in the `entrylist` argument. The net result of
    this is a list that has slash inserted at all the right places.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The next line converts this list into an equivalent string using `join()`, and
    then sets the value of our Entry widget to this string. This ensures that the
    Entry widget text is formatted into the aforementioned date format.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The remaining pieces of code simply control the cursor to ensure that the cursor
    advances by one position whenever it encounters a slash symbol. It also ensures
    that key presses, such as `'BackSpace'`, `'Right'`, `'Left'`, `'Up'`, and `'Down'`
    are handled properly.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Note that this method does not validate the date value and the user may add
    any invalid date. The method defined here will simply format it by adding forward
    slash at third and sixth positions. Adding date validation to this example is
    left as an exercise for you to complete.
  prefs: []
  type: TYPE_NORMAL
- en: This concludes our brief discussion on formatting data within widgets. Hopefully,
    you should now be able to create formatted widgets for a wide variety of input
    data that can be displayed better in a given format.
  prefs: []
  type: TYPE_NORMAL
- en: More on fonts
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Many Tkinter widgets let you specify custom font specifications either at the
    time of widget creation or later using the `configure()` option. For most cases,
    default fonts provide a standard look and feel. However, should you want to change
    font specifications, Tkinter lets you do so. There is one caveat though.
  prefs: []
  type: TYPE_NORMAL
- en: When you specify your own font, you need to make sure it looks good on all platforms
    where the program is intended to be deployed. This is because a font might look
    good and match well on a particular platform, but may look awful on another. Unless
    you know what you are doing, it is always advisable to stick to Tkinter's default
    fonts.
  prefs: []
  type: TYPE_NORMAL
- en: Most platforms have their own set of standard fonts that are used by the platform's
    native widgets. So, rather than trying to reinvent the wheel on what looks good
    on a given platform or what would be available for a given platform, Tkinter assigns
    these standard platform-specific fonts into its widget, thus providing a native
    look and feel on every platform.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Tkinter assigns nine fonts to nine different names, which you can therefore
    use in your programs. The font names are as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '`TkDefaultFont`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`TkTextFont`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`TkFixedFont`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`TkMenuFont`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`TkHeadingFont`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`TkCaptionFont`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`TkSmallCaptionFont`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`TkIconFont`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`TkTooltipFont`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Accordingly, you can use them in your programs in the following way:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: Using these kinds of fonts mark up, you can be assured that your font will look
    native across all platforms.
  prefs: []
  type: TYPE_NORMAL
- en: Finer Control over Font
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'In addition to the above method on handling fonts, Tkinter provides a separate
    `Font` class implementation. The source code of this class is located at the following
    link: <`Python27_installtion_dir>\Lib\lib-tk\tkfont.py`.'
  prefs: []
  type: TYPE_NORMAL
- en: 'To use this module, you need to import `tkFont` into your namespace.(refer
    to `8.08 tkfont demo.py`):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: 'The console output of this program is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: As you can see, the `tkfont` module provides a much better fine-grained control
    over various aspects of fonts, which are otherwise inaccessible.
  prefs: []
  type: TYPE_NORMAL
- en: Font Selector
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Now that we have seen the basic features available in the `tkfont` module,
    let''s use it to implement a font selector. The font selector would look like
    the one shown here:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Font Selector](img/7941OT_08_06.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'The code for the font selector is as follows (refer to `8.09 font selector.py`):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: 'The description of the preceding code is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: We import `Tkinter` (for all widgets), `ttk` (for the Combobox widget), and
    `tkfont` for handling font-related aspects of the program
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: We create a class named `FontSelectorDemo` and use its `__init_` method to initialize
    al attributes that we intend to track in our program.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Finally, the `__init__` method calls another method named `gui_creator()`, which
    is be responsible for creating all the GUI elements of the program
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Creating the GUI
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The code represented here is a highly abridged version of the actual code (refer
    to `8.09 font selector.py`). Here, we removed all the code that creates basic
    widgets, such as Label and Checkbuttons, in order to show only the font-related
    code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: 'The description of the preceding code is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: We have highlighted the code that creates two Combobox widgets; one for the
    **Font Family**, and the other for the **Font Size** selection.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: We use `tkfont.families()` to fetch the list of all the fonts installed on a
    computer. This is converted into a list format and sorted before it is inserted
    into the `fontList` Combobox widget.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Similarly, we add a font size range of values from `6` to `70` in the **Font
    Size** combobox.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: We also add four Checkbutton widgets to keep track of font styles **bold**,
    **italics**, **underline**, and **overstrike**. The code for this has not been
    shown previously, because we have created similar check buttons in some of our
    previous programs.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: We then add a Text widget and insert a sample text into it. More importantly,
    we add a tag to the text named `fontspec`.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Finally, all our widgets have a command callback method connecting back to a
    common method named `on_value_change`. This method will be responsible for updating
    the display of the sample text at the time of changes in the values of any of
    the widgets.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Updating Sample Text
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: 'The description of the preceding code is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: This method is called at the time of a state change for any of the widgets
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: This method simply fetches all font data and configures our `currentfont` attribute
    with the updated font values
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Finally, it updates the text content tagged as `fontspec` with the values of
    the current font
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Working with Unicode characters
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Computers only understand binary numbers. Therefore, all that you see on your
    computer, for example, texts, images, audio, video, and so on need to be expressed
    in terms of binary numbers.
  prefs: []
  type: TYPE_NORMAL
- en: This is where encoding comes into play. An **encoding** is a set of standard
    rules that assign unique numeral values to each text character.
  prefs: []
  type: TYPE_NORMAL
- en: Python 2.*x* default encoding is ASCII (American Standard Code for Information
    Interchange). The ASCII character encoding is a 7-bit encoding that can encode
    2 ^7 (128) characters.
  prefs: []
  type: TYPE_NORMAL
- en: Because ASCII encoding was developed in America, it encodes characters from
    the English alphabet, namely, the numbers 0-9, the letters a-z and A-Z, some common
    punctuation symbols, some teletype machine control codes, and a blank space.
  prefs: []
  type: TYPE_NORMAL
- en: 'It is here that Unicode encoding comes to our rescue. The following are the
    key features of Unicode encoding:'
  prefs: []
  type: TYPE_NORMAL
- en: It is a way to represent text without bytes
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: It provides unique code point for each character of every language
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: It defines more than a million code points, representing characters of all major
    scripts on the earth
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Within Unicode, there are several **Unicode Transformation Formats** (**UTF**)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: UTF-8 is one of the most commonly used encodings, where **8** means that 8-bit
    numbers are used in the encoding
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Python also supports UTF-16 encoding, but it's less frequently used, and UTF-32
    is not supported by Python 2.*x*
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Say you want to display a Hindi character on a Tkinter Label widget. You would
    intuitively try to run a code like the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: 'If you try to run the previous code, you will get an error message as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: This means that Python 2.*x*, by default, cannot handle non-ASCII characters.
    Python standard library supports over 100 encodings, but if you are trying to
    use anything other than ASCII encoding you have to explicitly declare the encoding.
  prefs: []
  type: TYPE_NORMAL
- en: 'Fortunately, handling other encodings is very simple in Python. There are two
    ways in which you can deal with non-ASCII characters. They are described in the
    following sections:'
  prefs: []
  type: TYPE_NORMAL
- en: Declaring line encoding
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The first way is to mark a string containing Unicode characters with the prefix
    `u` explicitly, as shown in the following code snippet (refer to `8.10 line encoding.py`):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: 'When you try to run this program from IDLE, you get a warning message similar
    to the following one:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Declaring line encoding](img/7941OT_08_07.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Simply click on **Ok** to save this file as UTF-8 and run this program to display
    the Unicode label.
  prefs: []
  type: TYPE_NORMAL
- en: Declaring file encoding
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Alternatively, you can explicitly declare the entire file to have UTF-8 encoding
    by including a header declaration in your source file in the following format:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: 'More precisely, the header declaration must match the regular expression:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: This declaration must be included in either the first or second line of your
    program. If you add some other declaration or comments in the first two lines,
    Python won't recognize this as a header declaration.
  prefs: []
  type: TYPE_NORMAL
- en: 'So, if you are dealing with UTF-8 characters, you will add the following header
    declaration in the first or second line of your Python program:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: 'Simply by adding this header declaration, your Python program can now recognize
    Unicode characters. So, our code can be rewritten as (refer to `8.11 file encoding.py`):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: 'Both of the above code examples generate an interface similar to the one shown
    here:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Declaring file encoding](img/7941OT_08_08.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The default encoding in Python 3.*x* is Unicode (UTF-8). This means that you
    don't need an explicit Unicode declaration in Python 3.*x* to display non-ASCII
    characters.
  prefs: []
  type: TYPE_NORMAL
- en: Tkinter class's hierarchy
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: As programmers, we hardly need to understand the class hierarchy of Tkinter.
    After all, we have been able to code all the applications so far without bothering
    about the overall class hierarchy.
  prefs: []
  type: TYPE_NORMAL
- en: However, knowing about class hierarchy enables us to trace the origin of a method
    within the source code or source documentation of a method. A brief review of
    the class hierarchy will also help us prevent accidental overriding of methods
    in our programs.
  prefs: []
  type: TYPE_NORMAL
- en: In order to understand the class hierarchy of Tkinter, let us take a look at
    the source code of Tkinter. On Windows installation, the source code of Tkinter
    is located at `C:\Python27\Lib\lib-tk\Tkinter.py`.
  prefs: []
  type: TYPE_NORMAL
- en: 'When we open this file in a code editor and look at its list of class definitions,
    we can see the following structure:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Tkinter class''s hierarchy](img/7941OT_08_09.jpg)'
  prefs: []
  type: TYPE_IMG
- en: So, what do we notice here? We have class definitions for each of the core Tkinter
    widgets. In addition, we have class definitions for different geometry managers
    and different variable types defined within Tkinter. These class definitions are
    what you would normally expect to be there.
  prefs: []
  type: TYPE_NORMAL
- en: However, in addition to these, we notice some strange-looking class names, such
    as `BaseWidget, Misc, Tk,` `Toplevel, Widget`, and `Wm`. All these classes are
    circled in the above screenshot. So what services do these classes provide, and
    where do they fit in the larger scheme of things?
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s use the `inspect` module to look at the class hierarchy of Tkinter.
    We will first inspect the class hierarchy of the Frame widget as a representation
    of class hierarchies for all other widgets. We will also look at the class hierarchy
    of the `Tk` and `Toplevel` classes to estimate their role in the overall class
    hierarchy of Tkinter (refer to `8.12 tkinter class hierarchy.py`):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: 'The output of the preceding program is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: 'The description of the preceding code is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: The `getmro(classname)` function from the inspect module returns a tuple, consisting
    of all the ancestors of `classname` in the order specified by the **Method Resolution
    Order** (**MRO**). Method Resolution Order refers to the order in which base classes
    are searched when looking for a given method.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: By inspecting the MRO and the source code, we come to know that the `Frame`
    class inherits from the `Widget` class, which in turn inherits from the `BaseWidget`
    class.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: In addition, the `Frame` class also inherits from the `Misc` class, which is
    a generic **mixin** that provides a lot of functionality that we have used in
    our applications.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'For a list of functionalities provided by the `Misc` class, run the following
    commands into your Python interactive shell:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Finally, all our widgets get properties from the geometry mixins—Pack, Grid,
    and Place.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Next, let us take a look at the `Tk` and `Toplevel` classes.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The `Tk` class represents the Toplevel widget of Tkinter, which represents the
    main window of an application. The `Toplevel` class provides several methods for
    constructing and managing a Toplevel widget with a given parent.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'For a list of methods provided by the `Toplevel` and `Tk` classes, run the
    following commands into your Python interactive shell:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: In addition to inheriting from the `Misc` mixin class, the `Toplevel` and `Tk`
    classes also inherit methods from the `Wm` mixin class.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The `Wm` (window manager) mixin class provides a lot of functions to communicate
    with the window manager. For a list of functions provided by the `Wm` class, run
    the following command into your Python interactive shell:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'After translating the class hierarchy—as obtained from the previous program—into
    an image, we get a hierarchy image similar to the one shown in the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Tkinter class''s hierarchy](img/7941OT_08_10.jpg)'
  prefs: []
  type: TYPE_IMG
- en: In addition to the normal inheritance relation (shown in the preceding diagram
    by unspotted lines), Tkinter provides a list of mixins (or helper classes). A
    **mixin** is a class that is designed not to be used directly, but to be combined
    with other classes using multiple inheritances.
  prefs: []
  type: TYPE_NORMAL
- en: 'Tkinter mixins can be broadly classified into two categories:'
  prefs: []
  type: TYPE_NORMAL
- en: Geometry mixins, which includes the Grid, Pack, and Place classes
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Implementation mixins, which includes:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The `Misc` class, which is used by the root window and widget classes, provides
    several Tk and window-related services
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: The `Wm` class, which is used by the root window and the Toplevel widget, provides
    several window manager services.
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: Custom-made mixins
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'We created a "bare bone" GUI framework in order to avoid repetition of the
    code that creates widgets. Similar to this concept, there is another way to avoid
    writing boilerplate code by using what are named **custom GUI mixins**. Take for
    example, the code of `8.13 creating custom mixins.py`. This program creates an
    interface similar to the one shown here:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Custom-made mixins](img/7941OT_08_11.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Let''s look at the code of `8.13 creating custom mixins.py`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: 'The description of the preceding code is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: This program first creates functions for different widgets, such as Frame, Label,
    Button, and Entry. Each method can be named a mixin, because it takes care of
    both widget creation and its geometry management using the grid method. These
    are essentially convenience functions to help us avoid writing similar code for
    a similar set of widgets.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Now, in the main section of the program, we can create a widget in a single
    line of code without having to add a separate line for handling its geometry.
    The end result of this is fewer lines of code in our actual program. This strategy
    can reduce the size of your program by many lines if there are a large number
    of widgets in your program.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_IND
  - PREF_H3
  type: TYPE_NORMAL
- en: However, mixins are highly case specific. A mixin defined for one particular
    case scenario or application may not be applicable to another application. For
    instance, while defining the earlier mentioned mixins, we made a few assumptions,
    such as all our widgets will use the grid geometry manager, and similarly, buttons
    would stick to east and entries would stick to the west side. These assumptions
    may not hold for a different application.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Tips for code cleanup and program optimization
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Let's now spend some time discussing the tips and tricks that will help improve
    the performance of our Python program. In a normal case scenario of GUI programming,
    this generally involves speeding up sections of program that contribute to improving
    the overall user experience.
  prefs: []
  type: TYPE_NORMAL
- en: Program optimization is often obsessively taken as an exercise in reducing code
    execution time. For programs where timing is a crucial factor, this obsession
    is genuine. However, if you are developing a simple GUI application, a correct
    and consistent user experience is generally more important than mere fast user
    experience.
  prefs: []
  type: TYPE_NORMAL
- en: Trying to optimize a code even before it is functional is premature optimization
    and should be avoided. However, a GUI program with correct but considerably long
    response time probably needs to be optimized, and this is the subject of discussion
    of the following sections.
  prefs: []
  type: TYPE_NORMAL
- en: Choose the right data structure
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Selecting the right data structure can have a profound impact on the performance
    of a program. If your program is to spend considerable time on lookups, use a
    dictionary, if feasible. When all you need is to traverse over a collection, prefer
    to choose a list over dictionaries, because dictionaries take more space.
  prefs: []
  type: TYPE_NORMAL
- en: When your data is immutable, prefer to choose tuples over lists, because tuples
    can be traversed faster than lists.
  prefs: []
  type: TYPE_NORMAL
- en: Working with Variables
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The way you select variables in your program can considerably affect the speed
    of the execution of your program. For instance, if you do not need to change the
    content or attributes of a widget after its instantiation, do not create a class-wide
    instance of the widget.
  prefs: []
  type: TYPE_NORMAL
- en: 'For example, if a Label widget is to remain static, use `Label(root, text=''Name'').pack(side=LEFT)`,
    instead of using the following snippet:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: 'Similarly, do not create local variables if you are not going to use them more
    than once. For example, use `mylabel.config (text= event.keysym)` instead of first
    creating a local variable `key` and then using it only once:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: If the local variable is to be used more than once, it may make sense to create
    a local variable.
  prefs: []
  type: TYPE_NORMAL
- en: Using Exceptions
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Now here is a small caveat. In order to concentrate on illustrating core Tkinter
    concepts, we have deliberately ignored the clean exception handling in all our
    examples in this book.
  prefs: []
  type: TYPE_NORMAL
- en: We have implemented a "catch all errors" exception using simple try-except blocks
    in most of our projects. However, when programming your applications, you would
    ideally want to be as specific as possible about the exception you want to handle.
  prefs: []
  type: TYPE_NORMAL
- en: Python follows the EAFP (easier to ask for forgiveness than permission) style
    of coding, as opposed to the LBYL (look before you leap) style followed by most
    other programming languages.
  prefs: []
  type: TYPE_NORMAL
- en: 'Thus, using exception handling similar to the following one is normally cleaner
    in Python than checking conditions using the if-then block:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: 'An example of an if-then block is shown in the following code snippet:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: Filter and map
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Python provides two built-in functions named `filter` and `map` to manipulate
    lists directly, rather than having to directly iterate over each item in the list.
    The `filter`, `map`, and `reduce` functions are faster than using loops, because
    a lot of the work is done by the underlying code written in C.
  prefs: []
  type: TYPE_NORMAL
- en: 'Filter: The `filter(function, list)` function returns a list (iterators in
    Python 3.*x*) that contains all the items for which the function returns a true
    value. For example:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: This is faster than running a conditional if-then check against the list.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Map: The `map(func, list)` function applies `func` to each item in the list
    and returns the values in a new list (returns iterators instead of lists in Python
    3.*x*). For example:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: This again is faster than running the list through a loop, adding `5` to each
    element.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Profiling
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '**Profiling** involves generating detailed statistics to show how often and
    for how long various routines of a program execute. This helps is isolating offending
    parts of a program, and those parts probably need redesigning.'
  prefs: []
  type: TYPE_NORMAL
- en: Python 2.7.*x* provides a built-in module named `cProfile`, which enables generation
    of detailed statistics about a program. The module gives details such as the total
    program-running time, time taken to run each function, and the number of times
    each function is called. These statistics make it easy to determine the parts
    of code that need optimization.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'In particular, **cProfile** provides the following data for a function or script:'
  prefs: []
  type: TYPE_NORMAL
- en: '**ncalls**: The number of times a function is called'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**tottime**: The time spent on a function, excluding time spent on calling
    other functions'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**percall**: `tottime` divided by ncalls'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**cumtime**: The time spent on a function, including calls to other functions'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**percall**: `cumtime` divided by `tottime`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'You can profile an individual function with the help of this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs: []
  type: TYPE_PRE
- en: 'You can then view the results of profiling using another module called `pstats`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs: []
  type: TYPE_PRE
- en: 'More importantly, you can profile an entire script. Let''s say you want to
    profile a script named `myscript.py`. You simply navigate to the directory of
    the script using a command-line tool, and then type and run:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs: []
  type: TYPE_PRE
- en: 'This produces an output similar to the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE37]'
  prefs: []
  type: TYPE_PRE
- en: After this, you can analyze the code to see the functions that take more time
    to execute. In our hypothetical example in the preceding output, we notice that
    the functions `findAudio` and `saveAudio` take the maximum time to execute. We
    can then analyze these two functions to see if they can be optimized.
  prefs: []
  type: TYPE_NORMAL
- en: In addition to the cProfile module, there are other modules, such as **PyCallGraph**
    and **objgraph** , and they provide visual graphs for profile data.
  prefs: []
  type: TYPE_NORMAL
- en: Other Optimization Tips
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Optimization is a vast topic and there is a lot that you can do. If you are
    interested in knowing more about code optimization, you might start with the official
    Python optimization tips at the following link:'
  prefs: []
  type: TYPE_NORMAL
- en: '[http://wiki.python.org/moin/PythonSpeed/PerformanceTips](http://wiki.python.org/moin/PythonSpeed/PerformanceTips)'
  prefs: []
  type: TYPE_NORMAL
- en: Distributing the Tkinter application
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: So, you have your new application ready and now you want to share it with the
    rest of the world. How do you do that?
  prefs: []
  type: TYPE_NORMAL
- en: Of course, you need Python installation for your program to run. Windows does
    not come with preinstalled Python. Most modern Linux distributions and Mac OS
    X come preinstalled with Python, but you don't just need any version of Python.
    You need a version of Python that is compatible with the version on which the
    program was originally written.
  prefs: []
  type: TYPE_NORMAL
- en: And then, if your program uses third-party modules, you need the appropriate
    module installed for the required Python version. Sure this is too much diversity
    to handle.
  prefs: []
  type: TYPE_NORMAL
- en: Fortunately, we have tools, such as **Freeze** tools, which allows us to distribute
    Python programs as standalone applications.
  prefs: []
  type: TYPE_NORMAL
- en: Given the diversity of platforms to be handled, there is a large number of Freeze
    tool options from which to choose. Therefore, a detailed discussion on any one
    of the tools is beyond the scope of this book.
  prefs: []
  type: TYPE_NORMAL
- en: We will list some of the most evolved freezing tools in the following sections.
    If you find a tool fitting into your distribution requirement, you can look at
    its documentation for more information.
  prefs: []
  type: TYPE_NORMAL
- en: py2exe
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: If you only need to distribute your Python application on Windows, **py2exe**
    is perhaps the most hardened tool. It converts Python programs into executable
    Windows programs that can run without requiring a Python installation. More information,
    a download link, and tutorials are available at [http://www.py2exe.org/](http://www.py2exe.org/).
  prefs: []
  type: TYPE_NORMAL
- en: py2app
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '**py2app** performs the same tasks in Mac OS X that py2exe does for Windows.
    If you just need to distribute your Python application on Mac OS X, py2app is
    a time-tested tool. More information is available at [http://svn.pythonmac.org/py2app/py2app/trunk/doc/index.html](http://svn.pythonmac.org/py2app/py2app/trunk/doc/index.html).'
  prefs: []
  type: TYPE_NORMAL
- en: PyInstaller
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '**PyInstaller** has gained popularity as a freezing tool in the last few years
    partly because it supports a wide variety of platforms, such as Windows, Linux,
    Mac OS X, Solaris, and AIX.'
  prefs: []
  type: TYPE_NORMAL
- en: In addition, executables created using PyInstaller are claimed to take less
    space than other freezing tools because it uses transparent compression. Another
    important feature of PyInstaller is its out of the box compatibility with a large
    number of third-party packages.
  prefs: []
  type: TYPE_NORMAL
- en: The full list of features, downloads, and documentation can be assessed at [http://www.pyinstaller.org/](http://www.pyinstaller.org/).
  prefs: []
  type: TYPE_NORMAL
- en: Other Freezing Tools
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Other freezing tool include:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Freeze: This tool ships with standard Python distribution. Freeze can be used
    to compile executables only on Unix systems. However, the program is overly simplistic,
    as it fails to handle even the common third-party libraries. More information
    is available at this link:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[http://wiki.python.org/moin/Freeze](http://wiki.python.org/moin/Freeze)'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'cx_Freeze: This tool is similar to py2exe and py2app, but claims to be portable
    across all platforms on which that Python itself works. More information is available
    at this link:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[http://cx-freeze.sourceforge.net/index.html](http://cx-freeze.sourceforge.net/index.html)'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Tip
  prefs:
  - PREF_IND
  - PREF_H3
  type: TYPE_NORMAL
- en: If you're distributing a small program, a freeze tool might be just what you
    need. However, if you have a large program, say, with lots of external third-party
    library dependencies or dependencies not supported by any existing freezing tool,
    your application might be the right candidate for bundling the Python interpreter
    with your application.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Limitations of Tkinter
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We have already explored the power of Tkinter. Perhaps the greatest power of
    Tkinter lies in its ease of use and a lightweight footprint.
  prefs: []
  type: TYPE_NORMAL
- en: However, ease of use and lightweightiness of Tkinter also result in some limitations.
  prefs: []
  type: TYPE_NORMAL
- en: Limited number of core widgets
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Tkinter provides only a small number of basic widgets, and lacks a collection
    of more modern widgets. It needs `ttk`, `Pmw`, `Tix`, and other extensions to
    provide some really useful widgets. Even with these extensions, Tkinter fails
    to match the range of widgets provided by other GUI tools, such as **wxPython**
    advanced widget set and **PyQt**.
  prefs: []
  type: TYPE_NORMAL
- en: For instance, wxPython's HtmlWindow widget lets the user display HTML content
    with ease. There have been attempts to provide similar extensions in Tkinter,
    but they are far from satisfactory. Similarly, there are other widgets from Advanced
    User Interface Library and mixins in wxPython, such as floating/docking frames,
    perspective loading and saving, and others, which Tkinter users can only hope
    to be included in future releases.
  prefs: []
  type: TYPE_NORMAL
- en: Tkinter supporters often tend to refute this criticism by citing how easily
    you can construct new widgets from a collection of basic widgets.
  prefs: []
  type: TYPE_NORMAL
- en: No Support for printing
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Tkinter is rightfully criticized for providing no support for printing features.
    Compare this to wxPython, which provides a complete printing solution in the form
    of a printing framework.
  prefs: []
  type: TYPE_NORMAL
- en: No support for newer image formats
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Tkinter natively does not support image formats such as JPEG and PNG. The `PhotoImage`
    class of Tkinter can read images only in GIF and PGM/PPM formats.
  prefs: []
  type: TYPE_NORMAL
- en: Although there are workarounds, such as using ImageTk and Image submodules from
    the PIL module, it would have been better if Tkinter natively supported the popular
    image formats.
  prefs: []
  type: TYPE_NORMAL
- en: Inactive development community
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Tkinter is often criticized as having a relatively inactive development community.
    This is true to a large extent. The documentation of Tkinter has remained a work-in-progress
    for many years now.
  prefs: []
  type: TYPE_NORMAL
- en: A large number of Tkinter extensions appeared over the years, but most of them
    have not been under active development for a long time.
  prefs: []
  type: TYPE_NORMAL
- en: Tkinter supporters refute this with the logic that Tkinter is a stable and mature
    technology that does not need frequent revisions like some other GUI modules that
    are being newly developed.
  prefs: []
  type: TYPE_NORMAL
- en: Alternatives to Tkinter
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In addition to Tkinter, there are several other popular Python GUI toolkits.
    Most popular ones include wxPython, PyQt, **PySide**, and **PyGTK**. Here's a
    brief discussion on these toolkits.
  prefs: []
  type: TYPE_NORMAL
- en: wxPython
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: wxPython is aPython interface to **wxWidgets**, a popular open source GUI library.
    Code written in wxPython is portable across most major platforms such as Windows,
    Linux, and Mac OS X.
  prefs: []
  type: TYPE_NORMAL
- en: The wxPython interface is generally considered better than Tkinter at building
    more complex GUIs primarily because it has a large base of natively supported
    widgets. However, Tkinter supporters do contest this claim.
  prefs: []
  type: TYPE_NORMAL
- en: The wxWidgets interface is originally written in C++ programming language, and
    hence, wxPython inherits a large portion of the complexity that is typical of
    C++ programs. wxPython provides a very large base of classes, and it often takes
    more code to produce the same interface than it would take in Tkinter. However,
    in exchange for this complexity, wxPython provides a larger base of built-in widgets
    than Tkinter. Moreover, some people prefer the appearance of wxPython widgets
    over that rendered by Tkinter.
  prefs: []
  type: TYPE_NORMAL
- en: Owing to its inherent complexity, wxPython has seen the emergence of several
    GUI builder toolkits, such as **wxGlade**, **wxFormBuilder**, **wxDesigner**,
    and so on.
  prefs: []
  type: TYPE_NORMAL
- en: 'The wxPython installation comes with demo programs that can help you get started
    with the toolkit quickly. To download the toolkit or for more information on wxPython,
    visit the following link:'
  prefs: []
  type: TYPE_NORMAL
- en: '[http://wxpython.org/](http://wxpython.org/)'
  prefs: []
  type: TYPE_NORMAL
- en: PyQt
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: PyQt is a Python interface of the cross-platform GUI toolkit Qt, a project currently
    developed and maintained by British firm Riverbank Computing.
  prefs: []
  type: TYPE_NORMAL
- en: PyQt, with several hundred classes and thousands of functions is perhaps the
    most fully-featured GUI library that is currently available for GUI programming
    in Python. However, this feature load brings in a lot of complexity and a steep
    learning curve.
  prefs: []
  type: TYPE_NORMAL
- en: Qt (and hence pyQt) has a very rich set of supported widgets. In addition, it
    includes built-in support for network programming, SQL databases, threads, multimedia
    framework, regular expressions, XML, SVG, and much more. The designer feature
    of Qtletsus generates GUI code from a WYSIWYG (What You See Is What You Get) interface.
  prefs: []
  type: TYPE_NORMAL
- en: PyQt is available under variety of licenses including **GNU**, **General Public
    License** (**GPL**), and commercial license. However, its greatest disadvantage
    is that unlike Qt, it is unavailable under the LGPL.
  prefs: []
  type: TYPE_NORMAL
- en: PySide
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'If you are looking for a LGPL version of Qt bindings for Python, you may want
    to explore PySide. PySide was originally released under the LGPL in August 2009
    by Nokia, the former owners of the **Qttoolkit** . It is now owned by Digia. More
    information on PySide can be obtained from the following link:'
  prefs: []
  type: TYPE_NORMAL
- en: '[http://qt-project.org/wiki/PySide](http://qt-project.org/wiki/PySide)'
  prefs: []
  type: TYPE_NORMAL
- en: PyGTK
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '**PyGTK** is a collection of Python bindings for the GTK + GUI library. PyGTK
    applications are cross-platform, and can run on Windows, Linux, MacOS X, and others.
    PyGTK is a free software and licensed under the LGPL. You can therefore use, modify,
    and distribute it with very little restrictions.'
  prefs: []
  type: TYPE_NORMAL
- en: 'More information about PyGTK can be obtained at the following link:'
  prefs: []
  type: TYPE_NORMAL
- en: '[http://www.pygtk.org/](http://www.pygtk.org/)'
  prefs: []
  type: TYPE_NORMAL
- en: Other Options
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Besides these most popular toolkits, there is a range of toolkits available
    for GUI programming in Python.
  prefs: []
  type: TYPE_NORMAL
- en: Java programmers who are comfortable with Java GUI libraries, such as swing
    and AWT, can seamlessly access these libraries by using **Jython** . Similarly
    C# programmers can use **IronPython** to access GUI construction features from
    the .NET framework.
  prefs: []
  type: TYPE_NORMAL
- en: 'For a comprehensive list of other GUI tools available to a Python developer
    visit this link:'
  prefs: []
  type: TYPE_NORMAL
- en: '[http://wiki.python.org/moin/GuiProgramming](http://wiki.python.org/moin/GuiProgramming)'
  prefs: []
  type: TYPE_NORMAL
- en: Getting interactive help
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: This section is not just true about Tkinter, but for any Python object for which
    you need help.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s say you need a reference on Tkinter Pack geometry manager, you can get
    interactive help in your Python interactive shell using the help command, as shown
    in the following command lines:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE38]'
  prefs: []
  type: TYPE_PRE
- en: This provides a detailed help documentation on all the methods defined under
    the `Pack` class in Tkinter.
  prefs: []
  type: TYPE_NORMAL
- en: 'You can similarly view help for all other individual widgets. For instance,
    you can check comprehensive and authoritative help documentation for Label widget
    in the interactive shell by typing:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE39]'
  prefs: []
  type: TYPE_PRE
- en: 'This provides a list of:'
  prefs: []
  type: TYPE_NORMAL
- en: All methods defined in class `Label`
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: All standard and widget specific options for Label widget
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: All methods inherited from other classes
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Finally, when in doubt about a method, look into the source file located at
    <`location-of-python-installation>\lib\lib-tk\Tkinter.py`.
  prefs: []
  type: TYPE_NORMAL
- en: Tip
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'The `lib-tk` directory is the home to some great Tkinter code that you can
    study. In particular, you may also want to take a look at the source code of:'
  prefs: []
  type: TYPE_NORMAL
- en: 'turtle.py: A popular way to introduce programming to kids. It includes some
    cool animated effects'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Tkdnd.py: An experiment code that lets you drag and drop items on the Tkinter
    window.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: You might also find it useful to look at the source code implementation of various
    other modules, such as the color chooser, file dialogs, ttk module, and others.
  prefs: []
  type: TYPE_NORMAL
- en: Tkinter in Python 3.*x*
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In 2008, Guido van Rossum, the author of Python, forked the language into two
    branches—2.*x*, and 3.*x*. This was done to clean up and make the language more
    consistent.
  prefs: []
  type: TYPE_NORMAL
- en: Python 3.*x* broke backward compatibility with the Python 2.*x*. For example,
    the print statement in Python 2.*x* was replaced by `print()` function that would
    now take arguments as parameters.
  prefs: []
  type: TYPE_NORMAL
- en: We coded all our Tkinter programs in Python Version 2.7, because it has a richer
    set of third-party libraries than Python 3.*x*, which is still considered a developing
    version.
  prefs: []
  type: TYPE_NORMAL
- en: The core functionality of Tkinter remains the same between 2.*x*, and 3.*x*.
    The only significant change to Tkinter when moving from Python 2.*x* to Python
    3.*x* involves changing the way Tkinter modules are imported.
  prefs: []
  type: TYPE_NORMAL
- en: '**Tkinter** has been renamed to **tkinter** in Python 3.*x* (capitalization
    has been removed). Note that in 3.*x*, the directory `lib-tk` was renamed to `tkinter`.
    Inside the directory, the file `Tkinter.py` was renamed to `__init__.py`, thus
    making tkinter an importable module.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Accordingly, the biggest major difference lies in the way you import the Tkinter
    module into your current namespace:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE40]'
  prefs: []
  type: TYPE_PRE
- en: 'Further, take a note of the following changes:'
  prefs: []
  type: TYPE_NORMAL
- en: '| Python 2.x | Python 3.x |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| `import ttk` | `import tkinter.ttk OR``from tkinter import ttk` |'
  prefs: []
  type: TYPE_TB
- en: '| `import tkMessageBox` | `import tkinter.messagebox` |'
  prefs: []
  type: TYPE_TB
- en: '| `import tkColorChooser` | `import tkinter.colorchooser` |'
  prefs: []
  type: TYPE_TB
- en: '| `import tkFileDialog` | `import tkinter.filedialog` |'
  prefs: []
  type: TYPE_TB
- en: '| `import tkSimpleDialog` | `import tkinter.simpledialog` |'
  prefs: []
  type: TYPE_TB
- en: '| `import tkCommonDialog` | `import tkinter.commondialog` |'
  prefs: []
  type: TYPE_TB
- en: '| `import tkFont` | `import tkinter.font` |'
  prefs: []
  type: TYPE_TB
- en: '| `import ScrolledText` | `import tkinter.scrolledtext` |'
  prefs: []
  type: TYPE_TB
- en: '| `import Tix` | `import tkinter.tix` |'
  prefs: []
  type: TYPE_TB
- en: Conclusion
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'To conclude, let''s summarize some of the key steps involved in designing an
    application:'
  prefs: []
  type: TYPE_NORMAL
- en: Depending on what you want to design, choose a suitable data structure to represent
    your needs logically.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: If required, combine primitive data structures to form complex structures like,
    say, a list of dictionaries or a tuple of dictionaries.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Create classes for objects that constitute your application. Add attributes
    that need to be manipulated and methods to manipulate those attributes.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Manipulate attributes using different API provided by a rich set of Python standard
    and external libraries.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: We tried to build several partly-functional applications in this book. And then
    we put up an explanation for the code. However, when you try to explain a software
    development process in a sequential text, you sometimes mislead your readers to
    imply that development of software programs is a linear process. This is hardly
    true.
  prefs: []
  type: TYPE_NORMAL
- en: Actual programming doesn't usually work this way. In fact, small-to-medium-sized
    programs are normally written in an incremental trial and error process where
    assumptions get changed and structures modified throughout the course of application
    development.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here is how you would develop a small to medium application:'
  prefs: []
  type: TYPE_NORMAL
- en: Start with a simple script.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Set a small achievable goal, implement it, and then think of adding the next
    feature to your program in an incremental fashion.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: You may or may not introduce a class structure initially. If you are clear about
    the problem domain, you may introduce the class structure right from the very
    beginning.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: If you are not sure about the class structure initially, start with simple procedural
    code. As your program starts to grow, you will probably start getting lot of global
    variables. It is here that you will start getting a glimpse of the structural
    dimensions of your program. It is now time to refactor and restructure your program
    to introduce a class structure.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Tip
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: If you are writing a small program, the evolutionary **trial and error** strategy
    works well.
  prefs: []
  type: TYPE_NORMAL
- en: If, however, you get into developing medium to large-scale applications, it
    is better to do some serious upfront planning before you sit down to write your
    code, because the cost of failure of a large program is way higher than what we
    can generally afford.
  prefs: []
  type: TYPE_NORMAL
- en: An analogy would explain this better. You can build a small shed on a trial
    and error basis, but you would not attempt to build a skyscraper without some
    serious planning.
  prefs: []
  type: TYPE_NORMAL
- en: It is also important not to be unnecessarily bogged down by ever evolving jargons
    in the technical world. Programming is less about knowing a particular API or
    even a particular programming language. You can literally get to know the basic
    constructs of a programming language in a small sitting. Programming is rather
    a tool for finding solution to your immediate problems.
  prefs: []
  type: TYPE_NORMAL
- en: That brings us to the end of the book. I hope this book has taught you something
    about GUI programming with Python and Tkinter.
  prefs: []
  type: TYPE_NORMAL
- en: Beyond reading books, there is really no substitute for doing some original
    GUI programming. So, take up an original programming challenge and execute it
    for the fun of it.
  prefs: []
  type: TYPE_NORMAL
- en: How you implement it is a matter of individual experiences and taste. Do what
    feels comfortable to you, but keep yourself open to the idea of continuous refactoring
    at every stage of development.
  prefs: []
  type: TYPE_NORMAL
