<html><head></head><body>
        <section>

                            <header>
                    <h1 class="header-title">When Objects Are Alike</h1>
                </header>
            
            <article>
                
<p>In the programming world, duplicate code is considered evil. We should not have multiple copies of the same, or similar, code in different places.</p>
<p>There are many ways to merge pieces of code or objects that have a similar functionality. In this chapter, we'll be covering the most famous object-oriented principle: inheritance. As discussed in <a href="f3a06c74-ab7f-450f-9663-bfe014b359bf.xhtml"><span class="ChapterrefPACKT">Chapter 1</span></a>, <em>Object-Oriented Design</em>, inheritance allows us to create is a relationships between two or more classes, abstracting common logic into superclasses and managing specific details in the subclass. In particular, we'll be covering the Python syntax and principles for the following:</p>
<ul>
<li>Basic inheritance</li>
<li>Inheriting from built-in types</li>
<li>Multiple inheritance</li>
<li>Polymorphism and duck typing</li>
</ul>
<p class="mce-root"/>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Basic inheritance</h1>
                </header>
            
            <article>
                
<p>Technically, every class we create uses inheritance. All Python classes are subclasses of the special built-in class named <kbd>object</kbd>. This class provides very little in terms of data and behaviors (the behaviors it does provide are all double-underscore methods intended for internal use only), but it does allow Python to treat all objects in the same way.</p>
<p>If we don't explicitly inherit from a different class, our classes will automatically inherit from <kbd>object</kbd>. However, we can openly state that our class derives from <kbd>object</kbd> using the following syntax:</p>
<pre>class MySubClass(object): 
    pass </pre>
<p>This is inheritance! This example is, technically, no different from our very first example in <a href="0786c893-abb9-4f35-9320-3f2f54de95eb.xhtml"><span class="ChapterrefPACKT">Chapter 2</span></a>, <em>Objects in Python</em>, since Python 3 automatically inherits from <kbd>object</kbd> if we don't explicitly provide a different <strong>superclass</strong>. A superclass, or parent class, is a class that is being inherited from. A subclass is a class that is inheriting from a superclass. In this case, the superclass is <kbd>object</kbd>, and <kbd>MySubClass</kbd> is the subclass. A subclass is also said to be derived from its parent class or that the subclass extends the parent.</p>
<p>As you've probably figured out from the example, inheritance requires a minimal amount of extra syntax over a basic class definition. Simply include the name of the parent class inside parentheses between the class name and the colon that follows. This is all we have to do to tell Python that the new class should be derived from the given superclass.</p>
<p>How do we apply inheritance in practice? The simplest and most obvious use of inheritance is to add functionality to an existing class. Let's start with a simple contact manager that tracks the name and email address of several people. The <kbd>Contact</kbd> class is responsible for maintaining a list of all contacts in a class variable, and for initializing the name and address for an individual contact:</p>
<pre>class Contact:<br/>    all_contacts = []<br/><br/>    def __init__(self, name, email):<br/>        self.name = name<br/>        self.email = email<br/>        Contact.all_contacts.append(self)</pre>
<p>This example introduces us to <strong>class variables</strong>. The <kbd>all_contacts</kbd> list, because it is part of the class definition, is shared by all instances of this class. This means that there is only one <kbd>Contact.all_contacts</kbd> list. We can also access it as <kbd>self.all_contacts</kbd> from within any method on an instance of the <kbd>Contact</kbd> class. If a field can't be found on the object (via <kbd>self</kbd>), then it will be found on the class and will thus refer to the same single list.</p>
<div class="packt_tip">Be careful with this syntax, for if you ever <em>set</em> the variable using <kbd>self.all_contacts</kbd>, you will actually be creating a <strong>new</strong> instance variable associated just with that object. The class variable will still be unchanged and accessible as <kbd>Contact.all_contacts</kbd>.</div>
<p>This is a simple class that allows us to track a couple of pieces of data about each contact. But what if some of our contacts are also suppliers that we need to order supplies from? We could add an <kbd>order</kbd> method to the <kbd>Contact</kbd> class, but that would allow people to accidentally order things from contacts who are customers or family friends. Instead, let's create a new <kbd>Supplier</kbd> class that acts like our <kbd>Contact</kbd> class, but has an additional <kbd>order</kbd> method:</p>
<pre>class Supplier(Contact):<br/>    def order(self, order):<br/>        print(<br/>            "If this were a real system we would send "<br/>            f"'{order}' order to '{self.name}'"<br/>        )</pre>
<p>Now, if we test this class in our trusty interpreter, we see that all contacts, including suppliers, accept a name and email address in their <kbd>__init__</kbd>, but that only suppliers have a functional order method:</p>
<pre><strong>&gt;&gt;&gt; c = Contact("Some Body", "somebody@example.net")</strong>
<strong>&gt;&gt;&gt; s = Supplier("Sup Plier", "supplier@example.net")</strong>
<strong>&gt;&gt;&gt; print(c.name, c.email, s.name, s.email)</strong>
<strong>Some Body somebody@example.net Sup Plier supplier@example.net</strong>
<strong>&gt;&gt;&gt; c.all_contacts</strong>
<strong>[&lt;__main__.Contact object at 0xb7375ecc&gt;,</strong>
<strong> &lt;__main__.Supplier object at 0xb7375f8c&gt;]</strong>
<strong>&gt;&gt;&gt; c.order("I need pliers")</strong>
<strong>Traceback (most recent call last):</strong>
<strong>  File "&lt;stdin&gt;", line 1, in &lt;module&gt;</strong>
<strong>AttributeError: 'Contact' object has no attribute 'order'</strong>
<strong>&gt;&gt;&gt; s.order("I need pliers")</strong>
<strong>If this were a real system we would send 'I need pliers' order to</strong>
<strong>'Sup Plier '</strong>  </pre>
<p>So, now our <kbd>Supplier</kbd> class can do everything a contact can do (including adding itself to the list of <kbd>all_contacts</kbd>) and all the special things it needs to handle as a supplier. This is the beauty of inheritance.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Extending built-ins</h1>
                </header>
            
            <article>
                
<p>One interesting use of this kind of inheritance is adding functionality to built-in classes. In the <kbd>Contact</kbd> class seen earlier, we are adding contacts to a list of all contacts. What if we also wanted to search that list by name? Well, we could add a method on the <kbd>Contact</kbd> class to search it, but it feels like this method actually belongs to the list itself. We can do this using inheritance:</p>
<pre><strong>class ContactList(list):</strong><br/>    def search(self, name):<br/>        """Return all contacts that contain the search value<br/>        in their name."""<br/>        matching_contacts = []<br/>        for contact in self:<br/>            if name in contact.name:<br/>                matching_contacts.append(contact)<br/>        return matching_contacts<br/><br/><br/>class Contact:<br/>    all_contacts = ContactList()<br/><br/>    def __init__(self, name, email):<br/>        self.name = name<br/>        self.email = email<br/>        Contact.all_contacts.append(self)</pre>
<p>Instead of instantiating a normal list as our class variable, we create a new <kbd>ContactList</kbd> class that extends the built-in <kbd>list</kbd> data type. Then, we instantiate this subclass as our <kbd>all_contacts</kbd> list. We can test the new search functionality as follows:</p>
<pre><strong>&gt;&gt;&gt; c1 = Contact("John A", "johna@example.net")</strong>
<strong>&gt;&gt;&gt; c2 = Contact("John B", "johnb@example.net")</strong>
<strong>&gt;&gt;&gt; c3 = Contact("Jenna C", "jennac@example.net")</strong>
<strong>&gt;&gt;&gt; [c.name for c in Contact.all_contacts.search('John')]</strong>
<strong>['John A', 'John B']</strong>  </pre>
<p>Are you wondering how we changed the built-in syntax <kbd>[]</kbd> into something we can inherit from? Creating an empty list with <kbd>[]</kbd> is actually a shortcut for creating an empty list using <kbd>list()</kbd>; the two syntaxes behave identically:</p>
<pre><strong>&gt;&gt;&gt; [] == list()</strong>
<strong>True</strong>  </pre>
<p>In reality, the <kbd>[]</kbd> syntax is actually so-called <strong>syntactic sugar</strong> that calls the <kbd>list()</kbd> constructor under the hood. The <kbd>list</kbd> data type is a class that we can extend. In fact, the list itself extends the <kbd>object</kbd> class:</p>
<pre><strong>&gt;&gt;&gt; isinstance([], object)</strong>
<strong>True</strong>  </pre>
<p>As a second example, we can extend the <kbd>dict</kbd> class, which is, similar to the list, the class that is constructed when using the <kbd>{}</kbd> syntax shorthand:</p>
<pre><strong>class LongNameDict(dict):</strong> 
    def longest_key(self): 
        longest = None 
        for key in self: 
            if not longest or len(key) &gt; len(longest): 
                longest = key 
        return longest </pre>
<p>This is easy to test in the interactive interpreter:</p>
<pre><strong>&gt;&gt;&gt; longkeys = LongNameDict()</strong>
<strong>&gt;&gt;&gt; longkeys['hello'] = 1</strong>
<strong>&gt;&gt;&gt; longkeys['longest yet'] = 5</strong>
<strong>&gt;&gt;&gt; longkeys['hello2'] = 'world'</strong>
<strong>&gt;&gt;&gt; longkeys.longest_key()</strong>
<strong>'longest yet'</strong>  </pre>
<p>Most built-in types can be similarly extended. Commonly extended built-ins are <kbd>object</kbd>, <kbd>list</kbd>, <kbd>set</kbd>, <kbd>dict</kbd>, <kbd>file</kbd>, and <kbd>str</kbd>. Numerical types such as <kbd>int</kbd> and <kbd>float</kbd> are also occasionally inherited from.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Overriding and super</h1>
                </header>
            
            <article>
                
<p>So, inheritance is great for <em>adding</em> new behavior to existing classes, but what about <em>changing</em> behavior? Our <kbd>Contact</kbd> class allows only a name and an email address. This may be sufficient for most contacts, but what if we want to add a phone number for our close friends?</p>
<p>As we saw in <a href="0786c893-abb9-4f35-9320-3f2f54de95eb.xhtml"><span class="ChapterrefPACKT">Chapter 2</span></a>, <em>Objects in Python</em>, we can do this easily by just setting a <kbd>phone</kbd> attribute on the contact after it is constructed. But if we want to make this third variable available on initialization, we have to override <kbd>__init__</kbd>. Overriding means altering or replacing a method of the superclass with a new method (with the same name) in the subclass. No special syntax is needed to do this; the subclass's newly created method is automatically called instead of the superclass's method. As shown in the following code:</p>
<pre>class Friend(Contact): 
 def __init__(self, name, email, phone):         self.name = name 
        self.email = email 
        self.phone = phone </pre>
<p>Any method can be overridden, not just <kbd>__init__</kbd>. Before we go on, however, we need to address some problems in this example. Our <kbd>Contact</kbd> and <kbd>Friend</kbd> classes have duplicate code to set up the <kbd>name</kbd> and <kbd>email</kbd> properties; this can make code maintenance complicated, as we have to update the code in two or more places. More alarmingly, our <kbd>Friend</kbd> class is neglecting to add itself to the <kbd>all_contacts</kbd> list we have created on the <kbd>Contact</kbd> class.</p>
<p>What we really need is a way to execute the original <kbd>__init__</kbd> method on the <kbd>Contact</kbd> class from inside our new class. This is what the <kbd>super</kbd> function does; it returns the object as an instance of the parent class, allowing us to call the parent method directly:</p>
<pre>class Friend(Contact): 
    def __init__(self, name, email, phone): 
<strong>        super().__init__(name, email)</strong> 
        self.phone = phone </pre>
<p>This example first gets the instance of the parent object using <kbd>super</kbd>, and calls <kbd>__init__</kbd> on that object, passing in the expected arguments. It then does its own initialization, namely, setting the <kbd>phone</kbd> attribute.</p>
<p>A <kbd>super()</kbd> call can be made inside any method. Therefore, all methods can be modified via overriding and calls to <kbd>super</kbd>. The call to <kbd>super</kbd> can also be made at any point in the method; we don't have to make the call as the first line. For example, we may need to manipulate or validate incoming parameters before forwarding them to the superclass.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Multiple inheritance</h1>
                </header>
            
            <article>
                
<p>Multiple inheritance is a touchy subject. In principle, it's simple: a subclass that inherits from more than one parent class is able to access functionality from both of them. In practice, this is less useful than it sounds and many expert programmers recommend against using it.</p>
<div class="packt_tip">As a humorous rule of thumb, if you think you need multiple inheritance, you're probably wrong, but if you know you need it, you might be right.</div>
<p>The simplest and most useful form of multiple inheritance is called a <strong>mixin</strong>. A mixin is a superclass that is not intended to exist on its own, but is meant to be inherited by some other class to provide extra functionality. For example, let's say we wanted to add functionality to our <kbd>Contact</kbd> class that allows sending an email to <kbd>self.email</kbd>. Sending email is a common task that we might want to use on many other classes. So, we can write a simple mixin class to do the emailing for us:</p>
<pre>class MailSender: 
    def send_mail(self, message): 
        print("Sending mail to " + self.email) 
        # Add e-mail logic here </pre>
<p>For brevity, we won't include the actual email logic here; if you're interested in studying how it's done, see the <kbd>smtplib</kbd> module in the Python standard library.</p>
<p>This class doesn't do anything special (in fact, it can barely function as a standalone class), but it does allow us to define a new class that describes both a <kbd>Contact</kbd> and a <kbd>MailSender</kbd>, using multiple inheritance:</p>
<pre><strong>class EmailableContact(Contact, MailSender):</strong> 
    pass </pre>
<p>The syntax for multiple inheritance looks like a parameter list in the class definition. Instead of including one base class inside the parentheses, we include two (or more), separated by a comma. We can test this new hybrid to see the mixin at work:</p>
<pre><strong>&gt;&gt;&gt; e = EmailableContact("John Smith", "jsmith@example.net")</strong>
<strong>&gt;&gt;&gt; Contact.all_contacts</strong>
<strong>[&lt;__main__.EmailableContact object at 0xb7205fac&gt;]</strong>
<strong>&gt;&gt;&gt; e.send_mail("Hello, test e-mail here")</strong>
<strong>Sending mail to jsmith@example.net</strong>  </pre>
<p>The <kbd>Contact</kbd> initializer is still adding the new contact to the <kbd>all_contacts</kbd> list, and the mixin is able to send mail to <kbd>self.email</kbd>, so we know that everything is working.</p>
<p>This wasn't so hard, and you're probably wondering what the dire warnings about multiple inheritance are. We'll get into the complexities in a minute, but let's consider some other options we had for this example, rather than using a mixin:</p>
<ul>
<li>We could have used single inheritance and added the <kbd>send_mail</kbd> function to the subclass. The disadvantage here is that the email functionality then has to be duplicated for any other classes that need an email.</li>
<li>We can create a standalone Python function for sending an email, and just call that function with the correct email address supplied as a parameter when the email needs to be sent (this would be my choice).</li>
<li>We could have explored a few ways of using composition instead of inheritance. For example, <kbd>EmailableContact</kbd> could have a <kbd>MailSender</kbd> object as a property instead of inheriting from it.</li>
<li>We could monkey patch (we'll briefly cover monkey patching in <a href="b70c8ea0-4778-4005-af13-bdae3d90d2c6.xhtml"><span class="ChapterrefPACKT">Chapter 7</span></a>, <em>Python Object-Oriented Shortcuts</em>) the <kbd>Contact</kbd> class to have a <kbd>send_mail</kbd> method after the class has been created. This is done by defining a function that accepts the <kbd>self</kbd> argument, and setting it as an attribute on an existing class.</li>
</ul>
<p>Multiple inheritance works all right when mixing methods from different classes, but it gets very messy when we have to call methods on the superclass. There are multiple superclasses. How do we know which one to call? How do we know what order to call them in?</p>
<p>Let's explore these questions by adding a home address to our <kbd>Friend</kbd> class. There are a few approaches we might take. An address is a collection of strings representing the street, city, country, and other related details of the contact. We could pass each of these strings as a parameter into the <kbd>Friend</kbd> class's <kbd>__init__</kbd> method. We could also store these strings in a tuple, dictionary, or dataclass (we'll discuss dataclasses in <a href="6a121a79-7716-4a8f-94ab-f96781e82d25.xhtml">Chapter 6</a>,<em> Python Data Structures</em>) and pass them into <kbd>__init__</kbd> as a single argument. This is probably the best course of action if there are no methods that need to be added to the address.</p>
<p>Another option would be to create a new <kbd>Address</kbd> class to hold those strings together, and then pass an instance of this class into the <kbd>__init__</kbd> method in our <kbd>Friend</kbd> class. The advantage of this solution is that we can add behavior (say, a method to give directions or to print a map) to the data instead of just storing it statically. This is an example of composition, as we discussed in <a href="f3a06c74-ab7f-450f-9663-bfe014b359bf.xhtml"><span class="ChapterrefPACKT">Chapter 1</span></a>, <em>Object-Oriented Design</em>. The has a relationship of composition is a perfectly viable solution to this problem and allows us to reuse <kbd>Address</kbd> classes in other entities, such as buildings, businesses, or organizations.</p>
<p>However, inheritance is also a viable solution, and that's what we want to explore. Let's add a new class that holds an address. We'll call this new class <kbd>AddressHolder</kbd> instead of <kbd>Address</kbd> because inheritance defines an is a relationship. It is not correct to say a <kbd>Friend</kbd> class is an <kbd>Address</kbd> class, but since a friend can have an <kbd>Address</kbd> class, we can argue that a <kbd>Friend</kbd> class is an <kbd>AddressHolder</kbd> class. Later, we could create other entities (companies, buildings) that also hold addresses. Then again, such convoluted naming is a decent indication we should be sticking with composition, rather than inheritance. But for pedagogical purposes, we'll stick with inheritance. Here's our <kbd>AddressHolder</kbd> class:</p>
<pre>class AddressHolder: 
    def __init__(self, street, city, state, code): 
        self.street = street 
        self.city = city 
        self.state = state 
        self.code = code </pre>
<p>We just take all the data and toss it into instance variables upon initialization.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">The diamond problem</h1>
                </header>
            
            <article>
                
<p>We can use multiple inheritance to add this new class as a parent of our existing <kbd>Friend</kbd> class. The tricky part is that we now have two parent <kbd>__init__</kbd> methods, both of which need to be initialized. And they need to be initialized with different arguments. How do we do this? Well, we could start with a naive approach:</p>
<pre>class Friend(Contact, AddressHolder): 
    def __init__( 
        self, name, email, phone, street, city, state, code): 
<strong>        Contact.__init__(self, name, email) 
        AddressHolder.__init__(self, street, city, state, code)</strong> 
        self.phone = phone </pre>
<p>In this example, we directly call the <kbd>__init__</kbd> function on each of the superclasses and explicitly pass the <kbd>self</kbd> argument. This example technically works; we can access the different variables directly on the class. But there are a few problems.</p>
<p>First, it is possible for a superclass to go uninitialized if we neglect to explicitly call the initializer. That wouldn't break this example, but it could cause hard-to-debug program crashes in common scenarios. Imagine trying to insert data into a database that has not been connected to, for example.</p>
<p>A more insidious possibility is a superclass being called multiple times because of the organization of the class hierarchy. Look at this inheritance diagram:</p>
<div class="packt_figure CDPAlignCenter CDPAlign"><img src="assets/48be52f3-363e-4fe2-8b90-a3f1c8464aea.png" style="width:17.33em;height:16.17em;"/></div>
<p>The <kbd>__init__</kbd> method from the <kbd>Friend</kbd> class first calls <kbd>__init__</kbd> on <kbd>Contact</kbd>, which implicitly initializes the <kbd>object</kbd> superclass (remember, all classes derive from <kbd>object</kbd>). <kbd>Friend</kbd> then calls <kbd>__init__</kbd> on <kbd>AddressHolder</kbd>, which implicitly initializes the <kbd>object</kbd> superclass <em>again</em>. This means the parent class has been set up twice. With the <kbd>object</kbd> class, that's relatively harmless, but in some situations, it could spell disaster. Imagine trying to connect to a database twice for every request!</p>
<p>The base class should only be called once. Once, yes, but when? Do we call <kbd>Friend</kbd>, then <kbd>Contact</kbd>, then <kbd>Object</kbd>, and then <kbd>AddressHolder</kbd>? Or <kbd>Friend</kbd>, then <kbd>Contact</kbd>, then <kbd>AddressHolder</kbd>, and then <kbd>Object</kbd>?</p>
<div class="packt_tip">The order in which methods can be called can be adapted on the fly by modifying the <kbd>__mro__</kbd> (<strong>Method Resolution Order</strong>) attribute on the class. This is beyond the scope of this book. If you think you need to understand it, we recommend <em>Expert Python Programming</em>, <em>Tarek Ziadé</em>, <em>Packt Publishing</em>, or read the original documentation (beware, it's deep!) on the topic at <a href="http://www.python.org/download/releases/2.3/mro/"><span class="URLPACKT">http://www.python.org/download/releases/2.3/mro/</span></a>.</div>
<p>Let's look at a second contrived example, which illustrates this problem more clearly. Here, we have a base class that has a method named <kbd>call_me</kbd>. Two subclasses override that method, and then another subclass extends both of these using multiple inheritance. This is called diamond inheritance because of the diamond shape of the class diagram:</p>
<div class="packt_figure CDPAlignCenter CDPAlign"><img src="assets/ed5ab038-124e-44a3-b0c6-975e0f92392b.png" style="width:20.17em;height:18.67em;"/></div>
<p>Let's convert this diagram to code; this example shows when the methods are called:</p>
<pre>class BaseClass:<br/>    num_base_calls = 0<br/><br/>    def call_me(self):<br/>        print("Calling method on Base Class")<br/>        self.num_base_calls += 1<br/><br/><br/>class LeftSubclass(BaseClass):<br/>    num_left_calls = 0<br/><br/>    def call_me(self):<br/>        BaseClass.call_me(self)<br/>        print("Calling method on Left Subclass")<br/>        self.num_left_calls += 1<br/><br/><br/>class RightSubclass(BaseClass):<br/>    num_right_calls = 0<br/><br/>    def call_me(self):<br/>        BaseClass.call_me(self)<br/>        print("Calling method on Right Subclass")<br/>        self.num_right_calls += 1<br/><br/><br/>class Subclass(LeftSubclass, RightSubclass):<br/>    num_sub_calls = 0<br/><br/>    def call_me(self):<br/><strong>        LeftSubclass.call_me(self)</strong><br/><strong>        RightSubclass.call_me(self)</strong><br/>        print("Calling method on Subclass")<br/>        self.num_sub_calls += 1</pre>
<p>This example ensures that each overridden <kbd>call_me</kbd> method directly calls the parent method with the same name. It lets us know each time a method is called by printing the information to the screen. It also updates a static variable on the class to show how many times it has been called. If we instantiate one <kbd>Subclass</kbd> object and call the method on it once, we get the output:</p>
<pre><strong>&gt;&gt;&gt; s = Subclass()</strong>
<strong>&gt;&gt;&gt; s.call_me()</strong>
<strong>Calling method on Base Class</strong>
<strong>Calling method on Left Subclass</strong>
<strong>Calling method on Base Class</strong>
<strong>Calling method on Right Subclass</strong>
<strong>Calling method on Subclass</strong>
<strong>&gt;&gt;&gt; print(</strong>
<strong>... s.num_sub_calls,</strong>
<strong>... s.num_left_calls,</strong>
<strong>... s.num_right_calls,</strong>
<strong>... s.num_base_calls)</strong>
<strong>1 1 1 2</strong>  </pre>
<p>Thus, we can clearly see the base class's <kbd>call_me</kbd> method being called twice. This could lead to some pernicious bugs if that method is doing actual work, such as depositing into a bank account, twice.</p>
<p>The thing to keep in mind with multiple inheritance is that we only want to call the <kbd>next</kbd> method in the class hierarchy, not the <kbd>parent</kbd> method. In fact, that next method may not be on a parent or ancestor of the current class. The <kbd>super</kbd> keyword comes to our rescue once again. Indeed, <kbd>super</kbd> was originally developed to make complicated forms of multiple inheritance possible. Here is the same code written using <kbd>super</kbd>:</p>
<pre>class BaseClass:<br/>    num_base_calls = 0<br/><br/>    def call_me(self):<br/>        print("Calling method on Base Class")<br/>        self.num_base_calls += 1<br/><br/><br/>class LeftSubclass(BaseClass):<br/>    num_left_calls = 0<br/><br/>    def call_me(self):<br/><strong>        super().call_me()</strong><br/>        print("Calling method on Left Subclass")<br/>        self.num_left_calls += 1<br/><br/><br/>class RightSubclass(BaseClass):<br/>    num_right_calls = 0<br/><br/>    def call_me(self):<br/><strong>        super().call_me()</strong><br/>        print("Calling method on Right Subclass")<br/>        self.num_right_calls += 1<br/><br/><br/>class Subclass(LeftSubclass, RightSubclass):<br/>    num_sub_calls = 0<br/><br/>    def call_me(self):<br/><strong> super().call_me()</strong><br/>        print("Calling method on Subclass")<br/>        self.num_sub_calls += 1</pre>
<p>The change is pretty minor; we only replaced the naive direct calls with calls to <kbd>super()</kbd>, although the bottom subclass only calls <kbd>super</kbd> once rather than having to make the calls for both the left and right. The change is easy enough, but look at the difference when we execute it:</p>
<pre><strong>&gt;&gt;&gt; s = Subclass()</strong>
<strong>&gt;&gt;&gt; s.call_me()</strong>
<strong>Calling method on Base Class</strong>
<strong>Calling method on Right Subclass</strong>
<strong>Calling method on Left Subclass</strong>
<strong>Calling method on Subclass</strong>
<strong>&gt;&gt;&gt; print(s.num_sub_calls, s.num_left_calls, s.num_right_calls,</strong>
<strong>s.num_base_calls)</strong>
<strong>1 1 1 1</strong>  </pre>
<p>Looks good; our base method is only being called once. But what is <kbd>super()</kbd> actually doing here? Since the <kbd>print</kbd> statements are executed after the <kbd>super</kbd> calls, the printed output is in the order each method is actually executed. Let's look at the output from back to front to see who is calling what.</p>
<p>First, <kbd>call_me</kbd> of <kbd>Subclass</kbd> calls <kbd>super().call_me()</kbd>, which happens to refer<br/>
to <kbd>LeftSubclass.call_me()</kbd>. The <kbd>LeftSubclass.call_me()</kbd> method then calls <kbd>super().call_me()</kbd>, but in this case, <kbd>super()</kbd> is referring to <kbd>RightSubclass.call_me()</kbd>.</p>
<p><strong>Pay particular attention to this</strong>: the <kbd>super</kbd> call is <em>not</em> calling the method on the superclass of <kbd>LeftSubclass</kbd> (which is <kbd>BaseClass</kbd>). Rather, it is calling <kbd>RightSubclass</kbd>, even though it is not a direct parent of <kbd>LeftSubclass</kbd>! This is the <em>next</em> method, not the parent method. <kbd>RightSubclass</kbd> then calls <kbd>BaseClass</kbd> and the <kbd>super</kbd> calls have ensured each method in the class hierarchy is executed once.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Different sets of arguments</h1>
                </header>
            
            <article>
                
<p>This is going to make things complicated as we return to our <kbd>Friend</kbd> multiple inheritance example. In the <kbd>__init__</kbd> method for <kbd>Friend</kbd>, we were originally calling <kbd>__init__</kbd> for both parent classes, <em>with different sets of arguments</em>:</p>
<pre><strong>Contact.__init__(self, name, email) 
AddressHolder.__init__(self, street, city, state, code)</strong> </pre>
<p>How can we manage different sets of arguments when using <kbd>super</kbd>? We don't necessarily know which class <kbd>super</kbd> is going to try to initialize first. Even if we did, we need a way to pass the <kbd>extra</kbd> arguments so that subsequent calls to <kbd>super</kbd>, on other subclasses, receive the right arguments.</p>
<p>Specifically, if the first call to <kbd>super</kbd> passes the <kbd>name</kbd> and <kbd>email</kbd> arguments to <kbd>Contact.__init__</kbd>, and <kbd>Contact.__init__</kbd> then calls <kbd>super</kbd>, it needs to be able to pass the address-related arguments to the <kbd>next</kbd> method, which is <kbd>AddressHolder.__init__</kbd>.</p>
<p>This problem manifests itself anytime we want to call superclass methods with the same name, but with different sets of arguments. Most often, the only time you would want to call a superclass with a completely different set of arguments is in <kbd>__init__</kbd>, as we're doing here. Even with regular methods, though, we may want to add optional parameters that only make sense to one subclass or set of subclasses.</p>
<p>Sadly, the only way to solve this problem is to plan for it from the beginning. We have to design our base class parameter lists to accept keyword arguments for any parameters that are not required by every subclass implementation. Finally, we must ensure the method freely accepts unexpected arguments and passes them on to its <kbd>super</kbd> call, in case they are necessary to later methods in the inheritance order.</p>
<p>Python's function parameter syntax provides all the tools we need to do this, but it makes the overall code look cumbersome. Have a look at the proper version of the <kbd>Friend</kbd> multiple inheritance code, as follows:</p>
<pre>class Contact:<br/>    all_contacts = []<br/><br/><strong>    def __init__(self, name="", email="", **kwargs):</strong><br/><strong>        super().__init__(**kwargs)</strong><br/>        self.name = name<br/>        self.email = email<br/>        self.all_contacts.append(self)<br/><br/><br/>class AddressHolder:<br/><strong>    def __init__(self, street="", city="", state="", code="", **kwargs):</strong><br/><strong>        super().__init__(**kwargs)</strong><br/>        self.street = street<br/>        self.city = city<br/>        self.state = state<br/>        self.code = code<br/><br/><br/>class Friend(Contact, AddressHolder):<br/><strong>    def __init__(self, phone="", **kwargs):</strong><br/><strong>        super().__init__(**kwargs)</strong><br/>        self.phone = phone</pre>
<p>We've changed all arguments to keyword arguments by giving them an empty string as a default value. We've also ensured that a <kbd>**kwargs</kbd> parameter is included to capture any additional parameters that our particular method doesn't know what to do with. It passes these parameters up to the next class with the <kbd>super</kbd> call.</p>
<div class="packt_tip">If you aren't familiar with the <kbd>**kwargs</kbd> syntax, it basically collects any keyword arguments passed into the method that were not explicitly listed in the parameter list. These arguments are stored in a dictionary named <kbd>kwargs</kbd> (we can call the variable whatever we like, but convention suggests <kbd>kw</kbd>, or <kbd>kwargs</kbd>). When we call a different method (for example, <kbd>super().__init__</kbd>) with a <kbd>**kwargs</kbd> syntax, it unpacks the dictionary and passes the results to the method as normal keyword arguments. We'll cover this in detail in <span class="ChapterrefPACKT"><a href="b70c8ea0-4778-4005-af13-bdae3d90d2c6.xhtml">Chapter 7</a></span>, <em>Python Object-Oriented Shortcuts</em>.</div>
<p>The previous example does what it is supposed to do. But it's starting to look messy, and it is difficult to answer the question, <em>What arguments do we need to pass into</em> <kbd>Friend.__init__</kbd>? This is the foremost question for anyone planning to use the class, so a docstring should be added to the method to explain what is happening.</p>
<p>Furthermore, even this implementation is insufficient if we want to <em>reuse</em> variables in parent classes. When we pass the <kbd>**kwargs</kbd> variable to <kbd>super</kbd>, the dictionary does not include any of the variables that were included as explicit keyword arguments. For example, in <kbd>Friend.__init__</kbd>, the call to <kbd>super</kbd> does not have <kbd>phone</kbd> in the <kbd>kwargs</kbd> dictionary. If any of the other classes need the <kbd>phone</kbd> parameter, we need to ensure it is in the dictionary that is passed. Worse, if we forget to do this, it will be extremely frustrating to debug because the superclass will not complain, but will simply assign the default value (in this case, an empty string) to the variable.</p>
<p>There are a few ways to ensure that the variable is passed upward. Assume the <kbd>Contact</kbd> class does, for some reason, need to be initialized with a <kbd>phone</kbd> parameter, and the <kbd>Friend</kbd> class will also need access to it. We can do any of the following:</p>
<ul>
<li>Don't include <kbd>phone</kbd> as an explicit keyword argument. Instead, leave it in the <kbd>kwargs</kbd> dictionary. <kbd>Friend</kbd> can look it up using the <kbd>kwargs['phone'] </kbd> syntax. When it passes <kbd>**kwargs</kbd> to the <kbd>super</kbd> call, <kbd>phone</kbd> will still be in the dictionary.</li>
<li>Make <kbd>phone</kbd> an explicit keyword argument, but update the <kbd>kwargs</kbd> dictionary before passing it to <kbd>super</kbd>, using the standard dictionary <kbd>kwargs['phone'] = phone</kbd> <span>syntax.</span></li>
<li>Make <kbd>phone</kbd> an explicit keyword argument, but update the <kbd>kwargs</kbd> dictionary using the <kbd>kwargs.update</kbd> method. This is useful if you have several arguments to update. You can create the dictionary passed into <kbd>update</kbd> using either the <kbd>dict(phone=phone)</kbd> constructor, or the dictionary <kbd>{'phone': phone}</kbd> <span>syntax</span>.</li>
<li>Make <kbd>phone</kbd> an explicit keyword argument, but pass it to the super call explicitly with the <kbd>super().__init__(phone=phone, **kwargs)</kbd> <span>syntax</span>.</li>
</ul>
<p>We have covered many of the caveats involved with multiple inheritance in Python. When we need to account for all possible situations, we have to plan for them and our code will get messy. Basic multiple inheritance can be handy but, in many cases, we may want to choose a more transparent way of combining two disparate classes, usually using composition or one of the design patterns we'll be covering in <a href="345fe617-9a90-4c59-9355-e7076759f9a4.xhtml"><span class="ChapterrefPACKT">Chapter 10</span></a>, <em>Design Patterns I,</em> and <a href="8f3d1c0f-4a63-4d06-8fb2-ad4dfe2669a3.xhtml"><span class="ChapterrefPACKT">Chapter 11</span></a>, <em>Design Patterns II</em>.</p>
<div class="packt_infobox">I have wasted entire days of my life trawling through complex multiple inheritance hierarchies trying to figure out what arguments I need to pass into one of the deeply nested subclasses. The author of the code tended not to document his classes and often passed the kwargs—Just in case they might be needed someday. This was a particularly bad example of using multiple inheritance when it was not needed. Multiple inheritance is a big fancy term that new coders like to show off, but I recommend avoiding it, even when you think it's a good choice. Your future self and other coders will be glad they understand your code when they have to read it later.</div>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Polymorphism</h1>
                </header>
            
            <article>
                
<p>We were introduced to polymorphism in <a href="f3a06c74-ab7f-450f-9663-bfe014b359bf.xhtml"><span class="ChapterrefPACKT">Chapter 1</span></a>, <em>Object-Oriented Design</em>. It is a showy name describing a simple concept: different behaviors happen depending on which subclass is being used, without having to explicitly know what the subclass actually is. As an example, imagine a program that plays audio files. A media player might need to load an <kbd>AudioFile</kbd> object and then <kbd>play</kbd> it. We can put a <kbd>play()</kbd> method on the object, which is responsible for decompressing or extracting the audio and routing it to the sound card and speakers. The act of playing an <kbd>AudioFile</kbd> could feasibly be as simple as:</p>
<pre>audio_file.play() </pre>
<p>However, the process of decompressing and extracting an audio file is very different for different types of files. While <kbd>.wav</kbd> files are stored uncompressed, <kbd>.mp3</kbd>, <kbd>.wma</kbd>, and <kbd>.ogg</kbd> files all utilize totally different compression algorithms.</p>
<p>We can use inheritance with polymorphism to simplify the design. Each type of file can be represented by a different subclass of <kbd>AudioFile</kbd>, for example, <kbd>WavFile</kbd> and <kbd>MP3File</kbd>. Each of these would have a <kbd>play()</kbd> method that would be implemented differently for each file to ensure that the correct extraction procedure is followed. The media player object would never need to know which subclass of <kbd>AudioFile</kbd> it is referring to; it just calls <kbd>play()</kbd> and polymorphically lets the object take care of the actual details of playing. Let's look at a quick skeleton showing how this might look:</p>
<pre>class AudioFile:<br/>    def __init__(self, filename):<br/>        if not filename.endswith(self.ext):<br/>            raise Exception("Invalid file format")<br/><br/>        self.filename = filename<br/><br/><br/>class MP3File(AudioFile):<br/>    ext = "mp3"<br/><br/>    def play(self):<br/>        print("playing {} as mp3".format(self.filename))<br/><br/><br/>class WavFile(AudioFile):<br/>    ext = "wav"<br/><br/>    def play(self):<br/>        print("playing {} as wav".format(self.filename))<br/><br/><br/>class OggFile(AudioFile):<br/>    ext = "ogg"<br/><br/>    def play(self):<br/>        print("playing {} as ogg".format(self.filename))</pre>
<p>All audio files check to ensure that a valid extension was given upon initialization. But did you notice how the <kbd>__init__</kbd> method in the parent class is able to access the <kbd>ext</kbd> class variable from different subclasses? That's polymorphism at work. If the filename doesn't end with the correct name, it raises an exception (exceptions will be covered in detail in the next chapter). The fact that the <kbd>AudioFile</kbd> parent class doesn't actually store a reference to the <kbd>ext</kbd> variable doesn't stop it from being able to access it on the subclass.</p>
<p>In addition, each subclass of <kbd>AudioFile</kbd> implements <kbd>play()</kbd> in a different way (this example doesn't actually play the music; audio compression algorithms really deserve a separate book!). This is also polymorphism in action. The media player can use the exact same code to play a file, no matter what type it is; it doesn't care what subclass of <kbd>AudioFile</kbd> it is looking at. The details of decompressing the audio file are <em>encapsulated</em>. If we test this example, it works as we would hope:</p>
<pre><strong>&gt;&gt;&gt; ogg = OggFile("myfile.ogg")</strong>
<strong>&gt;&gt;&gt; ogg.play()</strong>
<strong>playing myfile.ogg as ogg</strong>
<strong>&gt;&gt;&gt; mp3 = MP3File("myfile.mp3")</strong>
<strong>&gt;&gt;&gt; mp3.play()</strong>
<strong>playing myfile.mp3 as mp3</strong>
<strong>&gt;&gt;&gt; not_an_mp3 = MP3File("myfile.ogg")</strong>
<strong>Traceback (most recent call last):</strong>
<strong>  File "&lt;stdin&gt;", line 1, in &lt;module&gt;</strong>
<strong>  File "polymorphic_audio.py", line 4, in __init__</strong>
<strong>    raise Exception("Invalid file format")</strong>
<strong>Exception: Invalid file format</strong>  </pre>
<p>See how <kbd>AudioFile.__init__</kbd> is able to check the file type without actually knowing which subclass it is referring to?</p>
<p>Polymorphism is actually one of the coolest things about object-oriented programming, and it makes some programming designs obvious that weren't possible in earlier paradigms. However, Python makes polymorphism seem less awesome because of duck typing. Duck typing in Python allows us to use <em>any</em> object that provides the required behavior without forcing it to be a subclass. The dynamic nature of Python makes this trivial. The following example does not extend <kbd>AudioFile</kbd>, but it can be interacted with in Python using the exact same interface:</p>
<pre>class FlacFile: 
    def __init__(self, filename): 
        if not filename.endswith(".flac"): 
            raise Exception("Invalid file format") 
 
        self.filename = filename 
 
    def play(self): 
        print("playing {} as flac".format(self.filename)) </pre>
<p>Our media player can play this object just as easily as one that extends <kbd>AudioFile</kbd>.</p>
<p>Polymorphism is one of the most important reasons to use inheritance in many object-oriented contexts. Because any objects that supply the correct interface can be used interchangeably in Python, it reduces the need for polymorphic common superclasses. Inheritance can still be useful for sharing code, but if all that is being shared is the public interface, duck typing is all that is required. This reduced need for inheritance also reduces the need for multiple inheritance; often, when multiple inheritance appears to be a valid solution, we can just use duck typing to mimic one of the multiple superclasses.</p>
<p>Of course, just because an object satisfies a particular interface (by providing required methods or attributes) does not mean it will simply work in all situations. It has to fulfill that interface in a way that makes sense in the overall system. Just because an object provides a <kbd>play()</kbd> method does not mean it will automatically work with a media player. For example, our chess AI object from <a href="f3a06c74-ab7f-450f-9663-bfe014b359bf.xhtml"><span class="ChapterrefPACKT">Chapter 1</span></a>, <em>Object-Oriented Design</em>, may have a <kbd>play()</kbd> method that moves a chess piece. Even though it satisfies the interface, this class would likely break in spectacular ways if we tried to plug it into a media player!</p>
<p>Another useful feature of duck typing is that the duck-typed object only needs to provide those methods and attributes that are actually being accessed. For example, if we needed to create a fake file object to read data from, we can create a new object that has a <kbd>read()</kbd> method; we don't have to override the <kbd>write</kbd> method if the code that is going to interact with the fake object will not be calling it. More succinctly, duck typing doesn't need to provide the entire interface of an object that is available; it only needs to fulfill the interface that is actually accessed.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Abstract base classes</h1>
                </header>
            
            <article>
                
<p>While duck typing is useful, it is not always easy to tell in advance if a class is going to fulfill the protocol you require. Therefore, Python introduced the idea of <strong>abstract base classes</strong> (<strong>ABC</strong>s). Abstract base classes define a set of methods and properties that a class must implement in order to be considered a duck-type instance of that class. The class can extend the abstract base class itself in order to be used as an instance of that class, but it must supply all the appropriate methods.</p>
<p>In practice, it's rarely necessary to create new abstract base classes, but we may find occasions to implement instances of existing ABCs. We'll cover implementing ABCs first, and then briefly see how to create your own, should you ever need to.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Using an abstract base class</h1>
                </header>
            
            <article>
                
<p>Most of the abstract base classes that exist in the Python standard library live in the <kbd>collections</kbd> module. One of the simplest ones is the <kbd>Container</kbd> class. Let's inspect it in the Python interpreter to see what methods this class requires:</p>
<pre><strong>&gt;&gt;&gt; from collections import Container 
&gt;&gt;&gt; Container.__abstractmethods__</strong> 
frozenset(['__contains__']) </pre>
<p>So, the <kbd>Container</kbd> class has exactly one abstract method that needs to be implemented, <kbd>__contains__</kbd>. You can issue <kbd>help(Container.__contains__)</kbd> to see what the function signature should look like:</p>
<pre>Help on method __contains__ in module _abcoll:<br/> __contains__(self, x) unbound _abcoll.Container method</pre>
<p>We can see that <kbd>__contains__</kbd> needs to take a single argument. Unfortunately, the help file doesn't tell us much about what that argument should be, but it's pretty obvious from the name of the ABC and the single method it implements that this argument is the value the user is checking to see whether the container holds.</p>
<p>This method is implemented by <kbd>list</kbd>, <kbd>str</kbd>, and <kbd>dict</kbd> to indicate whether or not a given value is <em>in</em> that data structure. However, we can also define a silly container that tells us whether a given value is in the set of odd integers:</p>
<pre>class OddContainer: 
    def __contains__(self, x): 
        if not isinstance(x, int) or not x % 2: 
            return False 
        return True </pre>
<p>Here's the interesting part: we can instantiate an <kbd>OddContainer</kbd> object and determine that, even though we did not extend <kbd>Container</kbd>, the class is a <kbd>Container</kbd> object:</p>
<pre><strong>&gt;&gt;&gt; from collections import Container 
&gt;&gt;&gt; odd_container = OddContainer() 
&gt;&gt;&gt; isinstance(odd_container, Container) 
True 
&gt;&gt;&gt; issubclass(OddContainer, Container) 
True</strong> </pre>
<p>And that is why duck typing is way more awesome than classical polymorphism. We can create is a relationships without the overhead of writing the code to set up inheritance (or worse, multiple inheritance).</p>
<p>One cool thing about the <kbd>Container</kbd> ABC is that any class that implements it gets to use the <kbd>in</kbd> keyword for free. In fact, <kbd>in</kbd> is just syntax sugar that delegates to the <kbd>__contains__</kbd> method. Any class that has a <kbd>__contains__</kbd> method is a <kbd>Container</kbd> and can therefore be queried by the <kbd>in</kbd> keyword, for example:</p>
<pre><strong>&gt;&gt;&gt; 1 in odd_container 
True 
&gt;&gt;&gt; 2 in odd_container 
False 
&gt;&gt;&gt; 3 in odd_container 
True 
&gt;&gt;&gt; "a string" in odd_container 
False</strong> </pre>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Creating an abstract base class</h1>
                </header>
            
            <article>
                
<p>As we saw earlier, it's not necessary to have an abstract base class to enable duck typing. However, imagine we were creating a media player with third-party plugins. It is advisable to create an abstract base class in this case to document what API the third-party plugins should provide (documentation is one of the stronger use cases for ABCs). The <kbd>abc</kbd> module provides the tools you need to do this, but I'll warn you in advance, this utilizes some of Python's most arcane <span>concepts, as demonstrated in the following block of code:</span>:</p>
<pre>import abc 
 
<strong>class MediaLoader(metaclass=abc.ABCMeta):</strong><br/>    @abc.abstractmethod<br/>    def play(self):<br/>        pass<br/><br/>    @abc.abstractproperty<br/>    def ext(self):<br/>        pass<br/><br/>    @classmethod<br/>    def __subclasshook__(cls, C):<br/>        if cls is MediaLoader:<br/>            attrs = set(dir(C))<br/>            if set(cls.__abstractmethods__) &lt;= attrs:<br/>                return True<br/><br/>        return NotImplemented</pre>
<p>This is a complicated example that includes several Python features that won't be explained until later in this book. It is included here for completeness, but you do not need to understand all of it to get the gist of how to create your own ABC.</p>
<p>The first weird thing is the <kbd>metaclass</kbd> keyword argument that is passed into the class where you would normally see the list of parent classes. This is a seldom-used construct from the mystic art of metaclass programming. We won't be covering metaclasses in this book, so all you need to know is that by assigning the <kbd>ABCMeta</kbd> metaclass, you are giving your class superhero (or at least superclass) abilities.</p>
<p>Next, we see the <kbd>@abc.abstractmethod</kbd> and <kbd>@abc.abstractproperty</kbd> constructs. These are Python decorators. We'll discuss those in <a href="345fe617-9a90-4c59-9355-e7076759f9a4.xhtml"><span class="ChapterrefPACKT">Chapter 10</span></a>, <em>Python Design Patterns I</em>. For now, just know that by marking a method or property as being abstract, you are stating that any subclass of this class must implement that method or supply that property in order to be considered a proper member of the class.</p>
<p>See what happens if you implement subclasses that do, or don't, supply those properties:</p>
<pre><strong>&gt;&gt;&gt; class Wav(MediaLoader): 
...     pass 
... 
&gt;&gt;&gt; x = Wav() 
Traceback (most recent call last): 
  File "&lt;stdin&gt;", line 1, in &lt;module&gt; 
TypeError: Can't instantiate abstract class Wav with abstract methods ext, play 
&gt;&gt;&gt; class Ogg(MediaLoader): 
...     ext = '.ogg' 
...     def play(self): 
...         pass 
... 
&gt;&gt;&gt; o = Ogg()</strong> </pre>
<p>Since the <kbd>Wav</kbd> class fails to implement the abstract attributes, it is not possible to instantiate that class. The class is still a legal abstract class, but you'd have to subclass it to actually do anything. The <kbd>Ogg</kbd> class supplies both attributes, so it instantiates cleanly.</p>
<p>Going back to the <kbd>MediaLoader</kbd> ABC, let's dissect that <kbd>__subclasshook__</kbd> method. It is basically saying that any class that supplies concrete implementations of all the abstract attributes of this ABC should be considered a subclass of <kbd>MediaLoader</kbd>, even if it doesn't actually inherit from the <kbd>MediaLoader</kbd> class.</p>
<p>More common object-oriented languages have a clear separation between the interface and the implementation of a class. For example, some languages provide an explicit <kbd>interface</kbd> keyword that allows us to define the methods that a class must have without any implementation. In such an environment, an abstract class is one that provides both an interface and a concrete implementation of some, but not all, methods. Any class can explicitly state that it implements a given interface.</p>
<p>Python's ABCs help to supply the functionality of interfaces without compromising on the benefits of duck typing.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Demystifying the magic</h1>
                </header>
            
            <article>
                
<p>You can copy and paste the subclass code without understanding it if you want to make abstract classes that fulfill this particular contract. We'll cover most of the unusual syntaxes in the book, but let's go over it line by line to get an overview:</p>
<pre>    @classmethod </pre>
<p>This decorator marks the method as a class method. It essentially says that the method can be called on a class instead of an instantiated object:</p>
<pre>    def __subclasshook__(cls, C): </pre>
<p>This defines the <kbd>__subclasshook__</kbd> class method. This special method is called by the Python interpreter to answer the question: Is the class <kbd>C</kbd> a subclass of this class?</p>
<pre>        if cls is MediaLoader: </pre>
<p>We check to see whether the method was called specifically on this class, rather than, say, a subclass of this class. This prevents, for example, the <kbd>Wav</kbd> class from being thought of as a parent class of the <kbd>Ogg</kbd> class:</p>
<pre>            attrs = set(dir(C)) </pre>
<p>All this line does is get the set of methods and properties that the class has, including any parent classes in its class hierarchy:</p>
<pre>            if set(cls.__abstractmethods__) &lt;= attrs: </pre>
<p>This line uses set notation to see whether the set of abstract methods in this class has been supplied in the candidate class. We'll cover sets in detail in the <span><a href="6a121a79-7716-4a8f-94ab-f96781e82d25.xhtml">Chapter 6</a>, </span><em>Python Data Structures</em><em>.</em> Note that it doesn't check to see whether the methods have been implemented; just if they are there. Thus, it's possible for a class to be a subclass and yet still be an abstract class itself.</p>
<pre>                return True </pre>
<p>If all the abstract methods have been supplied, then the candidate class is a subclass of this class and we return <kbd>True</kbd>. The method can legally return one of the three values: <kbd>True</kbd>, <kbd>False</kbd>, or <kbd>NotImplemented</kbd>. <kbd>True</kbd> and <kbd>False</kbd> indicate that the class is, or isn't, definitively a subclass of this class:</p>
<pre>return NotImplemented </pre>
<p>If any of the conditionals have not been met (that is, the class is not <kbd>MediaLoader</kbd> or not all abstract methods have been supplied), then return <kbd>NotImplemented</kbd>. This tells the Python machinery to use the default mechanism (does the candidate class explicitly extend this class?) for subclass detection.</p>
<p>In short, we can now define the <kbd>Ogg</kbd> class as a subclass of the <kbd>MediaLoader</kbd> class without actually extending the <kbd>MediaLoader</kbd> class:</p>
<pre><strong>&gt;&gt;&gt; class Ogg(): ... ext = '.ogg' ... def play(self): ... print("this will play an ogg file") ... &gt;&gt;&gt; issubclass(Ogg, MediaLoader) True &gt;&gt;&gt; isinstance(Ogg(), MediaLoader) True</strong></pre>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Case study</h1>
                </header>
            
            <article>
                
<p>Let's try to tie everything we've learned together with a larger example. We'll be developing an automated grading system for programming assignments, similar to that employed at Dataquest or Coursera. The system will need to provide a simple class-based interface for course writers to create their assignments and should give a useful error message if it does not fulfill that interface. The writers need to be able to supply their lesson content and to write custom answer checking code to make sure their students got the answer right. It will also be nice for them to have access to the students' names to make the content seem a little friendlier.</p>
<p>The grader itself will need to keep track of which assignment the student is currently working on. A student might make several attempts at an assignment before they get it right. We want to keep track of the number of attempts so the course authors can improve the content of the more difficult lessons.</p>
<p>Let's start by defining the interface that the course authors will need to use. Ideally, it will require the course authors to write a minimal amount of extra code besides their lesson content and answer checking code. Here is the simplest class I could come up with:</p>
<pre>class IntroToPython:<br/>    def lesson(self):<br/>        return f"""<br/>            Hello {self.student}. define two variables,<br/>            an integer named a with value 1<br/>            and a string named b with value 'hello'<br/><br/>        """<br/><br/>    def check(self, code):<br/>        return code == "a = 1\nb = 'hello'"</pre>
<p>Admittedly, that particular course author may be a little naive in how they do their answer checking. If you haven't seen the <kbd>f"""</kbd> syntax before, we'll cover it in detail in the <a href="9a6335a2-1c69-4fa8-a685-02bbeeba23be.xhtml">Chapter 8</a>, <em>Strings and Serialization</em>.</p>
<p>We can start with an abstract base class that defines this interface, as follows:</p>
<pre>class Assignment(metaclass=abc.ABCMeta):<br/>    @abc.abstractmethod<br/>    def lesson(self, student):<br/>        pass<br/><br/>    @abc.abstractmethod<br/>    def check(self, code):<br/>        pass<br/><br/>    @classmethod<br/>    def __subclasshook__(cls, C):<br/>        if cls is Assignment:<br/>            attrs = set(dir(C))<br/>            if set(cls.__abstractmethods__) &lt;= attrs:<br/>                return True<br/><br/>        return NotImplemented</pre>
<p class="mce-root">This ABC defines the two required abstract methods and provides the magic <kbd>__subclasshook__</kbd> method to allow a class to be perceived as a subclass without having to explicitly extend it (I usually just copy and paste this code. It isn't worth memorizing.)</p>
<p>We can confirm that the <kbd>IntroToPython</kbd> class fulfills this interface using <kbd><span>issubclass</span><span>(IntroToPython, Assignment)</span></kbd>, which should return <kbd>True</kbd>. Of course, we can explicitly extend the <kbd>Assignment</kbd> class if we prefer, as seen in this second assignment:</p>
<pre class="mce-root">class Statistics(Assignment):<br/>    def lesson(self):<br/>        return (<br/>            "Good work so far, "<br/>            + self.student<br/>            + ". Now calculate the average of the numbers "<br/>            + " 1, 5, 18, -3 and assign to a variable named 'avg'"<br/>        )<br/><br/>    def check(self, code):<br/>        import statistics<br/><br/>        code = "import statistics\n" + code<br/><br/>        local_vars = {}<br/>        global_vars = {}<br/>        exec(code, global_vars, local_vars)<br/><br/>        return local_vars.get("avg") == statistics.mean([1, 5, 18, -3])</pre>
<p>This course author, unfortunately, is also rather naive. The <kbd>exec</kbd> call will execute the student's code right inside the grading system, giving them access to the entire system. Obviously, the first thing they will do is hack the system to make their grades 100%. They probably think that's easier than doing the assignments correctly!</p>
<p>Next, we'll create a class that manages how many attempts the student has made at a given assignment:</p>
<pre>class AssignmentGrader:<br/>    def __init__(self, student, AssignmentClass):<br/>        self.assignment = AssignmentClass()<br/>        self.assignment.student = student<br/>        self.attempts = 0<br/>        self.correct_attempts = 0<br/><br/>    def check(self, code):<br/>        self.attempts += 1<br/>        result = self.assignment.check(code)<br/>        if result:<br/>            self.correct_attempts += 1<br/><br/>        return result<br/><br/>    def lesson(self):<br/>        return self.assignment.lesson()</pre>
<p>This class uses composition instead of inheritance. At first glance, it would make sense for these methods to exist on the <kbd>Assignment</kbd> superclass. That would eliminate the annoying <kbd>lesson</kbd> method, which just proxies through to the same method on the assignment object. It would certainly be possible to put all this logic directly on the <kbd>Assignment</kbd> abstract base class, or even to have the ABC inherit from this <kbd>AssignmentGrader</kbd> class. In fact, I would normally recommend that, but in this case, it would force all course authors to explicitly extend the class, which violates our request that content authoring be as simple as possible.</p>
<p>Finally, we can start to put together the <kbd>Grader</kbd> class, which is responsible for managing which assignments are available and which one each student is currently working on. The most interesting part is the register method:</p>
<pre>import uuid<br/><br/>class Grader:<br/>    def __init__(self):<br/>        self.student_graders = {}<br/>        self.assignment_classes = {}<br/><br/>    def register(self, assignment_class):<br/>        if not issubclass(assignment_class, Assignment):<br/>            raise RuntimeError(<br/>                "Your class does not have the right methods"<br/>            )<br/><br/>        id = uuid.uuid4()<br/>        self.assignment_classes[id] = assignment_class<br/>        return id</pre>
<p>This code block includes the initializer, which includes two dictionaries we'll discuss in a minute. The <kbd>register</kbd> method is a bit complex, so we'll dissect it thoroughly.</p>
<p>The first odd thing is the parameter this method accepts: <kbd>assignment_class</kbd>. This parameter is intended to be an actual class, not an instance of the class. Remember, classes are objects, too, and can be passed around like other classes. Given the <kbd>IntroToPython</kbd> class we defined earlier, we might register it without instantiating it, as follows:</p>
<pre>from grader import Grader<br/>from lessons import IntroToPython, Statistics<br/><br/>grader = Grader()<br/><strong>itp_id = grader.register(IntroToPython)</strong></pre>
<p>The method first checks whether that class is a subclass of the <kbd>Assignment</kbd> class. Of course, we implemented a custom <kbd>__subclasshook__</kbd> method, so this includes classes that do not explicitly subclass <kbd>Assignment</kbd>. The naming is, perhaps, a bit deceitful! If it doesn't have the two required methods, it raises an exception. Exceptions are a topic we'll cover in detail in the next chapter; for now, just assume that it makes the program get angry and quit.</p>
<p>Then, we generate a random identifier to represent that specific assignment. We store the <kbd>assignment_class</kbd> in a dictionary indexed by that ID, and return the ID so that the calling code can look that assignment up in the future. Presumably, another object would then place that ID in a course syllabus of some sort so students do the assignments in order, but we won't be doing that for this part of the project.</p>
<div class="packt_infobox">The <kbd>uuid</kbd> function returns a specially formatted string called a universally unique identifier, also known as a globally unique identifier. It essentially represents an extremely large random number that is almost, but not quite, impossible to conflict with another similarly generated identifier. It is a great, quick, and clean way to create an arbitrary ID to keep track of items.</div>
<p>Next up, we have the <kbd>start_assignment</kbd> function, which allows a student to start working on an assignment given the ID of that assignment. All it does is construct an instance of the <kbd>AssignmentGrader</kbd> class we defined earlier and plop it in a dictionary stored on the <kbd>Grader</kbd> class, as follows:</p>
<pre>    def start_assignment(self, student, id):<br/>        self.student_graders[student] = AssignmentGrader(<br/>            student, self.assignment_classes[id]<br/>        )</pre>
<p>After that, we write a couple of proxy methods that get the lesson or check the code for whatever assignment the student is currently working on:</p>
<pre>    def get_lesson(self, student):<br/>        assignment = self.student_graders[student]<br/>        return assignment.lesson()<br/><br/>    def check_assignment(self, student, code):<br/>        assignment = self.student_graders[student]<br/>        return assignment.check(code)</pre>
<p>Finally, we create a method that gives a summary of a student's current assignment progress. It looks up the assignment object and creates a formatted string with all the information we have about that student:</p>
<pre><br/>    def assignment_summary(self, student):<br/>        grader = self.student_graders[student]<br/>        return f"""<br/>        {student}'s attempts at {grader.assignment.__class__.__name__}:<br/><br/>        attempts: {grader.attempts}<br/>        correct: {grader.correct_attempts}<br/><br/>        passed: {grader.correct_attempts &gt; 0}<br/>        """</pre>
<p>And that's it. You'll notice that this case study does not use a ton of inheritance, which may seem a bit odd given the topic of the chapter, but duck typing is very prevalent. It is quite common for Python programs to be designed with inheritance that gets simplified into more versatile constructs as it is iterated on. As another example, I originally defined the <kbd>AssignmentGrader</kbd> as an inheritance relationship, but realized halfway through that it would be better to use composition, for the reasons outlined previously.</p>
<p>Here's a bit of test code that shows all these objects connected together:</p>
<pre>grader = Grader()<br/>itp_id = grader.register(IntroToPython)<br/>stat_id = grader.register(Statistics)<br/><br/>grader.start_assignment("Tammy", itp_id)<br/>print("Tammy's Lesson:", grader.get_lesson("Tammy"))<br/>print(<br/>    "Tammy's check:",<br/>    grader.check_assignment("Tammy", "a = 1 ; b = 'hello'"),<br/>)<br/>print(<br/>    "Tammy's other check:",<br/>    grader.check_assignment("Tammy", "a = 1\nb = 'hello'"),<br/>)<br/><br/>print(grader.assignment_summary("Tammy"))<br/><br/>grader.start_assignment("Tammy", stat_id)<br/>print("Tammy's Lesson:", grader.get_lesson("Tammy"))<br/>print("Tammy's check:", grader.check_assignment("Tammy", "avg=5.25"))<br/>print(<br/>    "Tammy's other check:",<br/>    grader.check_assignment(<br/>        "Tammy", "avg = statistics.mean([1, 5, 18, -3])"<br/>    ),<br/>)<br/><br/>print(grader.assignment_summary("Tammy"))</pre>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Exercises</h1>
                </header>
            
            <article>
                
<p>Look around you at some of the physical objects in your workspace and see if you can describe them in an inheritance hierarchy. Humans have been dividing the world into taxonomies like this for centuries, so it shouldn't be difficult. Are there any non-obvious inheritance relationships between classes of objects? If you were to model these objects in a computer application, what properties and methods would they share? Which ones would have to be polymorphically overridden? What properties would be completely different between them?</p>
<p>Now write some code. No, not for the physical hierarchy; that's boring. Physical items have more properties than methods. Just think about a pet programming project you've wanted to tackle in the past year, but never gotten around to. For whatever problem you want to solve, try to think of some basic inheritance relationships and then implement them. Make sure that you also pay attention to the sorts of relationships that you actually don't need to use inheritance for. Are there any places where you might want to use multiple inheritance? Are you sure? Can you see any place where you would want to use a mixin? Try to knock together a quick prototype. It doesn't have to be useful or even partially working. You've seen how you can test code using <kbd>python -i</kbd> already; just write some code and test it in the interactive interpreter. If it works, write some more. If it doesn't, fix it!</p>
<p>Now, take a look at the student grader system in the case study. There is a lot missing from it, and not just decent course content! How do students get into the system? Is there a curriculum that defines which order they should study lessons in? What happens if you change the <kbd>AssignmentGrader</kbd> to use inheritance, rather than composition, on the <kbd>Assignment</kbd> objects?</p>
<p>Finally, try to come up with some good use cases for mixins, then experiment with them until you realize that there is probably a better design using composition!</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Summary</h1>
                </header>
            
            <article>
                
<p>We've gone from simple inheritance, one of the most useful tools in the object-oriented programmer's toolbox, all the way through to multiple inheritance—One of the most complicated. Inheritance can be used to add functionality to existing classes and built-ins using inheritance. Abstracting similar code into a parent class can help increase maintainability. Methods on parent classes can be called using <kbd>super</kbd> and argument lists must be formatted safely for these calls to work when using multiple inheritance. Abstract base classes allow you to document what methods and properties a class must have to fulfill a particular interface, and even allow you to change the very definition of <em>subclass</em>.</p>
<p>In the next chapter, we'll cover the subtle art of handling exceptional circumstances.</p>


            </article>

            
        </section>
    </body></html>