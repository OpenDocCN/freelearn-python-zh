<html><head></head><body>
<div><div><div><div><div><h1 class="title" id="calibre_pb_0"><a id="ch11" class="calibre1"/>Chapter 11. Extending the Master</h1></div></div></div><p class="calibre8">Even though some of the modules that we've written so far can be used on the Master, the focus has still been entirely on managing Minion-based operations. Even runners, which only run on the Master, were originally designed to script tasks between Minions.</p><p class="calibre8">There <a id="id327" class="calibre1"/>are two types of modules that are <a id="id328" class="calibre1"/>designed entirely for Master-side work: external authentication modules and wheel modules. In this chapter, we'll go over:</p><div><ul class="itemizedlist"><li class="listitem">Adding external authentication to the Master</li><li class="listitem">Troubleshooting external authentication modules</li><li class="listitem">Managing Master configuration with wheel modules</li><li class="listitem">Troubleshooting wheel modules</li></ul></div></div>

<div><div><div><div><div><h1 class="title" id="calibre_pb_1"><a id="ch11lvl1sec58" class="calibre1"/>Using external authentication</h1></div></div></div><p class="calibre8">In its <a id="id329" class="calibre1"/>default setup, users only communicate with Salt with one user: usually either <code class="email">root</code> or <code class="email">salt</code>. Any user who has access to log in as that user will be able to issue Salt commands. This may be OK with smaller setups, but it does not scale well at all. Larger organizations will want each user to manage Salt with their own login, and be able to set access controls on a per-user basis. There are also other programs, including Salt API, which require the use of external authentication modules.</p><p class="calibre8">
<strong class="calibre2">External authentication</strong> (or <strong class="calibre2">auth or eauth</strong>) modules <a id="id330" class="calibre1"/>allow individual users to have their own permissions to the various components of Salt. The simplest is probably the <code class="email">pam</code> module, in part because other existing access control mechanisms can be configured inside PAM itself. Unfortunately, PAM is rarely used outside of Linux, so other modules are needed on other platforms.</p></div></div>

<div><div><div><div><div><div><h2 class="title1" id="calibre_pb_2"><a id="ch11lvl2sec92" class="calibre1"/>Authenticating credentials</h2></div></div></div><p class="calibre8">On the<a id="id331" class="calibre1"/> surface, an auth module doesn't need to do much. It only needs to accept a username and password, and check with the appropriate service to ensure that it is valid. If it is, then it returns <code class="email">True</code>. Otherwise, it will return <code class="email">False</code>.</p><p class="calibre8">Let's go ahead and set up an auth module for a fictional web service that accepts a username and password, and returns a status of <code class="email">200</code> (<code class="email">OK</code>) if they are correct and <code class="email">403</code> (<code class="email">FORBIDDEN</code>) if they are not. As with some of the other module types, there is a required function in auth modules. This one is called <code class="email">auth()</code>. Let's go ahead and look at our entire auth module at once:</p><div><pre class="programlisting">'''
Provide authentication using an authentication web service. This service
must be configured with an API ID and API key in the master configuration.

webauth:
  apiid: 0123456789
  apikey: abcdef0123456789abcdef0123456789

This file should be saved as salt/auth/webauth.py
'''
import json
import base64
import urllib
import salt.utils.http


def auth(username, password):
    '''
    Authenticate using an external web authentication service
    '''
    apiid = __opts__.get('webauth', {}).get('apiid', None)
    apikey = __opts__.get('webauth', {}).get('apikey', None)
    url = 'https://api.example.com/v1/checkauth'

    username = urllib.quote(username)
    password = urllib.quote(password)
    data = {
        'type': 'basic',
        'value': base64.b64encode('{0}:{1}'.format(username, password))
    }

    result = salt.utils.http.query(
        path,
        method='POST',
        username=apiid,
        password=apikey,
        data=json.dumps(data),
        status=True,
        opts=__opts__,
    )
    if result.get('status', 403) == 200:
        return True

    return False</pre></div><p class="calibre8">Our <a id="id332" class="calibre1"/>function declaration has two required arguments: username and password. These will be sent to the authentication service to check their validity. Our service doesn't just accept arbitrary credentials; it requires an account to be set up first, with its own authentication, which stores the username and password. So, our first job is to grab the credentials for that service (<code class="email">apiid</code> and <code class="email">apikey</code>) from the master configuration. Then add in the URL to be used for the authentication check:</p><div><pre class="programlisting">    apiid = __opts__.get('webauth', {}).get('apiid', None)
    apikey = __opts__.get('webauth', {}).get('apikey', None)
    url = 'https://api.example.com/v1/checkauth'</pre></div><p class="calibre8">We want to be able to accept special characters in either the username or password, but since they won't translate properly over the wire, we use Python's <code class="email">urllib</code> library to add quoting to them. Then we format the credentials in the way that the external web service expects:</p><div><pre class="programlisting">    username = urllib.quote(username)
    password = urllib.quote(password)
    data = {
        'type': 'basic',
        'value': base64.b64encode('{0}:{1}'.format(username, password))
    }</pre></div><p class="calibre8">Now that we have all of the data set up to pass to the web service, we use the <code class="email">http.query()</code> function to make the call. <code class="email">apiid</code> and <code class="email">apikey</code> are used as the username and password to the service itself, and the user's username and password are set along as a JSON string. We also make sure to tell <code class="email">http.query()</code> to return a status code, since that is the only part of the result that we care about:</p><div><pre class="programlisting">    result = salt.utils.http.query(
        path,
        method='POST',
        username=apiid,
        password=apikey,
        data=json.dumps(data),
        status=True,
        opts=__opts__,
    )</pre></div><p class="calibre8">Once <a id="id333" class="calibre1"/>we have an authentication code, we check to see if it's <code class="email">200</code>. If something goes wrong and there is no code, then we default the value to <code class="email">403</code>, but when it comes down to it, anything other than <code class="email">200</code> means that the credentials will be considered invalid:</p><div><pre class="programlisting">   if result.get('status', 403) == 200:
        return True

    return False</pre></div></div></div></div>

<div><div><div><div><div><h1 class="title" id="calibre_pb_0"><a id="ch11lvl1sec59" class="calibre1"/>Troubleshooting external authentication</h1></div></div></div><p class="calibre8">Troubleshooting <code class="email">auth</code> modules is a little different from other types of module, because what<a id="id334" class="calibre1"/> you're testing is the ability to access a command, not the functionality of the resulting command. This means that the command that you choose to execute should be one that is already known to work, such as <code class="email">test.ping</code>.</p></div>

<div><div><div><div><div><h2 class="title1" id="calibre_pb_1"><a id="ch11lvl2sec93" class="calibre1"/>Setting auth parameters</h2></div></div></div><p class="calibre8">Before <a id="id335" class="calibre1"/>you can use an <code class="email">auth</code> module, you <a id="id336" class="calibre1"/>need to enable it in the master configuration file. Multiple auth modules can be configured, using the <code class="email">external_auth</code> directive:</p><div><pre class="programlisting">external_auth:
  pam:
    moe:
      - .*
      - '@runner'
      - '@wheel'
    larry:
      - test.*
      - disk.*
      - network.*
      - '@runner'
      - '@wheel'
  webauth:
    shemp:
      - test.*
      - network.*
      - '@runner'
      - '@wheel'</pre></div><p class="calibre8">In this example, we have three users set, between two different <code class="email">auth</code> modules. The <code class="email">moe</code> and <code class="email">larry</code> users are set to use the <code class="email">pam</code> module, and the <code class="email">shemp</code> user is set to use the <code class="email">webauth</code> module that we just created. The <code class="email">moe</code> user has access to all execution modules, plus the<a id="id337" class="calibre1"/> runner and wheel systems, while <code class="email">larry</code>'s execution module access is limited to the <code class="email">test</code>, <code class="email">disk</code>, and <code class="email">network</code> modules. The <code class="email">shemp</code> user is the same as <code class="email">larry</code>, minus access to the <code class="email">disk</code> module.</p><p class="calibre8">Keep in<a id="id338" class="calibre1"/> mind that Salt API requires <code class="email">@runner</code> and <code class="email">@wheel</code> to be set. If you are not planning on giving users access to resources using Salt API, then you can skip those two lines.</p><p class="calibre8">Once you have <code class="email">external_auth</code> configured, there are two means of testing <code class="email">auth</code> modules: using the <code class="email">salt</code> command on the Master, and using Salt API.</p><div><div><div><div><h3 class="title2"><a id="ch11lvl3sec25" class="calibre1"/>Testing with the salt command</h3></div></div></div><p class="calibre8">The<a id="id339" class="calibre1"/> fastest way to test an <code class="email">auth</code> module is to log in to the Master with the account that the <code class="email">salt-master</code> service is running as and issue a <code class="email">salt</code> command, with the appropriate arguments to set which <code class="email">auth</code> module is to be used, and which credentials to use:</p><div><ul class="itemizedlist"><li class="listitem"><code class="email">--auth</code> or <code class="email">-a</code>: This argument sets which auth module to use. The default argument for this is <code class="email">pam</code>.</li><li class="listitem"><code class="email">--username</code>: The username to authenticate with.</li><li class="listitem"><code class="email">--password</code>: The password to authenticate with.</li></ul></div><p class="calibre8">Assuming that you're testing with the <code class="email">webauth</code> module that we just created, a basic <code class="email">salt</code> command will look like this:</p><div><pre class="programlisting">
<strong class="calibre2">salt --auth=webauth --username=larry --password=123pass '*' test.ping</strong>
</pre></div></div><div><div><div><div><h3 class="title2"><a id="ch11lvl3sec26" class="calibre1"/>Testing with Salt API</h3></div></div></div><p class="calibre8">You<a id="id340" class="calibre1"/> can also test <code class="email">auth</code> modules using Salt API. This can be easily accomplished using the <code class="email">curl</code> command that is commonly available in Linux. Before you can test using this method, you need to configure Salt API inside the <code class="email">master</code> configuration file.</p><p class="calibre8">Please note that the following configuration block is insecure, as it does not use SSL. Never set <code class="email">disable_ssl</code> to <code class="email">True</code> in production! As a safety measure, this configuration block also sets Salt API to only listen to requests from the local host:</p><div><pre class="programlisting">rest_cherrypy:
  port: 8080
  host: 127.0.0.1
  debug: True
  disable_ssl: True</pre></div><p class="calibre8">Once you have Salt API configured, go ahead and start the <code class="email">salt-master</code> and <code class="email">salt-api</code> services in the foreground (in two different windows):</p><div><pre class="programlisting">
<strong class="calibre2"># salt-master -l debug</strong>
<strong class="calibre2"># salt-api -l debug</strong>
</pre></div><p class="calibre8">Use the <a id="id341" class="calibre1"/>following <code class="email">curl</code> command to run the <code class="email">test.ping</code> function:</p><div><pre class="programlisting">
<strong class="calibre2"># curl localhost:8080/run \</strong>
<strong class="calibre2">    -H 'Accept: application/json' \</strong>
<strong class="calibre2">    -d username=larry \</strong>
<strong class="calibre2">    -d password=123pass \</strong>
<strong class="calibre2">    -d eauth=pam \</strong>
<strong class="calibre2">    -d client=local \</strong>
<strong class="calibre2">    -d tgt='*' \</strong>
<strong class="calibre2">    -d fun='test.ping'</strong>
</pre></div><p class="calibre8">The most important arguments here are <code class="email">eauth</code>, which is equivalent to the <code class="email">--auth</code> parameter from the <code class="email">salt</code> command, and <code class="email">client</code>, which specifies which type of module to access. Here, we use <code class="email">local</code>, which refers to execution modules. Some of the other available arguments are <code class="email">runner</code> and <code class="email">wheel</code>, for runner and wheel modules.</p><p class="calibre8">When you issue the preceding command with the correct credentials, you will receive a JSON string back with the result:</p><div><pre class="programlisting">{"return": [{"dufresne": true}]}</pre></div><p class="calibre8">If you issue it with bad credentials, you will receive an error page that includes the following text:</p><div><pre class="programlisting">&lt;h2&gt;401 Unauthorized&lt;/h2&gt;
&lt;p&gt;No permission -- see authorization schemes&lt;/p&gt;</pre></div><p class="calibre8">If you look at the window with <code class="email">salt-master</code> running in the foreground, you will see an error message like this:</p><div><pre class="programlisting">[WARNING ] Authentication failure of type "eauth" occurred for user larry.</pre></div><p class="calibre8">And if you look in the window running <code class="email">salt-api</code>, you will see a message like this:</p><div><pre class="programlisting">
<strong class="calibre2">127.0.0.1 - - [26/Jan/2016:08:25:32] "POST /run HTTP/1.1" 401 1214 "" "curl/7.46.0"</strong>
<strong class="calibre2">[INFO    ] 127.0.0.1 - - [26/Jan/2016:08:25:32] "POST /run HTTP/1.1" 401 1214 "" "curl/7.46.0"</strong>
</pre></div></div></div></div>

<div><div><div><div><div><h1 class="title" id="calibre_pb_0"><a id="ch11lvl1sec60" class="calibre1"/>Managing the Master with the wheel modules</h1></div></div></div><p class="calibre8">The wheel<a id="id342" class="calibre1"/> system is designed to provide an API to <a id="id343" class="calibre1"/>the Master, which is accessible via programs that give external access to the Master, such as Salt API.</p><p class="calibre8">One of the first things that you'll find when writing wheel modules is that there is no command-line program available for testing wheel modules directly. Wheel modules generally include functionality that would be available via some other means, were you logged directly in to the Master, but are still useful when manual access is not an option.</p><p class="calibre8">For instance, possibly the most commonly used wheel module is key, which allows a programmatic way to manage Minion keys without using the key command. Because wheel modules are available to the reactor system, you can write reactor modules that can automatically accept or delete keys for Minions based on predefined conditions.</p></div>

<div><div><div><div><div><h2 class="title1" id="calibre_pb_1"><a id="ch11lvl2sec94" class="calibre1"/>Wrapping a wheel around runners</h2></div></div></div><p class="calibre8">For<a id="id344" class="calibre1"/> our example module, we'll put together a wheel module that returns a small amount of data concerning runner modules. This module is a simplified version of the runner functions inside the <code class="email">sys</code> execution module. The reason these functions might be useful as a wheel module is that runners are designed to run on the Master, not Minions. If you do not run the <code class="email">salt-minion</code> service on the Master, then you have no way to programmatically list available runner modules on the Master.</p><p class="calibre8">To start things off, we'll create a function that does nothing more than list all of the functions available in the runner system:</p><div><pre class="programlisting">'''
Show information about runners on the Master

This file should be saved as salt/wheel/runners.py
'''
import salt.runner


def list_functions():
    '''
    List the functions for all runner modules.
    '''
    run_ = salt.runner.Runner(__opts__)
    return sorted(run_.functions)</pre></div><p class="calibre8">This function doesn't do a whole lot. It sets up a connection to the Runner system and assigns it to a <code class="email">run_ object</code>. Then it returns a sorted list of all of the runner functions available on the Master.</p><p class="calibre8">To<a id="id345" class="calibre1"/> test this, we'll need Salt API configured, just like we did in the <em class="calibre9">Troubleshooting external authentication</em> section. Then we issue a command that sets <code class="email">client</code> to use the <code class="email">wheel</code> system:</p><div><pre class="programlisting">
<strong class="calibre2"># curl localhost:8080/run \</strong>
<strong class="calibre2">    -H 'Accept: application/json' \</strong>
<strong class="calibre2">    -d username=larry \</strong>
<strong class="calibre2">    -d password=123pass \</strong>
<strong class="calibre2">    -d eauth=pam \</strong>
<strong class="calibre2">    -d client=wheel \</strong>
<strong class="calibre2">    -d fun='runners.list_functions'</strong>
</pre></div><p class="calibre8">On a Master that only has the manage module available, we would get a JSON string back that looks like this:</p><div><pre class="programlisting">"return": [{"tag": "salt/wheel/20160126084725920013", "data": {"jid": "20160126084725920013", "return": ["manage.alived", "manage.allowed", "manage.bootstrap", "manage.bootstrap_psexec", "manage.down", "manage.get_stats", "manage.joined", "manage.key_regen", "manage.lane_stats", "manage.list_not_state", "manage.list_state", "manage.not_alived", "manage.not_allowed", "manage.not_joined", "manage.not_present", "manage.not_reaped", "manage.present", "manage.reaped", "manage.road_stats", "manage.safe_accept", "manage.status", "manage.tagify", "manage.up", "manage.versions"], "success": true, "_stamp": "2016-01-26T15:47:25.974625", "tag": "salt/wheel/20160126084725920013", "user": "larry", "fun": "wheel.runners.list_functions"}}]}</pre></div><p class="calibre8">Let's go ahead and build on that a little bit and add a runner-specific version of the <code class="email">sys.doc</code> function in the execution modules:</p><div><pre class="programlisting">from salt.utils.doc import strip_rst as _strip_rst


def doc():
    '''
    Return the docstrings for all runners.
    '''
    run_ = salt.runner.Runner(__opts__)
    docs = {}
    for fun in run_.functions:
        docs[fun] = run_.functions[fun].__doc__
    return _strip_rst(docs)</pre></div><p class="calibre8">Once again, this function sets up a connection to the Runner system, and assigns it to the <code class="email">run_</code> object. It then iterates through the functions inside the <code class="email">run_</code> object, extracting the docstrings that live inside the <code class="email">__doc__</code> attribute. Each docstring is added to a <code class="email">docs</code> dictionary, which is passed through a function in Salt called <code class="email">_strip_rst()</code>, which cleans things up a little bit.</p><p class="calibre8">Let's finish <a id="id346" class="calibre1"/>things up with a function that lists just the runner modules available, but no other information about them such as docstrings or even function names:</p><div><pre class="programlisting">__func_alias__ = {
    'list_': 'list'
}


def list_():
    '''
    List the runners loaded on the minion
    '''
    run_ = salt.runner.Runner(__opts__)
    runners = set()
    for func in run_.functions:
        comps = func.split('.')
        if len(comps) &lt; 2:
            continue
        runners.add(comps[0])
    return sorted(runners)</pre></div><p class="calibre8">This function expands upon the <code class="email">list_runners()</code> function by stripping out function names and adding the resulting module names to a set called <code class="email">runners</code>. As before, a sorted copy of that set is returned.</p></div></div>

<div><div><div><div><div><h2 class="title1" id="calibre_pb_2"><a id="ch11lvl2sec95" class="calibre1"/>The final wheel module</h2></div></div></div><p class="calibre8">With all <a id="id347" class="calibre1"/>of our functions put together, we will end up with a cohesive module that looks like this:</p><div><pre class="programlisting">'''
Show information about runners on the Master

This file should be saved as salt/wheel/runners.py
'''
import salt.runner
from salt.utils.doc import strip_rst as _strip_rst

__func_alias__ = {
    'list_': 'list'
}


def doc():
    '''
    Return the docstrings for all runners.
    '''
    run_ = salt.runner.Runner(__opts__)
    docs = {}
    for fun in run_.functions:
        docs[fun] = run_.functions[fun].__doc__
    return _strip_rst(docs)


def list_():
    '''
    List the runners loaded on the minion
    '''
    run_ = salt.runner.Runner(__opts__)
    runners = set()
    for func in run_.functions:
        comps = func.split('.')
        if len(comps) &lt; 2:
            continue
        runners.add(comps[0])
    return sorted(runners)


def list_functions():
    '''
    List the functions for all runner modules.
    '''
    run_ = salt.runner.Runner(__opts__)
    return sorted(run_.functions)</pre></div></div></div>
<div><div><div><div><h1 class="title" id="calibre_pb_0"><a id="ch11lvl1sec61" class="calibre1"/>Troubleshooting wheel modules</h1></div></div></div><p class="calibre8">Once again, wheel<a id="id348" class="calibre1"/> modules are a little special when it comes to troubleshooting, because there is no specific command-line program in Salt that executes them directly. Unlike <code class="email">auth</code> modules, they can't even be tested using the <code class="email">salt</code> command.</p><p class="calibre8">However, as you have just seen, they can be tested using Salt API and <code class="email">curl</code>:</p><div><pre class="programlisting">
<strong class="calibre2"># curl localhost:8080/run \</strong>
<strong class="calibre2">    -H 'Accept: application/json' \</strong>
<strong class="calibre2">    -d username=larry \</strong>
<strong class="calibre2">    -d password=123pass \</strong>
<strong class="calibre2">    -d eauth=pam \</strong>
<strong class="calibre2">    -d client=wheel \</strong>
<strong class="calibre2">    -d fun='runners.list'</strong>
</pre></div><p class="calibre8">You can<a id="id349" class="calibre1"/> also test wheel modules using the event system in Salt. It is good to get used to testing this way, since wheel modules are so useful inside reactor modules.</p><p class="calibre8">Let's go ahead and set up a reactor that deletes a Minion's key from the Master:</p><div><pre class="programlisting"># This reactor should be saved as /srv/reactor/test_delete.sls
test_delete_minion:
  wheel.key.delete:
    - match: data['bad_minion']</pre></div><p class="calibre8">Then add that reactor to the <code class="email">master</code> configuration file:</p><div><pre class="programlisting">reactor:
  - 'user/minon/delete/*':
    - '/srv/reactor/test_delete.sls'</pre></div><p class="calibre8">Go ahead and create a bad Minion key on the Master:</p><div><pre class="programlisting">
<strong class="calibre2"># touch /etc/salt/pki/master/minions/ronald</strong>
</pre></div><p class="calibre8">After restarting the Master, go ahead and issue a command to trigger the reactor:</p><div><pre class="programlisting">
<strong class="calibre2"># salt myminion event.fire_master '{"bad_minion":"ronald"}' 'user/minion/delete/ronald'</strong>
</pre></div><p class="calibre8">Once you issue this command, you can use the <code class="email">salt-key</code> command to make sure that the Minion's bad key is no longer there:</p><div><pre class="programlisting">
<strong class="calibre2"># salt-key -L</strong>
</pre></div><p class="calibre8">Or for bonus points, why not use Salt API to make sure that Minion's key is gone?:</p><div><pre class="programlisting">
<strong class="calibre2"># curl localhost:8080/run \</strong>
<strong class="calibre2">    -H 'Accept: application/json' \</strong>
<strong class="calibre2">    -d username=larry \</strong>
<strong class="calibre2">    -d password=123pass \</strong>
<strong class="calibre2">    -d eauth=pam \</strong>
<strong class="calibre2">    -d client=wheel \</strong>
<strong class="calibre2">    -d fun='key.list' \</strong>
<strong class="calibre2">    -d match='ronald'</strong>
<strong class="calibre2">{"return": [{"tag": "salt/wheel/20160126091522567932", "data": {"jid": "20160126091522567932", "return": {}, "success": true, "_stamp": "2016-01-26T16:15:22.576966", "tag": "salt/wheel/20160126091522567932", "user": "larry", "fun": "wheel.key.list"}}]}</strong>
</pre></div><p class="calibre8">Don't be <a id="id350" class="calibre1"/>fooled by the fact that <code class="email">success</code> is set to <code class="email">true</code>; the important value here is <code class="email">return</code>, which is an empty dictionary.</p></div>
<div><div><div><div><h1 class="title" id="calibre_pb_0"><a id="ch11lvl1sec62" class="calibre1"/>Summary</h1></div></div></div><p class="calibre8">External authentication (or auth) modules allow an external authentication system to validate user credentials on the Master. This can be used for authenticating a user locally, but it is required for using external systems that connect to Salt.</p><p class="calibre8">Wheel modules allow API access to Master-side functionality. The functions contained in a wheel module generally allow the management of features that are normally available via some other means on the Master locally, but not other means from an external endpoint outside the Master. However, wheel modules can contain any Master-side management that you deem necessary.</p><p class="calibre8">Congratulations! You made it all the way through Extending SaltStack! We've included a couple of appendices to give you some general development guidelines and some information about contributing to the community.</p><p class="calibre8">As you can see, there is a world of Salt development to explore. More modules are added regularly, and occasionally new types of modules will appear as well. While we haven't covered everything there is or will be, you now have a solid foundation that you can use to tackle new Salt code as you come across it. Good luck out there; I hope you win!</p></div>

<div><div><div><div><div><h1 class="title" id="calibre_pb_0"><a id="appA" class="calibre1"/>Appendix A. Connecting Different Modules</h1></div></div></div><p class="calibre8">When building an infrastructure, it is helpful to understand how each of the module types fits together. This includes both how they fit together inside of Salt and how you are able to use those connections to build your own solutions.</p></div>

<div><div><div><div><div><h1 class="title" id="calibre_pb_1"><a id="ch11lvl1sec63" class="calibre1"/>Separating Master and Minion functionality</h1></div></div></div><p class="calibre8">It's easy<a id="id351" class="calibre1"/> to think of Salt in terms of the following: the Master sends commands to the Minions, the Minions do the work, and then the Minions send the results back to the Master. However, the Master and the Minion are two distinct components that work together in harmony to complete their respective tasks.</p><p class="calibre8">It is important to keep in mind that when the Minion is running in a Masterless mode (using <code class="email">salt-call --local</code>), it behaves as its own Master, and outside of a few specific features (such as <code class="email">salt-key</code> and runners that make use of <code class="email">local_client</code>), any feature that is available on the Master is also available on the Minion, using the same configuration options that would appear in the <code class="email">master</code> file, but in the <code class="email">minion</code> file instead.</p><p class="calibre8">But when running with a Master and one or more Minions, they are two distinct entities. Some module types are available to either the Master or the Minion; there are many more that are only available for that specific service.</p><p class="calibre8">Let us <a id="id352" class="calibre1"/>have a look at a diagrammatic representation of the Salt Master topology:</p><div><img src="img/00002.jpeg" alt="Separating Master and Minion functionality" class="calibre10"/></div><p class="calibre11"> </p><p class="calibre8">And <a id="id353" class="calibre1"/>now follows the diagrammatic representation <a id="id354" class="calibre1"/>of the Salt Minion topology:</p><div><img src="img/00003.jpeg" alt="Separating Master and Minion functionality" class="calibre10"/></div><p class="calibre11"> </p><p class="calibre8">Like the <a id="id355" class="calibre1"/>Master and the Minion, each module type is specific and distinct. However, like the Master and the Minion, modules connect to each other and work in concert to accomplish larger workflows. Regardless of module type, the Master and the Minion will always communicate directly (using transport modules, which are beyond the scope of this book). Beyond that, different modules are able to communicate with each other to varying degrees.</p><p class="calibre8">The Master generally uses its own modules directly. Some of those modules may be used to provide Minions with resources (such as file server modules), but a number of them are used entirely for providing resources to the Master itself. Master returners are functionally identical to returners that execute on the Minion, with the exception of how they get their data.</p><p class="calibre8">Minion<a id="id356" class="calibre1"/> modules communicate with each other extensively. Execution modules can pull data from grain and SDB modules (and from pillars, through the Master) and cross-call each other. State modules are themselves called from an execution module, but also have access to cross-callback to execution modules. Renderers are used by a number of different module types, and when all is said and done, returners transport return data to the correct destination.</p><p class="calibre8">Salt Cloud is the odd man out, because while it can be accessed via either a runner or an execution module, it can also be accessed directly, and even used independently of the rest of Salt. In fact, it can be used to manage nodes without even installing Salt on them.</p></div></div>
<div><div><div><div><h1 class="title" id="calibre_pb_0"><a id="ch11lvl1sec64" class="calibre1"/>Working with dunders</h1></div></div></div><p class="calibre8">For those <a id="id357" class="calibre1"/>of you not in the know, <em class="calibre9">dunder</em> refers to a variable that is preceded and succeeded by two underscores. For instance, one of the most common dunders in Salt is <code class="email">__opts__</code>, which contains the configuration for either the Master or the Minion, depending on the context. There are a number of dunders that work together to form the glue that ties all of Salt together. Let's take a look at them in turn:</p><div><ul class="itemizedlist"><li class="listitem"><code class="email">__opts__</code>: On a Master, the <code class="email">__opts__</code> dictionary contains a composite of the <a id="id358" class="calibre1"/>information located in the Master's configuration files (normally <code class="email">/etc/salt/master</code> plus files located in the <code class="email">/etc/salt/master.d/</code> directory), along with the default values for configuration parameters not specified, plus any internal configuration that Salt generates for its own use at runtime.<p class="calibre19">On a Minion, <code class="email">__opts__</code> contains the same sort of information (but from the <code class="email">/etc/salt/minion</code> file and the <code class="email">/etc/salt/minion.d/</code> directory), when it is connected to the Master. However, when the Minion is used in a Masterless mode (such as when called from <code class="email">salt-call --local</code>), any defaults are filled in as if it were a Master, rather than a Minion. This is because lookups such as pillars and files need to be provided from a Master of some sort, and in this capacity the Minion needs to play that role.</p></li><li class="listitem"><code class="email">__salt__</code>: In modules that run on the Minions (most notably execution and state modules), <code class="email">__salt__</code> contains a list of function calls to all of the available<a id="id359" class="calibre1"/> execution modules on the system. These items<a id="id360" class="calibre1"/> can be called directly, as if they were functions inside the calling module itself. For example:<div><pre class="programlisting">__salt__['disk.usage']()
__salt__['cmd.run']('ls -l /')
__salt__['cmd.run']('dir c:\\')</pre></div><p class="calibre19">Using a function in this way is referred to as <em class="calibre9">cross-calling</em>. Because it calls out to execution modules, which are only available as a Minion, the Master does not make use of cross-calling.</p></li><li class="listitem"><code class="email">__grains__</code>: Another Minion-only dunder is the <code class="email">__grains__</code> dictionary, which <a id="id361" class="calibre1"/>contains a copy of all of the grains computed for the Minion. This is used extensively throughout Salt to help Minions auto-detect what kinds of resources are available. It is possible to start <code class="email">salt-call</code> without detecting grains by passing the <code class="email">--skip-grains</code> flag, like this:<div><pre class="programlisting">
<strong class="calibre2"># salt-call --local --skip-grains test.ping</strong>
</pre></div><p class="calibre19">You will notice that if you try this, the Minion responds much more quickly. But if you try to use any modules much more advanced than <code class="email">test</code>, you will quickly find out how important grains are to the functionality of the Minion.</p></li><li class="listitem"><code class="email">__pillar__</code>: Pillars <a id="id362" class="calibre1"/>have their own dunder dictionary as well, whose name is strangely singular (<code class="email">__pillar__</code> instead of <code class="email">__pillars__</code>). Unlike grains, which are generated by the Minion, pillars are generated by the Master. However, if you run <code class="email">salt-call</code> in <code class="email">--local</code> mode like this, you will discover that as <code class="email">__opts__</code> now contains Master-side configuration, pillar configuration that would normally live on the Master will now be accepted by the Minion:<div><pre class="programlisting">
<strong class="calibre2"># salt-call --local test.ping</strong>
</pre></div></li><li class="listitem">This is incredibly useful for writing and debugging pillar modules, since you don't run the risk of contaminating other Minions with bad pillar data.</li><li class="listitem"><code class="email">__context__</code>: This <a id="id363" class="calibre1"/>dictionary is available both to state and execution modules. When Salt fires up the first execution module (which will be the <code class="email">state</code> module on a state run), it creates the <code class="email">__context__</code> dictionary. All of the information entered into this dictionary will persist across each subsequent module, so that different modules have a means of storing information for later use by another module. Once the final module has finished, the <code class="email">__context__</code> dictionary will be destroyed.<p class="calibre19">Make <a id="id364" class="calibre1"/>sure that if you decide to use <code class="email">__context__</code>, you check for the existence of keys in it before trying to set or use them. This is because you really have no way of knowing beforehand which order somebody will use modules in, so you shouldn't assume that things have or have not been populated.</p></li></ul></div><div><h3 class="title2"><a id="note08" class="calibre1"/>Note</h3><p class="calibre8">For<a id="id365" class="calibre1"/> more information about Salt dunders, check out:</p><p class="calibre8">
<a class="calibre1" href="https://docs.saltstack.com/en/latest/topics/development/dunder_dictionaries.html">https://docs.saltstack.com/en/latest/topics/development/dunder_dictionaries.html</a>
</p></div></div>
<div><div><div><div><h1 class="title" id="calibre_pb_0"><a id="ch11lvl1sec65" class="calibre1"/>Using the event bus</h1></div></div></div><p class="calibre8">The event <a id="id366" class="calibre1"/>bus does not appear in the topology drawings because it is available anywhere inside of Salt, just by importing the <code class="email">salt.event</code> library. It also has the ability to call out to other module types, using the reactor system. Reactors have access to execution, state, and runner modules.</p><div><h3 class="title2"><a id="tip09" class="calibre1"/>Tip</h3><p class="calibre8">You may be wondering why we didn't cover reactor modules in this book. In truth, there is no such thing as a reactor module. Reactors are written using standard SLS files, which can include extra functionality using the renderer system. For more thorough discussions on writing and using reactors, be sure to check out <em class="calibre9">Mastering SaltStack</em>, <em class="calibre9">Joseph Hall</em>, <em class="calibre9">Packt Publishing</em>.</p></div><p class="calibre8">Because the event bus is so ubiquitous, it can be a very powerful tool for tying together the other module types into a cohesive workflow.</p><p class="calibre8">For example, let's take a look at Salt Cloud. It can be operated independently from the rest of Salt, but when using a Master + Minions setup, it will fire events to the Master during the creation and deletion process that can be picked up by reactors.</p><p class="calibre8">Salt Cloud events use tags that are namespaced in a way that can be easily determined by reactors:</p><div><pre class="programlisting">salt/cloud/&lt;minion_id&gt;/&lt;operation&gt;</pre></div><p class="calibre8">Available events vary depending on the cloud provider, and the work that provider has been configured to do, but a properly written cloud driver will always fire at least these two events when creating a node:</p><div><pre class="programlisting">salt/cloud/&lt;minion_id&gt;/creating
salt/cloud/&lt;minion_id&gt;/created</pre></div><p class="calibre8">It will also fire these two events when deleting a node:</p><div><pre class="programlisting">salt/cloud/&lt;minion_id&gt;/deleting
salt/cloud/&lt;minion_id&gt;/deleted</pre></div><p class="calibre8">Operations <a id="id367" class="calibre1"/>that perform maintenance on Minions and their resources can be kicked off using these events. For instance, if you want to sync a Minion's resources as soon as it's created, you can use a reactor that looks like:</p><div><pre class="programlisting">sync_minion:
  cmd.saltutil.sync_all:
    - tgt: data['id']</pre></div><p class="calibre8">Because a Minion will be available by the time Salt Cloud sends the <code class="email">salt/cloud/&lt;minion_id&gt;/created</code> tag, you can set a reactor to ensure that the Minion is synced as soon as it comes online, without having to configure any <code class="email">startup_states</code>.</p></div>
<div><div><div><div><h1 class="title" id="calibre_pb_0"><a id="ch11lvl1sec66" class="calibre1"/>Firing events</h1></div></div></div><p class="calibre8">You can fire <a id="id368" class="calibre1"/>events both from the Minion-side modules (such as execution and state modules) and Master-side modules (such as runners). From a Minion-side module, you need nothing more than to call out to the event execution module as follows:</p><div><pre class="programlisting">__salt__['event.fire_master'](data_dict, some_tag)</pre></div><p class="calibre8">But in Master-side modules, you need to do a little more work, since <code class="email">__salt__</code> isn't available. You need to import <code class="email">salt.utils.event</code>, then use it to fire the event. This isn't much more work, but you do have to do some setup. It looks like:</p><div><pre class="programlisting">import os.path
import salt.utils.event
import salt.syspaths
sock_dir = os.path.join(salt.syspaths.SOCK_DIR, 'master')
transport = __opts__.get('transport', 'zeromq')
event = salt.utils.event.get_event(
    'master',
    sock_dir,
    transport,
    listen=False,
)
event.fire_event(data_dict, some_tag)</pre></div><p class="calibre8">Let's go over what happened here. First, we set up our imports. The <code class="email">salt.syspaths</code> library contains information about where standard files and directories will be located on this system. In our case, we need to connect to a socket called <code class="email">master</code>. We use this information to set up a variable called <code class="email">sock_dir</code>, which tells Salt where to find the event bus to connect to.</p><p class="calibre8">We also <a id="id369" class="calibre1"/>find out which transport mechanism is configured for this system. This will usually be <code class="email">zeromq</code>, but it can also be another protocol such as <code class="email">raet</code> or <code class="email">tcp</code>. Then we set up an object using the <code class="email">get_event()</code> function. The first argument says which bus we're dealing with, then the <code class="email">sock_dir</code>, transport, and finally we say that we're not going to be listening for events' we'll be sending them.</p><div><h3 class="title2"><a id="note09" class="calibre1"/>Note</h3><p class="calibre8">What do we mean by <em class="calibre9">which bus we're dealing with</em>? Both the Master and the Minion have their own event bus. A Minion can either fire a message to itself using the <code class="email">minion</code> bus, or to the Master using the <code class="email">master</code> bus. The Minion event bus is rarely used except by the internal Salt code, but the Master bus is used extensively.</p></div><p class="calibre8">Once we have the event object set up, we can fire the event. The data (which can be a list or a dictionary) is specified first, and then the event tag. If you like, you can set up a listener on the Master to see those events come in:</p><div><pre class="programlisting"># salt-run state.event pretty=True</pre></div><p class="calibre8">One of the most useful things that events are used in is reactors. As mentioned earlier, for more information on writing reactors, check out <em class="calibre9">Mastering SaltStack</em>, <em class="calibre9">Joseph Hal</em>
<em class="calibre9">l</em>, <em class="calibre9">Packt Publishing</em>.</p></div>

<div><div><div><div><div><h1 class="title" id="calibre_pb_0"><a id="appB" class="calibre1"/>Appendix B. Contributing Code Upstream</h1></div></div></div><p class="calibre8">A number of users have commented over the years that Salt has a low barrier to entry for new developers. This can be attributed in part both to the friendly and professional community, and the tools that are used to manage the Salt code base.</p></div>

<div><div><div><div><div><h1 class="title" id="calibre_pb_1"><a id="ch11lvl1sec67" class="calibre1"/>How the community works</h1></div></div></div><p class="calibre8">The Salt<a id="id370" class="calibre1"/> community comprises users and developers from all over the globe. The vast majority of these people are professionals who use Salt in a business environment, though some hobbyists have found their place among the ranks too.</p><p class="calibre8">When most people make their way to the community, they are looking for help and information about a particular situation that they are working with. This may be as minor as looking for examples or documentation, or it could be more serious, such as reporting what appears to be a bug in the software.</p><p class="calibre8">Once people have spent some time in the community, they often stick around to help out other users. Remember that while some of them may be experts with Salt and the various pieces of technology that it manages, they are still just users like you, who are contributing their own time to help out people like you.</p></div></div>

<div><div><div><div><div><h1 class="title" id="calibre_pb_0"><a id="ch11lvl1sec68" class="calibre1"/>Asking questions and reporting issues</h1></div></div></div><p class="calibre8">There are<a id="id371" class="calibre1"/> three primary places where the Salt community gets together to discuss the software and help each other out: the mailing list, the IRC chat room, and the issue tracker on GitHub.</p><p class="calibre8">There are three types of messages that you will generally find in these places: questions about the software, bug reports, and feature requests. In general, questions about the software <a id="id372" class="calibre1"/>should be asked either on the mailing list or in IRC. Bug reports and feature requests are better suited to the issue tracker.</p></div>

<div><div><div><div><div><h2 class="title1" id="calibre_pb_1"><a id="ch11lvl2sec96" class="calibre1"/>Using the mailing list</h2></div></div></div><p class="calibre8">The <a id="id373" class="calibre1"/>salt-users mailing list is a very active<a id="id374" class="calibre1"/> discussion environment, hosted on Google Groups. The mailing list can be found at:</p><p class="calibre8">
<a class="calibre1" href="https://groups.google.com/d/forum/salt-users">https://groups.google.com/d/forum/salt-users</a>
</p><p class="calibre8">You can browse the mailing list at the preceding link, or you can set up an e-mail subscription and get messages sent to your inbox, where you can reply to them. There are, typically, a good dozen or so e-mails a day, so if that sounds like too many, then maybe just looking online is the way to go.</p><p class="calibre8">If you're going to post a question, there are a few guidelines that will help you out:</p><div><ul class="itemizedlist"><li class="listitem">When you ask a question, try to post enough information about your problem so that people will be able help you out. In the past, people have asked how to fix a particular problem without stating what the problem actually is, or in some cases, even the part of Salt that the question pertains to. As you can imagine, this isn't helpful to anybody.</li><li class="listitem">Describe what you're trying to do, and what you expect to happen. If something isn't working the way that you expect, make sure to state what is actually happening.</li><li class="listitem">You may need to post the output from a command in order to explain what is happening. If this is the case, make sure to post the actual command that you're running, and the relevant part of the output. If you issue a command that results in dozens of lines of logging output, but the actual error only takes up five lines, then just post those five lines to start with. If somebody asks for more, then go ahead and post more.<div><h3 class="title2"><a id="tip10" class="calibre1"/>Tip</h3><p class="calibre8">Be careful when posting logs and configuration files! All too often, people will accidentally post an API key, password, or private network information without meaning to. Before pasting any information at a place online, where somebody can see it, make sure to remove any sensitive information. Making sure not to post long log messages will make this a lot easier.</p></div></li><li class="listitem">It is also helpful to know which version of Salt you are running. It is likely that your particular experience is unique to a specific version of Salt. Rather than just saying which version of Salt, it is often more helpful to give the output of the following command:<div><pre class="programlisting">
<strong class="calibre2"># salt --versions-report</strong>
</pre></div></li><li class="listitem">If you are working with Salt Cloud, then make sure to get that report instead, using:<div><pre class="programlisting">
<strong class="calibre2"># salt-cloud --versions-report</strong>
</pre></div></li><li class="listitem">Because <a id="id375" class="calibre1"/>Salt Cloud uses a different set of libraries, using its <code class="email">versions</code> report will give more information that may be useful, in addition to all of the version information for Salt itself.</li><li class="listitem">If you happen to find the resolution for your situation from outside the mailing list, it is also a good idea to reply to your own thread with a copy of the solution. The mailing list is archived on Google's servers, and if somebody else with your issue searches for it, they will appreciate seeing the solution. Believe me, few things are more frustrating than finding a dozen different people asking the same question on a dozen different mailing lists, with either no solution or a message from the original person saying, "Hey, I figured it out," and leaving it at that.</li></ul></div></div></div>

<div><div><div><div><div><h2 class="title1" id="calibre_pb_2"><a id="ch11lvl2sec97" class="calibre1"/>Using IRC</h2></div></div></div><p class="calibre8">IRC, or <a id="id376" class="calibre1"/>Internet relay chat, is a type of chat room that's been around for a very long time. If you already have an IRC client, you can <a id="id377" class="calibre1"/>connect to the Freenode server at:</p><p class="calibre8">
<a class="calibre1" href="http://irc.freenode.com">irc.freenode.com</a>
</p><p class="calibre8">And then join the Salt chat room at:</p><div><pre class="programlisting">
<strong class="calibre2">#salt</strong>
</pre></div><p class="calibre8">If you don't have<a id="id378" class="calibre1"/> an IRC client yet, you might want to consider Pidgin, which is a chat client that supports a number of chat protocols. It's not the most popular IRC client by any means, but it's easy to use and available for Windows, Mac, and Linux. You can download it at:</p><p class="calibre8">
<a class="calibre1" href="https://www.pidgin.im/">https://www.pidgin.im/</a>
</p><p class="calibre8">If you <a id="id379" class="calibre1"/>don't want to commit to an IRC client, Freenode does have a web-based IRC client that you can use to connect to Salt's chat room. You can find this client at:</p><p class="calibre8">
<a class="calibre1" href="https://webchat.freenode.net/">https://webchat.freenode.net/</a>
</p><p class="calibre8">When you connect to Salt's chat room, there are a few things that will be useful to know:</p><div><ul class="itemizedlist"><li class="listitem"><strong class="calibre2">Be patient.</strong> There are hundreds of people logged in to the Salt chat room at any given time, but not all of them are actively participating. It is very common for people to log in to an IRC room while at work, and check it periodically throughout the day. When you ask a question, don't expect an immediate answer. Somebody may be watching at that moment and try to help <a id="id380" class="calibre1"/>you, but it may take an hour for the right person to see your question and jump in to try to answer it.</li><li class="listitem"><strong class="calibre2">Be ready to provide information as necessary.</strong> The kind person who offers to help you may ask for log messages or code snippets, or may ask you to try a few different commands, and post the response.<p class="calibre19">You may want to look into getting an account on a text-sharing service. One<a id="id381" class="calibre1"/> such popular service is PasteBin:</p><p class="calibre19">
<a class="calibre1" href="http://pastebin.com/">http://pastebin.com/</a>
</p><p class="calibre19">However, you <a id="id382" class="calibre1"/>might also want to look into using GitHub's gist service:</p><p class="calibre19">
<a class="calibre1" href="https://gist.github.com/">https://gist.github.com/</a>
</p><p class="calibre19">This has become an increasingly popular way to share logs and code snippets as with PasteBin, but with the kind of revision management that Git is known for.</p></li><li class="listitem"><strong class="calibre2">Post solutions.</strong> As <a id="id383" class="calibre1"/>with the mailing list, conversations in the Salt chat room are archived. You can find them at:<p class="calibre19">
<a class="calibre1" href="https://irclog.perlgeek.de/salt/">https://irclog.perlgeek.de/salt/</a>
</p><p class="calibre19">If you find the solution as you are working on the problem, and it's not obvious by looking at the conversation what it is, make sure to post it in the chat room so that others can find it later.</p></li></ul></div></div></div>

<div><div><div><div><div><h2 class="title1" id="calibre_pb_3"><a id="ch11lvl2sec98" class="calibre1"/>Using the issue tracker</h2></div></div></div><p class="calibre8">When<a id="id384" class="calibre1"/> you come across a situation that you know is a bug, or you have a feature request, the Salt issue tracker on GitHub is the way to go. You can find it at:</p><p class="calibre8">
<a class="calibre1" href="https://github.com/saltstack/salt/issues">https://github.com/saltstack/salt/issues</a>
</p><p class="calibre8">You may<a id="id385" class="calibre1"/> come across a situation where you don't know whether your problem is the result of inexperience, or an actual bug. If you're not sure, go ahead and post it on the mailing list. If it is a bug, then you will probably be asked to file an issue in the issue tracker, assuming somebody else hasn't already filed the same issue.</p><p class="calibre8">One of the advantages of filing an issue in the issue tracker is that you are automatically subscribed to updates for that issue. That means that when others post questions and comments on the issue, you will receive an e-mail with a copy of their response. If somebody else posted the issue, then you can still subscribe to it. Just look for the <strong class="calibre2">Subscribe</strong> button on the right-hand side of the issue page:</p><div><img src="img/00004.jpeg" alt="Using the issue tracker" class="calibre10"/></div><p class="calibre11"> </p><p class="calibre8">Once <a id="id386" class="calibre1"/>you hit that button, it will change to say <strong class="calibre2">Unsubscribe</strong>. If you ever get tired of receiving updates for that issue (even if you created it), then you can unsubscribe from it. But if you've left comments, I would encourage you to remain subscribed, in case anybody wants to ask you further questions down the road.</p><p class="calibre8">Once again, make sure to post any relevant information, exactly as you would on the mailing list. Detailed information about the issue, version reports, and code snippets are all helpful. A very recent addition to the Salt issue tracker is the use of templates, which provide reminders as to which information to give.</p></div></div>

<div><div><div><div><div><h2 class="title1" id="calibre_pb_4"><a id="ch11lvl2sec99" class="calibre1"/>Using GitHub markdown</h2></div></div></div><p class="calibre8">One<a id="id387" class="calibre1"/> incredibly helpful feature in GitHub is the ability to use markdown. You can find a helpful guide to markdown<a id="id388" class="calibre1"/> at:</p><p class="calibre8">
<a class="calibre1" href="https://guides.github.com/features/mastering-markdown/">https://guides.github.com/features/mastering-markdown/</a>
</p><p class="calibre8">By far the most useful markdown syntax to know is how to mark out code blocks. The character <a id="id389" class="calibre1"/>used to mark out code is commonly known as the backtick, also known as the grave accent. On an American QWERTY keyboard, this key is located in the top-left position:</p><div><img src="img/00005.jpeg" alt="Using GitHub markdown" class="calibre10"/></div><p class="calibre11"> </p><p class="calibre8">When<a id="id390" class="calibre1"/> you place a single backtick in front of a piece of text and another at the end, then the text will be formatted as a piece of code. If you need to format multiple lines, then start with three backticks together on the first line, and three more together on the last line. Blocking out code this way helps immensely with readability.</p><div><img src="img/00006.jpeg" alt="Using GitHub markdown" class="calibre10"/></div><p class="calibre11"> </p></div></div>

<div><div><div><div><div><h1 class="title" id="calibre_pb_0"><a id="ch11lvl1sec69" class="calibre1"/>Understanding the Salt Style Guide</h1></div></div></div><p class="calibre8">If you've<a id="id391" class="calibre1"/> spent enough time in Python, then you're already familiar with the Style Guide for Python Code, also known as PEP 8. For those who have<a id="id392" class="calibre1"/> not seen it, or if you need a refresher, you can take a look at it here:</p><p class="calibre8">
<a class="calibre1" href="https://www.python.org/dev/peps/pep-0008/">https://www.python.org/dev/peps/pep-0008/</a>
</p><p class="calibre8">There is also a guide to the Salt Coding Style, available at:</p><p class="calibre8">
<a class="calibre1" href="https://docs.saltstack.com/en/latest/topics/development/conventions/style.html">https://docs.saltstack.com/en/latest/topics/development/conventions/style.html</a>
</p><p class="calibre8">In general, Salt <a id="id393" class="calibre1"/>coding conventions follow PEP 8, but there are some key differences:</p><div><ul class="itemizedlist"><li class="listitem"><strong class="calibre2">Quoting:</strong> One of the first conventions that new developers come across is that Salt uses single quotes (') instead of double quotes ("). This applies to everything from string formatting to docstrings.</li><li class="listitem"><strong class="calibre2">Line length:</strong> It is very common for code to restrict lines to no longer than 80 characters. This seems to be especially adhered to in Python, but it is based on an older convention where computer screens were exactly 80 characters wide. Because this is no longer the case, it is considered acceptable in Salt to expand to 120 characters, particularly if it helps with readability.</li><li class="listitem"><strong class="calibre2">Tabs versus spaces:</strong> Salt uses four spaces for indentation. No tabs. No exceptions.</li></ul></div></div>

<div><div><div><div><div><h2 class="title1" id="calibre_pb_1"><a id="ch11lvl2sec100" class="calibre1"/>Using Pylint</h2></div></div></div><p class="calibre8">Salt <a id="id394" class="calibre1"/>makes extensive use of a program called <strong class="calibre2">Pylint</strong> to<a id="id395" class="calibre1"/> ensure that its code adheres to its style guide. You can find information <a id="id396" class="calibre1"/>about installing Pylint at:</p><p class="calibre8">
<a class="calibre1" href="http://www.pylint.org/">http://www.pylint.org/</a>
</p><p class="calibre8">Keep in mind that Salt currently uses Python 2 (the minimum version being 2.6), so if you're working in a distribution where both Python 2 and 3 versions of Pylint are available, make sure you use the Python 2 version.</p><p class="calibre8">The Salt code base ships with a <code class="email">.pylintrc</code> file to be used with Pylint. It doesn't get used by default, so you need to make sure to point it out to Pylint:</p><div><pre class="programlisting">
<strong class="calibre2">$ cd /path/to/salt</strong>
<strong class="calibre2">$ pylint --rcfile=.pylintrc</strong>
</pre></div><p class="calibre8">Not only will this file allow you to check your code against Salt style guidelines but also to check the entire code base at once. This is important, because the loader inserts variables<a id="id397" class="calibre1"/> into modules that wouldn't be picked up otherwise by Pylint.</p></div></div>

<div><div><div><div><div><h1 class="title" id="calibre_pb_0"><a id="ch11lvl1sec70" class="calibre1"/>Creating pull requests on GitHub</h1></div></div></div><p class="calibre8">Whereas<a id="id398" class="calibre1"/> many project communities accept code <a id="id399" class="calibre1"/>only through mailing lists or complex websites, Salt has opted to stick with pull requests for accepting code contributions. A list of active <a id="id400" class="calibre1"/>pull requests can be found at:</p><p class="calibre8">
<a class="calibre1" href="https://github.com/saltstack/salt/pulls">https://github.com/saltstack/salt/pulls</a>
</p><p class="calibre8">The complete details of using Git are way beyond the scope of this book, but it is worth going over the steps to clone the Salt repository and put in a new pull request.</p><p class="calibre8">First, you will need <a id="id401" class="calibre1"/>your own fork of Salt on GitHub. If you don't have one yet, then use the <strong class="calibre2">Fork</strong> button at Salt's own GitHub page:</p><p class="calibre8">
<a class="calibre1" href="https://github.com/saltstack/salt">https://github.com/saltstack/salt</a>
</p><p class="calibre8">Assuming that your GitHub username is <em class="calibre9">mygithubuser</em>, your new fork will appear at:</p><p class="calibre8">
<code class="email">https://github.com/mygithubuser/salt</code>
</p><p class="calibre8">Once you have a fork set up, you'll need to clone a copy to your computer. The following steps assume that you work in a command-line environment, such as Linux:</p><div><ol class="orderedlist"><li class="listitem" value="1">If you have an SSH key set up, you can clone using SSH:<div><pre class="programlisting">
<strong class="calibre2">$ git clone git@github.com:mygithubuser/salt.git</strong>
</pre></div><p class="calibre19">Otherwise, you'll need to clone over HTTPS:</p><div><pre class="programlisting">
<strong class="calibre2">$ git clone https://github.com/mygithubuser/salt.git</strong>
</pre></div></li><li class="listitem" value="2">You will also need to add the original SaltStack repository to your local clone, to be able to create pull requests:<div><pre class="programlisting">
<strong class="calibre2">$ git remote add upstream https://github.com/saltstack/salt.git</strong>
</pre></div></li><li class="listitem" value="3">The default Git branch is <code class="email">develop</code>. If you're adding a new feature to Salt, the work should be performed on a branch based on <code class="email">develop</code>. To create a new branch called <code class="email">newfeature</code> and switch to it, use:<div><pre class="programlisting">
<strong class="calibre2">$ git checkout -b newfeature</strong>
</pre></div></li><li class="listitem" value="4">When you are ready to put in a pull request, it is best to rebase your branch to make sure it doesn't conflict with any other pull requests that have been merged since your last update:<div><pre class="programlisting">
<strong class="calibre2">$ git checkout develop</strong>
<strong class="calibre2">$ git fetch upstream</strong>
<strong class="calibre2">$ git pull upstream develop</strong>
<strong class="calibre2">$ git checkout newfeature</strong>
<strong class="calibre2">$ git rebase develop</strong>
</pre></div><div><h3 class="title2"><a id="note10" class="calibre1"/>Note</h3><p class="calibre8">For more <a id="id402" class="calibre1"/>information on using rebase, check out:</p><p class="calibre8">
<a class="calibre1" href="https://help.github.com/articles/using-git-rebase/">https://help.github.com/articles/using-git-rebase/</a>
</p></div></li><li class="listitem" value="5">Once <a id="id403" class="calibre1"/>you have rebased, go ahead and<a id="id404" class="calibre1"/> push your branch up to GitHub:<div><pre class="programlisting">
<strong class="calibre2">$ git push origin newfeature</strong>
</pre></div></li><li class="listitem" value="6">When you visit your fork on GitHub again, you will see a link that says <strong class="calibre2">New Pull Request</strong>. From there, you can look at the diff readout between your branch and the current version of the <code class="email">develop</code> branch on GitHub, and create your pull request when you're satisfied with it.</li></ol><div></div><p class="calibre8">As with issue submission, pull requests now also have a template to use as a guide to provide useful information about describing the changes that your pull request includes.</p></div>

<div><div><div><div><div><h2 class="title1" id="calibre_pb_1"><a id="ch11lvl2sec101" class="calibre1"/>Using other branches</h2></div></div></div><p class="calibre8">If you're <a id="id405" class="calibre1"/>submitting bug fixes, then it may be more appropriate to submit them against a branch that matches a specific version of Salt. If you know which version of Salt the bug was first found in, then use that branch. The exception would be if the branch in question is so old that it is no longer being maintained. If that is the case, then choose the oldest branch that is being maintained. For instance, if the oldest maintained version is <code class="email">2015.8.x</code>, then check out the <code class="email">2015.8</code> branch:</p><div><pre class="programlisting">
<strong class="calibre2">$ git checkout 2015.8</strong>
</pre></div></div></div>
<div><div><div><div><h1 class="title" id="calibre_pb_0"><a id="ch11lvl1sec71" class="calibre1"/>Understanding test errors in pull requests</h1></div></div></div><p class="calibre8">When<a id="id406" class="calibre1"/> you submit a new pull request, GitHub will trigger<a id="id407" class="calibre1"/> the test suite to run against it. This will take several minutes, as it needs to create a new virtual machine, and start a lint test using Pylint, as well as tests on popular platforms such as CentOS and Ubuntu:</p><div><img src="img/00007.jpeg" alt="Understanding test errors in pull requests" class="calibre10"/></div><p class="calibre11"> </p><p class="calibre8">As the <a id="id408" class="calibre1"/>tests are running, you can check progress <a id="id409" class="calibre1"/>by clicking the <strong class="calibre2">Details</strong> button on the right:</p><div><img src="img/00008.jpeg" alt="Understanding test errors in pull requests" class="calibre10"/></div><p class="calibre11"> </p><p class="calibre8">Click on one of the tests to see more information. You will see output such as error messages, stacktraces, and standard output and standard error output.</p><p class="calibre8">There is a chance that one or more of the test failures that show up in your pull request are not actually your fault. It could be that another pull request was merged, which caused unforeseen issues on the build server. If the errors that show up don't look to be related to your code, leave a comment to ask about it. One of the core developers at SaltStack will see it and help you out.</p><p class="calibre8">Lint errors look a little different. When you look at the details for a lint test, you will see a list of files that are affected. Click on one, and you will see each error marked out. Hover over it<a id="id410" class="calibre1"/> to find out what went wrong:</p><div><img src="img/00009.jpeg" alt="Understanding test errors in pull requests" class="calibre10"/></div><p class="calibre11"> </p><p class="calibre8">If you<a id="id411" class="calibre1"/> would like more information about the lint test, you can click on <strong class="calibre2">Console Output</strong> on the left, to see a full log of the lint test.</p><p class="calibre8">Once you have made corrections to the code in your local Git clone, commit them as you normally would, and push them back up to GitHub:</p><div><pre class="programlisting">
<strong class="calibre2">$ git push origin newfeature</strong>
</pre></div><p class="calibre8">A new test run will be scheduled, and any remaining errors will show up as before. Once all of the errors have been resolved, a core developer will be able to merge your code.</p></div></body></html>