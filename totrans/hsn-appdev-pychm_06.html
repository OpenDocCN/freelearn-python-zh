<html><head></head><body>
<div id="_idContainer221">
<h1 class="chapter-number" id="_idParaDest-143"><a id="_idTextAnchor145"/><span class="koboSpan" id="kobo.1.1">6</span></h1>
<h1 id="_idParaDest-144"><a id="_idTextAnchor146"/><span class="koboSpan" id="kobo.2.1">Seamless Testing, Debugging, and Profiling</span></h1>
<p><span class="koboSpan" id="kobo.3.1">In </span><a href="B19644_05.xhtml#_idTextAnchor112"><span class="No-Break"><em class="italic"><span class="koboSpan" id="kobo.4.1">Chapter 5</span></em></span></a><span class="koboSpan" id="kobo.5.1">, </span><em class="italic"><span class="koboSpan" id="kobo.6.1">Version Control with Git in PyCharm</span></em><span class="koboSpan" id="kobo.7.1">, I talked about </span><em class="italic"><span class="koboSpan" id="kobo.8.1">The Joel Test</span></em><span class="koboSpan" id="kobo.9.1">. </span><span class="koboSpan" id="kobo.9.2">This test is just a list of best practices. </span><span class="koboSpan" id="kobo.9.3">At the top of the list is the use of version control, which was the subject of the previous chapter. </span><span class="koboSpan" id="kobo.9.4">If you looked up the list, you were probably not surprised to see testing was also on the list. </span><span class="koboSpan" id="kobo.9.5">Formalized software testing practices such as </span><strong class="bold"><span class="koboSpan" id="kobo.10.1">test-driven development</span></strong><span class="koboSpan" id="kobo.11.1"> (</span><strong class="bold"><span class="koboSpan" id="kobo.12.1">TDD</span></strong><span class="koboSpan" id="kobo.13.1">) and </span><strong class="bold"><span class="koboSpan" id="kobo.14.1">behavior-driven development</span></strong><span class="koboSpan" id="kobo.15.1"> (</span><strong class="bold"><span class="koboSpan" id="kobo.16.1">BDD</span></strong><span class="koboSpan" id="kobo.17.1">) are the cornerstones of software quality control. </span><span class="koboSpan" id="kobo.17.2">Working with these methodologies helps you create software that is less likely to fail in production. </span><span class="koboSpan" id="kobo.17.3">Done correctly, it also has side benefits, such as preventing scope creep and allowing for effective refactoring on projects that might have neglected best practices and taken on a lot of </span><span class="No-Break"><span class="koboSpan" id="kobo.18.1">technical debt.</span></span></p>
<p><span class="koboSpan" id="kobo.19.1">Several levels of testing are in practice today, including </span><span class="No-Break"><span class="koboSpan" id="kobo.20.1">the following:</span></span></p>
<ul>
<li><strong class="bold"><span class="koboSpan" id="kobo.21.1">Unit testing</span></strong><span class="koboSpan" id="kobo.22.1">, which aims to test basic low-level functionality at the level of functions </span><span class="No-Break"><span class="koboSpan" id="kobo.23.1">or classes</span></span></li>
<li><strong class="bold"><span class="koboSpan" id="kobo.24.1">Integration testing</span></strong><span class="koboSpan" id="kobo.25.1">, which aims to test how components within a larger system </span><span class="No-Break"><span class="koboSpan" id="kobo.26.1">work together</span></span></li>
<li><strong class="bold"><span class="koboSpan" id="kobo.27.1">User interface testing</span></strong><span class="koboSpan" id="kobo.28.1">, which aims to test how interactive elements of a </span><span class="No-Break"><span class="koboSpan" id="kobo.29.1">system work</span></span></li>
<li><strong class="bold"><span class="koboSpan" id="kobo.30.1">End-to-end testing</span></strong><span class="koboSpan" id="kobo.31.1">, which tests an entire system in a </span><span class="No-Break"><span class="koboSpan" id="kobo.32.1">production-like environment</span></span></li>
</ul>
<p><span class="koboSpan" id="kobo.33.1">Like all well-established programming languages, Python has a rich set of testing libraries available. </span><span class="koboSpan" id="kobo.33.2">And since Python is “batteries included,” there are some fine testing tools built into the standard library. </span><span class="koboSpan" id="kobo.33.3">Naturally, third-party solutions have evolved and are available </span><span class="No-Break"><span class="koboSpan" id="kobo.34.1">via </span></span><a href="http://PyPi.org"><span class="No-Break"><span class="koboSpan" id="kobo.35.1">PyPi.org</span></span></a><span class="No-Break"><span class="koboSpan" id="kobo.36.1">.</span></span></p>
<p><span class="koboSpan" id="kobo.37.1">I cut my teeth on Java’s </span><strong class="bold"><span class="koboSpan" id="kobo.38.1">JUnit</span></strong><span class="koboSpan" id="kobo.39.1"> library, and later on its .NET port called </span><strong class="bold"><span class="koboSpan" id="kobo.40.1">NUnit</span></strong><span class="koboSpan" id="kobo.41.1">. </span><span class="koboSpan" id="kobo.41.2">I found it made software development</span><a id="_idIndexMarker509"/><span class="koboSpan" id="kobo.42.1"> very enjoyable. </span><span class="koboSpan" id="kobo.42.2">There’s just </span><a id="_idIndexMarker510"/><span class="koboSpan" id="kobo.43.1">something fun about starting your day with a set of tests that don’t pass, and throughout the day, writing the code to make each one pass. </span><span class="koboSpan" id="kobo.43.2">If you’re disciplined, you will write the bare minimum code needed, and gradually you will see progress as your testing tool changes color from red to green. </span><span class="koboSpan" id="kobo.43.3">You shouldn’t take shortcuts, and you shouldn’t be tempted to write in functionality that seems cool but that you might not need later. </span><span class="koboSpan" id="kobo.43.4">When I made the leap to Python years ago, I was pleased to see so many options regarding testing libraries and frameworks. </span><span class="koboSpan" id="kobo.43.5">I was equally pleased to see that PyCharm supports most of the popular ones right in </span><span class="No-Break"><span class="koboSpan" id="kobo.44.1">the IDE.</span></span></p>
<p><span class="koboSpan" id="kobo.45.1">In this chapter, we’ll be looking at creating unit tests in Python code while following the tenets of TDD. </span><span class="koboSpan" id="kobo.45.2">In TDD, you generally create a set of tests designed to prove your software meets a set of requirements. </span><span class="koboSpan" id="kobo.45.3">These tests are written before you create any functionality in your program, and they start as failures. </span><span class="koboSpan" id="kobo.45.4">Your job is to make the tests pass with the simplest </span><span class="No-Break"><span class="koboSpan" id="kobo.46.1">code possible.</span></span></p>
<p><span class="koboSpan" id="kobo.47.1">Along the way, you’ll need to use a debugger to step through problematic code that either inexplicably fails, or perhaps worse, inexplicably works. </span><span class="koboSpan" id="kobo.47.2">Once your code works and passes tests, you usually want to consider the speed of execution. </span><span class="koboSpan" id="kobo.47.3">The </span><strong class="bold"><span class="koboSpan" id="kobo.48.1">National Health Service</span></strong><span class="koboSpan" id="kobo.49.1"> (</span><strong class="bold"><span class="koboSpan" id="kobo.50.1">NHS</span></strong><span class="koboSpan" id="kobo.51.1">) in Great</span><a id="_idIndexMarker511"/><span class="koboSpan" id="kobo.52.1"> Britain developed an algorithm that matched organ donations to patients in the system. </span><span class="koboSpan" id="kobo.52.2">The complex algorithm had to be fast because there is a limited window of time during which a harvested organ is viable for transplant. </span><span class="koboSpan" id="kobo.52.3">Similar time constraints exist in many other types of applications. </span><span class="koboSpan" id="kobo.52.4">As developers, we need tools to help us pinpoint </span><span class="No-Break"><span class="koboSpan" id="kobo.53.1">efficiency bottlenecks.</span></span></p>
<p><span class="koboSpan" id="kobo.54.1">The following topics will be covered in </span><span class="No-Break"><span class="koboSpan" id="kobo.55.1">this chapter:</span></span></p>
<ul>
<li><span class="koboSpan" id="kobo.56.1">Unit testing in Python </span><span class="No-Break"><span class="koboSpan" id="kobo.57.1">with PyCharm</span></span></li>
<li><span class="koboSpan" id="kobo.58.1">Using PyCharm’s powerful </span><span class="No-Break"><span class="koboSpan" id="kobo.59.1">visual debugger</span></span></li>
<li><span class="koboSpan" id="kobo.60.1">Working with PyCharm’s profiling tools to find performance bottlenecks in </span><span class="No-Break"><span class="koboSpan" id="kobo.61.1">your code</span></span></li>
</ul>
<h1 id="_idParaDest-145"><a id="_idTextAnchor147"/><span class="koboSpan" id="kobo.62.1">Technical requirements</span></h1>
<p><span class="koboSpan" id="kobo.63.1">The following are the prerequisites for </span><span class="No-Break"><span class="koboSpan" id="kobo.64.1">this chapter:</span></span></p>
<ul>
<li><span class="koboSpan" id="kobo.65.1">A working installation of Python 3.10 </span><span class="No-Break"><span class="koboSpan" id="kobo.66.1">or later</span></span></li>
<li><span class="koboSpan" id="kobo.67.1">A working installation </span><span class="No-Break"><span class="koboSpan" id="kobo.68.1">of PyCharm</span></span></li>
<li><span class="koboSpan" id="kobo.69.1">The sample code for this chapter, which can be found </span><span class="No-Break"><span class="koboSpan" id="kobo.70.1">at </span></span><a href="https://github.com/PacktPublishing/Hands-On-Application-Development-with-PyCharm---Second-Edition/tree/main/chapter-06 "><span class="No-Break"><span class="koboSpan" id="kobo.71.1">https://github.com/PacktPublishing/Hands-On-Application-Development-with-PyCharm---Second-Edition/tree/main/chapter-06</span></span></a></li>
</ul>
<h1 id="_idParaDest-146"><a id="_idTextAnchor148"/><span class="koboSpan" id="kobo.72.1">Testing, testing, 1-2-3</span></h1>
<p><span class="koboSpan" id="kobo.73.1">Unit testing is a</span><a id="_idIndexMarker512"/><span class="koboSpan" id="kobo.74.1"> practice designed to prove your code works as designed. </span><span class="koboSpan" id="kobo.74.2">A good set of tests will match a functional specification. </span><span class="koboSpan" id="kobo.74.3">A great set of tests will do that but also account for any obvious paths of failure. </span><span class="koboSpan" id="kobo.74.4">To get started, let’s get our feet wet with something simple: your bank account. </span><span class="koboSpan" id="kobo.74.5">OK, it doesn’t have to be yours. </span><span class="koboSpan" id="kobo.74.6">Consider a typical transaction where you buy something at a store using your </span><span class="No-Break"><span class="koboSpan" id="kobo.75.1">ATM card.</span></span></p>
<p><span class="koboSpan" id="kobo.76.1">You visit your favorite brick-and-mortar bookstore to pick up your next excellent read in the field of software development. </span><span class="koboSpan" id="kobo.76.2">Let’s say you find a copy of my first book, </span><em class="italic"><span class="koboSpan" id="kobo.77.1">Real World Implementation of C# Design Patterns</span></em><span class="koboSpan" id="kobo.78.1">, published by Packt. </span><span class="koboSpan" id="kobo.78.2">Given its status as an instant classic, you can’t resist picking up a copy at any price. </span><span class="koboSpan" id="kobo.78.3">You tap your card on the bookstore’s point-of-sale system and two </span><span class="No-Break"><span class="koboSpan" id="kobo.79.1">things happen:</span></span></p>
<ol>
<li><span class="koboSpan" id="kobo.80.1">The equivalent of $39.95 – which is an absolute steal by the way – is taken out of your </span><span class="No-Break"><span class="koboSpan" id="kobo.81.1">bank account.</span></span></li>
<li><span class="koboSpan" id="kobo.82.1">The same amount is transferred into the bank account of </span><span class="No-Break"><span class="koboSpan" id="kobo.83.1">the bookstore.</span></span></li>
</ol>
<p><span class="koboSpan" id="kobo.84.1">This is a transactional operation. </span><span class="koboSpan" id="kobo.84.2">Formally speaking, a transaction is a multi-step operation where every step must complete without errors. </span><span class="koboSpan" id="kobo.84.3">It should be an all-or-nothing set of operations. </span><span class="koboSpan" id="kobo.84.4">If the first step completes but the second fails, then $39.95 just vanishes from your bank account and you don’t get to go home with your book. </span><span class="koboSpan" id="kobo.84.5">If the second step works but the first fails, you get a free book, but the local bookseller goes broke. </span><span class="koboSpan" id="kobo.84.6">We need both steps to complete, or at worst, fail completely so that no money </span><span class="No-Break"><span class="koboSpan" id="kobo.85.1">changes hands.</span></span></p>
<p><span class="koboSpan" id="kobo.86.1">This level of criticality is a good scenario for learning about </span><span class="No-Break"><span class="koboSpan" id="kobo.87.1">unit testing.</span></span></p>
<h1 id="_idParaDest-147"><a id="_idTextAnchor149"/><span class="koboSpan" id="kobo.88.1">Unit testing in Python using PyCharm</span></h1>
<p><span class="koboSpan" id="kobo.89.1">Create a new project in PyCharm using the plain Python project template. </span><span class="koboSpan" id="kobo.89.2">Let’s call it </span><strong class="source-inline"><span class="koboSpan" id="kobo.90.1">bank_account</span></strong><span class="koboSpan" id="kobo.91.1">. </span><span class="koboSpan" id="kobo.91.2">You’ll find the </span><a id="_idIndexMarker513"/><span class="koboSpan" id="kobo.92.1">completed example in the source repository for this chapter, but if you’d like to practice creating and testing the necessary code, just </span><span class="No-Break"><span class="koboSpan" id="kobo.93.1">follow along.</span></span></p>
<p><span class="koboSpan" id="kobo.94.1">PyCharm created a file called </span><strong class="source-inline"><span class="koboSpan" id="kobo.95.1">main.py</span></strong><span class="koboSpan" id="kobo.96.1">. </span><span class="koboSpan" id="kobo.96.2">We’ll use it in a moment, but let’s put our bank transaction code in a separate module. </span><span class="koboSpan" id="kobo.96.3">One of the tenets of writing good code is writing </span><strong class="bold"><span class="koboSpan" id="kobo.97.1">testable code</span></strong><span class="koboSpan" id="kobo.98.1">, and the</span><a id="_idIndexMarker514"/><span class="koboSpan" id="kobo.99.1"> best way to write testable </span><a id="_idIndexMarker515"/><span class="koboSpan" id="kobo.100.1">code is to follow the </span><strong class="bold"><span class="koboSpan" id="kobo.101.1">single-responsibility principle</span></strong><span class="koboSpan" id="kobo.102.1"> (</span><strong class="bold"><span class="koboSpan" id="kobo.103.1">SRP</span></strong><span class="koboSpan" id="kobo.104.1">), where you create units of code that have only one responsibility. </span><span class="koboSpan" id="kobo.104.2">SRP is part of a larger set of rules for creating a resilient coding architecture called </span><strong class="bold"><span class="koboSpan" id="kobo.105.1">SOLID</span></strong><span class="koboSpan" id="kobo.106.1">, which is an acronym for the </span><span class="No-Break"><span class="koboSpan" id="kobo.107.1">following principles:</span></span></p>
<ul>
<li><strong class="bold"><span class="koboSpan" id="kobo.108.1">Single-responsibility </span></strong><span class="No-Break"><strong class="bold"><span class="koboSpan" id="kobo.109.1">principle</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.110.1"> (</span></span><span class="No-Break"><strong class="bold"><span class="koboSpan" id="kobo.111.1">SRP</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.112.1">)</span></span></li>
<li><strong class="bold"><span class="koboSpan" id="kobo.113.1">Open-closed </span></strong><span class="No-Break"><strong class="bold"><span class="koboSpan" id="kobo.114.1">principle</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.115.1"> (</span></span><span class="No-Break"><strong class="bold"><span class="koboSpan" id="kobo.116.1">OCP</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.117.1">)</span></span></li>
<li><strong class="bold"><span class="koboSpan" id="kobo.118.1">Liskov substitution </span></strong><span class="No-Break"><strong class="bold"><span class="koboSpan" id="kobo.119.1">principle</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.120.1"> (</span></span><span class="No-Break"><strong class="bold"><span class="koboSpan" id="kobo.121.1">LSP</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.122.1">)</span></span></li>
<li><strong class="bold"><span class="koboSpan" id="kobo.123.1">Interface segregation </span></strong><span class="No-Break"><strong class="bold"><span class="koboSpan" id="kobo.124.1">principle</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.125.1"> (</span></span><span class="No-Break"><strong class="bold"><span class="koboSpan" id="kobo.126.1">ISP</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.127.1">)</span></span></li>
<li><strong class="bold"><span class="koboSpan" id="kobo.128.1">Dependency inversion </span></strong><span class="No-Break"><strong class="bold"><span class="koboSpan" id="kobo.129.1">principle</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.130.1"> (</span></span><span class="No-Break"><strong class="bold"><span class="koboSpan" id="kobo.131.1">DIP</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.132.1">)</span></span></li>
</ul>
<p><span class="koboSpan" id="kobo.133.1">SOLID is normally </span><a id="_idIndexMarker516"/><span class="koboSpan" id="kobo.134.1">considered when developing a </span><strong class="bold"><span class="koboSpan" id="kobo.135.1">fully object-oriented</span></strong><span class="koboSpan" id="kobo.136.1"> (</span><strong class="bold"><span class="koboSpan" id="kobo.137.1">FOO</span></strong><span class="koboSpan" id="kobo.138.1">) architecture using static languages that are strictly object-oriented. </span><span class="koboSpan" id="kobo.138.2">Java, C++, and C# are classic examples of such languages. </span><span class="koboSpan" id="kobo.138.3">Python allows for many different development paradigms, and its implementation of </span><strong class="bold"><span class="koboSpan" id="kobo.139.1">object-oriented programming</span></strong><span class="koboSpan" id="kobo.140.1"> (</span><strong class="bold"><span class="koboSpan" id="kobo.141.1">OOP</span></strong><span class="koboSpan" id="kobo.142.1">) isn’t as </span><a id="_idIndexMarker517"/><span class="koboSpan" id="kobo.143.1">complete, or maybe not as traditional, as many others. </span><span class="koboSpan" id="kobo.143.2">If you’ve never heard of SOLID as a Python developer, that’s probably why. </span><span class="koboSpan" id="kobo.143.3">Books and blogs exist where people have tried to shoehorn Python code to fit, but in my opinion, it often </span><span class="No-Break"><span class="koboSpan" id="kobo.144.1">feels forced.</span></span></p>
<p><span class="koboSpan" id="kobo.145.1">SRP is one you should absolutely follow. </span><span class="koboSpan" id="kobo.145.2">It fits into any language and any paradigm. </span><span class="koboSpan" id="kobo.145.3">Simply put, the elements you make, be they functions, Python packages, or objects, should do only one thing, and do it well. </span><span class="koboSpan" id="kobo.145.4">By breaking up the responsibilities of your code, you can create reusable elements that can easily be unit tested, and therefore easily maintained. </span><span class="koboSpan" id="kobo.145.5">Everything should do one thing. </span><span class="koboSpan" id="kobo.145.6">Of course, there will be something tying it all together – maybe a </span><strong class="source-inline"><span class="koboSpan" id="kobo.146.1">main</span></strong><span class="koboSpan" id="kobo.147.1"> function in a program whose only purpose is to call everything else and provide a flow for </span><span class="No-Break"><span class="koboSpan" id="kobo.148.1">your program.</span></span></p>
<p><span class="koboSpan" id="kobo.149.1">OCP states that once you have shipped a class to production, you should never change it. </span><span class="koboSpan" id="kobo.149.2">You should write your code in such a way that your classes are open to extension, but closed for modification. </span><span class="koboSpan" id="kobo.149.3">This principle is designed to protect the functionality you’ve already tested and shipped. </span><span class="koboSpan" id="kobo.149.4">If you open the class and change it, then you introduce the risk of bugs and you have to retest your entire program. </span><span class="koboSpan" id="kobo.149.5">If you limit your changes to an extension, then you only need to worry about testing </span><span class="No-Break"><span class="koboSpan" id="kobo.150.1">the extension.</span></span></p>
<p><span class="koboSpan" id="kobo.151.1">LSP doesn’t translate easily to Python. </span><span class="koboSpan" id="kobo.151.2">It states that any sub-class should be able to replace its superclass without affecting the correctness of the program. </span><span class="koboSpan" id="kobo.151.3">In other words, if a program is using a base class, it should be able to work correctly when you substitute a derived class for the base class. </span><span class="koboSpan" id="kobo.151.4">When you adhere to LSP, you are promoting the concept of</span><a id="_idIndexMarker518"/><span class="koboSpan" id="kobo.152.1"> polymorphism within your classes. </span><span class="koboSpan" id="kobo.152.2">This allows different objects to be treated uniformly through their common supertype, which leads to more flexible and modular designs. </span><span class="koboSpan" id="kobo.152.3">Implementing LSP is hard in dynamic languages such as Python since these languages allow for dynamic typing and late binding of method calls. </span><span class="koboSpan" id="kobo.152.4">For this reason, LSP is even more crucial than it is in static, strongly typed languages. </span><span class="koboSpan" id="kobo.152.5">The challenge comes with the lack of a strict compile type check you get in C#, C++, or Java. </span><span class="koboSpan" id="kobo.152.6">Any design mistakes you make will not surface until runtime. </span><span class="koboSpan" id="kobo.152.7">As a Python developer, you must design very carefully, and test with more intensity than you might in </span><span class="No-Break"><span class="koboSpan" id="kobo.153.1">other languages.</span></span></p>
<p><span class="koboSpan" id="kobo.154.1">ISP states that classes or modules should have interfaces that are tailored to their specific needs. </span><span class="koboSpan" id="kobo.154.2">An interface that specifies the structure and behavior of a class should not contain anything that is not needed by that class. </span><span class="koboSpan" id="kobo.154.3">This doesn’t translate well into Python since Python lacks the traditional interfaces found in languages such as Java and C#. </span><span class="koboSpan" id="kobo.154.4">The word interface can be taken to mean a regular superclass, in which case the superclass shouldn’t contain properties and methods that are never used within </span><span class="No-Break"><span class="koboSpan" id="kobo.155.1">a subclass.</span></span></p>
<p><span class="koboSpan" id="kobo.156.1">DIP is a fundamental principle in object-oriented programming that deals with the dependencies between classes and modules. </span><span class="koboSpan" id="kobo.156.2">It states that high-level modules should not depend on low-level modules, but both should depend on abstractions. </span><span class="koboSpan" id="kobo.156.3">Additionally, it emphasizes that abstractions should not depend on details; rather, details should depend </span><span class="No-Break"><span class="koboSpan" id="kobo.157.1">on abstractions.</span></span></p>
<p><span class="koboSpan" id="kobo.158.1">Here are the key ideas </span><span class="No-Break"><span class="koboSpan" id="kobo.159.1">of DIP:</span></span></p>
<ul>
<li><strong class="bold"><span class="koboSpan" id="kobo.160.1">High-level modules should not depend on low-level modules</span></strong><span class="koboSpan" id="kobo.161.1">: High-level modules represent the higher-level logic or functionality of an application, while low-level modules deal with the implementation details and lower-level operations. </span><span class="koboSpan" id="kobo.161.2">According to DIP, high-level modules should not directly depend on low-level modules. </span><span class="koboSpan" id="kobo.161.3">Instead, both should depend </span><span class="No-Break"><span class="koboSpan" id="kobo.162.1">on abstractions.</span></span></li>
<li><strong class="bold"><span class="koboSpan" id="kobo.163.1">Abstractions should not depend on details</span></strong><span class="koboSpan" id="kobo.164.1">: Abstractions, such as interfaces or abstract classes, define contracts that specify the behavior and functionality expected from the collaborating objects. </span><span class="koboSpan" id="kobo.164.2">DIP states that these abstractions should not depend on the specific implementation details of the lower-level modules. </span><span class="koboSpan" id="kobo.164.3">It promotes the idea of programming to interfaces rather than </span><span class="No-Break"><span class="koboSpan" id="kobo.165.1">concrete implementations.</span></span></li>
</ul>
<p><span class="koboSpan" id="kobo.166.1">To adhere to DIP, it is essential to introduce abstractions, such as interfaces or abstract classes, and program </span><a id="_idIndexMarker519"/><span class="koboSpan" id="kobo.167.1">against those abstractions rather than concrete implementations. </span><span class="koboSpan" id="kobo.167.2">This promotes loose coupling and allows for greater flexibility and </span><a id="_idIndexMarker520"/><span class="koboSpan" id="kobo.168.1">maintainability in the code base. </span><span class="koboSpan" id="kobo.168.2">Ensure you don’t confuse this with </span><strong class="bold"><span class="koboSpan" id="kobo.169.1">dependency injection</span></strong><span class="koboSpan" id="kobo.170.1"> (</span><strong class="bold"><span class="koboSpan" id="kobo.171.1">DI</span></strong><span class="koboSpan" id="kobo.172.1">). </span><span class="koboSpan" id="kobo.172.2">They are related, but not the </span><span class="No-Break"><span class="koboSpan" id="kobo.173.1">same thing.</span></span></p>
<p><span class="koboSpan" id="kobo.174.1">DI is a design pattern or technique that facilitates the implementation of DIP. </span><span class="koboSpan" id="kobo.174.2">DI is a way to provide the dependencies required by a class from an external source, rather than having the class create or manage its </span><span class="No-Break"><span class="koboSpan" id="kobo.175.1">dependencies internally.</span></span></p>
<p><span class="koboSpan" id="kobo.176.1">In DI, the responsibility of creating and providing dependencies is delegated to an external entity, typically called an “injector” or “container.” </span><span class="koboSpan" id="kobo.176.2">The container is responsible for creating instances of classes and injecting their dependencies. </span><span class="koboSpan" id="kobo.176.3">This allows for better decoupling and flexibility and easier testing since dependencies can easily be substituted or mocked during </span><span class="No-Break"><span class="koboSpan" id="kobo.177.1">unit testing.</span></span></p>
<p><span class="koboSpan" id="kobo.178.1">DI can be seen as an implementation strategy for achieving the principles outlined in DIP. </span><span class="koboSpan" id="kobo.178.2">It helps in adhering to DIP by providing a mechanism that inverts the control of dependencies and separates the creation of objects from </span><span class="No-Break"><span class="koboSpan" id="kobo.179.1">their usage.</span></span></p>
<p><span class="koboSpan" id="kobo.180.1">In summary, DIP is a guideline for designing modular, loosely coupled systems, while DI is a technique or pattern that’s used to implement DIP, which it does by externalizing the responsibility of </span><span class="No-Break"><span class="koboSpan" id="kobo.181.1">managing dependencies.</span></span></p>
<p><span class="koboSpan" id="kobo.182.1">If you are interested in this kind of architecture, you should check out that book I plugged earlier as SOLID is covered extensively throughout, albeit with C# as the language. </span><span class="koboSpan" id="kobo.182.2">SRP, however, fits nicely with any language or paradigm, </span><span class="No-Break"><span class="koboSpan" id="kobo.183.1">Python included.</span></span></p>
<p><span class="koboSpan" id="kobo.184.1">When you stick with functions and classes that only do one thing, and do it well, testing them is a breeze because the functionality is isolated. </span><span class="koboSpan" id="kobo.184.2">Functions or classes that try to do too much are harder to</span><a id="_idIndexMarker521"/><span class="koboSpan" id="kobo.185.1"> test because of the interplay between dependencies. </span><span class="koboSpan" id="kobo.185.2">Let’s build something to make </span><span class="No-Break"><span class="koboSpan" id="kobo.186.1">this clear.</span></span></p>
<h2 id="_idParaDest-148"><a id="_idTextAnchor150"/><span class="koboSpan" id="kobo.187.1">Choosing a test library</span></h2>
<p><span class="koboSpan" id="kobo.188.1">Several popular</span><a id="_idIndexMarker522"/><span class="koboSpan" id="kobo.189.1"> unit testing libraries are available for Python 3. </span><span class="koboSpan" id="kobo.189.2">Some of the most widely used include </span><span class="No-Break"><span class="koboSpan" id="kobo.190.1">the following:</span></span></p>
<ul>
<li><strong class="source-inline"><span class="koboSpan" id="kobo.191.1">unittest</span></strong><span class="koboSpan" id="kobo.192.1">: This is Python’s built-in unit testing framework, often referred to as </span><strong class="source-inline"><span class="koboSpan" id="kobo.193.1">unittest</span></strong><span class="koboSpan" id="kobo.194.1">. </span><span class="koboSpan" id="kobo.194.2">It provides a set of classes and methods for writing and running tests. </span><strong class="source-inline"><span class="koboSpan" id="kobo.195.1">unittest</span></strong><span class="koboSpan" id="kobo.196.1"> follows the xUnit style of unit testing and offers features such as test discovery, test fixtures, and </span><span class="No-Break"><span class="koboSpan" id="kobo.197.1">assertion methods.</span></span></li>
<li><strong class="source-inline"><span class="koboSpan" id="kobo.198.1">pytest</span></strong><span class="koboSpan" id="kobo.199.1">: </span><strong class="source-inline"><span class="koboSpan" id="kobo.200.1">pytest</span></strong><span class="koboSpan" id="kobo.201.1"> is a popular, feature-rich testing framework that provides a more concise and expressive way of writing tests compared to </span><strong class="source-inline"><span class="koboSpan" id="kobo.202.1">unittest</span></strong><span class="koboSpan" id="kobo.203.1">. </span><span class="koboSpan" id="kobo.203.2">It supports test discovery, fixtures, parameterized tests, and powerful assertion methods. </span><strong class="source-inline"><span class="koboSpan" id="kobo.204.1">pytest</span></strong><span class="koboSpan" id="kobo.205.1"> is known for its simplicity </span><span class="No-Break"><span class="koboSpan" id="kobo.206.1">and flexibility.</span></span></li>
<li><strong class="source-inline"><span class="koboSpan" id="kobo.207.1">nose</span></strong><span class="koboSpan" id="kobo.208.1">: </span><strong class="source-inline"><span class="koboSpan" id="kobo.209.1">nose</span></strong><span class="koboSpan" id="kobo.210.1"> is another popular testing framework that extends the capabilities of </span><strong class="source-inline"><span class="koboSpan" id="kobo.211.1">unittest</span></strong><span class="koboSpan" id="kobo.212.1">. </span><span class="koboSpan" id="kobo.212.2">It provides additional features, such as automatic test discovery, test generators, plugins, and advanced test selection and filtering options. </span><span class="koboSpan" id="kobo.212.3">While </span><strong class="source-inline"><span class="koboSpan" id="kobo.213.1">nose</span></strong><span class="koboSpan" id="kobo.214.1"> is widely used, its popularity has declined in recent years in favor </span><span class="No-Break"><span class="koboSpan" id="kobo.215.1">of </span></span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.216.1">pytest</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.217.1">.</span></span></li>
<li><strong class="source-inline"><span class="koboSpan" id="kobo.218.1">doctest</span></strong><span class="koboSpan" id="kobo.219.1">: </span><strong class="source-inline"><span class="koboSpan" id="kobo.220.1">doctest</span></strong><span class="koboSpan" id="kobo.221.1"> is a unique testing framework that allows you to write tests in the form of interactive examples within docstrings or documentation comments. </span><span class="koboSpan" id="kobo.221.2">It extracts and executes the examples as tests, verifying that the actual output matches the expected output. </span><strong class="source-inline"><span class="koboSpan" id="kobo.222.1">doctest</span></strong><span class="koboSpan" id="kobo.223.1"> is well-suited for testing code documentation </span><span class="No-Break"><span class="koboSpan" id="kobo.224.1">and examples.</span></span></li>
</ul>
<p><span class="koboSpan" id="kobo.225.1">These are just a few examples of popular unit testing libraries in Python. </span><span class="koboSpan" id="kobo.225.2">Each library has its own features, style, and strengths, so it’s worth exploring them to find the one that aligns best with your project’s requirements and your personal preferences. </span><span class="koboSpan" id="kobo.225.3">The neat thing about working with PyCharm is that it supports all of these testing libraries, and the UI for running tests and viewing the results is always </span><span class="No-Break"><span class="koboSpan" id="kobo.226.1">the same.</span></span></p>
<p><span class="koboSpan" id="kobo.227.1">Since this is a book on PyCharm rather than an exposition on testing frameworks, I’m going to be using the </span><strong class="source-inline"><span class="koboSpan" id="kobo.228.1">unittest</span></strong><span class="koboSpan" id="kobo.229.1"> library, which is part of Python’s standard library. </span><span class="koboSpan" id="kobo.229.2">This will keep our sample code free of</span><a id="_idIndexMarker523"/> <span class="No-Break"><span class="koboSpan" id="kobo.230.1">external dependencies.</span></span></p>
<h2 id="_idParaDest-149"><a id="_idTextAnchor151"/><span class="koboSpan" id="kobo.231.1">Adding a bank account class</span></h2>
<p><span class="koboSpan" id="kobo.232.1">Right-click the project title</span><a id="_idIndexMarker524"/><span class="koboSpan" id="kobo.233.1"> in the project window and select </span><strong class="bold"><span class="koboSpan" id="kobo.234.1">New</span></strong><span class="koboSpan" id="kobo.235.1"> | </span><strong class="bold"><span class="koboSpan" id="kobo.236.1">Python File</span></strong><span class="koboSpan" id="kobo.237.1">. </span><span class="koboSpan" id="kobo.237.2">Name the </span><span class="No-Break"><span class="koboSpan" id="kobo.238.1">file </span></span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.239.1">bank_account.py.</span></strong></span></p>
<p><span class="koboSpan" id="kobo.240.1">Next, add the </span><span class="No-Break"><span class="koboSpan" id="kobo.241.1">following code:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.242.1">
class BankAccount:
  def __init__(self, name: str, account_number: str, \
    balance: float):
    self.name = name
    self.account_number = account_number
    self.balance = balance</span></pre> <p><span class="koboSpan" id="kobo.243.1">So far, we’ve created a class called </span><strong class="source-inline"><span class="koboSpan" id="kobo.244.1">BankAccount</span></strong><span class="koboSpan" id="kobo.245.1">, created a constructor, and initialized three member variables called </span><strong class="source-inline"><span class="koboSpan" id="kobo.246.1">name</span></strong><span class="koboSpan" id="kobo.247.1">, </span><strong class="source-inline"><span class="koboSpan" id="kobo.248.1">account number</span></strong><span class="koboSpan" id="kobo.249.1">, and </span><strong class="source-inline"><span class="koboSpan" id="kobo.250.1">balance</span></strong><span class="koboSpan" id="kobo.251.1">. </span><span class="koboSpan" id="kobo.251.2">Next, we’ll add a method designed to handle withdrawing money, but only if the amount is less than </span><span class="No-Break"><span class="koboSpan" id="kobo.252.1">the balance:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.253.1">
  def withdraw(self, amount: float) -&gt; None:
    new_balance = self.balance - amount
    if new_balance &gt; 0:
      self.balance = new_balance
    else:
      raise ValueError("Account overdrawn!")</span></pre> <p><span class="koboSpan" id="kobo.254.1">If the amount that’s withdrawn is more than </span><strong class="source-inline"><span class="koboSpan" id="kobo.255.1">balance</span></strong><span class="koboSpan" id="kobo.256.1">, we throw a </span><strong class="source-inline"><span class="koboSpan" id="kobo.257.1">ValueError</span></strong><span class="koboSpan" id="kobo.258.1"> and issue a message stating </span><strong class="source-inline"><span class="koboSpan" id="kobo.259.1">Account overdrawn!</span></strong><span class="koboSpan" id="kobo.260.1">. </span><span class="koboSpan" id="kobo.260.2">Next, we need a method to add money to the account. </span><span class="koboSpan" id="kobo.260.3">It needs to be a positive number; otherwise, we’ll be doing a withdrawal, not </span><span class="No-Break"><span class="koboSpan" id="kobo.261.1">a deposit:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.262.1">
  def deposit(self, amount: float):
    if amount &gt; 0:
      self.balance += amount
    else:
      raise ValueError("Deposit amount must be greater \
        than 0.")</span></pre> <p><span class="koboSpan" id="kobo.263.1">So far, so good, right? </span><span class="koboSpan" id="kobo.263.2">Since </span><a id="_idIndexMarker525"/><span class="koboSpan" id="kobo.264.1">our methods have some business logic in them, we should create a unit test </span><span class="No-Break"><span class="koboSpan" id="kobo.265.1">for them.</span></span></p>
<h2 id="_idParaDest-150"><a id="_idTextAnchor152"/><span class="koboSpan" id="kobo.266.1">Testing the bank account class</span></h2>
<p><span class="koboSpan" id="kobo.267.1">Right-click the title </span><a id="_idIndexMarker526"/><span class="koboSpan" id="kobo.268.1">of the project in the project window and select </span><strong class="bold"><span class="koboSpan" id="kobo.269.1">New</span></strong><span class="koboSpan" id="kobo.270.1"> | </span><strong class="bold"><span class="koboSpan" id="kobo.271.1">Python File</span></strong><span class="koboSpan" id="kobo.272.1">, but this time, make it a Python unit test, as shown in </span><span class="No-Break"><em class="italic"><span class="koboSpan" id="kobo.273.1">Figure 6</span></em></span><span class="No-Break"><em class="italic"><span class="koboSpan" id="kobo.274.1">.1</span></em></span><span class="No-Break"><span class="koboSpan" id="kobo.275.1">:</span></span></p>
<div>
<div class="IMG---Figure" id="_idContainer186">
<span class="koboSpan" id="kobo.276.1"><img alt="Figure 6.1: There are several templates for a new Python file" src="image/B19644_Figure_6.01.jpg"/></span>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US"><span class="koboSpan" id="kobo.277.1">Figure 6.1: There are several templates for a new Python file</span></p>
<p><span class="koboSpan" id="kobo.278.1">There are several conventions for working with test files. </span><span class="koboSpan" id="kobo.278.2">Some think it’s a good idea to have a folder that contains just tests. </span><span class="koboSpan" id="kobo.278.3">Others think the test file should be right next to the file it is testing. </span><span class="koboSpan" id="kobo.278.4">I like this convention because it allows me to easily see which files in my project lack testing. </span><span class="koboSpan" id="kobo.278.5">Per a similar convention, I’m going to name the file </span><strong class="source-inline"><span class="koboSpan" id="kobo.279.1">back_account_test.py</span></strong><span class="koboSpan" id="kobo.280.1">. </span><span class="koboSpan" id="kobo.280.2">Conventions dictate I either start or end the name of my file with the word </span><em class="italic"><span class="koboSpan" id="kobo.281.1">test</span></em><span class="koboSpan" id="kobo.282.1">. </span><span class="koboSpan" id="kobo.282.2">I have put it at the end because if I don’t, the test file won’t be next to the file it is testing within the </span><span class="No-Break"><span class="koboSpan" id="kobo.283.1">file explorer.</span></span></p>
<p><span class="koboSpan" id="kobo.284.1">PyCharm creates the file, but it isn’t empty. </span><span class="koboSpan" id="kobo.284.2">The code in the file looks </span><span class="No-Break"><span class="koboSpan" id="kobo.285.1">like this:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.286.1">
import unittest
class MyTestCase(unittest.TestCase):
  def test_something(self):
    self.assertEqual(True, False) # add assertion here
if __name__ == '__main__':
  unittest.main()</span></pre> <p><span class="koboSpan" id="kobo.287.1">The IDE has presented us with a template containing a testing class that inherits from Python’s built-in unit testing framework. </span><span class="koboSpan" id="kobo.287.2">The framework is simply but unimaginatively called </span><strong class="source-inline"><span class="koboSpan" id="kobo.288.1">unittest</span></strong><span class="koboSpan" id="kobo.289.1">. </span><span class="koboSpan" id="kobo.289.2">The</span><a id="_idIndexMarker527"/><span class="koboSpan" id="kobo.290.1"> template contains the required import at the top of the file, a testing class, one test method, and a </span><strong class="source-inline"><span class="koboSpan" id="kobo.291.1">dunder-main</span></strong><span class="koboSpan" id="kobo.292.1"> block that allows the script to run standalone. </span><span class="koboSpan" id="kobo.292.2">To get the test working, you need to modify this file. </span><span class="koboSpan" id="kobo.292.3">Start by adding an import to the file containing the class you want to test. </span><span class="koboSpan" id="kobo.292.4">The added line is </span><span class="No-Break"><span class="koboSpan" id="kobo.293.1">in bold:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.294.1">
import unittest
from bank_account import BankAccount</span></pre> <p><span class="koboSpan" id="kobo.295.1">Next, change the name of the class to </span><strong class="source-inline"><span class="koboSpan" id="kobo.296.1">BankAccountTestCase</span></strong><span class="koboSpan" id="kobo.297.1">. </span><span class="koboSpan" id="kobo.297.2">Then, take out the </span><strong class="source-inline"><span class="koboSpan" id="kobo.298.1">test_something(self)</span></strong><span class="koboSpan" id="kobo.299.1"> method entirely and replace it with </span><span class="No-Break"><span class="koboSpan" id="kobo.300.1">this one:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.301.1">
  def test_init(self):
    test_account = BankAccount("Bruce Van Horn", \
      "123355-23434", 4000)
    self.assertEqual(test_account.name, "Bruce Van Horn")
    self.assertEqual(test_account.account_number, \
      "123355-23434")
    self.assertEqual(test_account.balance, 4000)</span></pre> <p><span class="koboSpan" id="kobo.302.1">To be honest, this is kind of a silly test because the constructor logic is extremely simple. </span><span class="koboSpan" id="kobo.302.2">Even I would be tempted to skip it. </span><span class="koboSpan" id="kobo.302.3">That isn’t always the case, though. </span><span class="koboSpan" id="kobo.302.4">If you’re doing something complicated in the constructor, you should unit-test it. </span><span class="koboSpan" id="kobo.302.5">Here, the example serves as a simple one to get us moving. </span><span class="koboSpan" id="kobo.302.6">All we did here was create a new instance of the </span><strong class="source-inline"><span class="koboSpan" id="kobo.303.1">BankAccount</span></strong><span class="koboSpan" id="kobo.304.1"> class and pass in a name, an account number, and an initial balance. </span><span class="koboSpan" id="kobo.304.2">Then, we used</span><a id="_idIndexMarker528"/><span class="koboSpan" id="kobo.305.1"> the </span><strong class="source-inline"><span class="koboSpan" id="kobo.306.1">unittest</span></strong><span class="koboSpan" id="kobo.307.1"> class’ </span><strong class="source-inline"><span class="koboSpan" id="kobo.308.1">assertEqual</span></strong><span class="koboSpan" id="kobo.309.1"> method to check each of the member variables to make sure they were set properly. </span><span class="koboSpan" id="kobo.309.2">There’s pretty much no way they weren’t unless you made a mistake, which is exactly </span><span class="No-Break"><span class="koboSpan" id="kobo.310.1">the point.</span></span></p>
<p class="callout-heading"><span class="koboSpan" id="kobo.311.1">Beware of the pesky self-typing self):</span></p>
<p class="callout"><span class="koboSpan" id="kobo.312.1">Having done a whole chapter on the miracles of auto-completion, I have to admit that sometimes, it can be annoying. </span><span class="koboSpan" id="kobo.312.2">This is one of those times. </span><span class="koboSpan" id="kobo.312.3">The instant you type the opening parenthesis of your test method, PyCharm is going to fill in the word </span><strong class="source-inline"><span class="koboSpan" id="kobo.313.1">self</span></strong><span class="koboSpan" id="kobo.314.1">, along with the closing parenthesis and the colon for the end of the line. </span><span class="koboSpan" id="kobo.314.2">Because I type rapidly, I used to often wind up with something like </span><strong class="source-inline"><span class="koboSpan" id="kobo.315.1">test_init(selfsel):</span></strong><span class="koboSpan" id="kobo.316.1"> before I caught what happened. </span><span class="koboSpan" id="kobo.316.2">I’ve trained my right hand to find the </span><em class="italic"><span class="koboSpan" id="kobo.317.1">End</span></em><span class="koboSpan" id="kobo.318.1"> key on the keyboard as soon as I hit the opening parenthesis. </span><span class="koboSpan" id="kobo.318.2">This jumps you to the end of the auto-completed line. </span><span class="koboSpan" id="kobo.318.3">Hit </span><em class="italic"><span class="koboSpan" id="kobo.319.1">Enter</span></em><span class="koboSpan" id="kobo.320.1">, and you’ll be right where you want </span><span class="No-Break"><span class="koboSpan" id="kobo.321.1">to be.</span></span></p>
<p><span class="koboSpan" id="kobo.322.1">We’re going to add two more tests below the first one. </span><span class="koboSpan" id="kobo.322.2">The first test will test the </span><strong class="source-inline"><span class="koboSpan" id="kobo.323.1">withdraw</span></strong><span class="koboSpan" id="kobo.324.1"> method. </span><span class="koboSpan" id="kobo.324.2">Type in the new method below the first test, but above the line with the </span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.325.1">dunder-main</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.326.1"> test:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.327.1">
def test_withdraw(self):
  self.fail()</span></pre> <p><span class="koboSpan" id="kobo.328.1">Type the test for the deposit below the </span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.329.1">test_withdraw</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.330.1"> method:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.331.1">
def test_deposit(self):
  self.fail()</span></pre> <p><span class="koboSpan" id="kobo.332.1">If you haven’t guessed yet, these two tests are going to fail. </span><span class="koboSpan" id="kobo.332.2">That’s OK. </span><span class="koboSpan" id="kobo.332.3">I like to see them fail so that I know the whole testing setup is working. </span><span class="koboSpan" id="kobo.332.4">One of the benefits and side effects of being a long-time software developer is you don’t just assume anything will just work, regardless of who wrote it or how much the thing costs. </span><span class="koboSpan" id="kobo.332.5">Call it a survival instinct. </span><span class="koboSpan" id="kobo.332.6">If you skip this step, then may the odds be ever in </span><span class="No-Break"><span class="koboSpan" id="kobo.333.1">your favor.</span></span></p>
<h2 id="_idParaDest-151"><a id="_idTextAnchor153"/><span class="koboSpan" id="kobo.334.1">Running the tests</span></h2>
<p><span class="koboSpan" id="kobo.335.1">Let’s run our tests. </span><span class="koboSpan" id="kobo.335.2">Like many </span><a id="_idIndexMarker529"/><span class="koboSpan" id="kobo.336.1">things, there are lots of ways to run the tests. </span><span class="koboSpan" id="kobo.336.2">You have no doubt noticed the appearance of green arrows in your test code, as seen in </span><span class="No-Break"><em class="italic"><span class="koboSpan" id="kobo.337.1">Figure 6</span></em></span><span class="No-Break"><em class="italic"><span class="koboSpan" id="kobo.338.1">.2</span></em></span><span class="No-Break"><span class="koboSpan" id="kobo.339.1">:</span></span></p>
<div>
<div class="IMG---Figure" id="_idContainer187">
<span class="koboSpan" id="kobo.340.1"><img alt="Figure 6.2: Green run arrows will appear in the IDE as you create your tests" src="image/B19644_Figure_6.02.jpg"/></span>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US"><span class="koboSpan" id="kobo.341.1">Figure 6.2: Green run arrows will appear in the IDE as you create your tests</span></p>
<p><span class="koboSpan" id="kobo.342.1">These green arrows trigger a menu when you click them. </span><span class="koboSpan" id="kobo.342.2">For now, we’ll click the first item, which is </span><strong class="bold"><span class="koboSpan" id="kobo.343.1">Run ‘Python tests for…’</span></strong><span class="koboSpan" id="kobo.344.1">. </span><span class="koboSpan" id="kobo.344.2">Clicking the green arrow next to the test class definition will run all the tests in this class. </span><span class="koboSpan" id="kobo.344.3">Clicking the green arrow next to any of the three test methods will run just </span><span class="No-Break"><span class="koboSpan" id="kobo.345.1">that test.</span></span><span class="koboSpan" id="kobo.346.1"> If you click the green arrow next to </span><strong class="source-inline"><span class="koboSpan" id="kobo.347.1">BankAccountTestCase</span></strong><span class="koboSpan" id="kobo.348.1">, the test runner will appear in the tool window at the bottom of the IDE window. </span><span class="koboSpan" id="kobo.348.2">You can see mine in </span><span class="No-Break"><em class="italic"><span class="koboSpan" id="kobo.349.1">Figure 6</span></em></span><span class="No-Break"><em class="italic"><span class="koboSpan" id="kobo.350.1">.3</span></em></span><span class="No-Break"><span class="koboSpan" id="kobo.351.1">:</span></span></p>
<div>
<div class="IMG---Figure" id="_idContainer188">
<span class="koboSpan" id="kobo.352.1"><img alt="Figure 6.3: The test runner shows the tests that run, including those that passed and failed, and the console output" src="image/B19644_Figure_6.03.jpg"/></span>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US"><span class="koboSpan" id="kobo.353.1">Figure 6.3: The test runner shows the tests that run, including those that passed and failed, and the console output</span></p>
<p><span class="koboSpan" id="kobo.354.1">The test runner itself has a complete</span><a id="_idIndexMarker530"/><span class="koboSpan" id="kobo.355.1"> set of tools integrated into its window. </span><span class="koboSpan" id="kobo.355.2">I’ve numbered them in </span><span class="No-Break"><em class="italic"><span class="koboSpan" id="kobo.356.1">Figure 6</span></em></span><span class="No-Break"><em class="italic"><span class="koboSpan" id="kobo.357.1">.3</span></em></span><span class="No-Break"><span class="koboSpan" id="kobo.358.1">:</span></span></p>
<ol>
<li><span class="koboSpan" id="kobo.359.1">This pane shows the tests that passed and those that failed. </span><span class="koboSpan" id="kobo.359.2">They are displayed in a hierarchy that matches the </span><span class="No-Break"><span class="koboSpan" id="kobo.360.1">call hierarchy.</span></span></li>
<li><span class="koboSpan" id="kobo.361.1">This pane shows the console output from the test </span><span class="No-Break"><span class="koboSpan" id="kobo.362.1">run itself.</span></span></li>
<li><span class="koboSpan" id="kobo.363.1">Above the output pane is a summary of the number of passing tests, along with how long the test </span><span class="No-Break"><span class="koboSpan" id="kobo.364.1">suite ran.</span></span></li>
<li><span class="koboSpan" id="kobo.365.1">To the left on the same toolbar is a collection of five buttons, followed by a vertical ellipsis. </span><span class="koboSpan" id="kobo.365.2">The ✓ and   ⃠   buttons will filter out all the passed and failed tests, respectively. </span><span class="koboSpan" id="kobo.365.3">Filtering out the passed tests lets you focus solely on what failed. </span><span class="koboSpan" id="kobo.365.4">Filtering out the failed tests reduces the general malaise and utter hopelessness that you’ll feel when you have 5 out of 100 tests that passed. </span><span class="koboSpan" id="kobo.365.5">When this happens, I usually eat a sandwich and I feel better. </span><span class="koboSpan" id="kobo.365.6">Look at it this way: so long as you have failing tests, your job is probably safe because it would take longer to train a replacement than it would to wait until everything starts working. </span><span class="koboSpan" id="kobo.365.7">See it as a glass half-full. </span><span class="koboSpan" id="kobo.365.8">The next three before the ellipsis allow you to sort your test results, import tests from another file, and review your test run history. </span><span class="koboSpan" id="kobo.365.9">Say you have a test that was passing, then it failed and you wanted to go back and look at the last</span><a id="_idIndexMarker531"/><span class="koboSpan" id="kobo.366.1"> time it passed. </span><span class="koboSpan" id="kobo.366.2">That history is there if you need it. </span><span class="koboSpan" id="kobo.366.3">The ellipsis holds a few more options, including some miscellaneous settings for the test </span><span class="No-Break"><span class="koboSpan" id="kobo.367.1">runner itself.</span></span></li>
<li><span class="koboSpan" id="kobo.368.1">This toolbar allows you to rerun all the tests, rerun only those that failed, and stop a long-running test. </span><span class="koboSpan" id="kobo.368.2">Again, we have a vertical ellipsis, but this one has an interesting option for toggling </span><strong class="bold"><span class="koboSpan" id="kobo.369.1">Auto Test</span></strong><span class="koboSpan" id="kobo.370.1">. </span><span class="koboSpan" id="kobo.370.2">Turning this option on will continually run your tests, for those of you who can’t stand the cursor travel time back down to the </span><span class="No-Break"><span class="koboSpan" id="kobo.371.1">rerun button.</span></span></li>
</ol>
<p><span class="koboSpan" id="kobo.372.1">When you run tests for the first time, PyCharm will create run configurations for you automatically. </span><span class="koboSpan" id="kobo.372.2">You can see them in the </span><strong class="bold"><span class="koboSpan" id="kobo.373.1">Run configuration</span></strong><span class="koboSpan" id="kobo.374.1"> dropdown on the </span><span class="No-Break"><span class="koboSpan" id="kobo.375.1">top toolbar.</span></span></p>
<h2 id="_idParaDest-152"><a id="_idTextAnchor154"/><span class="koboSpan" id="kobo.376.1">Fixing the failing tests</span></h2>
<p><span class="koboSpan" id="kobo.377.1">We have two</span><a id="_idIndexMarker532"/><span class="koboSpan" id="kobo.378.1"> tests that will always fail, no matter what we do. </span><span class="koboSpan" id="kobo.378.2">Let’s start by altering the </span><strong class="source-inline"><span class="koboSpan" id="kobo.379.1">test_withdraw(self)</span></strong><span class="koboSpan" id="kobo.380.1"> method in the </span><strong class="source-inline"><span class="koboSpan" id="kobo.381.1">bank_account_test.py</span></strong><span class="koboSpan" id="kobo.382.1"> file. </span><span class="koboSpan" id="kobo.382.2">Change it </span><span class="No-Break"><span class="koboSpan" id="kobo.383.1">to this:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.384.1">
def test_withdraw(self):
 test_account = BankAccount("Bruce Van Horn", "123355-23434", 4000)
 test_account.withdraw(2000)
 self.assertEqual(test_account.balance, 2000)</span></pre> <p><span class="koboSpan" id="kobo.385.1">The first line instantiates the </span><strong class="source-inline"><span class="koboSpan" id="kobo.386.1">BankAccount</span></strong><span class="koboSpan" id="kobo.387.1"> class with some testable values. </span><span class="koboSpan" id="kobo.387.2">Next, we invoke the </span><strong class="source-inline"><span class="koboSpan" id="kobo.388.1">withdraw</span></strong><span class="koboSpan" id="kobo.389.1"> method and withdraw $2,000. </span><span class="koboSpan" id="kobo.389.2">I hope it is for something fun! </span><span class="koboSpan" id="kobo.389.3">Usually, it is my daughters borrowing my wallet to either shop for clothes or maybe buy raw materials for an engineering project. </span><span class="koboSpan" id="kobo.389.4">I can hope, right? </span><span class="koboSpan" id="kobo.389.5">I now expect my balance to drop from $4,000 to $2,000. </span><span class="koboSpan" id="kobo.389.6">So, I use the </span><strong class="source-inline"><span class="koboSpan" id="kobo.390.1">assertEqual</span></strong><span class="koboSpan" id="kobo.391.1"> method on the </span><strong class="source-inline"><span class="koboSpan" id="kobo.392.1">unittest</span></strong><span class="koboSpan" id="kobo.393.1"> class, which is the superclass for my </span><strong class="source-inline"><span class="koboSpan" id="kobo.394.1">BankAccountTestCase</span></strong><span class="koboSpan" id="kobo.395.1"> class. </span><span class="koboSpan" id="kobo.395.2">I pass in </span><strong class="source-inline"><span class="koboSpan" id="kobo.396.1">test_account.balance</span></strong><span class="koboSpan" id="kobo.397.1">, which will be compared with the </span><span class="No-Break"><span class="koboSpan" id="kobo.398.1">expected result.</span></span></p>
<p><span class="koboSpan" id="kobo.399.1">I fully expect this test to pass! </span><span class="koboSpan" id="kobo.399.2">Click the rerun failed tests button shown in </span><span class="No-Break"><em class="italic"><span class="koboSpan" id="kobo.400.1">Figure 6</span></em></span><em class="italic"><span class="koboSpan" id="kobo.401.1">.3</span></em><span class="koboSpan" id="kobo.402.1">. </span><span class="koboSpan" id="kobo.402.2">It passed! </span><span class="koboSpan" id="kobo.402.3">Now, let’s write the </span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.403.1">test_deposit</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.404.1"> method:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.405.1">
def test_deposit(self):
 test_account = BankAccount("Bruce Van Horn", "123355-23434", 4000)
 test_account.deposit(5000)
 self.assertEqual(test_account.balance, 9000)</span></pre> <p><span class="koboSpan" id="kobo.406.1">The explanation here is the same as the last one, except this time, we are depositing $5,000 into my account. </span><span class="koboSpan" id="kobo.406.2">This rarely happens in real life, so give me a moment while </span><span class="No-Break"><span class="koboSpan" id="kobo.407.1">I celebrate.</span></span></p>
<p><span class="koboSpan" id="kobo.408.1">Rerun the failed tests. </span><span class="koboSpan" id="kobo.408.2">They</span><a id="_idIndexMarker533"/><span class="koboSpan" id="kobo.409.1"> should all pass now! </span><span class="koboSpan" id="kobo.409.2">But we’re not done yet, </span><span class="No-Break"><span class="koboSpan" id="kobo.410.1">are we?</span></span></p>
<p><span class="koboSpan" id="kobo.411.1">So far, these tests have followed the no-fault path. </span><span class="koboSpan" id="kobo.411.2">This means that so far, I’ve only tested the methods while running them as I designed them. </span><span class="koboSpan" id="kobo.411.3">Users in the real world will never do this. </span><span class="koboSpan" id="kobo.411.4">We need to test fault paths </span><span class="No-Break"><span class="koboSpan" id="kobo.412.1">as well.</span></span></p>
<h2 id="_idParaDest-153"><a id="_idTextAnchor155"/><span class="koboSpan" id="kobo.413.1">Testing the fault paths</span></h2>
<p><span class="koboSpan" id="kobo.414.1">There is one</span><a id="_idIndexMarker534"/><span class="koboSpan" id="kobo.415.1"> obvious fault path we designed into the system: the overdraft. </span><span class="koboSpan" id="kobo.415.2">What will happen if we try to take out more money than is available in the current balance? </span><span class="koboSpan" id="kobo.415.3">Or as my daughters might say, how do we generate a signal that tells us it’s time to come home from the mall and hide </span><span class="No-Break"><span class="koboSpan" id="kobo.416.1">the receipts?</span></span></p>
<p><span class="koboSpan" id="kobo.417.1">We account for this in </span><span class="No-Break"><span class="koboSpan" id="kobo.418.1">our code:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.419.1">
def withdraw(self, amount: float) -&gt; None:
    new_balance = self.balance - amount
    if new_balance &gt; 0:
      self.balance = new_balance
    else:
      raise ValueError("Account overdrawn!")</span></pre> <p><span class="koboSpan" id="kobo.420.1">As you can see, we check if the new balance will be a negative number. </span><span class="koboSpan" id="kobo.420.2">If it is, we throw a </span><strong class="source-inline"><span class="koboSpan" id="kobo.421.1">ValueError</span></strong><span class="koboSpan" id="kobo.422.1">. </span><span class="koboSpan" id="kobo.422.2">This test is going to be a little different. </span><span class="koboSpan" id="kobo.422.3">Instead of using </span><strong class="source-inline"><span class="koboSpan" id="kobo.423.1">assertEquals</span></strong><span class="koboSpan" id="kobo.424.1"> to test a no-fault result, we want to verify that when this condition exists, we not only throw an error but that we throw the right kind of error. </span><span class="koboSpan" id="kobo.424.2">This is important because we expect </span><strong class="source-inline"><span class="koboSpan" id="kobo.425.1">ValueError</span></strong><span class="koboSpan" id="kobo.426.1">, but if some other error is produced, the tests will give us a false positive if we only test for a generic </span><strong class="source-inline"><span class="koboSpan" id="kobo.427.1">Exception</span></strong><span class="koboSpan" id="kobo.428.1">. </span><span class="koboSpan" id="kobo.428.2">Add the following test </span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.429.1">BankAccountTestCase</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.430.1"> class:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.431.1">
def test_overdraft(self):
 test_account = BankAccount("Bruce Van Horn", "123355-23434", 4000)
 self.assertRaises(ValueError, test_account.withdraw, 5000)]</span></pre> <p><span class="koboSpan" id="kobo.432.1">As before, we instantiate the </span><strong class="source-inline"><span class="koboSpan" id="kobo.433.1">BankAccount</span></strong><span class="koboSpan" id="kobo.434.1"> class with some testable values. </span><span class="koboSpan" id="kobo.434.2">For the test, we want to</span><a id="_idIndexMarker535"/><span class="koboSpan" id="kobo.435.1"> assert that the withdraw method raises a </span><strong class="source-inline"><span class="koboSpan" id="kobo.436.1">ValueError</span></strong><span class="koboSpan" id="kobo.437.1"> if we pass in more money than what exists in the balance. </span><span class="koboSpan" id="kobo.437.2">Here, we use </span><strong class="source-inline"><span class="koboSpan" id="kobo.438.1">self.assertRaises</span></strong><span class="koboSpan" id="kobo.439.1">, which takes three arguments. </span><span class="koboSpan" id="kobo.439.2">The first argument is the type of error </span><span class="No-Break"><span class="koboSpan" id="kobo.440.1">we expect.</span></span></p>
<p><span class="koboSpan" id="kobo.441.1">The second argument is the method under test. </span><span class="koboSpan" id="kobo.441.2">Note that we’re passing a reference to the function lambda-style. </span><span class="koboSpan" id="kobo.441.3">We aren’t executing the function since we need the </span><strong class="source-inline"><span class="koboSpan" id="kobo.442.1">assertRaises</span></strong><span class="koboSpan" id="kobo.443.1"> function to do that. </span><span class="koboSpan" id="kobo.443.2">Finally, we need to pass in the value of any arguments – in this case, some numbers that are bigger than the four grand I used for instantiation. </span><span class="koboSpan" id="kobo.443.3">In this case, I pass in </span><strong class="source-inline"><span class="koboSpan" id="kobo.444.1">5000</span></strong><span class="koboSpan" id="kobo.445.1">. </span><span class="koboSpan" id="kobo.445.2">When I run this test, it should pass because the function will fail with the </span><strong class="source-inline"><span class="koboSpan" id="kobo.446.1">ValueError</span></strong><span class="koboSpan" id="kobo.447.1"> exception </span><span class="No-Break"><span class="koboSpan" id="kobo.448.1">I expect.</span></span></p>
<p><span class="koboSpan" id="kobo.449.1">There is just one test left: we need to be sure that when we pass a negative number into the </span><strong class="source-inline"><span class="koboSpan" id="kobo.450.1">deposit</span></strong><span class="koboSpan" id="kobo.451.1"> method, we get a </span><strong class="source-inline"><span class="koboSpan" id="kobo.452.1">ValueError</span></strong><span class="koboSpan" id="kobo.453.1">. </span><span class="koboSpan" id="kobo.453.2">I’ll leave this one for you to practice with. </span><span class="koboSpan" id="kobo.453.3">The full working code is in the repository code for </span><span class="No-Break"><span class="koboSpan" id="kobo.454.1">this chapter.</span></span></p>
<h2 id="_idParaDest-154"><a id="_idTextAnchor156"/><span class="koboSpan" id="kobo.455.1">Generating tests automatically</span></h2>
<p><span class="koboSpan" id="kobo.456.1">So far, we’ve</span><a id="_idIndexMarker536"/><span class="koboSpan" id="kobo.457.1"> spent some time writing the </span><strong class="source-inline"><span class="koboSpan" id="kobo.458.1">BankAccout</span></strong><span class="koboSpan" id="kobo.459.1"> class, but think back to our original idea for a use case for unit testing: a financial transaction. </span><span class="koboSpan" id="kobo.459.2">This time, we’re going to write some code that needs to be tested, but instead of a generic test template, we’re going to generate a more </span><span class="No-Break"><span class="koboSpan" id="kobo.460.1">exact test.</span></span></p>
<p><span class="koboSpan" id="kobo.461.1">Let’s start with the code we will be testing. </span><span class="koboSpan" id="kobo.461.2">Create a new file in your project called </span><strong class="source-inline"><span class="koboSpan" id="kobo.462.1">transaction.py</span></strong><span class="koboSpan" id="kobo.463.1">. </span><span class="koboSpan" id="kobo.463.2">The contents of this file should look </span><span class="No-Break"><span class="koboSpan" id="kobo.464.1">as follows:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.465.1">
from bank_account import BankAccount</span></pre> <p><span class="koboSpan" id="kobo.466.1">We’ll need the </span><strong class="source-inline"><span class="koboSpan" id="kobo.467.1">BankAccount</span></strong><span class="koboSpan" id="kobo.468.1"> class since the whole idea is to write code that transfers money from one account to </span><a id="_idIndexMarker537"/><span class="koboSpan" id="kobo.469.1">another in response to the sale of an item. </span><span class="koboSpan" id="kobo.469.2">Speaking of </span><em class="italic"><span class="koboSpan" id="kobo.470.1">item</span></em><span class="koboSpan" id="kobo.471.1">, let’s make a class to represent what we’ll </span><span class="No-Break"><span class="koboSpan" id="kobo.472.1">be buying:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.473.1">
class Item:
  def __init__(self, name: str, price: float):
    self.name = name
    self.price = price</span></pre> <p><span class="koboSpan" id="kobo.474.1">There’s nothing too crazy here – just two instance variables called </span><strong class="source-inline"><span class="koboSpan" id="kobo.475.1">name</span></strong><span class="koboSpan" id="kobo.476.1"> and </span><strong class="source-inline"><span class="koboSpan" id="kobo.477.1">price</span></strong><span class="koboSpan" id="kobo.478.1">. </span><span class="koboSpan" id="kobo.478.2">Now for the hard part: we need a class to represent a transaction. </span><span class="koboSpan" id="kobo.478.3">Remember, a transaction is an atomic operation. </span><span class="koboSpan" id="kobo.478.4">All the steps should be completed. </span><span class="koboSpan" id="kobo.478.5">If there are any errors along the way, everything that happened before the error needs to be </span><span class="No-Break"><span class="koboSpan" id="kobo.479.1">rolled back:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.480.1">
class Transaction:
  def __init__(self, buyer: BankAccount, seller: \
    BankAccount, item: Item):
    self.buyer = buyer
    self.seller = seller
    self.item = item</span></pre> <p><span class="koboSpan" id="kobo.481.1">We started the class with a constructor that initializes two bank accounts and an item. </span><span class="koboSpan" id="kobo.481.2">After this comes the logic for the </span><span class="No-Break"><span class="koboSpan" id="kobo.482.1">transaction itself:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.483.1">
  def do_transaction(self):
    original_buyer_balance = self.buyer.balance
    original_seller_balance = self.seller.balance</span></pre> <p><span class="koboSpan" id="kobo.484.1">We need to store the original balances. </span><span class="koboSpan" id="kobo.484.2">If anything goes awry, we’ll need this information to put everything back the way it was. </span><span class="koboSpan" id="kobo.484.3">Next comes the part where money changes hands. </span><span class="koboSpan" id="kobo.484.4">I’ll </span><a id="_idIndexMarker538"/><span class="koboSpan" id="kobo.485.1">wrap it in </span><span class="No-Break"><span class="koboSpan" id="kobo.486.1">a </span></span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.487.1">try</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.488.1">:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.489.1">
    try:
      self.buyer.withdraw(self.item.price)
      self.seller.deposit(self.item.price)
    except ValueError:
      self.buyer.balance = original_buyer_balance
      self.seller.balance = original_seller_balance
      raise ValueError("Transaction failed and was \
        rolled back")</span></pre> <p><span class="koboSpan" id="kobo.490.1">We attempt to withdraw money from the buyer’s account, then deposit the same amount into the seller’s account. </span><span class="koboSpan" id="kobo.490.2">If a </span><strong class="source-inline"><span class="koboSpan" id="kobo.491.1">ValueError</span></strong><span class="koboSpan" id="kobo.492.1"> is thrown, we put all the money back by restoring the balances to their original values. </span><span class="koboSpan" id="kobo.492.2">Once the money has been restored, we should still raise an error so that the primary application knows the error occurred. </span><span class="koboSpan" id="kobo.492.3">This function will need to report the result to a user interface to let the user know what happened with the transaction. </span><span class="koboSpan" id="kobo.492.4">The last line handles this for us. </span><span class="koboSpan" id="kobo.492.5">In a real application, you might want to create your own custom error that might yield more information, but this one serves us well for </span><span class="No-Break"><span class="koboSpan" id="kobo.493.1">demonstrative purposes.</span></span></p>
<h2 id="_idParaDest-155"><a id="_idTextAnchor157"/><span class="koboSpan" id="kobo.494.1">Generating the transaction test</span></h2>
<p><span class="koboSpan" id="kobo.495.1">Earlier, we created </span><a id="_idIndexMarker539"/><span class="koboSpan" id="kobo.496.1">a new test using the </span><strong class="bold"><span class="koboSpan" id="kobo.497.1">File</span></strong><span class="koboSpan" id="kobo.498.1"> menu. </span><span class="koboSpan" id="kobo.498.2">This gave us a very generic test that had nothing to do with our work up to that point. </span><span class="koboSpan" id="kobo.498.3">This time, we’ll generate a test from the class definition itself. </span><span class="koboSpan" id="kobo.498.4">Right-click the line that starts with </span><strong class="source-inline"><span class="koboSpan" id="kobo.499.1">class Transaction</span></strong><span class="koboSpan" id="kobo.500.1">. </span><span class="koboSpan" id="kobo.500.2">Then, click the </span><strong class="bold"><span class="koboSpan" id="kobo.501.1">Generate…</span></strong><span class="koboSpan" id="kobo.502.1"> menu option, as seen in </span><span class="No-Break"><em class="italic"><span class="koboSpan" id="kobo.503.1">Figure 6</span></em></span><span class="No-Break"><em class="italic"><span class="koboSpan" id="kobo.504.1">.4</span></em></span><span class="No-Break"><span class="koboSpan" id="kobo.505.1">:</span></span></p>
<div>
<div class="IMG---Figure" id="_idContainer189">
<span class="koboSpan" id="kobo.506.1"><img alt="Figure 6.4: The Generate… menu item can be found when you right-click your class definition" src="image/B19644_Figure_6.04.jpg"/></span>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US"><span class="koboSpan" id="kobo.507.1">Figure 6.4: The Generate… menu item can be found when you right-click your class definition</span></p>
<p><span class="koboSpan" id="kobo.508.1">Next, click </span><strong class="bold"><span class="koboSpan" id="kobo.509.1">Test…</span></strong><span class="koboSpan" id="kobo.510.1">, as</span><a id="_idIndexMarker540"/><span class="koboSpan" id="kobo.511.1"> seen in </span><span class="No-Break"><em class="italic"><span class="koboSpan" id="kobo.512.1">Figure 6</span></em></span><span class="No-Break"><em class="italic"><span class="koboSpan" id="kobo.513.1">.5</span></em></span><span class="No-Break"><span class="koboSpan" id="kobo.514.1">:</span></span></p>
<div>
<div class="IMG---Figure" id="_idContainer190">
<span class="koboSpan" id="kobo.515.1"><img alt="Figure 6.5: Click the Test… button to generate your test" src="image/B19644_Figure_6.05.jpg"/></span>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US"><span class="koboSpan" id="kobo.516.1">Figure 6.5: Click the Test… button to generate your test</span></p>
<p><span class="koboSpan" id="kobo.517.1">At this point, a dialog box will appear where</span><a id="_idIndexMarker541"/><span class="koboSpan" id="kobo.518.1"> you can control the test that will be generated, as seen in </span><span class="No-Break"><em class="italic"><span class="koboSpan" id="kobo.519.1">Figure 6</span></em></span><span class="No-Break"><em class="italic"><span class="koboSpan" id="kobo.520.1">.6</span></em></span><span class="No-Break"><span class="koboSpan" id="kobo.521.1">:</span></span></p>
<div>
<div class="IMG---Figure" id="_idContainer191">
<span class="koboSpan" id="kobo.522.1"><img alt="Figure 6.6: PyCharm is about to generate a unit test file based on these settings" src="image/B19644_Figure_6.06.jpg"/></span>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US"><span class="koboSpan" id="kobo.523.1">Figure 6.6: PyCharm is about to generate a unit test file based on these settings</span></p>
<p><span class="koboSpan" id="kobo.524.1">PyCharm is about to create a file called </span><strong class="source-inline"><span class="koboSpan" id="kobo.525.1">test_transaction.py</span></strong><span class="koboSpan" id="kobo.526.1">. </span><span class="koboSpan" id="kobo.526.2">Within that file, instead of a generic test class name, there will be a class definition called </span><strong class="source-inline"><span class="koboSpan" id="kobo.527.1">TestTransaction</span></strong><span class="koboSpan" id="kobo.528.1">. </span><span class="koboSpan" id="kobo.528.2">Finally, within the file, assuming you leave the checkbox ticked, a test method stub will be generated </span><span class="No-Break"><span class="koboSpan" id="kobo.529.1">called </span></span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.530.1">test_do_transaction</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.531.1">.</span></span></p>
<p><span class="koboSpan" id="kobo.532.1">The resulting file contains </span><span class="No-Break"><span class="koboSpan" id="kobo.533.1">this code:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.534.1">
from unittest import TestCase
class TestTransaction(TestCase):
  def test_do_transaction(self):
    self.fail()</span></pre> <p><span class="koboSpan" id="kobo.535.1">Way back in </span><a href="B19644_01.xhtml#_idTextAnchor014"><span class="No-Break"><em class="italic"><span class="koboSpan" id="kobo.536.1">Chapter 1</span></em></span></a><span class="koboSpan" id="kobo.537.1">, I told you that one of the benefits of an IDE is that it can reduce boilerplate. </span><span class="koboSpan" id="kobo.537.2">The first time, PyCharm generated some generic boilerplate for us. </span><span class="koboSpan" id="kobo.537.3">At least we didn’t have to type it in, but it was almost as much effort to change what it generated. </span><span class="koboSpan" id="kobo.537.4">This time, there is </span><a id="_idIndexMarker542"/><span class="koboSpan" id="kobo.538.1">even less work to do. </span><span class="koboSpan" id="kobo.538.2">If I had many methods in my class, there would be a correctly named stub for each </span><span class="No-Break"><span class="koboSpan" id="kobo.539.1">of them.</span></span></p>
<p><span class="koboSpan" id="kobo.540.1">All I must do now is write the code that makes the </span><strong class="source-inline"><span class="koboSpan" id="kobo.541.1">test_do_transaction</span></strong><span class="koboSpan" id="kobo.542.1"> method </span><span class="No-Break"><span class="koboSpan" id="kobo.543.1">pass. </span><span class="koboSpan" id="kobo.543.2">Behold!</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.544.1">
from unittest import TestCase
from bank_account import BankAccount
from transaction import Transaction, Item</span></pre> <p><span class="koboSpan" id="kobo.545.1">We started with the required imports. </span><span class="koboSpan" id="kobo.545.2">I know I’m going to need two tests, rather than just the one PyCharm generated. </span><span class="koboSpan" id="kobo.545.3">PyCharm generated one test method, which I’m using for the no-fault path. </span><span class="koboSpan" id="kobo.545.4">I’ll pass in something that works the way the method is intended to work. </span><span class="koboSpan" id="kobo.545.5">Since I know I have two tests, I can reuse the seller account to keep my test </span><strong class="bold"><span class="koboSpan" id="kobo.546.1">DRY</span></strong><span class="koboSpan" id="kobo.547.1">. </span><span class="koboSpan" id="kobo.547.2">If you’re not familiar with the</span><a id="_idIndexMarker543"/><span class="koboSpan" id="kobo.548.1"> acronym, it stands for </span><strong class="bold"><span class="koboSpan" id="kobo.549.1">Don’t Repeat Yourself</span></strong><span class="koboSpan" id="kobo.550.1">. </span><span class="koboSpan" id="kobo.550.2">By hoisting this code to the top of the file, I only need to type it once. </span><span class="koboSpan" id="kobo.550.3">This code will initialize a seller’s bank account with a balance of $4,000. </span><span class="koboSpan" id="kobo.550.4">It also sets up the item we will be purchasing, which will not change </span><span class="No-Break"><span class="koboSpan" id="kobo.551.1">between tests:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.552.1">
initial_seller_balance = 4000
seller_account = BankAccount("PacktPub", "839423-38402",
               initial_seller_balance)
item = Item("Python book", 39.95)</span></pre> <p><span class="koboSpan" id="kobo.553.1">Next, we will move on to the test class itself, which was generated for us. </span><span class="koboSpan" id="kobo.553.2">We already have </span><span class="No-Break"><span class="koboSpan" id="kobo.554.1">this part:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.555.1">
class TestTransaction(TestCase):
 def test_do_transaction(self):</span></pre> <p><span class="koboSpan" id="kobo.556.1">I’m replacing the generated </span><strong class="source-inline"><span class="koboSpan" id="kobo.557.1">self.fail()</span></strong><span class="koboSpan" id="kobo.558.1"> with code that I hope will cause the test </span><span class="No-Break"><span class="koboSpan" id="kobo.559.1">to pass:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.560.1">
  buyer_account = BankAccount("Bruce Van Horn", "123355-23434", 99)
  item = Item("Python book", 39.95)
  test_transaction = Transaction(buyer_account, \
  seller_account, item)</span></pre> <p><span class="koboSpan" id="kobo.561.1">As usual, I instantiate the classes I’ll be using in the test. </span><span class="koboSpan" id="kobo.561.2">So far, I’ve made two accounts and an item with a price. </span><span class="koboSpan" id="kobo.561.3">Next, I’ll run the method </span><span class="No-Break"><span class="koboSpan" id="kobo.562.1">under test:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.563.1">
  test_transaction.do_transaction()</span></pre> <p><span class="koboSpan" id="kobo.564.1">Then, I’ll check </span><span class="No-Break"><span class="koboSpan" id="kobo.565.1">my results:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.566.1">
  self.assertEqual(buyer_account.balance, 99 - 39.95)
  self.assertEqual(seller_account.balance,\
                   initial_seller_balance + 39.95)</span></pre> <p><span class="koboSpan" id="kobo.567.1">You might be</span><a id="_idIndexMarker544"/><span class="koboSpan" id="kobo.568.1"> tempted to get fancy with the test code. </span><span class="koboSpan" id="kobo.568.2">Be careful with this. </span><span class="koboSpan" id="kobo.568.3">Fancy test code is as likely to break as the purposefully fancy code it is meant to test. </span><span class="koboSpan" id="kobo.568.4">If you are testing complicated math, please don’t duplicate the calculation in the test and then compare it to the code under test. </span><span class="koboSpan" id="kobo.568.5">You should be plugging in known inputs and checking for known outputs. </span><span class="No-Break"><span class="koboSpan" id="kobo.569.1">Nothing more!</span></span></p>
<p><span class="koboSpan" id="kobo.570.1">This test represents the no-fault path. </span><span class="koboSpan" id="kobo.570.2">I fully expect this to pass since this exercise merely entails everything working under ideal conditions. </span><span class="koboSpan" id="kobo.570.3">Let’s see if I’m right. </span><span class="koboSpan" id="kobo.570.4">Click any of the green run buttons. </span><span class="koboSpan" id="kobo.570.5">My result is shown in </span><span class="No-Break"><em class="italic"><span class="koboSpan" id="kobo.571.1">Figure 6</span></em></span><span class="No-Break"><em class="italic"><span class="koboSpan" id="kobo.572.1">.7</span></em></span><span class="No-Break"><span class="koboSpan" id="kobo.573.1">:</span></span></p>
<div>
<div class="IMG---Figure" id="_idContainer192">
<span class="koboSpan" id="kobo.574.1"><img alt="Figure 6.7: So far, so good! My test is passing!" src="image/B19644_Figure_6.07.jpg"/></span>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US"><span class="koboSpan" id="kobo.575.1">Figure 6.7: So far, so good! </span><span class="koboSpan" id="kobo.575.2">My test is passing!</span></p>
<p><span class="koboSpan" id="kobo.576.1">We need a test for at least one fault path. </span><span class="koboSpan" id="kobo.576.2">In this case, it will be to test what happens when I don’t have</span><a id="_idIndexMarker545"/><span class="koboSpan" id="kobo.577.1"> enough in my account to cover buying </span><span class="No-Break"><span class="koboSpan" id="kobo.578.1">a book.</span></span></p>
<p><span class="koboSpan" id="kobo.579.1">Here’s my test for </span><span class="No-Break"><span class="koboSpan" id="kobo.580.1">that case:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.581.1">
def test_transaction_overdraw_fault(self):
 initial_buyer_balance = 5
 buyer_account = BankAccount("Bruce Van Horn", \
  "123355-23434", initial_buyer_balance)
 test_transaction = Transaction(buyer_account, \
  seller_account, item)</span></pre> <p><span class="koboSpan" id="kobo.582.1">When I left for work today, I had at least $9,000 in my account. </span><span class="koboSpan" id="kobo.582.2">But my daughter Phoebe “borrowed” my card out of my jacket pocket. </span><span class="koboSpan" id="kobo.582.3">She said she was going to create a robotic bicycle factory. </span><span class="koboSpan" id="kobo.582.4">I thought nothing of it. </span><span class="koboSpan" id="kobo.582.5">She was kidding, right? </span><span class="koboSpan" id="kobo.582.6">So, I go to the bookstore after work, intent on picking up the </span><span class="No-Break"><span class="koboSpan" id="kobo.583.1">latest masterpiece:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.584.1">
 test_transaction.do_transaction()</span></pre> <p><span class="koboSpan" id="kobo.585.1">The transaction occurs. </span><span class="koboSpan" id="kobo.585.2">Do you know that sound that Pac-Man makes when he gets eaten by a ghost? </span><span class="koboSpan" id="kobo.585.3">I’m</span><a id="_idIndexMarker546"/><span class="koboSpan" id="kobo.586.1"> making that sound now. </span><span class="koboSpan" id="kobo.586.2">The sale will fail; let’s see if the transaction rolls </span><span class="No-Break"><span class="koboSpan" id="kobo.587.1">back correctly:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.588.1">
 self.assertEqual(buyer_account.balance, initial_buyer_balance)
 self.assertEqual(seller_account.balance, initial_seller_balance)</span></pre> <p><span class="koboSpan" id="kobo.589.1">This last piece of code verifies that both the buyer and seller balances are returned to their original values. </span><span class="koboSpan" id="kobo.589.2">Run the tests – they should both pass! </span><span class="koboSpan" id="kobo.589.3">See </span><span class="No-Break"><em class="italic"><span class="koboSpan" id="kobo.590.1">Figure 6</span></em></span><em class="italic"><span class="koboSpan" id="kobo.591.1">.8</span></em><span class="koboSpan" id="kobo.592.1"> for my triumphant test run. </span><span class="koboSpan" id="kobo.592.2">I can’t wait to go home </span><span class="No-Break"><span class="koboSpan" id="kobo.593.1">and relax!</span></span></p>
<div>
<div class="IMG---Figure" id="_idContainer193">
<span class="koboSpan" id="kobo.594.1"><img alt="Figure 6.8: I’d better call my wife and tell her to keep dinner warm for me" src="image/B19644_Figure_6.08.jpg"/></span>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US"><span class="koboSpan" id="kobo.595.1">Figure 6.8: I’d better call my wife and tell her to keep dinner warm for me</span></p>
<p><span class="koboSpan" id="kobo.596.1">It looks like I was a little overconfident. </span><span class="koboSpan" id="kobo.596.2">The output window shows a set of stack traces for everything that went wrong. </span><span class="koboSpan" id="kobo.596.3">It’s so long that I had to scroll down quite a bit to get to the good part of this screenshot. </span><span class="koboSpan" id="kobo.596.4">In the trace (which is not shown), I can see that a few of the errors I thought would be thrown were, and that’s fine. </span><span class="koboSpan" id="kobo.596.5">The two we can see here are not. </span><span class="koboSpan" id="kobo.596.6">First, I intended to verify that the message coming from the exception matched the value I assigned in the definition. </span><span class="koboSpan" id="kobo.596.7">Again, I’m doing this to make sure the error I threw is the one we’re seeing and not some other error resulting from a mistake. </span><span class="koboSpan" id="kobo.596.8">It looks like I didn’t understand the structure of the error, and in fact, there is no attribute called message. </span><span class="koboSpan" id="kobo.596.9">I coulda swore! </span><span class="koboSpan" id="kobo.596.10">Wait – that’s probably from some other language. </span><span class="koboSpan" id="kobo.596.11">OK, I can look </span><span class="No-Break"><span class="koboSpan" id="kobo.597.1">that up.</span></span></p>
<p><span class="koboSpan" id="kobo.598.1">The other, more disturbing</span><a id="_idIndexMarker547"/><span class="koboSpan" id="kobo.599.1"> error is that my transaction didn’t roll back! </span><span class="koboSpan" id="kobo.599.2">As you look at the trace, you’ll see that there are hyperlinks throughout that allow you to navigate directly to the fault code mentioned in the trace. </span><span class="koboSpan" id="kobo.599.3">It is very easy to move around and look for problems. </span><span class="koboSpan" id="kobo.599.4">I can find the line for the first problem in the list of stack traces, as shown in </span><span class="No-Break"><em class="italic"><span class="koboSpan" id="kobo.600.1">Figure 6</span></em></span><span class="No-Break"><em class="italic"><span class="koboSpan" id="kobo.601.1">.9</span></em></span><span class="No-Break"><span class="koboSpan" id="kobo.602.1">:</span></span></p>
<div>
<div class="IMG---Figure" id="_idContainer194">
<span class="koboSpan" id="kobo.603.1"><img alt="Figure 6.9: The stack traces are riddled with hyperlinks that will jump you to the offending section of your code" src="image/B19644_Figure_6.09.jpg"/></span>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US"><span class="koboSpan" id="kobo.604.1">Figure 6.9: The stack traces are riddled with hyperlinks that will jump you to the offending section of your code</span></p>
<p><span class="koboSpan" id="kobo.605.1">Clicking this link takes me to the problematic code shown in </span><span class="No-Break"><em class="italic"><span class="koboSpan" id="kobo.606.1">Figure 6</span></em></span><span class="No-Break"><em class="italic"><span class="koboSpan" id="kobo.607.1">.10</span></em></span><span class="No-Break"><span class="koboSpan" id="kobo.608.1">:</span></span></p>
<div>
<div class="IMG---Figure" id="_idContainer195">
<span class="koboSpan" id="kobo.609.1"><img alt="Figure 6.10: Fiddlesticks! The IDE even told me line 34 was wrong, but I didn’t listen" src="image/B19644_Figure_6.10.jpg"/></span>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US"><span class="koboSpan" id="kobo.610.1">Figure 6.10: Fiddlesticks! </span><span class="koboSpan" id="kobo.610.2">The IDE even told me line 34 was wrong, but I didn’t listen</span></p>
<p><span class="koboSpan" id="kobo.611.1">I have a few options here, don’t I? </span><span class="koboSpan" id="kobo.611.2">I could use the documentation features in PyCharm by hovering over the </span><strong class="source-inline"><span class="koboSpan" id="kobo.612.1">e</span></strong><span class="koboSpan" id="kobo.613.1"> variable. </span><span class="koboSpan" id="kobo.613.2">We talked about automatic documentation features in </span><a href="B19644_04.xhtml#_idTextAnchor077"><span class="No-Break"><em class="italic"><span class="koboSpan" id="kobo.614.1">Chapter 4</span></em></span></a><span class="koboSpan" id="kobo.615.1">. </span><span class="No-Break"><em class="italic"><span class="koboSpan" id="kobo.616.1">Figure 6</span></em></span><em class="italic"><span class="koboSpan" id="kobo.617.1">.11</span></em><span class="koboSpan" id="kobo.618.1"> shows what this looks like in case you’ve been </span><span class="No-Break"><span class="koboSpan" id="kobo.619.1">skipping around:</span></span></p>
<div>
<div class="IMG---Figure" id="_idContainer196">
<span class="koboSpan" id="kobo.620.1"><img alt="Figure 6.11: The auto-documentation feature will give me a link to the official documentation" src="image/B19644_Figure_6.11.jpg"/></span>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US"><span class="koboSpan" id="kobo.621.1">Figure 6.11: The auto-documentation feature will give me a link to the official documentation</span></p>
<p><span class="koboSpan" id="kobo.622.1">There’s no easy answer here, is there? </span><span class="koboSpan" id="kobo.622.2">Sure, I could click on the link at the bottom and go to the Python site and read the documentation. </span><span class="koboSpan" id="kobo.622.3">If I do that, though, I’ll lose any credibility with you, the</span><a id="_idIndexMarker548"/><span class="koboSpan" id="kobo.623.1"> reader. </span><span class="koboSpan" id="kobo.623.2">Read the manual with y’all watching? </span><span class="koboSpan" id="kobo.623.3">No chance! </span><span class="koboSpan" id="kobo.623.4">I’m sure I’d find the answer but at the expense of </span><span class="No-Break"><span class="koboSpan" id="kobo.624.1">my pride.</span></span></p>
<p><span class="koboSpan" id="kobo.625.1">I have another idea! </span><span class="koboSpan" id="kobo.625.2">I’ve talked about PyCharm’s console before. </span><span class="koboSpan" id="kobo.625.3">I’d like to try something out. </span><span class="koboSpan" id="kobo.625.4">Check out </span><span class="No-Break"><em class="italic"><span class="koboSpan" id="kobo.626.1">Figure 6</span></em></span><span class="No-Break"><em class="italic"><span class="koboSpan" id="kobo.627.1">.12</span></em></span><span class="No-Break"><span class="koboSpan" id="kobo.628.1">:</span></span></p>
<div>
<div class="IMG---Figure" id="_idContainer197">
<span class="koboSpan" id="kobo.629.1"><img alt="Figure 6.12: If the PyCharm Console button (2) isn’t on your toolbar, click the ellipses (1) to turn it on" src="image/B19644_Figure_6.12.jpg"/></span>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US"><span class="koboSpan" id="kobo.630.1">Figure 6.12: If the PyCharm Console button (2) isn’t on your toolbar, click the ellipses (1) to turn it on</span></p>
<p><span class="koboSpan" id="kobo.631.1">The arrow pointing to </span><em class="italic"><span class="koboSpan" id="kobo.632.1">2</span></em><span class="koboSpan" id="kobo.633.1"> will open the PyCharm console. </span><span class="koboSpan" id="kobo.633.2">If you’ve never done this, that icon won’t be on the toolbar. </span><span class="koboSpan" id="kobo.633.3">You’ll need</span><a id="_idIndexMarker549"/><span class="koboSpan" id="kobo.634.1"> to click the ellipsis at </span><em class="italic"><span class="koboSpan" id="kobo.635.1">1</span></em><span class="koboSpan" id="kobo.636.1"> and click the </span><strong class="bold"><span class="koboSpan" id="kobo.637.1">Python Console</span></strong><span class="koboSpan" id="kobo.638.1"> area. </span><span class="koboSpan" id="kobo.638.2">This will add it to your toolbar. </span><span class="koboSpan" id="kobo.638.3">My console session is shown in </span><span class="No-Break"><em class="italic"><span class="koboSpan" id="kobo.639.1">Figure 6</span></em></span><span class="No-Break"><em class="italic"><span class="koboSpan" id="kobo.640.1">.13</span></em></span><span class="No-Break"><span class="koboSpan" id="kobo.641.1">:</span></span></p>
<div>
<div class="IMG---Figure" id="_idContainer198">
<span class="koboSpan" id="kobo.642.1"><img alt="Figure 6.13: Revisiting the console allows us to do a quick experiment to solve our error" src="image/B19644_Figure_6.13.jpg"/></span>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US"><span class="koboSpan" id="kobo.643.1">Figure 6.13: Revisiting the console allows us to do a quick experiment to solve our error</span></p>
<p><span class="koboSpan" id="kobo.644.1">In the console, I first hit </span><em class="italic"><span class="koboSpan" id="kobo.645.1">Enter</span></em><span class="koboSpan" id="kobo.646.1"> on the first line. </span><span class="koboSpan" id="kobo.646.2">I did that for you. </span><span class="koboSpan" id="kobo.646.3">If I hadn’t, the console would have bunched everything up and it wouldn’t look as pretty. </span><span class="koboSpan" id="kobo.646.4">Next, I typed </span><span class="No-Break"><span class="koboSpan" id="kobo.647.1">the following:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.648.1">
check = ValueError("This is a test")</span></pre> <p><span class="koboSpan" id="kobo.649.1">I suspect that if I convert the check into a string, I will get the message I am looking for. </span><span class="koboSpan" id="kobo.649.2">Call it intuition. </span><span class="koboSpan" id="kobo.649.3">Or call it “I looked it </span><a id="_idIndexMarker550"/><span class="koboSpan" id="kobo.650.1">up with </span><strong class="bold"><span class="koboSpan" id="kobo.651.1">ChatGPT</span></strong><span class="koboSpan" id="kobo.652.1"> while your back was turned.” </span><span class="koboSpan" id="kobo.652.2">I’m going </span><span class="No-Break"><span class="koboSpan" id="kobo.653.1">with intuition.</span></span></p>
<p><span class="koboSpan" id="kobo.654.1">If I type in </span><strong class="source-inline"><span class="koboSpan" id="kobo.655.1">str(check)</span></strong><span class="koboSpan" id="kobo.656.1">, the Python REPL will evaluate the expression and print the result. </span><span class="koboSpan" id="kobo.656.2">The idea works. </span><span class="koboSpan" id="kobo.656.3">I can</span><a id="_idIndexMarker551"/><span class="koboSpan" id="kobo.657.1"> correct my code. </span><span class="koboSpan" id="kobo.657.2">Line 34 in </span><strong class="source-inline"><span class="koboSpan" id="kobo.658.1">test_transaction.py</span></strong><span class="koboSpan" id="kobo.659.1"> will now be </span><span class="No-Break"><span class="koboSpan" id="kobo.660.1">as follows:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.661.1">
self.assertEqual(str(e), "Transaction failed and was rolled back")</span></pre> <p><span class="koboSpan" id="kobo.662.1">Now, if I run the test again, it will fail, as shown in </span><span class="No-Break"><em class="italic"><span class="koboSpan" id="kobo.663.1">Figure 6</span></em></span><span class="No-Break"><em class="italic"><span class="koboSpan" id="kobo.664.1">.14</span></em></span><span class="No-Break"><span class="koboSpan" id="kobo.665.1">:</span></span></p>
<div>
<div class="IMG---Figure" id="_idContainer199">
<span class="koboSpan" id="kobo.666.1"><img alt="Figure 6.14: Progress can be measured in software development by the rate at which the list of errors is reduced" src="image/B19644_Figure_6.14.jpg"/></span>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US"><span class="koboSpan" id="kobo.667.1">Figure 6.14: Progress can be measured in software development by the rate at which the list of errors is reduced</span></p>
<p><span class="koboSpan" id="kobo.668.1">We expected this. </span><span class="koboSpan" id="kobo.668.2">The list of problems got shorter, so it’s a victory! </span><span class="koboSpan" id="kobo.668.3">Let’s clear out the last problem. </span><span class="koboSpan" id="kobo.668.4">The transaction is failing to correctly reset the value of the seller’s account after the transaction fails. </span><span class="koboSpan" id="kobo.668.5">We could stare at it for a while, or we could take a more proactive approach by firing up PyCharm’s debugger and stepping through the </span><span class="No-Break"><span class="koboSpan" id="kobo.669.1">whole test.</span></span></p>
<h1 id="_idParaDest-156"><a id="_idTextAnchor158"/><span class="koboSpan" id="kobo.670.1">Working with PyCharm’s debugger</span></h1>
<p><span class="koboSpan" id="kobo.671.1">In </span><a href="B19644_01.xhtml#_idTextAnchor014"><span class="No-Break"><em class="italic"><span class="koboSpan" id="kobo.672.1">Chapter 1</span></em></span></a><span class="koboSpan" id="kobo.673.1">, I lauded PyCharm’s debugger as the single biggest reason to use an IDE versus a command-line debugger such as the standard Python debugger, which is called </span><strong class="bold"><span class="koboSpan" id="kobo.674.1">pdb</span></strong><span class="koboSpan" id="kobo.675.1">. </span><span class="koboSpan" id="kobo.675.2">Don’t get</span><a id="_idIndexMarker552"/><span class="koboSpan" id="kobo.676.1"> me wrong – you </span><a id="_idIndexMarker553"/><span class="koboSpan" id="kobo.677.1">should learn to use pdb because there will be times when the IDE isn’t available. </span><span class="koboSpan" id="kobo.677.2">However, I suspect that once you use PyCharm’s, you’ll prefer it over anything else. </span><span class="koboSpan" id="kobo.677.3">Let’s see if </span><span class="No-Break"><span class="koboSpan" id="kobo.678.1">I’m right.</span></span></p>
<p><span class="koboSpan" id="kobo.679.1">We have a problem in our </span><strong class="source-inline"><span class="koboSpan" id="kobo.680.1">Transaction</span></strong><span class="koboSpan" id="kobo.681.1"> class that isn’t quite accurate. </span><span class="koboSpan" id="kobo.681.2">When it comes to testing, there are always </span><span class="No-Break"><span class="koboSpan" id="kobo.682.1">two possibilities:</span></span></p>
<ul>
<li><span class="koboSpan" id="kobo.683.1">The code is failing because of a flaw in the code </span><span class="No-Break"><span class="koboSpan" id="kobo.684.1">under test.</span></span></li>
<li><span class="koboSpan" id="kobo.685.1">The code is failing because of the </span><span class="No-Break"><span class="koboSpan" id="kobo.686.1">test code.</span></span></li>
</ul>
<p><span class="koboSpan" id="kobo.687.1">Since we don’t know which possibility is correct at this point, the debugger is going to allow us to step through our code one line at a time and inspect its inner workings. </span><span class="koboSpan" id="kobo.687.2">To do this, we need to set a breakpoint. </span><span class="koboSpan" id="kobo.687.3">A breakpoint marks a spot in your code where you would like to halt its execution and inspect the contents of the variables, the stack, and so on. </span><span class="koboSpan" id="kobo.687.4">You can create a breakpoint by clicking the line number in the gutter within the editor, as shown in </span><span class="No-Break"><em class="italic"><span class="koboSpan" id="kobo.688.1">Figure 6</span></em></span><em class="italic"><span class="koboSpan" id="kobo.689.1">.15</span></em><span class="koboSpan" id="kobo.690.1">. </span><span class="koboSpan" id="kobo.690.2">I’m going to add a breakpoint to the beginning of the test so that we can walk through it. </span><span class="koboSpan" id="kobo.690.3">The test starts on line 25, so I’ll click on that line number; observe that the line number has been replaced with a </span><span class="No-Break"><span class="koboSpan" id="kobo.691.1">red dot:</span></span></p>
<div>
<div class="IMG---Figure" id="_idContainer200">
<span class="koboSpan" id="kobo.692.1"><img alt="Figure 6.15: Click a line number to create a breakpoint, which will replace the number with a red dot" src="image/B19644_Figure_6.15.jpg"/></span>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US"><span class="koboSpan" id="kobo.693.1">Figure 6.15: Click a line number to create a breakpoint, which will replace the number with a red dot</span></p>
<p><span class="koboSpan" id="kobo.694.1">Next, we need to run</span><a id="_idIndexMarker554"/><span class="koboSpan" id="kobo.695.1"> the debugger. </span><span class="koboSpan" id="kobo.695.2">Click the green arrow in the editor window next to the method definition for the </span><strong class="source-inline"><span class="koboSpan" id="kobo.696.1">test_transaction_overdraw_fault(self)</span></strong><span class="koboSpan" id="kobo.697.1"> method. </span><span class="koboSpan" id="kobo.697.2">This time, click the </span><strong class="bold"><span class="koboSpan" id="kobo.698.1">Debug ‘Python tests for tes…’</span></strong><span class="koboSpan" id="kobo.699.1"> option, shown in </span><span class="No-Break"><em class="italic"><span class="koboSpan" id="kobo.700.1">Figure 6</span></em></span><em class="italic"><span class="koboSpan" id="kobo.701.1">.16</span></em><span class="koboSpan" id="kobo.702.1">, to run the </span><span class="No-Break"><span class="koboSpan" id="kobo.703.1">failed test:</span></span></p>
<div>
<div class="IMG---Figure" id="_idContainer201">
<span class="koboSpan" id="kobo.704.1"><img alt="Figure 6.16: Clicking the green arrows provides a menu that can be used to make variations to a running test, including running the debugger" src="image/B19644_Figure_6.16.jpg"/></span>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US"><span class="koboSpan" id="kobo.705.1">Figure 6.16: Clicking the green arrows provides a menu that can be used to make variations to a running test, including running the debugger</span></p>
<p><span class="koboSpan" id="kobo.706.1">When the debugger is run, the program will start, then stop on line 25 of our test. </span><span class="koboSpan" id="kobo.706.2">The IDE transformed significantly. </span><span class="koboSpan" id="kobo.706.3">Let’s look at </span><span class="No-Break"><em class="italic"><span class="koboSpan" id="kobo.707.1">Figure 6</span></em></span><span class="No-Break"><em class="italic"><span class="koboSpan" id="kobo.708.1">.17</span></em></span><span class="No-Break"><span class="koboSpan" id="kobo.709.1">:</span></span></p>
<div>
<div class="IMG---Figure" id="_idContainer202">
<span class="koboSpan" id="kobo.710.1"><img alt="Figure 6.17: The paused debugger in PyCharm" src="image/B19644_Figure_6.17.jpg"/></span>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US"><span class="koboSpan" id="kobo.711.1">Figure 6.17: The paused debugger in PyCharm</span></p>
<p><span class="koboSpan" id="kobo.712.1">There are a few things you might notice right away. </span><span class="koboSpan" id="kobo.712.2">First, the run buttons at the top of the IDE are now green, and the red stop button is illuminated (</span><em class="italic"><span class="koboSpan" id="kobo.713.1">1</span></em><span class="koboSpan" id="kobo.714.1">). </span><span class="koboSpan" id="kobo.714.2">These are all visual clues showing that something is running, which of course </span><span class="No-Break"><span class="koboSpan" id="kobo.715.1">we do.</span></span></p>
<p><span class="koboSpan" id="kobo.716.1">The bottom half of the IDE is</span><a id="_idIndexMarker555"/><span class="koboSpan" id="kobo.717.1"> now taken up by the debugger tools (</span><em class="italic"><span class="koboSpan" id="kobo.718.1">2</span></em><span class="koboSpan" id="kobo.719.1">). </span><span class="koboSpan" id="kobo.719.2">There is also a tab bar present (</span><em class="italic"><span class="koboSpan" id="kobo.720.1">3</span></em><span class="koboSpan" id="kobo.721.1">), which allows you to run multiple debugging sessions at the same time. </span><span class="koboSpan" id="kobo.721.2">This can be handy when developing RESTful microservice architectures, which we’ll talk about in several of the upcoming chapters, most notably in </span><span class="No-Break"><em class="italic"><span class="koboSpan" id="kobo.722.1">Chapter 9</span></em></span><span class="koboSpan" id="kobo.723.1">, </span><em class="italic"><span class="koboSpan" id="kobo.724.1">Creating a RESTful API </span></em><span class="No-Break"><em class="italic"><span class="koboSpan" id="kobo.725.1">with FastAPI</span></em></span><span class="No-Break"><span class="koboSpan" id="kobo.726.1">.</span></span></p>
<p><span class="koboSpan" id="kobo.727.1">There is a list of threads on the right-hand side (</span><em class="italic"><span class="koboSpan" id="kobo.728.1">4</span></em><span class="koboSpan" id="kobo.729.1">), which allows you to switch between and inspect the various threads at play. </span><span class="koboSpan" id="kobo.729.2">However, most of the time, you’re going to land in the right place and might use this only rarely. </span><span class="koboSpan" id="kobo.729.3">The area at location </span><em class="italic"><span class="koboSpan" id="kobo.730.1">5</span></em><span class="koboSpan" id="kobo.731.1"> shows everything that is currently in scope. </span><span class="koboSpan" id="kobo.731.2">Right now, that is just </span><strong class="source-inline"><span class="koboSpan" id="kobo.732.1">self</span></strong><span class="koboSpan" id="kobo.733.1">, which you can see is an instance of the </span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.734.1">TestTransaction</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.735.1"> class.</span></span></p>
<p><em class="italic"><span class="koboSpan" id="kobo.736.1">6</span></em><span class="koboSpan" id="kobo.737.1"> shows two tabs that allow you to switch between the view we’re seeing right now, which allows you to inspect the state of the program at area </span><em class="italic"><span class="koboSpan" id="kobo.738.1">5</span></em><span class="koboSpan" id="kobo.739.1">. </span><span class="koboSpan" id="kobo.739.2">If you switch this tab to </span><strong class="bold"><span class="koboSpan" id="kobo.740.1">Console</span></strong><span class="koboSpan" id="kobo.741.1">, area 5 will display the Terminal output from your program. </span><span class="koboSpan" id="kobo.741.2">Any output or </span><strong class="source-inline"><span class="koboSpan" id="kobo.742.1">print</span></strong><span class="koboSpan" id="kobo.743.1"> statements will appear so that you can review the output as the </span><span class="No-Break"><span class="koboSpan" id="kobo.744.1">program runs.</span></span></p>
<p><span class="koboSpan" id="kobo.745.1">The toolbar marked with </span><em class="italic"><span class="koboSpan" id="kobo.746.1">7</span></em><span class="koboSpan" id="kobo.747.1"> houses a set of very useful tools, while the expression window (</span><em class="italic"><span class="koboSpan" id="kobo.748.1">8</span></em><span class="koboSpan" id="kobo.749.1">) allows you to add a </span><a id="_idIndexMarker556"/><span class="koboSpan" id="kobo.750.1">watch or evaluate an expression using whatever is currently </span><span class="No-Break"><span class="koboSpan" id="kobo.751.1">in scope.</span></span></p>
<p><span class="koboSpan" id="kobo.752.1">The most useful parts of the debugging window are the inspection area (</span><em class="italic"><span class="koboSpan" id="kobo.753.1">5</span></em><span class="koboSpan" id="kobo.754.1">), the tab switch, which you can use to swap between the variable and thread inspector and console output (</span><em class="italic"><span class="koboSpan" id="kobo.755.1">6</span></em><span class="koboSpan" id="kobo.756.1">), and the debugging toolbar (</span><em class="italic"><span class="koboSpan" id="kobo.757.1">7</span></em><span class="koboSpan" id="kobo.758.1">). </span><span class="koboSpan" id="kobo.758.2">Let’s take a closer look at the </span><span class="No-Break"><span class="koboSpan" id="kobo.759.1">debugging toolbar:</span></span></p>
<div>
<div class="IMG---Figure" id="_idContainer203">
<span class="koboSpan" id="kobo.760.1"><img alt="Figure 6.18: The debugging toolbar in PyCharm" src="image/B19644_Figure_6.18.jpg"/></span>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US"><span class="koboSpan" id="kobo.761.1">Figure 6.18: The debugging toolbar in PyCharm</span></p>
<p><span class="koboSpan" id="kobo.762.1">I’ve numbered each button. </span><span class="koboSpan" id="kobo.762.2">Let’s </span><span class="No-Break"><span class="koboSpan" id="kobo.763.1">review them:</span></span></p>
<ol>
<li><span class="koboSpan" id="kobo.764.1">This button restarts the debugging run. </span><span class="koboSpan" id="kobo.764.2">You can find a duplicate restart button at the top of the IDE window near the </span><span class="No-Break"><span class="koboSpan" id="kobo.765.1">run button.</span></span></li>
<li><span class="koboSpan" id="kobo.766.1">This button stops the debugging run. </span><span class="koboSpan" id="kobo.766.2">You can find a duplicate stop button at the top of the IDE window near the </span><span class="No-Break"><span class="koboSpan" id="kobo.767.1">restart button.</span></span></li>
<li><span class="koboSpan" id="kobo.768.1">This is the </span><strong class="bold"><span class="koboSpan" id="kobo.769.1">Continue</span></strong><span class="koboSpan" id="kobo.770.1"> button. </span><span class="koboSpan" id="kobo.770.2">The debugger will stop at any breakpoint it hits and wait until you use one of the step buttons (</span><em class="italic"><span class="koboSpan" id="kobo.771.1">5</span></em><span class="koboSpan" id="kobo.772.1"> – </span><em class="italic"><span class="koboSpan" id="kobo.773.1">8</span></em><span class="koboSpan" id="kobo.774.1">) or you hit this button to continue </span><span class="No-Break"><span class="koboSpan" id="kobo.775.1">the run.</span></span></li>
<li><span class="koboSpan" id="kobo.776.1">The </span><strong class="bold"><span class="koboSpan" id="kobo.777.1">Pause</span></strong><span class="koboSpan" id="kobo.778.1"> button will pause the run. </span><span class="koboSpan" id="kobo.778.2">This can be useful if you’re running a loop or an algorithm that takes a while and you want to pause </span><span class="No-Break"><span class="koboSpan" id="kobo.779.1">the run.</span></span></li>
<li><span class="koboSpan" id="kobo.780.1">The </span><strong class="bold"><span class="koboSpan" id="kobo.781.1">Step Over</span></strong><span class="koboSpan" id="kobo.782.1"> button will execute the current line where the debugger has paused. </span><span class="koboSpan" id="kobo.782.2">If that line is a function call to a function in your program, the function will execute normally and return, after which you’ll be taken to the next line of your code, where the debugger will remain paused. </span><span class="koboSpan" id="kobo.782.3">Here, you’re stepping over the execution of the </span><span class="No-Break"><span class="koboSpan" id="kobo.783.1">next line.</span></span></li>
<li><span class="koboSpan" id="kobo.784.1">In contrast, this is the </span><strong class="bold"><span class="koboSpan" id="kobo.785.1">Step Into</span></strong><span class="koboSpan" id="kobo.786.1"> button. </span><span class="koboSpan" id="kobo.786.2">If your debugger has paused on a line containing a function call, clicking this button will allow you to step into that function and step through as if you had placed a breakpoint at the beginning of the function. </span><strong class="bold"><span class="koboSpan" id="kobo.787.1">Step Over</span></strong><span class="koboSpan" id="kobo.788.1"> skips past this execution, while this button steps </span><span class="No-Break"><span class="koboSpan" id="kobo.789.1">into it.</span></span></li>
<li><strong class="bold"><span class="koboSpan" id="kobo.790.1">Step Into My Code</span></strong><span class="koboSpan" id="kobo.791.1"> is a </span><a id="_idIndexMarker557"/><span class="koboSpan" id="kobo.792.1">game changer! </span><span class="koboSpan" id="kobo.792.2">This button is just like the </span><strong class="bold"><span class="koboSpan" id="kobo.793.1">Step Into</span></strong><span class="koboSpan" id="kobo.794.1"> button (</span><em class="italic"><span class="koboSpan" id="kobo.795.1">6</span></em><span class="koboSpan" id="kobo.796.1">), except this one will not step into code that you didn’t create. </span><span class="koboSpan" id="kobo.796.2">By that, I mean the </span><strong class="bold"><span class="koboSpan" id="kobo.797.1">Step Into</span></strong><span class="koboSpan" id="kobo.798.1"> button will happily step you into the bowels of your third-party library code, or into the code comprising Python itself. </span><span class="koboSpan" id="kobo.798.2">This is rarely useful. </span><span class="koboSpan" id="kobo.798.3">The </span><strong class="bold"><span class="koboSpan" id="kobo.799.1">Step Into My Code</span></strong><span class="koboSpan" id="kobo.800.1"> button will only step into code that is part of </span><span class="No-Break"><span class="koboSpan" id="kobo.801.1">your project.</span></span></li>
<li><span class="koboSpan" id="kobo.802.1">This is the </span><strong class="bold"><span class="koboSpan" id="kobo.803.1">Step Out</span></strong><span class="koboSpan" id="kobo.804.1"> button. </span><span class="koboSpan" id="kobo.804.2">If you find yourself stepping into some code that clearly isn’t a problem, or maybe you’ve taken into library code you didn’t create, the step-out code will jump you back out to the point where </span><span class="No-Break"><span class="koboSpan" id="kobo.805.1">you entered.</span></span></li>
</ol>
<p class="callout-heading"><span class="koboSpan" id="kobo.806.1">Attention Visual Studio users</span></p>
<p class="callout"><span class="koboSpan" id="kobo.807.1">The buttons in the PyCharm debugger work differently than they do in Visual Studio! </span><span class="koboSpan" id="kobo.807.2">This took some getting used to for me. </span><span class="koboSpan" id="kobo.807.3">In Visual Studio, you can click the green button on the top toolbar to start the debugging session. </span><span class="koboSpan" id="kobo.807.4">When you hit a breakpoint, you can hit the same button to continue. </span><span class="koboSpan" id="kobo.807.5">In PyCharm, the continue button is in the debugging toolbar, in area </span><em class="italic"><span class="koboSpan" id="kobo.808.1">3</span></em><span class="koboSpan" id="kobo.809.1"> in </span><span class="No-Break"><em class="italic"><span class="koboSpan" id="kobo.810.1">Figure 6</span></em></span><em class="italic"><span class="koboSpan" id="kobo.811.1">.18</span></em><span class="koboSpan" id="kobo.812.1">. </span><span class="koboSpan" id="kobo.812.2">If you were to click the same button you used to launch the debugger, you would launch a second debug session. </span><span class="koboSpan" id="kobo.812.3">PyCharm will generally complain when you do this unless you’ve checked the box in the run configuration that allows multiple runs at the </span><span class="No-Break"><span class="koboSpan" id="kobo.813.1">same time.</span></span></p>
<h2 id="_idParaDest-157"><a id="_idTextAnchor159"/><span class="koboSpan" id="kobo.814.1">Using the debugger to find and fix our test problem</span></h2>
<p><span class="koboSpan" id="kobo.815.1">Our unit test revealed a </span><a id="_idIndexMarker558"/><span class="koboSpan" id="kobo.816.1">problem in our code. </span><span class="koboSpan" id="kobo.816.2">When our transaction fails due to an overdraft error, we expect the balances of our buyer and seller to revert to their original values. </span><span class="koboSpan" id="kobo.816.3">At this point, the seller is getting $39.95 in credit following a failed transaction. </span><span class="koboSpan" id="kobo.816.4">Let’s use the debugger to step through and see if we can figure out why this </span><span class="No-Break"><span class="koboSpan" id="kobo.817.1">is happening.</span></span></p>
<p><span class="koboSpan" id="kobo.818.1">Per </span><span class="No-Break"><em class="italic"><span class="koboSpan" id="kobo.819.1">Figure 6</span></em></span><em class="italic"><span class="koboSpan" id="kobo.820.1">.19</span></em><span class="koboSpan" id="kobo.821.1">, we’ve started the debugger on our unit test and we’ve stopped at line 25 in </span><strong class="source-inline"><span class="koboSpan" id="kobo.822.1">test_transaction.py</span></strong><span class="koboSpan" id="kobo.823.1">. </span><span class="koboSpan" id="kobo.823.2">At this stage, nothing in the test method has run. </span><span class="koboSpan" id="kobo.823.3">When you’re looking at a highlighted line in PyCharm’s debugger, you need to remember that the highlighted line has not been executed yet. </span><span class="koboSpan" id="kobo.823.4">To execute the line, click the </span><strong class="bold"><span class="koboSpan" id="kobo.824.1">Step Over</span></strong><span class="koboSpan" id="kobo.825.1"> button, which is labeled as </span><em class="italic"><span class="koboSpan" id="kobo.826.1">5</span></em><span class="koboSpan" id="kobo.827.1"> in </span><span class="No-Break"><em class="italic"><span class="koboSpan" id="kobo.828.1">Figure 6</span></em></span><em class="italic"><span class="koboSpan" id="kobo.829.1">.18</span></em><span class="koboSpan" id="kobo.830.1">. </span><span class="koboSpan" id="kobo.830.2">The debugger variable window will update now that </span><strong class="source-inline"><span class="koboSpan" id="kobo.831.1">buyer_account</span></strong><span class="koboSpan" id="kobo.832.1"> has been instantiated, and our highlight will move to and</span><a id="_idIndexMarker559"/><span class="koboSpan" id="kobo.833.1"> stop on line 26, as shown in </span><span class="No-Break"><em class="italic"><span class="koboSpan" id="kobo.834.1">Figure 6</span></em></span><span class="No-Break"><em class="italic"><span class="koboSpan" id="kobo.835.1">.19</span></em></span><span class="No-Break"><span class="koboSpan" id="kobo.836.1">:</span></span></p>
<div>
<div class="IMG---Figure" id="_idContainer204">
<span class="koboSpan" id="kobo.837.1"><img alt="Figure 6.19: Having clicked the Step Over button, the debugger has been stopped on line 26" src="image/B19644_Figure_6.19.jpg"/></span>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US"><span class="koboSpan" id="kobo.838.1">Figure 6.19: Having clicked the Step Over button, the debugger has been stopped on line 26</span></p>
<p><span class="koboSpan" id="kobo.839.1">To see the content of the objects, you’ll need to twirl open the caret, which I’ve circled in </span><span class="No-Break"><em class="italic"><span class="koboSpan" id="kobo.840.1">Figure 6</span></em></span><em class="italic"><span class="koboSpan" id="kobo.841.1">.19</span></em><span class="koboSpan" id="kobo.842.1">. </span><span class="koboSpan" id="kobo.842.2">You can see that </span><strong class="source-inline"><span class="koboSpan" id="kobo.843.1">buyer_account</span></strong><span class="koboSpan" id="kobo.844.1"> has a balance of $5. </span><span class="koboSpan" id="kobo.844.2">However, what we’re interested in here is the seller account since that’s where the </span><span class="No-Break"><span class="koboSpan" id="kobo.845.1">problem lies.</span></span></p>
<p><span class="koboSpan" id="kobo.846.1">Click line 30 to add a breakpoint there, then click the </span><strong class="bold"><span class="koboSpan" id="kobo.847.1">Continue</span></strong><span class="koboSpan" id="kobo.848.1"> button. </span><span class="koboSpan" id="kobo.848.2">The debugger will stop on line 30. </span><span class="koboSpan" id="kobo.848.3">We’re going to step into the </span><strong class="source-inline"><span class="koboSpan" id="kobo.849.1">do_transaction()</span></strong><span class="koboSpan" id="kobo.850.1"> method to watch it execute. </span><span class="koboSpan" id="kobo.850.2">Click the </span><strong class="bold"><span class="koboSpan" id="kobo.851.1">Step Into My Code</span></strong><span class="koboSpan" id="kobo.852.1"> button. </span><span class="koboSpan" id="kobo.852.2">Refer to </span><span class="No-Break"><em class="italic"><span class="koboSpan" id="kobo.853.1">Figure 6</span></em></span><em class="italic"><span class="koboSpan" id="kobo.854.1">.18</span></em><span class="koboSpan" id="kobo.855.1"> and look at </span><em class="italic"><span class="koboSpan" id="kobo.856.1">7</span></em><span class="koboSpan" id="kobo.857.1"> if you don’t remember which button </span><span class="No-Break"><span class="koboSpan" id="kobo.858.1">I mean.</span></span></p>
<p><span class="koboSpan" id="kobo.859.1">This will take us to line 17 in </span><strong class="source-inline"><span class="koboSpan" id="kobo.860.1">transaction.py</span></strong><span class="koboSpan" id="kobo.861.1">. </span><span class="koboSpan" id="kobo.861.2">Step over lines 17 and 18 to arrive at line 19 and inspect our state. </span><span class="koboSpan" id="kobo.861.3">You’ll see the problem, which is shown in </span><span class="No-Break"><em class="italic"><span class="koboSpan" id="kobo.862.1">Figure 6</span></em></span><span class="No-Break"><em class="italic"><span class="koboSpan" id="kobo.863.1">.20</span></em></span><span class="No-Break"><span class="koboSpan" id="kobo.864.1">:</span></span></p>
<div>
<div class="IMG---Figure" id="_idContainer205">
<span class="koboSpan" id="kobo.865.1"><img alt="Figure 6.20: The debugger reveals that the starting value of the seller balance is wrong" src="image/B19644_Figure_6.20.jpg"/></span>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US"><span class="koboSpan" id="kobo.866.1">Figure 6.20: The debugger reveals that the starting value of the seller balance is wrong</span></p>
<p><span class="koboSpan" id="kobo.867.1">The debugger reveals that the</span><a id="_idIndexMarker560"/><span class="koboSpan" id="kobo.868.1"> original seller balance is $4,039.95, where we would expect it to be $4,000. </span><span class="koboSpan" id="kobo.868.2">You can see this value in two places. </span><span class="koboSpan" id="kobo.868.3">The variables window shows it to us (</span><em class="italic"><span class="koboSpan" id="kobo.869.1">1</span></em><span class="koboSpan" id="kobo.870.1">), but you can also hover over any in-scope variable in the editor window (</span><em class="italic"><span class="koboSpan" id="kobo.871.1">2</span></em><span class="koboSpan" id="kobo.872.1">) and see </span><span class="No-Break"><span class="koboSpan" id="kobo.873.1">its value.</span></span></p>
<p><span class="koboSpan" id="kobo.874.1">Now, why would our starting balance be wrong? </span><span class="koboSpan" id="kobo.874.2">It’s a scope problem! </span><span class="koboSpan" id="kobo.874.3">Since I hoisted the </span><strong class="source-inline"><span class="koboSpan" id="kobo.875.1">seller_account</span></strong><span class="koboSpan" id="kobo.876.1"> variable to line 5 in </span><strong class="source-inline"><span class="koboSpan" id="kobo.877.1">test_transaction.py</span></strong><span class="koboSpan" id="kobo.878.1"> up to a global, the first test successfully changes the balance to $4,039.95 just like it should. </span><span class="koboSpan" id="kobo.878.2">Since it is global, that number remains. </span><span class="koboSpan" id="kobo.878.3">To fix this, we need to reset the balance of the seller account at the beginning of the </span><strong class="source-inline"><span class="koboSpan" id="kobo.879.1">test_transaction_overdraw_fault(self)</span></strong><span class="koboSpan" id="kobo.880.1"> method. </span><span class="koboSpan" id="kobo.880.2">We started our debugging efforts on line 25. </span><span class="koboSpan" id="kobo.880.3">Let’s just make our change there. </span><span class="koboSpan" id="kobo.880.4">Click the stop button on the debugger toolbar, then add this line on </span><span class="No-Break"><span class="koboSpan" id="kobo.881.1">line 25:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.882.1">
seller_account.balance = 4000</span></pre> <p><span class="koboSpan" id="kobo.883.1">Rerun your tests without debugging. </span><span class="koboSpan" id="kobo.883.2">Be bold! </span><span class="koboSpan" id="kobo.883.3">Assume it worked! </span><span class="koboSpan" id="kobo.883.4">If you’re not following along, kindly move to </span><a id="_idIndexMarker561"/><span class="koboSpan" id="kobo.884.1">the edge of your seat and begin biting your nails nervously. </span><span class="koboSpan" id="kobo.884.2">Will our hero triumph in </span><span class="No-Break"><em class="italic"><span class="koboSpan" id="kobo.885.1">Figure 6</span></em></span><em class="italic"><span class="koboSpan" id="kobo.886.1">.21</span></em><span class="koboSpan" id="kobo.887.1">? </span><span class="koboSpan" id="kobo.887.2">Cue organ music: duhn </span><span class="No-Break"><span class="koboSpan" id="kobo.888.1">duhn duuuuuhn!</span></span></p>
<div>
<div class="IMG---Figure" id="_idContainer206">
<span class="koboSpan" id="kobo.889.1"><img alt="Figure 6.21: Victory!" src="image/B19644_Figure_6.21.jpg"/></span>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US"><span class="koboSpan" id="kobo.890.1">Figure 6.21: Victory!</span></p>
<p><span class="koboSpan" id="kobo.891.1">It works! </span><span class="koboSpan" id="kobo.891.2">Now, it’s time to head home and heat up dinner since we’ve restored everyone’s faith in the international </span><span class="No-Break"><span class="koboSpan" id="kobo.892.1">banking industry.</span></span></p>
<h1 id="_idParaDest-158"><a id="_idTextAnchor160"/><span class="koboSpan" id="kobo.893.1">Checking test coverage</span></h1>
<p><span class="koboSpan" id="kobo.894.1">Unit tests are most effective when there are tests to cover every class, method, function, or module in your </span><a id="_idIndexMarker562"/><span class="koboSpan" id="kobo.895.1">program. </span><span class="koboSpan" id="kobo.895.2">As your software code grows, it is easy to forget to write tests or maybe to put them off until you have more time. </span><span class="koboSpan" id="kobo.895.3">PyCharm has a tool that can tell you what your test coverage is and helps you find unexploited opportunities for testing more of your work than you might have on </span><span class="No-Break"><span class="koboSpan" id="kobo.896.1">your own.</span></span></p>
<p><span class="koboSpan" id="kobo.897.1">To check your test coverage, you just need to run your tests a little bit differently. </span><span class="koboSpan" id="kobo.897.2">We’ve been running our tests individually from within the test files. </span><span class="koboSpan" id="kobo.897.3">We need to run all the tests together so that we can</span><a id="_idIndexMarker563"/><span class="koboSpan" id="kobo.898.1"> have a comprehensive report of where we are missing coverage. </span><span class="koboSpan" id="kobo.898.2">For this, we will make a new run configuration. </span><span class="koboSpan" id="kobo.898.3">Click the run configurations dropdown on the toolbar and click </span><strong class="bold"><span class="koboSpan" id="kobo.899.1">Edit Configurations</span></strong><span class="koboSpan" id="kobo.900.1">. </span><span class="koboSpan" id="kobo.900.2">Add a new configuration using the Python </span><strong class="source-inline"><span class="koboSpan" id="kobo.901.1">unittest</span></strong><span class="koboSpan" id="kobo.902.1"> template. </span><span class="koboSpan" id="kobo.902.2">Make sure you use my settings, as shown in </span><span class="No-Break"><em class="italic"><span class="koboSpan" id="kobo.903.1">Figure 6</span></em></span><span class="No-Break"><em class="italic"><span class="koboSpan" id="kobo.904.1">.22</span></em></span><span class="No-Break"><span class="koboSpan" id="kobo.905.1">:</span></span></p>
<div>
<div class="IMG---Figure" id="_idContainer207">
<span class="koboSpan" id="kobo.906.1"><img alt="Figure 6.22: Create a run configuration that runs all your tests at once" src="image/B19644_Figure_6.22.jpg"/></span>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US"><span class="koboSpan" id="kobo.907.1">Figure 6.22: Create a run configuration that runs all your tests at once</span></p>
<p><span class="koboSpan" id="kobo.908.1">For the script path, enter the folder where your tests are located. </span><span class="koboSpan" id="kobo.908.2">Set the pattern to </span><strong class="source-inline"><span class="koboSpan" id="kobo.909.1">*_test.py</span></strong><span class="koboSpan" id="kobo.910.1">. </span><span class="koboSpan" id="kobo.910.2">This will make the test runner find all files that end with </span><strong class="source-inline"><span class="koboSpan" id="kobo.911.1">_test.py</span></strong><span class="koboSpan" id="kobo.912.1">, which is different from the defaults. </span><span class="koboSpan" id="kobo.912.2">The defaults will look for files beginning with “test.” </span><span class="koboSpan" id="kobo.912.3">I don’t particularly like this because it bunches all the tests together in the project file window instead of putting the test right next to the file it </span><span class="No-Break"><span class="koboSpan" id="kobo.913.1">is testing.</span></span></p>
<p><span class="koboSpan" id="kobo.914.1">By setting the pattern and setting the test runner to a folder rather than a single file, the runner will find all files matching the pattern and run them as tests. </span><span class="koboSpan" id="kobo.914.2">Speaking of running, you can do that by clicking the ellipsis next to the run and debug buttons. </span><span class="koboSpan" id="kobo.914.3">See </span><span class="No-Break"><em class="italic"><span class="koboSpan" id="kobo.915.1">Figure 6</span></em></span><em class="italic"><span class="koboSpan" id="kobo.916.1">.23</span></em><span class="koboSpan" id="kobo.917.1"> to locate the </span><strong class="bold"><span class="koboSpan" id="kobo.918.1">Run ‘All Tests’</span></strong><strong class="bold"><span class="koboSpan" id="kobo.919.1"> with Coverage</span></strong> <span class="No-Break"><span class="koboSpan" id="kobo.920.1">menu item:</span></span></p>
<div>
<div class="IMG---Figure" id="_idContainer208">
<span class="koboSpan" id="kobo.921.1"><img alt="Figure 6.23: Run ‘All Tests’ with Coverage allows you to run your tests and find out how much of your application isn’t covered by unit tests" src="image/B19644_Figure_6.23.jpg"/></span>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US"><span class="koboSpan" id="kobo.922.1">Figure 6.23: Run ‘All Tests’ with Coverage allows you to run your tests and find out how much of your application isn’t covered by unit tests</span></p>
<p><span class="koboSpan" id="kobo.923.1">The first time you do this, you’ll likely</span><a id="_idIndexMarker564"/><span class="koboSpan" id="kobo.924.1"> see an error message – not from your code, but from PyCharm. </span><span class="koboSpan" id="kobo.924.2">See </span><span class="No-Break"><em class="italic"><span class="koboSpan" id="kobo.925.1">Figure 6</span></em></span><em class="italic"><span class="koboSpan" id="kobo.926.1">.24</span></em><span class="koboSpan" id="kobo.927.1"> to see what </span><span class="No-Break"><span class="koboSpan" id="kobo.928.1">I mean:</span></span></p>
<div>
<div class="IMG---Figure" id="_idContainer209">
<span class="koboSpan" id="kobo.929.1"><img alt="Figure 6.24: The first time you run test coverage, you’ll be warned if you haven’t installed the coverage software or enabled the bundled copy" src="image/B19644_Figure_6.24.jpg"/></span>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US"><span class="koboSpan" id="kobo.930.1">Figure 6.24: The first time you run test coverage, you’ll be warned if you haven’t installed the coverage software or enabled the bundled copy</span></p>
<p><span class="koboSpan" id="kobo.931.1">Running with coverage requires some software, </span><strong class="source-inline"><span class="koboSpan" id="kobo.932.1">coverage.py</span></strong><span class="koboSpan" id="kobo.933.1">, which we haven’t installed. </span><span class="koboSpan" id="kobo.933.2">You have two </span><a id="_idIndexMarker565"/><span class="koboSpan" id="kobo.934.1">options here: you can either add </span><strong class="source-inline"><span class="koboSpan" id="kobo.935.1">coverage.py</span></strong><span class="koboSpan" id="kobo.936.1"> to your project, or you can use the bundled version that ships with PyCharm. </span><span class="koboSpan" id="kobo.936.2">I prefer using the bundled version. </span><span class="koboSpan" id="kobo.936.3">You can click the word </span><em class="italic"><span class="koboSpan" id="kobo.937.1">enable</span></em><span class="koboSpan" id="kobo.938.1"> in the error message, which is displayed as a blue hyperlink, and PyCharm will turn on this setting for you. </span><span class="koboSpan" id="kobo.938.2">If you’d like to manage this setting yourself, see </span><span class="No-Break"><em class="italic"><span class="koboSpan" id="kobo.939.1">Figure 6</span></em></span><em class="italic"><span class="koboSpan" id="kobo.940.1">.25</span></em><span class="koboSpan" id="kobo.941.1"> to see where the setting can </span><span class="No-Break"><span class="koboSpan" id="kobo.942.1">be found:</span></span></p>
<div>
<div class="IMG---Figure" id="_idContainer210">
<span class="koboSpan" id="kobo.943.1"><img alt="Figure 6.25: The setting for using the bundled coverage.py file allows you to use coverage.py without you having to add it to your project" src="image/B19644_Figure_6.25.jpg"/></span>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US"><span class="koboSpan" id="kobo.944.1">Figure 6.25: The setting for using the bundled coverage.py file allows you to use coverage.py without you having to add it to your project</span></p>
<p><span class="koboSpan" id="kobo.945.1">With </span><strong class="source-inline"><span class="koboSpan" id="kobo.946.1">coverage.py</span></strong><span class="koboSpan" id="kobo.947.1"> enabled, rerun </span><a id="_idIndexMarker566"/><span class="koboSpan" id="kobo.948.1">your coverage test. </span><span class="koboSpan" id="kobo.948.2">Let’s see how </span><span class="No-Break"><span class="koboSpan" id="kobo.949.1">we do:</span></span></p>
<div>
<div class="IMG---Figure" id="_idContainer211">
<span class="koboSpan" id="kobo.950.1"><img alt="Figure 6.26: I wish my grades in college were this good!" src="image/B19644_Figure_6.26.jpg"/></span>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US"><span class="koboSpan" id="kobo.951.1">Figure 6.26: I wish my grades in college were this good!</span></p>
<p><span class="koboSpan" id="kobo.952.1">Holy smokes! </span><span class="koboSpan" id="kobo.952.2">We have 100% coverage in</span><a id="_idIndexMarker567"/><span class="koboSpan" id="kobo.953.1"> the transaction tests, but a miserable failure in the </span><strong class="source-inline"><span class="koboSpan" id="kobo.954.1">bank_account_test.py</span></strong><span class="koboSpan" id="kobo.955.1"> file – that is, if you consider 94% coverage a failure. </span><span class="koboSpan" id="kobo.955.2">Being a perfectionist, I would like to see how I missed those points. </span><span class="koboSpan" id="kobo.955.3">I can double-click the line showing the 94% in </span><strong class="source-inline"><span class="koboSpan" id="kobo.956.1">bank_account_test.py</span></strong><span class="koboSpan" id="kobo.957.1"> and I’ll be treated to a color-coded gutter. </span><span class="koboSpan" id="kobo.957.2">Here, again, I must apologize for the book being printed in black and white. </span><span class="koboSpan" id="kobo.957.3">Area </span><em class="italic"><span class="koboSpan" id="kobo.958.1">1</span></em><span class="koboSpan" id="kobo.959.1"> in </span><span class="No-Break"><em class="italic"><span class="koboSpan" id="kobo.960.1">Figure 6</span></em></span><em class="italic"><span class="koboSpan" id="kobo.961.1">.26</span></em><span class="koboSpan" id="kobo.962.1"> is colored red. </span><span class="koboSpan" id="kobo.962.2">These are the lines that are not covered by the tests. </span><span class="koboSpan" id="kobo.962.3">To be truthful, I don’t remember typing these in. </span><span class="koboSpan" id="kobo.962.4">I don’t need them since my test runner is executing my tests for me. </span><span class="koboSpan" id="kobo.962.5">I can simply remove these lines and re-format my file with </span><em class="italic"><span class="koboSpan" id="kobo.963.1">Ctrl</span></em><span class="koboSpan" id="kobo.964.1"> + </span><em class="italic"><span class="koboSpan" id="kobo.965.1">Alt</span></em><span class="koboSpan" id="kobo.966.1"> + </span><em class="italic"><span class="koboSpan" id="kobo.967.1">L</span></em><span class="koboSpan" id="kobo.968.1">/</span><em class="italic"><span class="koboSpan" id="kobo.969.1">Cmd</span></em><span class="koboSpan" id="kobo.970.1"> + </span><em class="italic"><span class="koboSpan" id="kobo.971.1">Opt</span></em><span class="koboSpan" id="kobo.972.1"> + </span><em class="italic"><span class="koboSpan" id="kobo.973.1">L</span></em><span class="koboSpan" id="kobo.974.1">. </span><span class="koboSpan" id="kobo.974.2">Rerun the test with coverage. </span><span class="koboSpan" id="kobo.974.3">My results in </span><span class="No-Break"><em class="italic"><span class="koboSpan" id="kobo.975.1">Figure 6</span></em></span><em class="italic"><span class="koboSpan" id="kobo.976.1">.27</span></em><span class="koboSpan" id="kobo.977.1"> show that </span><span class="No-Break"><span class="koboSpan" id="kobo.978.1">we’re close:</span></span></p>
<div>
<div class="IMG---Figure" id="_idContainer212">
<span class="koboSpan" id="kobo.979.1"><img alt="Figure 6.27: We have achieved 100% coverage! Keep this up and you might get a raise" src="image/B19644_Figure_6.27.jpg"/></span>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US"><span class="koboSpan" id="kobo.980.1">Figure 6.27: We have achieved 100% coverage! </span><span class="koboSpan" id="kobo.980.2">Keep this up and you might get a raise</span></p>
<p><span class="koboSpan" id="kobo.981.1">The </span><strong class="source-inline"><span class="koboSpan" id="kobo.982.1">bank_account_test.py</span></strong><span class="koboSpan" id="kobo.983.1"> file now has 100% coverage, but at the top, I can still see that the </span><strong class="source-inline"><span class="koboSpan" id="kobo.984.1">bank_account</span></strong><span class="koboSpan" id="kobo.985.1"> folder only has 98% coverage. </span><span class="koboSpan" id="kobo.985.2">This simply will not stand! </span><span class="koboSpan" id="kobo.985.3">Right now, I have my project explorer</span><a id="_idIndexMarker568"/><span class="koboSpan" id="kobo.986.1"> window closed to maximize space for the editor and coverage window. </span><span class="koboSpan" id="kobo.986.2">If I open it back up, having run with coverage, I will get some more information. </span><span class="No-Break"><em class="italic"><span class="koboSpan" id="kobo.987.1">Figure 6</span></em></span><em class="italic"><span class="koboSpan" id="kobo.988.1">.28</span></em><span class="koboSpan" id="kobo.989.1"> shows where we should look. </span><span class="koboSpan" id="kobo.989.2">The </span><strong class="source-inline"><span class="koboSpan" id="kobo.990.1">bank_account.py</span></strong><span class="koboSpan" id="kobo.991.1"> file only has 92% coverage. </span><span class="koboSpan" id="kobo.991.2">Upon double-clicking to open it, I’ll see the lines I’m missing colored red, as seen in </span><span class="No-Break"><em class="italic"><span class="koboSpan" id="kobo.992.1">Figure 6</span></em></span><span class="No-Break"><em class="italic"><span class="koboSpan" id="kobo.993.1">.28</span></em></span><span class="No-Break"><span class="koboSpan" id="kobo.994.1">:</span></span></p>
<div>
<div class="IMG---Figure" id="_idContainer213">
<span class="koboSpan" id="kobo.995.1"><img alt="Figure 6.28: The grayish-red area in the gutter indicates that lines 17 and 18 are not covered by any unit test" src="image/B19644_Figure_6.28.jpg"/></span>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US"><span class="koboSpan" id="kobo.996.1">Figure 6.28: The grayish-red area in the gutter indicates that lines 17 and 18 are not covered by any unit test</span></p>
<p><span class="koboSpan" id="kobo.997.1">It looks like we have another unit test to write. </span><span class="koboSpan" id="kobo.997.2">I forgot to write a test for the error condition. </span><span class="koboSpan" id="kobo.997.3">This is legitimate! </span><span class="koboSpan" id="kobo.997.4">As </span><a id="_idIndexMarker569"/><span class="koboSpan" id="kobo.998.1">you may recall, I left the deposit test as a challenge for you. </span><span class="koboSpan" id="kobo.998.2">I wrote it in my code for this book, but I forgot to write the error test. </span><span class="koboSpan" id="kobo.998.3">Coverage saves </span><span class="No-Break"><span class="koboSpan" id="kobo.999.1">the day!</span></span></p>
<p><span class="koboSpan" id="kobo.1000.1">Open </span><strong class="source-inline"><span class="koboSpan" id="kobo.1001.1">bank_account_test.py</span></strong><span class="koboSpan" id="kobo.1002.1"> and add the following test, which will cover the case of trying to deposit a </span><span class="No-Break"><span class="koboSpan" id="kobo.1003.1">negative number:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.1004.1">
def test_deposit_negative_number_fail(self):
 test_account = BankAccount("Bruce Van Horn", "123355-23434", 4000)
 self.assertRaises(ValueError, test_account.deposit, -2000)</span></pre> <p><span class="koboSpan" id="kobo.1005.1">Run the test and verify it passes, then rerun the </span><strong class="bold"><span class="koboSpan" id="kobo.1006.1">All Tests</span></strong><span class="koboSpan" id="kobo.1007.1"> configuration with coverage. </span><span class="koboSpan" id="kobo.1007.2">My result is shown in </span><span class="No-Break"><em class="italic"><span class="koboSpan" id="kobo.1008.1">Figure 6</span></em></span><span class="No-Break"><em class="italic"><span class="koboSpan" id="kobo.1009.1">.29</span></em></span><span class="No-Break"><span class="koboSpan" id="kobo.1010.1">:</span></span></p>
<div>
<div class="IMG---Figure" id="_idContainer214">
<span class="koboSpan" id="kobo.1011.1"><img alt="Figure 6.29: We have achieved 100% coverage for all files" src="image/B19644_Figure_6.29.jpg"/></span>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US"><span class="koboSpan" id="kobo.1012.1">Figure 6.29: We have achieved 100% coverage for all files</span></p>
<p><span class="koboSpan" id="kobo.1013.1">This time, we should have a perfect score! </span><span class="koboSpan" id="kobo.1013.2">Now that we’re feeling fine, I’ll point out the coverage window on the right-hand </span><a id="_idIndexMarker570"/><span class="koboSpan" id="kobo.1014.1">side of the screen. </span><span class="koboSpan" id="kobo.1014.2">It shows a list of the results, which we’ve already seen. </span><span class="koboSpan" id="kobo.1014.3">Note the shield icon in the right toolbar. </span><span class="koboSpan" id="kobo.1014.4">You can show or hide the coverage window by clicking </span><span class="No-Break"><span class="koboSpan" id="kobo.1015.1">this shield.</span></span></p>
<h2 id="_idParaDest-159"><a id="_idTextAnchor161"/><span class="koboSpan" id="kobo.1016.1">Test coverage output</span></h2>
<p><span class="koboSpan" id="kobo.1017.1">In addition to the</span><a id="_idIndexMarker571"/><span class="koboSpan" id="kobo.1018.1"> graphical display, PyCharm outputs a report for the coverage run. </span><span class="koboSpan" id="kobo.1018.2">You will see the output mentioned in the output window alongside the usual test output. </span><span class="koboSpan" id="kobo.1018.3">Mine states </span><span class="No-Break"><span class="koboSpan" id="kobo.1019.1">the following:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.1020.1">
Wrote XML report to /home/brucevanhorn/.cache/JetBrains/PyCharm2023.1/coverage/bank_account&amp;All_Test.xml</span></pre> <p><span class="koboSpan" id="kobo.1021.1">The XML file is generated by </span><strong class="source-inline"><span class="koboSpan" id="kobo.1022.1">coverage.py</span></strong><span class="koboSpan" id="kobo.1023.1">, which we enabled earlier. </span><span class="koboSpan" id="kobo.1023.2">As you might have guessed, </span><strong class="source-inline"><span class="koboSpan" id="kobo.1024.1">coverage.py</span></strong><span class="koboSpan" id="kobo.1025.1"> is a popular Python tool for measuring code coverage during test runs. </span><span class="koboSpan" id="kobo.1025.2">It is an open source tool that helps you identify which parts of your Python code are being exercised by your tests and which parts are not. </span><span class="koboSpan" id="kobo.1025.3">The tool works by collecting information about which lines of code are executed during a test run and then generating a report that shows the percentage of code coverage. </span><span class="koboSpan" id="kobo.1025.4">The XML output is used by PyCharm to render the color-coded UI displays we’ve been using. </span><span class="koboSpan" id="kobo.1025.5">The XML output can also be</span><a id="_idIndexMarker572"/><span class="koboSpan" id="kobo.1026.1"> used by your </span><strong class="bold"><span class="koboSpan" id="kobo.1027.1">continuous integration</span></strong><span class="koboSpan" id="kobo.1028.1"> (</span><strong class="bold"><span class="koboSpan" id="kobo.1029.1">CI</span></strong><span class="koboSpan" id="kobo.1030.1">) system to generate reports and</span><a id="_idIndexMarker573"/><span class="koboSpan" id="kobo.1031.1"> displays. </span><span class="koboSpan" id="kobo.1031.2">JetBrains has created an excellent CI system called </span><strong class="bold"><span class="koboSpan" id="kobo.1032.1">TeamCity</span></strong><span class="koboSpan" id="kobo.1033.1">, which can leverage </span><strong class="source-inline"><span class="koboSpan" id="kobo.1034.1">coverage.py</span></strong><span class="koboSpan" id="kobo.1035.1"> to fail a build if test coverage is below a </span><span class="No-Break"><span class="koboSpan" id="kobo.1036.1">set threshold.</span></span></p>
<h1 id="_idParaDest-160"><a id="_idTextAnchor162"/><span class="koboSpan" id="kobo.1037.1">Profiling performance</span></h1>
<p><span class="koboSpan" id="kobo.1038.1">The first step in creating </span><a id="_idIndexMarker574"/><span class="koboSpan" id="kobo.1039.1">a great program is getting the program fully working. </span><span class="koboSpan" id="kobo.1039.2">The second step is to perform automated testing to prove that the program works as intended. </span><span class="koboSpan" id="kobo.1039.3">The final step ought to be tweaking the code so that the program runs as fast and as efficiently as possible. </span><span class="koboSpan" id="kobo.1039.4">Poorly performing programs run the risk of having a low adoption rate at best, and may simply be unusable at worst. </span><span class="koboSpan" id="kobo.1039.5">In England, the NHS has an algorithm that was designed to match organ transplant recipients to recently harvested organs. </span><span class="koboSpan" id="kobo.1039.6">The algorithm is complicated but extremely time-sensitive. </span><span class="koboSpan" id="kobo.1039.7">Harvested organs must be transplanted quickly; otherwise, their tissues will die and become useless. </span><span class="koboSpan" id="kobo.1039.8">In short, the algorithm must be extremely accurate; otherwise, the transplanted organ may be rejected, resulting in the patient’s death. </span><span class="koboSpan" id="kobo.1039.9">It must also be fast since the organ will lose viability, which may also result in patient death. </span><span class="koboSpan" id="kobo.1039.10">Suddenly, I’m very glad for my job dealing with hardware system capacity planning and forecasting. </span><span class="koboSpan" id="kobo.1039.11">Nobody has ever died because my database queries were too slow. </span><span class="koboSpan" id="kobo.1039.12">At least, not that I </span><span class="No-Break"><span class="koboSpan" id="kobo.1040.1">know of.</span></span></p>
<p><span class="koboSpan" id="kobo.1041.1">In addition to being able to run your tests with coverage, you can also run with performance profiling. </span><span class="koboSpan" id="kobo.1041.2">While the coverage report tells you graphically which areas of your code remain untested, PyCharm’s profiler gives you reports on which parts of your code are consuming the lion’s share of the overall runtime. </span><span class="koboSpan" id="kobo.1041.3">This allows you to spot bottlenecks so that you can focus your refactoring efforts toward making the code, and its execution, </span><span class="No-Break"><span class="koboSpan" id="kobo.1042.1">more efficient.</span></span></p>
<p><span class="koboSpan" id="kobo.1043.1">Similar to there being several testing libraries that are widely used by Python developers, there is also a variety of profiling tools, including Yappi, cProfile, and VMProf. </span><span class="koboSpan" id="kobo.1043.2">PyCharm supports them all, but they do not work the same. </span><span class="koboSpan" id="kobo.1043.3">cProfile is built into Python, and so is the default profiler. </span><span class="koboSpan" id="kobo.1043.4">Yappi is an improvement over cProfile because it allows you to profile multithreaded applications and supports CPU time profiling. </span><span class="koboSpan" id="kobo.1043.5">VMProf supports statistical sampling. </span><span class="koboSpan" id="kobo.1043.6">When you profile using this tool, it won’t simply time a single run of your program; instead, it will run and sample multiple runs, providing you with a more realistic performance profile. </span><span class="koboSpan" id="kobo.1043.7">PyCharm will use VMProf if it is available. </span><span class="koboSpan" id="kobo.1043.8">If not, it will look for Yappi. </span><span class="koboSpan" id="kobo.1043.9">If it can’t find Yappi, then it will use the cProfile solution built into Python. </span><span class="koboSpan" id="kobo.1043.10">For this book, I will stick to the default </span><span class="No-Break"><span class="koboSpan" id="kobo.1044.1">cProfile tool.</span></span></p>
<h2 id="_idParaDest-161"><a id="_idTextAnchor163"/><span class="koboSpan" id="kobo.1045.1">Profiling in PyCharm</span></h2>
<p><span class="koboSpan" id="kobo.1046.1">The code we’ll be profiling can be</span><a id="_idIndexMarker575"/><span class="koboSpan" id="kobo.1047.1"> found in this book’s repository, in the </span><strong class="source-inline"><span class="koboSpan" id="kobo.1048.1">chapter-06</span></strong><span class="koboSpan" id="kobo.1049.1"> folder. </span><span class="koboSpan" id="kobo.1049.2">The </span><strong class="source-inline"><span class="koboSpan" id="kobo.1050.1">profiling.py</span></strong><span class="koboSpan" id="kobo.1051.1"> file contains the </span><span class="No-Break"><span class="koboSpan" id="kobo.1052.1">following code:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.1053.1">
def custom_sum(n=1000000):
  result = 0
  for i in range(n):
    result += i
  return result
def built_in_sum(n=1000000):
  result = sum(range(n))
  return result
if __name__ == '__main__':
  print(custom_sum())
  # print(built_in_sum())</span></pre> <p><span class="koboSpan" id="kobo.1054.1">This code will compare two ways of computing the sum of the integers, ranging from one to an upper limit expressed as </span><em class="italic"><span class="koboSpan" id="kobo.1055.1">n</span></em><span class="koboSpan" id="kobo.1056.1">, whose default value is 1,000,000. </span><span class="koboSpan" id="kobo.1056.2">The </span><strong class="source-inline"><span class="koboSpan" id="kobo.1057.1">custom_sum</span></strong><span class="koboSpan" id="kobo.1058.1"> function loops through all the elements, adding each to a running sum. </span><span class="koboSpan" id="kobo.1058.2">The </span><strong class="source-inline"><span class="koboSpan" id="kobo.1059.1">built_in_sum</span></strong><span class="koboSpan" id="kobo.1060.1"> function utilizes the built-in </span><strong class="source-inline"><span class="koboSpan" id="kobo.1061.1">sum()</span></strong><span class="koboSpan" id="kobo.1062.1"> method </span><span class="No-Break"><span class="koboSpan" id="kobo.1063.1">of Python.</span></span></p>
<p><span class="koboSpan" id="kobo.1064.1">In the main scope, we will use commenting to swap between the two function calls to test both methods. </span><span class="koboSpan" id="kobo.1064.2">We will be looking at our custom summing function first, so the call to </span><strong class="source-inline"><span class="koboSpan" id="kobo.1065.1">built_in_sum</span></strong><span class="koboSpan" id="kobo.1066.1"> is commented out </span><span class="No-Break"><span class="koboSpan" id="kobo.1067.1">for now.</span></span></p>
<p><span class="koboSpan" id="kobo.1068.1">The typical claim is that built-in functions are generally faster than any code you might write. </span><span class="koboSpan" id="kobo.1068.2">In this example, we will </span><a id="_idIndexMarker576"/><span class="koboSpan" id="kobo.1069.1">be able to fact-check that claim and further qualify it with runtime statistics through our profiling process. </span><span class="koboSpan" id="kobo.1069.2">Let’s </span><span class="No-Break"><span class="koboSpan" id="kobo.1070.1">get started.</span></span></p>
<p><span class="koboSpan" id="kobo.1071.1">As with testing and coverage, we can start a profiling run by using either the green arrows within the editor or the run button ellipsis at the top of the screen. </span><span class="No-Break"><em class="italic"><span class="koboSpan" id="kobo.1072.1">Figure 6</span></em></span><em class="italic"><span class="koboSpan" id="kobo.1073.1">.30</span></em><span class="koboSpan" id="kobo.1074.1"> shows </span><span class="No-Break"><span class="koboSpan" id="kobo.1075.1">both options:</span></span></p>
<div>
<div class="IMG---Figure" id="_idContainer215">
<span class="koboSpan" id="kobo.1076.1"><img alt="Figure 6.30: You can run a profile using either the ellipsis menu at the top right or by clicking the green arrow next to the dunder-main entry point on line 14" src="image/B19644_Figure_6.30.jpg"/></span>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US"><span class="koboSpan" id="kobo.1077.1">Figure 6.30: You can run a profile using either the ellipsis menu at the top right or by clicking the green arrow next to the dunder-main entry point on line 14</span></p>
<p><span class="koboSpan" id="kobo.1078.1">When the profile run is complete, we will be provided with a performance report, as seen in </span><span class="No-Break"><em class="italic"><span class="koboSpan" id="kobo.1079.1">Figure 6</span></em></span><span class="No-Break"><em class="italic"><span class="koboSpan" id="kobo.1080.1">.31</span></em></span><span class="No-Break"><span class="koboSpan" id="kobo.1081.1">:</span></span></p>
<div>
<div class="IMG---Figure" id="_idContainer216">
<span class="koboSpan" id="kobo.1082.1"><img alt="Figure 6.31: The performance profile for the custom_sum function" src="image/B19644_Figure_6.31.jpg"/></span>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US"><span class="koboSpan" id="kobo.1083.1">Figure 6.31: The performance profile for the custom_sum function</span></p>
<p><span class="koboSpan" id="kobo.1084.1">On my computer, which in this case is a VMWare virtual machine with a very modest configuration (2 cores, 4 GB of RAM, and a 7,200 RPM spinning disk), the </span><strong class="source-inline"><span class="koboSpan" id="kobo.1085.1">custom_sum</span></strong><span class="koboSpan" id="kobo.1086.1"> function completed in 41 ms. </span><span class="koboSpan" id="kobo.1086.2">The time and the percentage are a little bunched together on my display, but we</span><a id="_idIndexMarker577"/><span class="koboSpan" id="kobo.1087.1"> can see that 100% of the time was spent in the </span><strong class="source-inline"><span class="koboSpan" id="kobo.1088.1">custom_sum</span></strong><span class="koboSpan" id="kobo.1089.1"> function. </span><span class="koboSpan" id="kobo.1089.2">If this were a more complicated program with many functions being called during the run, we’d see a full listing of each function and how much time was spent on each. </span><span class="koboSpan" id="kobo.1089.3">Pay attention to the </span><strong class="bold"><span class="koboSpan" id="kobo.1090.1">Own Time</span></strong><span class="koboSpan" id="kobo.1091.1"> column versus the </span><span class="No-Break"><strong class="bold"><span class="koboSpan" id="kobo.1092.1">Time</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.1093.1"> column.</span></span></p>
<p><span class="koboSpan" id="kobo.1094.1">In PyCharm’s performance profiler, the </span><strong class="bold"><span class="koboSpan" id="kobo.1095.1">Time</span></strong><span class="koboSpan" id="kobo.1096.1"> column shows the total time spent executing a particular function or method, including the time spent executing any sub-functions or methods called </span><span class="No-Break"><span class="koboSpan" id="kobo.1097.1">within it.</span></span></p>
<p><span class="koboSpan" id="kobo.1098.1">On the other hand, the </span><strong class="bold"><span class="koboSpan" id="kobo.1099.1">Own Time</span></strong><span class="koboSpan" id="kobo.1100.1"> column shows the time spent executing only the code within the function or method itself, excluding any time spent executing sub-functions or methods. </span><span class="koboSpan" id="kobo.1100.2">This means that the </span><strong class="bold"><span class="koboSpan" id="kobo.1101.1">Own Time</span></strong><span class="koboSpan" id="kobo.1102.1"> column can give you a better understanding of the performance of the code within a specific function or method, independent of any external factors such as the performance of other functions or methods </span><span class="No-Break"><span class="koboSpan" id="kobo.1103.1">it calls.</span></span></p>
<p><span class="koboSpan" id="kobo.1104.1">To illustrate the difference, consider a function, </span><em class="italic"><span class="koboSpan" id="kobo.1105.1">A()</span></em><span class="koboSpan" id="kobo.1106.1">, that calls two other functions, </span><em class="italic"><span class="koboSpan" id="kobo.1107.1">B()</span></em><span class="koboSpan" id="kobo.1108.1"> and </span><em class="italic"><span class="koboSpan" id="kobo.1109.1">C()</span></em><span class="koboSpan" id="kobo.1110.1">. </span><span class="koboSpan" id="kobo.1110.2">If you look at the </span><strong class="bold"><span class="koboSpan" id="kobo.1111.1">Time</span></strong><span class="koboSpan" id="kobo.1112.1"> column for </span><em class="italic"><span class="koboSpan" id="kobo.1113.1">A()</span></em><span class="koboSpan" id="kobo.1114.1">, it will include the time spent executing both </span><em class="italic"><span class="koboSpan" id="kobo.1115.1">B()</span></em><span class="koboSpan" id="kobo.1116.1"> and </span><em class="italic"><span class="koboSpan" id="kobo.1117.1">C()</span></em><span class="koboSpan" id="kobo.1118.1"> in addition to the time spent executing the code within </span><em class="italic"><span class="koboSpan" id="kobo.1119.1">A()</span></em><span class="koboSpan" id="kobo.1120.1"> itself. </span><span class="koboSpan" id="kobo.1120.2">However, if you look at the </span><strong class="bold"><span class="koboSpan" id="kobo.1121.1">Own Time</span></strong><span class="koboSpan" id="kobo.1122.1"> column for </span><em class="italic"><span class="koboSpan" id="kobo.1123.1">A()</span></em><span class="koboSpan" id="kobo.1124.1">, it will only show the time spent executing the code within </span><em class="italic"><span class="koboSpan" id="kobo.1125.1">A()</span></em><span class="koboSpan" id="kobo.1126.1"> and not the time spent executing </span><em class="italic"><span class="koboSpan" id="kobo.1127.1">B()</span></em> <span class="No-Break"><span class="koboSpan" id="kobo.1128.1">and </span></span><span class="No-Break"><em class="italic"><span class="koboSpan" id="kobo.1129.1">C()</span></em></span><span class="No-Break"><span class="koboSpan" id="kobo.1130.1">.</span></span></p>
<p><span class="koboSpan" id="kobo.1131.1">In general, the </span><strong class="bold"><span class="koboSpan" id="kobo.1132.1">Time</span></strong><span class="koboSpan" id="kobo.1133.1"> column </span><a id="_idIndexMarker578"/><span class="koboSpan" id="kobo.1134.1">can give you a sense of the overall performance impact of a particular function or method, while the </span><strong class="bold"><span class="koboSpan" id="kobo.1135.1">Own Time</span></strong><span class="koboSpan" id="kobo.1136.1"> column can help you focus on the performance of the code within that function </span><span class="No-Break"><span class="koboSpan" id="kobo.1137.1">or method.</span></span></p>
<h2 id="_idParaDest-162"><a id="_idTextAnchor164"/><span class="koboSpan" id="kobo.1138.1">Comparing performance versus the built-in sum() function</span></h2>
<p><span class="koboSpan" id="kobo.1139.1">Let’s see how my 72 ms runtime fares </span><a id="_idIndexMarker579"/><span class="koboSpan" id="kobo.1140.1">against the built-in Python </span><strong class="source-inline"><span class="koboSpan" id="kobo.1141.1">sum()</span></strong><span class="koboSpan" id="kobo.1142.1"> function. </span><span class="koboSpan" id="kobo.1142.2">Alter the bottom of the </span><strong class="source-inline"><span class="koboSpan" id="kobo.1143.1">main.py</span></strong><span class="koboSpan" id="kobo.1144.1"> file by commenting out the </span><strong class="source-inline"><span class="koboSpan" id="kobo.1145.1">custom_sum</span></strong><span class="koboSpan" id="kobo.1146.1"> function and commenting in the </span><strong class="source-inline"><span class="koboSpan" id="kobo.1147.1">built_in_sum</span></strong><span class="koboSpan" id="kobo.1148.1"> function, </span><span class="No-Break"><span class="koboSpan" id="kobo.1149.1">like this:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.1150.1">
if __name__ == '__main__':
  # print(custom_sum())
  print(built_in_sum())</span></pre> <p><span class="koboSpan" id="kobo.1151.1">Run a profile with this configuration. </span><span class="koboSpan" id="kobo.1151.2">You can see my result in </span><span class="No-Break"><em class="italic"><span class="koboSpan" id="kobo.1152.1">Figure 6</span></em></span><span class="No-Break"><em class="italic"><span class="koboSpan" id="kobo.1153.1">.32</span></em></span><span class="No-Break"><span class="koboSpan" id="kobo.1154.1">:</span></span></p>
<div>
<div class="IMG---Figure" id="_idContainer217">
<span class="koboSpan" id="kobo.1155.1"><img alt="Figure 6.32: The built-in sum function appears to run significantly faster at 11 ms" src="image/B19644_Figure_6.32.jpg"/></span>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US"><span class="koboSpan" id="kobo.1156.1">Figure 6.32: The built-in sum function appears to run significantly faster at 11 ms</span></p>
<p><span class="koboSpan" id="kobo.1157.1">Wow, there’s no contest! </span><span class="koboSpan" id="kobo.1157.2">On </span><a id="_idIndexMarker580"/><span class="koboSpan" id="kobo.1158.1">my computer, leveraging the built-in </span><strong class="source-inline"><span class="koboSpan" id="kobo.1159.1">sum()</span></strong><span class="koboSpan" id="kobo.1160.1"> function is seven times faster! </span><span class="koboSpan" id="kobo.1160.2">In real life, I advise running each profile a few times and taking an average since the runtimes can vary. </span><span class="koboSpan" id="kobo.1160.3">In my case, subsequent runs of the </span><strong class="source-inline"><span class="koboSpan" id="kobo.1161.1">built_in_sum</span></strong><span class="koboSpan" id="kobo.1162.1"> function ranged from 11 ms to 26 ms, which is a pretty </span><span class="No-Break"><span class="koboSpan" id="kobo.1163.1">wide variance.</span></span></p>
<h2 id="_idParaDest-163"><a id="_idTextAnchor165"/><span class="koboSpan" id="kobo.1164.1">Viewing the call graph</span></h2>
<p><span class="koboSpan" id="kobo.1165.1">In addition to the </span><a id="_idIndexMarker581"/><span class="koboSpan" id="kobo.1166.1">statistics table, you can also view the profile as a call graph. </span><span class="koboSpan" id="kobo.1166.2">This graph represents a tree-like view of your program’s run, as shown in </span><span class="No-Break"><em class="italic"><span class="koboSpan" id="kobo.1167.1">Figure 6</span></em></span><span class="No-Break"><em class="italic"><span class="koboSpan" id="kobo.1168.1">.33</span></em></span><span class="No-Break"><span class="koboSpan" id="kobo.1169.1">:</span></span></p>
<div>
<div class="IMG---Figure" id="_idContainer218">
<span class="koboSpan" id="kobo.1170.1"><img alt="Figure 6.33: The call graph shows a tree-like view of the program run" src="image/B19644_Figure_6.33.jpg"/></span>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US"><span class="koboSpan" id="kobo.1171.1">Figure 6.33: The call graph shows a tree-like view of the program run</span></p>
<p><span class="koboSpan" id="kobo.1172.1">The nodes in the call graph are shaded green and red. </span><span class="koboSpan" id="kobo.1172.2">The darker the shade of red, the more time was spent on the function indicated by that node. </span><span class="koboSpan" id="kobo.1172.3">In </span><span class="No-Break"><em class="italic"><span class="koboSpan" id="kobo.1173.1">Figure 6</span></em></span><em class="italic"><span class="koboSpan" id="kobo.1174.1">.33</span></em><span class="koboSpan" id="kobo.1175.1">, pretty much all of the</span><a id="_idIndexMarker582"/><span class="koboSpan" id="kobo.1176.1"> time is being spent in the </span><strong class="source-inline"><span class="koboSpan" id="kobo.1177.1">custom_sum</span></strong><span class="koboSpan" id="kobo.1178.1"> function, which is as dark a red as it gets (trust me). </span><span class="koboSpan" id="kobo.1178.2">The built-in </span><strong class="source-inline"><span class="koboSpan" id="kobo.1179.1">print</span></strong><span class="koboSpan" id="kobo.1180.1"> method takes up a tiny but non-zero amount of time when it prints the sum in the </span><span class="No-Break"><span class="koboSpan" id="kobo.1181.1">main function.</span></span></p>
<h2 id="_idParaDest-164"><a id="_idTextAnchor166"/><span class="koboSpan" id="kobo.1182.1">Navigating using the performance profile</span></h2>
<p><span class="koboSpan" id="kobo.1183.1">You can navigate to a</span><a id="_idIndexMarker583"/><span class="koboSpan" id="kobo.1184.1"> function using either the statistics table or the corresponding node in the call graph. </span><span class="koboSpan" id="kobo.1184.2">Just right-click, as shown in </span><span class="No-Break"><em class="italic"><span class="koboSpan" id="kobo.1185.1">Figure 6</span></em></span><span class="No-Break"><em class="italic"><span class="koboSpan" id="kobo.1186.1">.34</span></em></span><span class="No-Break"><span class="koboSpan" id="kobo.1187.1">:</span></span></p>
<div>
<div class="IMG---Figure" id="_idContainer219">
<span class="koboSpan" id="kobo.1188.1"><img alt="Figure 6.34: You can navigate to your code by right-clicking the function and selecting Navigate to Source" src="image/B19644_Figure_6.34.jpg"/></span>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US"><span class="koboSpan" id="kobo.1189.1">Figure 6.34: You can navigate to your code by right-clicking the function and selecting Navigate to Source</span></p>
<p><span class="koboSpan" id="kobo.1190.1">You can do the</span><a id="_idIndexMarker584"/><span class="koboSpan" id="kobo.1191.1"> same thing on the call graph. </span><span class="koboSpan" id="kobo.1191.2">Upon right-clicking a node on the call graph, you’ll get the same navigation option to take you to the source. </span><span class="koboSpan" id="kobo.1191.3">This can help you navigate straight to any code you might want </span><span class="No-Break"><span class="koboSpan" id="kobo.1192.1">to inspect.</span></span></p>
<h2 id="_idParaDest-165"><a id="_idTextAnchor167"/><span class="koboSpan" id="kobo.1193.1">Performance cProfile snapshots</span></h2>
<p><span class="koboSpan" id="kobo.1194.1">When you do a profile run with cProfile, PyCharm will save a </span><strong class="bold"><span class="koboSpan" id="kobo.1195.1">cProfile snapshot</span></strong><span class="koboSpan" id="kobo.1196.1">, or </span><strong class="bold"><span class="koboSpan" id="kobo.1197.1">pstat</span></strong><span class="koboSpan" id="kobo.1198.1"> file, for you. </span><span class="koboSpan" id="kobo.1198.2">You</span><a id="_idIndexMarker585"/><span class="koboSpan" id="kobo.1199.1"> can see this in the output window. </span><span class="koboSpan" id="kobo.1199.2">In my case, the </span><strong class="source-inline"><span class="koboSpan" id="kobo.1200.1">.pstat</span></strong><span class="koboSpan" id="kobo.1201.1"> files are generated in my </span><span class="No-Break"><span class="koboSpan" id="kobo.1202.1">home folder:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.1203.1">
Snapshot saved to /home/brucevanhorn/.cache/JetBrains/PyCharm2023.1/snapshots/profiling4.pstat</span></pre> <p><span class="koboSpan" id="kobo.1204.1">When I’m doing serious profiling work, I will often copy these files into a more convenient folder and alter their names to indicate the conditions under which they were run. </span><span class="koboSpan" id="kobo.1204.2">For example, in our example, I might call the first </span><strong class="source-inline"><span class="koboSpan" id="kobo.1205.1">.pstat</span></strong><span class="koboSpan" id="kobo.1206.1"> file something like </span><strong class="source-inline"><span class="koboSpan" id="kobo.1207.1">custom_sum_performance_1.pstat</span></strong><span class="koboSpan" id="kobo.1208.1">; the second might be </span><span class="No-Break"><span class="koboSpan" id="kobo.1209.1">called </span></span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.1210.1">built_in_sum_performance_1.pstat</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.1211.1">.</span></span></p>
<p><span class="koboSpan" id="kobo.1212.1">I’m doing this so that I have a baseline performance profile for each. </span><span class="koboSpan" id="kobo.1212.2">In real life, I suspect you will rarely have such an easy alternative to what we’ve presented here. </span><span class="koboSpan" id="kobo.1212.3">You’ll more likely have several versions of a function using different approaches to algorithm design. </span><span class="koboSpan" id="kobo.1212.4">In those cases, keeping your </span><strong class="source-inline"><span class="koboSpan" id="kobo.1213.1">.pstat</span></strong><span class="koboSpan" id="kobo.1214.1"> files so that you can compare them with future runs can be very handy, if for no other reason than to brag at your next </span><span class="No-Break"><span class="koboSpan" id="kobo.1215.1">employee review.</span></span></p>
<p><span class="koboSpan" id="kobo.1216.1">You can open your older </span><strong class="source-inline"><span class="koboSpan" id="kobo.1217.1">.pstat</span></strong><span class="koboSpan" id="kobo.1218.1"> files using the </span><strong class="bold"><span class="koboSpan" id="kobo.1219.1">Tools</span></strong><span class="koboSpan" id="kobo.1220.1"> menu, as shown in </span><span class="No-Break"><em class="italic"><span class="koboSpan" id="kobo.1221.1">Figure 6</span></em></span><span class="No-Break"><em class="italic"><span class="koboSpan" id="kobo.1222.1">.35</span></em></span><span class="No-Break"><span class="koboSpan" id="kobo.1223.1">:</span></span></p>
<div>
<div class="IMG---Figure" id="_idContainer220">
<span class="koboSpan" id="kobo.1224.1"><img alt="Figure 6.35: You can open your old snapshots via the Tools menu" src="image/B19644_Figure_6.35.jpg"/></span>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US"><span class="koboSpan" id="kobo.1225.1">Figure 6.35: You can open your old snapshots via the Tools menu</span></p>
<p><span class="koboSpan" id="kobo.1226.1">Opening this </span><strong class="source-inline"><span class="koboSpan" id="kobo.1227.1">.pstat</span></strong><span class="koboSpan" id="kobo.1228.1"> file will </span><a id="_idIndexMarker586"/><span class="koboSpan" id="kobo.1229.1">show the statistics table and call graph. </span><span class="koboSpan" id="kobo.1229.2">If you’ve refactored the names of the functions, then you shouldn’t expect the navigation to still work; however, you can see the old results and compare them against a </span><span class="No-Break"><span class="koboSpan" id="kobo.1230.1">newer run.</span></span></p>
<p><span class="koboSpan" id="kobo.1231.1">Overall, PyCharm’s ability to open and compare old </span><strong class="source-inline"><span class="koboSpan" id="kobo.1232.1">.pstat</span></strong><span class="koboSpan" id="kobo.1233.1"> files can be a useful tool for tracking the performance of your code over time and identifying areas where performance improvements can </span><span class="No-Break"><span class="koboSpan" id="kobo.1234.1">be made.</span></span></p>
<h1 id="_idParaDest-166"><a id="_idTextAnchor168"/><span class="koboSpan" id="kobo.1235.1">Summary</span></h1>
<p><span class="koboSpan" id="kobo.1236.1">Testing, debugging, and profiling are high-level tasks we can use to analyze applications to look for improvements in correctness and performance, but they can be quite confusing to beginner developers. </span><span class="koboSpan" id="kobo.1236.2">PyCharm offers straightforward and intuitive interfaces for these processes, making them more accessible </span><span class="No-Break"><span class="koboSpan" id="kobo.1237.1">and streamlined.</span></span></p>
<p><span class="koboSpan" id="kobo.1238.1">Unit testing is the process of making sure the individual components of a large system work as intended. </span><span class="koboSpan" id="kobo.1238.2">PyCharm has convenient commands to generate test skeletons/boilerplate code that usually takes time for developers to write manually. </span><span class="koboSpan" id="kobo.1238.3">While testing a program, it is important to consider expected faults, as well as the obvious tests for </span><span class="No-Break"><span class="koboSpan" id="kobo.1239.1">intended functionality.</span></span></p>
<p><span class="koboSpan" id="kobo.1240.1">In a debugging session, developers attempt to narrow down and identify the causes of bugs and errors that are detected during testing. </span><span class="koboSpan" id="kobo.1240.2">With a graphical interface, combined with various options to track the values of variables throughout a program, PyCharm allows us to debug our programs dynamically with considerable freedom. </span><span class="koboSpan" id="kobo.1240.3">The various stepping functions also provide us with a flexible way to step through the program we are trying </span><span class="No-Break"><span class="koboSpan" id="kobo.1241.1">to debug.</span></span></p>
<p><span class="koboSpan" id="kobo.1242.1">Lastly, the goal of profiling is to analyze the performance of a program and find ways to improve it. </span><span class="koboSpan" id="kobo.1242.2">This can include looking for faster ways to compute a value or identifying a bottleneck in the program. </span><span class="koboSpan" id="kobo.1242.3">With the ability to generate comprehensive statistics on the running time of each function that’s executed, as well as call graphs, PyCharm helps developers navigate the different components of a profiled program </span><span class="No-Break"><span class="koboSpan" id="kobo.1243.1">with ease.</span></span></p>
<p><span class="koboSpan" id="kobo.1244.1">This chapter also marks the end of the second part of this book, where we focused on improving our development productivity. </span><span class="koboSpan" id="kobo.1244.2">From here, we will be considering the usage of PyCharm in more specialized fields, namely web development and data </span><span class="No-Break"><span class="koboSpan" id="kobo.1245.1">science projects.</span></span></p>
<p><span class="koboSpan" id="kobo.1246.1">In the next chapter, we will cover the basics of three universal web development languages – JavaScript, HTML, and CSS – within the context </span><span class="No-Break"><span class="koboSpan" id="kobo.1247.1">of PyCharm.</span></span></p>
<h1 id="_idParaDest-167"><a id="_idTextAnchor169"/><span class="koboSpan" id="kobo.1248.1">Questions</span></h1>
<p><span class="koboSpan" id="kobo.1249.1">Answer the following questions to test your knowledge of </span><span class="No-Break"><span class="koboSpan" id="kobo.1250.1">this chapter:</span></span></p>
<ol>
<li><span class="koboSpan" id="kobo.1251.1">What is testing in the context of software development? </span><span class="koboSpan" id="kobo.1251.2">What are the different </span><span class="No-Break"><span class="koboSpan" id="kobo.1252.1">testing methods?</span></span></li>
<li><span class="koboSpan" id="kobo.1253.1">How does PyCharm support </span><span class="No-Break"><span class="koboSpan" id="kobo.1254.1">testing processes?</span></span></li>
<li><span class="koboSpan" id="kobo.1255.1">What is debugging in the context of </span><span class="No-Break"><span class="koboSpan" id="kobo.1256.1">software development?</span></span></li>
<li><span class="koboSpan" id="kobo.1257.1">How does PyCharm support </span><span class="No-Break"><span class="koboSpan" id="kobo.1258.1">debugging processes?</span></span></li>
<li><span class="koboSpan" id="kobo.1259.1">What is profiling in the context of </span><span class="No-Break"><span class="koboSpan" id="kobo.1260.1">software development?</span></span></li>
<li><span class="koboSpan" id="kobo.1261.1">How does PyCharm support </span><span class="No-Break"><span class="koboSpan" id="kobo.1262.1">profiling processes?</span></span></li>
<li><span class="koboSpan" id="kobo.1263.1">What is the significance of run arrows in </span><span class="No-Break"><span class="koboSpan" id="kobo.1264.1">PyCharm’s editor?</span></span></li>
</ol>
<h1 id="_idParaDest-168"><a id="_idTextAnchor170"/><span class="koboSpan" id="kobo.1265.1">Further reading</span></h1>
<p><span class="koboSpan" id="kobo.1266.1">To learn more about the topics that were covered in this chapter, take a look at the </span><span class="No-Break"><span class="koboSpan" id="kobo.1267.1">following resources:</span></span></p>
<ul>
<li><em class="italic"><span class="koboSpan" id="kobo.1268.1">Agile Software Development, Principles, Patterns, and Practices</span></em><span class="koboSpan" id="kobo.1269.1">, Martin, R. </span><span class="koboSpan" id="kobo.1269.2">C. </span><span class="koboSpan" id="kobo.1269.3">(2003). </span><span class="No-Break"><span class="koboSpan" id="kobo.1270.1">Prentice Hall.</span></span></li>
<li><em class="italic"><span class="koboSpan" id="kobo.1271.1">Clean Architecture: A Craftsman’s Guide to Software Structure and Design</span></em><span class="koboSpan" id="kobo.1272.1">, Martin, R. </span><span class="koboSpan" id="kobo.1272.2">C. </span><span class="koboSpan" id="kobo.1272.3">(2017). </span><span class="No-Break"><span class="koboSpan" id="kobo.1273.1">Prentice Hall.</span></span></li>
<li><em class="italic"><span class="koboSpan" id="kobo.1274.1">Real-World Implementation of C# Design Patterns</span></em><span class="koboSpan" id="kobo.1275.1">, Van Horn, B and Symons, V. </span><span class="koboSpan" id="kobo.1275.2">(2022). </span><span class="No-Break"><span class="koboSpan" id="kobo.1276.1">Packt Publishing.</span></span></li>
<li><span class="koboSpan" id="kobo.1277.1">Be sure to check out the companion website for the book </span><span class="No-Break"><span class="koboSpan" id="kobo.1278.1">at</span></span><span class="No-Break"><em class="italic"> </em></span><a href="https://www.pycharm-book.com"><span class="No-Break"><span class="koboSpan" id="kobo.1279.1">https://www.pycharm-book.com</span></span></a><span class="No-Break"><em class="italic"><span class="koboSpan" id="kobo.1280.1">.</span></em></span></li>
</ul>
</div>


<div class="Content" id="_idContainer222">
<h1 id="_idParaDest-169" lang="en-US" xml:lang="en-US"><a id="_idTextAnchor171"/><span class="koboSpan" id="kobo.1.1">Part 3: Web Development in PyCharm</span></h1>
<p><span class="koboSpan" id="kobo.2.1">This part of the book focuses on web development processes in Python programming and what support PyCharm has in store for web projects. </span><span class="koboSpan" id="kobo.2.2">Readers will be able to use PyCharm and its features to efficiently develop their </span><span class="No-Break"><span class="koboSpan" id="kobo.3.1">web applications.</span></span></p>
<p><span class="koboSpan" id="kobo.4.1">This part has the </span><span class="No-Break"><span class="koboSpan" id="kobo.5.1">following chapters:</span></span></p>
<ul>
<li><a href="B19644_07.xhtml#_idTextAnchor172"><em class="italic"><span class="koboSpan" id="kobo.6.1">Chapter 7</span></em></a><span class="koboSpan" id="kobo.7.1">, </span><em class="italic"><span class="koboSpan" id="kobo.8.1">Web Development with JavaScript, HTML, and CSS</span></em></li>
<li><a href="B19644_08.xhtml#_idTextAnchor203"><em class="italic"><span class="koboSpan" id="kobo.9.1">Chapter 8</span></em></a><span class="koboSpan" id="kobo.10.1">, </span><em class="italic"><span class="koboSpan" id="kobo.11.1">Building a Dynamic Web Application with Flask</span></em></li>
<li><a href="B19644_09.xhtml#_idTextAnchor223"><em class="italic"><span class="koboSpan" id="kobo.12.1">Chapter 9</span></em></a><span class="koboSpan" id="kobo.13.1">, </span><em class="italic"><span class="koboSpan" id="kobo.14.1">Creating a RESTful API with FastAPI</span></em></li>
<li><a href="B19644_10.xhtml#_idTextAnchor243"><em class="italic"><span class="koboSpan" id="kobo.15.1">Chapter 10</span></em></a><span class="koboSpan" id="kobo.16.1">, </span><em class="italic"><span class="koboSpan" id="kobo.17.1">More full stack frameworks: Django and Pyramid</span></em></li>
<li><em class="italic"><span class="koboSpan" id="kobo.18.1">Chapter 11</span></em><span class="koboSpan" id="kobo.19.1">, </span><em class="italic"><span class="koboSpan" id="kobo.20.1">Understanding Database Management in PyCharm</span></em></li>
</ul>
</div>
<div>
<div id="_idContainer223">
</div>
</div>
<div>
<div class="Basic-Graphics-Frame" id="_idContainer224">
</div>
</div>
</body></html>