<html><head></head><body>
<div><h1 class="chapter-number" id="_idParaDest-143"><a id="_idTextAnchor145"/>6</h1>
<h1 id="_idParaDest-144"><a id="_idTextAnchor146"/>Seamless Testing, Debugging, and Profiling</h1>
<p>In <a href="B19644_05.xhtml#_idTextAnchor112"><em class="italic">Chapter 5</em></a>, <em class="italic">Version Control with Git in PyCharm</em>, I talked about <em class="italic">The Joel Test</em>. This test is just a list of best practices. At the top of the list is the use of version control, which was the subject of the previous chapter. If you looked up the list, you were probably not surprised to see testing was also on the list. Formalized software testing practices such as <strong class="bold">test-driven development</strong> (<strong class="bold">TDD</strong>) and <strong class="bold">behavior-driven development</strong> (<strong class="bold">BDD</strong>) are the cornerstones of software quality control. Working with these methodologies helps you create software that is less likely to fail in production. Done correctly, it also has side benefits, such as preventing scope creep and allowing for effective refactoring on projects that might have neglected best practices and taken on a lot of technical debt.</p>
<p>Several levels of testing are in practice today, including the following:</p>
<ul>
<li><strong class="bold">Unit testing</strong>, which aims to test basic low-level functionality at the level of functions or classes</li>
<li><strong class="bold">Integration testing</strong>, which aims to test how components within a larger system work together</li>
<li><strong class="bold">User interface testing</strong>, which aims to test how interactive elements of a system work</li>
<li><strong class="bold">End-to-end testing</strong>, which tests an entire system in a production-like environment</li>
</ul>
<p>Like all well-established programming languages, Python has a rich set of testing libraries available. And since Python is “batteries included,” there are some fine testing tools built into the standard library. Naturally, third-party solutions have evolved and are available via <a href="http://PyPi.org">PyPi.org</a>.</p>
<p>I cut my teeth on Java’s <strong class="bold">JUnit</strong> library, and later on its .NET port called <strong class="bold">NUnit</strong>. I found it made software development<a id="_idIndexMarker509"/> very enjoyable. There’s just <a id="_idIndexMarker510"/>something fun about starting your day with a set of tests that don’t pass, and throughout the day, writing the code to make each one pass. If you’re disciplined, you will write the bare minimum code needed, and gradually you will see progress as your testing tool changes color from red to green. You shouldn’t take shortcuts, and you shouldn’t be tempted to write in functionality that seems cool but that you might not need later. When I made the leap to Python years ago, I was pleased to see so many options regarding testing libraries and frameworks. I was equally pleased to see that PyCharm supports most of the popular ones right in the IDE.</p>
<p>In this chapter, we’ll be looking at creating unit tests in Python code while following the tenets of TDD. In TDD, you generally create a set of tests designed to prove your software meets a set of requirements. These tests are written before you create any functionality in your program, and they start as failures. Your job is to make the tests pass with the simplest code possible.</p>
<p>Along the way, you’ll need to use a debugger to step through problematic code that either inexplicably fails, or perhaps worse, inexplicably works. Once your code works and passes tests, you usually want to consider the speed of execution. The <strong class="bold">National Health Service</strong> (<strong class="bold">NHS</strong>) in Great<a id="_idIndexMarker511"/> Britain developed an algorithm that matched organ donations to patients in the system. The complex algorithm had to be fast because there is a limited window of time during which a harvested organ is viable for transplant. Similar time constraints exist in many other types of applications. As developers, we need tools to help us pinpoint efficiency bottlenecks.</p>
<p>The following topics will be covered in this chapter:</p>
<ul>
<li>Unit testing in Python with PyCharm</li>
<li>Using PyCharm’s powerful visual debugger</li>
<li>Working with PyCharm’s profiling tools to find performance bottlenecks in your code</li>
</ul>
<h1 id="_idParaDest-145"><a id="_idTextAnchor147"/>Technical requirements</h1>
<p>The following are the prerequisites for this chapter:</p>
<ul>
<li>A working installation of Python 3.10 or later</li>
<li>A working installation of PyCharm</li>
<li>The sample code for this chapter, which can be found at <a href="https://github.com/PacktPublishing/Hands-On-Application-Development-with-PyCharm---Second-Edition/tree/main/chapter-06 ">https://github.com/PacktPublishing/Hands-On-Application-Development-with-PyCharm---Second-Edition/tree/main/chapter-06</a></li>
</ul>
<h1 id="_idParaDest-146"><a id="_idTextAnchor148"/>Testing, testing, 1-2-3</h1>
<p>Unit testing is a<a id="_idIndexMarker512"/> practice designed to prove your code works as designed. A good set of tests will match a functional specification. A great set of tests will do that but also account for any obvious paths of failure. To get started, let’s get our feet wet with something simple: your bank account. OK, it doesn’t have to be yours. Consider a typical transaction where you buy something at a store using your ATM card.</p>
<p>You visit your favorite brick-and-mortar bookstore to pick up your next excellent read in the field of software development. Let’s say you find a copy of my first book, <em class="italic">Real World Implementation of C# Design Patterns</em>, published by Packt. Given its status as an instant classic, you can’t resist picking up a copy at any price. You tap your card on the bookstore’s point-of-sale system and two things happen:</p>
<ol>
<li>The equivalent of $39.95 – which is an absolute steal by the way – is taken out of your bank account.</li>
<li>The same amount is transferred into the bank account of the bookstore.</li>
</ol>
<p>This is a transactional operation. Formally speaking, a transaction is a multi-step operation where every step must complete without errors. It should be an all-or-nothing set of operations. If the first step completes but the second fails, then $39.95 just vanishes from your bank account and you don’t get to go home with your book. If the second step works but the first fails, you get a free book, but the local bookseller goes broke. We need both steps to complete, or at worst, fail completely so that no money changes hands.</p>
<p>This level of criticality is a good scenario for learning about unit testing.</p>
<h1 id="_idParaDest-147"><a id="_idTextAnchor149"/>Unit testing in Python using PyCharm</h1>
<p>Create a new project in PyCharm using the plain Python project template. Let’s call it <code>bank_account</code>. You’ll find the <a id="_idIndexMarker513"/>completed example in the source repository for this chapter, but if you’d like to practice creating and testing the necessary code, just follow along.</p>
<p>PyCharm created a file called <code>main.py</code>. We’ll use it in a moment, but let’s put our bank transaction code in a separate module. One of the tenets of writing good code is writing <strong class="bold">testable code</strong>, and the<a id="_idIndexMarker514"/> best way to write testable <a id="_idIndexMarker515"/>code is to follow the <strong class="bold">single-responsibility principle</strong> (<strong class="bold">SRP</strong>), where you create units of code that have only one responsibility. SRP is part of a larger set of rules for creating a resilient coding architecture called <strong class="bold">SOLID</strong>, which is an acronym for the following principles:</p>
<ul>
<li><strong class="bold">Single-responsibility </strong><strong class="bold">principle</strong> (<strong class="bold">SRP</strong>)</li>
<li><strong class="bold">Open-closed </strong><strong class="bold">principle</strong> (<strong class="bold">OCP</strong>)</li>
<li><strong class="bold">Liskov substitution </strong><strong class="bold">principle</strong> (<strong class="bold">LSP</strong>)</li>
<li><strong class="bold">Interface segregation </strong><strong class="bold">principle</strong> (<strong class="bold">ISP</strong>)</li>
<li><strong class="bold">Dependency inversion </strong><strong class="bold">principle</strong> (<strong class="bold">DIP</strong>)</li>
</ul>
<p>SOLID is normally <a id="_idIndexMarker516"/>considered when developing a <strong class="bold">fully object-oriented</strong> (<strong class="bold">FOO</strong>) architecture using static languages that are strictly object-oriented. Java, C++, and C# are classic examples of such languages. Python allows for many different development paradigms, and its implementation of <strong class="bold">object-oriented programming</strong> (<strong class="bold">OOP</strong>) isn’t as <a id="_idIndexMarker517"/>complete, or maybe not as traditional, as many others. If you’ve never heard of SOLID as a Python developer, that’s probably why. Books and blogs exist where people have tried to shoehorn Python code to fit, but in my opinion, it often feels forced.</p>
<p>SRP is one you should absolutely follow. It fits into any language and any paradigm. Simply put, the elements you make, be they functions, Python packages, or objects, should do only one thing, and do it well. By breaking up the responsibilities of your code, you can create reusable elements that can easily be unit tested, and therefore easily maintained. Everything should do one thing. Of course, there will be something tying it all together – maybe a <code>main</code> function in a program whose only purpose is to call everything else and provide a flow for your program.</p>
<p>OCP states that once you have shipped a class to production, you should never change it. You should write your code in such a way that your classes are open to extension, but closed for modification. This principle is designed to protect the functionality you’ve already tested and shipped. If you open the class and change it, then you introduce the risk of bugs and you have to retest your entire program. If you limit your changes to an extension, then you only need to worry about testing the extension.</p>
<p>LSP doesn’t translate easily to Python. It states that any sub-class should be able to replace its superclass without affecting the correctness of the program. In other words, if a program is using a base class, it should be able to work correctly when you substitute a derived class for the base class. When you adhere to LSP, you are promoting the concept of<a id="_idIndexMarker518"/> polymorphism within your classes. This allows different objects to be treated uniformly through their common supertype, which leads to more flexible and modular designs. Implementing LSP is hard in dynamic languages such as Python since these languages allow for dynamic typing and late binding of method calls. For this reason, LSP is even more crucial than it is in static, strongly typed languages. The challenge comes with the lack of a strict compile type check you get in C#, C++, or Java. Any design mistakes you make will not surface until runtime. As a Python developer, you must design very carefully, and test with more intensity than you might in other languages.</p>
<p>ISP states that classes or modules should have interfaces that are tailored to their specific needs. An interface that specifies the structure and behavior of a class should not contain anything that is not needed by that class. This doesn’t translate well into Python since Python lacks the traditional interfaces found in languages such as Java and C#. The word interface can be taken to mean a regular superclass, in which case the superclass shouldn’t contain properties and methods that are never used within a subclass.</p>
<p>DIP is a fundamental principle in object-oriented programming that deals with the dependencies between classes and modules. It states that high-level modules should not depend on low-level modules, but both should depend on abstractions. Additionally, it emphasizes that abstractions should not depend on details; rather, details should depend on abstractions.</p>
<p>Here are the key ideas of DIP:</p>
<ul>
<li><strong class="bold">High-level modules should not depend on low-level modules</strong>: High-level modules represent the higher-level logic or functionality of an application, while low-level modules deal with the implementation details and lower-level operations. According to DIP, high-level modules should not directly depend on low-level modules. Instead, both should depend on abstractions.</li>
<li><strong class="bold">Abstractions should not depend on details</strong>: Abstractions, such as interfaces or abstract classes, define contracts that specify the behavior and functionality expected from the collaborating objects. DIP states that these abstractions should not depend on the specific implementation details of the lower-level modules. It promotes the idea of programming to interfaces rather than concrete implementations.</li>
</ul>
<p>To adhere to DIP, it is essential to introduce abstractions, such as interfaces or abstract classes, and program <a id="_idIndexMarker519"/>against those abstractions rather than concrete implementations. This promotes loose coupling and allows for greater flexibility and <a id="_idIndexMarker520"/>maintainability in the code base. Ensure you don’t confuse this with <strong class="bold">dependency injection</strong> (<strong class="bold">DI</strong>). They are related, but not the same thing.</p>
<p>DI is a design pattern or technique that facilitates the implementation of DIP. DI is a way to provide the dependencies required by a class from an external source, rather than having the class create or manage its dependencies internally.</p>
<p>In DI, the responsibility of creating and providing dependencies is delegated to an external entity, typically called an “injector” or “container.” The container is responsible for creating instances of classes and injecting their dependencies. This allows for better decoupling and flexibility and easier testing since dependencies can easily be substituted or mocked during unit testing.</p>
<p>DI can be seen as an implementation strategy for achieving the principles outlined in DIP. It helps in adhering to DIP by providing a mechanism that inverts the control of dependencies and separates the creation of objects from their usage.</p>
<p>In summary, DIP is a guideline for designing modular, loosely coupled systems, while DI is a technique or pattern that’s used to implement DIP, which it does by externalizing the responsibility of managing dependencies.</p>
<p>If you are interested in this kind of architecture, you should check out that book I plugged earlier as SOLID is covered extensively throughout, albeit with C# as the language. SRP, however, fits nicely with any language or paradigm, Python included.</p>
<p>When you stick with functions and classes that only do one thing, and do it well, testing them is a breeze because the functionality is isolated. Functions or classes that try to do too much are harder to<a id="_idIndexMarker521"/> test because of the interplay between dependencies. Let’s build something to make this clear.</p>
<h2 id="_idParaDest-148"><a id="_idTextAnchor150"/>Choosing a test library</h2>
<p>Several popular<a id="_idIndexMarker522"/> unit testing libraries are available for Python 3. Some of the most widely used include the following:</p>
<ul>
<li><code>unittest</code>: This is Python’s built-in unit testing framework, often referred to as <code>unittest</code>. It provides a set of classes and methods for writing and running tests. <code>unittest</code> follows the xUnit style of unit testing and offers features such as test discovery, test fixtures, and assertion methods.</li>
<li><code>pytest</code>: <code>pytest</code> is a popular, feature-rich testing framework that provides a more concise and expressive way of writing tests compared to <code>unittest</code>. It supports test discovery, fixtures, parameterized tests, and powerful assertion methods. <code>pytest</code> is known for its simplicity and flexibility.</li>
<li><code>nose</code>: <code>nose</code> is another popular testing framework that extends the capabilities of <code>unittest</code>. It provides additional features, such as automatic test discovery, test generators, plugins, and advanced test selection and filtering options. While <code>nose</code> is widely used, its popularity has declined in recent years in favor of <code>pytest</code>.</li>
<li><code>doctest</code>: <code>doctest</code> is a unique testing framework that allows you to write tests in the form of interactive examples within docstrings or documentation comments. It extracts and executes the examples as tests, verifying that the actual output matches the expected output. <code>doctest</code> is well-suited for testing code documentation and examples.</li>
</ul>
<p>These are just a few examples of popular unit testing libraries in Python. Each library has its own features, style, and strengths, so it’s worth exploring them to find the one that aligns best with your project’s requirements and your personal preferences. The neat thing about working with PyCharm is that it supports all of these testing libraries, and the UI for running tests and viewing the results is always the same.</p>
<p>Since this is a book on PyCharm rather than an exposition on testing frameworks, I’m going to be using the <code>unittest</code> library, which is part of Python’s standard library. This will keep our sample code free of<a id="_idIndexMarker523"/> external dependencies.</p>
<h2 id="_idParaDest-149"><a id="_idTextAnchor151"/>Adding a bank account class</h2>
<p>Right-click the project title<a id="_idIndexMarker524"/> in the project window and select <code>bank_account.py.</code></p>
<p>Next, add the following code:</p>
<pre class="source-code">
class BankAccount:
  def __init__(self, name: str, account_number: str, \
    balance: float):
    self.name = name
    self.account_number = account_number
    self.balance = balance</pre> <p>So far, we’ve created a class called <code>BankAccount</code>, created a constructor, and initialized three member variables called <code>name</code>, <code>account number</code>, and <code>balance</code>. Next, we’ll add a method designed to handle withdrawing money, but only if the amount is less than the balance:</p>
<pre class="source-code">
  def withdraw(self, amount: float) -&gt; None:
    new_balance = self.balance - amount
    if new_balance &gt; 0:
      self.balance = new_balance
    else:
      raise ValueError("Account overdrawn!")</pre> <p>If the amount that’s withdrawn is more than <code>balance</code>, we throw a <code>ValueError</code> and issue a message stating <code>Account overdrawn!</code>. Next, we need a method to add money to the account. It needs to be a positive number; otherwise, we’ll be doing a withdrawal, not a deposit:</p>
<pre class="source-code">
  def deposit(self, amount: float):
    if amount &gt; 0:
      self.balance += amount
    else:
      raise ValueError("Deposit amount must be greater \
        than 0.")</pre> <p>So far, so good, right? Since <a id="_idIndexMarker525"/>our methods have some business logic in them, we should create a unit test for them.</p>
<h2 id="_idParaDest-150"><a id="_idTextAnchor152"/>Testing the bank account class</h2>
<p>Right-click the title <a id="_idIndexMarker526"/>of the project in the project window and select <strong class="bold">New</strong> | <strong class="bold">Python File</strong>, but this time, make it a Python unit test, as shown in <em class="italic">Figure 6</em><em class="italic">.1</em>:</p>
<div><div><img alt="Figure 6.1: There are several templates for a new Python file" src="img/B19644_Figure_6.01.jpg"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 6.1: There are several templates for a new Python file</p>
<p>There are several conventions for working with test files. Some think it’s a good idea to have a folder that contains just tests. Others think the test file should be right next to the file it is testing. I like this convention because it allows me to easily see which files in my project lack testing. Per a similar convention, I’m going to name the file <code>back_account_test.py</code>. Conventions dictate I either start or end the name of my file with the word <em class="italic">test</em>. I have put it at the end because if I don’t, the test file won’t be next to the file it is testing within the file explorer.</p>
<p>PyCharm creates the file, but it isn’t empty. The code in the file looks like this:</p>
<pre class="source-code">
import unittest
class MyTestCase(unittest.TestCase):
  def test_something(self):
    self.assertEqual(True, False) # add assertion here
if __name__ == '__main__':
  unittest.main()</pre> <p>The IDE has presented us with a template containing a testing class that inherits from Python’s built-in unit testing framework. The framework is simply but unimaginatively called <code>unittest</code>. The<a id="_idIndexMarker527"/> template contains the required import at the top of the file, a testing class, one test method, and a <code>dunder-main</code> block that allows the script to run standalone. To get the test working, you need to modify this file. Start by adding an import to the file containing the class you want to test. The added line is in bold:</p>
<pre class="source-code">
import unittest
from bank_account import BankAccount</pre> <p>Next, change the name of the class to <code>BankAccountTestCase</code>. Then, take out the <code>test_something(self)</code> method entirely and replace it with this one:</p>
<pre class="source-code">
  def test_init(self):
    test_account = BankAccount("Bruce Van Horn", \
      "123355-23434", 4000)
    self.assertEqual(test_account.name, "Bruce Van Horn")
    self.assertEqual(test_account.account_number, \
      "123355-23434")
    self.assertEqual(test_account.balance, 4000)</pre> <p>To be honest, this is kind of a silly test because the constructor logic is extremely simple. Even I would be tempted to skip it. That isn’t always the case, though. If you’re doing something complicated in the constructor, you should unit-test it. Here, the example serves as a simple one to get us moving. All we did here was create a new instance of the <code>BankAccount</code> class and pass in a name, an account number, and an initial balance. Then, we used<a id="_idIndexMarker528"/> the <code>unittest</code> class’ <code>assertEqual</code> method to check each of the member variables to make sure they were set properly. There’s pretty much no way they weren’t unless you made a mistake, which is exactly the point.</p>
<p class="callout-heading">Beware of the pesky self-typing self):</p>
<p class="callout">Having done a whole chapter on the miracles of auto-completion, I have to admit that sometimes, it can be annoying. This is one of those times. The instant you type the opening parenthesis of your test method, PyCharm is going to fill in the word <code>self</code>, along with the closing parenthesis and the colon for the end of the line. Because I type rapidly, I used to often wind up with something like <code>test_init(selfsel):</code> before I caught what happened. I’ve trained my right hand to find the <em class="italic">End</em> key on the keyboard as soon as I hit the opening parenthesis. This jumps you to the end of the auto-completed line. Hit <em class="italic">Enter</em>, and you’ll be right where you want to be.</p>
<p>We’re going to add two more tests below the first one. The first test will test the <code>withdraw</code> method. Type in the new method below the first test, but above the line with the <code>dunder-main</code> test:</p>
<pre class="source-code">
def test_withdraw(self):
  self.fail()</pre> <p>Type the test for the deposit below the <code>test_withdraw</code> method:</p>
<pre class="source-code">
def test_deposit(self):
  self.fail()</pre> <p>If you haven’t guessed yet, these two tests are going to fail. That’s OK. I like to see them fail so that I know the whole testing setup is working. One of the benefits and side effects of being a long-time software developer is you don’t just assume anything will just work, regardless of who wrote it or how much the thing costs. Call it a survival instinct. If you skip this step, then may the odds be ever in your favor.</p>
<h2 id="_idParaDest-151"><a id="_idTextAnchor153"/>Running the tests</h2>
<p>Let’s run our tests. Like many <a id="_idIndexMarker529"/>things, there are lots of ways to run the tests. You have no doubt noticed the appearance of green arrows in your test code, as seen in <em class="italic">Figure 6</em><em class="italic">.2</em>:</p>
<div><div><img alt="Figure 6.2: Green run arrows will appear in the IDE as you create your tests" src="img/B19644_Figure_6.02.jpg"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 6.2: Green run arrows will appear in the IDE as you create your tests</p>
<p>These green arrows trigger a menu when you click them. For now, we’ll click the first item, which is <code>BankAccountTestCase</code>, the test runner will appear in the tool window at the bottom of the IDE window. You can see mine in <em class="italic">Figure 6</em><em class="italic">.3</em>:</p>
<div><div><img alt="Figure 6.3: The test runner shows the tests that run, including those that passed and failed, and the console output" src="img/B19644_Figure_6.03.jpg"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 6.3: The test runner shows the tests that run, including those that passed and failed, and the console output</p>
<p>The test runner itself has a complete<a id="_idIndexMarker530"/> set of tools integrated into its window. I’ve numbered them in <em class="italic">Figure 6</em><em class="italic">.3</em>:</p>
<ol>
<li>This pane shows the tests that passed and those that failed. They are displayed in a hierarchy that matches the call hierarchy.</li>
<li>This pane shows the console output from the test run itself.</li>
<li>Above the output pane is a summary of the number of passing tests, along with how long the test suite ran.</li>
<li>To the left on the same toolbar is a collection of five buttons, followed by a vertical ellipsis. The ✓ and   ⃠   buttons will filter out all the passed and failed tests, respectively. Filtering out the passed tests lets you focus solely on what failed. Filtering out the failed tests reduces the general malaise and utter hopelessness that you’ll feel when you have 5 out of 100 tests that passed. When this happens, I usually eat a sandwich and I feel better. Look at it this way: so long as you have failing tests, your job is probably safe because it would take longer to train a replacement than it would to wait until everything starts working. See it as a glass half-full. The next three before the ellipsis allow you to sort your test results, import tests from another file, and review your test run history. Say you have a test that was passing, then it failed and you wanted to go back and look at the last<a id="_idIndexMarker531"/> time it passed. That history is there if you need it. The ellipsis holds a few more options, including some miscellaneous settings for the test runner itself.</li>
<li>This toolbar allows you to rerun all the tests, rerun only those that failed, and stop a long-running test. Again, we have a vertical ellipsis, but this one has an interesting option for toggling <strong class="bold">Auto Test</strong>. Turning this option on will continually run your tests, for those of you who can’t stand the cursor travel time back down to the rerun button.</li>
</ol>
<p>When you run tests for the first time, PyCharm will create run configurations for you automatically. You can see them in the <strong class="bold">Run configuration</strong> dropdown on the top toolbar.</p>
<h2 id="_idParaDest-152"><a id="_idTextAnchor154"/>Fixing the failing tests</h2>
<p>We have two<a id="_idIndexMarker532"/> tests that will always fail, no matter what we do. Let’s start by altering the <code>test_withdraw(self)</code> method in the <code>bank_account_test.py</code> file. Change it to this:</p>
<pre class="source-code">
def test_withdraw(self):
 test_account = BankAccount("Bruce Van Horn", "123355-23434", 4000)
 test_account.withdraw(2000)
 self.assertEqual(test_account.balance, 2000)</pre> <p>The first line instantiates the <code>BankAccount</code> class with some testable values. Next, we invoke the <code>withdraw</code> method and withdraw $2,000. I hope it is for something fun! Usually, it is my daughters borrowing my wallet to either shop for clothes or maybe buy raw materials for an engineering project. I can hope, right? I now expect my balance to drop from $4,000 to $2,000. So, I use the <code>assertEqual</code> method on the <code>unittest</code> class, which is the superclass for my <code>BankAccountTestCase</code> class. I pass in <code>test_account.balance</code>, which will be compared with the expected result.</p>
<p>I fully expect this test to pass! Click the rerun failed tests button shown in <em class="italic">Figure 6</em><em class="italic">.3</em>. It passed! Now, let’s write the <code>test_deposit</code> method:</p>
<pre class="source-code">
def test_deposit(self):
 test_account = BankAccount("Bruce Van Horn", "123355-23434", 4000)
 test_account.deposit(5000)
 self.assertEqual(test_account.balance, 9000)</pre> <p>The explanation here is the same as the last one, except this time, we are depositing $5,000 into my account. This rarely happens in real life, so give me a moment while I celebrate.</p>
<p>Rerun the failed tests. They<a id="_idIndexMarker533"/> should all pass now! But we’re not done yet, are we?</p>
<p>So far, these tests have followed the no-fault path. This means that so far, I’ve only tested the methods while running them as I designed them. Users in the real world will never do this. We need to test fault paths as well.</p>
<h2 id="_idParaDest-153"><a id="_idTextAnchor155"/>Testing the fault paths</h2>
<p>There is one<a id="_idIndexMarker534"/> obvious fault path we designed into the system: the overdraft. What will happen if we try to take out more money than is available in the current balance? Or as my daughters might say, how do we generate a signal that tells us it’s time to come home from the mall and hide the receipts?</p>
<p>We account for this in our code:</p>
<pre class="source-code">
def withdraw(self, amount: float) -&gt; None:
    new_balance = self.balance - amount
    if new_balance &gt; 0:
      self.balance = new_balance
    else:
      raise ValueError("Account overdrawn!")</pre> <p>As you can see, we check if the new balance will be a negative number. If it is, we throw a <code>ValueError</code>. This test is going to be a little different. Instead of using <code>assertEquals</code> to test a no-fault result, we want to verify that when this condition exists, we not only throw an error but that we throw the right kind of error. This is important because we expect <code>ValueError</code>, but if some other error is produced, the tests will give us a false positive if we only test for a generic <code>Exception</code>. Add the following test <code>BankAccountTestCase</code> class:</p>
<pre class="source-code">
def test_overdraft(self):
 test_account = BankAccount("Bruce Van Horn", "123355-23434", 4000)
 self.assertRaises(ValueError, test_account.withdraw, 5000)]</pre> <p>As before, we instantiate the <code>BankAccount</code> class with some testable values. For the test, we want to<a id="_idIndexMarker535"/> assert that the withdraw method raises a <code>ValueError</code> if we pass in more money than what exists in the balance. Here, we use <code>self.assertRaises</code>, which takes three arguments. The first argument is the type of error we expect.</p>
<p>The second argument is the method under test. Note that we’re passing a reference to the function lambda-style. We aren’t executing the function since we need the <code>assertRaises</code> function to do that. Finally, we need to pass in the value of any arguments – in this case, some numbers that are bigger than the four grand I used for instantiation. In this case, I pass in <code>5000</code>. When I run this test, it should pass because the function will fail with the <code>ValueError</code> exception I expect.</p>
<p>There is just one test left: we need to be sure that when we pass a negative number into the <code>deposit</code> method, we get a <code>ValueError</code>. I’ll leave this one for you to practice with. The full working code is in the repository code for this chapter.</p>
<h2 id="_idParaDest-154"><a id="_idTextAnchor156"/>Generating tests automatically</h2>
<p>So far, we’ve<a id="_idIndexMarker536"/> spent some time writing the <code>BankAccout</code> class, but think back to our original idea for a use case for unit testing: a financial transaction. This time, we’re going to write some code that needs to be tested, but instead of a generic test template, we’re going to generate a more exact test.</p>
<p>Let’s start with the code we will be testing. Create a new file in your project called <code>transaction.py</code>. The contents of this file should look as follows:</p>
<pre class="source-code">
from bank_account import BankAccount</pre> <p>We’ll need the <code>BankAccount</code> class since the whole idea is to write code that transfers money from one account to <a id="_idIndexMarker537"/>another in response to the sale of an item. Speaking of <em class="italic">item</em>, let’s make a class to represent what we’ll be buying:</p>
<pre class="source-code">
class Item:
  def __init__(self, name: str, price: float):
    self.name = name
    self.price = price</pre> <p>There’s nothing too crazy here – just two instance variables called <code>name</code> and <code>price</code>. Now for the hard part: we need a class to represent a transaction. Remember, a transaction is an atomic operation. All the steps should be completed. If there are any errors along the way, everything that happened before the error needs to be rolled back:</p>
<pre class="source-code">
class Transaction:
  def __init__(self, buyer: BankAccount, seller: \
    BankAccount, item: Item):
    self.buyer = buyer
    self.seller = seller
    self.item = item</pre> <p>We started the class with a constructor that initializes two bank accounts and an item. After this comes the logic for the transaction itself:</p>
<pre class="source-code">
  def do_transaction(self):
    original_buyer_balance = self.buyer.balance
    original_seller_balance = self.seller.balance</pre> <p>We need to store the original balances. If anything goes awry, we’ll need this information to put everything back the way it was. Next comes the part where money changes hands. I’ll <a id="_idIndexMarker538"/>wrap it in a <code>try</code>:</p>
<pre class="source-code">
    try:
      self.buyer.withdraw(self.item.price)
      self.seller.deposit(self.item.price)
    except ValueError:
      self.buyer.balance = original_buyer_balance
      self.seller.balance = original_seller_balance
      raise ValueError("Transaction failed and was \
        rolled back")</pre> <p>We attempt to withdraw money from the buyer’s account, then deposit the same amount into the seller’s account. If a <code>ValueError</code> is thrown, we put all the money back by restoring the balances to their original values. Once the money has been restored, we should still raise an error so that the primary application knows the error occurred. This function will need to report the result to a user interface to let the user know what happened with the transaction. The last line handles this for us. In a real application, you might want to create your own custom error that might yield more information, but this one serves us well for demonstrative purposes.</p>
<h2 id="_idParaDest-155"><a id="_idTextAnchor157"/>Generating the transaction test</h2>
<p>Earlier, we created <a id="_idIndexMarker539"/>a new test using the <code>class Transaction</code>. Then, click the <strong class="bold">Generate…</strong> menu option, as seen in <em class="italic">Figure 6</em><em class="italic">.4</em>:</p>
<div><div><img alt="Figure 6.4: The Generate… menu item can be found when you right-click your class definition" src="img/B19644_Figure_6.04.jpg"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 6.4: The Generate… menu item can be found when you right-click your class definition</p>
<p>Next, click <strong class="bold">Test…</strong>, as<a id="_idIndexMarker540"/> seen in <em class="italic">Figure 6</em><em class="italic">.5</em>:</p>
<div><div><img alt="Figure 6.5: Click the Test… button to generate your test" src="img/B19644_Figure_6.05.jpg"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 6.5: Click the Test… button to generate your test</p>
<p>At this point, a dialog box will appear where<a id="_idIndexMarker541"/> you can control the test that will be generated, as seen in <em class="italic">Figure 6</em><em class="italic">.6</em>:</p>
<div><div><img alt="Figure 6.6: PyCharm is about to generate a unit test file based on these settings" src="img/B19644_Figure_6.06.jpg"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 6.6: PyCharm is about to generate a unit test file based on these settings</p>
<p>PyCharm is about to create a file called <code>test_transaction.py</code>. Within that file, instead of a generic test class name, there will be a class definition called <code>TestTransaction</code>. Finally, within the file, assuming you leave the checkbox ticked, a test method stub will be generated called <code>test_do_transaction</code>.</p>
<p>The resulting file contains this code:</p>
<pre class="source-code">
from unittest import TestCase
class TestTransaction(TestCase):
  def test_do_transaction(self):
    self.fail()</pre> <p>Way back in <a href="B19644_01.xhtml#_idTextAnchor014"><em class="italic">Chapter 1</em></a>, I told you that one of the benefits of an IDE is that it can reduce boilerplate. The first time, PyCharm generated some generic boilerplate for us. At least we didn’t have to type it in, but it was almost as much effort to change what it generated. This time, there is <a id="_idIndexMarker542"/>even less work to do. If I had many methods in my class, there would be a correctly named stub for each of them.</p>
<p>All I must do now is write the code that makes the <code>test_do_transaction</code> method pass. Behold!</p>
<pre class="source-code">
from unittest import TestCase
from bank_account import BankAccount
from transaction import Transaction, Item</pre> <p>We started with the required imports. I know I’m going to need two tests, rather than just the one PyCharm generated. PyCharm generated one test method, which I’m using for the no-fault path. I’ll pass in something that works the way the method is intended to work. Since I know I have two tests, I can reuse the seller account to keep my test <strong class="bold">DRY</strong>. If you’re not familiar with the<a id="_idIndexMarker543"/> acronym, it stands for <strong class="bold">Don’t Repeat Yourself</strong>. By hoisting this code to the top of the file, I only need to type it once. This code will initialize a seller’s bank account with a balance of $4,000. It also sets up the item we will be purchasing, which will not change between tests:</p>
<pre class="source-code">
initial_seller_balance = 4000
seller_account = BankAccount("PacktPub", "839423-38402",
               initial_seller_balance)
item = Item("Python book", 39.95)</pre> <p>Next, we will move on to the test class itself, which was generated for us. We already have this part:</p>
<pre class="source-code">
class TestTransaction(TestCase):
 def test_do_transaction(self):</pre> <p>I’m replacing the generated <code>self.fail()</code> with code that I hope will cause the test to pass:</p>
<pre class="source-code">
  buyer_account = BankAccount("Bruce Van Horn", "123355-23434", 99)
  item = Item("Python book", 39.95)
  test_transaction = Transaction(buyer_account, \
  seller_account, item)</pre> <p>As usual, I instantiate the classes I’ll be using in the test. So far, I’ve made two accounts and an item with a price. Next, I’ll run the method under test:</p>
<pre class="source-code">
  test_transaction.do_transaction()</pre> <p>Then, I’ll check my results:</p>
<pre class="source-code">
  self.assertEqual(buyer_account.balance, 99 - 39.95)
  self.assertEqual(seller_account.balance,\
                   initial_seller_balance + 39.95)</pre> <p>You might be<a id="_idIndexMarker544"/> tempted to get fancy with the test code. Be careful with this. Fancy test code is as likely to break as the purposefully fancy code it is meant to test. If you are testing complicated math, please don’t duplicate the calculation in the test and then compare it to the code under test. You should be plugging in known inputs and checking for known outputs. Nothing more!</p>
<p>This test represents the no-fault path. I fully expect this to pass since this exercise merely entails everything working under ideal conditions. Let’s see if I’m right. Click any of the green run buttons. My result is shown in <em class="italic">Figure 6</em><em class="italic">.7</em>:</p>
<div><div><img alt="Figure 6.7: So far, so good! My test is passing!" src="img/B19644_Figure_6.07.jpg"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 6.7: So far, so good! My test is passing!</p>
<p>We need a test for at least one fault path. In this case, it will be to test what happens when I don’t have<a id="_idIndexMarker545"/> enough in my account to cover buying a book.</p>
<p>Here’s my test for that case:</p>
<pre class="source-code">
def test_transaction_overdraw_fault(self):
 initial_buyer_balance = 5
 buyer_account = BankAccount("Bruce Van Horn", \
  "123355-23434", initial_buyer_balance)
 test_transaction = Transaction(buyer_account, \
  seller_account, item)</pre> <p>When I left for work today, I had at least $9,000 in my account. But my daughter Phoebe “borrowed” my card out of my jacket pocket. She said she was going to create a robotic bicycle factory. I thought nothing of it. She was kidding, right? So, I go to the bookstore after work, intent on picking up the latest masterpiece:</p>
<pre class="source-code">
 test_transaction.do_transaction()</pre> <p>The transaction occurs. Do you know that sound that Pac-Man makes when he gets eaten by a ghost? I’m<a id="_idIndexMarker546"/> making that sound now. The sale will fail; let’s see if the transaction rolls back correctly:</p>
<pre class="source-code">
 self.assertEqual(buyer_account.balance, initial_buyer_balance)
 self.assertEqual(seller_account.balance, initial_seller_balance)</pre> <p>This last piece of code verifies that both the buyer and seller balances are returned to their original values. Run the tests – they should both pass! See <em class="italic">Figure 6</em><em class="italic">.8</em> for my triumphant test run. I can’t wait to go home and relax!</p>
<div><div><img alt="Figure 6.8: I’d better call my wife and tell her to keep dinner warm for me" src="img/B19644_Figure_6.08.jpg"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 6.8: I’d better call my wife and tell her to keep dinner warm for me</p>
<p>It looks like I was a little overconfident. The output window shows a set of stack traces for everything that went wrong. It’s so long that I had to scroll down quite a bit to get to the good part of this screenshot. In the trace (which is not shown), I can see that a few of the errors I thought would be thrown were, and that’s fine. The two we can see here are not. First, I intended to verify that the message coming from the exception matched the value I assigned in the definition. Again, I’m doing this to make sure the error I threw is the one we’re seeing and not some other error resulting from a mistake. It looks like I didn’t understand the structure of the error, and in fact, there is no attribute called message. I coulda swore! Wait – that’s probably from some other language. OK, I can look that up.</p>
<p>The other, more disturbing<a id="_idIndexMarker547"/> error is that my transaction didn’t roll back! As you look at the trace, you’ll see that there are hyperlinks throughout that allow you to navigate directly to the fault code mentioned in the trace. It is very easy to move around and look for problems. I can find the line for the first problem in the list of stack traces, as shown in <em class="italic">Figure 6</em><em class="italic">.9</em>:</p>
<div><div><img alt="Figure 6.9: The stack traces are riddled with hyperlinks that will jump you to the offending section of your code" src="img/B19644_Figure_6.09.jpg"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 6.9: The stack traces are riddled with hyperlinks that will jump you to the offending section of your code</p>
<p>Clicking this link takes me to the problematic code shown in <em class="italic">Figure 6</em><em class="italic">.10</em>:</p>
<div><div><img alt="Figure 6.10: Fiddlesticks! The IDE even told me line 34 was wrong, but I didn’t listen" src="img/B19644_Figure_6.10.jpg"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 6.10: Fiddlesticks! The IDE even told me line 34 was wrong, but I didn’t listen</p>
<p>I have a few options here, don’t I? I could use the documentation features in PyCharm by hovering over the <code>e</code> variable. We talked about automatic documentation features in <a href="B19644_04.xhtml#_idTextAnchor077"><em class="italic">Chapter 4</em></a>. <em class="italic">Figure 6</em><em class="italic">.11</em> shows what this looks like in case you’ve been skipping around:</p>
<div><div><img alt="Figure 6.11: The auto-documentation feature will give me a link to the official documentation" src="img/B19644_Figure_6.11.jpg"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 6.11: The auto-documentation feature will give me a link to the official documentation</p>
<p>There’s no easy answer here, is there? Sure, I could click on the link at the bottom and go to the Python site and read the documentation. If I do that, though, I’ll lose any credibility with you, the<a id="_idIndexMarker548"/> reader. Read the manual with y’all watching? No chance! I’m sure I’d find the answer but at the expense of my pride.</p>
<p>I have another idea! I’ve talked about PyCharm’s console before. I’d like to try something out. Check out <em class="italic">Figure 6</em><em class="italic">.12</em>:</p>
<div><div><img alt="Figure 6.12: If the PyCharm Console button (2) isn’t on your toolbar, click the ellipses (1) to turn it on" src="img/B19644_Figure_6.12.jpg"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 6.12: If the PyCharm Console button (2) isn’t on your toolbar, click the ellipses (1) to turn it on</p>
<p>The arrow pointing to <em class="italic">2</em> will open the PyCharm console. If you’ve never done this, that icon won’t be on the toolbar. You’ll need<a id="_idIndexMarker549"/> to click the ellipsis at <em class="italic">1</em> and click the <strong class="bold">Python Console</strong> area. This will add it to your toolbar. My console session is shown in <em class="italic">Figure 6</em><em class="italic">.13</em>:</p>
<div><div><img alt="Figure 6.13: Revisiting the console allows us to do a quick experiment to solve our error" src="img/B19644_Figure_6.13.jpg"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 6.13: Revisiting the console allows us to do a quick experiment to solve our error</p>
<p>In the console, I first hit <em class="italic">Enter</em> on the first line. I did that for you. If I hadn’t, the console would have bunched everything up and it wouldn’t look as pretty. Next, I typed the following:</p>
<pre class="source-code">
check = ValueError("This is a test")</pre> <p>I suspect that if I convert the check into a string, I will get the message I am looking for. Call it intuition. Or call it “I looked it <a id="_idIndexMarker550"/>up with <strong class="bold">ChatGPT</strong> while your back was turned.” I’m going with intuition.</p>
<p>If I type in <code>str(check)</code>, the Python REPL will evaluate the expression and print the result. The idea works. I can<a id="_idIndexMarker551"/> correct my code. Line 34 in <code>test_transaction.py</code> will now be as follows:</p>
<pre class="source-code">
self.assertEqual(str(e), "Transaction failed and was rolled back")</pre> <p>Now, if I run the test again, it will fail, as shown in <em class="italic">Figure 6</em><em class="italic">.14</em>:</p>
<div><div><img alt="Figure 6.14: Progress can be measured in software development by the rate at which the list of errors is reduced" src="img/B19644_Figure_6.14.jpg"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 6.14: Progress can be measured in software development by the rate at which the list of errors is reduced</p>
<p>We expected this. The list of problems got shorter, so it’s a victory! Let’s clear out the last problem. The transaction is failing to correctly reset the value of the seller’s account after the transaction fails. We could stare at it for a while, or we could take a more proactive approach by firing up PyCharm’s debugger and stepping through the whole test.</p>
<h1 id="_idParaDest-156"><a id="_idTextAnchor158"/>Working with PyCharm’s debugger</h1>
<p>In <a href="B19644_01.xhtml#_idTextAnchor014"><em class="italic">Chapter 1</em></a>, I lauded PyCharm’s debugger as the single biggest reason to use an IDE versus a command-line debugger such as the standard Python debugger, which is called <strong class="bold">pdb</strong>. Don’t get<a id="_idIndexMarker552"/> me wrong – you <a id="_idIndexMarker553"/>should learn to use pdb because there will be times when the IDE isn’t available. However, I suspect that once you use PyCharm’s, you’ll prefer it over anything else. Let’s see if I’m right.</p>
<p>We have a problem in our <code>Transaction</code> class that isn’t quite accurate. When it comes to testing, there are always two possibilities:</p>
<ul>
<li>The code is failing because of a flaw in the code under test.</li>
<li>The code is failing because of the test code.</li>
</ul>
<p>Since we don’t know which possibility is correct at this point, the debugger is going to allow us to step through our code one line at a time and inspect its inner workings. To do this, we need to set a breakpoint. A breakpoint marks a spot in your code where you would like to halt its execution and inspect the contents of the variables, the stack, and so on. You can create a breakpoint by clicking the line number in the gutter within the editor, as shown in <em class="italic">Figure 6</em><em class="italic">.15</em>. I’m going to add a breakpoint to the beginning of the test so that we can walk through it. The test starts on line 25, so I’ll click on that line number; observe that the line number has been replaced with a red dot:</p>
<div><div><img alt="Figure 6.15: Click a line number to create a breakpoint, which will replace the number with a red dot" src="img/B19644_Figure_6.15.jpg"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 6.15: Click a line number to create a breakpoint, which will replace the number with a red dot</p>
<p>Next, we need to run<a id="_idIndexMarker554"/> the debugger. Click the green arrow in the editor window next to the method definition for the <code>test_transaction_overdraw_fault(self)</code> method. This time, click the <strong class="bold">Debug ‘Python tests for tes…’</strong> option, shown in <em class="italic">Figure 6</em><em class="italic">.16</em>, to run the failed test:</p>
<div><div><img alt="Figure 6.16: Clicking the green arrows provides a menu that can be used to make variations to a running test, including running the debugger" src="img/B19644_Figure_6.16.jpg"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 6.16: Clicking the green arrows provides a menu that can be used to make variations to a running test, including running the debugger</p>
<p>When the debugger is run, the program will start, then stop on line 25 of our test. The IDE transformed significantly. Let’s look at <em class="italic">Figure 6</em><em class="italic">.17</em>:</p>
<div><div><img alt="Figure 6.17: The paused debugger in PyCharm" src="img/B19644_Figure_6.17.jpg"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 6.17: The paused debugger in PyCharm</p>
<p>There are a few things you might notice right away. First, the run buttons at the top of the IDE are now green, and the red stop button is illuminated (<em class="italic">1</em>). These are all visual clues showing that something is running, which of course we do.</p>
<p>The bottom half of the IDE is<a id="_idIndexMarker555"/> now taken up by the debugger tools (<em class="italic">2</em>). There is also a tab bar present (<em class="italic">3</em>), which allows you to run multiple debugging sessions at the same time. This can be handy when developing RESTful microservice architectures, which we’ll talk about in several of the upcoming chapters, most notably in <em class="italic">Chapter 9</em>, <em class="italic">Creating a RESTful API </em><em class="italic">with FastAPI</em>.</p>
<p>There is a list of threads on the right-hand side (<em class="italic">4</em>), which allows you to switch between and inspect the various threads at play. However, most of the time, you’re going to land in the right place and might use this only rarely. The area at location <em class="italic">5</em> shows everything that is currently in scope. Right now, that is just <code>self</code>, which you can see is an instance of the <code>TestTransaction</code> class.</p>
<p><em class="italic">6</em> shows two tabs that allow you to switch between the view we’re seeing right now, which allows you to inspect the state of the program at area <em class="italic">5</em>. If you switch this tab to <code>print</code> statements will appear so that you can review the output as the program runs.</p>
<p>The toolbar marked with <em class="italic">7</em> houses a set of very useful tools, while the expression window (<em class="italic">8</em>) allows you to add a <a id="_idIndexMarker556"/>watch or evaluate an expression using whatever is currently in scope.</p>
<p>The most useful parts of the debugging window are the inspection area (<em class="italic">5</em>), the tab switch, which you can use to swap between the variable and thread inspector and console output (<em class="italic">6</em>), and the debugging toolbar (<em class="italic">7</em>). Let’s take a closer look at the debugging toolbar:</p>
<div><div><img alt="Figure 6.18: The debugging toolbar in PyCharm" src="img/B19644_Figure_6.18.jpg"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 6.18: The debugging toolbar in PyCharm</p>
<p>I’ve numbered each button. Let’s review them:</p>
<ol>
<li>This button restarts the debugging run. You can find a duplicate restart button at the top of the IDE window near the run button.</li>
<li>This button stops the debugging run. You can find a duplicate stop button at the top of the IDE window near the restart button.</li>
<li>This is the <strong class="bold">Continue</strong> button. The debugger will stop at any breakpoint it hits and wait until you use one of the step buttons (<em class="italic">5</em> – <em class="italic">8</em>) or you hit this button to continue the run.</li>
<li>The <strong class="bold">Pause</strong> button will pause the run. This can be useful if you’re running a loop or an algorithm that takes a while and you want to pause the run.</li>
<li>The <strong class="bold">Step Over</strong> button will execute the current line where the debugger has paused. If that line is a function call to a function in your program, the function will execute normally and return, after which you’ll be taken to the next line of your code, where the debugger will remain paused. Here, you’re stepping over the execution of the next line.</li>
<li>In contrast, this is the <strong class="bold">Step Into</strong> button. If your debugger has paused on a line containing a function call, clicking this button will allow you to step into that function and step through as if you had placed a breakpoint at the beginning of the function. <strong class="bold">Step Over</strong> skips past this execution, while this button steps into it.</li>
<li><strong class="bold">Step Into My Code</strong> is a <a id="_idIndexMarker557"/>game changer! This button is just like the <strong class="bold">Step Into</strong> button (<em class="italic">6</em>), except this one will not step into code that you didn’t create. By that, I mean the <strong class="bold">Step Into</strong> button will happily step you into the bowels of your third-party library code, or into the code comprising Python itself. This is rarely useful. The <strong class="bold">Step Into My Code</strong> button will only step into code that is part of your project.</li>
<li>This is the <strong class="bold">Step Out</strong> button. If you find yourself stepping into some code that clearly isn’t a problem, or maybe you’ve taken into library code you didn’t create, the step-out code will jump you back out to the point where you entered.</li>
</ol>
<p class="callout-heading">Attention Visual Studio users</p>
<p class="callout">The buttons in the PyCharm debugger work differently than they do in Visual Studio! This took some getting used to for me. In Visual Studio, you can click the green button on the top toolbar to start the debugging session. When you hit a breakpoint, you can hit the same button to continue. In PyCharm, the continue button is in the debugging toolbar, in area <em class="italic">3</em> in <em class="italic">Figure 6</em><em class="italic">.18</em>. If you were to click the same button you used to launch the debugger, you would launch a second debug session. PyCharm will generally complain when you do this unless you’ve checked the box in the run configuration that allows multiple runs at the same time.</p>
<h2 id="_idParaDest-157"><a id="_idTextAnchor159"/>Using the debugger to find and fix our test problem</h2>
<p>Our unit test revealed a <a id="_idIndexMarker558"/>problem in our code. When our transaction fails due to an overdraft error, we expect the balances of our buyer and seller to revert to their original values. At this point, the seller is getting $39.95 in credit following a failed transaction. Let’s use the debugger to step through and see if we can figure out why this is happening.</p>
<p>Per <em class="italic">Figure 6</em><em class="italic">.19</em>, we’ve started the debugger on our unit test and we’ve stopped at line 25 in <code>test_transaction.py</code>. At this stage, nothing in the test method has run. When you’re looking at a highlighted line in PyCharm’s debugger, you need to remember that the highlighted line has not been executed yet. To execute the line, click the <code>buyer_account</code> has been instantiated, and our highlight will move to and<a id="_idIndexMarker559"/> stop on line 26, as shown in <em class="italic">Figure 6</em><em class="italic">.19</em>:</p>
<div><div><img alt="Figure 6.19: Having clicked the Step Over button, the debugger has been stopped on line 26" src="img/B19644_Figure_6.19.jpg"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 6.19: Having clicked the Step Over button, the debugger has been stopped on line 26</p>
<p>To see the content of the objects, you’ll need to twirl open the caret, which I’ve circled in <em class="italic">Figure 6</em><em class="italic">.19</em>. You can see that <code>buyer_account</code> has a balance of $5. However, what we’re interested in here is the seller account since that’s where the problem lies.</p>
<p>Click line 30 to add a breakpoint there, then click the <code>do_transaction()</code> method to watch it execute. Click the <strong class="bold">Step Into My Code</strong> button. Refer to <em class="italic">Figure 6</em><em class="italic">.18</em> and look at <em class="italic">7</em> if you don’t remember which button I mean.</p>
<p>This will take us to line 17 in <code>transaction.py</code>. Step over lines 17 and 18 to arrive at line 19 and inspect our state. You’ll see the problem, which is shown in <em class="italic">Figure 6</em><em class="italic">.20</em>:</p>
<div><div><img alt="Figure 6.20: The debugger reveals that the starting value of the seller balance is wrong" src="img/B19644_Figure_6.20.jpg"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 6.20: The debugger reveals that the starting value of the seller balance is wrong</p>
<p>The debugger reveals that the<a id="_idIndexMarker560"/> original seller balance is $4,039.95, where we would expect it to be $4,000. You can see this value in two places. The variables window shows it to us (<em class="italic">1</em>), but you can also hover over any in-scope variable in the editor window (<em class="italic">2</em>) and see its value.</p>
<p>Now, why would our starting balance be wrong? It’s a scope problem! Since I hoisted the <code>seller_account</code> variable to line 5 in <code>test_transaction.py</code> up to a global, the first test successfully changes the balance to $4,039.95 just like it should. Since it is global, that number remains. To fix this, we need to reset the balance of the seller account at the beginning of the <code>test_transaction_overdraw_fault(self)</code> method. We started our debugging efforts on line 25. Let’s just make our change there. Click the stop button on the debugger toolbar, then add this line on line 25:</p>
<pre class="source-code">
seller_account.balance = 4000</pre> <p>Rerun your tests without debugging. Be bold! Assume it worked! If you’re not following along, kindly move to <a id="_idIndexMarker561"/>the edge of your seat and begin biting your nails nervously. Will our hero triumph in <em class="italic">Figure 6</em><em class="italic">.21</em>? Cue organ music: duhn duhn duuuuuhn!</p>
<div><div><img alt="Figure 6.21: Victory!" src="img/B19644_Figure_6.21.jpg"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 6.21: Victory!</p>
<p>It works! Now, it’s time to head home and heat up dinner since we’ve restored everyone’s faith in the international banking industry.</p>
<h1 id="_idParaDest-158"><a id="_idTextAnchor160"/>Checking test coverage</h1>
<p>Unit tests are most effective when there are tests to cover every class, method, function, or module in your <a id="_idIndexMarker562"/>program. As your software code grows, it is easy to forget to write tests or maybe to put them off until you have more time. PyCharm has a tool that can tell you what your test coverage is and helps you find unexploited opportunities for testing more of your work than you might have on your own.</p>
<p>To check your test coverage, you just need to run your tests a little bit differently. We’ve been running our tests individually from within the test files. We need to run all the tests together so that we can<a id="_idIndexMarker563"/> have a comprehensive report of where we are missing coverage. For this, we will make a new run configuration. Click the run configurations dropdown on the toolbar and click <code>unittest</code> template. Make sure you use my settings, as shown in <em class="italic">Figure 6</em><em class="italic">.22</em>:</p>
<div><div><img alt="Figure 6.22: Create a run configuration that runs all your tests at once" src="img/B19644_Figure_6.22.jpg"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 6.22: Create a run configuration that runs all your tests at once</p>
<p>For the script path, enter the folder where your tests are located. Set the pattern to <code>*_test.py</code>. This will make the test runner find all files that end with <code>_test.py</code>, which is different from the defaults. The defaults will look for files beginning with “test.” I don’t particularly like this because it bunches all the tests together in the project file window instead of putting the test right next to the file it is testing.</p>
<p>By setting the pattern and setting the test runner to a folder rather than a single file, the runner will find all files matching the pattern and run them as tests. Speaking of running, you can do that by clicking the ellipsis next to the run and debug buttons. See <em class="italic">Figure 6</em><em class="italic">.23</em> to locate the <strong class="bold">Run ‘All Tests’</strong><strong class="bold"> with Coverage</strong> menu item:</p>
<div><div><img alt="Figure 6.23: Run ‘All Tests’ with Coverage allows you to run your tests and find out how much of your application isn’t covered by unit tests" src="img/B19644_Figure_6.23.jpg"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 6.23: Run ‘All Tests’ with Coverage allows you to run your tests and find out how much of your application isn’t covered by unit tests</p>
<p>The first time you do this, you’ll likely<a id="_idIndexMarker564"/> see an error message – not from your code, but from PyCharm. See <em class="italic">Figure 6</em><em class="italic">.24</em> to see what I mean:</p>
<div><div><img alt="Figure 6.24: The first time you run test coverage, you’ll be warned if you haven’t installed the coverage software or enabled the bundled copy" src="img/B19644_Figure_6.24.jpg"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 6.24: The first time you run test coverage, you’ll be warned if you haven’t installed the coverage software or enabled the bundled copy</p>
<p>Running with coverage requires some software, <code>coverage.py</code>, which we haven’t installed. You have two <a id="_idIndexMarker565"/>options here: you can either add <code>coverage.py</code> to your project, or you can use the bundled version that ships with PyCharm. I prefer using the bundled version. You can click the word <em class="italic">enable</em> in the error message, which is displayed as a blue hyperlink, and PyCharm will turn on this setting for you. If you’d like to manage this setting yourself, see <em class="italic">Figure 6</em><em class="italic">.25</em> to see where the setting can be found:</p>
<div><div><img alt="Figure 6.25: The setting for using the bundled coverage.py file allows you to use coverage.py without you having to add it to your project" src="img/B19644_Figure_6.25.jpg"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 6.25: The setting for using the bundled coverage.py file allows you to use coverage.py without you having to add it to your project</p>
<p>With <code>coverage.py</code> enabled, rerun <a id="_idIndexMarker566"/>your coverage test. Let’s see how we do:</p>
<div><div><img alt="Figure 6.26: I wish my grades in college were this good!" src="img/B19644_Figure_6.26.jpg"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 6.26: I wish my grades in college were this good!</p>
<p>Holy smokes! We have 100% coverage in<a id="_idIndexMarker567"/> the transaction tests, but a miserable failure in the <code>bank_account_test.py</code> file – that is, if you consider 94% coverage a failure. Being a perfectionist, I would like to see how I missed those points. I can double-click the line showing the 94% in <code>bank_account_test.py</code> and I’ll be treated to a color-coded gutter. Here, again, I must apologize for the book being printed in black and white. Area <em class="italic">1</em> in <em class="italic">Figure 6</em><em class="italic">.26</em> is colored red. These are the lines that are not covered by the tests. To be truthful, I don’t remember typing these in. I don’t need them since my test runner is executing my tests for me. I can simply remove these lines and re-format my file with <em class="italic">Ctrl</em> + <em class="italic">Alt</em> + <em class="italic">L</em>/<em class="italic">Cmd</em> + <em class="italic">Opt</em> + <em class="italic">L</em>. Rerun the test with coverage. My results in <em class="italic">Figure 6</em><em class="italic">.27</em> show that we’re close:</p>
<div><div><img alt="Figure 6.27: We have achieved 100% coverage! Keep this up and you might get a raise" src="img/B19644_Figure_6.27.jpg"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 6.27: We have achieved 100% coverage! Keep this up and you might get a raise</p>
<p>The <code>bank_account_test.py</code> file now has 100% coverage, but at the top, I can still see that the <code>bank_account</code> folder only has 98% coverage. This simply will not stand! Right now, I have my project explorer<a id="_idIndexMarker568"/> window closed to maximize space for the editor and coverage window. If I open it back up, having run with coverage, I will get some more information. <em class="italic">Figure 6</em><em class="italic">.28</em> shows where we should look. The <code>bank_account.py</code> file only has 92% coverage. Upon double-clicking to open it, I’ll see the lines I’m missing colored red, as seen in <em class="italic">Figure 6</em><em class="italic">.28</em>:</p>
<div><div><img alt="Figure 6.28: The grayish-red area in the gutter indicates that lines 17 and 18 are not covered by any unit test" src="img/B19644_Figure_6.28.jpg"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 6.28: The grayish-red area in the gutter indicates that lines 17 and 18 are not covered by any unit test</p>
<p>It looks like we have another unit test to write. I forgot to write a test for the error condition. This is legitimate! As <a id="_idIndexMarker569"/>you may recall, I left the deposit test as a challenge for you. I wrote it in my code for this book, but I forgot to write the error test. Coverage saves the day!</p>
<p>Open <code>bank_account_test.py</code> and add the following test, which will cover the case of trying to deposit a negative number:</p>
<pre class="source-code">
def test_deposit_negative_number_fail(self):
 test_account = BankAccount("Bruce Van Horn", "123355-23434", 4000)
 self.assertRaises(ValueError, test_account.deposit, -2000)</pre> <p>Run the test and verify it passes, then rerun the <strong class="bold">All Tests</strong> configuration with coverage. My result is shown in <em class="italic">Figure 6</em><em class="italic">.29</em>:</p>
<div><div><img alt="Figure 6.29: We have achieved 100% coverage for all files" src="img/B19644_Figure_6.29.jpg"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 6.29: We have achieved 100% coverage for all files</p>
<p>This time, we should have a perfect score! Now that we’re feeling fine, I’ll point out the coverage window on the right-hand <a id="_idIndexMarker570"/>side of the screen. It shows a list of the results, which we’ve already seen. Note the shield icon in the right toolbar. You can show or hide the coverage window by clicking this shield.</p>
<h2 id="_idParaDest-159"><a id="_idTextAnchor161"/>Test coverage output</h2>
<p>In addition to the<a id="_idIndexMarker571"/> graphical display, PyCharm outputs a report for the coverage run. You will see the output mentioned in the output window alongside the usual test output. Mine states the following:</p>
<pre class="source-code">
Wrote XML report to /home/brucevanhorn/.cache/JetBrains/PyCharm2023.1/coverage/bank_account&amp;All_Test.xml</pre> <p>The XML file is generated by <code>coverage.py</code>, which we enabled earlier. As you might have guessed, <code>coverage.py</code> is a popular Python tool for measuring code coverage during test runs. It is an open source tool that helps you identify which parts of your Python code are being exercised by your tests and which parts are not. The tool works by collecting information about which lines of code are executed during a test run and then generating a report that shows the percentage of code coverage. The XML output is used by PyCharm to render the color-coded UI displays we’ve been using. The XML output can also be<a id="_idIndexMarker572"/> used by your <code>coverage.py</code> to fail a build if test coverage is below a set threshold.</p>
<h1 id="_idParaDest-160"><a id="_idTextAnchor162"/>Profiling performance</h1>
<p>The first step in creating <a id="_idIndexMarker574"/>a great program is getting the program fully working. The second step is to perform automated testing to prove that the program works as intended. The final step ought to be tweaking the code so that the program runs as fast and as efficiently as possible. Poorly performing programs run the risk of having a low adoption rate at best, and may simply be unusable at worst. In England, the NHS has an algorithm that was designed to match organ transplant recipients to recently harvested organs. The algorithm is complicated but extremely time-sensitive. Harvested organs must be transplanted quickly; otherwise, their tissues will die and become useless. In short, the algorithm must be extremely accurate; otherwise, the transplanted organ may be rejected, resulting in the patient’s death. It must also be fast since the organ will lose viability, which may also result in patient death. Suddenly, I’m very glad for my job dealing with hardware system capacity planning and forecasting. Nobody has ever died because my database queries were too slow. At least, not that I know of.</p>
<p>In addition to being able to run your tests with coverage, you can also run with performance profiling. While the coverage report tells you graphically which areas of your code remain untested, PyCharm’s profiler gives you reports on which parts of your code are consuming the lion’s share of the overall runtime. This allows you to spot bottlenecks so that you can focus your refactoring efforts toward making the code, and its execution, more efficient.</p>
<p>Similar to there being several testing libraries that are widely used by Python developers, there is also a variety of profiling tools, including Yappi, cProfile, and VMProf. PyCharm supports them all, but they do not work the same. cProfile is built into Python, and so is the default profiler. Yappi is an improvement over cProfile because it allows you to profile multithreaded applications and supports CPU time profiling. VMProf supports statistical sampling. When you profile using this tool, it won’t simply time a single run of your program; instead, it will run and sample multiple runs, providing you with a more realistic performance profile. PyCharm will use VMProf if it is available. If not, it will look for Yappi. If it can’t find Yappi, then it will use the cProfile solution built into Python. For this book, I will stick to the default cProfile tool.</p>
<h2 id="_idParaDest-161"><a id="_idTextAnchor163"/>Profiling in PyCharm</h2>
<p>The code we’ll be profiling can be<a id="_idIndexMarker575"/> found in this book’s repository, in the <code>chapter-06</code> folder. The <code>profiling.py</code> file contains the following code:</p>
<pre class="source-code">
def custom_sum(n=1000000):
  result = 0
  for i in range(n):
    result += i
  return result
def built_in_sum(n=1000000):
  result = sum(range(n))
  return result
if __name__ == '__main__':
  print(custom_sum())
  # print(built_in_sum())</pre> <p>This code will compare two ways of computing the sum of the integers, ranging from one to an upper limit expressed as <em class="italic">n</em>, whose default value is 1,000,000. The <code>custom_sum</code> function loops through all the elements, adding each to a running sum. The <code>built_in_sum</code> function utilizes the built-in <code>sum()</code> method of Python.</p>
<p>In the main scope, we will use commenting to swap between the two function calls to test both methods. We will be looking at our custom summing function first, so the call to <code>built_in_sum</code> is commented out for now.</p>
<p>The typical claim is that built-in functions are generally faster than any code you might write. In this example, we will <a id="_idIndexMarker576"/>be able to fact-check that claim and further qualify it with runtime statistics through our profiling process. Let’s get started.</p>
<p>As with testing and coverage, we can start a profiling run by using either the green arrows within the editor or the run button ellipsis at the top of the screen. <em class="italic">Figure 6</em><em class="italic">.30</em> shows both options:</p>
<div><div><img alt="Figure 6.30: You can run a profile using either the ellipsis menu at the top right or by clicking the green arrow next to the dunder-main entry point on line 14" src="img/B19644_Figure_6.30.jpg"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 6.30: You can run a profile using either the ellipsis menu at the top right or by clicking the green arrow next to the dunder-main entry point on line 14</p>
<p>When the profile run is complete, we will be provided with a performance report, as seen in <em class="italic">Figure 6</em><em class="italic">.31</em>:</p>
<div><div><img alt="Figure 6.31: The performance profile for the custom_sum function" src="img/B19644_Figure_6.31.jpg"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 6.31: The performance profile for the custom_sum function</p>
<p>On my computer, which in this case is a VMWare virtual machine with a very modest configuration (2 cores, 4 GB of RAM, and a 7,200 RPM spinning disk), the <code>custom_sum</code> function completed in 41 ms. The time and the percentage are a little bunched together on my display, but we<a id="_idIndexMarker577"/> can see that 100% of the time was spent in the <code>custom_sum</code> function. If this were a more complicated program with many functions being called during the run, we’d see a full listing of each function and how much time was spent on each. Pay attention to the <strong class="bold">Own Time</strong> column versus the <strong class="bold">Time</strong> column.</p>
<p>In PyCharm’s performance profiler, the <strong class="bold">Time</strong> column shows the total time spent executing a particular function or method, including the time spent executing any sub-functions or methods called within it.</p>
<p>On the other hand, the <strong class="bold">Own Time</strong> column shows the time spent executing only the code within the function or method itself, excluding any time spent executing sub-functions or methods. This means that the <strong class="bold">Own Time</strong> column can give you a better understanding of the performance of the code within a specific function or method, independent of any external factors such as the performance of other functions or methods it calls.</p>
<p>To illustrate the difference, consider a function, <em class="italic">A()</em>, that calls two other functions, <em class="italic">B()</em> and <em class="italic">C()</em>. If you look at the <strong class="bold">Time</strong> column for <em class="italic">A()</em>, it will include the time spent executing both <em class="italic">B()</em> and <em class="italic">C()</em> in addition to the time spent executing the code within <em class="italic">A()</em> itself. However, if you look at the <strong class="bold">Own Time</strong> column for <em class="italic">A()</em>, it will only show the time spent executing the code within <em class="italic">A()</em> and not the time spent executing <em class="italic">B()</em> and <em class="italic">C()</em>.</p>
<p>In general, the <strong class="bold">Time</strong> column <a id="_idIndexMarker578"/>can give you a sense of the overall performance impact of a particular function or method, while the <strong class="bold">Own Time</strong> column can help you focus on the performance of the code within that function or method.</p>
<h2 id="_idParaDest-162"><a id="_idTextAnchor164"/>Comparing performance versus the built-in sum() function</h2>
<p>Let’s see how my 72 ms runtime fares <a id="_idIndexMarker579"/>against the built-in Python <code>sum()</code> function. Alter the bottom of the <code>main.py</code> file by commenting out the <code>custom_sum</code> function and commenting in the <code>built_in_sum</code> function, like this:</p>
<pre class="source-code">
if __name__ == '__main__':
  # print(custom_sum())
  print(built_in_sum())</pre> <p>Run a profile with this configuration. You can see my result in <em class="italic">Figure 6</em><em class="italic">.32</em>:</p>
<div><div><img alt="Figure 6.32: The built-in sum function appears to run significantly faster at 11 ms" src="img/B19644_Figure_6.32.jpg"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 6.32: The built-in sum function appears to run significantly faster at 11 ms</p>
<p>Wow, there’s no contest! On <a id="_idIndexMarker580"/>my computer, leveraging the built-in <code>sum()</code> function is seven times faster! In real life, I advise running each profile a few times and taking an average since the runtimes can vary. In my case, subsequent runs of the <code>built_in_sum</code> function ranged from 11 ms to 26 ms, which is a pretty wide variance.</p>
<h2 id="_idParaDest-163"><a id="_idTextAnchor165"/>Viewing the call graph</h2>
<p>In addition to the <a id="_idIndexMarker581"/>statistics table, you can also view the profile as a call graph. This graph represents a tree-like view of your program’s run, as shown in <em class="italic">Figure 6</em><em class="italic">.33</em>:</p>
<div><div><img alt="Figure 6.33: The call graph shows a tree-like view of the program run" src="img/B19644_Figure_6.33.jpg"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 6.33: The call graph shows a tree-like view of the program run</p>
<p>The nodes in the call graph are shaded green and red. The darker the shade of red, the more time was spent on the function indicated by that node. In <em class="italic">Figure 6</em><em class="italic">.33</em>, pretty much all of the<a id="_idIndexMarker582"/> time is being spent in the <code>custom_sum</code> function, which is as dark a red as it gets (trust me). The built-in <code>print</code> method takes up a tiny but non-zero amount of time when it prints the sum in the main function.</p>
<h2 id="_idParaDest-164"><a id="_idTextAnchor166"/>Navigating using the performance profile</h2>
<p>You can navigate to a<a id="_idIndexMarker583"/> function using either the statistics table or the corresponding node in the call graph. Just right-click, as shown in <em class="italic">Figure 6</em><em class="italic">.34</em>:</p>
<div><div><img alt="Figure 6.34: You can navigate to your code by right-clicking the function and selecting Navigate to Source" src="img/B19644_Figure_6.34.jpg"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 6.34: You can navigate to your code by right-clicking the function and selecting Navigate to Source</p>
<p>You can do the<a id="_idIndexMarker584"/> same thing on the call graph. Upon right-clicking a node on the call graph, you’ll get the same navigation option to take you to the source. This can help you navigate straight to any code you might want to inspect.</p>
<h2 id="_idParaDest-165"><a id="_idTextAnchor167"/>Performance cProfile snapshots</h2>
<p>When you do a profile run with cProfile, PyCharm will save a <code>.pstat</code> files are generated in my home folder:</p>
<pre class="source-code">
Snapshot saved to /home/brucevanhorn/.cache/JetBrains/PyCharm2023.1/snapshots/profiling4.pstat</pre> <p>When I’m doing serious profiling work, I will often copy these files into a more convenient folder and alter their names to indicate the conditions under which they were run. For example, in our example, I might call the first <code>.pstat</code> file something like <code>custom_sum_performance_1.pstat</code>; the second might be called <code>built_in_sum_performance_1.pstat</code>.</p>
<p>I’m doing this so that I have a baseline performance profile for each. In real life, I suspect you will rarely have such an easy alternative to what we’ve presented here. You’ll more likely have several versions of a function using different approaches to algorithm design. In those cases, keeping your <code>.pstat</code> files so that you can compare them with future runs can be very handy, if for no other reason than to brag at your next employee review.</p>
<p>You can open your older <code>.pstat</code> files using the <strong class="bold">Tools</strong> menu, as shown in <em class="italic">Figure 6</em><em class="italic">.35</em>:</p>
<div><div><img alt="Figure 6.35: You can open your old snapshots via the Tools menu" src="img/B19644_Figure_6.35.jpg"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 6.35: You can open your old snapshots via the Tools menu</p>
<p>Opening this <code>.pstat</code> file will <a id="_idIndexMarker586"/>show the statistics table and call graph. If you’ve refactored the names of the functions, then you shouldn’t expect the navigation to still work; however, you can see the old results and compare them against a newer run.</p>
<p>Overall, PyCharm’s ability to open and compare old <code>.pstat</code> files can be a useful tool for tracking the performance of your code over time and identifying areas where performance improvements can be made.</p>
<h1 id="_idParaDest-166"><a id="_idTextAnchor168"/>Summary</h1>
<p>Testing, debugging, and profiling are high-level tasks we can use to analyze applications to look for improvements in correctness and performance, but they can be quite confusing to beginner developers. PyCharm offers straightforward and intuitive interfaces for these processes, making them more accessible and streamlined.</p>
<p>Unit testing is the process of making sure the individual components of a large system work as intended. PyCharm has convenient commands to generate test skeletons/boilerplate code that usually takes time for developers to write manually. While testing a program, it is important to consider expected faults, as well as the obvious tests for intended functionality.</p>
<p>In a debugging session, developers attempt to narrow down and identify the causes of bugs and errors that are detected during testing. With a graphical interface, combined with various options to track the values of variables throughout a program, PyCharm allows us to debug our programs dynamically with considerable freedom. The various stepping functions also provide us with a flexible way to step through the program we are trying to debug.</p>
<p>Lastly, the goal of profiling is to analyze the performance of a program and find ways to improve it. This can include looking for faster ways to compute a value or identifying a bottleneck in the program. With the ability to generate comprehensive statistics on the running time of each function that’s executed, as well as call graphs, PyCharm helps developers navigate the different components of a profiled program with ease.</p>
<p>This chapter also marks the end of the second part of this book, where we focused on improving our development productivity. From here, we will be considering the usage of PyCharm in more specialized fields, namely web development and data science projects.</p>
<p>In the next chapter, we will cover the basics of three universal web development languages – JavaScript, HTML, and CSS – within the context of PyCharm.</p>
<h1 id="_idParaDest-167"><a id="_idTextAnchor169"/>Questions</h1>
<p>Answer the following questions to test your knowledge of this chapter:</p>
<ol>
<li>What is testing in the context of software development? What are the different testing methods?</li>
<li>How does PyCharm support testing processes?</li>
<li>What is debugging in the context of software development?</li>
<li>How does PyCharm support debugging processes?</li>
<li>What is profiling in the context of software development?</li>
<li>How does PyCharm support profiling processes?</li>
<li>What is the significance of run arrows in PyCharm’s editor?</li>
</ol>
<h1 id="_idParaDest-168"><a id="_idTextAnchor170"/>Further reading</h1>
<p>To learn more about the topics that were covered in this chapter, take a look at the following resources:</p>
<ul>
<li><em class="italic">Agile Software Development, Principles, Patterns, and Practices</em>, Martin, R. C. (2003). Prentice Hall.</li>
<li><em class="italic">Clean Architecture: A Craftsman’s Guide to Software Structure and Design</em>, Martin, R. C. (2017). Prentice Hall.</li>
<li><em class="italic">Real-World Implementation of C# Design Patterns</em>, Van Horn, B and Symons, V. (2022). Packt Publishing.</li>
<li>Be sure to check out the companion website for the book at<em class="italic"> </em><a href="https://www.pycharm-book.com">https://www.pycharm-book.com</a><em class="italic">.</em></li>
</ul>
</div>


<div><h1 id="_idParaDest-169" lang="en-US" xml:lang="en-US"><a id="_idTextAnchor171"/>Part 3: Web Development in PyCharm</h1>
<p>This part of the book focuses on web development processes in Python programming and what support PyCharm has in store for web projects. Readers will be able to use PyCharm and its features to efficiently develop their web applications.</p>
<p>This part has the following chapters:</p>
<ul>
<li><a href="B19644_07.xhtml#_idTextAnchor172"><em class="italic">Chapter 7</em></a>, <em class="italic">Web Development with JavaScript, HTML, and CSS</em></li>
<li><a href="B19644_08.xhtml#_idTextAnchor203"><em class="italic">Chapter 8</em></a>, <em class="italic">Building a Dynamic Web Application with Flask</em></li>
<li><a href="B19644_09.xhtml#_idTextAnchor223"><em class="italic">Chapter 9</em></a>, <em class="italic">Creating a RESTful API with FastAPI</em></li>
<li><a href="B19644_10.xhtml#_idTextAnchor243"><em class="italic">Chapter 10</em></a>, <em class="italic">More full stack frameworks: Django and Pyramid</em></li>
<li><em class="italic">Chapter 11</em>, <em class="italic">Understanding Database Management in PyCharm</em></li>
</ul>
</div>
<div><div></div>
</div>
<div><div></div>
</div>
</body></html>