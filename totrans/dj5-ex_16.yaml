- en: '16'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '16'
- en: Building a Chat Server
  id: totrans-1
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 构建聊天服务器
- en: In the previous chapter, you created a RESTful API for your project that provides
    a programmable interface for your application.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 在上一章中，您为项目创建了一个 RESTful API，为您的应用程序提供了一个可编程的接口。
- en: In this chapter, you will develop a chat server for students using Django Channels,
    enabling students to engage in real-time messaging within course chat rooms. You
    will learn how to build real-time applications through asynchronous programming
    with Django Channels. By serving your Django project through **Asynchronous Server
    Gateway Interface** (**ASGI**), and implementing asynchronous communication, you
    will enhance the responsiveness and scalability of your server. Additionally,
    you will persist chat messages into the database, building a comprehensive chat
    history and enriching the user experience and functionality of the chat application.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，您将使用 Django Channels 开发一个面向学生的聊天服务器，使学生能够在课程聊天室中进行实时消息交流。您将学习如何通过 Django
    Channels 的异步编程构建实时应用程序。通过通过 **异步服务器网关接口** (**ASGI**) 提供您的 Django 项目，并实现异步通信，您将提高服务器的响应性和可扩展性。此外，您将把聊天消息持久化到数据库中，构建一个全面的聊天历史，丰富聊天应用的用户体验和功能。
- en: 'In this chapter, you will:'
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，您将：
- en: Add Channels to your project
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 将 Channels 添加到您的项目中
- en: Build a WebSocket consumer and appropriate routing
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 构建WebSocket消费者和适当的路由
- en: Implement a WebSocket client
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 实现WebSocket客户端
- en: Enable a channel layer with Redis
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 启用带有Redis的通道层
- en: Make your consumer fully asynchronous
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使您的消费者完全异步
- en: Persist chat messages into the database
  id: totrans-10
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 将聊天消息持久化到数据库中
- en: Functional overview
  id: totrans-11
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 功能概述
- en: '*Figure 16.1* shows a representation of the views, templates, and functionalities
    that will be built in this chapter:'
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 16.1* 展示了本章将构建的视图、模板和功能：'
- en: '![](img/B21088_16_01.png)'
  id: totrans-13
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/B21088_16_01.png)'
- en: 'Figure 16.1: Diagram of functionalities built in this chapter'
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 图 16.1：本章构建的功能图
- en: In this chapter, you will implement the `course_chat_room` view in the `chat`
    application. This view will serve the template that displays the chat room for
    a given course. The latest chat messages will be displayed when a user joins a
    chat room. You will use JavaScript to establish a WebSocket connection in the
    browser, and you will build the `ChatConsumer` WebSocket consumer to handle WebSocket
    connections and to exchange messages. You will use Redis to implement the channel
    layer that allows broadcasting messages to all users in the chat room.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，您将在 `chat` 应用程序中实现 `course_chat_room` 视图。此视图将提供显示给定课程聊天室的模板。当用户加入聊天室时，将显示最新的聊天消息。您将使用
    JavaScript 在浏览器中建立 WebSocket 连接，并构建 `ChatConsumer` WebSocket 消费者来处理 WebSocket
    连接和交换消息。您将使用 Redis 实现允许向聊天室中的所有用户广播消息的通道层。
- en: The source code for this chapter can be found at [https://github.com/PacktPublishing/Django-5-by-example/tree/main/Chapter16](https://github.com/PacktPublishing/Django-5-by-example/tree/main/Chapter16).
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 本章的源代码可以在 [https://github.com/PacktPublishing/Django-5-by-example/tree/main/Chapter16](https://github.com/PacktPublishing/Django-5-by-example/tree/main/Chapter16)
    找到。
- en: All Python modules used in this chapter are included in the `requirements.txt`
    file in the source code that comes along with this chapter. You can follow the
    instructions to install each Python module below or you can install all requirements
    at once with the command `python -m pip install -r requirements.txt`.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 本章中使用的所有 Python 模块都包含在本章源代码的 `requirements.txt` 文件中。您可以根据以下说明安装每个 Python 模块，或者使用命令
    `python -m pip install -r requirements.txt` 一次性安装所有依赖。
- en: Creating a chat application
  id: totrans-18
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 创建一个聊天应用
- en: You are going to implement a chat server to provide students with a chat room
    for each course. Students enrolled in a course will be able to access the course
    chat room and exchange messages in real time. You will use Channels to build this
    functionality. Channels is a Django application that extends Django to handle
    protocols that require long-running connections, such as WebSockets, chatbots,
    or MQTT (a lightweight publish/subscribe message transport commonly used in **Internet
    of Things** (**IoT**) projects).
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 您将实现一个聊天服务器，为每个课程提供聊天室，以便学生可以访问课程聊天室并实时交换消息。您将使用 Channels 来构建此功能。Channels 是一个
    Django 应用程序，它扩展了 Django 以处理需要长时间运行连接的协议，例如 WebSockets、聊天机器人或 MQTT（一种轻量级的发布/订阅消息传输，常用于
    **物联网** (**IoT**) 项目）。
- en: Using Channels, you can easily implement real-time or asynchronous functionalities
    into your project in addition to your standard HTTP synchronous views. You will
    start by adding a new application to your project. The new application will contain
    the logic for the chat server.
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 使用Channels，您可以在项目中轻松实现实时或异步功能，除了您标准的HTTP同步视图。您将首先向项目中添加一个新的应用程序。新的应用程序将包含聊天服务器的逻辑。
- en: You can the documentation for Django Channels at [https://channels.readthedocs.io/](https://channels.readthedocs.io/).
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以在[https://channels.readthedocs.io/](https://channels.readthedocs.io/)找到Django
    Channels的文档。
- en: 'Let’s start implementing the chat server. Run the following command from the
    project’s `educa` directory to create the new application file structure:'
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们开始实现聊天服务器。从项目的`educa`目录运行以下命令以创建新的应用程序文件结构：
- en: '[PRE0]'
  id: totrans-23
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'Edit the `settings.py` file of the `educa` project and activate the `chat`
    application in your project by editing the `INSTALLED_APPS` setting, as follows:'
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 编辑`educa`项目的`settings.py`文件，通过编辑`INSTALLED_APPS`设置来激活项目中的`chat`应用程序，如下所示：
- en: '[PRE1]'
  id: totrans-25
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: The new `chat` application is now active in your project. Next, you are going
    to build a view for course chat rooms.
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 新的`chat`应用程序现在已在您的项目中激活。接下来，您将构建一个用于课程聊天室的视图。
- en: Implementing the chat room view
  id: totrans-27
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 实现聊天室视图
- en: You will provide students with a different chat room for each course. You need
    to create a view for students to join the chat room of a given course. Only students
    who are enrolled in a course will be able to access the course chat room.
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 您将为每个课程提供不同的聊天室。您需要创建一个视图，让学生能够加入指定课程的聊天室。只有注册了课程的学生的才能访问课程聊天室。
- en: 'Edit the `views.py` file of the new `chat` application and add the following
    code to it:'
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 编辑新`chat`应用程序的`views.py`文件，并向其中添加以下代码：
- en: '[PRE2]'
  id: totrans-30
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'This is the `course_chat_room` view. In this view, you use the `@login_required`
    decorator to prevent any non-authenticated user from accessing the view. The view
    works as follows:'
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 这是`course_chat_room`视图。在这个视图中，您使用`@login_required`装饰器来阻止任何未经认证的用户访问视图。视图的工作方式如下：
- en: The view receives a required `course_id` parameter that is used to retrieve
    the course with the given `id`.
  id: totrans-32
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 视图接收一个必需的`course_id`参数，用于检索具有给定`id`的课程。
- en: The courses that the user is enrolled in are retrieved through the `courses_joined`
    relationship and the course with the given `id` is obtained from that subset of
    courses. If the course with the given `id` does not exist or the user is not enrolled
    in it, an `HttpResponseForbidden` response is returned, which translates to an
    HTTP response with status `403`.
  id: totrans-33
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 用户注册的课程通过`courses_joined`关系检索，并从这些课程子集中获取具有给定`id`的课程。如果具有给定`id`的课程不存在或用户未注册，则返回`HttpResponseForbidden`响应，这相当于HTTP状态`403`的响应。
- en: If the course with the given `id` exists and the user is enrolled in it, the
    `chat/room.html` template is rendered, passing the `course` object to the template
    context.
  id: totrans-34
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果具有给定`id`的课程存在且用户已注册，则渲染`chat/room.html`模板，并将`course`对象传递到模板上下文中。
- en: 'You need to add a URL pattern for this view. Create a new file inside the `chat`
    application directory and name it `urls.py`. Add the following code to it:'
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 您需要为这个视图添加一个URL模式。在`chat`应用程序目录内创建一个新文件，命名为`urls.py`。向其中添加以下代码：
- en: '[PRE3]'
  id: totrans-36
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: This is the initial URL patterns file for the `chat` application. You define
    the `course_chat_room` URL pattern, including the `course_id` parameter with the
    `int` prefix, as you only expect an integer value here.
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 这是`chat`应用程序的初始URL模式文件。您定义了`course_chat_room` URL模式，包括带有`int`前缀的`course_id`参数，因为您只期望这里是一个整数值。
- en: 'Include the new URL patterns of the `chat` application in the main URL patterns
    of the project. Edit the main `urls.py` file of the `educa` project and add the
    following line to it:'
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 在项目的主体URL模式中包含`chat`应用程序的新URL模式。编辑`educa`项目的主体`urls.py`文件，并向其中添加以下行：
- en: '[PRE4]'
  id: totrans-39
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: URL patterns for the `chat` application are added to the project under the `chat/`
    path.
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: '`chat`应用程序的URL模式已添加到项目的`chat/`路径下。'
- en: You need to create a template for the `course_chat_room` view. This template
    will contain an area to visualize the messages that are exchanged in the chat,
    and a text input with a submit button to send text messages to the chat.
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 您需要为`course_chat_room`视图创建一个模板。此模板将包含一个用于可视化聊天中交换的消息的区域，以及一个带有提交按钮的文本输入框，用于向聊天发送文本消息。
- en: 'Create the following file structure within the `chat` application directory:'
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 在`chat`应用程序目录内创建以下文件结构：
- en: '[PRE5]'
  id: totrans-43
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'Edit the `chat/room.html` template and add the following code to it:'
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 编辑 `chat/room.html` 模板，并向其中添加以下代码：
- en: '[PRE6]'
  id: totrans-45
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'This is the template for the course chat room. In this template, you perform
    the following actions:'
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 这是课程聊天室的模板。在这个模板中，你执行以下操作：
- en: You extend the `base.html` template of your project and fill its `content` block.
  id: totrans-47
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 你扩展了项目的 `base.html` 模板，并填充其 `content` 块。
- en: You define a `<div>` HTML element with the `chat` ID that you will use to display
    the chat messages sent by the user and by other students.
  id: totrans-48
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 你定义了一个带有 `chat` ID 的 `<div>` HTML 元素，你将使用它来显示用户和其他学生发送的聊天消息。
- en: You also define a second `<div>` element with a `text` input and a submit button
    that will allow the user to send messages.
  id: totrans-49
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 你还定义了一个带有 `text` 输入和提交按钮的第二个 `<div>` 元素，这将允许用户发送消息。
- en: You add the `include_js` and `domready` blocks defined in the `base.html` template,
    which you are going to implement later, to establish a connection with a WebSocket
    and send or receive messages.
  id: totrans-50
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 你添加了 `base.html` 模板中定义的 `include_js` 和 `domready` 块，你将在稍后实现它们，以建立与 WebSocket
    的连接并发送或接收消息。
- en: Run the development server and open `http://127.0.0.1:8000/chat/room/1/` in
    your browser, replacing `1` with the `id` of an existing course in the database.
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 运行开发服务器，并在你的浏览器中打开 `http://127.0.0.1:8000/chat/room/1/`，将 `1` 替换为数据库中现有课程的 `id`。
- en: 'Access the chat room with a logged-in user who is enrolled in the course. You
    will see the following screen:'
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 使用注册了课程的登录用户访问聊天室。你将看到以下屏幕：
- en: '![](img/B21088_16_02.png)'
  id: totrans-53
  prefs: []
  type: TYPE_IMG
  zh: '![图片 B21088_16_02.png](img/B21088_16_02.png)'
- en: 'Figure 16.2: The course chat room page'
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 图 16.2：课程聊天室页面
- en: This is the course chat room screen that students will use to discuss topics
    within a course.
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 这是学生将在其中讨论课程主题的课程聊天室屏幕。
- en: You have created the base view for the course chat room. Now you need to handle
    messages between students. The next section will introduce asynchronous support
    with Channels for real-time communication.
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 你已经创建了课程聊天室的基视图。现在你需要处理学生之间的消息。下一节将介绍使用 Channels 的异步支持来实现实时通信。
- en: Real-time Django with Channels
  id: totrans-57
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 实时 Django 与 Channels
- en: You are building a chat server to provide students with a chat room for each
    course. Students enrolled in a course will be able to access the course chat room
    and exchange messages. This functionality requires real-time communication between
    the server and the client.
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 你正在构建一个聊天服务器，为每个课程提供学生聊天室。注册了课程的学生的将能够访问课程聊天室并交换消息。此功能需要服务器和客户端之间的实时通信。
- en: A standard HTTP request/response model doesn’t work here because you need the
    browser to receive notifications as soon as new messages arrive. There are several
    ways you could implement this feature, using AJAX polling or long polling in combination
    with storing the messages in your database or Redis. However, there is no efficient
    way to implement real-time communication using a standard synchronous web application.
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 标准的 HTTP 请求/响应模型在这里不适用，因为你需要浏览器在新消息到达时立即接收通知。你可以通过使用 AJAX 轮询或长轮询结合将消息存储在你的数据库或
    Redis 中来实现此功能。然而，使用标准的同步 Web 应用程序实现实时通信没有高效的方法。
- en: You need asynchronous communication, which allows real-time interactions, where
    the server can push updates to the client as soon as new messages arrive without
    the client needing to request updates periodically. Asynchronous communication
    also comes with other advantages, such as reduced latency, improved performance
    under load, and a better overall user experience. You are going to build a chat
    server using asynchronous communication through ASGI.
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 你需要异步通信，这允许实时交互，其中服务器可以在新消息到达时立即将更新推送到客户端，而无需客户端定期请求更新。异步通信还带来其他优势，例如降低延迟、提高负载下的性能，以及更好的整体用户体验。你将使用
    ASGI 通过异步通信构建聊天服务器。
- en: Asynchronous applications using ASGI
  id: totrans-61
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用 ASGI 的异步应用程序
- en: Django is usually deployed using **Web Server Gateway Interface** (**WSGI**),
    which is the standard interface for Python applications to handle HTTP requests.
    However, to work with asynchronous applications, you need to use another interface
    called ASGI, which can handle WebSocket requests as well. ASGI is the emerging
    Python standard for asynchronous web servers and applications. By using ASGI,
    we will enable Django to handle each message independently and in real time, creating
    a smooth and live chat experience for students.
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: Django通常使用**Web服务器网关接口**（**WSGI**）进行部署，这是Python应用程序处理HTTP请求的标准接口。然而，为了与异步应用程序一起工作，你需要使用另一个名为ASGI的接口，它可以处理WebSocket请求。ASGI是异步Web服务器和应用程序的Python标准。通过使用ASGI，我们将使Django能够独立并实时地处理每条消息，为学生创造一个流畅和实时的聊天体验。
- en: You can find an introduction to ASGI at [https://asgi.readthedocs.io/en/latest/introduction.html](https://asgi.readthedocs.io/en/latest/introduction.html).
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以在[https://asgi.readthedocs.io/en/latest/introduction.html](https://asgi.readthedocs.io/en/latest/introduction.html)找到ASGI的介绍。
- en: Django comes with support for running asynchronous Python through ASGI. Writing
    asynchronous views has been supported since Django 3.1, and Django 4.1 introduced
    asynchronous handlers for class-based views. Django 5.0 adds handling for disconnect
    events in asynchronous views before the response is generated. It also adds asynchronous
    functions to the authentication framework, provides support for asynchronous signal
    dispatching, and adds async support to multiple built-in decorators.
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: Django自带通过ASGI运行异步Python的支持。自Django 3.1以来，就支持编写异步视图，而Django 4.1引入了基于类的视图的异步处理程序。Django
    5.0在生成响应之前添加了对异步视图中的断开事件的处理。它还向认证框架添加了异步函数，提供了异步信号分发的支持，并将异步支持添加到多个内置装饰器中。
- en: Channels builds upon the native ASGI support available in Django and provides
    additional functionalities to handle protocols that require long-running connections,
    such as WebSockets, IoT protocols, and chat protocols.
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: Channels建立在Django中可用的原生ASGI支持之上，并为处理需要长时间运行连接的协议（如WebSockets、IoT协议和聊天协议）提供了额外的功能。
- en: WebSockets provide full-duplex communication by establishing a persistent, open,
    bidirectional **Transmission Control Protocol** (**TCP**) connection between servers
    and clients. Instead of sending HTTP requests to the server, you establish a connection
    with the server; once the channel is open, messages can be exchanged in both directions
    without needing to establish a new connection each time. You are going to use
    WebSockets to implement your chat server.
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: WebSockets通过在服务器和客户端之间建立一个持久、开放、双向的**传输控制协议**（**TCP**）连接来提供全双工通信。你不需要向服务器发送HTTP请求，而是与服务器建立连接；一旦通道打开，就可以在两个方向上交换消息，而不需要每次都建立新的连接。你将使用WebSockets来实现你的聊天服务器。
- en: You can read more about WebSockets at [https://en.wikipedia.org/wiki/WebSocket](https://en.wikipedia.org/wiki/WebSocket).
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以在[https://en.wikipedia.org/wiki/WebSocket](https://en.wikipedia.org/wiki/WebSocket)上了解更多关于WebSockets的信息。
- en: You can find more information about deploying Django with ASGI at [https://docs.djangoproject.com/en/5.0/howto/deployment/asgi/](https://docs.djangoproject.com/en/5.0/howto/deployment/asgi/).
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以在[https://docs.djangoproject.com/en/5.0/howto/deployment/asgi/](https://docs.djangoproject.com/en/5.0/howto/deployment/asgi/)找到有关使用ASGI部署Django的更多信息。
- en: You can find more information about Django’s support for writing asynchronous
    views at [https://docs.djangoproject.com/en/5.0/topics/async/](https://docs.djangoproject.com/en/5.0/topics/async/)
    and Django’s support for asynchronous class-based views at [https://docs.djangoproject.com/en/5.0/topics/class-based-views/#async-class-based-views](https://docs.djangoproject.com/en/5.0/topics/class-based-views/#async-class-based-views).
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以在[https://docs.djangoproject.com/en/5.0/topics/async/](https://docs.djangoproject.com/en/5.0/topics/async/)找到有关Django支持编写异步视图的更多信息，以及Django对异步类视图的支持[https://docs.djangoproject.com/en/5.0/topics/class-based-views/#async-class-based-views](https://docs.djangoproject.com/en/5.0/topics/class-based-views/#async-class-based-views)。
- en: Next, we are going to learn how the Django request/response cycle is altered
    by using Channels.
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们将学习如何使用Channels改变Django的请求/响应周期。
- en: The request/response cycle using Channels
  id: totrans-71
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用Channels的请求/响应周期
- en: 'It’s important to understand the differences in a request cycle between a standard
    synchronous request cycle and a Channels implementation. The following schema
    shows the request cycle of a synchronous Django setup:'
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 理解标准同步请求周期与Channels实现之间的差异非常重要。以下图示展示了同步Django设置的请求周期：
- en: '![](img/B21088_16_03.png)'
  id: totrans-73
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/B21088_16_03.png)'
- en: 'Figure 16.3: The Django request/response cycle'
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 图 16.3：Django 请求/响应周期
- en: When an HTTP request is sent by the browser to the web server, Django handles
    the request and passes the `HttpRequest` object to the corresponding view. The
    view processes the request and returns an `HttpResponse` object that is sent back
    to the browser as an HTTP response. There is no mechanism to maintain an open
    connection or send data to the browser without an associated HTTP request.
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 当浏览器向 Web 服务器发送 HTTP 请求时，Django 处理请求并将 `HttpRequest` 对象传递给相应的视图。视图处理请求并返回一个
    `HttpResponse` 对象，该对象作为 HTTP 响应发送回浏览器。没有机制在不需要相关 HTTP 请求的情况下保持打开的连接或向浏览器发送数据。
- en: 'The following schema shows the request cycle of a Django project using Channels
    with WebSockets:'
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 以下架构显示了使用 WebSocket 的 Django 项目使用 Channels 的请求周期：
- en: '![](img/B21088_16_04.png)'
  id: totrans-77
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/B21088_16_04.png)'
- en: 'Figure 16.4: The Django Channels request/response cycle'
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 图 16.4：Django Channels 请求/响应周期
- en: Channels replaces Django’s request/response cycle with messages that are sent
    across channels. HTTP requests are still routed to view functions using Django,
    but they get routed over channels. This allows WebSocket message handling as well,
    where you have producers and consumers that exchange messages across a channel
    layer. Channels preserves Django’s synchronous architecture, allowing you to choose
    between writing synchronous code and asynchronous code, or a combination of both.
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: Channels 用跨通道发送的消息替换了 Django 的请求/响应周期。HTTP 请求仍然通过 Django 路由到视图函数，但它们通过通道进行路由。这允许处理
    WebSocket 消息，其中您有生产者和消费者在通道层之间交换消息。Channels 保留了 Django 的同步架构，允许您在编写同步代码和异步代码之间进行选择，或者两者结合。
- en: Your existing synchronous views will co-exist with the WebSocket functionality
    that we will implement with Daphne, and you will serve both HTTP and WebSocket
    requests.
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 您现有的同步视图将与我们将使用 Daphne 实现的 WebSocket 功能共存，并且您将同时处理 HTTP 和 WebSocket 请求。
- en: Next, you are going to install Channels and add it to your project.
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，您将安装 Channels 并将其添加到项目中。
- en: Installing Channels and Daphne
  id: totrans-82
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 安装 Channels 和 Daphne
- en: You are going to add Channels to your project and set up the required basic
    ASGI application routing for it to manage HTTP requests.
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 您将向项目中添加 Channels 并为其设置所需的基本 ASGI 应用程序路由，以便管理 HTTP 请求。
- en: 'Install Channels in your virtual environment with the following command:'
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 使用以下命令在您的虚拟环境中安装 Channels：
- en: '[PRE7]'
  id: totrans-85
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: This will simultaneously install Channels along with the Daphne ASGI application
    server. An ASGI server is necessary for handling asynchronous requests, and we
    choose Daphne for its simplicity and compatibility, as it comes bundled with Channels.
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 这将同时安装 Channels 和 Daphne ASGI 应用程序服务器。处理异步请求需要一个 ASGI 服务器，我们选择 Daphne，因为它简单且兼容，并且与
    Channels 一起打包。
- en: 'Edit the `settings.py` file of the `educa` project and add `daphne` to the
    beginning of the `INSTALLED_APPS` setting as follows:'
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 编辑 `educa` 项目的 `settings.py` 文件，并将 `daphne` 添加到 `INSTALLED_APPS` 设置的开头，如下所示：
- en: '[PRE8]'
  id: totrans-88
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: When `daphne` is added to the `INSTALLED_APPS` setting, it takes control over
    the `runserver` command, replacing the standard Django development server. This
    will allow you to serve asynchronous requests during development. Besides handling
    URL routing to Django views for synchronous requests, Daphne also manages routes
    to WebSocket consumers. You can find more information about Daphne at [https://github.com/django/daphne](https://github.com/django/daphne).
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 当 `daphne` 被添加到 `INSTALLED_APPS` 设置中时，它将接管 `runserver` 命令，替换标准的 Django 开发服务器。这将允许您在开发期间处理异步请求。除了处理同步请求的
    URL 路由到 Django 视图外，Daphne 还管理 WebSocket 消费者的路由。您可以在 [https://github.com/django/daphne](https://github.com/django/daphne)
    找到有关 Daphne 的更多信息。
- en: Channels expects you to define a single root application that will be executed
    for all requests. You can define the root application by adding the `ASGI_APPLICATION`
    setting to your project. This is similar to the `ROOT_URLCONF` setting that points
    to the base URL patterns of your project. You can place the root application anywhere
    in your project, but it is recommended to put it in a project-level file. You
    can add your root routing configuration to the `asgi.py` file directly, where
    the ASGI application will be defined.
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: Channels 预期您定义一个单一的根应用程序，该应用程序将执行所有请求。您可以通过将 `ASGI_APPLICATION` 设置添加到项目中来定义根应用程序。这与指向项目基本
    URL 模式的 `ROOT_URLCONF` 设置类似。您可以在项目的任何位置放置根应用程序，但建议将其放在项目级别的文件中。您可以直接将根路由配置添加到
    `asgi.py` 文件中，其中将定义 ASGI 应用程序。
- en: 'Edit the `asgi.py` file in the `educa` project directory and add the following
    code highlighted in bold:'
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 在`educa`项目目录中编辑`asgi.py`文件，并添加以下粗体显示的代码：
- en: '[PRE9]'
  id: totrans-92
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: In the previous code, you define the main ASGI application that will be executed
    when serving the Django project through ASGI. You use the `ProtocolTypeRouter`
    class provided by Channels as the main entry point of your routing system. `ProtocolTypeRouter`
    takes a dictionary that maps communication types like `http` or `websocket` to
    ASGI applications. You instantiate this class with the default application for
    the HTTP protocol. Later, you will add a protocol for the WebSocket.
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的代码中，你定义了当通过ASGI服务Django项目时将被执行的主要ASGI应用程序。你使用Channels提供的`ProtocolTypeRouter`类作为路由系统的主入口点。`ProtocolTypeRouter`接受一个映射通信类型（如`http`或`websocket`）到ASGI应用程序的字典。你使用HTTP协议的默认应用程序实例化这个类。稍后，你将添加WebSocket的协议。
- en: 'Add the following line to the `settings.py` file of your project:'
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 将以下行添加到你的项目`settings.py`文件中：
- en: '[PRE10]'
  id: totrans-95
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: The `ASGI_APPLICATION` setting is used by Channels to locate the root routing
    configuration.
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: '`ASGI_APPLICATION`设置被Channels用于定位根路由配置。'
- en: 'Start the development server using the following command:'
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 使用以下命令启动开发服务器：
- en: '[PRE11]'
  id: totrans-98
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'You will see output similar to the following:'
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 你将看到类似以下输出的内容：
- en: '[PRE12]'
  id: totrans-100
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: Check that the output contains the line `Starting ASGI/Daphne version 4.1.0
    development server`. This line confirms that you are using the Daphne development
    server, which is capable of managing synchronous and asynchronous requests, instead
    of the standard Django development server. HTTP requests continue to behave the
    same as before, but they get routed over Channels.
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 检查输出是否包含以下行`Starting ASGI/Daphne version 4.1.0 development server`。这一行确认你正在使用Daphne开发服务器，它能够管理同步和异步请求，而不是标准的Django开发服务器。HTTP请求的行为与之前相同，但它们将通过通道路由。
- en: 'Now that Channels is installed in your project, you can build the chat server
    for courses. To implement the chat server for your project, you will need to take
    the following steps:'
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 现在Channels已安装到你的项目中，你可以构建课程的聊天服务器。为了实现你项目的聊天服务器，你需要采取以下步骤：
- en: '**Set up a consumer**: Consumers are individual pieces of code that can handle
    WebSockets in a very similar way to traditional HTTP views. You will build a consumer
    to read and write messages to a communication channel.'
  id: totrans-103
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**设置消费者**：消费者是能够以与传统HTTP视图非常相似的方式处理WebSocket的独立代码块。你将构建一个消费者来读取和写入通信通道的消息。'
- en: '**Configure routing**: Channels provides routing classes that allow you to
    combine and stack your consumers. You will configure URL routing for your chat
    consumer.'
  id: totrans-104
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**配置路由**：Channels提供了路由类，允许你组合和堆叠你的消费者。你将为你的聊天消费者配置URL路由。'
- en: '**Implement a WebSocket client**: When the student accesses the chat room,
    you will connect to the WebSocket from the browser and send or receive messages
    using JavaScript.'
  id: totrans-105
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**实现WebSocket客户端**：当学生访问聊天室时，你将从浏览器连接到WebSocket，并使用JavaScript发送或接收消息。'
- en: '**Enable a channel layer**: Channel layers allow you to talk between different
    instances of an application. They’re a useful part of making a distributed real-time
    application. You will set up a channel layer using Redis.'
  id: totrans-106
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**启用通道层**：通道层允许你在应用程序的不同实例之间进行通信。它们是构建分布式实时应用程序的有用部分。你将使用Redis设置一个通道层。'
- en: Let’s start by writing your own consumer to handle connecting to a WebSocket,
    receiving and sending messages, and disconnecting.
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们从编写自己的消费者开始，以处理连接到WebSocket、接收和发送消息以及断开连接。
- en: Writing a consumer
  id: totrans-108
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 编写消费者
- en: Consumers are the equivalent of Django views for asynchronous applications.
    As mentioned, they handle WebSockets in a very similar way to how traditional
    views handle HTTP requests. Consumers are ASGI applications that can handle messages,
    notifications, and other things. Unlike Django views, consumers are built for
    long-running communication. URLs are mapped to consumers through routing classes
    that allow you to combine and stack consumers.
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 消费者是对异步应用程序中Django视图的等效。如前所述，它们以与传统视图处理HTTP请求非常相似的方式处理WebSocket。消费者是能够处理消息、通知和其他内容的ASGI应用程序。与Django视图不同，消费者是为长时间运行的通信而构建的。通过允许你组合和堆叠消费者的路由类，URL被映射到消费者。
- en: Let’s implement a basic consumer that can accept WebSocket connections and echoes
    every message it receives from the WebSocket back to it. This initial functionality
    will allow the student to send messages to the consumer and receive back the messages
    it sends.
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们实现一个基本的消费者，它可以接受WebSocket连接，并将从WebSocket接收到的每条消息回显给它。此初始功能将允许学生向消费者发送消息，并接收回发送的消息。
- en: 'Create a new file inside the `chat` application directory and name it `consumers.py`.
    Add the following code to it:'
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 在`chat`应用程序目录内创建一个新文件，并将其命名为`consumers.py`。将以下代码添加到其中：
- en: '[PRE13]'
  id: totrans-112
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'This is the `ChatConsumer` consumer. This class inherits from the Channels
    `WebsocketConsumer` class to implement a basic WebSocket consumer. In this consumer,
    you implement the following methods:'
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 这是`ChatConsumer`消费者。此类从Channels的`WebsocketConsumer`类继承，以实现基本的WebSocket消费者。在此消费者中，您实现了以下方法：
- en: '`connnect()`: Called when a new connection is received. You accept any connection
    with `self.accept()`. You can also reject a connection by calling `self.close()`.'
  id: totrans-114
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`connect()`: 当接收到新的连接时调用。您可以使用`self.accept()`接受任何连接。您也可以通过调用`self.close()`拒绝连接。'
- en: '`disconnect()`: Called when the socket closes. You use `pass` because you don’t
    need to implement any action when a client closes the connection.'
  id: totrans-115
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`disconnect()`: 当套接字关闭时调用。您使用`pass`，因为当客户端关闭连接时，您不需要实现任何操作。'
- en: '`receive()`: Called whenever data is received from the WebSocket. You expect
    text to be received as `text_data` (this could also be `binary_data` for binary
    data). You treat the text data received as JSON. Therefore, you use `json.loads()`
    to load the received JSON data into a Python dictionary. You access the `message`
    key, which you expect to be present in the JSON structure received. To echo the
    message, you send the message back to the WebSocket with `self.send()`, transforming
    it into JSON format again through `json.dumps()`.'
  id: totrans-116
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`receive()`: 当从WebSocket接收到数据时调用。您期望接收到的数据是`text_data`（这也可以是`binary_data`，用于二进制数据）。您将接收到的文本数据视为JSON。因此，您使用`json.loads()`将接收到的JSON数据加载到Python字典中。您访问`message`键，您期望它在接收到的JSON结构中存在。为了回显消息，您使用`self.send()`将消息发送回WebSocket，并通过`json.dumps()`将其再次转换为JSON格式。'
- en: The initial version of your `ChatConsumer` consumer accepts any WebSocket connection
    and echoes to the WebSocket client every message it receives. Note that the consumer
    does not broadcast messages to other clients yet. You will build this functionality
    by implementing a channel layer later.
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 您的`ChatConsumer`消费者初始版本接受任何WebSocket连接，并将接收到的每条消息回显到WebSocket客户端。请注意，消费者尚未向其他客户端广播消息。您将通过实现通道层来构建此功能。
- en: First, let’s expose our consumer by adding it to the URLs of the project.
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，让我们通过将其添加到项目的URL中，来公开我们的消费者。
- en: Routing
  id: totrans-119
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 路由
- en: You need to define a URL to route connections to the `ChatConsumer` consumer
    you have implemented. Channels provides routing classes that allow you to combine
    and stack consumers to dispatch based on what the connection is. You can think
    of them as the URL routing system of Django for asynchronous applications.
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 您需要定义一个URL，以便将连接路由到您已实现的`ChatConsumer`消费者。Channels提供了路由类，允许您组合和堆叠消费者，根据连接的内容进行分发。您可以将它们视为Django异步应用的URL路由系统。
- en: 'Create a new file inside the `chat` application directory and name it `routing.py`.
    Add the following code to it:'
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 在`chat`应用程序目录内创建一个新文件，并将其命名为`routing.py`。将以下代码添加到其中：
- en: '[PRE14]'
  id: totrans-122
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'In this code, you map a URL pattern with the `ChatConsumer` class that you
    defined in the `chat/consumers.py` file. There are some details that are worth
    reviewing:'
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 在此代码中，您将一个URL模式映射到您在`chat/consumers.py`文件中定义的`ChatConsumer`类。有一些细节值得审查：
- en: You use Django’s `re_path()` to define the path with a regular expression instead
    of `path()`. Channels’ URL routing may not function correctly with `path()` routes
    if inner routers are wrapped by additional middleware, so this approach helps
    avoid any issues.
  id: totrans-124
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 您使用Django的`re_path()`来定义带有正则表达式的路径，而不是`path()`。如果内部路由器被额外的中间件包装，Channels的URL路由可能与`path()`路由不正确地工作，因此这种方法有助于避免任何问题。
- en: The URL includes an integer parameter called `course_id`. This parameter will
    be available in the scope of the consumer and will allow you to identify the course
    chat room that the user is connecting to.
  id: totrans-125
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: URL包含一个名为`course_id`的整数参数。此参数将在消费者的作用域内可用，并允许您识别用户连接到的课程聊天室。
- en: You call the `as_asgi()` method of the `consumer` class in order to get an ASGI
    application that will instantiate an instance of the consumer for each user connection.
    This behavior is similar to Django’s `as_view()` method for class-based views.
  id: totrans-126
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 你调用`consumer`类的`as_asgi()`方法，以获取一个ASGI应用程序，该应用程序将为每个用户连接实例化消费者实例。这种行为类似于Django的`as_view()`方法对于基于类的视图。
- en: It is a good practice to prepend WebSocket URLs with `/ws/` to differentiate
    them from URLs used for standard synchronous HTTP requests. This also simplifies
    the production setup when an HTTP server routes requests based on the path.
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 将WebSocket URL以`/ws/`开头是一种良好的实践，以区分用于标准同步HTTP请求的URL。这也简化了生产设置，当HTTP服务器根据路径路由请求时。
- en: 'Edit the global `asgi.py` file located next to the `settings.py` file so that
    it looks like this:'
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 编辑位于`settings.py`文件旁边的全局`asgi.py`文件，使其看起来像这样：
- en: '[PRE15]'
  id: totrans-129
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'In this code, you have added:'
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 在此代码中，你添加了：
- en: A new route for the `websocket` protocol. You use `URLRouter` to map `websocket`
    connections to the URL patterns defined in the `websocket_urlpatterns` list of
    the `chat.routing` module.
  id: totrans-131
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 为`websocket`协议创建一个新的路由。你使用`URLRouter`将`websocket`连接映射到`chat.routing`模块中定义的`websocket_urlpatterns`列表中的URL模式。
- en: '`AuthMiddlewareStack` as a wrapper function for the URL router. The `AuthMiddlewareStack`
    class provided by Channels supports standard Django authentication, where the
    user details are stored in the session. Later, you will access the user instance
    in the scope of the consumer to identify the user who sends a message.'
  id: totrans-132
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`AuthMiddlewareStack`作为一个URL路由器的包装函数。由Channels提供的`AuthMiddlewareStack`类支持标准的Django认证，其中用户详细信息存储在会话中。稍后，你将在消费者作用域内访问用户实例以识别发送消息的用户。'
- en: Note that the `websocket_urlpatterns` import is below the `get_asgi_application()`
    function call. This is needed to ensure the application registry is populated
    before importing code that may import ORM models.
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，`websocket_urlpatterns`的导入位于`get_asgi_application()`函数调用下方。这是为了确保在导入可能导入ORM模型的代码之前，应用程序注册已填充。
- en: Now that we have a functioning WebSocket consumer that is available through
    a URL, we can implement the WebSocket client.
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经有一个通过URL可用的功能WebSocket消费者，我们可以实现WebSocket客户端。
- en: Implementing the WebSocket client
  id: totrans-135
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 实现WebSocket客户端
- en: So far, you have created the `course_chat_room` view and its corresponding template
    for students to access the course chat room. You have implemented a WebSocket
    consumer for the chat server and tied it with URL routing. Now, you need to build
    a WebSocket client to establish a connection with the WebSocket in the course
    chat room template and be able to send/receive messages.
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，你已经创建了`course_chat_room`视图及其对应的模板，以便学生访问课程聊天室。你已经实现了聊天服务器的WebSocket消费者并将其与URL路由绑定。现在，你需要构建一个WebSocket客户端以与课程聊天室模板中的WebSocket建立连接，并能够发送/接收消息。
- en: You are going to implement the WebSocket client with JavaScript to open and
    maintain a connection in the browser, and you will interact with the **Document
    Object Model** (**DOM**) using JavaScript.
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 你将使用JavaScript实现WebSocket客户端，以在浏览器中打开并维护连接，并且你将使用JavaScript与**文档对象模型**（**DOM**）交互。
- en: 'You will perform the following tasks related to the WebSocket client:'
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 你将执行以下与WebSocket客户端相关的任务：
- en: Open a WebSocket connection with the server when the page is loaded.
  id: totrans-139
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 当页面加载时，打开与服务器的WebSocket连接。
- en: Add messages to an HTML container when data is received through the WebSocket.
  id: totrans-140
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 当通过WebSocket接收到数据时，向HTML容器添加消息。
- en: Attach a listener to the submit button to send messages through the WebSocket
    when the user clicks the **SEND** button or presses the *Enter* key.
  id: totrans-141
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将监听器附加到提交按钮上，以便在用户点击**发送**按钮或按下*Enter*键时通过WebSocket发送消息。
- en: Let’s start by opening the WebSocket connection.
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们从打开WebSocket连接开始。
- en: 'Edit the `chat/room.html` template of the `chat` application and modify the
    `include_js` and `domready` blocks, as follows:'
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 编辑`chat/room.html`模板的`chat`应用程序，并修改`include_js`和`domready`块，如下所示：
- en: '[PRE16]'
  id: totrans-144
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: In the `include_js` block, you use the `json_script` template filter to securely
    use the value of `course.id` with JavaScript. The `json_script` template filter
    provided by Django outputs a Python object as JSON, wrapped in a `<script>` tag,
    so that you can safely use it with JavaScript. The code `{{ course.id|json_script:"course-id"
    }}` is rendered as `<script id="course-id" type="application/json">6</script>`.
    This value is then retrieved in the `domready` block by parsing the content of
    the element with `id="course-id"` using `JSON.parse()`. This is the safe way to
    use Python objects in JavaScript.
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
- en: The `json_script` template filter securely encodes Python objects as JSON and
    safely embeds them in a `<script>` HTML tag, protecting against **cross-site scripting**
    (**XSS**) attacks by escaping potentially harmful characters.
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
- en: You can find more information about the `json_script` template filter at [https://docs.djangoproject.com/en/5.0/ref/templates/builtins/#json-script](https://docs.djangoproject.com/en/5.0/ref/templates/builtins/#json-script).
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
- en: In the `domready` block, you define an URL with the WebSocket protocol, which
    looks like `ws://` (or `wss://` for secure WebSockets, just like `https://`).
    You build the URL using the current location of the browser, which you obtain
    from `window.location.host`. The rest of the URL is built with the path for the
    chat room URL pattern that you defined in the `routing.py` file of the `chat`
    application.
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
- en: You write the URL instead of building it with a resolver because Channels does
    not provide a way to reverse URLs. You use the current course `ID` to generate
    the URL for the current course and store the URL in a new constant named `url`.
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
- en: You then open a WebSocket connection to the stored URL using `new` `WebSocket(url)`.
    You assign the instantiated WebSocket client object to the new constant `chatSocket`.
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
- en: You have created a WebSocket consumer, you have included routing for it, and
    you have implemented a basic WebSocket client. Let’s try the initial version of
    your chat.
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
- en: 'Start the development server using the following command:'
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  id: totrans-153
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'Open the URL `http://127.0.0.1:8000/chat/room/1/` in your browser, replacing
    `1` with the `id` of an existing course in the database. Take a look at the console
    output. Besides the HTTP `GET` requests for the page and its static files, you
    should see two lines, including `WebSocket HANDSHAKING` and `WebSocket CONNECT`,
    like the following output:'
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  id: totrans-155
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: The Daphne server listens for incoming socket connections using a standard TCP
    socket. The handshake is the bridge from HTTP to WebSockets. In the handshake,
    details of the connection are negotiated and either party can close the connection
    before completion. Remember that you are using `self.accept()` to accept any connection
    in the `connect()` method of the `ChatConsumer` class, implemented in the `consumers.py`
    file of the `chat` application. The connection is accepted, and therefore, you
    see the `WebSocket CONNECT` message in the console.
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
- en: If you use the browser developer tools to track network connections, you can
    also see information for the WebSocket connection that has been established.
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
- en: 'It should look like *Figure 16.5*:'
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
- en: '![Graphical user interface, application, table  Description automatically generated](img/B21088_16_05.png)'
  id: totrans-159
  prefs: []
  type: TYPE_IMG
- en: 'Figure 16.5: The browser developer tools showing that the WebSocket connection
    has been established'
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
- en: 'Now that you can connect to the WebSocket, it’s time to interact with it. You
    will implement the methods to handle common events, such as receiving a message
    and closing the connection. Edit the `chat/room.html` template of the `chat` application
    and modify the `domready` block, as follows:'
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  id: totrans-162
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'In this code, you define the following events for the WebSocket client:'
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
- en: '`onmessage`: Fired when data is received through the WebSocket. You parse the
    message, which you expect in JSON format, and access its `message` attribute.
    You then append a new `<div>` element with the message received to the HTML element
    with the `chat` ID. This will add new messages to the chat log, while keeping
    all previous messages that have been added to the log. You scroll the chat log
    `<div>` to the bottom to ensure that the new message gets visibility. You achieve
    this by scrolling to the total scrollable height of the chat log, which can be
    obtained by accessing its `scrollHeight` attribute.'
  id: totrans-164
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`onclose`: Fired when the connection with the WebSocket is closed. You don’t
    expect to close the connection, and therefore, you write the error `Chat socket
    closed unexpectedly` to the console log if this happens.'
  id: totrans-165
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: You have implemented the action to display the message when a new message is
    received. You need to implement the functionality to send messages to the socket
    as well.
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
- en: 'Edit the `chat/room.html` template of the `chat` application and add the following
    JavaScript code to the bottom of the `domready` block:'
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  id: totrans-168
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'In this code, you define an event listener for the `click` event of the submit
    button, which you select by its ID `chat-message-submit`. When the button is clicked,
    you perform the following actions:'
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
- en: You read the message entered by the user from the value of the text input element
    with the ID `chat-message-input`.
  id: totrans-170
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: You check whether the message has any content with `if(message)`.
  id: totrans-171
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'If the user has entered a message, you form JSON content such as `{''message'':
    ''string entered by the user''}` by using `JSON.stringify()`.'
  id: totrans-172
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: You send the JSON content through the WebSocket, calling the `send()` method
    of `chatSocket` client.
  id: totrans-173
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: You clear the contents of the text input by setting its value to an empty string
    with `input.value = ''`.
  id: totrans-174
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: You return the focus to the text input with `input.focus()` so that the user
    can write a new message straight away.
  id: totrans-175
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The user is now able to send messages using the text input and by clicking the
    submit button.
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
- en: To improve the user experience, you will give focus to the text input when the
    page loads, allowing users to begin typing immediately without needing to click
    on it first. You will also capture keyboard keypress events to identify the *Enter*
    key and fire the `click` event on the submit button. Users will be able to either
    click the button or press the *Enter* key to send a message.
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
- en: 'Edit the `chat/room.html` template of the `chat` application and add the following
    JavaScript code to the bottom of the `domready` block:'
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  id: totrans-179
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'In this code, you also define a function for the `keypress` event of the `input`
    element. For any key that the user presses, you perform the following actions:'
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
- en: You check whether its key is *Enter*.
  id: totrans-181
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'If the *Enter* key is pressed:'
  id: totrans-182
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: You prevent the default behavior for this key with `event.preventDefault()`.
  id: totrans-183
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: Then you fire the `click` event on the submit button to send the message to
    the WebSocket.
  id: totrans-184
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: Outside of the event handler, in the main JavaScript code for the `domready`
    block, you give the focus to the text input with `input.focus()`. By doing so,
    when the DOM is loaded, the focus will be set on the `input` element for the user
    to type a message.
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
- en: 'The `domready` block of the `chat/room.html` template should now look as follows:'
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  id: totrans-187
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: Open the URL `http://127.0.0.1:8000/chat/room/1/` in your browser, replacing
    `1` with the `id` of an existing course in the database. With a logged-in user
    who is enrolled in the course, write some text in the input field and click the
    **SEND** button or press the *Enter* key.
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
- en: 'You will see that your message appears in the chat log:'
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/B21088_16_06.png)'
  id: totrans-190
  prefs: []
  type: TYPE_IMG
- en: 'Figure 16.6: The chat room page, including messages sent through the WebSocket'
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
- en: Great! The message has been sent through the WebSocket and the `ChatConsumer`
    consumer has received the message and has sent it back through the WebSocket.
    The `chatSocket` client has received a message event and the `onmessage` function
    has been fired, adding the message to the chat log.
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
- en: You have implemented the functionality with a WebSocket consumer and a WebSocket
    client to establish client/server communication and can send or receive events.
    However, the chat server is not able to broadcast messages to other clients. If
    you open a second browser tab and enter a message, the message will not appear
    on the first tab. In order to build communication between consumers, you have
    to enable a channel layer.
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
- en: Enabling a channel layer
  id: totrans-194
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Channel layers allow you to communicate between different instances of an application.
    A channel layer is the transport mechanism that allows multiple consumer instances
    to communicate with each other and with other parts of Django.
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
- en: In your chat server, you plan to have multiple instances of the `ChatConsumer`
    consumer for the same course chat room. Each student who joins the chat room will
    instantiate the WebSocket client in their browser, and that will open a connection
    with an instance of the WebSocket consumer. You need a common channel layer to
    distribute messages between consumers.
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
- en: Channels and groups
  id: totrans-197
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Channel layers provide two abstractions to manage communications: channels
    and groups:'
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
- en: '**Channel**: You can think of a channel as an inbox where messages can be sent
    or as a task queue. Each channel has a name. Messages are sent to a channel by
    anyone who knows the channel name and then given to consumers listening on that
    channel.'
  id: totrans-199
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Group**: Multiple channels can be grouped into a group. Each group has a
    name. A channel can be added or removed from a group by anyone who knows the group
    name. Using the group name, you can also send a message to all channels in the
    group.'
  id: totrans-200
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: You will work with channel groups to implement the chat server. By creating
    a channel group for each course chat room, the `ChatConsumer` instances will be
    able to communicate with each other.
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
- en: Let’s add a channel layer to our project.
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
- en: Setting up a channel layer with Redis
  id: totrans-203
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Redis is the preferred option for a channel layer, though Channels has support
    for other types of channel layers. Redis works as the communication store for
    the channel layer. Remember that you already used Redis in *Chapter 7*, *Tracking
    User Actions*, *Chapter 10*, *Extending Your Shop*, and *Chapter 14*, *Rendering
    and Caching Content*.
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
- en: If you haven’t installed Redis yet, you can find installation instructions in
    *Chapter 7*, *Tracking User Actions*.
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
- en: 'To use Redis as a channel layer, you have to install the `channels-redis` package.
    Install `channels-redis` in your virtual environment with the following command:'
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  id: totrans-207
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'Edit the `settings.py` file of the `educa` project and add the following code
    to it:'
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  id: totrans-209
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: The `CHANNEL_LAYERS` setting defines the configuration for the channel layers
    available to the project. You define a default channel layer using the `RedisChannelLayer`
    backend provided by `channels-redis` and specify the host `127.0.0.1` and the
    port `6379`, on which Redis is running.
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s try the channel layer. Initialize the Redis Docker container using the
    following command:'
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  id: totrans-212
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: If you want to run the command in the background (in detached mode) you can
    use the `-d` option.
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
- en: 'Open the Django shell using the following command from the project directory:'
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  id: totrans-215
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: 'To verify that the channel layer can communicate with Redis, write the following
    code to send a message to a test channel named `test_channel` and receive it back:'
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  id: totrans-217
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: 'You should get the following output:'
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  id: totrans-219
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: In the previous code, you send a message to a test channel through the channel
    layer, and then you retrieve it from the channel layer. The channel layer is communicating
    successfully with Redis.
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
- en: Next, we will add the channel layer to our project.
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
- en: Updating the consumer to broadcast messages
  id: totrans-222
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Let’s edit the `ChatConsumer` consumer to use the channel layer we have implemented
    with Redis. You will use a channel group for each course chat room. Therefore,
    you will use the course `id` to build the group name. `ChatConsumer` instances
    will know the group name and will be able to communicate with each other.
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
- en: 'Edit the `consumers.py` file of the `chat` application, import the `async_to_sync()`
    function, and modify the `connect()` method of the `ChatConsumer` class, as follows:'
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  id: totrans-225
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: In this code, you import the `async_to_sync()` helper function to wrap calls
    to asynchronous channel layer methods. `ChatConsumer` is a synchronous `WebsocketConsumer`
    consumer, but it needs to call asynchronous methods of the channel layer.
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
- en: 'In the new `connect()` method, you perform the following tasks:'
  id: totrans-227
  prefs: []
  type: TYPE_NORMAL
- en: You retrieve the course `id` from the scope to know the course that the chat
    room is associated with. You access `self.scope['url_route']['kwargs']['course_id']`
    to retrieve the `course_id` parameter from the URL. Every consumer has a scope
    with information about its connection, arguments passed by the URL, and the authenticated
    user, if any.
  id: totrans-228
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: You build the group name with the `id` of the course that the group corresponds
    to. Remember that you will have a channel group for each course chat room. You
    store the group name in the `room_group_name` attribute of the consumer.
  id: totrans-229
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: You join the group by adding the current channel to the group. You obtain the
    channel name from the `channel_name` attribute of the consumer. You use the `group_add`
    method of the channel layer to add the channel to the group. You use the `async_to_sync()`
    wrapper to use the channel layer asynchronous method.
  id: totrans-230
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: You keep the `self.accept()` call to accept the WebSocket connection.
  id: totrans-231
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: When the `ChatConsumer` consumer receives a new WebSocket connection, it adds
    the channel to the group associated with the course in its scope. The consumer
    is now able to receive any messages sent to the group.
  id: totrans-232
  prefs: []
  type: TYPE_NORMAL
- en: 'In the same `consumers.py` file, modify the `disconnect()` method of the `ChatConsumer`
    class, as follows:'
  id: totrans-233
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  id: totrans-234
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: When the connection is closed, you call the `group_discard()` method of the
    channel layer to leave the group. You use the `async_to_sync()` wrapper to use
    the channel layer asynchronous method.
  id: totrans-235
  prefs: []
  type: TYPE_NORMAL
- en: 'In the same `consumers.py` file, modify the `receive()` method of the `ChatConsumer`
    class, as follows:'
  id: totrans-236
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  id: totrans-237
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: 'When you receive a message from the WebSocket connection, instead of sending
    the message to the associated channel, you send the message to the group. You
    do this by calling the `group_send()` method of the channel layer. You use the
    `async_to_sync()` wrapper to use the channel layer asynchronous method. You pass
    the following information in the event sent to the group:'
  id: totrans-238
  prefs: []
  type: TYPE_NORMAL
- en: '`type`: The event type. This is a special key that corresponds to the name
    of the method that should be invoked on consumers that receive the event. You
    can implement a method in the consumer named the same as the message type so that
    it gets executed every time a message with that specific type is received.'
  id: totrans-239
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`message`: The actual message you are sending.'
  id: totrans-240
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'In the same `consumers.py` file, add a new `chat_message()` method in the `ChatConsumer`
    class, as follows:'
  id: totrans-241
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  id: totrans-242
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: You name this method `chat_message()` to match the `type` key that is sent to
    the channel group when a message is received from the WebSocket. When a message
    with type `chat_message` is sent to the group, all consumers subscribed to the
    group will receive the message and will execute the `chat_message()` method. In
    the `chat_message()` method, you send the event message received to the WebSocket.
  id: totrans-243
  prefs: []
  type: TYPE_NORMAL
- en: 'The complete `consumers.py` file should now look like this:'
  id: totrans-244
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  id: totrans-245
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: You have implemented a channel layer in `ChatConsumer`, allowing consumers to
    broadcast messages and communicate with each other.
  id: totrans-246
  prefs: []
  type: TYPE_NORMAL
- en: 'Run the development server with the following command:'
  id: totrans-247
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE34]'
  id: totrans-248
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: Open the URL `http://127.0.0.1:8000/chat/room/1/` in your browser, replacing
    `1` with the `id` of an existing course in the database. Write a message and send
    it. Then, open a second browser window and access the same URL. Send a message
    from each browser window.
  id: totrans-249
  prefs: []
  type: TYPE_NORMAL
- en: 'The result should look like this:'
  id: totrans-250
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/B21088_16_07.png)'
  id: totrans-251
  prefs: []
  type: TYPE_IMG
- en: 'Figure 16.7: The chat room page with messages sent from different browser windows'
  id: totrans-252
  prefs: []
  type: TYPE_NORMAL
- en: You will see that the first message is only displayed in the first browser window.
    When you open a second browser window, messages sent in any of the browser windows
    are displayed in both of them. When you open a new browser window and access the
    chat room URL, a new WebSocket connection is established between the JavaScript
    WebSocket client in the browser and the WebSocket consumer in the server. Each
    channel gets added to the group associated with the course ID and passed through
    the URL to the consumer. Messages are sent to the group and received by all consumers.
  id: totrans-253
  prefs: []
  type: TYPE_NORMAL
- en: Next, we are going to enrich messages with additional context.
  id: totrans-254
  prefs: []
  type: TYPE_NORMAL
- en: Adding context to the messages
  id: totrans-255
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Now that messages can be exchanged between all users in a chat room, you probably
    want to display who sent which message and when it was sent. Let’s add some context
    to the messages.
  id: totrans-256
  prefs: []
  type: TYPE_NORMAL
- en: 'Edit the `consumers.py` file of the `chat` application and implement the following
    changes:'
  id: totrans-257
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE35]'
  id: totrans-258
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: You now import the `timezone` module provided by Django. In the `connect()`
    method of the consumer, you retrieve the current user from the scope with `self.scope['user']`
    and store them in a new `user` attribute of the consumer.
  id: totrans-259
  prefs: []
  type: TYPE_NORMAL
- en: When the consumer receives a message through the WebSocket, it gets the current
    time using `timezone.now()` and passes the current `user` and `datetime` in ISO
    8601 format along with the message in the event sent to the channel group.
  id: totrans-260
  prefs: []
  type: TYPE_NORMAL
- en: 'Edit the `chat/room.html` template of the `chat` application and add the following
    line highlighted in bold to the `include_js` block:'
  id: totrans-261
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE36]'
  id: totrans-262
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: Using the `json_script` template, you safely print the username of the request
    user to use it with JavaScript.
  id: totrans-263
  prefs: []
  type: TYPE_NORMAL
- en: 'In the `domready` block of the `chat/room.html` template, add the following
    lines highlighted in bold:'
  id: totrans-264
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE37]'
  id: totrans-265
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: In the new code, you safely parse the data of the element with the ID `request-user`
    and store it in the `requestUser` constant.
  id: totrans-266
  prefs: []
  type: TYPE_NORMAL
- en: 'Then, in the `domready` block, find the following lines:'
  id: totrans-267
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE38]'
  id: totrans-268
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: 'Replace those lines with the following code:'
  id: totrans-269
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE39]'
  id: totrans-270
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: 'In this code, you implement the following changes:'
  id: totrans-271
  prefs: []
  type: TYPE_NORMAL
- en: You convert the `datetime` received in the message to a JavaScript `Date` object
    and format it with a specific locale.
  id: totrans-272
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: You compare the username received in the message with two different constants
    as helpers to identify the user.
  id: totrans-273
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The constant `source` gets the value `me` if the user sending the message is
    the current user, or `other` otherwise.
  id: totrans-274
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The constant `name` gets the value `Me` if the user sending the message is the
    current user or the name of the user sending the message otherwise. You use it
    to display the name of the user sending the message.
  id: totrans-275
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: You use the `source` value as a `class` of the main `<div>` message element
    to differentiate messages sent by the current user from messages sent by others.
    Different CSS styles are applied based on the `class` attribute. These CSS styles
    are declared in the `css/base.css` static file.
  id: totrans-276
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: You use the username and the `datetime` in the message that you append to the
    chat log.
  id: totrans-277
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Open the URL `http://127.0.0.1:8000/chat/room/1/` in your browser, replacing
    `1` with the `id` of an existing course in the database. With a logged-in user
    who is enrolled in the course, write a message and send it.
  id: totrans-278
  prefs: []
  type: TYPE_NORMAL
- en: Then, open a second browser window in incognito mode to prevent the use of the
    same session. Log in with a different user, also enrolled in the same course,
    and send a message.
  id: totrans-279
  prefs: []
  type: TYPE_NORMAL
- en: 'You will be able to exchange messages using the two different users and see
    the user and time, with a clear distinction between messages sent by the user
    and messages sent by others. The conversation between two users should look similar
    to the following one:'
  id: totrans-280
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/B21088_16_08.png)'
  id: totrans-281
  prefs: []
  type: TYPE_IMG
- en: 'Figure 16.8: The chat room page with messages from two different user sessions'
  id: totrans-282
  prefs: []
  type: TYPE_NORMAL
- en: Great! You have built a functional real-time chat application using Channels.
    Next, you will learn how to improve the chat consumer by making it fully asynchronous.
  id: totrans-283
  prefs: []
  type: TYPE_NORMAL
- en: Modifying the consumer to be fully asynchronous
  id: totrans-284
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The `ChatConsumer` you have implemented inherits from the synchronous base class
    `WebsocketConsumer`. Synchronous consumers operate in a way that each request
    must be processed in sequence, one after the other. Synchronous consumers are
    convenient for accessing Django models and calling regular synchronous I/O functions.
    However, asynchronous consumers perform better because of their ability to perform
    non-blocking operations, moving to another task without waiting for the first
    operation to complete. They don’t require additional threads when handling requests,
    thus reducing wait times and increasing the ability to scale to more users and
    requests simultaneously.
  id: totrans-285
  prefs: []
  type: TYPE_NORMAL
- en: Given that you are already using the asynchronous channel layer functions, you
    can seamlessly rewrite the `ChatConsumer` class to make it asynchronous.
  id: totrans-286
  prefs: []
  type: TYPE_NORMAL
- en: 'Edit the `consumers.py` file of the `chat` application and implement the following
    changes:'
  id: totrans-287
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE40]'
  id: totrans-288
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: 'You have implemented the following changes:'
  id: totrans-289
  prefs: []
  type: TYPE_NORMAL
- en: The `ChatConsumer` consumer now inherits from the `AsyncWebsocketConsumer` class
    to implement asynchronous calls.
  id: totrans-290
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: You have changed the definition of all methods from `def` to `async def`.
  id: totrans-291
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: You use `await` to call asynchronous functions that perform I/O operations.
  id: totrans-292
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: You no longer use the `async_to_sync()` helper function when calling methods
    on the channel layer.
  id: totrans-293
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Open the URL `http://127.0.0.1:8000/chat/room/1/` with two different browser
    windows again and verify that the chat server still works. The chat server is
    now fully asynchronous!
  id: totrans-294
  prefs: []
  type: TYPE_NORMAL
- en: Next, we are going to implement a chat history by storing messages in the database.
  id: totrans-295
  prefs: []
  type: TYPE_NORMAL
- en: Persisting messages into the database
  id: totrans-296
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Let’s enhance the chat application by adding message persistence. We will develop
    functionality to store messages in the database, allowing us to present a chat
    history to users when they join a chat room. This feature is essential for real-time
    applications, where it’s necessary to display both current and previously generated
    data. For example, consider a stock trading application: upon logging in, users
    should see not only the current stock values but also the historical values from
    the time the stock market opened.'
  id: totrans-297
  prefs: []
  type: TYPE_NORMAL
- en: 'To implement the chat history functionality, we will follow these steps:'
  id: totrans-298
  prefs: []
  type: TYPE_NORMAL
- en: We will create Django model to store chat messages and add it to the administration
    site.
  id: totrans-299
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: We will modify the WebSocket consumer to persist messages.
  id: totrans-300
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: We will retrieve the chat history to display the latest messages when users
    enter a chat room.
  id: totrans-301
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Let’s start by creating the message model.
  id: totrans-302
  prefs: []
  type: TYPE_NORMAL
- en: Creating a model for chat messages
  id: totrans-303
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Edit the `models.py` file of the `chat` application and add the following lines
    highlighted in bold:'
  id: totrans-304
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE41]'
  id: totrans-305
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: 'This is the data model to persist chat messages. Let’s take a look at the fields
    of the `Message` model:'
  id: totrans-306
  prefs: []
  type: TYPE_NORMAL
- en: '`user`: The `User` object that wrote the message. This is a foreign key field
    because it specifies a many-to-one relationship: a user can send multiple messages,
    but each message is sent by a single user. By using `PROTECT` for the `on_delete`
    parameter, a `User` object cannot be deleted if related messages exist.'
  id: totrans-307
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`course`: A relationship with the `Course` object. Each message belongs to
    the chat room of a course. By using `PROTECT` for the `on_delete` parameter, a
    `Course` object cannot be deleted if related messages exist.'
  id: totrans-308
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`content`: A `TextField` to store the content of the message.'
  id: totrans-309
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`sent_on`: A `DateTimeField` to store the date and time when the message object
    is saved the first time.'
  id: totrans-310
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Run the following command in the shell prompt to generate the database migrations
    for the `chat` application:'
  id: totrans-311
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE42]'
  id: totrans-312
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: 'You should get the following output:'
  id: totrans-313
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE43]'
  id: totrans-314
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: 'Apply the newly created migration to your database with the following command:'
  id: totrans-315
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE44]'
  id: totrans-316
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: 'You will get an output that ends with the following line:'
  id: totrans-317
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE45]'
  id: totrans-318
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: The database is now in sync with the new model. Let’s add the `Message` model
    to the administration site.
  id: totrans-319
  prefs: []
  type: TYPE_NORMAL
- en: Adding the message model to the administration site
  id: totrans-320
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Edit the `admin.py` file of the `chat` application and register the `Message`
    model into the administration site, as follows. The new code is highlighted in
    bold:'
  id: totrans-321
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE46]'
  id: totrans-322
  prefs: []
  type: TYPE_PRE
  zh: '[PRE46]'
- en: 'Run the development server and open `http://127.0.0.1:8000/admin/` in your
    browser. You should see the **CHAT** block and the **Messages** section on the
    administration site:'
  id: totrans-323
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/B21088_16_09.png)'
  id: totrans-324
  prefs: []
  type: TYPE_IMG
- en: 'Figure 16.9: The Chat application and Messages section on the administration
    site'
  id: totrans-325
  prefs: []
  type: TYPE_NORMAL
- en: We will continue by saving messages to the database when they are sent by users.
  id: totrans-326
  prefs: []
  type: TYPE_NORMAL
- en: Storing messages in the database
  id: totrans-327
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'We will modify the WebSocket consumer to persist each message that is received
    through the WebSocket. Edit the `consumers.py` file of the `chat` application,
    and add the following code highlighted in bold:'
  id: totrans-328
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE47]'
  id: totrans-329
  prefs: []
  type: TYPE_PRE
  zh: '[PRE47]'
- en: In this code, we add the asynchronous `persist_message()` method to the `ChatConsumer`
    class. This method takes a `message` parameter and creates a `Message` object
    in the database with the given message, the related authenticated `user`, and
    the `id` of the `Course` object that the group chat room belongs to. Since the
    is `ChatConsumer` is fully asynchronous, we use the `acreate()` QuerySet method,
    which is the asynchronous version of `create()`. You can read more about how to
    write asynchronous queries with the Django ORM at [https://docs.djangoproject.com/en/5.0/topics/db/queries/#asynchronous-queries](https://docs.djangoproject.com/en/5.0/topics/db/queries/#asynchronous-queries).
  id: totrans-330
  prefs: []
  type: TYPE_NORMAL
- en: We call the `persist_message()` method asynchronously in the `receive()` method
    that is executed when a message is received by the consumer through the WebSocket.
  id: totrans-331
  prefs: []
  type: TYPE_NORMAL
- en: Run the development server and open `http://127.0.0.1:8000/chat/room/1/` in
    your browser, replacing `1` with the `id` of an existing course in the database.
    With a logged-in user who is enrolled in the course, write a message and send
    it.
  id: totrans-332
  prefs: []
  type: TYPE_NORMAL
- en: Then, open a second browser window in incognito mode to prevent the use of the
    same session. Log in with a different user, also enrolled in the same course,
    and send a few messages as well.
  id: totrans-333
  prefs: []
  type: TYPE_NORMAL
- en: '*Figure 16.10* shows an example of messages sent by two different users:'
  id: totrans-334
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/B21088_16_10.png)'
  id: totrans-335
  prefs: []
  type: TYPE_IMG
- en: 'Figure 16.10: Chat room example with messages sent by two different users'
  id: totrans-336
  prefs: []
  type: TYPE_NORMAL
- en: 'Open `http://127.0.0.1:8000/admin/chat/message/` in your browser. The messages
    sent should appear on the administration site, as in *Figure 16.11*:'
  id: totrans-337
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/B21088_16_11.png)'
  id: totrans-338
  prefs: []
  type: TYPE_IMG
- en: 'Figure 16.11: Admin list display view of messages stored in the database'
  id: totrans-339
  prefs: []
  type: TYPE_NORMAL
- en: All messages are now persisted in the database.
  id: totrans-340
  prefs: []
  type: TYPE_NORMAL
- en: Note that messages could contain malicious code, for example, JavaScript fragments.
    We do not mark the messages as safe in our template, providing an initial layer
    of protection against malicious content. However, to further enhance security,
    consider sanitizing the messages before storing them in the database. A reliable
    option for sanitizing content is the `nh3` package. You can read more about `nh3`
    at [https://nh3.readthedocs.io/en/latest/](https://nh3.readthedocs.io/en/latest/).
    Additionally, `django-nh3` is a Django integration available that offers custom
    `nh3` model fields and form fields. More information is available at [https://github.com/marksweb/django-nh3](https://github.com/marksweb/django-nh3).
  id: totrans-341
  prefs: []
  type: TYPE_NORMAL
- en: Now that you are storing the complete chat history in your database, let’s learn
    how to present the latest messages in the chat history to users when they join
    a chat room.
  id: totrans-342
  prefs: []
  type: TYPE_NORMAL
- en: Displaying the chat history
  id: totrans-343
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: When users join a course chat room, we will display the latest five messages
    of the chat history. This will ensure that users gain immediate context for ongoing
    conversations.
  id: totrans-344
  prefs: []
  type: TYPE_NORMAL
- en: 'Edit the `views.py` file of the `chat` application and add the following code
    highlighted in bold to the `course_chat_room` view:'
  id: totrans-345
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE48]'
  id: totrans-346
  prefs: []
  type: TYPE_PRE
  zh: '[PRE48]'
- en: We retrieve the chat messages related to the course and use `select_related()`
    to fetch the related user in the same query. This will prevent the generation
    of additional SQL queries when accessing the username to display it alongside
    each message. Django’s ORM doesn’t support negative indexing, so we retrieve the
    first five messages in reverse chronological order, and we utilize the `reversed()`
    function to reorder them back into chronological sequence.
  id: totrans-347
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, we will add the chat history to the chat room template. Edit the `chat/room.html`
    template and add the following lines highlighted in bold:'
  id: totrans-348
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE49]'
  id: totrans-349
  prefs: []
  type: TYPE_PRE
  zh: '[PRE49]'
- en: 'Open `http://127.0.0.1:8000/chat/room/1/` in your browser, replacing `1` with
    the `id` of an existing course in the database. You should now see the latest
    messages, as shown in *Figure 16.12*:'
  id: totrans-350
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/B21088_16_12.png)'
  id: totrans-351
  prefs: []
  type: TYPE_IMG
- en: 'Figure 16.12: Chat room initially displaying the latest messages'
  id: totrans-352
  prefs: []
  type: TYPE_NORMAL
- en: Users can now see the latest messages in the chat history upon joining a chat
    room. Next, we are going to add a link to the menu so that users can enter the
    course chat room.
  id: totrans-353
  prefs: []
  type: TYPE_NORMAL
- en: Integrating the chat application with existing views
  id: totrans-354
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The chat server is now fully implemented, and students enrolled in a course
    can communicate with each other. Let’s add a link for students to join the chat
    room for each course.
  id: totrans-355
  prefs: []
  type: TYPE_NORMAL
- en: 'Edit the `students/course/detail.html` template of the `students` application
    and add the following `<h3>` HTML element code at the bottom of the `<div class="contents">`
    element:'
  id: totrans-356
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE50]'
  id: totrans-357
  prefs: []
  type: TYPE_PRE
  zh: '[PRE50]'
- en: 'Open the browser and access any course that the student is enrolled in to view
    the course contents. The sidebar will now contain a **Course chat room** link
    that points to the course chat room view. If you click on it, you will enter the
    chat room:'
  id: totrans-358
  prefs: []
  type: TYPE_NORMAL
- en: '![Graphical user interface, application  Description automatically generated](img/B21088_16_13.png)'
  id: totrans-359
  prefs: []
  type: TYPE_IMG
- en: 'Figure 16.13: The course detail page, including a link to the course chat room'
  id: totrans-360
  prefs: []
  type: TYPE_NORMAL
- en: Congratulations! You successfully built your first asynchronous application
    using Django Channels.
  id: totrans-361
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  id: totrans-362
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, you learned how to create a chat server using Channels. You
    implemented both a WebSocket consumer and a client. By enabling communication
    through a channel layer with Redis and modifying the consumer to be fully asynchronous,
    you improved the responsiveness and scalability of your application. Additionally,
    you implemented chat message persistence, providing a robust and user-friendly
    experience and maintaining chat history for users over time. The skills you learned
    in this chapter will help you in any future implementations of asynchronous real-time
    functionalities.
  id: totrans-363
  prefs: []
  type: TYPE_NORMAL
- en: The next chapter will teach you how to build a production environment for your
    Django project using NGINX, uWSGI, and Daphne with Docker Compose. You will also
    learn how to implement custom middleware for request/response processing across
    your entire application, and how to develop custom management commands, which
    enable you to automate tasks and execute them via the command line.
  id: totrans-364
  prefs: []
  type: TYPE_NORMAL
- en: Additional resources
  id: totrans-365
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The following resources provide additional information related to the topics
    covered in this chapter:'
  id: totrans-366
  prefs: []
  type: TYPE_NORMAL
- en: 'Source code for this chapter: [https://github.com/PacktPublishing/Django-5-by-example/tree/main/Chapter16](https://github.com/PacktPublishing/Django-5-by-example/tree/main/Chapter16)'
  id: totrans-367
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Introduction to ASGI: [https://asgi.readthedocs.io/en/latest/introduction.html](https://asgi.readthedocs.io/en/latest/introduction.html)'
  id: totrans-368
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Django support for asynchronous views: [https://docs.djangoproject.com/en/5.0/topics/async/](https://docs.djangoproject.com/en/5.0/topics/async/)'
  id: totrans-369
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Django support for asynchronous class-based views: [https://docs.djangoproject.com/en/5.0/topics/class-based-views/#async-class-based-views](https://docs.djangoproject.com/en/5.0/topics/class-based-views/#async-class-based-views)'
  id: totrans-370
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Daphne ASGI server: [https://github.com/django/daphne](https://github.com/django/daphne)'
  id: totrans-371
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Django Channels documentation: [https://channels.readthedocs.io/](https://channels.readthedocs.io/)'
  id: totrans-372
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Deploying Django with ASGI: [https://docs.djangoproject.com/en/5.0/howto/deployment/asgi/](https://docs.djangoproject.com/en/5.0/howto/deployment/asgi/)'
  id: totrans-373
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Introduction to WebSockets: [https://en.wikipedia.org/wiki/WebSocket](https://en.wikipedia.org/wiki/WebSocket).'
  id: totrans-374
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`json_script` template filter usage: [https://docs.djangoproject.com/en/5.0/ref/templates/builtins/#json-script](https://docs.djangoproject.com/en/5.0/ref/templates/builtins/#json-script)'
  id: totrans-375
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Django ORM asynchronous queries: [https://docs.djangoproject.com/en/5.0/topics/db/queries/#asynchronous-queries](https://docs.djangoproject.com/en/5.0/topics/db/queries/#asynchronous-queries)'
  id: totrans-376
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`nh3` documentation: [https://nh3.readthedocs.io/en/latest/](https://nh3.readthedocs.io/en/latest/)'
  id: totrans-377
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`django-nh3` project: [https://github.com/marksweb/django-nh3](https://github.com/marksweb/django-nh3)'
  id: totrans-378
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
