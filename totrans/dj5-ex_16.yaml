- en: '16'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '16'
- en: Building a Chat Server
  id: totrans-1
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 构建聊天服务器
- en: In the previous chapter, you created a RESTful API for your project that provides
    a programmable interface for your application.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 在上一章中，您为项目创建了一个 RESTful API，为您的应用程序提供了一个可编程的接口。
- en: In this chapter, you will develop a chat server for students using Django Channels,
    enabling students to engage in real-time messaging within course chat rooms. You
    will learn how to build real-time applications through asynchronous programming
    with Django Channels. By serving your Django project through **Asynchronous Server
    Gateway Interface** (**ASGI**), and implementing asynchronous communication, you
    will enhance the responsiveness and scalability of your server. Additionally,
    you will persist chat messages into the database, building a comprehensive chat
    history and enriching the user experience and functionality of the chat application.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，您将使用 Django Channels 开发一个面向学生的聊天服务器，使学生能够在课程聊天室中进行实时消息交流。您将学习如何通过 Django
    Channels 的异步编程构建实时应用程序。通过通过 **异步服务器网关接口** (**ASGI**) 提供您的 Django 项目，并实现异步通信，您将提高服务器的响应性和可扩展性。此外，您将把聊天消息持久化到数据库中，构建一个全面的聊天历史，丰富聊天应用的用户体验和功能。
- en: 'In this chapter, you will:'
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，您将：
- en: Add Channels to your project
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 将 Channels 添加到您的项目中
- en: Build a WebSocket consumer and appropriate routing
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 构建WebSocket消费者和适当的路由
- en: Implement a WebSocket client
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 实现WebSocket客户端
- en: Enable a channel layer with Redis
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 启用带有Redis的通道层
- en: Make your consumer fully asynchronous
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使您的消费者完全异步
- en: Persist chat messages into the database
  id: totrans-10
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 将聊天消息持久化到数据库中
- en: Functional overview
  id: totrans-11
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 功能概述
- en: '*Figure 16.1* shows a representation of the views, templates, and functionalities
    that will be built in this chapter:'
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 16.1* 展示了本章将构建的视图、模板和功能：'
- en: '![](img/B21088_16_01.png)'
  id: totrans-13
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/B21088_16_01.png)'
- en: 'Figure 16.1: Diagram of functionalities built in this chapter'
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 图 16.1：本章构建的功能图
- en: In this chapter, you will implement the `course_chat_room` view in the `chat`
    application. This view will serve the template that displays the chat room for
    a given course. The latest chat messages will be displayed when a user joins a
    chat room. You will use JavaScript to establish a WebSocket connection in the
    browser, and you will build the `ChatConsumer` WebSocket consumer to handle WebSocket
    connections and to exchange messages. You will use Redis to implement the channel
    layer that allows broadcasting messages to all users in the chat room.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，您将在 `chat` 应用程序中实现 `course_chat_room` 视图。此视图将提供显示给定课程聊天室的模板。当用户加入聊天室时，将显示最新的聊天消息。您将使用
    JavaScript 在浏览器中建立 WebSocket 连接，并构建 `ChatConsumer` WebSocket 消费者来处理 WebSocket
    连接和交换消息。您将使用 Redis 实现允许向聊天室中的所有用户广播消息的通道层。
- en: The source code for this chapter can be found at [https://github.com/PacktPublishing/Django-5-by-example/tree/main/Chapter16](https://github.com/PacktPublishing/Django-5-by-example/tree/main/Chapter16).
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 本章的源代码可以在 [https://github.com/PacktPublishing/Django-5-by-example/tree/main/Chapter16](https://github.com/PacktPublishing/Django-5-by-example/tree/main/Chapter16)
    找到。
- en: All Python modules used in this chapter are included in the `requirements.txt`
    file in the source code that comes along with this chapter. You can follow the
    instructions to install each Python module below or you can install all requirements
    at once with the command `python -m pip install -r requirements.txt`.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 本章中使用的所有 Python 模块都包含在本章源代码的 `requirements.txt` 文件中。您可以根据以下说明安装每个 Python 模块，或者使用命令
    `python -m pip install -r requirements.txt` 一次性安装所有依赖。
- en: Creating a chat application
  id: totrans-18
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 创建一个聊天应用
- en: You are going to implement a chat server to provide students with a chat room
    for each course. Students enrolled in a course will be able to access the course
    chat room and exchange messages in real time. You will use Channels to build this
    functionality. Channels is a Django application that extends Django to handle
    protocols that require long-running connections, such as WebSockets, chatbots,
    or MQTT (a lightweight publish/subscribe message transport commonly used in **Internet
    of Things** (**IoT**) projects).
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 您将实现一个聊天服务器，为每个课程提供聊天室，以便学生可以访问课程聊天室并实时交换消息。您将使用 Channels 来构建此功能。Channels 是一个
    Django 应用程序，它扩展了 Django 以处理需要长时间运行连接的协议，例如 WebSockets、聊天机器人或 MQTT（一种轻量级的发布/订阅消息传输，常用于
    **物联网** (**IoT**) 项目）。
- en: Using Channels, you can easily implement real-time or asynchronous functionalities
    into your project in addition to your standard HTTP synchronous views. You will
    start by adding a new application to your project. The new application will contain
    the logic for the chat server.
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 使用Channels，您可以在项目中轻松实现实时或异步功能，除了您标准的HTTP同步视图。您将首先向项目中添加一个新的应用程序。新的应用程序将包含聊天服务器的逻辑。
- en: You can the documentation for Django Channels at [https://channels.readthedocs.io/](https://channels.readthedocs.io/).
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以在[https://channels.readthedocs.io/](https://channels.readthedocs.io/)找到Django
    Channels的文档。
- en: 'Let’s start implementing the chat server. Run the following command from the
    project’s `educa` directory to create the new application file structure:'
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们开始实现聊天服务器。从项目的`educa`目录运行以下命令以创建新的应用程序文件结构：
- en: '[PRE0]'
  id: totrans-23
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'Edit the `settings.py` file of the `educa` project and activate the `chat`
    application in your project by editing the `INSTALLED_APPS` setting, as follows:'
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 编辑`educa`项目的`settings.py`文件，通过编辑`INSTALLED_APPS`设置来激活项目中的`chat`应用程序，如下所示：
- en: '[PRE1]'
  id: totrans-25
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: The new `chat` application is now active in your project. Next, you are going
    to build a view for course chat rooms.
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 新的`chat`应用程序现在已在您的项目中激活。接下来，您将构建一个用于课程聊天室的视图。
- en: Implementing the chat room view
  id: totrans-27
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 实现聊天室视图
- en: You will provide students with a different chat room for each course. You need
    to create a view for students to join the chat room of a given course. Only students
    who are enrolled in a course will be able to access the course chat room.
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 您将为每个课程提供不同的聊天室。您需要创建一个视图，让学生能够加入指定课程的聊天室。只有注册了课程的学生的才能访问课程聊天室。
- en: 'Edit the `views.py` file of the new `chat` application and add the following
    code to it:'
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 编辑新`chat`应用程序的`views.py`文件，并向其中添加以下代码：
- en: '[PRE2]'
  id: totrans-30
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'This is the `course_chat_room` view. In this view, you use the `@login_required`
    decorator to prevent any non-authenticated user from accessing the view. The view
    works as follows:'
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 这是`course_chat_room`视图。在这个视图中，您使用`@login_required`装饰器来阻止任何未经认证的用户访问视图。视图的工作方式如下：
- en: The view receives a required `course_id` parameter that is used to retrieve
    the course with the given `id`.
  id: totrans-32
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 视图接收一个必需的`course_id`参数，用于检索具有给定`id`的课程。
- en: The courses that the user is enrolled in are retrieved through the `courses_joined`
    relationship and the course with the given `id` is obtained from that subset of
    courses. If the course with the given `id` does not exist or the user is not enrolled
    in it, an `HttpResponseForbidden` response is returned, which translates to an
    HTTP response with status `403`.
  id: totrans-33
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 用户注册的课程通过`courses_joined`关系检索，并从这些课程子集中获取具有给定`id`的课程。如果具有给定`id`的课程不存在或用户未注册，则返回`HttpResponseForbidden`响应，这相当于HTTP状态`403`的响应。
- en: If the course with the given `id` exists and the user is enrolled in it, the
    `chat/room.html` template is rendered, passing the `course` object to the template
    context.
  id: totrans-34
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果具有给定`id`的课程存在且用户已注册，则渲染`chat/room.html`模板，并将`course`对象传递到模板上下文中。
- en: 'You need to add a URL pattern for this view. Create a new file inside the `chat`
    application directory and name it `urls.py`. Add the following code to it:'
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 您需要为这个视图添加一个URL模式。在`chat`应用程序目录内创建一个新文件，命名为`urls.py`。向其中添加以下代码：
- en: '[PRE3]'
  id: totrans-36
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: This is the initial URL patterns file for the `chat` application. You define
    the `course_chat_room` URL pattern, including the `course_id` parameter with the
    `int` prefix, as you only expect an integer value here.
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 这是`chat`应用程序的初始URL模式文件。您定义了`course_chat_room` URL模式，包括带有`int`前缀的`course_id`参数，因为您只期望这里是一个整数值。
- en: 'Include the new URL patterns of the `chat` application in the main URL patterns
    of the project. Edit the main `urls.py` file of the `educa` project and add the
    following line to it:'
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 在项目的主体URL模式中包含`chat`应用程序的新URL模式。编辑`educa`项目的主体`urls.py`文件，并向其中添加以下行：
- en: '[PRE4]'
  id: totrans-39
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: URL patterns for the `chat` application are added to the project under the `chat/`
    path.
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: '`chat`应用程序的URL模式已添加到项目的`chat/`路径下。'
- en: You need to create a template for the `course_chat_room` view. This template
    will contain an area to visualize the messages that are exchanged in the chat,
    and a text input with a submit button to send text messages to the chat.
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 您需要为`course_chat_room`视图创建一个模板。此模板将包含一个用于可视化聊天中交换的消息的区域，以及一个带有提交按钮的文本输入框，用于向聊天发送文本消息。
- en: 'Create the following file structure within the `chat` application directory:'
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 在`chat`应用程序目录内创建以下文件结构：
- en: '[PRE5]'
  id: totrans-43
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'Edit the `chat/room.html` template and add the following code to it:'
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 编辑 `chat/room.html` 模板，并向其中添加以下代码：
- en: '[PRE6]'
  id: totrans-45
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'This is the template for the course chat room. In this template, you perform
    the following actions:'
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 这是课程聊天室的模板。在这个模板中，你执行以下操作：
- en: You extend the `base.html` template of your project and fill its `content` block.
  id: totrans-47
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 你扩展了项目的 `base.html` 模板，并填充其 `content` 块。
- en: You define a `<div>` HTML element with the `chat` ID that you will use to display
    the chat messages sent by the user and by other students.
  id: totrans-48
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 你定义了一个带有 `chat` ID 的 `<div>` HTML 元素，你将使用它来显示用户和其他学生发送的聊天消息。
- en: You also define a second `<div>` element with a `text` input and a submit button
    that will allow the user to send messages.
  id: totrans-49
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 你还定义了一个带有 `text` 输入和提交按钮的第二个 `<div>` 元素，这将允许用户发送消息。
- en: You add the `include_js` and `domready` blocks defined in the `base.html` template,
    which you are going to implement later, to establish a connection with a WebSocket
    and send or receive messages.
  id: totrans-50
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 你添加了 `base.html` 模板中定义的 `include_js` 和 `domready` 块，你将在稍后实现它们，以建立与 WebSocket
    的连接并发送或接收消息。
- en: Run the development server and open `http://127.0.0.1:8000/chat/room/1/` in
    your browser, replacing `1` with the `id` of an existing course in the database.
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 运行开发服务器，并在你的浏览器中打开 `http://127.0.0.1:8000/chat/room/1/`，将 `1` 替换为数据库中现有课程的 `id`。
- en: 'Access the chat room with a logged-in user who is enrolled in the course. You
    will see the following screen:'
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 使用注册了课程的登录用户访问聊天室。你将看到以下屏幕：
- en: '![](img/B21088_16_02.png)'
  id: totrans-53
  prefs: []
  type: TYPE_IMG
  zh: '![图片 B21088_16_02.png](img/B21088_16_02.png)'
- en: 'Figure 16.2: The course chat room page'
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 图 16.2：课程聊天室页面
- en: This is the course chat room screen that students will use to discuss topics
    within a course.
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 这是学生将在其中讨论课程主题的课程聊天室屏幕。
- en: You have created the base view for the course chat room. Now you need to handle
    messages between students. The next section will introduce asynchronous support
    with Channels for real-time communication.
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 你已经创建了课程聊天室的基视图。现在你需要处理学生之间的消息。下一节将介绍使用 Channels 的异步支持来实现实时通信。
- en: Real-time Django with Channels
  id: totrans-57
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 实时 Django 与 Channels
- en: You are building a chat server to provide students with a chat room for each
    course. Students enrolled in a course will be able to access the course chat room
    and exchange messages. This functionality requires real-time communication between
    the server and the client.
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 你正在构建一个聊天服务器，为每个课程提供学生聊天室。注册了课程的学生的将能够访问课程聊天室并交换消息。此功能需要服务器和客户端之间的实时通信。
- en: A standard HTTP request/response model doesn’t work here because you need the
    browser to receive notifications as soon as new messages arrive. There are several
    ways you could implement this feature, using AJAX polling or long polling in combination
    with storing the messages in your database or Redis. However, there is no efficient
    way to implement real-time communication using a standard synchronous web application.
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 标准的 HTTP 请求/响应模型在这里不适用，因为你需要浏览器在新消息到达时立即接收通知。你可以通过使用 AJAX 轮询或长轮询结合将消息存储在你的数据库或
    Redis 中来实现此功能。然而，使用标准的同步 Web 应用程序实现实时通信没有高效的方法。
- en: You need asynchronous communication, which allows real-time interactions, where
    the server can push updates to the client as soon as new messages arrive without
    the client needing to request updates periodically. Asynchronous communication
    also comes with other advantages, such as reduced latency, improved performance
    under load, and a better overall user experience. You are going to build a chat
    server using asynchronous communication through ASGI.
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 你需要异步通信，这允许实时交互，其中服务器可以在新消息到达时立即将更新推送到客户端，而无需客户端定期请求更新。异步通信还带来其他优势，例如降低延迟、提高负载下的性能，以及更好的整体用户体验。你将使用
    ASGI 通过异步通信构建聊天服务器。
- en: Asynchronous applications using ASGI
  id: totrans-61
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用 ASGI 的异步应用程序
- en: Django is usually deployed using **Web Server Gateway Interface** (**WSGI**),
    which is the standard interface for Python applications to handle HTTP requests.
    However, to work with asynchronous applications, you need to use another interface
    called ASGI, which can handle WebSocket requests as well. ASGI is the emerging
    Python standard for asynchronous web servers and applications. By using ASGI,
    we will enable Django to handle each message independently and in real time, creating
    a smooth and live chat experience for students.
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: Django通常使用**Web服务器网关接口**（**WSGI**）进行部署，这是Python应用程序处理HTTP请求的标准接口。然而，为了与异步应用程序一起工作，你需要使用另一个名为ASGI的接口，它可以处理WebSocket请求。ASGI是异步Web服务器和应用程序的Python标准。通过使用ASGI，我们将使Django能够独立并实时地处理每条消息，为学生创造一个流畅和实时的聊天体验。
- en: You can find an introduction to ASGI at [https://asgi.readthedocs.io/en/latest/introduction.html](https://asgi.readthedocs.io/en/latest/introduction.html).
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以在[https://asgi.readthedocs.io/en/latest/introduction.html](https://asgi.readthedocs.io/en/latest/introduction.html)找到ASGI的介绍。
- en: Django comes with support for running asynchronous Python through ASGI. Writing
    asynchronous views has been supported since Django 3.1, and Django 4.1 introduced
    asynchronous handlers for class-based views. Django 5.0 adds handling for disconnect
    events in asynchronous views before the response is generated. It also adds asynchronous
    functions to the authentication framework, provides support for asynchronous signal
    dispatching, and adds async support to multiple built-in decorators.
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: Django自带通过ASGI运行异步Python的支持。自Django 3.1以来，就支持编写异步视图，而Django 4.1引入了基于类的视图的异步处理程序。Django
    5.0在生成响应之前添加了对异步视图中的断开事件的处理。它还向认证框架添加了异步函数，提供了异步信号分发的支持，并将异步支持添加到多个内置装饰器中。
- en: Channels builds upon the native ASGI support available in Django and provides
    additional functionalities to handle protocols that require long-running connections,
    such as WebSockets, IoT protocols, and chat protocols.
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: Channels建立在Django中可用的原生ASGI支持之上，并为处理需要长时间运行连接的协议（如WebSockets、IoT协议和聊天协议）提供了额外的功能。
- en: WebSockets provide full-duplex communication by establishing a persistent, open,
    bidirectional **Transmission Control Protocol** (**TCP**) connection between servers
    and clients. Instead of sending HTTP requests to the server, you establish a connection
    with the server; once the channel is open, messages can be exchanged in both directions
    without needing to establish a new connection each time. You are going to use
    WebSockets to implement your chat server.
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: WebSockets通过在服务器和客户端之间建立一个持久、开放、双向的**传输控制协议**（**TCP**）连接来提供全双工通信。你不需要向服务器发送HTTP请求，而是与服务器建立连接；一旦通道打开，就可以在两个方向上交换消息，而不需要每次都建立新的连接。你将使用WebSockets来实现你的聊天服务器。
- en: You can read more about WebSockets at [https://en.wikipedia.org/wiki/WebSocket](https://en.wikipedia.org/wiki/WebSocket).
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以在[https://en.wikipedia.org/wiki/WebSocket](https://en.wikipedia.org/wiki/WebSocket)上了解更多关于WebSockets的信息。
- en: You can find more information about deploying Django with ASGI at [https://docs.djangoproject.com/en/5.0/howto/deployment/asgi/](https://docs.djangoproject.com/en/5.0/howto/deployment/asgi/).
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以在[https://docs.djangoproject.com/en/5.0/howto/deployment/asgi/](https://docs.djangoproject.com/en/5.0/howto/deployment/asgi/)找到有关使用ASGI部署Django的更多信息。
- en: You can find more information about Django’s support for writing asynchronous
    views at [https://docs.djangoproject.com/en/5.0/topics/async/](https://docs.djangoproject.com/en/5.0/topics/async/)
    and Django’s support for asynchronous class-based views at [https://docs.djangoproject.com/en/5.0/topics/class-based-views/#async-class-based-views](https://docs.djangoproject.com/en/5.0/topics/class-based-views/#async-class-based-views).
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以在[https://docs.djangoproject.com/en/5.0/topics/async/](https://docs.djangoproject.com/en/5.0/topics/async/)找到有关Django支持编写异步视图的更多信息，以及Django对异步类视图的支持[https://docs.djangoproject.com/en/5.0/topics/class-based-views/#async-class-based-views](https://docs.djangoproject.com/en/5.0/topics/class-based-views/#async-class-based-views)。
- en: Next, we are going to learn how the Django request/response cycle is altered
    by using Channels.
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们将学习如何使用Channels改变Django的请求/响应周期。
- en: The request/response cycle using Channels
  id: totrans-71
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用Channels的请求/响应周期
- en: 'It’s important to understand the differences in a request cycle between a standard
    synchronous request cycle and a Channels implementation. The following schema
    shows the request cycle of a synchronous Django setup:'
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 理解标准同步请求周期与Channels实现之间的差异非常重要。以下图示展示了同步Django设置的请求周期：
- en: '![](img/B21088_16_03.png)'
  id: totrans-73
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/B21088_16_03.png)'
- en: 'Figure 16.3: The Django request/response cycle'
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 图 16.3：Django 请求/响应周期
- en: When an HTTP request is sent by the browser to the web server, Django handles
    the request and passes the `HttpRequest` object to the corresponding view. The
    view processes the request and returns an `HttpResponse` object that is sent back
    to the browser as an HTTP response. There is no mechanism to maintain an open
    connection or send data to the browser without an associated HTTP request.
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 当浏览器向 Web 服务器发送 HTTP 请求时，Django 处理请求并将 `HttpRequest` 对象传递给相应的视图。视图处理请求并返回一个
    `HttpResponse` 对象，该对象作为 HTTP 响应发送回浏览器。没有机制在不需要相关 HTTP 请求的情况下保持打开的连接或向浏览器发送数据。
- en: 'The following schema shows the request cycle of a Django project using Channels
    with WebSockets:'
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 以下架构显示了使用 WebSocket 的 Django 项目使用 Channels 的请求周期：
- en: '![](img/B21088_16_04.png)'
  id: totrans-77
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/B21088_16_04.png)'
- en: 'Figure 16.4: The Django Channels request/response cycle'
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 图 16.4：Django Channels 请求/响应周期
- en: Channels replaces Django’s request/response cycle with messages that are sent
    across channels. HTTP requests are still routed to view functions using Django,
    but they get routed over channels. This allows WebSocket message handling as well,
    where you have producers and consumers that exchange messages across a channel
    layer. Channels preserves Django’s synchronous architecture, allowing you to choose
    between writing synchronous code and asynchronous code, or a combination of both.
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: Channels 用跨通道发送的消息替换了 Django 的请求/响应周期。HTTP 请求仍然通过 Django 路由到视图函数，但它们通过通道进行路由。这允许处理
    WebSocket 消息，其中您有生产者和消费者在通道层之间交换消息。Channels 保留了 Django 的同步架构，允许您在编写同步代码和异步代码之间进行选择，或者两者结合。
- en: Your existing synchronous views will co-exist with the WebSocket functionality
    that we will implement with Daphne, and you will serve both HTTP and WebSocket
    requests.
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 您现有的同步视图将与我们将使用 Daphne 实现的 WebSocket 功能共存，并且您将同时处理 HTTP 和 WebSocket 请求。
- en: Next, you are going to install Channels and add it to your project.
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，您将安装 Channels 并将其添加到项目中。
- en: Installing Channels and Daphne
  id: totrans-82
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 安装 Channels 和 Daphne
- en: You are going to add Channels to your project and set up the required basic
    ASGI application routing for it to manage HTTP requests.
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 您将向项目中添加 Channels 并为其设置所需的基本 ASGI 应用程序路由，以便管理 HTTP 请求。
- en: 'Install Channels in your virtual environment with the following command:'
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 使用以下命令在您的虚拟环境中安装 Channels：
- en: '[PRE7]'
  id: totrans-85
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: This will simultaneously install Channels along with the Daphne ASGI application
    server. An ASGI server is necessary for handling asynchronous requests, and we
    choose Daphne for its simplicity and compatibility, as it comes bundled with Channels.
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 这将同时安装 Channels 和 Daphne ASGI 应用程序服务器。处理异步请求需要一个 ASGI 服务器，我们选择 Daphne，因为它简单且兼容，并且与
    Channels 一起打包。
- en: 'Edit the `settings.py` file of the `educa` project and add `daphne` to the
    beginning of the `INSTALLED_APPS` setting as follows:'
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 编辑 `educa` 项目的 `settings.py` 文件，并将 `daphne` 添加到 `INSTALLED_APPS` 设置的开头，如下所示：
- en: '[PRE8]'
  id: totrans-88
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: When `daphne` is added to the `INSTALLED_APPS` setting, it takes control over
    the `runserver` command, replacing the standard Django development server. This
    will allow you to serve asynchronous requests during development. Besides handling
    URL routing to Django views for synchronous requests, Daphne also manages routes
    to WebSocket consumers. You can find more information about Daphne at [https://github.com/django/daphne](https://github.com/django/daphne).
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 当 `daphne` 被添加到 `INSTALLED_APPS` 设置中时，它将接管 `runserver` 命令，替换标准的 Django 开发服务器。这将允许您在开发期间处理异步请求。除了处理同步请求的
    URL 路由到 Django 视图外，Daphne 还管理 WebSocket 消费者的路由。您可以在 [https://github.com/django/daphne](https://github.com/django/daphne)
    找到有关 Daphne 的更多信息。
- en: Channels expects you to define a single root application that will be executed
    for all requests. You can define the root application by adding the `ASGI_APPLICATION`
    setting to your project. This is similar to the `ROOT_URLCONF` setting that points
    to the base URL patterns of your project. You can place the root application anywhere
    in your project, but it is recommended to put it in a project-level file. You
    can add your root routing configuration to the `asgi.py` file directly, where
    the ASGI application will be defined.
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: Channels 预期您定义一个单一的根应用程序，该应用程序将执行所有请求。您可以通过将 `ASGI_APPLICATION` 设置添加到项目中来定义根应用程序。这与指向项目基本
    URL 模式的 `ROOT_URLCONF` 设置类似。您可以在项目的任何位置放置根应用程序，但建议将其放在项目级别的文件中。您可以直接将根路由配置添加到
    `asgi.py` 文件中，其中将定义 ASGI 应用程序。
- en: 'Edit the `asgi.py` file in the `educa` project directory and add the following
    code highlighted in bold:'
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 在`educa`项目目录中编辑`asgi.py`文件，并添加以下粗体显示的代码：
- en: '[PRE9]'
  id: totrans-92
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: In the previous code, you define the main ASGI application that will be executed
    when serving the Django project through ASGI. You use the `ProtocolTypeRouter`
    class provided by Channels as the main entry point of your routing system. `ProtocolTypeRouter`
    takes a dictionary that maps communication types like `http` or `websocket` to
    ASGI applications. You instantiate this class with the default application for
    the HTTP protocol. Later, you will add a protocol for the WebSocket.
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的代码中，你定义了当通过ASGI服务Django项目时将被执行的主要ASGI应用程序。你使用Channels提供的`ProtocolTypeRouter`类作为路由系统的主入口点。`ProtocolTypeRouter`接受一个映射通信类型（如`http`或`websocket`）到ASGI应用程序的字典。你使用HTTP协议的默认应用程序实例化这个类。稍后，你将添加WebSocket的协议。
- en: 'Add the following line to the `settings.py` file of your project:'
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 将以下行添加到你的项目`settings.py`文件中：
- en: '[PRE10]'
  id: totrans-95
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: The `ASGI_APPLICATION` setting is used by Channels to locate the root routing
    configuration.
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: '`ASGI_APPLICATION`设置被Channels用于定位根路由配置。'
- en: 'Start the development server using the following command:'
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 使用以下命令启动开发服务器：
- en: '[PRE11]'
  id: totrans-98
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'You will see output similar to the following:'
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 你将看到类似以下输出的内容：
- en: '[PRE12]'
  id: totrans-100
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: Check that the output contains the line `Starting ASGI/Daphne version 4.1.0
    development server`. This line confirms that you are using the Daphne development
    server, which is capable of managing synchronous and asynchronous requests, instead
    of the standard Django development server. HTTP requests continue to behave the
    same as before, but they get routed over Channels.
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 检查输出是否包含以下行`Starting ASGI/Daphne version 4.1.0 development server`。这一行确认你正在使用Daphne开发服务器，它能够管理同步和异步请求，而不是标准的Django开发服务器。HTTP请求的行为与之前相同，但它们将通过通道路由。
- en: 'Now that Channels is installed in your project, you can build the chat server
    for courses. To implement the chat server for your project, you will need to take
    the following steps:'
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 现在Channels已安装到你的项目中，你可以构建课程的聊天服务器。为了实现你项目的聊天服务器，你需要采取以下步骤：
- en: '**Set up a consumer**: Consumers are individual pieces of code that can handle
    WebSockets in a very similar way to traditional HTTP views. You will build a consumer
    to read and write messages to a communication channel.'
  id: totrans-103
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**设置消费者**：消费者是能够以与传统HTTP视图非常相似的方式处理WebSocket的独立代码块。你将构建一个消费者来读取和写入通信通道的消息。'
- en: '**Configure routing**: Channels provides routing classes that allow you to
    combine and stack your consumers. You will configure URL routing for your chat
    consumer.'
  id: totrans-104
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**配置路由**：Channels提供了路由类，允许你组合和堆叠你的消费者。你将为你的聊天消费者配置URL路由。'
- en: '**Implement a WebSocket client**: When the student accesses the chat room,
    you will connect to the WebSocket from the browser and send or receive messages
    using JavaScript.'
  id: totrans-105
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**实现WebSocket客户端**：当学生访问聊天室时，你将从浏览器连接到WebSocket，并使用JavaScript发送或接收消息。'
- en: '**Enable a channel layer**: Channel layers allow you to talk between different
    instances of an application. They’re a useful part of making a distributed real-time
    application. You will set up a channel layer using Redis.'
  id: totrans-106
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**启用通道层**：通道层允许你在应用程序的不同实例之间进行通信。它们是构建分布式实时应用程序的有用部分。你将使用Redis设置一个通道层。'
- en: Let’s start by writing your own consumer to handle connecting to a WebSocket,
    receiving and sending messages, and disconnecting.
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们从编写自己的消费者开始，以处理连接到WebSocket、接收和发送消息以及断开连接。
- en: Writing a consumer
  id: totrans-108
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 编写消费者
- en: Consumers are the equivalent of Django views for asynchronous applications.
    As mentioned, they handle WebSockets in a very similar way to how traditional
    views handle HTTP requests. Consumers are ASGI applications that can handle messages,
    notifications, and other things. Unlike Django views, consumers are built for
    long-running communication. URLs are mapped to consumers through routing classes
    that allow you to combine and stack consumers.
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 消费者是对异步应用程序中Django视图的等效。如前所述，它们以与传统视图处理HTTP请求非常相似的方式处理WebSocket。消费者是能够处理消息、通知和其他内容的ASGI应用程序。与Django视图不同，消费者是为长时间运行的通信而构建的。通过允许你组合和堆叠消费者的路由类，URL被映射到消费者。
- en: Let’s implement a basic consumer that can accept WebSocket connections and echoes
    every message it receives from the WebSocket back to it. This initial functionality
    will allow the student to send messages to the consumer and receive back the messages
    it sends.
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们实现一个基本的消费者，它可以接受WebSocket连接，并将从WebSocket接收到的每条消息回显给它。此初始功能将允许学生向消费者发送消息，并接收回发送的消息。
- en: 'Create a new file inside the `chat` application directory and name it `consumers.py`.
    Add the following code to it:'
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 在`chat`应用程序目录内创建一个新文件，并将其命名为`consumers.py`。将以下代码添加到其中：
- en: '[PRE13]'
  id: totrans-112
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'This is the `ChatConsumer` consumer. This class inherits from the Channels
    `WebsocketConsumer` class to implement a basic WebSocket consumer. In this consumer,
    you implement the following methods:'
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 这是`ChatConsumer`消费者。此类从Channels的`WebsocketConsumer`类继承，以实现基本的WebSocket消费者。在此消费者中，您实现了以下方法：
- en: '`connnect()`: Called when a new connection is received. You accept any connection
    with `self.accept()`. You can also reject a connection by calling `self.close()`.'
  id: totrans-114
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`connect()`: 当接收到新的连接时调用。您可以使用`self.accept()`接受任何连接。您也可以通过调用`self.close()`拒绝连接。'
- en: '`disconnect()`: Called when the socket closes. You use `pass` because you don’t
    need to implement any action when a client closes the connection.'
  id: totrans-115
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`disconnect()`: 当套接字关闭时调用。您使用`pass`，因为当客户端关闭连接时，您不需要实现任何操作。'
- en: '`receive()`: Called whenever data is received from the WebSocket. You expect
    text to be received as `text_data` (this could also be `binary_data` for binary
    data). You treat the text data received as JSON. Therefore, you use `json.loads()`
    to load the received JSON data into a Python dictionary. You access the `message`
    key, which you expect to be present in the JSON structure received. To echo the
    message, you send the message back to the WebSocket with `self.send()`, transforming
    it into JSON format again through `json.dumps()`.'
  id: totrans-116
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`receive()`: 当从WebSocket接收到数据时调用。您期望接收到的数据是`text_data`（这也可以是`binary_data`，用于二进制数据）。您将接收到的文本数据视为JSON。因此，您使用`json.loads()`将接收到的JSON数据加载到Python字典中。您访问`message`键，您期望它在接收到的JSON结构中存在。为了回显消息，您使用`self.send()`将消息发送回WebSocket，并通过`json.dumps()`将其再次转换为JSON格式。'
- en: The initial version of your `ChatConsumer` consumer accepts any WebSocket connection
    and echoes to the WebSocket client every message it receives. Note that the consumer
    does not broadcast messages to other clients yet. You will build this functionality
    by implementing a channel layer later.
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 您的`ChatConsumer`消费者初始版本接受任何WebSocket连接，并将接收到的每条消息回显到WebSocket客户端。请注意，消费者尚未向其他客户端广播消息。您将通过实现通道层来构建此功能。
- en: First, let’s expose our consumer by adding it to the URLs of the project.
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，让我们通过将其添加到项目的URL中，来公开我们的消费者。
- en: Routing
  id: totrans-119
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 路由
- en: You need to define a URL to route connections to the `ChatConsumer` consumer
    you have implemented. Channels provides routing classes that allow you to combine
    and stack consumers to dispatch based on what the connection is. You can think
    of them as the URL routing system of Django for asynchronous applications.
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 您需要定义一个URL，以便将连接路由到您已实现的`ChatConsumer`消费者。Channels提供了路由类，允许您组合和堆叠消费者，根据连接的内容进行分发。您可以将它们视为Django异步应用的URL路由系统。
- en: 'Create a new file inside the `chat` application directory and name it `routing.py`.
    Add the following code to it:'
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 在`chat`应用程序目录内创建一个新文件，并将其命名为`routing.py`。将以下代码添加到其中：
- en: '[PRE14]'
  id: totrans-122
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'In this code, you map a URL pattern with the `ChatConsumer` class that you
    defined in the `chat/consumers.py` file. There are some details that are worth
    reviewing:'
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 在此代码中，您将一个URL模式映射到您在`chat/consumers.py`文件中定义的`ChatConsumer`类。有一些细节值得审查：
- en: You use Django’s `re_path()` to define the path with a regular expression instead
    of `path()`. Channels’ URL routing may not function correctly with `path()` routes
    if inner routers are wrapped by additional middleware, so this approach helps
    avoid any issues.
  id: totrans-124
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 您使用Django的`re_path()`来定义带有正则表达式的路径，而不是`path()`。如果内部路由器被额外的中间件包装，Channels的URL路由可能与`path()`路由不正确地工作，因此这种方法有助于避免任何问题。
- en: The URL includes an integer parameter called `course_id`. This parameter will
    be available in the scope of the consumer and will allow you to identify the course
    chat room that the user is connecting to.
  id: totrans-125
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: URL包含一个名为`course_id`的整数参数。此参数将在消费者的作用域内可用，并允许您识别用户连接到的课程聊天室。
- en: You call the `as_asgi()` method of the `consumer` class in order to get an ASGI
    application that will instantiate an instance of the consumer for each user connection.
    This behavior is similar to Django’s `as_view()` method for class-based views.
  id: totrans-126
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 你调用`consumer`类的`as_asgi()`方法，以获取一个ASGI应用程序，该应用程序将为每个用户连接实例化消费者实例。这种行为类似于Django的`as_view()`方法对于基于类的视图。
- en: It is a good practice to prepend WebSocket URLs with `/ws/` to differentiate
    them from URLs used for standard synchronous HTTP requests. This also simplifies
    the production setup when an HTTP server routes requests based on the path.
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 将WebSocket URL以`/ws/`开头是一种良好的实践，以区分用于标准同步HTTP请求的URL。这也简化了生产设置，当HTTP服务器根据路径路由请求时。
- en: 'Edit the global `asgi.py` file located next to the `settings.py` file so that
    it looks like this:'
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 编辑位于`settings.py`文件旁边的全局`asgi.py`文件，使其看起来像这样：
- en: '[PRE15]'
  id: totrans-129
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'In this code, you have added:'
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 在此代码中，你添加了：
- en: A new route for the `websocket` protocol. You use `URLRouter` to map `websocket`
    connections to the URL patterns defined in the `websocket_urlpatterns` list of
    the `chat.routing` module.
  id: totrans-131
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 为`websocket`协议创建一个新的路由。你使用`URLRouter`将`websocket`连接映射到`chat.routing`模块中定义的`websocket_urlpatterns`列表中的URL模式。
- en: '`AuthMiddlewareStack` as a wrapper function for the URL router. The `AuthMiddlewareStack`
    class provided by Channels supports standard Django authentication, where the
    user details are stored in the session. Later, you will access the user instance
    in the scope of the consumer to identify the user who sends a message.'
  id: totrans-132
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`AuthMiddlewareStack`作为一个URL路由器的包装函数。由Channels提供的`AuthMiddlewareStack`类支持标准的Django认证，其中用户详细信息存储在会话中。稍后，你将在消费者作用域内访问用户实例以识别发送消息的用户。'
- en: Note that the `websocket_urlpatterns` import is below the `get_asgi_application()`
    function call. This is needed to ensure the application registry is populated
    before importing code that may import ORM models.
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，`websocket_urlpatterns`的导入位于`get_asgi_application()`函数调用下方。这是为了确保在导入可能导入ORM模型的代码之前，应用程序注册已填充。
- en: Now that we have a functioning WebSocket consumer that is available through
    a URL, we can implement the WebSocket client.
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经有一个通过URL可用的功能WebSocket消费者，我们可以实现WebSocket客户端。
- en: Implementing the WebSocket client
  id: totrans-135
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 实现WebSocket客户端
- en: So far, you have created the `course_chat_room` view and its corresponding template
    for students to access the course chat room. You have implemented a WebSocket
    consumer for the chat server and tied it with URL routing. Now, you need to build
    a WebSocket client to establish a connection with the WebSocket in the course
    chat room template and be able to send/receive messages.
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，你已经创建了`course_chat_room`视图及其对应的模板，以便学生访问课程聊天室。你已经实现了聊天服务器的WebSocket消费者并将其与URL路由绑定。现在，你需要构建一个WebSocket客户端以与课程聊天室模板中的WebSocket建立连接，并能够发送/接收消息。
- en: You are going to implement the WebSocket client with JavaScript to open and
    maintain a connection in the browser, and you will interact with the **Document
    Object Model** (**DOM**) using JavaScript.
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 你将使用JavaScript实现WebSocket客户端，以在浏览器中打开并维护连接，并且你将使用JavaScript与**文档对象模型**（**DOM**）交互。
- en: 'You will perform the following tasks related to the WebSocket client:'
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 你将执行以下与WebSocket客户端相关的任务：
- en: Open a WebSocket connection with the server when the page is loaded.
  id: totrans-139
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 当页面加载时，打开与服务器的WebSocket连接。
- en: Add messages to an HTML container when data is received through the WebSocket.
  id: totrans-140
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 当通过WebSocket接收到数据时，向HTML容器添加消息。
- en: Attach a listener to the submit button to send messages through the WebSocket
    when the user clicks the **SEND** button or presses the *Enter* key.
  id: totrans-141
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将监听器附加到提交按钮上，以便在用户点击**发送**按钮或按下*Enter*键时通过WebSocket发送消息。
- en: Let’s start by opening the WebSocket connection.
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们从打开WebSocket连接开始。
- en: 'Edit the `chat/room.html` template of the `chat` application and modify the
    `include_js` and `domready` blocks, as follows:'
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 编辑`chat/room.html`模板的`chat`应用程序，并修改`include_js`和`domready`块，如下所示：
- en: '[PRE16]'
  id: totrans-144
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: In the `include_js` block, you use the `json_script` template filter to securely
    use the value of `course.id` with JavaScript. The `json_script` template filter
    provided by Django outputs a Python object as JSON, wrapped in a `<script>` tag,
    so that you can safely use it with JavaScript. The code `{{ course.id|json_script:"course-id"
    }}` is rendered as `<script id="course-id" type="application/json">6</script>`.
    This value is then retrieved in the `domready` block by parsing the content of
    the element with `id="course-id"` using `JSON.parse()`. This is the safe way to
    use Python objects in JavaScript.
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 在 `include_js` 块中，您使用 `json_script` 模板过滤器安全地使用 `course.id` 的值与 JavaScript 一起使用。Django
    提供的 `json_script` 模板过滤器将 Python 对象作为 JSON 输出，并用 `<script>` 标签包裹，这样您就可以安全地与 JavaScript
    一起使用。代码 `{{ course.id|json_script:"course-id" }}` 被渲染为 `<script id="course-id"
    type="application/json">6</script>`。然后，在 `domready` 块中，通过使用 `JSON.parse()` 解析具有
    `id="course-id"` 的元素的文本内容来检索此值。这是在 JavaScript 中安全使用 Python 对象的方法。
- en: The `json_script` template filter securely encodes Python objects as JSON and
    safely embeds them in a `<script>` HTML tag, protecting against **cross-site scripting**
    (**XSS**) attacks by escaping potentially harmful characters.
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: '`json_script` 模板过滤器安全地将 Python 对象编码为 JSON，并安全地将其嵌入到 `<script>` HTML 标签中，通过转义潜在的有害字符来防止
    **跨站脚本攻击**（**XSS**）。'
- en: You can find more information about the `json_script` template filter at [https://docs.djangoproject.com/en/5.0/ref/templates/builtins/#json-script](https://docs.djangoproject.com/en/5.0/ref/templates/builtins/#json-script).
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以在 [https://docs.djangoproject.com/en/5.0/ref/templates/builtins/#json-script](https://docs.djangoproject.com/en/5.0/ref/templates/builtins/#json-script)
    找到有关 `json_script` 模板过滤器的更多信息。
- en: In the `domready` block, you define an URL with the WebSocket protocol, which
    looks like `ws://` (or `wss://` for secure WebSockets, just like `https://`).
    You build the URL using the current location of the browser, which you obtain
    from `window.location.host`. The rest of the URL is built with the path for the
    chat room URL pattern that you defined in the `routing.py` file of the `chat`
    application.
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 在 `domready` 块中，您定义一个使用 WebSocket 协议的 URL，它看起来像 `ws://`（或者对于安全的 WebSocket，像
    `https://` 一样，使用 `wss://`）。您使用浏览器当前的位置构建 URL，您可以从 `window.location.host` 获取它。其余的
    URL 使用您在 `chat` 应用的 `routing.py` 文件中定义的聊天室 URL 模式路径构建。
- en: You write the URL instead of building it with a resolver because Channels does
    not provide a way to reverse URLs. You use the current course `ID` to generate
    the URL for the current course and store the URL in a new constant named `url`.
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 您直接写入 URL 而不是使用解析器构建它，因为 Channels 不提供反转 URL 的方法。您使用当前课程的 `ID` 生成当前课程的 URL，并将
    URL 存储在名为 `url` 的新常量中。
- en: You then open a WebSocket connection to the stored URL using `new` `WebSocket(url)`.
    You assign the instantiated WebSocket client object to the new constant `chatSocket`.
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 然后您使用 `new` `WebSocket(url)` 打开到存储的 URL 的 WebSocket 连接。您将实例化的 WebSocket 客户端对象分配给新的常量
    `chatSocket`。
- en: You have created a WebSocket consumer, you have included routing for it, and
    you have implemented a basic WebSocket client. Let’s try the initial version of
    your chat.
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 您已创建 WebSocket 消费者，为其添加了路由，并实现了一个基本的 WebSocket 客户端。让我们尝试您的聊天初始版本。
- en: 'Start the development server using the following command:'
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 使用以下命令启动开发服务器：
- en: '[PRE17]'
  id: totrans-153
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'Open the URL `http://127.0.0.1:8000/chat/room/1/` in your browser, replacing
    `1` with the `id` of an existing course in the database. Take a look at the console
    output. Besides the HTTP `GET` requests for the page and its static files, you
    should see two lines, including `WebSocket HANDSHAKING` and `WebSocket CONNECT`,
    like the following output:'
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 在您的浏览器中打开 URL `http://127.0.0.1:8000/chat/room/1/`，将 `1` 替换为数据库中现有课程的 `id`。查看控制台输出。除了对页面及其静态文件的
    HTTP `GET` 请求外，您应该看到两行，包括 `WebSocket HANDSHAKING` 和 `WebSocket CONNECT`，如下所示输出：
- en: '[PRE18]'
  id: totrans-155
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: The Daphne server listens for incoming socket connections using a standard TCP
    socket. The handshake is the bridge from HTTP to WebSockets. In the handshake,
    details of the connection are negotiated and either party can close the connection
    before completion. Remember that you are using `self.accept()` to accept any connection
    in the `connect()` method of the `ChatConsumer` class, implemented in the `consumers.py`
    file of the `chat` application. The connection is accepted, and therefore, you
    see the `WebSocket CONNECT` message in the console.
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: Daphne 服务器使用标准 TCP 套接字监听传入的套接字连接。握手是 HTTP 到 WebSocket 的桥梁。在握手过程中，连接的详细信息被协商，任何一方都可以在完成前关闭连接。请记住，您在
    `ChatConsumer` 类的 `connect()` 方法中使用 `self.accept()` 接受任何连接，该类在 `chat` 应用的 `consumers.py`
    文件中实现。连接被接受，因此您在控制台看到 `WebSocket CONNECT` 消息。
- en: If you use the browser developer tools to track network connections, you can
    also see information for the WebSocket connection that has been established.
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您使用浏览器开发者工具跟踪网络连接，您还可以看到已建立的WebSocket连接的信息。
- en: 'It should look like *Figure 16.5*:'
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 它应该看起来像*图16.5*：
- en: '![Graphical user interface, application, table  Description automatically generated](img/B21088_16_05.png)'
  id: totrans-159
  prefs: []
  type: TYPE_IMG
  zh: '![图形用户界面、应用程序、表格  自动生成的描述](img/B21088_16_05.png)'
- en: 'Figure 16.5: The browser developer tools showing that the WebSocket connection
    has been established'
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 图16.5：浏览器开发者工具显示已建立WebSocket连接
- en: 'Now that you can connect to the WebSocket, it’s time to interact with it. You
    will implement the methods to handle common events, such as receiving a message
    and closing the connection. Edit the `chat/room.html` template of the `chat` application
    and modify the `domready` block, as follows:'
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 现在您已经可以连接到WebSocket，是时候与之交互了。您将实现处理常见事件的方法，例如接收消息和关闭连接。编辑`chat/room.html`模板的`chat`应用程序并修改`domready`块，如下所示：
- en: '[PRE19]'
  id: totrans-162
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'In this code, you define the following events for the WebSocket client:'
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 在此代码中，您为WebSocket客户端定义以下事件：
- en: '`onmessage`: Fired when data is received through the WebSocket. You parse the
    message, which you expect in JSON format, and access its `message` attribute.
    You then append a new `<div>` element with the message received to the HTML element
    with the `chat` ID. This will add new messages to the chat log, while keeping
    all previous messages that have been added to the log. You scroll the chat log
    `<div>` to the bottom to ensure that the new message gets visibility. You achieve
    this by scrolling to the total scrollable height of the chat log, which can be
    obtained by accessing its `scrollHeight` attribute.'
  id: totrans-164
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`onmessage`：当通过WebSocket接收到数据时触发。您解析消息，您期望其以JSON格式，并访问其`message`属性。然后您将一个新的`<div>`元素与接收到的消息附加到具有`chat`
    ID的HTML元素。这将向聊天记录添加新消息，同时保留已添加到日志的所有先前消息。您将聊天记录的`<div>`滚动到最底部以确保新消息可见。您通过滚动到聊天记录的总可滚动高度来实现这一点，这可以通过访问其`scrollHeight`属性来获得。'
- en: '`onclose`: Fired when the connection with the WebSocket is closed. You don’t
    expect to close the connection, and therefore, you write the error `Chat socket
    closed unexpectedly` to the console log if this happens.'
  id: totrans-165
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`onclose`：当WebSocket连接关闭时触发。您不期望关闭连接，因此如果发生这种情况，您将错误`Chat socket closed unexpectedly`写入控制台日志。'
- en: You have implemented the action to display the message when a new message is
    received. You need to implement the functionality to send messages to the socket
    as well.
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 您已实现了在接收到新消息时显示消息的动作。您还需要实现向套接字发送消息的功能。
- en: 'Edit the `chat/room.html` template of the `chat` application and add the following
    JavaScript code to the bottom of the `domready` block:'
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 编辑`chat/room.html`模板的`chat`应用程序，并将以下JavaScript代码添加到`domready`块的底部：
- en: '[PRE20]'
  id: totrans-168
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'In this code, you define an event listener for the `click` event of the submit
    button, which you select by its ID `chat-message-submit`. When the button is clicked,
    you perform the following actions:'
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 在此代码中，您为提交按钮的`click`事件定义了一个事件监听器，您通过其ID `chat-message-submit`选择该按钮。当按钮被点击时，您执行以下操作：
- en: You read the message entered by the user from the value of the text input element
    with the ID `chat-message-input`.
  id: totrans-170
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 您从具有ID `chat-message-input`的文本输入元素的值中读取用户输入的消息。
- en: You check whether the message has any content with `if(message)`.
  id: totrans-171
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 您使用`if(message)`检查消息是否有内容。
- en: 'If the user has entered a message, you form JSON content such as `{''message'':
    ''string entered by the user''}` by using `JSON.stringify()`.'
  id: totrans-172
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '如果用户已输入消息，您可以使用`JSON.stringify()`形成如`{''message'': ''用户输入的字符串''}`这样的JSON内容。'
- en: You send the JSON content through the WebSocket, calling the `send()` method
    of `chatSocket` client.
  id: totrans-173
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 您通过调用`chatSocket`客户端的`send()`方法将JSON内容通过WebSocket发送。
- en: You clear the contents of the text input by setting its value to an empty string
    with `input.value = ''`.
  id: totrans-174
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 您通过将文本输入的值设置为空字符串`input.value = ''`来清除文本输入的内容。
- en: You return the focus to the text input with `input.focus()` so that the user
    can write a new message straight away.
  id: totrans-175
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 您使用`input.focus()`将焦点返回到文本输入，以便用户可以立即写入新消息。
- en: The user is now able to send messages using the text input and by clicking the
    submit button.
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 用户现在可以使用文本输入和点击提交按钮来发送消息。
- en: To improve the user experience, you will give focus to the text input when the
    page loads, allowing users to begin typing immediately without needing to click
    on it first. You will also capture keyboard keypress events to identify the *Enter*
    key and fire the `click` event on the submit button. Users will be able to either
    click the button or press the *Enter* key to send a message.
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 为了提高用户体验，当页面加载时，你将焦点放在文本输入框上，使用户可以立即开始输入，而无需先点击它。你还将捕获键盘按键事件以识别*Enter*键，并在提交按钮上触发`click`事件。用户可以通过点击按钮或按*Enter*键来发送消息。
- en: 'Edit the `chat/room.html` template of the `chat` application and add the following
    JavaScript code to the bottom of the `domready` block:'
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: 编辑`chat`应用程序的`chat/room.html`模板，并将以下JavaScript代码添加到`domready`块的底部：
- en: '[PRE21]'
  id: totrans-179
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'In this code, you also define a function for the `keypress` event of the `input`
    element. For any key that the user presses, you perform the following actions:'
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: 在此代码中，你还定义了一个用于`input`元素的`keypress`事件函数。对于用户按下的任何键，你执行以下操作：
- en: You check whether its key is *Enter*.
  id: totrans-181
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 你检查其键是否为*Enter*。
- en: 'If the *Enter* key is pressed:'
  id: totrans-182
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果按下*Enter*键：
- en: You prevent the default behavior for this key with `event.preventDefault()`.
  id: totrans-183
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 你可以通过`event.preventDefault()`来阻止此键的默认行为。
- en: Then you fire the `click` event on the submit button to send the message to
    the WebSocket.
  id: totrans-184
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后你在提交按钮上触发`click`事件，将消息发送到WebSocket。
- en: Outside of the event handler, in the main JavaScript code for the `domready`
    block, you give the focus to the text input with `input.focus()`. By doing so,
    when the DOM is loaded, the focus will be set on the `input` element for the user
    to type a message.
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: 在事件处理器外部，在`domready`块的JavaScript主代码中，你使用`input.focus()`将焦点放在文本输入框上。这样做的话，当DOM加载完成后，焦点将设置在`input`元素上，以便用户可以输入信息。
- en: 'The `domready` block of the `chat/room.html` template should now look as follows:'
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: '`chat/room.html`模板的`domready`块现在应该如下所示：'
- en: '[PRE22]'
  id: totrans-187
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: Open the URL `http://127.0.0.1:8000/chat/room/1/` in your browser, replacing
    `1` with the `id` of an existing course in the database. With a logged-in user
    who is enrolled in the course, write some text in the input field and click the
    **SEND** button or press the *Enter* key.
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: 在你的浏览器中打开URL `http://127.0.0.1:8000/chat/room/1/`，将`1`替换为数据库中现有课程的`id`。对于已登录并注册该课程的用户，在输入框中输入一些文本，然后点击**发送**按钮或按*Enter*键。
- en: 'You will see that your message appears in the chat log:'
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: 你将看到你的消息出现在聊天记录中：
- en: '![](img/B21088_16_06.png)'
  id: totrans-190
  prefs: []
  type: TYPE_IMG
  zh: '![](img/B21088_16_06.png)'
- en: 'Figure 16.6: The chat room page, including messages sent through the WebSocket'
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: 图16.6：聊天室页面，包括通过WebSocket发送的消息
- en: Great! The message has been sent through the WebSocket and the `ChatConsumer`
    consumer has received the message and has sent it back through the WebSocket.
    The `chatSocket` client has received a message event and the `onmessage` function
    has been fired, adding the message to the chat log.
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: 太好了！消息已经通过WebSocket发送，`ChatConsumer`消费者已经收到消息并通过WebSocket将其发送回来。`chatSocket`客户端收到消息事件并触发`onmessage`函数，将消息添加到聊天记录中。
- en: You have implemented the functionality with a WebSocket consumer and a WebSocket
    client to establish client/server communication and can send or receive events.
    However, the chat server is not able to broadcast messages to other clients. If
    you open a second browser tab and enter a message, the message will not appear
    on the first tab. In order to build communication between consumers, you have
    to enable a channel layer.
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: 你已经使用WebSocket消费者和WebSocket客户端实现了功能，以建立客户端/服务器通信并可以发送或接收事件。然而，聊天服务器无法向其他客户端广播消息。如果你打开第二个浏览器标签页并输入一条消息，该消息将不会出现在第一个标签页上。为了在消费者之间建立通信，你必须启用通道层。
- en: Enabling a channel layer
  id: totrans-194
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 启用通道层
- en: Channel layers allow you to communicate between different instances of an application.
    A channel layer is the transport mechanism that allows multiple consumer instances
    to communicate with each other and with other parts of Django.
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: 通道层允许你在应用程序的不同实例之间进行通信。通道层是允许多个消费者实例相互通信以及与Django的其他部分通信的传输机制。
- en: In your chat server, you plan to have multiple instances of the `ChatConsumer`
    consumer for the same course chat room. Each student who joins the chat room will
    instantiate the WebSocket client in their browser, and that will open a connection
    with an instance of the WebSocket consumer. You need a common channel layer to
    distribute messages between consumers.
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: 在你的聊天服务器中，你计划为同一课程聊天室创建多个 `ChatConsumer` 消费者实例。每个加入聊天室的学生将在他们的浏览器中实例化 WebSocket
    客户端，这将与 WebSocket 消费者实例建立连接。你需要一个公共通道层来在消费者之间分配消息。
- en: Channels and groups
  id: totrans-197
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 通道和组
- en: 'Channel layers provide two abstractions to manage communications: channels
    and groups:'
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: 通道层提供了两个抽象来管理通信：通道和组：
- en: '**Channel**: You can think of a channel as an inbox where messages can be sent
    or as a task queue. Each channel has a name. Messages are sent to a channel by
    anyone who knows the channel name and then given to consumers listening on that
    channel.'
  id: totrans-199
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**通道**：你可以将通道想象成一个可以发送或接收消息的收件箱，或者是一个任务队列。每个通道都有一个名称。消息可以通过知道通道名称的任何人发送到通道，然后传递给在该通道上监听的消费者。'
- en: '**Group**: Multiple channels can be grouped into a group. Each group has a
    name. A channel can be added or removed from a group by anyone who knows the group
    name. Using the group name, you can also send a message to all channels in the
    group.'
  id: totrans-200
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**组**：多个通道可以被组合成一个组。每个组都有一个名称。任何人都可以通过知道组名称来向组中添加或移除通道。使用组名称，你还可以向组中的所有通道发送消息。'
- en: You will work with channel groups to implement the chat server. By creating
    a channel group for each course chat room, the `ChatConsumer` instances will be
    able to communicate with each other.
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: 你将通过使用通道组来实现聊天服务器。通过为每个课程聊天室创建一个通道组，`ChatConsumer` 实例将能够相互通信。
- en: Let’s add a channel layer to our project.
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们向我们的项目中添加一个通道层。
- en: Setting up a channel layer with Redis
  id: totrans-203
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用 Redis 设置通道层
- en: Redis is the preferred option for a channel layer, though Channels has support
    for other types of channel layers. Redis works as the communication store for
    the channel layer. Remember that you already used Redis in *Chapter 7*, *Tracking
    User Actions*, *Chapter 10*, *Extending Your Shop*, and *Chapter 14*, *Rendering
    and Caching Content*.
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然 Channels 支持其他类型的通道层，但 Redis 是通道层的首选选项。Redis 作为通道层的通信存储。记住，你已经在 *第 7 章*，*跟踪用户行为*，*第
    10 章*，*扩展你的商店* 和 *第 14 章*，*渲染和缓存内容* 中使用了 Redis。
- en: If you haven’t installed Redis yet, you can find installation instructions in
    *Chapter 7*, *Tracking User Actions*.
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你还没有安装 Redis，你可以在 *第 7 章*，*跟踪用户行为* 中找到安装说明。
- en: 'To use Redis as a channel layer, you have to install the `channels-redis` package.
    Install `channels-redis` in your virtual environment with the following command:'
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: 要使用 Redis 作为通道层，你必须安装 `channels-redis` 包。使用以下命令在你的虚拟环境中安装 `channels-redis`：
- en: '[PRE23]'
  id: totrans-207
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'Edit the `settings.py` file of the `educa` project and add the following code
    to it:'
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: 编辑 `educa` 项目的 `settings.py` 文件，并向其中添加以下代码：
- en: '[PRE24]'
  id: totrans-209
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: The `CHANNEL_LAYERS` setting defines the configuration for the channel layers
    available to the project. You define a default channel layer using the `RedisChannelLayer`
    backend provided by `channels-redis` and specify the host `127.0.0.1` and the
    port `6379`, on which Redis is running.
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: '`CHANNEL_LAYERS` 设置定义了项目可用的通道层的配置。你使用 `channels-redis` 提供的 `RedisChannelLayer`
    后端定义一个默认的通道层，并指定 Redis 运行的主机 `127.0.0.1` 和端口 `6379`。'
- en: 'Let’s try the channel layer. Initialize the Redis Docker container using the
    following command:'
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们尝试通道层。使用以下命令初始化 Redis Docker 容器：
- en: '[PRE25]'
  id: totrans-212
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: If you want to run the command in the background (in detached mode) you can
    use the `-d` option.
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你想在后台（分离模式）运行命令，你可以使用 `-d` 选项。
- en: 'Open the Django shell using the following command from the project directory:'
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
  zh: 使用以下命令从项目目录中打开 Django shell：
- en: '[PRE26]'
  id: totrans-215
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: 'To verify that the channel layer can communicate with Redis, write the following
    code to send a message to a test channel named `test_channel` and receive it back:'
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
  zh: 为了验证通道层可以与 Redis 通信，编写以下代码向名为 `test_channel` 的测试通道发送消息并接收它：
- en: '[PRE27]'
  id: totrans-217
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: 'You should get the following output:'
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
  zh: 你应该得到以下输出：
- en: '[PRE28]'
  id: totrans-219
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: In the previous code, you send a message to a test channel through the channel
    layer, and then you retrieve it from the channel layer. The channel layer is communicating
    successfully with Redis.
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的代码中，你通过通道层向一个测试通道发送消息，然后从通道层检索它。通道层正在成功与 Redis 通信。
- en: Next, we will add the channel layer to our project.
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们将向我们的项目中添加通道层。
- en: Updating the consumer to broadcast messages
  id: totrans-222
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 更新消费者以广播消息
- en: Let’s edit the `ChatConsumer` consumer to use the channel layer we have implemented
    with Redis. You will use a channel group for each course chat room. Therefore,
    you will use the course `id` to build the group name. `ChatConsumer` instances
    will know the group name and will be able to communicate with each other.
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们编辑 `ChatConsumer` 消费者，使用我们用 Redis 实现的通道层。对于每个课程聊天室，你将使用一个通道组。因此，你将使用课程 `id`
    来构建组名。`ChatConsumer` 实例将知道组名，并且能够相互通信。
- en: 'Edit the `consumers.py` file of the `chat` application, import the `async_to_sync()`
    function, and modify the `connect()` method of the `ChatConsumer` class, as follows:'
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
  zh: 编辑 `chat` 应用的 `consumers.py` 文件，导入 `async_to_sync()` 函数，并修改 `ChatConsumer` 类的
    `connect()` 方法，如下所示：
- en: '[PRE29]'
  id: totrans-225
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: In this code, you import the `async_to_sync()` helper function to wrap calls
    to asynchronous channel layer methods. `ChatConsumer` is a synchronous `WebsocketConsumer`
    consumer, but it needs to call asynchronous methods of the channel layer.
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
  zh: 在此代码中，你导入 `async_to_sync()` 辅助函数来包装对异步通道层方法的调用。`ChatConsumer` 是一个同步的 `WebsocketConsumer`
    消费者，但它需要调用通道层的异步方法。
- en: 'In the new `connect()` method, you perform the following tasks:'
  id: totrans-227
  prefs: []
  type: TYPE_NORMAL
  zh: 在新的 `connect()` 方法中，你执行以下任务：
- en: You retrieve the course `id` from the scope to know the course that the chat
    room is associated with. You access `self.scope['url_route']['kwargs']['course_id']`
    to retrieve the `course_id` parameter from the URL. Every consumer has a scope
    with information about its connection, arguments passed by the URL, and the authenticated
    user, if any.
  id: totrans-228
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 你从作用域中检索课程 `id`，以了解聊天室关联的课程。你通过访问 `self.scope['url_route']['kwargs']['course_id']`
    来从 URL 中检索 `course_id` 参数。每个消费者都有一个包含其连接信息、通过 URL 传递的参数以及（如果有）认证用户的作用域。
- en: You build the group name with the `id` of the course that the group corresponds
    to. Remember that you will have a channel group for each course chat room. You
    store the group name in the `room_group_name` attribute of the consumer.
  id: totrans-229
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 你使用与组对应的课程的 `id` 来构建组名。记住，你将为每个课程聊天室有一个通道组。你将组名存储在消费者的 `room_group_name` 属性中。
- en: You join the group by adding the current channel to the group. You obtain the
    channel name from the `channel_name` attribute of the consumer. You use the `group_add`
    method of the channel layer to add the channel to the group. You use the `async_to_sync()`
    wrapper to use the channel layer asynchronous method.
  id: totrans-230
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 你通过将当前通道添加到组中来加入组。你从消费者的 `channel_name` 属性中获取通道名称。你使用通道层的 `group_add` 方法将通道添加到组中。你使用
    `async_to_sync()` 包装器来使用通道层的异步方法。
- en: You keep the `self.accept()` call to accept the WebSocket connection.
  id: totrans-231
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 你保留 `self.accept()` 调用来接受 WebSocket 连接。
- en: When the `ChatConsumer` consumer receives a new WebSocket connection, it adds
    the channel to the group associated with the course in its scope. The consumer
    is now able to receive any messages sent to the group.
  id: totrans-232
  prefs: []
  type: TYPE_NORMAL
  zh: 当 `ChatConsumer` 消费者接收到新的 WebSocket 连接时，它将其通道添加到其作用域内与课程关联的组中。消费者现在能够接收发送到该组的任何消息。
- en: 'In the same `consumers.py` file, modify the `disconnect()` method of the `ChatConsumer`
    class, as follows:'
  id: totrans-233
  prefs: []
  type: TYPE_NORMAL
  zh: 在相同的 `consumers.py` 文件中，修改 `ChatConsumer` 类的 `disconnect()` 方法，如下所示：
- en: '[PRE30]'
  id: totrans-234
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: When the connection is closed, you call the `group_discard()` method of the
    channel layer to leave the group. You use the `async_to_sync()` wrapper to use
    the channel layer asynchronous method.
  id: totrans-235
  prefs: []
  type: TYPE_NORMAL
  zh: 当连接关闭时，你调用通道层的 `group_discard()` 方法来离开组。你使用 `async_to_sync()` 包装器来使用通道层的异步方法。
- en: 'In the same `consumers.py` file, modify the `receive()` method of the `ChatConsumer`
    class, as follows:'
  id: totrans-236
  prefs: []
  type: TYPE_NORMAL
  zh: 在相同的 `consumers.py` 文件中，修改 `ChatConsumer` 类的 `receive()` 方法，如下所示：
- en: '[PRE31]'
  id: totrans-237
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: 'When you receive a message from the WebSocket connection, instead of sending
    the message to the associated channel, you send the message to the group. You
    do this by calling the `group_send()` method of the channel layer. You use the
    `async_to_sync()` wrapper to use the channel layer asynchronous method. You pass
    the following information in the event sent to the group:'
  id: totrans-238
  prefs: []
  type: TYPE_NORMAL
  zh: 当你从 WebSocket 连接接收到消息时，而不是将消息发送到关联的通道，你将消息发送到组。你通过调用通道层的 `group_send()` 方法来完成此操作。你使用
    `async_to_sync()` 包装器来使用通道层的异步方法。你将以下信息传递给发送到组的事件：
- en: '`type`: The event type. This is a special key that corresponds to the name
    of the method that should be invoked on consumers that receive the event. You
    can implement a method in the consumer named the same as the message type so that
    it gets executed every time a message with that specific type is received.'
  id: totrans-239
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`type`：事件类型。这是一个特殊键，对应于接收事件的消费者应该调用的方法名称。你可以在消费者中实现一个与消息类型相同名称的方法，这样每次接收到具有该特定类型的消息时，它都会被执行。'
- en: '`message`: The actual message you are sending.'
  id: totrans-240
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`message`：你实际发送的消息。'
- en: 'In the same `consumers.py` file, add a new `chat_message()` method in the `ChatConsumer`
    class, as follows:'
  id: totrans-241
  prefs: []
  type: TYPE_NORMAL
  zh: 在相同的 `consumers.py` 文件中，在 `ChatConsumer` 类中添加一个新的 `chat_message()` 方法，如下所示：
- en: '[PRE32]'
  id: totrans-242
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: You name this method `chat_message()` to match the `type` key that is sent to
    the channel group when a message is received from the WebSocket. When a message
    with type `chat_message` is sent to the group, all consumers subscribed to the
    group will receive the message and will execute the `chat_message()` method. In
    the `chat_message()` method, you send the event message received to the WebSocket.
  id: totrans-243
  prefs: []
  type: TYPE_NORMAL
  zh: 你将此方法命名为 `chat_message()` 以匹配从WebSocket接收消息时发送到通道组的 `type` 键。当向组发送类型为 `chat_message`
    的消息时，所有订阅该组的消费者将接收到消息并执行 `chat_message()` 方法。在 `chat_message()` 方法中，你将接收到的消息事件发送到WebSocket。
- en: 'The complete `consumers.py` file should now look like this:'
  id: totrans-244
  prefs: []
  type: TYPE_NORMAL
  zh: 完整的 `consumers.py` 文件现在应该看起来像这样：
- en: '[PRE33]'
  id: totrans-245
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: You have implemented a channel layer in `ChatConsumer`, allowing consumers to
    broadcast messages and communicate with each other.
  id: totrans-246
  prefs: []
  type: TYPE_NORMAL
  zh: 你已经在 `ChatConsumer` 中实现了通道层，允许消费者广播消息并相互通信。
- en: 'Run the development server with the following command:'
  id: totrans-247
  prefs: []
  type: TYPE_NORMAL
  zh: 使用以下命令运行开发服务器：
- en: '[PRE34]'
  id: totrans-248
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: Open the URL `http://127.0.0.1:8000/chat/room/1/` in your browser, replacing
    `1` with the `id` of an existing course in the database. Write a message and send
    it. Then, open a second browser window and access the same URL. Send a message
    from each browser window.
  id: totrans-249
  prefs: []
  type: TYPE_NORMAL
  zh: 在你的浏览器中打开URL `http://127.0.0.1:8000/chat/room/1/`，将 `1` 替换为数据库中现有课程的 `id`。写一条消息并发送。然后，打开第二个浏览器窗口并访问相同的URL。从每个浏览器窗口发送一条消息。
- en: 'The result should look like this:'
  id: totrans-250
  prefs: []
  type: TYPE_NORMAL
  zh: 结果应该看起来像这样：
- en: '![](img/B21088_16_07.png)'
  id: totrans-251
  prefs: []
  type: TYPE_IMG
  zh: '![](img/B21088_16_07.png)'
- en: 'Figure 16.7: The chat room page with messages sent from different browser windows'
  id: totrans-252
  prefs: []
  type: TYPE_NORMAL
  zh: 图16.7：来自不同浏览器窗口发送的消息的聊天室页面
- en: You will see that the first message is only displayed in the first browser window.
    When you open a second browser window, messages sent in any of the browser windows
    are displayed in both of them. When you open a new browser window and access the
    chat room URL, a new WebSocket connection is established between the JavaScript
    WebSocket client in the browser and the WebSocket consumer in the server. Each
    channel gets added to the group associated with the course ID and passed through
    the URL to the consumer. Messages are sent to the group and received by all consumers.
  id: totrans-253
  prefs: []
  type: TYPE_NORMAL
  zh: 你会看到第一条消息只在第一个浏览器窗口中显示。当你打开第二个浏览器窗口时，来自任何浏览器窗口的消息都会在两个窗口中显示。当你打开一个新的浏览器窗口并访问聊天室URL时，浏览器中的JavaScript
    WebSocket客户端和服务器中的WebSocket消费者之间将建立一个新的WebSocket连接。每个通道都被添加到与课程ID关联的组中，并通过URL传递给消费者。消息被发送到组，并由所有消费者接收。
- en: Next, we are going to enrich messages with additional context.
  id: totrans-254
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们将通过添加额外的上下文来丰富消息。
- en: Adding context to the messages
  id: totrans-255
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 给消息添加上下文
- en: Now that messages can be exchanged between all users in a chat room, you probably
    want to display who sent which message and when it was sent. Let’s add some context
    to the messages.
  id: totrans-256
  prefs: []
  type: TYPE_NORMAL
  zh: 现在聊天室中的所有用户都可以互相发送消息，你可能想要显示谁发送了哪条消息以及发送的时间。让我们给消息添加一些上下文。
- en: 'Edit the `consumers.py` file of the `chat` application and implement the following
    changes:'
  id: totrans-257
  prefs: []
  type: TYPE_NORMAL
  zh: 编辑 `chat` 应用程序的 `consumers.py` 文件并实现以下更改：
- en: '[PRE35]'
  id: totrans-258
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: You now import the `timezone` module provided by Django. In the `connect()`
    method of the consumer, you retrieve the current user from the scope with `self.scope['user']`
    and store them in a new `user` attribute of the consumer.
  id: totrans-259
  prefs: []
  type: TYPE_NORMAL
  zh: 你现在导入Django提供的 `timezone` 模块。在消费者的 `connect()` 方法中，你使用 `self.scope['user']`
    从作用域中检索当前用户，并将它们存储在消费者新的 `user` 属性中。
- en: When the consumer receives a message through the WebSocket, it gets the current
    time using `timezone.now()` and passes the current `user` and `datetime` in ISO
    8601 format along with the message in the event sent to the channel group.
  id: totrans-260
  prefs: []
  type: TYPE_NORMAL
  zh: 当消费者通过WebSocket接收到消息时，它使用 `timezone.now()` 获取当前时间，并将当前 `user` 和 `datetime` 以ISO
    8601格式以及消息一起传递给发送到通道组的消息。
- en: 'Edit the `chat/room.html` template of the `chat` application and add the following
    line highlighted in bold to the `include_js` block:'
  id: totrans-261
  prefs: []
  type: TYPE_NORMAL
  zh: 编辑`chat/room.html`模板的`chat`应用，并将以下加粗的行添加到`include_js`块中：
- en: '[PRE36]'
  id: totrans-262
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: Using the `json_script` template, you safely print the username of the request
    user to use it with JavaScript.
  id: totrans-263
  prefs: []
  type: TYPE_NORMAL
  zh: 使用`json_script`模板，你安全地打印出请求用户的用户名，以便与JavaScript一起使用。
- en: 'In the `domready` block of the `chat/room.html` template, add the following
    lines highlighted in bold:'
  id: totrans-264
  prefs: []
  type: TYPE_NORMAL
  zh: 在`chat/room.html`模板的`domready`块中，添加以下加粗的行：
- en: '[PRE37]'
  id: totrans-265
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: In the new code, you safely parse the data of the element with the ID `request-user`
    and store it in the `requestUser` constant.
  id: totrans-266
  prefs: []
  type: TYPE_NORMAL
  zh: 在新代码中，你安全地解析具有ID `request-user`的元素的数据，并将其存储在`requestUser`常量中。
- en: 'Then, in the `domready` block, find the following lines:'
  id: totrans-267
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，在`domready`块中，找到以下行：
- en: '[PRE38]'
  id: totrans-268
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: 'Replace those lines with the following code:'
  id: totrans-269
  prefs: []
  type: TYPE_NORMAL
  zh: 将这些行替换为以下代码：
- en: '[PRE39]'
  id: totrans-270
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: 'In this code, you implement the following changes:'
  id: totrans-271
  prefs: []
  type: TYPE_NORMAL
  zh: 在此代码中，你实现了以下更改：
- en: You convert the `datetime` received in the message to a JavaScript `Date` object
    and format it with a specific locale.
  id: totrans-272
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 你将接收到的`datetime`转换为JavaScript的`Date`对象，并使用特定的区域设置进行格式化。
- en: You compare the username received in the message with two different constants
    as helpers to identify the user.
  id: totrans-273
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 你将接收到的消息中的用户名与两个不同的常量作为辅助工具来识别用户。
- en: The constant `source` gets the value `me` if the user sending the message is
    the current user, or `other` otherwise.
  id: totrans-274
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果发送消息的用户是当前用户，则常量`source`获取值`me`，否则获取`other`。
- en: The constant `name` gets the value `Me` if the user sending the message is the
    current user or the name of the user sending the message otherwise. You use it
    to display the name of the user sending the message.
  id: totrans-275
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果发送消息的用户是当前用户，则常量`name`获取值`Me`，否则获取发送消息用户的名称。你用它来显示发送消息用户的名称。
- en: You use the `source` value as a `class` of the main `<div>` message element
    to differentiate messages sent by the current user from messages sent by others.
    Different CSS styles are applied based on the `class` attribute. These CSS styles
    are declared in the `css/base.css` static file.
  id: totrans-276
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 你使用`source`值作为主`<div>`消息元素的`class`，以区分当前用户发送的消息和其他用户发送的消息。基于`class`属性应用不同的CSS样式。这些CSS样式在`css/base.css`静态文件中声明。
- en: You use the username and the `datetime` in the message that you append to the
    chat log.
  id: totrans-277
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 你在附加到聊天记录的消息中使用用户名和`datetime`。
- en: Open the URL `http://127.0.0.1:8000/chat/room/1/` in your browser, replacing
    `1` with the `id` of an existing course in the database. With a logged-in user
    who is enrolled in the course, write a message and send it.
  id: totrans-278
  prefs: []
  type: TYPE_NORMAL
  zh: 在你的浏览器中打开URL `http://127.0.0.1:8000/chat/room/1/`，将`1`替换为数据库中现有课程的`id`。使用已登录并注册该课程的用户，写一条消息并发送。
- en: Then, open a second browser window in incognito mode to prevent the use of the
    same session. Log in with a different user, also enrolled in the same course,
    and send a message.
  id: totrans-279
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，在隐身模式下打开第二个浏览器窗口，以防止使用相同的会话。使用不同用户登录，该用户也注册了同一课程，并发送一条消息。
- en: 'You will be able to exchange messages using the two different users and see
    the user and time, with a clear distinction between messages sent by the user
    and messages sent by others. The conversation between two users should look similar
    to the following one:'
  id: totrans-280
  prefs: []
  type: TYPE_NORMAL
  zh: 你将能够使用两个不同的用户交换消息，并看到用户和时间，明确区分用户发送的消息和其他用户发送的消息。两个用户之间的对话应该看起来类似于以下的一个：
- en: '![](img/B21088_16_08.png)'
  id: totrans-281
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/B21088_16_08.png)'
- en: 'Figure 16.8: The chat room page with messages from two different user sessions'
  id: totrans-282
  prefs: []
  type: TYPE_NORMAL
  zh: 图16.8：包含来自两个不同用户会话的消息的聊天室页面
- en: Great! You have built a functional real-time chat application using Channels.
    Next, you will learn how to improve the chat consumer by making it fully asynchronous.
  id: totrans-283
  prefs: []
  type: TYPE_NORMAL
  zh: 太好了！你已经使用Channels构建了一个功能性的实时聊天应用。接下来，你将学习如何通过使其完全异步来改进聊天消费者。
- en: Modifying the consumer to be fully asynchronous
  id: totrans-284
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 将消费者修改为完全异步
- en: The `ChatConsumer` you have implemented inherits from the synchronous base class
    `WebsocketConsumer`. Synchronous consumers operate in a way that each request
    must be processed in sequence, one after the other. Synchronous consumers are
    convenient for accessing Django models and calling regular synchronous I/O functions.
    However, asynchronous consumers perform better because of their ability to perform
    non-blocking operations, moving to another task without waiting for the first
    operation to complete. They don’t require additional threads when handling requests,
    thus reducing wait times and increasing the ability to scale to more users and
    requests simultaneously.
  id: totrans-285
  prefs: []
  type: TYPE_NORMAL
  zh: 你实现的 `ChatConsumer` 类继承自同步基类 `WebsocketConsumer`。同步消费者以这种方式操作，即每个请求必须按顺序依次处理。同步消费者便于访问
    Django 模型并调用常规同步 I/O 函数。然而，异步消费者由于能够执行非阻塞操作，可以在等待第一个操作完成之前转移到另一个任务，因此性能更佳。它们在处理请求时不需要额外的线程，从而减少了等待时间并增加了同时处理更多用户和请求的能力。
- en: Given that you are already using the asynchronous channel layer functions, you
    can seamlessly rewrite the `ChatConsumer` class to make it asynchronous.
  id: totrans-286
  prefs: []
  type: TYPE_NORMAL
  zh: 既然你已经使用了异步通道层函数，你可以无缝地重写 `ChatConsumer` 类以使其异步。
- en: 'Edit the `consumers.py` file of the `chat` application and implement the following
    changes:'
  id: totrans-287
  prefs: []
  type: TYPE_NORMAL
  zh: 编辑 `chat` 应用程序的 `consumers.py` 文件并实现以下更改：
- en: '[PRE40]'
  id: totrans-288
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: 'You have implemented the following changes:'
  id: totrans-289
  prefs: []
  type: TYPE_NORMAL
  zh: 你实现了以下更改：
- en: The `ChatConsumer` consumer now inherits from the `AsyncWebsocketConsumer` class
    to implement asynchronous calls.
  id: totrans-290
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`ChatConsumer` 消费者现在继承自 `AsyncWebsocketConsumer` 类以实现异步调用。'
- en: You have changed the definition of all methods from `def` to `async def`.
  id: totrans-291
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 你将所有方法的定义从 `def` 改为了 `async def`。
- en: You use `await` to call asynchronous functions that perform I/O operations.
  id: totrans-292
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 你使用 `await` 调用执行 I/O 操作的异步函数。
- en: You no longer use the `async_to_sync()` helper function when calling methods
    on the channel layer.
  id: totrans-293
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 当你在通道层上调用方法时，不再使用 `async_to_sync()` 辅助函数。
- en: Open the URL `http://127.0.0.1:8000/chat/room/1/` with two different browser
    windows again and verify that the chat server still works. The chat server is
    now fully asynchronous!
  id: totrans-294
  prefs: []
  type: TYPE_NORMAL
  zh: 再次用两个不同的浏览器窗口打开 URL `http://127.0.0.1:8000/chat/room/1/` 并验证聊天服务器是否仍然正常工作。聊天服务器现在是完全异步的！
- en: Next, we are going to implement a chat history by storing messages in the database.
  id: totrans-295
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们将通过在数据库中存储消息来实现聊天历史。
- en: Persisting messages into the database
  id: totrans-296
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 将消息持久化到数据库
- en: 'Let’s enhance the chat application by adding message persistence. We will develop
    functionality to store messages in the database, allowing us to present a chat
    history to users when they join a chat room. This feature is essential for real-time
    applications, where it’s necessary to display both current and previously generated
    data. For example, consider a stock trading application: upon logging in, users
    should see not only the current stock values but also the historical values from
    the time the stock market opened.'
  id: totrans-297
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们通过添加消息持久化来增强聊天应用程序。我们将开发将消息存储在数据库中的功能，这样我们就可以在用户加入聊天室时向他们展示聊天历史。这个特性对于实时应用至关重要，在这些应用中，显示当前和以前生成数据都是必要的。例如，考虑一个股票交易应用：用户登录时，应看到不仅当前的股票价值，还应从股市开盘以来的历史价值。
- en: 'To implement the chat history functionality, we will follow these steps:'
  id: totrans-298
  prefs: []
  type: TYPE_NORMAL
  zh: 为了实现聊天历史功能，我们将遵循以下步骤：
- en: We will create Django model to store chat messages and add it to the administration
    site.
  id: totrans-299
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们将创建 Django 模型以存储聊天消息并将其添加到管理站点。
- en: We will modify the WebSocket consumer to persist messages.
  id: totrans-300
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们将修改 WebSocket 消费者以持久化消息。
- en: We will retrieve the chat history to display the latest messages when users
    enter a chat room.
  id: totrans-301
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们将检索聊天历史，以便在用户进入聊天室时显示最新消息。
- en: Let’s start by creating the message model.
  id: totrans-302
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们从创建消息模型开始。
- en: Creating a model for chat messages
  id: totrans-303
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 创建聊天消息模型
- en: 'Edit the `models.py` file of the `chat` application and add the following lines
    highlighted in bold:'
  id: totrans-304
  prefs: []
  type: TYPE_NORMAL
  zh: 编辑 `chat` 应用程序的 `models.py` 文件并添加以下加粗的行：
- en: '[PRE41]'
  id: totrans-305
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: 'This is the data model to persist chat messages. Let’s take a look at the fields
    of the `Message` model:'
  id: totrans-306
  prefs: []
  type: TYPE_NORMAL
  zh: 这是持久化聊天消息的数据模型。让我们看看 `Message` 模型的字段：
- en: '`user`: The `User` object that wrote the message. This is a foreign key field
    because it specifies a many-to-one relationship: a user can send multiple messages,
    but each message is sent by a single user. By using `PROTECT` for the `on_delete`
    parameter, a `User` object cannot be deleted if related messages exist.'
  id: totrans-307
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`用户`: 写入消息的`User`对象。这是一个外键字段，因为它指定了一个多对一的关系：一个用户可以发送多条消息，但每条消息都是由单个用户发送的。通过为`on_delete`参数使用`PROTECT`，如果存在相关消息，则无法删除`User`对象。'
- en: '`course`: A relationship with the `Course` object. Each message belongs to
    the chat room of a course. By using `PROTECT` for the `on_delete` parameter, a
    `Course` object cannot be deleted if related messages exist.'
  id: totrans-308
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`课程`: 与`Course`对象的关系。每条消息都属于一个课程聊天室。通过为`on_delete`参数使用`PROTECT`，如果存在相关消息，则无法删除`Course`对象。'
- en: '`content`: A `TextField` to store the content of the message.'
  id: totrans-309
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`内容`: 用于存储消息内容的`TextField`。'
- en: '`sent_on`: A `DateTimeField` to store the date and time when the message object
    is saved the first time.'
  id: totrans-310
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`发送时间`: 用于存储消息对象首次保存的日期和时间的`DateTimeField`。'
- en: 'Run the following command in the shell prompt to generate the database migrations
    for the `chat` application:'
  id: totrans-311
  prefs: []
  type: TYPE_NORMAL
  zh: 在shell提示符中运行以下命令以生成`chat`应用的数据库迁移：
- en: '[PRE42]'
  id: totrans-312
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: 'You should get the following output:'
  id: totrans-313
  prefs: []
  type: TYPE_NORMAL
  zh: 你应该得到以下输出：
- en: '[PRE43]'
  id: totrans-314
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: 'Apply the newly created migration to your database with the following command:'
  id: totrans-315
  prefs: []
  type: TYPE_NORMAL
  zh: 使用以下命令将新创建的迁移应用到你的数据库中：
- en: '[PRE44]'
  id: totrans-316
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: 'You will get an output that ends with the following line:'
  id: totrans-317
  prefs: []
  type: TYPE_NORMAL
  zh: 你将得到一个以以下行结束的输出：
- en: '[PRE45]'
  id: totrans-318
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: The database is now in sync with the new model. Let’s add the `Message` model
    to the administration site.
  id: totrans-319
  prefs: []
  type: TYPE_NORMAL
  zh: 数据库现在与新的模型同步。让我们将`Message`模型添加到管理网站。
- en: Adding the message model to the administration site
  id: totrans-320
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 将消息模型添加到管理网站
- en: 'Edit the `admin.py` file of the `chat` application and register the `Message`
    model into the administration site, as follows. The new code is highlighted in
    bold:'
  id: totrans-321
  prefs: []
  type: TYPE_NORMAL
  zh: 编辑`chat`应用的`admin.py`文件，并将`Message`模型注册到管理网站，如下所示。新代码加粗：
- en: '[PRE46]'
  id: totrans-322
  prefs: []
  type: TYPE_PRE
  zh: '[PRE46]'
- en: 'Run the development server and open `http://127.0.0.1:8000/admin/` in your
    browser. You should see the **CHAT** block and the **Messages** section on the
    administration site:'
  id: totrans-323
  prefs: []
  type: TYPE_NORMAL
  zh: 运行开发服务器，并在浏览器中打开`http://127.0.0.1:8000/admin/`。你应该在管理网站上看到**聊天**块和**消息**部分：
- en: '![](img/B21088_16_09.png)'
  id: totrans-324
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/B21088_16_09.png)'
- en: 'Figure 16.9: The Chat application and Messages section on the administration
    site'
  id: totrans-325
  prefs: []
  type: TYPE_NORMAL
  zh: 图16.9：管理网站上的聊天应用和消息部分
- en: We will continue by saving messages to the database when they are sent by users.
  id: totrans-326
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将继续通过用户发送消息时将消息保存到数据库。
- en: Storing messages in the database
  id: totrans-327
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 在数据库中存储消息
- en: 'We will modify the WebSocket consumer to persist each message that is received
    through the WebSocket. Edit the `consumers.py` file of the `chat` application,
    and add the following code highlighted in bold:'
  id: totrans-328
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将修改WebSocket消费者以持久化通过WebSocket接收到的每条消息。编辑`chat`应用的`consumers.py`文件，并添加以下加粗的代码：
- en: '[PRE47]'
  id: totrans-329
  prefs: []
  type: TYPE_PRE
  zh: '[PRE47]'
- en: In this code, we add the asynchronous `persist_message()` method to the `ChatConsumer`
    class. This method takes a `message` parameter and creates a `Message` object
    in the database with the given message, the related authenticated `user`, and
    the `id` of the `Course` object that the group chat room belongs to. Since the
    is `ChatConsumer` is fully asynchronous, we use the `acreate()` QuerySet method,
    which is the asynchronous version of `create()`. You can read more about how to
    write asynchronous queries with the Django ORM at [https://docs.djangoproject.com/en/5.0/topics/db/queries/#asynchronous-queries](https://docs.djangoproject.com/en/5.0/topics/db/queries/#asynchronous-queries).
  id: totrans-330
  prefs: []
  type: TYPE_NORMAL
  zh: 在此代码中，我们将异步的`persist_message()`方法添加到`ChatConsumer`类中。此方法接受一个`message`参数，并在数据库中创建一个包含给定消息、相关认证的`user`和属于聊天室组的`Course`对象`id`的`Message`对象。由于`ChatConsumer`是完全异步的，我们使用`acreate()`
    QuerySet方法，这是`create()`的异步版本。你可以在[https://docs.djangoproject.com/en/5.0/topics/db/queries/#asynchronous-queries](https://docs.djangoproject.com/en/5.0/topics/db/queries/#asynchronous-queries)了解更多关于如何使用Django
    ORM编写异步查询的信息。
- en: We call the `persist_message()` method asynchronously in the `receive()` method
    that is executed when a message is received by the consumer through the WebSocket.
  id: totrans-331
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在消费者通过WebSocket接收消息时执行的`receive()`方法中异步调用`persist_message()`方法。
- en: Run the development server and open `http://127.0.0.1:8000/chat/room/1/` in
    your browser, replacing `1` with the `id` of an existing course in the database.
    With a logged-in user who is enrolled in the course, write a message and send
    it.
  id: totrans-332
  prefs: []
  type: TYPE_NORMAL
  zh: 运行开发服务器，并在浏览器中打开`http://127.0.0.1:8000/chat/room/1/`，将`1`替换为数据库中现有课程的`id`。使用已登录并注册该课程的用户，写一条消息并发送。
- en: Then, open a second browser window in incognito mode to prevent the use of the
    same session. Log in with a different user, also enrolled in the same course,
    and send a few messages as well.
  id: totrans-333
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，在隐身模式下打开第二个浏览器窗口，以防止使用相同的会话。使用不同的用户登录，该用户也注册了相同的课程，并发送一些消息。
- en: '*Figure 16.10* shows an example of messages sent by two different users:'
  id: totrans-334
  prefs: []
  type: TYPE_NORMAL
  zh: '*图16.10* 展示了两个不同用户发送的消息示例：'
- en: '![](img/B21088_16_10.png)'
  id: totrans-335
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/B21088_16_10.png)'
- en: 'Figure 16.10: Chat room example with messages sent by two different users'
  id: totrans-336
  prefs: []
  type: TYPE_NORMAL
  zh: 图16.10：显示两个不同用户发送的消息的聊天室示例
- en: 'Open `http://127.0.0.1:8000/admin/chat/message/` in your browser. The messages
    sent should appear on the administration site, as in *Figure 16.11*:'
  id: totrans-337
  prefs: []
  type: TYPE_NORMAL
  zh: 在您的浏览器中打开`http://127.0.0.1:8000/admin/chat/message/`。发送的消息应出现在管理网站上，如图16.11所示：
- en: '![](img/B21088_16_11.png)'
  id: totrans-338
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/B21088_16_11.png)'
- en: 'Figure 16.11: Admin list display view of messages stored in the database'
  id: totrans-339
  prefs: []
  type: TYPE_NORMAL
  zh: 图16.11：数据库中存储的消息的行政列表显示视图
- en: All messages are now persisted in the database.
  id: totrans-340
  prefs: []
  type: TYPE_NORMAL
  zh: 所有消息现在都已持久化存储在数据库中。
- en: Note that messages could contain malicious code, for example, JavaScript fragments.
    We do not mark the messages as safe in our template, providing an initial layer
    of protection against malicious content. However, to further enhance security,
    consider sanitizing the messages before storing them in the database. A reliable
    option for sanitizing content is the `nh3` package. You can read more about `nh3`
    at [https://nh3.readthedocs.io/en/latest/](https://nh3.readthedocs.io/en/latest/).
    Additionally, `django-nh3` is a Django integration available that offers custom
    `nh3` model fields and form fields. More information is available at [https://github.com/marksweb/django-nh3](https://github.com/marksweb/django-nh3).
  id: totrans-341
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，消息可能包含恶意代码，例如JavaScript片段。在我们的模板中，我们不将消息标记为安全，以提供对恶意内容的初步保护。然而，为了进一步增强安全性，考虑在将消息存储到数据库之前对其进行清理。清理内容的一个可靠选项是`nh3`包。您可以在[https://nh3.readthedocs.io/en/latest/](https://nh3.readthedocs.io/en/latest/)了解更多关于`nh3`的信息。此外，`django-nh3`是一个Django集成，它提供了自定义的`nh3`模型字段和表单字段。更多信息可在[https://github.com/marksweb/django-nh3](https://github.com/marksweb/django-nh3)找到。
- en: Now that you are storing the complete chat history in your database, let’s learn
    how to present the latest messages in the chat history to users when they join
    a chat room.
  id: totrans-342
  prefs: []
  type: TYPE_NORMAL
  zh: 现在您已经将完整的聊天历史存储在数据库中，让我们学习如何在用户加入聊天室时向他们展示聊天历史中的最新消息。
- en: Displaying the chat history
  id: totrans-343
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 显示聊天历史
- en: When users join a course chat room, we will display the latest five messages
    of the chat history. This will ensure that users gain immediate context for ongoing
    conversations.
  id: totrans-344
  prefs: []
  type: TYPE_NORMAL
  zh: 当用户加入课程聊天室时，我们将显示聊天历史的最新五条消息。这将确保用户能够立即获得正在进行对话的上下文。
- en: 'Edit the `views.py` file of the `chat` application and add the following code
    highlighted in bold to the `course_chat_room` view:'
  id: totrans-345
  prefs: []
  type: TYPE_NORMAL
  zh: 编辑`chat`应用程序的`views.py`文件，并在`course_chat_room`视图中添加以下加粗的代码：
- en: '[PRE48]'
  id: totrans-346
  prefs: []
  type: TYPE_PRE
  zh: '[PRE48]'
- en: We retrieve the chat messages related to the course and use `select_related()`
    to fetch the related user in the same query. This will prevent the generation
    of additional SQL queries when accessing the username to display it alongside
    each message. Django’s ORM doesn’t support negative indexing, so we retrieve the
    first five messages in reverse chronological order, and we utilize the `reversed()`
    function to reorder them back into chronological sequence.
  id: totrans-347
  prefs: []
  type: TYPE_NORMAL
  zh: 我们检索与课程相关的聊天消息，并使用`select_related()`在同一查询中获取相关用户。这将防止在访问用户名以显示在每个消息旁边时生成额外的SQL查询。Django的ORM不支持负索引，所以我们以倒序检索前五条消息，并利用`reversed()`函数将它们重新排序成时间顺序。
- en: 'Now, we will add the chat history to the chat room template. Edit the `chat/room.html`
    template and add the following lines highlighted in bold:'
  id: totrans-348
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们将聊天历史添加到聊天室模板中。编辑`chat/room.html`模板，并添加以下加粗的行：
- en: '[PRE49]'
  id: totrans-349
  prefs: []
  type: TYPE_PRE
  zh: '[PRE49]'
- en: 'Open `http://127.0.0.1:8000/chat/room/1/` in your browser, replacing `1` with
    the `id` of an existing course in the database. You should now see the latest
    messages, as shown in *Figure 16.12*:'
  id: totrans-350
  prefs: []
  type: TYPE_NORMAL
  zh: 在您的浏览器中打开`http://127.0.0.1:8000/chat/room/1/`，将`1`替换为数据库中现有课程的`id`。您现在应该看到最新消息，如图16.12所示：
- en: '![](img/B21088_16_12.png)'
  id: totrans-351
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/B21088_16_12.png)'
- en: 'Figure 16.12: Chat room initially displaying the latest messages'
  id: totrans-352
  prefs: []
  type: TYPE_NORMAL
  zh: 图16.12：聊天室最初显示最新消息
- en: Users can now see the latest messages in the chat history upon joining a chat
    room. Next, we are going to add a link to the menu so that users can enter the
    course chat room.
  id: totrans-353
  prefs: []
  type: TYPE_NORMAL
  zh: 用户现在可以在加入聊天室后看到最新的消息。接下来，我们将在菜单中添加一个链接，以便用户可以进入课程聊天室。
- en: Integrating the chat application with existing views
  id: totrans-354
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 将聊天应用程序集成到现有视图中
- en: The chat server is now fully implemented, and students enrolled in a course
    can communicate with each other. Let’s add a link for students to join the chat
    room for each course.
  id: totrans-355
  prefs: []
  type: TYPE_NORMAL
  zh: 聊天服务器现已完全实现，注册课程的学生可以相互交流。让我们为每个课程添加一个学生加入聊天室的超链接。
- en: 'Edit the `students/course/detail.html` template of the `students` application
    and add the following `<h3>` HTML element code at the bottom of the `<div class="contents">`
    element:'
  id: totrans-356
  prefs: []
  type: TYPE_NORMAL
  zh: 编辑 `students/course/detail.html` 模板中的 `students` 应用程序，并在 `<div class="contents">`
    元素的底部添加以下 `<h3>` HTML 元素代码：
- en: '[PRE50]'
  id: totrans-357
  prefs: []
  type: TYPE_PRE
  zh: '[PRE50]'
- en: 'Open the browser and access any course that the student is enrolled in to view
    the course contents. The sidebar will now contain a **Course chat room** link
    that points to the course chat room view. If you click on it, you will enter the
    chat room:'
  id: totrans-358
  prefs: []
  type: TYPE_NORMAL
  zh: 打开浏览器并访问学生已注册的任何课程以查看课程内容。现在侧边栏将包含一个指向课程聊天室的 **课程聊天室** 链接。如果您点击它，您将进入聊天室：
- en: '![Graphical user interface, application  Description automatically generated](img/B21088_16_13.png)'
  id: totrans-359
  prefs: []
  type: TYPE_IMG
  zh: '![图形用户界面，应用程序描述自动生成](img/B21088_16_13.png)'
- en: 'Figure 16.13: The course detail page, including a link to the course chat room'
  id: totrans-360
  prefs: []
  type: TYPE_NORMAL
  zh: 图 16.13：课程详情页面，包括指向课程聊天室的链接
- en: Congratulations! You successfully built your first asynchronous application
    using Django Channels.
  id: totrans-361
  prefs: []
  type: TYPE_NORMAL
  zh: 恭喜！您已成功使用 Django Channels 构建了您的第一个异步应用程序。
- en: Summary
  id: totrans-362
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: In this chapter, you learned how to create a chat server using Channels. You
    implemented both a WebSocket consumer and a client. By enabling communication
    through a channel layer with Redis and modifying the consumer to be fully asynchronous,
    you improved the responsiveness and scalability of your application. Additionally,
    you implemented chat message persistence, providing a robust and user-friendly
    experience and maintaining chat history for users over time. The skills you learned
    in this chapter will help you in any future implementations of asynchronous real-time
    functionalities.
  id: totrans-363
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，您学习了如何使用 Channels 创建聊天服务器。您实现了 WebSocket 消费者和客户端。通过启用通过 Redis 的通道层进行通信，并将消费者修改为完全异步，您提高了应用程序的响应性和可扩展性。此外，您实现了聊天消息持久化，提供了稳健且用户友好的体验，并随着时间的推移维护用户的聊天历史。您在本章中学到的技能将帮助您在未来的任何异步实时功能实现中。
- en: The next chapter will teach you how to build a production environment for your
    Django project using NGINX, uWSGI, and Daphne with Docker Compose. You will also
    learn how to implement custom middleware for request/response processing across
    your entire application, and how to develop custom management commands, which
    enable you to automate tasks and execute them via the command line.
  id: totrans-364
  prefs: []
  type: TYPE_NORMAL
  zh: 下一章将教您如何使用 NGINX、uWSGI 和 Daphne 以及 Docker Compose 为您的 Django 项目构建生产环境。您还将学习如何实现跨整个应用程序的请求/响应处理的自定义中间件，以及如何开发自定义管理命令，这些命令使您能够自动化任务并通过命令行执行它们。
- en: Additional resources
  id: totrans-365
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 其他资源
- en: 'The following resources provide additional information related to the topics
    covered in this chapter:'
  id: totrans-366
  prefs: []
  type: TYPE_NORMAL
  zh: 以下资源提供了与本章涵盖主题相关的额外信息：
- en: 'Source code for this chapter: [https://github.com/PacktPublishing/Django-5-by-example/tree/main/Chapter16](https://github.com/PacktPublishing/Django-5-by-example/tree/main/Chapter16)'
  id: totrans-367
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 本章源代码：[https://github.com/PacktPublishing/Django-5-by-example/tree/main/Chapter16](https://github.com/PacktPublishing/Django-5-by-example/tree/main/Chapter16)
- en: 'Introduction to ASGI: [https://asgi.readthedocs.io/en/latest/introduction.html](https://asgi.readthedocs.io/en/latest/introduction.html)'
  id: totrans-368
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: ASGI 简介：[https://asgi.readthedocs.io/en/latest/introduction.html](https://asgi.readthedocs.io/en/latest/introduction.html)
- en: 'Django support for asynchronous views: [https://docs.djangoproject.com/en/5.0/topics/async/](https://docs.djangoproject.com/en/5.0/topics/async/)'
  id: totrans-369
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Django 对异步视图的支持：[https://docs.djangoproject.com/en/5.0/topics/async/](https://docs.djangoproject.com/en/5.0/topics/async/)
- en: 'Django support for asynchronous class-based views: [https://docs.djangoproject.com/en/5.0/topics/class-based-views/#async-class-based-views](https://docs.djangoproject.com/en/5.0/topics/class-based-views/#async-class-based-views)'
  id: totrans-370
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Django 对异步类视图的支持：[https://docs.djangoproject.com/en/5.0/topics/class-based-views/#async-class-based-views](https://docs.djangoproject.com/en/5.0/topics/class-based-views/#async-class-based-views)
- en: 'Daphne ASGI server: [https://github.com/django/daphne](https://github.com/django/daphne)'
  id: totrans-371
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Daphne ASGI 服务器：[https://github.com/django/daphne](https://github.com/django/daphne)
- en: 'Django Channels documentation: [https://channels.readthedocs.io/](https://channels.readthedocs.io/)'
  id: totrans-372
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Django Channels 文档：[https://channels.readthedocs.io/](https://channels.readthedocs.io/)
- en: 'Deploying Django with ASGI: [https://docs.djangoproject.com/en/5.0/howto/deployment/asgi/](https://docs.djangoproject.com/en/5.0/howto/deployment/asgi/)'
  id: totrans-373
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用 ASGI 部署 Django：[https://docs.djangoproject.com/en/5.0/howto/deployment/asgi/](https://docs.djangoproject.com/en/5.0/howto/deployment/asgi/)
- en: 'Introduction to WebSockets: [https://en.wikipedia.org/wiki/WebSocket](https://en.wikipedia.org/wiki/WebSocket).'
  id: totrans-374
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: WebSocket 简介：[https://en.wikipedia.org/wiki/WebSocket](https://en.wikipedia.org/wiki/WebSocket).
- en: '`json_script` template filter usage: [https://docs.djangoproject.com/en/5.0/ref/templates/builtins/#json-script](https://docs.djangoproject.com/en/5.0/ref/templates/builtins/#json-script)'
  id: totrans-375
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`json_script` 模板过滤器使用：[https://docs.djangoproject.com/en/5.0/ref/templates/builtins/#json-script](https://docs.djangoproject.com/en/5.0/ref/templates/builtins/#json-script)'
- en: 'Django ORM asynchronous queries: [https://docs.djangoproject.com/en/5.0/topics/db/queries/#asynchronous-queries](https://docs.djangoproject.com/en/5.0/topics/db/queries/#asynchronous-queries)'
  id: totrans-376
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Django ORM 异步查询：[https://docs.djangoproject.com/en/5.0/topics/db/queries/#asynchronous-queries](https://docs.djangoproject.com/en/5.0/topics/db/queries/#asynchronous-queries)
- en: '`nh3` documentation: [https://nh3.readthedocs.io/en/latest/](https://nh3.readthedocs.io/en/latest/)'
  id: totrans-377
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`nh3` 文档：[https://nh3.readthedocs.io/en/latest/](https://nh3.readthedocs.io/en/latest/)'
- en: '`django-nh3` project: [https://github.com/marksweb/django-nh3](https://github.com/marksweb/django-nh3)'
  id: totrans-378
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`django-nh3` 项目：[https://github.com/marksweb/django-nh3](https://github.com/marksweb/django-nh3)'
