- en: '16'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Building a Chat Server
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In the previous chapter, you created a RESTful API for your project that provides
    a programmable interface for your application.
  prefs: []
  type: TYPE_NORMAL
- en: In this chapter, you will develop a chat server for students using Django Channels,
    enabling students to engage in real-time messaging within course chat rooms. You
    will learn how to build real-time applications through asynchronous programming
    with Django Channels. By serving your Django project through **Asynchronous Server
    Gateway Interface** (**ASGI**), and implementing asynchronous communication, you
    will enhance the responsiveness and scalability of your server. Additionally,
    you will persist chat messages into the database, building a comprehensive chat
    history and enriching the user experience and functionality of the chat application.
  prefs: []
  type: TYPE_NORMAL
- en: 'In this chapter, you will:'
  prefs: []
  type: TYPE_NORMAL
- en: Add Channels to your project
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Build a WebSocket consumer and appropriate routing
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Implement a WebSocket client
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Enable a channel layer with Redis
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Make your consumer fully asynchronous
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Persist chat messages into the database
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Functional overview
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '*Figure 16.1* shows a representation of the views, templates, and functionalities
    that will be built in this chapter:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/B21088_16_01.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 16.1: Diagram of functionalities built in this chapter'
  prefs: []
  type: TYPE_NORMAL
- en: In this chapter, you will implement the `course_chat_room` view in the `chat`
    application. This view will serve the template that displays the chat room for
    a given course. The latest chat messages will be displayed when a user joins a
    chat room. You will use JavaScript to establish a WebSocket connection in the
    browser, and you will build the `ChatConsumer` WebSocket consumer to handle WebSocket
    connections and to exchange messages. You will use Redis to implement the channel
    layer that allows broadcasting messages to all users in the chat room.
  prefs: []
  type: TYPE_NORMAL
- en: The source code for this chapter can be found at [https://github.com/PacktPublishing/Django-5-by-example/tree/main/Chapter16](https://github.com/PacktPublishing/Django-5-by-example/tree/main/Chapter16).
  prefs: []
  type: TYPE_NORMAL
- en: All Python modules used in this chapter are included in the `requirements.txt`
    file in the source code that comes along with this chapter. You can follow the
    instructions to install each Python module below or you can install all requirements
    at once with the command `python -m pip install -r requirements.txt`.
  prefs: []
  type: TYPE_NORMAL
- en: Creating a chat application
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: You are going to implement a chat server to provide students with a chat room
    for each course. Students enrolled in a course will be able to access the course
    chat room and exchange messages in real time. You will use Channels to build this
    functionality. Channels is a Django application that extends Django to handle
    protocols that require long-running connections, such as WebSockets, chatbots,
    or MQTT (a lightweight publish/subscribe message transport commonly used in **Internet
    of Things** (**IoT**) projects).
  prefs: []
  type: TYPE_NORMAL
- en: Using Channels, you can easily implement real-time or asynchronous functionalities
    into your project in addition to your standard HTTP synchronous views. You will
    start by adding a new application to your project. The new application will contain
    the logic for the chat server.
  prefs: []
  type: TYPE_NORMAL
- en: You can the documentation for Django Channels at [https://channels.readthedocs.io/](https://channels.readthedocs.io/).
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s start implementing the chat server. Run the following command from the
    project’s `educa` directory to create the new application file structure:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'Edit the `settings.py` file of the `educa` project and activate the `chat`
    application in your project by editing the `INSTALLED_APPS` setting, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: The new `chat` application is now active in your project. Next, you are going
    to build a view for course chat rooms.
  prefs: []
  type: TYPE_NORMAL
- en: Implementing the chat room view
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: You will provide students with a different chat room for each course. You need
    to create a view for students to join the chat room of a given course. Only students
    who are enrolled in a course will be able to access the course chat room.
  prefs: []
  type: TYPE_NORMAL
- en: 'Edit the `views.py` file of the new `chat` application and add the following
    code to it:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: 'This is the `course_chat_room` view. In this view, you use the `@login_required`
    decorator to prevent any non-authenticated user from accessing the view. The view
    works as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: The view receives a required `course_id` parameter that is used to retrieve
    the course with the given `id`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The courses that the user is enrolled in are retrieved through the `courses_joined`
    relationship and the course with the given `id` is obtained from that subset of
    courses. If the course with the given `id` does not exist or the user is not enrolled
    in it, an `HttpResponseForbidden` response is returned, which translates to an
    HTTP response with status `403`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: If the course with the given `id` exists and the user is enrolled in it, the
    `chat/room.html` template is rendered, passing the `course` object to the template
    context.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'You need to add a URL pattern for this view. Create a new file inside the `chat`
    application directory and name it `urls.py`. Add the following code to it:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: This is the initial URL patterns file for the `chat` application. You define
    the `course_chat_room` URL pattern, including the `course_id` parameter with the
    `int` prefix, as you only expect an integer value here.
  prefs: []
  type: TYPE_NORMAL
- en: 'Include the new URL patterns of the `chat` application in the main URL patterns
    of the project. Edit the main `urls.py` file of the `educa` project and add the
    following line to it:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: URL patterns for the `chat` application are added to the project under the `chat/`
    path.
  prefs: []
  type: TYPE_NORMAL
- en: You need to create a template for the `course_chat_room` view. This template
    will contain an area to visualize the messages that are exchanged in the chat,
    and a text input with a submit button to send text messages to the chat.
  prefs: []
  type: TYPE_NORMAL
- en: 'Create the following file structure within the `chat` application directory:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: 'Edit the `chat/room.html` template and add the following code to it:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: 'This is the template for the course chat room. In this template, you perform
    the following actions:'
  prefs: []
  type: TYPE_NORMAL
- en: You extend the `base.html` template of your project and fill its `content` block.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: You define a `<div>` HTML element with the `chat` ID that you will use to display
    the chat messages sent by the user and by other students.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: You also define a second `<div>` element with a `text` input and a submit button
    that will allow the user to send messages.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: You add the `include_js` and `domready` blocks defined in the `base.html` template,
    which you are going to implement later, to establish a connection with a WebSocket
    and send or receive messages.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Run the development server and open `http://127.0.0.1:8000/chat/room/1/` in
    your browser, replacing `1` with the `id` of an existing course in the database.
  prefs: []
  type: TYPE_NORMAL
- en: 'Access the chat room with a logged-in user who is enrolled in the course. You
    will see the following screen:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/B21088_16_02.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 16.2: The course chat room page'
  prefs: []
  type: TYPE_NORMAL
- en: This is the course chat room screen that students will use to discuss topics
    within a course.
  prefs: []
  type: TYPE_NORMAL
- en: You have created the base view for the course chat room. Now you need to handle
    messages between students. The next section will introduce asynchronous support
    with Channels for real-time communication.
  prefs: []
  type: TYPE_NORMAL
- en: Real-time Django with Channels
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: You are building a chat server to provide students with a chat room for each
    course. Students enrolled in a course will be able to access the course chat room
    and exchange messages. This functionality requires real-time communication between
    the server and the client.
  prefs: []
  type: TYPE_NORMAL
- en: A standard HTTP request/response model doesn’t work here because you need the
    browser to receive notifications as soon as new messages arrive. There are several
    ways you could implement this feature, using AJAX polling or long polling in combination
    with storing the messages in your database or Redis. However, there is no efficient
    way to implement real-time communication using a standard synchronous web application.
  prefs: []
  type: TYPE_NORMAL
- en: You need asynchronous communication, which allows real-time interactions, where
    the server can push updates to the client as soon as new messages arrive without
    the client needing to request updates periodically. Asynchronous communication
    also comes with other advantages, such as reduced latency, improved performance
    under load, and a better overall user experience. You are going to build a chat
    server using asynchronous communication through ASGI.
  prefs: []
  type: TYPE_NORMAL
- en: Asynchronous applications using ASGI
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Django is usually deployed using **Web Server Gateway Interface** (**WSGI**),
    which is the standard interface for Python applications to handle HTTP requests.
    However, to work with asynchronous applications, you need to use another interface
    called ASGI, which can handle WebSocket requests as well. ASGI is the emerging
    Python standard for asynchronous web servers and applications. By using ASGI,
    we will enable Django to handle each message independently and in real time, creating
    a smooth and live chat experience for students.
  prefs: []
  type: TYPE_NORMAL
- en: You can find an introduction to ASGI at [https://asgi.readthedocs.io/en/latest/introduction.html](https://asgi.readthedocs.io/en/latest/introduction.html).
  prefs: []
  type: TYPE_NORMAL
- en: Django comes with support for running asynchronous Python through ASGI. Writing
    asynchronous views has been supported since Django 3.1, and Django 4.1 introduced
    asynchronous handlers for class-based views. Django 5.0 adds handling for disconnect
    events in asynchronous views before the response is generated. It also adds asynchronous
    functions to the authentication framework, provides support for asynchronous signal
    dispatching, and adds async support to multiple built-in decorators.
  prefs: []
  type: TYPE_NORMAL
- en: Channels builds upon the native ASGI support available in Django and provides
    additional functionalities to handle protocols that require long-running connections,
    such as WebSockets, IoT protocols, and chat protocols.
  prefs: []
  type: TYPE_NORMAL
- en: WebSockets provide full-duplex communication by establishing a persistent, open,
    bidirectional **Transmission Control Protocol** (**TCP**) connection between servers
    and clients. Instead of sending HTTP requests to the server, you establish a connection
    with the server; once the channel is open, messages can be exchanged in both directions
    without needing to establish a new connection each time. You are going to use
    WebSockets to implement your chat server.
  prefs: []
  type: TYPE_NORMAL
- en: You can read more about WebSockets at [https://en.wikipedia.org/wiki/WebSocket](https://en.wikipedia.org/wiki/WebSocket).
  prefs: []
  type: TYPE_NORMAL
- en: You can find more information about deploying Django with ASGI at [https://docs.djangoproject.com/en/5.0/howto/deployment/asgi/](https://docs.djangoproject.com/en/5.0/howto/deployment/asgi/).
  prefs: []
  type: TYPE_NORMAL
- en: You can find more information about Django’s support for writing asynchronous
    views at [https://docs.djangoproject.com/en/5.0/topics/async/](https://docs.djangoproject.com/en/5.0/topics/async/)
    and Django’s support for asynchronous class-based views at [https://docs.djangoproject.com/en/5.0/topics/class-based-views/#async-class-based-views](https://docs.djangoproject.com/en/5.0/topics/class-based-views/#async-class-based-views).
  prefs: []
  type: TYPE_NORMAL
- en: Next, we are going to learn how the Django request/response cycle is altered
    by using Channels.
  prefs: []
  type: TYPE_NORMAL
- en: The request/response cycle using Channels
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'It’s important to understand the differences in a request cycle between a standard
    synchronous request cycle and a Channels implementation. The following schema
    shows the request cycle of a synchronous Django setup:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/B21088_16_03.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 16.3: The Django request/response cycle'
  prefs: []
  type: TYPE_NORMAL
- en: When an HTTP request is sent by the browser to the web server, Django handles
    the request and passes the `HttpRequest` object to the corresponding view. The
    view processes the request and returns an `HttpResponse` object that is sent back
    to the browser as an HTTP response. There is no mechanism to maintain an open
    connection or send data to the browser without an associated HTTP request.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following schema shows the request cycle of a Django project using Channels
    with WebSockets:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/B21088_16_04.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 16.4: The Django Channels request/response cycle'
  prefs: []
  type: TYPE_NORMAL
- en: Channels replaces Django’s request/response cycle with messages that are sent
    across channels. HTTP requests are still routed to view functions using Django,
    but they get routed over channels. This allows WebSocket message handling as well,
    where you have producers and consumers that exchange messages across a channel
    layer. Channels preserves Django’s synchronous architecture, allowing you to choose
    between writing synchronous code and asynchronous code, or a combination of both.
  prefs: []
  type: TYPE_NORMAL
- en: Your existing synchronous views will co-exist with the WebSocket functionality
    that we will implement with Daphne, and you will serve both HTTP and WebSocket
    requests.
  prefs: []
  type: TYPE_NORMAL
- en: Next, you are going to install Channels and add it to your project.
  prefs: []
  type: TYPE_NORMAL
- en: Installing Channels and Daphne
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: You are going to add Channels to your project and set up the required basic
    ASGI application routing for it to manage HTTP requests.
  prefs: []
  type: TYPE_NORMAL
- en: 'Install Channels in your virtual environment with the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: This will simultaneously install Channels along with the Daphne ASGI application
    server. An ASGI server is necessary for handling asynchronous requests, and we
    choose Daphne for its simplicity and compatibility, as it comes bundled with Channels.
  prefs: []
  type: TYPE_NORMAL
- en: 'Edit the `settings.py` file of the `educa` project and add `daphne` to the
    beginning of the `INSTALLED_APPS` setting as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: When `daphne` is added to the `INSTALLED_APPS` setting, it takes control over
    the `runserver` command, replacing the standard Django development server. This
    will allow you to serve asynchronous requests during development. Besides handling
    URL routing to Django views for synchronous requests, Daphne also manages routes
    to WebSocket consumers. You can find more information about Daphne at [https://github.com/django/daphne](https://github.com/django/daphne).
  prefs: []
  type: TYPE_NORMAL
- en: Channels expects you to define a single root application that will be executed
    for all requests. You can define the root application by adding the `ASGI_APPLICATION`
    setting to your project. This is similar to the `ROOT_URLCONF` setting that points
    to the base URL patterns of your project. You can place the root application anywhere
    in your project, but it is recommended to put it in a project-level file. You
    can add your root routing configuration to the `asgi.py` file directly, where
    the ASGI application will be defined.
  prefs: []
  type: TYPE_NORMAL
- en: 'Edit the `asgi.py` file in the `educa` project directory and add the following
    code highlighted in bold:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: In the previous code, you define the main ASGI application that will be executed
    when serving the Django project through ASGI. You use the `ProtocolTypeRouter`
    class provided by Channels as the main entry point of your routing system. `ProtocolTypeRouter`
    takes a dictionary that maps communication types like `http` or `websocket` to
    ASGI applications. You instantiate this class with the default application for
    the HTTP protocol. Later, you will add a protocol for the WebSocket.
  prefs: []
  type: TYPE_NORMAL
- en: 'Add the following line to the `settings.py` file of your project:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: The `ASGI_APPLICATION` setting is used by Channels to locate the root routing
    configuration.
  prefs: []
  type: TYPE_NORMAL
- en: 'Start the development server using the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: 'You will see output similar to the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: Check that the output contains the line `Starting ASGI/Daphne version 4.1.0
    development server`. This line confirms that you are using the Daphne development
    server, which is capable of managing synchronous and asynchronous requests, instead
    of the standard Django development server. HTTP requests continue to behave the
    same as before, but they get routed over Channels.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now that Channels is installed in your project, you can build the chat server
    for courses. To implement the chat server for your project, you will need to take
    the following steps:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Set up a consumer**: Consumers are individual pieces of code that can handle
    WebSockets in a very similar way to traditional HTTP views. You will build a consumer
    to read and write messages to a communication channel.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '**Configure routing**: Channels provides routing classes that allow you to
    combine and stack your consumers. You will configure URL routing for your chat
    consumer.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '**Implement a WebSocket client**: When the student accesses the chat room,
    you will connect to the WebSocket from the browser and send or receive messages
    using JavaScript.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '**Enable a channel layer**: Channel layers allow you to talk between different
    instances of an application. They’re a useful part of making a distributed real-time
    application. You will set up a channel layer using Redis.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Let’s start by writing your own consumer to handle connecting to a WebSocket,
    receiving and sending messages, and disconnecting.
  prefs: []
  type: TYPE_NORMAL
- en: Writing a consumer
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Consumers are the equivalent of Django views for asynchronous applications.
    As mentioned, they handle WebSockets in a very similar way to how traditional
    views handle HTTP requests. Consumers are ASGI applications that can handle messages,
    notifications, and other things. Unlike Django views, consumers are built for
    long-running communication. URLs are mapped to consumers through routing classes
    that allow you to combine and stack consumers.
  prefs: []
  type: TYPE_NORMAL
- en: Let’s implement a basic consumer that can accept WebSocket connections and echoes
    every message it receives from the WebSocket back to it. This initial functionality
    will allow the student to send messages to the consumer and receive back the messages
    it sends.
  prefs: []
  type: TYPE_NORMAL
- en: 'Create a new file inside the `chat` application directory and name it `consumers.py`.
    Add the following code to it:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: 'This is the `ChatConsumer` consumer. This class inherits from the Channels
    `WebsocketConsumer` class to implement a basic WebSocket consumer. In this consumer,
    you implement the following methods:'
  prefs: []
  type: TYPE_NORMAL
- en: '`connnect()`: Called when a new connection is received. You accept any connection
    with `self.accept()`. You can also reject a connection by calling `self.close()`.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`disconnect()`: Called when the socket closes. You use `pass` because you don’t
    need to implement any action when a client closes the connection.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`receive()`: Called whenever data is received from the WebSocket. You expect
    text to be received as `text_data` (this could also be `binary_data` for binary
    data). You treat the text data received as JSON. Therefore, you use `json.loads()`
    to load the received JSON data into a Python dictionary. You access the `message`
    key, which you expect to be present in the JSON structure received. To echo the
    message, you send the message back to the WebSocket with `self.send()`, transforming
    it into JSON format again through `json.dumps()`.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The initial version of your `ChatConsumer` consumer accepts any WebSocket connection
    and echoes to the WebSocket client every message it receives. Note that the consumer
    does not broadcast messages to other clients yet. You will build this functionality
    by implementing a channel layer later.
  prefs: []
  type: TYPE_NORMAL
- en: First, let’s expose our consumer by adding it to the URLs of the project.
  prefs: []
  type: TYPE_NORMAL
- en: Routing
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: You need to define a URL to route connections to the `ChatConsumer` consumer
    you have implemented. Channels provides routing classes that allow you to combine
    and stack consumers to dispatch based on what the connection is. You can think
    of them as the URL routing system of Django for asynchronous applications.
  prefs: []
  type: TYPE_NORMAL
- en: 'Create a new file inside the `chat` application directory and name it `routing.py`.
    Add the following code to it:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: 'In this code, you map a URL pattern with the `ChatConsumer` class that you
    defined in the `chat/consumers.py` file. There are some details that are worth
    reviewing:'
  prefs: []
  type: TYPE_NORMAL
- en: You use Django’s `re_path()` to define the path with a regular expression instead
    of `path()`. Channels’ URL routing may not function correctly with `path()` routes
    if inner routers are wrapped by additional middleware, so this approach helps
    avoid any issues.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The URL includes an integer parameter called `course_id`. This parameter will
    be available in the scope of the consumer and will allow you to identify the course
    chat room that the user is connecting to.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: You call the `as_asgi()` method of the `consumer` class in order to get an ASGI
    application that will instantiate an instance of the consumer for each user connection.
    This behavior is similar to Django’s `as_view()` method for class-based views.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: It is a good practice to prepend WebSocket URLs with `/ws/` to differentiate
    them from URLs used for standard synchronous HTTP requests. This also simplifies
    the production setup when an HTTP server routes requests based on the path.
  prefs: []
  type: TYPE_NORMAL
- en: 'Edit the global `asgi.py` file located next to the `settings.py` file so that
    it looks like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: 'In this code, you have added:'
  prefs: []
  type: TYPE_NORMAL
- en: A new route for the `websocket` protocol. You use `URLRouter` to map `websocket`
    connections to the URL patterns defined in the `websocket_urlpatterns` list of
    the `chat.routing` module.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`AuthMiddlewareStack` as a wrapper function for the URL router. The `AuthMiddlewareStack`
    class provided by Channels supports standard Django authentication, where the
    user details are stored in the session. Later, you will access the user instance
    in the scope of the consumer to identify the user who sends a message.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Note that the `websocket_urlpatterns` import is below the `get_asgi_application()`
    function call. This is needed to ensure the application registry is populated
    before importing code that may import ORM models.
  prefs: []
  type: TYPE_NORMAL
- en: Now that we have a functioning WebSocket consumer that is available through
    a URL, we can implement the WebSocket client.
  prefs: []
  type: TYPE_NORMAL
- en: Implementing the WebSocket client
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: So far, you have created the `course_chat_room` view and its corresponding template
    for students to access the course chat room. You have implemented a WebSocket
    consumer for the chat server and tied it with URL routing. Now, you need to build
    a WebSocket client to establish a connection with the WebSocket in the course
    chat room template and be able to send/receive messages.
  prefs: []
  type: TYPE_NORMAL
- en: You are going to implement the WebSocket client with JavaScript to open and
    maintain a connection in the browser, and you will interact with the **Document
    Object Model** (**DOM**) using JavaScript.
  prefs: []
  type: TYPE_NORMAL
- en: 'You will perform the following tasks related to the WebSocket client:'
  prefs: []
  type: TYPE_NORMAL
- en: Open a WebSocket connection with the server when the page is loaded.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Add messages to an HTML container when data is received through the WebSocket.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Attach a listener to the submit button to send messages through the WebSocket
    when the user clicks the **SEND** button or presses the *Enter* key.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Let’s start by opening the WebSocket connection.
  prefs: []
  type: TYPE_NORMAL
- en: 'Edit the `chat/room.html` template of the `chat` application and modify the
    `include_js` and `domready` blocks, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: In the `include_js` block, you use the `json_script` template filter to securely
    use the value of `course.id` with JavaScript. The `json_script` template filter
    provided by Django outputs a Python object as JSON, wrapped in a `<script>` tag,
    so that you can safely use it with JavaScript. The code `{{ course.id|json_script:"course-id"
    }}` is rendered as `<script id="course-id" type="application/json">6</script>`.
    This value is then retrieved in the `domready` block by parsing the content of
    the element with `id="course-id"` using `JSON.parse()`. This is the safe way to
    use Python objects in JavaScript.
  prefs: []
  type: TYPE_NORMAL
- en: The `json_script` template filter securely encodes Python objects as JSON and
    safely embeds them in a `<script>` HTML tag, protecting against **cross-site scripting**
    (**XSS**) attacks by escaping potentially harmful characters.
  prefs: []
  type: TYPE_NORMAL
- en: You can find more information about the `json_script` template filter at [https://docs.djangoproject.com/en/5.0/ref/templates/builtins/#json-script](https://docs.djangoproject.com/en/5.0/ref/templates/builtins/#json-script).
  prefs: []
  type: TYPE_NORMAL
- en: In the `domready` block, you define an URL with the WebSocket protocol, which
    looks like `ws://` (or `wss://` for secure WebSockets, just like `https://`).
    You build the URL using the current location of the browser, which you obtain
    from `window.location.host`. The rest of the URL is built with the path for the
    chat room URL pattern that you defined in the `routing.py` file of the `chat`
    application.
  prefs: []
  type: TYPE_NORMAL
- en: You write the URL instead of building it with a resolver because Channels does
    not provide a way to reverse URLs. You use the current course `ID` to generate
    the URL for the current course and store the URL in a new constant named `url`.
  prefs: []
  type: TYPE_NORMAL
- en: You then open a WebSocket connection to the stored URL using `new` `WebSocket(url)`.
    You assign the instantiated WebSocket client object to the new constant `chatSocket`.
  prefs: []
  type: TYPE_NORMAL
- en: You have created a WebSocket consumer, you have included routing for it, and
    you have implemented a basic WebSocket client. Let’s try the initial version of
    your chat.
  prefs: []
  type: TYPE_NORMAL
- en: 'Start the development server using the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: 'Open the URL `http://127.0.0.1:8000/chat/room/1/` in your browser, replacing
    `1` with the `id` of an existing course in the database. Take a look at the console
    output. Besides the HTTP `GET` requests for the page and its static files, you
    should see two lines, including `WebSocket HANDSHAKING` and `WebSocket CONNECT`,
    like the following output:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: The Daphne server listens for incoming socket connections using a standard TCP
    socket. The handshake is the bridge from HTTP to WebSockets. In the handshake,
    details of the connection are negotiated and either party can close the connection
    before completion. Remember that you are using `self.accept()` to accept any connection
    in the `connect()` method of the `ChatConsumer` class, implemented in the `consumers.py`
    file of the `chat` application. The connection is accepted, and therefore, you
    see the `WebSocket CONNECT` message in the console.
  prefs: []
  type: TYPE_NORMAL
- en: If you use the browser developer tools to track network connections, you can
    also see information for the WebSocket connection that has been established.
  prefs: []
  type: TYPE_NORMAL
- en: 'It should look like *Figure 16.5*:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Graphical user interface, application, table  Description automatically generated](img/B21088_16_05.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 16.5: The browser developer tools showing that the WebSocket connection
    has been established'
  prefs: []
  type: TYPE_NORMAL
- en: 'Now that you can connect to the WebSocket, it’s time to interact with it. You
    will implement the methods to handle common events, such as receiving a message
    and closing the connection. Edit the `chat/room.html` template of the `chat` application
    and modify the `domready` block, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: 'In this code, you define the following events for the WebSocket client:'
  prefs: []
  type: TYPE_NORMAL
- en: '`onmessage`: Fired when data is received through the WebSocket. You parse the
    message, which you expect in JSON format, and access its `message` attribute.
    You then append a new `<div>` element with the message received to the HTML element
    with the `chat` ID. This will add new messages to the chat log, while keeping
    all previous messages that have been added to the log. You scroll the chat log
    `<div>` to the bottom to ensure that the new message gets visibility. You achieve
    this by scrolling to the total scrollable height of the chat log, which can be
    obtained by accessing its `scrollHeight` attribute.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`onclose`: Fired when the connection with the WebSocket is closed. You don’t
    expect to close the connection, and therefore, you write the error `Chat socket
    closed unexpectedly` to the console log if this happens.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: You have implemented the action to display the message when a new message is
    received. You need to implement the functionality to send messages to the socket
    as well.
  prefs: []
  type: TYPE_NORMAL
- en: 'Edit the `chat/room.html` template of the `chat` application and add the following
    JavaScript code to the bottom of the `domready` block:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: 'In this code, you define an event listener for the `click` event of the submit
    button, which you select by its ID `chat-message-submit`. When the button is clicked,
    you perform the following actions:'
  prefs: []
  type: TYPE_NORMAL
- en: You read the message entered by the user from the value of the text input element
    with the ID `chat-message-input`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: You check whether the message has any content with `if(message)`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'If the user has entered a message, you form JSON content such as `{''message'':
    ''string entered by the user''}` by using `JSON.stringify()`.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: You send the JSON content through the WebSocket, calling the `send()` method
    of `chatSocket` client.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: You clear the contents of the text input by setting its value to an empty string
    with `input.value = ''`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: You return the focus to the text input with `input.focus()` so that the user
    can write a new message straight away.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The user is now able to send messages using the text input and by clicking the
    submit button.
  prefs: []
  type: TYPE_NORMAL
- en: To improve the user experience, you will give focus to the text input when the
    page loads, allowing users to begin typing immediately without needing to click
    on it first. You will also capture keyboard keypress events to identify the *Enter*
    key and fire the `click` event on the submit button. Users will be able to either
    click the button or press the *Enter* key to send a message.
  prefs: []
  type: TYPE_NORMAL
- en: 'Edit the `chat/room.html` template of the `chat` application and add the following
    JavaScript code to the bottom of the `domready` block:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: 'In this code, you also define a function for the `keypress` event of the `input`
    element. For any key that the user presses, you perform the following actions:'
  prefs: []
  type: TYPE_NORMAL
- en: You check whether its key is *Enter*.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'If the *Enter* key is pressed:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: You prevent the default behavior for this key with `event.preventDefault()`.
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: Then you fire the `click` event on the submit button to send the message to
    the WebSocket.
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: Outside of the event handler, in the main JavaScript code for the `domready`
    block, you give the focus to the text input with `input.focus()`. By doing so,
    when the DOM is loaded, the focus will be set on the `input` element for the user
    to type a message.
  prefs: []
  type: TYPE_NORMAL
- en: 'The `domready` block of the `chat/room.html` template should now look as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: Open the URL `http://127.0.0.1:8000/chat/room/1/` in your browser, replacing
    `1` with the `id` of an existing course in the database. With a logged-in user
    who is enrolled in the course, write some text in the input field and click the
    **SEND** button or press the *Enter* key.
  prefs: []
  type: TYPE_NORMAL
- en: 'You will see that your message appears in the chat log:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/B21088_16_06.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 16.6: The chat room page, including messages sent through the WebSocket'
  prefs: []
  type: TYPE_NORMAL
- en: Great! The message has been sent through the WebSocket and the `ChatConsumer`
    consumer has received the message and has sent it back through the WebSocket.
    The `chatSocket` client has received a message event and the `onmessage` function
    has been fired, adding the message to the chat log.
  prefs: []
  type: TYPE_NORMAL
- en: You have implemented the functionality with a WebSocket consumer and a WebSocket
    client to establish client/server communication and can send or receive events.
    However, the chat server is not able to broadcast messages to other clients. If
    you open a second browser tab and enter a message, the message will not appear
    on the first tab. In order to build communication between consumers, you have
    to enable a channel layer.
  prefs: []
  type: TYPE_NORMAL
- en: Enabling a channel layer
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Channel layers allow you to communicate between different instances of an application.
    A channel layer is the transport mechanism that allows multiple consumer instances
    to communicate with each other and with other parts of Django.
  prefs: []
  type: TYPE_NORMAL
- en: In your chat server, you plan to have multiple instances of the `ChatConsumer`
    consumer for the same course chat room. Each student who joins the chat room will
    instantiate the WebSocket client in their browser, and that will open a connection
    with an instance of the WebSocket consumer. You need a common channel layer to
    distribute messages between consumers.
  prefs: []
  type: TYPE_NORMAL
- en: Channels and groups
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Channel layers provide two abstractions to manage communications: channels
    and groups:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Channel**: You can think of a channel as an inbox where messages can be sent
    or as a task queue. Each channel has a name. Messages are sent to a channel by
    anyone who knows the channel name and then given to consumers listening on that
    channel.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Group**: Multiple channels can be grouped into a group. Each group has a
    name. A channel can be added or removed from a group by anyone who knows the group
    name. Using the group name, you can also send a message to all channels in the
    group.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: You will work with channel groups to implement the chat server. By creating
    a channel group for each course chat room, the `ChatConsumer` instances will be
    able to communicate with each other.
  prefs: []
  type: TYPE_NORMAL
- en: Let’s add a channel layer to our project.
  prefs: []
  type: TYPE_NORMAL
- en: Setting up a channel layer with Redis
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Redis is the preferred option for a channel layer, though Channels has support
    for other types of channel layers. Redis works as the communication store for
    the channel layer. Remember that you already used Redis in *Chapter 7*, *Tracking
    User Actions*, *Chapter 10*, *Extending Your Shop*, and *Chapter 14*, *Rendering
    and Caching Content*.
  prefs: []
  type: TYPE_NORMAL
- en: If you haven’t installed Redis yet, you can find installation instructions in
    *Chapter 7*, *Tracking User Actions*.
  prefs: []
  type: TYPE_NORMAL
- en: 'To use Redis as a channel layer, you have to install the `channels-redis` package.
    Install `channels-redis` in your virtual environment with the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: 'Edit the `settings.py` file of the `educa` project and add the following code
    to it:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: The `CHANNEL_LAYERS` setting defines the configuration for the channel layers
    available to the project. You define a default channel layer using the `RedisChannelLayer`
    backend provided by `channels-redis` and specify the host `127.0.0.1` and the
    port `6379`, on which Redis is running.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s try the channel layer. Initialize the Redis Docker container using the
    following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: If you want to run the command in the background (in detached mode) you can
    use the `-d` option.
  prefs: []
  type: TYPE_NORMAL
- en: 'Open the Django shell using the following command from the project directory:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: 'To verify that the channel layer can communicate with Redis, write the following
    code to send a message to a test channel named `test_channel` and receive it back:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: 'You should get the following output:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: In the previous code, you send a message to a test channel through the channel
    layer, and then you retrieve it from the channel layer. The channel layer is communicating
    successfully with Redis.
  prefs: []
  type: TYPE_NORMAL
- en: Next, we will add the channel layer to our project.
  prefs: []
  type: TYPE_NORMAL
- en: Updating the consumer to broadcast messages
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Let’s edit the `ChatConsumer` consumer to use the channel layer we have implemented
    with Redis. You will use a channel group for each course chat room. Therefore,
    you will use the course `id` to build the group name. `ChatConsumer` instances
    will know the group name and will be able to communicate with each other.
  prefs: []
  type: TYPE_NORMAL
- en: 'Edit the `consumers.py` file of the `chat` application, import the `async_to_sync()`
    function, and modify the `connect()` method of the `ChatConsumer` class, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: In this code, you import the `async_to_sync()` helper function to wrap calls
    to asynchronous channel layer methods. `ChatConsumer` is a synchronous `WebsocketConsumer`
    consumer, but it needs to call asynchronous methods of the channel layer.
  prefs: []
  type: TYPE_NORMAL
- en: 'In the new `connect()` method, you perform the following tasks:'
  prefs: []
  type: TYPE_NORMAL
- en: You retrieve the course `id` from the scope to know the course that the chat
    room is associated with. You access `self.scope['url_route']['kwargs']['course_id']`
    to retrieve the `course_id` parameter from the URL. Every consumer has a scope
    with information about its connection, arguments passed by the URL, and the authenticated
    user, if any.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: You build the group name with the `id` of the course that the group corresponds
    to. Remember that you will have a channel group for each course chat room. You
    store the group name in the `room_group_name` attribute of the consumer.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: You join the group by adding the current channel to the group. You obtain the
    channel name from the `channel_name` attribute of the consumer. You use the `group_add`
    method of the channel layer to add the channel to the group. You use the `async_to_sync()`
    wrapper to use the channel layer asynchronous method.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: You keep the `self.accept()` call to accept the WebSocket connection.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: When the `ChatConsumer` consumer receives a new WebSocket connection, it adds
    the channel to the group associated with the course in its scope. The consumer
    is now able to receive any messages sent to the group.
  prefs: []
  type: TYPE_NORMAL
- en: 'In the same `consumers.py` file, modify the `disconnect()` method of the `ChatConsumer`
    class, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: When the connection is closed, you call the `group_discard()` method of the
    channel layer to leave the group. You use the `async_to_sync()` wrapper to use
    the channel layer asynchronous method.
  prefs: []
  type: TYPE_NORMAL
- en: 'In the same `consumers.py` file, modify the `receive()` method of the `ChatConsumer`
    class, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: 'When you receive a message from the WebSocket connection, instead of sending
    the message to the associated channel, you send the message to the group. You
    do this by calling the `group_send()` method of the channel layer. You use the
    `async_to_sync()` wrapper to use the channel layer asynchronous method. You pass
    the following information in the event sent to the group:'
  prefs: []
  type: TYPE_NORMAL
- en: '`type`: The event type. This is a special key that corresponds to the name
    of the method that should be invoked on consumers that receive the event. You
    can implement a method in the consumer named the same as the message type so that
    it gets executed every time a message with that specific type is received.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`message`: The actual message you are sending.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'In the same `consumers.py` file, add a new `chat_message()` method in the `ChatConsumer`
    class, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: You name this method `chat_message()` to match the `type` key that is sent to
    the channel group when a message is received from the WebSocket. When a message
    with type `chat_message` is sent to the group, all consumers subscribed to the
    group will receive the message and will execute the `chat_message()` method. In
    the `chat_message()` method, you send the event message received to the WebSocket.
  prefs: []
  type: TYPE_NORMAL
- en: 'The complete `consumers.py` file should now look like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: You have implemented a channel layer in `ChatConsumer`, allowing consumers to
    broadcast messages and communicate with each other.
  prefs: []
  type: TYPE_NORMAL
- en: 'Run the development server with the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs: []
  type: TYPE_PRE
- en: Open the URL `http://127.0.0.1:8000/chat/room/1/` in your browser, replacing
    `1` with the `id` of an existing course in the database. Write a message and send
    it. Then, open a second browser window and access the same URL. Send a message
    from each browser window.
  prefs: []
  type: TYPE_NORMAL
- en: 'The result should look like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/B21088_16_07.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 16.7: The chat room page with messages sent from different browser windows'
  prefs: []
  type: TYPE_NORMAL
- en: You will see that the first message is only displayed in the first browser window.
    When you open a second browser window, messages sent in any of the browser windows
    are displayed in both of them. When you open a new browser window and access the
    chat room URL, a new WebSocket connection is established between the JavaScript
    WebSocket client in the browser and the WebSocket consumer in the server. Each
    channel gets added to the group associated with the course ID and passed through
    the URL to the consumer. Messages are sent to the group and received by all consumers.
  prefs: []
  type: TYPE_NORMAL
- en: Next, we are going to enrich messages with additional context.
  prefs: []
  type: TYPE_NORMAL
- en: Adding context to the messages
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Now that messages can be exchanged between all users in a chat room, you probably
    want to display who sent which message and when it was sent. Let’s add some context
    to the messages.
  prefs: []
  type: TYPE_NORMAL
- en: 'Edit the `consumers.py` file of the `chat` application and implement the following
    changes:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs: []
  type: TYPE_PRE
- en: You now import the `timezone` module provided by Django. In the `connect()`
    method of the consumer, you retrieve the current user from the scope with `self.scope['user']`
    and store them in a new `user` attribute of the consumer.
  prefs: []
  type: TYPE_NORMAL
- en: When the consumer receives a message through the WebSocket, it gets the current
    time using `timezone.now()` and passes the current `user` and `datetime` in ISO
    8601 format along with the message in the event sent to the channel group.
  prefs: []
  type: TYPE_NORMAL
- en: 'Edit the `chat/room.html` template of the `chat` application and add the following
    line highlighted in bold to the `include_js` block:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs: []
  type: TYPE_PRE
- en: Using the `json_script` template, you safely print the username of the request
    user to use it with JavaScript.
  prefs: []
  type: TYPE_NORMAL
- en: 'In the `domready` block of the `chat/room.html` template, add the following
    lines highlighted in bold:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE37]'
  prefs: []
  type: TYPE_PRE
- en: In the new code, you safely parse the data of the element with the ID `request-user`
    and store it in the `requestUser` constant.
  prefs: []
  type: TYPE_NORMAL
- en: 'Then, in the `domready` block, find the following lines:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE38]'
  prefs: []
  type: TYPE_PRE
- en: 'Replace those lines with the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE39]'
  prefs: []
  type: TYPE_PRE
- en: 'In this code, you implement the following changes:'
  prefs: []
  type: TYPE_NORMAL
- en: You convert the `datetime` received in the message to a JavaScript `Date` object
    and format it with a specific locale.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: You compare the username received in the message with two different constants
    as helpers to identify the user.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The constant `source` gets the value `me` if the user sending the message is
    the current user, or `other` otherwise.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The constant `name` gets the value `Me` if the user sending the message is the
    current user or the name of the user sending the message otherwise. You use it
    to display the name of the user sending the message.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: You use the `source` value as a `class` of the main `<div>` message element
    to differentiate messages sent by the current user from messages sent by others.
    Different CSS styles are applied based on the `class` attribute. These CSS styles
    are declared in the `css/base.css` static file.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: You use the username and the `datetime` in the message that you append to the
    chat log.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Open the URL `http://127.0.0.1:8000/chat/room/1/` in your browser, replacing
    `1` with the `id` of an existing course in the database. With a logged-in user
    who is enrolled in the course, write a message and send it.
  prefs: []
  type: TYPE_NORMAL
- en: Then, open a second browser window in incognito mode to prevent the use of the
    same session. Log in with a different user, also enrolled in the same course,
    and send a message.
  prefs: []
  type: TYPE_NORMAL
- en: 'You will be able to exchange messages using the two different users and see
    the user and time, with a clear distinction between messages sent by the user
    and messages sent by others. The conversation between two users should look similar
    to the following one:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/B21088_16_08.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 16.8: The chat room page with messages from two different user sessions'
  prefs: []
  type: TYPE_NORMAL
- en: Great! You have built a functional real-time chat application using Channels.
    Next, you will learn how to improve the chat consumer by making it fully asynchronous.
  prefs: []
  type: TYPE_NORMAL
- en: Modifying the consumer to be fully asynchronous
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The `ChatConsumer` you have implemented inherits from the synchronous base class
    `WebsocketConsumer`. Synchronous consumers operate in a way that each request
    must be processed in sequence, one after the other. Synchronous consumers are
    convenient for accessing Django models and calling regular synchronous I/O functions.
    However, asynchronous consumers perform better because of their ability to perform
    non-blocking operations, moving to another task without waiting for the first
    operation to complete. They don’t require additional threads when handling requests,
    thus reducing wait times and increasing the ability to scale to more users and
    requests simultaneously.
  prefs: []
  type: TYPE_NORMAL
- en: Given that you are already using the asynchronous channel layer functions, you
    can seamlessly rewrite the `ChatConsumer` class to make it asynchronous.
  prefs: []
  type: TYPE_NORMAL
- en: 'Edit the `consumers.py` file of the `chat` application and implement the following
    changes:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE40]'
  prefs: []
  type: TYPE_PRE
- en: 'You have implemented the following changes:'
  prefs: []
  type: TYPE_NORMAL
- en: The `ChatConsumer` consumer now inherits from the `AsyncWebsocketConsumer` class
    to implement asynchronous calls.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: You have changed the definition of all methods from `def` to `async def`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: You use `await` to call asynchronous functions that perform I/O operations.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: You no longer use the `async_to_sync()` helper function when calling methods
    on the channel layer.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Open the URL `http://127.0.0.1:8000/chat/room/1/` with two different browser
    windows again and verify that the chat server still works. The chat server is
    now fully asynchronous!
  prefs: []
  type: TYPE_NORMAL
- en: Next, we are going to implement a chat history by storing messages in the database.
  prefs: []
  type: TYPE_NORMAL
- en: Persisting messages into the database
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Let’s enhance the chat application by adding message persistence. We will develop
    functionality to store messages in the database, allowing us to present a chat
    history to users when they join a chat room. This feature is essential for real-time
    applications, where it’s necessary to display both current and previously generated
    data. For example, consider a stock trading application: upon logging in, users
    should see not only the current stock values but also the historical values from
    the time the stock market opened.'
  prefs: []
  type: TYPE_NORMAL
- en: 'To implement the chat history functionality, we will follow these steps:'
  prefs: []
  type: TYPE_NORMAL
- en: We will create Django model to store chat messages and add it to the administration
    site.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: We will modify the WebSocket consumer to persist messages.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: We will retrieve the chat history to display the latest messages when users
    enter a chat room.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Let’s start by creating the message model.
  prefs: []
  type: TYPE_NORMAL
- en: Creating a model for chat messages
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Edit the `models.py` file of the `chat` application and add the following lines
    highlighted in bold:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE41]'
  prefs: []
  type: TYPE_PRE
- en: 'This is the data model to persist chat messages. Let’s take a look at the fields
    of the `Message` model:'
  prefs: []
  type: TYPE_NORMAL
- en: '`user`: The `User` object that wrote the message. This is a foreign key field
    because it specifies a many-to-one relationship: a user can send multiple messages,
    but each message is sent by a single user. By using `PROTECT` for the `on_delete`
    parameter, a `User` object cannot be deleted if related messages exist.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`course`: A relationship with the `Course` object. Each message belongs to
    the chat room of a course. By using `PROTECT` for the `on_delete` parameter, a
    `Course` object cannot be deleted if related messages exist.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`content`: A `TextField` to store the content of the message.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`sent_on`: A `DateTimeField` to store the date and time when the message object
    is saved the first time.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Run the following command in the shell prompt to generate the database migrations
    for the `chat` application:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE42]'
  prefs: []
  type: TYPE_PRE
- en: 'You should get the following output:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE43]'
  prefs: []
  type: TYPE_PRE
- en: 'Apply the newly created migration to your database with the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE44]'
  prefs: []
  type: TYPE_PRE
- en: 'You will get an output that ends with the following line:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE45]'
  prefs: []
  type: TYPE_PRE
- en: The database is now in sync with the new model. Let’s add the `Message` model
    to the administration site.
  prefs: []
  type: TYPE_NORMAL
- en: Adding the message model to the administration site
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Edit the `admin.py` file of the `chat` application and register the `Message`
    model into the administration site, as follows. The new code is highlighted in
    bold:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE46]'
  prefs: []
  type: TYPE_PRE
- en: 'Run the development server and open `http://127.0.0.1:8000/admin/` in your
    browser. You should see the **CHAT** block and the **Messages** section on the
    administration site:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/B21088_16_09.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 16.9: The Chat application and Messages section on the administration
    site'
  prefs: []
  type: TYPE_NORMAL
- en: We will continue by saving messages to the database when they are sent by users.
  prefs: []
  type: TYPE_NORMAL
- en: Storing messages in the database
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'We will modify the WebSocket consumer to persist each message that is received
    through the WebSocket. Edit the `consumers.py` file of the `chat` application,
    and add the following code highlighted in bold:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE47]'
  prefs: []
  type: TYPE_PRE
- en: In this code, we add the asynchronous `persist_message()` method to the `ChatConsumer`
    class. This method takes a `message` parameter and creates a `Message` object
    in the database with the given message, the related authenticated `user`, and
    the `id` of the `Course` object that the group chat room belongs to. Since the
    is `ChatConsumer` is fully asynchronous, we use the `acreate()` QuerySet method,
    which is the asynchronous version of `create()`. You can read more about how to
    write asynchronous queries with the Django ORM at [https://docs.djangoproject.com/en/5.0/topics/db/queries/#asynchronous-queries](https://docs.djangoproject.com/en/5.0/topics/db/queries/#asynchronous-queries).
  prefs: []
  type: TYPE_NORMAL
- en: We call the `persist_message()` method asynchronously in the `receive()` method
    that is executed when a message is received by the consumer through the WebSocket.
  prefs: []
  type: TYPE_NORMAL
- en: Run the development server and open `http://127.0.0.1:8000/chat/room/1/` in
    your browser, replacing `1` with the `id` of an existing course in the database.
    With a logged-in user who is enrolled in the course, write a message and send
    it.
  prefs: []
  type: TYPE_NORMAL
- en: Then, open a second browser window in incognito mode to prevent the use of the
    same session. Log in with a different user, also enrolled in the same course,
    and send a few messages as well.
  prefs: []
  type: TYPE_NORMAL
- en: '*Figure 16.10* shows an example of messages sent by two different users:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/B21088_16_10.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 16.10: Chat room example with messages sent by two different users'
  prefs: []
  type: TYPE_NORMAL
- en: 'Open `http://127.0.0.1:8000/admin/chat/message/` in your browser. The messages
    sent should appear on the administration site, as in *Figure 16.11*:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/B21088_16_11.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 16.11: Admin list display view of messages stored in the database'
  prefs: []
  type: TYPE_NORMAL
- en: All messages are now persisted in the database.
  prefs: []
  type: TYPE_NORMAL
- en: Note that messages could contain malicious code, for example, JavaScript fragments.
    We do not mark the messages as safe in our template, providing an initial layer
    of protection against malicious content. However, to further enhance security,
    consider sanitizing the messages before storing them in the database. A reliable
    option for sanitizing content is the `nh3` package. You can read more about `nh3`
    at [https://nh3.readthedocs.io/en/latest/](https://nh3.readthedocs.io/en/latest/).
    Additionally, `django-nh3` is a Django integration available that offers custom
    `nh3` model fields and form fields. More information is available at [https://github.com/marksweb/django-nh3](https://github.com/marksweb/django-nh3).
  prefs: []
  type: TYPE_NORMAL
- en: Now that you are storing the complete chat history in your database, let’s learn
    how to present the latest messages in the chat history to users when they join
    a chat room.
  prefs: []
  type: TYPE_NORMAL
- en: Displaying the chat history
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: When users join a course chat room, we will display the latest five messages
    of the chat history. This will ensure that users gain immediate context for ongoing
    conversations.
  prefs: []
  type: TYPE_NORMAL
- en: 'Edit the `views.py` file of the `chat` application and add the following code
    highlighted in bold to the `course_chat_room` view:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE48]'
  prefs: []
  type: TYPE_PRE
- en: We retrieve the chat messages related to the course and use `select_related()`
    to fetch the related user in the same query. This will prevent the generation
    of additional SQL queries when accessing the username to display it alongside
    each message. Django’s ORM doesn’t support negative indexing, so we retrieve the
    first five messages in reverse chronological order, and we utilize the `reversed()`
    function to reorder them back into chronological sequence.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, we will add the chat history to the chat room template. Edit the `chat/room.html`
    template and add the following lines highlighted in bold:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE49]'
  prefs: []
  type: TYPE_PRE
- en: 'Open `http://127.0.0.1:8000/chat/room/1/` in your browser, replacing `1` with
    the `id` of an existing course in the database. You should now see the latest
    messages, as shown in *Figure 16.12*:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/B21088_16_12.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 16.12: Chat room initially displaying the latest messages'
  prefs: []
  type: TYPE_NORMAL
- en: Users can now see the latest messages in the chat history upon joining a chat
    room. Next, we are going to add a link to the menu so that users can enter the
    course chat room.
  prefs: []
  type: TYPE_NORMAL
- en: Integrating the chat application with existing views
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The chat server is now fully implemented, and students enrolled in a course
    can communicate with each other. Let’s add a link for students to join the chat
    room for each course.
  prefs: []
  type: TYPE_NORMAL
- en: 'Edit the `students/course/detail.html` template of the `students` application
    and add the following `<h3>` HTML element code at the bottom of the `<div class="contents">`
    element:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE50]'
  prefs: []
  type: TYPE_PRE
- en: 'Open the browser and access any course that the student is enrolled in to view
    the course contents. The sidebar will now contain a **Course chat room** link
    that points to the course chat room view. If you click on it, you will enter the
    chat room:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Graphical user interface, application  Description automatically generated](img/B21088_16_13.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 16.13: The course detail page, including a link to the course chat room'
  prefs: []
  type: TYPE_NORMAL
- en: Congratulations! You successfully built your first asynchronous application
    using Django Channels.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, you learned how to create a chat server using Channels. You
    implemented both a WebSocket consumer and a client. By enabling communication
    through a channel layer with Redis and modifying the consumer to be fully asynchronous,
    you improved the responsiveness and scalability of your application. Additionally,
    you implemented chat message persistence, providing a robust and user-friendly
    experience and maintaining chat history for users over time. The skills you learned
    in this chapter will help you in any future implementations of asynchronous real-time
    functionalities.
  prefs: []
  type: TYPE_NORMAL
- en: The next chapter will teach you how to build a production environment for your
    Django project using NGINX, uWSGI, and Daphne with Docker Compose. You will also
    learn how to implement custom middleware for request/response processing across
    your entire application, and how to develop custom management commands, which
    enable you to automate tasks and execute them via the command line.
  prefs: []
  type: TYPE_NORMAL
- en: Additional resources
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The following resources provide additional information related to the topics
    covered in this chapter:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Source code for this chapter: [https://github.com/PacktPublishing/Django-5-by-example/tree/main/Chapter16](https://github.com/PacktPublishing/Django-5-by-example/tree/main/Chapter16)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Introduction to ASGI: [https://asgi.readthedocs.io/en/latest/introduction.html](https://asgi.readthedocs.io/en/latest/introduction.html)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Django support for asynchronous views: [https://docs.djangoproject.com/en/5.0/topics/async/](https://docs.djangoproject.com/en/5.0/topics/async/)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Django support for asynchronous class-based views: [https://docs.djangoproject.com/en/5.0/topics/class-based-views/#async-class-based-views](https://docs.djangoproject.com/en/5.0/topics/class-based-views/#async-class-based-views)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Daphne ASGI server: [https://github.com/django/daphne](https://github.com/django/daphne)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Django Channels documentation: [https://channels.readthedocs.io/](https://channels.readthedocs.io/)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Deploying Django with ASGI: [https://docs.djangoproject.com/en/5.0/howto/deployment/asgi/](https://docs.djangoproject.com/en/5.0/howto/deployment/asgi/)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Introduction to WebSockets: [https://en.wikipedia.org/wiki/WebSocket](https://en.wikipedia.org/wiki/WebSocket).'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`json_script` template filter usage: [https://docs.djangoproject.com/en/5.0/ref/templates/builtins/#json-script](https://docs.djangoproject.com/en/5.0/ref/templates/builtins/#json-script)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Django ORM asynchronous queries: [https://docs.djangoproject.com/en/5.0/topics/db/queries/#asynchronous-queries](https://docs.djangoproject.com/en/5.0/topics/db/queries/#asynchronous-queries)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`nh3` documentation: [https://nh3.readthedocs.io/en/latest/](https://nh3.readthedocs.io/en/latest/)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`django-nh3` project: [https://github.com/marksweb/django-nh3](https://github.com/marksweb/django-nh3)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
