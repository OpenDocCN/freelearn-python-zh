- en: '9'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Creating a RESTful API with FastAPI
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In the last chapter, we learned about a framework called Flask. Flask represents
    Python in a landscape of traditional web development frameworks designed to generate
    content on the server and send it back to the browser. This is how we have developed
    web applications for decades. The 2010s brought a paradigm shift, but it didn’t
    happen overnight.
  prefs: []
  type: TYPE_NORMAL
- en: 'In 2004, the term **AJAX**, an acronym for **Asynchronous JavaScript and XML**,
    was coined by Jesse James Garrett in an article titled *Ajax: A New Approach to
    Web Applications*. This article helped popularize the concept and techniques of
    asynchronous web applications. By 2005, mainstream browsers all supported a new
    **XMLHttpRequest** (**XHR**) web API call. The feature allowed a developer to
    request pure data instead of a generated HTML page with the data integrated with
    markup.'
  prefs: []
  type: TYPE_NORMAL
- en: The rise of **single-page applications** (**SPAs**) in the 2010s was closely
    associated with the advancement of JavaScript frameworks such as AngularJS (now
    Angular), React, and Vue.js. These provided developers with the tools and capabilities
    to build dynamic, interactive web applications differently from traditional applications,
    which make requests for HTML and data at the same time. SPAs load all their markup,
    CSS, and JavaScript in a single request. After that, the app uses XHR to request
    data, and in response to the data received and the user’s interactions, the developer
    used JavaScript to show and hide different elements in the user experience rather
    than re-rendering the entire page each time there was a change in data or a user
    interaction.
  prefs: []
  type: TYPE_NORMAL
- en: '**AngularJS**, released by Google in 2010, played a significant role in popularizing
    the concept of SPAs. It introduced a declarative approach to building web applications,
    allowing developers to create rich, responsive user interfaces without the need
    for full-page reloads. AngularJS provided a solid foundation for building SPAs,
    and its success inspired the development of other JavaScript frameworks that further
    refined and improved the SPA development experience.'
  prefs: []
  type: TYPE_NORMAL
- en: '**React**, developed by Facebook and released in 2013, also contributed to
    the popularity of SPAs. React introduced a component-based architecture that made
    it easier to manage the state and UI components of an application. React’s virtual
    **DOM** (**Document Object Model**) diffing algorithm and efficient rendering
    mechanism made it well suited for building fast and scalable SPAs.'
  prefs: []
  type: TYPE_NORMAL
- en: '**Vue.js**, created by Evan You and released in 2014, gained popularity as
    a lightweight and approachable framework for building SPAs. It offered a gentle
    learning curve and provided a flexible and intuitive way to build user interfaces.'
  prefs: []
  type: TYPE_NORMAL
- en: Overall, the combination of these JavaScript frameworks, along with advancements
    in browser technologies and APIs, led to the rise of SPAs in the early 2010s onward.
    SPAs today continue to provide a more seamless and responsive user experience
    by dynamically updating content on a single web page, eliminating the need for
    full page reloads, and providing a more app-like feel to web applications.
  prefs: []
  type: TYPE_NORMAL
- en: We could certainly create an SPA backend using Flask, but it might not be the
    best choice. This is especially true if you expect your application’s user base
    to be large. Flask is criticized as being a bit slow when you have server requests
    at high volume. Thankfully, there are other players in the game, and in this chapter,
    we’re going to focus on FastAPI.
  prefs: []
  type: TYPE_NORMAL
- en: 'The interesting thing about FastAPI is the way it handles web requests. Most
    products, including Flask, use a worker model. A pool of workers is responsible
    for servicing multiple incoming requests on separate processes managed by the
    operating system. FastAPI uses an **asynchronous programming** model. In the realm
    of asynchronous programming, functions are invoked, but the immediate return of
    outcomes is not guaranteed. Let’s explore the following illustrative Python code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: When calling `add_two` in a synchronous programming context, the execution thread
    halts until the function is completed and the outcome is furnished. However, the
    mechanics differ when employing asynchronous programming. An asynchronous invocation
    doesn’t halt the invoking thread. Instead, the calling thread persists in execution
    after obtaining a `a + b` once this computation has been executed. It’s important
    to acknowledge that this may not happen instantaneously, but during the computation,
    other operations remain unblocked. Naturally, performing an addition of integers
    is likely to conclude swiftly.
  prefs: []
  type: TYPE_NORMAL
- en: Consider an alternative scenario where a request is made to a networked resource,
    such as fetching a web page. The speed of response is no longer solely contingent
    on the processor’s execution speed. It encompasses factors such as computer performance,
    network latency, and various other elements that might introduce delays ranging
    from seconds to even minutes. This is particularly true for those who don’t reside
    in well-connected urban areas with high-speed internet access. Since the asynchronous
    software doesn’t block, it can serve many requests serially since none of them
    are waiting for the previous function call or, in this case, web request, to finish.
    You can think of it as a restaurant with one waiter. You submit your order serially
    with other diners, but the cook only returns your food when it has been cooked.
    With this expectation set, the cook is free to cook as many dishes at once as
    their stove allows, and there is an implicit promise given that once your food
    is cooked, the waiter will bring it to you. Someone who orders a glass of juice
    might get their order back immediately, whereas your baked Alaska will take a
    little longer to produce.
  prefs: []
  type: TYPE_NORMAL
- en: A synchronous restaurant, by contrast, would employ, say, eight cooks. Eight
    orders can come in at once, but each cook is completely dedicated to fixing that
    one order until it is complete. As it turns out, the throughput, at least for
    computers, is often faster when employing the asynchronous model for typical web
    request workloads.
  prefs: []
  type: TYPE_NORMAL
- en: In Python 3.4, we got a new module called `asyncio`, which brought asynchronous
    programming features to our favorite language. Three years later, we found the
    first GitHub commit to a library project called **Starlette**. Starlette is an
    asynchronous web framework for building high-performance applications with Python.
    It provides the core functionality for handling HTTP requests and responses in
    an efficient manner. Starlette is known for its simplicity, speed, and support
    for modern Python features, making it an ideal foundation for building web applications.
    Like Werkzeug, though, which powers Flask, Starlette was only meant to be a foundation.
    This chapter covers **FastAPI**, a framework built on top of Starlette that represents
    a full implementation of a web framework specializing in the development of **RESTful
    Application Programming Interfaces** (**REST APIs**) Where Flask used a worker
    model, FastAPI uses an asynchronous model, and where Flask was designed to create
    traditional round trip, template-driven content generation, FastAPI normally used
    the SPAs to handle serving data in the form of **JavaScript Object** **Notation**
    (**JSON**).
  prefs: []
  type: TYPE_NORMAL
- en: I realize we just introduced a lot of jargon, which may be new to Python developers
    who aren’t normally web developers. We’ll explain our terminology in context as
    we cover building a simple FastAPI project using PyCharm.
  prefs: []
  type: TYPE_NORMAL
- en: 'By the end of this chapter, you will be able to do the following:'
  prefs: []
  type: TYPE_NORMAL
- en: Explain the difference between a traditional template-driven content generation
    system such as Flask and one that strictly serves data
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Describe the stateless nature of HTTP (and HTTPS) along with how **representational
    state transfer** (**REST**) is used to mitigate the lack of state in HTTP
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Create a FastAPI project using the built-in template provided in PyCharm Professional
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Perform tests on your FastAPI project using PyCharm’s HTTP REST client
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Create a React frontend application in a separate but connected (attached) project
    in PyCharm, allowing you to develop a full stack application without mingling
    the frontend JavaScript code with the backend Python code
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Manage multiple run configurations and debug the entire request-response pipeline
    in PyCharm’s debugger
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Bear in mind that this chapter isn’t meant to be a full tutorial on either FastAPI
    or React. The core purpose of this book is to teach PyCharm within the context
    of creating applications. Our coverage of FastAPI might be tacit, whereas our
    coverage of PyCharm as a tool to make an application with FastAPI will be very
    complete.
  prefs: []
  type: TYPE_NORMAL
- en: Technical requirements
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In order to proceed through this chapter, and indeed the rest of the book,
    you will need the following:'
  prefs: []
  type: TYPE_NORMAL
- en: An installed and working Python interpreter. I’ll be using the latest from [https://python.org](https://python.org).
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Installed copies of `pip` and `virtualenv`. You get these automatically when
    you install Python on Windows, and macOS has them included on every system. If
    you are using Linux, you need to install the package managers, such as `pip`,
    and virtual environment tools, such as `virtualenv`, separately. Our examples
    will be using `pip` and `virtualenv`.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: An installed and working copy of PyCharm. Installation was covered in [*Chapter
    2*](B19644_02.xhtml#_idTextAnchor028), *Installation and Configuration*, in case
    you are jumping into the middle of the book.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: This book’s sample source code is from GitHub. We covered cloning the code in
    [*Chapter 2*](B19644_02.xhtml#_idTextAnchor028), *Installation and Configuration*.
    You’ll find this chapter’s relevant code at [https://github.com/PacktPublishing/Hands-On-Application-Development-with-PyCharm---Second-Edition/tree/main/chapter-09](https://github.com/PacktPublishing/Hands-On-Application-Development-with-PyCharm---Second-Edition/tree/main/chapter-09).
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: There is no REST in a wicked stateless world
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: I’ve heard it said that computers are the dumbest creatures on the planet. They
    only do exactly as they are told, and they take your instructions in an extremely
    literal way. This is what makes programming a computer so difficult. You must
    choose exactly the right syntax and structure your ideas precisely and succinctly
    because any ambiguity will result in a bug.
  prefs: []
  type: TYPE_NORMAL
- en: 'There is only one way to make our lives hard, and that is to base our work
    and our careers on a system with the attention span of a fruit fly. I’m talking
    about web servers, of course. The term web server can mean two different things:
    it can refer to hardware or software. The hardware is any computer system running
    the software. I’ve seen people build web server hardware that fits in a matchbox,
    and I’ve seen web server hardware fill expansive rack mount systems in specially
    cooled data centers. In truth, for us at least, the hardware is the boring part.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Web server software is a little more interesting to those of us who write code.
    Web server software, such as **Apache**, **Nginx** (pronounced “engine-ex”), **LightHTTPD**,
    and others, are designed to be simple yet robust implementations of a common specification
    for the HTTP protocol. These specifications are internationally agreed to by the
    **World Wide Web Consortium** (**W3C**). The protocol itself is very straightforward.
    We’ve mentioned a few things about it already in earlier chapters, such as the
    following:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Client-server model**: HTTP follows a client-server model, where the client
    (typically a web browser) sends a request to the server, and the server responds
    with the requested data.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`GET`, `POST`, `PUT`, or `DELETE`), a **Uniform Resource Identifier** (**URI**)
    that identifies the resource being accessed, and headers that provide additional
    information. The server responds with a status code indicating the success or
    failure of the request and includes the requested data in the response body. In
    case you missed it, there’s a full discussion of the request-response paradigm
    (complete with pictures) in [*Chapter 8*](B19644_08.xhtml#_idTextAnchor203), *Building
    a Dynamic Web Application* *with Flask*.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Text-based protocol**: HTTP is a text-based protocol, meaning that both the
    request and response messages are human-readable. The messages follow a specific
    format called the HTTP message format, which consists of headers and an optional
    message body.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Secure variant**: HTTP can be augmented with encryption and security features
    using **HTTPS** (**HTTP Secure**). HTTPS adds a layer of **Transport Layer Security**
    (**TLS**) or **Secure Sockets Layer** (**SSL**) encryption to protect the confidentiality
    and integrity of the data transmitted between the client and the server.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'In our immediate discussion, I want to point out a nugget we have heretofore
    glossed over: HTTP is stateless. This means that each request from a client is
    treated independently, without any knowledge of previous requests. The server
    does not retain any information about the client’s previous interactions. In the
    US, there is a famous advertising campaign for the city of Las Vegas, which states
    “What happens in Vegas stays in Vegas.” Likewise, what happens within the request-response
    mechanism stays in that request-response life cycle. Once the response is received
    and acknowledged by the web browser, there is nothing other than a log entry somewhere
    that the request even took place.'
  prefs: []
  type: TYPE_NORMAL
- en: In concert, what we have here is a dumb machine executing requests of which
    it has no memory. This can make our job somewhat frustrating. We want our users
    to be continually interacting with our application, but the server isn’t going
    to help us do that without some form of cajoling.
  prefs: []
  type: TYPE_NORMAL
- en: Over the years, a number of mechanisms have been invented to help with the state
    in our application. If you’re not sure what I mean by state, I like to describe
    it as a saved game in your favorite video game.
  prefs: []
  type: TYPE_NORMAL
- en: Imagine you are playing an adventure game. You’ve been playing for quite a while,
    and you’ve found the entrance to the dark castle, which is on level three. You’ve
    answered the gatekeeper’s riddle, and you have obtained the vorpal sword of smiting.
    You have amassed 32,768 gold pieces and your character is at full health. Then
    your mom yells for you to go take out the trash. As we all know, this is “mom
    code” for “quit playing video games and do something productive.” She’ll never
    understand, will she? Naturally, you’d like to pick up where you left off, so
    you save your game. You can turn off your computer and turn it back on tomorrow,
    at which point you can load your game and it will behave as though you never stopped
    playing. This is because your saved game represents a saved state for the program.
    It is a snapshot of all the objects, variables, and data used by your game at
    the time you saved it. This is the program’s state. This is what web applications
    intrinsically lack, at least at the protocol level.
  prefs: []
  type: TYPE_NORMAL
- en: 'The state can be managed using a few techniques. Server solutions such as Flask
    allow you to implement sticky sessions where HTTP requests generate a token. The
    request details can be stored between sessions with reference to the token. This
    is not handled by your web server, but by your application server, which leverages
    the web server for the communications part: the request-response mechanism. Sessions
    are generally not desirable because, in most cases, they don’t scale. If you have
    a lot of web traffic, it is common practice to balance the traffic load between
    several servers. If your session is stored on server A on the first request, and
    a subsequent request goes to server B, it won’t have your session. Naturally,
    we’ve come up with solutions for that too, but let’s not get down in the weeds.'
  prefs: []
  type: TYPE_NORMAL
- en: You can use cookies, which store the data on the client side. Unfortunately,
    cookies have a bad reputation as they have been highly abused over the years.
    The major browsers expose the cookies you are saving, and your ever-paranoid users
    can choose to not accept your request to store cookies.
  prefs: []
  type: TYPE_NORMAL
- en: 'The best answer is to store the state of your application in the application
    itself. The idea here is called representational state transfer, or REST for short.
    In a RESTful scenario, we maintain the program’s state in memory on the client.
    We transfer any part of the state, or even (but not usually) the entire state
    using the request-response mechanism. The program essentially sends the parts
    of the state the server will need to fulfill the request. The server does whatever
    it is supposed to do, and then sends back the altered state in the response. If
    you are familiar with software design patterns, REST reminds me of the command
    pattern: the request encapsulates everything the server needs to complete the
    request.'
  prefs: []
  type: TYPE_NORMAL
- en: Now that the stage is set, let’s remember that SPAs are now responsible for
    maintaining their state, that all of the markup HTML, CSS, and JavaScript is loaded
    in the browser, and that all subsequent requests contain only the state data,
    which is sent to the server where it is altered and returned.
  prefs: []
  type: TYPE_NORMAL
- en: 'The format of the data transfer can be any form of text. Most often, it is
    JSON. Back in ye olde days of yore, we used XML, but we stopped because XML processing
    is ridiculously slow in a browser. JSON is faster since the browser already inherently
    understands JavaScript, so there is no parsing of the text required. Just in case
    this is your first rodeo, let’s compare the two formats. First, here’s some XML:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: 'XML is tag-based markup like HTML, but you can define your own tags using an
    XML schema. This was the format originally used in browsers with the **XMLHttpRequest**
    (**XHR**) API call. The *X* actually stands for *XML*. XHR is still used, but
    almost nobody (Microsoft Azure API teams notwithstanding) still uses XML. Instead,
    for performance reasons already mentioned, I give you the same thing in JSON:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: 'The same data is represented as is the structure of that data. As a Python
    developer, you’ve no doubt recognized this as a `dict`. Instead of tags with content
    and attributes, we have key-value pairs stored within curly braces. It is a rule
    of JSON that keys and textual values be enclosed in double quotations. Be careful
    here. JavaScript and Python both consider single and double quotation marks to
    be interchangeable, but JSON does not. Only double quotes are acceptable! Thankfully,
    Python has a `json` library available within the standard library that will convert
    your structures to JSON, and back again, without any fuss:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: 'These first few lines import the `json` library, then convert it to a JSON
    object with the `json.dumps` method. Just remember, we’re dumping to a string,
    hence `dumps` (the *s* is for *string*). Now let’s convert the other direction:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: We used `json.loads` to convert the JSON back to a `dict`. Just remember it
    as “We’re loading a JSON string,” hence `loads` (the *s* is for *string*).
  prefs: []
  type: TYPE_NORMAL
- en: You now understand the basic mechanics of what we’re going to be doing with
    FastAPI. Requests will be coming in like they did with Flask, but generally, instead
    of simple `GET` requests, which are intercepted and processed using the Jinja2
    template engine, the requests will contain JSON payloads, which we will process.
    The results of the processing will be returned as JSON. The request-response mechanism
    will be handled using asynchronous functions, so the code will look a little different
    than it did with Flask.
  prefs: []
  type: TYPE_NORMAL
- en: Let’s get our hands dirty so you can see what I mean!
  prefs: []
  type: TYPE_NORMAL
- en: Creating a FastAPI project in PyCharm Professional
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: By now, we’ve created many projects in PyCharm Professional and this isn’t very
    different. I’ll remind you that this set of features is only available in the
    Professional edition of PyCharm. If you need to use the Community edition, you
    can, but you’re on your own in terms of setting up the project since you won’t
    have access to the tooling we’re about to use.
  prefs: []
  type: TYPE_NORMAL
- en: 'Create a new project in PyCharm by clicking **File** | **New Project**. Then,
    find **FastAPI**in the list of templates. You can see mine in *Figure 9**.1*:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 9.1: The PyCharm project menu contains a template for a FastAPI project](img/B19644_09_01.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 9.1: The PyCharm project menu contains a template for a FastAPI project'
  prefs: []
  type: TYPE_NORMAL
- en: 'As with Flask, the FastAPI project template generates some starter code and
    a run configuration for us, as seen in *Figure 9**.2*:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 9.2: The template generates our FastAPI starter code and run configuration](img/B19644_09_02.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 9.2: The template generates our FastAPI starter code and run configuration'
  prefs: []
  type: TYPE_NORMAL
- en: There is a lot to talk about in *Figure 9**.2*, so I’ve numbered the diagram
    for reference.
  prefs: []
  type: TYPE_NORMAL
- en: PyCharm has created a virtual environment, along with two files as seen at `main.py`
    and `test_main.http`. We’ll come back to the files in a moment. PyCharm generated
    a run configuration for us. You can tell because it is the currently selected
    run configuration at **(2)** where that menu would normally say **Current File**
    if PyCharm didn’t have a run configuration set up.
  prefs: []
  type: TYPE_NORMAL
- en: At position `Hello World` endpoint for our FastAPI project. The power of these
    starter code templates is the psychological prompting they provide. If you have
    used any system for working with web routing and endpoints, regardless of language
    or framework, you can read this code and tell what is happening.
  prefs: []
  type: TYPE_NORMAL
- en: Lines 1 and 3 show us a typical constructor for the imported library instance
    of FastAPI. Line 6 shows us how FastAPI decorates endpoints. `@app` comes from
    the instantiation on line 3 and we’re invoking the HTTP `GET` method here so requests
    coming in using that method will be received and processed. If a client makes
    a request using another HTTP verb such as `PUT` or `POST`, they’ll receive an
    error since, currently, there is no code to handle that HTTP method.
  prefs: []
  type: TYPE_NORMAL
- en: Position `async` function below the decorator on line 7, and we can see we are
    returning something that looks like a `dict`, which also looks like JSON.
  prefs: []
  type: TYPE_NORMAL
- en: Position `GET` endpoint defined as `/hello/{name}`. The `name` variable offset
    in curly braces refers to part of the URL that can vary and is called a path parameter
    or a path variable. You can see it is duplicated in the `async` function definition
    on line 12\. The contents of the branches (`name`) on line 11 should match the
    name of the parameter for the function on line 12.
  prefs: []
  type: TYPE_NORMAL
- en: Position `f` string expression fills the name into the data. There is no special
    templating mechanism other than a normal Python `f` string.
  prefs: []
  type: TYPE_NORMAL
- en: Running the FastAPI project
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Naturally, we can run the FastAPI project by clicking the green arrowed run
    button near position **(2)**in *Figure 9**.2*. If you’ve skipped the chapter on
    setting up and using run and debug configurations, you might want to peek at [*Chapter
    6*](B19644_06.xhtml#_idTextAnchor145), *Seamless Testing, Debugging, and Profiling*,
    for details on how this feature works in PyCharm. You can see my program running
    in *Figure 9**.3*:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 9.3: I clicked the green run button, which spawned a tab in the run
    window for my project in PyCharm](img/B19644_09_03.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 9.3: I clicked the green run button, which spawned a tab in the run
    window for my project in PyCharm'
  prefs: []
  type: TYPE_NORMAL
- en: This looks similar to the runs in Flask, but there isn’t a warning about the
    development server. This is because FastAPI runs in an application called `uvicorn`,
    which is a variant of Green Unicorn (`gunicorn`). Uvicorn is production ready,
    so there is no warning. You can develop using the same application server software
    you will use when you deploy your application to your customers. The difference
    between `uvicorn` and `gunicorn`, which is most often used as a production server
    for Flask applications, is that `uvicorn` handles the async programming model
    while `gunicorn` uses traditional workers, as described earlier in this chapter.
  prefs: []
  type: TYPE_NORMAL
- en: 'At this point, we are left with something of a quandary. When we did this with
    Flask, the app was generating some HTML for us to view. This one isn’t. You can
    view the endpoint in a browser if you would like, as I am in *Figure 9**.4*:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 9.4: Visiting the root route isn’t very exciting, but it works](img/B19644_09_04.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 9.4: Visiting the root route isn’t very exciting, but it works'
  prefs: []
  type: TYPE_NORMAL
- en: 'I can also visit the other URL with the path parameter as part of the URL as
    shown in *Figure 9**.5*:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 9.5: Supplying a path parameter alters the data in the response](img/B19644_09_05.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 9.5: Supplying a path parameter alters the data in the response'
  prefs: []
  type: TYPE_NORMAL
- en: This time, I added the path parameter to the end of the URL, and as we saw in
    the code earlier, we’re getting back the generated JSON data.
  prefs: []
  type: TYPE_NORMAL
- en: There’s a problem with using the browser. The browser only allows you to submit
    HTTP `GET` requests. There are quite a few more HTTP methods typically used in
    a REST API project. In fact, the four most popular methods, sometimes referred
    to as verbs, map to the typical CRUD operations used in database applications.
    `GET` and `POST`.
  prefs: []
  type: TYPE_NORMAL
- en: 'In addition to standards for your requests, your responses can be standardized
    via best practice by using proper HTTP status codes. These are documented in the
    HTTP specifications provided by the W3C. Reading the specification is a sure-fire
    cure for insomnia, so I’ll refer you to the excellent **Mozilla Developer Network**
    (**MDN**) page for the status codes. This is a handy address to bookmark in your
    browser: [https://developer.mozilla.org/en-US/docs/Web/HTTP/Status](https://developer.mozilla.org/en-US/docs/Web/HTTP/Status).'
  prefs: []
  type: TYPE_NORMAL
- en: '| **HTTP Verb /** **Method** | **CRUD Operation** | **HTTP Status for** **Successful
    Response** | **Explanation** |'
  prefs: []
  type: TYPE_TB
- en: '| `GET` | `READ` | `200 (OK)` | Used to retrieve or get information from the
    server or database. For example, getting a list of users in your application.
    |'
  prefs: []
  type: TYPE_TB
- en: '| `POST` | `CREATE` | `201 (Created)` | Used to create a new record in a database.
    Use this anytime you are creating something on the server. For example, new user
    registration. |'
  prefs: []
  type: TYPE_TB
- en: '| `PUT` | `UPDATE` | `204 (No Content)` or `200 (OK)` | Use this method when
    you are sending an update to something that already exists, such as a database
    record. For example, updating a password. |'
  prefs: []
  type: TYPE_TB
- en: '| `DELETE` | `DELETE` | `204 (No Content)` or `200 (OK)` | Use this when you
    want to delete something. |'
  prefs: []
  type: TYPE_TB
- en: 'Figure 9.6: HTTP methods map to CRUD operations 1:1 and have standard response
    codes to denote successful responses'
  prefs: []
  type: TYPE_NORMAL
- en: 'With your browser limited to HTTP `GET` requests, and the 100% likelihood that
    we will want to use at least one of the other methods in our project, we need
    something better than just a browser for testing our API. We have a few options:'
  prefs: []
  type: TYPE_NORMAL
- en: There are browser plugins that allow you to send different kinds of requests.
    You can find them in your favorite browser’s marketplace.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Command-line tools such as cURL allow you to craft HTTP requests using any of
    the HTTP methods.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Dedicated API testing tools such as Insomnia ([https://www.insomnia.rest](https://www.insomnia.rest))
    or Postman ([https://getpostman.com](https://getpostman.com)) allow you a graphical
    tool for working with API requests. These tools can be very bloated as they are
    meant to do a lot more than just allow you to make the various request types.
    With that said, I use both because of their wide adoption rate. Believe it or
    not, there are developers on my team who don’t use PyCharm.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: PyCharm’s built-in HTTP `Requests` feature.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Obviously, we’re going to be focusing on the fourth option.
  prefs: []
  type: TYPE_NORMAL
- en: Working with PyCharm’s HTTP Requests
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'When we generated our project, PyCharm created two files. It created `main.py`,
    which we have already examined. It also created a file called `test_main.http`.
    This file is unique to PyCharm. Let’s examine the file shown in *Figure 9**.7*:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 9.7: The HTTP test file generated by PyCharm as part of a FastAPI
    project](img/B19644_09_06.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 9.7: The HTTP test file generated by PyCharm as part of a FastAPI project'
  prefs: []
  type: TYPE_NORMAL
- en: You’ll find the file itself directly next to `main.py` `test-main.http`, which
    lets us know exactly what is being tested. The `main.py` file will contain endpoints
    and `test_main.http` will then contain tests for all the endpoints.
  prefs: []
  type: TYPE_NORMAL
- en: 'This `http` test file isn’t code, as we saw in [*Chapter 6*](B19644_06.xhtml#_idTextAnchor145),
    *Seamless Testing, Debugging, and Profiling*. This is a specification for HTTP
    requests. Positions `main.py`, which is a good starting point. These tests are
    very simple, and like unit tests, they can be run individually using the green
    arrows. If you want to run all the tests in the file, you can use the toolbar
    **(2)**, which has a button with two green arrows. There is also an environment
    selector, which we’ll come back to soon. Position **(5)** shows a link that gives
    you a set of examples that can be pasted into your test files. We’ll come back
    to that too. First, let’s exercise our test and see what it does. I’ll click the
    double arrow run button shown by the top arrow in *Figure 9**.8*:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 9.8: Click the double arrow to run all the tests and you’ll find they
    both fail! Oh no!](img/B19644_09_07.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 9.8: Click the double arrow to run all the tests and you’ll find they
    both fail! Oh no!'
  prefs: []
  type: TYPE_NORMAL
- en: This isn’t good. Both of the tests fail spectacularly. I say *spectacularly*
    because PyCharm leaves no ambiguity. I see a red banner telling me my test failed.
    I see red text, by the lower arrow, telling me two tests failed. I see red Xs
    next to the test list. I see a message stating **Stopped. Tests failed 2 of 2**.
    If that isn’t enough, there is a log area that also lets you know your code missed
    the mark. In short, there are more red marks on this screen than there are on
    this chapter’s manuscript after the editor made their first pass! Trust me, that’s
    a lot! What in the world could be wrong? Why would PyCharm generate a failing
    test code like that in a *Hello* *World* example?
  prefs: []
  type: TYPE_NORMAL
- en: 'There’s nothing wrong with the code! In [*Chapter 6*](B19644_06.xhtml#_idTextAnchor145),
    *Seamless Testing, Debugging, and Profiling*, we learned about unit testing. Unit
    tests comprise code that exercises the code you are testing using assertions.
    The HTTP file doesn’t contain code, and this is not unit testing, this is integration
    testing. These tests require a running server in order to work. Let’s try this
    again. Examine *Figure 9**.9* and follow along if you like:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 9.9: You have to run the development server before you run the HTTP
    tests](img/B19644_09_08.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 9.9: You have to run the development server before you run the HTTP
    tests'
  prefs: []
  type: TYPE_NORMAL
- en: Click the run button for the API project **(1)**. Then click the run button
    for the tests **(2)**. With the server running, all the tests will pass **(3)**.
    If they don’t, call JetBrains and ask for your money back. That probably won’t
    work, which is OK because your tests should pass.
  prefs: []
  type: TYPE_NORMAL
- en: Examining the details of the return
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'It isn’t enough to know we passed, because all that really means is both requests
    were made against the local development server, and both came back with a status
    code of `200`. What you really want, most of the time, is to be able to see the
    JSON data that came back on the response. Let’s go find that. Locate the output
    for the test and scroll down until you see a mention of a JSON file like the one
    shown in *Figure 9**.10*:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 9.10: Scroll through the log and find the links to the JSON files.
    Click them to open the data in the tabbed area in the editor](img/B19644_09_09.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 9.10: Scroll through the log and find the links to the JSON files. Click
    them to open the data in the tabbed area in the editor'
  prefs: []
  type: TYPE_NORMAL
- en: 'This section in the log window tells us all the details about the request and
    response made in the test. We can see the following:'
  prefs: []
  type: TYPE_NORMAL
- en: The version of HTTP being used (1.1)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The status code of the response (`200 OK`)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The date of the request
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The server that generated the result (`uvicorn`)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The content type of the response (`application/json`)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The location where the test result was saved
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Yahtzee! PyCharm saved the result of the response in a JSON file that is date
    stamped, along with the status code, and presented it as a hyperlink in the log.
    If you click the link, the JSON file opens like any other text file in its own
    tab. In *Figure 9**.10*, I had to expand the log to be large enough to make for
    a good screenshot, but this obscured the contents of the open tab, so check out
    *Figure 9**.11* to see the return data in its tab having clicked the hyperlink
    in the log:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 9.11: The returned data appears in its own tab when you click the
    hyperlink](img/B19644_09_10.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 9.11: The returned data appears in its own tab when you click the hyperlink'
  prefs: []
  type: TYPE_NORMAL
- en: 'If you notice, it says the file is saved, but it doesn’t appear in the project
    files. If you are wondering where it was saved, you can right-click the tab as
    indicated in *Figure 9**.12*:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 9.12: Right-click the tab and use the Open In menu to open the location
    of the test result JSON file](img/B19644_09_11.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 9.12: Right-click the tab and use the Open In menu to open the location
    of the test result JSON file'
  prefs: []
  type: TYPE_NORMAL
- en: 'The contents of the menu will differ depending on your operating system. You’re
    looking for the top option, which for me is **Files**, which is the default file
    manager in **Gnome 42**. Windows will have a reference to Explorer and macOS ought
    to have a reference to Finder. Clicking that option will show you the location
    in your OS-specific file manager. You can see mine in *Figure 9**.13*:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 9.13: My file manager reveals the location for the HTTP response files,
    which is in the project’s .idea folder](img/B19644_09_12.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 9.13: My file manager reveals the location for the HTTP response files,
    which is in the project’s .idea folder'
  prefs: []
  type: TYPE_NORMAL
- en: 'As you can see, the test results are stored in the PyCharm project folder:
    the hidden `.idea` folder the IDE creates when you either create a new project
    or open a folder in PyCharm. Remember, any folder with a name beginning with a
    dot is hidden on a Mac or in Linux, but you can see them in Windows because Bill
    likes to be different. If you test often, as you should, these files might begin
    to stack up in numbers. I personally prefer to exclude these from my repositories.'
  prefs: []
  type: TYPE_NORMAL
- en: We just generated a new run configuration
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'A neat side effect of running all tests from the test window is that PyCharm
    creates a new run configuration, which you will find in the run configuration
    dropdown shown in *Figure 9**.14*:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 9.14: PyCharm created a new run configuration automatically following
    the first time we ran the HTTP tests](img/B19644_09_13.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 9.14: PyCharm created a new run configuration automatically following
    the first time we ran the HTTP tests'
  prefs: []
  type: TYPE_NORMAL
- en: 'If we edit the configuration, you can see more details, as seen in *Figure
    9**.15*:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 9.15: Options for HTTP Request test runs can be found in the run configuration
    editor](img/B19644_09_14.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 9.15: Options for HTTP Request test runs can be found in the run configuration
    editor'
  prefs: []
  type: TYPE_NORMAL
- en: As you can see, you can opt to run individual requests or all the requests in
    the file. Running single requests is handy if you’re focusing on the code for
    one endpoint and you need to run it over and over. If you had many endpoints in
    the test, your tests might take a while to complete.
  prefs: []
  type: TYPE_NORMAL
- en: Using Before launch actions in run configurations
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: We’ve seen that every run of our HTTP tests generates a new JSON file containing
    the response. This can fill up a folder pretty quickly with hundreds of files.
    Since PyCharm gives us a run configuration, we have the opportunity to set up
    some automation to delete older files. In this section, we’ll explore some automation
    capabilities available in PyCharm’s run configuration settings.
  prefs: []
  type: TYPE_NORMAL
- en: To do this you’ll need a script to delete the JSON files as you see fit. Perhaps
    you want to delete everything older than a week, or maybe you just want to keep
    the last 25 runs. This part is up to you.
  prefs: []
  type: TYPE_NORMAL
- en: 'In order to automate this, you need to create a shell script for your operating
    system. If you aren’t a shell scripting guru, that’s OK, because modern artificial
    intelligence can come to your rescue. *Figure 9**.16* shows me asking ChatGPT
    to create a shell script for the Bash shell that keeps only the last 25 JSON files
    generated by our test runs:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 9.16: I’ve asked ChatGPT about a few different ways to delete old
    files and it has generated a script for me](img/B19644_09_15.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 9.16: I’ve asked ChatGPT about a few different ways to delete old files
    and it has generated a script for me'
  prefs: []
  type: TYPE_NORMAL
- en: I realize you can’t see the whole script for Bash in the figure, so I’ll be
    sure to include it in the project source for this chapter.
  prefs: []
  type: TYPE_NORMAL
- en: Warning – never run generated scripts you don’t understand!
  prefs: []
  type: TYPE_NORMAL
- en: You should never blindly run a script generated by ChatGPT or anything (or anyone)
    else, including or even especially me, without fully understanding how it works!
    ChatGPT will probably not give you the same result it gave me, so exercise caution
    when running any script it gives you. Be especially wary if the script includes
    anything like `-Force` switches, as in the PowerShell script in the figure. If
    you don’t know what the script does, don’t run it on your computer!
  prefs: []
  type: TYPE_NORMAL
- en: To use the generated code, you can just add a new file to your project as you
    would any other. I’m going to right-click my project in the `Project` window and
    create a new file called `delete-old-http-test-results.sh`. Naturally, if you
    are on Windows, you’ll want to use PowerShell, which typically bears an extension
    of `.ps1`, so it would be `delete-old-http-test-results.ps1`. Copy the script
    generated by the AI once you fully understand the ramifications of running said
    script and save the file.
  prefs: []
  type: TYPE_NORMAL
- en: Make sure the script has run permissions
  prefs: []
  type: TYPE_NORMAL
- en: Make sure the script file you create has permission to run on your computer.
    Most editions of Windows heavily restrict running any PowerShell script, and your
    ability to do this might even be restricted by your employer’s security policy.
  prefs: []
  type: TYPE_NORMAL
- en: 'On Mac and Linux, you might need to run this in a terminal before PyCharm will
    execute the script:'
  prefs: []
  type: TYPE_NORMAL
- en: '`chmod +``x delete-old-http-test-results.sh`'
  prefs: []
  type: TYPE_NORMAL
- en: If you can’t run the script manually, it probably won’t work in PyCharm either.
  prefs: []
  type: TYPE_NORMAL
- en: 'Next, we need to create a run configuration that executes the script. Click
    the run configuration dropdown and click **Edit Configurations**. If you don’t
    remember how to do this, review [*Chapter 3*](B19644_03.xhtml#_idTextAnchor052),
    *Customizing Interpreters and Virtual Environments*. Add a new run configuration
    using the Shell Script template. You can see mine in *Figure 9**.17*:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 9.17: Create a run configuration for the shell script we just created](img/B19644_09_16.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 9.17: Create a run configuration for the shell script we just created'
  prefs: []
  type: TYPE_NORMAL
- en: 'You can navigate to the shell script using the folder button in the `httpRequests`
    folder inside the project’s `.idea` folder. Click the folder icon in the **Working
    directory** textbox to browse this folder. If you are not on Windows, this will
    be a hidden folder, so be sure to turn on viewing hidden folders in the selection
    dialog as I did in *Figure 9**.18*:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 9.18: To find the httpRequests folder inside the .idea folder, you
    need to turn on hidden folders by clicking the eyeball (ouch) on the top toolbar](img/B19644_09_17.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 9.18: To find the httpRequests folder inside the .idea folder, you need
    to turn on hidden folders by clicking the eyeball (ouch) on the top toolbar'
  prefs: []
  type: TYPE_NORMAL
- en: You now have a run configuration that executes your `delete` script. You should
    test it. Run your tests 26 more times, and verify you only have the last 25 results
    in your `httpRequests` folder. I’ll show you my results in the next 25 full-page
    color screenshots. Just kidding. Sometimes it’s fun to scare my editors.
  prefs: []
  type: TYPE_NORMAL
- en: 'If it works, and you’re happy, then there’s one more thing you can do to make
    it extra awesome. You can chain your delete script run configuration with your
    test run configuration. Edit the run configuration for the tests and add a `Before
    build` condition. Click the **+** button to add a new condition. Click **Run another
    run configuration**. Click **Delete Old HTTP Results run configuration**. You
    should see something like *Figure 9**.19*, which shows the deletion script will
    run before each new test run:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 9.19: The deletion run configuration will now run before each launch
    of my tests](img/B19644_09_18.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 9.19: The deletion run configuration will now run before each launch
    of my tests'
  prefs: []
  type: TYPE_NORMAL
- en: 'For the sake of the book, I changed my retention number to the last five JSON
    files and tried it out. After each run, I can look in my file browser, shown in
    *Figure 9**.20*, and see whether it’s working:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 9.20: After my run, there are seven JSON files since the delete script
    reduces the file count to five before the run, and the test produces results for
    two endpoints](img/B19644_09_19.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 9.20: After my run, there are seven JSON files since the delete script
    reduces the file count to five before the run, and the test produces results for
    two endpoints'
  prefs: []
  type: TYPE_NORMAL
- en: You’ll only ever have at most 25 results in your folder, or however many you
    specified in your script! Don’t forget, though, the deletion script runs first
    and PyCharm will generate one new JSON file for each tested endpoint. If I set
    my delete script to retain five JSON files and I run the generated test script,
    I’ll have seven files after the run since there are two endpoints being tested.
  prefs: []
  type: TYPE_NORMAL
- en: Using this technique, you can enable a great many automation scenarios for your
    code. Python doesn’t generally have a build script, like many languages, so it’s
    nice to know you have this level of automation available in the IDE itself. There
    were several options besides running another run configuration. I recommend you
    explore all the possibilities!
  prefs: []
  type: TYPE_NORMAL
- en: Working with HTTP Request environments
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Most web projects begin their life on a developer’s computer. When you test,
    you run your application locally on your laptop or PC, and all of your test requests
    are usually going to localhost, which is the loopback address assigned to every
    computer with a network card. The project starts out there, but assuming the app
    enjoys any level of success, it will not stay there.
  prefs: []
  type: TYPE_NORMAL
- en: Best practice dictates that applications intended for publication should use
    some sort of **continuous integration** (**CI**) environment where automated tests
    can be run. In fact, JetBrains makes a CI product called Team City. I used Team
    City for many years and can attest that it is an excellent CI system that is easy
    to set up, and it is free for small teams. These days, there is even a cloud version,
    so you needn’t set up your own servers if that’s not your thing. Team City, though,
    has the same plugin we’ve been using to create tests for our HTTP endpoints in
    our FastAPI project. This allows you to test your project automatically every
    time someone commits code to your source repository.
  prefs: []
  type: TYPE_NORMAL
- en: 'Once your code passes muster with the CI system, it is common for the code
    to be deployed to a testing server. This should be a server that is as much like
    production as you can manage. Some people call this a staging server, some call
    it **user acceptance test** (**UAT**). No matter what you call it, it represents
    an environment. Production too is an environment. An environment is simply a configuration
    environment where you can run your code. To be clear, so far, we’ve mentioned
    four such environments:'
  prefs: []
  type: TYPE_NORMAL
- en: Your local computer (localhost)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A CI environment, which these days is probably a Docker container
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A UAT/staging environment where you can test your app before you release it
    to production
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A production environment where your real customers use your app
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Each of these environments might have different attributes. For example, your
    FastAPI app running on your laptop can be accessed using the IP address `127.0.0.1`.
    By default, the app runs on port `8000`, and also by default, the protocol used
    is HTTP and not HTTPS since few developers take the time to set up an SSL/TLS
    certificate on their laptops.
  prefs: []
  type: TYPE_NORMAL
- en: However, when you test your application in staging, all of those parameters
    are different. You probably will have an SSL certificate, so you’ll use HTTPS
    as your protocol. You’ll definitely have a different IP address. You might even
    have a domain name server resolving a nice test domain name for your app. You
    probably won’t be using port `8000` since that would not be very production-like.
    Instead, you’ll be using port `443` or `80`, and in that case, you needn’t necessarily
    fill in the port at all.
  prefs: []
  type: TYPE_NORMAL
- en: The production too will have different attributes again.
  prefs: []
  type: TYPE_NORMAL
- en: 'In our API tests, we are able to configure a set of variables to be used in
    our test script, which are assigned to an environment name. Make sure you have
    the `test_main.http` file, or any `.http` file. Click the environment dropdown
    shown in *Figure 9**.21*:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 9.21: You can select an environment for running your tests each with
    it’s own configuration variables](img/B19644_09_20.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 9.21: You can select an environment for running your tests each with
    it’s own configuration variables'
  prefs: []
  type: TYPE_NORMAL
- en: 'I’ll be honest. I worked ahead and set one up, but we’ll pretend I didn’t.
    Right now, your only option is `http-client.env.json`. You can see mine in *Figure
    9**.22*:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 9.22: PyCharm created http-client.env.json, which will allow me to
    set up different environments for testing](img/B19644_09_21.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 9.22: PyCharm created http-client.env.json, which will allow me to set
    up different environments for testing'
  prefs: []
  type: TYPE_NORMAL
- en: If you had chosen the `http-client-private.env.json`. The purpose of and difference
    between the two files isn’t in the documentation as I write this, so we’ll have
    to use our imaginations. Personally, I put environments I want to share with my
    development team in the public file. If I want to create some sort of private
    environment, maybe a virtual machine, Windows Subsystem for Linux, custom experiments
    in Docker, or maybe a Kubernetes cluster in a lab, I can use the private file,
    which I would likely put in my `.gitignore` file. Since the file contents are
    the same, I’ll focus on the public file.
  prefs: []
  type: TYPE_NORMAL
- en: 'I’m going to add a definition for my local computer. Change the contents of
    `http-client.env.json` to this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: 'We now have a dev environment set up with some environment variables. Let’s
    use them in our `test_main.http` file. Your first endpoint definition looks like
    this:'
  prefs: []
  type: TYPE_NORMAL
- en: 'To use the environment variables, replace the parts of your URL with mustache-formatted
    text. Mustache format entails putting the variables you want to resolve in double
    curly braces like {{ this }}:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: Taken together, the URL will resolve to the original, which is [http://localhost:8000](http://localhost:8000),
    or if you prefer, [http://127.0.0.1:8000](http://127.0.0.1:8000). To*may*to to*mah*to.
    The difference is, now you can create your other environments in the same way.
    You can switch the environment and run the tests unchanged, and the environment
    variables will resolve your URLs for you.
  prefs: []
  type: TYPE_NORMAL
- en: If you review my code in this chapter’s sample code, you’ll find I’ve tricked
    out the whole file this way.
  prefs: []
  type: TYPE_NORMAL
- en: Let’s get CRUDdier and then get testier!
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Right now, the only thing in our app is two pre-generated endpoints. Let’s add
    some more to make this a little more interesting. We’re going to make a fake list
    app as we did in [*Chapter 8*](B19644_08.xhtml#_idTextAnchor203), *Building a
    Dynamic Web Application* *with Flask*.
  prefs: []
  type: TYPE_NORMAL
- en: Open up `main.py` and let’s add one endpoint for each CRUD operation, and in
    turn, each of the four main methods used in building RESTful APIs. We’re going
    to make some sweeping changes, so I’ll simply present them starting at the top
    of the file.
  prefs: []
  type: TYPE_NORMAL
- en: 'On the first line, where we have the import, change it to this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: 'The app instantiate was unchanged. Below it, though, add this list of amazing
    people:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: 'This list will serve as a fake database, saving us the time of setting up servers
    and the blah blah blah, which would seriously bloat the book and not contribute
    to our soon-to-be champion-level PyCharm prowess. We’re going to leave the first
    two generated endpoints alone, so just start your editing below the `say_hello`
    function’s return. Our first CRUD endpoint is going to give us a list of names
    as if from a database query:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: 'It is best practice to start the endpoints in your project, which are expected
    to return JSON data, rather than markup, with a prefix of `API` followed by a
    version designation. Trust me when I say that you want to do this. As your API
    code matures, you may want to offer updated endpoints that may not necessarily
    be backward compatible, and this technique allows you to keep your API backward
    compatible and non-breaking with your older clients while introducing improved
    functionality for newer clients. As the code matures further, you can remove the
    `v1` endpoints at a time of your choosing:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: 'On the preceding `POST` endpoint, it is a best practice for the successful
    call to return an HTTP status code of `201` indicating new data was created by
    the API. The FastAPI code works very differently from Flask. Instead of discrete
    request and response objects, everything is implicit. If you are expecting JSON
    to be posted as a payload to your API, you need only specify this using an argument
    type of `dict`. In this case, I am expecting data to be posted in this format:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: 'A real app would have a richer structure. We’re keeping it simple. When this
    JSON comes in as the payload for `POST`, we extract the name and append it to
    our list. For the sake of simplicity, I am not doing any validation on this endpoint.
    You should always validate your incoming data to protect yourself against toxic
    data and injection attacks. That’s the subject of another book. With that said,
    I won’t be a total slouch. I’ll do a little bit of this in the `PUT` endpoint,
    so you can see what some of this would look like. Remember, a `PUT` call is an
    `UPDATE` operation. We’re taking an `id` value and a new `name` value and we’ll
    change the existing value accordingly. Add these lines below your `create_name`
    function return:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: 'Now back to the code. Let’s make sure the ID attribute submitted is a number,
    specifically an integer:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: 'What’s happening here? If you submit an ID attribute that doesn’t resolve to
    a number, I’m going to send you back an HTTP error status code of `400`, which
    means your request is malformed. Just to be nice, I’m going to add a little message
    telling you what you did wrong. For example, say you use `PUT` on this data as
    follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: 'Everything should work. But say you use `PUT` for the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: 'Your request will fail. Raising the HTTP extension will cause the response
    to be sent immediately, and the rest of this code isn’t executed. So, let’s continue.
    If you submitted good data, we can move on and grab the new name:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: 'Next, we detect whether the numeric ID you submitted isn’t out of range. Our
    list starts off with four names in it. If you try to send an update to `id` 600,
    that shouldn’t work unless you’ve added at least as many names to the list via
    the `POST` endpoint. In a `PUT`, if you present an invalid `id` value, it is customary
    to send back a `404` error stating you couldn’t find that ID in your database
    (or list in our case):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: 'That’s three down and only one to go. For the `DELETE` endpoint, all I need
    is `id`. Sending a JSON payload for something this simple would be silly, so I’ll
    just take the ID as a parameter on the endpoint URL. I still need to check to
    make sure it is within range of the length of the `names` list:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: 'If it is, then I’ll just pop it out of the list and return a nice message:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: Run the app and make sure it starts. Make any adjustments needed. Remember,
    the final working code is in the chapter’s sample code from the repository we
    checked out in [*Chapter 2*](B19644_02.xhtml#_idTextAnchor028).
  prefs: []
  type: TYPE_NORMAL
- en: Getting testier
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: If I were all cruddy, chances are I’d be pretty testy, right? Now that we have
    more varied endpoints, let’s learn more about testing them with HTTP clients.
    As it turns out, the tool is extremely rich, as rich as dedicated tools such as
    Insomnia or Postman, just without all that UI in the way.
  prefs: []
  type: TYPE_NORMAL
- en: Open your `test_main.http` file and let us add tests. Not just simple ones,
    let’s make some real ones and get a feel for how the PyCharm workflow helps you
    build RESTful APIs.
  prefs: []
  type: TYPE_NORMAL
- en: These testing features of PyCharm work with any framework
  prefs: []
  type: TYPE_NORMAL
- en: I should mention that while we’re using FastAPI, these features are not unique
    or tied to that framework. These tools would work the same if you developed your
    API in Flask, or even in some other framework.
  prefs: []
  type: TYPE_NORMAL
- en: 'So far, you just have two tests, which were generated when you created your
    project:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: 'I didn’t specifically tell you to modify the second test endpoint with the
    environment variables we made earlier, but I went ahead and did it since that
    seems like an obvious improvement. As you add code to the test file, there are
    a few things worth noting:'
  prefs: []
  type: TYPE_NORMAL
- en: Requests may be stored in files with either `.http` or `.rest` extensions. So
    far, we’ve worked with the `.http` file that was generated with the project. In
    the wild, you may see either extension and there is no fundamental difference
    between them other than the icons displayed in the IDE. This is purely cosmetic.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Code highlighting and syntax completion are active. The syntax of these files
    is specialized, but you can expect the same level of tooling here as you would
    anywhere else.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Inline documentation will also appear for the code in this file.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Requests must be separated by three hashtag/pound signs: `###`. If you fail
    to add these, the IDE will let you know with a sea of red squiggly lines.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: You can paste a command-line cURL command into this file, and it will automatically
    convert it to the syntax used by PyCharm.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Templating is supported. We’ve already seen the environment variable substitution
    at work. Stay tuned, it’s about to get amazing!
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The test editor has a little bit of UI to it, but to be honest, once you learn
    the syntax, you probably won’t use it. Let me show you. Refer to *Figure 9**.23*:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 9.23: The test editor has a minimal UI](img/B19644_09_22.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 9.23: The test editor has a minimal UI'
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s look at the numbers:'
  prefs: []
  type: TYPE_NORMAL
- en: The **+** icon at **(1)** allows you to add another test. To be honest, this
    is easier to do directly in the editor, but if you like clicking things, here’s
    your jam.
  prefs: []
  type: TYPE_NORMAL
- en: The clock icon `httpRequests` folder inside the `.idea` project folder. Since
    PyCharm automatically reloads files when they change, leaving this file open allows
    you to see everything that is happening without having to look at the individual
    response files. Earlier, we added automation to remove many of these response
    files since there are often so many of them. This doesn’t affect the log file
    since the request information is appended from the log window instead of the response
    file itself. In fact, the log shows the response data too.
  prefs: []
  type: TYPE_NORMAL
- en: Pro tip – open the log in a split view so you can always see it
  prefs: []
  type: TYPE_NORMAL
- en: If you right-click the tab containing the log file and select one of the split
    options, such as **Split Right**, the tab will open in a separate tab group. If
    you have a nice wide 4K monitor, you have plenty of room to keep the log open
    alongside your code and test files so you can see it all together.
  prefs: []
  type: TYPE_NORMAL
- en: The document icon at **(3)** is there to make command-line mavens happy. If
    you select a request and click this button, you are able to generate a cURL command,
    which can then be pasted into a terminal window. The import icon at **(4)** gives
    you a UI where you can paste a cURL command whereupon it will be converted to
    the request format used by PyCharm. This isn’t all that useful since you can paste
    a cURL command directly into the editor itself and the conversion happens automatically.
  prefs: []
  type: TYPE_NORMAL
- en: 'We’ve already seen the **Run All Tests** button at **(5)**, as well as the
    environment selection dropdown. Probably, the most useful item on this toolbar,
    apart from the history log, is the link to the examples at **(6)**. This is not
    fancy, but it is useful. Clicking this link will open a file that contains a slew
    of examples that you can copy, paste, and modify. Essentially, this is the same
    thing that happens when you click the UI button at position **(1)**. To me, opening
    the samples is faster and easier because you can see them all in one place. To
    use it, just click the ***Examples** link as shown in *Figure 9**.24*:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 9.24: The test examples are broken out by category](img/B19644_09_23.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 9.24: The test examples are broken out by category'
  prefs: []
  type: TYPE_NORMAL
- en: 'I like to use the `POST` requests sample open to the side, as in *Figure 9**.25*:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 9.25: You can open the samples to the side for easy pasting](img/B19644_09_24.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 9.25: You can open the samples to the side for easy pasting'
  prefs: []
  type: TYPE_NORMAL
- en: To split the files like this, just right-click the tab and click **Split Right**,
    or left, up, or down according to your preferences.
  prefs: []
  type: TYPE_NORMAL
- en: Creating the tests
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Let’s create those tests! Make sure you are working in `test_main.http`. Add
    these lines below your last test:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: 'The three hashtags are the separator between tests. The rest are variables
    coming from the environment variables we created earlier. This will translate
    to http://localhost:8000/api/v1/names. Make sure your app is running and run the
    test. You should see some results like those in *Figure 9**.26*:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 9.26: When you run the test, you can see the response data in the
    log view. The left side of my results will normally look different than yours](img/B19644_09_25.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 9.26: When you run the test, you can see the response data in the log
    view. The left side of my results will normally look different than yours'
  prefs: []
  type: TYPE_NORMAL
- en: 'This is nice, right? You can see you got back a good status code (`200`), and
    you can see your data. What if you could turn this into a proper test? You can!
    Go back to the `test_main.http` file. Every great moment in American, and perhaps
    world, history was preceded by the phrase I will utter next: *Hold my beer and*
    *watch this*.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Right below your test, add this code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: The first character is crucial. You have to type a `>` followed by `{%`. If
    you don’t, PyCharm will become quite cross! Just stare at the majesty for a moment.
    Take it all in. What we have here is a test. WRITTEN IN JAVASCRIPT! I’m sorry.
    I should have warned you to sit down or something. I did, however, mention that
    beer was involved. There is some magic here. There is a `client` object inherent
    in this test window, not unlike the `window` object that is ever-present in a
    browser window. We’re invoking the `.test` method on that client object and we’re
    passing it two arguments. The first is a string that describes the test. This
    can be anything you’d like. The contents do not affect the test in any way. The
    second argument is an anonymous function that actually executes the test. If you’re
    not up on JavaScript’s use of lambda-style functions, you’re just going to have
    to roll with it and copy these tests from examples. I suppose you could also go
    learn JavaScript, but that might take a while. Thankfully, the `client.assert`
    part seems like the tests we wrote in [*Chapter 6*](B19644_06.xhtml#_idTextAnchor145),
    *Seamless Testing, Debugging, and Profiling*, so let’s keep going. The assert
    takes an expression that will evaluate to true or false. JavaScript uses a triple
    equals sign for testing equality without coercion. If you have not heard of this,
    for now, just know you should always be using three equals signs because using
    two means something else and you don’t want that. A double equals sign, which
    is the norm in Python, might yield a false failure in your JavaScript test code
    because JavaScript will attempt to force any data types it encounters to match.
    The triple equals avoid this.
  prefs: []
  type: TYPE_NORMAL
- en: 'After the conditional statement, we have a JavaScript template literal. This
    is the equivalent of a Python `f`-string. You use the gravure marks for quotes.
    The gravure mark is the shifted tilde (~) on a US keyboard, and it looks like
    a heavy single quote: `. Enclosing a string within the gravure marks specifies
    the string to be a template literal. You can substitute expressions or variable
    values using `${whever}` in the curly braces. So, in Python, given the `foo =
    bar variable`, an `f`-string would be as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '`f"I''d rather be at` `the {foo}."`'
  prefs: []
  type: TYPE_NORMAL
- en: 'In JavaScript, given `const foo = "bar"`, it would be as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '`` `I''d rather be at `` `` the ${foo}` ``'
  prefs: []
  type: TYPE_NORMAL
- en: Here, I’ve used the template literal to give a little more information since
    this second string literally exposes a message seen when the test fails.
  prefs: []
  type: TYPE_NORMAL
- en: This particular test checks to make sure that the HTTP response code for the
    request was `200`, which indicates it was successful. If you don’t include a test
    like this, then your results will always be green even if your endpoint code melted
    the server and summoned the great Cthulu from his deep slumber at the heart of
    the cosmos. This is a test that should be included every single time, though the
    expected code might change depending on what you’re doing.
  prefs: []
  type: TYPE_NORMAL
- en: More tests you should always add
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Checking your status code is the bare minimum. I assert (see what I did there?)
    that you should check as many things as you can think of. Here, I’ll add a test
    to verify the returned data has a mime type of `application/json`, which is important
    to the way clients will consume this data. Add this below our earlier test:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: Remember, it’s JavaScript! So here, I’ve added a constant called `type` and
    pulled the value from another magical object available in the test window. `response.contentType.mimeType`
    gives you exactly that. We test to make sure it is `"application/json"`. Personally,
    I think attention to detail is important, and I see APIs created by professionals
    as being very unprofessional if the content type isn’t set correctly. As it happens,
    FastAPI does this for us, but not every framework will.
  prefs: []
  type: TYPE_NORMAL
- en: Now that you have the basics down, I invite you to explore my finished `test_main.http`
    file in the chapter’s sample code. There are tests there for all the conditions
    we put into the `PUT` endpoint allowing you to make sure the `400` status is returned
    if your user sends a non-numeric ID. There is also a test to make sure you get
    a `404` error if your ID is beyond the acceptable range for the `names` list.
  prefs: []
  type: TYPE_NORMAL
- en: Editing and debugging a full stack app by attaching projects
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: PyCharm has the ability to attach multiple projects together allowing you to
    work on full stack applications in the same instance of the IDE. When you are
    running multiple attached projects in your PyCharm IDE, you can debug them together
    in a seamless fashion! This capability alone is probably reason enough to stop
    using vim or VS Code and never look back! While it is possible to do this in other
    IDEs or even VS Code, PyCharm makes it so easy you’ll probably not want to.
  prefs: []
  type: TYPE_NORMAL
- en: Creating a React app in a separate project
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: To create a frontend for our FastAPI backend, we’re going to leverage React.
    As usual, I won’t have the space here to teach you a lot about React. I’ll make
    sure there is some reference reading in the *Further reading* section at the end
    of this chapter.
  prefs: []
  type: TYPE_NORMAL
- en: To create a React app in PyCharm Professional, just use the usual **File | Project**
    operation to which you have hopefully become accustomed. There is a project template
    that leverages an open source product called **create-react-app** (**CRA**). This
    is a tool widely used by React developers because, in truth, setting up a full-on
    React app from scratch is tedious and time-consuming.
  prefs: []
  type: TYPE_NORMAL
- en: 'In order for this `create-react-app` script to work, you need to have Node.js
    installed. If you don’t, PyCharm will attempt to install it for you, as you can
    see in *Figure 9**.27*:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 9.27: When creating a JavaScript project, such as a React project,
    you’ll need to have Node.js installed, otherwise PyCharm will try to install it
    for you](img/B19644_09_26.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 9.27: When creating a JavaScript project, such as a React project, you’ll
    need to have Node.js installed, otherwise PyCharm will try to install it for you'
  prefs: []
  type: TYPE_NORMAL
- en: In my experience, this doesn’t always work out. This same feature exists in
    Visual Studio, and I usually advise my students to install Node.js manually, rather
    than have an IDE do it. In general, the IDEs often don’t point to the latest release
    of Node.js. I can see in *Figure 9**.27* that PyCharm intends to install 16.16.0,
    which isn’t the latest. Besides, looking at the right version, I further recommend
    you use the latest **long-term support** (**LTS**) version of Node.js rather than
    the version with the highest version number. The LTS product is guaranteed stable,
    whereas the absolute newest version isn’t.
  prefs: []
  type: TYPE_NORMAL
- en: Another thing I recommend with Node.js, and Python too, for that matter, is
    to use a package manager such as **Chocolately** ([https://chocolatey.org/](https://chocolatey.org/))
    or **Homebrew** ([https://brew.sh/](https://brew.sh/)). Package managers are standard
    affairs on Linux, and every distribution uses their own, so if you’re using Linux,
    I’ll assume you know which one you need. The reason I advocate using package managers
    for installing Node.js is that the package manager makes it very easy to update,
    or even fully remove, your software should you ever need to. If you want to try
    out Homebrew for Mac, there is a short, free course on my website that teaches
    you to set up an Apple computer for Node.js development. You can find it at [https://www.maddevskilz.com/courses/setting-up-a-nodejs-development-workstation-in-macos](https://www.maddevskilz.com/courses/setting-up-a-nodejs-development-workstation-in-macos).
    I’ll look at making more of these after I finish writing this book, so check the
    site if you want to see the Windows version.
  prefs: []
  type: TYPE_NORMAL
- en: Having installed Node.js manually, let’s get back to creating our React project.
    I called my project `namelist`. React is picky about names, so I picked one that
    I know will work. I’ll leave fancier names to books about React. Click the **Create**
    button. CRA takes a while, but once it is finished, you should have a project
    folder ready to go. We are now ready to go 100% full stack! Next, I’m going to
    show you my favorite technique in PyCharm to work on both projects as if they
    were one, while maintaining full separation of the UI code from the backend.
  prefs: []
  type: TYPE_NORMAL
- en: Attaching the project to the FastAPI project we created earlier
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Open the `fastAPIProject` folder we created at the beginning of this chapter.
    Now, use the `namelist` folder containing the React project. Usually, when we
    do this, we tell PyCharm to open the project either in a new window or in the
    current window. This time, I want you to tell it to attach the project to the
    current one, as shown in *Figure 9**.28*:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 9.28: Pick the attach option when you open the React project](img/B19644_09_27.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 9.28: Pick the Attach option when you open the React project'
  prefs: []
  type: TYPE_NORMAL
- en: 'You will find both projects open at the same time in the IDE. This is evident
    in the project window shown in *Figure 9**.29*:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 9.29: Both halves of a full stack app can be open at the same time,
    allowing you to run and debug them as if they were one project](img/B19644_09_28.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 9.29: Both halves of a full stack app can be open at the same time,
    allowing you to run and debug them as if they were one project'
  prefs: []
  type: TYPE_NORMAL
- en: 'Working with attached projects makes for a very enjoyable experience in full
    stack development. Consider the benefits:'
  prefs: []
  type: TYPE_NORMAL
- en: Technically, they are separate projects in separate repositories.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: PyCharm allows you to create run and debug configurations for all attached projects.
    For example, it is possible to set a breakpoint in your React app to examine some
    form of data just before it is submitted. Then in your FastAPI project, you can
    set a breakpoint in the endpoint function to inspect the data received, making
    it easy to find errors in data formatting between the two projects.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Other people who are not able to work full stack can still work on individual
    projects separately.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'In [*Chapter 11*](B19644_11.xhtml#_idTextAnchor266), *Understanding Database
    Management with PyCharm*, we’ll learn that you can work with the frontend, the
    backend, and databases, all from within one PyCharm window. For full stack development,
    PyCharm is hard to beat! But first, in the next chapter, let’s look at a third
    web development framework supported by PyCharm: Pyramid.'
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we effectively covered everything you need to know in order
    to get started creating a RESTful API project using FastAPI in PyCharm.
  prefs: []
  type: TYPE_NORMAL
- en: FastAPI is distinct from Flask, and many other template-oriented web development
    frameworks, in that it is specifically designed to create only RESTful APIs. A
    RESTful API is a backend that is decoupled from any frontend markup, layout, interactivity,
    or display logic. Instead, the API focuses solely on receiving requests bearing
    user interaction data and returning processed data, such as that retrieved or
    processed in a relational database.
  prefs: []
  type: TYPE_NORMAL
- en: Since these types of applications focus on data, we learned that an SPA is normally
    used to serve as the frontend presentation layer. A number of modern frameworks
    support this paradigm, including React, Angular, and Vue. It is the frontend application’s
    job to control the application state since HTTP is a stateless protocol, and any
    backend would be ill suited to this responsibility.
  prefs: []
  type: TYPE_NORMAL
- en: Creating the FastAPI project was easy using the template built into PyCharm
    Professional. It generated starting code as well as a special type of test file
    unique to PyCharm. The HTTP file contains a specification for a request, and a
    testing framework based on JavaScript, which allows us to validate the response
    with the same kind of assertion logic we saw in our earlier exposure to unit testing.
  prefs: []
  type: TYPE_NORMAL
- en: Finally, we created a React frontend in a separate, but connected (attached),
    project in PyCharm, allowing you to develop a full stack application without mingling
    the frontend JavaScript code with the backend Python code. In the next chapter,
    we will discuss Django and Pyramid.
  prefs: []
  type: TYPE_NORMAL
- en: Questions
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: What framework serves as the basis for FastAPI, and what makes it different
    from Flask and Werkzeug?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: What is meant by “representational state transfer” and what problem does it
    solve?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Where is the application state stored in a RESTful API project using an SPA
    as its frontend?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: What are the four most widely used HTTP methods?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: What are CRUD methods, and how do the HTTP methods map to CRUD methods?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: What are the benefits of keeping frontend and backend projects separate, and
    how does PyCharm make working with such full stack projects easier?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Further reading
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Garret, J. J. (2005). A new approach to web applications. [http://www.adaptivepath.com/publications/essays/archives/000385.php](http://www.adaptivepath.com/publications/essays/archives/000385.php).
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Pandey, R. (2023) Build Full Stack Projects with FARM Stack [Video]. Packtpub.com
    [https://www.packtpub.com/product/build-full-stack-projects-with-farm-stack-video/9781803236667](https://www.packtpub.com/product/build-full-stack-projects-with-farm-stack-video/9781803236667)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Van Horn, B. (2021) Setting Up a Python Development Workstation in Windows 10\.
    maddevskilz.com [https://www.maddevskilz.com/courses/setting-up-a-python-development-workstation-in-windows](https://www.maddevskilz.com/courses/setting-up-a-python-development-workstation-in-windows
    )
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Van Horn, B. (2021) Setting Up a NodeJS Development Workstation in MacOS. maddevskilz.com
    [https://www.maddevskilz.com/courses/setting-up-a-nodejs-development-workstation-in-macos](https://www.maddevskilz.com/courses/setting-up-a-nodejs-development-workstation-in-macos)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Be sure to check out the companion website for the book at [https://www.pycharm-book.com](https://www.pycharm-book.com).
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
