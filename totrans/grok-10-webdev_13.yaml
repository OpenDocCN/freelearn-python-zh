- en: Chapter 12. Grokkers, Martian, and Agile Configuration
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Agility is very important in Grok, and having to do less configuration to get
    an application running is the key to being **agile**. In Grok parlance, a **grokker**
    is a piece of code that allows developers to use framework functionality by making
    declarations in the code instead of using ZCML configuration files. In this chapter,
    we introduce **Martian** the library that is used to create grokkers and demonstrate
    how to create a simple one for our application. Among the subjects that we will
    cover are:'
  prefs: []
  type: TYPE_NORMAL
- en: What Martian is
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Why it is needed and how Grok uses it
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: What a grokker is
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: How to create a grokker
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Agile configuration
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: As we explained at the very beginning of this book, when we use the Zope Toolkit
    without Grok, we must use ZCML to configure everything. This means that we have
    to add ZCML directives for every view, viewlet, adapter, subscriber, and annotation
    in our code. That's quite a lot of markup there, all of which has to be maintained
    along with the code. Agility is not the first thing that comes to mind when we
    think about this.
  prefs: []
  type: TYPE_NORMAL
- en: Grok's developers knew from experience that the Zope Toolkit and the **Zope
    Component Architecture** (**ZCA**) enable developers to create advanced object-oriented
    systems. This power comes at the cost of a raised barrier of entry for new developers.
  prefs: []
  type: TYPE_NORMAL
- en: Another thing that proved to be a problem for Zope Toolkit adoption, is its
    emphasis on explicit configuration. ZCML allows developers to be very explicit
    and flexible in their application configuration, but it requires separate files
    for configuration, and takes more time to create, maintain, and understand. You
    simply need more time to understand an application because you have to take a
    look at the different pieces of code and then consult the ZCML files to see how
    they are connected with each other.
  prefs: []
  type: TYPE_NORMAL
- en: Grok was designed in such a way that, if the developer follows certain conventions
    in his code, there is no need for configuration files. Instead, Grok analyzes
    the Python code for the use of these conventions, and then 'groks' them. Behind
    the scenes, everything is connected just as it would be if the configuration was
    written with ZCML, but the developer doesn't even need to think about that.
  prefs: []
  type: TYPE_NORMAL
- en: As a result of this process, known as 'grokking', the code for a Grok application
    is clean and uniform. The entire configuration is in the code, in the form of
    directives and components, so it's easier to follow, and more fun to develop.
  prefs: []
  type: TYPE_NORMAL
- en: Grok is definitely more agile than the Zope Toolkit alone, but it's not a subset
    or a 'stripped down' version of it. All of the power of the Zope Toolkit is available
    to the developer. Even explicit configuration can be used with ZCML when it's
    needed, as we saw when we configured the SMTP mailer, in the previous chapter.
  prefs: []
  type: TYPE_NORMAL
- en: The Martian library
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The part of Grok that does the code 'grokking' has been extracted into a standalone
    library called Martian. This library provides a framework that allows configuration
    to be expressed in Python code, in the form of declarative statements. The idea
    is that, often, the structure of a piece of code can be examined and most of the
    configuration steps that it requires are deduced from this. Martian takes this
    a step further by using directives to annotate the code, making configuration
    requirements even more obvious.
  prefs: []
  type: TYPE_NORMAL
- en: Martian is published as a standalone library because even though, it's a key
    part of Grok, it can be very useful for adding declarative configuration to any
    kind of framework. For example, `repoze.bfg` ([http://bfg.repoze.org](http://bfg.repoze.org)),
    a minimalist web framework based on Zope concepts, uses Martian to optionally
    allow the view configuration without ZCML.
  prefs: []
  type: TYPE_NORMAL
- en: At program startup time, Martian reads the Python code in a module and analyzes
    all of the classes to see if they belong to a 'grokked' base class (or a subclass
    of one). If they do, Martian retrieves information from the class registration
    and any of the directives that it may contain. This information is then used to
    perform component registrations in the ZCA registry, much like the ZCML machinery
    does. This process is called 'grokking' and as you see, allows for quick registration
    of plugins within the framework. Grokkers allow us to write "agility" and "Zope
    Toolkit" in the same sentence again, without being ironic about it.
  prefs: []
  type: TYPE_NORMAL
- en: Understanding grokkers
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: A grokker is a package that includes a base class to be grokked, a series of
    directives for configuring that class, and the actual code that performs the registration
    process using Martian.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s take a look at a regular Grok view definition:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: In this code, `grok.View` is a grokked class, which means that, when the "Grok
    time" comes at program startup, it will be found by Martian, 'grokked', and registered
    with the ZCA. The `grok.context` and `grok.template` declarations are the configuration
    directives available for this class. The actual 'grokking' is done by a piece
    of code associated with the grokked class, which registers a named adapter with
    the ZCA registry for the interface that is passed in the `grok.context` directive.
    The registration is done by using the class name to name the view, and whatever
    string value is passed as a parameter to the `grok.template` directive is used
    to name the associated template.
  prefs: []
  type: TYPE_NORMAL
- en: That's all that grokking means, so if we have the three required parts, we can
    easily make our own grokkers.
  prefs: []
  type: TYPE_NORMAL
- en: The grokked class
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Any class can be grokked; there are no special requirements. This makes it
    easy for a developer to get started, and is a lot less confusing to work with.
    Imagine that we have some `Mailer` class that we want to grok. It can be as simple
    as this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: Of course, it could be as complex as needed, but the point is that it doesn't
    need to be.
  prefs: []
  type: TYPE_NORMAL
- en: The directives
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Once we have a class that we want to grok, we define the directives that we
    may need for configuring it. Again, there's nothing required of us here. We could
    perhaps perform our configuration without the need for directives, but most of
    the time we may need a couple of them.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: Directives do need to inherit from the `martian.Directive` subclass. Also, they
    need to at least specify a scope, and probably a default value as well. Here,
    we defined two directives `hostname` and `port`, which will be used to configure
    the mailer.
  prefs: []
  type: TYPE_NORMAL
- en: The class grokker
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The final piece of our grokker is the one that does the actual registration,
    and it comes in the form of a class that inherits from `martian.ClassGrokker:`
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: The grokker class connects the grokked class with its directives, and does the
    grokking, or registration. It has to include an `execute` method that will take
    care of any configuration actions.
  prefs: []
  type: TYPE_NORMAL
- en: The `martian.component` directive connects the grokker with the class to be
    grokked, in this case, `Mailer`. The directive `martian.directive` is used to
    associate the various directives that we defined earlier with this grokker.
  prefs: []
  type: TYPE_NORMAL
- en: Finally, the `execute` method takes the base class and the directive values
    declared in the code that uses the grokker, and performs the final registration.
    Note that the `register_mailer` method (which would actually do the work here)
    is not present in the preceding code, because all we want to show here is the
    structure of a grokker.
  prefs: []
  type: TYPE_NORMAL
- en: The only ZCML you'll ever need
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Once the grokker is available, it has to be configured to be initialized and
    used, by the Grok registration machinery at startup time. To do that, we have
    to use a bit of ZCML in a file named `meta.zcml:`
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: If our `MailGrokker` class is inside the `meta.py` file, it will be initialized
    by the Grok machinery.
  prefs: []
  type: TYPE_NORMAL
- en: Creating our own grokker for zope.sendmail configuration
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Now that we know how a grokker is structured, let's create one for the SMTP
    mailer from the `zope.sendmail` that we used in the section about adding e-mail
    notifications (in Chapter 11) to our application.
  prefs: []
  type: TYPE_NORMAL
- en: What we want is to have a simple `MailGrokker` class declaration with `hostname,
    port, username, password`, and `delivery type` directives. This will allow us
    to avoid using ZCML to configure the mailer, as we were required to do in the
    previous section.
  prefs: []
  type: TYPE_NORMAL
- en: We'll have to create a new package, so that our grokker is independent of the
    `todo_plus` code and can be used freely elsewhere.
  prefs: []
  type: TYPE_NORMAL
- en: Creating the package
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: We performed these steps in the *Creating the new package* section of Chapter
    11\. If you have any doubts, please refer to that section for details.
  prefs: []
  type: TYPE_NORMAL
- en: 'To create the package, go into the `src` directory of our main `todo` application,
    and type:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: 'This will create a `mailgrokker` directory. Now, navigate to this directory
    and add `grok, martian`, and the `zope.sendmail` package to the `install_requires`
    declaration:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: In this way, we make sure that the required packages are present, once `mailgrokker`
    is installed. We also have to add our new `mailgrokker` package to the main `buildout.cfg`
    file at the top level of our project, immediately under `todo_plus`. Do this in
    both the eggs and the develop sections.
  prefs: []
  type: TYPE_NORMAL
- en: Writing our grokker
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'First, we''ll add a `configure.zcml` file, which is just like the one in the
    `todo_plus` package. In fact, we can copy it from there:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: 'Our grokked class will be inside the `component.py` file. Here, we are using
    only one base class, but a grokker project could include several base classes,
    and by convention they are defined here:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: This is just a simple base class with no methods. The `grok.baseclass` directive
    is used to mark it as a base class, although this is not mandatory.
  prefs: []
  type: TYPE_NORMAL
- en: The configuration directives are stored in a file named `directives.py:`
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: This is very straightforward. We just define all of the directives that we need,
    and then add a `martian.CLASS` scope. Each directive has its own default value,
    depending on its purpose. The intent of each directive should be obvious just
    by looking at the code, except perhaps for the `delivery` directive. This directive
    is needed because `zope.sendmail` includes two different delivery mechanisms `direct`
    and `queued`.
  prefs: []
  type: TYPE_NORMAL
- en: Now comes the main grokker class, which we will add to the `meta.py` file. First,
    are the `import` statements. Note that here we import `martian` as well as `GrokError`,
    which is an exception that we can throw if the grokking fails. We also import
    everything that we are going to use from the `zope.sendmail` library.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: The `register_mailer` function creates a `zope.sendmail` SMTP mailer object,
    and registers it as a named utility for `IMailer`, with the name taken from the
    `name` directive. Note the use of the `getGlobalSiteManager` function, which is
    really a fancy name for getting the component registry. We use the `registerUtility`
    function of the registry to add our newly created `SMTPMailer` instance.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: Continuing with the `register_mailer` code, we now use the selected delivery
    mechanism, which was passed as a parameter, to decide if we should initialize
    a `DirectMailDelivery` instance or a `QueuedMailDelivery` instance. Either way,
    we register the result as a utility.
  prefs: []
  type: TYPE_NORMAL
- en: In the case of a `queue` delivery mechanism, a thread that will take care of
    sending e-mail separately from the main application code is started.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: The `MailGrokker` class declares all of the directives that we added to the
    `directives` module, and associates itself with the `Mailer` class that it will
    grok. It then defines the `execute` method that will call the `register_mailer`
    function to perform the required `zope.sendmail` registrations.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: The only difference between the above code and the code that we showed earlier
    is that instead of calling the `register_mailer` function directly, we wrap it
    inside a `config.action` object. This is done so that Grok can perform the registrations
    in an arbitrary order after the code is loaded, instead of doing that as it initializes
    each package. This prevents any configuration conflicts, and allows us to be specific
    about the registration conditions.
  prefs: []
  type: TYPE_NORMAL
- en: For example, the `discriminator` parameter, which could be empty, is, in this
    case, a tuple containing the string `utility`, the interface `IMailer`, and the
    value of the `name` directive. If any other grokker package uses this same discriminator,
    Grok will signal a conflict error condition.
  prefs: []
  type: TYPE_NORMAL
- en: The `order` parameter of the `action` is used to dictate the order in which
    the actions are called, although here it was added for demonstration purposes
    only. The `callable` parameter is the function that will perform the registration,
    and the `args` parameter contains the parameters that will be passed to it.
  prefs: []
  type: TYPE_NORMAL
- en: 'We now have our grokker in the `meta` module, and need to tell Grok to find
    it here, which we do by adding the small `meta.zcml` file discussed earlier:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: 'Finally, edit the existing `__init__.py` file, which is inside `src/mailgrokker/mailgrokker`
    directory, to look like the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: This will allow us to use the directives simply by importing the main `mailgrokker`
    module, much in the way that `grok.*` directives work.
  prefs: []
  type: TYPE_NORMAL
- en: Using mailgrokker
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Now that we are done with our grokker, the only thing that is missing is to
    show how it would be used inside an application. We will add it to the `todo_plus`
    package. Insert the following lines at the bottom of that file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: Obviously, you should substitute the values shown here with the real values
    of your `smtp` server. You might also want to eliminate the mailer configuration
    that we placed in the `configure.zcml` file, earlier.
  prefs: []
  type: TYPE_NORMAL
- en: Done. We have now created a small grokker package that can be used in any of
    our applications in order to easily configure e-mail submissions.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter we learned about the Martian library and how it enables Grok
    to be an agile framework. We are now ready to discuss how to debug our applications.
  prefs: []
  type: TYPE_NORMAL
