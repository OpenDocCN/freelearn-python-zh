<html><head></head><body><div class="chapter" title="Chapter&#xA0;4.&#xA0;Glyph Lefkowitz"><div class="titlepage"><div><div><h1 class="title"><a id="ch04"/>Chapter 4. Glyph Lefkowitz</h1></div></div></div><div class="mediaobject"><img src="graphics/B08180_08_01.jpg" alt="Glyph Lefkowitz"/></div><p>Glyph Lefkowitz<a id="id87" class="indexterm"/> is an American software engineer who has worked on numerous open source projects. Previous roles include senior software engineer at Apple, and today he works at Pilot.com, a bookkeeping service for start-ups. Glyph is the original founder of Twisted, a network programming framework written in Python. He continues to maintain Twisted and play an active role in the Twisted community. In 2009, Glyph was made a fellow of the Python Software Foundation (PSF). The PSF awarded Glyph its Community Service Award for contributions to the Python language in 2017.</p><div class="blockquote"><blockquote class="blockquote"><p>
<span class="strong"><strong>Discussion themes:  v2.7/v3.x, Python's future, diversity.</strong></span>
</p><p>
<span class="strong"><strong>Catch up with Glyph Lefkowitz here: @glyph</strong></span>
</p></blockquote></div><p>
<span class="strong"><strong>Mike Driscoll</strong></span>: So<a id="id88" class="indexterm"/> how did you end up becoming a programmer?</p><p>
<span class="strong"><strong>Glyph Lefkowitz</strong></span>: Well, my programming path was somewhat circuitous. I started off programming as a kid, but I do not have the stereotypical story of learning BASIC, then Perl. There wasn't a linear progression, or some professional aspiration that I had to do programming.</p><p>I just wanted to make games like Zork when I was a kid. My dad is a professional programmer, so he tried to teach me APL. I did not take to programming quickly. I learned how to assign variables and that was it. I had no idea what variable assignment meant. That was where I stayed for about five years.</p><p>Then I learned <a id="id89" class="indexterm"/>HyperCard and I started to get the notion of control flow and loops. I tried to make video games with it. The whole time, for my entire childhood, I was trying to avoid learning to program. I was always looking for non-programmer stuff to do, because I was terrible at math.</p><div class="blockquote"><blockquote class="blockquote"><p>
<span class="strong"><strong>Glyph Lefkowitz: 'The whole time, for my entire childhood, I was trying to avoid learning to program.'</strong></span>
</p></blockquote></div><p>So after a while, HyperCard sort of got limiting. I got SuperCard and at some point, I learned what a variable was and how to make programs that would actually operate on data structures. Then I learned C++. Once I understood the power inherent in programming, after years of trying to avoid it, then I really got into it.</p><div class="blockquote"><blockquote class="blockquote"><p>
<span class="strong"><strong>Glyph Lefkowitz: 'Once I understood the power inherent in programming, after years of trying to avoid it, then I really got into it.'</strong></span>
</p></blockquote></div><p>I learned Java, I learned Perl, I learned Lisp and I learned Scheme, all in high school. I taught a programming class at my high school, so I got really into it by the time I was about 17. But it was quite a slog on the way up there.</p><p>
<span class="strong"><strong>Driscoll</strong></span>: So how did that end up pushing you<a id="id90" class="indexterm"/> from all those other languages into Python?</p><p>
<span class="strong"><strong>Lefkowitz</strong></span>: Well, by the time I started my professional career, I'd sort of settled on Java.</p><p>I had some really terrible experiences with the proprietary runtime, particularly for macOS, that shipped with Java. So I had professional experience with the runtimes being really bad. Basically, there was a bug in the windowing system that the application I was working on kind of leaned on.</p><p>The application could not be rearchitected to avoid tickling this bug, because the bug was connected with leaking large amounts of memory. So effectively the project that I was on died and I lost the job. I ended up being unemployed for a couple of months and as a result of that experience I thought well, screw Java, I'm not doing that anymore, mainly because of the runtime issues.</p><div class="blockquote"><blockquote class="blockquote"><p>
<span class="strong"><strong>Glyph Lefkowitz: 'I ended up being unemployed for a couple of months and as a result of that experience I thought well, screw Java.'</strong></span>
</p></blockquote></div><p>My very first reaction was to see what GNU had on offer for a Java compiler. I thought maybe I could do Java, but not touch the runtime stuff, because it was just too buggy. The conclusion from that was rapidly that none of that stuff worked.</p><p>So at the same time, my hobby project, which does exist to this day, was this online text-based game which I had written in Java. A tremendous amount of the work that I had done in Java was building up these hash tables full of objects with run methods.</p><p>There were then arguments to the run methods, which I would inject into them with reflection. The whole idea was that you were supposed to wire the game together at runtime. It was kind of <a id="id91" class="indexterm"/>user-programmable, but in a more restricted way.</p><p>
<span class="strong"><strong>Driscoll</strong></span>: So how did this game work?</p><p>
<span class="strong"><strong>Lefkowitz</strong></span>: You would have a set of building blocks that were somewhat constrained, so that if you made something, it could have game consequences and not just flavor text that it would print. So almost all of the code in the Java version was this tremendous amount of ceremony, associated with dynamically composing objects, out of other objects that might be arbitrary collections.</p><p>I reimplemented the whole thing in Python and I realized that you didn't need to do any of that stuff. Objects in Python were just these dynamic collections of things, that you could arbitrarily add attributes to and retrieve attributes from. You could look into other dicts and all that stuff.</p><div class="blockquote"><blockquote class="blockquote"><p>
<span class="strong"><strong>Glyph Lefkowitz: 'I reimplemented the entire thing, which was about 25,000 lines of Java in 800 lines of Python, and I thought it was a much better program.'</strong></span>
</p></blockquote></div><p>So I reimplemented the entire thing, which was about 25,000 lines of Java in 800 lines of Python, and I thought it was a much better program. Now granted, what I had implemented in Java was a crummy version of the Python object model, so it was particularly easy to implement.</p><p>One of my interests that has endured over many years is composability and the ability to automatically assemble. I want the ability to make programs self-symmetric, so that you can have a large number of implementations of the similar interface and compose them automatically. Python's metaprogramming facilities were in this wonderful sweet spot between say Lisp or Scheme, where there was so much power that nothing was compatible. No two people would write the same object model in those languages.</p><p>At the other end, with something like Java, everything was very standardized, but it didn't matter, because everything was also really tedious. You couldn't automatically pull things together and everything was very verbose, so it wasn't worth trying to do any metaprogramming.</p><p>Python is standard enough that things work together, but flexible and high-level enough that you get almost as much power as Lisp macros. So that's why I've stuck with it ever since, although because I know a bunch of other languages, I periodically venture into them. But Python is definitely my main language that I've built my career on.</p><div class="blockquote"><blockquote class="blockquote"><p>
<span class="strong"><strong>Glyph Lefkowitz: 'Python is definitely my main language that I've built my career on.'</strong></span>
</p></blockquote></div><p>
<span class="strong"><strong>Driscoll</strong></span>: Are you actually a core Python developer? I wasn't able to discover that information.</p><p>
<span class="strong"><strong>Lefkowitz</strong></span>: I'm not. I have attended a bunch of core Python developer events, because Twisted<a id="id92" class="indexterm"/> is a <a id="id93" class="indexterm"/>pretty high-profile Python project.</p><p>I went to a language summit a couple of years ago and I have triage permissions on the bug tracker. I'm on the Python security response team to provide a library perspective on this stuff. I also worked with Guido van Rossum a fair amount on asyncio getting integrated into the standard library. For instance, providing feedback on that and the experiences I've had with Twisted.</p><p>So I'm peripheral to Python core development, but not a member of the core team. I never really had the desire to get involved. I basically already spend way more time than I probably should doing volunteer open source development, to be adding to that by doing Python core stuff. A lot of people use Python professionally and want to give back, but I already give back.</p><p>
<span class="strong"><strong>Driscoll</strong></span>: So, now we're talking about Twisted, could you tell me about how Twisted came about and what inspired you to write it?</p><p>
<span class="strong"><strong>Lefkowitz</strong></span>: Well, it came<a id="id94" class="indexterm"/> about originally because of that very same video game that I <a id="id95" class="indexterm"/>was telling you about before. I started off in Python rewriting the Java version of the server that I had been working on.</p><p>The concurrency of that server was very heavily based on threads, because there were multiple players walking around and multiple autonomous agents doing various things. So there was just a big mess of threads in Java. There was no other way to do it and the whole ecosystem was kind of oriented around using lots of threads.</p><div class="blockquote"><blockquote class="blockquote"><p>
<span class="strong"><strong>Glyph Lefkowitz: 'There was a time... when the term massively multithreaded was like a boast that projects would make.'</strong></span>
</p></blockquote></div><p>In fact, I'll never forget this, there was a time, in the late 1990s and very early 2000s, when <span class="emphasis"><em>massively multithreaded</em></span> was like a boast that projects would make. This was something positive that they were claiming about their project.</p><p>We had a similar type of architecture and it was a giant mess. There were tons and tons of horrible bugs that were the result of the incorrect management of threads. I don't remember exactly how I discovered it, but basically originally there were three threads for every connection: the reader thread, the writer thread and the logic thread.</p><p>My friend James Knight rewrote the client/server protocol for this game. I believe that when he rewrote it, he condensed down those three threads into a single thread per player, by using the select module.</p><p>
<span class="strong"><strong>Driscoll</strong></span>: What did this development mean for you?</p><p>
<span class="strong"><strong>Lefkowitz</strong></span>: I looked at the client/server protocol and I realized that there were multiple things I wanted to know about, that I might be able to do with a socket.</p><div class="blockquote"><blockquote class="blockquote"><p>
<span class="strong"><strong>Glyph Lefkowitz: 'Once I found out about the select module, I read about it and it completely changed my conception of how programs worked.'</strong></span>
</p></blockquote></div><p>So once I found out<a id="id96" class="indexterm"/> about the <code class="literal">select</code> module, I read about it and it completely changed my conception of how programs worked. As I mentioned before, my early introduction to programming was HyperCard, so I had this intuitive notion that the computer is idle and waiting for something to happen.</p><p>
<span class="strong"><strong>Driscoll</strong></span>: Where did you go from there?</p><p>
<span class="strong"><strong>Lefkowitz</strong></span>: So, after messing around with the <code class="literal">select</code> module for a day or two, I realized that you could have something that was on data received, or on connection started, and do something.</p><p>That was much more natural to me, because I had been using threads to sort of emulate this, but never felt really comfortable. At that time, I didn't have a good intuition about what happened when we started up a program. It started threads in the background, or something concurrent was happening, but I didn't really understand how the parallelism worked.</p><p>With <code class="literal">select</code>, you could see the parallelism because multiple connections would come in. Then there would just be multiple objects that I had instantiated and that had methods on them, which I was calling from this event loop. So building that up from the bottom gave me a much better understanding of how concurrency worked.</p><p>From there, the idea was that the game would be what these days you call an alternate reality game. It would be reaching out via various protocols to send you emails or send you text messages. This really dates the whole thing, because the web server was not the first thing I did and it was not really clear that the web thing was going to catch on.</p><div class="blockquote"><blockquote class="blockquote"><p>
<span class="strong"><strong>Glyph Lefkowitz: 'The web was just a really slow and buggy native client that crashed a lot.'</strong></span>
</p></blockquote></div><p>For us, the Twisted development team, the web was just a really slow and buggy native client that crashed a lot. We could write native clients in Python that would do exactly what we wanted. Security, of course, was not nearly the concern that it is today, so it wasn't as clear that we needed sandboxing. To be fair, browser security was also terrible at the time, but it was not like we were really thinking about that. So that's how the project got built up into the multi-protocol Hydra that it is.</p><p>One of the reasons that Twisted<a id="id97" class="indexterm"/> existed in the form where it had this big standard library built in, was that we really wanted developers to rewrite their protocols in such a way that you did not need threads to speak to them. I still feel this way to a large extent today.</p><p>
<span class="strong"><strong>Driscoll</strong></span>: What lessons did you learn <a id="id98" class="indexterm"/>from the first Twisted releases?</p><p>
<span class="strong"><strong>Lefkowitz</strong></span>: Well, one lesson was that each time you made an object persistent, you were basically making a vow to support it for the rest of your natural life.</p><div class="blockquote"><blockquote class="blockquote"><p>
<span class="strong"><strong>Glyph Lefkowitz: 'One lesson was that each time you made an object persistent, you were basically making a vow to support it for the rest of your natural life.'</strong></span>
</p></blockquote></div><p>So we had all of these really crummy little classes that were dumb implementation details. They were exactly the kind of thing you would imagine if you got a bunch of bored 19-year-olds to write a bunch of production-critical server infrastructure. That's what we were doing and we ended up creating this very odd situation where we had these server files which were like dozens of dead objects from previous versions of the software.</p><p>We didn't know the files were in there because <code class="literal">pickle</code> has no way to visualize your object graph, or show you what's going on. So the main web server for Twistedmatrix.com, up until around 2009, was this 45 MB <code class="literal">pickle</code> file. We didn't know why it was so big, but that was how you would run it. You would just fire up a Python interpreter to run the reactor. We were living five to ten years in the future, but that wasn't necessarily always a good thing.</p><p>
<span class="strong"><strong>Driscoll</strong></span>: What problems did you run into?</p><p>
<span class="strong"><strong>Lefkowitz</strong></span>: We were sometimes trying to do things that were really bad decisions, because there was no tooling associated with them.</p><p>There was no supporting ecosystem, so we assumed that we could do something alternative that was not keeping all of our config and plain text files. We thought we could then somehow handwave all the benefits of version control and text diffing, and all the log processing tools would somehow arrive in our ecosystem, but they never did. So we've been trying to do less weird for the sake of weird in the last five to ten years of the project, which is still less than half its lifetime.</p><div class="blockquote"><blockquote class="blockquote"><p>
<span class="strong"><strong>Glyph Lefkowitz: 'We've been trying to do less weird for the sake of weird in the last five to ten years of the project.'</strong></span>
</p></blockquote></div><p>
<span class="strong"><strong>Driscoll</strong></span>: So you mentioned that you were helping with the <code class="literal">asyncio</code> and other library changes related to that. How do you see those changes affecting Twisted? </p><p>
<span class="strong"><strong>Lefkowitz</strong></span>: I actually wrote an article<a id="id99" class="indexterm"/> on my blog about this a while back. At the time, a vocal minority of Python users, who really didn't like Twisted to begin with, sort of rejoiced that the library changes would finally kill Twisted, because there would be no reason to use it anymore.</p><div class="blockquote"><blockquote class="blockquote"><p>
<span class="strong"><strong>Glyph Lefkowitz: 'A vocal minority of Python users, who really didn't like Twisted to begin with, sort of rejoiced that the library changes would finally kill Twisted.'</strong></span>
</p></blockquote></div><p>What I predicted at the time, and I think this prediction has largely borne out, was that sanctioning event-driven concurrency in the standard library, and saying this is the way that Python does concurrency, would prompt a lot of new interest in Twisted.</p><p>The whole Python stack has really been converging on this idea of event-driven concurrency being the right way to do things. Previously, Twisted had to be a good server framework that you could use to deploy your applications. It also had to be a good GUI client framework, that you could use to write direct line apps and desktop apps.</p><p>Twisted needed to be a solid implementation of a bunch of design patterns, but it also had to be its own little standard library. It had to paper over a bunch of issues in the Python standard library that had a really slow release cycle and you couldn't necessarily depend on for the applications.</p><div class="blockquote"><blockquote class="blockquote"><p>
<span class="strong"><strong>Glyph Lefkowitz: 'This tool appeared to be proselytizing to them before it was solving their problems.'</strong></span>
</p></blockquote></div><p>The sort of breaking point that Twisted reached, was that it also had to be this messenger for event-driven networking. People would come to Twisted wanting some feature, and then you would first have to sell them on the idea that async was a good idea at all. What this resulted in was that people would show up to Twisted with no shared expectations and no background. This tool appeared to be proselytizing to them before it was solving their problems.</p><p>In order to live in the Twisted ecosystem to some extent, to get the real benefits of it, you would have to start converting your code over to this async model, and that was a bunch of work. If you didn't know how it worked and it wasn't intuitive to you, it would be baffling. You would not be in a frame of mind where you'd be interested in hearing about it.</p><p>So the interesting thing is that even people who are stuck on Python 2.7, and will be for the next decade, show up to Twisted nowadays.</p><p>
<span class="strong"><strong>Driscoll</strong></span>: Why are people stuck on Python 2.7?</p><p>
<span class="strong"><strong>Lefkowitz</strong></span>: People kind of<a id="id100" class="indexterm"/> know that the standard library, like Python, has moved on. It's all event-driven now, it's all async, and they can't use <code class="literal">asyncio</code> because they're in a large corporate code base.</p><p>Initially the transition from Python 2 to Python 3 was, frankly, mismanaged. The core team, despite warnings from concerned users like myself, just didn't comprehend the scale of their own creation. They underestimated the migration effort by several orders of magnitude.</p><div class="blockquote"><blockquote class="blockquote"><p>
<span class="strong"><strong>Glyph Lefkowitz: 'Initially the transition from Python 2 to Python 3 was, frankly, mismanaged.'</strong></span>
</p></blockquote></div><p>The long life of Python 2 is a consequence of their responsible management of that mistake. The Python development team saw that users were not upgrading, and worked hard to understand why and to address the issues of big Python users. So it's not ideal, but it's significantly better than the alternative, which was for Python 3 to become Perl 6.</p><p>
<span class="strong"><strong>Driscoll</strong></span>: What's your opinion of Python 3?</p><p>
<span class="strong"><strong>Lefkowitz</strong></span>: I'm in Python 3 <a id="id101" class="indexterm"/>in my day job now and I love it. After much blood, sweat and tears, I think it actually is a better programming language than Python 2 was. I think that it resolves a lot of inconsistencies.</p><p>Most improvements should mirror quality of life issues and the really interesting stuff going on in Python is all in the ecosystem. I absolutely cannot wait for a PyPy 3.5, because one of the real downsides of using Python 3 at work is that I now have to deal with the fact that all of my code is 20 times slower.</p><p>When I do stuff for the Twisted ecosystem, and I run stuff on Twisted's infrastructure, we use Python 2.7 as a language everywhere, but we use PyPy as the runtime. It is just unbelievably fast! If you're running services, then they can run with a tenth of the resources.</p><p>A PyPy process will take<a id="id102" class="indexterm"/> 80 MB of memory, but once you're running that it will actually take more memory per interpreter, but less memory per object. So if you're doing any Python stuff at scale, I think PyPy is super interesting.</p><p>One of my continued bits of confusion about the Python community is that there's this thing out there which, for Python 2 anyway, just makes all of your code 20 times faster. This wasn't really super popular, in fact PyPy download stats still show that it's not as popular as Python 3, and Python 3 is really experiencing a huge uptick in popularity.</p><div class="blockquote"><blockquote class="blockquote"><p>
<span class="strong"><strong>Glyph Lefkowitz: 'The lack of viable Python 3 implementation for PyPy is starting to hurt it quite a bit.'</strong></span>
</p></blockquote></div><p>I do think that given that the uptake in popularity has happened, the lack of a viable Python 3 implementation for PyPy is starting to hurt it quite a bit. But it was around and very fast for a long time before Python 3 had even hit 10% of PyPy's downloads. So I keep wanting to predict that this is the year of PyPy on the desktop, but it just never seems to happen.</p><p>
<span class="strong"><strong>Driscoll</strong></span>: Why do you think PyPy<a id="id103" class="indexterm"/> has not taken off on the server?</p><p>
<span class="strong"><strong>Lefkowitz</strong></span>: I'm still not quite sure why, because especially for companies with significant infrastructure spend, it could save them literally millions of dollars a year to run.</p><p>You can tell companies that they will save millions of dollars a year if they rewrite all of their code. The problem is they would be taking a huge security risk, blowing up the size of their development team and making no feature progress in two years. That's a bad trade-off and I can see why you wouldn't want to do that.</p><p>With PyPy we say, "Why is that not the future? We just dropped in this new interpreter." There are reasons that we can't use it, such as that the scientific Python community's tooling does not work on PyPy yet. But that's actually the exception rather than the rule, and even NumPy programs largely work on PyPy. I wrote some OpenGL stuff last year that uses PyPy extensively and doing that was really interesting.</p><p>
<span class="strong"><strong>Driscoll</strong></span>: What do you <a id="id104" class="indexterm"/>like about PyPy?</p><p>
<span class="strong"><strong>Lefkowitz</strong></span>: You write an OpenGL program using CPython and it's struggling to stay at 50 frames per second. You do the same thing in PyPy and it's 300, 400 or 500 frames per second, not breaking a <a id="id105" class="indexterm"/>sweat and <a id="id106" class="indexterm"/>not taking up CPU.</p><div class="blockquote"><blockquote class="blockquote"><p>
<span class="strong"><strong>Glyph Lefkowitz: 'Where I would like to see Python go is for it to adopt more advanced technology.'</strong></span>
</p></blockquote></div><p>Where I would like to see Python go is for it to adopt more advanced technology, but for some reason we've collectively lagged behind. Another thing that I think will be critical for determining where Python goes is to what extent we can get away from <span class="emphasis"><em>pip</em></span> as a tool for users to install applications.</p><p>I think that we need a better story for how you write cross-platform GUI code, even if it's really basic. For instance, <code class="literal">tkinter</code> is bad enough that people just don't use it. We need a better story for how you package applications.</p><p>I want to make an app that I can upload to the App Store, even before we start talking about mobile. There are all the issues of resource constraints that come along with that. I want to compile my app and put it on someone else's computer, but it is way too hard to do that right now.</p><p>
<span class="strong"><strong>Driscoll</strong></span>: Do you see making apps becoming easier?</p><p>
<span class="strong"><strong>Lefkowitz</strong></span>: I'm encouraged by projects like pybee/briefcase, and I think that they're starting to finally gain some traction.</p><p>They're a very small project with very big problems in front of them. But they're also very determined and committed, with real experience of navigating those issues. This is evidenced by Pythonista, the iOS Python app, which uses their code.</p><p>I think that the story around building and integrating Python programs is getting better all the time. I am optimistic that within the next five years, it won't be unusual to see apps that are fully written in Python, rather than the small handful of examples that we have now.</p><p>It would be a shame if the only way you could realistically get Python code from one computer to another was Docker. Python should be on your Mac, it should be on your Android, it should be on your Linux box, it should be in the cloud and it should be on your Raspberry Pi. In particular, with the emergence of the Internet of Things, I really wish more of those things were running Python web servers.</p><div class="blockquote"><blockquote class="blockquote"><p>
<span class="strong"><strong>Glyph Lefkowitz: 'The mission is Python on every port, and we really feel like that's an important mission.'</strong></span>
</p></blockquote></div><p>The mission is Python on every port, and we really feel like that's an important mission. So many services, the things that people actually use to talk to edge network devices such as Nginx, Apache, XM and BIND, are also in C.</p><p>We're writing all of our application code in these high-level languages. The things that are actually pulling the bytes off the wire and handing them to your application, then parsing them, are all barely-maintained C programs from 20 years ago. This is a real danger.</p><p>So the idea is that you can't do crypto in Python. Crypto primitives need to be in C, but those are a tiny part of a security application. Higher-level cryptographic constructions can (and really should) absolutely be assembled in Python, where you're dealing with composing multiple cryptographic primitives into a workable whole. Doing that composition in C is dangerous and error-prone.</p><p>In many cases, you have to drop down to a sublayer, but you have to write crypto primitives in a language where you can tell the underlying hardware to take fixed lengths of time to do things. So it has to be completely data input independent. It also has to be extremely fast, because you don't want to be paying a huge overhead to encrypt things. You just need to encrypt them no matter what.</p><p>
<span class="strong"><strong>Driscoll</strong></span>: Do you think that the Python<a id="id107" class="indexterm"/> language is here to stay?</p><p>
<span class="strong"><strong>Lefkowitz</strong></span>: Wow, that's an interesting question! I think that many languages that have had the lifetime that Python has had, have sort of slowly faded into legacy status.</p><p>Overall, I think one of the places that the Python language is going is forwards. It's still an unbelievably vibrant community and it's still growing. It was growing slowly at the beginning and it's growing slowly now, but it has been consistently growing over years and years. I think this is interesting because there are a lot of languages that have been gigantic flashes in the pan. Ruby was hugely popular for a while and then its popularity really plummeted with Rails losing popularity.</p><div class="blockquote"><blockquote class="blockquote"><p>
<span class="strong"><strong>Glyph Lefkowitz: 'I think Python is going to have a much longer life than previous generations of languages.'</strong></span>
</p></blockquote></div><p>I think Python is going to have <a id="id108" class="indexterm"/>a much longer life than previous generations of languages, which were in their heyday super-hot technology, and then faded away with the next generation of stuff. I think Python is becoming its own next generation. Ironically, I think that Python 3 is a very small part of that.</p><p>One thing that I really hope happens, and I think it's another one that hasn't yet, is Python in the browser. Skulpt, Pyjs, PyPy.js, and a bunch of other projects have kind of got things that are good proofs of concept, but again nobody's sitting down and going: "I'm a new Python programmer and I want to do a frontend Python app. What do I do?"</p><p>The answer to that is inevitably that the thing that actually lets you do what you want to do is only on Git master in this one project. You've got to check it out and check out another project. When you ask the question: "Well, why can't I <code class="literal">pip</code> install this?" The answer is: "We're kind of still working on it and it's not fully done."</p><div class="blockquote"><blockquote class="blockquote"><p>
<span class="strong"><strong>Glyph Lefkowitz: 'I do think that Python will certainly keep growing in a variety of different backend capacities.'</strong></span>
</p></blockquote></div><p>The answer should just be, of course, that you can <span class="emphasis"><em>pip</em></span> install it and it shouldn't be harder than that. So that's where I hope the community will go, but I do think that Python will certainly keep growing in a variety of different backend capacities.</p><p>I also think that where we're headed as a language and an ecosystem is towards greater diversity. It's going to take us to some surprising places that I can't predict, but I would say that it looks like Python is going to be around for a really long time. I think that for now, where Python's going is data science. There are obviously a lot of people interested in data science right now.</p><p>
<span class="strong"><strong>Driscoll</strong></span>: Python is being used a lot in the AI and machine learning boom. Why do you think this is?</p><p>
<span class="strong"><strong>Lefkowitz</strong></span>: AI is a bit of a<a id="id109" class="indexterm"/> catch-all term that tends to mean whatever the most advanced areas in current computer science research are.</p><p>There was a time when the basic graph-traversal stuff that we take for granted was considered AI. At that time, Lisp was the big AI language, just because it was higher-level than average and easier for researchers to do quick prototypes with. I think Python has largely replaced it in the general sense because, in addition to being similarly high-level, it has an excellent third-party library ecosystem, and a great integration story for operating system facilities.</p><p>Lispers will object, so I should make it clear that I'm not making a precise statement about Python's position in a hierarchy of expressiveness, just saying that both Python and Lisp are in the same class of language, with things like garbage collection, memory safety, modules, namespaces and high-level data structures.</p><p>In the more specific sense of <a id="id110" class="indexterm"/>machine learning, which is what more people mean when they say AI these days, I think there are more specific answers. The existence of NumPy and its accompanying ecosystem allows for a very research-friendly mix of high-level stuff, with very high-performance number-crunching. Machine learning is nothing if not very intense number-crunching.</p><div class="blockquote"><blockquote class="blockquote"><p>
<span class="strong"><strong>Glyph Lefkowitz: 'The Python community's focus on providing friendly introductions... to non-programmers, has really increased its adoption in the sister disciplines of data science and scientific computing.'</strong></span>
</p></blockquote></div><p>The Python community's focus on providing friendly introductions and ecosystem support to non-programmers, has really increased its adoption in the sister disciplines of data science and scientific computing. Countless working statisticians, astronomers, biologists, and business analysts have become Python programmers and have improved the tooling. Programming is fundamentally a social activity and Python's community has acknowledged this more than any other language except JavaScript.</p><p>Machine learning is a particularly integration-heavy discipline, in the sense that any AI/machine learning system is going to need to ingest large amounts of data from real-world sources as training data, or system input, so Python's broad library ecosystem means that it is often well-positioned to access and transform that data.</p><p>
<span class="strong"><strong>Driscoll</strong></span>: What could be done to make<a id="id111" class="indexterm"/> Python a better language for AI and machine learning?</p><p>
<span class="strong"><strong>Lefkowitz</strong></span>: Using more PyPy. Right<a id="id112" class="indexterm"/> now, the data science/machine learning ecosystem in Python is very focused around the CPython runtime, which is unfortunate.</p><p>This means that new tools are often created without testing on PyPy, which means that when they have performance bottlenecks, rewrites of core logic in C (or, if you're lucky, Cython) are an inevitable part of any significant project.</p><div class="blockquote"><blockquote class="blockquote"><p>
<span class="strong"><strong>Glyph Lefkowitz: 'Right now the data science/machine learning ecosystem in Python is very focused around the CPython runtime, which is unfortunate.'</strong></span>
</p></blockquote></div><p>This is largely a social problem and the technical challenges preventing some parts of the current Python AI/machine learning infrastructure from running, or running well, on PyPy are not significant in terms of the resources they would take to fix if their maintainers cared. But, from the perspective of someone uninvolved with those projects, who is starting a project and trying to use PyPy, it's just one inscrutable failure after another in some code you don't know anything about.</p><p>This is true in several fields of Python's application and I just wish that more folks would think of Python as a language that can be very fast, and competitive with Java or even C++, and plan accordingly when evaluating their testing matrix.</p><div class="blockquote"><blockquote class="blockquote"><p>
<span class="strong"><strong>Glyph Lefkowitz: 'I just wish that more folks would think of Python as a language that can be very fast, and competitive with Java or even C++.'</strong></span>
</p></blockquote></div><p>
<span class="strong"><strong>Driscoll</strong></span>: What changes would you like to see in <a id="id113" class="indexterm"/>future Python releases?</p><p>
<span class="strong"><strong>Lefkowitz</strong></span>: My main wish is for there to be some good defaults for getting new projects set up.</p><p>For example, today you have to know that when you install Python, you also need to install <code class="literal">pip</code>, and then you also need to create a <code class="literal">virtualenv</code>, but all of these steps are optional. You also have to hand-create a <code class="literal">setup.py</code> to describe your project, then learn about building wheels, specifying dependencies and so on.</p><p>What I'd like to see is Python <a id="id114" class="indexterm"/>presenting an integrated view of best practices, that makes it harder to get lost in the weeds of installing stuff. This could be just having a <code class="literal">new project</code> button, so that a Python project would look like any other kind of document to a user just getting started. Also, Python could look more like an app, even if that app required lots of command-line use.</p><p>Secondary to that, I'd like to see tools that make it easier for library authors to protect private implementation details from accidental breakage. For example, you can import the stuff that the library has imported, rather than importing the stuff that the library is trying to define. Right now, upgrading Python libraries is extra risky, because every single user of every library might have made a mistake like this and be depending on a bug.</p><p>The tool that I want to make it easy for users to create projects would benefit a lot from coming with the language, but this type of boundary enforcement around modules would have to be built into the language. It would be extremely hard to build it in the ecosystem.</p><p>
<span class="strong"><strong>Driscoll</strong></span>: So what do you think is the best thing about<a id="id115" class="indexterm"/> the Python community?</p><p>
<span class="strong"><strong>Lefkowitz</strong></span>: One of the things that I think is really good is the commitment to diversity. A lot of people think that this is a political thing or that there are different factions for pro-diversity and anti-diversity. Diversity is almost seen as taking away from the technical stuff somehow.</p><p>I can just share my own personal journey to becoming interested in diversity and social justice. I looked around a Twisted project and I said, "Why are we 100% dudes? What is going on here? What have we done to shut women out of this project?"</p><div class="blockquote"><blockquote class="blockquote"><p>
<span class="strong"><strong>Glyph Lefkowitz: 'We were clearly missing out on half the talent the world had to offer.'</strong></span>
</p></blockquote></div><p>I felt bad, but also that we were clearly missing out on half the talent the world had to offer in just the most obvious way. We were also all white and there are lots of people of color who also have talent to offer. They weren't showing up. So there's certainly a degree of altruistic impulses, but I also think that many people inside the Python community have accepted that this is a real skills gap issue.</p><p>If we don't get a diverse group of people working on our stuff, and getting involved in our community, then we're not going to make software that's useful to a lot of the world. We're going to be missing out on a lot of talent and we're going to be missing out on a lot of interesting voices that will challenge us, and make us a more interesting community.</p><div class="blockquote"><blockquote class="blockquote"><p>
<span class="strong"><strong>Glyph Lefkowitz: 'If we don't get a diverse group of people working on our stuff... then we're not going to make software that's useful.'</strong></span>
</p></blockquote></div><p>So when we talked earlier about the <a id="id116" class="indexterm"/>technical directions that the Python community has been moving in, those directions are aided by this pursuit of diversity. I believe that one of the reasons that Python is popular in life sciences is that it has a different demographic breakdown than the rest of the tech industry. I think Python has made real inroads there, in large part because people look at the Python community and are not scared off. It's not an intimidating or exclusionary type of environment.</p><div class="blockquote"><blockquote class="blockquote"><p>
<span class="strong"><strong>Glyph Lefkowitz: 'The Python community is not perfect. We still have a long way to go.'</strong></span>
</p></blockquote></div><p>Now that said, I felt a little weird commenting on this because I also feel that the Python community is not perfect. We still have a long way to go. The tech industry overall is highlighting women, just because that's the most obvious demographic disparity, but there are also lots of other underrepresented groups.</p><p>When you look at the representation of women throughout the software industry, you've got about 25 to 30%, depending on how it's measured. Then you look at the open source community and it's more like 5% women, which is a lot better than it was a couple of years ago, when it was about 1%.</p><p>The Python community is considerably better than that, but still when you look at people who are actively participating in projects, it's not even really hitting the industry average, let alone the overall demographic average.</p><p>
<span class="strong"><strong>Driscoll</strong></span>: How can the Python community<a id="id117" class="indexterm"/> encourage more diversity?</p><p>
<span class="strong"><strong>Lefkowitz</strong></span>: I think we still have a long way to go, but the fact that the Python community has, in the large part, acknowledged the real problem that's affecting a lot of aspects of technology is important. Diversity is an issue that's affecting the culture around technology.</p><div class="blockquote"><blockquote class="blockquote"><p>
<span class="strong"><strong>Glyph Lefkowitz: 'Diversity is an issue that's affecting the culture around technology.'</strong></span>
</p></blockquote></div><p>You have other communities, like Clojure or Erlang, which have fantastic technology on offer, but they don't really care about the diversity problem. You can see that reflected in a monoculture among their thinking and the lack of success becoming more popular.</p><p>I think a community which is largely following in Python's footsteps is Rust. Despite it being extremely low-level and somewhat tedious to write, they do have some great ideas in that language. As a result of being more inclusive and thoughtful about the way the community is organized, Rust is skyrocketing in popularity from very far down on the list of languages.</p><div class="blockquote"><blockquote class="blockquote"><p>
<span class="strong"><strong>Glyph Lefkowitz: 'I think that the inclusiveness of the Python community is definitely the best thing about it.'</strong></span>
</p></blockquote></div><p>So I think that the inclusiveness of the Python community is definitely the best thing about it. That is not just a comment on its political orientation, but a comment on its ability to produce interesting technology in the future.</p><p>I think that Python has endured by being friendly. It's open to lots of people from new and different communities. I don't know how to predict the future really, because it's going to depend on who shows up next.</p><p>
<span class="strong"><strong>Driscoll</strong></span>: Thank you, Glyph Lefkowitz.</p></div></body></html>