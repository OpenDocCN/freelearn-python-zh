- en: '*Chapter 3*: Understanding Decorators and their Applications'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: From this chapter onwards, we will start looking at various concepts that are
    part of metaprogramming along with examples of how to apply them. We will first
    take a look at decorators and how decorators can be implemented in Python 3\.
  prefs: []
  type: TYPE_NORMAL
- en: Decorators are one of the metaprogramming concepts that deal with decorating
    a function without modifying the actual function body. As the name suggests, a
    decorator adds additional value to a function, a method, or a class by allowing
    the function to become an argument of another function that *decorates* or gives
    more information on the function, method, or class being decorated. Decorators
    can be developed on an individual user-defined function or on a method that is
    defined inside a class, or they can be defined on a class itself too. Understanding
    decorators will help us to enhance the reusability of functions, methods, and
    classes by manipulating them externally without impacting the actual implementation.
  prefs: []
  type: TYPE_NORMAL
- en: In the previous chapter, we reviewed the concept of object-oriented programming,
    which serves as the base for this chapter and the future chapters in this book.
  prefs: []
  type: TYPE_NORMAL
- en: 'In this chapter, we will be taking a look at the following main topics:'
  prefs: []
  type: TYPE_NORMAL
- en: Looking into simple function decorators
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Exchanging decorators from one function to another
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Applying multiple decorators to one function
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Exploring class decorators
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Getting to know built-in decorators
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: By the end of this chapter, you should be able to create your own decorators,
    implement user-defined decorators on functions/methods and classes, and reuse
    built-in decorators.
  prefs: []
  type: TYPE_NORMAL
- en: Technical requirements
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The code examples shared in this chapter are available on GitHub under the
    code for this chapter here: [https://github.com/PacktPublishing/Metaprogramming-with-Python/tree/main/Chapter03](https://github.com/PacktPublishing/Metaprogramming-with-Python/tree/main/Chapter03).'
  prefs: []
  type: TYPE_NORMAL
- en: Looking into simple function decorators
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We will now look at different types of function decorators with an example.
    We will continue using the *ABC Megamart* example we looked at in the previous
    chapter. Each user-defined function in Python can perform a different operation.
    But what if we want different functions to show specific additional information,
    no matter what the functions perform? We can do this simply by defining another
    function that decorates any function that is provided as an input.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s take a look at the following steps to understand this better:'
  prefs: []
  type: TYPE_NORMAL
- en: 'A function decorator can be defined as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: This code defines a simple function decorator that takes in any input function
    as an argument and adds a line above the function result that prints `---Decorate
    function with this line---` as the first output line for any input function.
  prefs: []
  type: TYPE_NORMAL
- en: 'This function decorator can be called by a new user-defined function with two
    different syntaxes. Let us define two simple functions:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: This function returns the phrase `A picture is worth a thousand words`.
  prefs: []
  type: TYPE_NORMAL
- en: 'We will be adding one more function that returns a different phrase: `Actions
    speak louder than words`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'In the following step, let us add a function decorator to both the preceding
    user-defined functions and look at the results:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'In the preceding code, we have reassigned the functions by adding a decorator
    function to them. Executing decorated function 1 results in the following:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Similarly, we can also execute decorated function 2:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Both of the function results added an additional line, `---Decorate function
    with this line---`, that was not part of their function definition but was part
    of the decorator function. These examples show the reusable nature of function
    decorators.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let us look further into syntax 2, which is the most widely used method of
    adding decorators to other functions, methods, or classes:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: In the preceding code, while defining the user-defined functions, we added an
    additional line above the definition of `@functiondecorator`. This line signifies
    that we have added a decorator to the function in the definition stage itself.
    This decorator can be declared once and reused for any relevant function that
    is newly defined.
  prefs: []
  type: TYPE_NORMAL
- en: 'Executing the preceding code provides the same results as in the code execution
    of examples with syntax 1:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Now that you understand simple function decorators, we can look into an example
    that demonstrates its applications.
  prefs: []
  type: TYPE_NORMAL
- en: Understanding function decorators with an application
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: We can further look into an example of function decorators using a scenario
    from *ABC Megamart*. In this example, we will create a function to add an email
    signature for a branch manager in a different format for each branch. We will
    define two functions, `manager_albany` and `manager_manhattan`, with different
    font colors and highlights.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s look at this first piece of code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: 'The preceding code prints the branch manager’s email signature with white,
    bold, and blue highlighted text:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: 'Now let’s take a quick look at this block of code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: 'This one prints the branch manager’s email signature with highlighted text:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, let us add the name of *ABC Megamart* in both the signatures with a yellow
    highlight and modify the font color of the signature to yellow while keeping the
    signature highlight colors intact. To do this, we will create a function decorator
    that takes in the arguments of the preceding functions and add *ABC Megamart*
    with a black font and yellow highlight:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE35]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE36]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE37]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE38]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE39]'
  prefs: []
  type: TYPE_PRE
- en: The following figure is a representation of how an email signature decorator
    can be implemented on two different signatures.
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 3.1 – Email signature decorator ](img/B13426_03_01.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 3.1 – Email signature decorator
  prefs: []
  type: TYPE_NORMAL
- en: The preceding signature decorator adds the name of *ABC Megamart* in both the
    signatures with a yellow highlight and modifies the font color of the signature
    to yellow while keeping the signature highlight colors intact.
  prefs: []
  type: TYPE_NORMAL
- en: 'First, let’s add `@signature` to `manager_manhattan`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE40]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE41]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE42]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE43]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE44]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE45]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE46]'
  prefs: []
  type: TYPE_PRE
- en: 'This code returns the following email signature:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE47]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE48]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE49]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE50]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE51]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE52]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE53]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE54]'
  prefs: []
  type: TYPE_PRE
- en: 'Now let’s add `@signature` to `manager_albany`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE55]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE56]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE57]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE58]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE59]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE60]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE61]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE62]'
  prefs: []
  type: TYPE_PRE
- en: 'Doing so returns the following email signature:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE63]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE64]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE65]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE66]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE67]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE68]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE69]'
  prefs: []
  type: TYPE_PRE
- en: Adding a function decorator to different functions in the preceding code snippets
    makes them have common functionality – in this case, the *ABC Megamart* title
    with a yellow highlight as a common functionality while keeping the individual
    branch manager signatures. It’s a simple example of how reusable decorators can
    be and the nature of adding metadata or additional information to a function while
    keeping the actual functionality of the function intact.
  prefs: []
  type: TYPE_NORMAL
- en: Now that we understand what function decorators are and how we can use them,
    let’s look at utilizing decorators for different functions by exchanging them
    and making them more reusable.
  prefs: []
  type: TYPE_NORMAL
- en: Exchanging decorators from one function to another
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We now have an understanding of what a function decorator is and how a function
    decorator can be used for more than one function. We will look into further exploring
    the reusability concept of decorators by creating two different decorators to
    serve two different purposes and later utilizing them by interchanging the decorators
    between different functions.
  prefs: []
  type: TYPE_NORMAL
- en: To demonstrate this concept, we will be creating Decorator 1 for function 1
    and Decorator 2 for function 2, and then we will be exchanging them from one function
    to another. Let us create two decorators to decorate two different functions.
  prefs: []
  type: TYPE_NORMAL
- en: '**Decorator 1** will be created to convert a date argument that is provided
    as a holiday date to the function that sets holidays for the Alabama branch of
    *ABC Megamart*.'
  prefs: []
  type: TYPE_NORMAL
- en: The following figure is a representation of **Decorator 1** and its **Function
    1**.
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 3.2 – Date converter as a decorator ](img/B13426_03_02.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 3.2 – Date converter as a decorator
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s take a look at the code we’d be using for our desired example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE70]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE71]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE72]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE73]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE74]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE75]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE76]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE77]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE78]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE79]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE80]'
  prefs: []
  type: TYPE_PRE
- en: The preceding `dateconverter` is a decorator function that takes in another
    function as an argument. To perform this function, we have imported the `datetime`
    library that helps us to convert the input date argument into the format of weekday,
    day of the month, month of the year, and year. This decorator function internally
    takes in all the arguments passed to the internal function and checks whether
    any of the function arguments are of the `datetime` data type, and if it finds
    a `datetime` object, it will be converted to display weekday, day of the month,
    month of the year, and year.
  prefs: []
  type: TYPE_NORMAL
- en: This decorator also stores the converted format of the `datetime` object along
    with the rest of the function arguments in a list and passes the list as an argument
    to the function that is provided as input to this decorator. Let us now create
    a function to set a holiday calendar for the Alabama branch and decorate it using
    this decorator function.
  prefs: []
  type: TYPE_NORMAL
- en: '`*args` parameter. The first argument of this function will be set as `branch_id`,
    the second argument as `holiday_type`, the third argument as `holiday_name`, and
    the fourth argument as `holiday_date`. All of these input arguments are converted
    into a dictionary variable by the function and it returns the dictionary with
    its key-value pairs denoting each value.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Here is what the code looks like using the details we just discussed:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE81]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE82]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE83]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE84]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE85]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE86]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE87]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE88]'
  prefs: []
  type: TYPE_PRE
- en: 'In the preceding code, we have started the function definition by adding the
    decorator `@dateconverter`, which takes care of converting the holiday date into
    the aforementioned format. Let us now call this function by providing the arguments
    required to create the holiday details dictionary:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE89]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE90]'
  prefs: []
  type: TYPE_PRE
- en: 'In the preceding code, we have created a `datatime` object and stored it in
    a holiday variable that will be passed as one of the inputs to the `set_holidays_alabama`
    function:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE91]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE92]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE93]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE94]'
  prefs: []
  type: TYPE_PRE
- en: 'The preceding code gives us the following decorated output:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE95]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE96]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE97]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE98]'
  prefs: []
  type: TYPE_PRE
- en: We can now go ahead and create another decorator that performs a different manipulation
    on another function that is provided as input.
  prefs: []
  type: TYPE_NORMAL
- en: Let’s now look at `id` is present in the input that denotes that the input value
    is an identifier of any kind and returns the numerical value of the identifier
    by removing its prefix. This decorator will be added to a function to set promotion
    details for any input product for the Malibu branch.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following figure is a representation of **Decorator 2** and **Function
    2**:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 3.3 – ID identifier as a decorator ](img/B13426_03_03.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 3.3 – ID identifier as a decorator
  prefs: []
  type: TYPE_NORMAL
- en: 'Here is the code we’ll be using for our decorator:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE99]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE100]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE101]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE102]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE103]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE104]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE105]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE106]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE107]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE108]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE109]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE110]'
  prefs: []
  type: TYPE_PRE
- en: The preceding identifier is a decorator function that takes in another function
    as an argument. This decorator function also internally takes in all the arguments
    passed to its internal function and navigates through each individual argument
    to check whether it is a string. If the argument is a string, the decorator converts
    the string into lowercase and checks whether it has a substring ID. If the substring
    ID is present in the variable, then all strings will be removed from the variable
    and only digits will be stored in it with the rest of the function arguments in
    a list, passing the list as an argument to the function that is provided as input
    to this decorator. Let us now create a function to set promotion details for the
    Malibu branch and decorate its ID using this decorator function.
  prefs: []
  type: TYPE_NORMAL
- en: '`*args` similar to the `set_holidays_alabama` function. The first argument
    of this function will be set as `branch_id`, the second argument as `product_id`,
    the third argument as `promotion_date`, the fourth as `promotion_type`, and the
    fifth as `promotion_reason`. All of these input arguments are also converted into
    a dictionary variable by the function and it returns the dictionary with its key-value
    pairs denoting each value. There are two `id` arguments in this function that
    get decorated by the identifier.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Here is what the code looks like using the details we just discussed:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE111]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE112]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE113]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE114]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE115]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE116]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE117]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE118]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE119]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE120]'
  prefs: []
  type: TYPE_PRE
- en: 'In the preceding code, we have started the function definition by adding the
    decorator `@identifier`, which takes care of removing the prefixes from the `id`
    variable. Let us now call this function by providing the arguments required to
    create the product promotion details dictionary:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE121]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE122]'
  prefs: []
  type: TYPE_PRE
- en: 'Here, we have created a `datatime` object and stored it in a promotion date,
    which will be passed as one of the inputs to the `set_promotion_malibu` function,
    but this date variable will stay in the same format as defined:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE123]'
  prefs: []
  type: TYPE_PRE
- en: 'The preceding code gives us the decorated output that follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE124]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE125]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE126]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE127]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE128]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE129]'
  prefs: []
  type: TYPE_PRE
- en: 'We now have two decorators and two different functions decorated by them. To
    check whether these decorators can be exchanged, let us now redefine these functions
    by swapping the decorators using the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE130]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE131]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE132]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE133]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE134]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE135]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE136]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE137]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE138]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE139]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE140]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE141]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE142]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE143]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE144]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE145]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE146]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE147]'
  prefs: []
  type: TYPE_PRE
- en: 'Let us input the required arguments and execute the preceding function, `set_holidays_alabama`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE148]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE149]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE150]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE151]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE152]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE153]'
  prefs: []
  type: TYPE_PRE
- en: 'This code gives us the decorated output as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE154]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE155]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE156]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE157]'
  prefs: []
  type: TYPE_PRE
- en: 'In the preceding output, the identifier is applied on the branch ID and there
    is no change to the holiday date. Similarly, let us execute the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE158]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE159]'
  prefs: []
  type: TYPE_PRE
- en: 'This code gives us the decorated output that follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE160]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE161]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE162]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE163]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE164]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE165]'
  prefs: []
  type: TYPE_PRE
- en: 'The following figure is a representation of how the two decorators will be
    exchanged or swapped between their functions:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 3.4 – Exchange decorators ](img/B13426_03_04.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 3.4 – Exchange decorators
  prefs: []
  type: TYPE_NORMAL
- en: Let us reuse the previous examples to look further into the concept of applying
    multiple decorators to one function.
  prefs: []
  type: TYPE_NORMAL
- en: Applying multiple decorators to one function
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: So far, we have understood that decorators can be created and added to functions
    to perform metaprogramming on the functions. We also understand that decorators
    can be reused and exchanged for different functions. We have also understood that
    decorators add decoration or value to a function from outside of the function
    body and help in altering the function with additional information. What if we
    want the function to perform two different actions through decorators and at the
    same time do not want the decorators to become more specific? Can we create two
    or more different decorators and apply them to a single function? Yes, we can.
    We will now look at decorating a function with more than one decorator and understand
    how it works.
  prefs: []
  type: TYPE_NORMAL
- en: For this example, let us reuse the decorators `dateconverter` and `identifier`.
    To understand this concept, we can reuse one of the previously declared functions,
    `set_promotion_malibu`, which has both a `datetime` object as an input argument
    – promotion date – and two ID values as input arguments – `branch_id` and `product_id`.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following figure is a representation of adding two decorators to a function:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 3.5 – Multiple decorators for one function ](img/B13426_03_05.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 3.5 – Multiple decorators for one function
  prefs: []
  type: TYPE_NORMAL
- en: 'The following code puts our example into action:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE166]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE167]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE168]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE169]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE170]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE171]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE172]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE173]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE174]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE175]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE176]'
  prefs: []
  type: TYPE_PRE
- en: 'In this code, we have added both decorators to the `set_promotion_malibu` function:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE177]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE178]'
  prefs: []
  type: TYPE_PRE
- en: 'Executing the preceding code results in the application of both decorators
    on the input values:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE179]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE180]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE181]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE182]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE183]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE184]'
  prefs: []
  type: TYPE_PRE
- en: From the preceding output, we can see that `@identifier` is applied on `branch_id`
    and `product_id`. At the same time, `@dateconverter` is applied on the `promotion_date`.
    Let us now explore other variants of decorators.
  prefs: []
  type: TYPE_NORMAL
- en: Exploring class decorators
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: A `__init__` and `__call__`. Any variable initialized as part of the `__init__`
    function of a class while creating an object instance of the class becomes a variable
    of the class itself. Similarly, the `__call__` function of a class returns a function
    object. If we want to use a class as a decorator, we need to make use of the combination
    of these two built-in methods.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let us look at what happens if we don’t use the `call` method. Look at the
    following piece of code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE185]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE186]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE187]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE188]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE189]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE190]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE191]'
  prefs: []
  type: TYPE_PRE
- en: Here, we have created a class named `classdecorator` and have added the `init`
    method to take a function as input. We have also created a `decorator` method
    that stores the result of the initialized function variable and adds a decorator
    string decorated by a class decorator to the input function result.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let us now create an input function to test the preceding `classdecorator`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE192]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE193]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE194]'
  prefs: []
  type: TYPE_PRE
- en: 'Adding this class decorator should decorate the input function. Let us check
    what happens when we call this input function:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE195]'
  prefs: []
  type: TYPE_PRE
- en: 'We get the following type error, which states `classdecorator` is not callable:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 3.6 – Error due to an incorrect definition of the class decorator
    ](img/B13426_03_06.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 3.6 – Error due to an incorrect definition of the class decorator
  prefs: []
  type: TYPE_NORMAL
- en: 'We are receiving this error since we did not use the right method to make the
    class behave as a decorator. The `decorator` method in the preceding code returns
    a variable but not a function. To make this class work as a decorator, we need
    to redefine the class as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE196]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE197]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE198]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE199]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE200]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE201]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE202]'
  prefs: []
  type: TYPE_PRE
- en: 'Here, we have replaced the `decorator` method with the built-in method `__call__`.
    Let us now redefine the input function and see what happens:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE203]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE204]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE205]'
  prefs: []
  type: TYPE_PRE
- en: 'We can call the preceding function and check the behavior of this class decorator:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE206]'
  prefs: []
  type: TYPE_PRE
- en: 'The following figure is a simple representation that shows an incorrect way
    of creating a class decorator:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 3.7 – Wrong method for creating a class decorator ](img/B13426_03_07.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 3.7 – Wrong method for creating a class decorator
  prefs: []
  type: TYPE_NORMAL
- en: 'Here is the correct way of creating it:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 3.8 – Correct method for creating a class decorator ](img/B13426_03_08.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 3.8 – Correct method for creating a class decorator
  prefs: []
  type: TYPE_NORMAL
- en: Now that you have a better understanding of class decorator, we can proceed
    to analyze the application of class decorator on *ABC Megamart*.
  prefs: []
  type: TYPE_NORMAL
- en: Understanding class decorators with an application
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: We will look into a detailed example of the class decorator by applying it to
    a scenario on *ABC Megamart*. Let us consider a scenario where *ABC Megamart*
    has a separate class created for each branch. Let us also assume each class has
    its own method, `buy_product`, to calculate a product’s sales price by specifically
    applying the sales tax rate for the specific branch and product being purchased.
    When the mart wants to apply seasonal promotions that involve eight generic promotion
    types. Each branch class need not have a promotion calculation method to be applied
    to its calculated sales price. Instead, we can create a class decorator that can
    be applied to the `buy_product` method of each branch and the class decorator
    will, in turn, calculate the final sales price by applying promotion discounts
    on the actual sales price calculated by the branch.
  prefs: []
  type: TYPE_NORMAL
- en: 'We will create two classes and add the `buy_product` method to each class to
    calculate the sales price without adding a class decorator. This is to understand
    the return values of the actual methods:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE207]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE208]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE209]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE210]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE211]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE212]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE213]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE214]'
  prefs: []
  type: TYPE_PRE
- en: 'Creating an object instance for the previous class and calling the method with
    its arguments returns the following result:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE215]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE216]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE217]'
  prefs: []
  type: TYPE_PRE
- en: 'Similarly, we can define the class `Arizona` and add the method `buy_product`
    and execute the following code to verify its return value without a decorator:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE218]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE219]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE220]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE221]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE222]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE223]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE224]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE225]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE226]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE227]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE228]'
  prefs: []
  type: TYPE_PRE
- en: The preceding `buy_product` method takes in product name, unit price, quantity,
    and promotion type as input and calculates the initial price by multiplying the
    unit price by the quantity of a product. It further calculates the sales price
    by adding the product of the initial price to the state tax rate along with the
    initial price calculated in the previous step. Finally, the method returns the
    sales price, product name, and promotion type. The sales tax rates are different
    for each state and the sales price calculation differs according to the sales
    tax rates.
  prefs: []
  type: TYPE_NORMAL
- en: We can now create a class decorator to apply a promotional discount on the sales
    price and calculate the final sales price for a product by including the offer
    rate or discount rate.
  prefs: []
  type: TYPE_NORMAL
- en: 'In the following code, let us define the class `applypromotion` and add two
    built-in methods required to make the class behave as a decorator:'
  prefs: []
  type: TYPE_NORMAL
- en: 'The **__init__ method**: This is a function or method as an input variable
    in this scenario'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The **__call__ method**: This method accepts multiple input arguments, which
    are also the arguments of the function or method being decorated'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The input arguments are applied to the function or method being decorated and
    it further applies various discount rates to the sales price resulting from the
    input function by checking for eight different promotion types, recalculating
    the sales price, and storing it as the final sales price, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE229]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE230]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE231]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE232]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE233]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE234]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE235]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE236]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE237]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE238]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE239]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE240]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE241]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE242]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE243]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE244]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE245]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE246]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE247]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE248]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE249]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE250]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE251]'
  prefs: []
  type: TYPE_PRE
- en: 'The class decorator to `@applypromotion` is now ready to be further used by
    other functions or methods. We can now apply this decorator to the `buy_product`
    method from the class `Alabama`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE252]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE253]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE254]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE255]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE256]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE257]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE258]'
  prefs: []
  type: TYPE_PRE
- en: 'Creating an object instance for the preceding code and calling its method works
    as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE259]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE260]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE261]'
  prefs: []
  type: TYPE_PRE
- en: 'Similarly, we can also redefine the class `Arizona` and its method `buy_product`
    by adding the class decorator as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE262]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE263]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE264]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE265]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE266]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE267]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE268]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE269]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE270]'
  prefs: []
  type: TYPE_PRE
- en: 'Creating an object instance for the preceding code and calling its method works
    as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE271]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE272]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE273]'
  prefs: []
  type: TYPE_PRE
- en: 'Let us review the results of `buy_product` methods from Arizona before adding
    the decorator and after adding the decorator. The preceding code has the output
    after adding the decorator and the following code has the output before adding
    the decorator:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE274]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE275]'
  prefs: []
  type: TYPE_PRE
- en: After adding the `applypromotion` decorator, the sales price for 250 packs of
    cookies is at a discounted rate of $85.66 compared to the price of $128.50 before
    applying the promotion. The store need not always add a promotion on a product
    and the `buy_product` method can reuse the `applypromotion` decorator only when
    it needs to sell a product on promotion, thus making the decorator externally
    alter the behavior of the class while keeping the `buy_product` method’s actual
    functionality intact.
  prefs: []
  type: TYPE_NORMAL
- en: 'The simple representation of this example is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 3.9 – Class decorator to apply promotional discounts on products ](img/B13426_03_09.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 3.9 – Class decorator to apply promotional discounts on products
  prefs: []
  type: TYPE_NORMAL
- en: Having learned how to apply class decorators to methods or functions from other
    classes, we will proceed further to look at some of the built-in decorators available
    in Python.
  prefs: []
  type: TYPE_NORMAL
- en: Getting to know built-in decorators
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Now, the question is, do we have to always create user-defined or custom decorators
    to be applied to classes and methods, or do we have some pre-defined decorators
    that can be used for specific purposes.
  prefs: []
  type: TYPE_NORMAL
- en: In addition to the user-defined decorators that we’ve looked at throughout this
    chapter, Python has its own built-in decorators, such as `@staticmethod` and `@classmethod`,
    that can be directly applied to methods. These decorators add certain important
    functionalities to methods and classes during the process of the class definition
    itself. We will be looking at these two decorators in detail, as follows.
  prefs: []
  type: TYPE_NORMAL
- en: The static method
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The `@staticmethod` – is a decorator that takes in a regular Python function
    as an input argument and converts it into a static method. Static methods can
    be created inside a class but will not use the implicit first argument of the
    class object instance usually denoted as an argument named `self` like the other
    instance-based methods.
  prefs: []
  type: TYPE_NORMAL
- en: 'To understand this concept, let us first create the class `Alabama` and add
    a function to the class `buy_product` without `self` as an argument and without
    the static method decorator and check its behavior:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE276]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE277]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE278]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE279]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE280]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE281]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE282]'
  prefs: []
  type: TYPE_PRE
- en: 'Here we have defined the class `Alabama` with the function `buy_product`. Let
    us now create an object instance and call the function inside the class to check
    its behavior:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE283]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE284]'
  prefs: []
  type: TYPE_PRE
- en: 'Executing this code leads to the following error:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 3.10 – Error on calling a function without static method and self
    ](img/B13426_03_10.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 3.10 – Error on calling a function without static method and self
  prefs: []
  type: TYPE_NORMAL
- en: 'Rerunning the preceding function without creating an object works as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE285]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE286]'
  prefs: []
  type: TYPE_PRE
- en: 'To avoid the preceding error and to call a function inside a class with or
    without creating an object, we can convert the function into a static method by
    adding the `@staticmethod` decorator to it. We can now look at how it works:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE287]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE288]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE289]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE290]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE291]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE292]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE293]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE294]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE295]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE296]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE297]'
  prefs: []
  type: TYPE_PRE
- en: 'We have added an additional method named `another_method`, which can only be
    called using an object instance. Let us now create an object for the class and
    call both the preceding methods:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE298]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE299]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE300]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE301]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE302]'
  prefs: []
  type: TYPE_PRE
- en: 'Both the methods, `static` and `instance`, can be called using the object of
    the class. At the same time, the static method can also be called using the class
    itself without creating an object:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE303]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE304]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE305]'
  prefs: []
  type: TYPE_PRE
- en: 'Executing this code leads to the following error:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 3.11 – Error on calling an instance method using its class ](img/B13426_03_11.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 3.11 – Error on calling an instance method using its class
  prefs: []
  type: TYPE_NORMAL
- en: The static method generated the expected output when called using its class,
    while the instance method did not run. This is the advantage of using a static
    method to convert a function into a method inside a class.
  prefs: []
  type: TYPE_NORMAL
- en: The class method
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The `@classmethod` – is also a built-in decorator similar to `@staticmethod,`
    and this decorator also converts a function into a static method inside a class.
    `@staticmethod` does not have an implicit argument of the object to a class whereas
    `@classmethod` has an implicit argument, `cls`, which gets added to the function,
    while the `@classmethod` decorator is added to it as seen in the following code
    block:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE306]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE307]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE308]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE309]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE310]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE311]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE312]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE313]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE314]'
  prefs: []
  type: TYPE_PRE
- en: 'This function can be called either with or without creating a class instance.
    We can look at both in the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE315]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE316]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE317]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE318]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE319]'
  prefs: []
  type: TYPE_PRE
- en: In the preceding code, we can see that a function converted by `@classmethod`
    into a class method can be called directly using the class or by creating an object
    of the class.
  prefs: []
  type: TYPE_NORMAL
- en: These are a few of the built-in decorators and there are more such decorators
    available in Python 3 that can be explored and reused.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we have learned how to create simple decorators and how to
    apply decorators with examples. We saw how to exchange decorators from one function
    to another along with how to add multiple decorators to one function.
  prefs: []
  type: TYPE_NORMAL
- en: We now understand the concept of class decorators and have looked at an example
    of how to apply them. And finally, we learned how to use some built-in decorators
    such as `@staticmethod` and `@classmethod`.
  prefs: []
  type: TYPE_NORMAL
- en: All of these concepts are part of Python metaprogramming and they are used to
    change the behavior of a function or a method externally and without impacting
    the internal functionalities of the function or method.
  prefs: []
  type: TYPE_NORMAL
- en: In the next chapter, we will be looking at the concept of meta classes with
    different examples.
  prefs: []
  type: TYPE_NORMAL
