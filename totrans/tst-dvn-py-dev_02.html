<html><head></head><body>
  <div id="sbo-rt-content"><div class="chapter" title="Chapter 2. Red-Green-Refactor – The TDD Cycle"><div class="titlepage"><div><div><h1 class="title"><a id="ch02"/>Chapter 2. Red-Green-Refactor – The TDD Cycle</h1></div></div></div><p>In the previous chapter, we went through a small TDD cycle by creating a failing test and then making it pass. In this chapter, we are going to fill out the rest of the <code class="literal">Stock</code> class by writing more tests. In the process, we will dig deeper into the TDD cycle and the <code class="literal">unittest</code> module.</p><div class="section" title="Tests are executable requirements"><div class="titlepage"><div><div><h1 class="title"><a id="ch02lvl1sec13"/>Tests are executable requirements</h1></div></div></div><p>In the<a id="id33" class="indexterm"/> first test, we wrote a very simple test that checked whether a new <code class="literal">Stock</code> class has its <code class="literal">price</code> attribute initialized to <code class="literal">None</code>. We can now think about what requirement we want to implement next.</p><p>An observant reader might have caught on to the terminology used in the previous sentence, where I said that we can think about the requirement to implement next, instead of saying that we can think about the test to write next. Both statements are equivalent, because in TDD, tests are nothing but requirements. Each time we write a test and implement code to make it pass, what we actually do is make the code meet some requirement. Looking at it another way, tests are just executable requirement specifications. Requirement documentation often goes out of sync with what is actually implemented, but this is impossible with tests, because the moment they go out of sync, the test will fail.</p><p>In the previous chapter, we said that the <code class="literal">Stock</code> class will be used to hold price information and price history for a stock symbol. This suggests that we need a way to set the price whenever it is updated. Let us implement an <code class="literal">update</code> method that meets the following requirements:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">It should take a timestamp and price value and set it on the object</li><li class="listitem" style="list-style-type: disc">The price cannot be negative</li><li class="listitem" style="list-style-type: disc">After multiple updates, the object gives us the latest price</li></ul></div></div></div></div>


  <div id="sbo-rt-content"><div class="section" title="Arrange-Act-Assert"><div class="titlepage"><div><div><h1 class="title"><a id="ch02lvl1sec14"/>Arrange-Act-Assert</h1></div></div></div><p>Let us <a id="id34" class="indexterm"/>start with the first requirement. Here is the test:</p><div class="informalexample"><pre class="programlisting">    def test_stock_update(self):
        """An update should set the price on the stock object
        We will be using the `datetime` module for the timestamp
        """
        goog = Stock("GOOG")
        goog.update(datetime(2014, 2, 12), price=10)
        self.assertEqual(10, goog.price)</pre></div><p>Here we call <a id="id35" class="indexterm"/>the <code class="literal">update</code> method (which doesn't exist yet) with the timestamp and price and then check that the price has been set correctly. We use the <code class="literal">assertEqual</code> method provided in the <code class="literal">unittest.TestCase</code> class to assert the value.</p><p>Since we are using the <code class="literal">datetime</code> module to set the timestamp, we will have to add the line <code class="literal">from datetime import datetime</code> to the top of the file before it will run.</p><p>This test follows the pattern of Arrange-Act-Assert.</p><div class="orderedlist"><ol class="orderedlist arabic"><li class="listitem"><span class="strong"><strong>Arrange</strong></span>: Set up the context for the test. In this case, we create a <code class="literal">Stock</code> object. In other tests, it may involve creating multiple objects or hooking a few things together that will be required by the particular test.</li><li class="listitem"><span class="strong"><strong>Act</strong></span>: Perform the action that we want to test. Here, we call the <code class="literal">update</code> method with the appropriate arguments.</li><li class="listitem"><span class="strong"><strong>Assert</strong></span>: Finally we assert that the outcome was as expected.</li></ol></div><p>In this test, each part of the pattern took one line of code, but this is not always the case. Often there will be more than one line for each part of the test.</p></div></div>


  <div id="sbo-rt-content"><div class="section" title="Documenting our tests"><div class="titlepage"><div><div><h1 class="title"><a id="ch02lvl1sec15"/>Documenting our tests</h1></div></div></div><p>When<a id="id36" class="indexterm"/> we <a id="id37" class="indexterm"/>run the tests, we get the following output:</p><div class="informalexample"><pre class="programlisting"><span class="strong"><strong>.E</strong></span>
<span class="strong"><strong>==================================================================</strong></span>
<span class="strong"><strong>ERROR: test_stock_update (__main__.StockTest)</strong></span>
<span class="strong"><strong>An update should set the price on the stock object</strong></span>
<span class="strong"><strong>------------------------------------------------------------------</strong></span>
<span class="strong"><strong>Traceback (most recent call last):</strong></span>
<span class="strong"><strong>  File "stock_alerter\stock.py", line 22, in test_stock_update</strong></span>
<span class="strong"><strong>    goog.update(datetime(2014, 2, 12), price=10)</strong></span>
<span class="strong"><strong>AttributeError: 'Stock' object has no attribute 'update'</strong></span>

<span class="strong"><strong>------------------------------------------------------------------</strong></span>
<span class="strong"><strong>Ran 2 tests in 0.001s</strong></span>
<span class="strong"><strong>FAILED (errors=1)</strong></span>
</pre></div><p>The test fails as <a id="id38" class="indexterm"/>expected, but the interesting thing is that the first line of the docstring is printed out on the fourth line. This is useful because we get some more information on which case is failing. This shows a second way of documenting out tests by using the first line for a short summary, and the rest of the docstring for a more detailed explanation. The detailed explanation will not be printed out with a test failure, so there is no problem with cluttering the test failure output.</p><p>We have used two ways of documenting tests:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">Writing a descriptive test method name</li><li class="listitem" style="list-style-type: disc">Putting an explanation in the docstring</li></ul></div><p>Which <a id="id39" class="indexterm"/>is better? Most of the time the test is self explanatory and doesn't need a whole lot of background explanation. In such cases, a well named test method is sufficient.</p><p>However, sometimes the test method name becomes so long that it becomes clumsy and actually ends up reducing the readability of the code. At other times, we might want to put in a more detailed explanation of what we are testing and why. In such cases, shortening the method name and putting the explanation in the docstring is a good idea.</p><p>Here is the implementation to make this test pass:</p><div class="informalexample"><pre class="programlisting">    def update(self, timestamp, price):
        self.price = price</pre></div><p>This minimal implementation passes the test. As with the first bit of implementation, we aren't trying to implement the whole functionality. We want to implement just enough to make the test pass. Remember, when the test passes, it means the requirement is met. At this point, we have two passing tests, and we don't really have anything to refactor, so let us move on.</p></div></div>


  <div id="sbo-rt-content"><div class="section" title="Testing for exceptions"><div class="titlepage"><div><div><h1 class="title"><a id="ch02lvl1sec16"/>Testing for exceptions</h1></div></div></div><p>Another<a id="id40" class="indexterm"/> requirement is that the price should not be negative. We would want to raise a <code class="literal">ValueError</code> if the price is negative. How would we check for this expectation in a test? Here is one way to do that:</p><div class="informalexample"><pre class="programlisting">    def test_negative_price_should_throw_ValueError(self):
        goog = Stock("GOOG")
        try:
            goog.update(datetime(2014, 2, 13), -1)
        except ValueError:
            return
        self.fail("ValueError was not raised")</pre></div><p>In the preceding code, we call the <code class="literal">update</code> method with a negative price. This call is wrapped with a <code class="literal">try...except</code> block to catch <code class="literal">ValueError</code>. If the exception is raised correctly, then<a id="id41" class="indexterm"/> control goes into the <code class="literal">except</code> block where we return from the test. Since the test method returned successfully, it is marked as passing. If the exception is not raised, then the <code class="literal">fail</code> method gets called. This is another method provided by <code class="literal">unittest.TestCase</code> and raises a test failure exception when it is called. We can pass in a message to provide some explanation as to why it failed.</p><p>Here is the code to pass this test:</p><div class="informalexample"><pre class="programlisting">    def update(self, timestamp, price):
        if price &lt; 0:
            raise ValueError("price should not be negative")
        self.price = price</pre></div><p>With this code, all the three tests so far pass.</p><p>Since checking for exceptions is quite a common case, <code class="literal">unittest</code> provides a simpler way to do it:</p><div class="informalexample"><pre class="programlisting">    def test_negative_price_should_throw_ValueError(self):
        goog = Stock("GOOG")
        self.assertRaises(ValueError, goog.update, datetime(2014, 2, 13), -1)</pre></div><p>The <code class="literal">assertRaises</code> method takes the expected exception as the first argument, the function to call as the second argument, and the parameters to the function are passed as in the remaining arguments. If you need to call the function with keyword arguments, then they can be passed in as keyword arguments to the <code class="literal">assertRaises</code> method.</p><div class="note" title="Note" style=""><div class="inner"><h3 class="title"><a id="note04"/>Note</h3><p>Note that the second argument to <code class="literal">assertRaises</code> is a reference to the function to be called. This is why we don't put parentheses after the function name.</p></div></div><p>If passing in a function reference and a list of parameters feels awkward, then <code class="literal">assertRaises</code> provides another syntax that we can use:</p><div class="informalexample"><pre class="programlisting">    def test_negative_price_should_throw_ValueError(self):
        goog = Stock("GOOG")
        with self.assertRaises(ValueError):
            goog.update(datetime(2014, 2, 13), -1)</pre></div><p>What is going on here? When we pass only one parameter to <code class="literal">assertRaises</code>, a context manager is returned. We can use that with the <code class="literal">with</code> statement and put our action in that block. If the block raises the expected exception, then the context manager matches it and exits the block without an error. However, if the expected exception is not raised in the block, then the context<a id="id42" class="indexterm"/> manager raises a failure when the block is exited.</p></div></div>


  <div id="sbo-rt-content"><div class="section" title="Exploring assert methods"><div class="titlepage"><div><div><h1 class="title"><a id="ch02lvl1sec17"/>Exploring assert methods</h1></div></div></div><p>Now<a id="id43" class="indexterm"/> we<a id="id44" class="indexterm"/> have just one requirement for <code class="literal">update</code> remaining:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc"><span class="strong"><strong>-Done-</strong></span> It should take a timestamp and price value and set it on the object</li><li class="listitem" style="list-style-type: disc"><span class="strong"><strong>-Done-</strong></span> The price cannot be negative</li><li class="listitem" style="list-style-type: disc">After multiple updates, the object gives us the latest price</li></ul></div><p>Let us take the remaining requirement. Here is the test:</p><div class="informalexample"><pre class="programlisting">    def test_stock_price_should_give_the_latest_price(self):
        goog = Stock("GOOG")
        goog.update(datetime(2014, 2, 12), price=10)
        goog.update(datetime(2014, 2, 13), price=8.4)
        self.assertAlmostEqual(8.4, goog.price, delta=0.0001)</pre></div><p>What this test does is to simply call <code class="literal">update</code> twice, and when we ask for the price, provide us with the newer one. The interesting point about the test is that we use the <code class="literal">assertAlmostEqual</code> method here. This method is often used when checking equality with floating point numbers. Why don't we use plain old <code class="literal">assertEqual</code>? The reason is that due to the way floating points are stored, the result may not be exactly the number you expect. There could be a very small difference between what you expect and the actual number that is stored. Taking this into account, the <code class="literal">assertAlmostEqual</code> method allows us to specify a tolerance in the comparison. So, for example, if we expect 8.4 but the actual value is 8.39999999, the test will still pass.</p><p>The <code class="literal">assertAlmostEqual</code> method<a id="id45" class="indexterm"/> has two ways of specifying tolerance. The method we used above involves passing in a <code class="literal">delta</code> parameter which says that the difference between the expected value and the actual value should be within the delta. We've specified the <code class="literal">delta</code> parameter above as <code class="literal">0.0001,</code> which means any value between 8.3999 and 8.4001 will pass the test.</p><p>The other way of specifying tolerance is to use the <code class="literal">places</code> parameter as shown in the following code:</p><div class="informalexample"><pre class="programlisting">        self.assertAlmostEqual(8.4, goog.price, places=4)</pre></div><p>If this parameter is used, then both the expected and the actual values are rounded to the given number of decimal places before being compared. Note that you need to pass either the <code class="literal">delta</code> parameter or the <code class="literal">places</code> parameter. It is an error to pass both parameters together.</p><p>So far, we've used<a id="id46" class="indexterm"/> the following assertion methods:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc"><code class="literal">assertIsNone</code></li><li class="listitem" style="list-style-type: disc"><code class="literal">assertEqual</code></li><li class="listitem" style="list-style-type: disc"><code class="literal">assertRaises</code></li><li class="listitem" style="list-style-type: disc"><code class="literal">assertAlmostEqual</code></li><li class="listitem" style="list-style-type: disc"><code class="literal">fail</code></li></ul></div><p>The <a id="id47" class="indexterm"/>
<code class="literal">unittest</code> module<a id="id48" class="indexterm"/> provides a large number of assertion methods that we can use for various conditions. Some of the common ones are listed below:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc"><code class="literal">assertFalse(x, msg)</code>, <code class="literal">assertTrue(x, msg)</code></li><li class="listitem" style="list-style-type: disc"><code class="literal">assertIsNone(x, msg)</code>, <code class="literal">assertIsNotNone(x, msg)</code></li><li class="listitem" style="list-style-type: disc"><code class="literal">assertEqual(x, y, msg)</code>, <code class="literal">assertNotEqual(x, y, msg)</code></li><li class="listitem" style="list-style-type: disc"><code class="literal">assertAlmostEqual(x, y, places, msg, delta)</code>, <code class="literal">assertNotAlmostEqual(x, y, places, msg, delta)</code></li><li class="listitem" style="list-style-type: disc"><code class="literal">assertGreater(x, y, msg)</code>, <code class="literal">assertGreaterEqual(x, y, msg)</code></li><li class="listitem" style="list-style-type: disc"><code class="literal">assertLess(x, y, msg)</code>, <code class="literal">assertLessEqual(x, y, msg)</code></li><li class="listitem" style="list-style-type: disc"><code class="literal">assertIs(x, y, msg)</code>, <code class="literal">assertIsNot(x, y, msg)</code></li><li class="listitem" style="list-style-type: disc"><code class="literal">assertIn(x, seq, msg)</code>, <code class="literal">assertNotIn(x, seq, msg)</code></li><li class="listitem" style="list-style-type: disc"><code class="literal">assertIsInstance(x, cls, msg)</code>, <code class="literal">assertNotIsInstance(x, cls, msg)</code></li><li class="listitem" style="list-style-type: disc"><code class="literal">assertRegex(text, regex, msg)</code>, <code class="literal">assertNotRegex(text, regex, msg)</code></li><li class="listitem" style="list-style-type: disc"><code class="literal">assertRaises(exception, callable, *args, **kwargs)</code></li><li class="listitem" style="list-style-type: disc"><code class="literal">fail(msg)</code></li></ul></div><p>Most of the preceding functions are self explanatory. The following are some points that require a bit of explanation:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc"><code class="literal">msg</code> parameter: Most of the <a id="id49" class="indexterm"/>assert methods take an optional message parameter. A string can be passed here and it will be printed out in case the assertion fails. Usually, the default message is quite descriptive and this parameter is not required. Most of the time it is used with the <code class="literal">fail</code> method, as we saw a little while ago.</li><li class="listitem" style="list-style-type: disc"><code class="literal">assertEqual</code> versus <code class="literal">assertIs</code>: These <a id="id50" class="indexterm"/>two sets of assertions are very similar. The critical difference is that the former checks for <span class="emphasis"><em>equality</em></span> while the latter assertion is used to check for object <span class="emphasis"><em>identity</em></span>. The second assertion fails in previous example because although both objects are equal, they are still two different objects, and hence their identity is different:<div class="informalexample"><pre class="programlisting"><span class="strong"><strong>&gt;&gt;&gt; test = unittest.TestCase()</strong></span>
<span class="strong"><strong>&gt;&gt;&gt; test.assertEqual([1, 2], [1, 2])  # Assertion Passes</strong></span>
<span class="strong"><strong>&gt;&gt;&gt; test.assertIs([1, 2], [1, 2])     # Assertion Fails</strong></span>
<span class="strong"><strong>Traceback (most recent call last):</strong></span>
<span class="strong"><strong>  File "&lt;stdin&gt;", line 1, in &lt;module&gt;</strong></span>
<span class="strong"><strong>  File "C:\Python34\lib\unittest\case.py", line 1067, in assertIs</strong></span>
<span class="strong"><strong>    self.fail(self._formatMessage(msg, standardMsg))</strong></span>
<span class="strong"><strong>  File "C:\Python34\lib\unittest\case.py", line 639, in fail</strong></span>
<span class="strong"><strong>    raise self.failureException(msg)</strong></span>
<span class="strong"><strong>AssertionError: [1, 2] is not [1, 2]</strong></span>
</pre></div></li><li class="listitem" style="list-style-type: disc"><code class="literal">assertIn</code>/<code class="literal">assertNotIn</code>: These <a id="id51" class="indexterm"/>asserts are used to check if an element is present in a sequence. This includes strings, lists, sets, and any other object that supports the <code class="literal">in</code> operator.</li><li class="listitem" style="list-style-type: disc"><code class="literal">assertIsInstance</code>/<code class="literal">assertNotIsInstance</code>: They <a id="id52" class="indexterm"/>check if an object is an instance of the given class. The <code class="literal">cls</code> parameter can also be a tuple of classes, to assert that the object is an instance of any one of them.</li></ul></div><p>The <code class="literal">unittest</code> module also provides some less-frequently-used assertions:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc"><code class="literal">assertRaisesRegex(exception, regex, callable, *args, **kwargs)</code>: This<a id="id53" class="indexterm"/> assertion is similar to <code class="literal">assertRaises</code>, except that it takes an additional <code class="literal">regex</code> parameter. A regular expression can be passed in here and the assertion will check that the right exception was raised, as well as that the exception message matches the regular expression.</li><li class="listitem" style="list-style-type: disc"><code class="literal">assertWarns(warning, callable, *args, **kwargs)</code>: It is similar to <code class="literal">assertRaises</code>, but<a id="id54" class="indexterm"/> checks that a warning was raised instead.</li><li class="listitem" style="list-style-type: disc"><code class="literal">assertWarnsRegex(warning, callable, *args, **kwargs)</code>: It is the warning <a id="id55" class="indexterm"/>equivalent of <code class="literal">assertRaisesRegex</code>.</li></ul></div></div></div>


  <div id="sbo-rt-content"><div class="section" title="Specific asserts versus generic asserts"><div class="titlepage"><div><div><h1 class="title"><a id="ch02lvl1sec18"/>Specific asserts versus generic asserts</h1></div></div></div><p>One<a id="id56" class="indexterm"/> question that might come to your mind is why there are so many different assert methods. Why can't we just use <code class="literal">assertTrue</code> instead of the more specific assert, as shown in the following code:</p><div class="informalexample"><pre class="programlisting">assertInSeq(x, seq)
assertTrue(x in seq)

assertEqual(10, x)
assertTrue(x == 10)</pre></div><p>While they are certainly equivalent, one motivation for using a specific assert is that you get a better error message if the assertion fails. When comparing objects like lists and dicts, the error message will show exactly where the difference occurs, making it much easier to understand. Therefore, it is recommended to use the more specific asserts wherever possible.</p></div></div>


  <div id="sbo-rt-content"><div class="section" title="Setup and teardown"><div class="titlepage"><div><div><h1 class="title"><a id="ch02lvl1sec19"/>Setup and teardown</h1></div></div></div><p>Let us<a id="id57" class="indexterm"/> take a <a id="id58" class="indexterm"/>look at the tests that we have done so far:</p><div class="informalexample"><pre class="programlisting">    def test_price_of_a_new_stock_class_should_be_None(self):
        stock = Stock("GOOG")
        self.assertIsNone(stock.price)

    def test_stock_update(self):
        """An update should set the price on the stock object
        We will be using the `datetime` module for the timestamp
        """
        goog = Stock("GOOG")
        goog.update(datetime(2014, 2, 12), price=10)
        self.assertEqual(10, goog.price)

    def test_negative_price_should_throw_ValueError(self):
        goog = Stock("GOOG")
        with self.assertRaises(ValueError):
            goog.update(datetime(2014, 2, 13), -1)

    def test_stock_price_should_give_the_latest_price(self):
        goog = Stock("GOOG")
        goog.update(datetime(2014, 2, 12), price=10)
        goog.update(datetime(2014, 2, 13), price=8.4)
        self.assertAlmostEqual(8.4, goog.price, delta=0.0001)</pre></div><p>If you notice, each test does the same setup by instantiating a <code class="literal">Stock</code> object that is then used in the test. In this case, the setup is just one line, but sometimes we might have to do multiple steps <a id="id59" class="indexterm"/>before we are ready to run the test. Instead of repeating this <a id="id60" class="indexterm"/>setup code in each and every test, we can make use of the <code class="literal">setUp</code> method provided by the <code class="literal">TestCase</code> class:</p><div class="informalexample"><pre class="programlisting">    def setUp(self):
        self.goog = Stock("GOOG")

    def test_price_of_a_new_stock_class_should_be_None(self):
        self.assertIsNone(self.goog.price)

    def test_stock_update(self):
        """An update should set the price on the stock object We will be  using the `datetime` module for the timestamp """
        self.goog.update(datetime(2014, 2, 12), price=10)
        self.assertEqual(10, self.goog.price)

    def test_negative_price_should_throw_ValueError(self):
        with self.assertRaises(ValueError):
            self.goog.update(datetime(2014, 2, 13), -1)

    def test_stock_price_should_give_the_latest_price(self):
        self.goog.update(datetime(2014, 2, 12), price=10)
        self.goog.update(datetime(2014, 2, 13), price=8.4)
        self.assertAlmostEqual(8.4, self.goog.price, delta=0.0001)</pre></div><p>In the preceding code, we are overriding the default <code class="literal">setUp</code> method with our own. We've put our setup code in this method. This method is executed before every test, so the initialization done here is available for our test method to use. Note that we have to change our tests to use <code class="literal">self.goog</code> since it has now become an instance variable.</p><p>Similar to <code class="literal">setUp</code>, a <code class="literal">tearDown</code> method is also available which is executed immediately after the test is executed. We can do any required cleanup in this method.</p><p>The <code class="literal">setUp</code> and <code class="literal">tearDown</code> methods are executed before and after every test. What if we want some setup to be done only once for a group of tests? The <code class="literal">setupUpClass</code> and <code class="literal">tearDownClass</code> methods can be implemented as class methods and will be executed only once per test class. Similarly, the <code class="literal">setupUpModule</code> and <code class="literal">tearDownModule</code> functions are available to do any initialization once for the whole module. The following example shows the order of execution:</p><div class="informalexample"><pre class="programlisting">import unittest

def setUpModule():
    print("setUpModule")

def tearDownModule():
    print("tearDownModule")

class Class1Test(unittest.TestCase):
    @classmethod
    def setUpClass(cls):
        print("  setUpClass")

    @classmethod
    def tearDownClass(cls):
        print("  tearDownClass")

    def setUp(self):
        print("       setUp")

    def tearDown(self):
        print("       tearDown")

    def test_1(self):
        print("         class 1 test 1")

    def test_2(self):
        print("         class 1 test 2")

class Class2Test(unittest.TestCase):
    def test_1(self):
        print("         class 2 test 1")</pre></div><p>When this code is run, the output is as follows:</p><div class="informalexample"><pre class="programlisting">setUpModule
  setUpClass
       setUp
         class 1 test 1
       tearDown
       setUp
         class 1 test 2
       tearDown
  tearDownClass
         class 2 test 1
tearDownModule</pre></div><p>As we can see, the module level setup is executed first, followed by the class level, and finally the test case level. The <a id="id61" class="indexterm"/>teardown is executed in reverse order. In practical use, the test case level <code class="literal">setUp</code> and <code class="literal">tearDown</code> methods are very commonly used, while <a id="id62" class="indexterm"/>class level and module level setups are not needed much. Class level and module level setups are only used when there is an expensive setup step, such as making a connection to a database or a remote server, and it is preferable to do this setup just once and share it between all the tests.</p><div class="note" title="Note" style=""><div class="inner"><h3 class="title"><a id="note05"/>Note</h3><p>
<span class="strong"><strong>A warning when using class level and module level setup</strong></span>
</p><p>Any initialization done at class and module levels is shared between tests. Hence, it is important that modifications made in one test do not affect the other. For example, if we had initialized <code class="literal">self.goog = Stock("GOOG")</code> in <code class="literal">setUpClass</code>, it could have led to an unexpected failure, since the first test to check that the price of a new <code class="literal">Stock</code> object should be <code class="literal">None</code> will fail if one of the other tests is executed before it and it changes the state of the object.</p><p>Remember that the order in which tests are run is not guaranteed. Tests should be independent and should pass no matter the order they are executed in. Therefore, it is crucial that <code class="literal">setUpClass</code> and <code class="literal">setUpModule</code> are used carefully to only setup state which can be reused between tests.</p></div></div></div></div>


  <div id="sbo-rt-content"><div class="section" title="Brittle tests"><div class="titlepage"><div><div><h1 class="title"><a id="ch02lvl1sec20"/>Brittle tests</h1></div></div></div><p>We've <a id="id63" class="indexterm"/>implemented<a id="id64" class="indexterm"/> the three requirements for the <code class="literal">update</code> method:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc"><span class="strong"><strong>-Done-</strong></span> It should take a timestamp and price value and set it on the object</li><li class="listitem" style="list-style-type: disc"><span class="strong"><strong>-Done-</strong></span> After multiple updates, the object gives us the latest price</li><li class="listitem" style="list-style-type: disc"><span class="strong"><strong>-Done-</strong></span> The price cannot be negative</li></ul></div><p>Now, let us suppose that a new requirement comes up that we had not known about before:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">The <code class="literal">Stock</code> class needs a method to check if the stock has an increasing trend. An increasing trend is one where each of the latest three updates is an increase over the previous one.</li></ul></div><p>So far, our <code class="literal">Stock</code> implementation just stores the latest price. In order to implement this functionality, we need to store some history of past price values. One way to do this is to change the <code class="literal">price</code> variable to a list. The problem is that when we change the internals of our implementation, it would break all of our tests, because all of them access the <code class="literal">price</code> variable directly and assert that it has specific values.</p><p>What we see here is an <a id="id65" class="indexterm"/>example of test brittleness.</p><p>A test is <a id="id66" class="indexterm"/>brittle when a change in the implementation details requires a change in the test cases. Ideally, a test should be testing the interface and not the implementation directly. After all, it is the interface that other units will be using to interact with this unit. When we test through the interface, it allows us the freedom to change the implementation of code without worrying about breaking the tests.</p><div class="note" title="Note" style=""><div class="inner"><h3 class="title"><a id="note06"/>Note</h3><p>
<span class="strong"><strong>There are three ways a test might fail:</strong></span>
</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">If there is a bug introduced in the code being tested</li><li class="listitem" style="list-style-type: disc">If the test is tightly coupled to an implementation and we make changes to the code that modify the implementation, but without introducing a bug (for example, renaming a variable or modifying the internal design)</li><li class="listitem" style="list-style-type: disc">If the test requires some resource that is unavailable (for example, connecting to an external server, but the server is down)</li></ul></div><p>Ideally, the first case should be the only case where a test should fail. We should try to avoid the second and third as much as possible.</p></div></div><p>Sometimes it might be important to test specific implementation details. For example, suppose we have a class that is expected to perform a complex calculation and cache it for future use. The only way to test the caching functionality would be to verify if the calculated value is stored in the cache. If we later change the caching method (for example, moving from a file cache to memcache), then we will have to change the test as well.</p><p>Brittle tests can be worse than no tests, as the maintenance overhead of having to fix ten or twenty tests with every change in the implementation can turn developers away from TDD, increase the amount of frustration, and lead to teams disabling or skipping testing. Here are some guidelines<a id="id67" class="indexterm"/> on how to think about test brittleness:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">If at all possible, avoid using implementation details in tests, and only use the publicly exposed interface. This includes using only the interface methods in setup code and assertions.</li><li class="listitem" style="list-style-type: disc">If the test needs to check functionality that is internal to the unit being tested, and it is an important functionality, then it might make sense to check for specific implementation actions.</li><li class="listitem" style="list-style-type: disc">If it is cumbersome to use the external interface to set up the exact state that we want, or there is no interface method that retrieves the specific value we want to assert, then we may need to peek into the implementation in our tests.</li><li class="listitem" style="list-style-type: disc">If we are fairly confident that the implementation details are very unlikely to change in the future, then we might go ahead and use implementation-specific details in the test.</li></ul></div><p>For the second and third cases, the important point is to understand that there is a tradeoff between convenience, test readability, and brittleness. There is no right answer and it is a subjective decision that needs to be taken, weighing up the pros and cons of each specific situation.</p></div></div>


  <div id="sbo-rt-content"><div class="section" title="Refactoring the design"><div class="titlepage"><div><div><h1 class="title"><a id="ch02lvl1sec21"/>Refactoring the design</h1></div></div></div><p>In the<a id="id68" class="indexterm"/> previous section, we talked about the new requirement <a id="id69" class="indexterm"/>of having to check if a stock has an increasing trend.</p><p>Let us start by writing a test first:</p><div class="informalexample"><pre class="programlisting">class StockTrendTest(unittest.TestCase):
    def setUp(self):
        self.goog = Stock("GOOG")
    def test_increasing_trend_is_true_if_price_increase_for_3_updates(self):
        timestamps = [datetime(2014, 2, 11), datetime(2014, 2, 12), datetime(2014, 2, 13)]
        prices = [8, 10, 12]
        for timestamp, price in zip(timestamps, prices):
            self.goog.update(timestamp, price)
        self.assertTrue(self.goog.is_increasing_trend())</pre></div><p>The test takes three timestamps and prices and performs an update for each one. Since all three prices are increasing, the <code class="literal">is_increasing_trend</code> method should return <code class="literal">True</code>.</p><p>To make this test pass, we need to first add support for storing price history.</p><p>In the initializer, let us replace the <code class="literal">price</code> attribute with a <code class="literal">price_history</code> list. This list will store the history of price updates, with each new update added to the end of the list:</p><div class="informalexample"><pre class="programlisting">    def __init__(self, symbol):
        self.symbol = symbol
        self.price_history = []</pre></div><div class="note" title="Note" style=""><div class="inner"><h3 class="title"><a id="note08"/>Note</h3><p>After making this change, all the tests will now fail, including the ones that were passing before. Only after we complete a few steps will we be able to have the tests pass again. When tests are passing, we can constantly run the tests to make sure we aren't breaking any functionality with our changes. When tests are failing, we do not have this safety net. It is inevitable that certain design changes, like the one we are making now, will temporarily make a number of tests fail until we finish the sequence of changes. We should try and minimize the time we spend making changes during failing tests, by making small changes at a time. This allows us to validate our changes as we go along.</p></div></div><p>We can now change the <code class="literal">update</code> method to store the new price in this list.</p><div class="informalexample"><pre class="programlisting">    def update(self, timestamp, price):
        if price &lt; 0:
            raise ValueError("price should not be negative")
            self.price_history.append(price)</pre></div><p>We shall <a id="id70" class="indexterm"/>retain the current interface for getting the latest price by accessing the <code class="literal">price</code> attribute. However, since we have replaced the <code class="literal">price</code> attribute with the <code class="literal">price_history</code> list, we need to create a property that will mimic the existing interface:</p><div class="informalexample"><pre class="programlisting">    @property
    def price(self):
        return self.price_history[-1] \
        if self.price_history else None</pre></div><p>With this <a id="id71" class="indexterm"/>change, we can run the tests again and see that all our previous tests are still passing, with only the new test for the trend functionality failing.</p><p>The new design now allows us to implement the code to pass the trend test:</p><div class="informalexample"><pre class="programlisting">    def is_increasing_trend(self):
        return self.price_history[-3] &lt; \
        self.price_history[-2] &lt; self.price_history[-1]</pre></div><p>The implementation of the method simply checks whether the last three price updates are increasing. With that code implemented, all our tests, including the new one, will pass.</p><div class="note" title="Note" style=""><div class="inner"><h3 class="title"><a id="note09"/>Note</h3><p>
<span class="strong"><strong>A quick primer on properties</strong></span>
</p><p>Properties are a feature of Python where we can delegate attribute access to a function. Since we declared price as a property, accessing <code class="literal">Stock.price</code> will cause the method to be called instead of searching for the attribute. In our implementation, it allows us to create an interface so that other modules can refer to the stock price as an attribute, even though there is no such actual attribute in the object.</p></div></div></div></div>


  <div id="sbo-rt-content"><div class="section" title="Refactoring tests"><div class="titlepage"><div><div><h1 class="title"><a id="ch02lvl1sec22"/>Refactoring tests</h1></div></div></div><p>With <a id="id72" class="indexterm"/>the<a id="id73" class="indexterm"/> first test passing, we can go ahead with the second test:</p><div class="informalexample"><pre class="programlisting">    def test_increasing_trend_is_false_if_price_decreases(self):
        timestamps = [datetime(2014, 2, 11), datetime(2014, 2, 12), \ 
            datetime(2014, 2, 13)]
        prices = [8, 12, 10]
        for timestamp, price in zip(timestamps, prices):
            self.goog.update(timestamp, price)
        self.assertFalse(self.goog.is_increasing_trend())</pre></div><p>Our implementation already passes this test, so let us move on to the third test:</p><div class="informalexample"><pre class="programlisting">    def test_increasing_trend_is_false_if_price_equal(self):
        timestamps = [datetime(2014, 2, 11), datetime(2014, 2, 12), \ 
            datetime(2014, 2, 13)]
        prices = [8, 10, 10]
        for timestamp, price in zip(timestamps, prices):
            self.goog.update(timestamp, price)
        self.assertFalse(self.goog.is_increasing_trend())</pre></div><p>The current code passes this test as well. But let us pause at this point. If we look at the test cases so far, we can see that a lot of code is being repeated between tests. The setup code is also not very readable. The most important line here is the list of prices, which is getting hidden in the clutter. We need to clean this up. What we are going to do is to take the common code and put it into a helper method:</p><div class="informalexample"><pre class="programlisting">class StockTrendTest(unittest.TestCase):
    def setUp(self):
        self.goog = Stock("GOOG")

    def given_a_series_of_prices(self, prices):
        timestamps = [datetime(2014, 2, 10), datetime(2014, 2, \ 
            11), datetime(2014, 2, 12), datetime(2014, 2, 13)]
        for timestamp, price in zip(timestamps, prices):
            self.goog.update(timestamp, price)

    def test_increasing_trend_is_true_if_price_increase_for_3_updates(self):
        self.given_a_series_of_prices([8, 10, 12])
        self.assertTrue(self.goog.is_increasing_trend())

    def test_increasing_trend_is_false_if_price_decreases(self):
        self.given_a_series_of_prices([8, 12, 10])
        self.assertFalse(self.goog.is_increasing_trend())

    def test_increasing_trend_is_false_if_price_equal(self):
        self.given_a_series_of_prices([8, 10, 10])
        self.assertFalse(self.goog.is_increasing_trend())</pre></div><p>Much better! Not <a id="id74" class="indexterm"/>only is the <a id="id75" class="indexterm"/>duplication removed, but the tests are a lot more readable. By default, the <code class="literal">unittest</code> module looks for methods that start with the word <code class="literal">test</code> and only executes those methods as tests, so there is no risk that our helper method will be mistaken for a test case.</p><div class="note" title="Note" style=""><div class="inner"><h3 class="title"><a id="note10"/>Note</h3><p>Remember that test cases are also code. All the rules of writing clean, maintainable, and readable code apply to the test cases as well.</p></div></div></div></div>


  <div id="sbo-rt-content"><div class="section" title="Exploring the Rule classes"><div class="titlepage"><div><div><h1 class="title"><a id="ch02lvl1sec23"/>Exploring the Rule classes</h1></div></div></div><p>So far we<a id="id76" class="indexterm"/> have concentrated on the <code class="literal">Stock</code> class. Let us <a id="id77" class="indexterm"/>now turn our attention to the rule classes.</p><div class="note" title="Note" style=""><div class="inner"><h3 class="title"><a id="note11"/>Note</h3><p>From this point in the book, we will look at the implementation code, and then show how we can test it effectively. Note, however, that this does not mean writing the code first, followed by the unit test. The TDD process is still test first, followed by the implementation. It is the test case which will drive the implementation strategy. We are showing the implementation code first, only because it makes it easier to understand the testing concepts that will follow. All this code was originally written test first!</p></div></div><p>The rule classes keep track of the rules that the user wants to track and they can be of different types. For example, send an alert when a stock crosses a value, or matches a trend.</p><p>Here is an example of a <code class="literal">PriceRule</code> implementation:</p><div class="informalexample"><pre class="programlisting">class PriceRule:
        """PriceRule is a rule that triggers when a stock price
        satisfies a condition (usually greater, equal or lesser
        than a given value)"""

    def __init__(self, symbol, condition):
        self.symbol = symbol
        self.condition = condition

    def matches(self, exchange):
        try:
            stock = exchange[self.symbol]
        except KeyError:
            return False
        return self.condition(stock) if stock.price else False

    def depends_on(self):
        return {self.symbol}</pre></div><p>This class<a id="id78" class="indexterm"/> is initialized with a stock symbol and a condition. The condition can be a lambda or a function that takes a stock as a parameter and returns <code class="literal">True</code> or <code class="literal">False</code>. The rule matches when the stock matches the condition. The key method for this is the <code class="literal">matches</code> method. This method returns <code class="literal">True</code> or <code class="literal">False</code> depending on whether the rule is matched or not. The matches method takes an exchange as a parameter. This is nothing but a dictionary containing all the stocks that are available for the application.</p><p>We haven't talked about the <code class="literal">depends_on</code> method. This method just returns which stocks updates the rule depends on. This will be used later on to check the rule when any of those particular stocks get an update. For the <code class="literal">PriceRule</code>, it only depends on the stock that is passed in the initializer. An observant reader will notice that it returns a set (curly braces) and not a list.</p><p>Put this rule <a id="id79" class="indexterm"/>code in the file <code class="literal">rule.py</code> in the <code class="literal">stock_alerter</code> directory.</p><p>Here is how we would use the <code class="literal">PriceRule</code>:</p><div class="informalexample"><pre class="programlisting"><span class="strong"><strong>&gt;&gt;&gt; from datetime import datetime</strong></span>
<span class="strong"><strong>&gt;&gt;&gt; from stock_alerter.stock import Stock</strong></span>
<span class="strong"><strong>&gt;&gt;&gt; from stock_alerter.rule import PriceRule</strong></span>
<span class="strong"><strong>&gt;&gt;&gt;</strong></span>
<span class="strong"><strong>&gt;&gt;&gt; # First, create the exchange</strong></span>
<span class="strong"><strong>&gt;&gt;&gt; exchange = {"GOOG": Stock("GOOG"), "MSFT": Stock("MSFT")}</strong></span>
<span class="strong"><strong>&gt;&gt;&gt;</strong></span>
<span class="strong"><strong>&gt;&gt;&gt; # Next, create the rule, checking if GOOG price &gt; 100</strong></span>
<span class="strong"><strong>&gt;&gt;&gt; rule = PriceRule("GOOG", lambda stock: stock.price &gt; 100)</strong></span>
<span class="strong"><strong>&gt;&gt;&gt;</strong></span>
<span class="strong"><strong>&gt;&gt;&gt; # No updates? The rule is False</strong></span>
<span class="strong"><strong>&gt;&gt;&gt; rule.matches(exchange)</strong></span>
<span class="strong"><strong>False</strong></span>
<span class="strong"><strong>&gt;&gt;&gt;</strong></span>
<span class="strong"><strong>&gt;&gt;&gt; # Price does not match the rule? Rule is False</strong></span>
<span class="strong"><strong>&gt;&gt;&gt; exchange["GOOG"].update(datetime(2014, 2, 13), 50)</strong></span>
<span class="strong"><strong>&gt;&gt;&gt; rule.matches(exchange)</strong></span>
<span class="strong"><strong>False</strong></span>
<span class="strong"><strong>&gt;&gt;&gt;</strong></span>
<span class="strong"><strong>&gt;&gt;&gt; # Price matches the rule? Rule is True</strong></span>
<span class="strong"><strong>&gt;&gt;&gt; exchange["GOOG"].update(datetime(2014, 2, 13), 101)</strong></span>
<span class="strong"><strong>&gt;&gt;&gt; rule.matches(exchange)</strong></span>
<span class="strong"><strong>True</strong></span>
<span class="strong"><strong>&gt;&gt;&gt;</strong></span>
</pre></div><p>This is what <a id="id80" class="indexterm"/>some of the tests would look like:</p><div class="informalexample"><pre class="programlisting">class PriceRuleTest(unittest.TestCase):
    @classmethod
    def setUpClass(cls):
        goog = Stock("GOOG")
        goog.update(datetime(2014, 2, 10), 11)
        cls.exchange = {"GOOG": goog}

    def test_a_PriceRule_matches_when_it_meets_the_condition(self):
        rule = PriceRule("GOOG", lambda stock: stock.price &gt; 10)
        self.assertTrue(rule.matches(self.exchange))

    def test_a_PriceRule_is_False_if_the_condition_is_not_met(self):
        rule = PriceRule("GOOG", lambda stock: stock.price &lt; 10)
        self.assertFalse(rule.matches(self.exchange))

    def test_a_PriceRule_is_False_if_the_stock_is_not_in_the_exchange(self):
        rule = PriceRule("MSFT", lambda stock: stock.price &gt; 10)
        self.assertFalse(rule.matches(self.exchange))

    def test_a_PriceRule_is_False_if_the_stock_hasnt_got_an_update_yet(self):
        self.exchange["AAPL"] = Stock("AAPL")
        rule = PriceRule("AAPL", lambda stock: stock.price &gt; 10)
        self.assertFalse(rule.matches(self.exchange))

    def test_a_PriceRule_only_depends_on_its_stock(self):
        rule = PriceRule("MSFT", lambda stock: stock.price &gt; 10)
        self.assertEqual({"MSFT"}, rule.depends_on())</pre></div><p>One point to<a id="id81" class="indexterm"/> note is how we have used the <code class="literal">setupClass</code> method to do the setup. As discussed previously, this method is called just once for the whole series of tests. We use this method to set up the exchange and store it. Remember to put the <code class="literal">@classmethod</code> decorator on the <code class="literal">setupClass</code> method. We store the exchange in the class, and we can access it in the tests using <code class="literal">self.exchange</code>.</p><p>Otherwise, the tests are simply a matter of constructing a rule and checking the matches method.</p><div class="note" title="Note" style=""><div class="inner"><h3 class="title"><a id="note12"/>Note</h3><p>
<span class="strong"><strong>A (very) quick primer on decorators</strong></span>
</p><p>Decorators are functions that take a function as an input and return another function as an output. Python has a shorthand syntax by which we can say <code class="literal">@decorator</code> above a function or method and it will apply the decorator to that function. For more details, check the python documentation or a tutorial. A good one is <a class="ulink" href="http://simeonfranklin.com/blog/2012/jul/1/python-decorators-in-12-steps/">http://simeonfranklin.com/blog/2012/jul/1/python-decorators-in-12-steps/</a>.</p></div></div><p>Let us now <a id="id82" class="indexterm"/>look at another rule class, the <code class="literal">AndRule</code>. The <code class="literal">AndRule</code> is used when you want to compose two or more rules together, for example, <code class="literal">AAPL &gt; 10 AND GOOG &gt; 15</code>.</p><p>This is how we could write a test for it:</p><div class="informalexample"><pre class="programlisting">class AndRuleTest(unittest.TestCase):
    @classmethod
    def setUpClass(cls):
        goog = Stock("GOOG")
        goog.update(datetime(2014, 2, 10), 8)
        goog.update(datetime(2014, 2, 11), 10)
        goog.update(datetime(2014, 2, 12), 12)
        msft = Stock("MSFT")
        msft.update(datetime(2014, 2, 10), 10)
        msft.update(datetime(2014, 2, 11), 10)
        msft.update(datetime(2014, 2, 12), 12)
        redhat = Stock("RHT")
        redhat.update(datetime(2014, 2, 10), 7)
        cls.exchange = {"GOOG": goog, "MSFT": msft, "RHT": redhat}

    def test_an_AndRule_matches_if_all_component_rules_are_true(self):
        rule = AndRule(PriceRule("GOOG", lambda stock: stock.price &gt; 8), PriceRule("MSFT", lambda stock: stock.price &gt; 10))
        self.assertTrue(rule.matches(self.exchange))</pre></div><p>One of the things <a id="id83" class="indexterm"/>about writing a test first is that it makes us think about how the class is going to be used.</p><p>For example, how should we pass in the various sub-rules to the <code class="literal">AndRule</code>? Should we have a method to set them? Should we pass them as a list? Should we pass them as individual parameters? This is a design decision and creating the test first allows us to actually write code as a user of our class and determine which is the best choice. In the test above, we have decided to pass in each sub-rule as a separate parameter to the <code class="literal">AndRule</code> constructor.</p><p>Now that the decision has been made, we can implement some code to pass the test:</p><div class="informalexample"><pre class="programlisting">class AndRule:
    def __init__(self, *args):
        self.rules = args

    def matches(self, exchange):
        return all([rule.matches(exchange) for rule in self.rules])</pre></div><p>Here we <a id="id84" class="indexterm"/>can see <a id="id85" class="indexterm"/>how the test-first process helps drive the design of our code.</p><div class="note" title="Note" style=""><div class="inner"><h3 class="title"><a id="note13"/>Note</h3><p>
<span class="strong"><strong>The all function</strong></span>
</p><p>The all function is a built-in function that takes a list and returns <code class="literal">True</code> only if every element of that list is <code class="literal">True</code>.</p></div></div></div></div>


  <div id="sbo-rt-content"><div class="section" title="Exercise"><div class="titlepage"><div><div><h1 class="title"><a id="ch02lvl1sec24"/>Exercise</h1></div></div></div><p>It is now time to put our newly-learned skills into practice. Here is a new requirement to build into the <code class="literal">Stock</code> class:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">Sometimes, updates might come out of order and we might get an update for a newer timestamp, followed by an update for an older timestamp. This could be due to random network latency, or due to the fact that sometimes we might get updates from different sources and one might be slightly ahead of the other.</li><li class="listitem" style="list-style-type: disc">The <code class="literal">Stock</code> class should be able to handle such cases, and the <code class="literal">price</code> attribute should return the latest price as per the timestamp.</li><li class="listitem" style="list-style-type: disc">The <code class="literal">is_increasing_trend</code> should also process the latest three prices as per their timestamps.</li></ul></div><p>Try your hand at implementing this requirement. Do not make any changes to the existing interfaces for these methods, but feel free to make any changes to the implementation as you require. Here are some things to think about:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">Does our existing design support this new feature? Do we need to make any changes to the current design?</li><li class="listitem" style="list-style-type: disc">What kind of tests would we write for this requirement?</li><li class="listitem" style="list-style-type: disc">After we get everything working, is there any clean up we can do to make the code more readable or maintainable?</li><li class="listitem" style="list-style-type: disc">Do we need to change the existing tests after we make this change, or do they continue to work without any modifications?</li></ul></div><p>By the end of the exercise, you should have all the existing tests passing, as well as any new ones that you wrote for this requirement. Once you are done, you can check <a class="link" href="apa.html" title="Appendix A. Answers to Exercises">Appendix A</a>, <span class="emphasis"><em>Answers to Exercises</em></span> for one possible solution to this exercise.</p></div></div>


  <div id="sbo-rt-content"><div class="section" title="Summary"><div class="titlepage"><div><div><h1 class="title"><a id="ch02lvl1sec25"/>Summary</h1></div></div></div><p>In this chapter we took a more detailed look at the TDD cycle. We learnt about the Arrange-Act-Assert pattern, took a more detailed look at the various assertions that are provided, as well as some of the different ways of setting up tests and cleaning up afterwards. Finally, we looked at how to prevent tests from being too brittle and did a few basic refactorings.</p></div></div>
</body></html>