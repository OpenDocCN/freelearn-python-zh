<html><head></head><body>
        

                            
                    <h1 class="header-title">Creating Controllers with Blueprints</h1>
                
            
            
                
<p>The final piece of the <strong>Model View Controller</strong> (<strong>MVC</strong>) equation is controllers. We have already seen the basic usage of the view functions in our <kbd>main.py</kbd> file. Now, the more complex and powerful versions will be introduced, and we will turn our disparate view functions into cohesive wholes. We will also discuss the internals of how Flask handles the lifetime of an HTTP request and advanced ways to define Flask views.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">Sessions and globals</h1>
                
            
            
                
<p><strong>Sessions</strong> are the way Flask will store information across requests; to do this, Flask will use signed cookies using the previously set <kbd>SECRET_KEY</kbd> config to apply the HMAC-SHA1 default cryptographic method. So, a user can read their session cookie but can't modify it. Flask also sets a default session lifetime that defaults to 31 days to prevent relay attacks; this can be changed by using the configuration key's <kbd>PERMANENT_SESSION_LIFETIME</kbd> config key.</p>
<p>Security is paramount in today's modern web applications; read Flask's documentation carefully, where various attacks methods are covered: <a href="http://flask.pocoo.org/docs/security/">http://flask.pocoo.org/docs/security/</a>.</p>
<p>A Flask session object is a special kind of Python dictionary, but you can use it much like a plain Python dictionary, as follows:</p>
<pre>from flask import session<br/>...<br/>session['page_loads'] = session.get('page_loads', 0) + 1<br/>...</pre>
<p><strong>Global</strong> is a thread-safe namespace store to keep data during a request's context. At the beginning of each request, a new global object is created, and at the end of the request the object is destroyed. It's the right place to keep a User object or any data that needs to be shared across views, templates, or Python functions that are called within the request context. This is done without the need to pass around any data.</p>
<p>The use of <kbd>g</kbd> (global)<strong> </strong>is very simple, to set a key on a request context:</p>
<pre>from flask import g<br/>....<br/># Set some key with some value on a request context<br/>g.some_key = "some_value"<br/># Get a key<br/>v = g.some_key<br/># Get and remove a key<br/>v = g.pop('some_key', "default_if_not_present")</pre>


            

            
        
    

        

                            
                    <h1 class="header-title">Request setup and teardown</h1>
                
            
            
                
<p>When your <strong>WSGI</strong> (<strong>Web Server Gateway Interface</strong>) handles a request, Flask creates a request context object that contains all the information about the request itself. This object is pushed into a stack that contains other important information, such as the Flask <kbd>app</kbd> , <kbd>g</kbd>, <kbd>session</kbd>, and flash messages. </p>
<p>The request object is available to any function, view, or template that is currently processing the request; this happens without the need to pass around the request object itself. <kbd>request</kbd> contains information such as HTTP headers, URI arguments, URL path, WSGI environment, and whatnot. </p>
<p>For more detailed information on the Flask request object, see: <a href="http://flask.pocoo.org/docs/api/#incoming-request-data">http://flask.pocoo.org/docs/api/#incoming-request-data</a>.<a href="http://flask.pocoo.org/docs/api/#incoming-request-data"/></p>
<p class="mce-root"/>
<p>We can easily add more information to the request context by implementing our own hooks on request creation. To achieve this, we can use Flask's decorator function, <kbd>@app.before_request</kbd>, and the <kbd>g</kbd> object. The <kbd>@app.before_request</kbd> function is executed every time, before a new request is made. For example, the following code keeps a global counter for the number of page loads:</p>
<p> </p>
<pre>import random<br/>from flask import session, g<br/><br/>@app.before_request<br/>def before_request():<br/>    session['page_loads'] = session.get('page_loads', 0) + 1<br/>    g.random_key = random.randrange(1, 10)</pre>
<p>Multiple functions can be decorated with <kbd>@app.before_request</kbd>, and they all will be executed before the requested view function is executed. There also exists a decorator, <kbd>@app.teardown_request</kbd>, which is called after the end of every request. </p>
<p>Initialize the example code provided for this chapter and watch how the data for <kbd>g</kbd>, <kbd>session</kbd>, and <kbd>request</kbd> changes. Also, note the <kbd>csrf_token</kbd> set by WTForm to secure our forms.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">Error pages</h1>
                
            
            
                
<p>Displaying a browser's default error pages to the end user is jarring as the user loses all context of your app, and they must hit the back button to return to your site. To display your own templates when an error is returned with the Flask <kbd>abort()</kbd> function, use the <kbd>errorhandler</kbd> decorator function:</p>
<pre>@app.errorhandler(404) 
def page_not_found(error): 
    return render_template('404.html'), 404 </pre>
<p><kbd>errorhandler</kbd> is also useful to translate internal server errors and HTTP 500 codes into user-friendly error pages. The <kbd>app.errorhandler()</kbd> function may take either one or many HTTP status codes to define which code it will act on. The returning of a tuple instead of just an HTML string allows you to define the HTTP status code of the <kbd>Response</kbd> object. By default, this is set to <kbd>200</kbd>. The <kbd>recommend</kbd> method is covered in <a href="433b4f3b-4e05-4a63-ae8b-ec2e392877b4.xhtml" target="_blank">Chapter 6</a>, <em>Securing Your App</em>.</p>
<p class="mce-root"/>


            

            
        
    

        

                            
                    <h1 class="header-title">Class-based views</h1>
                
            
            
                
<p>In most Flask apps, views are handled by functions. However, when many views share common functionality or there are pieces of your code that could be broken out into separate functions, it would be useful to implement our views as classes to take advantage of inheritance.</p>
<p>For example, if we have views that render a template, we could create a generic view class that keeps our code <em>DRY</em>:</p>
<pre>from flask.views import View 
 
class GenericView(View): 
    def __init__(self, template): 
        self.template = template 
        super(GenericView, self).__init__() 
 
    def dispatch_request(self): 
        return render_template(self.template) 
 
app.add_url_rule( 
    '/', view_func=GenericView.as_view( 
        'home', template='home.html' 
    ) 
)</pre>
<p>The first thing to note about this code is the <kbd>dispatch_request()</kbd> function in our view class. This is the function in our view that acts as the normal view function and returns an HTML string. The <kbd>app.add_url_rule()</kbd> function mimics the <kbd>app.route()</kbd> function as it ties a route to a function call. The first argument defines the route of the function, and the <kbd>view_func</kbd> parameter defines the function that handles the route. The <kbd>View.as_view()</kbd> method is passed to the <kbd>view_func</kbd> parameter because it transforms the <kbd>View</kbd> class into a view function. The first argument defines the name of the view function, so functions such as <kbd>url_for()</kbd> can route to it. The remaining parameters are passed to the <kbd>__init__</kbd> function of the <kbd>View</kbd> class.</p>
<p>Like the normal view functions, HTTP methods other than <kbd>GET</kbd> must be explicitly allowed for the <kbd>View</kbd> class. To allow other methods, a class variable containing the list of named methods must be added:</p>
<pre>class GenericView(View): 
    methods = ['GET', 'POST'] 
    ... 
    def dispatch_request(self): 
        if request.method == 'GET': 
            return render_template(self.template) 
        elif request.method == 'POST': 
            ... </pre>
<p>This can be a very powerful approach. Take for example web pages that render tabular lists from database tables; they are almost identical, so are nice candidates for generic approaches. Although not a trivial task to carry out, the time you take to implement it can save you time in the future. An initial skeleton using class-based views could be this:</p>
<pre>from flask.views import View<br/><br/><br/>class GenericListView(View):<br/><br/>    def __init__(self, model, list_template='generic_list.html'):<br/>        self.model = model<br/>        self.list_template = list_template<br/>        <strong>self.columns = self.model.__mapper__.columns.keys()</strong><br/>        # Call super python3 style<br/>        super(GenericListView, self).__init__()<br/><br/>    def render_template(self, context):<br/>        return render_template(self.list_template, **context)<br/><br/>    def get_objects(self):<br/>        return self.model.query.all()<br/><br/>    def dispatch_request(self):<br/>        <strong>context = {'objects': self.get_objects(),<br/>                   'columns': self.columns}</strong><br/>        return self.render_template(context)<br/><br/><br/>app.add_url_rule(<br/>    '/generic_posts', view_func=GenericListView.as_view(<br/>        'generic_posts', model=Post)<br/>    )<br/><br/>app.add_url_rule(<br/>    '/generic_users', view_func=GenericListView.as_view(<br/>        'generic_users', model=User)<br/>)<br/><br/>app.add_url_rule(<br/>    '/generic_comments', view_func=GenericListView.as_view(<br/>        'generic_comments', model=Comment)<br/>)</pre>
<p class="mce-root"/>
<p>There are some interesting things to notice. First, in the class constructor we initialize the <kbd>columns</kbd> class property with the SQLAlchemy model columns; we are leveraging the model introspection ability of SQLAlchemy to be able to implement our generic template. So, column names are going to be passed to our generic template so that we can properly render a well formatted tabular list for any model we throw at it. </p>
<p>This is a simple example of how, with a single class view, we handle all list views from all our models.</p>
<p>This is how the template looks like:</p>
<pre>{% extends "base.html" %}<br/>{% block body %}<br/><br/>&lt;div class="table-responsive"&gt;<br/>    &lt;table class="table table-bordered table-hover"&gt;<br/>    {% for obj in objects %}<br/>        &lt;tr&gt;<br/>        {% for col in columns %}<br/>        &lt;td&gt;<br/>        {{col}} {{ obj[col] }}<br/>        &lt;/td&gt;<br/>        {% endfor %}<br/>        &lt;/tr&gt;<br/>    {% endfor %}<br/>    &lt;/table&gt;<br/>&lt;/div&gt;<br/><br/>{% endblock %}</pre>
<p>You can access these views by running the example code provided for this chapter, then directly accessing the declared URLs: </p>
<ul>
<li><kbd>http://localhost:5000/generic_users</kbd></li>
<li><kbd>http://localhost:5000/generic_posts</kbd></li>
<li><kbd>http://localhost:5000/generic_comments</kbd></li>
</ul>
<p>You may have noticed that our tabular view is missing the table column headers. As an exercise, I challenge you to implement it; you can simply render the provided <kbd>columns</kbd> class property, or even better, use a label/column mapping to display more user-friendly column names.</p>
<p class="mce-root"/>


            

            
        
    

        

                            
                    <h1 class="header-title">Method class views</h1>
                
            
            
                
<p>Often, when functions handle multiple HTTP methods, the code can become difficult to read due to large sections of code nested within <kbd>if</kbd> statements, as demonstrated in the following:</p>
<pre>@app.route('/user', methods=['GET', 'POST', 'PUT', 'DELETE']) 
def users(): 
    if request.method == 'GET': 
        ... 
    elif request.method == 'POST': 
        ... 
    elif request.method == 'PUT': 
        ... 
    elif request.method == 'DELETE': 
        ... </pre>
<p>This can be solved with the <kbd>MethodView</kbd> class. <kbd>MethodView</kbd> allows each method to be handled by a different class method to separate concerns:</p>
<pre>from flask.views import MethodView 
 
class UserView(MethodView): 
    def get(self): 
        ... 
    def post(self): 
        ... 
    def put(self): 
        ... 
    def delete(self): 
        ... 
 
app.add_url_rule( 
    '/user', 
    view_func=UserView.as_view('user') 
) </pre>


            

            
        
    

        

                            
                    <h1 class="header-title">Blueprints</h1>
                
            
            
                
<p>In Flask, a <strong>blueprint</strong> is a method of extending an existing Flask app. They provide a way of combining groups of views with common functionality and allow developers to break their app down into different components. In our architecture, the blueprints will act as our <em>controllers</em>.</p>
<p class="mce-root"/>
<p>Views are registered to a blueprint; a separate template and static folder can be defined for it, and when it has all the desired content in it, it can be registered on the main Flask app to add the blueprint's content. A blueprint acts much like a Flask app object, but is not actually a self-contained app. This is how Flask extensions provide view functions. To get an idea of what blueprints are, here is a very simple example:</p>
<pre>from flask import Blueprint 
example = Blueprint( 
    'example', 
    __name__, 
    template_folder='templates/example', 
    static_folder='static/example', 
    url_prefix="/example" 
) 
 
@example.route('/') 
def home(): 
    return render_template('home.html') </pre>
<p>The blueprint takes two required parameters, the name of the blueprint and the name of the package, which are used internally in Flask, and passing <kbd>__name__</kbd> to it will suffice.</p>
<p>The other parameters are optional and define where the blueprint will look for files. Because <kbd>templates_folder</kbd> was specified, the blueprint will not look in the default template folder, and the route will render <kbd>templates/example/home.html</kbd> and not <kbd>templates/home.html</kbd>. The <kbd>url_prefix</kbd> option automatically adds the provided URI to the start of every route in the blueprint. So, the URL for the home view is actually <kbd>/example/</kbd>.</p>
<p>The <kbd>url_for()</kbd> function will now have to be told which blueprint the requested route is in:</p>
<pre>{{ url_for('example.home') }} </pre>
<p>Also, the <kbd>url_for()</kbd> function will now have to be told whether the view is being rendered from within the same blueprint:</p>
<pre>{{ url_for('.home') }} </pre>
<p>The <kbd>url_for()</kbd> function will also look for static files in the specified <kbd>static</kbd> folder as well.</p>
<p>Use this to add the blueprint to our app:</p>
<pre>app.register_blueprint(example) </pre>
<p>Let's transform our current app to one that uses blueprints. We will first need to define our blueprint before all of our routes:</p>
<pre>blog_blueprint = Blueprint( 
    'blog', 
    __name__, 
    template_folder='templates/blog', 
    url_prefix="/blog" 
) </pre>
<p>Now, because the <kbd>templates</kbd> folder was defined, we need to move all of our templates into a subfolder of the <kbd>templates</kbd> folder named <kbd>blog</kbd>. Next, all of our routes need to have <kbd>@app.route</kbd> changed to <kbd>@blog_blueprint.route</kbd>, and any class view assignments now need to be registered to <kbd>blog_blueprint</kbd>. Remember that the <kbd>url_for()</kbd> function calls in the templates will also have to be changed to have a period prepended to then to indicate that the route is in the same blueprint.</p>
<p>At the end of the file, right before the <kbd>if__name__ == '__main__':</kbd> statement, add the following:</p>
<pre>app.register_blueprint(blog_blueprint)</pre>
<p>Now, all of our content is back in the app, which is registered under the blueprint. Because our base app no longer has any views, let's add a redirect on the base URL:</p>
<pre>@app.route('/') 
def index(): 
    return redirect(url_for('blog.home')) </pre>
<p>Why blog and not <kbd>blog_blueprint</kbd>? Because blog is the name of the blueprint and the name is what Flask uses internally for routing. <kbd>blog_blueprint</kbd> is the name of the variable in the Python file.</p>
<p class="mce-root"/>
<p class="mce-root"/>


            

            
        
    

        

                            
                    <h1 class="header-title">Summary</h1>
                
            
            
                
<p>In this chapter, we have introduced you to some powerful features of Flask; we have seen how to use sessions to store user data across requests and globals for keeping data during the request context. We have introduced you to the concept of request context and started showing you some new features that will enable us to scale our applications easily to any size, using Blueprints and Method Class views.</p>
<p>We now have our app working inside a blueprint, but what does this give us? Let's say that we wanted to add a photo sharing function to our site, we would be able to group all the view functions into one blueprint with its own templates, static folder, and URL prefix without any fear of disrupting the functionality of the rest of the site.</p>
<p>In the next chapter, blueprints will be made even more powerful by separating them into different files after upgrading our file and code structure.</p>


            

            
        
    </body></html>