- en: <st c="0">6</st>
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: <st c="0">6</st>
- en: <st c="2">Developing Computational and Scientific Applications</st>
  id: totrans-1
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: <st c="2">开发计算和科学应用</st>
- en: <st c="54">Computational scientists always choose easy-to-use, effective, and
    accurate GUI-based applications for their discovery, analysis, synthesis, data
    mines, and number crunches to save time and effort in arriving at some conclusions
    for their studies.</st> <st c="303">Although powerful computational tools are
    available in the market, such as Maple, Matlab, MathCAD, and Mathematica, scientists
    still prefer mechanisms that can provide them with further customizations to apply
    their desired precision, accuracy, and calibration for their mathematical and
    statistical models.</st> <st c="611">In other words, they still prefer custom-made
    applications that can fit with their laboratory setup</st> <st c="711">and parameters.</st>
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="54">计算科学家总是选择易于使用、有效和准确的基于 GUI 的应用程序来进行他们的发现、分析、综合、数据挖掘和数值计算，以节省时间和精力，为他们的研究得出结论。</st>
    <st c="303">尽管市场上提供了强大的计算工具，如 Maple、Matlab、MathCAD 和 Mathematica，但科学家仍然更喜欢可以提供进一步定制的机制，以便应用他们所需的精度、准确性和校准到他们的数学和统计模型。</st>
    <st c="611">换句话说，他们仍然更喜欢可以与他们的实验室设置</st> <st c="711">和参数相匹配的定制应用程序。</st>
- en: <st c="726">Since the utmost priority is to provide scientists with accurate
    results given an infinite number of data, it is always a challenge as to what
    application frameworks to use in building scalable, real-time, and fast modules
    suited to their needs.</st> <st c="973">The ultimate requirement is to create
    and run asynchronous transactions for complex numerical algorithms, which asynchronous
    Flask</st> <st c="1104">can provide.</st>
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="726">由于最高优先级是提供科学家在给定无限数据的情况下准确的结果，因此选择什么应用程序框架来构建适合他们需求的可扩展、实时和快速模块始终是一个挑战。</st>
    <st c="973">最终要求是创建和运行异步事务以执行复杂的数值算法，这是异步 Flask</st> <st c="1104">可以提供的。</st>
- en: <st c="1116">The Flask has asynchronous components that can build complex, fast,
    and real-time applications for scientists.</st> <st c="1228">Because of its flexibility,
    asynchronous features, and wide-ranging support, this framework has the complete
    building blocks that can provide scientists with their tailor-fit</st> <st c="1403">scientific
    software.</st>
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="1116">Flask 有异步组件，可以为科学家构建复杂、快速和实时的应用程序。</st> <st c="1228">由于其灵活性、异步特性和广泛的支持，这个框架提供了完整的构建模块，可以为科学家提供定制的</st>
    <st c="1403">科学软件。</st>
- en: <st c="1423">This chapter will cover the following computational building blocks
    that flask[async]</st> <st c="1510">can provide:</st>
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="1423">本章将介绍 Flask[async] 可以提供的以下计算构建模块：</st>
- en: <st c="1522">Uploading</st> **<st c="1533">Comma-Separated Values</st>** <st
    c="1555">(</st>**<st c="1557">CSV</st>**<st c="1560">) and</st> **<st c="1567">Microsoft
    Excel Spreadsheets</st>** <st c="1595">(</st>**<st c="1597">XLSX</st>**<st c="1601">)
    documents</st> <st c="1614">for computing</st>
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: <st c="1522">上传</st> **<st c="1533">逗号分隔值</st>** <st c="1555">(</st>**<st c="1557">CSV</st>**<st
    c="1560">) 和</st> **<st c="1567">Microsoft Excel 工作表</st>** <st c="1595">(</st>**<st
    c="1597">XLSX</st>**<st c="1601">) 文档</st> <st c="1614">用于计算</st>
- en: <st c="1627">Implementing symbolic computation</st> <st c="1662">with visualization</st>
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: <st c="1627">实现符号计算</st> <st c="1662">与可视化</st>
- en: <st c="1680">Using the</st> `<st c="1691">pandas</st>` <st c="1697">module for
    data and</st> <st c="1718">graphical analysis</st>
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: <st c="1680">使用</st> `<st c="1691">pandas</st>` <st c="1697">模块进行数据和</st> <st
    c="1718">图形分析</st>
- en: <st c="1736">Creating and rendering</st> <st c="1760">LaTeX documents</st>
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: <st c="1736">创建和渲染</st> <st c="1760">LaTeX 文档</st>
- en: <st c="1775">Building graphical charts with</st> <st c="1807">frontend libraries</st>
  id: totrans-10
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: <st c="1775">使用</st> <st c="1807">前端库</st> <st c="1811">构建图形图表</st>
- en: <st c="1825">Building real-time data plots using WebSocket and</st> **<st c="1876">Server-Sent</st>**
    **<st c="1888">Events</st>** <st c="1894">(</st>**<st c="1896">SSE</st>**<st c="1899">)</st>
  id: totrans-11
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: <st c="1825">使用 WebSocket 和</st> **<st c="1876">服务器端事件</st>** **<st c="1888">（SSE）</st>
    <st c="1894">(</st>**<st c="1896">SSE</st>**<st c="1899">)</st>
- en: <st c="1901">Using asynchronous background tasks for</st> <st c="1941">resource-intensive
    computations</st>
  id: totrans-12
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: <st c="1901">使用异步后台任务进行</st> <st c="1941">资源密集型计算</st>
- en: <st c="1972">Incorporating Julia packages</st> <st c="2002">with Flask</st>
  id: totrans-13
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: <st c="1972">将 Julia 包与 Flask</st> <st c="2002">集成</st>
- en: <st c="2012">Technical requirements</st>
  id: totrans-14
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: <st c="2012">技术要求</st>
- en: <st c="2035">This chapter will highlight a software prototype for an</st> *<st
    c="2092">Online Housing Pricing Prediction and Analysis</st>* <st c="2138">application
    with features expected to appear in many scientific applications.</st> <st c="2217">First,
    it has simple and formal GUIs that capture user data through forms.</st> <st c="2292">Forms
    that will ask for formulas, variable values, and constants with the capability
    to provide graphical plots, either in real-time or immediately after computations,
    are used.</st> <st c="2470">Second, it is a web application that can be accessible
    within teams or organizations.</st> <st c="2556">Finally, the application can
    run highly computational tasks asynchronously with the</st> <st c="2640">Flask
    platform.</st>
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="2035">本章将重点介绍一个</st> *<st c="2092">在线房价预测与分析</st>* <st c="2138">软件原型，该原型预计将在许多科学应用中出现。</st>
    <st c="2217">首先，它具有简单而正式的图形用户界面，通过表单捕获用户数据。</st> <st c="2292">使用的表单将要求输入公式、变量值和常数，并具有提供图形图表的能力，无论是实时还是计算后立即显示。</st>
    <st c="2470">其次，它是一个可以在团队或组织中访问的Web应用程序。</st> <st c="2556">最后，该应用程序可以使用</st> <st
    c="2640">Flask平台</st>异步运行高度计算的任务。
- en: <st c="2655">The test data used in this chapter are from</st> [<st c="2700">https://www.kaggle.com/datasets/yasserh/housing-prices-dataset</st>](https://www.kaggle.com/datasets/yasserh/housing-prices-dataset)
    <st c="2762">and</st> [<st c="2767">https://data.world/finance/international-house-price-database</st>](https://data.world/finance/international-house-price-database)<st
    c="2828">. On the other hand, this project uses the</st> `<st c="2871">Blueprint</st>`
    <st c="2880">approach for managing the modules and components.</st> <st c="2931">All
    files are available</st> <st c="2955">at</st> [<st c="2958">https://github.com/PacktPublishing/Mastering-Flask-Web-Development/tree/main/ch06</st>](https://github.com/PacktPublishing/Mastering-Flask-Web-Development/tree/main/ch06)<st
    c="3039">.</st>
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="2655">本章中使用的测试数据来自</st> [<st c="2700">https://www.kaggle.com/datasets/yasserh/housing-prices-dataset</st>](https://www.kaggle.com/datasets/yasserh/housing-prices-dataset)
    <st c="2762">和</st> [<st c="2767">https://data.world/finance/international-house-price-database</st>](https://data.world/finance/international-house-price-database)<st
    c="2828">。另一方面，本项目采用</st> `<st c="2871">蓝图</st>` <st c="2880">方法来管理模块和组件。</st>
    <st c="2931">所有文件均可在</st> <st c="2955">以下链接</st> [<st c="2958">https://github.com/PacktPublishing/Mastering-Flask-Web-Development/tree/main/ch06</st>](https://github.com/PacktPublishing/Mastering-Flask-Web-Development/tree/main/ch06)<st
    c="3039">找到。</st>
- en: <st c="3040">Uploading CSV and XLSX documents for computing</st>
  id: totrans-17
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: <st c="3040">上传 CSV 和 XLSX 文档进行计算</st>
- en: <st c="3087">The application</st> <st c="3103">will deal</st> <st c="3114">with
    XLSX and CSV files that contain numerical data affecting worldwide house prices,
    such as the periodic actual and</st> <st c="3232">nominal</st> **<st c="3240">House
    Price Index</st>** <st c="3257">(</st>**<st c="3259">HPI</st>**<st c="3262">)
    of each country and the nominal and actual</st> **<st c="3308">Personal Disposable
    Income</st>** <st c="3334">(</st>**<st c="3336">PDI</st>**<st c="3339">) of the</st>
    <st c="3349">customers.</st> <st c="3360">Also, some documents will show how factors
    such as the house area, furnishing status, the main road preference, and the number
    of bedrooms and bathrooms can affect the housing prices in a country.</st> <st
    c="3557">Our application will upload these documents to the server for</st> <st
    c="3619">data analysis.</st>
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="3087">该应用程序</st> <st c="3103">将处理</st> <st c="3114">包含影响全球房价的数值数据的XLSX和CSV文件，例如每个国家的周期性实际和</st>
    <st c="3232">名义</st> **<st c="3240">房价指数</st>** <st c="3257">(</st>**<st c="3259">HPI</st>**<st
    c="3262">) 以及客户的</st> <st c="3308">名义和实际</st> **<st c="3308">个人可支配收入</st>** <st
    c="3334">(</st>**<st c="3336">PDI</st>**<st c="3339">)。</st> <st c="3360">此外，一些文档将展示诸如房屋面积、装修状况、主要道路偏好以及卧室和浴室数量等因素如何影响一个国家的房价。</st>
    <st c="3557">我们的应用程序将把这些文档上传到服务器进行</st> <st c="3619">数据分析。</st>
- en: <st c="3633">Flask has built-in support for a single- or multiple-file-uploading
    process through an HTML</st> `<st c="3726"><form></st>` <st c="3732">with</st>
    `<st c="3738">enctype</st>` <st c="3745">of</st> `<st c="3749">multipart/form-data</st>`<st
    c="3768">. It stores all uploaded files in the</st> `<st c="3806">request.files</st>`
    <st c="3819">dictionary as</st> `<st c="3834">FileStorage</st>` <st c="3845">instances.</st>
    `<st c="3857">FileStorage</st>` <st c="3868">is a thin wrapper class from the</st>
    `<st c="3902">werkzeug</st>` <st c="3910">module used by Flask to represent an
    incoming file.</st> <st c="3963">The following is an HTML script that uploads
    an XLSX document for data analysis</st> <st c="4043">using</st> <st c="4048">the</st>
    `<st c="4053">pandas</st>` <st c="4059">module:</st>
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="3633">Flask 通过一个具有</st> `<st c="3726"><form></st>` <st c="3732">和</st>
    `<st c="3738">enctype</st>` <st c="3745">为</st> `<st c="3749">multipart/form-data</st>`<st
    c="3768">的 HTML</st> `<st c="3726"><form></st>` <st c="3732">表单支持单个或多个文件的上传过程。它将所有上传的文件存储在</st>
    `<st c="3806">request.files</st>` <st c="3819">字典中，作为</st> `<st c="3834">FileStorage</st>`
    <st c="3845">实例。</st> `<st c="3857">FileStorage</st>` <st c="3868">是 Flask 使用的
    Werkzeug 模块中的一个薄包装类，用于表示传入的文件。</st> `<st c="3963">以下是一个 HTML 脚本，它使用</st> `<st
    c="4048">pandas</st>` <st c="4059">模块上传 XLSX 文档以进行数据分析：</st>
- en: '[PRE0]'
  id: totrans-20
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: <st c="4472">The following snippet shows the</st> `<st c="4505">view</st>` <st
    c="4509">function implementation that renders the given page and accepts the</st>
    <st c="4577">incoming</st> <st c="4586">XLSX document:</st>
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="4472">以下代码片段显示了</st> `<st c="4505">view</st>` <st c="4509">函数的实现，该函数渲染给定的页面并接受</st>
    `<st c="4577"> incoming</st>` <st c="4586"> XLSX 文档：</st>
- en: '[PRE1]'
  id: totrans-22
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: <st c="5703">Like any form parameter, the view function accesses the file object
    from</st> `<st c="5777">request.files</st>` <st c="5790">through the name of the
    form field.</st> <st c="5827">The file object, wrapped in a</st> `<st c="5857">FileStorage</st>`
    <st c="5868">wrapper, provides</st> <st c="5887">the</st> <st c="5890">following
    attributes:</st>
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="5703">与任何表单参数一样，视图函数通过表单字段的名称从</st> `<st c="5777">request.files</st>`
    <st c="5790">访问文件对象。</st> <st c="5827">文件对象，封装在一个</st> `<st c="5857">FileStorage</st>`
    <st c="5868">包装器中，提供了以下属性：</st>
- en: '`<st c="5912">filename</st>`<st c="5921">: This provides the raw filename of
    the</st> <st c="5962">file object.</st>'
  id: totrans-24
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`<st c="5912">filename</st>`<st c="5921">: 这提供了文件对象的原始文件名。</st>'
- en: '`<st c="5974">stream</st>`<st c="5981">: This provides the input stream object
    that emits Input/Output methods such as</st> `<st c="6062">read()</st>`<st c="6068">,</st>
    `<st c="6070">write()</st>`<st c="6077">,</st> `<st c="6079">readline()</st>`<st
    c="6089">,</st> `<st c="6091">writelines()</st>`<st c="6103">,</st> <st c="6105">and</st>
    `<st c="6109">seek()</st>`<st c="6115">.</st>'
  id: totrans-25
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`<st c="5974">stream</st>`<st c="5981">: 这提供了输入流对象，该对象可以发出输入/输出方法，例如</st> `<st
    c="6062">read()</st>`<st c="6068">,</st> `<st c="6070">write()</st>`<st c="6077">,</st>
    `<st c="6079">readline()</st>`<st c="6089">,</st> `<st c="6091">writelines()</st>`<st
    c="6103">,</st> <st c="6105">和</st> `<st c="6109">seek()</st>`<st c="6115">.</st>'
- en: '`<st c="6116">headers</st>`<st c="6124">: This contains the file’s</st> <st
    c="6152">header information.</st>'
  id: totrans-26
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`<st c="6116">headers</st>`<st c="6124">: 这包含文件的</st> `<st c="6152">header</st>`<st
    c="6156">信息。</st>'
- en: '`<st c="6171">content-length</st>`<st c="6186">: This pertains to the content-length
    header of</st> <st c="6235">the file.</st>'
  id: totrans-27
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`<st c="6171">content-length</st>`<st c="6186">: 这与文件的</st> `<st c="6235">
    content-length</st>`<st c="6239">头有关。</st>'
- en: '`<st c="6244">content-type</st>`<st c="6257">: This pertains to the content-type
    header of</st> <st c="6304">the file.</st>'
  id: totrans-28
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`<st c="6244">content-type</st>`<st c="6257">: 这与文件的</st> `<st c="6304">content-type</st>`<st
    c="6308">头有关。</st>'
- en: <st c="6313">It also contains the following methods that can manage the file</st>
    <st c="6378">at runtime:</st>
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="6313">它还包含以下可以在运行时管理文件的方法：</st>
- en: '`<st c="6389">save(destination)</st>`<st c="6407">: This places the file in</st>
    <st c="6434">a destination.</st>'
  id: totrans-30
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`<st c="6389">save(destination)</st>`<st c="6407">: 这会将文件放置在</st> `<st c="6434">目的地</st>`<st
    c="6438">。</st>'
- en: '`<st c="6448">close()</st>`<st c="6456">: This closes the file,</st> <st c="6481">if
    necessary.</st>'
  id: totrans-31
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`<st c="6448">close()</st>`<st c="6456">: 如果需要，这会关闭文件。</st>'
- en: <st c="6494">Before accessing the file for reading, writing, transformation,
    or saving, the view function must apply validation and restriction to the file
    object received.</st> <st c="6655">Here are the following areas of concern where
    to impose</st> <st c="6711">red flags:</st>
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="6494">在访问文件进行读取、写入、转换或保存之前，视图函数必须对收到的文件对象应用验证和限制。</st> `<st c="6655">以下是需要注意的以下区域，以设置</st>`
    `<st c="6711">红旗：</st>`
- en: <st c="6721">The existence of the actual</st> <st c="6750">uploaded file</st>
  id: totrans-33
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: <st c="6721">实际</st> `<st c="6750">上传的文件</st>
- en: <st c="6763">A</st> <st c="6766">sanitized filename</st>
  id: totrans-34
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: <st c="6763">一个</st> `<st c="6766">清理过的文件名</st>
- en: <st c="6784">The accepted valid extension of</st> <st c="6817">the file</st>
  id: totrans-35
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`<st c="6784">接受的文件有效扩展名</st>` `<st c="6817">为</st>`'
- en: <st c="6825">The accepted</st> <st c="6839">file size</st>
  id: totrans-36
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`<st c="6825">接受的</st>` `<st c="6839">文件大小</st>`'
- en: <st c="6848">The given</st> `<st c="6859">show_analysis()</st>` <st c="6874">view
    function raises the following custom exception classes when it encounters a problem
    on the preceding</st> <st c="6981">red flags:</st>
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 给定的`<st c="6848">show_analysis()</st>` `<st c="6859">视图函数</st>` `<st c="6874">在遇到前一个</st>`
    `<st c="6981">红旗</st>` `<st c="6981">问题</st>`时引发以下自定义异常类：
- en: '`<st c="6991">NoneFilenameException</st>`<st c="7013">: This is raised when
    there is no filename in</st> <st c="7060">the request.</st>'
  id: totrans-38
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`<st c="6991">NoneFilenameException</st>` `<st c="7013">: 当请求中没有文件名时引发。</st>`'
- en: '`<st c="7072">InvalidTypeException</st>`<st c="7093">: This is raised when
    the sanitized filename gives an</st> <st c="7148">empty value.</st>'
  id: totrans-39
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`<st c="7072">InvalidTypeException</st>` `<st c="7093">: 当清理后的文件名给出空值时引发。</st>`'
- en: '`<st c="7160">InvalidTypeException</st>`<st c="7181">: This is raised when
    the uploaded file has an extension not supported by</st> <st c="7256">the application.</st>'
  id: totrans-40
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`<st c="7160">InvalidTypeException</st>` `<st c="7181">: 当上传的文件扩展名不被</st>`
    `<st c="7256">应用程序</st>` `<st c="7256">支持</st>`时引发。'
- en: <st c="7272">Also, part of the concern is to sanitize the filename of the multipart
    object before utilizing it for any file transactions.</st> <st c="7398">The immediate
    use of the raw</st> `<st c="7427">filename</st>` <st c="7435">attribute of the</st>
    `<st c="7453">FileStorage</st>` <st c="7464">instance can expose the application
    to several vulnerabilities because</st> `<st c="7536">filename</st>` <st c="7544">can
    have malware-related symbols, some special characters that are suspicious, and
    characters denoting the file path, such as</st> `<st c="7671">../../</st>`<st
    c="7677">, which can cause trouble with the</st> `<st c="7712">save()</st>` <st
    c="7718">method.</st> <st c="7727">To perform filename sanitation, use the</st>
    `<st c="7767">secure_filename()</st>` <st c="7784">utility method of the</st>
    `<st c="7807">werkzeug.utils</st>` <st c="7821">module.</st> <st c="7830">On the
    other hand, some of our application’s view functions save their uploaded files
    inside our project’s folder, but storing them outside the project directory is
    still the</st> <st c="8005">best practice.</st>
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，部分关注点是，在利用任何文件事务之前，对多部分对象的文件名进行清理。<st c="7272">立即使用</st>` `<st c="7427">filename</st>`
    `<st c="7435">属性</st>` `<st c="7435">的</st>` `<st c="7453">FileStorage</st>` `<st
    c="7464">实例</st>`可能会使应用程序暴露于多个漏洞，因为`<st c="7536">filename</st>` `<st c="7544">可能包含与恶意软件相关的符号，一些可疑的特殊字符，以及表示文件路径的字符，例如`<st
    c="7671">../../</st>` `<st c="7677">`，这可能会与`<st c="7712">save()</st>` `<st c="7718">方法</st>`
    `<st c="7718">产生问题。</st>` `<st c="7727">要执行文件名清理，请使用</st>` `<st c="7767">secure_filename()</st>`
    `<st c="7784">实用方法</st>` `<st c="7784">的</st>` `<st c="7807">werkzeug.utils</st>`
    `<st c="7821">模块。</st>` `<st c="7830">另一方面，我们的一些应用程序视图函数将上传的文件保存在我们项目的文件夹中，但将它们存储在项目目录之外仍然是</st>`
    `<st c="8005">最佳实践。</st>`
- en: <st c="8019">Lastly, always enclose</st> <st c="8043">the</st> <st c="8046">entire
    file transactions of the view function with the</st> `<st c="8102">try-except</st>`
    <st c="8112">clause and raise the necessary exception classes to log all the underlying
    problems that will arise at runtime.</st> <st c="8225">Now, let us discuss the
    process after the file uploading with the</st> `<st c="8291">pandas</st>` <st
    c="8297">module.</st>
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，始终使用`<st c="8019">try-except</st>` `<st c="8043">子句</st>` `<st c="8046">包围</st>`
    `<st c="8046">视图函数的全部文件事务</st>`，并引发必要的异常类以记录运行时可能出现的所有底层问题。<st c="8225">现在，让我们讨论使用</st>`
    `<st c="8291">pandas</st>` `<st c="8297">模块</st>` `<st c="8297">上传文件后的过程。</st>`
- en: <st c="8305">Using the pandas module for data and graphical analysis</st>
  id: totrans-43
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用`<st c="8305">pandas模块进行数据和分析</st>`
- en: <st c="8361">The</st> `<st c="8366">pandas</st>` <st c="8372">module is a</st>
    <st c="8384">popular Python library for data analysis because of its easy-to-apply
    utility functions and a high-performance tabular data structure called</st> `<st
    c="8583">numpy</st>` <st c="8588">module, a low-level library that supports multi-dimensional
    array objects called</st> `<st c="8670">ndarray</st>` <st c="8677">and its mathematical
    operations, and</st> `<st c="8715">matplotlib</st>`<st c="8725">, a library for
    visualizations.</st> <st c="8757">So, install these two</st> <st c="8779">modules
    first:</st>
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="8361">pandas</st> <st c="8366">模块是一个</st> <st c="8372">流行的 Python 数据分析库，因为它易于应用的功能函数和名为</st>
    `<st c="8583">numpy</st>` <st c="8588">模块的高性能表格数据结构，一个支持多维数组对象和其数学运算的低级库，称为</st>
    `<st c="8670">ndarray</st>` <st c="8677">，以及</st> `<st c="8715">matplotlib</st>`<st
    c="8725">，一个用于可视化的库。</st> <st c="8757">因此，首先安装这两个</st> <st c="8779">模块：</st>
- en: '[PRE2]'
  id: totrans-45
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: <st c="8822">Then, install the</st> `<st c="8841">pandas</st>` <st c="8847">module:</st>
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="8822">然后，安装</st> `<st c="8841">pandas</st>` <st c="8847">模块：</st>
- en: '[PRE3]'
  id: totrans-47
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: <st c="8874">Since our data will be coming from XLSX sheets, install the</st>
    `<st c="8935">openpyxl</st>` <st c="8943">dependency module of</st> `<st c="8965">pandas</st>`
    <st c="8971">that deals with reading and writing</st> <st c="9008">XLSX documents:</st>
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="8874">由于我们的数据将来自 XLSX 工作表，请安装处理读取和写入</st> `<st c="8935">openpyxl</st>`
    <st c="8943">依赖模块的</st> `<st c="8965">pandas</st>` <st c="8971">模块，该模块处理读取和写入</st>
    `<st c="9008">XLSX 文档：</st>
- en: '[PRE4]'
  id: totrans-49
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: <st c="9044">After installing all the dependency modules, we can start creating
    the</st> `<st c="9116">DataFrame</st>` <st c="9126">object.</st>
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="9044">安装所有依赖模块后，我们可以开始创建</st> `<st c="9116">DataFrame</st>` <st c="9126">对象。</st>
- en: <st c="9133">Utilizing the DataFrame</st>
  id: totrans-51
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: <st c="9133">利用 DataFrame</st>
- en: <st c="9157">To read an</st> <st c="9168">XLSX document, the</st> `<st c="9188">pandas</st>`
    <st c="9194">module</st> <st c="9201">has a</st> `<st c="9208">read_excel()</st>`
    <st c="9220">method with parameters such as</st> `<st c="9252">usecols</st>`<st
    c="9259">, which indicates the columns or range of columns to include,</st> `<st
    c="9321">skiprows</st>`<st c="9329">, which selects the rows to skip starting
    from the column row, and</st> `<st c="9396">sheet_name</st>`<st c="9406">, which
    chooses the sheet to read starting from sheet</st> `<st c="9460">0</st>`<st c="9461">.
    The following from the previous</st> `<st c="9495">show_analysis()</st>` <st c="9510">view
    depicts the data retrieval from sheet</st> `<st c="9554">2</st>` <st c="9555">of
    the workbook, excluding</st> <st c="9583">row</st> `<st c="9587">1</st>`<st c="9588">:</st>
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="9157">要读取一个</st> <st c="9168">XLSX 文档，pandas</st> <st c="9194">模块有一个</st>
    `<st c="9208">read_excel()</st>` <st c="9220">方法，具有</st> `<st c="9252">usecols</st>`<st
    c="9259">等参数，该参数表示要包含的列或列的范围，</st> `<st c="9321">skiprows</st>`<st c="9329">，它从列行开始选择要跳过的行，以及</st>
    `<st c="9396">sheet_name</st>`<st c="9406">，它从工作表</st> `<st c="9460">0</st>`<st
    c="9461">开始选择要读取的工作表。以下是从之前的</st> `<st c="9495">show_analysis()</st>` <st c="9510">视图中的数据检索，包括工作表</st>
    `<st c="9554">2</st>` <st c="9555">，排除</st> `<st c="9583">行</st>` `<st c="9587">1</st>`<st
    c="9588">：</st>
- en: '[PRE5]'
  id: totrans-53
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: <st c="9653">This result will be similar to the following snapshot from a</st>
    <st c="9715">sample</st> `<st c="9722">uploaded_file</st>`<st c="9735">:</st>
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="9653">此结果将与以下从样本</st> <st c="9715">上传文件</st> <st c="9722">的快照相似：</st>
- en: '![Figure 6.1 – A sample XLSX document containing HPI and PDI data](img/B19383_06_001.jpg)'
  id: totrans-55
  prefs: []
  type: TYPE_IMG
  zh: '![图 6.1 – 包含 HPI 和 PDI 数据的样本 XLSX 文档](img/B19383_06_001.jpg)'
- en: <st c="11351">Figure 6.1 – A sample XLSX document containing HPI and PDI data</st>
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="11351">图 6.1 – 包含 HPI 和 PDI 数据的样本 XLSX 文档</st>
- en: '*<st c="11414">Figure 6</st>**<st c="11423">.2</st>* <st c="11425">shows a</st>
    <st c="11433">sample</st> `<st c="11441">DataFrame</st>` <st c="11450">object</st>
    <st c="11457">extracted from an uploaded housing price data set to the</st> `<st
    c="11515">show_analysis()</st>` <st c="11530">view function.</st>'
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: '*<st c="11414">图 6</st>**<st c="11423">.2</st>* <st c="11425">显示了一个</st> <st
    c="11433">样本</st> `<st c="11441">DataFrame</st>` <st c="11450">对象</st>，该对象是从上传的房价数据集中提取到
    `<st c="11515">show_analysis()</st>` <st c="11530">视图函数</st> 的。'
- en: '![Figure 6.2 – A sample DataFrame from an uploaded file](img/B19383_06_002.jpg)'
  id: totrans-58
  prefs: []
  type: TYPE_IMG
  zh: '![图 6.2 – 从上传文件中提取的样本 DataFrame](img/B19383_06_002.jpg)'
- en: <st c="12527">Figure 6.2 – A sample DataFrame from an uploaded file</st>
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="12527">图 6.2 – 从上传文件中提取的样本 DataFrame</st>
- en: <st c="12580">A</st> `<st c="12583">DataFrame</st>` <st c="12592">object has
    easy-to-use properties that can extract a portion of the table, such as</st> `<st
    c="12676">shape</st>`<st c="12681">,</st> `<st c="12683">size</st>`<st c="12687">,</st>
    `<st c="12689">axes</st>`<st c="12693">,</st> `<st c="12695">at</st>`<st c="12697">,</st>
    `<st c="12699">columns</st>`<st c="12706">,</st> `<st c="12708">indexes</st>`<st
    c="12715">,</st> `<st c="12717">ndim</st>`<st c="12721">,</st> `<st c="12723">iloc</st>`<st
    c="12727">, and</st> `<st c="12733">loc</st>`<st c="12736">. If the goal is to
    extract only the columns from Australia to the US, the</st> `<st c="12811">loc</st>`
    <st c="12814">property should indicate the range of columns that</st> `<st c="12866">DataFrame</st>`
    <st c="12875">object will sift its analysis from, as shown in the</st> <st c="12928">following
    snippet:</st>
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="12580">DataFrame</st>对象具有易于使用的属性，可以提取表格的一部分，例如<st c="12583">DataFrame</st>
    <st c="12592">对象有易于使用的属性，可以提取表格的一部分，例如</st> <st c="12676">shape</st> <st c="12681">、</st>
    <st c="12683">size</st> <st c="12687">、</st> <st c="12689">axes</st> <st c="12693">、</st>
    <st c="12695">at</st> <st c="12697">、</st> <st c="12699">columns</st> <st c="12706">、</st>
    <st c="12708">indexes</st> <st c="12715">、</st> <st c="12717">ndim</st> <st c="12721">、</st>
    <st c="12723">iloc</st> <st c="12727">和</st> <st c="12733">loc</st> <st c="12736">。如果目标是仅提取从澳大利亚到美国的列，则</st>
    <st c="12811">loc</st> <st c="12814">属性应指示DataFrame <st c="12866">对象将从中筛选分析列的范围，如下面的代码片段所示：</st>
- en: '[PRE6]'
  id: totrans-61
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: <st c="13010">The</st> `<st c="13015">loc</st>` <st c="13018">property accesses
    the data values using selected column labels or ranges, while its</st> `<st c="13103">iloc</st>`
    <st c="13107">counterpart uses column indices to slice the</st> `<st c="13153">DataFrame</st>`
    <st c="13162">instance, like the</st> `<st c="13182">df_tbl</st>`<st c="13188">.
    Both properties emit mathematical methods, such as</st> `<st c="13241">count()</st>`<st
    c="13248">,</st> `<st c="13250">mean()</st>`<st c="13256">,</st> `<st c="13258">sum()</st>`<st
    c="13263">,</st> `<st c="13265">mode()</st>`<st c="13271">,</st> `<st c="13273">std()</st>`<st
    c="13278">, and</st> `<st c="13284">var()</st>`<st c="13289">. However, the given
    view function utilizes the</st> `<st c="13337">describe()</st>` <st c="13347">method
    to extract the columnar data from</st> `<st c="13389">Australia</st>` <st c="13398">to
    the</st> `<st c="13406">US</st>` <st c="13408">columns on the actual HPI values
    quarterly from 1975 to the current year.</st> <st c="13483">Here is the actual
    output of our view when a valid XLSX document on housing datasets</st> <st c="13568">is
    uploaded:</st>
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="13010">loc <st c="13015">属性通过选择列标签或范围访问数据值，而其iloc <st c="13103">对应属性使用列索引来切片DataFrame
    <st c="13153">实例，如df_tbl <st c="13182">。这两个属性都发出数学方法，如count() <st c="13241">、</st>
    mean() <st c="13250">、</st> sum() <st c="13258">、</st> mode() <st c="13265">、</st>
    std() <st c="13273">和</st> var() <st c="13284">。然而，给定的视图函数利用describe() <st c="13337">方法从1975年到当前年度的实际HPI值季度数据中提取从澳大利亚到美国的列数据。</st>
    <st c="13483">以下是上传有效的住房数据集XLSX文档时我们视图的实际输出：</st>
- en: '![Figure 6.3 – A sample output of the show_analysis() view](img/B19383_06_003.jpg)'
  id: totrans-63
  prefs: []
  type: TYPE_IMG
  zh: '![图6.3 – show_analysis()视图的示例输出](img/B19383_06_003.jpg)'
- en: <st c="15018">Figure 6.3 – A sample output of the show_analysis() view</st>
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="15018">图6.3 – show_analysis()视图的示例输出</st>
- en: <st c="15074">When rendering data values using Flask, the</st> `<st c="15119">DataFrame</st>`
    <st c="15128">object has three utility methods that can provide format-ready results.</st>
    <st c="15201">Here are the</st> <st c="15214">three methods:</st>
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="15074">当使用Flask渲染数据值时，DataFrame <st c="15119">对象有三个实用方法，可以提供格式化后的结果。</st>
    <st c="15201">以下是这三个方法：</st>
- en: '`<st c="15228">to_html()</st>`<st c="15238">: This generates an HTML table
    format with</st> <st c="15282">the datasets.</st>'
  id: totrans-66
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`<st c="15228">to_html()</st>` <st c="15238">：这生成一个带有数据集的HTML表格格式。</st>'
- en: '`<st c="15295">to_latex()</st>`<st c="15306">: This creates a LaTeX-formatted
    result with the data ready for</st> <st c="15371">PDF transformation.</st>'
  id: totrans-67
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`<st c="15295">to_latex()</st>` <st c="15306">：这创建了一个LaTeX格式的结果，数据已准备好进行PDF转换。</st>'
- en: '`<st c="15390">to_markdown()</st>`<st c="15404">: This generates a Markdown-ready
    template with the</st> <st c="15457">data values.</st>'
  id: totrans-68
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`<st c="15390">to_markdown()</st>` <st c="15404">：这生成一个带有数据值的Markdown模板。</st>'
- en: <st c="15469">In the case</st> <st c="15481">of</st> `<st c="15485">show_analysis()</st>`<st
    c="15500">, it</st> <st c="15505">uses</st> `<st c="15510">to_html()</st>` <st
    c="15519">to render all the captured datasets as an HTML table through</st> `<st
    c="15581">to_html()</st>`<st c="15590">. However, the rendition will only work
    with the</st> `<st c="15639">safe</st>` <st c="15643">Jinja2 filter because Jinja2
    will not automatically HTML-escape all the characters provided by</st> `<st c="15739">to_html()</st>`
    <st c="15748">for security purposes.</st> *<st c="15772">Figure 6</st>**<st c="15780">.3</st>*
    <st c="15782">shows a raw result of rendering tabular values from the</st> `<st
    c="15839">DataFrame</st>` <st c="15848">instance containing the values using its</st>
    `<st c="15890">to_html()</st>` <st c="15899">method.</st>
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="15469">在</st> <st c="15481">show_analysis()</st><st c="15500">的情况下，它使用</st>
    `<st c="15510">to_html()</st>` <st c="15519">将所有捕获的数据集通过</st> `<st c="15581">to_html()</st>`<st
    c="15590">渲染为HTML表格。然而，这种渲染方式仅适用于</st> `<st c="15639">safe</st>` <st c="15643">Jinja2过滤器，因为出于安全目的，Jinja2不会自动对</st>
    `<st c="15739">to_html()</st>` <st c="15748">提供的所有字符进行HTML转义。</st> *<st c="15772">图6</st>**<st
    c="15780">.3</st>* <st c="15782">显示了从包含值的</st> `<st c="15839">DataFrame</st>`
    <st c="15848">实例使用其</st> `<st c="15890">to_html()</st>` <st c="15899">方法渲染的表格值的原始结果。</st>
- en: <st c="15907">Rendering graphs and charts using matplotlib</st>
  id: totrans-70
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: <st c="15907">使用matplotlib绘制图表和图表</st>
- en: <st c="15952">It is easy to plot</st> <st c="15971">data</st> <st c="15977">when</st>
    <st c="15982">contained</st> <st c="15992">in a</st> `<st c="15997">DataFrame</st>`
    <st c="16006">object’s two-dimension data structure.</st> <st c="16046">The</st>
    `<st c="16050">matplotlib</st>` <st c="16060">has built-in support for rendering
    the tabular values as a</st> *<st c="16120">line</st>*<st c="16124">,</st> *<st
    c="16126">bar</st>*<st c="16129">,</st> *<st c="16131">pie</st>*<st c="16134">,
    or other graph or chart type.</st> <st c="16166">Since our application is a web
    app, our view functions must render these visuals as images, unlike in a REST
    application, which returns JSON resources for</st> <st c="16321">frontend frameworks.</st>
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="15952">当数据包含在</st> `<st c="15997">DataFrame</st>` <st c="16006">对象的两维数据结构中时，绘制数据很容易。</st>
    <st c="16046">matplotlib</st> <st c="16060">内置支持将表格值渲染为</st> *<st c="16120">线</st>*<st
    c="16124">、*<st c="16126">条形图</st>*<st c="16129">、*<st c="16131">饼图</st>*<st c="16134">或其他图形或图表类型。</st>
    <st c="16166">由于我们的应用程序是一个Web应用程序，我们的视图函数必须将这些视觉元素渲染为图像，这与返回JSON资源的REST应用程序不同，后者为前端框架提供资源。</st>
- en: <st c="16341">Now, the first step is to create a</st> `<st c="16377">Figure</st>`
    <st c="16383">object.</st> <st c="16392">A</st> `<st c="16394">Figure</st>` <st
    c="16400">object serves as a canvas of a plot or subplots depending on the visualization
    approach.</st> <st c="16490">It is a plain blank object created by the</st> `<st
    c="16532">figure()</st>` <st c="16540">method of the</st> `<st c="16555">matplotlib</st>`
    <st c="16565">module or the</st> `<st c="16580">Figure</st>` <st c="16586">helper
    class of the</st> `<st c="16607">matplotlib.figure</st>` <st c="16624">module.</st>
    <st c="16633">It has the following essential properties that need configuration
    before finalizing</st> <st c="16717">the plot:</st>
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="16341">现在，第一步是创建一个</st> `<st c="16377">Figure</st>` <st c="16383">对象。</st>
    <st c="16392">一个</st> `<st c="16394">Figure</st>` <st c="16400">对象根据可视化方法作为图表或子图的画布。</st>
    <st c="16490">它是由</st> `<st c="16532">figure()</st>` <st c="16540">方法创建的一个普通空白对象，该方法属于</st>
    `<st c="16555">matplotlib</st>` <st c="16565">模块或</st> `<st c="16580">Figure</st>`
    <st c="16586">辅助类，该类属于</st> `<st c="16607">matplotlib.figure</st>` <st c="16624">模块。</st>
    <st c="16633">在最终确定绘图之前，它具有以下需要配置的基本属性：</st>
- en: '`<st c="16726">figsize</st>`<st c="16734">: This measures the</st> `<st c="16755">x-</st>`<st
    c="16757">axis and</st> `<st c="16767">y</st>`<st c="16768">-axis of the</st>
    <st c="16781">canvas’ dimensions.</st>'
  id: totrans-73
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`<st c="16726">figsize</st>`<st c="16734">: 这用于测量画布尺寸的x轴和y轴。</st>'
- en: '`<st c="16800">dpi</st>`<st c="16804">: This gauges the dot pixel per inch
    for</st> <st c="16846">the plot.</st>'
  id: totrans-74
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`<st c="16800">dpi</st>`<st c="16804">: 这用于测量绘图每英寸的点数。</st>'
- en: '`<st c="16855">linewidth</st>`<st c="16865">: This measures the borderline
    of</st> <st c="16900">the canvas.</st>'
  id: totrans-75
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`<st c="16855">linewidth</st>`<st c="16865">: 这用于测量画布的边框线。</st>'
- en: '`<st c="16911">edgecolor</st>`<st c="16921">: This applies the color of the</st>
    <st c="16954">canvas’ borderline.</st>'
  id: totrans-76
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`<st c="16911">edgecolor</st>`<st c="16921">: 这应用于画布边框的颜色。</st>'
- en: '`<st c="16973">facecolor</st>`<st c="16983">: This applies the indicated color
    to the border area between the canvas borderline and the axes</st> <st c="17081">plot
    borderline.</st>'
  id: totrans-77
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`<st c="16973">facecolor</st>`<st c="16983">: 这将应用指定的颜色到画布边框和坐标轴之间的边界区域</st>
    <st c="17081">绘图边框。</st>'
- en: <st c="17097">The following view implementation uploads a file, creates a</st>
    `<st c="17158">DataFrame</st>` <st c="17167">object from the uploaded XLSX document,
    and renders a line graph from the</st> <st c="17242">tabular values:</st>
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="17097">以下视图实现上传文件，从上传的 XLSX 文档创建一个</st> `<st c="17158">数据框</st>` <st
    c="17167">对象，并从表格值渲染线图：</st>
- en: '[PRE7]'
  id: totrans-79
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: df_rhpi = read_excel(uploaded_file, sheet_name=2, <st c="19978">plot()</st>’s
    x-values or <st c="20000">scalex</st> will have <st c="20017">ndarray</st> from
    <st c="20030">0</st> to the maximum number of captured HPI values, and its y-values
    or <st c="20098">scaley</st> will have the HPI values of Belgium. Its color parameter
    is set to <st c="20172">#fc0366</st> to change the default blue color of the line
    graph. Aside from <st c="20243">plot()</st>, <st c="20251">Axes</st> has <st c="20260">set_title()</st>
    to add a header title for the image, <st c="20309">set_xlabel()</st> to add the
    description of the x-values, <st c="20362">set_ylabel()</st> for the y-values
    description, <st c="20405">set_facecolor()</st> to change the font color of the
    text, and <st c="20463">tick_params()</st> to update the color of the x and y
    tick values. <st c="20525">Axes</st> also has properties such as <st c="20558">xaxis</st>
    and <st c="20568">yaxis</st> to apply a new color to the x- and y-axis descriptions
    and spines to adjust the <st c="20654">linewidth</st> and <st c="20668">edgecolor</st>
    of the plot.
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: df_rhpi = read_excel(uploaded_file, sheet_name=2, <st c="19978">plot()</st>的
    x-值或 <st c="20000">scalex</st> 将有从 <st c="20030">0</st> 到捕获的 HPI 值最大数的 ndarray，其
    y-值或 <st c="20098">scaley</st> 将有比利时的 HPI 值。其颜色参数设置为 <st c="20172">#fc0366</st>
    以改变线图的默认蓝色。除了 <st c="20243">plot()</st>，<st c="20251">坐标轴</st> 还具有 <st c="20260">set_title()</st>
    以添加图像的标题，<st c="20309">set_xlabel()</st> 以添加 x-值的描述，<st c="20362">set_ylabel()</st>
    以添加 y-值的描述，<st c="20405">set_facecolor()</st> 以改变文本的字体颜色，以及 <st c="20463">tick_params()</st>
    以更新 x 和 y 刻度值的颜色。 <st c="20525">坐标轴</st> 还具有如 <st c="20558">xaxis</st> 和 <st c="20568">yaxis</st>
    之类的属性，以将新的颜色应用到 x 和 y 轴描述和脊上，并调整绘图 <st c="20654">linewidth</st> 和 <st c="20668">edgecolor</st>。</st>
- en: <st c="20690">After finalizing the plot details, create a</st> `<st c="20735">BytesIO</st>`
    <st c="20742">buffer object to contain the</st> `<st c="20772">Figure</st>` <st
    c="20778">instance.</st> <st c="20789">Saving the</st> `<st c="20800">Figure</st>`
    <st c="20806">in</st> `<st c="20810">BytesIO</st>` <st c="20817">is necessary
    for decoding the plot as an inline image.</st> <st c="20873">The view must pass
    the</st> `<st c="20896">base64</st>`<st c="20902">-encoded image to its Jinja2
    template for rendition.</st> <st c="20956">Rendering an inline image through the</st>
    `<st c="20994"><url></st>` <st c="20999">tag is a fast way of displaying images.</st>
    *<st c="21040">Figure 6</st>**<st c="21048">.5</st>* <st c="21050">shows the updated
    line graph for a sample actual HPI dataset</st> <st c="21112">for Belgium.</st>
  id: totrans-81
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: <st c="20690">在完成绘图细节后，创建一个</st> `<st c="20735">BytesIO</st>` <st c="20742">缓冲对象来包含</st>
    `<st c="20772">图</st>` <st c="20778">实例。</st> <st c="20789">将</st> `<st c="20800">图</st>`
    <st c="20806">保存到</st> `<st c="20810">BytesIO</st>` <st c="20817">是解码为内联图像所必需的。</st>
    <st c="20873">视图必须将</st> `<st c="20896">base64</st>`<st c="20902">-编码的图像传递给其 Jinja2
    模板以进行渲染。</st> <st c="20956">通过</st> `<st c="20994"><url></st>` <st c="20999">标签渲染内联图像是一种快速显示图像的方法。</st>
    *<st c="21040">图 6</st>**<st c="21048">.5</st>* <st c="21050">显示了比利时样本实际 HPI 数据集的更新线图。</st>
    <st c="21112">。</st>
- en: '![Figure 6.5 – A final line graph for a sample actual HPI data set for Belgium](img/B19383_06_005.jpg)'
  id: totrans-82
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_IMG
  zh: '![图 6.5 – 比利时样本实际 HPI 数据集的最终线图](img/B19383_06_005.jpg)'
- en: <st c="21401">Figure 6.5 – A final line graph for a sample actual HPI data set
    for Belgium</st>
  id: totrans-83
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: <st c="21401">图 6.5 – 比利时样本实际 HPI 数据集的最终线图</st>
- en: <st c="21477">How about if</st> <st c="21491">we</st> <st c="21494">have</st>
    <st c="21499">multiple</st> <st c="21508">graphs in one</st> `<st c="21522">Axes</st>`
    <st c="21526">plot?</st>
  id: totrans-84
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: <st c="21477">如果我们</st> <st c="21491">有一个</st> <st c="21494">多个</st> <st c="21499">图表</st>
    <st c="21508">在一个</st> `<st c="21522">坐标轴</st>` <st c="21526">绘图</st>中呢？</st>
- en: <st c="21532">Rendering multiple line graphs</st>
  id: totrans-85
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: <st c="21532">渲染多个线图</st>
- en: <st c="21563">Depending on the</st> <st c="21580">goal of</st> <st c="21589">the
    visualization, the</st> `<st c="21612">pandas</st>` <st c="21618">module with</st>
    `<st c="21631">matplotlib</st>` <st c="21641">can handle complex graphical renditions
    of</st> `<st c="21685">DataFrame</st>` <st c="21694">object’s data values.</st>
    <st c="21717">The following view function creates two line graphs that can compare
    Belgium’s actual and nominal HPI values based on a</st> <st c="21837">sample dataset:</st>
  id: totrans-86
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: <st c="21563">根据</st> <st c="21580">可视化的</st> <st c="21589">目标，</st> `<st c="21612">pandas</st>`
    <st c="21618">模块与</st> `<st c="21631">matplotlib</st>` <st c="21641">可以处理 DataFrame
    对象数据值的复杂图形渲染。</st> <st c="21717">以下视图函数创建两个线形图，可以比较基于样本数据集的比利时实际和名义 HPI 值：</st>
- en: '[PRE8]'
  id: totrans-87
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: <st c="22894">Compared to the previous</st> `<st c="22920">upload_xlsx_hpi_belgium_plot()</st>`
    <st c="22950">view,</st> `<st c="22957">upload_xlsx_belgium_hpi_rhpi_plot()</st>`
    <st c="22992">utilizes two sheets from the workbook of an uploaded file, namely</st>
    `<st c="23059">sheet[1]</st>` <st c="23067">for the nominal HPI and</st> `<st
    c="23092">sheet[2]</st>` <st c="23100">for the actual HPI values of Belgium.</st>
    <st c="23139">It derives separate</st> `<st c="23159">DataFrame</st>` <st c="23168">object’s
    tabular values from each worksheet and plots a Line2D graph to compare the trend
    between the two datasets.</st> <st c="23285">Similar to the previous vector transformation
    in this chapter, this view still uses</st> `<st c="23369">numpy</st>` <st c="23374">to
    flatten the extracted vertical vector from the DataFrame’s</st> `<st c="23437">to_numpy()</st>`
    <st c="23447">utility method.</st> <st c="23464">By the way, the view function
    only uses one</st> `<st c="23508">Axes</st>` <st c="23512">plot for</st> <st c="23522">both
    graphs.</st>
  id: totrans-88
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: <st c="22894">与之前的</st> `<st c="22920">upload_xlsx_hpi_belgium_plot()</st>`
    <st c="22950">视图相比，</st> `<st c="22957">upload_xlsx_belgium_hpi_rhpi_plot()</st>`
    <st c="22992">利用上传文件的工作簿中的两个工作表，即</st> `<st c="23059">sheet[1]</st>` <st c="23067">用于名义
    HPI 和</st> `<st c="23092">sheet[2]</st>` <st c="23100">用于比利时实际 HPI 值。</st> <st
    c="23139">它从每个工作表导出单独的</st> `<st c="23159">DataFrame</st>` <st c="23168">对象的表格值，并绘制一个
    Line2D 图来比较两个数据集之间的趋势。</st> <st c="23285">与本章中之前的向量变换类似，这个视图仍然使用</st> `<st c="23369">numpy</st>`
    <st c="23374">来展平从 DataFrame 的</st> `<st c="23437">to_numpy()</st>` <st c="23447">实用方法中提取的垂直向量。</st>
    <st c="23464">顺便说一下，视图函数只为两个图表使用一个</st> `<st c="23508">Axes</st>` <st c="23512">绘图。</st>
- en: <st c="23534">Moreover, the view also showcases the inclusion of a</st> `<st
    c="23767">Axes</st>`<st c="23771">, but this view captures the Line2D objects
    from the</st> `<st c="23824">plot()</st>` <st c="23830">method calls and maps
    each plot with a string label using the</st> `<st c="23893">Axes</st>`<st c="23897">’</st>
    `<st c="23900">legend()</st>` <st c="23908">method.</st> *<st c="23917">Figure
    6</st>**<st c="23925">.6</st>* <st c="23927">shows the result of running</st>
    `<st c="23956">upload_xlsx_belgium_hpi_rhpi_plot()</st>` <st c="23991">with an
    uploaded</st> <st c="24009">XLSX document.</st>
  id: totrans-89
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: <st c="23534">此外，视图还展示了包含一个</st> `<st c="23767">Axes</st>`<st c="23771">，但这个视图捕获了从</st>
    `<st c="23824">plot()</st>` <st c="23830">方法调用中的 Line2D 对象，并使用</st> `<st c="23893">Axes</st>`<st
    c="23897">的</st> `<st c="23900">legend()</st>` <st c="23908">方法将每个图表映射到一个字符串标签。</st>
    *<st c="23917">图 6</st>**<st c="23925">.6</st>* <st c="23927">显示了运行</st> `<st
    c="23956">upload_xlsx_belgium_hpi_rhpi_plot()</st>` <st c="23991">并上传一个</st> <st
    c="24009">XLSX 文档的结果。</st>
- en: '![Figure 6.6 – Two line graphs in one Axes plot](img/B19383_06_006.jpg)'
  id: totrans-90
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_IMG
  zh: '![图 6.6 – 一个 Axes 图中两个线形图](img/B19383_06_006.jpg)'
- en: <st c="24301">Figure 6.6 – Two line graphs in one Axes plot</st>
  id: totrans-91
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: <st c="24301">图 6.6 – 一个 Axes 图中两个线形图</st>
- en: <st c="24346">Up next, we will</st> <st c="24364">see how</st> <st c="24372">to
    plot a pie chart</st> <st c="24392">with Flask.</st>
  id: totrans-92
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: 下一个，我们将<st c="24346">了解如何</st> <st c="24364">使用 Flask 绘制饼图</st> <st c="24392">。</st>
- en: <st c="24403">Rendering a pie chart from a CSV file</st>
  id: totrans-93
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: <st c="24403">从 CSV 文件渲染饼图</st>
- en: <st c="24441">The</st> `<st c="24446">pandas</st>` <st c="24452">module</st>
    <st c="24460">can also</st> <st c="24468">read data from CSV files</st> <st c="24493">through
    its</st> `<st c="24506">read_csv()</st>` <st c="24516">method.</st> <st c="24525">Unlike
    in</st> `<st c="24535">read_excel()</st>`<st c="24547">, the</st> `<st c="24553">pandas</st>`
    <st c="24559">module does not need any dependency to read valid CSV files.</st>
    <st c="24621">The following view uses</st> `<st c="24645">read_csv()</st>` <st
    c="24655">to create a DataFrame of values for plotting a</st> <st c="24703">pie
    chart:</st>
  id: totrans-94
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: <st c="24441">The</st> `<st c="24446">pandas</st>` <st c="24452">模块</st> <st
    c="24460">也可以通过其</st> `<st c="24506">read_csv()</st>` <st c="24516">方法</st> <st
    c="24525">从CSV文件中读取数据。</st> <st c="24525">与</st> `<st c="24535">read_excel()</st>`<st
    c="24547">不同，</st> `<st c="24553">pandas</st>` <st c="24559">模块读取有效的CSV文件不需要任何依赖。</st>
    <st c="24621">以下视图使用</st> `<st c="24645">read_csv()</st>` <st c="24655">创建用于绘制饼图的值的DataFrame：</st>
- en: '[PRE9]'
  id: totrans-95
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: <st c="25469">The</st> `<st c="25474">pandas</st>` <st c="25480">module</st>
    <st c="25488">can</st> <st c="25492">also read data from CSV</st> <st c="25516">files
    through its</st> `<st c="25534">read_csv()</st>` <st c="25544">method.</st> <st
    c="25553">Unlike in</st> `<st c="25563">read_excel()</st>`<st c="25575">, the</st>
    `<st c="25581">pandas</st>` <st c="25587">module does not need any dependency
    to read valid</st> <st c="25638">CSV files.</st>
  id: totrans-96
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: <st c="25469">The</st> `<st c="25474">pandas</st>` <st c="25480">模块</st> <st
    c="25488">也可以通过其</st> `<st c="25534">read_csv()</st>` <st c="25544">方法</st> <st
    c="25553">从CSV文件中读取数据。</st> <st c="25553">与</st> `<st c="25563">read_excel()</st>`<st
    c="25575">不同，</st> `<st c="25581">pandas</st>` <st c="25587">模块读取有效的CSV文件不需要任何依赖。</st>
- en: <st c="25648">On the other hand, the</st> `<st c="25672">Axes</st>`<st c="25676">’</st>
    `<st c="25679">pie()</st>` <st c="25684">method has several parameters to consider
    before reaching the appropriate pie diagram for the data values.</st> <st c="25792">Here
    are some of the parameters used by the</st> `<st c="25836">upload_csv_pie()</st>`
    <st c="25852">view function:</st>
  id: totrans-97
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: <st c="25648">另一方面，</st> `<st c="25672">Axes</st>`<st c="25676">’</st> `<st
    c="25679">pie()</st>` <st c="25684">方法在达到适合数据值的适当饼图之前需要考虑几个参数。</st> <st c="25792">以下是</st>
    `<st c="25836">upload_csv_pie()</st>` <st c="25852">视图函数使用的部分参数：</st>
- en: '`<st c="25867">explode</st>`<st c="25875">: This provides a list of fraction
    digits that indicate spaces around the wedges that will make them</st> <st c="25977">stand
    out.</st>'
  id: totrans-98
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`<st c="25867">explode</st>`<st c="25875">: 这提供了一个分数数字列表，指示围绕扇区的空间，使它们突出。</st>'
- en: '`<st c="25987">colors</st>`<st c="25994">: This provides a list of</st> `<st
    c="26021">matplotlib</st>`<st c="26031">’s built-in named colors or hexadecimal
    formatted color code set to each of</st> <st c="26108">the widgets.</st>'
  id: totrans-99
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`<st c="25987">colors</st>`<st c="25994">: 这提供了一个颜色列表，可以是</st> `<st c="26021">matplotlib</st>`<st
    c="26031">的内置命名颜色或设置为每个小部件的十六进制格式化颜色代码。</st>'
- en: '`<st c="26120">labels</st>`<st c="26127">: This provides a list of string values
    assigned to</st> <st c="26180">each widget.</st>'
  id: totrans-100
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`<st c="26120">labels</st>`<st c="26127">: 这提供了分配给每个小部件的字符串值列表。</st>'
- en: '`<st c="26192">autopct</st>`<st c="26200">: This provides a string-formatted
    percentage value of</st> <st c="26256">each widget.</st>'
  id: totrans-101
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`<st c="26192">autopct</st>`<st c="26200">: 这提供了每个小部件的字符串格式化百分比值。</st>'
- en: '`<st c="26268">shadow</st>`<st c="26275">: This allows adding a shadow around
    the</st> <st c="26317">pie chart.</st>'
  id: totrans-102
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`<st c="26268">shadow</st>`<st c="26275">: 这允许在饼图周围添加阴影。</st>'
- en: '`<st c="26327">startangle</st>`<st c="26338">: This provides an angle of rotation
    for the pie chart to start with its</st> <st c="26412">first wedge.</st>'
  id: totrans-103
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`<st c="26327">startangle</st>`<st c="26338">: 这提供了一个旋转角度，用于饼图从其第一个扇区开始。</st>'
- en: <st c="26424">The goal of the</st> <st c="26440">given</st> `<st c="26447">upload_csv_pie()</st>`
    <st c="26463">is to</st> <st c="26469">generate</st> <st c="26478">a pie chart
    based on the number of projected house prices (</st>`<st c="26538">Price</st>`<st
    c="26544">) per furnishing status (</st>`<st c="26570">FurnishingStatus</st>`<st
    c="26587">), namely the</st> `<st c="26602">Furnished</st>`<st c="26611">,</st>
    `<st c="26613">Semi-furnished</st>`<st c="26627">, and</st> `<st c="26633">Fully-furnished</st>`
    <st c="26648">houses.</st> <st c="26657">The</st> `<st c="26661">groupby()</st>`
    <st c="26670">method of the</st> `<st c="26685">df_csv</st>` <st c="26691">DataFrame
    extracts the needed data values for the</st> `<st c="26742">pie()</st>` <st c="26747">method.</st>
    <st c="26756">Now, running this view function will render the</st> <st c="26804">following
    chart:</st>
  id: totrans-104
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: 给定的`<st c="26447">upload_csv_pie()</st>` `<st c="26463">is to</st>` `<st c="26469">generate</st>`
    `<st c="26478">a pie chart based on the number of projected house prices (</st>`
    `<st c="26538">Price</st>` `<st c="26544">) per furnishing status (</st>` `<st
    c="26570">FurnishingStatus</st>` `<st c="26587">), namely the</st>` `<st c="26602">Furnished</st>`
    `<st c="26611">,</st>` `<st c="26613">Semi-furnished</st>` `<st c="26627">, and</st>`
    `<st c="26633">Fully-furnished</st>` `<st c="26648">houses.</st>` `<st c="26657">The</st>`
    `<st c="26661">groupby()</st>` `<st c="26670">method of the</st>` `<st c="26685">df_csv</st>`
    `<st c="26691">DataFrame extracts the needed data values for the</st>` `<st c="26742">pie()</st>`
    `<st c="26747">method.</st>` `<st c="26756">Now, running this view function will
    render the</st>` `<st c="26804">following chart:</st>`
- en: '![Figure 6.7 – Pie chart on Furnishing Status preference](img/B19383_06_007.jpg)'
  id: totrans-105
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_IMG
  zh: '![Figure 6.7 – 饰面状态偏好饼图](img/B19383_06_007.jpg)'
- en: <st c="26951">Figure 6.7 – Pie chart on Furnishing Status preference</st>
  id: totrans-106
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: '`<st c="26951">Figure 6.7 – 饰面状态偏好饼图</st>`'
- en: '<st c="27005">If saving the pie chart figure produces the following warning
    message,</st> `<st c="27077">UserWarning: Starting a Matplotlib GUI outside of
    the main thread will likely fail.</st>`<st c="27160">, add</st> `<st c="27166">matplotlib.use(''agg'')</st>`
    <st c="27187">anywhere before creating the</st> `<st c="27217">Figure</st>` <st
    c="27223">instance</st> <st c="27233">to</st> <st c="27235">enable</st> <st c="27242">the
    non-interactive backend mode for writing files outside the</st> <st c="27306">main
    thread.</st>'
  id: totrans-107
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: '如果保存饼图图形时产生以下警告信息，`<st c="27077">UserWarning: Starting a Matplotlib GUI outside
    of the main thread will likely fail.</st>`，则添加`<st c="27166">matplotlib.use(''agg'')</st>`在任何创建`<st
    c="27217">Figure</st>` `<st c="27223">instance</st>` `<st c="27233">to</st>` `<st
    c="27235">enable</st>` `<st c="27242">the non-interactive backend mode for writing
    files outside the</st>` `<st c="27306">main thread.</st>`之前，以启用非交互式后端模式，以便在主线程外写入文件。'
- en: <st c="27318">How about if we have multiple</st> `<st c="27349">Axes</st>` <st
    c="27353">plots in</st> <st c="27363">one</st> `<st c="27367">Figure</st>`<st
    c="27373">?</st>
  id: totrans-108
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: 如果我们在一个`<st c="27367">Figure</st>` `<st c="27373">>`中有多多个`<st c="27349">Axes</st>`
    `<st c="27353">plots`呢？
- en: <st c="27374">Rendering multiple Axes plots</st>
  id: totrans-109
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: '`<st c="27374">Rendering multiple Axes plots</st>`'
- en: <st c="27403">A Figure can</st> <st c="27416">contain</st> <st c="27425">more
    than one plot of different graphs and charts.</st> <st c="27476">Scientific applications
    mostly have GUIs that render several charts of varying data calibration, transformation,
    and analytics.</st> <st c="27604">The following view function uploads an XLSX
    document and creates four plots on a</st> `<st c="27685">Figure</st>` <st c="27691">to
    create different graphs of the DataFrame data values extracted from</st> <st c="27763">the
    document:</st>
  id: totrans-110
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: '`<st c="27403">一个Figure可以</st>` `<st c="27416">包含</st>` `<st c="27425">多个不同图表和图形的plot。</st>`
    `<st c="27476">科学应用通常具有GUI，可以渲染不同数据校准、转换和分析的多个图表。</st>` `<st c="27604">以下视图函数上传一个XLSX文档，并在一个</st>`
    `<st c="27685">Figure</st>` `<st c="27691">>`上创建四个plot，以创建从文档中提取的DataFrame数据值的不同的图形：</st>`'
- en: '[PRE10]'
  id: totrans-111
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: <st c="28354">axes1.plot(df_xlsx.index.values,</st><st c="28387">df_xlsx['Australia'],
    'green',</st><st c="28418">df_xlsx.index.values,</st><st c="28440">df_xlsx['Belgium'],
    'red',)</st> axes1.set_xlabel('Quarterly Duration')
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: '`<st c="28354">axes1.plot(df_xlsx.index.values,</st><st c="28387">df_xlsx[''Australia''],
    ''green'',</st><st c="28418">df_xlsx.index.values,</st><st c="28440">df_xlsx[''Belgium''],
    ''red'',)</st>` `axes1.set_xlabel(''季度持续时间'')`'
- en: axes1.set_ylabel('House Price Index')
  id: totrans-113
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: '`axes1.set_ylabel(''House Price Index'')`'
- en: axes1.set_title('RHPI between Australia ………')
  id: totrans-114
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: '`axes1.set_title(''澳大利亚……之间的RHPI'')`'
- en: '[PRE11]'
  id: totrans-115
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'index = arange(df_xlsx.loc[: , ''Australia'':''US''].shape[1]) <st c="28805">axes2.bar(index,
    df_xlsx.loc[: ,</st> <st c="28837">''Australia'':''US''].mean(),</st><st c="28863">color=(0.1,
    0.1, 0.1, 0.1), edgecolor=''blue'')</st> axes2.set_xlabel(''Country ID'')'
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: '`index = arange(df_xlsx.loc[: , ''Australia'':''US''].shape[1])` `<st c="28805">axes2.bar(index,
    df_xlsx.loc[: ,</st> `<st c="28837">''Australia'':''US''].mean(),</st><st c="28863">color=(0.1,
    0.1, 0.1, 0.1), edgecolor=''blue'')</st>` `axes2.set_xlabel(''国家ID'')`'
- en: axes2.set_ylabel('Mean HPI')
  id: totrans-117
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: '`axes2.set_ylabel(''Mean HPI'')`'
- en: axes2.set_xticks(index)
  id: totrans-118
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: '`axes2.set_xticks(index)`'
- en: axes2.set_title('Mean RHPI among countries')
  id: totrans-119
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: '`axes2.set_title(''Mean RHPI among countries'')`'
- en: '[PRE12]'
  id: totrans-120
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: '<st c="29182">axes3.plot(df_xlsx.loc[: , ''Australia'':''US''])</st> axes3.set_xlabel(''Quarterly
    Duration'')'
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: '<st c="29182">axes3.plot(df_xlsx.loc[: , ''Australia'':''US''])</st> axes3.set_xlabel(''季度持续时间'')'
- en: axes3.set_ylabel('House Price Index')
  id: totrans-122
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: axes3.set_ylabel('房价指数')
- en: axes3.set_title('RHPI trend among countries')
  id: totrans-123
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: axes3.set_title('各国RHPI趋势')
- en: '[PRE13]'
  id: totrans-124
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: width = 0.3 <st c="29494">axes4.bar(df_xlsx.loc[0:3,</st> <st c="29520">'Japan'].index.values-width,
    df_xlsx.loc[0:3,</st> <st c="29566">'Japan'], width=width, color='#d9182b',</st>
    <st c="29606">label="JP")</st><st c="29618">axes4.bar(df_xlsx.loc[0:3, 'S.</st>
    <st c="29649">Korea'].index.values, df_xlsx.loc[0:3, 'S.</st> <st c="29692">Korea'],
    width=width, color='#f09ec1',</st> <st c="29731">label="SK")</st><st c="29743">axes4.bar(df_xlsx.loc[0:3,
    'New</st> <st c="29775">Zealand'].index.values+width, df_xlsx.loc[0:3,</st> <st
    c="29822">'New Zealand'], width=width, color='#000',</st> <st c="29865">label="NZ")</st>
    axes4.set_xlabel('Quarterly Duration')
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: width = 0.3 <st c="29494">axes4.bar(df_xlsx.loc[0:3,</st> <st c="29520">'Japan'].index.values-width,
    df_xlsx.loc[0:3,</st> <st c="29566">'Japan'], width=width, color='#d9182b',</st>
    <st c="29606">label="JP")</st><st c="29618">axes4.bar(df_xlsx.loc[0:3, 'S.</st>
    <st c="29649">Korea'].index.values, df_xlsx.loc[0:3, 'S.</st> <st c="29692">Korea'],
    width=width, color='#f09ec1',</st> <st c="29731">label="SK")</st><st c="29743">axes4.bar(df_xlsx.loc[0:3,
    'New</st> <st c="29775">Zealand'].index.values+width, df_xlsx.loc[0:3,</st> <st
    c="29822">'New Zealand'], width=width, color='#000',</st> <st c="29865">label="NZ")</st>
    axes4.set_xlabel('季度持续时间')
- en: … … … … … …
  id: totrans-126
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: … … … … … …
- en: axes4.legend()
  id: totrans-127
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: axes4.legend()
- en: '[PRE14]'
  id: totrans-128
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: pip install sympy
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: pip install sympy
- en: '[PRE15]'
  id: totrans-130
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: pip install mpmath
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: pip install mpmath
- en: '[PRE16]'
  id: totrans-132
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: from modules.equations import eqn_bp
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: from modules.equations import eqn_bp
- en: from flask import render_template, request <st c="32238">from sympy import sympify</st>
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: from flask import render_template, request <st c="32238">from sympy import sympify</st>
- en: <st c="32263">import gladiator as gl</st> @eqn_bp.route('/eqn/simple/bivar',
    methods = ['GET', 'POST'])
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="32263">import gladiator as gl</st> @eqn_bp.route('/eqn/simple/bivar',
    methods = ['GET', 'POST'])
- en: 'async def solve_multivariate_linear():'
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 'async def solve_multivariate_linear():'
- en: 'if request.method == ''GET'':'
  id: totrans-137
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 'if request.method == ''GET'':'
- en: soln = None
  id: totrans-138
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: soln = None
- en: 'else: <st c="32434">field_validations</st> = ('
  id: totrans-139
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 'else: <st c="32434">field_validations</st> = ('
- en: ('lineqn', gl.required, gl.type_(str),    gl.regex_('[+\-]?(([0-9]+\.[0-9]+)|([0-9]+\.?)|(\.?[0-9]+))[+\-/*][xy]([+\-/*](([0-9]+\.[0-9]+)|([0-9]+\.?)|(\.?[0-9]+))[+\-/*][xy])*([+\-/*](([0-9]+\.[0-9]+)|([0-9]+\.?)|(\.?[0-9]+)))*')),
  id: totrans-140
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: ('lineqn', gl.required, gl.type_(str),    gl.regex_('[+\-]?(([0-9]+\.[0-9]+)|([0-9]+\.?)|(\.?[0-9]+))[+\-/*][xy]([+\-/*](([0-9]+\.[0-9]+)|([0-9]+\.?)|(\.?[0-9]+))[+\-/*][xy])*([+\-/*](([0-9]+\.[0-9]+)|([0-9]+\.?)|(\.?[0-9]+)))*')),
- en: ('xvar', gl.required, gl.type_(str), gl.regex_('[0-9]+')),
  id: totrans-141
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: ('xvar', gl.required, gl.type_(str), gl.regex_('[0-9]+')),
- en: ('yvar', gl.required, gl.type_(str), gl.regex_('[0-9]+'))
  id: totrans-142
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: ('yvar', gl.required, gl.type_(str), gl.regex_('[0-9]+'))
- en: )
  id: totrans-143
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: )
- en: 'form_data = request.form.to_dict() <st c="32839">result = gl.validate(field_validations,
    form_data )</st> if bool(result): <st c="32908">xval = float(form_data[''xvar''])</st><st
    c="32939">yval = float(form_data[''yvar''])</st><st c="32971">eqn = sympify(form_data[''lineqn''],
    {''x'': xval,</st> <st c="33018">''y'': yval})</st><st c="33030">soln = eqn.evalf()</st>
    else:'
  id: totrans-144
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: 'form_data = request.form.to_dict() <st c="32839">result = gl.validate(field_validations,
    form_data )</st> if bool(result): <st c="32908">xval = float(form_data[''xvar''])</st><st
    c="32939">yval = float(form_data[''yvar''])</st><st c="32971">eqn = sympify(form_data[''lineqn''],
    {''x'': xval,</st> <st c="33018">''y'': yval})</st><st c="33030">soln = eqn.evalf()</st>
    else:'
- en: soln = None
  id: totrans-145
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: soln = None
- en: return render_template('simple_linear_mv_form.html', soln=soln), 200
  id: totrans-146
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: return render_template('simple_linear_mv_form.html', soln=soln), 200
- en: '[PRE17]'
  id: totrans-147
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: from modules.equations import eqn_bp
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: from modules.equations import eqn_bp
- en: from flask import render_template, request <st c="35315">from sympy import symbols,
    sympify, solve</st> @eqn_bp.route('/eqn/eqnsystem/solve', methods = ['GET', 'POST'])
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: from flask import render_template, request <st c="35315">from sympy import symbols,
    sympify, solve</st> @eqn_bp.route('/eqn/eqnsystem/solve', methods = ['GET', 'POST'])
- en: 'async def solve_multiple_eqns():'
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 'async def solve_multiple_eqns():'
- en: 'if request.method == ''GET'':'
  id: totrans-151
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 'if request.method == ''GET'':'
- en: soln = None
  id: totrans-152
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: soln = None
- en: 'else:'
  id: totrans-153
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 'else:'
- en: field_validations = (
  id: totrans-154
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: field_validations = (
- en: ('polyeqn1', gl.required, gl.type_(str)),
  id: totrans-155
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: ('polyeqn1', gl.required, gl.type_(str)),
- en: ('polyeqn2', gl.required, gl.type_(str))
  id: totrans-156
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: ('polyeqn2', gl.required, gl.type_(str))
- en: )
  id: totrans-157
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: )
- en: form_data = request.form.to_dict()
  id: totrans-158
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: form_data = request.form.to_dict()
- en: result = gl.validate(field_validations, form_data )
  id: totrans-159
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: result = gl.validate(field_validations, form_data )
- en: 'if bool(result): <st c="35712">x, y = symbols(''x y'')</st><st c="35733">eqn1
    = sympify(form_data[''polyeqn1''])</st><st c="35771">eqn2 = sympify(form_data[''polyeqn2''])</st><st
    c="35809">soln = solve((eqn1, eqn2),(x, y))</st> else:'
  id: totrans-160
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: 'if bool(result): <st c="35712">x, y = symbols(''x y'')</st><st c="35733">eqn1
    = sympify(form_data[''polyeqn1''])</st><st c="35771">eqn2 = sympify(form_data[''polyeqn2''])</st><st
    c="35809">soln = solve((eqn1, eqn2),(x, y))</st> else:'
- en: soln = None
  id: totrans-161
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: soln = None
- en: return  render_template('complex_multiple_eqns_form.html',   soln=soln), 200y
  id: totrans-162
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: return  render_template('complex_multiple_eqns_form.html',   soln=soln), 200y
- en: '[PRE18]'
  id: totrans-163
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: <st c="38327">from sympy import symbols, sympify</st>
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="38327">from sympy import symbols, sympify</st>
- en: <st c="38362">from sympy.plotting import plot</st>
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="38362">from sympy.plotting import plot</st>
- en: <st c="38394">import matplotlib</st>
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="38394">import matplotlib</st>
- en: <st c="38412">import base64</st>
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="38412">import base64</st>
- en: <st c="38426">from io import BytesIO</st>
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="38426">from io import BytesIO</st>
- en: <st c="38449">from PIL import Image</st> @eqn_bp.route('/eqn/multi/plot', methods
    = ['GET', 'POST'])
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="38449">from PIL import Image</st> @eqn_bp.route('/eqn/multi/plot', methods
    = ['GET', 'POST'])
- en: 'async def plot_two_equations():'
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 'async def plot_two_equations():'
- en: 'if request.method == ''GET'':'
  id: totrans-171
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 'if request.method == ''GET'':'
- en: data = None
  id: totrans-172
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: data = None
- en: 'else:'
  id: totrans-173
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 'else:'
- en: … … … … … …
  id: totrans-174
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: … … … … … …
- en: form_data = request.form.to_dict()
  id: totrans-175
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: form_data = request.form.to_dict()
- en: result = gl.validate(field_validations, form_data )
  id: totrans-176
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: result = gl.validate(field_validations, form_data )
- en: eqn1_upper = float(form_data['eqn1_maxval'])
  id: totrans-177
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: eqn1_upper = float(form_data['eqn1_maxval'])
- en: eqn1_lower = float(form_data['eqn1_minval'])
  id: totrans-178
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: eqn1_lower = float(form_data['eqn1_minval'])
- en: eqn2_upper = float(form_data['eqn2_maxval'])
  id: totrans-179
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: eqn2_upper = float(form_data['eqn2_maxval'])
- en: eqn2_lower = float(form_data['eqn2_minval'])
  id: totrans-180
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: eqn2_lower = float(form_data['eqn2_minval'])
- en: data = None
  id: totrans-181
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: data = None
- en: 'if bool(result) and (eqn1_lower <= eqn1_upper) and (eqn2_lower <= eqn2_upper):
    <st c="38980">matplotlib.use(''agg'')</st> x = symbols(''x'')'
  id: totrans-182
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: 'if bool(result) and (eqn1_lower <= eqn1_upper) and (eqn2_lower <= eqn2_upper):
    <st c="38980">matplotlib.use(''agg'')</st> x = symbols(''x'')'
- en: eqn1 = sympify(form_data['equation1'])
  id: totrans-183
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: eqn1 = sympify(form_data['equation1'])
- en: eqn2 = sympify(form_data['equation2']) <st c="39097">graph = plot(eqn1, (x,
    eqn1_lower, eqn1_upper), line_color='red', show=False)</st><st c="39174">graph.extend(plot(eqn2,
    (x, eqn2_lower, eqn2_upper), line_color='blue', show=False))</st> filename = "./files/img/multi_plot.png"
    <st c="39300">graph.save(filename)</st><st c="39320">img = Image.open(filename)</st><st
    c="39347">image_io = BytesIO()</st><st c="39368">img.save(image_io, 'PNG')</st>
    data = base64.b64encode(image_io.getbuffer()) .decode("ascii")
  id: totrans-184
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: eqn2 = sympify(form_data['equation2']) <st c="39097">graph = plot(eqn1, (x,
    eqn1_lower, eqn1_upper), line_color='red', show=False)</st><st c="39174">graph.extend(plot(eqn2,
    (x, eqn2_lower, eqn2_upper), line_color='blue', show=False))</st> filename = "./files/img/multi_plot.png"
    <st c="39300">graph.save(filename)</st><st c="39320">img = Image.open(filename)</st><st
    c="39347">image_io = BytesIO()</st><st c="39368">img.save(image_io, 'PNG')</st>
    data = base64.b64encode(image_io.getbuffer()) .decode("ascii")
- en: return render_template('plot_two_eqns_form.html', data=data), 200
  id: totrans-185
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: return render_template('plot_two_eqns_form.html', data=data), 200
- en: '[PRE19]'
  id: totrans-186
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: pip install latex
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: pip install latex
- en: '[PRE20]'
  id: totrans-188
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: <st c="42802">from jinja2 import FileSystemLoader, Environment</st>
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="42802">from jinja2 import FileSystemLoader, Environment</st>
- en: <st c="42851">from latex.jinja2 import make_env</st> environ:<st c="42894">Environment</st>
    = make_env(loader=FileSystemLoader('files'), <st c="42952">enable_async=True,</st>
    block_start_string = '\BLOCK{',
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="42851">from latex.jinja2 import make_env</st> environ:<st c="42894">Environment</st>
    = make_env(loader=FileSystemLoader('files'), <st c="42952">enable_async=True,</st>
    block_start_string = '\BLOCK{',
- en: block_end_string = '}',
  id: totrans-191
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: block_end_string = '}',
- en: variable_start_string = 'VAR{',
  id: totrans-192
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: variable_start_string = 'VAR{',
- en: variable_end_string = '}',
  id: totrans-193
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: variable_end_string = '}',
- en: comment_start_string = '#{',
  id: totrans-194
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: comment_start_string = '#{',
- en: comment_end_string = '}',
  id: totrans-195
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: comment_end_string = '}',
- en: line_statement_prefix = '%-',
  id: totrans-196
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: line_statement_prefix = '%-',
- en: line_comment_prefix = '%#',
  id: totrans-197
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: line_comment_prefix = '%#',
- en: trim_blocks = True,
  id: totrans-198
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: trim_blocks = True,
- en: autoescape = False,)
  id: totrans-199
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: autoescape = False,)
- en: '[PRE21]'
  id: totrans-200
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: from modules.rendition import rendition_bp
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: from modules.rendition import rendition_bp
- en: from flask import send_from_directory
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: from flask import send_from_directory
- en: from jinja2 import FileSystemLoader
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: from jinja2 import FileSystemLoader
- en: from latex.jinja2 import make_env
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: from latex.jinja2 import make_env
- en: '@rendition_bp.route(''/render/hpi/plot/eqns'', methods = [''GET'', ''POST''])
    <st c="44441">async</st> def convert_latex(): <st c="44468">tpl = environ.get_template(''/latex/hpi_plot.tex'')</st>
    outpath=os.path.join(''./files/latex'',''hpi_plot.pdf'')'
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: '@rendition_bp.route(''/render/hpi/plot/eqns'', methods = [''GET'', ''POST''])
    <st c="44441">async</st> def convert_latex(): <st c="44468">tpl = environ.get_template(''/latex/hpi_plot.tex'')</st>
    outpath=os.path.join(''./files/latex'',''hpi_plot.pdf'')'
- en: outfile=open(outpath,'w') <st c="44597">outfile.write(await tpl.render_async(author='Sherwin</st>
    <st c="44649">John Tragura', title="Rendering HPI Plot with</st> <st c="44695">LaTeX",
    date=datetime.now().strftime("%B %d, %Y"),</st> <st c="44746">renderTbl=True))</st><st
    c="44763">outfile.close()</st> os.system("pdflatex <st c="44800">--shell-escape</st>
    -output-directory=" + './files/latex' + " " + outpath) <st c="44959">get_template()</st>
    of the <st c="44981">Environment</st> instance, <st c="45003">environ</st>, to
    create a Jinja2 template of a specific LaTeX document from the <st c="45078">/latex</st>
    sub-directory of the root folder. The template’s <st c="45134">render_async()</st>
    function opens the specified LaTeX document for changes, such as passing context
    values (e.g., <st c="45244">author</st>, <st c="45252">title</st>, <st c="45259">date</st>,
    and <st c="45269">renderTbl</st>) to complete the document.
  id: totrans-206
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: outfile=open(outpath,'w') <st c="44597">outfile.write(await tpl.render_async(author='Sherwin</st>
    <st c="44649">约翰·特拉古拉', title="使用LaTeX渲染HPI图", date=datetime.now().strftime("%B
    %d, %Y"),</st> <st c="44695">renderTbl=True))</st><st c="44763">outfile.close()</st>
    os.system("pdflatex <st c="44800">--shell-escape</st> -output-directory=" + './files/latex'
    + " " + outpath) <st c="44959">get_template()</st> of the <st c="44981">环境</st>实例，<st
    c="45003">环境</st>，从根目录的<st c="45078">/latex</st>子目录中创建一个特定LaTeX文档的Jinja2模板。该模板的<st
    c="45134">render_async()</st>函数打开指定的LaTeX文档以进行更改，例如传递上下文值（例如，<st c="45244">作者</st>，<st
    c="45252">标题</st>，<st c="45259">日期</st>和<st c="45269">renderTbl</st>）以完成文档。
- en: <st c="45306">Afterward, the</st> `<st c="45322">view</st>` <st c="45326">function
    will convert the document into PDF format, which is the necessary approach for
    this application.</st> `<st c="45433">os.path.join()</st>` <st c="45447">will
    indicate where to save the file.</st> <st c="45486">Now, MikTeX offers three compilers
    to compile and convert the LaTeX document to PDF, namely pdfLaTeX, XeLaTeX, and
    LuaLaTeX, but our implementation uses pdfLaTeX, which is the default one.</st>
    `<st c="45675">os.system()</st>` <st c="45686">will run the compiler and save
    the PDF into the specific location.</st> <st c="45754">To render the content,
    Flask has a</st> `<st c="45789">send_from_directory()</st>` <st c="45810">method
    that can display the content of a PDF file saved in the directory.</st> *<st c="45885">Figure
    6</st>**<st c="45893">.15</st>* <st c="45896">shows the</st> <st c="45906">resulting
    PDF document by running the</st> `<st c="45945">convert_latex()</st>` <st c="45960">view
    function.</st>
  id: totrans-207
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: <st c="45306">之后，</st> `<st c="45322">视图</st>` <st c="45326">函数将文档转换为PDF格式，这是此应用程序的必要方法。</st>
    `<st c="45433">os.path.join()</st>` <st c="45447">将指示文件保存的位置。</st> <st c="45486">现在，MikTeX提供了三个编译器来编译并将LaTeX文档转换为PDF，即pdfLaTeX、XeLaTeX和LuaLaTeX，但我们的实现使用pdfLaTeX，这是默认的。</st>
    `<st c="45675">os.system()</st>` <st c="45686">将运行编译器并将PDF保存到指定位置。</st> <st c="45754">为了渲染内容，Flask有一个</st>
    `<st c="45789">send_from_directory()</st>` <st c="45810">方法可以显示目录中保存的PDF文件的内容。</st>
    *<st c="45885">图6</st>**<st c="45893">.15</st>* <st c="45896">显示了通过运行</st> `<st
    c="45945">convert_latex()</st>` <st c="45960">视图函数得到的PDF文档的结果。</st>
- en: '![Figure 6.15 – Rendering a LaTeX document as a PDF](img/B19383_06_015.jpg)'
  id: totrans-208
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_IMG
  zh: '![图6.15 – 将LaTeX文档渲染为PDF](img/B19383_06_015.jpg)'
- en: <st c="46098">Figure 6.15 – Rendering a LaTeX document as a PDF</st>
  id: totrans-209
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: <st c="46098">图6.15 – 将LaTeX文档渲染为PDF</st>
- en: <st c="46147">Our Flask application</st> <st c="46169">does not only render
    existing LaTeX documents but also creates one before rendering it to</st> <st
    c="46260">the client.</st>
  id: totrans-210
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: <st c="46147">我们的Flask应用程序</st> <st c="46169">不仅渲染现有的LaTeX文档，而且在将其渲染到客户端之前先创建一个。</st>
- en: <st c="46271">Creating LaTeX documents</st>
  id: totrans-211
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: <st c="46271">创建LaTeX文档</st>
- en: <st c="46296">So far, the</st> `<st c="46309">latex</st>` <st c="46314">module</st>
    <st c="46322">with Jinja2 has no LaTeX creation features that Flask can use to
    build scientific writeups from various data sources.</st> <st c="46440">However,
    other modules, such as</st> `<st c="46472">pylatex</st>`<st c="46479">, can provide
    helper classes and methods to serialize LaTeX content at runtime.</st> <st c="46559">The
    following view implementation shows how to generate a LaTeX file with</st> `<st
    c="46633">DataFrame</st>` <st c="46642">object’s data derived from an uploaded</st>
    <st c="46682">XLSX document:</st>
  id: totrans-212
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: <st c="46296">到目前为止，</st> `<st c="46309">latex</st>` <st c="46314">模块</st> <st
    c="46322">与Jinja2一起没有LaTeX创建功能，Flask可以使用这些功能从各种数据源构建科学论文。</st> <st c="46440">然而，其他模块，如</st>
    `<st c="46472">pylatex</st>`<st c="46479">，可以提供辅助类和方法，在运行时序列化LaTeX内容。</st> <st
    c="46559">以下视图实现展示了如何使用</st> `<st c="46633">DataFrame</st>` <st c="46642">对象的数据，该数据来自上传的</st>
    `<st c="46682">XLSX</st>`文档来生成LaTeX文件：</st>
- en: '[PRE22]'
  id: totrans-213
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: <st c="47246">Before anything else, the environment setup must have the MikTeX
    or TeX Live installation for the LaTeX compilers.</st> <st c="47362">Then, install
    the</st> `<st c="47380">pylatex</st>` <st c="47387">module through the</st> `<st
    c="47407">pip</st>` <st c="47410">command:</st>
  id: totrans-214
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: 在所有其他事情之前，环境设置必须安装 MikTeX 或 TeX Live 以支持 LaTeX 编译器。</st> <st c="47362">然后，通过</st>
    `<st c="47380">pylatex</st>` <st c="47387">模块通过</st> `<st c="47407">pip</st>`
    <st c="47410">命令安装：</st>
- en: '[PRE23]'
  id: totrans-215
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: <st c="47439">To start the transaction, the given</st> `<st c="47476">create_latext_pdf()</st>`
    <st c="47495">retrieves an uploaded XLSX document to derive the tabular values
    for the</st> <st c="47569">report generation:</st>
  id: totrans-216
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: <st c="47439">要开始事务，给定的</st> `<st c="47476">create_latext_pdf()</st>` <st c="47495">检索上传的
    XLSX 文档以提取用于报告生成的表格值：</st>
- en: '[PRE24]'
  id: totrans-217
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: <st c="48045">Then, it sets up a</st> <st c="48064">dictionary,</st> `<st c="48077">geometry_options</st>`<st
    c="48093">, that consists of the LaTeX document parameters, such as the document
    orientation (</st>`<st c="48177">landscape</st>`<st c="48187">), the left, right,
    top, and bottom margins (</st>`<st c="48233">margin</st>`<st c="48240">), the
    vertical height from the bottom part of the header down to the topmost area of
    first the text (</st>`<st c="48343">headsep</st>`<st c="48351">), the space from
    the top margin to the line where to start the header part (</st>`<st c="48429">headheight</st>`<st
    c="48440">), and the toggle parameter to include or exclude the document header
    and footer of the document (</st>`<st c="48539">includeheadfoot</st>`<st c="48555">).</st>
    <st c="48559">This dictionary is essential to the instantiation of the</st> `<st
    c="48616">pylatex</st>`<st c="48623">’s</st> `<st c="48627">Document container</st>`
    <st c="48645">class, which will represent the</st> <st c="48678">LaTeX document.</st>
  id: totrans-218
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: <st c="48045">然后，它设置了一个</st> <st c="48064">字典</st>，`<st c="48077">geometry_options</st>`<st
    c="48093">，它包含 LaTeX 文档参数，例如文档方向（</st>`<st c="48177">landscape</st>`<st c="48187">），左右、顶部和底部边距（</st>`<st
    c="48233">margin</st>`<st c="48240">），从页眉底部到第一段文字最顶部的垂直高度（</st>`<st c="48343">headsep</st>`<st
    c="48351">），从页眉顶部到开始页眉部分的行的空间（</st>`<st c="48429">headheight</st>`<st c="48440">），以及切换参数以包含或排除文档的页眉和页脚（</st>`<st
    c="48539">includeheadfoot</st>`<st c="48555">）。</st> <st c="48559">这个字典对于实例化</st>
    `<st c="48616">pylatex</st>`<st c="48623">的</st> `<st c="48627">Document container</st>`
    <st c="48645">类至关重要，该类将代表 LaTeX 文档。</st>
- en: <st c="48693">Initially, the LaTeX document will be a blank instance with the
    desired document parameters indicated by its</st> `<st c="48803">geometry_option</st>`
    <st c="48818">constructor parameter and the</st> `<st c="48849">document_options</st>`
    <st c="48865">list containing other options such as the font size and paper size.</st>
    <st c="48934">Then, to start customizing the document, the</st> `<st c="48979">view</st>`
    <st c="48983">function uses the</st> `<st c="49002">Command</st>` <st c="49009">class
    to create custom values to the document’s title, author, and date without escaping
    the backslash, thus the use of the</st> `<st c="49134">NoEscape</st>` <st c="49142">class,
    and append them to the preamble property of the</st> `<st c="49198">Document</st>`
    <st c="49206">instance.</st> <st c="49217">This process is similar to calling</st>
    `<st c="49252">\title</st>`<st c="49258">,</st> `<st c="49260">\author</st>`<st
    c="49267">, and</st> `<st c="49273">\date</st>` <st c="49278">commands with custom
    values interpolated by the</st> `<st c="49327">\</st>``<st c="49328">VAR{}</st>`
    <st c="49333">command.</st>
  id: totrans-219
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: <st c="48693">最初，LaTeX 文档将是一个带有通过其</st> `<st c="48803">geometry_option</st>`
    <st c="48818">构造函数参数和包含其他选项（如字体大小和纸张大小）的</st> `<st c="48849">document_options</st>`
    <st c="48865">列表的空白实例。</st> <st c="48934">然后，为了开始自定义文档，</st> `<st c="48979">view</st>`
    <st c="48983">函数使用</st> `<st c="49002">Command</st>` <st c="49009">类创建用于文档标题、作者和日期的定制值，而不进行转义，因此使用了</st>
    `<st c="49134">NoEscape</st>` <st c="49142">类，并将它们附加到</st> `<st c="49198">Document</st>`
    <st c="49206">实例的 preamble 属性。</st> <st c="49217">这个过程类似于调用</st> `<st c="49252">\title</st>`<st
    c="49258">，`<st c="49260">\author</st>`<st c="49267">，和</st> `<st c="49273">\date</st>`
    <st c="49278">命令，并通过</st> `<st c="49327">\</st>``<st c="49328">VAR{}</st>` <st
    c="49333">命令插入自定义值。</st>
- en: <st c="49342">Next, the view must append the</st> `<st c="49374">\maketitle</st>`
    <st c="49384">command without escaping the backslash to typeset all these added
    document details.</st> <st c="49469">The line following</st> `<st c="49488">\maketitle</st>`
    <st c="49498">is always the generation of the body content, in our case, the</st>
    <st c="49562">following section:</st>
  id: totrans-220
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: '`<st c="49342">接下来，视图必须添加`<st c="49374">\maketitle</st>` `<st c="49384">命令，而不需要转义反斜杠，以排版所有这些添加的文档细节。</st>`
    `<st c="49469">在`<st c="49488">\maketitle</st>` `<st c="49498">之后的行总是生成正文内容，在我们的例子中，是以下章节：</st>'
- en: '[PRE25]'
  id: totrans-221
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: <st c="49713">The</st> `<st c="49718">pylatex</st>` <st c="49725">module classes
    are equivalent to some LaTeX commands, such as</st> `<st c="49788">Axis</st>`<st
    c="49792">,</st> `<st c="49794">Math</st>`<st c="49798">,</st> `<st c="49800">Matrix</st>`<st
    c="49806">,</st> `<st c="49808">Center</st>`<st c="49814">,</st> `<st c="49816">Alignat</st>`<st
    c="49823">,</st> `<st c="49825">Alignref</st>`<st c="49833">, and</st> `<st c="49839">Plot</st>`<st
    c="49843">. The</st> `<st c="49849">Command</st>` <st c="49856">class is a module
    class used to run custom or general commands such as</st> `<st c="49928">\title</st>`<st
    c="49934">,</st> `<st c="49936">\author</st>`<st c="49943">, and</st> `<st c="49949">\date</st>`<st
    c="49954">. In this</st> `<st c="49964">create_latex_pdf()</st>` <st c="49982">view,
    the content generation started with running the</st> `<st c="50037">Section</st>`
    <st c="50044">command</st> <st c="50052">with a section title,</st> *<st c="50075">The
    Data Analysis.</st> <st c="50094">A</st>* <st c="50095">section is an organized
    part of the content that contains combinations of tables, text, plots, and mathematical
    equations.</st> <st c="50219">After that, the view appends a statement in text
    form.</st> <st c="50274">Since there is no backslash to escape, there is no reason
    to wrap the test with the</st> `<st c="50358">NoEscape</st>` <st c="50366">class.</st>
    <st c="50374">Then, we create the sub-sections indicated in the</st> <st c="50424">following
    snippet:</st>
  id: totrans-222
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: '`<st c="49713">The</st>` `<st c="49718">pylatex</st>` `<st c="49725">模块类与一些LaTeX命令等价，例如</st>`
    `<st c="49788">Axis</st>`<st c="49792">,</st> `<st c="49794">Math</st>`<st c="49798">,</st>
    `<st c="49800">Matrix</st>`<st c="49806">,</st> `<st c="49808">Center</st>`<st
    c="49814">,</st> `<st c="49816">Alignat</st>`<st c="49823">,</st> `<st c="49825">Alignref</st>`<st
    c="49833">, 和</st> `<st c="49839">Plot</st>`<st c="49843">。`<st c="49849">Command</st>`
    `<st c="49856">类是一个模块类，用于运行自定义或通用命令，例如</st>` `<st c="49928">\title</st>`<st c="49934">,</st>
    `<st c="49936">\author</st>`<st c="49943">, 和</st> `<st c="49949">\date</st>`<st
    c="49954">。在这个`<st c="49964">create_latex_pdf()</st>` `<st c="49982">视图中，内容生成从运行带有章节标题的`<st
    c="50037">Section</st>` `<st c="50044">命令</st>` `<st c="50052">开始，标题为` *<st c="50075">数据分析。</st>
    <st c="50094">A</st>* `<st c="50095">章节是内容的一个有组织的部分，包含表格、文本、图表和数学公式的组合。</st>`
    `<st c="50219">之后，视图以文本形式添加一条声明。</st>` `<st c="50274">由于没有反斜杠需要转义，因此没有必要用`<st
    c="50358">NoEscape</st>` `<st c="50366">类`将文本包裹起来。</st>` `<st c="50374">然后，我们创建以下片段中指示的子章节：</st>'
- en: '[PRE26]'
  id: totrans-223
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: <st c="50987">After the text, the view appends a</st> `<st c="51023">Subsection</st>`
    <st c="51033">command, which will granularize the content of the recently created
    section.</st> <st c="51111">Part of its component is the</st> `<st c="51140">Tabular</st>`
    <st c="51147">command that will</st> <st c="51166">construct a spreadsheet of
    HPI values derived from the extracted tabular values.</st> <st c="51247">After
    the assemblage of the LaTeX content, the</st> `<st c="51294">create_latex_pdf()</st>`
    <st c="51312">view will now generate the PDF for rendition, as shown in the</st>
    <st c="51375">following snippet:</st>
  id: totrans-224
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: '`<st c="50987">在文本之后，视图添加一个`<st c="51023">Subsection</st>` `<st c="51033">命令，这将细化最近创建的章节的内容。</st>`
    `<st c="51111">其部分组件是`<st c="51140">Tabular</st>` `<st c="51147">命令，它将构建一个由提取的表格值派生出的HPI值的电子表格。</st>`
    `<st c="51247">在LaTeX内容的组装之后，`<st c="51294">create_latex_pdf()</st>` `<st c="51312">视图现在将生成用于呈现的PDF，如下面的片段所示：</st>'
- en: '[PRE27]'
  id: totrans-225
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: <st c="51526">The</st> `<st c="51531">Document</st>` <st c="51539">instance
    has a</st> `<st c="51555">generate_pdf()</st>` <st c="51569">method that compiles
    and generates the LaTeX file, converts the LaTeX file to its PDF form, and saves
    both files to a specific directory.</st> <st c="51708">Once the PDF is available,
    the view can render the PDF content through Flask’s</st> `<st c="51787">send_from_directory()</st>`
    <st c="51808">method.</st> *<st c="51817">Figure 6</st>**<st c="51825">.16</st>*
    <st c="51828">displays the generated PDF of the</st> `<st c="51863">create_latex_pdf()</st>`
    <st c="51881">view function.</st>
  id: totrans-226
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: <st c="51526">文档</st> <st c="51531">实例有一个</st> <st c="51539">generate_pdf()</st>
    <st c="51555">方法，它编译并生成LaTeX文件，将LaTeX文件转换为PDF格式，并将这两个文件保存到特定目录。</st> <st c="51708">一旦PDF可用，视图可以通过Flask的</st>
    <st c="51787">send_from_directory()</st> <st c="51808">方法渲染PDF内容。</st> *<st c="51817">图6.16</st>**<st
    c="51825">.16</st>* <st c="51828">显示了</st> <st c="51863">create_latex_pdf()</st>
    <st c="51881">视图函数生成的PDF。</st>
- en: '![Figure 6.16 – A PDF generated by the pylatex module](img/B19383_06_016.jpg)'
  id: totrans-227
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_IMG
  zh: '![图6.16 – 由pylatex模块生成的PDF](img/B19383_06_016.jpg)'
- en: <st c="52320">Figure 6.16 – A PDF generated by the pylatex module</st>
  id: totrans-228
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: <st c="52320">图6.16 – 由pylatex模块生成的PDF</st>
- en: <st c="52371">Aside from rendering PDF content, Flask can also utilize popular
    frontend libraries for displaying graphs and</st> <st c="52482">charts.</st> <st
    c="52490">Let us concentrate on how Flask can integrate with</st> <st c="52541">these</st>
    **<st c="52547">JavaScript</st>** <st c="52557">(</st>**<st c="52559">JS</st>**<st
    c="52561">)-based libraries in</st> <st c="52583">visualizing datasets.</st>
  id: totrans-229
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: <st c="52371">除了渲染PDF内容外，Flask还可以利用流行的前端库来显示图表和</st> <st c="52482">图表。</st>
    <st c="52490">让我们集中讨论Flask如何与</st> <st c="52541">这些</st> **<st c="52547">JavaScript</st>**
    <st c="52557">(</st>**<st c="52559">JS</st>**<st c="52561">)-based libraries在</st>
    <st c="52583">可视化数据集</st>中集成。</st>
- en: <st c="52604">Building graphical charts with frontend libraries</st>
  id: totrans-230
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: <st c="52604">使用前端库构建图形图表</st>
- en: <st c="52654">Most developers prefer</st> <st c="52678">rendering</st> <st c="52687">graphs
    and charts using frontend libraries rather than</st> `<st c="52743">matplotlib</st>`<st
    c="52753">, which requires complex Python coding to refine presentation and lacks
    UI-related features such as responsiveness, adaptability, and user interaction.</st>
    <st c="52905">This section will highlight the Chart.js,</st> `<st c="52947">Bokeh</st>`<st
    c="52952">, and</st> `<st c="52958">Plotly</st>` <st c="52964">libraries, which
    are all popular libraries with varying strengths and weaknesses as external tools</st>
    <st c="53064">for visualization.</st>
  id: totrans-231
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: <st c="52654">大多数开发者更喜欢使用前端库来渲染</st> <st c="52678">图形和图表</st>，而不是使用需要复杂Python编码来完善展示且缺乏UI相关功能（如响应性、适应性、用户交互）的`matplotlib`。</st>
    <st c="52905">本节将重点介绍Chart.js、`Bokeh`和`Plotly`库，这些库都是流行的可视化外部工具，具有不同的优势和劣势。</st>
    <st c="53064">。</st>
- en: <st c="53082">Let’s begin</st> <st c="53095">with Chart.js.</st>
  id: totrans-232
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: <st c="53082">让我们从Chart.js开始。</st>
- en: <st c="53109">Plotting with Chart.js</st>
  id: totrans-233
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: <st c="53109">使用Chart.js进行绘图</st>
- en: <st c="53132">The most common</st> <st c="53149">and popular charting library
    used in many visualization applications is Chart.js.</st> <st c="53231">It is
    100% JS, is lightweight, is easy to use, and has a straightforward syntax for
    designing graphs and charts.</st> <st c="53344">The following is the Chart.js
    implementation that displays the mean HPI values of</st> <st c="53426">certain
    countries:</st>
  id: totrans-234
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: <st c="53132">在许多可视化应用中最常见</st> <st c="53149">且最受欢迎的图表库是 Chart.js。</st> <st
    c="53231">它是100%的JS，轻量级，易于使用，并且具有设计图表和图表的直观语法。</st> <st c="53344">以下是一个Chart.js实现，用于显示某些国家的平均HPI值：</st>
    <st c="53426">。</st>
- en: '[PRE28]'
  id: totrans-235
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: <st c="54031">Chart.js is available in</st> <st c="54057">three sources:</st>
  id: totrans-236
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: <st c="54031">Chart.js有三种来源：</st>
- en: '**<st c="54071">Node.js</st>**<st c="54079">: By running npm to install the</st>
    <st c="54112">chart.js module.</st>'
  id: totrans-237
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**<st c="54071">Node.js</st>**<st c="54079">：通过运行npm安装</st> <st c="54112">chart.js模块。</st>'
- en: '**<st c="54128">GitHub</st>**<st c="54135">: By downloading the</st> [<st c="54157">https://github.com/chartjs/Chart.js/releases/download/v4.4.0/chart.js-4.4.0.tgz</st>](https://github.com/chartjs/Chart.js/releases/download/v4.4.0/chart.js-4.4.0.tgz)
    <st c="54236">file or the latest</st> <st c="54256">release available.</st>'
  id: totrans-238
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**<st c="54128">GitHub</st>**<st c="54135">：通过下载</st> [<st c="54157">https://github.com/chartjs/Chart.js/releases/download/v4.4.0/chart.js-4.4.0.tgz</st>](https://github.com/chartjs/Chart.js/releases/download/v4.4.0/chart.js-4.4.0.tgz)
    <st c="54236">文件或可用的最新</st> <st c="54256">版本。</st>'
- en: '**<st c="54274">Content delivery network</st>** **<st c="54299">(CDN)</st>**<st
    c="54305">: By</st> <st c="54310">referencing</st> [<st c="54323">https://cdn.jsdelivr.net/npm/chart.js</st>](https://cdn.jsdelivr.net/npm/chart.js)<st
    c="54360">.</st>'
  id: totrans-239
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**<st c="54274">内容分发网络</st>** **<st c="54299">(CDN)</st>**<st c="54305">：通过</st>
    <st c="54310">引用</st> [<st c="54323">https://cdn.jsdelivr.net/npm/chart.js</st>](https://cdn.jsdelivr.net/npm/chart.js)<st
    c="54360">。</st>'
- en: <st c="54361">Based on the HTML script, our implementation opted for the</st>
    <st c="54421">CDN source.</st>
  id: totrans-240
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: <st c="54361">根据 HTML 脚本，我们的实现选择了</st> <st c="54421">CDN 源。</st>
- en: <st c="54432">After referencing Chart.js, create a</st> `<st c="54470"><canvas></st>`
    <st c="54478">tag with the width and height that fits your plot.</st> <st c="54530">Then,
    create a</st> `<st c="54545">Chart()</st>` <st c="54552">instance with the node
    or 2D context of</st> `<st c="54593"><canvas></st>` <st c="54601">and some</st>
    <st c="54610">configuration options.</st> <st c="54634">Moreover, set new and
    appropriate values to global default properties such as the font name, font size,
    and</st> <st c="54742">font color:</st>
  id: totrans-241
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: <st c="54432">在引用 Chart.js 之后，创建一个宽度高度适合您图表的 `<st c="54470"><canvas></st>` <st
    c="54478">标签。</st> <st c="54530">然后，创建一个带有 `<st c="54593"><canvas></st>` <st c="54601">的节点或
    2D 上下文和某些</st> <st c="54610">配置选项的 `<st c="54545">Chart()</st>` <st c="54552">实例。</st>
    <st c="54634">此外，为全局默认属性设置新的和适当的值，例如字体名称、字体大小和</st> <st c="54742">字体颜色：</st>
- en: '[PRE29]'
  id: totrans-242
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: <st c="55049">The</st> `<st c="55054">data</st>` <st c="55058">property provides
    the x-axis labels, data points, and connecting lines.</st> <st c="55131">Its</st>
    `<st c="55135">datasets</st>` <st c="55143">sub-property</st> <st c="55157">contains
    the look-and-feel details of the plots with the actual data.</st> <st c="55227">Both
    the</st> `<st c="55236">label</st>` <st c="55241">and</st> `<st c="55246">data</st>`
    <st c="55250">lists are context data supplied by its</st> <st c="55290">view function:</st>
  id: totrans-243
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: <st c="55049">`<st c="55054">data</st>` <st c="55058">属性提供了 x 轴标签、数据点和连接线。</st>
    它的 `<st c="55135">datasets</st>` <st c="55143">子属性</st> 包含了实际数据的图表外观和感觉细节。</st>
    `<st c="55236">label</st>` <st c="55241">和 `<st c="55246">data</st>` <st c="55250">列表都是其
    `<st c="55290">view</st>` <st c="55290">函数</st> 提供的上下文数据：</st>
- en: '[PRE30]'
  id: totrans-244
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: <st c="55617">Now, Chart.js can also build multiple line graphs, varieties of
    bar graphs, pie charts, and doughnuts, all using the same setup as the given line
    graph.</st> <st c="55771">Running the view function with the given Chart.js</st>
    <st c="55820">script will render a line graph, as indicated in</st> *<st c="55870">Figure
    6</st>**<st c="55878">.17</st>*<st c="55881">.</st>
  id: totrans-245
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: <st c="55617">现在，Chart.js 也可以构建多个折线图、各种条形图、饼图和甜甜圈，所有这些都使用与提供的折线图相同的设置。</st>
    <st c="55771">运行带有给定 Chart.js <st c="55820">脚本的 view 函数将渲染一个折线图，如</st> *<st c="55870">图
    6</st>**<st c="55878">.17</st>**<st c="55881">所示。</st>
- en: '![Figure 6.17 – A line graph for HPI values per country](img/B19383_06_017.jpg)'
  id: totrans-246
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_IMG
  zh: '![图 6.17 – 每个国家 HPI 值的折线图](img/B19383_06_017.jpg)'
- en: <st c="56131">Figure 6.17 – A line graph for HPI values per country</st>
  id: totrans-247
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: <st c="56131">图 6.17 – 每个国家 HPI 值的折线图</st>
- en: <st c="56184">Chart.js supports responsive web design and interactive results,
    such as the given line graph that provides us with some information during mouse-over
    on every line dot.</st> <st c="56355">Despite its popularity, Chart.js still utilizes
    HTML canvas, which cannot render efficiently large and complex graphs.</st> <st
    c="56474">Also, it lacks other interactive utilities present in Bokeh</st> <st
    c="56534">and Plotly.</st>
  id: totrans-248
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: <st c="56184">Chart.js 支持响应式网页设计和交互式结果，例如提供的折线图，在鼠标悬停在每个线点上时提供一些信息。</st> <st
    c="56355">尽管它很受欢迎，但 Chart.js 仍然使用 HTML canvas，这不能有效地渲染大型和复杂的图表。</st> <st c="56474">此外，它还缺少
    Bokeh 和 Plotly 中存在的其他交互式实用工具。</st>
- en: <st c="56545">Let us now create</st> <st c="56564">graphs using a module friendlier
    to</st> <st c="56600">Python,</st> **<st c="56608">Plotly</st>**<st c="56614">.</st>
  id: totrans-249
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: <st c="56545">现在，让我们使用一个对 Python 更友好的模块来创建</st> <st c="56564">图表，**<st c="56608">Plotly</st>**<st
    c="56614">。</st>
- en: <st c="56615">Creating graphs with Plotly</st>
  id: totrans-250
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: <st c="56615">使用 Plotly 创建图表</st>
- en: <st c="56643">Plotly is also a JS-based</st> <st c="56669">library that can
    render interactive</st> <st c="56706">charts and graphs.</st> <st c="56725">It
    is a popular library for various statistical and mathematical projects that require
    interactive data visualization and 3D graphics effects and can seamlessly plot</st>
    <st c="56891">DataFrame datasets.</st>
  id: totrans-251
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: <st c="56643">Plotly</st> 也是一个基于 JS 的 <st c="56669">库，可以渲染交互式 <st c="56706">图表和图形。</st>
    它是各种需要交互式数据可视化和 3D 图形效果的统计和数学项目的流行库，可以无缝地绘制 <st c="56891">DataFrame 数据集。</st>
- en: <st c="56910">To utilize its classes and methods for plotting graphs, install
    the</st> `<st c="56979">plotly</st>` <st c="56985">module through the</st> `<st
    c="57005">pip</st>` <st c="57008">command:</st>
  id: totrans-252
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: <st c="56910">为了利用其类和方法进行绘图，请通过</st> `<st c="56979">plotly</st>` <st c="56985">模块使用</st>
    `<st c="57005">pip</st>` <st c="57008">命令安装：</st>
- en: '[PRE31]'
  id: totrans-253
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: <st c="57036">The following view function uses Plotly to create a grouped bar
    graph about the price and bedroom preferences of buyers categorized according
    to their furnishing</st> <st c="57199">status preference:</st>
  id: totrans-254
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: <st c="57036">以下视图函数使用 Plotly 创建关于买家按装修状态偏好分类的价格和卧室偏好的分组条形图：</st> <st c="57199">偏好：</st>
- en: '[PRE32]'
  id: totrans-255
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: <!doctype html>
  id: totrans-256
  prefs: []
  type: TYPE_NORMAL
  zh: <!doctype html>
- en: <html>
  id: totrans-257
  prefs: []
  type: TYPE_NORMAL
  zh: <html>
- en: <head>
  id: totrans-258
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: <head>
- en: <title>Plotly Bar Graph</title>
  id: totrans-259
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: <title>Plotly 条形图</title>
- en: </head>
  id: totrans-260
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: </head>
- en: <body>
  id: totrans-261
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: <body>
- en: … … … … … …
  id: totrans-262
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: … … … … … …
- en: '{%if graphJSON == ''{}'' %}'
  id: totrans-263
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: '{%if graphJSON == ''{}'' %}'
- en: <p>No plot image.</p>
  id: totrans-264
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: <p>没有图表图像。</p>
- en: '{% else %} <st c="58844"><div id=''chart'' class=''chart''></div></st> {% endif
    %}'
  id: totrans-265
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: '{% else %} <st c="58844"><div id=''chart'' class=''chart''></div></st> {% endif
    %}'
- en: </body> <st c="58901"><script src='https://cdn.plot.ly/plotly-latest.js'></script></st><st
    c="58961"><script type='text/javascript'></st><st c="58993">var graphs = {{ graphJSON
    | safe }};</st><st c="59030">Plotly.plot('chart', graphs, {});</st><st c="59064"></script></st>
    </html>
  id: totrans-266
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: </body> <st c="58901"><script src='https://cdn.plot.ly/plotly-latest.js'></script></st><st
    c="58961"><script type='text/javascript'></st><st c="58993">var graphs = {{ graphJSON
    | safe }};</st><st c="59030">Plotly.plot('chart', graphs, {});</st><st c="59064"></script></st>
    </html>
- en: '[PRE33]'
  id: totrans-267
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: pip install bokeh
  id: totrans-268
  prefs: []
  type: TYPE_NORMAL
  zh: pip install bokeh
- en: '[PRE34]'
  id: totrans-269
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: <st c="60939">from bokeh.plotting import figure</st>
  id: totrans-270
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="60939">从 bokeh.plotting 导入 figure</st>
- en: <st c="60973">from bokeh.embed import components</st> @rendition_bp.route('/bokeh/hpi/line',
    methods = ['GET', 'POST'])
  id: totrans-271
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="60973">从 bokeh.embed 导入 components</st> @rendition_bp.route('/bokeh/hpi/line',
    methods = ['GET', 'POST'])
- en: 'def create_bokeh_line():'
  id: totrans-272
  prefs: []
  type: TYPE_NORMAL
  zh: 'def create_bokeh_line():'
- en: 'if request.method == ''GET'':'
  id: totrans-273
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 'if request.method == ''GET'':'
- en: script = None
  id: totrans-274
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: script = None
- en: div = None
  id: totrans-275
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: div = None
- en: 'else:'
  id: totrans-276
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 'else:'
- en: … … … … … …
  id: totrans-277
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: … … … … … …
- en: 'try:'
  id: totrans-278
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: 'try:'
- en: df = read_excel(uploaded_file, sheet_name=1, skiprows=[1])
  id: totrans-279
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: df = read_excel(uploaded_file, sheet_name=1, skiprows=[1])
- en: x = df.index.values
  id: totrans-280
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: x = df.index.values
- en: 'y = df[''UK''] <st c="61268">plot = figure(max_width=600, max_height=800,title=None,
    toolbar_location="below", background_fill_color="#FFFFCC", x_axis_label=''Period
    by Quarter ID'', y_axis_label=''Nominal HPI'')</st><st c="61447">plot.line(x,y,
    line_width=4, color="#CC0000")</st><st c="61493">script, div = components(plot)</st>
    except:'
  id: totrans-281
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: 'y = df[''UK''] <st c="61268">plot = figure(max_width=600, max_height=800,title=None,
    toolbar_location="below", background_fill_color="#FFFFCC", x_axis_label=''按季度ID的时期'',
    y_axis_label=''名义HPI'')</st><st c="61447">plot.line(x,y, line_width=4, color="#CC0000")</st><st
    c="61493">script, div = components(plot)</st> except:'
- en: raise FileSavingException()
  id: totrans-282
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: raise FileSavingException()
- en: return render_template('bokeh.html', script=script, div=div, title="Line Graph
    of UK's Nominal HPI")
  id: totrans-283
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: return render_template('bokeh.html', script=script, div=div, title="英国名义HPI折线图")
- en: '[PRE35]'
  id: totrans-284
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: <!DOCTYPE html>
  id: totrans-285
  prefs: []
  type: TYPE_NORMAL
  zh: <!DOCTYPE html>
- en: <html lang="en">
  id: totrans-286
  prefs: []
  type: TYPE_NORMAL
  zh: <html lang="en">
- en: <head>
  id: totrans-287
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: <head>
- en: <meta charset="utf-8">
  id: totrans-288
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: <meta charset="utf-8">
- en: <title>Bokeh HPI</title> <st c="62727"><script src="img/bokeh-3.2.2.js"></script></st>
    </head>
  id: totrans-289
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: <title>Bokeh HPI</title> <st c="62727"><script src="img/bokeh-3.2.2.js"></script></st>
    </head>
- en: <body>
  id: totrans-290
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: <body>
- en: … … … … … …
  id: totrans-291
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: … … … … … …
- en: '{%if div == None and script == None %}'
  id: totrans-292
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: '{%if div == None and script == None %}'
- en: <p>No plot image.</p>
  id: totrans-293
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: <p>没有图表图像。</p>
- en: '{% else %} <st c="62900">{{ div | safe }}</st><st c="62916">{{ script | safe
    }}</st> {% endif %}'
  id: totrans-294
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: '{% else %} <st c="62900">{{ div | safe }}</st><st c="62916">{{ script | safe
    }}</st> {% endif %}'
- en: </body>
  id: totrans-295
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: </body>
- en: </html>
  id: totrans-296
  prefs: []
  type: TYPE_NORMAL
  zh: </html>
- en: '[PRE36]'
  id: totrans-297
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: '<st c="64773">@sock.route(''/ch06/ws/server/hpi/plot'')</st> def ws_server_plot(ws):'
  id: totrans-298
  prefs: []
  type: TYPE_NORMAL
  zh: '<st c="64773">@sock.route(''/ch06/ws/server/hpi/plot'')</st> def ws_server_plot(ws):'
- en: 'async def process():'
  id: totrans-299
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 'async def process():'
- en: 'while True: <st c="64871">hpi_data_json = ws.receive()</st> hpi_data_dict =
    loads(hpi_data_json) <st c="64937">json_data = dumps(</st><st c="64955">{''period'':
    f"Y{hpi_data_dict[''year'']}</st> <st c="64993">Q{hpi_data_dict[''quarter'']}"</st>,
    <st c="65024">''hpi'': float(hpi_data_dict[''hpi''])})</st><st c="65060">ws.send(json_data)</st>
    run(process())'
  id: totrans-300
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: 'while True: <st c="64871">hpi_data_json = ws.receive()</st> hpi_data_dict =
    loads(hpi_data_json) <st c="64937">json_data = dumps(</st><st c="64955">{''period'':
    f"Y{hpi_data_dict[''year'']}</st> <st c="64993">Q{hpi_data_dict[''quarter'']}"</st>,
    <st c="65024">''hpi'': float(hpi_data_dict[''hpi''])})</st><st c="65060">ws.send(json_data)</st>
    run(process())'
- en: '[PRE37]'
  id: totrans-301
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: <st c="65355">const socket = new WebSocket('ws://' + location.host +</st> <st
    c="65410">'/ch06/ws/server/hpi/plot');</st> socket.addEventListener('message',
    msg => { <st c="65484">const data = JSON.parse(msg.data);</st> if (config.data.labels.length
    === 20) {
  id: totrans-302
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="65355">const socket = new WebSocket('ws://' + location.host +</st> <st
    c="65410">'/ch06/ws/server/hpi/plot');</st> socket.addEventListener('message',
    msg => { <st c="65484">const data = JSON.parse(msg.data);</st> if (config.data.labels.length
    === 20) {
- en: config.data.labels.shift();
  id: totrans-303
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: config.data.labels.shift();
- en: config.data.datasets[0].data.shift();
  id: totrans-304
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: config.data.datasets[0].data.shift();
- en: '} <st c="65627">config.data.labels.push(data.period);</st><st c="65664">config.data.datasets[0].data.push(data.hpi);</st><st
    c="65709">lineChart.update();</st> });'
  id: totrans-305
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: '} <st c="65627">config.data.labels.push(data.period);</st><st c="65664">config.data.datasets[0].data.push(data.hpi);</st><st
    c="65709">lineChart.update();</st> });'
- en: '[PRE38]'
  id: totrans-306
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: from redis import Redis
  id: totrans-307
  prefs: []
  type: TYPE_NORMAL
  zh: from redis import Redis
- en: redis_conn = Redis(
  id: totrans-308
  prefs: []
  type: TYPE_NORMAL
  zh: redis_conn = Redis(
- en: db = 0,
  id: totrans-309
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: db = 0,
- en: host='127.0.0.1',
  id: totrans-310
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: host='127.0.0.1',
- en: port=6379,
  id: totrans-311
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: port=6379,
- en: decode_responses=True
  id: totrans-312
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: decode_responses=True
- en: )
  id: totrans-313
  prefs: []
  type: TYPE_NORMAL
  zh: )
- en: '[PRE39]'
  id: totrans-314
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: <st c="66943">var source = new EventSource("/ch06/sse/hpi/data/stream");</st>
    source.onmessage = function (event) {
  id: totrans-315
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="66943">var source = new EventSource("/ch06/sse/hpi/data/stream");</st>
    source.onmessage = function (event) {
- en: const data = JSON.parse(event.data);
  id: totrans-316
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: const data = JSON.parse(event.data);
- en: if (config.data.labels.length === 20) {
  id: totrans-317
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: if (config.data.labels.length === 20) {
- en: config.data.labels.shift();
  id: totrans-318
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: config.data.labels.shift();
- en: config.data.datasets[0].data.shift();
  id: totrans-319
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: config.data.datasets[0].data.shift();
- en: '} <st c="67186">config.data.labels.push(data.period);</st><st c="67223">config.data.datasets[0].data.push(data.hpi);</st>
    lineChart.update();'
  id: totrans-320
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: '} <st c="67186">config.data.labels.push(data.period);</st><st c="67223">config.data.datasets[0].data.push(data.hpi);</st>
    lineChart.update();'
- en: '};'
  id: totrans-321
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: '};'
- en: '[PRE40]'
  id: totrans-322
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: pip install celery
  id: totrans-323
  prefs: []
  type: TYPE_NORMAL
  zh: pip install celery
- en: '[PRE41]'
  id: totrans-324
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: '@shared_task(ignore_result=False)'
  id: totrans-325
  prefs: []
  type: TYPE_NORMAL
  zh: '@shared_task(ignore_result=False)'
- en: 'def compute_hpi_laspeyre(df_json): <st c="68779">async def compute_hpi_task(df_json):</st>
    try:'
  id: totrans-326
  prefs: []
  type: TYPE_NORMAL
  zh: 'def compute_hpi_laspeyre(df_json): <st c="68779">async def compute_hpi_task(df_json):</st>
    try:'
- en: df_dict = loads(df_json)
  id: totrans-327
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: df_dict = loads(df_json)
- en: df = DataFrame(df_dict)
  id: totrans-328
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: df = DataFrame(df_dict)
- en: df["p1*q0"] = df["p1"] * df["q0"]
  id: totrans-329
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: df["p1*q0"] = df["p1"] * df["q0"]
- en: df["p0*q0"] = df["p0"] * df["q0"]
  id: totrans-330
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: df["p0*q0"] = df["p0"] * df["q0"]
- en: print(df)
  id: totrans-331
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: print(df)
- en: numer = df["p1*q0"].sum()
  id: totrans-332
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: numer = df["p1*q0"].sum()
- en: denom = df["p0*q0"].sum()
  id: totrans-333
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: denom = df["p0*q0"].sum()
- en: hpi = numer/denom
  id: totrans-334
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: hpi = numer/denom
- en: return hpi
  id: totrans-335
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: return hpi
- en: 'except Exception as e:'
  id: totrans-336
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: 'except Exception as e:'
- en: return 0
  id: totrans-337
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: return 0
- en: return <st c="69098">compute_hpi_laspeyre()</st> runs an asynchronous task that
    computes the HPI value using Laspeyre’s formula with inputs that include the house
    price for a particular house preference and the number of customers who bought
    the house for a specific year. The computation will take longer when given a lot
    of data, so using an asynchronous Celery task to run the formula when the worst-case
    scenario happens may improve its execution at runtime.
  id: totrans-338
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: return <st c="69098">compute_hpi_laspeyre()</st> 运行一个异步任务，使用 Laspeyre 公式计算 HPI
    值，输入包括特定房屋偏好的房价和特定年份购买该房屋的客户数量。当给定大量数据时，计算将需要更长的时间，因此当发生最坏情况时，使用异步 Celery 任务运行公式可能会提高其运行时的执行效率。
- en: <st c="69535">It is always a good practice to run heavy and resource-intensive
    computations or processes outside the thread of the view function using asynchronous
    background tasks.</st> <st c="69704">It also employs loose coupling between the
    request-response transactions and the numerical algorithms, which can help avoid
    the degradation and starvations of</st> <st c="69863">these processes.</st>
  id: totrans-339
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: <st c="69535">始终将重负载和资源密集型计算或进程在视图函数的线程之外运行，使用异步后台任务，这是一种良好的实践。</st> <st c="69704">它还采用了请求-响应事务与数值算法之间的松散耦合，这有助于避免这些进程的降级和饥饿。</st>
    <st c="69863">。</st>
- en: <st c="69879">Integrating</st> <st c="69892">popular</st> <st c="69900">numerical
    and symbolic software into the Flask platform can sometimes save migration time
    when dealing with existing scientific projects.</st> <st c="70038">Let us now
    explore the capability of Flask to integrate with the</st> <st c="70103">Julia
    language.</st>
  id: totrans-340
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: <st c="69879">将</st> <st c="69892">流行的</st> <st c="69900">数值和符号软件集成到 Flask 平台中，在处理现有科学项目时有时可以节省迁移时间。</st>
    <st c="70038">现在让我们探索 Flask 与</st> <st c="70103">Julia 语言集成的能力。</st>
- en: <st c="70118">Incorporating Julia packages with Flask</st>
  id: totrans-341
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: <st c="70118">将 Julia 包与 Flask 集成</st>
- en: '**<st c="70158">Julia</st>** <st c="70164">is a high-powered</st> <st c="70183">compiled
    programming</st> <st c="70203">language that provides mathematical and symbolic
    libraries.</st> <st c="70264">It contains simple syntax for numerical computing
    and provides better runtime performance for executing</st> <st c="70368">its applications.</st>'
  id: totrans-342
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: '**<st c="70158">Julia</st>** <st c="70164">是一种功能强大的</st> <st c="70183">编译型编程</st>
    <st c="70203">语言，提供了数学和符号库。</st> <st c="70264">它包含用于数值计算的简单语法，并为其应用程序提供了更好的运行时性能。</st>'
- en: <st c="70385">Although Julia has web frameworks such as Genie, Oxygen, and Bukdu,
    which can implement Julia-based web applications, it is also possible that Flask
    applications can run and extract values from</st> <st c="70580">Julia functions.</st>
  id: totrans-343
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: <st c="70385">尽管 Julia 有 Genie、Oxygen 和 Bukdu 等网络框架，可以实现基于 Julia 的网络应用程序，但 Flask
    应用程序也可以运行并从</st> <st c="70580">Julia 函数中提取值。</st>
- en: <st c="70596">But first, download the latest Julia compiler from</st> [<st c="70648">https://julialang.org/downloads/</st>](https://julialang.org/downloads/)
    <st c="70680">and install it on your system.</st> <st c="70712">Installing an
    old Julia version into an updated Windows OS will result in a system crash, as
    indicated in</st> *<st c="70818">Figure 6</st>**<st c="70826">.20</st>*<st c="70829">.</st>
  id: totrans-344
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: 首先，从 [<st c="70648">https://julialang.org/downloads/</st>](https://julialang.org/downloads/)
    下载最新的 Julia 编译器并将其安装到您的系统上。将旧版本的 Julia 安装到更新的 Windows 操作系统中会导致系统崩溃，如 *<st c="70818">图
    6</st>**<st c="70826">.20</st>*<st c="70829">* 所示。
- en: '![Figure 6.20 – System crashes due to Flask running outdated Julia](img/B19383_06_020.jpg)'
  id: totrans-345
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_IMG
  zh: '![图 6.20 – 由于 Flask 运行过时的 Julia 而导致的系统崩溃](img/B19383_06_020.jpg)'
- en: <st c="71132">Figure 6.20 – System crashes due to Flask running outdated Julia</st>
  id: totrans-346
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: 图 6.20 – 由于 Flask 运行过时的 Julia 而导致的系统崩溃
- en: <st c="71196">Let’s now take</st> <st c="71212">a</st> <st c="71214">look at
    the steps involved in creating and integrating the Julia package into a</st> <st
    c="71294">Flask application.</st>
  id: totrans-347
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: 现在，让我们看看创建和将 Julia 软件包集成到 `<st c="71294">Flask 应用</st>` 中的步骤。
- en: <st c="71312">Creating a custom Julia package</st>
  id: totrans-348
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: 创建自定义 Julia 软件包
- en: <st c="71344">After the installation, go</st> <st c="71371">to the project directory
    of the Flask app through the console and open a Julia shell by running the</st>
    `<st c="71472">julia</st>` <st c="71477">command.</st> <st c="71487">Then, follow</st>
    <st c="71500">these instructions:</st>
  id: totrans-349
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: 安装完成后，通过控制台进入 Flask 应用的项目目录，并运行 `<st c="71472">julia</st>` `<st c="71477">命令</st>`
    打开 Julia 壳。然后，按照 `<st c="71487">以下</st>` `<st c="71500">说明</st>` 进行操作：
- en: <st c="71519">Run the command using</st> `<st c="71542">Pkg</st>` <st c="71545">on</st>
    <st c="71549">the shell.</st>
  id: totrans-350
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用 `<st c="71519">Pkg</st>` 在 `<st c="71542">Pkg</st>` 上 `<st c="71545">运行</st>`
    `<st c="71549">shell</st>` 命令。
- en: <st c="71559">Create a</st> `<st c="71569">Julia</st>` <st c="71574">package
    in the Flask app directory by running the</st> <st c="71625">following command:</st>
  id: totrans-351
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 通过运行以下命令在 `<st c="71559">Flask 应用目录</st>` 中创建一个 `<st c="71569">Julia</st>` `<st
    c="71574">软件包</st>`：
- en: '[PRE42]'
  id: totrans-352
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE42]'
- en: <st c="71672">Install the</st> `<st c="71685">PythonCall</st>` <st c="71695">plugin
    by running the</st> <st c="71718">following command:</st>
  id: totrans-353
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 通过运行以下命令安装 `<st c="71672">PythonCall</st>` `<st c="71685">插件</st>`：
- en: '[PRE43]'
  id: totrans-354
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE43]'
- en: <st c="71758">Also, install Julia packages such as</st> `<st c="71796">DataFrame</st>`<st
    c="71805">,</st> `<st c="71807">Pandas</st>`<st c="71813">, and</st> `<st c="71819">Statistics</st>`
    <st c="71829">for converting and running Python syntax in the</st> <st c="71878">Julia
    environment.</st>
  id: totrans-355
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 此外，安装 Julia 软件包，如 `<st c="71796">DataFrame</st>`<st c="71805">`、`<st c="71807">Pandas</st>`<st
    c="71813">` 和 `<st c="71819">Statistics</st>`，以便在 `<st c="71878">Julia 环境</st>`
    中转换和运行 Python 语法。
- en: <st c="71896">Finally, run</st> `<st c="71910">Pkg.resolve()</st>` <st c="71923">and</st>
    `<st c="71928">Pkg.instantiate()</st>` <st c="71945">to finalize</st> <st c="71958">the
    setup.</st>
  id: totrans-356
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后，运行 `<st c="71910">Pkg.resolve()</st>` `<st c="71923">和</st>` `<st c="71928">Pkg.instantiate()</st>`
    `<st c="71945">以完成</st>` `<st c="71958">设置</st>`。
- en: <st c="71968">Next, we’ll install the</st> `<st c="71993">juliacall</st>` <st
    c="72002">client module and add the Julia-related configuration details to the</st>
    **<st c="72072">TOML</st>** <st c="72076">file.</st>
  id: totrans-357
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: 接下来，我们将安装 `<st c="71993">juliacall</st>` 客户端模块并将与 Julia 相关的配置细节添加到 **<st c="72072">TOML</st>**
    `<st c="72076">文件</st>` 中。
- en: <st c="72082">Configuring Julia accessibility in a Flask project</st>
  id: totrans-358
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: 配置 Flask 项目中的 Julia 可访问性
- en: <st c="72133">After creating a</st> <st c="72151">Julia custom package</st>
    <st c="72171">inside the Flask app, open the app’s</st> `<st c="72209">config_dev.toml</st>`
    <st c="72224">file and add the following environment variables to integrate Julia
    into the</st> <st c="72302">Flask platform:</st>
  id: totrans-359
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: 在 Flask 应用内部创建一个 `<st c="72151">Julia 自定义软件包</st>` 后，打开应用的 `<st c="72209">config_dev.toml</st>`
    `<st c="72224">文件</st>` 并添加以下环境变量以将 Julia 集成到 `<st c="72302">Flask 平台</st>` 中：
- en: '`<st c="72317">PYTHON_JULIAPKG_EXE</st>`<st c="72337">: The path to the</st>
    `<st c="72356">julia.exe</st>` <st c="72365">file, including the filename (</st><st
    c="72396">e.g.,</st> `<st c="72403">C:/Alibata/Development/Language/Julia-1.9.2/bin/julia</st>`<st
    c="72456">).</st>'
  id: totrans-360
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`<st c="72317">PYTHON_JULIAPKG_EXE</st>`：到 `<st c="72356">julia.exe</st>` `<st
    c="72365">文件</st>` 的路径，包括文件名（例如，`<st c="72396">e.g.</st>` `<st c="72403">C:/Alibata/Development/Language/Julia-1.9.2/bin/julia</st>`
    `<st c="72456">）。</st>`'
- en: '`<st c="72459">PYTHON_JULIAPKG_OFFLINE</st>`<st c="72483">: Set to</st> `<st
    c="72493">yes</st>` <st c="72496">to stop any Julia installation in</st> <st c="72531">the
    background.</st>'
  id: totrans-361
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`<st c="72459">PYTHON_JULIAPKG_OFFLINE</st>` `<st c="72483">：设置为</st>` `<st
    c="72493">yes</st>` `<st c="72496">以停止在</st>` `<st c="72531">后台</st>` `<st c="72531">的任何
    Julia 安装。</st>`'
- en: '`<st c="72546">PYTHON_JULIAPKG_PROJECT</st>`<st c="72570">: The path to the
    newly created custom Julia package inside the Flask app (</st><st c="72646">e.g.,</st>
    `<st c="72653">C:/Alibata/Training/Source/flask/mastering/ch06-web-final/Ch06JuliaPkg/</st>`<st
    c="72724">).</st>'
  id: totrans-362
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`<st c="72546">PYTHON_JULIAPKG_PROJECT</st>` `<st c="72570">：在 Flask 应用程序内部新创建的自定义
    Julia 包的路径（</st>` `<st c="72646">例如</st>` `<st c="72653">C:/Alibata/Training/Source/flask/mastering/ch06-web-final/Ch06JuliaPkg/</st>`
    `<st c="72724">）。</st>`'
- en: '`<st c="72727">JULIA_PYTHONCALL_EXE</st>`<st c="72748">: The path to the Python
    compiler of the virtual environment, including the filename (</st><st c="72835">e.g.,</st>
    `<st c="72842">C:/Alibata/Training/Source/flask/mastering/ch06-web-env/Scripts/python</st>`<st
    c="72912">).</st>'
  id: totrans-363
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`<st c="72727">JULIA_PYTHONCALL_EXE</st>` `<st c="72748">：虚拟环境 Python 编译器的路径，包括文件名（</st>`
    `<st c="72835">例如</st>` `<st c="72842">C:/Alibata/Training/Source/flask/mastering/ch06-web-env/Scripts/python</st>`
    `<st c="72912">）。</st>`'
- en: <st c="72915">Afterward, install the</st> `<st c="72939">juliacall</st>` <st
    c="72948">module through the</st> `<st c="72968">pip</st>` <st c="72971">command:</st>
  id: totrans-364
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: '`<st c="72915">之后，通过</st>` `<st c="72939">juliacall</st>` `<st c="72948">模块通过</st>`
    `<st c="72968">pip</st>` `<st c="72971">命令安装：</st>`'
- en: '[PRE44]'
  id: totrans-365
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: <st c="73002">After the Flask setup, let us now create the Julia code inside
    the</st> <st c="73070">Julia package.</st>
  id: totrans-366
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: 在 Flask 设置之后，现在让我们在 Julia 包内部创建 Julia 代码。
- en: <st c="73084">Implementing Julia functions in the package</st>
  id: totrans-367
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: 在包中实现 Julia 函数
- en: <st c="73128">After the Python</st> <st c="73145">configuration, open</st> `<st
    c="73166">ch06-web-final\Ch06JuliaPkg\src\Ch06JuliaPkg.jl</st>` <st c="73213">and
    create some Julia functions with the imported</st> `<st c="73264">PythonCall</st>`
    <st c="73274">package, like in the</st> <st c="73296">following snippet:</st>
  id: totrans-368
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: 在 Python `<st c="73128">配置</st>` `<st c="73145">之后，打开</st>` `<st c="73166">ch06-web-final\Ch06JuliaPkg\src\Ch06JuliaPkg.jl</st>`
    `<st c="73213">并使用导入的</st>` `<st c="73264">PythonCall</st>` `<st c="73274">包创建一些
    Julia 函数，如下面的代码片段所示：</st>` `<st c="73296">：</st>`
- en: '[PRE45]'
  id: totrans-369
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: <st c="73706">All syntax inside the Julia package must be valid Julia syntax.</st>
    <st c="73771">Thus, the given</st> `<st c="73787">sum_array()</st>` <st c="73798">is
    a Julia package.</st> <st c="73819">On the other hand, importing Python modules
    requires the</st> <st c="73876">instantiation of</st> `<st c="73893">PythonCall</st>`
    <st c="73903">through</st> `<st c="73912">pynew()</st>`<st c="73919">, and the
    actual module mapping happens in its</st> `<st c="73966">__init__()</st>` <st
    c="73976">initialization method</st> <st c="73999">through</st> `<st c="74007">pycopy()</st>`<st
    c="74015">.</st>
  id: totrans-370
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: Julia 包内部的所有语法都必须是有效的 Julia 语法。因此，给定的 `<st c="73787">sum_array()</st>` `<st
    c="73798">是 Julia 包。</st>` `<st c="73819">另一方面，导入 Python 模块需要通过 `<st c="73876">实例化</st>`
    `<st c="73893">PythonCall</st>` `<st c="73903">通过</st>` `<st c="73912">pynew()</st>`
    `<st c="73919">，并且实际的模块映射发生在其</st>` `<st c="73966">__init__()</st>` `<st c="73976">初始化方法</st>`
    `<st c="73999">通过</st>` `<st c="74007">pycopy()</st>` `<st c="74015">。</st>`
- en: <st c="74016">Creating the Julia service module</st>
  id: totrans-371
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: 创建 Julia 服务模块
- en: <st c="74050">To access the</st> <st c="74064">functions in the custom Julia
    package, such as</st> `<st c="74112">Ch06JuliaPkg</st>`<st c="74124">, create
    a service module that will activate</st> `<st c="74169">Ch06JuliaPkg</st>` <st
    c="74181">and create a Julia module that will execute the Julia commands in Flask
    in that particular</st> `<st c="74273">Blueprint</st>` <st c="74282">section.</st>
    <st c="74292">The following is the</st> `<st c="74313">\modules\external\services\julia_transactions.py</st>`
    <st c="74361">service module from the external</st> `<st c="74395">Blueprint</st>`
    <st c="74404">with the needed</st> `<st c="74421">juliacall</st>` <st c="74430">executions:</st>
  id: totrans-372
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: 要访问自定义 Julia 包中的函数，例如 `<st c="74112">Ch06JuliaPkg</st>` `<st c="74124">，创建一个服务模块，该模块将激活
    `<st c="74169">Ch06JuliaPkg</st>` `<st c="74181">并创建一个 Julia 模块，该模块将在特定的 `<st
    c="74273">Blueprint</st>` `<st c="74282">部分</st>` `<st c="74292">中执行 Flask 中的
    Julia 命令。</st>` 《以下是从外部 `<st c="74313">\modules\external\services\julia_transactions.py</st>`
    `<st c="74361">服务模块中需要的</st>` `<st c="74395">Blueprint</st>` `<st c="74404">执行
    juliacall</st>` `<st c="74421">执行：</st>`
- en: '[PRE46]'
  id: totrans-373
  prefs: []
  type: TYPE_PRE
  zh: '[PRE46]'
- en: <st c="74723">At every startup</st> <st c="74741">of the Flask server, the application
    always activates the Julia package because the application always loads all the
    services of the blueprints.</st> *<st c="74886">Figure 6</st>**<st c="74894">.21</st>*
    <st c="74897">shows the activation process on the server log of the</st> <st c="74952">Flask
    app:</st>
  id: totrans-374
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: <st c="74723">在每次启动</st> <st c="74741">Flask服务器时，应用程序总是激活Julia包，因为应用程序总是加载所有蓝图的服务。</st>
    *<st c="74886">图6</st>**<st c="74894">.21</st>* <st c="74897">显示了Flask应用程序服务器日志中的激活过程：</st>
- en: '![Figure 6.21 – Julia package activation log during server startup](img/B19383_06_021.jpg)'
  id: totrans-375
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_IMG
  zh: '![图6.21 – 服务器启动期间Julia包激活日志](img/B19383_06_021.jpg)'
- en: <st c="75365">Figure 6.21 – Julia package activation log during server startup</st>
  id: totrans-376
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: <st c="75365">图6.21 – 服务器启动期间Julia包激活日志</st>
- en: <st c="75429">The activation may cause degradation to the startup time of the
    server, which is a disadvantage for Flask.</st> <st c="75537">If this performance
    glitch worsens, it will be advisable to migrate all implementation to popular
    Julia web frameworks, such as Oxygen, Genie, and Bukduh, instead of pursuing further
    the</st> <st c="75724">Flask integration.</st>
  id: totrans-377
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: <st c="75429">激活可能会降低服务器的启动时间，这对Flask来说是一个缺点。</st> <st c="75537">如果这种性能问题恶化，建议将所有实现迁移到流行的Julia
    Web框架，如Oxygen、Genie和Bukduh，而不是进一步追求</st> `<st c="75724">Flask集成</st>`。</st>
- en: <st c="75742">Now, for the view functions to access Julia functions, add service
    methods in the</st> `<st c="75825">Blueprint</st>` <st c="75834">service where
    the activation happens.</st> <st c="75873">In our project, the</st> `<st c="75893">modules\external\services\julia_transactions.py</st>`
    <st c="75940">service module implements the following</st> `<st c="75981">total_array()</st>`
    <st c="75994">service to expose the</st> `<st c="76017">sum_array()</st>` <st
    c="76028">function</st> <st c="76038">in</st> `<st c="76041">Ch06JuliaPkg</st>`<st
    c="76053">:</st>
  id: totrans-378
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: <st c="75742">现在，为了使视图函数能够访问Julia函数，请向激活发生的</st> `<st c="75825">Blueprint</st>`
    <st c="75834">服务中添加服务方法。</st> <st c="75873">在我们的项目中，</st> `<st c="75893">modules\external\services\julia_transactions.py</st>`
    <st c="75940">服务模块实现了以下</st> `<st c="75981">total_array()</st>` <st c="75994">服务，以暴露</st>
    `<st c="76017">sum_array()</st>` <st c="76028">函数</st> <st c="76038">在</st> `<st
    c="76041">Ch06JuliaPkg</st>`<st c="76053">：</st>
- en: '[PRE47]'
  id: totrans-379
  prefs: []
  type: TYPE_PRE
  zh: '[PRE47]'
- en: <st c="76144">The Julia module or</st> `<st c="76165">jl</st>`<st c="76167">,
    using its</st> `<st c="76179">seval()</st>` <st c="76186">method, is the one that
    accesses and executes custom or built-in Julia functions in the Flask service.</st>
    <st c="76290">Given that the applications followed all installations and setups
    given correctly, running</st> `<st c="76381">jl.seval()</st>` <st c="76391">must
    not cause any system crash or</st> `<st c="76427">HTTP Status 500</st>`<st c="76442">.
    Again, the Python service functions that</st> <st c="76485">execute</st> `<st
    c="76493">jl.seval()</st>` <st c="76503">must be placed in the service module
    where the Julia package</st> <st c="76565">activation happened.</st>
  id: totrans-380
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: <st c="76144">Julia模块或</st> `<st c="76165">jl</st>`<st c="76167">，使用其</st> `<st
    c="76179">seval()</st>` <st c="76186">方法，是访问和执行Flask服务中自定义或内置Julia函数的一个。</st>
    <st c="76290">鉴于所有应用程序都正确遵循了所有安装和设置，运行</st> `<st c="76381">jl.seval()</st>` <st
    c="76391">不应导致任何系统崩溃或</st> `<st c="76427">HTTP状态500</st>`<st c="76442">。再次强调，执行</st>
    `<st c="76493">jl.seval()</st>` <st c="76503">的Python服务函数必须放置在Julia包激活发生的服务模块中。</st>
- en: <st c="76585">Summary</st>
  id: totrans-381
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: <st c="76585">总结</st>
- en: <st c="76593">Flask 3.0 is the best-fit version of Flask that can build scientific
    applications because of its asynchronous features and asyncio support.</st> <st
    c="76734">The asynchronous WebSocket, SSE, Celery background tasks, and services,
    together with the mathematical and computational modules, such as</st> `<st c="76872">numpy</st>`<st
    c="76877">,</st> `<st c="76879">matplotlib</st>`<st c="76889">,</st> `<st c="76891">sympy</st>`<st
    c="76896">,</st> `<st c="76898">pandas</st>`<st c="76904">,</st> `<st c="76906">scipy</st>`<st
    c="76911">, and</st> `<st c="76917">seaborn</st>`<st c="76924">, are the core
    ingredients in building applications that highlight visualizations, computations,
    and</st> <st c="77025">statistical analysis.</st>
  id: totrans-382
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: <st c="76593">Flask 3.0是构建科学应用的最佳Flask版本，因为它具有异步特性和asyncio支持。</st> <st c="76734">异步WebSocket、SSE、Celery后台任务和服务，以及数学和计算模块，如</st>
    `<st c="76872">numpy</st>`<st c="76877">、</st> `<st c="76879">matplotlib</st>`<st
    c="76889">、</st> `<st c="76891">sympy</st>`<st c="76896">、</st> `<st c="76898">pandas</st>`<st
    c="76904">、</st> `<st c="76906">scipy</st>`<st c="76911">和</st> `<st c="76917">seaborn</st>`<st
    c="76924">，是构建强调可视化、计算和</st> <st c="77025">统计分析的应用程序的核心成分。</st>
- en: <st c="77046">Proven by this chapter, Flask supports LaTeX document generation,
    updating, and rendition, including its PDF transformation.</st> <st c="77172">This
    feature is crucial in most scientific computing that requires archiving, reporting,
    and</st> <st c="77265">records management.</st>
  id: totrans-383
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: <st c="77046">正如本章所证明的，Flask支持LaTeX文档的生成、更新和呈现，包括其PDF转换。</st> <st c="77172">这一特性对于大多数需要存档、报告和记录管理的科学计算至关重要。</st>
    <st c="77265">管理。</st>
- en: <st c="77284">Flask support on visualization is also clear cut in this chapter,
    from the real-time data plotting down to the native plots of the</st> `<st c="77416">matplotlib</st>`
    <st c="77426">module.</st> <st c="77435">Flask can utilize JS-based libraries
    for data plotting of</st> `<st c="77493">DataFrame</st>` <st c="77502">object’s
    tabular values seamlessly and in a</st> <st c="77547">straightforward manner.</st>
  id: totrans-384
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: <st c="77284">本章中，Flask对可视化的支持也是明确的，从实时数据绘图到matplotlib模块的本地绘图。</st> <st c="77416">matplotlib</st>
    <st c="77426">模块。</st> <st c="77435">Flask可以无缝且直接地利用基于JS的库来绘制DataFrame对象的表格值。</st>
- en: <st c="77570">Although not yet stable, the integration of Julia with Flask shows
    how the interoperability property works with Flask.</st> <st c="77690">Using</st>
    `<st c="77696">PythonCall</st>` <st c="77706">and</st> `<st c="77711">JuliaCall</st>`
    <st c="77720">modules, it is now possible to run existing Julia functions in Flask
    as long as the setup and configuration</st> <st c="77829">are correct.</st>
  id: totrans-385
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: <st c="77570">尽管目前还不稳定，但Julia与Flask的集成展示了互操作性属性在Flask中的工作方式。</st> <st c="77690">使用</st>
    `<st c="77696">PythonCall</st>` <st c="77706">和</st> `<st c="77711">JuliaCall</st>`
    <st c="77720">模块，只要设置和配置正确，现在就可以在Flask中运行现有的Julia函数。</st> <st c="77829">正确。</st>
- en: <st c="77841">In conclusion, Flask, particularly the asynchronous version of
    Flask , is the best option for building web-based scientific applications.</st>
    <st c="77980">The next chapter will discuss how Flask utilizes NoSQL databases
    and addresses some big</st> <st c="78068">data requirements.</st>
  id: totrans-386
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: <st c="77841">总之，Flask，尤其是Flask的异步版本，是构建基于Web的科学应用的最佳选择。</st> <st c="77980">下一章将讨论Flask如何利用NoSQL数据库并解决一些大数据需求。</st>
    <st c="78068">数据。</st>
- en: '[PRE48]'
  id: totrans-387
  prefs: []
  type: TYPE_PRE
  zh: '[PRE48]'
- en: '[PRE49]'
  id: totrans-388
  prefs: []
  type: TYPE_PRE
  zh: '[PRE49]'
- en: '[PRE50]'
  id: totrans-389
  prefs: []
  type: TYPE_PRE
  zh: '[PRE50]'
