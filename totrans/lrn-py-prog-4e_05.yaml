- en: '5'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '5'
- en: Comprehensions and Generators
  id: totrans-1
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 理解和生成器
- en: ”It’s not the daily increase but daily decrease. Hack away at the unessential.”
  id: totrans-2
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: “不是每天的增量，而是每天的减量。砍掉不必要的东西。”
- en: ''
  id: totrans-3
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: —Bruce Lee
  id: totrans-4
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: ——李小龙
- en: The second part of the above quote, “hack away at the unessential,” is to us
    what makes a computer program elegant. We constantly strive to find better ways
    of doing things so that we do not waste time or memory.
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 上述引言的第二部分，“砍掉不必要的东西”，对我们来说正是使计算机程序优雅的原因。我们不断努力寻找更好的做事方式，以便我们不浪费时间或内存。
- en: There are valid reasons for not pushing our code up to the maximum limit. For
    example, sometimes we have to sacrifice readability or maintainability to achieve
    a negligible improvement. It does not make sense to have a web page served in
    1 second with unreadable, complicated code when we could serve it in 1.05 seconds
    with readable, clean code.
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: 有一些合理的理由不将我们的代码推到最大极限。例如，有时我们不得不牺牲可读性或可维护性以换取微小的改进。当我们可以用可读、干净的代码在1.05秒内提供服务时，用难以阅读、复杂的代码在1秒内提供服务是没有意义的。
- en: On the other hand, sometimes it is perfectly reasonable to try to shave off
    a millisecond from a function, especially when the function is meant to be called
    thousands of times. One millisecond saved over thousands of calls adds up to seconds
    saved overall, which might be meaningful for your application.
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: 另一方面，有时尝试从函数中节省一毫秒是完全合理的，特别是当函数打算被调用数千次时。在数千次调用中节省的一毫秒可以累积成秒，这可能会对你的应用程序有意义。
- en: In light of these considerations, the focus of this chapter will not be to give
    you the tools to push your code to the absolute limits of performance and optimization
    *no matter what* , but rather to enable you to write efficient, elegant code that
    reads well, runs fast, and does not waste resources in an obvious way.
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 考虑到这些因素，本章的重点不是给你工具来让你的代码无论什么情况下都能达到性能和优化的绝对极限，而是让你能够编写高效、优雅的代码，易于阅读，运行速度快，并且不会以明显的方式浪费资源。
- en: 'In this chapter, we are going to cover the following:'
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将涵盖以下内容：
- en: The `map()` , `zip()` , and `filter()` functions
  id: totrans-10
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`map()`、`zip()`和`filter()`函数'
- en: Comprehensions
  id: totrans-11
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 理解
- en: Generators
  id: totrans-12
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 生成器
- en: Performance
  id: totrans-13
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 性能
- en: We will perform several measurements and comparisons and cautiously draw some
    conclusions. Please do keep in mind that on a different machine with a different
    setup or operating system, results may vary.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将进行多次测量和比较，并谨慎地得出一些结论。请务必记住，在不同的机器、不同的设置或操作系统上，结果可能会有所不同。
- en: 'Take a look at this code:'
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 看看这段代码：
- en: '[PRE0]'
  id: totrans-16
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'Both functions return the square of `n` , but which is faster? From a simple
    benchmark that we ran, it looks like the second is slightly faster. If you think
    about it, it makes sense: calculating the power of a number involves multiplication.
    Therefore, whatever algorithm you may use to perform the power operation, it is
    not likely to beat a simple multiplication such as the one in `square2` .'
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 这两个函数都返回`n`的平方，但哪个更快？从我们运行的一个简单基准测试来看，第二个似乎稍微快一点。如果你这么想，这是有道理的：计算一个数的幂涉及乘法。因此，无论你使用什么算法来执行幂运算，都不太可能打败`square2`中的简单乘法。
- en: Do we care about this result? In most cases, no. If you are coding an e-commerce
    website, chances are you will never need to raise a number to the second power,
    and if you do, it is likely to be a sporadic operation. You do not need to concern
    yourself with saving a fraction of a microsecond on a function you call a few
    times.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 我们关心这个结果吗？在大多数情况下，不关心。如果你正在编写一个电子商务网站，你很可能永远不需要将一个数字提高到平方，即使你这样做，也很可能是偶尔的操作。你不需要担心在调用几次函数时节省几分之一微秒。
- en: So, when does optimization become important? One common case is when you have
    to deal with huge collections of data. If you are applying the same function on
    a million `customer` objects, then you want your function to be tuned up to its
    best. Gaining one-tenth of a second on a function called one million times saves
    you 100,000 seconds, which is about 27.7 hours. So, let us focus on collections,
    and see which tools Python gives you to handle them with efficiency and grace.
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 那么，何时优化变得重要呢？一个常见的例子是当你必须处理大量数据时。如果你要对一百万个`customer`对象应用相同的函数，那么你希望你的函数调优到最佳状态。对一个被调用一百万次的函数节省十分之一秒可以节省100,000秒，这大约是27.7小时。因此，让我们关注集合，看看Python为你提供了哪些工具来高效、优雅地处理它们。
- en: Many of the concepts we will see in this chapter are based on iterators and
    iterables, which we encountered in *Chapter 3* , *Conditionals and Iteration*
    . We will see how to code a custom iterator and iterable objects in *Chapter 6*
    , *OOP, Decorators, and Iterators* .
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 本章中我们将看到的大多数概念都是基于迭代器和可迭代对象，我们在 *第 3 章* ，*条件语句和迭代* 中遇到了它们。我们将看到如何在 *第 6 章* ，*面向对象编程、装饰器和迭代器*
    中编码自定义迭代器和可迭代对象。
- en: 'Some of the objects we are going to explore in this chapter are iterators,
    which save memory by only operating on a single element of a collection at a time
    rather than creating a modified copy. As a result, some extra work is needed if
    we just want to show the result of the operation. We will often resort to wrapping
    the iterator in a `list()` constructor. This is because passing an iterator to
    `list()` exhausts it and puts all the generated items in a newly created list,
    which we can easily print to show you its content. Let us see an example of using
    the technique on a `range` object:'
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 本章我们将探索的一些对象是迭代器，它们通过一次只操作集合中的一个元素来节省内存，而不是创建一个修改后的副本。因此，如果我们只想显示操作的结果，就需要做一些额外的工作。我们通常会求助于将迭代器包裹在
    `list()` 构造函数中。这是因为将迭代器传递给 `list()` 会耗尽它，并将所有生成的项放入一个新创建的列表中，我们可以轻松地打印出来以显示其内容。让我们看看在
    `range` 对象上使用该技术的例子：
- en: '[PRE1]'
  id: totrans-22
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: We have highlighted the result of typing `range(7)` into a Python console. Notice
    that it does not show the contents of the `range` because `range` never actually
    loads the entire sequence of numbers into memory. The second highlighted line
    shows how wrapping the `range` in a `list()` allows us to see the numbers it generates.
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经突出显示了在 Python 控制台中输入 `range(7)` 的结果。注意，它并没有显示 `range` 的内容，因为 `range` 从来不会实际将整个数字序列加载到内存中。第二个突出显示的行显示了将
    `range` 包裹在 `list()` 中是如何使我们能够看到它生成的数字的。
- en: Let us start looking at the various tools that Python provides for efficiently
    operating on collections of data.
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们开始查看 Python 为高效操作数据集合提供的各种工具。
- en: The map, zip, and filter functions
  id: totrans-25
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '`map`、`zip` 和 `filter` 函数'
- en: 'We will start by reviewing `map()` , `filter()` , and `zip()` , which are the
    main built-in functions you can employ when handling collections, and then we
    will learn how to achieve the same results using two important constructs: **comprehensions**
    and **generators** .'
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将首先回顾 `map()`、`filter()` 和 `zip()`，这些是处理集合时可以使用的内置函数的主要函数，然后我们将学习如何使用两个重要的结构：**列表推导式**和**生成器**来实现相同的结果。
- en: map
  id: totrans-27
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: '`map`'
- en: 'According to the official Python documentation ( [https://docs.python.org/3/library/functions.html#map](https://docs.python.org/3/library/functions.html#map)
    ), the following is true:'
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 根据 Python 的官方文档（[https://docs.python.org/3/library/functions.html#map](https://docs.python.org/3/library/functions.html#map)），以下内容是正确的：
- en: map(function, iterable, *iterables)
  id: totrans-29
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '`map(function, iterable, *iterables)`'
- en: ''
  id: totrans-30
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: Return an iterator that applies function to every item of iterable, yielding
    the results. If additional iterables arguments are passed, function must take
    that many arguments and is applied to the items from all iterables in parallel.
    With multiple iterables, the iterator stops when the shortest iterable is exhausted.
  id: totrans-31
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 返回一个迭代器，它将函数应用于可迭代对象的每个元素，并产生结果。如果传递了额外的可迭代参数，函数必须接受那么多参数，并且将并行应用于所有可迭代对象中的元素。在有多个可迭代对象的情况下，迭代器在最短的迭代器耗尽时停止。
- en: 'We will explain the concept of yielding later in the chapter. For now, let
    us translate this into code—we will use a `lambda` function that takes a variable
    number of positional arguments, and returns them as a tuple:'
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将在本章后面解释生成器的概念。现在，让我们将其转换为代码——我们将使用一个接受可变数量位置参数的 `lambda` 函数，并返回一个元组：
- en: '[PRE2]'
  id: totrans-33
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: In the preceding code, you can see why we have to wrap calls in `list()` . Without
    it, we get the string representation of a `map` object. Python’s default string
    representation for objects gives their type and memory location which, in this
    context, is not particularly useful to us.
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的代码中，你可以看到为什么我们必须将调用包裹在 `list()` 中。没有它，我们会得到一个 `map` 对象的字符串表示形式。Python 对象的默认字符串表示会给出它们的类型和内存位置，在这个上下文中，这对我们来说并不特别有用。
- en: You can also notice how the elements of each iterable are applied to the function;
    at first, the first element of each iterable is applied, then the second one of
    each iterable, and so on. Notice also that `map()` stops when the shortest of
    the iterables we called it with is exhausted. This is a very useful behavior;
    it does not force us to level off all the iterables to a common length, nor does
    it break if they are not all the same length.
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 您还可以注意到每个可迭代元素的函数应用方式；最初，每个可迭代元素的第一个元素被应用，然后是每个可迭代元素的第二个元素，依此类推。请注意，`map()`
    在我们调用的最短可迭代对象耗尽时停止。这是一个非常有用的行为；它不会强迫我们将所有可迭代对象调整到相同的长度，也不会在它们长度不同时中断。
- en: As a more interesting example, suppose we have a collection of student dictionaries,
    each of which contains a nested dictionary of the student’s credits. We want to
    sort the students based on the sum of their credits. However, the data as it is
    does not allow for a straightforward application of the sorting function.
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 作为更有趣的例子，假设我们有一个包含学生字典的集合，每个字典中都有一个嵌套的学生学分字典。我们希望根据学生学分的总和对学生进行排序。然而，现有的数据并不允许直接应用排序函数。
- en: To solve the problem, we are going to apply the **decorate-sort-undecorate**
    idiom (also known as **Schwartzian transform** ). It is a technique that was quite
    popular in older Python versions, when sorting did not support the use of *key
    functions* . Nowadays, it is not needed as often, but it still occasionally comes
    in handy.
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 为了解决这个问题，我们将应用 **装饰-排序-取消装饰** 惯用（也称为 **Schwartzian 转换**）。这是一种在较旧的 Python 版本中相当流行的技术，当时排序不支持使用
    *键函数*。如今，它不再经常需要，但它偶尔仍然很有用。
- en: To **decorate** an object means to transform it, either adding extra data to
    it or putting it into another object. Conversely, to **undecorate** an object
    means to revert the decorated object to its original form.
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 要 **装饰** 一个对象意味着对其进行转换，无论是向其添加额外数据还是将其放入另一个对象中。相反，要 **取消装饰** 一个对象意味着将装饰过的对象恢复到其原始形式。
- en: This technique has nothing to do with Python decorators, which we will explore
    later in the book.
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 这种技术与 Python 装饰器无关，我们将在本书的后面部分探讨。
- en: 'In the following example, we can see how `map()` is used to apply this idiom:'
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 在以下示例中，我们可以看到 `map()` 是如何应用这个惯用的：
- en: '[PRE3]'
  id: totrans-41
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'Let us start by understanding what each student object is. In fact, let us
    print the first one:'
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们先来了解每个学生对象是什么。实际上，让我们打印第一个：
- en: '[PRE4]'
  id: totrans-43
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'You can see that it is a dictionary with two keys: `id` and `credits` . The
    value of `credits` is also a dictionary in which there are three subject/grade
    key/value pairs. As you may recall from *Chapter 2* , *Built-in Data Types* ,
    calling `dict.values()` returns an iterable object, with only the dictionary’s
    values. Therefore, `sum(student["credits"].values())` for the first student is
    equivalent to `sum((9, 6, 7))` .'
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以看到这是一个包含两个键的字典：`id` 和 `credits`。`credits` 的值也是一个字典，其中包含三个科目/成绩键值对。如您从 *第2章*
    ，*内置数据类型* 中回忆的那样，调用 `dict.values()` 返回一个可迭代对象，其中只有字典的值。因此，第一个学生的 `sum(student["credits"].values())`
    等同于 `sum((9, 6, 7))`。
- en: 'Let us print the result of calling `decorate` with the first student:'
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们打印调用 `decorate` 时第一个学生的结果：
- en: '[PRE5]'
  id: totrans-46
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: If we decorate all the students like this, we can sort them on their total number
    of credits by just sorting the list of tuples. To apply the decoration to each
    item in `students` , we call `map(decorate, students)` . We sort the result, and
    then we undecorate in a similar fashion.
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们这样装饰所有学生，我们只需对元组列表进行排序，就可以根据他们的总学分数对他们进行排序。为了将装饰应用到 `students` 中的每个项上，我们调用
    `map(decorate, students)`。我们排序结果，然后以类似的方式取消装饰。
- en: 'Printing `students` after running the whole code yields the following:'
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 在运行整个代码后打印 `students` 会得到以下结果：
- en: '[PRE6]'
  id: totrans-49
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: As you can see, the student objects have indeed been sorted by the sums of their
    credits.
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 如您所见，学生对象确实是根据他们学分的总和进行排序的。
- en: 'For more on the *decorate-sort-undecorate* idiom, there is a good introduction
    in the *Sorting HOW TO* section of the official Python documentation:'
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 关于 *装饰-排序-取消装饰* 惯用，官方 Python 文档的 *排序 HOW TO* 部分有一个很好的介绍：
- en: '[https://docs.python.org/3.12/howto/sorting.html#decorate-sort-undecorate](https://docs.python.org/3.12/howto/sorting.html#decorate-sort-undecorate)'
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: '[https://docs.python.org/3.12/howto/sorting.html#decorate-sort-undecorate](https://docs.python.org/3.12/howto/sorting.html#decorate-sort-undecorate)'
- en: One thing to notice about the sorting part is what happens when two or more
    students share the same total sum. The sorting algorithm would then proceed to
    sort the tuples by comparing the `student` objects with each other. This does
    not make any sense and, in more complex cases, could lead to unpredictable results,
    or even errors. If you want to avoid this issue, one simple solution is to create
    a three-tuple instead of a two-tuple, having the sum of credits in the first position,
    the position of the `student` object in the original `students` list in second
    place, and the `student` object itself in third place. This way, if the sum of
    credits is the same, the tuples will be sorted against the position, which will
    always be different, and therefore enough to resolve the sorting between any pair
    of tuples.
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 在排序部分需要注意的一点是，当两个或多个学生的总分相同时会发生什么。排序算法将接着通过比较 `student` 对象来对元组进行排序。这没有任何意义，并且在更复杂的情况下可能会导致不可预测的结果，甚至错误。如果你想要避免这个问题，一个简单的解决方案是创建一个三重元组而不是双重元组，将学分总和放在第一个位置，`student`
    对象在原始 `students` 列表中的位置放在第二个位置，`student` 对象本身放在第三个位置。这样，如果学分总和相同，元组将根据位置进行排序，位置总是不同的，因此足以解决任何一对元组之间的排序问题。
- en: zip
  id: totrans-54
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: zip
- en: We have already covered `zip()` in the previous chapters, so let us just define
    it properly, after which we want to show you how you could combine it with `map()`
    .
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经在前面的章节中介绍了 `zip()`，所以让我们正确地定义它，之后我们想向你展示如何将它与 `map()` 结合使用。
- en: 'According to the Python documentation ( [https://docs.python.org/3/library/functions.html#zip](https://docs.python.org/3/library/functions.html#zip)
    ), the following applies:'
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 根据Python文档（[https://docs.python.org/3/library/functions.html#zip](https://docs.python.org/3/library/functions.html#zip)），以下适用：
- en: zip(*iterables, strict=False)
  id: totrans-57
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: zip(*iterables, strict=False)
- en: ''
  id: totrans-58
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '... returns an iterator of tuples, where the i-th tuple contains the i-th element
    from each of the argument iterables.'
  id: totrans-59
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '... 返回一个元组的迭代器，其中第 i 个元组包含来自每个参数可迭代对象的第 i 个元素。'
- en: ''
  id: totrans-60
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: Another way to think of zip() is that it turns rows into columns, and columns
    into rows. This is similar to transposing a matrix.
  id: totrans-61
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 另一种思考 `zip()` 的方式是它将行转换为列，将列转换为行。这与矩阵转置类似。
- en: 'Let us see an example:'
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看一个例子：
- en: '[PRE7]'
  id: totrans-63
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: Here, we are zipping together the average and the grade for the last exam for
    each student. Notice how easy it is to reproduce `zip()` using `map()` (the last
    two instructions of the example). Once again, we have to use `list()` to visualize
    the results.
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们将每个学生的平均分和最后一次考试的成绩进行组合。注意，使用 `map()`（示例中的最后两条指令）来重现 `zip()` 是多么简单。再次，我们必须使用
    `list()` 来可视化结果。
- en: 'Like `map()` , `zip()` will normally stop as soon as it reaches the end of
    the shortest iterable. This can, however, mask problems with the input data, leading
    to bugs. For example, suppose we need to combine a list of students’ names and
    a list of grades into a dictionary mapping each student’s name to their grade.
    A mistake in data entry could result in the list of grades being shorter than
    the list of students. Here is an example:'
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 与 `map()` 类似，`zip()` 通常会在到达最短可迭代对象的末尾时停止。然而，这可能会掩盖输入数据的问题，导致错误。例如，假设我们需要将学生名单和成绩列表合并到一个字典中，将每个学生的名字映射到他们的成绩。数据输入错误可能会导致成绩列表比学生名单短。以下是一个例子：
- en: '[PRE8]'
  id: totrans-66
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'Notice that there is no entry for `"Alice"` in the dictionary. The default
    behavior of `zip()` has masked the data error. For this reason, the `strict` keyword-only
    parameter was added in Python 3.10. If `zip()` receives `strict=True` as an argument,
    it raises an exception if the iterables do not all have the same length:'
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，字典中没有 `"Alice"` 的条目。`zip()` 的默认行为掩盖了数据错误。因此，在Python 3.10中添加了仅关键字参数 `strict`。如果
    `zip()` 接收到 `strict=True` 作为参数，当可迭代对象长度不相同时，它会引发异常：
- en: '[PRE9]'
  id: totrans-68
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: The `itertools` module also provides a `zip_longest()` function. It behaves
    like `zip()` but stops only when the longest iterable is exhausted. Shorter iterables
    are padded with a value that can be specified as an argument, which defaults to
    `None` .
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: '`itertools` 模块还提供了一个 `zip_longest()` 函数。它的行为类似于 `zip()`，但只有在最长的可迭代对象耗尽时才会停止。较短的迭代器将被指定为参数的值填充，默认为
    `None` 。'
- en: filter
  id: totrans-70
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: filter
- en: 'According to the Python documentation ( [https://docs.python.org/3/library/functions.html#filter](https://docs.python.org/3/library/functions.html#filter)
    ), the following applies:'
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 根据Python文档（[https://docs.python.org/3/library/functions.html#filter](https://docs.python.org/3/library/functions.html#filter)），以下适用：
- en: filter(function, iterable)
  id: totrans-72
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: filter(function, iterable)
- en: ''
  id: totrans-73
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: Construct an iterator from those elements of iterable for which function is
    true. iterable may be either a sequence, a container which supports iteration,
    or an iterator. If function is None, the identity function is assumed, that is,
    all elements of iterable that are false are removed.
  id: totrans-74
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 从可迭代对象中构建一个迭代器，该迭代器对于函数为真。可迭代对象可以是序列、支持迭代的容器或迭代器。如果函数是 None，则假定是恒等函数，即移除可迭代对象中所有为假的元素。
- en: 'Let us see a quick example:'
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看一个快速示例：
- en: '[PRE10]'
  id: totrans-76
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: Notice how the second call to `filter()` is equivalent to the first one. If
    we pass a function that takes one argument and returns the argument itself, only
    those arguments that are `True` will make the function return `True` . This behavior
    is the same as passing `None` . It is often a good exercise to mimic some of the
    built-in Python behaviors. When you succeed, you can say you fully understand
    how Python behaves in a specific situation.
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 注意到第二个 `filter()` 调用与第一个调用等效。如果我们传递一个接受一个参数并返回该参数本身的函数，只有那些使函数返回 `True` 的参数才会使函数返回
    `True`。这种行为与传递 `None` 相同。模仿一些内置的 Python 行为通常是一个很好的练习。当你成功时，你可以说你完全理解了 Python 在特定情况下的行为。
- en: 'Armed with `map()` , `zip()` , and `filter()` (and several other functions
    from the Python standard library), we can manipulate sequences very effectively.
    But these functions are not the only way to do it. Let us look at one of the most
    powerful features of Python: *comprehensions* .'
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 有了 `map()`、`zip()`、`filter()`（以及 Python 标准库中的几个其他函数），我们可以非常有效地操作序列。但这些都是实现方式之一。让我们看看
    Python 最强大的功能之一：*理解*。
- en: Comprehensions
  id: totrans-79
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 理解
- en: A comprehension is a concise notation for performing some operation on each
    element of a collection of objects, and/or selecting a subset of elements that
    satisfy some condition. They are borrowed from the functional programming language
    Haskell ( [https://www.haskell.org/](https://www.haskell.org/) ) and, together
    with iterators and generators, contribute to giving Python a functional flavor.
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 理解是一种对一组对象中的每个元素执行某些操作或选择满足某些条件的元素子集的简洁表示。它们借鉴了函数式编程语言 Haskell ([https://www.haskell.org/](https://www.haskell.org/))，并与迭代器和生成器一起，为
    Python 增添了函数式风格。
- en: 'Python offers several types of comprehensions: list, dictionary, and set. We
    will concentrate on list comprehensions; once you understand them, the other types
    will be easy to grasp.'
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: Python 提供了多种类型的理解：列表、字典和集合。我们将专注于列表理解；一旦你理解了它们，其他类型就会很容易掌握。
- en: 'Let us start with a simple example. We want to calculate a list with the squares
    of the first 10 natural numbers. We could use a `for` loop and append a square
    to the list in each iteration:'
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们从简单的例子开始。我们想要计算一个包含前 10 个自然数的平方的列表。我们可以使用 `for` 循环并在每次迭代中将一个平方数追加到列表中：
- en: '[PRE11]'
  id: totrans-83
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'This is not very elegant as we have to initialize the list first. With `map()`
    , we can achieve the same thing in just one line of code:'
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 这不是很优雅，因为我们必须首先初始化列表。使用 `map()`，我们可以在一行代码中实现相同的功能：
- en: '[PRE12]'
  id: totrans-85
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'Now, let us see how to achieve the same result using a list comprehension:'
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们看看如何使用列表理解达到相同的结果：
- en: '[PRE13]'
  id: totrans-87
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'This is much easier to read, and we no longer need to use a lambda. We have
    placed a `for` loop within square brackets. Let us now filter out the odd squares.
    We will show you how to do it with `map()` and `filter()` first, before then using
    a list comprehension again:'
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 这更容易阅读，我们不再需要使用 lambda。我们已经在方括号内放置了一个 `for` 循环。现在让我们过滤掉奇数平方。我们首先会展示如何使用 `map()`
    和 `filter()` 来实现，然后再使用列表理解：
- en: '[PRE14]'
  id: totrans-89
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'We think that the difference in readability is now evident. The list comprehension
    reads much better. It is almost English: give us all squares ( `n**2` ) for `n`
    between 0 and 9 if `n` is even.'
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 我们认为，现在可读性的差异已经很明显。列表理解读起来更顺畅。它几乎就像英语：如果 n 是偶数，请给出 0 到 9 之间所有平方数（`n**2`）。
- en: 'According to the Python documentation ( [https://docs.python.org/3.12/tutorial/datastructures.html#list-comprehensions](https://docs.python.org/3.12/tutorial/datastructures.html#list-comprehensions)
    ), the following is true:'
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 根据 Python 文档 ([https://docs.python.org/3.12/tutorial/datastructures.html#list-comprehensions](https://docs.python.org/3.12/tutorial/datastructures.html#list-comprehensions))，以下是真的：
- en: A list comprehension consists of brackets containing an expression followed
    by a for clause, then zero or more for or if clauses. The result will be a new
    list resulting from evaluating the expression in the context of the for and if
    clauses which follow it.
  id: totrans-92
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 列表理解由包含一个表达式、后跟一个 `for` 子句、然后是零个或多个 `for` 或 `if` 子句的括号组成。结果将是一个新列表，该列表是在评估随后的
    `for` 和 `if` 子句的上下文中的表达式后生成的。
- en: Nested comprehensions
  id: totrans-93
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 嵌套列表推导
- en: 'Let us see an example of nested loops. This is quite common because many algorithms
    involve iterating on a sequence using two placeholders. The first one runs through
    the whole sequence, left to right. The second one does, too, but it starts from
    the first one, instead of 0. The concept is that of testing all pairs without
    duplication. Let us see the classical `for` loop equivalent:'
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看嵌套循环的一个例子。这相当常见，因为许多算法都涉及使用两个占位符迭代一个序列。第一个占位符从左到右遍历整个序列。第二个占位符也这样做，但它从第一个占位符开始，而不是从0开始。这个概念是测试所有对而不重复。让我们看看经典的`for`循环等效：
- en: '[PRE15]'
  id: totrans-95
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'If you print `pairs` at the end, you get the following:'
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您在最后打印`pairs`，您将得到以下内容：
- en: '[PRE16]'
  id: totrans-97
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'All the tuples with the same letter are those where `b` is at the same position
    as `a` . Now, let us see how we can translate this to a list comprehension:'
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 所有具有相同字母的元组都是那些`b`位于与`a`相同位置的元组。现在，让我们看看我们如何将这个转换成列表推导：
- en: '[PRE17]'
  id: totrans-99
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: Notice that because the `for` loop over `b` depends on `a` , it must come after
    the `for` loop over `a` in the comprehension. If you swap them around, you will
    get a name error.
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，因为`for`循环中的`b`依赖于`a`，所以在推导中它必须位于`a`的`for`循环之后。如果您交换它们的位置，您将得到一个命名错误。
- en: Another way of achieving the same result is to use the `combinations_with_replacement()`
    function from the `itertools` module (which we briefly introduced in *Chapter
    3* , *Conditionals and Iteration* ). You can read more about it in the official
    Python documentation.
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 实现相同结果的另一种方法是使用`itertools`模块中的`combinations_with_replacement()`函数（我们在*第3章*，*条件与迭代*中简要介绍了它）。您可以在官方Python文档中了解更多信息。
- en: Filtering a comprehension
  id: totrans-102
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 推导的过滤
- en: We can also apply filtering to a comprehension. Let us first do it with `filter()`
    , and find all Pythagorean triples whose short sides are numbers smaller than
    10. A **Pythagorean triple** is a triple *(a, b, c)* of integer numbers satisfying
    the equation *a* ² *+ b* ² *= c* ² .
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 我们也可以将过滤应用于推导。让我们首先使用`filter()`，找到所有短边小于10的毕达哥拉斯三元组。**毕达哥拉斯三元组**是一组满足方程*a² +
    b² = c²*的整数数的三元组*(a, b, c)*。
- en: 'We obviously do not want to test a combination twice, and therefore, we will
    use a trick similar to the one we saw in the previous example:'
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 我们显然不希望测试组合两次，因此，我们将使用与上一个示例中看到类似的技巧：
- en: '[PRE18]'
  id: totrans-105
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: In the preceding code, we generated a list of *three-tuples* , `triples` . Each
    tuple contains two integer numbers (the legs), and the hypotenuse of the Pythagorean
    triangle, whose legs are the first two numbers in the tuple. For example, when
    `a` is 3 and `b` is 4, the tuple will be `(3, 4, 5.0)` , and when `a` is 5 and
    `b` is 7, the tuple will be `(5, 7, 8.602325267042627)` .
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的代码中，我们生成了一组*三元组*，`triples`。每个元组包含两个整数数（两腿），以及勾股三角形的斜边，其两腿是元组中的前两个数。例如，当`a`是3且`b`是4时，元组将是`(3,
    4, 5.0)`，当`a`是5且`b`是7时，元组将是`(5, 7, 8.602325267042627)`。
- en: After generating all the `triples` , we need to filter out all those where the
    hypotenuse is not an integer number. To achieve this, we filter based on `float_number.is_integer()`
    being `True` . This means that of the two example tuples we just showed you, the
    one with hypotenuse `5.0` will be retained, while the one with the `8.602325267042627`
    hypotenuse will be discarded.
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 在生成所有`triples`之后，我们需要过滤掉那些斜边不是整数数的所有情况。为了实现这一点，我们根据`float_number.is_integer()`为`True`进行过滤。这意味着在我们刚刚向您展示的两个示例元组中，斜边为`5.0`的那个将被保留，而斜边为`8.602325267042627`的那个将被丢弃。
- en: 'This is good, but we do not like the fact that the triple has two integer numbers
    and a float—they are all supposed to be integers. We can use `map()` to fix this:'
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 这很好，但我们不喜欢三元组中有两个整数数和一个浮点数——它们都应该都是整数。我们可以使用`map()`来解决这个问题：
- en: '[PRE19]'
  id: totrans-109
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'Notice the step we added. We slice each element in `triples` , taking only
    the first two elements. Then, we concatenate the slice with a one-tuple, containing
    the integer version of that float number that we did not like. This code is getting
    quite complicated. We can achieve the same result with a much simpler list comprehension:'
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 注意我们添加的步骤。我们切片`triples`中的每个元素，只取前两个元素。然后，我们将切片与包含我们不喜欢的那浮点数的整数版本的单一元组连接起来。这段代码变得越来越复杂。我们可以用更简单的列表推导来实现相同的结果：
- en: '[PRE20]'
  id: totrans-111
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'That is cleaner, easier to read, and shorter. There is still room for improvement,
    though. We are still wasting memory by constructing a list with many triples that
    we end up discarding. We can fix that by combining the two comprehensions into
    one:'
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 这样更简洁、更易读、更短。尽管如此，仍有改进的空间。我们仍然在构建一个包含许多最终会被丢弃的三元组的列表中浪费内存。我们可以通过将两个推导式合并为一个来解决这个问题：
- en: '[PRE21]'
  id: totrans-113
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: Now that is elegant. By generating the triples and filtering them in the same
    list comprehension, we avoid keeping any triple that does not pass the test in
    memory. Notice that we used an `assignment expression` to avoid needing to compute
    the value of `sqrt(a**2 + b**2)` twice.
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 现在这是优雅的。通过在同一个列表推导式中生成三元组和过滤它们，我们避免了在内存中保留任何未通过测试的三元组。注意，我们使用了一个`赋值表达式`来避免需要两次计算`sqrt(a**2
    + b**2)`的值。
- en: Dictionary comprehensions
  id: totrans-115
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 字典推导式
- en: 'Dictionary comprehensions work exactly like list comprehensions, but to construct
    dictionaries. There is only a slight difference in the syntax. The following example
    will suffice to explain everything you need to know:'
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 字典推导式与列表推导式的工作方式完全相同，但用于构建字典。在语法上只有细微的差别。以下示例足以解释你需要知道的一切：
- en: '[PRE22]'
  id: totrans-117
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'If you print `lettermap` , you will see the following:'
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你打印`lettermap`，你会看到以下内容：
- en: '[PRE23]'
  id: totrans-119
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: In the preceding code, we are enumerating the sequence of all lowercase ASCII
    letters (using the `enumerate` function). We then construct a dictionary with
    the resulting letter/number pairs as keys and values. Notice how the syntax is
    similar to the familiar dictionary syntax.
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的代码中，我们正在枚举所有小写ASCII字母的序列（使用`enumerate`函数）。然后我们构建一个字典，将结果字母/数字对作为键和值。注意语法与熟悉的字典语法相似。
- en: 'There is also another way to do the same thing:'
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 还有另一种做同样事情的方法：
- en: '[PRE24]'
  id: totrans-122
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: In this case, we are feeding a generator expression (we will talk more about
    these later in this chapter) to the `dict` constructor.
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 在这种情况下，我们向`dict`构造函数提供了一个生成器表达式（我们将在本章后面更多地讨论这些内容）。
- en: 'Dictionaries do not allow duplicate keys, as shown in the following example:'
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 字典不允许重复键，如下例所示：
- en: '[PRE25]'
  id: totrans-125
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'We create a dictionary with the letters of the string `"Hello"` as keys and
    the same letters, but with the case swapped, as values. Notice that there is only
    one `"l": "L"` pair. The constructor does not complain; it simply reassigns duplicates
    to the last value. Let us make this clearer with another example that assigns
    to each key its position in the string:'
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: '我们创建了一个字典，以字符串`"Hello"`中的字母作为键，以相同字母但大小写互换作为值。注意，只有一个`"l": "L"`对。构造函数不会抱怨；它只是将重复的值重新分配给最后一个值。让我们用一个将每个键分配到字符串中位置的另一个例子来使这一点更清晰：'
- en: '[PRE26]'
  id: totrans-127
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: 'Notice the value associated with the letter `l: 3` . The `l: 2` pair is not
    there; it has been overridden by `l: 3` .'
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: '注意与字母`l`关联的值：`3`。`l: 2`对不存在；它已被`l: 3`覆盖。'
- en: Set comprehensions
  id: totrans-129
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 集合推导式
- en: 'Set comprehensions are similar to list and dictionary ones. Let us see one
    quick example:'
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 集合推导式与列表和字典推导式类似。让我们看一个快速示例：
- en: '[PRE27]'
  id: totrans-131
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: Notice how for set comprehensions, as for dictionaries, duplication is not allowed,
    and therefore the resulting set has only four letters. Also, notice that the expressions
    assigned to `letters1` and `letters2` produce equivalent sets.
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，对于集合推导式，就像字典一样，不允许重复，因此结果集合只有四个字母。此外，注意分配给`letters1`和`letters2`的表达式产生等效的集合。
- en: The syntax used to create `letters1` is similar to that of a dictionary comprehension.
    You can spot the difference only by the fact that dictionaries require keys and
    values, separated by colons, while sets do not. For `letters2` , we fed a generator
    expression to the `set()` constructor.
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 创建`letters1`使用的语法与字典推导式类似。你只能通过以下事实来发现差异：字典需要键和值，通过冒号分隔，而集合不需要。对于`letters2`，我们向`set()`构造函数提供了一个生成器表达式。
- en: Generators
  id: totrans-134
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 生成器
- en: '**Generators** are based on the concept of *iteration* , as we said before,
    and they allow coding patterns that combine elegance with efficiency.'
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: '**生成器**基于我们之前提到的**迭代**概念，并允许结合优雅与效率的编码模式。'
- en: 'Generators are of two types:'
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 生成器有两种类型：
- en: '**Generator functions** : These are similar to regular functions, but instead
    of returning results through `return` statements, they use `yield` , which allows
    them to suspend and resume their state between each call.'
  id: totrans-137
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**生成器函数**：这些与常规函数类似，但它们不是通过`return`语句返回结果，而是使用`yield`，这允许它们在每次调用之间挂起和恢复其状态。'
- en: '**Generator expressions** : These are similar to the list comprehensions we
    have seen in this chapter, but instead of returning a list, they return an object
    that produces results one by one.'
  id: totrans-138
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**生成器表达式**：这些与我们在本章中看到的列表推导式类似，但它们返回的对象会逐个产生结果。'
- en: Generator functions
  id: totrans-139
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 生成器函数
- en: 'Generator functions behave like regular functions in all respects, except for
    one difference: instead of collecting results and returning them at once, they
    are automatically turned into iterators that yield results one at a time.'
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 生成器函数在所有方面都表现得像常规函数，只有一个区别：它们不是一次性收集结果并返回，而是自动转换为迭代器，一次产生一个结果。
- en: Suppose we asked you to count from 1 to 1,000,000. You start, and at some point,
    we ask you to stop. After some time, we ask you to resume. As long as you can
    remember the last number you reached, you will be able to continue where you left
    off. For example, if we stopped you after 31,415, you would just go on with 31,416,
    and so on. The point is that you do not need to remember all the numbers you said
    before 31,415, nor do you need them to be written down somewhere. Generators behave
    in much the same way.
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 假设我们要求你从1数到1,000,000。你开始数，在某个时刻，我们要求你停下来。过了一段时间，我们要求你继续。只要你记得你最后到达的数字，你就能从你离开的地方继续。例如，如果我们在你数到31,415后停下来，你就可以从31,416继续数下去。关键是，你不需要记住你之前说的所有数字，也不需要将它们写下来。生成器的行为与此非常相似。
- en: 'Take a good look at the following code:'
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 仔细看看下面的代码：
- en: '[PRE28]'
  id: totrans-143
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: 'The result of the two `print` statements will be the same: `[0, 1, 4, 9, 16,
    25, 36, 49, 64, 81]` . But there is an important difference between the two functions.
    `get_squares()` is a classic function that collects all the squares of numbers
    in *[0, n)* in a list, and returns it. On the other hand, `get_squares_gen()`
    is a generator and behaves differently. Each time the interpreter reaches the
    `yield` line, its execution is suspended. The only reason those `print` statements
    return the same result is because we fed `get_squares_gen()` to the `list()` constructor,
    which exhausts the generator completely by asking for the next element until a
    `StopIteration` is raised. Let us see this in detail:'
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 两个`print`语句的结果将是相同的：`[0, 1, 4, 9, 16, 25, 36, 49, 64, 81]`。但这两个函数之间有一个重要的区别。`get_squares()`是一个经典函数，它将*[0,
    n)*区间内所有数字的平方收集到一个列表中，并返回它。另一方面，`get_squares_gen()`是一个生成器，其行为不同。每次解释器到达`yield`行时，它的执行就会暂停。那些`print`语句返回相同结果的原因仅仅是因为我们将`get_squares_gen()`传递给了`list()`构造函数，它通过请求下一个元素直到抛出`StopIteration`异常来完全耗尽生成器。让我们详细看看这一点：
- en: '[PRE29]'
  id: totrans-145
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: Each time we call `next()` on the generator object, we either start it (the
    first `next()` ) or make it resume from the last suspension point (any other `next()`
    ). The first time we call `next()` on it, we get 0, which is the square of 0,
    then 1, then 4, then 9, and since the `for` loop stops after that ( `n` is 4),
    the generator naturally ends. A classic function would at that point just return
    `None` , but to comply with the iteration protocol, a generator will instead raise
    a `StopIteration` exception.
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 每次我们对生成器对象调用`next()`时，我们要么启动它（第一次`next()`），要么从最后一个暂停点恢复（任何其他`next()`）。我们第一次调用`next()`时，得到0，这是0的平方，然后是1，然后是4，然后是9，由于`for`循环在那之后停止（`n`是4），生成器自然结束。在这一点上，一个经典函数会简单地返回`None`，但为了遵守迭代协议，生成器会抛出一个`StopIteration`异常。
- en: This explains how a `for` loop works. When you call `for k in range(n)` , what
    happens under the hood is that the `for` loop gets an iterator out of `range(n)`
    and starts calling `next` on it, until `StopIteration` is raised, which tells
    the `for` loop that the iteration has reached its end.
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 这解释了`for`循环的工作原理。当你调用`for k in range(n)`时，幕后发生的事情是`for`循环从`range(n)`中获取一个迭代器，并开始调用它的`next`方法，直到抛出`StopIteration`异常，这告诉`for`循环迭代已达到其结束。
- en: Having this behavior built into every iteration aspect of Python makes generators
    even more powerful because once we have written them, we will be able to plug
    them into whatever iteration mechanism we want.
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 将这种行为内置到Python的每个迭代方面，使得生成器更加强大，因为一旦我们编写了它们，我们就能将它们插入到我们想要的任何迭代机制中。
- en: At this point, you are probably asking yourself why you would want to use a
    generator instead of a regular function. The answer is to save time and (especially)
    memory.
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，你可能正在问自己，为什么你想使用生成器而不是常规函数。答案是节省时间和（尤其是）内存。
- en: 'We will talk more about performance later, but for now, let us concentrate
    on one aspect: sometimes, generators allow you to do something that would not
    be possible with a simple list. For example, say you want to analyze all permutations
    of a sequence. If the sequence has a length of *N* , then the number of its permutations
    is *N!* . This means that if the sequence is 10 elements long, the number of permutations
    is 3,628,800. But a sequence of 20 elements would have 2,432,902,008,176,640,000
    permutations. They grow factorially.'
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
- en: Now imagine you have a classic function that is attempting to calculate all
    permutations, put them in a list, and return it to you. With 10 elements, it would
    require probably a few seconds, but for 20 elements there is simply no way that
    it could be done (it would take thousands of years and require billions of gigabytes
    of memory).
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
- en: 'On the other hand, a generator function will be able to start the computation
    and give you back the first permutation, then the second, and so on. Of course,
    you will not have the time to process them all—there are too many—but at least
    you will be able to work with some of them. Sometimes the amount of data you have
    to iterate over is so huge that you cannot keep it all in memory in a list. In
    this case, generators are invaluable: they make possible that which otherwise
    would not be.'
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
- en: So, to save memory (and time), use generator functions whenever possible.
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
- en: 'It is also worth noting that you can use the `return` statement in a generator
    function. It will cause a `StopIteration` exception to be raised, effectively
    ending the iteration. If a `return` statement were to make the function return
    something, it would break the iteration protocol. Python’s consistency prevents
    this and allows us great ease when coding. Let us see a quick example:'
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  id: totrans-155
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: 'The preceding code yields all terms of the geometric progression, *a, aq, aq2,
    aq3, ...* . When the progression produces a term that is greater than 100,000,
    the generator stops (with a `return` statement). Running the code produces the
    following result:'
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  id: totrans-157
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: The next term would have been `156250` , which is too big.
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
- en: Going beyond next
  id: totrans-159
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Generator objects have methods that allow us to control their behavior: `send()`
    , `throw()` , and `close()` . The `send()` method allows us to communicate a value
    back to the generator object, while `throw()` and `close()` , respectively, allow
    us to raise an exception within the generator and close it. Their use is quite
    advanced, and we will not be covering them here in detail, but we want to spend
    a few words on `send()` , with a simple example:'
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  id: totrans-161
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: 'The preceding iterator creates a generator object that will run forever. You
    can keep calling it, and it will never stop. But what if you wanted to stop it
    at some point? One solution is to use a global variable to control the `while`
    loop:'
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  id: totrans-163
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: We initially set `stop = False` , and until we change it to `True` , the generator
    will just keep going, like before. After we change `stop` to `True` though, the
    `while` loop will exit, and the following call to `next` will raise a `StopIteration`
    exception. This trick works, but it is not a satisfactory solution. The function
    depends on an external variable, which can lead to problems. For example, the
    generator could inadvertently be stopped if another, unrelated function changes
    the global variable. Functions should ideally be self-contained and not rely on
    a global state.
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
- en: 'The generator `send()` method takes a single argument, which is passed into
    the generator function as the value of the `yield` expression. We can use this
    to pass a flag value into the generator to signal that it should stop:'
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE34]'
  id: totrans-166
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: 'Executing this code produces the following output:'
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE35]'
  id: totrans-168
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: We think it is worth going through this code line by line, as if we were executing
    it, to see whether we can understand what is going on.
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
- en: We start the generator execution with a call to `next()` ( `#C` ). Within the
    generator, `n` is set to the same value as `start` . The `while` loop is entered,
    execution stops ( `#A` ), and `n` ( `0` ) is yielded back to the caller. `0` is
    printed on the console.
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
- en: We then call `send()` ( `#D` ), execution resumes, `result` is set to `"Wow!"`
    (still `#A` ), and its type and value are printed on the console ( `#B` ). `result`
    is not `"Q"` , so `n` is incremented by 1 and execution goes back to the top of
    the loop. The `while` condition is `True` , so another iteration of the loop is
    started. Execution again stops at `#A` , and `n` ( `1` ) is yielded back to the
    caller. `1` is printed on the console.
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
- en: At this point, we call `next()` ( `#E` ), execution is resumed ( `#A` ), and
    because we are not sending anything to the generator explicitly, the `yield n`
    expression ( `#A` ) returns `None` (the behavior is the same as when we call a
    function that does not return anything). `result` is therefore set to `None` ,
    and its type and value are again printed on the console ( `#B` ). Execution continues,
    `result` is not `"Q"` , so `n` is incremented by 1, and we start another loop
    again. Execution stops again ( `#A` ) and `n` ( `2` ) is yielded back to the caller.
    `2` is printed on the console.
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
- en: Now we call `send` again ( `#F` ), this time passing the argument `"Q"` . The
    generator resumes, `result` is set to `"Q"` ( `#A` ), and its type and value are
    printed on the console again ( `#B` ). When we reach the `if` statement again,
    `result == "Q"` evaluates to `True` , and the `while` loop is stopped by the `break`
    statement. The generator naturally terminates, which means a `StopIteration` exception
    is raised. You can see the traceback of the exception in the last few lines printed
    on the console.
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
- en: This is not at all simple to understand at first, so if it is not clear to you,
    do not be discouraged. You can keep reading and come back to this example later.
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
- en: Using `send()` allows for interesting patterns, and it is worth noting that
    `send()` can also be used to start the execution of a generator (provided you
    call it with `None` ).
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
- en: The yield from expression
  id: totrans-176
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Another interesting construct is the `yield from` expression. This expression
    allows you to yield values from a sub-iterator. Its use allows for quite advanced
    patterns, so let us see a quick example of it:'
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE36]'
  id: totrans-178
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: 'The code above prints the numbers `4` , `9` , and `16` on the console (on separate
    lines). By now, we expect you to be able to understand it by yourself, but let
    us quickly recap what happens. The `for` loop outside the function gets an iterator
    from `print_squares(2, 5)` and calls `next()` on it until iteration is over. Every
    time the generator is called, execution is suspended (and later resumed) on `yield
    n**2` , which returns the square of the current `n` . Let us see how we could
    use a `yield from` expression to achieve the same result:'
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE37]'
  id: totrans-180
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: This code produces the same result, but as you can see, `yield from` is actually
    running a sub-iterator, `(n**2 ...)` . The `yield from` expression returns to
    the caller each value the sub-iterator is producing. It is shorter and reads better.
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
- en: Generator expressions
  id: totrans-182
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In addition to generator functions, generators can also be created using **generator
    expressions** . The syntax to create a generator expression is the same as for
    a list comprehension, except that we use round brackets instead of square brackets.
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
- en: A generator expression will generate the same sequence of values as an equivalent
    list comprehensions. However, instead of immediately creating a list object containing
    the entire sequence in memory, the generator will yield the values one at a time.
    It is important to remember that you can only iterate over a generator once. After
    that, it will be exhausted.
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
- en: 'Let us see an example:'
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE38]'
  id: totrans-186
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: As you can see from the output when we try to print it, `cubes_gen` is a generator
    object. To see the values it generates, we can use a `for` loop or a manual set
    of calls to `next` , or simply feed it to a `list()` constructor, which is what
    we did.
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
- en: Notice how, once the generator has been exhausted, there is no way to recover
    the same elements from it again. We need to recreate it if we want to use it from
    scratch again.
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
- en: 'In the next few examples, let us see how to reproduce `map()` and `filter()`
    using generator expressions. First, let’s look at `map()` :'
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE39]'
  id: totrans-190
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: In the previous example, `s1` and `s2` are both equal to the sum of `adder(0,
    1)` , `adder(1, 2)` , `adder(2, 3)` , and so on, which translates to `sum(1, 3,
    5, ...)` . We find the generator expression syntax to be much more readable, though.
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
- en: 'Now for `filter()` :'
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE40]'
  id: totrans-193
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: 'In this example, `odd_cubes1` and `odd_cubes2` are equivalent: they generate
    a sequence of odd cubes. Yet again, we prefer the generator syntax. This should
    be evident when things get a little more complicated:'
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE41]'
  id: totrans-195
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: 'The preceding code creates two iterators, `cubes1` and `cubes2` . Both will
    yield the same sequence of tuples *(n, n3)* where `n` is a multiple of 3 or 5.
    If you print the list of values obtained from either, you get the following: `[(0,
    0), (3, 27), (5, 125), (6, 216), (9, 729), (10, 1000), (12, 1728), (15, 3375),
    (18, 5832)]` .'
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
- en: Notice that the generator expression is much easier to read. It may be debatable
    for trivial examples, but as soon as you start performing more complex operations,
    the superiority of the generator syntax is evident. It is shorter, simpler, and
    more elegant.
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, let us ask you: what is the difference between the following lines of
    code?'
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE42]'
  id: totrans-199
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: Strictly speaking, they all produce the same sum. The expressions to get `s2`
    and `s3` are equivalent because the brackets in `s2` are redundant. Both are generator
    expressions passed to the `sum()` function.
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
- en: The expression to get `s1` is different, though. Here we are passing the result
    of a list comprehension to `sum()` . This wastes both time and memory because
    we first create a list of a million elements (which has to be stored in memory).
    We then pass the list to `sum` , which iterates over it, after which we discard
    the list. It is much better to use a generator expression, as we do not need to
    wait for a list to be constructed, and we do not need to store the entire sequence
    of 1 million values in memory.
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
- en: 'So, *watch out for extra parentheses when you write your expressions* . Details
    like this are easy to miss, but they can make a significant difference. For example,
    look at the following code:'
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE43]'
  id: totrans-203
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: 'If we run this, we get:'
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE44]'
  id: totrans-205
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: 'On the other hand, if we comment out the first line, and uncomment the second
    one, this is the result:'
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE45]'
  id: totrans-207
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: The difference between the two lines is that in the first, the Python interpreter
    must construct a list with the squares of the first ten billion numbers to pass
    to the `sum` function. That list is huge, and we ran out of memory, so the operating
    system killed the process.
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
- en: When we remove the square brackets, we no longer have a list. The `sum` function
    receives a generator, which yields 0, 1, 4, 9, and so on, and computes the sum
    without needing to keep all the values in memory.
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
- en: Some performance considerations
  id: totrans-210
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: There are usually multiple ways of achieving the same result. We can use any
    combination of `map()` , `zip()` , and `filter()` , or choose to go with a comprehension
    or a generator. We may even decide to go with `for` loops. Readability is often
    a factor in choosing between these approaches. List comprehensions or generator
    expressions are often easier to read than complex combinations of `map()` and
    `filter()` . For more complicated operations, generator functions or `for` loops
    are often better.
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
- en: 'Besides readability concerns, however, we must also consider performance when
    deciding which approach to use. There are two factors that need to be considered
    when comparing the performance of different implementations: `space` and `time`
    .'
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
- en: Space refers to the amount of memory that your data structures are going to
    use. The best way to choose is to ask yourself if you really need a list (or tuple),
    or whether a generator would work instead.
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
- en: 'If the answer is yes to the latter, go with the generator, as it will save
    a lot of space. The same goes for functions: if you do not actually need them
    to return a list or tuple, then you can transform them into generator functions
    as well.'
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
- en: Sometimes, you will have to use lists (or tuples); for example, there are algorithms
    that scan sequences using multiple pointers, and others need to iterate over the
    sequence more than once. A generator (function or expression) can be iterated
    over only once before it is exhausted, so in these situations, it would not be
    the right choice.
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
- en: Time is a bit more complicated than space because it depends on more variables,
    and it is not always possible to state that *X is faster than Y* with absolute
    certainty for all cases. However, based on tests run on Python today, we can say
    that on average, `map()` exhibits performance similar to comprehensions and generator
    expressions, while `for` loops are consistently slower.
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
- en: To appreciate the reasoning behind these statements fully, we need to understand
    how Python works, which is a bit outside the scope of this book as it is quite
    technical and detailed. Let us just say that `map()` and comprehensions run at
    C language speed within the interpreter, while a Python `for` loop is run as Python
    bytecode within the Python Virtual Machine, which is often much slower.
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
- en: There are several different implementations of Python. The original one, and
    still the most common one, is CPython ( [https://github.com/python/cpython](https://github.com/python/cpython)
    ), which is written in C. C is one of the most powerful and popular programming
    languages still used today.
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
- en: 'In the rest of this section, we will perform some simple experiments to verify
    these performance claims. We will write a small piece of code that collects the
    results of `divmod(a, b)` for a set of integer pairs, `(a, b)` . We will use the
    `time()` function from the `time` module to calculate the elapsed time of the
    operations that we perform:'
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE46]'
  id: totrans-220
  prefs: []
  type: TYPE_PRE
  zh: '[PRE46]'
- en: 'As you can see, we are creating three lists: `floop` , `compr` , and `gener`
    . Running the code produces the following:'
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE47]'
  id: totrans-222
  prefs: []
  type: TYPE_PRE
  zh: '[PRE47]'
- en: The list comprehension runs in ~71% of the time taken by the `for` loop. The
    generator expression was slightly faster than that, with ~69%. The difference
    in time between the list comprehension and generator expression is hardly significant,
    and if you re-run the example a few times, you will probably also see the list
    comprehension take less time than the generator expression.
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
- en: It is worth noting that, within the body of the `for` loop, we are appending
    data to a list. This implies that, behind the scenes, the Python interpreter occasionally
    has to resize the list to allocate space for more items to be appended. We guessed
    that creating a list of zeros, and simply filling it with the results, might have
    sped up the `for` loop, but we were wrong. Try it for yourself; you just need
    `mx * (mx - 1) // 2` elements to be pre-allocated.
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
- en: The approach we used here for timing execution is rather naïve. In *Chapter
    11* , *Debugging and Profiling* , we will look at better ways of profiling code
    and timing execution.
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
- en: 'Let us see a similar example that compares a `for` loop and a `map()` call:'
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE48]'
  id: totrans-227
  prefs: []
  type: TYPE_PRE
  zh: '[PRE48]'
- en: 'This code is conceptually similar to the previous example. The only thing that
    has changed is that we are applying the `abs()` function instead of `divmod()`
    , and we have only one loop instead of two nested ones. Execution gives the following
    result:'
  id: totrans-228
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE49]'
  id: totrans-229
  prefs: []
  type: TYPE_PRE
  zh: '[PRE49]'
- en: 'This time, `map` was the fastest: it took ~53% of the time required by the
    list comprehension, and ~31% of the time needed by the `for` loop.'
  id: totrans-230
  prefs: []
  type: TYPE_NORMAL
- en: The results from these experiments give us a rough indication of the relative
    speed of `for` loops, list comprehensions, generator expressions, and the `map()`
    function. Do not rely too heavily on these results though, as the experiments
    we performed here are rather simplistic, and accurately measuring and comparing
    execution times is difficult. Measurements can easily be affected by several factors,
    such as other processes running on the same computer. Performance results are
    also heavily dependent on the hardware, operating system, and Python version.
  id: totrans-231
  prefs: []
  type: TYPE_NORMAL
- en: It is clear that `for` loops are slower than comprehensions or `map()` , so
    it is worth discussing why we nevertheless often prefer them over the alternatives.
  id: totrans-232
  prefs: []
  type: TYPE_NORMAL
- en: Do not overdo comprehensions and generators
  id: totrans-233
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We have seen how powerful comprehensions and generator expressions can be. However,
    we find that the more you try to do within a single comprehension or generator
    expression, the harder it becomes to read, understand, and therefore maintain
    or change.
  id: totrans-234
  prefs: []
  type: TYPE_NORMAL
- en: 'If you consider the Zen of Python again, there are a few lines that, we think,
    are worth keeping in mind when dealing with optimized code:'
  id: totrans-235
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE50]'
  id: totrans-236
  prefs: []
  type: TYPE_PRE
  zh: '[PRE50]'
- en: Comprehensions and generator expressions are more implicit than explicit, can
    be quite difficult to read and understand, and can be difficult to explain. Sometimes,
    you have to break them apart using the inside-out technique to understand what
    is going on.
  id: totrans-237
  prefs: []
  type: TYPE_NORMAL
- en: To give you an example, let us talk a bit more about Pythagorean triples. Just
    to remind you, a Pythagorean triple is a tuple of positive integers *(a, b, c)*
    such that *a* ² *+ b* ² *= c* ² . We saw how to calculate them in the *Filtering
    a comprehension* section, but we did it in a very inefficient way. We scanned
    all pairs of numbers below a certain threshold, calculating the hypotenuse, and
    filtering out those that were not valid Pythagorean triples.
  id: totrans-238
  prefs: []
  type: TYPE_NORMAL
- en: 'A better way to get a list of Pythagorean triples is to generate them directly.
    There are many different formulas you can use to do this; here we will use the
    **Euclidean formula** . This formula says that any triple *(a, b, c)* , where
    *a = m* ² *- n* ² *, b = 2mn* and *c = m* ² *+ n* ² , with *m* and *n* positive
    integers such that *m > n* , is a Pythagorean triple. For example, when *m = 2*
    and *n = 1* , we find the smallest triple: *(3, 4, 5)* .'
  id: totrans-239
  prefs: []
  type: TYPE_NORMAL
- en: 'There is one catch though: consider the triple *(6, 8, 10)* , which is like
    *(3, 4, 5)* , only all the numbers are multiplied by *2* . This triple is Pythagorean,
    since *6* ² *+ 8* ² *= 10* ² , but we can derive it from *(3, 4, 5)* simply by
    multiplying each of its elements by *2* . The same goes for *(9, 12, 15)* , *(12,
    16, 20)* , and in general for all the triples that we can write as *(3k, 4k, 5k)*
    , with *k* being a positive integer greater than *1* .'
  id: totrans-240
  prefs: []
  type: TYPE_NORMAL
- en: 'A triple that cannot be obtained by multiplying the elements of another one
    by some factor, *k* , is called **primitive** . Another way of stating this is
    as follows: if the three elements of a triple are **coprime** , then the triple
    is primitive. Two numbers are coprime when they do not share any prime factor
    among their divisors, that is, when their **greatest common divisor** ( **GCD**
    ) is *1* . For example, 3 and 5 are coprime, while 3 and 6 are not because they
    are both divisible by 3.'
  id: totrans-241
  prefs: []
  type: TYPE_NORMAL
- en: 'The Euclidean formula tells us that if *m* and *n* are coprime, and *m - n*
    is odd, the triple they generate is *primitive* . In the following example, we
    will write a generator expression to calculate all the primitive Pythagorean triples
    whose hypotenuse, *c* , is less than or equal to some integer, *N* . This means
    we want all triples for which *m* ² *+ n* ² *≤ N* . When *n* is *1* , the formula
    looks like this: *m* ² *≤ N - 1* , which means we can approximate the calculation
    with an upper bound of *m ≤ N* ^(1/2) .'
  id: totrans-242
  prefs: []
  type: TYPE_NORMAL
- en: 'To recap: *m* must be greater than *n* , they must also be coprime, and their
    difference *m - n* must be odd. Moreover, to avoid useless calculations, we will
    put the upper bound for *m* at *floor(sqrt(N)) + 1* .'
  id: totrans-243
  prefs: []
  type: TYPE_NORMAL
- en: The `floor` function for a real number, *x* , gives the maximum integer, *n*
    , such that *n < x* , for example, *floor(3.8) = 3* , *floor(13.1) = 13* . Taking
    *floor(sqrt(N)) + 1* means taking the integer part of the square root of *N* and
    adding a minimal margin just to make sure we do not miss any numbers.
  id: totrans-244
  prefs: []
  type: TYPE_NORMAL
- en: 'Let us put all of this into code, step by step. We start by writing a simple
    `gcd()` function that uses **Euclid’s algorithm** :'
  id: totrans-245
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE51]'
  id: totrans-246
  prefs: []
  type: TYPE_PRE
  zh: '[PRE51]'
- en: 'The explanation of Euclid’s algorithm is available on the web, so we will not
    spend any time talking about it here as we need to focus on the generator expression.
    The next step is to use the knowledge we gathered before to generate a list of
    primitive Pythagorean triples:'
  id: totrans-247
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE52]'
  id: totrans-248
  prefs: []
  type: TYPE_PRE
  zh: '[PRE52]'
- en: This is not easy to read, so let us go through it line by line. At `#3` , we
    start a generator expression that creates triples. You can see from `#4` and `#5`
    that we are looping on `m` in *[1, M]* , with *M* being the integer part of *sqrt(N)*
    , plus *1* . On the other hand, `n` loops within *[1, m)* , to respect the *m
    > n* rule. It is worth noting how we calculated *sqrt(N)* , that is, `N**.5` ,
    which is just another way to do it that we wanted to show you.
  id: totrans-249
  prefs: []
  type: TYPE_NORMAL
- en: 'At `#6` , you can see the filtering conditions to make the triples primitive:
    `(m - n) % 2` evaluates to `True` when `(m - n)` is odd, and `gcd(m, n) == 1`
    means `m` and `n` are coprime. With these in place, we know the triples will be
    primitive. This takes care of the innermost generator expression. The outermost
    one starts at `#2` and finishes at `#7` . We take the triples `(a, b, c) in (...innermost
    generator...)` such that `c <= N` .'
  id: totrans-250
  prefs: []
  type: TYPE_NORMAL
- en: Finally, at `#1` , we apply sorting to present the list in order. At `#8` ,
    after the outermost generator expression is closed, you can see that we specify
    the sorting key to be the sum `a + b + c` . This is just our personal preference;
    there is no mathematical reason behind it.
  id: totrans-251
  prefs: []
  type: TYPE_NORMAL
- en: This code is certainly not easy to understand or explain. Code like this is
    also difficult to debug or modify. It should have no place in a professional environment.
  id: totrans-252
  prefs: []
  type: TYPE_NORMAL
- en: 'Let us see whether we can rewrite this code into something more readable:'
  id: totrans-253
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE53]'
  id: totrans-254
  prefs: []
  type: TYPE_PRE
  zh: '[PRE53]'
- en: This is much easier to read. Let us go through it, line by line. You will see
    it is also much easier to understand.
  id: totrans-255
  prefs: []
  type: TYPE_NORMAL
- en: 'We start looping at `#1` and `#2` , over the same ranges as in the previous
    example. On line `#3` , we filter for primitive triples. On line `#4` , we deviate
    a bit from what we were doing before: we calculate `c` , and on line `#5` , we
    filter on `c` being less than or equal to `N` . We only calculate `a` and `b`
    , and yield the resulting tuple if `c` satisfies that condition. We could have
    calculated the values of `a` and `b` earlier, but by delaying until we know all
    conditions for a valid triple are satisfied, we avoid wasting time and CPU cycles.
    On the last line, we apply sorting with the same key we were using in the generator
    expression example.'
  id: totrans-256
  prefs: []
  type: TYPE_NORMAL
- en: We hope you agree that this example is easier to understand. If we ever need
    to modify the code, this will be much easier, and less error-prone to work with,
    than the generator expression.
  id: totrans-257
  prefs: []
  type: TYPE_NORMAL
- en: 'If you print the results of both examples, you will get this:'
  id: totrans-258
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE54]'
  id: totrans-259
  prefs: []
  type: TYPE_PRE
  zh: '[PRE54]'
- en: There is often a trade-off between performance and readability, and it is not
    always easy to get the balance right. Our advice is to try to use comprehensions
    and generator expressions whenever you can. But if the code starts to become complicated
    to modify or difficult to read or explain, you may want to refactor it into something
    more readable.
  id: totrans-260
  prefs: []
  type: TYPE_NORMAL
- en: Name localization
  id: totrans-261
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Now that we are familiar with all types of comprehensions and generator expressions,
    let us talk about name localization within them. Python 3 localizes loop variables
    in all four forms of comprehensions: list, dictionary, set, and generator expressions.
    This behavior is different from that of the `for` loop. Let us look at some simple
    examples to show all the cases:'
  id: totrans-262
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE55]'
  id: totrans-263
  prefs: []
  type: TYPE_PRE
  zh: '[PRE55]'
- en: In the preceding code, we declare a global name, `A = 100.` We then have list,
    dictionary, and set comprehensions, and a generator expression. Even though they
    all use the name `A` , none of them alter the global name, `A` . On the other
    hand, the `for` loop at the end does modify the global `A` . The last `print`
    statement prints 4.
  id: totrans-264
  prefs: []
  type: TYPE_NORMAL
- en: 'Let us see what happens if the global `A` was not there:'
  id: totrans-265
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE56]'
  id: totrans-266
  prefs: []
  type: TYPE_PRE
  zh: '[PRE56]'
- en: 'The preceding code would work in the same way with any other type of comprehension
    or with a generator expression. After we run the first line, `A` is not defined
    in the global namespace. Once again, the `for` loop behaves differently:'
  id: totrans-267
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE57]'
  id: totrans-268
  prefs: []
  type: TYPE_PRE
  zh: '[PRE57]'
- en: 'The preceding code shows that after a `for` loop, if the loop variable was
    not defined before it, we can find it in the global namespace. We can verify this
    by inspecting the dictionary returned by the `globals()` built-in function:'
  id: totrans-269
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE58]'
  id: totrans-270
  prefs: []
  type: TYPE_PRE
  zh: '[PRE58]'
- en: 'Along with various built-in global names (which we have not reproduced here),
    we see `''A'': 4` .'
  id: totrans-271
  prefs: []
  type: TYPE_NORMAL
- en: Generation behavior in built-ins
  id: totrans-272
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Generator-like behavior is quite common among the built-in types and functions.
    This is a major difference between Python 2 and Python 3. In Python 2, functions
    such as `map()` , `zip()` , and `filter()` returned lists instead of iterable
    objects. The idea behind this change is that if you need to make a list of those
    results, you can always wrap the call in a `list()` class. On the other hand,
    if you just need to iterate and want to keep the impact on memory as light as
    possible, you can use those functions safely. Another notable example is the `range()`
    function. In Python 2, it returned a list, and there was another function called
    `xrange()` that behaved like the `range()` function now behaves in Python 3.
  id: totrans-273
  prefs: []
  type: TYPE_NORMAL
- en: The idea of functions and methods that return iterable objects is quite widespread.
    You can find it in the `open()` function, which is used to operate on file objects
    (we will see it in *Chapter 8* , *Files and Data Persistence* ), but also in `enumerate()`
    , in the dictionary `keys()` , `values()` , and `items()` methods, and several
    other places.
  id: totrans-274
  prefs: []
  type: TYPE_NORMAL
- en: 'It all makes sense: Python aims to reduce the memory footprint by avoiding
    wasting space wherever possible, especially in those functions and methods that
    are used extensively in most situations.'
  id: totrans-275
  prefs: []
  type: TYPE_NORMAL
- en: At the beginning of this chapter, we said that it makes more sense to optimize
    the performance of code that has to deal with large collections of objects, rather
    than shaving off a few milliseconds from a function that we call twice a day.
    That is precisely what Python itself is doing here.
  id: totrans-276
  prefs: []
  type: TYPE_NORMAL
- en: One last example
  id: totrans-277
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Before we finish this chapter, we will show you a simple problem that Fabrizio
    used to give to candidates for a Python developer role in a company he used to
    work for.
  id: totrans-278
  prefs: []
  type: TYPE_NORMAL
- en: 'The problem is the following: write a function that returns the terms of the
    sequence *0 1 1 2 3 5 8 13 21 ...* , up to some limit, *N* .'
  id: totrans-279
  prefs: []
  type: TYPE_NORMAL
- en: If you have not recognized it, that is the Fibonacci sequence, which is defined
    as *F(0) = 0, F(1) = 1* and, for any *n > 1* , *F(n) = F(n-1) + F(n-2)* . This
    sequence is excellent for testing knowledge about recursion, memoization techniques,
    and other technical details, but in this case, it was a good opportunity to check
    whether the candidate knew about generators.
  id: totrans-280
  prefs: []
  type: TYPE_NORMAL
- en: 'Let us start with a rudimentary version, and then improve on it:'
  id: totrans-281
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE59]'
  id: totrans-282
  prefs: []
  type: TYPE_PRE
  zh: '[PRE59]'
- en: 'From the top: we set up the `result` list to a starting value of `[0]` . Then
    we start the iteration from the next element ( `next_n` ), which is 1. While the
    next element is not greater than `N` , we keep appending it to the list and calculating
    the next value in the sequence. We calculate the next element by taking a slice
    of the last two elements in the `result` list and passing it to the `sum` function.'
  id: totrans-283
  prefs: []
  type: TYPE_NORMAL
- en: If you struggle to understand the code, it can help to add some `print()` statements
    so that you can see how values change during execution.
  id: totrans-284
  prefs: []
  type: TYPE_NORMAL
- en: When the loop condition evaluates to `False` , we exit the loop and return `result`
    . You can see the result of those `print` statements in the comments next to each
    of them.
  id: totrans-285
  prefs: []
  type: TYPE_NORMAL
- en: 'At this point, Fabrizio would ask the candidate the following question: *What
    if I just wanted to iterate over those numbers?* A good candidate would then change
    the code to the following:'
  id: totrans-286
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE60]'
  id: totrans-287
  prefs: []
  type: TYPE_PRE
  zh: '[PRE60]'
- en: This is actually one of the solutions he was given. Now, the `fibonacci()` function
    is a *generator function* . First, we yield 0, and then, if `N` is 0, we `return`
    (this will cause a `StopIteration` exception to be raised). If that is not the
    case, we start looping, yielding `b` at every iteration, before updating `a` and
    `b` . This solution relies on the fact that we only need the last two elements
    ( `a` and `b` ) to be able to produce the next one.
  id: totrans-288
  prefs: []
  type: TYPE_NORMAL
- en: 'This code is much better, has a lighter memory footprint, and all we have to
    do to get a list of Fibonacci numbers is wrap the call with `list()` , as usual.
    We can make it even more elegant, though:'
  id: totrans-289
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE61]'
  id: totrans-290
  prefs: []
  type: TYPE_PRE
  zh: '[PRE61]'
- en: The whole body of the function is now only four lines, or five if you count
    the docstring. Notice how, in this case, using tuple assignment ( `a, b = 0, 1`
    and `a, b = b, a + b` ) helps in making the code shorter and more readable.
  id: totrans-291
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  id: totrans-292
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we explored the concepts of iteration and generation a bit
    more deeply. We looked at the `map()` , `zip()` , and `filter()` functions in
    detail, and learned how to use them as an alternative to a regular `for` loop
    approach.
  id: totrans-293
  prefs: []
  type: TYPE_NORMAL
- en: Then, we covered the concept of comprehensions to construct lists, dictionaries,
    and sets. We explored their syntax and how to use them as an alternative to both
    the classic `for` loop approach and the `map()` , `zip()` , and `filter()` functions.
  id: totrans-294
  prefs: []
  type: TYPE_NORMAL
- en: 'Finally, we talked about the concept of generators in two forms: generator
    functions and expressions. We learned how to save time and space by using generation
    techniques. We also saw how operations that are infeasible to perform with lists
    can be performed with generators instead.'
  id: totrans-295
  prefs: []
  type: TYPE_NORMAL
- en: We talked about performance and saw that `for` loops come last in terms of speed,
    but they provide the best readability and flexibility to change. On the other
    hand, functions such as `map()` and `filter()` , and comprehensions, can be much
    faster.
  id: totrans-296
  prefs: []
  type: TYPE_NORMAL
- en: The complexity of the code written using these techniques grows exponentially,
    so to favor readability and ease of maintainability, we still need to use the
    classic `for` loop approach at times. Another difference is in the name localization,
    where the `for` loop behaves differently from all other types of comprehensions.
  id: totrans-297
  prefs: []
  type: TYPE_NORMAL
- en: The next chapter will be all about objects and classes. It is structurally similar
    to this one, in that we will not explore many different subjects—just a few of
    them—but we will try to delve deeper into them.
  id: totrans-298
  prefs: []
  type: TYPE_NORMAL
- en: Join our community on Discord
  id: totrans-299
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Join our community’s Discord space for discussions with the authors and other
    readers:'
  id: totrans-300
  prefs: []
  type: TYPE_NORMAL
- en: '[https://discord.com/invite/uaKmaz7FEC](Chapter_5.xhtml)'
  id: totrans-301
  prefs: []
  type: TYPE_NORMAL
- en: '![img](img/QR_Code119001106417026468.png)'
  id: totrans-302
  prefs: []
  type: TYPE_IMG
