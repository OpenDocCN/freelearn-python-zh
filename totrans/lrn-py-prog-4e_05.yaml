- en: '5'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Comprehensions and Generators
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: ”It’s not the daily increase but daily decrease. Hack away at the unessential.”
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: ''
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: —Bruce Lee
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: The second part of the above quote, “hack away at the unessential,” is to us
    what makes a computer program elegant. We constantly strive to find better ways
    of doing things so that we do not waste time or memory.
  prefs: []
  type: TYPE_NORMAL
- en: There are valid reasons for not pushing our code up to the maximum limit. For
    example, sometimes we have to sacrifice readability or maintainability to achieve
    a negligible improvement. It does not make sense to have a web page served in
    1 second with unreadable, complicated code when we could serve it in 1.05 seconds
    with readable, clean code.
  prefs: []
  type: TYPE_NORMAL
- en: On the other hand, sometimes it is perfectly reasonable to try to shave off
    a millisecond from a function, especially when the function is meant to be called
    thousands of times. One millisecond saved over thousands of calls adds up to seconds
    saved overall, which might be meaningful for your application.
  prefs: []
  type: TYPE_NORMAL
- en: In light of these considerations, the focus of this chapter will not be to give
    you the tools to push your code to the absolute limits of performance and optimization
    *no matter what* , but rather to enable you to write efficient, elegant code that
    reads well, runs fast, and does not waste resources in an obvious way.
  prefs: []
  type: TYPE_NORMAL
- en: 'In this chapter, we are going to cover the following:'
  prefs: []
  type: TYPE_NORMAL
- en: The `map()` , `zip()` , and `filter()` functions
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Comprehensions
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Generators
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Performance
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: We will perform several measurements and comparisons and cautiously draw some
    conclusions. Please do keep in mind that on a different machine with a different
    setup or operating system, results may vary.
  prefs: []
  type: TYPE_NORMAL
- en: 'Take a look at this code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'Both functions return the square of `n` , but which is faster? From a simple
    benchmark that we ran, it looks like the second is slightly faster. If you think
    about it, it makes sense: calculating the power of a number involves multiplication.
    Therefore, whatever algorithm you may use to perform the power operation, it is
    not likely to beat a simple multiplication such as the one in `square2` .'
  prefs: []
  type: TYPE_NORMAL
- en: Do we care about this result? In most cases, no. If you are coding an e-commerce
    website, chances are you will never need to raise a number to the second power,
    and if you do, it is likely to be a sporadic operation. You do not need to concern
    yourself with saving a fraction of a microsecond on a function you call a few
    times.
  prefs: []
  type: TYPE_NORMAL
- en: So, when does optimization become important? One common case is when you have
    to deal with huge collections of data. If you are applying the same function on
    a million `customer` objects, then you want your function to be tuned up to its
    best. Gaining one-tenth of a second on a function called one million times saves
    you 100,000 seconds, which is about 27.7 hours. So, let us focus on collections,
    and see which tools Python gives you to handle them with efficiency and grace.
  prefs: []
  type: TYPE_NORMAL
- en: Many of the concepts we will see in this chapter are based on iterators and
    iterables, which we encountered in *Chapter 3* , *Conditionals and Iteration*
    . We will see how to code a custom iterator and iterable objects in *Chapter 6*
    , *OOP, Decorators, and Iterators* .
  prefs: []
  type: TYPE_NORMAL
- en: 'Some of the objects we are going to explore in this chapter are iterators,
    which save memory by only operating on a single element of a collection at a time
    rather than creating a modified copy. As a result, some extra work is needed if
    we just want to show the result of the operation. We will often resort to wrapping
    the iterator in a `list()` constructor. This is because passing an iterator to
    `list()` exhausts it and puts all the generated items in a newly created list,
    which we can easily print to show you its content. Let us see an example of using
    the technique on a `range` object:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: We have highlighted the result of typing `range(7)` into a Python console. Notice
    that it does not show the contents of the `range` because `range` never actually
    loads the entire sequence of numbers into memory. The second highlighted line
    shows how wrapping the `range` in a `list()` allows us to see the numbers it generates.
  prefs: []
  type: TYPE_NORMAL
- en: Let us start looking at the various tools that Python provides for efficiently
    operating on collections of data.
  prefs: []
  type: TYPE_NORMAL
- en: The map, zip, and filter functions
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'We will start by reviewing `map()` , `filter()` , and `zip()` , which are the
    main built-in functions you can employ when handling collections, and then we
    will learn how to achieve the same results using two important constructs: **comprehensions**
    and **generators** .'
  prefs: []
  type: TYPE_NORMAL
- en: map
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'According to the official Python documentation ( [https://docs.python.org/3/library/functions.html#map](https://docs.python.org/3/library/functions.html#map)
    ), the following is true:'
  prefs: []
  type: TYPE_NORMAL
- en: map(function, iterable, *iterables)
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: ''
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: Return an iterator that applies function to every item of iterable, yielding
    the results. If additional iterables arguments are passed, function must take
    that many arguments and is applied to the items from all iterables in parallel.
    With multiple iterables, the iterator stops when the shortest iterable is exhausted.
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: 'We will explain the concept of yielding later in the chapter. For now, let
    us translate this into code—we will use a `lambda` function that takes a variable
    number of positional arguments, and returns them as a tuple:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: In the preceding code, you can see why we have to wrap calls in `list()` . Without
    it, we get the string representation of a `map` object. Python’s default string
    representation for objects gives their type and memory location which, in this
    context, is not particularly useful to us.
  prefs: []
  type: TYPE_NORMAL
- en: You can also notice how the elements of each iterable are applied to the function;
    at first, the first element of each iterable is applied, then the second one of
    each iterable, and so on. Notice also that `map()` stops when the shortest of
    the iterables we called it with is exhausted. This is a very useful behavior;
    it does not force us to level off all the iterables to a common length, nor does
    it break if they are not all the same length.
  prefs: []
  type: TYPE_NORMAL
- en: As a more interesting example, suppose we have a collection of student dictionaries,
    each of which contains a nested dictionary of the student’s credits. We want to
    sort the students based on the sum of their credits. However, the data as it is
    does not allow for a straightforward application of the sorting function.
  prefs: []
  type: TYPE_NORMAL
- en: To solve the problem, we are going to apply the **decorate-sort-undecorate**
    idiom (also known as **Schwartzian transform** ). It is a technique that was quite
    popular in older Python versions, when sorting did not support the use of *key
    functions* . Nowadays, it is not needed as often, but it still occasionally comes
    in handy.
  prefs: []
  type: TYPE_NORMAL
- en: To **decorate** an object means to transform it, either adding extra data to
    it or putting it into another object. Conversely, to **undecorate** an object
    means to revert the decorated object to its original form.
  prefs: []
  type: TYPE_NORMAL
- en: This technique has nothing to do with Python decorators, which we will explore
    later in the book.
  prefs: []
  type: TYPE_NORMAL
- en: 'In the following example, we can see how `map()` is used to apply this idiom:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: 'Let us start by understanding what each student object is. In fact, let us
    print the first one:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: 'You can see that it is a dictionary with two keys: `id` and `credits` . The
    value of `credits` is also a dictionary in which there are three subject/grade
    key/value pairs. As you may recall from *Chapter 2* , *Built-in Data Types* ,
    calling `dict.values()` returns an iterable object, with only the dictionary’s
    values. Therefore, `sum(student["credits"].values())` for the first student is
    equivalent to `sum((9, 6, 7))` .'
  prefs: []
  type: TYPE_NORMAL
- en: 'Let us print the result of calling `decorate` with the first student:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: If we decorate all the students like this, we can sort them on their total number
    of credits by just sorting the list of tuples. To apply the decoration to each
    item in `students` , we call `map(decorate, students)` . We sort the result, and
    then we undecorate in a similar fashion.
  prefs: []
  type: TYPE_NORMAL
- en: 'Printing `students` after running the whole code yields the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: As you can see, the student objects have indeed been sorted by the sums of their
    credits.
  prefs: []
  type: TYPE_NORMAL
- en: 'For more on the *decorate-sort-undecorate* idiom, there is a good introduction
    in the *Sorting HOW TO* section of the official Python documentation:'
  prefs: []
  type: TYPE_NORMAL
- en: '[https://docs.python.org/3.12/howto/sorting.html#decorate-sort-undecorate](https://docs.python.org/3.12/howto/sorting.html#decorate-sort-undecorate)'
  prefs: []
  type: TYPE_NORMAL
- en: One thing to notice about the sorting part is what happens when two or more
    students share the same total sum. The sorting algorithm would then proceed to
    sort the tuples by comparing the `student` objects with each other. This does
    not make any sense and, in more complex cases, could lead to unpredictable results,
    or even errors. If you want to avoid this issue, one simple solution is to create
    a three-tuple instead of a two-tuple, having the sum of credits in the first position,
    the position of the `student` object in the original `students` list in second
    place, and the `student` object itself in third place. This way, if the sum of
    credits is the same, the tuples will be sorted against the position, which will
    always be different, and therefore enough to resolve the sorting between any pair
    of tuples.
  prefs: []
  type: TYPE_NORMAL
- en: zip
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: We have already covered `zip()` in the previous chapters, so let us just define
    it properly, after which we want to show you how you could combine it with `map()`
    .
  prefs: []
  type: TYPE_NORMAL
- en: 'According to the Python documentation ( [https://docs.python.org/3/library/functions.html#zip](https://docs.python.org/3/library/functions.html#zip)
    ), the following applies:'
  prefs: []
  type: TYPE_NORMAL
- en: zip(*iterables, strict=False)
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: ''
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '... returns an iterator of tuples, where the i-th tuple contains the i-th element
    from each of the argument iterables.'
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: ''
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: Another way to think of zip() is that it turns rows into columns, and columns
    into rows. This is similar to transposing a matrix.
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: 'Let us see an example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: Here, we are zipping together the average and the grade for the last exam for
    each student. Notice how easy it is to reproduce `zip()` using `map()` (the last
    two instructions of the example). Once again, we have to use `list()` to visualize
    the results.
  prefs: []
  type: TYPE_NORMAL
- en: 'Like `map()` , `zip()` will normally stop as soon as it reaches the end of
    the shortest iterable. This can, however, mask problems with the input data, leading
    to bugs. For example, suppose we need to combine a list of students’ names and
    a list of grades into a dictionary mapping each student’s name to their grade.
    A mistake in data entry could result in the list of grades being shorter than
    the list of students. Here is an example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: 'Notice that there is no entry for `"Alice"` in the dictionary. The default
    behavior of `zip()` has masked the data error. For this reason, the `strict` keyword-only
    parameter was added in Python 3.10. If `zip()` receives `strict=True` as an argument,
    it raises an exception if the iterables do not all have the same length:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: The `itertools` module also provides a `zip_longest()` function. It behaves
    like `zip()` but stops only when the longest iterable is exhausted. Shorter iterables
    are padded with a value that can be specified as an argument, which defaults to
    `None` .
  prefs: []
  type: TYPE_NORMAL
- en: filter
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'According to the Python documentation ( [https://docs.python.org/3/library/functions.html#filter](https://docs.python.org/3/library/functions.html#filter)
    ), the following applies:'
  prefs: []
  type: TYPE_NORMAL
- en: filter(function, iterable)
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: ''
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: Construct an iterator from those elements of iterable for which function is
    true. iterable may be either a sequence, a container which supports iteration,
    or an iterator. If function is None, the identity function is assumed, that is,
    all elements of iterable that are false are removed.
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: 'Let us see a quick example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: Notice how the second call to `filter()` is equivalent to the first one. If
    we pass a function that takes one argument and returns the argument itself, only
    those arguments that are `True` will make the function return `True` . This behavior
    is the same as passing `None` . It is often a good exercise to mimic some of the
    built-in Python behaviors. When you succeed, you can say you fully understand
    how Python behaves in a specific situation.
  prefs: []
  type: TYPE_NORMAL
- en: 'Armed with `map()` , `zip()` , and `filter()` (and several other functions
    from the Python standard library), we can manipulate sequences very effectively.
    But these functions are not the only way to do it. Let us look at one of the most
    powerful features of Python: *comprehensions* .'
  prefs: []
  type: TYPE_NORMAL
- en: Comprehensions
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: A comprehension is a concise notation for performing some operation on each
    element of a collection of objects, and/or selecting a subset of elements that
    satisfy some condition. They are borrowed from the functional programming language
    Haskell ( [https://www.haskell.org/](https://www.haskell.org/) ) and, together
    with iterators and generators, contribute to giving Python a functional flavor.
  prefs: []
  type: TYPE_NORMAL
- en: 'Python offers several types of comprehensions: list, dictionary, and set. We
    will concentrate on list comprehensions; once you understand them, the other types
    will be easy to grasp.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Let us start with a simple example. We want to calculate a list with the squares
    of the first 10 natural numbers. We could use a `for` loop and append a square
    to the list in each iteration:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: 'This is not very elegant as we have to initialize the list first. With `map()`
    , we can achieve the same thing in just one line of code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, let us see how to achieve the same result using a list comprehension:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: 'This is much easier to read, and we no longer need to use a lambda. We have
    placed a `for` loop within square brackets. Let us now filter out the odd squares.
    We will show you how to do it with `map()` and `filter()` first, before then using
    a list comprehension again:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: 'We think that the difference in readability is now evident. The list comprehension
    reads much better. It is almost English: give us all squares ( `n**2` ) for `n`
    between 0 and 9 if `n` is even.'
  prefs: []
  type: TYPE_NORMAL
- en: 'According to the Python documentation ( [https://docs.python.org/3.12/tutorial/datastructures.html#list-comprehensions](https://docs.python.org/3.12/tutorial/datastructures.html#list-comprehensions)
    ), the following is true:'
  prefs: []
  type: TYPE_NORMAL
- en: A list comprehension consists of brackets containing an expression followed
    by a for clause, then zero or more for or if clauses. The result will be a new
    list resulting from evaluating the expression in the context of the for and if
    clauses which follow it.
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: Nested comprehensions
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Let us see an example of nested loops. This is quite common because many algorithms
    involve iterating on a sequence using two placeholders. The first one runs through
    the whole sequence, left to right. The second one does, too, but it starts from
    the first one, instead of 0. The concept is that of testing all pairs without
    duplication. Let us see the classical `for` loop equivalent:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: 'If you print `pairs` at the end, you get the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: 'All the tuples with the same letter are those where `b` is at the same position
    as `a` . Now, let us see how we can translate this to a list comprehension:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: Notice that because the `for` loop over `b` depends on `a` , it must come after
    the `for` loop over `a` in the comprehension. If you swap them around, you will
    get a name error.
  prefs: []
  type: TYPE_NORMAL
- en: Another way of achieving the same result is to use the `combinations_with_replacement()`
    function from the `itertools` module (which we briefly introduced in *Chapter
    3* , *Conditionals and Iteration* ). You can read more about it in the official
    Python documentation.
  prefs: []
  type: TYPE_NORMAL
- en: Filtering a comprehension
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: We can also apply filtering to a comprehension. Let us first do it with `filter()`
    , and find all Pythagorean triples whose short sides are numbers smaller than
    10. A **Pythagorean triple** is a triple *(a, b, c)* of integer numbers satisfying
    the equation *a* ² *+ b* ² *= c* ² .
  prefs: []
  type: TYPE_NORMAL
- en: 'We obviously do not want to test a combination twice, and therefore, we will
    use a trick similar to the one we saw in the previous example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: In the preceding code, we generated a list of *three-tuples* , `triples` . Each
    tuple contains two integer numbers (the legs), and the hypotenuse of the Pythagorean
    triangle, whose legs are the first two numbers in the tuple. For example, when
    `a` is 3 and `b` is 4, the tuple will be `(3, 4, 5.0)` , and when `a` is 5 and
    `b` is 7, the tuple will be `(5, 7, 8.602325267042627)` .
  prefs: []
  type: TYPE_NORMAL
- en: After generating all the `triples` , we need to filter out all those where the
    hypotenuse is not an integer number. To achieve this, we filter based on `float_number.is_integer()`
    being `True` . This means that of the two example tuples we just showed you, the
    one with hypotenuse `5.0` will be retained, while the one with the `8.602325267042627`
    hypotenuse will be discarded.
  prefs: []
  type: TYPE_NORMAL
- en: 'This is good, but we do not like the fact that the triple has two integer numbers
    and a float—they are all supposed to be integers. We can use `map()` to fix this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: 'Notice the step we added. We slice each element in `triples` , taking only
    the first two elements. Then, we concatenate the slice with a one-tuple, containing
    the integer version of that float number that we did not like. This code is getting
    quite complicated. We can achieve the same result with a much simpler list comprehension:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: 'That is cleaner, easier to read, and shorter. There is still room for improvement,
    though. We are still wasting memory by constructing a list with many triples that
    we end up discarding. We can fix that by combining the two comprehensions into
    one:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: Now that is elegant. By generating the triples and filtering them in the same
    list comprehension, we avoid keeping any triple that does not pass the test in
    memory. Notice that we used an `assignment expression` to avoid needing to compute
    the value of `sqrt(a**2 + b**2)` twice.
  prefs: []
  type: TYPE_NORMAL
- en: Dictionary comprehensions
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Dictionary comprehensions work exactly like list comprehensions, but to construct
    dictionaries. There is only a slight difference in the syntax. The following example
    will suffice to explain everything you need to know:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: 'If you print `lettermap` , you will see the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: In the preceding code, we are enumerating the sequence of all lowercase ASCII
    letters (using the `enumerate` function). We then construct a dictionary with
    the resulting letter/number pairs as keys and values. Notice how the syntax is
    similar to the familiar dictionary syntax.
  prefs: []
  type: TYPE_NORMAL
- en: 'There is also another way to do the same thing:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: In this case, we are feeding a generator expression (we will talk more about
    these later in this chapter) to the `dict` constructor.
  prefs: []
  type: TYPE_NORMAL
- en: 'Dictionaries do not allow duplicate keys, as shown in the following example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: 'We create a dictionary with the letters of the string `"Hello"` as keys and
    the same letters, but with the case swapped, as values. Notice that there is only
    one `"l": "L"` pair. The constructor does not complain; it simply reassigns duplicates
    to the last value. Let us make this clearer with another example that assigns
    to each key its position in the string:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: 'Notice the value associated with the letter `l: 3` . The `l: 2` pair is not
    there; it has been overridden by `l: 3` .'
  prefs: []
  type: TYPE_NORMAL
- en: Set comprehensions
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Set comprehensions are similar to list and dictionary ones. Let us see one
    quick example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: Notice how for set comprehensions, as for dictionaries, duplication is not allowed,
    and therefore the resulting set has only four letters. Also, notice that the expressions
    assigned to `letters1` and `letters2` produce equivalent sets.
  prefs: []
  type: TYPE_NORMAL
- en: The syntax used to create `letters1` is similar to that of a dictionary comprehension.
    You can spot the difference only by the fact that dictionaries require keys and
    values, separated by colons, while sets do not. For `letters2` , we fed a generator
    expression to the `set()` constructor.
  prefs: []
  type: TYPE_NORMAL
- en: Generators
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '**Generators** are based on the concept of *iteration* , as we said before,
    and they allow coding patterns that combine elegance with efficiency.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Generators are of two types:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Generator functions** : These are similar to regular functions, but instead
    of returning results through `return` statements, they use `yield` , which allows
    them to suspend and resume their state between each call.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Generator expressions** : These are similar to the list comprehensions we
    have seen in this chapter, but instead of returning a list, they return an object
    that produces results one by one.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Generator functions
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Generator functions behave like regular functions in all respects, except for
    one difference: instead of collecting results and returning them at once, they
    are automatically turned into iterators that yield results one at a time.'
  prefs: []
  type: TYPE_NORMAL
- en: Suppose we asked you to count from 1 to 1,000,000. You start, and at some point,
    we ask you to stop. After some time, we ask you to resume. As long as you can
    remember the last number you reached, you will be able to continue where you left
    off. For example, if we stopped you after 31,415, you would just go on with 31,416,
    and so on. The point is that you do not need to remember all the numbers you said
    before 31,415, nor do you need them to be written down somewhere. Generators behave
    in much the same way.
  prefs: []
  type: TYPE_NORMAL
- en: 'Take a good look at the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: 'The result of the two `print` statements will be the same: `[0, 1, 4, 9, 16,
    25, 36, 49, 64, 81]` . But there is an important difference between the two functions.
    `get_squares()` is a classic function that collects all the squares of numbers
    in *[0, n)* in a list, and returns it. On the other hand, `get_squares_gen()`
    is a generator and behaves differently. Each time the interpreter reaches the
    `yield` line, its execution is suspended. The only reason those `print` statements
    return the same result is because we fed `get_squares_gen()` to the `list()` constructor,
    which exhausts the generator completely by asking for the next element until a
    `StopIteration` is raised. Let us see this in detail:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: Each time we call `next()` on the generator object, we either start it (the
    first `next()` ) or make it resume from the last suspension point (any other `next()`
    ). The first time we call `next()` on it, we get 0, which is the square of 0,
    then 1, then 4, then 9, and since the `for` loop stops after that ( `n` is 4),
    the generator naturally ends. A classic function would at that point just return
    `None` , but to comply with the iteration protocol, a generator will instead raise
    a `StopIteration` exception.
  prefs: []
  type: TYPE_NORMAL
- en: This explains how a `for` loop works. When you call `for k in range(n)` , what
    happens under the hood is that the `for` loop gets an iterator out of `range(n)`
    and starts calling `next` on it, until `StopIteration` is raised, which tells
    the `for` loop that the iteration has reached its end.
  prefs: []
  type: TYPE_NORMAL
- en: Having this behavior built into every iteration aspect of Python makes generators
    even more powerful because once we have written them, we will be able to plug
    them into whatever iteration mechanism we want.
  prefs: []
  type: TYPE_NORMAL
- en: At this point, you are probably asking yourself why you would want to use a
    generator instead of a regular function. The answer is to save time and (especially)
    memory.
  prefs: []
  type: TYPE_NORMAL
- en: 'We will talk more about performance later, but for now, let us concentrate
    on one aspect: sometimes, generators allow you to do something that would not
    be possible with a simple list. For example, say you want to analyze all permutations
    of a sequence. If the sequence has a length of *N* , then the number of its permutations
    is *N!* . This means that if the sequence is 10 elements long, the number of permutations
    is 3,628,800. But a sequence of 20 elements would have 2,432,902,008,176,640,000
    permutations. They grow factorially.'
  prefs: []
  type: TYPE_NORMAL
- en: Now imagine you have a classic function that is attempting to calculate all
    permutations, put them in a list, and return it to you. With 10 elements, it would
    require probably a few seconds, but for 20 elements there is simply no way that
    it could be done (it would take thousands of years and require billions of gigabytes
    of memory).
  prefs: []
  type: TYPE_NORMAL
- en: 'On the other hand, a generator function will be able to start the computation
    and give you back the first permutation, then the second, and so on. Of course,
    you will not have the time to process them all—there are too many—but at least
    you will be able to work with some of them. Sometimes the amount of data you have
    to iterate over is so huge that you cannot keep it all in memory in a list. In
    this case, generators are invaluable: they make possible that which otherwise
    would not be.'
  prefs: []
  type: TYPE_NORMAL
- en: So, to save memory (and time), use generator functions whenever possible.
  prefs: []
  type: TYPE_NORMAL
- en: 'It is also worth noting that you can use the `return` statement in a generator
    function. It will cause a `StopIteration` exception to be raised, effectively
    ending the iteration. If a `return` statement were to make the function return
    something, it would break the iteration protocol. Python’s consistency prevents
    this and allows us great ease when coding. Let us see a quick example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: 'The preceding code yields all terms of the geometric progression, *a, aq, aq2,
    aq3, ...* . When the progression produces a term that is greater than 100,000,
    the generator stops (with a `return` statement). Running the code produces the
    following result:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: The next term would have been `156250` , which is too big.
  prefs: []
  type: TYPE_NORMAL
- en: Going beyond next
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Generator objects have methods that allow us to control their behavior: `send()`
    , `throw()` , and `close()` . The `send()` method allows us to communicate a value
    back to the generator object, while `throw()` and `close()` , respectively, allow
    us to raise an exception within the generator and close it. Their use is quite
    advanced, and we will not be covering them here in detail, but we want to spend
    a few words on `send()` , with a simple example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: 'The preceding iterator creates a generator object that will run forever. You
    can keep calling it, and it will never stop. But what if you wanted to stop it
    at some point? One solution is to use a global variable to control the `while`
    loop:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: We initially set `stop = False` , and until we change it to `True` , the generator
    will just keep going, like before. After we change `stop` to `True` though, the
    `while` loop will exit, and the following call to `next` will raise a `StopIteration`
    exception. This trick works, but it is not a satisfactory solution. The function
    depends on an external variable, which can lead to problems. For example, the
    generator could inadvertently be stopped if another, unrelated function changes
    the global variable. Functions should ideally be self-contained and not rely on
    a global state.
  prefs: []
  type: TYPE_NORMAL
- en: 'The generator `send()` method takes a single argument, which is passed into
    the generator function as the value of the `yield` expression. We can use this
    to pass a flag value into the generator to signal that it should stop:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs: []
  type: TYPE_PRE
- en: 'Executing this code produces the following output:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs: []
  type: TYPE_PRE
- en: We think it is worth going through this code line by line, as if we were executing
    it, to see whether we can understand what is going on.
  prefs: []
  type: TYPE_NORMAL
- en: We start the generator execution with a call to `next()` ( `#C` ). Within the
    generator, `n` is set to the same value as `start` . The `while` loop is entered,
    execution stops ( `#A` ), and `n` ( `0` ) is yielded back to the caller. `0` is
    printed on the console.
  prefs: []
  type: TYPE_NORMAL
- en: We then call `send()` ( `#D` ), execution resumes, `result` is set to `"Wow!"`
    (still `#A` ), and its type and value are printed on the console ( `#B` ). `result`
    is not `"Q"` , so `n` is incremented by 1 and execution goes back to the top of
    the loop. The `while` condition is `True` , so another iteration of the loop is
    started. Execution again stops at `#A` , and `n` ( `1` ) is yielded back to the
    caller. `1` is printed on the console.
  prefs: []
  type: TYPE_NORMAL
- en: At this point, we call `next()` ( `#E` ), execution is resumed ( `#A` ), and
    because we are not sending anything to the generator explicitly, the `yield n`
    expression ( `#A` ) returns `None` (the behavior is the same as when we call a
    function that does not return anything). `result` is therefore set to `None` ,
    and its type and value are again printed on the console ( `#B` ). Execution continues,
    `result` is not `"Q"` , so `n` is incremented by 1, and we start another loop
    again. Execution stops again ( `#A` ) and `n` ( `2` ) is yielded back to the caller.
    `2` is printed on the console.
  prefs: []
  type: TYPE_NORMAL
- en: Now we call `send` again ( `#F` ), this time passing the argument `"Q"` . The
    generator resumes, `result` is set to `"Q"` ( `#A` ), and its type and value are
    printed on the console again ( `#B` ). When we reach the `if` statement again,
    `result == "Q"` evaluates to `True` , and the `while` loop is stopped by the `break`
    statement. The generator naturally terminates, which means a `StopIteration` exception
    is raised. You can see the traceback of the exception in the last few lines printed
    on the console.
  prefs: []
  type: TYPE_NORMAL
- en: This is not at all simple to understand at first, so if it is not clear to you,
    do not be discouraged. You can keep reading and come back to this example later.
  prefs: []
  type: TYPE_NORMAL
- en: Using `send()` allows for interesting patterns, and it is worth noting that
    `send()` can also be used to start the execution of a generator (provided you
    call it with `None` ).
  prefs: []
  type: TYPE_NORMAL
- en: The yield from expression
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Another interesting construct is the `yield from` expression. This expression
    allows you to yield values from a sub-iterator. Its use allows for quite advanced
    patterns, so let us see a quick example of it:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs: []
  type: TYPE_PRE
- en: 'The code above prints the numbers `4` , `9` , and `16` on the console (on separate
    lines). By now, we expect you to be able to understand it by yourself, but let
    us quickly recap what happens. The `for` loop outside the function gets an iterator
    from `print_squares(2, 5)` and calls `next()` on it until iteration is over. Every
    time the generator is called, execution is suspended (and later resumed) on `yield
    n**2` , which returns the square of the current `n` . Let us see how we could
    use a `yield from` expression to achieve the same result:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE37]'
  prefs: []
  type: TYPE_PRE
- en: This code produces the same result, but as you can see, `yield from` is actually
    running a sub-iterator, `(n**2 ...)` . The `yield from` expression returns to
    the caller each value the sub-iterator is producing. It is shorter and reads better.
  prefs: []
  type: TYPE_NORMAL
- en: Generator expressions
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In addition to generator functions, generators can also be created using **generator
    expressions** . The syntax to create a generator expression is the same as for
    a list comprehension, except that we use round brackets instead of square brackets.
  prefs: []
  type: TYPE_NORMAL
- en: A generator expression will generate the same sequence of values as an equivalent
    list comprehensions. However, instead of immediately creating a list object containing
    the entire sequence in memory, the generator will yield the values one at a time.
    It is important to remember that you can only iterate over a generator once. After
    that, it will be exhausted.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let us see an example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE38]'
  prefs: []
  type: TYPE_PRE
- en: As you can see from the output when we try to print it, `cubes_gen` is a generator
    object. To see the values it generates, we can use a `for` loop or a manual set
    of calls to `next` , or simply feed it to a `list()` constructor, which is what
    we did.
  prefs: []
  type: TYPE_NORMAL
- en: Notice how, once the generator has been exhausted, there is no way to recover
    the same elements from it again. We need to recreate it if we want to use it from
    scratch again.
  prefs: []
  type: TYPE_NORMAL
- en: 'In the next few examples, let us see how to reproduce `map()` and `filter()`
    using generator expressions. First, let’s look at `map()` :'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE39]'
  prefs: []
  type: TYPE_PRE
- en: In the previous example, `s1` and `s2` are both equal to the sum of `adder(0,
    1)` , `adder(1, 2)` , `adder(2, 3)` , and so on, which translates to `sum(1, 3,
    5, ...)` . We find the generator expression syntax to be much more readable, though.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now for `filter()` :'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE40]'
  prefs: []
  type: TYPE_PRE
- en: 'In this example, `odd_cubes1` and `odd_cubes2` are equivalent: they generate
    a sequence of odd cubes. Yet again, we prefer the generator syntax. This should
    be evident when things get a little more complicated:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE41]'
  prefs: []
  type: TYPE_PRE
- en: 'The preceding code creates two iterators, `cubes1` and `cubes2` . Both will
    yield the same sequence of tuples *(n, n3)* where `n` is a multiple of 3 or 5.
    If you print the list of values obtained from either, you get the following: `[(0,
    0), (3, 27), (5, 125), (6, 216), (9, 729), (10, 1000), (12, 1728), (15, 3375),
    (18, 5832)]` .'
  prefs: []
  type: TYPE_NORMAL
- en: Notice that the generator expression is much easier to read. It may be debatable
    for trivial examples, but as soon as you start performing more complex operations,
    the superiority of the generator syntax is evident. It is shorter, simpler, and
    more elegant.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, let us ask you: what is the difference between the following lines of
    code?'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE42]'
  prefs: []
  type: TYPE_PRE
- en: Strictly speaking, they all produce the same sum. The expressions to get `s2`
    and `s3` are equivalent because the brackets in `s2` are redundant. Both are generator
    expressions passed to the `sum()` function.
  prefs: []
  type: TYPE_NORMAL
- en: The expression to get `s1` is different, though. Here we are passing the result
    of a list comprehension to `sum()` . This wastes both time and memory because
    we first create a list of a million elements (which has to be stored in memory).
    We then pass the list to `sum` , which iterates over it, after which we discard
    the list. It is much better to use a generator expression, as we do not need to
    wait for a list to be constructed, and we do not need to store the entire sequence
    of 1 million values in memory.
  prefs: []
  type: TYPE_NORMAL
- en: 'So, *watch out for extra parentheses when you write your expressions* . Details
    like this are easy to miss, but they can make a significant difference. For example,
    look at the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE43]'
  prefs: []
  type: TYPE_PRE
- en: 'If we run this, we get:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE44]'
  prefs: []
  type: TYPE_PRE
- en: 'On the other hand, if we comment out the first line, and uncomment the second
    one, this is the result:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE45]'
  prefs: []
  type: TYPE_PRE
- en: The difference between the two lines is that in the first, the Python interpreter
    must construct a list with the squares of the first ten billion numbers to pass
    to the `sum` function. That list is huge, and we ran out of memory, so the operating
    system killed the process.
  prefs: []
  type: TYPE_NORMAL
- en: When we remove the square brackets, we no longer have a list. The `sum` function
    receives a generator, which yields 0, 1, 4, 9, and so on, and computes the sum
    without needing to keep all the values in memory.
  prefs: []
  type: TYPE_NORMAL
- en: Some performance considerations
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: There are usually multiple ways of achieving the same result. We can use any
    combination of `map()` , `zip()` , and `filter()` , or choose to go with a comprehension
    or a generator. We may even decide to go with `for` loops. Readability is often
    a factor in choosing between these approaches. List comprehensions or generator
    expressions are often easier to read than complex combinations of `map()` and
    `filter()` . For more complicated operations, generator functions or `for` loops
    are often better.
  prefs: []
  type: TYPE_NORMAL
- en: 'Besides readability concerns, however, we must also consider performance when
    deciding which approach to use. There are two factors that need to be considered
    when comparing the performance of different implementations: `space` and `time`
    .'
  prefs: []
  type: TYPE_NORMAL
- en: Space refers to the amount of memory that your data structures are going to
    use. The best way to choose is to ask yourself if you really need a list (or tuple),
    or whether a generator would work instead.
  prefs: []
  type: TYPE_NORMAL
- en: 'If the answer is yes to the latter, go with the generator, as it will save
    a lot of space. The same goes for functions: if you do not actually need them
    to return a list or tuple, then you can transform them into generator functions
    as well.'
  prefs: []
  type: TYPE_NORMAL
- en: Sometimes, you will have to use lists (or tuples); for example, there are algorithms
    that scan sequences using multiple pointers, and others need to iterate over the
    sequence more than once. A generator (function or expression) can be iterated
    over only once before it is exhausted, so in these situations, it would not be
    the right choice.
  prefs: []
  type: TYPE_NORMAL
- en: Time is a bit more complicated than space because it depends on more variables,
    and it is not always possible to state that *X is faster than Y* with absolute
    certainty for all cases. However, based on tests run on Python today, we can say
    that on average, `map()` exhibits performance similar to comprehensions and generator
    expressions, while `for` loops are consistently slower.
  prefs: []
  type: TYPE_NORMAL
- en: To appreciate the reasoning behind these statements fully, we need to understand
    how Python works, which is a bit outside the scope of this book as it is quite
    technical and detailed. Let us just say that `map()` and comprehensions run at
    C language speed within the interpreter, while a Python `for` loop is run as Python
    bytecode within the Python Virtual Machine, which is often much slower.
  prefs: []
  type: TYPE_NORMAL
- en: There are several different implementations of Python. The original one, and
    still the most common one, is CPython ( [https://github.com/python/cpython](https://github.com/python/cpython)
    ), which is written in C. C is one of the most powerful and popular programming
    languages still used today.
  prefs: []
  type: TYPE_NORMAL
- en: 'In the rest of this section, we will perform some simple experiments to verify
    these performance claims. We will write a small piece of code that collects the
    results of `divmod(a, b)` for a set of integer pairs, `(a, b)` . We will use the
    `time()` function from the `time` module to calculate the elapsed time of the
    operations that we perform:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE46]'
  prefs: []
  type: TYPE_PRE
- en: 'As you can see, we are creating three lists: `floop` , `compr` , and `gener`
    . Running the code produces the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE47]'
  prefs: []
  type: TYPE_PRE
- en: The list comprehension runs in ~71% of the time taken by the `for` loop. The
    generator expression was slightly faster than that, with ~69%. The difference
    in time between the list comprehension and generator expression is hardly significant,
    and if you re-run the example a few times, you will probably also see the list
    comprehension take less time than the generator expression.
  prefs: []
  type: TYPE_NORMAL
- en: It is worth noting that, within the body of the `for` loop, we are appending
    data to a list. This implies that, behind the scenes, the Python interpreter occasionally
    has to resize the list to allocate space for more items to be appended. We guessed
    that creating a list of zeros, and simply filling it with the results, might have
    sped up the `for` loop, but we were wrong. Try it for yourself; you just need
    `mx * (mx - 1) // 2` elements to be pre-allocated.
  prefs: []
  type: TYPE_NORMAL
- en: The approach we used here for timing execution is rather naïve. In *Chapter
    11* , *Debugging and Profiling* , we will look at better ways of profiling code
    and timing execution.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let us see a similar example that compares a `for` loop and a `map()` call:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE48]'
  prefs: []
  type: TYPE_PRE
- en: 'This code is conceptually similar to the previous example. The only thing that
    has changed is that we are applying the `abs()` function instead of `divmod()`
    , and we have only one loop instead of two nested ones. Execution gives the following
    result:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE49]'
  prefs: []
  type: TYPE_PRE
- en: 'This time, `map` was the fastest: it took ~53% of the time required by the
    list comprehension, and ~31% of the time needed by the `for` loop.'
  prefs: []
  type: TYPE_NORMAL
- en: The results from these experiments give us a rough indication of the relative
    speed of `for` loops, list comprehensions, generator expressions, and the `map()`
    function. Do not rely too heavily on these results though, as the experiments
    we performed here are rather simplistic, and accurately measuring and comparing
    execution times is difficult. Measurements can easily be affected by several factors,
    such as other processes running on the same computer. Performance results are
    also heavily dependent on the hardware, operating system, and Python version.
  prefs: []
  type: TYPE_NORMAL
- en: It is clear that `for` loops are slower than comprehensions or `map()` , so
    it is worth discussing why we nevertheless often prefer them over the alternatives.
  prefs: []
  type: TYPE_NORMAL
- en: Do not overdo comprehensions and generators
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We have seen how powerful comprehensions and generator expressions can be. However,
    we find that the more you try to do within a single comprehension or generator
    expression, the harder it becomes to read, understand, and therefore maintain
    or change.
  prefs: []
  type: TYPE_NORMAL
- en: 'If you consider the Zen of Python again, there are a few lines that, we think,
    are worth keeping in mind when dealing with optimized code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE50]'
  prefs: []
  type: TYPE_PRE
- en: Comprehensions and generator expressions are more implicit than explicit, can
    be quite difficult to read and understand, and can be difficult to explain. Sometimes,
    you have to break them apart using the inside-out technique to understand what
    is going on.
  prefs: []
  type: TYPE_NORMAL
- en: To give you an example, let us talk a bit more about Pythagorean triples. Just
    to remind you, a Pythagorean triple is a tuple of positive integers *(a, b, c)*
    such that *a* ² *+ b* ² *= c* ² . We saw how to calculate them in the *Filtering
    a comprehension* section, but we did it in a very inefficient way. We scanned
    all pairs of numbers below a certain threshold, calculating the hypotenuse, and
    filtering out those that were not valid Pythagorean triples.
  prefs: []
  type: TYPE_NORMAL
- en: 'A better way to get a list of Pythagorean triples is to generate them directly.
    There are many different formulas you can use to do this; here we will use the
    **Euclidean formula** . This formula says that any triple *(a, b, c)* , where
    *a = m* ² *- n* ² *, b = 2mn* and *c = m* ² *+ n* ² , with *m* and *n* positive
    integers such that *m > n* , is a Pythagorean triple. For example, when *m = 2*
    and *n = 1* , we find the smallest triple: *(3, 4, 5)* .'
  prefs: []
  type: TYPE_NORMAL
- en: 'There is one catch though: consider the triple *(6, 8, 10)* , which is like
    *(3, 4, 5)* , only all the numbers are multiplied by *2* . This triple is Pythagorean,
    since *6* ² *+ 8* ² *= 10* ² , but we can derive it from *(3, 4, 5)* simply by
    multiplying each of its elements by *2* . The same goes for *(9, 12, 15)* , *(12,
    16, 20)* , and in general for all the triples that we can write as *(3k, 4k, 5k)*
    , with *k* being a positive integer greater than *1* .'
  prefs: []
  type: TYPE_NORMAL
- en: 'A triple that cannot be obtained by multiplying the elements of another one
    by some factor, *k* , is called **primitive** . Another way of stating this is
    as follows: if the three elements of a triple are **coprime** , then the triple
    is primitive. Two numbers are coprime when they do not share any prime factor
    among their divisors, that is, when their **greatest common divisor** ( **GCD**
    ) is *1* . For example, 3 and 5 are coprime, while 3 and 6 are not because they
    are both divisible by 3.'
  prefs: []
  type: TYPE_NORMAL
- en: 'The Euclidean formula tells us that if *m* and *n* are coprime, and *m - n*
    is odd, the triple they generate is *primitive* . In the following example, we
    will write a generator expression to calculate all the primitive Pythagorean triples
    whose hypotenuse, *c* , is less than or equal to some integer, *N* . This means
    we want all triples for which *m* ² *+ n* ² *≤ N* . When *n* is *1* , the formula
    looks like this: *m* ² *≤ N - 1* , which means we can approximate the calculation
    with an upper bound of *m ≤ N* ^(1/2) .'
  prefs: []
  type: TYPE_NORMAL
- en: 'To recap: *m* must be greater than *n* , they must also be coprime, and their
    difference *m - n* must be odd. Moreover, to avoid useless calculations, we will
    put the upper bound for *m* at *floor(sqrt(N)) + 1* .'
  prefs: []
  type: TYPE_NORMAL
- en: The `floor` function for a real number, *x* , gives the maximum integer, *n*
    , such that *n < x* , for example, *floor(3.8) = 3* , *floor(13.1) = 13* . Taking
    *floor(sqrt(N)) + 1* means taking the integer part of the square root of *N* and
    adding a minimal margin just to make sure we do not miss any numbers.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let us put all of this into code, step by step. We start by writing a simple
    `gcd()` function that uses **Euclid’s algorithm** :'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE51]'
  prefs: []
  type: TYPE_PRE
- en: 'The explanation of Euclid’s algorithm is available on the web, so we will not
    spend any time talking about it here as we need to focus on the generator expression.
    The next step is to use the knowledge we gathered before to generate a list of
    primitive Pythagorean triples:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE52]'
  prefs: []
  type: TYPE_PRE
- en: This is not easy to read, so let us go through it line by line. At `#3` , we
    start a generator expression that creates triples. You can see from `#4` and `#5`
    that we are looping on `m` in *[1, M]* , with *M* being the integer part of *sqrt(N)*
    , plus *1* . On the other hand, `n` loops within *[1, m)* , to respect the *m
    > n* rule. It is worth noting how we calculated *sqrt(N)* , that is, `N**.5` ,
    which is just another way to do it that we wanted to show you.
  prefs: []
  type: TYPE_NORMAL
- en: 'At `#6` , you can see the filtering conditions to make the triples primitive:
    `(m - n) % 2` evaluates to `True` when `(m - n)` is odd, and `gcd(m, n) == 1`
    means `m` and `n` are coprime. With these in place, we know the triples will be
    primitive. This takes care of the innermost generator expression. The outermost
    one starts at `#2` and finishes at `#7` . We take the triples `(a, b, c) in (...innermost
    generator...)` such that `c <= N` .'
  prefs: []
  type: TYPE_NORMAL
- en: Finally, at `#1` , we apply sorting to present the list in order. At `#8` ,
    after the outermost generator expression is closed, you can see that we specify
    the sorting key to be the sum `a + b + c` . This is just our personal preference;
    there is no mathematical reason behind it.
  prefs: []
  type: TYPE_NORMAL
- en: This code is certainly not easy to understand or explain. Code like this is
    also difficult to debug or modify. It should have no place in a professional environment.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let us see whether we can rewrite this code into something more readable:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE53]'
  prefs: []
  type: TYPE_PRE
- en: This is much easier to read. Let us go through it, line by line. You will see
    it is also much easier to understand.
  prefs: []
  type: TYPE_NORMAL
- en: 'We start looping at `#1` and `#2` , over the same ranges as in the previous
    example. On line `#3` , we filter for primitive triples. On line `#4` , we deviate
    a bit from what we were doing before: we calculate `c` , and on line `#5` , we
    filter on `c` being less than or equal to `N` . We only calculate `a` and `b`
    , and yield the resulting tuple if `c` satisfies that condition. We could have
    calculated the values of `a` and `b` earlier, but by delaying until we know all
    conditions for a valid triple are satisfied, we avoid wasting time and CPU cycles.
    On the last line, we apply sorting with the same key we were using in the generator
    expression example.'
  prefs: []
  type: TYPE_NORMAL
- en: We hope you agree that this example is easier to understand. If we ever need
    to modify the code, this will be much easier, and less error-prone to work with,
    than the generator expression.
  prefs: []
  type: TYPE_NORMAL
- en: 'If you print the results of both examples, you will get this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE54]'
  prefs: []
  type: TYPE_PRE
- en: There is often a trade-off between performance and readability, and it is not
    always easy to get the balance right. Our advice is to try to use comprehensions
    and generator expressions whenever you can. But if the code starts to become complicated
    to modify or difficult to read or explain, you may want to refactor it into something
    more readable.
  prefs: []
  type: TYPE_NORMAL
- en: Name localization
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Now that we are familiar with all types of comprehensions and generator expressions,
    let us talk about name localization within them. Python 3 localizes loop variables
    in all four forms of comprehensions: list, dictionary, set, and generator expressions.
    This behavior is different from that of the `for` loop. Let us look at some simple
    examples to show all the cases:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE55]'
  prefs: []
  type: TYPE_PRE
- en: In the preceding code, we declare a global name, `A = 100.` We then have list,
    dictionary, and set comprehensions, and a generator expression. Even though they
    all use the name `A` , none of them alter the global name, `A` . On the other
    hand, the `for` loop at the end does modify the global `A` . The last `print`
    statement prints 4.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let us see what happens if the global `A` was not there:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE56]'
  prefs: []
  type: TYPE_PRE
- en: 'The preceding code would work in the same way with any other type of comprehension
    or with a generator expression. After we run the first line, `A` is not defined
    in the global namespace. Once again, the `for` loop behaves differently:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE57]'
  prefs: []
  type: TYPE_PRE
- en: 'The preceding code shows that after a `for` loop, if the loop variable was
    not defined before it, we can find it in the global namespace. We can verify this
    by inspecting the dictionary returned by the `globals()` built-in function:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE58]'
  prefs: []
  type: TYPE_PRE
- en: 'Along with various built-in global names (which we have not reproduced here),
    we see `''A'': 4` .'
  prefs: []
  type: TYPE_NORMAL
- en: Generation behavior in built-ins
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Generator-like behavior is quite common among the built-in types and functions.
    This is a major difference between Python 2 and Python 3. In Python 2, functions
    such as `map()` , `zip()` , and `filter()` returned lists instead of iterable
    objects. The idea behind this change is that if you need to make a list of those
    results, you can always wrap the call in a `list()` class. On the other hand,
    if you just need to iterate and want to keep the impact on memory as light as
    possible, you can use those functions safely. Another notable example is the `range()`
    function. In Python 2, it returned a list, and there was another function called
    `xrange()` that behaved like the `range()` function now behaves in Python 3.
  prefs: []
  type: TYPE_NORMAL
- en: The idea of functions and methods that return iterable objects is quite widespread.
    You can find it in the `open()` function, which is used to operate on file objects
    (we will see it in *Chapter 8* , *Files and Data Persistence* ), but also in `enumerate()`
    , in the dictionary `keys()` , `values()` , and `items()` methods, and several
    other places.
  prefs: []
  type: TYPE_NORMAL
- en: 'It all makes sense: Python aims to reduce the memory footprint by avoiding
    wasting space wherever possible, especially in those functions and methods that
    are used extensively in most situations.'
  prefs: []
  type: TYPE_NORMAL
- en: At the beginning of this chapter, we said that it makes more sense to optimize
    the performance of code that has to deal with large collections of objects, rather
    than shaving off a few milliseconds from a function that we call twice a day.
    That is precisely what Python itself is doing here.
  prefs: []
  type: TYPE_NORMAL
- en: One last example
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Before we finish this chapter, we will show you a simple problem that Fabrizio
    used to give to candidates for a Python developer role in a company he used to
    work for.
  prefs: []
  type: TYPE_NORMAL
- en: 'The problem is the following: write a function that returns the terms of the
    sequence *0 1 1 2 3 5 8 13 21 ...* , up to some limit, *N* .'
  prefs: []
  type: TYPE_NORMAL
- en: If you have not recognized it, that is the Fibonacci sequence, which is defined
    as *F(0) = 0, F(1) = 1* and, for any *n > 1* , *F(n) = F(n-1) + F(n-2)* . This
    sequence is excellent for testing knowledge about recursion, memoization techniques,
    and other technical details, but in this case, it was a good opportunity to check
    whether the candidate knew about generators.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let us start with a rudimentary version, and then improve on it:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE59]'
  prefs: []
  type: TYPE_PRE
- en: 'From the top: we set up the `result` list to a starting value of `[0]` . Then
    we start the iteration from the next element ( `next_n` ), which is 1. While the
    next element is not greater than `N` , we keep appending it to the list and calculating
    the next value in the sequence. We calculate the next element by taking a slice
    of the last two elements in the `result` list and passing it to the `sum` function.'
  prefs: []
  type: TYPE_NORMAL
- en: If you struggle to understand the code, it can help to add some `print()` statements
    so that you can see how values change during execution.
  prefs: []
  type: TYPE_NORMAL
- en: When the loop condition evaluates to `False` , we exit the loop and return `result`
    . You can see the result of those `print` statements in the comments next to each
    of them.
  prefs: []
  type: TYPE_NORMAL
- en: 'At this point, Fabrizio would ask the candidate the following question: *What
    if I just wanted to iterate over those numbers?* A good candidate would then change
    the code to the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE60]'
  prefs: []
  type: TYPE_PRE
- en: This is actually one of the solutions he was given. Now, the `fibonacci()` function
    is a *generator function* . First, we yield 0, and then, if `N` is 0, we `return`
    (this will cause a `StopIteration` exception to be raised). If that is not the
    case, we start looping, yielding `b` at every iteration, before updating `a` and
    `b` . This solution relies on the fact that we only need the last two elements
    ( `a` and `b` ) to be able to produce the next one.
  prefs: []
  type: TYPE_NORMAL
- en: 'This code is much better, has a lighter memory footprint, and all we have to
    do to get a list of Fibonacci numbers is wrap the call with `list()` , as usual.
    We can make it even more elegant, though:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE61]'
  prefs: []
  type: TYPE_PRE
- en: The whole body of the function is now only four lines, or five if you count
    the docstring. Notice how, in this case, using tuple assignment ( `a, b = 0, 1`
    and `a, b = b, a + b` ) helps in making the code shorter and more readable.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we explored the concepts of iteration and generation a bit
    more deeply. We looked at the `map()` , `zip()` , and `filter()` functions in
    detail, and learned how to use them as an alternative to a regular `for` loop
    approach.
  prefs: []
  type: TYPE_NORMAL
- en: Then, we covered the concept of comprehensions to construct lists, dictionaries,
    and sets. We explored their syntax and how to use them as an alternative to both
    the classic `for` loop approach and the `map()` , `zip()` , and `filter()` functions.
  prefs: []
  type: TYPE_NORMAL
- en: 'Finally, we talked about the concept of generators in two forms: generator
    functions and expressions. We learned how to save time and space by using generation
    techniques. We also saw how operations that are infeasible to perform with lists
    can be performed with generators instead.'
  prefs: []
  type: TYPE_NORMAL
- en: We talked about performance and saw that `for` loops come last in terms of speed,
    but they provide the best readability and flexibility to change. On the other
    hand, functions such as `map()` and `filter()` , and comprehensions, can be much
    faster.
  prefs: []
  type: TYPE_NORMAL
- en: The complexity of the code written using these techniques grows exponentially,
    so to favor readability and ease of maintainability, we still need to use the
    classic `for` loop approach at times. Another difference is in the name localization,
    where the `for` loop behaves differently from all other types of comprehensions.
  prefs: []
  type: TYPE_NORMAL
- en: The next chapter will be all about objects and classes. It is structurally similar
    to this one, in that we will not explore many different subjects—just a few of
    them—but we will try to delve deeper into them.
  prefs: []
  type: TYPE_NORMAL
- en: Join our community on Discord
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Join our community’s Discord space for discussions with the authors and other
    readers:'
  prefs: []
  type: TYPE_NORMAL
- en: '[https://discord.com/invite/uaKmaz7FEC](Chapter_5.xhtml)'
  prefs: []
  type: TYPE_NORMAL
- en: '![img](img/QR_Code119001106417026468.png)'
  prefs: []
  type: TYPE_IMG
