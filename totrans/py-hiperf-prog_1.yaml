- en: Chapter 1. Benchmarking and Profiling
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第一章：基准测试和分析
- en: Recognizing the slow parts of your program is the single most important task
    when it comes to speeding up your code. In most cases, the bottlenecks account
    for a very small fraction of the program. By specifically addressing those critical
    spots you can focus on the parts that need improvement without wasting time in
    micro-optimizations.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 在加快代码速度时，识别程序中的慢速部分是最重要的任务。在大多数情况下，瓶颈只占程序的一小部分。通过专门解决这些关键点，你可以专注于需要改进的部分，而无需在微优化上浪费时间。
- en: '**Profiling** is the technique that allows us to pinpoint the bottlenecks.
    A **profiler** is a program that runs the code and observes how long each function
    takes to run, detecting the slow parts of the program. Python provides several
    tools to help us find those bottlenecks and navigate the performance metrics.
    In this chapter, we will learn how to use the standard `cProfile` module, `line_profiler`
    and `memory_profiler`. We will also learn how to interpret the profiling results
    using the program **KCachegrind**.'
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: '**分析**是允许我们定位瓶颈的技术。**分析器**是一个运行代码并观察每个函数运行所需时间的程序，检测程序中的慢速部分。Python提供了几个工具来帮助我们找到这些瓶颈并导航性能指标。在本章中，我们将学习如何使用标准`cProfile`模块、`line_profiler`和`memory_profiler`。我们还将学习如何使用程序**KCachegrind**来解释分析结果。'
- en: You may also want to assess the total execution time of your program and see
    how it is affected by your changes. We will learn how to write benchmarks and
    how to accurately time your programs.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 你可能还想评估你程序的总体执行时间，看看你的更改是如何影响的。我们将学习如何编写基准测试以及如何准确计时你的程序。
- en: Designing your application
  id: totrans-4
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 设计你的应用程序
- en: 'When you are designing a performance-intensive program, the very first step
    is to write your code without having optimization in mind; quoting *Donald Knuth*:'
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 当你设计一个性能密集型程序时，第一步是编写代码时不要考虑优化；引用*唐纳德·克努特*的话：
- en: Premature optimization is the root of all evil.
  id: totrans-6
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 过早的优化是万恶之源。
- en: In the early development stages, the design of the program can change quickly,
    requiring you to rewrite and reorganize big chunks of code. By testing different
    prototypes without bothering about optimizations, you learn more about your program,
    and this will help you make better design decisions.
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: 在早期开发阶段，程序的设计可能会迅速变化，需要你重写和重新组织大量代码。通过在不考虑优化的情况下测试不同的原型，你可以更多地了解你的程序，这将帮助你做出更好的设计决策。
- en: 'The mantras that you should remember when optimizing your code, are as follows:'
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 在优化代码时你应该记住的咒语如下：
- en: '**Make it run**: We have to get the software in a working state, and be sure
    that it produces the correct results. This phase serves to explore the problem
    that we are trying to solve and to spot major design issues in the early stages.'
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**让它运行**：我们必须让软件处于工作状态，并确保它产生正确的结果。这一阶段旨在探索我们试图解决的问题，并在早期阶段发现主要的设计问题。'
- en: '**Make it right**: We want to make sure that the design of the program is solid.
    Refactoring should be done before attempting any performance optimization. This
    really helps separate the application into independent and cohesive units that
    are easier to maintain.'
  id: totrans-10
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**让它正确**：我们想确保程序的设计是稳固的。在尝试任何性能优化之前应该进行重构。这实际上有助于将应用程序分解成独立且一致的单元，这些单元更容易维护。'
- en: '**Make it fast**: Once our program is working and has a good design we want
    to optimize the parts of the program that are not fast enough. We may also want
    to optimize memory usage if that constitutes an issue.'
  id: totrans-11
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**让它变得更快**：一旦我们的程序运行良好并且有良好的设计，我们希望优化程序中不够快的部分。如果内存使用构成问题，我们可能还想优化内存使用。'
- en: In this section we will profile a test application—**a particle simulator**.
    The simulator is a program that takes some particles and evolves them over time
    according to a set of laws that we will establish. Those particles can either
    be abstract entities or correspond to physical objects. They can be, for example,
    billiard balls moving on a table, molecules in gas, stars moving through space,
    smoke particles, fluids in a chamber, and so on.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们将分析一个测试应用程序——**粒子模拟器**。模拟器是一个程序，它根据我们将建立的一系列法则，随着时间的推移演变一些粒子。这些粒子可以是抽象实体，也可以对应于物理对象。例如，它们可以是桌子上移动的台球、气体中的分子、在空间中移动的恒星、烟雾粒子、室内的流体等等。
- en: Those simulations are useful in fields such as Physics, Chemistry, and Astronomy,
    and the programs used to simulate physical systems are typically performance-intensive.
    In order to study realistic systems it's often necessary to simulate the highest
    possible number of bodies.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 这些模拟在物理学、化学和天文学等领域非常有用，用于模拟物理系统的程序通常是性能密集型的。为了研究现实系统，通常需要模拟尽可能多的物体。
- en: In our first example, we will simulate a system containing particles that constantly
    rotate around a central point at various speeds, like the hands of a clock.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的第一个例子中，我们将模拟一个包含粒子围绕中心点以不同速度不断旋转的系统，就像时钟的指针一样。
- en: The necessary information to run our simulation will be the starting positions
    of the particles, the speed, and the rotation direction. From these elements,
    we have to calculate the position of the particle in the next instant of time.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 运行我们的模拟所需的信息将是粒子的起始位置、速度和旋转方向。从这些元素中，我们必须计算粒子在下一个时间瞬间的位置。
- en: '![Designing your application](img/8458OS_01_01.jpg)'
  id: totrans-16
  prefs: []
  type: TYPE_IMG
  zh: '![设计您的应用程序](img/8458OS_01_01.jpg)'
- en: 'The basic feature of a circular motion is that the particles always move perpendicularly
    to the direction connecting the particle and the center, as shown in the preceding
    image. To move the particle we simply change the position by taking a series of
    very small steps in the direction of motion, as shown in the following figure:'
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 圆周运动的基本特征是粒子始终垂直于连接粒子和中心的连线方向移动，如前图所示。为了移动粒子，我们只需通过在运动方向上采取一系列非常小的步骤来改变其位置，如下图所示：
- en: '![Designing your application](img/8458OS_01_02.jpg)'
  id: totrans-18
  prefs: []
  type: TYPE_IMG
  zh: '![设计您的应用程序](img/8458OS_01_02.jpg)'
- en: 'We will start by designing the application in an object-oriented way. According
    to our requirements, it is natural to have a generic `Particle` class that simply
    stores the particle position (*x*, *y*) and its angular speed:'
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将首先以面向对象的方式设计应用程序。根据我们的要求，自然有一个通用的 `Particle` 类，它简单地存储粒子的位置 (*x*，*y*) 和其角速度：
- en: '[PRE0]'
  id: totrans-20
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: Another class, called `ParticleSimulator` will encapsulate our laws of motion
    and will be responsible for changing the positions of the particles over time.
    The `__init__` method will store a list of `Particle` instances and the `evolve`
    method will change the particle positions according to our laws.
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 另一个类，称为 `ParticleSimulator`，将封装我们的运动定律，并负责随时间改变粒子的位置。`__init__` 方法将存储 `Particle`
    实例的列表，而 `evolve` 方法将根据我们的定律改变粒子的位置。
- en: We want the particles to rotate around the point (*x*, *y*), which, here, is
    equal to (0, 0), at constant speed. The direction of the particles will always
    be perpendicular to the direction from the center (refer to the first figure of
    this chapter). To find this vector
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 我们希望粒子围绕点 (*x*，*y*) 旋转，在这里，它等于 (0, 0)，以恒定速度。粒子的方向始终垂直于从中心（参见图章的第一幅图）的方向。为了找到这个向量
- en: '![Designing your application](img/8458OS_01_041.jpg)'
  id: totrans-23
  prefs: []
  type: TYPE_IMG
  zh: '![设计您的应用程序](img/8458OS_01_041.jpg)'
- en: '(corresponding to the Python variables `v_x` and `v_y`) it is sufficient to
    use these formulae:'
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: （对应于 Python 变量 `v_x` 和 `v_y`）使用以下公式就足够了：
- en: '![Designing your application](img/8458OS_01_06.jpg)'
  id: totrans-25
  prefs: []
  type: TYPE_IMG
  zh: '![设计您的应用程序](img/8458OS_01_06.jpg)'
- en: 'If we let one of our particles move, after a certain time *dt*, it will follow
    a circular path, reaching another position. To let the particle follow that trajectory
    we have to divide the time interval *dt* into very small time steps where the
    particle moves tangentially to the circle. The final result, is just an approximation
    of a circular motion and, in fact, it''s similar to a polygon. The time steps
    should be very small, otherwise the particle trajectory will diverge quickly,
    as shown in the following figure:'
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们让其中一个粒子移动，经过一定的时间 *dt*，它将沿着圆形路径移动，到达另一个位置。为了让粒子沿着这条轨迹移动，我们必须将时间间隔 *dt* 分成非常小的时间步长，其中粒子沿着圆周切线方向移动。最终结果只是圆形运动的近似，实际上它类似于多边形。时间步长应该非常小，否则粒子的轨迹会迅速发散，如下图所示：
- en: '![Designing your application](img/8458OS_01_03(1).jpg)'
  id: totrans-27
  prefs: []
  type: TYPE_IMG
  zh: '![设计您的应用程序](img/8458OS_01_03(1).jpg)'
- en: 'In a more schematic way, to calculate the particle position at time *dt* we
    have to carry out the following steps:'
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 以更简化的方式，为了计算时间 *dt* 时的粒子位置，我们必须执行以下步骤：
- en: 'Calculate the direction of motion: `v_x`, `v_y`.'
  id: totrans-29
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 计算运动方向：`v_x`，`v_y`。
- en: Calculate the displacement (`d_x`, `d_y`) which is the product of time and speed
    and follows the direction of motion.
  id: totrans-30
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 计算位移 (`d_x`，`d_y`)，它是时间和速度的乘积，并遵循运动方向。
- en: Repeat steps 1 and 2 for enough time steps to cover the total time *dt*.
  id: totrans-31
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 重复步骤1和2足够长的时间步，以覆盖总时间*dt*。
- en: 'The following code shows the full `ParticleSimulator` implementation:'
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 以下代码显示了完整的`ParticleSimulator`实现：
- en: '[PRE1]'
  id: totrans-33
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'We can use the `matplotlib` library to visualize our particles. This library
    is not included in the Python standard library. To install it, you can follow
    the instructions included in the official documentation at:'
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以使用`matplotlib`库来可视化我们的粒子。这个库不包括在Python标准库中。要安装它，您可以按照官方文档中的说明进行操作：
- en: '[http://matplotlib.org/users/installing.html](http://matplotlib.org/users/installing.html)'
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: '[http://matplotlib.org/users/installing.html](http://matplotlib.org/users/installing.html)'
- en: Note
  id: totrans-36
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: Alternatively, you can use the Anaconda Python distribution ([https://store.continuum.io/cshop/anaconda/](https://store.continuum.io/cshop/anaconda/))
    that includes `matplotlib` and most of the other third-party packages used in
    this book. Anaconda is free and available for Linux, Windows, and Mac.
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 或者，您可以使用包含`matplotlib`和本书中使用的其他大多数第三方包的Anaconda Python发行版（[https://store.continuum.io/cshop/anaconda/](https://store.continuum.io/cshop/anaconda/))。Anaconda是免费的，适用于Linux、Windows和Mac。
- en: The `plot` function included in `matplotlib` can display our particles as points
    on a Cartesian grid and the `FuncAnimation` class can animate the evolution of
    our particles over time.
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: '`matplotlib`中的`plot`函数可以将我们的粒子显示在笛卡尔网格上的点，而`FuncAnimation`类可以动画化粒子随时间的变化。'
- en: The `visualize` function accomplishes this by taking the particle simulator
    and displaying the trajectory in an animated plot.
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: '`visualize`函数通过获取粒子模拟器并在动画图中显示轨迹来实现这一点。'
- en: 'The `visualize` function is structured as follows:'
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: '`visualize`函数的结构如下：'
- en: Setup the axes and display the particles as points using the plot function
  id: totrans-41
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 设置坐标轴并使用绘图函数将粒子显示为点
- en: Write an initialization function (`init`) and an update function (`animate`)
    that changes the *x*, *y* coordinates of the data points using the `line.set_data`
    method
  id: totrans-42
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 编写一个初始化函数（`init`）和一个更新函数（`animate`），使用`line.set_data`方法改变数据点的*x*，*y*坐标
- en: Create a `FuncAnimation` instance passing the functions and some parameters
  id: totrans-43
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 创建一个`FuncAnimation`实例，传递函数和一些参数
- en: Run the animation with `plt.show()`
  id: totrans-44
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用`plt.show()`运行动画
- en: 'The complete implementation of the visualize function is as follows:'
  id: totrans-45
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 可视化函数的完整实现如下：
- en: '[PRE2]'
  id: totrans-46
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'Finally, we define a small test function—`test_visualize`—that animates a system
    of three particles rotating in different directions. Note that the third particle
    completes a round three times faster than the others:'
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们定义了一个小的测试函数——`test_visualize`——它动画化了一个由三个不同方向旋转的粒子组成的系统。注意，第三个粒子比其他粒子快三倍完成一圈：
- en: '[PRE3]'
  id: totrans-48
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: Writing tests and benchmarks
  id: totrans-49
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 编写测试和基准
- en: Now that we have a working simulator, we can start measuring our performance
    and tuning-up our code, so that our simulator can handle as many particles as
    possible. The first step in this process is to write a test and a benchmark.
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们有一个工作的模拟器，我们可以开始测量我们的性能并调整我们的代码，以便我们的模拟器可以处理尽可能多的粒子。这个过程的第一步是编写一个测试和一个基准。
- en: We need a test that checks whether the results produced by the simulation are
    correct or not. In the optimization process we will rewrite the code to try different
    solutions; by doing so we may easily introduce bugs. Maintaining a solid test
    suite is essential to avoid wasting time on broken code.
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 我们需要一个测试来检查模拟产生的结果是否正确。在优化过程中，我们将重写代码以尝试不同的解决方案；这样做可能会轻易引入错误。维护一个坚实的测试套件对于避免在损坏的代码上浪费时间至关重要。
- en: 'Our test will take three particle and let the system evolve for 0.1 time units.
    We then compare our results, up to a certain precision, with those from a reference
    implementation:'
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的测试将使用三个粒子，并让系统演化0.1个时间单位。然后，我们将我们的结果与参考实现的结果进行比较，直到一定的精度：
- en: '[PRE4]'
  id: totrans-53
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: We also want to write a benchmark that can measure the performance of our application.
    This will provide an indication of how much we have improved over the previous
    implementation.
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还希望编写一个基准，可以测量我们应用程序的性能。这将提供有关我们相对于先前实现的改进程度的指示。
- en: 'In our benchmark we instantiate 100 `Particle` objects with random coordinates
    and angular velocity, and feed them to a `ParticleSimulator` class. We then let
    the system evolve for 0.1 time units:'
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的基准测试中，我们实例化了100个具有随机坐标和角速度的`Particle`对象，并将它们输入到`ParticleSimulator`类中。然后，我们让系统演化0.1个时间单位：
- en: '[PRE5]'
  id: totrans-56
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: Timing your benchmark
  id: totrans-57
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 测试基准的时间
- en: 'You can easily measure the execution time of any process from the command line
    by using the Unix `time` command:'
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以通过使用 Unix 的 `time` 命令从命令行轻松测量任何进程的执行时间：
- en: '[PRE6]'
  id: totrans-59
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: Note
  id: totrans-60
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: The `time` command is not available for Windows, but can be found in the `cygwin`
    shell that you can download from the official website [http://www.cygwin.com/](http://www.cygwin.com/).
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: '`time` 命令在 Windows 上不可用，但可以在从官方网站 [http://www.cygwin.com/](http://www.cygwin.com/)
    下载的 `cygwin` 命令行界面中找到。'
- en: 'By default, `time` shows three metrics:'
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 默认情况下，`time` 命令显示三个指标：
- en: '`real`: The actual time spent in running the process from start to finish,
    as if it was measured by a human with a stopwatch'
  id: totrans-63
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`real`：从开始到结束运行进程的实际时间，就像用秒表测量的人一样'
- en: '`user`: The cumulative time spent by all the CPUs during the computation'
  id: totrans-64
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`user`：所有 CPU 在计算过程中累计花费的时间'
- en: '`sys`: The cumulative time spent by all the CPUs during system-related tasks
    such as memory allocation'
  id: totrans-65
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`sys`：所有 CPU 在与系统相关的任务（如内存分配）中累计花费的时间'
- en: Notice that sometimes `user` + `sys` might be greater than `real`, as multiple
    processors may work in parallel.
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，有时 `user` + `sys` 可能会大于 `real`，因为多个处理器可能并行工作。
- en: Tip
  id: totrans-67
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 提示
- en: '`time` also offers several formatting options; for an overview you can explore
    its manual (by using the `man time` command). If you want a summary of all the
    metrics available, you can use the `-v` option.'
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: '`time` 还提供了几个格式化选项；要了解概述，你可以查看其手册（使用 `man time` 命令）。如果你想要所有可用指标的总览，可以使用 `-v`
    选项。'
- en: The Unix `time` command is a good way to benchmark your program. To achieve
    a more accurate measurement, the benchmark should run long enough (in the order
    of seconds) so that the setup and tear-down of the process become small, compared
    to the execution time. The `user` metric is suitable as a monitor for the CPU
    performance, as the `real` metric includes also the time spent in other processes
    or waiting for I/O operations.
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: Unix 的 `time` 命令是衡量你程序的好方法。为了获得更精确的测量，基准测试应该运行足够长的时间（以秒为单位），使得过程的设置和拆除与执行时间相比变得很小。`user`
    指标适合作为 CPU 性能的监控器，因为 `real` 指标还包括在其他进程或等待 I/O 操作中花费的时间。
- en: Another useful program to time Python scripts is the `timeit` module. This module
    runs a snippet of code in a loop for *n* times and measures the time taken. Then,
    it repeats this operation *r* times (by default the value of *r* is 3) and takes
    the best of those runs. Because of this procedure, `timeit` is suitable to accurately
    time small statements in isolation.
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 另一个用于计时 Python 脚本的有用程序是 `timeit` 模块。该模块将代码片段在循环中运行 *n* 次，并测量所花费的时间。然后，它重复此操作
    *r* 次（默认情况下，*r* 的值为 3）并取最佳运行结果。由于此过程，`timeit` 适用于准确计时独立的小语句。
- en: The `timeit` module can be used as a Python module, from the command line, or
    from **IPython**.
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: '`timeit` 模块可以用作 Python 模块，从命令行或从 **IPython** 中使用。'
- en: IPython is a Python shell designed for interactive usage. It boosts tab completion
    and many utilities to time, profile, and debug your code. We will make use of
    this shell to try out snippets throughout the book. The IPython shell accepts
    **magic commands**—statements that start with a `%` symbol—that enhance the shell
    with special behaviors. Commands that start with `%%` are called **cell magics**,
    and these commands can be applied on multi-line snippets (called **cells**).
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: IPython 是一个专为交互式使用设计的 Python 命令行界面。它增强了 tab 自动完成和许多时间、性能分析和调试代码的实用工具。我们将利用这个
    shell 在整本书中尝试代码片段。IPython 命令行界面接受 **魔法命令**——以 `%` 符号开头的语句，这些语句增强了 shell 的特殊行为。以
    `%%` 开头的命令称为 **单元魔法命令**，这些命令可以应用于多行代码片段（称为 **单元**）。
- en: 'IPython is available on most Linux distributions and is included in Anaconda.
    You can follow the installation instructions in the official documentation at:'
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: IPython 在大多数 Linux 发行版中可用，并包含在 Anaconda 中。你可以按照官方文档中的安装说明进行操作：
- en: '[http://ipython.org/install.html](http://ipython.org/install.html)'
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: '[http://ipython.org/install.html](http://ipython.org/install.html)'
- en: Tip
  id: totrans-75
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 提示
- en: You can use IPython as a regular Python shell (`ipython`) but it is also available
    in a Qt-based version (`ipython qtconsole`) and as a powerful browser-based interface
    (`ipython notebook`).
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以将 IPython 用作常规的 Python 命令行界面（`ipython`），但它也提供基于 Qt 的版本（`ipython qtconsole`）以及强大的基于浏览器的界面（`ipython
    notebook`）。
- en: In IPython and command line interfaces it is possible to specify the number
    of loops or repetitions with the options `-n` and `-r`, otherwise they will be
    determined automatically. When invoking `timeit` from the command line, you can
    also give a setup code that will run before executing the statement in a loop.
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 在 IPython 和命令行接口中，可以使用 `-n` 和 `-r` 选项指定循环或重复的次数，否则它们将自动确定。当从命令行调用 `timeit` 时，你也可以提供一个在循环执行语句之前运行的设置代码。
- en: 'In the following code we show how to use timeit from IPython, from the command
    line and as a Python module:'
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 在以下代码中，我们展示了如何从 IPython、命令行以及作为 Python 模块使用 timeit：
- en: '[PRE7]'
  id: totrans-79
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: Notice that while the command line and IPython interfaces are automatically
    determining a reasonable value for `n`, the Python interface requires you to explicitly
    pass it as the `number` argument.
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，虽然命令行和 IPython 接口会自动确定一个合理的 `n` 值，但 Python 接口需要你显式地将其作为 `number` 参数传递。
- en: Finding bottlenecks with cProfile
  id: totrans-81
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用 cProfile 寻找瓶颈
- en: After assessing the execution time of the program we are ready to identify the
    parts of the code that need performance tuning. Those parts are typically quite
    small, compared to the size of the program.
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 在评估程序的执行时间后，我们准备识别需要性能调整的代码部分。这些部分通常与程序的大小相比相当小。
- en: 'Historically, there are three different profiling modules in Python''s standard
    library:'
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 历史上，Python 的标准库中有三个不同的配置文件模块：
- en: '**The** `profile` **module**: This module is written in pure Python and adds
    a significant overhead to the program execution. Its presence in the standard
    library is due mainly to its extendibility.'
  id: totrans-84
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**profile** 模块：此模块是用纯 Python 编写的，并为程序执行添加了显著的开销。它在标准库中的存在主要是由于其可扩展性。'
- en: '**The** `hotshot` **module**: A C module designed to minimize the profiling
    overhead. Its use is not recommended by the Python community and it is not available
    in Python 3.'
  id: totrans-85
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**hotshot** 模块：一个旨在最小化配置文件开销的 C 模块。Python 社区不建议使用它，并且在 Python 3 中不可用。'
- en: '**The** `cProfile` **module**: The main profiling module, with an interface
    similar to `profile`. It has a small overhead and it is suitable as a general
    purpose profiler.'
  id: totrans-86
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**cProfile** 模块：主要的配置文件模块，其接口类似于 `profile`。它具有较小的开销，适合作为通用配置文件。'
- en: 'We will see how to use the cProfile module in two different ways:'
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将展示如何以两种不同的方式使用 cProfile 模块：
- en: From the command line
  id: totrans-88
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 从命令行
- en: From IPython
  id: totrans-89
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 从 IPython
- en: In order to use `cProfile`, no change in the code is required, it can be executed
    directly on an existing Python script or function.
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 为了使用 `cProfile`，不需要对代码进行任何更改，可以直接在现有的 Python 脚本或函数上执行。
- en: 'You can use `cProfile` from the command line in this way:'
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以使用以下方式从命令行使用 `cProfile`：
- en: '[PRE8]'
  id: totrans-92
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'This will print a long output containing several profiling metrics. You can
    use the option `-s` to sort the output by a certain metric:'
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 这将打印出包含多个配置文件指标的冗长输出。你可以使用 `-s` 选项按某个指标排序输出：
- en: '[PRE9]'
  id: totrans-94
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'You can save an output file in a format readable by the `stats` module and
    other tools by passing the `-o` option:'
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以通过传递 `-o` 选项将输出文件保存为 `stats` 模块和其他工具可读的格式：
- en: '[PRE10]'
  id: totrans-96
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'You can also profile interactively from IPython. The `%prun` magic command
    lets you profile a function using `cProfile`:'
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 你还可以从 IPython 中交互式地配置文件。`%prun` 魔法命令允许你使用 `cProfile` 配置文件：
- en: '[PRE11]'
  id: totrans-98
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'The `cProfile` output is divided into five columns:'
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: '`cProfile` 的输出分为五列：'
- en: '`ncalls`: The number of times the function was called.'
  id: totrans-100
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`ncalls`：函数被调用的次数。'
- en: '`tottime`: The total time spent in the function without taking into account
    the calls to other functions.'
  id: totrans-101
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`tottime`：在函数中花费的总时间，不考虑对其他函数的调用。'
- en: '`cumtime`: The time spent in the function including other function calls.'
  id: totrans-102
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`cumtime`：在函数中花费的时间，包括其他函数调用。'
- en: '`percall`: The time spent for a single call of the function—it can be obtained
    by dividing the total or cumulative time by the number of calls.'
  id: totrans-103
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`percall`：函数单次调用的花费时间——可以通过将总时间或累积时间除以调用次数来获得。'
- en: '`filename:lineno`: The filename and corresponding line number. This information
    is not present when calling C extensions modules.'
  id: totrans-104
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`filename:lineno`：文件名和相应的行号。当调用 C 扩展模块时，此信息不存在。'
- en: The most important metric is `tottime`, the actual time spent in the function
    body excluding sub-calls. In our case, the largest portion of time is spent in
    the `evolve` function. We can imagine that the loop is the section of the code
    that needs performance tuning.
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 最重要的指标是 `tottime`，即函数体中实际花费的时间，不包括子调用。在我们的案例中，大部分时间都花在了 `evolve` 函数上。我们可以想象，循环是代码中需要性能调整的部分。
- en: Analyzing data in a textual way can be daunting for big programs with a lot
    of calls and sub-calls. Some graphic tools aid the task by improving the navigation
    with an interactive interface.
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 对于具有大量调用和子调用的程序，以文本方式分析数据可能会令人望而却步。一些图形工具通过改进交互式界面来辅助任务。
- en: KCachegrind is a GUI (Graphical User Interface) useful to analyze the profiling
    output of different programs.
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: KCachegrind是一个GUI（图形用户界面），用于分析不同程序的剖析输出。
- en: Note
  id: totrans-108
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: 'KCachegrind is available in Ubuntu 13.10 official repositories. The Qt port,
    QCacheGrind can be downloaded for Windows from the following web page:'
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: KCachegrind可在Ubuntu 13.10官方仓库中找到。Qt端口，QCacheGrind可以从以下网页下载到Windows：
- en: '[http://sourceforge.net/projects/qcachegrindwin/](http://sourceforge.net/projects/qcachegrindwin/)'
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: '[http://sourceforge.net/projects/qcachegrindwin/](http://sourceforge.net/projects/qcachegrindwin/)'
- en: 'Mac users can compile QCacheGrind using Mac Ports ([http://www.macports.org/](http://www.macports.org/))
    by following the instructions present in the blog post at this link:'
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: Mac用户可以通过Mac Ports ([http://www.macports.org/](http://www.macports.org/))编译QCacheGrind，按照此链接博客文章中的说明进行操作：
- en: '[http://blogs.perl.org/users/rurban/2013/04/install-kachegrind-on-macosx-with-ports.html](http://blogs.perl.org/users/rurban/2013/04/install-kachegrind-on-macosx-with-ports.html)'
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: '[http://blogs.perl.org/users/rurban/2013/04/install-kachegrind-on-macosx-with-ports.html](http://blogs.perl.org/users/rurban/2013/04/install-kachegrind-on-macosx-with-ports.html)'
- en: KCachegrind can't read directly the output files produced by `cProfile`. Luckily,
    the `pyprof2calltree` third-party Python module is able to convert the `cProfile`
    output file into a format readable by KCachegrind.
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: KCachegrind不能直接读取由`cProfile`产生的输出文件。幸运的是，`pyprof2calltree`第三方Python模块能够将`cProfile`输出文件转换为KCachegrind可读的格式。
- en: You can install `pyprof2calltree` from source ([https://pypi.python.org/pypi/pyprof2calltree/](https://pypi.python.org/pypi/pyprof2calltree/))
    or from the Python Package Index ([https://pypi.python.org/](https://pypi.python.org/)).
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以从源代码安装`pyprof2calltree`([https://pypi.python.org/pypi/pyprof2calltree/](https://pypi.python.org/pypi/pyprof2calltree/))或从Python包索引([https://pypi.python.org/](https://pypi.python.org/))安装。
- en: 'To best show the KCachegrind features we will use another example with a more
    diversified structure. We define a recursive function `factorial`, and two other
    functions that use `factorial`, and they are `taylor_exp` and `taylor_sin`. They
    represent the polynomial coefficients of the Taylor approximations of `exp(x)`
    and `sin(x)`:'
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 为了最好地展示KCachegrind的功能，我们将使用一个具有更多样化结构的另一个示例。我们定义一个递归函数`factorial`，以及两个使用`factorial`的其他函数，它们是`taylor_exp`和`taylor_sin`。它们代表`exp(x)`和`sin(x)`的泰勒近似的多项式系数：
- en: '[PRE12]'
  id: totrans-116
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'We need to first generate the `cProfile` output file:'
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 我们需要首先生成`cProfile`输出文件：
- en: '[PRE13]'
  id: totrans-118
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'Then, we can convert the output file with `pyprof2calltree` and launch KCachegrind:'
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们可以使用`pyprof2calltree`转换输出文件并启动KCachegrind：
- en: '[PRE14]'
  id: totrans-120
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: '![Finding bottlenecks with cProfile](img/8458OS_01_03.jpg)'
  id: totrans-121
  prefs: []
  type: TYPE_IMG
  zh: '![使用cProfile查找瓶颈](img/8458OS_01_03.jpg)'
- en: 'The preceding image is a screenshot of the KCachegrind user interface. On the
    left we have an output fairly similar to `cProfile`. The actual column names are
    slightly different: **Incl.** translates to `cProfile` module''s `cumtime`; **Self**
    translates to `tottime`. The values are given in percentages by clicking on the
    **Relative** button on the menu bar.By clicking on the column headers you can
    sort by the corresponding property.'
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 上一张图片是KCachegrind用户界面的截图。在左侧，我们有一个与`cProfile`相当输出的结果。实际的列名略有不同：**Incl.**对应于`cProfile`模块的`cumtime`；**Self**对应于`tottime`。通过在菜单栏上点击**Relative**按钮，数值以百分比形式给出。通过点击列标题，您可以按相应属性排序。
- en: On the top right, a click on the **Callee Map** tab contains a diagram of the
    function costs. In the diagram, each function is represented by a rectangle and
    the time percentage spent by the function is proportional to the area of the rectangle.
    Rectangles can contain sub-rectangles that represent sub-calls to other functions.
    In this case, we can easily see that there are two rectangles for the `factorial`
    function. The one on the left corresponds to the calls made by `taylor_exp` and
    the one on the right to the calls made by `taylor_sin`.
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 在右上角，点击**Callee Map**标签包含函数成本的图表。在图表中，每个函数由一个矩形表示，函数花费的时间百分比与矩形的面积成正比。矩形可以包含表示对其他函数子调用的子矩形。在这种情况下，我们可以很容易地看到有两个矩形表示`factorial`函数。左侧的对应于`taylor_exp`的调用，右侧的对应于`taylor_sin`的调用。
- en: 'On the bottom right, you can display another diagram—the call **graph**—by
    clicking on the **Call Graph** tab. A call graph is a graphical representation
    of the calling relationship between the functions: each square represents a function
    and the arrows imply a calling relationship. For example, `taylor_exp` calls <listcomp>
    (a list comprehension) which calls `factorial` **500** times `taylor_sin` calls
    factorial **250** times. KCachegrind also detects recursive calls: `factorial`
    calls itself **187250** times.'
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 在右下角，您可以通过点击**调用图**选项卡来显示另一个图表——调用**图**。调用图是函数之间调用关系的图形表示：每个方块代表一个函数，箭头表示调用关系。例如，`taylor_exp`调用<listcomp>（一个列表推导），它调用`factorial`
    500次；`taylor_sin`调用`factorial` 250次。KCachegrind还可以检测递归调用：`factorial`调用自身187250次。
- en: You can navigate to the **Call Graph** or the **Caller Map** tabs by double-clicking
    on the rectangles; the interface will update accordingly showing that the timing
    properties are relative to the selected function. For example, double-clicking
    on `taylor_exp` will cause the graph to change, showing only the `taylor_exp`
    contribution to the total cost.
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以通过双击矩形导航到**调用图**或**调用者映射**选项卡；界面将相应更新，显示时间属性相对于所选函数。例如，双击`taylor_exp`将导致图表更改，仅显示`taylor_exp`对总成本的贡献。
- en: Note
  id: totrans-126
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: '**Gprof2Dot** ([https://code.google.com/p/jrfonseca/wiki/Gprof2Dot](https://code.google.com/p/jrfonseca/wiki/Gprof2Dot))
    is another popular tool used to produce call graphs. Starting from output files
    produced by one of the supported profilers, it will generate a `.dot` diagram
    representing the call graph.'
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: '**Gprof2Dot** ([https://code.google.com/p/jrfonseca/wiki/Gprof2Dot](https://code.google.com/p/jrfonseca/wiki/Gprof2Dot))
    是另一个流行的工具，用于生成调用图。从支持的剖析器产生的输出文件开始，它将生成一个`.dot`图，表示调用图。'
- en: Profile line by line with line_profiler
  id: totrans-128
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用line_profiler逐行分析
- en: 'Now that we know which function we have to optimize, we can use the `line_profiler`
    module that shows us how time is spent in a line-by-line fashion. This is very
    useful in situations where it''s difficult to determine which statements are costly.
    The `line_profiler` module is a third-party module that is available on the Python
    Package Index and can be installed by following the instructions on its website:'
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们知道了哪个函数需要优化，我们可以使用`line_profiler`模块，它以逐行的方式显示时间消耗。这在难以确定哪些语句成本高昂的情况下非常有用。`line_profiler`模块是一个第三方模块，可在Python包索引上找到，并可通过其网站上的说明进行安装：
- en: '[http://pythonhosted.org/line_profiler/](http://pythonhosted.org/line_profiler/)'
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: '[http://pythonhosted.org/line_profiler/](http://pythonhosted.org/line_profiler/)'
- en: 'In order to use `line_profiler`,we need to apply a `@profile` decorator to
    the functions we intend to monitor. Notice that you don''t have to import the
    `profile` function from another module, as it gets injected in the global namespace
    when running the profiling script `kernprof.py`. To produce profiling output for
    our program we need to add the `@profile` decorator to the `evolve` function:'
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 为了使用`line_profiler`，我们需要将`@profile`装饰器应用到我们打算监控的函数上。请注意，您不需要从另一个模块导入`profile`函数，因为它在运行分析脚本`kernprof.py`时会被注入到全局命名空间中。为了生成程序的配置文件输出，我们需要将`@profile`装饰器添加到`evolve`函数上：
- en: '[PRE15]'
  id: totrans-132
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'The script `kernprof.py` will produce an output file and will print on standard
    output the result of the profiling. We should run the script with two options:'
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 脚本`kernprof.py`将生成一个输出文件，并将分析结果打印到标准输出。我们应该使用两个选项来运行脚本：
- en: '`-l` to use the `line_profiler` function'
  id: totrans-134
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`-l` 选项用于使用`line_profiler`函数'
- en: '`-v` to immediately print the results on screen'
  id: totrans-135
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`-v` 选项用于立即在屏幕上打印结果'
- en: '[PRE16]'
  id: totrans-136
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE16]'
- en: It is also possible to run the profiler in an IPython shell for interactive
    editing. You should first load the `line_profiler` extension that will provide
    the magic command `lprun`. By using that command you can avoid adding the `@profile`
    decorator.
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 还可以在IPython shell中运行剖析器以进行交互式编辑。您应该首先加载`line_profiler`扩展，这将提供`lprun`魔法命令。通过使用该命令，您可以避免添加`@profile`装饰器。
- en: '[PRE17]'
  id: totrans-138
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'The output is quite intuitive and is divided into columns:'
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 输出非常直观，分为几列：
- en: '**Line number**: The number of the line that was run'
  id: totrans-140
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**行号**：运行的行号'
- en: '**Hits**: The number of times that line was run'
  id: totrans-141
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**命中次数**：该行运行的次数'
- en: '**Time**: The execution time of the line in microseconds (Time)'
  id: totrans-142
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**时间**：该行的执行时间，以微秒为单位（时间）'
- en: '**Per Hit**: Time divided by hits'
  id: totrans-143
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**每次命中**：时间除以命中次数'
- en: '**% Time**: Fraction of the total time spent executing that line'
  id: totrans-144
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**% 时间**：执行该行所花费的总时间的比例'
- en: '**Line Contents**: the source of the corresponding line'
  id: totrans-145
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**行内容**：相应行的源代码'
- en: By looking at the percentage column we can have a pretty good idea of where
    the time is spent. In this case, there are a few statements in the `for` loop
    body with a cost of around 10-20 percent each.
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 通过查看百分比列，我们可以大致了解时间花费在哪里。在这种情况下，`for`循环体中有几个语句，每个语句的成本大约为10-20%。
- en: Optimizing our code
  id: totrans-147
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 优化我们的代码
- en: Now that we have identified exactly how the time is spent, we can modify the
    code and assess the change in performance.
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经确切地知道了时间是如何花费的，我们可以修改代码并评估性能的变化。
- en: 'There are a few different ways to tune up our pure Python code. The way that
    usually produces the most remarkable results is to change the *algorithm*. In
    this case, instead of calculating the velocity and adding small steps, it would
    be more efficient (and correct, as it is not an approximation) to express the
    equations of motion in terms of radius `r` and angle `alpha` (instead of `x` and
    `y`), and then calculate the points on a circle using the equation:'
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 有几种不同的方法可以调整我们的纯Python代码。通常产生最显著结果的方法是改变**算法**。在这种情况下，与其计算速度并添加小步骤，不如用半径`r`和角度`alpha`（而不是`x`和`y`）表示运动方程，然后使用以下方程计算圆上的点：
- en: '[PRE18]'
  id: totrans-150
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: Another way lies in minimizing the number of instructions. For example, we can
    pre-calculate the factor `timestep * p.ang_speed` that doesn't change with time.
    We can exchange the loop order (first we iterate on particles, then we iterate
    on time steps) and put the calculation of the factor outside of the loop on the
    particles.
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 另一种方法是通过最小化指令的数量。例如，我们可以预先计算因子`timestep * p.ang_speed`，这个因子不会随时间变化。我们可以交换循环顺序（首先迭代粒子，然后迭代时间步），并将因子的计算放在循环外的粒子中。
- en: 'The line by line profiling showed also that even simple assignment operations
    can take a considerable amount of time. For example, the following statement takes
    more than 10 percent of the total time:'
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 行内分析还显示，即使是简单的赋值操作也可能花费相当多的时间。例如，以下语句占用了超过10%的总时间：
- en: '[PRE19]'
  id: totrans-153
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'Therefore, a way to optimize the loop is reducing the number of assignment
    operations. To do that, we can avoid intermediate variables by sacrificing readability
    and rewriting the expression in a single and slightly more complex statement (notice
    that the right-hand side gets evaluated completely before being assigned to the
    variables):'
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，优化循环的一种方法是通过减少赋值操作的数量。为了做到这一点，我们可以牺牲可读性，通过将表达式重写为单个稍微复杂一些的语句来避免中间变量（注意，右侧在赋值给变量之前被完全评估）：
- en: '[PRE20]'
  id: totrans-155
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'This leads to the following code:'
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 这导致以下代码：
- en: '[PRE21]'
  id: totrans-157
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'After applying the changes we should make sure that the result is still the
    same, by running our test. We can then compare the execution times using our benchmark:'
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 应用更改后，我们应该通过运行我们的测试来确保结果仍然相同。然后我们可以使用我们的基准来比较执行时间：
- en: '[PRE22]'
  id: totrans-159
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: By acting on pure Python we obtained just a modest increment in speed.
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 通过对纯Python进行操作，我们只获得了速度的微小提升。
- en: The dis module
  id: totrans-161
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '`dis`模块'
- en: Sometimes, it's not easy to evaluate how many operations a Python statement
    will take. In this section, we will explore Python internals to estimate the performance
    of Python statements. Python code gets converted to an intermediate representation—called
    **bytecode**—that gets executed by the Python virtual machine.
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 有时候，很难评估Python语句将执行多少操作。在本节中，我们将探索Python内部机制来估计Python语句的性能。Python代码被转换为中间表示——称为**字节码**——由Python虚拟机执行。
- en: 'To help inspect how the code gets converted into bytecode we can use the Python
    module `dis` (disassemble). Its usage is really simple, it is sufficient to call
    the function `dis.dis` on the `ParticleSimulator.evolve` method:'
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 为了帮助检查代码如何转换为字节码，我们可以使用Python模块`dis`（反汇编）。它的使用非常简单，只需在`ParticleSimulator.evolve`方法上调用函数`dis.dis`即可：
- en: '[PRE23]'
  id: totrans-164
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'This will generate, for each line, a list of bytecode instructions. For example,
    the statement `v_x = (-p.y)/norm` is expanded in the following set of instructions:'
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 这将为每一行生成一个字节码指令列表。例如，语句`v_x = (-p.y)/norm`在以下指令集中展开：
- en: '[PRE24]'
  id: totrans-166
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: '`LOAD_FAST` loads a reference of the variable `p` onto the stack, `LOAD_ATTR`
    loads the `y` attribute of the item present on top of the stack. The other instructions
    (`UNARY_NEGATIVE` and `BINARY_TRUE_DIVIDE`) simply do arithmetic operations on
    top-of-stack items. Finally, the result is stored in `v_x` (`STORE_FAST`).'
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: '`LOAD_FAST`将变量`p`的引用加载到栈上，`LOAD_ATTR`加载栈顶元素的`y`属性。其他指令（`UNARY_NEGATIVE`和`BINARY_TRUE_DIVIDE`）在栈顶元素上执行算术运算。最后，结果存储在`v_x`中（`STORE_FAST`）。'
- en: By analyzing the complete `dis` output we can see that the first version of
    the loop produces 51 bytecode instructions, while the second gets converted into
    35 instructions.
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 通过分析完整的 `dis` 输出，我们可以看到循环的第一个版本产生了 51 条字节码指令，而第二个版本被转换成了 35 条指令。
- en: The `dis` module helps discover how the statements get converted and serve mainly
    as an exploration and learning tool of the Python bytecode representation.
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: '`dis` 模块有助于发现语句是如何被转换的，并主要作为探索和学习 Python 字节码表示的工具。'
- en: To improve our performance even further, we could keep trying to figure out
    other approaches to reduce the amount of instructions. It's clear however, that
    this approach has some limits and it is probably not the right tool for the job.
    In the next chapter, we will see how to speed up those kinds of calculations with
    the help of NumPy.
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 为了进一步提高我们的性能，我们可以继续尝试找出其他方法来减少指令的数量。然而，很明显，这种方法有一些限制，可能不是完成这项工作的正确工具。在下一章中，我们将看到如何借助
    NumPy 加快这类计算。
- en: Profiling memory usage with memory_profiler
  id: totrans-171
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用 `memory_profiler` 分析内存使用情况
- en: In some cases, memory usage constitutes an issue. For example, if we want to
    handle a huge number of particles we will have a memory overhead due to the creation
    of many `Particle` instances.
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 在某些情况下，内存使用可能成为一个问题。例如，如果我们想要处理大量的粒子，由于创建了大量的 `Particle` 实例，我们将会有内存开销。
- en: The module `memory_profiler` summarizes, in a way similar to `line_profiler`,
    the memory usage of the process.
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: '`memory_profiler` 模块以一种类似于 `line_profiler` 的方式总结进程的内存使用情况。'
- en: Note
  id: totrans-174
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: The `memory_profiler` package is also available on the Python Package Index.
    You should also install the `psutil` module ([https://code.google.com/p/psutil/](https://code.google.com/p/psutil/))
    as an optional dependency, it will make `memory_profiler` run considerably faster.
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: '`memory_profiler` 包也可在 Python 包索引中找到。你还应该安装 `psutil` 模块（[https://code.google.com/p/psutil/](https://code.google.com/p/psutil/)）作为可选依赖项，这将使
    `memory_profiler` 运行得更快。'
- en: Just like `line_profiler`, `memory_profiler` also requires the instrumentation
    of the source code, by putting a `@profile` decorator on the function we intend
    to monitor. In our case, we want to analyze the function `benchmark`.
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 就像 `line_profiler` 一样，`memory_profiler` 也需要源代码的仪器化，通过在我们要监控的函数上放置 `@profile`
    装饰器。在我们的例子中，我们想要分析 `benchmark` 函数。
- en: 'We can slightly change `benchmark` to instantiate a considerable amount (100000)
    of `Particle` instances and decrease the simulation time:'
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以稍微修改 `benchmark` 以实例化大量的 `Particle` 实例（100000 个）并减少模拟时间：
- en: '[PRE25]'
  id: totrans-178
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'We can use `memory_profiler` from an IPython shell through the magic command
    `%mprun`:'
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以通过 IPython 壳中的魔法命令 `%mprun` 使用 `memory_profiler`：
- en: '[PRE26]'
  id: totrans-180
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: Tip
  id: totrans-181
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 小贴士
- en: It is possible to run `memory_profiler` from the shell using the `mprof run`
    command after adding the `@profile` decorator.
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: 在添加了 `@profile` 装饰器后，可以使用 `mprof run` 命令从壳中运行 `memory_profiler`。
- en: From the output we can see that 100000 `Particle` objects take 25.7 **MiB**
    of memory.
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: 从输出中我们可以看到，100000 个 `Particle` 对象占用了 25.7 **MiB** 的内存。
- en: Tip
  id: totrans-184
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 小贴士
- en: 1 MiB (mebibyte) is equivalent to 1024² = 1,048,576 bytes. It is different from
    1 MB (*megabyte*), which is equivalent to 1000² = 1,000,000 bytes.
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: 1 MiB（梅比字节）相当于 1024² = 1,048,576 字节。它与 1 MB（兆字节）不同，1 MB 相当于 1000² = 1,000,000
    字节。
- en: 'We can use `__slots__` on the `Particle` class to reduce its memory footprint.
    This feature saves some memory by avoiding storing the variables of the instance
    in an internal dictionary. This optimization has a drawback: it prevents the addition
    of attributes other than the ones specified in `__slots__` (to use this feature
    in Python 2 you should make sure that you are using new-style classes):'
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以在 `Particle` 类上使用 `__slots__` 来减少其内存占用。这个特性通过避免在内部字典中存储实例变量来节省一些内存。这种优化的缺点是：它阻止了添加
    `__slots__` 中未指定的属性（要在 Python 2 中使用此功能，你应该确保你正在使用新式类）：
- en: '[PRE27]'
  id: totrans-187
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: By rewriting the `Particle` class using `__slots__` we can save 11 MiB of memory.
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: 通过使用 `__slots__` 重新编写 `Particle` 类，我们可以节省 11 MiB 的内存。
- en: Performance tuning tips for pure Python code
  id: totrans-189
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 纯 Python 代码的性能调优技巧
- en: As a rule of thumb, when optimizing pure Python code, you should look at what
    is available in the standard library. The standard library contains clever algorithms
    for the most common data structures such as lists, dicts, and sets. Furthermore,
    a lot of standard library modules are implemented in C and have fast processing
    times. However, it's important to always time the different solutions—the outcomes
    are often unpredictable.
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: 作为一条经验法则，在优化纯Python代码时，你应该查看标准库中可用的内容。标准库包含针对最常见的数据结构（如列表、字典和集合）的巧妙算法。此外，许多标准库模块是用C实现的，具有快速的执行时间。然而，始终计时不同的解决方案是很重要的——结果往往是不可预测的。
- en: 'The `collections` module provides extra data containers that can efficiently
    handle some common operations. For example, you can use `deque` in place of a
    list when you need to pop items from the start and append new items at the end.
    The `collections` module also includes a `Counter` class that can be used to count
    repeated elements in an iterable object. Beware, that `Counter` can be slower
    than the equivalent code written with a standard loop over a dictionary:'
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: '`collections`模块提供了额外的数据容器，可以高效地处理一些常见操作。例如，当你需要从开始处弹出项目并在末尾追加新项目时，你可以使用`deque`代替列表。`collections`模块还包括一个`Counter`类，可以用来计算可迭代对象中的重复元素。请注意，`Counter`可能比用标准循环在字典中编写的等效代码要慢：'
- en: '[PRE28]'
  id: totrans-192
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: 'You can put the code in a file named `purepy.py` and time it through IPython:'
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以将代码放入一个名为`purepy.py`的文件中，并通过IPython进行计时：
- en: '[PRE29]'
  id: totrans-194
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: 'In general, list comprehension and generators should be preferred in place
    of explicit loops. Even if the speedup over a standard loop is modest, this is
    a good practice because it improves readability. We can see in the following example,
    that both list comprehension and generator expressions are faster than an explicit
    loop when combined with the function `sum`:'
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: 通常，应该优先使用列表推导和生成器，而不是显式循环。即使与标准循环相比速度提升不大，这也是一个好习惯，因为它提高了可读性。在以下示例中，我们可以看到，列表推导和生成器表达式与函数`sum`结合时比显式循环更快：
- en: '[PRE30]'
  id: totrans-196
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: 'We can add those functions to `purepy.py` and test with IPython:'
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以将这些函数添加到`purepy.py`中，并用IPython进行测试：
- en: '[PRE31]'
  id: totrans-198
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: The `bisect` module can help with fast insertion and retrieval of elements,
    while maintaining a sorted list.
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: '`bisect`模块可以帮助快速插入和检索元素，同时保持列表排序。'
- en: Raw optimization of pure Python code is not very effective, unless there is
    a substantial algorithmic advantage. The second-best way to speed up your code
    is to use external libraries specifically designed for the purpose, such as `numpy`,
    or to write extensions modules in a more "down to the metal" language such as
    C with the help of **Cython**.
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: 纯Python代码的原始优化并不非常有效，除非有实质性的算法优势。加快你代码的第二种最佳方式是使用专门为此目的设计的库，如`numpy`，或者使用**Cython**在更接近底层语言（如C）中编写扩展模块。
- en: Summary
  id: totrans-201
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: In this chapter, we introduced the basic principles of optimization and we applied
    those principles to our test application. The most important thing is identifying
    the bottlenecks in the application before editing the code. We saw how to write
    and time a benchmark using the `time` Unix command and the Python `timeit` module.
    We learned how to profile our application using `cProfile`, `line_profiler`, and
    `memory_profiler`, and how to analyze and navigate graphically the profiling data
    with KCachegrind. We surveyed some of the strategies to optimize pure Python code
    by leveraging the tools available in the standard library.
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们介绍了优化的基本原理，并将这些原理应用于我们的测试应用。最重要的是在编辑代码之前识别应用中的瓶颈。我们看到了如何使用`time` Unix命令和Python的`timeit`模块编写和计时基准测试。我们学习了如何使用`cProfile`、`line_profiler`和`memory_profiler`来分析我们的应用，以及如何使用KCachegrind图形化地导航分析数据。我们还概述了一些利用标准库中可用的工具来优化纯Python代码的策略。
- en: In the next chapter, we will see how to use `numpy` to dramatically speedup
    computations in an easy and convenient way.
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章中，我们将看到如何使用`numpy`以简单方便的方式显著加快计算速度。
