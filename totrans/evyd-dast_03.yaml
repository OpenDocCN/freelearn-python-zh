- en: 'Chapter 3. Lists: Linear Collections'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In our last chapter, we introduced the array data structure upon which many
    of the structures we will examine in this text are based. Although arrays provide
    good performance for static collections of data, our coding examples proved that
    they are inflexible and inefficient for many applications--so much so that even
    something as simple as adding or deleting an element from a collection is an extremely
    complex and costly operation.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
- en: Lists are, in some ways, an evolution of the array. A list can be defined as
    a finite, ordered series of objects or values called **elements**. An empty list
    is a list with no elements, while the length of a list is the total number of
    elements in the collection. The first item in a list is called the **head**, while
    the last item is called the **tail**. In a list with a length of 1, the head and
    tail are the same object.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
- en: Note
  id: totrans-3
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: While arrays are a *concrete* data structure, a list is an abstract concept
    of a data structure that many languages provide a concrete implementation of.
    We will examine this distinction in more detail with one of the Java examples
    later in this chapter.
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
- en: Ordered lists should not be confused with sorted lists because lists can be
    either **sorted** or **unsorted**. Ordered simply means that each element has
    a defined position in the list. Objects in a sorted list have some type of relationship
    between them, while objects in an unsorted list have no notable relationship.
    For example, when my wife creates a shopping list, she sits down and carefully
    organizes the groceries in relation to how she knows the supermarket is arranged.
    Items on her list are types of groceries and they are arranged according to their
    relative positions in the supermarket so they have a *spatial relationship*. This
    is a sorted list. I, on the other hand, create a shopping list by slapping a piece
    of paper on the fridge and scribbling items on the paper as I notice shelves are
    empty or containers are missing. Although the items on my list are all types of
    groceries, they are not arranged in any particular way so they have *no notable
    relationship* to one another. This is an example of an unsorted list.
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
- en: 'In this chapter we will cover the following:'
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
- en: Definition of a list data structure
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Initializing lists
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Example applications for lists
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: List implementations
  id: totrans-10
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Append, insert, and remove operations
  id: totrans-11
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Array-based lists
  id: totrans-12
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Linked lists
  id: totrans-13
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Doubly linked lists
  id: totrans-14
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Searching
  id: totrans-15
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: List implementations
  id: totrans-16
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: One of the most common implementations of the list data structure is the *array-based*
    list. Generally speaking, an array-based list is simply a contiguous list of array
    positions, each holding a *pointer* to a list element. Since the list is based
    on an array, its functionality and performance are very similar to that of an
    array.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
- en: As seen in the previous examples, another common implementation is the **linked
    list**. A linked list is also a sequence of elements, except most implementations
    refer to the elements as **nodes**. In a linked list, the pointers to the elements
    are not contained in an array structure, but rather a pointer exists in memory
    to identify the first node. Then each node contains a link to the subsequent node
    in the list.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 如前例所示，另一种常见的实现是**链表**。链表也是一个元素序列，但大多数实现将元素称为**节点**。在链表中，元素的指针不包含在数组结构中，而是在内存中存在一个指针来标识第一个节点。然后每个节点都包含指向列表中后续节点的链接。
- en: Finally, there is the **doubly linked list**. In a doubly linked list, each
    node contains a link to both the subsequent node in the list and the previous
    node in the list. A doubly linked list makes traversing the list bidirectionally
    a much simpler process. The previous link in the head node and the next link in
    the tail node are both null. An alternative to this is to have the previous link
    in the head node point to the tail and the next link in the tail node point to
    the head, which changes the doubly linked list to a **circular linked list**.
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，还有**双向链表**。在双向链表中，每个节点都包含指向列表中后续节点和前一个节点的链接。双向链表使得双向遍历列表变得更加简单。头节点的上一个链接和尾节点的下一个链接都是空的。另一种选择是将头节点的上一个链接指向尾节点，尾节点的下一个链接指向头节点，这样双向链表就变成了**循环链表**。
- en: Note
  id: totrans-20
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: The term doubly linked list is not used very often, but if you work with the
    `LinkedList` classes in Java or C#, you are in fact working with a doubly linked
    list. C# and Java do not provide a **singly linked list** type, and the doubly
    linked list provides you with the same functionality and more, so you should never
    need one. However, you could easily implement one of your own if you really wanted
    to for academic purposes.
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 双向链表这个术语并不常用，但如果你在使用Java或C#中的`LinkedList`类，实际上你就是在使用双向链表。C#和Java没有提供**单链表**类型，双向链表为你提供了相同的功能甚至更多，所以你通常不需要它。然而，如果你真的出于学术目的想要实现一个，那也很容易做到。
- en: Typically, each of the concrete implementations of this structure provides you
    with convenience methods allowing you to append, insert, and remove elements from
    the list. Both array-based and link-based lists provide access to the basic append,
    insert, and remove operations. However, the way in which these operations are
    implemented and their associated cost vary slightly between the two implementations.
    Where existing methods for this functionality are not baked in, it is typically
    a trivial exercise to create that functionality.
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 通常，这个结构的每个具体实现都为你提供了方便的方法，允许你从列表中追加、插入和删除元素。基于数组和基于链接的列表都提供了访问基本追加、插入和删除操作的方法。然而，这些操作的实施方式和它们相关的成本在这两种实现之间略有不同。如果现有的方法没有内置，那么创建这种功能通常是一个简单的练习。
- en: Note
  id: totrans-23
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: As with other implementations of abstract data structures, when given a choice between
    using methods we create ourselves and any methods provided by the framework, choose
    the latter as they will typically be more robust and reliable.
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 与其他抽象数据结构的实现一样，当在创建我们自己的方法和框架提供的任何方法之间做出选择时，选择后者，因为它们通常会更健壮和可靠。
- en: Array-based lists
  id: totrans-25
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 基于数组的列表
- en: 'The append operation in an array-based list costs **O**(*1*), as we can always
    determine the new element''s position by simply incrementing the index of the
    tail position:'
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 在基于数组的列表中，追加操作的成本是**O**(*1*)，因为我们总能通过简单地增加尾位置的索引来确定新元素的位置：
- en: '![Array-based lists](img/00003.jpeg)'
  id: totrans-27
  prefs: []
  type: TYPE_IMG
  zh: '![基于数组的列表](img/00003.jpeg)'
- en: Whenever we insert an element into an array-based list, we need to also manage
    the position of the existing objects in the array to accommodate the new nodes.
    Inserting an element into the list at index *i* requires us to shift all of the
    elements in positions greater than *i* one position toward the tail, meaning that
    we will need to perform *n* - *i* operations where there are *n* elements already
    in the list. Inserting at the head position is a worst-case operation, costing
    **O**(*n*). Since we always count the cost of the worst case when evaluating an
    algorithm's efficiency, inserting an element costs **O**(*n*).
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
- en: 'Removing an element from the list at index *i* requires us to shift all of
    the elements in positions greater than *i* one position toward the head, meaning
    that we will need to perform *n* - *i*- 1 operations where there are *n* elements
    in the list. Removing from the head position is a worst-case operation, costing
    **O**(*n*). Therefore, removing an element costs **O**(*n*), as depicted in the
    following diagram:'
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
- en: '![Array-based lists](img/00004.jpeg)'
  id: totrans-30
  prefs: []
  type: TYPE_IMG
- en: Linked list
  id: totrans-31
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: As with an array-based list, the append operation costs **O**(*1*). However,
    the insert and remove operations also cost **O**(*1*). One of the key advantages
    of the linked list over the array-based list is mutability. Unlike an array, a linked
    list is a series of discrete objects related to one another by memory pointers,
    so inserting or removing elements is simply a matter of adding or modifying those
    pointers. In other words, a linked list is capable of growing and shrinking to
    accommodate additions to and deletions from the collection in a very efficient
    manner.
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
- en: '![Linked list](img/00005.jpeg)'
  id: totrans-33
  prefs: []
  type: TYPE_IMG
- en: If we wish to insert an element at position *i*, we need to change the original
    pointer *i* - 1 -> *i* to point to our new element at *i*, and insert a new pointer
    for *i* -> *i* + 1\. Similarly, removing an element at *i* requires adjusting
    the pointer from *i* - 1 -> *i* and making it *i* - 1 -> *i* + 1.
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
- en: Instantiating lists
  id: totrans-35
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Like other data structures, lists must be defined and instantiated prior to
    being used. Each of the four languages that we will examine in this text has varying
    support for, and unique implementations of, the list data structure. Let's briefly
    examine how to instantiate a list in each language.
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
- en: '**C#**'
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
- en: 'Instantiating lists in C# requires the use of the `new` keyword:'
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  id: totrans-39
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: The C# `ArrayList` class originated in .NET 1.0, and it is not used very often
    anymore. Most developers prefer to use the generic concrete implementation, `List<of
    T>`, for an array-based list. This is also true for the generic concrete linked
    list implementation, `LinkedList<of T>`. There is no non-generic linked list data
    structure in C#.
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
- en: '**Java**'
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
- en: 'Like C#, initializing a list in Java requires the use of the `new` keyword:'
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  id: totrans-43
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: Java developers will create an array-based list using a concrete implementation
    of the generic abstract `List<E>` class. This is also true of the concrete linked
    list implementation, `LinkedList<E>`. There is no non-generic linked list data
    structure in Java.
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
- en: '**Objective-C**'
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
- en: 'The process of creating a list in Objective-C is as follows:'
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  id: totrans-47
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: If you read the chapter on arrays, this example has probably caught your attention.
    In fact, this is not a mistake. The closest implementation for an array-based
    list in Objective-C is found in the `NSArray` class, while the closest implementation
    of a linked list is found in the `NSMutableArray` class. That's because `NSArray`
    and `NSMutableArray` are known as **class clusters**. Class clusters provide public
    APIs that are really abstract classes. When you initialize one of these classes
    you get back the concrete implementation of a data structure, which is custom
    tailored for the data you provided. These implementations can even change at runtime
    if the nature of the data set changes, making array classes extremely flexible.
    This means that many of the data structures we will discuss in this text will
    be implemented in Objective-C (and Swift) by only three abstract classes.
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
- en: Note
  id: totrans-49
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '**Class clusters in Objective-C**'
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
- en: Class clusters are a design pattern based on the **Abstract Factory** pattern,
    which returns a type adhering to a certain interface (C#/Java) or protocol (Objective-C/Swift).
    They are leveraged heavily in the **Foundation** framework and this is a good
    thing.
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
- en: Class clusters group private, concrete subclasses under an abstract superclass
    or API. This public API is much simpler to work with than working with each subclass
    directly. `NSNumber`, `NSString`, `NSArray`, and `NSDictionary` are all examples
    of class clusters in Foundation.
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
- en: '**Swift**'
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
- en: 'Finally, here''s how to instantiate a list in Swift:'
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  id: totrans-55
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: Swift also uses class clusters for many different abstract collections. For
    lists, we use the `Array` class, which is both generic and mutable by default.
    There is a shorthand and an explicit declaration for arrays in Swift. Although
    more verbose, the explicit definition more clearly demonstrates the generic nature
    of the API.
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
- en: Revisiting users logged in to a service
  id: totrans-57
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In [Chapter 2](part0019_split_000.html#I3QM2-77f2b5b248f04368a6f723b0e9357ef3
    "Chapter 2.  Arrays: Foundational Collections"), *Arrays: Foundational Structures*, we
    created an app to keep track of users logged into a web service, using an array
    as the underlying data structure containing the `User` objects. However, this
    design can be greatly improved upon by using a list data structure. Let''s revisit
    the users logged into a service problem here, and by replacing the class array
    with a list, we will see that our original code is both abbreviated and more readable
    in most cases.'
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
- en: '**C#**'
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
- en: 'In this example, we have replaced the `User[]` object with a `List<User>` object.
    Much of this refactor is obvious, but three lines of code should be noted. First,
    in the `CanAddUser()` method, we have replaced 15 lines of code with 2 lines of
    code by leveraging the `List<T>.Contains()` method and condensing our logic loop.
    Next, in the `UserAuthenticated()` method, we have leveraged the `List<T>.Add()`
    method, which replaced the call to `Array.Resize()` and the error-prone approach
    to assigning an object using the subscription operator. Finally, we replaced nearly
    20 lines of complex and ugly code using the `List<T>.Remove()` method. The convenience
    and power afforded by this wrapper class should be obvious based solely on the
    abbreviated code:'
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  id: totrans-61
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: '**Java**'
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
- en: 'In this example, we have replaced the `User[]` object with a `List<User>` object.
    Much of this refactor is obvious, but three lines of code should be noted. First,
    in the `CanAddUser()` method, we have replaced 15 lines of code with 2 lines of
    code by leveraging the `List<E>.contains()` method and condensing our logic loop.
    Next, in the `UserAuthenticated()` method, we are leveraging the `List<E>.add()`
    method, which replaced the call to `Array.copyOf()` and the error-prone approach
    to assigning an object using the subscription operator. Finally, we replaced nearly
    20 lines of complex and ugly code using the `List<E>.remove()` method:'
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  id: totrans-64
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: The following screenshot demonstrates another benefit of using generic classes
    when available. As you can see, our code  completion, or **Intellisense**, suggests
    potential completion options including the proper type to be included in the collection.
    This can save you from having to check back repeatedly to make sure that you are
    using the correct object and collection, which is both time-consuming and annoying.
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
- en: '![Revisiting users logged in to a service](img/00006.jpeg)'
  id: totrans-66
  prefs: []
  type: TYPE_IMG
- en: '**Objective-C**'
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
- en: 'In this example, we have replaced the `NSArray _users` object with an `NSMutableArray
    _users` object. In this example, besides some consolidation and code cleanup,
    there is really only one refactor. In `userLoggedOut:`, we replaced nearly 20
    lines of complex and ugly code using the `NSMutableArray removeObject:` method
    instead of checking indices, looping, and merging objects:'
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  id: totrans-69
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: '**Swift**'
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
- en: 'If you look carefully at this code in comparison to the original, you''ll see
    that effectively they are the same! That''s because Swift `Arrays` are already
    mutable and they already support generic types, so our original `LoggedInUserArray`
    class was already functioning as much like a linked, as Swift is capable of producing
    output with out-of-the-box code. We could create our own implementation of a linked
    list in Swift but that would only be necessary in very specific use cases:'
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  id: totrans-72
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: Note
  id: totrans-73
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: These refactored examples using some varieties of the list data structure are
    not only streamlined, they are also more performant than their array counterparts.
    For both of these reasons, the list structure is proven as the superior choice
    for this application.
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
- en: Generics
  id: totrans-75
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'You may have noticed the `List<T>.Contains()` method in our C# example or the
    `List<E>.Add()` method in our Java example. These methods are part of classes
    that have been defined as generic. In computer science, generics allow you to
    define a class or method without specifying the data type until the class is declared
    or the method is called. For example, suppose you have a method that adds two
    number values together. In order to work directly with the individual types, you
    could create multiple overloads of an `Add()` method:'
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  id: totrans-77
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'Generics allow you to create a single method that is customized for the type
    that invokes it, greatly simplifying your code. In this example, `T` can be substituted
    for whatever type the caller needs:'
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  id: totrans-79
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'Generics are an incredibly powerful tool, which we will discuss in greater
    detail in [Chapter 12](part0069_split_000.html#21PMQ2-77f2b5b248f04368a6f723b0e9357ef3
    "Chapter 12. Sorting: Bringing Order Out Of Chaos"), *Sorting: Bringing Order
    Out Of Chaos*.'
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
- en: 'Case study: bike route'
  id: totrans-81
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '**Business problem**: A mobile app is to be written for biking enthusiasts
    who like to travel off-road. One of the key business requirements is the ability
    to store waypoints in a route. The route has to have a beginning and an end, and
    it needs to be traversable in both directions. The app also needs the ability
    to modify the biker''s route in real time to allow for detours around hazards,
    visiting rest areas, or adding points of interest.'
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
- en: Due to the nature of the app and its requirements, the class that represents
    the route will need several basic pieces of functionality. First, it will require
    the ability to add, remove, and insert waypoints. Next, it will require the ability
    to start the route and traverse it to route forward and backward. Finally, the
    class should be able to easily identify the start and finish lines as well as
    the currently focused waypoint.
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
- en: Since the nature of this data is such that all waypoints have a spatial relationship
    to one another, and the app must traverse from point to point utilizing that relationship,
    an array would be a poor selection as a data structure. However, since a List
    inherently provides a mechanism for both defining and traversing relationships
    between objects in the collection, the developer has chosen to use a linked list
    structure to build this component.
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
- en: '**C#**'
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
- en: 'C# conveniently exposes a linked list structure through the `LinkedList<T>`
    class and list nodes through the `LinkedListNode<T>` class. Therefore, building
    this class in C# should be a fairly straightforward procedure. Here''s an example
    of what a simple implementation in C# looks like:'
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  id: totrans-87
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'First, we declare two properties. The first is the `route` property, which
    is `LinkedList<Waypoint>`. The next object is the `current` node. We have declared
    both objects without explicitly defining their scope, so they default to `private`.
    We want these fields to be private because we only permit the methods in this
    class to modify their values. Our constructor only instantiates the `route` property
    because the `current` node will be assigned on an as-needed basis:'
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  id: totrans-89
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: The `AddWaypoints(List<Waypoint>)` method allows us to add *1...n* new waypoints
    to the existing route. C# does not provide a mechanism for merging `List<T>` with
    a `LinkedList<T>`, so we must resort to looping through `waypoints` and adding
    the new nodes individually using `LinkedList<T>.AddLast()`, meaning this operation
    costs **O**(*i*), where *i* is the number of elements in the `waypoints` list.
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
- en: 'The `RemoveWaypoint(Waypoint)` method simply calls `LinkedList<T>.Remove()`
    on the route, passing `waypoint` as a parameter. As this is technically a search
    operation, it also costs **O**(*n*):'
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  id: totrans-92
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: The `InsertWaypointsBefore(List<Waypoint>, Waypoint)` method gives our class
    the ability to create alternate routes and add intermediate destinations on-the-fly.
    First, we attempt to locate the `before` node. If we find it, we begin inserting
    the list of new waypoints sequentially before the `before` node. Otherwise, we
    immediately call `AddWaypoints(List<Waypoint>)` to append the new list of waypoints
    onto the route. Although the functionality of this loop may seem quirky, by adding
    each item sequentially just prior to the `before` node, we shift `before` one
    node closer to the tail with each operation, ensuring that each new node is inserted
    in the correct order.
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
- en: 'This is the most expensive operation in this class as it is a combination of
    a search and an insert. This means its operational cost is **O**(*n*+*i*) where
    *n* is the number of elements in the existing `route` collection and *i* is the
    number of elements in the `waypoints` list:'
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  id: totrans-95
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: The `StartRoute()` method is used to set our initial current position and denote
    that it has been deactivated. Since our overall class represents a route, which
    is by definition a 2-dimensional object at the very least, the `StartRoute()`
    method immediately validates that `route` has at least two waypoints. If not,
    we return `false` because the route is not yet ready to be traversed. If we do
    have two or more waypoints, we set the `current` waypoint to the starting line
    and move to the next point. The `StartRoute()` method has an **O**(*1*) operational
    cost.
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
- en: Note
  id: totrans-97
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: We could have easily duplicated the critical code from the `StartingLine()` method
    and the `MoveToNextWaypoint()` method locally in `StartRoute()`. Doing so would
    mean that if we ever wanted to change how we identify the starting line or how
    we navigate the route, we would need to maintain that code in multiple locations.
    By following this pattern of code reuse, we minimize the amount of work and number
    of potential new bugs such a refactor could introduce.
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
- en: Next we'll look at the methods that alter the object's position.
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  id: totrans-100
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: The `MoveToNextWayPoint()` and `MoveToPreviousWaypoint()` methods introduce
    our route traversal functionality. In `MoveToNextWaypoint()`, we check that the
    current waypoint is not `null`, and then we deactivate it. Next, we check whether
    we are at the finish line, and if not, we set `current` to the next node in `route`
    and return `true`. The `MoveToPreviousWaypoint()` method verifies that `current`
    is not `null` and makes sure that we are not at the starting line. If so, we move
    `current` to the previous waypoint and reactivate it. If any of our checks in
    these two methods fail, we return `false`. Each of these methods has an **O**(*1*)
    operational cost.
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
- en: Note
  id: totrans-102
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: This dual `false` return seen in `MoveToNextWaypoint()` may seem like a design
    flaw, but remember that our class is not responsible for the overall functionality
    of the app, only the functionality of the route. It is the responsibility of the
    *caller* to check whether the route is ready to traverse before calling `MoveToNextWaypoint()`.
    Our return value is only signaling the success or failure of the operation.
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
- en: 'Lastly, we''ll look at the methods that indicate position:'
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  id: totrans-105
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: We add the `StartingLine()` and `FinishLine()` methods to expose the head and
    tail nodes of the route collection. Finally, we add the `CurrentPosition()` method
    to expose which node in the route is our next immediate destination. Each of these
    methods has an **O**(*1*) operational cost.
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
- en: '**Java**'
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
- en: 'Java also exposes a linked list data structure through the `LinkedList<E>`
    class. However, Java does not provide an implementation of the list node structure.
    This is because, in Java, you generally do not work with the nodes directly but
    through a list iterator. The `ListIterator<E>` class provides the necessary functionality
    to implement a linked list structure in the basic sense. If we needed our own
    node class, it would be easy to implement one. Here''s an example of what a simple
    implementation of our `WaypointList` class might look like in Java:'
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  id: totrans-109
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'First, we declare two properties. The first is the `route`, which is an abstract
    `List<Waypoint>`, and the next object is the `current` node. We have declared
    both objects without explicitly defining their scope, so they default to `package-private`,
    which is fine for our case. We want these fields to be private because we only
    permit the methods in this class to modify their values. Our constructor only
    instantiates the `route` because the `current` node will be assigned on an as-needed
    basis:'
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  id: totrans-111
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'The `AddWaypoints(List<Waypoint>)` method allows us to add *1..*.*n* new waypoints
    to the existing route. We append objects to our list using the `LinkedList<E>.addAll()`
    method. This operation is quite simple and costs **O**(*1*). The `RemoveWaypoint(Waypoint)`
    method simply calls `LinkedList<E>.remove()` on the route, passing `waypoint`
    as a parameter. As this is technically a search operation, it costs **O**(*n*):'
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  id: totrans-113
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: The `InsertWaypointsBefore(List<Waypoint>, Waypoint)` method gives our class
    the ability to create alternate routes and add intermediate destinations on the
    fly. First, we attempt to locate the `before` node using `LinkedList<E>.indexOf()`.
    The `indexOf()` method returns `-1` if it cannot find the object, so we confirm
    that the value is greater than `-1`; otherwise we immediately call `AddWaypoints(List<Waypoint>)`
    to append the new list of waypoints onto the route. If the `before` node is valid,
    we add the list of new waypoints before the `before` node.
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
- en: 'This is the most expensive method operation in this class as it is a combination
    of a search and an insert. This means its operational cost is **O**(*n*+*i*),
    where *n* is the number of elements in the existing `route` and *i* is the number
    of elements in the waypoints list:'
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  id: totrans-116
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'The `StartRoute()` method is used to set our initial current position and denote
    that it has been deactivated. Since our overall class represents a route, which
    is by definition a 2-dimensional object at the very least, the `StartRoute()`
    method immediately validates that `route` has at least two waypoints, and if not,
    we return `false` because `route` is not yet ready to be traversed. If we do have
    two or more waypoints, we set the `current` waypoint to the starting line and
    move to the next point. `StartRoute()` has an **O**(1) operational cost:'
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  id: totrans-118
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'The `MoveToNextWayPoint()` and `MoveToPreviousWaypoint()` methods introduce
    our route traversal functionality. In the `MoveToNextWaypoint()` method, we check
    whether the current waypoint is not `null`, and then we deactivate it. Next, we
    check whether we are not at the finish line, and if not, we set `current` to the
    next by assigning it to the `listIterator` property and the `next()` method of
    `route`, and then return `true`. The `MoveToPreviousWaypoint()` method verifies
    that `current` is not `null` and makes sure that we are not at the starting line.
    If so, we set `current` to the previous waypoint and reactivate it. If any of
    our checks in these two methods fail, we return `false`. Due to the need to search
    for a match for `current`, each of these methods has an **O**(*n*+1) operational
    cost:'
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  id: totrans-120
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: We add the `StartingLine()` and `FinishLine()` methods to expose the head and
    tail nodes of the route collection. Finally, we add the `CurrentPosition()` method
    to expose which node in the route is our next immediate destination. Each of these
    methods has an **O**(1) operational cost.
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
- en: '**Objective-C**'
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
- en: 'Objective-C does not expose any implementation of a linked list out-of-the-box.
    Although we could create our own implementation, the purpose of this text is to
    demonstrate the best approach given the tools available. For this scenario, we
    will once again use the class cluster, `NSMutableArray`. Here''s a simple example
    of how the `EDSWaypointList` class might be implemented in Objective-C:'
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  id: totrans-124
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'First, we declare two `ivar` properties. The first is `_route`, which is an
    `NSMutableArray` array. The next object is the `_current` node. Again, we have
    declared these as ivars because we only permit the methods in this class to modify
    their values. Our initializer only instantiates the `_route` because the `_current`
    node will be assigned on an as-needed basis:'
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  id: totrans-126
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: The `addWaypoints:` method allows us to add *1...n* new waypoints to the existing
    route. `NSMutableArray` allows us to merge the new array with the existing route
    by calling `addObjectsFromArray:`. This operation is quite simple and costs **O**(*1*).
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
- en: 'The `removeWaypoint:` method confirms that `_route` contains `waypoint` using
    `containsObject:`, then calls `removeObject:`. If we were not concerned with the
    success or failure of this operation, we could have simply called `removeObject:`
    and moved on. Note that, since our `_route` object is an array-backed list, it
    allows for **O**(*1*) search operations. Since we do not know the index of waypoint
    in advance, the `removeObject:` operation still costs **O**(*n*):'
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  id: totrans-129
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'The `insertWaypoints:beforeWaypoint:` method gives our class the ability to
    create alternate routes and add intermediate destinations on the fly. First, we
    attempt to locate the `before` node using `indexOfObject:`. If we cannot find
    it, we immediately call `addWaypoints:` to append the new list of waypoints onto
    the route. Otherwise, we create some ugly code to define an `NSRange` object and
    an `NSIndexSet` object, and use these with `insertObjects:atIndexes:`. Since this
    method represents a search and an insert, its operational cost is **O**(*n*+1),
    where *n* is the number of elements in the existing `_route` object:'
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  id: totrans-131
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: The `startRoute:` method is used to set our initial current position and denote
    that it has been deactivated. Since our overall class represents a route, which
    is by definition a 2-dimensional object at the very least, the `startRoute:` method
    immediately validates that `_route` has at least two waypoints; if not we return
    `NO` because the route is not yet ready to be traversed. If we do have two or
    more waypoints, we set the `_current` waypoint to the starting line and move to
    the next point. `startRoute:` has an **O**(1) operational cost.
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  id: totrans-133
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: 'In `moveToNextWaypoint:`, we check whether the current waypoint is not `nil`,
    and then we deactivate it. Next, we verify that we are not at the finish line,
    and if not, we get the index of `_current` in the list and assign the next highest
    index object to the property, then return `YES`. The `moveToPreviousWaypoint:`
    method verifies that `_current` is not `nil`, and makes sure that we are not at
    the starting line. If so, we set `_current` to the previous waypoint and reactivate
    it, and then we return `YES`. If any of our checks in these two methods fail,
    we return `NO`. Due to the need to search for a match for `_current`, each of
    these methods has an **O**(*n*+1) operational cost:'
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  id: totrans-135
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: We add the `startingLine:` and `finishLine:` methods to expose the head and
    tail nodes of the route collection. Finally, we add the `currentPosition:` method
    to expose which node in the route is our next immediate destination. Each of these
    methods has an **O**(1) operational cost.
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
- en: '**Swift**'
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
- en: 'Similar to Objective-C, Swift does not expose any implementation of a linked
    list data structure. Therefore, we will use the Swift `Array` class to create
    our data structure. Here''s a simple example of how this class might be implemented
    using Swift:'
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  id: totrans-139
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: 'First, we declare two properties. The first is `_route`, which is an array.
    The next object is the `_current` node, which is a `Waypoint` object, flagged
    as `optional`. Again, we have declared these as private because we only permit
    the methods in this class to modify their values. Our initializer does not need
    to instantiate either object because the declaration instantiates `_route`, and
    `_current` is flagged as `optional` and will only be assigned on an as-needed
    basis:'
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  id: totrans-141
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: The `addWaypoints(Array<Waypoint>)` method allows us to add *1..*.*n* new waypoints
    to the existing route. `Array` allows us to merge the new array with the existing
    route by calling `appendContentsOf(Array)`. This operation is quite simple and
    costs **O**(1).
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
- en: 'The `removeWaypoint(Waypoint)` method confirms that `_route` contains `waypoint`
    and gets its index in one operation by calling `if .. indexOf()`. If we do not
    retrieve an index, we return `false`, otherwise we call `removeAtIndex()` and
    return `true`. Note that, since our `_route` object is an array-backed list, the
    `removeAtIndex()` operation only costs **O**(1):'
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  id: totrans-144
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: 'The `insertWaypoints(Array<Waypoint>, Waypoint)` method first attempts to locate
    the `before` node using `if..indexOf()`. If we cannot find it, we immediately
    call `addWaypoints()` to append the new list of waypoints onto the route. Otherwise,
    we call `insertContentOf()`. Since this method represents a search and an insert,
    its operational cost is **O**(*n*+1), where *n* is the number of elements in the
    existing _`route`:'
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  id: totrans-146
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: 'The `startRoute:` object is used to set our initial current position and denote
    that it has been deactivated. If we have two or more waypoints, we set the `_current`
    waypoint to the starting line and move to the next point. The `startRoute()` object
    has an **O**(1) operational cost:'
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  id: totrans-148
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: 'In `moveToNextWaypoint()`, we verify that the current waypoint is not `nil`,
    and then we deactivate it. Next, we confirm that we are not at the finish line;
    and if not, we get the index of `_current` in the list, and assign the next highest
    index object to `_current`, and then we return `true`. The `moveToPreviousWaypoint()`
    method verifies that `_current` is not `nil` and makes sure that we are not at
    the starting line. If so, we set `_current` to the previous waypoint, reactivate
    it, and return `YES`. If any of our checks in these two methods fail, we return
    `NO`. Due to the need to search for a match for `_current`, each of these methods
    has an **O**(*n*+1) operational cost:'
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  id: totrans-150
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: We add the `startingLine()` and `finishLine()` methods to expose the head and
    tail nodes of the route collection. Finally, we add the `currentPosition()` method
    to expose which node in the route is our next immediate destination. Each of these
    methods has an **O**(1) operational cost.
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
- en: Doubly linked list
  id: totrans-152
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: A doubly linked list has the added overhead of *n* additional pointers where
    *n* is the length of the list. This additional pointer provides for simple reverse-traversal
    of the list. The added overhead is somewhat negligible and can typically be ignored
    except in very special cases. The append, insert, and remove operations still
    only cost **O**(1).
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
- en: Searching
  id: totrans-154
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Array backed lists provides a **O**(1) operational cost for searches if the
    index of the object is known in advance. Otherwise, all searches in lists cost
    **O**(n) for unsorted lists and **O**(log *n*) for sorted lists where a binary
    search pattern is applied. Binary search algorithms will be discussed in much
    greater detail in [Chapter 13](part0076_split_000.html#28FAO1-77f2b5b248f04368a6f723b0e9357ef3
    "Chapter 13. Searching: Finding What You Need"), *Searching: Finding What You
    Need*.'
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
- en: A few pointers
  id: totrans-156
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Many languages view memory as a series of successive cells, each a certain
    number of bytes in size and each with a unique address. Pointers are memory management
    tools, which are really objects that reference, or point to, a memory cell''s
    address. By utilizing pointers, a program can store objects in memory that are
    themselves larger than a single memory block. Some languages use the `*` operator
    to denote the assignment of a pointer. If you use Objective-C, or if you have
    worked with C/C++, you will already be very familiar with this operator. C#, Java,
    and Swift developers won''t have had too much experience with this operator, but
    you should be familiarize yourself with how pointers work anyway, and here''s
    why:'
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
- en: When an object in memory no longer has a pointer referencing its memory address,
    it should be de-allocated or removed from memory. Removing unused objects to prevent
    them from filling up memory is known as **memory management**. In some older languages,
    managing memory pointers is a tedious and often bug-prone task for the uninitiated.
    Most modern languages spare us from this drudgery through the use of some form
    of memory management device. C#, Java, and Swift use what's known as **Garbage
    Collection** (**GC**), while modern Objective-C provides **Automatic Reference
    Counting** (**ARC**) for automatic memory management.
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
- en: Although these tools are great, you should not rely too completely on GC or
    ARC to manage your memory. GC and ARC are not perfect to start with, but both
    can be thwarted by a poor implementation. What will separate programmers from
    engineers is the ability to diagnose and repair memory management issues. Understanding
    pointers and their use will better equip you to catch what GC or ARC can very
    often miss.
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
- en: A deeper discussion on pointers is beyond the scope of this book, but you should
    definitely take the time to research and familiarize yourself with this topic.
    Better still, spend some time writing code in a language that utilizes manual
    memory management like C or C++. Your career will thank you.
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  id: totrans-161
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, you learned the basic definition of the list structure, including
    the difference between sorted and unsorted list and array-backed versus linked
    lists. We discussed how to initialize lists or pseudo lists in each of the four
    languages we utilize in this text. We revisited the logged-in users class to see
    if we could improve its performance using lists instead of arrays and learned
    about interesting differences between the four languages including their use of
    generics and class clusters in the process. Next, we created a class to represent
    a route for biking enthusiasts, taking advantage of the properties of linked lists
    to manipulate and dynamically alter our collection of waypoints on the fly.
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
- en: In our advanced topics section, we examined different implementations of list
    structures in more detail, including array-based lists, (singly) linked lists,
    and doubly linked lists. Finally, for each implementation, we evaluated the performance
    of basic operations including appending, inserting, removing, and searching nodes.
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
