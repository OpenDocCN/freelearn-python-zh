- en: 'Chapter 3. Lists: Linear Collections'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第3章 列表：线性集合
- en: In our last chapter, we introduced the array data structure upon which many
    of the structures we will examine in this text are based. Although arrays provide
    good performance for static collections of data, our coding examples proved that
    they are inflexible and inefficient for many applications--so much so that even
    something as simple as adding or deleting an element from a collection is an extremely
    complex and costly operation.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们上一章中，我们介绍了数组数据结构，这是我们将在本文中探讨的许多结构的基础。尽管数组为静态数据集合提供了良好的性能，但我们的编码示例证明，对于许多应用来说，它们既不灵活也不高效——以至于从集合中添加或删除一个元素这样的简单操作都变得极其复杂且成本高昂。
- en: Lists are, in some ways, an evolution of the array. A list can be defined as
    a finite, ordered series of objects or values called **elements**. An empty list
    is a list with no elements, while the length of a list is the total number of
    elements in the collection. The first item in a list is called the **head**, while
    the last item is called the **tail**. In a list with a length of 1, the head and
    tail are the same object.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 在某些方面，列表是数组的演变。列表可以被定义为有限、有序的对象或值的序列，称为**元素**。空列表是没有元素的列表，而列表的长度是集合中元素的总数。列表中的第一个项目称为**头**，而最后一个项目称为**尾**。在长度为1的列表中，头和尾是同一个对象。
- en: Note
  id: totrans-3
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: While arrays are a *concrete* data structure, a list is an abstract concept
    of a data structure that many languages provide a concrete implementation of.
    We will examine this distinction in more detail with one of the Java examples
    later in this chapter.
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然**数组**是一种**具体**的数据结构，但**列表**是数据结构的一个抽象概念，许多语言都提供了具体的实现。我们将在本章后面的Java示例中更详细地探讨这种区别。
- en: Ordered lists should not be confused with sorted lists because lists can be
    either **sorted** or **unsorted**. Ordered simply means that each element has
    a defined position in the list. Objects in a sorted list have some type of relationship
    between them, while objects in an unsorted list have no notable relationship.
    For example, when my wife creates a shopping list, she sits down and carefully
    organizes the groceries in relation to how she knows the supermarket is arranged.
    Items on her list are types of groceries and they are arranged according to their
    relative positions in the supermarket so they have a *spatial relationship*. This
    is a sorted list. I, on the other hand, create a shopping list by slapping a piece
    of paper on the fridge and scribbling items on the paper as I notice shelves are
    empty or containers are missing. Although the items on my list are all types of
    groceries, they are not arranged in any particular way so they have *no notable
    relationship* to one another. This is an example of an unsorted list.
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 有序列表不应与排序列表混淆，因为列表可以是**排序**的或**未排序**的。有序仅仅意味着每个元素在列表中都有一个定义的位置。排序列表中的对象之间存在某种关系，而未排序列表中的对象之间没有显著的关系。例如，当我的妻子创建购物清单时，她会坐下来并仔细组织杂货，使其与她对超市的布局的了解相关。她清单上的项目是杂货的类型，并且它们根据在超市中的相对位置排列，因此它们有**空间关系**。这是一个排序列表。另一方面，我创建购物清单时，会在冰箱上贴一张纸，并在注意到架子空了或容器缺失时在纸上乱写项目。尽管我清单上的项目都是杂货的类型，但它们没有以任何特定的方式排列，因此它们之间没有**显著的关系**。这是一个未排序列表的例子。
- en: 'In this chapter we will cover the following:'
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: 本章我们将涵盖以下内容：
- en: Definition of a list data structure
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 列表数据结构的定义
- en: Initializing lists
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 初始化列表
- en: Example applications for lists
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 列表的应用示例
- en: List implementations
  id: totrans-10
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 列表实现
- en: Append, insert, and remove operations
  id: totrans-11
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 追加、插入和删除操作
- en: Array-based lists
  id: totrans-12
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 基于数组的列表
- en: Linked lists
  id: totrans-13
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 链表
- en: Doubly linked lists
  id: totrans-14
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 双向链表
- en: Searching
  id: totrans-15
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 搜索
- en: List implementations
  id: totrans-16
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 列表实现
- en: One of the most common implementations of the list data structure is the *array-based*
    list. Generally speaking, an array-based list is simply a contiguous list of array
    positions, each holding a *pointer* to a list element. Since the list is based
    on an array, its functionality and performance are very similar to that of an
    array.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 列表数据结构最常见的实现之一是**基于数组**的列表。一般来说，基于数组的列表只是一个连续的数组位置列表，每个位置都持有指向列表元素的**指针**。由于列表基于数组，其功能和性能与数组非常相似。
- en: As seen in the previous examples, another common implementation is the **linked
    list**. A linked list is also a sequence of elements, except most implementations
    refer to the elements as **nodes**. In a linked list, the pointers to the elements
    are not contained in an array structure, but rather a pointer exists in memory
    to identify the first node. Then each node contains a link to the subsequent node
    in the list.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 如前例所示，另一种常见的实现是**链表**。链表也是一个元素序列，但大多数实现将元素称为**节点**。在链表中，元素的指针不包含在数组结构中，而是在内存中存在一个指针来标识第一个节点。然后每个节点都包含指向列表中后续节点的链接。
- en: Finally, there is the **doubly linked list**. In a doubly linked list, each
    node contains a link to both the subsequent node in the list and the previous
    node in the list. A doubly linked list makes traversing the list bidirectionally
    a much simpler process. The previous link in the head node and the next link in
    the tail node are both null. An alternative to this is to have the previous link
    in the head node point to the tail and the next link in the tail node point to
    the head, which changes the doubly linked list to a **circular linked list**.
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，还有**双向链表**。在双向链表中，每个节点都包含指向列表中后续节点和前一个节点的链接。双向链表使得双向遍历列表变得更加简单。头节点的上一个链接和尾节点的下一个链接都是空的。另一种选择是将头节点的上一个链接指向尾节点，尾节点的下一个链接指向头节点，这样双向链表就变成了**循环链表**。
- en: Note
  id: totrans-20
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: The term doubly linked list is not used very often, but if you work with the
    `LinkedList` classes in Java or C#, you are in fact working with a doubly linked
    list. C# and Java do not provide a **singly linked list** type, and the doubly
    linked list provides you with the same functionality and more, so you should never
    need one. However, you could easily implement one of your own if you really wanted
    to for academic purposes.
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 双向链表这个术语并不常用，但如果你在使用Java或C#中的`LinkedList`类，实际上你就是在使用双向链表。C#和Java没有提供**单链表**类型，双向链表为你提供了相同的功能甚至更多，所以你通常不需要它。然而，如果你真的出于学术目的想要实现一个，那也很容易做到。
- en: Typically, each of the concrete implementations of this structure provides you
    with convenience methods allowing you to append, insert, and remove elements from
    the list. Both array-based and link-based lists provide access to the basic append,
    insert, and remove operations. However, the way in which these operations are
    implemented and their associated cost vary slightly between the two implementations.
    Where existing methods for this functionality are not baked in, it is typically
    a trivial exercise to create that functionality.
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 通常，这个结构的每个具体实现都为你提供了方便的方法，允许你从列表中追加、插入和删除元素。基于数组和基于链接的列表都提供了访问基本追加、插入和删除操作的方法。然而，这些操作的实施方式和它们相关的成本在这两种实现之间略有不同。如果现有的方法没有内置，那么创建这种功能通常是一个简单的练习。
- en: Note
  id: totrans-23
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: As with other implementations of abstract data structures, when given a choice between
    using methods we create ourselves and any methods provided by the framework, choose
    the latter as they will typically be more robust and reliable.
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 与其他抽象数据结构的实现一样，当在创建我们自己的方法和框架提供的任何方法之间做出选择时，选择后者，因为它们通常会更健壮和可靠。
- en: Array-based lists
  id: totrans-25
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 基于数组的列表
- en: 'The append operation in an array-based list costs **O**(*1*), as we can always
    determine the new element''s position by simply incrementing the index of the
    tail position:'
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 在基于数组的列表中，追加操作的成本是**O**(*1*)，因为我们总能通过简单地增加尾位置的索引来确定新元素的位置：
- en: '![Array-based lists](img/00003.jpeg)'
  id: totrans-27
  prefs: []
  type: TYPE_IMG
  zh: '![基于数组的列表](img/00003.jpeg)'
- en: Whenever we insert an element into an array-based list, we need to also manage
    the position of the existing objects in the array to accommodate the new nodes.
    Inserting an element into the list at index *i* requires us to shift all of the
    elements in positions greater than *i* one position toward the tail, meaning that
    we will need to perform *n* - *i* operations where there are *n* elements already
    in the list. Inserting at the head position is a worst-case operation, costing
    **O**(*n*). Since we always count the cost of the worst case when evaluating an
    algorithm's efficiency, inserting an element costs **O**(*n*).
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 每当我们向基于数组的列表中插入一个元素时，我们还需要管理数组中现有对象的位置以容纳新的节点。在索引*i*处插入元素需要我们将*i*之后的所有元素向尾部移动一个位置，这意味着我们需要执行*n*
    - *i*次操作，其中*n*是列表中已有的元素数量。在头部位置插入是一个最坏情况的操作，耗时**O**(*n*)。由于我们在评估算法效率时总是计算最坏情况下的成本，因此插入一个元素的成本是**O**(*n*)。
- en: 'Removing an element from the list at index *i* requires us to shift all of
    the elements in positions greater than *i* one position toward the head, meaning
    that we will need to perform *n* - *i*- 1 operations where there are *n* elements
    in the list. Removing from the head position is a worst-case operation, costing
    **O**(*n*). Therefore, removing an element costs **O**(*n*), as depicted in the
    following diagram:'
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 从索引*i*处删除列表中的元素需要我们将*i*之后的所有元素向头部移动一个位置，这意味着我们需要执行*n* - *i*- 1次操作，其中*n*是列表中的元素数量。从头部位置删除是一个最坏情况的操作，耗时**O**(*n*)。因此，删除一个元素的成本是**O**(*n*)，如下图中所示：
- en: '![Array-based lists](img/00004.jpeg)'
  id: totrans-30
  prefs: []
  type: TYPE_IMG
  zh: '![基于数组的列表](img/00004.jpeg)'
- en: Linked list
  id: totrans-31
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 链表
- en: As with an array-based list, the append operation costs **O**(*1*). However,
    the insert and remove operations also cost **O**(*1*). One of the key advantages
    of the linked list over the array-based list is mutability. Unlike an array, a linked
    list is a series of discrete objects related to one another by memory pointers,
    so inserting or removing elements is simply a matter of adding or modifying those
    pointers. In other words, a linked list is capable of growing and shrinking to
    accommodate additions to and deletions from the collection in a very efficient
    manner.
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 与基于数组的列表一样，追加操作的成本是**O**(*1*)。然而，插入和删除操作的成本也是**O**(*1*)。与基于数组的列表相比，链表的一个关键优势是可变性。与数组不同，链表是一系列通过内存指针相互关联的离散对象，因此插入或删除元素只是简单地添加或修改这些指针。换句话说，链表能够以非常高效的方式根据集合的增加和删除进行扩展和收缩。
- en: '![Linked list](img/00005.jpeg)'
  id: totrans-33
  prefs: []
  type: TYPE_IMG
  zh: '![链表](img/00005.jpeg)'
- en: If we wish to insert an element at position *i*, we need to change the original
    pointer *i* - 1 -> *i* to point to our new element at *i*, and insert a new pointer
    for *i* -> *i* + 1\. Similarly, removing an element at *i* requires adjusting
    the pointer from *i* - 1 -> *i* and making it *i* - 1 -> *i* + 1.
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们想在位置*i*插入一个元素，我们需要将原始指针*i* - 1 -> *i*改为指向我们的新元素*i*，并插入一个新的指针*i* -> *i* +
    1。同样，删除位置*i*的元素需要调整指针从*i* - 1 -> *i*到*i* - 1 -> *i* + 1。
- en: Instantiating lists
  id: totrans-35
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 实例化列表
- en: Like other data structures, lists must be defined and instantiated prior to
    being used. Each of the four languages that we will examine in this text has varying
    support for, and unique implementations of, the list data structure. Let's briefly
    examine how to instantiate a list in each language.
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 与其他数据结构一样，列表在使用之前必须定义和实例化。我们将在这篇文本中检查的四种语言对列表数据结构的支持各有不同，并且具有独特的实现方式。让我们简要地看看如何在每种语言中实例化一个列表。
- en: '**C#**'
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: '**C#**'
- en: 'Instantiating lists in C# requires the use of the `new` keyword:'
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 在C#中实例化列表需要使用`new`关键字：
- en: '[PRE0]'
  id: totrans-39
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: The C# `ArrayList` class originated in .NET 1.0, and it is not used very often
    anymore. Most developers prefer to use the generic concrete implementation, `List<of
    T>`, for an array-based list. This is also true for the generic concrete linked
    list implementation, `LinkedList<of T>`. There is no non-generic linked list data
    structure in C#.
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: C#的`ArrayList`类起源于.NET 1.0，现在使用得不太多了。大多数开发者更喜欢使用基于数组的列表的泛型具体实现，即`List<of T>`。这同样适用于泛型具体链表实现，即`LinkedList<of
    T>`。在C#中没有非泛型链表数据结构。
- en: '**Java**'
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: '**Java**'
- en: 'Like C#, initializing a list in Java requires the use of the `new` keyword:'
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 与C#类似，在Java中初始化列表也需要使用`new`关键字：
- en: '[PRE1]'
  id: totrans-43
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: Java developers will create an array-based list using a concrete implementation
    of the generic abstract `List<E>` class. This is also true of the concrete linked
    list implementation, `LinkedList<E>`. There is no non-generic linked list data
    structure in Java.
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: Java开发者将使用`List<E>`类的具体实现来创建一个基于数组的列表。这同样适用于具体的链表实现，即`LinkedList<E>`。Java中没有非泛型的链表数据结构。
- en: '**Objective-C**'
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: '**Objective-C**'
- en: 'The process of creating a list in Objective-C is as follows:'
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 在Objective-C中创建列表的过程如下：
- en: '[PRE2]'
  id: totrans-47
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: If you read the chapter on arrays, this example has probably caught your attention.
    In fact, this is not a mistake. The closest implementation for an array-based
    list in Objective-C is found in the `NSArray` class, while the closest implementation
    of a linked list is found in the `NSMutableArray` class. That's because `NSArray`
    and `NSMutableArray` are known as **class clusters**. Class clusters provide public
    APIs that are really abstract classes. When you initialize one of these classes
    you get back the concrete implementation of a data structure, which is custom
    tailored for the data you provided. These implementations can even change at runtime
    if the nature of the data set changes, making array classes extremely flexible.
    This means that many of the data structures we will discuss in this text will
    be implemented in Objective-C (and Swift) by only three abstract classes.
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你阅读了关于数组的章节，这个例子可能引起了你的注意。实际上，这并不是一个错误。在Objective-C中，基于数组的列表最接近的实现可以在`NSArray`类中找到，而链表的最接近实现可以在`NSMutableArray`类中找到。这是因为`NSArray`和`NSMutableArray`被称为**类簇**。类簇提供了真正的抽象类公共API。当你初始化这些类之一时，你会得到一个针对你提供的数据定制的具体数据结构实现。这些实现甚至可以在运行时根据数据集的性质变化而变化，使得数组类非常灵活。这意味着我们将在本文中讨论的许多数据结构都只通过三个抽象类在Objective-C（和Swift）中实现。
- en: Note
  id: totrans-49
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: '**Class clusters in Objective-C**'
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: '**Objective-C中的类簇**'
- en: Class clusters are a design pattern based on the **Abstract Factory** pattern,
    which returns a type adhering to a certain interface (C#/Java) or protocol (Objective-C/Swift).
    They are leveraged heavily in the **Foundation** framework and this is a good
    thing.
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 类簇是基于**抽象工厂**模式的设计模式，该模式返回一个遵循特定接口（C#/Java）或协议（Objective-C/Swift）的类型。它们在**Foundation**框架中被大量使用，这是一个好事。
- en: Class clusters group private, concrete subclasses under an abstract superclass
    or API. This public API is much simpler to work with than working with each subclass
    directly. `NSNumber`, `NSString`, `NSArray`, and `NSDictionary` are all examples
    of class clusters in Foundation.
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 类簇将私有、具体的子类分组在抽象超类或API下。与直接处理每个子类相比，这个公共API更容易使用。`NSNumber`、`NSString`、`NSArray`和`NSDictionary`都是Foundation中类簇的例子。
- en: '**Swift**'
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: '**Swift**'
- en: 'Finally, here''s how to instantiate a list in Swift:'
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，这是在Swift中实例化列表的方法：
- en: '[PRE3]'
  id: totrans-55
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: Swift also uses class clusters for many different abstract collections. For
    lists, we use the `Array` class, which is both generic and mutable by default.
    There is a shorthand and an explicit declaration for arrays in Swift. Although
    more verbose, the explicit definition more clearly demonstrates the generic nature
    of the API.
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: Swift也使用类簇来表示许多不同的抽象集合。对于列表，我们使用`Array`类，它默认既泛型又可变。Swift中数组有简写和显式声明两种形式。尽管更冗长，但显式定义更清楚地展示了API的泛型特性。
- en: Revisiting users logged in to a service
  id: totrans-57
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 重新访问登录到服务的用户
- en: 'In [Chapter 2](part0019_split_000.html#I3QM2-77f2b5b248f04368a6f723b0e9357ef3
    "Chapter 2.  Arrays: Foundational Collections"), *Arrays: Foundational Structures*, we
    created an app to keep track of users logged into a web service, using an array
    as the underlying data structure containing the `User` objects. However, this
    design can be greatly improved upon by using a list data structure. Let''s revisit
    the users logged into a service problem here, and by replacing the class array
    with a list, we will see that our original code is both abbreviated and more readable
    in most cases.'
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 在[第2章](part0019_split_000.html#I3QM2-77f2b5b248f04368a6f723b0e9357ef3 "第2章。数组：基础集合")，“数组：基础结构”中，我们创建了一个应用程序来跟踪登录到网络服务的用户，使用数组作为包含`User`对象的底层数据结构。然而，通过使用列表数据结构，这个设计可以大大改进。在这里，让我们重新审视登录到服务的用户问题，并通过用列表替换类数组，我们将看到在大多数情况下我们的原始代码既简短又易于阅读。
- en: '**C#**'
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: '**C#**'
- en: 'In this example, we have replaced the `User[]` object with a `List<User>` object.
    Much of this refactor is obvious, but three lines of code should be noted. First,
    in the `CanAddUser()` method, we have replaced 15 lines of code with 2 lines of
    code by leveraging the `List<T>.Contains()` method and condensing our logic loop.
    Next, in the `UserAuthenticated()` method, we have leveraged the `List<T>.Add()`
    method, which replaced the call to `Array.Resize()` and the error-prone approach
    to assigning an object using the subscription operator. Finally, we replaced nearly
    20 lines of complex and ugly code using the `List<T>.Remove()` method. The convenience
    and power afforded by this wrapper class should be obvious based solely on the
    abbreviated code:'
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个例子中，我们将`User[]`对象替换为了`List<User>`对象。大部分的代码重构都是显而易见的，但有三行代码需要特别注意。首先，在`CanAddUser()`方法中，我们通过利用`List<T>.Contains()`方法将15行代码缩减为2行，并简化了我们的逻辑循环。接下来，在`UserAuthenticated()`方法中，我们使用了`List<T>.Add()`方法，这替代了对`Array.Resize()`的调用以及使用下标操作符赋值时容易出错的方法。最后，我们使用`List<T>.Remove()`方法替换了近20行复杂且难看的代码。仅从缩短的代码来看，这个包装类提供的便利和功能应该是显而易见的：
- en: '[PRE4]'
  id: totrans-61
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: '**Java**'
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: '**Java**'
- en: 'In this example, we have replaced the `User[]` object with a `List<User>` object.
    Much of this refactor is obvious, but three lines of code should be noted. First,
    in the `CanAddUser()` method, we have replaced 15 lines of code with 2 lines of
    code by leveraging the `List<E>.contains()` method and condensing our logic loop.
    Next, in the `UserAuthenticated()` method, we are leveraging the `List<E>.add()`
    method, which replaced the call to `Array.copyOf()` and the error-prone approach
    to assigning an object using the subscription operator. Finally, we replaced nearly
    20 lines of complex and ugly code using the `List<E>.remove()` method:'
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个例子中，我们将`User[]`对象替换为了`List<User>`对象。大部分的代码重构都是显而易见的，但有三行代码需要特别注意。首先，在`CanAddUser()`方法中，我们通过利用`List<E>.contains()`方法将15行代码缩减为2行，并简化了我们的逻辑循环。接下来，在`UserAuthenticated()`方法中，我们使用了`List<E>.add()`方法，这替代了对`Array.copyOf()`的调用以及使用下标操作符赋值时容易出错的方法。最后，我们使用`List<E>.remove()`方法替换了近20行复杂且难看的代码：
- en: '[PRE5]'
  id: totrans-64
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: The following screenshot demonstrates another benefit of using generic classes
    when available. As you can see, our code  completion, or **Intellisense**, suggests
    potential completion options including the proper type to be included in the collection.
    This can save you from having to check back repeatedly to make sure that you are
    using the correct object and collection, which is both time-consuming and annoying.
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 以下截图展示了当可以使用泛型类时使用泛型类的另一个好处。正如你所见，我们的代码补全，或称为**Intellisense**，建议了可能的补全选项，包括应包含在集合中的正确类型。这可以避免你反复检查以确保使用正确的对象和集合，这既耗时又令人烦恼。
- en: '![Revisiting users logged in to a service](img/00006.jpeg)'
  id: totrans-66
  prefs: []
  type: TYPE_IMG
  zh: '![重新访问已登录服务的用户](img/00006.jpeg)'
- en: '**Objective-C**'
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: '**Objective-C**'
- en: 'In this example, we have replaced the `NSArray _users` object with an `NSMutableArray
    _users` object. In this example, besides some consolidation and code cleanup,
    there is really only one refactor. In `userLoggedOut:`, we replaced nearly 20
    lines of complex and ugly code using the `NSMutableArray removeObject:` method
    instead of checking indices, looping, and merging objects:'
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个例子中，我们将`NSArray _users`对象替换为了`NSMutableArray _users`对象。在这个例子中，除了某些合并和代码清理之外，实际上只有一个重构。在`userLoggedOut:`中，我们使用`NSMutableArray
    removeObject:`方法替换了近20行复杂且难看的代码，而不是检查索引、循环和合并对象：
- en: '[PRE6]'
  id: totrans-69
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: '**Swift**'
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: '**Swift**'
- en: 'If you look carefully at this code in comparison to the original, you''ll see
    that effectively they are the same! That''s because Swift `Arrays` are already
    mutable and they already support generic types, so our original `LoggedInUserArray`
    class was already functioning as much like a linked, as Swift is capable of producing
    output with out-of-the-box code. We could create our own implementation of a linked
    list in Swift but that would only be necessary in very specific use cases:'
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你仔细比较这段代码与原始代码，你会发现它们实际上是相同的！这是因为Swift的`Arrays`已经是可变的，并且已经支持泛型类型，所以我们的原始`LoggedInUserArray`类已经像Swift那样能够通过现成的代码产生输出，表现得像是一个链表。我们可以在Swift中创建自己的链表实现，但这只有在非常特定的用例中才是必要的：
- en: '[PRE7]'
  id: totrans-72
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: Note
  id: totrans-73
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: These refactored examples using some varieties of the list data structure are
    not only streamlined, they are also more performant than their array counterparts.
    For both of these reasons, the list structure is proven as the superior choice
    for this application.
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 这些使用列表数据结构各种变体的重构示例不仅流程简化，而且比它们的数组对应物性能更优。出于这两个原因，列表结构被证明是此应用的更优选择。
- en: Generics
  id: totrans-75
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 泛型
- en: 'You may have noticed the `List<T>.Contains()` method in our C# example or the
    `List<E>.Add()` method in our Java example. These methods are part of classes
    that have been defined as generic. In computer science, generics allow you to
    define a class or method without specifying the data type until the class is declared
    or the method is called. For example, suppose you have a method that adds two
    number values together. In order to work directly with the individual types, you
    could create multiple overloads of an `Add()` method:'
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 你可能已经注意到了我们的C#示例中的`List<T>.Contains()`方法或Java示例中的`List<E>.Add()`方法。这些方法是定义为泛型类的类的一部分。在计算机科学中，泛型允许你在声明类或调用方法之前不指定数据类型。例如，假设你有一个将两个数值相加的方法。为了直接与这些类型交互，你可以为`Add()`方法创建多个重载：
- en: '[PRE8]'
  id: totrans-77
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'Generics allow you to create a single method that is customized for the type
    that invokes it, greatly simplifying your code. In this example, `T` can be substituted
    for whatever type the caller needs:'
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 泛型允许你创建一个针对调用它的类型定制的单一方法，这极大地简化了你的代码。在这个例子中，`T`可以被替换为调用者需要的任何类型：
- en: '[PRE9]'
  id: totrans-79
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'Generics are an incredibly powerful tool, which we will discuss in greater
    detail in [Chapter 12](part0069_split_000.html#21PMQ2-77f2b5b248f04368a6f723b0e9357ef3
    "Chapter 12. Sorting: Bringing Order Out Of Chaos"), *Sorting: Bringing Order
    Out Of Chaos*.'
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 泛型是一个非常强大的工具，我们将在[第12章](part0069_split_000.html#21PMQ2-77f2b5b248f04368a6f723b0e9357ef3
    "第12章。排序：从混乱中带来秩序")中更详细地讨论，*排序：从混乱中带来秩序*。
- en: 'Case study: bike route'
  id: totrans-81
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 案例研究：骑行路线
- en: '**Business problem**: A mobile app is to be written for biking enthusiasts
    who like to travel off-road. One of the key business requirements is the ability
    to store waypoints in a route. The route has to have a beginning and an end, and
    it needs to be traversable in both directions. The app also needs the ability
    to modify the biker''s route in real time to allow for detours around hazards,
    visiting rest areas, or adding points of interest.'
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: '**业务问题**：为喜欢越野骑行的骑行爱好者编写一个移动应用程序。其中一个关键的业务需求是能够在路径中存储航点。路径必须有起点和终点，并且需要能够双向遍历。应用程序还需要能够实时修改骑行者的路径，以便绕过障碍物、访问休息区或添加兴趣点。'
- en: Due to the nature of the app and its requirements, the class that represents
    the route will need several basic pieces of functionality. First, it will require
    the ability to add, remove, and insert waypoints. Next, it will require the ability
    to start the route and traverse it to route forward and backward. Finally, the
    class should be able to easily identify the start and finish lines as well as
    the currently focused waypoint.
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 由于应用程序的性质及其需求，表示路径的类将需要几个基本的功能。首先，它将需要添加、删除和插入航点的功能。接下来，它将需要启动路径并遍历路径以向前和向后导航的能力。最后，该类应能够轻松地识别起点和终点以及当前关注的航点。
- en: Since the nature of this data is such that all waypoints have a spatial relationship
    to one another, and the app must traverse from point to point utilizing that relationship,
    an array would be a poor selection as a data structure. However, since a List
    inherently provides a mechanism for both defining and traversing relationships
    between objects in the collection, the developer has chosen to use a linked list
    structure to build this component.
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 由于此类数据的性质是所有航点之间都有空间关系，并且应用程序必须利用这种关系从一点到另一点进行遍历，因此数组作为数据结构的选择会很差。然而，由于列表本身提供了一种定义和遍历集合中对象之间关系的机制，开发者选择使用链表结构来构建此组件。
- en: '**C#**'
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: '**C#**'
- en: 'C# conveniently exposes a linked list structure through the `LinkedList<T>`
    class and list nodes through the `LinkedListNode<T>` class. Therefore, building
    this class in C# should be a fairly straightforward procedure. Here''s an example
    of what a simple implementation in C# looks like:'
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: C#通过`LinkedList<T>`类和`LinkedListNode<T>`类方便地公开了链表结构。因此，在C#中构建此类应该是一个相当直接的过程。以下是一个简单的C#实现示例：
- en: '[PRE10]'
  id: totrans-87
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'First, we declare two properties. The first is the `route` property, which
    is `LinkedList<Waypoint>`. The next object is the `current` node. We have declared
    both objects without explicitly defining their scope, so they default to `private`.
    We want these fields to be private because we only permit the methods in this
    class to modify their values. Our constructor only instantiates the `route` property
    because the `current` node will be assigned on an as-needed basis:'
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们声明了两个属性。第一个是`route`属性，它是`LinkedList<Waypoint>`类型。下一个对象是`current`节点。我们声明了这两个对象而没有明确定义它们的范围，因此它们默认为`private`。我们希望这些字段是私有的，因为我们只允许这个类中的方法修改它们的值。我们的构造函数只实例化了`route`属性，因为`current`节点将根据需要分配：
- en: '[PRE11]'
  id: totrans-89
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: The `AddWaypoints(List<Waypoint>)` method allows us to add *1...n* new waypoints
    to the existing route. C# does not provide a mechanism for merging `List<T>` with
    a `LinkedList<T>`, so we must resort to looping through `waypoints` and adding
    the new nodes individually using `LinkedList<T>.AddLast()`, meaning this operation
    costs **O**(*i*), where *i* is the number of elements in the `waypoints` list.
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: '`AddWaypoints(List<Waypoint>)`方法允许我们向现有路线添加*1...n*个新的航点。C#不提供合并`List<T>`与`LinkedList<T>`的机制，因此我们必须求助于遍历`waypoints`并使用`LinkedList<T>.AddLast()`逐个添加新节点，这意味着这个操作的成本是**O**(*i*)，其中*i*是`waypoints`列表中的元素数量。'
- en: 'The `RemoveWaypoint(Waypoint)` method simply calls `LinkedList<T>.Remove()`
    on the route, passing `waypoint` as a parameter. As this is technically a search
    operation, it also costs **O**(*n*):'
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: '`RemoveWaypoint(Waypoint)`方法简单地调用`LinkedList<T>.Remove()`在路线上，传递`waypoint`作为参数。由于这实际上是搜索操作，它也花费**O**(*n*)：'
- en: '[PRE12]'
  id: totrans-92
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: The `InsertWaypointsBefore(List<Waypoint>, Waypoint)` method gives our class
    the ability to create alternate routes and add intermediate destinations on-the-fly.
    First, we attempt to locate the `before` node. If we find it, we begin inserting
    the list of new waypoints sequentially before the `before` node. Otherwise, we
    immediately call `AddWaypoints(List<Waypoint>)` to append the new list of waypoints
    onto the route. Although the functionality of this loop may seem quirky, by adding
    each item sequentially just prior to the `before` node, we shift `before` one
    node closer to the tail with each operation, ensuring that each new node is inserted
    in the correct order.
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: '`InsertWaypointsBefore(List<Waypoint>, Waypoint)`方法使我们的类能够创建替代路线并在运行时添加中间目的地。首先，我们尝试定位`before`节点。如果我们找到了它，我们就开始顺序地将新航点的列表插入到`before`节点之前。如果没有找到，我们立即调用`AddWaypoints(List<Waypoint>)`将新航点列表附加到路线上。尽管这个循环的功能可能看起来有些奇怪，但通过在`before`节点之前逐个添加每个项目，我们每次操作都将`before`节点向尾部移动一个节点，确保每个新节点按正确顺序插入。'
- en: 'This is the most expensive operation in this class as it is a combination of
    a search and an insert. This means its operational cost is **O**(*n*+*i*) where
    *n* is the number of elements in the existing `route` collection and *i* is the
    number of elements in the `waypoints` list:'
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 这是这个类中最昂贵的操作，因为它结合了搜索和插入。这意味着它的操作成本是**O**(*n*+*i*)，其中*n*是现有`route`集合中的元素数量，*i*是`waypoints`列表中的元素数量：
- en: '[PRE13]'
  id: totrans-95
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: The `StartRoute()` method is used to set our initial current position and denote
    that it has been deactivated. Since our overall class represents a route, which
    is by definition a 2-dimensional object at the very least, the `StartRoute()`
    method immediately validates that `route` has at least two waypoints. If not,
    we return `false` because the route is not yet ready to be traversed. If we do
    have two or more waypoints, we set the `current` waypoint to the starting line
    and move to the next point. The `StartRoute()` method has an **O**(*1*) operational
    cost.
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: '`StartRoute()`方法用于设置我们的初始当前位置并标记它已被禁用。由于我们的整体类代表一个路线，而路线至少是一个二维对象，`StartRoute()`方法立即验证`route`至少有两个航点。如果没有，我们返回`false`，因为路线尚未准备好被穿越。如果我们有两个或更多的航点，我们将`current`航点设置为起点并移动到下一个点。`StartRoute()`方法的操作成本是**O**(*1*)。'
- en: Note
  id: totrans-97
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: We could have easily duplicated the critical code from the `StartingLine()` method
    and the `MoveToNextWaypoint()` method locally in `StartRoute()`. Doing so would
    mean that if we ever wanted to change how we identify the starting line or how
    we navigate the route, we would need to maintain that code in multiple locations.
    By following this pattern of code reuse, we minimize the amount of work and number
    of potential new bugs such a refactor could introduce.
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以轻松地复制 `StartingLine()` 方法中的关键代码和 `MoveToNextWaypoint()` 方法中的代码，在 `StartRoute()`
    方法中本地复制。这样做意味着，如果我们想改变识别起点线或导航路线的方式，我们需要在多个位置维护这段代码。通过遵循这种代码重用的模式，我们最小化了工作量并减少了这种重构可能引入的新潜在错误数量。
- en: Next we'll look at the methods that alter the object's position.
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来我们将查看那些改变对象位置的方法。
- en: '[PRE14]'
  id: totrans-100
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: The `MoveToNextWayPoint()` and `MoveToPreviousWaypoint()` methods introduce
    our route traversal functionality. In `MoveToNextWaypoint()`, we check that the
    current waypoint is not `null`, and then we deactivate it. Next, we check whether
    we are at the finish line, and if not, we set `current` to the next node in `route`
    and return `true`. The `MoveToPreviousWaypoint()` method verifies that `current`
    is not `null` and makes sure that we are not at the starting line. If so, we move
    `current` to the previous waypoint and reactivate it. If any of our checks in
    these two methods fail, we return `false`. Each of these methods has an **O**(*1*)
    operational cost.
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: '`MoveToNextWayPoint()` 和 `MoveToPreviousWaypoint()` 方法引入了我们的路线遍历功能。在 `MoveToNextWayPoint()`
    中，我们检查当前航标点是否为 `null`，然后将其停用。接下来，我们检查是否到达了终点线，如果没有，我们将 `current` 设置为 `route` 中的下一个节点并返回
    `true`。`MoveToPreviousWaypoint()` 方法验证 `current` 是否不为 `null` 并确保我们不在起点线。如果是这样，我们将
    `current` 移动到前一个航标点并重新激活它。如果这两个方法中的任何检查失败，我们返回 `false`。这些方法中的每一个都有 **O**(*1*)
    的操作成本。'
- en: Note
  id: totrans-102
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: This dual `false` return seen in `MoveToNextWaypoint()` may seem like a design
    flaw, but remember that our class is not responsible for the overall functionality
    of the app, only the functionality of the route. It is the responsibility of the
    *caller* to check whether the route is ready to traverse before calling `MoveToNextWaypoint()`.
    Our return value is only signaling the success or failure of the operation.
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 在 `MoveToNextWaypoint()` 中看到的这种双重 `false` 返回值可能看起来像是一个设计缺陷，但请记住，我们的类并不负责整个应用程序的功能，只负责路线的功能。检查路线是否准备好遍历的责任在于
    *调用者* 在调用 `MoveToNextWaypoint()` 之前。我们的返回值仅表示操作的成功或失败。
- en: 'Lastly, we''ll look at the methods that indicate position:'
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们将查看指示位置的方法：
- en: '[PRE15]'
  id: totrans-105
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: We add the `StartingLine()` and `FinishLine()` methods to expose the head and
    tail nodes of the route collection. Finally, we add the `CurrentPosition()` method
    to expose which node in the route is our next immediate destination. Each of these
    methods has an **O**(*1*) operational cost.
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 我们添加了 `StartingLine()` 和 `FinishLine()` 方法来公开路线集合的头和尾节点。最后，我们添加了 `CurrentPosition()`
    方法来公开路线中的哪个节点是我们下一个立即的目的地。这些方法中的每一个都有 **O**(*1*) 的操作成本。
- en: '**Java**'
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: '**Java**'
- en: 'Java also exposes a linked list data structure through the `LinkedList<E>`
    class. However, Java does not provide an implementation of the list node structure.
    This is because, in Java, you generally do not work with the nodes directly but
    through a list iterator. The `ListIterator<E>` class provides the necessary functionality
    to implement a linked list structure in the basic sense. If we needed our own
    node class, it would be easy to implement one. Here''s an example of what a simple
    implementation of our `WaypointList` class might look like in Java:'
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: Java 通过 `LinkedList<E>` 类也公开了一个链表数据结构。然而，Java 并没有提供列表节点结构的实现。这是因为，在 Java 中，你通常不直接与节点交互，而是通过列表迭代器。`ListIterator<E>`
    类提供了实现链表结构所需的基本功能。如果我们需要我们自己的节点类，实现起来会很容易。以下是一个简单的 `WaypointList` 类实现示例：
- en: '[PRE16]'
  id: totrans-109
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'First, we declare two properties. The first is the `route`, which is an abstract
    `List<Waypoint>`, and the next object is the `current` node. We have declared
    both objects without explicitly defining their scope, so they default to `package-private`,
    which is fine for our case. We want these fields to be private because we only
    permit the methods in this class to modify their values. Our constructor only
    instantiates the `route` because the `current` node will be assigned on an as-needed
    basis:'
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们声明两个属性。第一个是 `route`，它是一个抽象的 `List<Waypoint>`，下一个对象是 `current` 节点。我们未明确定义这两个对象的范围，因此它们默认为
    `package-private`，这对于我们的情况来说是合适的。我们希望这些字段是私有的，因为我们只允许这个类中的方法修改它们的值。我们的构造函数只实例化了
    `route`，因为 `current` 节点将根据需要分配：
- en: '[PRE17]'
  id: totrans-111
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'The `AddWaypoints(List<Waypoint>)` method allows us to add *1..*.*n* new waypoints
    to the existing route. We append objects to our list using the `LinkedList<E>.addAll()`
    method. This operation is quite simple and costs **O**(*1*). The `RemoveWaypoint(Waypoint)`
    method simply calls `LinkedList<E>.remove()` on the route, passing `waypoint`
    as a parameter. As this is technically a search operation, it costs **O**(*n*):'
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: '`AddWaypoints(List<Waypoint>)` 方法允许我们向现有路线添加 *1..*.*n* 个新的航点。我们使用 `LinkedList<E>.addAll()`
    方法将对象添加到我们的列表中。这个操作非常简单，成本为 **O**(*1*)。`RemoveWaypoint(Waypoint)` 方法简单地调用路线上的
    `LinkedList<E>.remove()`，并将 `waypoint` 作为参数传递。由于这是一个搜索操作，它成本为 **O**(*n*)：'
- en: '[PRE18]'
  id: totrans-113
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: The `InsertWaypointsBefore(List<Waypoint>, Waypoint)` method gives our class
    the ability to create alternate routes and add intermediate destinations on the
    fly. First, we attempt to locate the `before` node using `LinkedList<E>.indexOf()`.
    The `indexOf()` method returns `-1` if it cannot find the object, so we confirm
    that the value is greater than `-1`; otherwise we immediately call `AddWaypoints(List<Waypoint>)`
    to append the new list of waypoints onto the route. If the `before` node is valid,
    we add the list of new waypoints before the `before` node.
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: '`InsertWaypointsBefore(List<Waypoint>, Waypoint)` 方法使我们的类能够创建替代路线并在飞行中添加中间目的地。首先，我们尝试使用
    `LinkedList<E>.indexOf()` 定位 `before` 节点。如果 `indexOf()` 方法找不到对象，它将返回 `-1`，因此我们确认值大于
    `-1`；否则，我们立即调用 `AddWaypoints(List<Waypoint>)` 将新的航点列表附加到路线上。如果 `before` 节点是有效的，我们在
    `before` 节点之前添加新的航点列表。'
- en: 'This is the most expensive method operation in this class as it is a combination
    of a search and an insert. This means its operational cost is **O**(*n*+*i*),
    where *n* is the number of elements in the existing `route` and *i* is the number
    of elements in the waypoints list:'
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 这是这个类中最昂贵的操作方法，因为它是一个搜索和插入的组合。这意味着它的操作成本是 **O**(*n*+*i*)，其中 *n* 是现有 `route`
    中的元素数量，*i* 是航点列表中的元素数量：
- en: '[PRE19]'
  id: totrans-116
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'The `StartRoute()` method is used to set our initial current position and denote
    that it has been deactivated. Since our overall class represents a route, which
    is by definition a 2-dimensional object at the very least, the `StartRoute()`
    method immediately validates that `route` has at least two waypoints, and if not,
    we return `false` because `route` is not yet ready to be traversed. If we do have
    two or more waypoints, we set the `current` waypoint to the starting line and
    move to the next point. `StartRoute()` has an **O**(1) operational cost:'
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: '`StartRoute()` 方法用于设置我们的初始当前位置并标记它已被禁用。由于我们的整体类代表一个路线，而路线按定义至少是一个二维对象，`StartRoute()`
    方法立即验证 `route` 至少有两个航点，如果没有，我们返回 `false`，因为 `route` 还未准备好被遍历。如果我们有两个或更多航点，我们将
    `current` 航点设置为起点并移动到下一个点。`StartRoute()` 的操作成本为 **O**(1)：'
- en: '[PRE20]'
  id: totrans-118
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'The `MoveToNextWayPoint()` and `MoveToPreviousWaypoint()` methods introduce
    our route traversal functionality. In the `MoveToNextWaypoint()` method, we check
    whether the current waypoint is not `null`, and then we deactivate it. Next, we
    check whether we are not at the finish line, and if not, we set `current` to the
    next by assigning it to the `listIterator` property and the `next()` method of
    `route`, and then return `true`. The `MoveToPreviousWaypoint()` method verifies
    that `current` is not `null` and makes sure that we are not at the starting line.
    If so, we set `current` to the previous waypoint and reactivate it. If any of
    our checks in these two methods fail, we return `false`. Due to the need to search
    for a match for `current`, each of these methods has an **O**(*n*+1) operational
    cost:'
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: '`MoveToNextWayPoint()` 和 `MoveToPreviousWaypoint()` 方法介绍了我们的路线遍历功能。在 `MoveToNextWayPoint()`
    方法中，我们检查当前航标点是否不是 `null`，然后将其停用。接下来，我们检查是否不在终点线，如果不是，我们将 `current` 设置为下一个，通过将其分配给
    `listIterator` 属性和 `route` 的 `next()` 方法，然后返回 `true`。`MoveToPreviousWaypoint()`
    方法验证 `current` 不是 `null` 并确保我们不在起点线。如果是这样，我们将 `current` 设置为前一个航标点并重新激活它。如果这两个方法中的任何检查失败，我们返回
    `false`。由于需要搜索 `current` 的匹配项，这些方法每个都有 **O**(*n*+1) 的操作成本：'
- en: '[PRE21]'
  id: totrans-120
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: We add the `StartingLine()` and `FinishLine()` methods to expose the head and
    tail nodes of the route collection. Finally, we add the `CurrentPosition()` method
    to expose which node in the route is our next immediate destination. Each of these
    methods has an **O**(1) operational cost.
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 我们添加了 `StartingLine()` 和 `FinishLine()` 方法来暴露路线集合的头尾节点。最后，我们添加了 `CurrentPosition()`
    方法来暴露路线中的哪个节点是我们的下一个直接目的地。这些方法每个都有 **O**(1) 的操作成本。
- en: '**Objective-C**'
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: '**Objective-C**'
- en: 'Objective-C does not expose any implementation of a linked list out-of-the-box.
    Although we could create our own implementation, the purpose of this text is to
    demonstrate the best approach given the tools available. For this scenario, we
    will once again use the class cluster, `NSMutableArray`. Here''s a simple example
    of how the `EDSWaypointList` class might be implemented in Objective-C:'
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: Objective-C 默认不提供任何链表的实现。尽管我们可以创建自己的实现，但本文的目的是演示在现有工具下最佳的方法。对于这个场景，我们再次使用类簇，`NSMutableArray`。以下是一个简单的示例，说明
    `EDSWaypointList` 类如何在 Objective-C 中实现：
- en: '[PRE22]'
  id: totrans-124
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'First, we declare two `ivar` properties. The first is `_route`, which is an
    `NSMutableArray` array. The next object is the `_current` node. Again, we have
    declared these as ivars because we only permit the methods in this class to modify
    their values. Our initializer only instantiates the `_route` because the `_current`
    node will be assigned on an as-needed basis:'
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们声明两个 `ivar` 属性。第一个是 `_route`，它是一个 `NSMutableArray` 数组。下一个对象是 `_current`
    节点。同样，我们将其声明为 ivars，因为我们只允许这个类中的方法修改它们的值。我们的初始化器只实例化了 `_route`，因为 `_current` 节点将根据需要分配：
- en: '[PRE23]'
  id: totrans-126
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: The `addWaypoints:` method allows us to add *1...n* new waypoints to the existing
    route. `NSMutableArray` allows us to merge the new array with the existing route
    by calling `addObjectsFromArray:`. This operation is quite simple and costs **O**(*1*).
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: '`addWaypoints:` 方法允许我们向现有路线添加 *1...n* 个新的航标点。`NSMutableArray` 允许我们通过调用 `addObjectsFromArray:`
    将新数组与现有路线合并。这个操作相当简单，成本为 **O**(*1*)。'
- en: 'The `removeWaypoint:` method confirms that `_route` contains `waypoint` using
    `containsObject:`, then calls `removeObject:`. If we were not concerned with the
    success or failure of this operation, we could have simply called `removeObject:`
    and moved on. Note that, since our `_route` object is an array-backed list, it
    allows for **O**(*1*) search operations. Since we do not know the index of waypoint
    in advance, the `removeObject:` operation still costs **O**(*n*):'
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: '`removeWaypoint:` 方法确认 `_route` 包含 `waypoint` 使用 `containsObject:`，然后调用 `removeObject:`。如果我们不关心这个操作的成功或失败，我们可以简单地调用
    `removeObject:` 并继续。请注意，由于我们的 `_route` 对象是一个基于数组的列表，它允许进行 **O**(*1*) 的搜索操作。由于我们事先不知道航标点的索引，`removeObject:`
    操作仍然成本为 **O**(*n*):'
- en: '[PRE24]'
  id: totrans-129
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'The `insertWaypoints:beforeWaypoint:` method gives our class the ability to
    create alternate routes and add intermediate destinations on the fly. First, we
    attempt to locate the `before` node using `indexOfObject:`. If we cannot find
    it, we immediately call `addWaypoints:` to append the new list of waypoints onto
    the route. Otherwise, we create some ugly code to define an `NSRange` object and
    an `NSIndexSet` object, and use these with `insertObjects:atIndexes:`. Since this
    method represents a search and an insert, its operational cost is **O**(*n*+1),
    where *n* is the number of elements in the existing `_route` object:'
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: '`insertWaypoints:beforeWaypoint:` 方法使我们的类能够创建替代路线并在飞行中添加中间目的地。首先，我们尝试使用 `indexOfObject:`
    定位 `before` 节点。如果我们找不到它，我们立即调用 `addWaypoints:` 将新的航标列表附加到路线上。否则，我们编写一些丑陋的代码来定义一个
    `NSRange` 对象和一个 `NSIndexSet` 对象，并使用这些对象与 `insertObjects:atIndexes:` 一起。由于此方法代表搜索和插入，其操作成本是
    **O**(*n*+1)，其中 *n* 是现有 `_route` 对象中的元素数量：'
- en: '[PRE25]'
  id: totrans-131
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: The `startRoute:` method is used to set our initial current position and denote
    that it has been deactivated. Since our overall class represents a route, which
    is by definition a 2-dimensional object at the very least, the `startRoute:` method
    immediately validates that `_route` has at least two waypoints; if not we return
    `NO` because the route is not yet ready to be traversed. If we do have two or
    more waypoints, we set the `_current` waypoint to the starting line and move to
    the next point. `startRoute:` has an **O**(1) operational cost.
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: '`startRoute:` 方法用于设置我们的初始当前位置并表明它已被停用。由于我们的整体类代表一个路线，而路线按定义至少是一个二维对象，`startRoute:`
    方法立即验证 `_route` 至少有两个航标；如果没有，我们返回 `NO`，因为路线尚未准备好被穿越。如果我们有两个或更多的航标，我们将 `_current`
    航标设置为起点线并移动到下一个点。`startRoute:` 具有操作成本 **O**(1)。'
- en: '[PRE26]'
  id: totrans-133
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: 'In `moveToNextWaypoint:`, we check whether the current waypoint is not `nil`,
    and then we deactivate it. Next, we verify that we are not at the finish line,
    and if not, we get the index of `_current` in the list and assign the next highest
    index object to the property, then return `YES`. The `moveToPreviousWaypoint:`
    method verifies that `_current` is not `nil`, and makes sure that we are not at
    the starting line. If so, we set `_current` to the previous waypoint and reactivate
    it, and then we return `YES`. If any of our checks in these two methods fail,
    we return `NO`. Due to the need to search for a match for `_current`, each of
    these methods has an **O**(*n*+1) operational cost:'
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 在 `moveToNextWaypoint:` 方法中，我们检查当前航标是否不是 `nil`，然后将其停用。接下来，我们验证我们是否不在终点线，如果不是，我们获取
    `_current` 在列表中的索引，并将下一个最高索引的对象分配给属性，然后返回 `YES`。`moveToPreviousWaypoint:` 方法验证
    `_current` 是否不是 `nil`，并确保我们不在起点线。如果是这样，我们将 `_current` 设置为前一个航标并重新激活它，然后返回 `YES`。如果这两个方法中的任何检查失败，我们返回
    `NO`。由于需要搜索 `_current` 的匹配项，这些方法中的每一个都具有 **O**(*n*+1) 的操作成本：
- en: '[PRE27]'
  id: totrans-135
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: We add the `startingLine:` and `finishLine:` methods to expose the head and
    tail nodes of the route collection. Finally, we add the `currentPosition:` method
    to expose which node in the route is our next immediate destination. Each of these
    methods has an **O**(1) operational cost.
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 我们添加了 `startingLine:` 和 `finishLine:` 方法来暴露路线集合的头尾节点。最后，我们添加了 `currentPosition:`
    方法来暴露路线中的哪个节点是我们的下一个直接目的地。这些方法中的每一个都具有 **O**(1) 的操作成本。
- en: '**Swift**'
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: '**Swift**'
- en: 'Similar to Objective-C, Swift does not expose any implementation of a linked
    list data structure. Therefore, we will use the Swift `Array` class to create
    our data structure. Here''s a simple example of how this class might be implemented
    using Swift:'
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 与 Objective-C 类似，Swift 没有公开任何链表数据结构的实现。因此，我们将使用 Swift 的 `Array` 类来创建我们的数据结构。以下是一个使用
    Swift 实现此类的一个简单示例：
- en: '[PRE28]'
  id: totrans-139
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: 'First, we declare two properties. The first is `_route`, which is an array.
    The next object is the `_current` node, which is a `Waypoint` object, flagged
    as `optional`. Again, we have declared these as private because we only permit
    the methods in this class to modify their values. Our initializer does not need
    to instantiate either object because the declaration instantiates `_route`, and
    `_current` is flagged as `optional` and will only be assigned on an as-needed
    basis:'
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们声明两个属性。第一个是 `_route`，它是一个数组。下一个对象是 `_current` 节点，它是一个 `Waypoint` 对象，标记为
    `optional`。同样，我们将这些声明为私有的，因为我们只允许这个类中的方法修改它们的值。我们的初始化器不需要实例化任何对象，因为声明实例化了 `_route`，而
    `_current` 被标记为 `optional`，并且将根据需要分配：
- en: '[PRE29]'
  id: totrans-141
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: The `addWaypoints(Array<Waypoint>)` method allows us to add *1..*.*n* new waypoints
    to the existing route. `Array` allows us to merge the new array with the existing
    route by calling `appendContentsOf(Array)`. This operation is quite simple and
    costs **O**(1).
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: '`addWaypoints(Array<Waypoint>)` 方法允许我们向现有路线添加 *1..*.*n* 个新的航点。`Array` 允许我们通过调用
    `appendContentsOf(Array)` 将新数组与现有路线合并。这个操作相当简单，成本为 **O**(1)。'
- en: 'The `removeWaypoint(Waypoint)` method confirms that `_route` contains `waypoint`
    and gets its index in one operation by calling `if .. indexOf()`. If we do not
    retrieve an index, we return `false`, otherwise we call `removeAtIndex()` and
    return `true`. Note that, since our `_route` object is an array-backed list, the
    `removeAtIndex()` operation only costs **O**(1):'
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: '`removeWaypoint(Waypoint)` 方法确认 `_route` 包含 `waypoint` 并通过调用 `if .. indexOf()`
    在一个操作中获取其索引。如果我们没有检索到索引，我们返回 `false`，否则我们调用 `removeAtIndex()` 并返回 `true`。请注意，由于我们的
    `_route` 对象是一个基于数组的列表，`removeAtIndex()` 操作的成本仅为 **O**(1)：'
- en: '[PRE30]'
  id: totrans-144
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: 'The `insertWaypoints(Array<Waypoint>, Waypoint)` method first attempts to locate
    the `before` node using `if..indexOf()`. If we cannot find it, we immediately
    call `addWaypoints()` to append the new list of waypoints onto the route. Otherwise,
    we call `insertContentOf()`. Since this method represents a search and an insert,
    its operational cost is **O**(*n*+1), where *n* is the number of elements in the
    existing _`route`:'
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: '`insertWaypoints(Array<Waypoint>, Waypoint)` 方法首先尝试使用 `if..indexOf()` 定位 `before`
    节点。如果我们找不到它，我们立即调用 `addWaypoints()` 将新的航点列表追加到路线中。否则，我们调用 `insertContentOf()`。由于这个方法代表搜索和插入，其操作成本为
    **O**(*n*+1)，其中 *n* 是现有 _`route`_ 中元素的数量：'
- en: '[PRE31]'
  id: totrans-146
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: 'The `startRoute:` object is used to set our initial current position and denote
    that it has been deactivated. If we have two or more waypoints, we set the `_current`
    waypoint to the starting line and move to the next point. The `startRoute()` object
    has an **O**(1) operational cost:'
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: '`startRoute:` 对象用于设置我们的初始当前位置并表明它已被停用。如果我们有两个或更多航点，我们将 `_current` 航点设置为起点线并移动到下一个点。`startRoute()`
    对象的操作成本为 **O**(1)：'
- en: '[PRE32]'
  id: totrans-148
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: 'In `moveToNextWaypoint()`, we verify that the current waypoint is not `nil`,
    and then we deactivate it. Next, we confirm that we are not at the finish line;
    and if not, we get the index of `_current` in the list, and assign the next highest
    index object to `_current`, and then we return `true`. The `moveToPreviousWaypoint()`
    method verifies that `_current` is not `nil` and makes sure that we are not at
    the starting line. If so, we set `_current` to the previous waypoint, reactivate
    it, and return `YES`. If any of our checks in these two methods fail, we return
    `NO`. Due to the need to search for a match for `_current`, each of these methods
    has an **O**(*n*+1) operational cost:'
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 在 `moveToNextWaypoint()` 中，我们验证当前航点不是 `nil`，然后将其停用。接下来，我们确认我们不在终点线；如果不是，我们在列表中获取
    `_current` 的索引，并将下一个最高索引的对象分配给 `_current`，然后返回 `true`。`moveToPreviousWaypoint()`
    方法验证 `_current` 不是 `nil` 并确保我们不在起点线。如果是这样，我们将 `_current` 设置为前一个航点，重新激活它，并返回 `YES`。如果这两个方法中的任何检查失败，我们返回
    `NO`。由于需要搜索 `_current` 的匹配项，这些方法中的每一个都有 **O**(*n*+1) 的操作成本：
- en: '[PRE33]'
  id: totrans-150
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: We add the `startingLine()` and `finishLine()` methods to expose the head and
    tail nodes of the route collection. Finally, we add the `currentPosition()` method
    to expose which node in the route is our next immediate destination. Each of these
    methods has an **O**(1) operational cost.
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 我们添加了 `startingLine()` 和 `finishLine()` 方法来暴露路线集合的头和尾节点。最后，我们添加了 `currentPosition()`
    方法来暴露路线中的哪个节点是我们的下一个直接目的地。这些方法中的每一个都有 **O**(1) 的操作成本。
- en: Doubly linked list
  id: totrans-152
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 双向链表
- en: A doubly linked list has the added overhead of *n* additional pointers where
    *n* is the length of the list. This additional pointer provides for simple reverse-traversal
    of the list. The added overhead is somewhat negligible and can typically be ignored
    except in very special cases. The append, insert, and remove operations still
    only cost **O**(1).
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 双向链表增加了 *n* 个额外的指针开销，其中 *n* 是列表的长度。这个额外的指针提供了对列表的简单反向遍历。这种额外的开销可以忽略不计，通常可以忽略，除非在非常特殊的情况下。追加、插入和删除操作的成本仍然只有
    **O**(1)。
- en: Searching
  id: totrans-154
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 搜索
- en: 'Array backed lists provides a **O**(1) operational cost for searches if the
    index of the object is known in advance. Otherwise, all searches in lists cost
    **O**(n) for unsorted lists and **O**(log *n*) for sorted lists where a binary
    search pattern is applied. Binary search algorithms will be discussed in much
    greater detail in [Chapter 13](part0076_split_000.html#28FAO1-77f2b5b248f04368a6f723b0e9357ef3
    "Chapter 13. Searching: Finding What You Need"), *Searching: Finding What You
    Need*.'
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 如果事先知道对象的索引，基于数组的列表提供**O**(1)的操作成本进行搜索。否则，对于未排序的列表，列表中的所有搜索成本为**O**(n)，而对于应用了二分搜索模式的排序列表，搜索成本为**O**(log
    *n*)。[第13章](part0076_split_000.html#28FAO1-77f2b5b248f04368a6f723b0e9357ef3 "第13章。搜索：找到你需要的东西")*搜索：找到你需要的东西*将更详细地讨论二分搜索算法。
- en: A few pointers
  id: totrans-156
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 一些要点
- en: 'Many languages view memory as a series of successive cells, each a certain
    number of bytes in size and each with a unique address. Pointers are memory management
    tools, which are really objects that reference, or point to, a memory cell''s
    address. By utilizing pointers, a program can store objects in memory that are
    themselves larger than a single memory block. Some languages use the `*` operator
    to denote the assignment of a pointer. If you use Objective-C, or if you have
    worked with C/C++, you will already be very familiar with this operator. C#, Java,
    and Swift developers won''t have had too much experience with this operator, but
    you should be familiarize yourself with how pointers work anyway, and here''s
    why:'
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 许多语言将内存视为一系列连续的单元，每个单元的大小为一定数量的字节，并且每个单元都有一个唯一的地址。指针是内存管理工具，实际上是引用或指向内存单元地址的对象。通过利用指针，程序可以在内存中存储比单个内存块更大的对象。一些语言使用`*`运算符来表示指针的赋值。如果你使用Objective-C，或者如果你已经使用过C/C++，那么你将非常熟悉这个运算符。C#、Java和Swift的开发者可能没有太多使用这个运算符的经验，但无论如何，你应该熟悉指针的工作原理，原因如下：
- en: When an object in memory no longer has a pointer referencing its memory address,
    it should be de-allocated or removed from memory. Removing unused objects to prevent
    them from filling up memory is known as **memory management**. In some older languages,
    managing memory pointers is a tedious and often bug-prone task for the uninitiated.
    Most modern languages spare us from this drudgery through the use of some form
    of memory management device. C#, Java, and Swift use what's known as **Garbage
    Collection** (**GC**), while modern Objective-C provides **Automatic Reference
    Counting** (**ARC**) for automatic memory management.
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 当内存中的对象不再有指针引用其内存地址时，它应该被释放或从内存中移除。移除未使用的对象以防止它们填满内存被称为**内存管理**。在一些较老的语言中，管理内存指针对于初学者来说是一项繁琐且经常出现错误的任务。大多数现代语言通过使用某种形式的内存管理设备来免除我们这种苦差事。C#、Java和Swift使用所谓的**垃圾回收**（**GC**），而现代Objective-C提供了**自动引用计数**（**ARC**）来自动管理内存。
- en: Although these tools are great, you should not rely too completely on GC or
    ARC to manage your memory. GC and ARC are not perfect to start with, but both
    can be thwarted by a poor implementation. What will separate programmers from
    engineers is the ability to diagnose and repair memory management issues. Understanding
    pointers and their use will better equip you to catch what GC or ARC can very
    often miss.
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然这些工具很棒，但你不应完全依赖GC或ARC来管理你的内存。GC和ARC一开始并不完美，但两者都可能因为糟糕的实现而被挫败。区分程序员和工程师的是诊断和修复内存管理问题的能力。理解指针及其使用将使你更好地捕捉GC或ARC经常错过的问题。
- en: A deeper discussion on pointers is beyond the scope of this book, but you should
    definitely take the time to research and familiarize yourself with this topic.
    Better still, spend some time writing code in a language that utilizes manual
    memory management like C or C++. Your career will thank you.
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 对指针的更深入讨论超出了本书的范围，但你绝对应该花时间研究和熟悉这个主题。更好的是，花些时间用像C或C++这样的语言编写代码，这些语言使用手动内存管理。你的职业生涯会感谢你。
- en: Summary
  id: totrans-161
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: In this chapter, you learned the basic definition of the list structure, including
    the difference between sorted and unsorted list and array-backed versus linked
    lists. We discussed how to initialize lists or pseudo lists in each of the four
    languages we utilize in this text. We revisited the logged-in users class to see
    if we could improve its performance using lists instead of arrays and learned
    about interesting differences between the four languages including their use of
    generics and class clusters in the process. Next, we created a class to represent
    a route for biking enthusiasts, taking advantage of the properties of linked lists
    to manipulate and dynamically alter our collection of waypoints on the fly.
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，你学习了列表结构的基本定义，包括排序列表和无序列表之间的区别，以及数组支持与链表之间的区别。我们讨论了如何使用我们在这本书中使用的四种语言中的每一种来初始化列表或伪列表。我们回顾了登录用户类，看看我们是否可以使用列表而不是数组来提高其性能，并了解了四种语言之间有趣的差异，包括它们在过程中使用泛型和类簇的方式。接下来，我们创建了一个代表自行车爱好者的路线的类，利用链表的特性来动态地操作和改变我们的航点集合。
- en: In our advanced topics section, we examined different implementations of list
    structures in more detail, including array-based lists, (singly) linked lists,
    and doubly linked lists. Finally, for each implementation, we evaluated the performance
    of basic operations including appending, inserting, removing, and searching nodes.
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的高级主题部分，我们更详细地考察了列表结构的不同实现方式，包括基于数组的列表、（单链）链表和双链表。最后，对于每种实现方式，我们评估了包括追加、插入、删除和搜索节点在内的基本操作的性能。
