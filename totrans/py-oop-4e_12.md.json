["```py\nclass TimeSince:\n    \"\"\"Expects time as six digits, no punctuation.\"\"\"\n    def parse_time(self, time: str) -> tuple[float, float, float]:\n        return (\n            float(time[0:2]),\n            float(time[2:4]),\n            float(time[4:]),\n        )\n    def __init__(self, starting_time: str) -> None:\n        self.hr, self.min, self.sec = self.parse_time(starting_time)\n        self.start_seconds = ((self.hr * 60) + self.min) * 60 + self.sec\n    def interval(self, log_time: str) -> float:\n        log_hr, log_min, log_sec = self.parse_time(log_time)\n        log_seconds = ((log_hr * 60) + log_min) * 60 + log_sec\n        return log_seconds - self.start_seconds \n```", "```py\n>>> ts = TimeSince(\"000123\")  # Log started at 00:01:23\n>>> ts.interval(\"020304\")\n7301.0\n>>> ts.interval(\"030405\")\n10962.0 \n```", "```py\n>>> data = [\n...     (\"000123\", \"INFO\", \"Gila Flats 1959-08-20\"),\n...     (\"000142\", \"INFO\", \"test block 15\"),\n...     (\"004201\", \"ERROR\", \"intrinsic field chamber door locked\"),\n...     (\"004210.11\", \"INFO\", \"generator power active\"),\n...     (\"004232.33\", \"WARNING\", \"extra mass detected\")\n... ] \n```", "```py\nclass LogProcessor:\n    def __init__(self, log_entries: list[tuple[str, str, str]]) -> None:\n        self.log_entries = log_entries\n    def report(self) -> None:\n        first_time, first_sev, first_msg = self.log_entries[0]\n        for log_time, severity, message in self.log_entries:\n            if severity == \"ERROR\":\n                first_time = log_time\n            **interval = ??? Need to compute an interval ???**\n            print(f\"{interval:8.2f} | {severity:7s} {message}\") \n```", "```py\nclass IntervalAdapter:\n    def __init__(self) -> None:\n        self.ts: Optional[TimeSince] = None\n    def time_offset(self, start: str, now: str) -> float:\n        if self.ts is None:\n            self.ts = TimeSince(start)\n        else:\n            h_m_s = self.ts.parse_time(start)\n            if h_m_s != (self.ts.hr, self.ts.min, self.ts.sec):\n                self.ts = TimeSince(start)\n        return self.ts.interval(now) \n```", "```py\nclass LogProcessor:\n    def __init__(\n        self,\n        log_entries: list[tuple[str, str, str]]\n    ) -> None:\n        self.log_entries = log_entries\n        self.time_convert = IntervalAdapter()\n    def report(self) -> None:\n        first_time, first_sev, first_msg = self.log_entries[0]\n        for log_time, severity, message in self.log_entries:\n            if severity == \"ERROR\":\n                first_time = log_time\n            **interval = self.time_convert.time_offset(first_time, log_time)**\n            print(f\"{interval:8.2f} | {severity:7s} {message}\") \n```", "```py\nfrom __future__ import annotations\nimport re\nfrom pathlib import Path\nfrom typing import Iterator, Tuple\nclass FindUML:\n    def __init__(self, base: Path) -> None:\n        self.base = base\n        self.start_pattern = re.compile(r\"@startuml *(.*)\")\n    def uml_file_iter(self) -> Iterator[tuple[Path, Path]]:\n        for source in self.base.glob(\"**/*.uml\"):\n            if any(n.startswith(\".\") for n in source.parts):\n                continue\n            body = source.read_text()\n            for output_name in self.start_pattern.findall(body):\n                if output_name:\n                    target = source.parent / output_name\n                else:\n                    target = source.with_suffix(\".png\")\n                yield (\n                    source.relative_to(self.base),\n                    target.relative_to(self.base)\n                ) \n```", "```py\nimport subprocess\nclass PlantUML:\n    conda_env_name = \"CaseStudy\"\n    base_env = Path.home() / \"miniconda3\" / \"envs\" / conda_env_name\n    def __init__(\n        self,\n        graphviz: Path = Path(\"bin\") / \"dot\",\n        plantjar: Path = Path(\"share\") / \"plantuml.jar\",\n    ) -> None:\n        self.graphviz = self.base_env / graphviz\n        self.plantjar = self.base_env / plantjar\n    def process(self, source: Path) -> None:\n        env = {\n            \"GRAPHVIZ_DOT\": str(self.graphviz),\n        }\n        command = [\n          \"java\", \"-jar\",         str(self.plantjar), \"-progress\",         str(source)\n        ]\n        subprocess.run(command, env=env, check=True)\n        print() \n```", "```py\nclass GenerateImages:\n    def __init__(self, base: Path) -> None:\n        self.finder = FindUML(base)\n        self.painter = PlantUML()\n    def make_all_images(self) -> None:\n        for source, target in self.finder.uml_file_iter():\n            if (\n               not target.exists() \n               or source.stat().st_mtime > target.stat().st_mtime\n            ):\n                print(f\"Processing {source} -> {target}\")\n                self.painter.process(source)\n            else:\n                print(f\"Skipping {source} -> {target}\") \n```", "```py\nif __name__ == \"__main__\":\n    g = GenerateImages(Path.cwd())\n    g.make_all_images() \n```", "```py\nclass Buffer(Sequence[int]):\n    def __init__(self, content: bytes) -> None:\n        self.content = content\n    def __len__(self) -> int:\n        return len(self.content)\n    def __iter__(self) -> Iterator[int]:\n        return iter(self.content)\n    @overload\n    def __getitem__(self, index: int) -> int:\n        ...\n    @overload\n    def __getitem__(self, index: slice) -> bytes:\n        ...\n    def __getitem__(self, index: Union[int, slice]) -> Union[int, bytes]:\n        return self.content[index] \n```", "```py\n>>> raw = Buffer(b\"$GPGLL,3751.65,S,14507.36,E*77\") \n```", "```py\nclass Message(abc.ABC):\n    def __init__(self) -> None:\n        self.buffer: weakref.ReferenceType[Buffer]\n        self.offset: int\n        self.end: Optional[int]\n        self.commas: list[int]\n    def from_buffer(self, buffer: Buffer, offset: int) -> \"Message\":\n        self.buffer = weakref.ref(buffer)\n        self.offset = offset\n        self.commas = [offset]\n        self.end = None\n        for index in range(offset, offset + 82):\n            if buffer[index] == ord(b\",\"):\n                self.commas.append(index)\n            elif buffer[index] == ord(b\"*\"):\n                self.commas.append(index)\n                self.end = index + 3\n                break\n        if self.end is None:\n            raise GPSError(\"Incomplete\")\n        # TODO: confirm checksum.\n        return self\n    def __getitem__(self, field: int) -> bytes:\n        if (not hasattr(self, \"buffer\") \n            or (buffer := self.buffer()) is None):\n        raise RuntimeError(\"Broken reference\")\n    start, end = self.commas[field] + 1, self.commas[field + 1]\n    return buffer[start:end] \n```", "```py\nwhile True:\n    buffer = Buffer(gps_device.read(1024))\n    # process the messages in the buffer. \n```", "```py\ndef get_fix(self) -> Point:\n    return Point.from_bytes(\n        self.latitude(), \n        self.lat_n_s(), \n        self.longitude(), \n        self.lon_e_w()\n    )\n@abc.abstractmethod\ndef latitude(self) -> bytes:\n    ...\n@abc.abstractmethod\ndef lat_n_s(self) -> bytes:\n    ...\n@abc.abstractmethod\ndef longitude(self) -> bytes:\n    ...\n@abc.abstractmethod\ndef lon_e_w(self) -> bytes:\n    ... \n```", "```py\nclass GPGLL(Message):\n    def latitude(self) -> bytes:\n        return self[1]\n    def lat_n_s(self) -> bytes:\n        return self[2]\n    def longitude(self) -> bytes:\n        return self[3]\n    def lon_e_w(self) -> bytes:\n        return self[4] \n```", "```py\ndef message_factory(header: bytes) -> Optional[Message]:\n    # TODO: Add functools.lru_cache to save storage and time\n    if header == b\"GPGGA\":\n        return GPGGA()\n    elif header == b\"GPGLL\":\n        return GPGLL()\n    elif header == b\"GPRMC\":\n        return GPRMC()\n    else:\n        return None \n```", "```py\n>>> buffer = Buffer(\n...     b\"$GPGLL,3751.65,S,14507.36,E*77\"\n... )\n>>> flyweight = message_factory(buffer[1 : 6])\n>>> flyweight.from_buffer(buffer, 0)\n<gps_messages.GPGLL object at 0x7fc357a2b6d0>\n>>> flyweight.get_fix()\nPoint(latitude=-37.86083333333333, longitude=145.12266666666667)\n>>> print(flyweight.get_fix())\n(37°51.6500S, 145°07.3600E) \n```", "```py\n>>> buffer_2 = Buffer(\n...     b\"$GPGLL,3751.65,S,14507.36,E*77\\\\r\\\\n\"\n...     b\"$GPGLL,3723.2475,N,12158.3416,W,161229.487,A,A*41\\\\r\\\\n\"\n... )\n>>> start = 0\n>>> flyweight = message_factory(buffer_2[start+1 : start+6])\n>>> p_1 = flyweight.from_buffer(buffer_2, start).get_fix()\n>>> p_1\nPoint(latitude=-37.86083333333333, longitude=145.12266666666667)\n>>> print(p_1)\n(37°51.6500S, 145°07.3600E) \n```", "```py\n>>> flyweight.end\n30\n>>> next_start = buffer_2.index(ord(b\"$\"), flyweight.end)\n>>> next_start\n32\n>>> \n>>> flyweight = message_factory(buffer_2[next_start+1 : next_start+6])\n>>> p_2 = flyweight.from_buffer(buffer_2, next_start).get_fix()\n>>> p_2\nPoint(latitude=37.387458333333335, longitude=-121.97236)\n>>> print(p_2)\n(37°23.2475N, 121°58.3416W) \n```", "```py\nclass Point:\n    __slots__ = (\"latitude\", \"longitude\")\n    def __init__(self, latitude: float, longitude: float) -> None:\n        self.latitude = latitude\n        self.longitude = longitude\n    def __repr__(self) -> str:\n        return (\n            f\"Point(latitude={self.latitude}, \"\n            f\"longitude={self.longitude})\"\n        ) \n```", "```py\n>>> p2 = Point(latitude=49.274, longitude=-123.185)\n>>> p2.extra_attribute = 42\nTraceback (most recent call last):\n...\nAttributeError: 'Point' object has no attribute 'extra_attribute' \n```", "```py\nfrom enum import Enum, auto\nfrom typing import NamedTuple, List\nclass Suit(str, Enum):\n    Clubs = \"\\N{Black Club Suit}\"\n    Diamonds = \"\\N{Black Diamond Suit}\"\n    Hearts = \"\\N{Black Heart Suit}\"\n    Spades = \"\\N{Black Spade Suit}\"\nclass Card(NamedTuple):\n    rank: int\n    suit: Suit\n    def __str__(self) -> str:\n        return f\"{self.rank}{self.suit}\"\nclass Trick(int, Enum):\n    pass\nclass Hand(List[Card]):\n    def __init__(self, *cards: Card) -> None:\n        super().__init__(cards)\n    def scoring(self) -> List[Trick]:\n        pass \n```", "```py\nimport abc\nclass CardGameFactory(abc.ABC):\n    @abc.abstractmethod\n    def make_card(self, rank: int, suit: Suit) -> \"Card\":\n        ...\n    @abc.abstractmethod\n    def make_hand(self, *cards: Card) -> \"Hand\":\n        ... \n```", "```py\nclass CribbageCard(Card):\n    @property\n    def points(self) -> int:\n        return self.rank\nclass CribbageAce(Card):\n    @property\n    def points(self) -> int:\n        return 1\nclass CribbageFace(Card):\n    @property\n    def points(self) -> int:\n        return 10 \n```", "```py\nclass CribbageHand(Hand):\n    starter: Card\n    def upcard(self, starter: Card) -> \"Hand\":\n        self.starter = starter\n        return self\n    def scoring(self) -> list[Trick]:\n        \"\"\"15's. Pairs. Runs. Right Jack.\"\"\"\n        ... details omitted ...\n        return tricks \n```", "```py\nclass PokerCard(Card):\n    def __str__(self) -> str:\n        if self.rank == 14:\n            return f\"A{self.suit}\"\n        return f\"{self.rank}{self.suit}\"\nclass PokerHand(Hand):\n    def scoring(self) -> list[Trick]:\n        \"\"\"Return a single 'Trick'\"\"\"\n     ... details omitted ...\n        return [rank] \n```", "```py\nclass PokerFactory(CardGameFactory):\n    def make_card(self, rank: int, suit: Suit) -> \"Card\":\n        if rank == 1:\n            # Aces above kings\n            rank = 14\n        return PokerCard(rank, suit)\n    def make_hand(self, *cards: Card) -> \"Hand\":\n        return PokerHand(*cards) \n```", "```py\n>>> factory = CribbageFactory()\n>>> cards = [\n...     factory.make_card(6, Suit.Clubs),\n...     factory.make_card(7, Suit.Diamonds),\n...     factory.make_card(8, Suit.Hearts),\n...     factory.make_card(9, Suit.Spades),\n... ]\n>>> starter = factory.make_card(5, Suit.Spades)\n>>> hand = factory.make_hand(*cards)\n>>> score = sorted(hand.upcard(starter).scoring())\n>>> [t.name for t in score]\n['Fifteen', 'Fifteen', 'Run_5'] \n```", "```py\nclass CardGameFactoryProtocol(Protocol):\n    def make_card(self, rank: int, suit: Suit) -> \"Card\":\n        ...\n    def make_hand(self, *cards: Card) -> \"Hand\":\n        ... \n```", "```py\nclass Folder:\n    def __init__(\n            self, \n            name: str, \n            children: Optional[dict[str, \"Node\"]] = None\n    ) -> None:\n        self.name = name\n        self.children = children or {}\n        self.parent: Optional[\"Folder\"] = None\n    def __repr__(self) -> str:\n        return f\"Folder({self.name!r}, {self.children!r})\"\n    def add_child(self, node: \"Node\") -> \"Node\":\n        node.parent = self\n        return self.children.setdefault(node.name, node)\n    def move(self, new_folder: \"Folder\") -> None:\n        pass\n    def copy(self, new_folder: \"Folder\") -> None:\n        pass\n    def remove(self) -> None:\n        pass\nclass File:\n    def __init__(self, name: str) -> None:\n        self.name = name\n        self.parent: Optional[Folder] = None\n    def __repr__(self) -> str:\n        return f\"File({self.name!r})\"\n\n    def move(self, new_path): \n        pass \n\n    def copy(self, new_path): \n        pass \n\n    def remove(self): \n        pass \n```", "```py\nclass Node(abc.ABC):\n    def __init__(\n        self,\n        name: str,\n    ) -> None:\n        self.name = name\n        self.parent: Optional[\"Folder\"] = None\n    def move(self, new_place: \"Folder\") -> None:\n        previous = self.parent\n        new_place.add_child(self)\n        if previous:\n            del previous.children[self.name]\n    @abc.abstractmethod\n    def copy(self, new_folder: \"Folder\") -> None:\n        ...\n    @abc.abstractmethod\n    def remove(self) -> None:\n        ... \n```", "```py\nclass Folder(Node):\n    def __init__(\n            self, \n            name: str, \n            children: Optional[dict[str, \"Node\"]] = None\n    ) -> None:\n        super().__init__(name)\n        self.children = children or {}\n    def __repr__(self) -> str:\n        return f\"Folder({self.name!r}, {self.children!r})\"\n    def add_child(self, node: \"Node\") -> \"Node\":\n        node.parent = self\n        return self.children.setdefault(node.name, node)\n    def copy(self, new_folder: \"Folder\") -> None:\n        target = new_folder.add_child(Folder(self.name))\n        for c in self.children:\n            self.children[c].copy(target)\n    def remove(self) -> None:\n        names = list(self.children)\n        for c in names:\n            self.children[c].remove()\n        if self.parent:\n            del self.parent.children[self.name]\nclass File(Node):\n    def __repr__(self) -> str:\n        return f\"File({self.name!r})\"\n    def copy(self, new_folder: \"Folder\") -> None:\n        new_folder.add_child(File(self.name))\n    def remove(self) -> None:\n        if self.parent:\n            del self.parent.children[self.name] \n```", "```py\n>>> tree = Folder(\"Tree\")\n>>> tree.add_child(Folder(\"src\"))\nFolder('src', {})\n>>> tree.children[\"src\"].add_child(File(\"ex1.py\"))\nFile('ex1.py')\n>>> tree.add_child(Folder(\"src\"))\nFolder('src', {'ex1.py': File('ex1.py')})\n>>> tree.children[\"src\"].add_child(File(\"test1.py\"))\nFile('test1.py')\n>>> tree\nFolder('Tree', {'src': Folder('src', {'ex1.py': File('ex1.py'), 'test1.py': File('test1.py')})}) \n```", "```py\n+-- Tree\n     +-- src\n          +-- ex1.py\n          +-- test1.py \n```", "```py\n>>> test1 = tree.children[\"src\"].children[\"test1.py\"]\n>>> test1\nFile('test1.py')\n>>> tree.add_child(Folder(\"tests\"))\nFolder('tests', {})\n>>> test1.move(tree.children[\"tests\"])\n>>> tree\nFolder('Tree', \n    {'src': Folder('src', \n        {'ex1.py': File('ex1.py')}), \n     'tests': Folder('tests', \n        {'test1.py': File('test1.py')})}) \n```", "```py\n+-- Tree\n     +-- src\n          +-- ex1.py\n     +-- tests\n          +-- test1.py \n```", "```py\nimport sqlite3\ndef test_setup(db_name: str = \"sales.db\") -> sqlite3.Connection:\n    conn = sqlite3.connect(db_name)\n    conn.execute(\n        \"\"\"\n        CREATE TABLE IF NOT EXISTS Sales (\n            salesperson text,\n            amt currency,\n            year integer,\n            model text,\n            new boolean\n        )\n        \"\"\"\n    )\n    conn.execute(\n        \"\"\"\n        DELETE FROM Sales\n        \"\"\"\n    )\n    conn.execute(\n        \"\"\"\n        INSERT INTO Sales \n        VALUES('Tim', 16000, 2010, 'Honda Fit', 'true')\n        \"\"\"\n    )\n    conn.execute(\n        \"\"\"\n        INSERT INTO Sales \n        VALUES('Tim', 9000, 2006, 'Ford Focus', 'false')\n        \"\"\"\n    )\n    conn.execute(\n        \"\"\"\n        INSERT INTO Sales \n        VALUES('Hannah', 8000, 2004, 'Dodge Neon', 'false')\n        \"\"\"\n    )\n    conn.execute(\n        \"\"\"\n        INSERT INTO Sales \n        VALUES('Hannah', 28000, 2009, 'Ford Mustang', 'true')\n        \"\"\"\n    )\n    conn.execute(\n        \"\"\"\n        INSERT INTO Sales \n        VALUES('Hannah', 50000, 2010, 'Lincoln Navigator', 'true')\n        \"\"\"\n    )\n    conn.execute(\n        \"\"\"\n        INSERT INTO Sales \n        VALUES('Jason', 20000, 2008, 'Toyota Prius', 'false')\n        \"\"\"\n    )\n    conn.commit()\n    return conn \n```", "```py\nclass QueryTemplate:\n    def __init__(self, db_name: str = \"sales.db\") -> None:\n    def connect(self) -> None:\n        pass\n    def construct_query(self) -> None:\n        pass\n    def do_query(self) -> None:\n        pass\n    def output_context(self) -> ContextManager[TextIO]:\n        pass\n    def output_results(self) -> None:\n        pass\n    def process_format(self) -> None:\n        self.connect()\n        self.construct_query()\n        self.do_query()\n        self.format_results()\n        self.output_results() \n```", "```py\nclass QueryTemplate:\n    def __init__(self, db_name: str = \"sales.db\") -> None:\n        self.db_name = db_name\n        self.conn: sqlite3.Connection\n        self.results: list[tuple[str, ...]]\n        self.query: str\n        self.header: list[str]\n    def connect(self) -> None:\n        self.conn = sqlite3.connect(self.db_name)\n    def construct_query(self) -> None:\n        raise NotImplementedError(\"construct_query not implemented\")\n    def do_query(self) -> None:\n        results = self.conn.execute(self.query)\n        self.results = results.fetchall()\n    def output_context(self) -> ContextManager[TextIO]:\n        self.target_file = sys.stdout\n        return cast(ContextManager[TextIO], contextlib.nullcontext())\n    def output_results(self) -> None:\n        writer = csv.writer(self.target_file)\n        writer.writerow(self.header)\n        writer.writerows(self.results)\n    def process_format(self) -> None:\n        self.connect()\n        self.construct_query()\n        self.do_query()\n        with self.output_context():\n            self.output_results() \n```", "```py\nimport datetime\nclass NewVehiclesQuery(QueryTemplate):\n    def construct_query(self) -> None:\n        self.query = \"select * from Sales where new='true'\"\n        self.header = [\"salesperson\", \"amt\", \"year\", \"model\", \"new\"]\nclass SalesGrossQuery(QueryTemplate):\n    def construct_query(self) -> None:\n        self.query = (\n            \"select salesperson, sum(amt) \"\n            \" from Sales group by salesperson\"\n        )\n        self.header = [\"salesperson\", \"total sales\"]\n    def output_context(self) -> ContextManager[TextIO]:\n        today = datetime.date.today()\n        filepath = Path(f\"gross_sales_{today:%Y%m%d}.csv\")\n        self.target_file = filepath.open(\"w\")\n        return self.target_file \n```"]