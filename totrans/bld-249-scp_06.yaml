- en: Chapter 6. Shape Keys, IPOs, and Poses
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第6章。形状关键点，IPOs和姿态
- en: We already encountered IPOs in [Chapter 4](ch04.html "Chapter 4. Pydrivers and
    Constraints"), *Pydrivers and Constraints* when we discussed Pydrivers, but there
    is more to IPOs than just driving one **IPO** by another one. For example, the
    Blender API provides us with the means to define IPOs from scratch, enabling the
    definition of movements not easily re-created by setting key frames by hand. Furthermore,
    some types of IPOs have a somewhat different behavior than the ones that we encountered
    so far. **Shape keys** and **poses** are examples of (collections of) IPOs that
    are quite different from, for example, a location IPO. We will encounter both
    shape keys and poses later on in this chapter, but we will start off with looking
    at how we might define an IPO from scratch.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在[第4章](ch04.html "第4章。Pydrivers和Constraints")中遇到了IPOs，*Pydrivers和Constraints*，当我们讨论Pydrivers时，但IPOs不仅仅是通过另一个IPO来驱动一个**IPO**。例如，Blender
    API为我们提供了从头定义IPO的手段，使我们能够定义手动设置关键帧难以轻松复制的运动。此外，某些类型的IPO的行为与迄今为止我们所遇到的不同。**形状关键点**和**姿态**是（集合）IPO的例子，与例如位置IPO相当不同。我们将在本章后面遇到形状关键点和姿态，但我们将从探讨如何从头开始定义IPO开始。
- en: 'In this chapter, you will learn how to:'
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，你将学习如何：
- en: Define IPOs
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 定义IPOs
- en: Define shape keys on a mesh
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在网格上定义形状关键点
- en: Define IPOs for those shape keys
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 定义那些形状关键点的IPO。
- en: Pose armatures
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 定位骨架
- en: Group changes in poses into actions
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 将姿态变化分组到动作中
- en: A touchy subject—defining an IPO from scratch
  id: totrans-8
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 一个棘手的话题——从头开始定义IPO
- en: Many paths of motion of objects are hard to model by hand, for example, when
    we want the object to follow a precise mathematical curve or if we want to coordinate
    the movement of multiple objects in a way that is not easily accomplished by copying
    IPOs or defining IPO drivers.
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 许多物体的运动路径很难手动建模，例如，当我们想要物体遵循精确的数学曲线或想要以不是通过复制IPO或定义IPO驱动器的方式协调多个物体的运动时。
- en: 'Imagine the following scenario: we want to interchange the position of some
    objects over the duration of some time in a fluid way without those objects passing
    through each other in the middle and without even touching each other. This would
    be doable by manually setting keys perhaps, but also fairly cumbersome, especially
    if we would want to repeat this for several sets of objects. The script that we
    will devise takes care of all of those details and can be applied to any two objects.'
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 想象以下场景：我们希望在一段时间内以流畅的方式交换某些物体的位置，而这些物体在中间不会相互穿过，甚至不会相互接触。这可能通过手动设置关键帧来实现，但这也很繁琐，尤其是如果我们想要为几组物体重复这样做。我们将设计的脚本将处理所有这些细节，并且可以应用于任何两个物体。
- en: 'Code outline: orbit.py'
  id: totrans-11
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 代码概要：orbit.py
- en: 'The `orbit.py` script that we will design will take the following steps:'
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将设计的`orbit.py`脚本将采取以下步骤：
- en: Determine the halfway point between the selected objects.
  id: totrans-13
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 确定所选物体之间的中点。
- en: Determine the extent of the selected objects.
  id: totrans-14
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 确定所选物体的范围。
- en: Define IPO for object one.
  id: totrans-15
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 定义第一个物体的IPO。
- en: Define IPO for object two.
  id: totrans-16
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 定义第二个物体的IPO。
- en: 'Determining the halfway point between the selected objects is easy enough:
    we will just take the average location of both objects. Determining the extent
    of the selected objects is a little bit more challenging though. An object may
    have an irregular shape and determining the shortest distance for any rotation
    of the objects along the path that the object will be taking is difficult to calculate.
    Fortunately, we can make a reasonable approximation, as each object has an associated
    **bounding** **box** **.**'
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 确定所选物体之间的中点很容易：我们只需取两个物体的平均位置。确定所选物体的范围则有点更具挑战性。一个物体可能具有不规则形状，并且计算物体沿其将采取的路径的任何旋转的最短距离是困难的。幸运的是，我们可以做出合理的近似，因为每个物体都有一个相关的**边界****框**。
- en: 'This bounding box is a rectangular box that just encapsulates all of the points
    of an object. If we take half the body diagonal as the extent of an object, then
    it is easy to see that this distance may be an exaggeration of how close we can
    get to another object without touching, depending on the exact form of the object.
    But it will ensure that we never get too close. This bounding box is readily available
    from an object''s `getBoundBox()` method as a list of eight vectors, each representing
    one of the corners of the bounding box. The concept is illustrated in the following
    figure where the bounding boxes of two spheres are shown:'
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 这个边界框是一个矩形框，刚好包围了一个对象的所有点。如果我们取体对角线的一半作为对象的范围，那么很容易看出这个距离可能是对我们如何接近另一个对象而不接触的一种夸张，这取决于对象的精确形状。但它将确保我们永远不会太靠近。这个边界框可以通过对象的
    `getBoundBox()` 方法作为一个包含八个向量的列表轻松获得，每个向量代表边界框的一个角。这个概念在以下图中得到了说明，其中显示了两个球体的边界框：
- en: '![Code outline: orbit.py](img/0400-06-01.jpg)'
  id: totrans-19
  prefs: []
  type: TYPE_IMG
  zh: '![代码概要：orbit.py](img/0400-06-01.jpg)'
- en: 'The length of the body diagonal of a bounding box can be calculated by determining
    both the maximum and minimum values for each x, y, and z coordinate. The components
    of the vector representing this body diagonal are the differences between these
    maximums and minimums. The length of the diagonal is subsequently obtained by
    taking the square root of the sum of squares of the x, y, and z components. The
    function `diagonal()` is a rather terse implementation as it uses many built-in
    functions of Python. It takes a list of vectors as an argument and then iterates
    over each component (highlighted. x, y, and z components of a Blender `Vector`
    may be accessed as 0, 1, and 2 respectively):'
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 矩形框的体对角线长度可以通过确定每个 x、y 和 z 坐标的最大值和最小值来计算。表示该体对角线的向量的分量是这些最大值和最小值之间的差异。通过对 x、y
    和 z 分量的平方和开平方，随后得到对角线的长度。`diagonal()` 函数是一个相当简洁的实现，因为它使用了 Python 的许多内置函数。它接受一个向量列表作为参数，然后遍历每个分量（突出显示。Blender
    `Vector` 的 x、y 和 z 分量分别可以通过 0、1 和 2 访问）：
- en: '[PRE0]'
  id: totrans-21
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: It determines the extremes for each component by using the built-in `max()`
    and `min()` functions. Finally, it returns the length by pairing each minimum
    and maximum by using the `zip()` function.
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 它通过使用内置的 `max()` 和 `min()` 函数来确定每个分量的极端值。最后，它通过使用 `zip()` 函数将每个最小值和最大值配对来返回长度。
- en: 'The next step is to verify that we have exactly two objects selected and inform
    the user if this isn''t the case by drawing a pop up (highlighted in the next
    code snippet). If we do have two objects selected, we retrieve their locations
    and bounding boxes. Then we calculate the maximum distance `w` each object has
    to veer from its path to be half the minimum distance between them, which is equal
    to a quarter of the sum of the lengths of the body diagonals of those objects:'
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 下一步是验证我们是否恰好选择了两个对象，如果不是这种情况，则通过弹出窗口（在下一代码片段中突出显示）通知用户。如果我们确实选择了两个对象，我们检索它们的位置和边界框。然后我们计算每个对象必须偏离其路径的最大距离
    `w`，使其是它们之间最小距离的一半，这等于这些对象体对角线长度之和的四分之一：
- en: '[PRE1]'
  id: totrans-24
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'Before we can calculate the trajectories of both objects, we first create two
    new and empty Object IPOs:'
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们能够计算两个对象的轨迹之前，我们首先创建两个新的空 Object IPO：
- en: '[PRE2]'
  id: totrans-26
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'We arbitrarily choose the start and end frames of our swapping operation to
    be 1 and 30 respectively, but the script could easily be adapted to prompt the
    user for these values. We iterate over each separate IPO curve for the `Location`
    IPO and create the first point (or key frame) and thereby the actual curve by
    assigning a tuple `(framenumber,` `value)` to the curve (highlighted lines of
    the next code). Subsequent points may be added to these curves by indexing them
    by frame number when assigning a value, as is done for frame 30 in the following
    code:'
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 我们任意选择我们的交换操作的开始和结束帧分别为 1 和 30，但脚本可以很容易地修改为提示用户输入这些值。我们遍历每个单独的 `Location` IPO
    曲线，并为曲线分配一个元组 `(framenumber, value)` 以创建第一个点（或关键帧），从而创建实际的曲线（突出显示的下一行代码）。可以通过按帧号索引这些曲线来添加后续的点，就像在以下代码中对帧
    30 所做的那样：
- en: '[PRE3]'
  id: totrans-28
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: Note that the location of the first object keyframed at frame 1 is its current
    location and the location keyframed at frame 30 is the location of the second
    object. For the other object this is just the other way around. We set the interpolation
    modes of these curves to "Bezier" to get a smooth motion. We now have two IPO
    curves that do interchange the location of the two objects, but as calculated
    they will move right through each other.
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，第一个物体在帧1的关键帧位置是其当前位置，而帧30的关键帧位置是第二个物体的位置。对于其他物体，情况正好相反。我们将这些曲线的插值模式设置为“贝塞尔”，以获得平滑的运动。现在我们有两个IPO曲线，它们确实会交换两个物体的位置，但按照计算，它们将直接穿过对方。
- en: 'Our next step therefore is to add a key at frame 15 with an adjusted z-component.
    Earlier, we calculated `w` to hold half the distance needed to keep out of each
    other''s way. Here we add this distance to the z-component of the halfway point
    of the first object and subtract it for the other:'
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，我们的下一步是在帧15添加一个带有调整后的z分量的关键帧。之前，我们计算了`w`来保持彼此之间的距离。现在，我们将这个距离加到第一个物体的中点z分量上，并从另一个物体中减去它：
- en: '[PRE4]'
  id: totrans-31
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'Finally, we add the new IPOs to our objects:'
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们将新的IPO添加到我们的对象中：
- en: '[PRE5]'
  id: totrans-33
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'The full code is available as `swap2.py` in the file `orbit.blend`. The resulting
    paths of the two objects are sketched in the next screenshot:'
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 完整的代码作为`swap2.py`文件存储在`orbit.blend`文件中。两个物体的结果路径在下一张截图中有展示：
- en: '![Code outline: orbit.py](img/0400-06-02.jpg)'
  id: totrans-35
  prefs: []
  type: TYPE_IMG
  zh: '![代码概要：orbit.py](img/0400-06-02.jpg)'
- en: A lot to swallow—defining poses
  id: totrans-36
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 定义姿势有很多要消化
- en: Many cartoon characters seem to have difficulties trying to swallow their food,
    and even if they did enjoy a relaxing lunch, chances are they will be forced through
    a rain pipe too small to fit comfortably for no apparent reason.
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 许多卡通角色似乎在尝试吞咽食物时遇到困难，即使他们享受了一顿轻松的午餐，也很可能他们会被迫通过一个太小而无法舒适通过的雨管。
- en: 'It is difficult to animate swallowing or any other **peristaltic movement**
    by using shape keys as it is not the shape of the overall mesh that changes in
    a uniform way: we want to move along a localized deformation. One way of doing
    that is to associate an armature consisting of a linear chain of bones with the
    mesh that we want to deform (shown in the illustration) and animate the scale
    of each individual bone in time. This way, we can control the movement of the
    ''lump'' inside to a great extent. It is, for example, possible to make the movement
    a little bit halting as it moves from bone to bone to simulate something that
    is hard to swallow.'
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 使用形状键来动画化吞咽或其他**蠕动运动**是困难的，因为整体网格的形状并不是均匀变化的：我们希望沿着局部变形移动。实现这一点的办法之一是将由线性骨骼链组成的骨架与我们要变形的网格（如图所示）关联起来，并在时间上动画化每个单独骨骼的缩放。这样，我们可以极大地控制内部“块”的运动。例如，我们可以使运动稍微停顿，从一根骨骼移动到另一根，以模拟难以吞咽的东西。
- en: '![A lot to swallow—defining poses](img/0400-06-03.jpg)'
  id: totrans-39
  prefs: []
  type: TYPE_IMG
  zh: '![定义姿势有很多要消化——defining poses](img/0400-06-03.jpg)'
- en: In order to synchronize the scaling of the individual bones in a way that follows
    the chain from parent to child, we have to sort our bones because the `bones`
    attribute of the `Pose` object that we get when calling `getPose()` on an armature
    is a dictionary. Iterating over the keys or values of this dictionary will return
    those values in random order.
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 为了以从父级到子级的顺序同步单个骨骼的缩放，我们必须对骨骼进行排序，因为当我们对骨架调用`getPose()`时得到的`Pose`对象的`bones`属性是一个字典。遍历这个字典的键或值将返回随机的值。
- en: Therefore, we define a function `sort_by_parent()` that will take a list of
    `Pose` bones `pbones` and will return a list of strings, each the name of a `Pose`
    bone. The list is sorted with the parent as the first item followed by its children.
    Obviously, this will not return a meaningful list for armatures that have bones
    with more than one child, but for our linear chain of bones it works fine.
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，我们定义了一个函数`sort_by_parent()`，它将接受一个`Pose`骨骼列表`pbones`，并返回一个字符串列表，每个字符串都是一个`Pose`骨骼的名称。列表按照父级作为第一个项目，然后是其子项进行排序。显然，对于具有多个子项的骨骼的骨架，这个列表将没有意义，但对我们线性链骨骼来说，它工作得很好。
- en: 'In the following code, we maintain a list of names called `bones` that hold
    the names of the `Pose` bones in the correct order. We pop the list of `Pose`
    bones and add the name of the `Pose` bone as long as it is not already added (highlighted).
    We compare names instead of `Pose` bone objects because the current implementation
    of `Pose` bones does not reliably implement the `in` operator:'
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  id: totrans-43
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'We then get the parent of the bone that we just added to our list, and as long
    as we can traverse the chain of parents, we insert this parent (or rather its
    name) in our list in front of the current item (highlighted below). If the chain
    cannot be followed anymore we pop a new `Pose` bone. When there are no bones left,
    an `IndexError` exception is raised by the pop() method and we will exit our `while`-`loop`:'
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  id: totrans-45
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'The next step is to define the script itself. First, we get the active object
    in the current scene and verify if it is indeed an armature. If not, we alert
    the user with a pop up (highlighted part of the following code), otherwise we
    proceed and get the associated armature data with the `getData()` method:'
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  id: totrans-47
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: Then, we make the armature editable and make sure that each bone has the `HINGE`
    option set (highlighted). The business with the conversion of the list of options
    to a set and back again to a list once we added the `HINGE` option is a way to
    ensure that the option appears only once in the list.
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  id: totrans-49
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'A pose is associated with an armature object, not with its data, so we get
    it from `arm` by using the `getPose()` method. Bone poses are very much like ordinary
    IPOs but they have to be associated with an **action** that groups those poses.
    When working interactively with the Blender an action gets created automatically
    once we insert a key frame on a pose, but in a script we have to create an action
    explicitly if it is not present already (highlighted):'
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  id: totrans-51
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'The next step is to sort the `Pose` bones as a chain of parenthood by using
    our previously defined function. What is left is to step along the frames in steps
    of ten at a time and set keys on the scale of each bone at each step, scaling
    up if the sequence number of the bone matches our step and resetting it if it
    doesn''t. One of the resulting IPOs is shown in the screenshot. Note that by our
    setting the `HINGE` attribute on each bone previously, we prevent the scaling
    to propagate to the children of the bone:'
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  id: totrans-53
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: The full code is available as `peristaltic.py` in `peristaltic.blend`.
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
- en: '![A lot to swallow—defining poses](img/0400-06-04.jpg)'
  id: totrans-55
  prefs: []
  type: TYPE_IMG
- en: Application of peristaltic.py to an armature
  id: totrans-56
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'To use this script you will have to run it with an armature object selected.
    One recipe to show its application would be the following:'
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
- en: Add an armature to a scene.
  id: totrans-58
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Go to *edit* mode and extrude any number of bones from the tip of the first
    bone.
  id: totrans-59
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Go to *object* mode and add a mesh centered on the position of the armature.
    Any mesh will do but for our illustration we use a cylinder with plenty of subdivisions.
  id: totrans-60
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Select the mesh and then shift select the armature. Both armature and `Mesh`
    object are now selected while the armature is the active object.
  id: totrans-61
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 选择网格，然后按住Shift选择骨架。现在骨架和`网格`对象都被选中，而骨架是活动对象。
- en: Press *Ctrl + P* and select **armature**. In next pop up, select **Create from
    bone heat**. That will create a vertex group on the mesh for each bone in the
    armature. These vertex groups will be used to deform the mesh when we associate
    the armature as a modifier with the mesh.
  id: totrans-62
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 按下 *Ctrl + P* 并选择 **骨架**。在下一个弹出窗口中，选择 **从骨骼热量创建**。这将为骨架中的每个骨骼在网格上创建一个顶点组。这些顶点组将用于当我们将骨架作为修改器与网格关联时变形网格。
- en: Select the mesh and add an armature modifier. Type the name of the armature
    in the **Ob:** field and make sure that the **Vert.Group** toggle is selected
    and **Envelopes** is not.
  id: totrans-63
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 选择网格并添加一个骨架修改器。在**Ob:**字段中输入骨架的名称，并确保**Vert.Group**切换被选中，而**Envelopes**没有被选中。
- en: Select the armature and run the `peristaltic.py`.
  id: totrans-64
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 选择骨架并运行`peristaltic.py`。
- en: 'The result will be an animated `Mesh` object resembling a lump passing through
    a narrow flexible pipe. A few frames are shown in the illustration:'
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 结果将是一个动画的`网格`对象，类似于一个团块通过一个狭窄的柔性管道。图示中展示了几个帧：
- en: '![Application of peristaltic.py to an armature](img/0400-06-05.jpg)'
  id: totrans-66
  prefs: []
  type: TYPE_IMG
  zh: '![peristaltic.py应用于骨架的应用](img/0400-06-05.jpg)'
- en: 'Rain pipes are of course not the only hollow objects fit for animating this
    way as shown in the following illustration:'
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 如下所示，雨水管当然不是唯一适合以这种方式动画的空心物体：
- en: '![Application of peristaltic.py to an armature](img/0400-06-06.jpg)'
  id: totrans-68
  prefs: []
  type: TYPE_IMG
  zh: '![peristaltic.py应用于骨架的应用](img/0400-06-06.jpg)'
- en: Get down with the beat—syncing shape keys to sound
  id: totrans-69
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 跟随节奏——同步形状键与声音
- en: Many a rock video today features an animation of speaker cones reverberating
    with the sound of the music. And although the features for the manipulation of
    **sound** in the Blender API are rather sparse, we will see that this effect is
    rather simple to achieve.
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 许多摇滚音乐视频今天都展示了扬声器振膜随着音乐声音共振的动画。尽管Blender API中用于操作 **声音** 的功能相当稀少，但我们将看到这个效果相当简单就能实现。
- en: The animation that we will construct depends mainly on the manipulation of **shape
    keys**. Shape keys can be understood as distortions of a base mesh. A mesh can
    have many of these distortions and each of them is given a distinct name. The
    fun part is that Blender provides us with the possibility to interpolate between
    the base shape and any of the distorted shapes in a continuous way, even allowing
    us to mix contributions from different shapes.
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将要构建的动画主要依赖于对 **形状键** 的操作。形状键可以理解为基网格的扭曲。一个网格可以有多个这样的扭曲，每个扭曲都有一个独特的名称。有趣的是，Blender为我们提供了连续地在基形状和任何扭曲形状之间进行插值的可能性，甚至允许我们从不同的形状中混合贡献。
- en: One way to animate our speaker cone, for instance, is to model a basic, undistorted
    shape of the cone; add a shape key to this base mesh; and distort it to resemble
    a cone that is pushed outward. We can then blend between this "pop out" shape
    and the base's shape depending on the loudness of the sound.
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，要动画我们的扬声器振膜，一种方法是为锥形建模一个基本的、未扭曲的形状；向这个基网格添加一个形状键；并将其扭曲以类似于被推向外推的锥形。然后我们可以根据声音的响度在这“弹出”形状和基形状之间进行混合。
- en: Animating by setting key frames in Blender means creating IPOs and manipulating
    IPO curves as we have seen earlier. Indeed, `Shape` or `Key` IPOs are very similar
    to other kinds of IPOs and are manipulated very much in the same way. The main
    difference between for example an Object IPO and a Shape IPO is that the individual
    IPO curves of a Shape IPO are not indexed by some predefined numerical constant
    (such as `Ipo.OB_LOCX` for an Object) but by a string because the user may define
    any number of named shapes.
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 在Blender中通过设置关键帧进行动画意味着创建IPOs并像我们之前看到的那样操作IPO曲线。实际上，`形状` 或 `关键` IPOs与其他类型的IPOs非常相似，并且以非常相似的方式进行操作。例如，对象IPO和形状IPO之间的主要区别在于形状IPO的个别IPO曲线不是通过某些预定义的数值常数（如对象的`Ipo.OB_LOCX`）索引，而是通过字符串，因为用户可以定义任意数量的命名形状。
- en: Also, a `Shape` IPO is not accessed via an Object but through its underlying
    `Mesh` object (or `Lattice` or `Curve`, as these may have shape keys as well).
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，`形状` IPO不是通过对象访问，而是通过其底层的`网格`对象（或`晶格`或`曲线`，因为这些也可能有形状键）。
- en: Manipulating sound files
  id: totrans-75
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 操作声音文件
- en: So now that we know how to animate shapes, our next goal is to find out how
    to add some sound to our mesh, or rather to determine at each frame how much the
    distorted shape should be visible.
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 既然我们已经知道了如何动画化形状，我们的下一个目标就是找出如何给我们的网格添加一些声音，或者说确定在每一帧中扭曲的形状应该有多明显。
- en: As mentioned in the previous section, Blender's API does not provide many tools
    for manipulating sound files, Basically the `Sound` module provides us with ways
    to load and play a sound file but that's as far as it gets. There is no way to
    access individual points of the waveform encoded in the file.
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 如前文所述，Blender的API没有提供很多用于操作音频文件的工具，基本上`Sound`模块为我们提供了加载和播放音频文件的方法，但仅此而已。无法访问文件中编码的波形中的单个点。
- en: Fortunately, standard Python distributions come bundled with a `wave` module
    that provides us with the means to read files in the common `.wav` format. Although
    it supports only the uncompressed format, this will suffice as this format is
    very common and most audio tools, such as **Audacity**, can convert to this format.
    With this module we can open a `.wav` file, determine the sample rate and duration
    of the sound clip, and access individual samples. As we will see in the explanation
    of the following code, we still have to convert these samples to values that we
    can use as key values for our shape keys but the heavy lifting is already done
    for us.
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 幸运的是，标准的Python发行版自带了一个`wave`模块，它为我们提供了读取常见`.wav`格式文件的手段。尽管它只支持未压缩格式，但这已经足够了，因为这个格式非常常见，大多数音频工具，如**Audacity**，都可以转换成这个格式。使用这个模块，我们可以打开`.wav`文件，确定音频片段的采样率和时长，并访问单个样本。正如我们将在以下代码的解释中看到的那样，我们仍然需要将这些样本转换为我们可以用作形状键关键值的值，但繁重的工作已经为我们完成了。
- en: 'Code outline: Sound.py'
  id: totrans-79
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 代码概要：Sound.py
- en: 'Armed with the knowledge on how to construct IPO curves and access `.wav` files,
    we might draw up the following code outline:'
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 在掌握了如何构建IPO曲线和访问`.wav`文件的知识后，我们可能可以绘制以下代码概要：
- en: Determine if the active object has suitable shapes defined and provide a choice.
  id: totrans-81
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 确定活动对象是否已定义了合适的形状并提供选择。
- en: Let the user select a `.wav` file.
  id: totrans-82
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 允许用户选择`.wav`文件。
- en: Determine the number of sound samples per second present in the file.
  id: totrans-83
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 确定文件中每秒的音频样本数量。
- en: Calculate the number of animation frames needed based on the duration of the
    sound file and the video frame rate.
  id: totrans-84
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 根据音频文件的时长和视频帧率计算所需的动画帧数。
- en: 'Then, for each animation frame:'
  id: totrans-85
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后，对于每个动画帧：
- en: Average the sound samples occurring in this frame
  id: totrans-86
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 计算此帧中出现的音频样本的平均值
- en: Set the blend value of the chosen IPO curve to this (normalized) average
  id: totrans-87
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 将所选IPO曲线的混合值设置为这个（归一化）平均值
- en: 'The full code is available as `Sound.py` in `sound000.blend` and explained
    as follows:'
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 完整的代码作为`Sound.py`在`sound000.blend`中提供，并如下所述：
- en: '[PRE12]'
  id: totrans-89
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: We start off by importing the necessary modules including Python's `wave` module
    to access our `.wav` file and the `struct` module that provides functions to manipulate
    the actual binary data that we get from the `.wav` file.
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 我们首先导入必要的模块，包括Python的`wave`模块来访问我们的`.wav`文件和`struct`模块，它提供了操作我们从`.wav`文件中获取的实际二进制数据的函数。
- en: 'Next, we define a utility function to pop up a menu in the middle of our screen.
    It behaves just like the regular `PupMenu()` function from the `Draw` module but
    sets the cursor to a position halfway across and along the screen with the help
    of the `GetScreenSize()` and `SetMouseCoords()` functions from Blender''s `Window`
    module:'
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们定义一个实用函数，在屏幕中间弹出菜单。它就像`Draw`模块中的常规`PupMenu()`函数一样，但在`GetScreenSize()`和`SetMouseCoords()`函数的帮助下将光标设置在屏幕中间的位置：
- en: '[PRE13]'
  id: totrans-92
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'The bulk of the work will be done by the function `sound2active()`. It will
    take two arguments—the filename of the `.wav` file to use and the name of the
    shape key to animate based on the information in the `.wav` file. First, we attempt
    to create a `WaveReader` object by calling the `open()` function of the `wave`
    module (highlighted). If this fails, we show the error in a pop up and quit:'
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 大部分工作将由`sound2active()`函数完成。它将接受两个参数——要使用的`.wav`文件的文件名和基于`.wav`文件中的信息的要动画化的形状键的名称。首先，我们尝试通过调用`wave`模块的`open()`函数（突出显示）来创建一个`WaveReader`对象。如果失败，我们将错误显示在一个弹出窗口中并退出：
- en: '[PRE14]'
  id: totrans-94
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'Then we do some sanity checks: we first check if the `.wav` file is a `MONO`
    file. If you want to use a stereo file, convert it to mono first, for example
    with the free Audacity package ([http://audacity.sourceforge.net/)](http://audacity.sourceforge.net/)).
    Then we check if we are dealing with an uncompressed `.wav` file because the `wave`
    module cannot handle other types. (most `.wav` files are uncompressed but if needed,
    Audacity can convert them as well) and we verify that the samples are 16-bits.
    If any of these checks fail, we pop up an appropriate error message:'
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 然后我们进行一些合理性检查：我们首先检查`.wav`文件是否是`MONO`文件。如果您想使用立体声文件，请先将其转换为单声道，例如使用免费的Audacity软件包（[http://audacity.sourceforge.net/](http://audacity.sourceforge.net/））。然后我们检查我们是否在处理未压缩的`.wav`文件，因为`wave`模块无法处理其他类型。（大多数`.wav`文件都是未压缩的，但如果需要，Audacity也可以将它们转换为未压缩格式）并且我们验证样本是否为16位。如果这些检查中的任何一个失败，我们将弹出适当的错误消息：
- en: '[PRE15]'
  id: totrans-96
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: Now that we can process the file, we get its **frame** **rate** (the number
    of audio samples per second) and the total number of bytes (oddly enough by using
    the awkwardly named function `getnframes()` from the `wave` module). Then, we
    read all of these bytes and store them in the variable `b`.
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们能够处理文件了，我们获取其**帧率**（每秒的音频样本数）以及总字节数（奇怪的是，通过使用`wave`模块中名为`getnframes()`的尴尬命名的函数）。然后，我们读取所有这些字节并将它们存储在变量`b`中。
- en: '[PRE16]'
  id: totrans-98
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'Our next task is to get the rendering context from the current scene to retrieve
    the number of video frames per second. The number of seconds our animation will
    play is determined by the length of our audio sample, something we can calculate
    by dividing the total number of audio frames in the `.wav` file by the number
    of audio frames per second (highlighted in the following piece of code). We then
    define a constant `sampleratio`—the number of audio frames per video frame:'
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 我们接下来的任务是获取当前场景的渲染上下文以检索每秒的视频帧数。我们的动画将播放的秒数由音频样本的长度决定，我们可以通过将`.wav`文件中的总音频帧数除以每秒音频帧数来计算这一点（在下面的代码片段中突出显示）。然后我们定义一个常量`sampleratio`——每视频帧的音频帧数：
- en: '[PRE17]'
  id: totrans-100
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: As mentioned before, the `wave` module gives us access to a number of properties
    of a `.wav` file and the raw audio samples, but provides no functions to convert
    these raw samples to usable integer values. We therefore need to do this ourselves.
    Fortunately, this is not as hard as it may seem. Because we know that the 16-bit
    audio samples are present as 2 byte integers in the "little-endian" format, we
    can use the `unpack()` function from Python's `struct` module to efficiently convert
    the list of bytes to a list of integers by passing a fitting format specification.
    (You can read more about the way `.wav` files are laid out on [https://ccrma.stanford.edu/courses/422/projects/WaveFormat/](https://ccrma.stanford.edu/courses/422/projects/WaveFormat/).)
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 如前所述，`wave`模块为我们提供了访问`.wav`文件和原始音频样本的多个属性，但提供了将原始样本转换为可用的整数值的函数。因此，我们需要自己完成这项工作。幸运的是，这并不像看起来那么困难。因为我们知道16位音频样本以“小端”格式作为2字节整数存在，我们可以使用Python的`struct`模块中的`unpack()`函数通过传递合适的格式说明符来有效地将字节列表转换为整数列表。（您可以在[https://ccrma.stanford.edu/courses/422/projects/WaveFormat/](https://ccrma.stanford.edu/courses/422/projects/WaveFormat/)上了解更多关于`.wav`文件布局的信息。）
- en: '[PRE18]'
  id: totrans-102
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: Now we can start animating the shape key. We get the start frame from the rendering
    context and calculate the end frame by multiplying the number of seconds in the
    `.wav` file with the video frame rate. Note that this may be longer or shorter
    than the end frame that we may get from the rendering context. The latter determines
    the last frame that will get rendered when the user clicks on the **Anim** button,
    but we will animate the movement of our active object regardless of this value.
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们可以开始动画形状键了。我们从渲染上下文中获取起始帧，并通过将`.wav`文件中的秒数乘以视频帧率来计算结束帧。请注意，这可能会比我们从渲染上下文中得到的结束帧更长或更短。后者决定了当用户点击**动画**按钮时将渲染的最后一帧，但我们将无论这个值如何都会动画化活动对象的移动。
- en: Then for each frame we calculate from start frame to end frame (exclusive) the
    average value of the audio samples that occur in each video frame by summing these
    audio samples (present in the `samples` list) and dividing them by the number
    of audio samples per video frame (highlighted in the next code snippet).
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 然后对于从起始帧到结束帧（不包括）的每一帧，我们通过将这些音频样本（存在于`samples`列表中）相加并除以每视频帧的音频样本数来计算每个视频帧中出现的音频样本的平均值（在下一个代码片段中突出显示）。
- en: 'We will set the chosen shape key to a value in the range [0:1] so we will have
    to normalize the calculated averages by determining the minimum and maximum values
    and calculate a scale:'
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  id: totrans-106
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'Finally, we get the active object in the current scene and get its `Shape`
    IPO (highlighted). We conclude by setting the value of the shape key for each
    frame in the range we are considering to the scaled average of the audio samples:'
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  id: totrans-108
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'The remaining script itself is now rather simple. It fetches the active object
    and then tries to retrieve a list of shape key names from it (highlighted in the
    next part). This may fail (hence the `try … except` clause) if for example the
    active object is not a mesh or has no associated shape keys, in which case we
    alert the user with a pop up:'
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  id: totrans-110
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: If we were able to retrieve a list of shape keys, we present the user with a
    pop-up menu to choose from this list. If the user selects one of the items, `key`
    will be positive and we present the user with a file selector dialog (highlighted).
    This file selector dialog is passed a `lambda` function that will be called if
    the user selects a file, passing the name of this selected file as an argument.
    In our case we construct this `lambda` function to call the `sound2active()` function
    defined previously with this filename and the selected shape key.
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
- en: The initial directory that will be presented to the user in the file selector
    to pick a file from is determined by the last argument to the `FileSelector()`
    function. We set it to the contents of Blender's `soundsdir` parameter. This usually
    is `//` (that is, a relative path pointing to the same directory as the `.blend`
    file the user is working on) but may be set in the user preferences window (**File**
    **Paths** section) to something else.
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
- en: 'Animating a mesh by a .wav file: the workflow'
  id: totrans-113
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Now that we have our `Sounds.py` script we can apply it as follows:'
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
- en: Select a `Mesh` object.
  id: totrans-115
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Add a "Basis" shape key to it (**Buttons** **window**, **Editing** **context**,
    **Shapes** **panel**). This will correspond to the least distorted shape of the
    mesh.
  id: totrans-116
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Add a second shape key and give it a meaningful name.
  id: totrans-117
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Edit this mesh to represent the most distorted shape.
  id: totrans-118
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: In *object* mode, run `Sound.py` from the text editor by pressing *Alt + P.*
  id: totrans-119
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Select the shape key name defined earlier (not the "Basis" one) from the pop
    up.
  id: totrans-120
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Select the `.wav` file to apply.
  id: totrans-121
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'The result will be an object with an `IPOcurve` for the chosen shape key that
    will fluctuate according to the beat of the sound as shown in the next screenshot:'
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
- en: '![Animating a mesh by a .wav file: the workflow](img/0400-06-07.jpg)'
  id: totrans-123
  prefs: []
  type: TYPE_IMG
- en: Summary
  id: totrans-124
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In this chapter we saw how to associate shape keys with a mesh and how to add
    an IPO to animate transitions between those shape keys. Specifically, we learned
    how to:'
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
- en: Define IPOs
  id: totrans-126
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Define shape keys on a mesh
  id: totrans-127
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Define IPOs for those shape keys
  id: totrans-128
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Pose armatures
  id: totrans-129
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Group changes in poses into actions
  id: totrans-130
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: In the next chapter, we shall learn how to create custom textures and shaders.
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
