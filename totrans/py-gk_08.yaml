- en: '*Chapter 6*: Advanced Tips and Tricks in Python'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we will introduce some advanced tips and tricks that can be
    used as powerful programming techniques when writing code in Python. These include
    the advanced use of Python functions, such as nested functions, lambda functions,
    and building decorators with functions. Additionally, we will cover data transformations
    with the filter, mapper, and reducer functions. This will be followed by some
    tricks that can be used with data structures, such as the use of nested dictionaries
    and comprehension with different collection types. Finally, we will investigate
    the advanced functionality of the pandas library for DataFrame objects. These
    advanced tips and tricks will not only demonstrate Python's power in achieving
    advanced features with less code, but it will also help you code faster and more
    efficiently.
  prefs: []
  type: TYPE_NORMAL
- en: 'In this chapter, we will cover the following topics:'
  prefs: []
  type: TYPE_NORMAL
- en: Learning advanced tricks for using functions
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Understanding advanced concepts with data structures
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Introducing advanced tricks with pandas DataFrame
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: By the end of this chapter, you will have gained an understanding of how to
    use Python functions for advanced features such as data transformations and building
    decorators. Additionally, you will learn how to use data structures including
    pandas DataFrame for analytics-based applications.
  prefs: []
  type: TYPE_NORMAL
- en: Technical requirements
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The technical requirements for this chapter are as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: You need to have Python 3.7 or later installed on your computer.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: You need to register an account with TestPyPI and create an API token under
    your account.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The sample code for this chapter can be found at [https://github.com/PacktPublishing/Python-for-Geeks/tree/master/Chapter06](https://github.com/PacktPublishing/Python-for-Geeks/tree/master/Chapter06).
  prefs: []
  type: TYPE_NORMAL
- en: We will start our discussion with the advanced concepts for using functions
    in Python.
  prefs: []
  type: TYPE_NORMAL
- en: Learning advanced tricks for using functions
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The use of functions in Python and other programming languages is key for reusability
    and modularization. However, with new advances to modern programming languages,
    the role of functions has been extended beyond reusability, which includes writing
    simple, short, and concise code without using complex loops and conditional statements.
  prefs: []
  type: TYPE_NORMAL
- en: We will start with the use of the `counter`, `zip`, and `itertools` functions,
    which we will discuss next.
  prefs: []
  type: TYPE_NORMAL
- en: Introducing the counter, itertools, and zip functions for iterative tasks
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: For any data processing tasks, developers extensively use iterators. We have
    covered iterators, in detail, in [*Chapter 4*](B17189_04_Final_PG_ePub.xhtml#_idTextAnchor141),
    *Python Libraries for Advanced Programming*. In this section, we will learn about
    the next level of utility functions to help you conveniently work with iterators
    and iterables. These include the `counter` module, the `zip` function, and the
    `itertools` module. We will discuss each of these in the following subsections.
  prefs: []
  type: TYPE_NORMAL
- en: Counter
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '`Counter` class, we will present a simple code example, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'In the preceding code example, we created multiple `Counter` instances using
    a `String` object, a list object, and a dictionary object. The `Counter` class
    has methods such as `most_common` and `elements`. We used the `most_common` method
    with a value of `1`, which gives us the element that appears the most in the `my-counter`
    container. Additionally, we used the `elements` method to return the original
    list from the `Counter` instance. The console output of this program should be
    as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: It is important to note that in the case of the dictionary object, we deliberately
    used a repeated key, but in the `Counter` instance, we get only one key-value
    pair, which is the last one in the dictionary. Additionally, the elements in the
    `Counter` instance are ordered based on the values for each element. Note that
    the `Counter` class converts the dictionary object into a hashtable object.
  prefs: []
  type: TYPE_NORMAL
- en: zip
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'The `zip` function is used to create an aggregated iterator based on two or
    more individual iterators. The `zip` function is useful when we are required to
    iterate on multiple iterations in parallel. For example, we can use the `zip`
    function when implementing mathematical algorithms that involve interpolation
    or pattern recognition. This is also helpful in digital signal processing where
    we combine multiple signals (data sources) into a single signal. Here is a simple
    code example that uses a `zip` function:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: 'In the preceding code example, we combined the two lists for iteration purposes
    by using the `zip` function. Note that one list is larger than the other in terms
    of the number of elements. The console output of this program should be as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: As expected, we get the first two tuples using the `next` function, which is
    a combination of corresponding elements from each list. In the end, we used the
    `list` constructor to iterate over the rest of the tuples from the `zip` iterator.
    This gives us a list of the remaining tuples in a list format.
  prefs: []
  type: TYPE_NORMAL
- en: itertools
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Python offers a module, called `itertools`, that provides useful functions
    to work with iterators. When working with a large set of data, the use of iterators
    is a must, and that is where the utility functions provided by the `itertool`
    module prove to be very helpful. There are many functions available with the `itertools`
    module. We will briefly introduce a few key functions here:'
  prefs: []
  type: TYPE_NORMAL
- en: '`count`: This function is used to create an iterator for counting numbers.
    We can provide a starting number (default = 0) and, optionally, set a size of
    the counting step for the increment. The following code example will return an
    iterator that provides counting numbers, such as 10, 12, and 14:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '`cycle`: This function allows you to cycle through an iterator endlessly. The
    following code snippet illustrates how you can use this function for a list of
    alphabet letters:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '`Repeat`: This function provides us with an iterator that returns an object
    over and over again unless there is a `times` argument set with it. The following
    code snippet will repeat the `Python` string object five times:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '`accumulate`: This function will return an iterator that provides us with an
    accumulated sum or other accumulated results based on an aggregator function that
    was passed to this `accumulate` function as an argument. It is easier to understand
    the use of this function with a code example, as follows:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '`chain`: This function combines two or more iterables and returns a combined
    iterable. Take a look at the following example code showing two iterables (lists)
    along with the `chain` function:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Note that this function will combine the iterables in a serial manner. This
    means that items in `list1` will be accessible first, followed by the items in
    `list2`.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '`compress`: This function can be used to filter elements from one iterable
    based on another iterable. In the example code snippet, we have selected alphabet
    letters from a list based on a `selector` iterable:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '`groupby`: This function identifies the keys for each item in an iterable object
    and groups the items based on the identified keys. This function requires another
    function (known as `key_func`) that identifies a key in each element of an iterable
    object. The following example code explains the use of this function along with
    how to implement a `key_func` function:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '`tee`: This is another useful function that can be used to duplicate iterators
    from a single iterator. Here is an example code that duplicates two iterators
    from a single list iterable:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Next, we will discuss another category of functions that is extensively used
    for data transformation.
  prefs: []
  type: TYPE_NORMAL
- en: Using filters, mappers, and reducers for data transformations
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '`map`, `filter`, and `reduce` are three functions available in Python that
    are used to simplify and write concise code. These three functions are applied
    to iterables in a single shot without using iterative statements. The `map` and
    `filter` functions are available as built-in functions, while the `reduce` function
    requires you to import the `functtools` module. These functions are extensively
    used by data scientists for data processing. The `map` function and the `filter`
    function are used to transform or filter data, whereas the `reduce` function is
    used in data analysis to get meaningful results from a large dataset.'
  prefs: []
  type: TYPE_NORMAL
- en: In the following subsections, we will evaluate each function with its application
    and code examples.
  prefs: []
  type: TYPE_NORMAL
- en: map
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'The `map` function in Python is defined using the following syntax:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: The `func` argument is the name of the function that will be applied to each
    item of the `iter` object. The three dots indicate that it is possible to pass
    multiple iterable objects. However, it is important to understand that the number
    of arguments of the function (`func`) must match the number of iterable objects.
    The output of the `map` function is a `map` object, which is a generator object.
    The return value can be converted into a list by passing the `map` object to the
    `list` constructor.
  prefs: []
  type: TYPE_NORMAL
- en: Important note
  prefs: []
  type: TYPE_NORMAL
- en: In Python 2, the `map` function returns a list. This behavior has been changed
    in Python 3.
  prefs: []
  type: TYPE_NORMAL
- en: 'Before discussing the use of a `map` function, first, we will implement a simple
    transformation function that converts a list of numbers into their square values.
    The code example is provided next:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: 'Here, the code example uses a `for` loop structure to iterate through a list,
    calculates the square of each entry in the list, and then adds it to a new list.
    This style of writing code is common, but it is definitely not a Pythonic way
    to write code. The console output of this program is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: 'With the use of the `map` function, this code can be simplified and shortened,
    as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: By using the `map` function, we provided the name of the function (in this example,
    it is `square`) and the reference of the list (in this example, it is `mylist`).
    The `map` object that is returned by the `map` function is converted into a list
    object by using the `list` constructor. The console output of this code example
    is the same as the previous code example.
  prefs: []
  type: TYPE_NORMAL
- en: 'In the following code example, we will provide two lists as input for the `map`
    function:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: This time, the goal of the `map` function that has been implemented is to use
    the `product` function. The `product` function takes each item from two lists
    and multiplies the corresponding item in each list before returning it to the
    `map` function.
  prefs: []
  type: TYPE_NORMAL
- en: 'The console output of this code example is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: An analysis of this console output tells us that only the first four items from
    each list are used by the `map` function. The `map` function automatically stops
    when it runs out of the items in any of the iterables (in our case, these are
    the two lists). This means that even if we provide iterables of different sizes,
    the `map` function will not raise any exception but will work for the number of
    items that are possible to map across iterables using the function provided. In
    our code example, we have a smaller number of items in the `mylist2` list, which
    is four. That is why we only have four items in the output list (in our case,
    this is `new_list`). Next, we will discuss the `filter` function with some code
    examples.
  prefs: []
  type: TYPE_NORMAL
- en: filter
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'The `filter` function also operates on iterables but only on one iterable object.
    As its name suggests, it provides a filtering functionality on the iterable object.
    The filtering criteria are provided through the function definition. The syntax
    of a `filter` function is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: 'The `func` function provides the filtering criteria, and it has to return `True`
    or `False`. Since only one iterable is allowed alongside the `filter` function,
    only one argument is allowed for the `func` function. The following code example
    uses a `filter` function to select the items whose values are even numbers. To
    implement the selection criteria, the function `is_even` is implemented to evaluate
    whether a number provided to it is an even number or not. The sample code is as
    follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: 'The console output of the preceding code example is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: Next, we will discuss the `reduce` function.
  prefs: []
  type: TYPE_NORMAL
- en: reduce
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'The `reduce` function is used to apply a cumulative processing function on
    each element of a sequence, which is passed to it as an argument. This cumulative
    processing function is not for transformation or filtration purposes. As its name
    suggests, the cumulative processing function is used to get a single result at
    the end based on all of the elements in a sequence. The syntax of using the `reduce`
    function is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: 'The `func` function is a function that is used to apply cumulative processing
    on each element of the iterable. Additionally, `initial` is an optional value
    that can be passed to the `func` function to be used as an initial value for cumulative
    processing. It is important to understand that there will always be two arguments
    to the `func` function for the `reduce` function case: the first argument will
    either be the initial value (if provided) or the first element of the sequence,
    and the second argument will be the next element from the sequence.'
  prefs: []
  type: TYPE_NORMAL
- en: 'In the following code example, we will use a simple list of the first five
    numbers. We will implement a custom method to add the two numbers and then use
    the `reduce` method to sum all of the elements in the list. The code example is
    shown next:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: 'The output of this program is `15`, which is a numerical sum of all the elements
    of the list (in our example, this is called `mylist`). If we provide the initial
    value to the `reduce` function, the result will be appended as per the initial
    value. For example, the output of the same program with the following statement
    will be `25`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: As mentioned previously, the result or return value of the `reduce` function
    is a single value, which is as per the `func` function. In this example, it will
    be an integer.
  prefs: []
  type: TYPE_NORMAL
- en: In this section, we discussed the `map`, `filter`, and `reduce` functions that
    are available within Python. These functions are used extensively by data scientists
    for data transformation and data refinement. One problem of using functions such
    as `map` and `filter` is that they return an object of the `map` or `filter` type,
    and we have to convert the results explicitly into a `list` data type for further
    processing. The comprehensions and generators do not have such limitations but
    provide similar functionality, and they are relatively easier to use. That is
    why they are getting more traction than the `map`, `filter`, and `reduce` functions.
    We will discuss comprehension and generators in the *Understanding advanced concepts
    with data structures* section. Next, we will investigate the use of lambda functions.
  prefs: []
  type: TYPE_NORMAL
- en: Learning how to build lambda functions
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Lambda functions are anonymous functions that are based on a single-line expression.
    Just as the `def` keyword is used to define regular functions, the `lambda` keyword
    is used to define anonymous functions. Lambda functions are restricted to a single
    line. This means they cannot use multiple statements, and they cannot use a return
    statement. The return value is automatically returned after the evaluation of
    the single-line expression.
  prefs: []
  type: TYPE_NORMAL
- en: The lambda functions can be used anywhere a regular function is used. The easiest
    and most convenient usage of lambda functions is with the `map`, `reduce`, and
    `filter` functions. Lambda functions are helpful when you wish to make the code
    more concise.
  prefs: []
  type: TYPE_NORMAL
- en: 'To illustrate a lambda function, we will reuse the map and filter code examples
    that we discussed earlier. In these code examples, we will replace `func` with
    a lambda function, as highlighted in the following code snippet:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: Although the code has become more concise, we should be careful about using
    lambda functions. These functions are not reusable, and they are not easy to maintain.
    We need to rethink this before introducing a lambda function into our program.
    Any changes or additional functionality will not be easy to add. A rule of thumb
    is to only use lambda functions for simple expressions when writing a separate
    function would be an overhead.
  prefs: []
  type: TYPE_NORMAL
- en: Embedding a function within another function
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: When we add a function within an existing function, it is called an `def` keyword
    and with the appropriate indentation. The inner functions cannot be executed or
    called by the outside program. However, if the outer function returns a reference
    of the inner function, it can be used by the caller to execute the inner function.
    We will take a look at examples of returning inner function references for many
    use cases in the following subsections.
  prefs: []
  type: TYPE_NORMAL
- en: Inner functions have many advantages and applications. We will describe a few
    of them next.
  prefs: []
  type: TYPE_NORMAL
- en: Encapsulation
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'A common use case of an inner function is being able to hide its functionality
    from the outside world. The inner function is only available within the outer
    function scope and is not visible to the global scope. The following code example
    shows one outer function that is hiding an inner function:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: From the outside of the outer function, we can only call the outer function.
    The inner function can only be called from the body of the outer function.
  prefs: []
  type: TYPE_NORMAL
- en: Helper functions
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'In some cases, we can find ourselves in a situation where the code within a
    function code is reusable. We can turn such reusable code into a separate function;
    otherwise, if the code is reusable only within the scope of a function, then it
    is a case of building an inner function. This type of inner function is also called
    the helper function. The following code snippet illustrates this concept:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: In the preceding sample code, we defined an inner function, called `get_prefix`
    (a helper function), inside an outer function to filter the first two letters
    of an argument value. Since we have to repeat this filtering process for all arguments,
    we added a helper function for reusability within the scope of this function as
    it is specific to this function.
  prefs: []
  type: TYPE_NORMAL
- en: The closure and factory functions
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: This is a type of use case in which the inner functions shine. A **closure**
    is an inner function along with its enclosing environment. A closure is a dynamically
    created function that can be returned by another function. The real magic of a
    closure is that the returned function has full access to the variables and namespaces
    where it was created. This is true even when the enclosing function (in this context,
    it is the outer function) has finished executing.
  prefs: []
  type: TYPE_NORMAL
- en: 'The closure concept can be illustrated by a code example. The following code
    example shows a use case where we have implemented a closure factory to create
    a function to calculate the power of the base value, and the base value is retained
    by the closure:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: In the preceding code example, the outer function (that is, `power_calc_factory`)
    acts as a closure factory function because it creates a new closure every time
    it is called, and then it returns the closure to the caller. Additionally, `power_calc`
    is an inner function that takes one variable (that is, `base`) from the closure
    namespace and then takes the second variable (that is, `exponent`), which is passed
    to it as an argument. Note that the most important statement is `return power_calc`.
    This statement returns the inner function as an object with its enclosure.
  prefs: []
  type: TYPE_NORMAL
- en: 'When we call the `power_calc_factory` function for the first time along with
    the `base` argument, a closure is created with its namespace, including the argument
    that was passed to it, and the closure is returned to the caller. When we call
    the same function again, we get a new closure with the inner function object.
    In this code example, we created 2 closures: one with a `base` value of 2 and
    the other with a `base` value of 3\. When we called the inner function by passing
    different values for the `exponent` variable, the code inside the inner function
    (in this case, the `power_calc` function) will also have access to the `base`
    value that was already passed to the outer function.'
  prefs: []
  type: TYPE_NORMAL
- en: These code examples illustrated the use of outer and inner functions to create
    functions dynamically. Traditionally, inner functions are used for hiding or encapsulating
    functionality inside a function. But when they are used along with the outer functions
    acting as a factory for creating dynamic functions, it becomes the most powerful
    application of the inner functions. Inner functions are also used to implement
    decorators. We will discuss this in more detail in the following section.
  prefs: []
  type: TYPE_NORMAL
- en: Modifying function behavior using decorators
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The concept of decorators in Python is based on the **Decorator** design pattern,
    which is a type of structural design pattern. This pattern allows you to add new
    behavior to objects without changing anything in the object implementation. This
    new behavior is added inside the special wrapper objects.
  prefs: []
  type: TYPE_NORMAL
- en: In Python, **decorators** are special high-order functions that enable developers
    to add new functionality to an existing function (or a method) without adding
    or changing anything within the function. Typically, these decorators are added
    before the definition of a function. Decorators are used for implementing many
    features of an application, but they are particularly popular in data validation,
    logging, caching, debugging, encryption, and transaction management.
  prefs: []
  type: TYPE_NORMAL
- en: To create a decorator, we have to define a callable entity (that is, a function,
    a method, or a class) that accepts a function as an argument. The callable entity
    will return another function object with a decorator-defined behavior. The function
    that is decorated (we will call it a *decorated function* for the remainder of
    this section) is passed as an argument to the function that is implementing a
    decorator (which will be called a *decorator function* for the remainder of this
    section). The decorator function executes the function passed to it in addition
    to the additional behavior that was added as part of the decorator function.
  prefs: []
  type: TYPE_NORMAL
- en: 'A simple example of a decorator is shown in the following code example in which
    we define a decorator to add a timestamp before and after the execution of a function:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: 'In this code example, we define a `add_timestamps` decorator function that
    takes any function as an argument. In the inner function (`_add_timestamps`),
    we take the current time before and after the execution of the function, which
    is then passed as an argument. The decorator function returns the inner function
    object with a closure. The decorators are doing nothing more than using inner
    functions smartly, as we discussed in the previous section. The use of the `@`
    symbol to decorate a function is equivalent to the following lines of codes:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: In this case, we are calling the decorator function explicitly by passing the
    function name as a parameter. In other words, the decorated function is equal
    to the inner function, which is defined inside the decorator function. This is
    exactly how Python interprets and calls the decorator function when it sees a
    decorator with the `@` symbol before the definition of a function.
  prefs: []
  type: TYPE_NORMAL
- en: 'However, a problem arises when we have to obtain additional details about the
    invocation of functions, which is important for debugging. When we use the built-in
    `help` function with the `hello_world` function, we only receive help for the
    inner function. The same happens if we use the docstring, which will also work
    for the inner function but not the decorated function. Additionally, serializing
    the code is going to be a challenge for decorated functions. There is a simple
    solution that is available in Python for all of these problems; that solution
    is to use the `wraps` decorator from the `functools` library. We will revise our
    previous code example to include the `wraps` decorator. The complete code example
    is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: The use of the `wraps` decorators will provide additional details about the
    executions of the nested functions, and we can view these in the console output
    if we run the example code that has been provided.
  prefs: []
  type: TYPE_NORMAL
- en: So far, we have looked at a simple example of a decorator to explain this concept.
    For the remainder of this section, we will learn how to pass arguments with a
    function to a decorator, how to return value from a decorator, and how to chain
    multiple decorators. To begin, we will learn how to pass attributes and return
    a value with decorators.
  prefs: []
  type: TYPE_NORMAL
- en: Using a decorated function with a return value and argument
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'When our decorated function takes arguments, then decorating such a function
    requires some additional tricks. One trick is to use `*args` and `**kwargs` in
    the inner wrapper function. This will make the inner function accept any arbitrary
    number of positional and keyword arguments. Here is a simple example of a decorated
    function with arguments along with the return value:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: In the preceding example, the inner function of `inner_calc` takes the generic
    parameters of `*args` and `**kwargs`. To return a value from an inner function
    (in our code example, `inner_calc`), we can hold the returned value from the function
    (in our code example, this is either `func` or `power_base2(n)`) that is executed
    inside our inner function and return the final return value from the inner function
    of `inner_calc`.
  prefs: []
  type: TYPE_NORMAL
- en: Building a decorator with its own arguments
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'In the previous examples, we used what we call `decorator3.py` example. In
    the revised version, we calculate the power of a base value that is passed as
    an argument to the decorator. You can view a complete code example using nested
    decorator functions as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: 'The working of this code example is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: The `power_calc` decorator function takes one argument base and returns the
    `inner_decorator` function, which is a standard decorator implementation.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The `inner_decorator` function takes a function as an argument and returns the
    `inner_calc` function to do the actual calculation.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The `inner_calc` function calls the decorated function to get the `exponent`
    attribute (in this case) and then uses the `base` attribute, which is passed to
    the outer decorator function as an argument. As expected, the closure around the
    inner function makes the value of the `base` attribute available to the `inner_calc`
    function.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Next, we will discuss how to use more than one decorator with a function or
    a method.
  prefs: []
  type: TYPE_NORMAL
- en: Using multiple decorators
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'We have learned numerous times that there is a possibility of using more than
    one decorator with a function. This is possible by chaining the decorators. Chained
    decorators can either be the same or different. This can be achieved by placing
    the decorators one after the other before the function definition. When more than
    one decorator is used with a function, the decorated function is only executed
    once. To illustrate its implementation and practical use, we have selected an
    example in which we log a message to a target system using a timestamp. The timestamp
    is added through a separate decorator, and the target system is also selected
    based on another decorator. The following code sample shows the definitions of
    three decorators, that is, `add_time_stamp`, `file`, and `console`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: 'In the preceding code example, we implemented three decorator functions. They
    are as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '`file`: This decorator uses a predefined text file and adds the message provided
    by the decorated function to the file.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`console`: This decorator outputs the message provided by the decorated function
    to the console.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`add_timestamp`: This decorator adds a timestamp prior to the message provided
    by the decorated function. The execution of this decorator function has to occur
    before the file or console decorators, which means this decorator has to be placed
    last in the chain of decorators.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'In the following code snippet, we can use these decorators for different functions
    inside our main program:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs: []
  type: TYPE_PRE
- en: In the preceding code sample, we used the three decorator functions defined
    earlier in different combinations to exhibit the different behaviors from the
    same logging function. In the first combination, we output the message to the
    file only after adding the timestamp. In the second combination, we output the
    message to both the file and the console. In the final combination, we output
    the message to the console only. This shows the flexibility that the decorators
    provide without needing to change the functions. It is worth mentioning that the
    decorators are very useful in simplifying the code and adding behavior in a concise
    way, but they have the cost of additional overheads during execution. The use
    of decorators should be limited to those scenarios where the benefit is enough
    to compensate for any overhead costs.
  prefs: []
  type: TYPE_NORMAL
- en: This concludes our discussion regarding advanced function concepts and tricks.
    In the next section, we will switch gears to some advanced concepts related to
    data structures.
  prefs: []
  type: TYPE_NORMAL
- en: Understanding advanced concepts with data structures
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Python offers comprehensive support for data structures, including key tools
    for storing data and accessing data for processing and retrieving. In [*Chapter
    4*](B17189_04_Final_PG_ePub.xhtml#_idTextAnchor141), *Python Libraries for Advanced
    Programming*, we discussed the data structure objects that are available in Python.
    In this section, we will cover a number of advanced concepts such as a dictionary
    within a dictionary and how to use comprehension with a data structure. We will
    start by embedding a dictionary inside a dictionary.
  prefs: []
  type: TYPE_NORMAL
- en: Embedding a dictionary inside a dictionary
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: A dictionary in a dictionary or a nested dictionary is the process of putting
    a dictionary inside another dictionary. A nested dictionary is useful in many
    real-world examples, particularly when you are processing and transforming data
    from one format into the other.
  prefs: []
  type: TYPE_NORMAL
- en: '*Figure 6.1* shows a nested dictionary. The root dictionary has two dictionaries
    against key `1` and key `3`. The dictionary against key `1` has further dictionaries
    inside it. The dictionary against key `3` is a regular dictionary with key-value
    pairs as its entries:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 6.1: An example of a dictionary inside a dictionary'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/B17189_06_01.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: 'Figure 6.1: An example of a dictionary inside a dictionary'
  prefs: []
  type: TYPE_NORMAL
- en: 'The root dictionary shown in *Figure 6.1* can be written as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs: []
  type: TYPE_PRE
- en: Here, we created a root dictionary with a mix of dictionary objects and list
    objects inside it.
  prefs: []
  type: TYPE_NORMAL
- en: Creating or defining a nested dictionary
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'A nested dictionary can be defined or created by placing comma-separated dictionaries
    within curly brackets. To demonstrate how to create a nested dictionary, we will
    create a dictionary for students. Each student entry will have another dictionary
    with `name` and `age` as its elements, which are mapped to their student number:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs: []
  type: TYPE_PRE
- en: Next, we will learn how to create a dictionary dynamically and how to add or
    update nested dictionary elements.
  prefs: []
  type: TYPE_NORMAL
- en: Adding to a nested dictionary
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'To create a dictionary in a dictionary dynamically or to add elements to an
    existing nested dictionary, we can use multiple approaches. In the following code
    example, we will used three different approaches to build a nested dictionary.
    They are the same as the ones we defined in the `dictionary1.py` module:'
  prefs: []
  type: TYPE_NORMAL
- en: In the first case, we will build an inner dictionary (that is, `student101`)
    through the direct assignment of key-value pair items and then by assigning it
    to a key in the root dictionary. This is the preferred approach whenever possible
    because the code is both easier to read and manage.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: In the second case, we created an empty inner dictionary (that is, `student102`)
    and assigned the values to the keys through assignment statements. This is also
    a preferred approach when the values are available to us through other data structures.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'In the third case, we directly initiate an empty directory for the third key
    of the root dictionary. After the initialization process, we assign the values
    using double indexing (that is, two keys): the first key is for the root dictionary,
    and the second key is for the inner dictionary. This approach makes the code concise,
    but it is not a preferred approach if code readability is important for maintenance
    reasons.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The complete code example for these three different cases is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE37]'
  prefs: []
  type: TYPE_PRE
- en: Next, we will discuss how to access different elements from a nested dictionary.
  prefs: []
  type: TYPE_NORMAL
- en: Accessing elements from a nested dictionary
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'As we discussed earlier, to add values and dictionaries inside a dictionary,
    we can use double indexing. Alternatively, we can use the `get` method of the
    dictionary object. The same approach is applicable to access different elements
    from an inner dictionary. The following is an example code that illustrates how
    to access different elements from the inner dictionaries using the `get` method
    and double indexes:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE38]'
  prefs: []
  type: TYPE_PRE
- en: Next, we will examine how to delete an inner dictionary or a key-value pair
    item from an inner dictionary.
  prefs: []
  type: TYPE_NORMAL
- en: Deleting from a nested dictionary
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'To delete a dictionary or an element from a dictionary, we can use the generic
    `del` function, or we can use the `pop` method of the `dictionary` object. In
    the following example code, we will present both the `del` function and the `pop`
    method to demonstrate their usage:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE39]'
  prefs: []
  type: TYPE_PRE
- en: In the next section, we will discuss how comprehension helps to process data
    from different data structure types.
  prefs: []
  type: TYPE_NORMAL
- en: Using comprehension
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '**Comprehension** is a quick way in which to build new sequences such as lists,
    sets, and dictionaries from existing sequences. Python supports four different
    types of comprehension, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: List comprehension
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Dictionary comprehension
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Set comprehension
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Generator comprehension
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: We will discuss a brief overview, with code examples, for each of these comprehension
    types in the following subsections.
  prefs: []
  type: TYPE_NORMAL
- en: List comprehension
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '**List comprehension** involves creating a dynamic list using a loop and a
    conditional statement if needed.'
  prefs: []
  type: TYPE_NORMAL
- en: 'A few examples of how to use list comprehension will help us to understand
    the concept better. In the first example (that is, `list1.py`), we will create
    a new list from an original list by adding 1 to each element of the original list.
    Here is the code snippet:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE40]'
  prefs: []
  type: TYPE_PRE
- en: 'In this case, the new list will be created using the `x+1` expression, where
    `x` is an element in the original list. This is equivalent to the following traditional
    code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE41]'
  prefs: []
  type: TYPE_PRE
- en: Using list comprehension, we can achieve these three lines of code with only
    one line of code.
  prefs: []
  type: TYPE_NORMAL
- en: 'In the second example (that is, `list2.py`), we will create a new list from
    the original list of numbers from 1 to 10 but only include even numbers. We can
    do this by simply adding a condition to the previous code example, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE42]'
  prefs: []
  type: TYPE_PRE
- en: As you can see, the condition is added to the end of the comprehension expression.
    Next, we will discuss how to build dictionaries using comprehension.
  prefs: []
  type: TYPE_NORMAL
- en: Dictionary comprehension
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Dictionaries can also be created by using **dictionary comprehension**. Dictionary
    comprehension, which is similar to list comprehension, is an approach of creating
    a dictionary from another dictionary in such a way that the items from the source
    dictionary are selected or transformed conditionally. The following code snippet
    shows an example of creating a dictionary from existing dictionary elements that
    are less than or equal to 200 and by dividing each selected value by 2\. Note
    that the values are also converted back into integers as part of the comprehension
    expression:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE43]'
  prefs: []
  type: TYPE_PRE
- en: 'This dictionary comprehension code is equivalent to the following code snippet
    if done using traditional programming:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE44]'
  prefs: []
  type: TYPE_PRE
- en: Note that comprehension reduces the code significantly. Next, we will discuss
    set comprehension.
  prefs: []
  type: TYPE_NORMAL
- en: Set comrehension
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Sets can also be created using **set comprehension**, just like list comprehension.
    The code syntax for creating sets using set comprehension is similar to list comprehension.
    The exception is that we will be using curly brackets instead of square brackets.
    In the following code snippet, you can view an example of creating a set from
    a list using set comprehension:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE45]'
  prefs: []
  type: TYPE_PRE
- en: 'This set comprehension code is equivalent to the following code snippet with
    traditional programming:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE46]'
  prefs: []
  type: TYPE_PRE
- en: As expected, the duplicate entries will be discarded in the set.
  prefs: []
  type: TYPE_NORMAL
- en: This concludes our discussion regarding the types of comprehension that are
    available in Python for different data structures. Next, we will discuss the filtering
    options that are available with data structures.
  prefs: []
  type: TYPE_NORMAL
- en: Introducing advanced tricks with pandas DataFrame
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '**pandas** is an open source Python library that provides tools for high-performance
    data manipulation to make data analysis quick and easy. The typical uses of the
    pandas library are to reshape, sort, slice, aggregate, and merge data.'
  prefs: []
  type: TYPE_NORMAL
- en: The pandas library is built on top of the **NumPy** library, which is another
    Python library that is used for working with arrays. The NumPy library is significantly
    faster than traditional Python lists because data is stored at one continuous
    location in memory, which is not the case with traditional lists.
  prefs: []
  type: TYPE_NORMAL
- en: 'The pandas library deals with three key data structures, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '`Series`: This is a single-dimensional array-like object that contains an array
    of data and an array of data labels. The array of data labels is called an `index`.
    The `index` can be specified automatically using integers from *0 to n-1* if not
    explicitly specified by a user.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`DataFrame`: This is a representation of tabular data such as a spreadsheet
    containing a list of columns. The DataFrame object helps to store and manipulate
    tabular data in rows and columns. Interestingly, the DataFrame object has an index
    for both columns and rows.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`Panel`: This is a three-dimensional container of data.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The DataFrame is the key data structure that is used in data analysis. In the
    remainder of this section, we will be using the DataFrame object extensively in
    our code examples. Before we discuss any advanced tricks regarding these pandas
    DataFrame objects, we will do a quick review of the fundamental operations available
    for DataFrame objects.
  prefs: []
  type: TYPE_NORMAL
- en: Learning DataFrame operations
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'We will start by creating DataFrame objects. There are several ways to create
    a DataFrame, such as from a dictionary, a CSV file, an Excel sheet, or from a
    NumPy array. One of the easiest ways is to use the data in a dictionary as input.
    The following code snippet shows how you can build a DataFrame object based on
    weekly weather data stored in a dictionary:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE47]'
  prefs: []
  type: TYPE_PRE
- en: 'The console output will show the contents of the DataFrame as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 6.2 – The contents of the DataFrame](img/B17189_06_02.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 6.2 – The contents of the DataFrame
  prefs: []
  type: TYPE_NORMAL
- en: 'The pandas library is very rich in terms of methods and attributes. However,
    it is beyond the scope of this section to cover all of them. Instead, we will
    present a quick summary of the commonly used attributes and methods of DataFrame
    objects next to refresh our knowledge before using them in the upcoming code examples:'
  prefs: []
  type: TYPE_NORMAL
- en: '`index`: This attribute provides a list of indexes (or labels) of the DataFrame
    object.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`columns`: This attribute provides a list of columns in the DataFrame object.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`size`: This returns the size of the DataFrame object in terms of the number
    of rows multiplied by the number of columns.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`shape`: This provides us with a tuple representing the dimension of the DataFrame
    object.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`axes`: This attribute returns a list that represents the axes of the DataFrame
    object. Put simply, it includes rows and columns.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`describe`: This powerful method generates statistics data such as the count,
    mean, standard deviation, and minimum and maximum values.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`head`: This method returns *n* (default = 5) rows from a DataFrame object
    similar to the head command on files.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`tail`: This method returns the last *n* (default = 5) rows from a DataFrame
    object.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`drop_duplicates`: This method drops duplicate rows based on all of the columns
    in a DataFrame.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`dropna`: This method removes missing values (such as rows or columns) from
    a DataFrame. By passing appropriate arguments to this method, we can either remove
    rows or columns. Additionally, we can set whether the rows or columns will be
    removed based on a single occurrence of a missing value or only when all of the
    values in a row or column are missing.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`sort_values`: This method can be used to sort the rows based on single or
    multiple columns.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: In the following sections, we will review some fundamental operations for DataFrame
    objects.
  prefs: []
  type: TYPE_NORMAL
- en: Setting a custom index
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'The column labels (index) are normally added as per the data provided with
    a dictionary or according to whatever other input data stream has been used. We
    can change the index of the DataFrame by using one of the following options:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Set one of the data columns as an index, such as `day` in the previously mentioned
    example, by using a simple statement like this:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE48]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'The DataFrame will start using the `day` column as an index column, and its
    contents will be as follows:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '![Figure 6.3 – The contents of the DataFrame after using the day column as
    an index'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '](img/B17189_06_03.jpg)'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Figure 6.3 – The contents of the DataFrame after using the `day` column as an
    index
  prefs: []
  type: TYPE_NORMAL
- en: 'Set the index manually by providing it through a list, such as in the following
    code snippet:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE49]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'With this code snippet, the DataFrame will start using the index as provided
    by us through a list object. The contents of the DataFrame will show this change
    as follows:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '![Figure 6.4 – The contents of the DataFrame after setting custom entries for
    an index column'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/B17189_06_04.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 6.4 – The contents of the DataFrame after setting custom entries for
    an index column
  prefs: []
  type: TYPE_NORMAL
- en: Next, we will discuss how to navigate inside a DataFrame using a certain index
    and column.
  prefs: []
  type: TYPE_NORMAL
- en: Navigating inside a DataFrame
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'There are a few dozen ways in which to get a row of data or a particular location
    from a DataFrame object. The typical methods that are used to navigate inside
    a DataFrame are the `loc` and `iloc` methods. We will explore a few options of
    how to navigate through a DataFrame object using the same sample data that we
    used in the previous example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE50]'
  prefs: []
  type: TYPE_PRE
- en: 'Next, we will discuss a few techniques, with code samples, regarding how to
    select a row or location in this DataFrame object:'
  prefs: []
  type: TYPE_NORMAL
- en: 'We can select one or more rows by using index labels with the `loc` method.
    The index label is provided as a single item or a list. In the following code
    snippet, we have illustrated two examples of how to select one or more rows:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE51]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'We can select a value from a location in a DataFrame object using the row index
    label and the column label, as follows:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE52]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'We can also select a row by using an index value without providing any labels:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE53]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'We can select a value from a location using the row index value and the column
    index value by treating the DataFrame object like a two-dimensional array. In
    the next code snippet, we will get a value from a location in which the row index
    = 2 and the column index = 2:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE54]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Next, we will discuss how to add a row or a column to a DataFrame object.
  prefs: []
  type: TYPE_NORMAL
- en: Adding a row or column to a DataFrame
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'The easiest way to add a row to a DataFrame object is by assigning a list of
    values to an index location or an index label. For example, we can add a new row
    with the `TST` label for the previous example (that is, `pandas3.py`) by using
    the following statement:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE55]'
  prefs: []
  type: TYPE_PRE
- en: It is important to note that if the row label already exists in the DataFrame
    object, the same line of code can update the row with new values.
  prefs: []
  type: TYPE_NORMAL
- en: 'If we are not using the index label but the default index instead, we can use
    the index number to update an existing row or add a new row by using the following
    line of code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE56]'
  prefs: []
  type: TYPE_PRE
- en: 'A complete code example is shown for reference:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE57]'
  prefs: []
  type: TYPE_PRE
- en: 'To add a new column to a DataFrame object, multiple options are available in
    the pandas library. We will only illustrate three options, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '**By adding a list of values next to the column label**: This approach will
    add a column after the existing columns. If we use an existing column label, this
    approach can also be used to update or replace an existing column.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**By using the insert method**: This method will take a label and a list of
    values as arguments. This is particularly useful when you want to insert a column
    at any location. Note that this method does not allow you to insert a column if
    there is already an existing column inside the DataFrame object with the same
    label. This means this method cannot be used to update an existing column.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**By using the assign method**: This method is useful when you want to add
    multiple columns in one go. If we use an existing column label, this method can
    be used to update or replace an existing column.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'In the following code example, we will use all three approaches to insert a
    new column to a DataFrame object:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE58]'
  prefs: []
  type: TYPE_PRE
- en: Next, we will evaluate how to delete rows and columns from a DataFrame object.
  prefs: []
  type: TYPE_NORMAL
- en: Deleting an index, a row, or a column from a DataFrame
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Removing an index is relatively straightforward, and you can do so by using
    the `reset_index` method. However, the `reset_index` method adds default indexes
    and keeps the custom index column as a data column. To remove the custom index
    column completely, we have to use the `drop` argument with the `reset_index` method.
    The following code snippet uses the `reset_index` method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE59]'
  prefs: []
  type: TYPE_PRE
- en: 'To delete a duplicate row from a DataFrame object, we can use the `drop_duplicate`
    method. To delete a particular row or column, we can use the `drop` method. In
    the following code example, we will remove any rows with the `SAT` and `SUN` labels
    and any columns with the `condition` label:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE60]'
  prefs: []
  type: TYPE_PRE
- en: Next, we will examine how to rename an index or a column.
  prefs: []
  type: TYPE_NORMAL
- en: Renaming indexes and columns in a DataFrame
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'To rename an index or a column label, we will use the `rename` method. A code
    example of how to rename an index and a column is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE61]'
  prefs: []
  type: TYPE_PRE
- en: It is important to note that the current label and the new label for the index
    and column are provided as a dictionary. Next, we will discuss some advanced tricks
    for using DataFrame objects.
  prefs: []
  type: TYPE_NORMAL
- en: Learning advanced tricks for a DataFrame object
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In the previous section, we evaluated the fundamental operations that can be
    performed on a DataFrame object. In this section, we will investigate the next
    level of operations on a DataFrame object for data evaluation and transformation.
    These operations are discussed in the following subsections.
  prefs: []
  type: TYPE_NORMAL
- en: Replacing data
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'One common requirement is to replace numeric data or string data with another
    set of values. The pandas library is full of options in which to carry out such
    data replacements. The most popular method for these operations is to use the
    `at` method. The `at` method provides an easy way to access or update data in
    any cell in a DataFrame. For bulk replacement operations, you can also use a `replace`
    method, and we can use this method in many ways. For example, we can use this
    method to replace a number with another number or a string with another string,
    or we can replace anything that matches a regular expression. Additionally, we
    can use this method to replace any entries provided through a list or a dictionary.
    In the following code example (that is, `pandastrick1.py`), we will cover most
    of these replacement options. For this code example, we will use the same DataFrame
    object that we used in previous code examples. Here is the sample code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE62]'
  prefs: []
  type: TYPE_PRE
- en: 'Next, we will explore several replacement operations on this DataFrame object,
    one by one:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Replace any occurrences of the numeric value of `40` with `39` across the DataFrame
    object using the following statement:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE63]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Replace any occurrences of a `Sunny` string with `Sun` across the DataFrame
    object using the following statement:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE64]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Replace any occurrences of a string based on a regular expression (the aim
    is to replace `Cloudy` with `Cloud`) using the following statement:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE65]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Note that the use of the `to_replace` and `value` argument labels is optional.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Replace any occurrences of multiple strings represented by a list with another
    list of strings using the following statement:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE66]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: In this code, we replaced `Monday` and `Tuesday` with `Mon` and `Tue`.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Replace any occurrences of multiple strings in a DataFrame object using the
    key-value pairs in a dictionary. You can do this by using the following statement:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE67]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: In this case, the keys of the dictionary (that is, `Wednesday` and `Thursday`)
    will be replaced by their corresponding values (that is, `Wed` and `Thu`).
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Replace any occurrences of a string for a certain column using multiple dictionaries.
    You can do this by using the column name as a key in the dictionary and a sample
    statement such as the following:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE68]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: In this scenario, the first dictionary is used to indicate the column name and
    the value to be replaced. The second dictionary is used to indicate the same column
    name but with a value that will replace the original value. In our case, we will
    replace all instances of `Friday` in the `day` column with the value of `Fri`.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Replace any occurrences of multiple strings using a nested dictionary. You
    can do this by using a code sample such as the following:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE69]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: In this scenario, the outer dictionary (with the `day` and `condition` keys
    in our code sample) is used to identify the columns for this operation and the
    inner dictionary is used to hold the data to be replaced along with the replacing
    value. By using this approach, we replaced `Saturday` and `Sunday` with `Sat`
    and `Sun` inside the `day` column and the `Rainy` string with `Rain` inside the
    `condition` column.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: The complete code with all these sample operations is available within the source
    code of this chapter as `pandastrick1.py`. Note that we can either trigger the
    replacement operation across the DataFrame object or we can limit it to a certain
    column or a row.
  prefs: []
  type: TYPE_NORMAL
- en: Important note
  prefs: []
  type: TYPE_NORMAL
- en: The `inplace=True` argument is used with all `replace` method calls. This argument
    is used to set the output of the `replace` method within the same DataFrame object.
    The default option is to return a new DataFrame object without changing the original
    object. This argument is available with many DataFrame methods for convenience.
  prefs: []
  type: TYPE_NORMAL
- en: Applying a function to the column or row of a DataFrame object
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Sometimes, we want to clean up the data, adjust the data, or transform the data
    before starting data analysis. There is an easy way in which to apply some type
    of function on a DataFrame using the `apply`, `applymap`, or `map` methods. The
    `apply` method is applicable to columns or rows, while the `applymap` method works
    element by element for the whole DataFrame. In comparison, the `map` method works
    element by element for a single series. Now, we will discuss a couple of code
    examples to illustrate the use of the `apply` and `map` methods.
  prefs: []
  type: TYPE_NORMAL
- en: It is common to have data imported into a DataFrame object that might need some
    cleaning up. For example, it could have trailing or leading whitespaces, new line
    characters, or any unwanted characters. These can be removed from the data easily
    by using the `map` method and the lambda function on a column series. The lambda
    function is used on each element of the column. In our code example, first, we
    will remove the trailing whitespace, dot, and comma. Then, we will remove the
    leading whitespace, underscore, and dash for the `condition` column.
  prefs: []
  type: TYPE_NORMAL
- en: 'After cleaning up the data inside the `condition` column, the next step is
    to create a new `temp_F` column from the values of the `temp` column and convert
    them from Celsius units into Fahrenheit units. Note that we will use another lambda
    function for this conversion and use the `apply` method. When we get the result
    from the `apply` method, we will store it inside a new column label, `temp_F`,
    to create a new column. Here is the complete code example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE70]'
  prefs: []
  type: TYPE_PRE
- en: Note that for the preceding code example, we provided the same input data as
    in previous examples except that we added trailing and leading characters to the
    `condition` column data.
  prefs: []
  type: TYPE_NORMAL
- en: Querying rows in a DataFrame object
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'To query rows based on the values in a certain column, one common approach
    is to apply a filter using *AND* or *OR* logical operations. However, this quickly
    becomes a messy approach for simple requirements such as searching a row with
    a value in between a range of values. The pandas library offers a cleaner tool:
    the `between` method, which is somewhat similar to the *between* keyword in SQL.'
  prefs: []
  type: TYPE_NORMAL
- en: 'The following code example uses the same `weekly_data` DataFrame object that
    we used in the previous example. First, we will show the use of a traditional
    filter, and then we will show the use of the `between` method to query the rows
    that have temperature values between 30 and 40 inclusively:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE71]'
  prefs: []
  type: TYPE_PRE
- en: We get the same console output for both approaches we used. However, using the
    `between` method is far more convenient than writing conditional filters.
  prefs: []
  type: TYPE_NORMAL
- en: 'Querying rows based on text data is also very well supported in the pandas
    library. This can be achieved by using the `str` accessor on the string-type columns
    of the DataFrame object. For example, if we want to search rows in our `weekly_data`
    DataFrame object based on the condition of a day, such as `Rainy` or `Sunny`,
    we can either write a traditional filter or we can use the `str` accessor on the
    column with the `contains` method. The following code example illustrates the
    use of both options to get the rows with `Rainy` or `Sunny` as data values in
    the `condition` column:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE72]'
  prefs: []
  type: TYPE_PRE
- en: If you run the preceding code, you will find that the console output is the
    same for both of the approaches we used for searching the data.
  prefs: []
  type: TYPE_NORMAL
- en: Getting statistics on the DataFrame object data
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'To get statistical data such as central tendency, standard deviation, and shape,
    we can use the `describe` method. The output of the `describe` method for numeric
    columns includes the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '`count`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`mean`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`standard deviation`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`min`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`max`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`25`th `percentiles, 50`th `percentile, 75`th `percentile`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The default breakdown of percentiles can be changed by using the `percentiles`
    argument with the desired breakdown.
  prefs: []
  type: TYPE_NORMAL
- en: If the `describe` method is used for non-numeric data, such as strings, we will
    get *count*, *unique*, *top*, and *freq*. The *top* value is the most common value,
    whereas *freq* is the most common value frequency. By default, only numeric columns
    are evaluated by the `describe` method unless we provide the `include` argument
    with an appropriate value.
  prefs: []
  type: TYPE_NORMAL
- en: 'In the following code example, we will evaluate the following for the same
    `weekly_date` DataFrame object:'
  prefs: []
  type: TYPE_NORMAL
- en: The use of the `describe` method with or without the `include` argument
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The use of the `percentiles` argument with the `describe` method
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The use of the `groupby` method to group data on a column basis and then using
    the `describe` method on top of it
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The complete code example is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE73]'
  prefs: []
  type: TYPE_PRE
- en: Note that we changed the `max_columns` options for the pandas library at the
    beginning in order to display all of the columns that we expected in the console
    output. Without this, some of the columns will be truncated for the console output
    of the `groupby` method.
  prefs: []
  type: TYPE_NORMAL
- en: This concludes our discussion of the advanced tricks of working with a DataFrame
    object. This set of tricks and tips will empower anyone to start using the pandas
    library for data analysis. For additional advanced concepts, we recommend that
    you refer to the official documentation of the pandas library.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we introduced some advanced tricks that are important when
    you want to write efficient and concise programs in Python. We started with advanced
    functions such as the mapper, reducer, and filter functions. We also discussed
    several advanced concepts of functions, such as inner functions, lambda functions,
    and decorators. This was followed by a discussion of how to use data structures,
    including nested dictionaries and comprehensions. Finally, we reviewed the fundamental
    operations of a DataFrame object, and then we evaluated a few use cases using
    some advanced operations of the DataFrame object.
  prefs: []
  type: TYPE_NORMAL
- en: This chapter mainly focused on hands-on knowledge and experience of how to use
    advanced concepts in Python. This is important for anyone who wants to develop
    Python applications, especially for data analysis. The code examples provided
    in this chapter are very helpful for you to begin learning the advanced tricks
    that are available for functions, data structures, and the pandas library.
  prefs: []
  type: TYPE_NORMAL
- en: In the next chapter, we will explore multiprocessing and multithreading in Python.
  prefs: []
  type: TYPE_NORMAL
- en: Questions
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Which of the `map`, `filter`, and `reduce` functions are built-in Python functions?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: What are standard decorators?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Would you prefer a generator comprehension or a list comprehension for a large
    dataset?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: What is a DataFrame in the context of the pandas library?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: What is the purpose of the `inplace` argument in pandas' library methods?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Further reading
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '*Mastering Python Design Patterns*, by Sakis Kasampalis'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*Python for Data Analysis*, by Wes McKinney'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*Hands-On Data Analysis with Pandas*, *Second Edition*, by Stefanie Molin'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*The official Pandas documentation*, which is available at [https://pandas.pydata.org/docs/](https://pandas.pydata.org/docs/)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Answers
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The `map` and the `filter` functions are built-in.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Standard decorators are the ones without any arguments.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The generator comprehension is preferred in this case. It is memory efficient
    as the values are generated one by one.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The DataFrame is a representation of tabular data, such as a spreadsheet, and
    is a commonly used object for data analysis using the pandas library.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: When the `inplace` argument in pandas' library methods is set to `True`, the
    result of the operation is saved to the same DataFrame object on which the operation
    is applied.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
