- en: '9'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Launch Files – Starting All Your Nodes at Once
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: At this point, you know how to write nodes, how to make them communicate with
    topics, services, and actions, and how to make them more dynamic with parameters.
  prefs: []
  type: TYPE_NORMAL
- en: In this last chapter of *Part 2*, we will bring everything together and go one
    step further toward making your application more scalable. Here, we will talk
    about launch files, which allow you to start all your nodes and parameters at
    once.
  prefs: []
  type: TYPE_NORMAL
- en: To start with launch files, it’s important that you’re comfortable with the
    concepts seen in the previous chapters. As a starting point, we will use the code
    inside the **ch8** folder from the book’s GitHub repository ([https://github.com/PacktPublishing/ROS-2-from-Scratch](https://github.com/PacktPublishing/ROS-2-from-Scratch)).
    You can find the final code for launch files in the **ch9** folder.
  prefs: []
  type: TYPE_NORMAL
- en: First, as always, I will use a real-life example to explain why you need launch
    files and what they are exactly. You will then dive into the code and create your
    own launch file with XML and Python (we will discuss which language is more appropriate).
    You will also experiment with extra configurations to fully customize your nodes
    inside launch files, and you will practice more with a final challenge.
  prefs: []
  type: TYPE_NORMAL
- en: By the end of this chapter, you will be able to properly scale your ROS 2 applications
    and know how to use or modify existing launch files. Almost every ROS 2 application
    or stack contains one or several launch files. Being comfortable with them is
    key to becoming a great ROS developer.
  prefs: []
  type: TYPE_NORMAL
- en: 'In this chapter, we will cover the following topics:'
  prefs: []
  type: TYPE_NORMAL
- en: What is a ROS 2 launch file?
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Creating and installing an XML launch file
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Creating a Python launch file – XML or Python for launch files?
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Configuring nodes inside a launch file
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Launch file challenge
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: What is a ROS 2 launch file?
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: After everything you’ve learned already, understanding the concept of launch
    files will not be very difficult.
  prefs: []
  type: TYPE_NORMAL
- en: You have experimented a bit with launch files in [*Chapter 3*](B22403_03.xhtml#_idTextAnchor092).
    We will now, as usual, start from scratch and see what a launch file is with an
    example. First, we’ll look at why we need launch files.
  prefs: []
  type: TYPE_NORMAL
- en: Why launch files?
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: As your ROS 2 application starts to grow, so does the number of nodes and parameters.
    For example, a ROS stack I developed for a robotic arm had more than 15 nodes
    and 200 parameters. Imagine opening 15 terminals and starting all the nodes one
    by one with all the correct values for parameters. This would quickly become a
    nightmare.
  prefs: []
  type: TYPE_NORMAL
- en: 'For this explanation, let’s assume we have the following nodes in our application:'
  prefs: []
  type: TYPE_NORMAL
- en: Three camera nodes with different settings
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Two LED panel nodes with varying numbers of LEDs
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: One battery node
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Another node with more parameters
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Here is what your application would look like:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 9.1 – ROS 2 application with seven nodes and sixteen parameters](img/B22403_09_1.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 9.1 – ROS 2 application with seven nodes and sixteen parameters
  prefs: []
  type: TYPE_NORMAL
- en: To start all those nodes, you will need to open seven terminals and start the
    nodes one by one. For each node, you will also need to provide all the required
    parameters’ values (with what you’ve seen in the previous chapter, you can use
    YAML param files to make this easier). Not only is this not scalable, but it will
    make your development process much slower and frustrating. With so many terminals,
    it’s easy to make mistakes or to forget which terminal is doing what.
  prefs: []
  type: TYPE_NORMAL
- en: A solution you could think of is to create a script (a **bash** script, for
    example) to start all **ros2 run** commands from one file. That way, you could
    run your application from just one terminal. This would reduce development time
    and allow your application to scale.
  prefs: []
  type: TYPE_NORMAL
- en: Well, this is exactly what launch files are made for. There’s no need to write
    your own script; all you need to do is create a launch file and follow a few syntax
    rules. Launch files can be installed within your ROS 2 application. Let’s look
    at an example in the next section.
  prefs: []
  type: TYPE_NORMAL
- en: Example of a launch file with seven nodes
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'If we continue with our example, here is how your nodes would be organized:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 9.2 – Launch file with all nodes and parameters](img/B22403_09_2.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 9.2 – Launch file with all nodes and parameters
  prefs: []
  type: TYPE_NORMAL
- en: Inside one file, you start all the nodes and provide the values you want for
    each parameter. This file can be written with XML, YAML, or Python—we will see
    how to do that in a moment. Then, once the launch file is written, you will install
    it (**colcon build**) and run it with the **ros2 launch** command-line tool.
  prefs: []
  type: TYPE_NORMAL
- en: It’s not uncommon to have a few dozen nodes and a few hundred parameters inside
    one application. Without launch files, it would be impossible to quickly start
    the application, and you would spend most of your time debugging trivial things.
  prefs: []
  type: TYPE_NORMAL
- en: Launch files allow you to customize and scale your application easily. There
    is not much more to say; the concept is fairly straightforward. Most of the work
    is about learning how to implement one and knowing the features to customize your
    nodes to make them more dynamic. This is what we will dive into right now.
  prefs: []
  type: TYPE_NORMAL
- en: Creating and installing an XML launch file
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: You will now create your first launch file. We will start with XML. Later in
    this chapter, we will also write Python launch files and compare the two languages,
    but let’s keep things simple to get started.
  prefs: []
  type: TYPE_NORMAL
- en: To properly create, install, and start a launch file, you need to do a bit of
    setup. In this section, we will follow all the necessary setup steps with a minimal
    launch file.
  prefs: []
  type: TYPE_NORMAL
- en: What we want to do here is to start the number application (**number_publisher**
    and **number_counter** nodes) from one terminal, with just one command line. Let’s
    get started.
  prefs: []
  type: TYPE_NORMAL
- en: Setting up a package for launch files
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Where should you put your launch files? You could theoretically create a launch
    file in any existing package.
  prefs: []
  type: TYPE_NORMAL
- en: However, this method can quickly lead to a dependency mess between packages.
    If package A requires package B, and you create a launch file in package B to
    start nodes from both packages, then you have created what’s called a *dependency
    loop*. Package A depends on package B, and package B depends on package A. This
    is a very bad way to start a ROS application.
  prefs: []
  type: TYPE_NORMAL
- en: As a best practice, we will create a package dedicated to launch files. We will
    not modify any existing package; instead, we will create a completely independent
    one.
  prefs: []
  type: TYPE_NORMAL
- en: First, let’s choose a name for this package. We will follow a common naming
    convention. We start with the name of the robot or application, followed by the
    **_bringup** suffix. As we don’t have a robot here, we will call this package
    **my_robot_bringup**. If your robot were named *abc*, you would create an **abc_bringup**
    package.
  prefs: []
  type: TYPE_NORMAL
- en: 'Navigate to the **src** directory in your ROS 2 workspace and create this package.
    It will not contain any Python or C++ nodes. For the build type, you can choose
    **ament_cmake** (you could even omit the build type, as **ament_cmake** is the
    default anyway):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: Alternatively, you could just run **$ ros2 pkg** **create my_robot_bringup**.
  prefs: []
  type: TYPE_NORMAL
- en: 'Once the package is created, we can remove directories that we don’t need:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: 'Then, we create a **launch** directory. This is where we will put all our launch
    files for this application:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: 'Before we create a launch file, let’s finish the package configuration. Open
    the **CMakeLists.txt** file and add these lines:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: This will install the **launch** directory when you build your package with
    **colcon build**.
  prefs: []
  type: TYPE_NORMAL
- en: Now, the package is correctly configured. You only need to do those steps once
    for each ROS 2 application. Then, to add a launch file, you just have to create
    a new file inside the **launch** folder. Let’s do that.
  prefs: []
  type: TYPE_NORMAL
- en: Writing an XML launch file
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Navigate to the **launch** folder you created inside the **my_robot_bringup**
    package. To create a launch file, you will first choose a name and then use the
    **.launch.xml** extension. Since we have named our application the *number app*,
    let’s create a new file named **number_app.launch.xml**:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: Open the file, and let’s start to write the content for the launch file.
  prefs: []
  type: TYPE_NORMAL
- en: 'First, you will need to open and close a **<launch>** tag. Everything you write
    will be between those two lines. This is the minimum code for an XML launch file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: Then, we want to start the **number_publisher** and **number_counter** nodes.
  prefs: []
  type: TYPE_NORMAL
- en: 'As a quick reminder, in the terminal, you would run this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: 'Here, I started one node from the Python package and the other one from the
    C++ package. The two arguments we need to provide for **ros2 run** are the package
    name and executable name. This is the same inside a launch file. To add a node,
    use a **<node>** tag with the **pkg** and **exec** arguments:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: With this, we start the same two nodes from the launch file. As you can see,
    there’s nothing very complicated. Later on in this chapter, we will see how to
    configure the application with remappings, parameters, namespaces, and so on.
    For now, let’s focus on running this minimal launch file.
  prefs: []
  type: TYPE_NORMAL
- en: Installing and starting a launch file
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: You now have to install your new launch file before you can start using it.
  prefs: []
  type: TYPE_NORMAL
- en: 'As we are starting nodes from the **my_py_pkg** and **my_cpp_pkg** packages,
    we need to add the dependencies in the **package.xml** file of the **my_robot_bringup**
    package:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: Note
  prefs: []
  type: TYPE_NORMAL
- en: Previously, we only used a `<depend>` tag when specifying dependencies. In this
    case, there is nothing to build; we only need the dependency when executing the
    launch file. Thus, we use a weaker tag, `<exec_depend>`.
  prefs: []
  type: TYPE_NORMAL
- en: For each new package you use in your launch files, you will add a new **<exec_depend>**
    tag in the **package.xml** file.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, we can install the launch file. To do so, you just need to build your
    package:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: 'Then, source your environment, and use the **ros2 launch** command-line tool
    to start the launch file. The full command is **ros2 launch <****package_name>
    <launch_file_name>**:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: 'You will see the following logs:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: 'What’s happening here? Let’s take a closer look:'
  prefs: []
  type: TYPE_NORMAL
- en: A log file is created and the logging verbosity is set.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Each executable that you provided in the launch file is started as a new process.
    You can see the process name (for example, `number_publisher-1`) and the process
    ID (denoted as `pid`).
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Then, as all nodes are started in the same terminal, you will see all logs from
    all nodes.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: This example is quite simple, as we just start two executables with no additional
    configuration. Launch files will become quite handy when the number of nodes and
    settings gets bigger. Also, the **ros2 launch** command-line tool is very easy
    to use. There is not really much more than what we’ve seen here.
  prefs: []
  type: TYPE_NORMAL
- en: Now that you have completed the process to create, install, and start a launch
    file, let’s talk about Python launch files.
  prefs: []
  type: TYPE_NORMAL
- en: Creating a Python launch file – XML or Python for launch files?
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'There are actually three languages you can use to create launch files in ROS
    2: Python, XML, and YAML. I will not cover YAML launch files as they are not seldom
    used, and YAML doesn’t have any competitive advantage over XML for launch files.
    Here, we will be focusing on Python and XML.'
  prefs: []
  type: TYPE_NORMAL
- en: We will start this section by creating a Python launch file (the same application
    as before). Then, I will compare XML and Python launch files and give you some
    guidance on how to get the best out of them both.
  prefs: []
  type: TYPE_NORMAL
- en: Writing a Python launch file
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: As we already have a fully configured **my_robot_bringup** package for our application,
    there’s no need to do anything else. All we have to do is create a new file inside
    the **launch** directory.
  prefs: []
  type: TYPE_NORMAL
- en: 'For Python launch files, you will use the **.launch.py** extension. Create
    a new file named **number_app.launch.py**. Here is the code required to start
    the **number_publisher** and **number_counter** nodes:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: 'The first thing you will notice is that the code is much, much longer than
    the XML one. I will come back to this in a minute when I compare Python and XML.
    For now, let’s focus on the required steps to write a Python launch file:'
  prefs: []
  type: TYPE_NORMAL
- en: The launch file must include a `generate_launch_description()` function. Make
    sure you don’t make any typos.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: In this function, you will need to create and return a `LaunchDescription` object.
    You can get this from the `launch` module.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: To add a node in the launch file, you create a `Node` object (from `launch_ros.actions`)
    and specify the package and executable name. Then, you can add this object to
    the `LaunchDescription` object.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: That’s it for now, but there are more options that we will explore a bit later
    in this chapter.
  prefs: []
  type: TYPE_NORMAL
- en: Once you have written the launch file, make sure to add all required dependencies
    in the **package.xml** file of the **my_robot_bringup** package. As we already
    did that with the XML launch file (and we have the same dependencies here), we
    can skip this step.
  prefs: []
  type: TYPE_NORMAL
- en: 'Finally, to install this launch file, build the **my_robot_bringup** package
    again. Since we already wrote the necessary instructions in the **CMakeLists.txt**
    file, the launch file will be installed. All you need to do after that is to source
    your environment and start the launch file with **ros2 launch**:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: To create, install, and start a Python launch file, the process is the same
    as for an XML launch file. Only the code is different. Let’s now compare the two
    languages regarding their use in launch files.
  prefs: []
  type: TYPE_NORMAL
- en: XML versus Python for launch files
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: I have a strong bias toward simplicity, so, from seeing the previous code examples,
    you can already guess where I’m going to stand.
  prefs: []
  type: TYPE_NORMAL
- en: To answer the XML versus Python question, let’s first go back in time.
  prefs: []
  type: TYPE_NORMAL
- en: The issue with Python launch files
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: In ROS 1, the first version of ROS, XML was the only language used for launch
    files. Python was actually also available, but due to non-existent documentation,
    nobody knew about it.
  prefs: []
  type: TYPE_NORMAL
- en: At the beginning of ROS 2, the development team put a stronger emphasis on Python
    launch files and started to write the documentation only for Python, thus making
    it the default language for launch files. XML (and YAML) launch files were also
    supported, but again, due to non-existent documentation, nobody was using them.
  prefs: []
  type: TYPE_NORMAL
- en: I was initially enthusiastic about the idea of writing Python launch files,
    as this meant you could take advantage of the Python logic and syntax to make
    launch files much more dynamic and easier to write. That’s the theory, but in
    practice, I realized I didn’t see any programming logic in most of the launch
    files I found, and it was just another—more complex and difficult—way to write
    a description, which is basically why XML exists in the first place.
  prefs: []
  type: TYPE_NORMAL
- en: You can already see the added complexity in the two previous examples. To start
    two nodes, it takes four lines in XML and twenty lines in Python (I could optimize
    the code and make it less than fifteen lines, but that’s still a lot more). For
    the same number of nodes, you can expect Python launch files to be two to five
    times longer than the XML version.
  prefs: []
  type: TYPE_NORMAL
- en: Also, with more functionalities (parameters, arguments from the terminal, conditions,
    paths, and so on), you will have to use an increasing amount of Python imports
    that are hard to find and use. You will realize this as we see more examples of
    XML and Python launch files all along this book.
  prefs: []
  type: TYPE_NORMAL
- en: Fortunately, XML is coming back, as the official documentation is starting to
    include it as well as Python. More and more developers have started to use XML
    launch files again, which is a good thing because more online tutorials and open
    source code will include them.
  prefs: []
  type: TYPE_NORMAL
- en: How to combine XML and Python launch files in your application
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: XML launch files are much simpler and smaller to write than Python launch files.
    However, for some advanced use cases, Python will be the only choice, as it contains
    some functionalities that are not available for XML. This could be a problem because
    if you need just one Python functionality, it would mean that you’d need to write
    the entire launch file in Python.
  prefs: []
  type: TYPE_NORMAL
- en: Fortunately, there is a very easy way to solve that. As we will see in a minute,
    you can include any kind of launch file into any other launch file, be it Python,
    XML, or YAML.
  prefs: []
  type: TYPE_NORMAL
- en: So, if you absolutely need to use Python for a specific launch functionality,
    then go ahead and create a Python launch file for that. You can then include this
    launch file in your *main* XML launch file. You can also include any other existing
    Python launch file (from an already installed package) that contains the functionality
    you need. By doing this, you keep your code minimal and simple.
  prefs: []
  type: TYPE_NORMAL
- en: Now, what to do when you need to create a Python launch file for a specific
    use case? The syntax is really complicated, and there are too many imports for
    any functionality. It can quickly become a challenge.
  prefs: []
  type: TYPE_NORMAL
- en: What I myself do when I have to create a Python launch file is to try to find
    an existing launch file on GitHub that does what I want and tweak the code so
    that it works with my application. I gave up on trying to learn or even memorize
    the Python launch file syntax. I am not usually a fan of the “copy/paste from
    the internet” method, but I make an exception for Python launch files.
  prefs: []
  type: TYPE_NORMAL
- en: In the end, it’s a matter of choice for you. A correctly written XML, YAML,
    or Python launch file will do the exact same thing. As for YAML, it’s just another
    markup language, and I find XML easier to use for launch files. My recommendation
    is to use XML whenever possible. Use Python only if you have to and only for the
    functionalities that require Python. Then, include the Python launch file inside
    your XML one.
  prefs: []
  type: TYPE_NORMAL
- en: Following this process will make your life easier when developing ROS 2 applications.
  prefs: []
  type: TYPE_NORMAL
- en: Including a launch file inside another launch file
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Since I talked about including a Python launch file inside an XML launch file,
    let’s see how to do that. The syntax won’t be that complicated.
  prefs: []
  type: TYPE_NORMAL
- en: 'Make sure you add everything inside **<launch></launch>** tags. To include
    another launch file, use an **<include>** tag. Here is an example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: This line, with **find-pkg-share**, will find the path to the **number_app.launch.py**
    launch file inside the **my_robot_bringup** package. Then, the content of the
    launch file will be included. Even if you include a Python launch file inside
    an XML one, this will work.
  prefs: []
  type: TYPE_NORMAL
- en: You can reuse this line in any other XML launch file; just replace the package
    name and launch filename.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, if you wanted to do the opposite (which means including an XML launch
    file inside a Python launch file), here is what you would need to write:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: This code example illustrates what I was saying about the extra complexity brought
    by Python launch files. This complexity is not justified here, as it adds nothing
    compared to the XML file.
  prefs: []
  type: TYPE_NORMAL
- en: With those two code examples, you can now combine any XML and Python launch
    files.
  prefs: []
  type: TYPE_NORMAL
- en: Now that you have seen the process of creating a launch file in both XML and
    Python, let’s go a bit further and add some extra configuration for the nodes.
  prefs: []
  type: TYPE_NORMAL
- en: Configuring nodes inside a launch file
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: So far, we have just started two nodes, with zero extra configuration. When
    you start a node with **ros2 run**, as we have seen in the previous chapters in
    *Part 2*, you can rename it, rename topics/services/actions, add parameters, and
    so on.
  prefs: []
  type: TYPE_NORMAL
- en: In this section, you will learn how to do that inside a launch file. We will
    also introduce the concept of namespaces. All code examples will be in XML and
    Python.
  prefs: []
  type: TYPE_NORMAL
- en: Renaming nodes and communications
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'In an XML launch file, to rename a node, simply add a **name** argument in
    a **<****node>** tag:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: 'Changing the name for a topic/service/action is actually named *remapping*.
    To remap a communication, you have to use a **<remap>** tag, inside the **<****node>**
    tag:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: You can add as many **<remap>** tags as you want, each one in a new line.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs: []
  type: TYPE_NORMAL
- en: This is a quick XML reminder, but it can be useful if you’re not used to XML
    and can prevent lots of errors in the future. For one-line tags, you open the
    tag and end it with `/>` (for example, `<node />`). If you need to add a tag inside
    a tag, you then have to open the tag and close it later, like we did for `<launch>...</launch>`
    or `<node>...</node>`.
  prefs: []
  type: TYPE_NORMAL
- en: 'From this, let’s say we want to start two **number_publisher** nodes and one
    **number_counter** node. On top of that, we also want to remap the topic from
    **number** to **my_number**. Here is the full XML launch file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: We rename the two **number_publisher** nodes to avoid name conflicts. Then,
    we make sure to add the same **<remap>** tag for all nodes in which we use a publisher
    or subscriber on the **number** topic.
  prefs: []
  type: TYPE_NORMAL
- en: Additional tip
  prefs: []
  type: TYPE_NORMAL
- en: When you rename nodes and remap communications, use `rqt_graph` to verify that
    everything is working fine. With the graphical view, you can easily spot if a
    topic name is not the same on both sides of the communication.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here is the code to do the same thing with a Python launch file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: After renaming and remapping, let’s see how to add parameters to your nodes
    inside a launch file.
  prefs: []
  type: TYPE_NORMAL
- en: Parameters in a launch file
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Setting parameters’ values for a node in a launch file is pretty straightforward.
    We will first see how to provide the values directly, and then how to load a YAML
    file.
  prefs: []
  type: TYPE_NORMAL
- en: Setting parameters’ values directly
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'To add a parameter’s value for a node in an XML launch file, you first need
    to open and close the **<node></node>** tag. Inside this tag, you will add one
    **<param>** tag per parameter, with two arguments: **name** and **value**.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Here is an example, where we set the **number** and **publish_period** parameters
    for the **number_publisher** node:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: It will work the same as adding **-p <parameter>:=<value>** after the **ros2**
    **run** command.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, you can combine renaming, remapping, and setting parameters. Let’s add
    parameters to the previous example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: 'In a Python launch file, you need to add a list of dictionaries in the **Node**
    object:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: Setting each parameter’s value like this will work fine if you only have a handful
    of parameters. For bigger numbers, it’s more suitable to use a YAML file.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs: []
  type: TYPE_NORMAL
- en: Do not confuse YAML param files with YAML launch files. Launch files can be
    written in Python, XML, and YAML (though we didn’t use YAML in this book). Any
    of those launch files can include YAML param files, to add parameters’ values
    for the nodes in the launch file.
  prefs: []
  type: TYPE_NORMAL
- en: Installing and loading a YAML param file in a launch file
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'To provide parameters’ values using a YAML file, you will need to follow this
    process:'
  prefs: []
  type: TYPE_NORMAL
- en: Create a YAML file with the values.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Install this file inside the `_bringup` package.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Load the YAML file in your launch file (we will do that with XML and then Python).
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'For this example, we are going to reuse the **number_params.yaml** file that
    we created in [*Chapter 8*](B22403_08.xhtml#_idTextAnchor394). In this file, you
    can find the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: This will perfectly match the nodes that we launched in the previous example,
    as the names are exactly the same.
  prefs: []
  type: TYPE_NORMAL
- en: Now, what we have done so far is just provide the path to the file when starting
    a node with **ros2 run**. To use the YAML param file inside a launch file, we
    will need to install it in the package.
  prefs: []
  type: TYPE_NORMAL
- en: 'To do that, create a new directory inside the **my_robot_bringup** package.
    You could choose any name for that directory, but we will follow a common convention
    and name it **config**:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: Put the **number_params.yaml** file inside this **config** directory. This is
    where you will also put all other YAML param files for this application.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, to write instructions to install this directory (and all the YAML files
    inside), open the **CMakeLists.txt** file of the **my_robot_bringup** package
    and add one line:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: You only need to do this once. Any other file inside the **config** directory
    will be installed when running **colcon build** for that package.
  prefs: []
  type: TYPE_NORMAL
- en: 'Before we build the package, let’s modify the launch file so that we can use
    this YAML param file. The way to do this in XML is easy. You will add a **<param>**
    tag, but instead of **name** and **value**, you need to specify a **from** argument:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: As we’ve seen previously in this chapter, **$(find-pkg-share <package_name>)**
    will locate the installation folder for that package. Then, you only need to finish
    with the relative path to the file you want to retrieve.
  prefs: []
  type: TYPE_NORMAL
- en: To test this, first build your package. This will install the YAML param files
    and the launch files. Then, source your environment and start the XML launch file.
  prefs: []
  type: TYPE_NORMAL
- en: 'That’s it for parameters. Let’s now see the Python version. In your launch
    file, add the following imports:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: 'Then, retrieve the YAML file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: 'Finally, load the configuration into the node:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: With this, you should be able to start any node you want with any number of
    parameters without having any scaling issues.
  prefs: []
  type: TYPE_NORMAL
- en: Let’s now finish this section with namespaces. I have briefly mentioned them
    a few times during this book. As you now have a better understanding of how names
    work in ROS 2, and as namespaces are especially useful in launch files, this is
    a good time to start with them.
  prefs: []
  type: TYPE_NORMAL
- en: Namespaces
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Namespaces are quite common in programming, and you are probably already familiar
    with them. With a namespace, you can group some functionalities (variables, functions,
    and so on) inside one *container* that has a name. This can help you better organize
    your code and avoid name conflicts.
  prefs: []
  type: TYPE_NORMAL
- en: In ROS, namespaces are also quite practical. Let’s say you want to start an
    application that contains two identical robots, but you want to be able to control
    each robot independently. Instead of renaming the nodes, topics, services, and
    actions for each robot, you could just add a namespace.
  prefs: []
  type: TYPE_NORMAL
- en: If you have a node named **robot_controller** and a topic named **cmd_vel**,
    then those can become **/robot1/robot_controller** and **/robot1/cmd_vel** for
    the first robot. For the second robot, this would be **/robot2/robot_controller**
    and **/robot2/cmd_vel**. This way, the two robots are still running on the same
    application, but you make sure that the velocity command for each robot is independent.
  prefs: []
  type: TYPE_NORMAL
- en: As you make progress with ROS 2 and learn new stacks and plugins, you will encounter
    namespaces everywhere. Let’s now see how to work with namespaces. As we have not
    done this previously, we will first use namespaces with the **ros2 run** command
    line, and then add them in our launch file.
  prefs: []
  type: TYPE_NORMAL
- en: Starting a node inside a namespace
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Adding a namespace to a node is quite straightforward.
  prefs: []
  type: TYPE_NORMAL
- en: First of all, after the **ros2 run <package> <executable>** command, you add
    **--ros-args** once. Then, to specify a namespace, you will write **-r __ns:=<namespace>**.
    The **-r** option (or **--remap**) is the same as the one for renaming a node,
    only instead of **__node**, you use **__ns** here.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s start our **number_publisher** node inside a **/****abc** namespace:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: 'After this, you can check what the node and topic names are:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: As you can see, **/abc** was added to the node name but also to the topic name—if
    you have services and actions, the namespace will be equally applied.
  prefs: []
  type: TYPE_NORMAL
- en: Important note
  prefs: []
  type: TYPE_NORMAL
- en: The namespace was successfully applied because the topic name defined in the
    code is `number` without any leading slash. If you had written `/number` in the
    code, then the topic would have been considered to be in the *global* scope or
    namespace. Adding a namespace to the node will change the node name but not the
    topic name. Thus, pay attention to this when defining communication (topic, service,
    action) names in your code.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, as the topic name is **/abc/number**, if we want to start the **number_counter**
    node and receive some data, we need to either rename the topic or also add a namespace
    to the node:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: 'When adding namespaces, name mismatches can become a frequent issue. One of
    the best ways to verify that things are working is to run **rqt_graph**:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 9.3 – Double-checking namespaces with rqt_graph](img/B22403_09_3.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 9.3 – Double-checking namespaces with rqt_graph
  prefs: []
  type: TYPE_NORMAL
- en: With this, you can see that both nodes are publishing or subscribing to the
    **/****abc/number** topic.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs: []
  type: TYPE_NORMAL
- en: 'You can combine any type of renaming. For example, you could both add a namespace
    and rename the node: `$ ros2 run my_py_pkg number_publisher --ros-args -r __ns:=/abc
    -``r __node:=num_pub`.'
  prefs: []
  type: TYPE_NORMAL
- en: Now that you know how to provide a namespace for a node at runtime, let’s see
    how to do this inside a launch file.
  prefs: []
  type: TYPE_NORMAL
- en: Specifying a namespace in a launch file
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'To add a namespace to a node in an XML launch file, you just have to add a
    **namespace** argument inside the **<node>** tag. Let’s continue with our previous
    example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: 'For Python, the syntax is also quite easy; here too, you just need to add a
    **namespace** argument inside the **Node** object:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs: []
  type: TYPE_PRE
- en: 'If you add a namespace to this node, you will also add the same namespace to
    nodes that are directly communicating with it:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs: []
  type: TYPE_PRE
- en: 'Adding namespaces to nodes in a launch file is quite straightforward. However,
    there is one important thing you need to pay attention to. If you are using YAML
    param files, you also need to specify the namespace in the YAML file. Open the
    **number_params.yaml** file and add the namespace to the node name:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs: []
  type: TYPE_PRE
- en: If you don’t do this, the parameters will be applied to the **/num_pub2** node,
    which doesn’t exist, since it’s named **/abc/num_pub2**. This can be a common
    source of errors, so make sure you double-check param files when adding namespaces.
  prefs: []
  type: TYPE_NORMAL
- en: After all those modifications, make sure to build the **my_robot_bringup** package
    again and source the environment before you start any launch file.
  prefs: []
  type: TYPE_NORMAL
- en: You have now seen a few ways to configure your nodes inside a launch file. With
    this base knowledge, you can already scale your application a lot. Let’s finish
    this chapter with a new challenge so that you can practice more on your own.
  prefs: []
  type: TYPE_NORMAL
- en: Launch file challenge
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this challenge, you will practice more with launch files, YAML param files,
    remappings, and namespaces. This will be the conclusion of *Part 2*. To complete
    this challenge, you can decide to write the launch file in XML, Python, or both.
  prefs: []
  type: TYPE_NORMAL
- en: Challenge
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: What we want to do here is to start two **turtlesim** windows, each one with
    one turtle. Then, for each turtle, we run a **turtle_controller** node (the one
    we have been developing throughout the previous chapters).
  prefs: []
  type: TYPE_NORMAL
- en: 'The goal is to have each **turtle_controller** node controlling only one turtle.
    This is what the result should look like:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 9.4 – Two  different turtles with two independent controllers](img/B22403_09_4.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 9.4 – Two different turtles with two independent controllers
  prefs: []
  type: TYPE_NORMAL
- en: 'For each turtle, we will apply different settings (parameters):'
  prefs: []
  type: TYPE_NORMAL
- en: 'First `turtlesim` window:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`128` for the RGB value)'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: 'First controller:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`1.5`'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Second `turtlesim` window:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`128` for the RGB value)'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Second controller:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`0.5`'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Here are the steps you can take:'
  prefs: []
  type: TYPE_NORMAL
- en: Create a `turtle_params.yaml` file with the parameters for each node. Install
    this in the `my_robot_bringup` package.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Create a new launch file and start the four nodes. Load the parameters from
    the YAML param file. Put the different nodes into appropriate namespaces (to keep
    it simple, use `t1` and `t2` for `turtle1` and `turtle2`, respectively).
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Build, source, and start the launch file. You will see that some topics and
    services are not matching, and thus you will know what remappings you need to
    add.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: To make it easier, start with just one pair of nodes (**turtlesim** and **turtle_controller**),
    and then add another pair when it’s working.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here is an important point for this challenge: we will not modify any of the
    existing code—even if it would make things easier. The goal is to take the nodes
    exactly as they are (use the code from the **ch8** folder in the repo) and make
    things work using appropriate namespaces and remappings in the launch file and
    YAML param file.'
  prefs: []
  type: TYPE_NORMAL
- en: Solution
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Create a new file named **turtle_params.yaml**, inside the **config** directory
    of the **my_robot_bringup** package. As a base, you can take the one that we did
    in the parameter challenge for [*Chapter 8*](B22403_08.xhtml#_idTextAnchor394).
  prefs: []
  type: TYPE_NORMAL
- en: In this file, we will add parameters for all four nodes. Before we do this,
    we need to know exactly what will be the name for each node, including the namespaces.
  prefs: []
  type: TYPE_NORMAL
- en: 'With the **t1** and **t2** namespaces, if we just add a namespace and we don’t
    rename the nodes, we will then have these names:'
  prefs: []
  type: TYPE_NORMAL
- en: '`/``t1/turtlesim`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`/``t2/turtlesim`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`/``t1/turtle_controller`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`/``t2/turtle_controller`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'After making this choice, we can write the YAML param file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE37]'
  prefs: []
  type: TYPE_PRE
- en: This contains all the configurations given in the challenge. Now, create a new
    launch file (for example, **turtlesim_control.launch.xml**) inside the **launch**
    directory.
  prefs: []
  type: TYPE_NORMAL
- en: 'In this launch file, let’s start with something simple. We want to try to run
    one **turtlesim** node and one **turtle_controller** node, using the **t1** namespace:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE38]'
  prefs: []
  type: TYPE_PRE
- en: 'As we are starting nodes from the **turtlesim** and **turtle_controller** packages,
    we also add two new **<exec_depend>** tags in the **package.xml** file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE39]'
  prefs: []
  type: TYPE_PRE
- en: Now, if you launch this (make sure to build and source first), you will see
    the **turtlesim** node, but the turtle won’t move. Why is that?
  prefs: []
  type: TYPE_NORMAL
- en: 'If you look at the topic list, you will find these two topics:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE40]'
  prefs: []
  type: TYPE_PRE
- en: With **rqt_graph**, you can also see that the **turtlesim** node is subscribing
    to **/t1/turtle1/cmd_vel**, but the **turtle_controller** node is publishing on
    **/turtle1/cmd_vel**. Why did the namespace work for the node name but not for
    the topic name?
  prefs: []
  type: TYPE_NORMAL
- en: This is because we wrote **/turtle1/cmd_vel** in the code, and not **turtle1/cmd_vel**.
    The fact that we added a leading slash makes the namespace the *global* namespace.
    Thus, if you try to add a namespace to that, it will not be taken into account.
  prefs: []
  type: TYPE_NORMAL
- en: 'We have two options here: either we modify the code (we simply need to remove
    this leading slash) or we adapt the launch file to make this work. As specified
    in the challenge instructions, we are not going to modify the code. The reason
    why I’m adding this constraint is because, in real life, you won’t necessarily
    be able to modify the code of the nodes you run. Thus, knowing how to solve a
    name mismatch without touching the code is a great skill to have.'
  prefs: []
  type: TYPE_NORMAL
- en: 'So, if you look at the topic and service names (we don’t use actions here),
    you will see that we have two topics and one service to modify. Let’s add some
    **<remap>** tags inside the node:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE41]'
  prefs: []
  type: TYPE_PRE
- en: 'You can now start the launch file, and you will see the turtle moving. Now
    that we have this working, adding a second pair of nodes is easy. We basically
    need to copy/paste the two nodes and replace **t1** with **t2**:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE42]'
  prefs: []
  type: TYPE_PRE
- en: The challenge is now complete. If you start this launch file, you will see two
    **turtlesim** windows, each one containing a turtle that moves at a different
    speed and using different pen colors.
  prefs: []
  type: TYPE_NORMAL
- en: You can find the complete code and package organization in the book’s GitHub
    repository (including the Python launch file).
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, you worked on ROS 2 launch files. Launch files allow you to
    properly scale your application with multiple nodes, parameters, and sets of configuration.
  prefs: []
  type: TYPE_NORMAL
- en: You can write a launch file in Python, XML, or YAML. Here, you discovered the
    Python and XML syntax and saw that XML is probably the best choice by default.
    The syntax is much easier, and the code is much shorter. If you ever need to combine
    XML and Python launch files, you can do so by including a launch file in another
    one.
  prefs: []
  type: TYPE_NORMAL
- en: The best practice is to set up a dedicated package for launch files and YAML
    files. You can name the package using the **_bringup** suffix. Launch files will
    be installed in a **launch** folder, and YAML param files in a **config** folder.
  prefs: []
  type: TYPE_NORMAL
- en: 'If you correctly understand how to start nodes with the **ros2 run command**,
    then doing so in a launch file is pretty straightforward: you just need to provide
    the package and executable name for each node. The only thing to learn is the
    XML or Python syntax.'
  prefs: []
  type: TYPE_NORMAL
- en: 'In a launch file, you can also configure your nodes in multiple ways:'
  prefs: []
  type: TYPE_NORMAL
- en: Renaming the node and/or adding a namespace
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Remapping topics, services, and actions
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Adding parameters, individually or from a YAML param file
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: This is what we have seen so far, but there are many other ways to configure
    your nodes that you will discover throughout your ROS 2 learning journey.
  prefs: []
  type: TYPE_NORMAL
- en: '*Part 2* of this book is now finished. You have discovered all the core concepts
    that will allow you to write complete ROS 2 applications and join existing ROS
    2 projects. You should now be able to interact with any ROS 2 node, write code
    to communicate with it, and scale your application with parameters and launch
    files.'
  prefs: []
  type: TYPE_NORMAL
- en: Now, this part was heavily focused on programming (Python and C++), which is
    incredibly important, but ROS 2 is more than just that. In *Part 3*, we will dive
    into some additional concepts and tools (**TransForms** (**TFs**), **Unified Robot
    Description Format** (**URDF**), **Gazebo**) so that you can design a custom application
    for a robot, including a 3D simulation. This, combined with the programming we
    did in *Part 2*, will be the backbone of any ROS 2 application you work on.
  prefs: []
  type: TYPE_NORMAL
