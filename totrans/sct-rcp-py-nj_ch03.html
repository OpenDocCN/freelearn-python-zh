<?xml version="1.0" encoding="utf-8"?>
<!DOCTYPE html>

<html xmlns="http://www.w3.org/1999/xhtml" xmlns:epub="http://www.idpf.org/2007/ops" xmlns:m="http://www.w3.org/1998/Math/MathML" xmlns:pls="http://www.w3.org/2005/01/pronunciation-lexicon" xmlns:ssml="http://www.w3.org/2001/10/synthesis">
<head>
  <meta charset="UTF-8"/>
  <title>Working with Decorators</title>
  <link type="text/css" rel="stylesheet" media="all" href="style.css"/>
  <link type="text/css" rel="stylesheet" media="all" href="core.css"/>
</head>
<body>
  <div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">Working with Decorators</h1>
                </header>
            
            <article>
                
<p class="mce-root">In this chapter, we will talk about decorators for functions and classes, which allow the decorating of functions and classes with more details. In this chapter, we will cover the following:</p>
<ul>
<li>Reviewing functions</li>
<li>Introducing decorators</li>
<li>Using function decorators</li>
<li>Using class decorators</li>
<li>Examples of decorators</li>
<li>Using the decorators module</li>
</ul>


            </article>

            
        </section>
    </div>


  <div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">Introduction</h1>
                </header>
            
            <article>
                
<p>Decorators in Python are any callable objects that can modify a function or class. They allow some additional functionality similar to other languages, such as declaring a method as a&#160;<span>class&#160;</span>or&#160;<span>static&#160;</span>method.</p>
<p>A class method is one that is called on a class rather than a particular instance. A static method is similar, but would be applied to all instances of a class, not just a specific instance. An instance method is the traditional method when dealing with OOP in Python.&#160;</p>
<p>When a call to a function or a class is made, it is passed to a decorator and the decorator returns a modified function/class. These modified objects generally include calls to the originally called object.</p>
<div class="packt_infobox">In this chapter, decorators can be used with functions and methods, but usually only the term <em>functions</em> will be used for brevity. <em>Method</em> will be used when explicitly talking about classes.</div>


            </article>

            
        </section>
    </div>


  <div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">Reviewing functions</h1>
                </header>
            
            <article>
                
<p>Because it is important to understand how functions work when we deal with decorators, we'll take a quick look at them. First, we need to remember that everything in Python is an object, including functions.</p>
<p>Functions are created in Python by using the&#160;<kbd>def</kbd> keyword and naming the function; input arguments are optional. Following is a basic function for reference:</p>
<pre>def func_foo():<br/>    pass</pre>


            </article>

            
        </section>
    </div>


  <div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">How to do it...</h1>
                </header>
            
            <article>
                
<ol>
<li>Functions can have multiple names, that is, in addition to the function name itself, the function can be assigned to one or more variables. Each name has the same capabilities of the underlying function:</li>
</ol>
<pre><strong>      &gt;&gt;&gt; def first_func(val):</strong><br/><strong>      ...     print(val)</strong><br/><strong>      ...</strong><br/><strong>      &gt;&gt;&gt; new_name = first_func</strong><br/><strong>      &gt;&gt;&gt; first_func("Spam!")</strong><br/><strong>      Spam!</strong><br/><strong>      &gt;&gt;&gt; new_name("Spam too!")</strong><br/><strong>      Spam too!</strong></pre>
<ol start="2">
<li>Functions can be used as arguments for other functions. Some Python built-in functions, such as&#160;<kbd>map</kbd> and&#160;<kbd>filter</kbd>, use this feature to do their jobs:</li>
</ol>
<pre><strong>      &gt;&gt;&gt; def mult(x, y):</strong><br/><strong>      ...     return x * y</strong><br/><strong>      ... </strong><br/><strong>      &gt;&gt;&gt; def div(x, y):</strong><br/><strong>      ...     return x / y</strong><br/><strong>      ... </strong><br/><strong>      &gt;&gt;&gt; def math(func, x, y):</strong><br/><strong>      ...     result = func(x, y)</strong><br/><strong>      ...     return result</strong><br/><strong>      ... </strong><br/><strong>      &gt;&gt;&gt; math(mult, 4, 2)</strong><br/><strong>      8</strong><br/><strong>      &gt;&gt;&gt; math(div, 4, 2)</strong><br/><strong>      2.0</strong></pre>
<ol start="3">
<li>Functions can be nested within other functions:</li>
</ol>
<pre><strong>      &gt;&gt;&gt; def person(name):</strong><br/><strong>      ...     def greeting():</strong><br/><strong>      ...         return "Would you like some spam, "</strong><br/><strong>      ...     greet = greeting() + name + "?"</strong><br/><strong>      ...     return greet</strong><br/><strong>      ... </strong><br/><strong>      &gt;&gt;&gt; print(person("Sir Galahad"))</strong><br/><strong>      Would you like some spam, Sir Galahad?</strong></pre>
<ol start="4">
<li>Functions can be used as parameters to other functions. This is because function parameters are actually references to an object, and, since functions are objects, functions (actually references to the function object) can be used as parameters:</li>
</ol>
<pre><strong>      &gt;&gt;&gt; def greeting(name):</strong><br/><strong>      ...     return "'allo " + name</strong><br/><strong>      ...</strong><br/><strong>      &gt;&gt;&gt; def call_me(func):</strong><br/><strong>      ...     nickname = "mate"</strong><br/><strong>      ...     return func(nickname)</strong><br/><strong>      ... </strong><br/><strong>      &gt;&gt;&gt; print(call_me(greeting))</strong><br/><strong>      'allo mate</strong></pre>
<ol start="5">
<li>Functions can return functions. Again, this is because the return value of a function is a reference to an object:</li>
</ol>
<pre><strong>      &gt;&gt;&gt; def func_creator():</strong><br/><strong>      ...     def return_saying():</strong><br/><strong>      ...         return "Blessed are the cheese makers"</strong><br/><strong>      ...     return return_saying</strong><br/><strong>      ... </strong><br/><strong>      &gt;&gt;&gt; statement = func_creator()</strong><br/><strong>      &gt;&gt;&gt; print(statement())</strong><br/><strong>      Blessed are the cheese makers</strong></pre>
<ol start="6">
<li>Nested functions have access to the scope of their parent functions; this is also called <strong>closure</strong>. It is important to recognize that this access is read-only; nested functions cannot write out or assign variables to the outer scope.</li>
</ol>
<p style="padding-left: 60px">In practice, this is no different than assigning arguments to function variables; the input argument is simply being passed to another, enclosed function rather than a variable:</p>
<pre><strong>      &gt;&gt;&gt; def func_creator2(name):</strong><br/><strong>      ...     def greeting():</strong><br/><strong>      ...         return "Welcome, " + name</strong><br/><strong>      ...     return greeting</strong><br/><strong>      ... </strong><br/><strong>      &gt;&gt;&gt; greet = func_creator2("Brian")</strong><br/><strong>      &gt;&gt;&gt; print(greet())</strong><br/><strong>      Welcome, Brian</strong></pre>


            </article>

            
        </section>
    </div>


  <div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">How it works...</h1>
                </header>
            
            <article>
                
<p>Functions and their object-oriented cousins, methods, are the workhorses of many programming languages. They allow code reuse, as a function can be called multiple times from different locations within the code. They can even be called from different programs, if the language supports it, for example, Python imports.</p>
<p>Functions also allow abstraction of work. At their most basic level, a function is similar to a black box; all a developer needs to know is what data to feed a function and how the function deals with that data, that is, whether a value is returned. The actual algorithm within the function doesn't necessarily need to be known to use it, as long as the results are consistent.</p>
<p>It is possible to write a program without functions, but it will require the entire program to be processed serially. Any functionality that needs to be repeated must be copy and pasted every time. This is why even the earliest, high-level programming languages included subroutines, which allowed the developer to jump out of the main logic flow to process some data, and then return back to the main flow. Prior to this, subroutines had to be implemented using a special call sequence to store the return address to the main code.</p>


            </article>

            
        </section>
    </div>


  <div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">Introducing decorators</h1>
                </header>
            
            <article>
                
<p>With that out of the way, we can talk about decorators. Decorators wrap a function in another function that modifies the original in some way, such as adding functionality, modifying arguments or results, and so on. Decorators are identified by the&#160;<kbd>@foo</kbd> nomenclature on the line above a function/method definition.</p>
<p><span>The workhorse of a decorator function is defining the&#160;</span><kbd>wrapper</kbd> <span>function within it. In this case, the&#160;</span><kbd>wrapper</kbd> <span>function is a nested function that actually does the modification work, though the decorator name is what is called.</span></p>


            </article>

            
        </section>
    </div>


  <div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">How to do it...</h1>
                </header>
            
            <article>
                
<ol>
<li>Define the decorator function:</li>
</ol>
<pre>        def fun_decorator(some_funct):<br/>            def wrapper():<br/>                print("Here is the decorator, doing its thing")<br/>                for i in range(10):<br/>                    print(i)<br/>                print("The decorator is done, returning to the <br/>                       originally scheduled function")<br/>                print(some_funct())<br/>            return wrapper</pre>
<ol start="2">
<li>Define the main function:</li>
</ol>
<pre>        def a_funct():<br/>            text = "I am the original function call"<br/>            return text</pre>
<ol start="3">
<li>Use the main function as a variable and assign the decorator as its value:</li>
</ol>
<pre>        a_funct = fun_decorator(a_funct)</pre>
<ol start="4">
<li>Call the main function:</li>
</ol>
<pre>        a_funct()</pre>
<ol start="5">
<li>The whole program looks like <kbd>decorator.py</kbd>:</li>
</ol>
<pre>        def fun_decorator(some_funct):<br/>            def wrapper():<br/>                print("Here is the decorator, doing its thing")<br/>                for i in range(10):<br/>                    print(i)<br/>                print("The decorator is done, returning to the <br/>                       originally scheduled function")<br/>                print(some_funct())<br/>            return wrapper<br/><br/>        def a_funct():<br/>            text = "I am the original function call"<br/>            return text<br/><br/>        a_funct = fun_decorator(a_funct)<br/>        a_funct()</pre>
<ol start="6">
<li>When ran, the code prints the following:</li>
</ol>
<div class="CDPAlignCenter CDPAlign"><img src="images/28244834-ff32-42b3-a63e-d748d793b201.png" style="width:40.42em;height:16.83em;"/></div>
<ol start="7">
<li>To eliminate the line <kbd>a_funct = fun_decorator(a_funct)</kbd>, we can use syntactic sugar (the <kbd>@</kbd>&#160;symbol) to annotate that the main function is modified by a decorator, as shown below in <kbd>decorator.py</kbd>:</li>
</ol>
<pre>        def fun_decorator(some_funct):<br/>            def wrapper():<br/>                print("Here is the decorator, doing its thing")<br/>                for i in range(10):<br/>                    print(i)<br/>                print("The decorator is done, returning to the <br/>                       originally scheduled function")<br/>                print(some_funct())<br/>            return wrapper<br/><br/>        @fun_decorator<br/>        def a_funct():<br/>            text = "I am a decorated function call"<br/>            return text<br/><br/>        a_funct()</pre>
<ol start="8">
<li>The decorated function acts the same as when it was a variable:</li>
</ol>
<div class="CDPAlignCenter CDPAlign"><img src="images/c7d3c982-f296-40f6-9e8a-0ced39075383.png" style="width:39.25em;height:16.75em;"/></div>


            </article>

            
        </section>
    </div>


  <div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">How it works...</h1>
                </header>
            
            <article>
                
<p>When a function with a decorator is called, the call is caught by the decorator function, which then does its work. After it is complete, it hands off to the original function, which completes the job. Essentially, everything we discussed about preceding functions comes into play when working with decorators.</p>
<p><strong>Syntactic sugar</strong> is special syntax within a programming language, designed to make life easier for a programmer by making code easier to read or write. Syntactic sugar expressions are identified by seeing if the code functionality is lost if the sugar goes away. In the case of decorators, we've already demonstrated that decorator functionality can be maintained without the <kbd>@</kbd>&#160;decorator; we just have to manually assign the decorator function to the main function variable.</p>
<p>Decorated functions can be made permanent by using the first method, that is, if a decorated function is assigned to a variable, that variable can be used to call the decorated function every time, rather than the original function.</p>
<p>Methods can use decorators as well as functions. While any decorator can be made, there are a couple of standard decorators available to modify the methods for use with classes as well as instances. The following bullet points summarize the different methods covered:</p>
<ul>
<li>Instance methods are the normal-use methods when working with classes. They take an&#160;<kbd>object(self)</kbd><span>&#160;</span>call, where <kbd>self</kbd> identifies a particular instance to work with.</li>
</ul>
<ul>
<li>Static methods are more universal, being able to work with all instances of a class as well as the class itself.</li>
<li>Class methods operate on the class itself; instances are not affected.</li>
</ul>


            </article>

            
        </section>
    </div>


  <div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">Using function decorators</h1>
                </header>
            
            <article>
                
<p>Function decorators obviously apply to functions. The&#160;<kbd>@foo</kbd> decorator line is placed on the line prior to the function definition. The syntactic sugar takes one function and runs its results through another automatically; at the end of processing, the original function call's name is applied to the final result. To the system, it looks like the original function call provided the result directly. Below is a demonstration of what a decorator looks like:</p>
<pre>@foo_decorator<br/>def my_function():<br/>    pass</pre>
<p>When the Python interpreter gets to this code block,&#160;<kbd>my_function()</kbd> is processed and the result is passed to the function that&#160;<kbd>@foo_decorator</kbd> points to. The decorator function is processed and the result is substituted for the original&#160;<kbd>my_function()</kbd> results. In essence, the decorator hijacks the function call, modifying the original result and substituting the modification for the result the original function would have provided.</p>
<p>Decorator code modification can be in the form of management or augmentation of the original call. Once a function has done its work, the decorator takes over and does something to the original result, returning the modified code instead.</p>
<p>This concept is reiterated because it is the most important part of decorators; at face value, decorators look complicated and it can be difficult to figure out how code works when decorators are involved.</p>
<p>Decorators can obviously be applied to any function that relates to the decorators modification goals. It is therefore in the programmer's best interest to create decorators that are generic enough that they can be used by multiple functions; otherwise, you may as well just make the function do what the end result is, rather than waste time on a decorator that will be used only once.</p>


            </article>

            
        </section>
    </div>


  <div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">How to do it...</h1>
                </header>
            
            <article>
                
<p>This walk through shows how to create a decorator that can be used to check arguments passed to a function. This can be handled in a number of different ways, such as <kbd>if...else</kbd> checks, <kbd>assert</kbd> statements, and so on, but, by using a decorator, we can use this code on any function that operates the same way:</p>
<ol>
<li>First, we have to decide what the decorator will do. For this use case, the decorator function will look at arguments being passed to a function and check whether the values passed are integers.</li>
<li>Write the decorator function just as you would write any other function:</li>
</ol>
<pre>        def arg_check(func):<br/>            def wrapper(num):<br/>                if type(num) != int:<br/>                    raise TypeError("Argument is not an integer")<br/>                elif num &lt;= 0:<br/>                    raise ValueError("Argument is not positive")<br/>                else:<br/>                    return func(num)<br/>            return wrapper</pre>
<ol start="3">
<li>Write the function that will be decorated. In this case, we are simply going to calculate some measurements of a circle when the radius is provided:</li>
</ol>
<pre>        @arg_check<br/>        def circle_measures(radius):<br/>            circumference = 2 * pi * radius<br/>            area = pi * radius * radius<br/>            diameter = 2 * radius<br/>            return (diameter, circumference, area)</pre>
<ol start="4">
<li>Add the remainder of the code, such as importing libraries and printing results. The following is <kbd>arg_check.py</kbd>:</li>
</ol>
<pre>       from math import pi <br/><br/>       def arg_check(func):<br/>           def wrapper(num):<br/>               if type(num) != int:<br/>                   raise TypeError("Argument is not an integer")<br/>               elif num &lt;= 0:<br/>                   raise ValueError("Argument is not positive")<br/>               else:<br/>                   return func(num)<br/>           return wrapper<br/><br/>        @arg_check<br/>        def circle_measures(radius):<br/>            circumference = 2 * pi * radius<br/>            area = pi * radius * radius<br/>            diameter = 2 * radius<br/>            return (diameter, circumference, area)<br/><br/>        diameter, circumference, area = circle_measures(6)<br/>        print("The diameter is", diameter, "\nThe circumference is", <br/>              circumference, "\nThe area is", area)</pre>


            </article>

            
        </section>
    </div>


  <div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">How it works...</h1>
                </header>
            
            <article>
                
<p>When a value is provided as input to the function&#160;<kbd>circle_measures()</kbd>, the decorator&#160;<kbd>@arg_check</kbd> checks to see whether the value is an integer and if it is positive. If it meets the requirements, the function is allowed to finish and the results are printed, as shown in the following screenshot:</p>
<div class="CDPAlignCenter CDPAlign"><img src="images/497b5d31-9fa0-4c2b-a38c-afadbac2b7a1.png" style="width:38.83em;height:8.33em;"/></div>
<p>If the argument passed to the function is negative, then an exception is raised, as shown in the following screenshot:</p>
<div class="CDPAlignCenter CDPAlign"><img src="images/5d9aba7f-9d88-40ee-9c2f-958358921970.png" style="width:37.58em;height:10.33em;"/></div>
<p>If the argument passed in is not an integer, an alternate exception is raised, as shown in the following screenshot:</p>
<div class="CDPAlignCenter CDPAlign"><img src="images/ad548d61-40b3-4905-a798-af9af4111daf.png" style="width:35.33em;height:9.50em;"/></div>
<p class="mce-root">This code relies on the value passed to the function behind-the-scenes; there is no mechanism to allow user input. Accepting user input actually makes it slightly more complicated. The change is simple enough, simply adding the input call and passing the value to the&#160;<kbd>circle_measures()</kbd> call:</p>
<pre>r = input("Input radius: ")<br/>diameter, circumference, area = circle_measures(r)</pre>
<p class="mce-root">However, since the input is captured as a string, direct input to the function would always error out, as shown in the following screenshot:</p>
<div class="CDPAlignCenter CDPAlign"><img src="images/e7a7244b-f7f9-480f-a29e-641b6bd31577.png" style="width:38.25em;height:10.50em;"/></div>
<p>Casting the user input to a integer, that is,&#160;<kbd>diameter, circumference, area = circle_measures(int(r))</kbd>, at first glance, eliminates this problem, as the number will always be an integer. However, it just causes another problem if the value provided by the user doesn't actually convert to an integer, as shown in the following screenshot:</p>
<div class="CDPAlignCenter CDPAlign"><img src="images/730b69b3-eeec-4985-87f8-779d2ae6d7e3.png" style="width:36.83em;height:8.25em;"/></div>
<p>Obviously, with a little bit of work, all issues could be resolved, but this example shows a few things:</p>
<ul>
<li>It can be easier to make a program work when you don't have to account for all possible input values.</li>
<li>Decorators can actually make life easier, if some thought is put into how to write their wrapper function.</li>
<li>Effective testing of software is a critical piece of software development; testing for edge cases and potential out-of-bounds data input can reveal interesting things and prevent potential security issues.</li>
</ul>


            </article>

            
        </section>
    </div>


  <div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">Using class decorators</h1>
                </header>
            
            <article>
                
<p>Starting with Python 2.6, decorators have been made to work with classes. In this case, rather than just applying solely to functions, class decorators can be used on individual instances of classes or can be used on the class itself. They are frequently used to make a developer's logic intentions more obvious. They can also help minimize errors when it comes to calling methods or when dealing with objects.</p>


            </article>

            
        </section>
    </div>


  <div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">How to do it...</h1>
                </header>
            
            <article>
                
<ol>
<li>Class methods can be decorated as well. Instance methods are the most common form of methods, that is, functions in classes. Here is <kbd>cat_class.py</kbd> with a few methods to work with:</li>
</ol>
<pre style="color: black">        class Cat():<br/>            def __init__(self, breed, age):<br/>                """Initialization method to auto-populate an instance"""<br/><br/>                self.breed = breed<br/>                self.age = age<br/><br/>            def cat_age(self):<br/>                """Get the cat's age"""<br/><br/>                return self.age<br/><br/>            def breed(self):<br/>                """Get the type of cat, e.g. short hair, long hair, etc."""<br/>        <br/>                return self.breed<br/><br/>            def __repr__(self):<br/>                """Return string representation of Cat object.<br/><br/>                Without this method, only the object's <br/>                memory address will be printed.<br/>                """<br/>                return "{breed}, {age}".format(breed = self.breed, age = self.age)</pre>
<ol start="2">
<li>To utilize this class, create an instance of&#160;<kbd>Cat</kbd>, providing the initial parameters:</li>
</ol>
<pre>         chip = Cat("domestic shorthair", 4)</pre>
<ol start="3">
<li>Next, call the methods to ensure that they work:</li>
</ol>
<div class="CDPAlignCenter CDPAlign"><img src="images/c7c22727-14a4-464a-b599-7977ef401e44.png" style="width:39.58em;height:7.33em;"/></div>
<ol start="4">
<li>Notice that the methods are tied to a particular instance; they cannot be called on the generic<span>&#160;</span><kbd>Cat</kbd><span>&#160;</span>class:</li>
</ol>
<div class="CDPAlignCenter CDPAlign"><img src="images/f8460196-44ab-4f62-b87b-626e4fb6882c.png" style="width:41.67em;height:13.42em;"/></div>
<ol start="5">
<li>Static methods are methods that apply to all instances. They are denoted by the&#160;<kbd>@staticmethod</kbd><span>&#160;</span>decorator prior to a method definition. Also, the method itself does not require a&#160;<kbd>self</kbd><span>&#160;</span>argument in the definition (<kbd>static_method.py</kbd>):</li>
</ol>
<pre>        @staticmethod # This is required<br/>            def cry():<br/>                """Static method, available to all instances and the class<br/><br/>                Notice that 'self' is not a required argument<br/>                """<br/><br/>                return "Nyao nyao" # It's a Japanese cat</pre>
<ol start="6">
<li>Static methods can be applied to both instances and the class itself:</li>
</ol>
<div class="CDPAlignCenter CDPAlign"><img src="images/1b2a88c3-332e-428b-a3cc-d4d3a0a91d0d.png" style="width:46.00em;height:42.58em;"/></div>
<p style="padding-left: 60px" class="mce-root CDPAlignLeft CDPAlign">Notice that on lines 29 and 31, calling the static method without parentheses returns the memory location of the method; the method is not bound to an instance, but is available to the class as well. Only when parentheses are used (lines 30 and 32) will the correct return object be displayed.</p>
<ol start="7">
<li>Class methods are identified by the&#160;<kbd>@classmethod</kbd><span>&#160;</span>decorator prior to creating the method. In addition, the method argument is&#160;<kbd>cls</kbd><span>&#160;</span>instead of&#160;<kbd>self</kbd>. The following code can be added after the static method in the previous example (<kbd>class_method.py</kbd>):</li>
</ol>
<pre>        @classmethod # This is required<br/>            def type(cls):<br/>                """<br/>                Class method, available only to classes.<br/><br/>                Notice that 'cls' is the argument, as opposed to 'self'<br/>                """<br/><br/>                if cls.__name__ == "Cat":<br/>                    return "Some sort of domestic cat."<br/>                else:<br/>                    return cls.__name__</pre>
<ol start="8">
<li>Now, when instance is made, the class it comes from is checked. If the generic&#160;<kbd>Cat</kbd><span>&#160;</span>class is the generator, a message will be printed. If a subclass of&#160;<kbd>Cat</kbd><span>&#160;</span>is used, then the name of the class is printed:</li>
</ol>
<div class="CDPAlignCenter CDPAlign"><img src="images/bfa5d66b-d6ff-4066-a352-9a4a282835e7.png" style="width:44.50em;height:15.58em;"/></div>


            </article>

            
        </section>
    </div>


  <div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">Examples of decorators</h1>
                </header>
            
            <article>
                
<p>Frameworks, such as for web development or graphical interface design, frequently have decorators to automate functionality for a developer. While a developer can access parts of a framework directly, such as modules and functions, using decorators to facilitate this process makes a programmer's life easier.</p>
<p>For example, many web frameworks include a decorator, <kbd>@login_required</kbd>, to ensure that a user is authenticated with the website before being allowed to do anything on the site. While login and authentication capabilities could be coded by the developer, the framework includes that functionality because it is such an integral part of how websites work.&#160;</p>
<p>Because it is such an important part of website functionality and is frequently used, having a well-developed authentication method should be provided by the framework. Much like cryptography, leaving it up to developers to properly implement can lead to trouble, as it is easier to do it wrong than to do it right.</p>


            </article>

            
        </section>
    </div>


  <div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">Getting ready</h1>
                </header>
            
            <article>
                
<p>To utilize this recipe, you will have to install the Flask web framework. However, the following Flask example doesn't cover everything regarding how to use Flask; the installation is simply to ensure that no errors occur.&#160;Flask itself can take an entire book to cover. This section is designed to show how decorators are used in the real world to accomplish a variety of tasks and is not intended to show a working Flask website.</p>


            </article>

            
        </section>
    </div>


  <div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">How to do it...</h1>
                </header>
            
            <article>
                
<p>Flask does not include a login decorator function, but the documentation does provide an example of how to roll your own (<a href="http://flask.pocoo.org/docs/0.12/patterns/viewdecorators/">http://flask.pocoo.org/docs/0.12/patterns/viewdecorators/</a>). This should not be used for production use, even if it copies the Flask functionality, as you would then be responsible for ensuring that any modifications to your code don't affect the login functionality:</p>
<ol>
<li>Import the&#160;<kbd>wraps</kbd> function from the Python standard library's&#160;<kbd>functools</kbd> module. This is necessary to retain the original function's data:</li>
</ol>
<pre>        from functools import wraps</pre>
<ol start="2">
<li>A number of Flask tools need to be imported.&#160;<kbd>g</kbd> is a Flask application global, a special object that is only valid for the active request and returns a different value for each request.&#160;<kbd>request</kbd> is the default request object in Flask; it remembers the matched endpoint and view arguments.&#160;<kbd>redirect</kbd> returns an HTTP 30x redirection code to send the client to the correct destination. <kbd>url_for</kbd> creates a URL for the given endpoint (a&#160;web page created by a function call):</li>
</ol>
<pre>        from flask import g, request, redirect, url_for</pre>
<ol start="3">
<li>Write the login decorator&#160;<span>function:</span></li>
</ol>
<pre><span class="k">        def</span> <span class="nf">login_required</span><span class="p">(</span><span class="n">f</span><span class="p">):</span>
            <span class="nd">@wraps</span><span class="p">(</span><span class="n">f</span><span class="p">)</span>
            <span class="k">def</span> <span class="nf">decorated_function</span><span class="p">(</span><span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
                <span class="k">if</span> <span class="n">g</span><span class="o">.</span><span class="n">user</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
                    <span class="k">return</span> <span class="n">redirect</span><span class="p">(</span><span class="n">url_for</span><span class="p">(</span><span class="s1">'login'</span><span class="p">,</span> <span class="nb">next</span><span class="o">=</span><span class="n">request</span><span class="o">.</span><span class="n">url</span><span class="p">))</span>
                <span class="k">return</span> <span class="n">f</span><span class="p">(</span><span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
            <span class="k">return</span> <span class="n">decorated_function</span></pre>
<ol start="4">
<li>When implementing the login decorator, it is the last decorator to be used prior to writing the main function:</li>
</ol>
<pre><span class="nd">        @app</span><span class="o">.</span><span class="n">route</span><span class="p">(</span><span class="s1">'/inventory'</span><span class="p">)</span>
<span class="nd">        @login_required</span>
<span class="k">        def</span> <span class="nf">inventory</span><span class="p">():</span>
            <span class="k">pass</span></pre>
<ol start="5">
<li>One possible use of a decorator is to set up a timing function to time other functions. That way, you don't have to call&#160;<kbd>time</kbd> from the command line when running a script. The following code should be written to a file and not entered into an interactive Python prompt (<kbd>time_decorator_creation.py</kbd>):</li>
</ol>
<pre>        import time<br/><br/>        def time_decorator(funct):<br/>            def wrapper(*arg)<br/>                result = funct(*arg)<br/>                print(time.perf_counter())<br/>                return result<br/>            return wrapper</pre>
<ol start="6">
<li>The&#160;<kbd>time_decorator</kbd> can be used with any function to provide the time it takes for the function to complete. The following code should be written to the same file as the preceding decorator (<kbd>time_dec.py</kbd>):</li>
</ol>
<pre>        # Silly little number cruncher<br/>        import math<br/><br/>        @time_decorator<br/>        def factorial_counter(x, y):<br/>            fact = math.factorial(x)<br/>            time.sleep(2)  # Force a delay to show the time decorator works<br/>            fact2 = math.factorial(y)<br/>            print(math.gcd(fact, fact2))<br/><br/>        factorial_counter(10000, 10)</pre>
<ol start="7">
<li>Running the preceding code results in the following:</li>
</ol>
<div class="CDPAlignCenter CDPAlign"><img src="images/8f1b249f-39ec-45d7-9d47-6feaf219d718.png" style="width:36.58em;height:6.33em;"/></div>
<ol start="8">
<li>This example (from&#160;<a href="https://www.python.org/dev/peps/pep-0318/#examples">https://www.python.org/dev/peps/pep-0318/#examples</a>) shows how to add attributes to a function. One use case may be automatically adding data to a function, such as metadata (<kbd>add_attributes.py</kbd>):</li>
</ol>
<pre class="literal-block">        def attrs(**kwds):
            def decorate(f):
                for k in kwds:
                    setattr(f, k, kwds[k])
                return f
            return decorate

        @attrs(versionadded="2.2",
               author="Guido van Rossum")
        def mymethod(f):
            ...</pre>
<ol start="9">
<li>Another example from the PEP-318 documentation is to create a decorator that enforces function argument and return types. This is useful when programatically running scripts that accept/return arguments, but you cannot guarantee the object types that may be input (<kbd>function_enforcement.py</kbd>):</li>
</ol>
<pre class="literal-block">        def accepts(*types):
            def check_accepts(f):
                assert len(types) == f.func_code.co_argcount
                def new_f(*args, **kwds):
                    for (a, t) in zip(args, types):
                        assert isinstance(a, t), \
                           "arg %r does not match %s" % (a,t)
                    return f(*args, **kwds)
            new_f.func_name = f.func_name
            return new_f
        return check_accepts

        def returns(rtype):
            def check_returns(f):
                def new_f(*args, **kwds):
                    result = f(*args, **kwds)
                    assert isinstance(result, rtype), \
                    "return value %r does not match %s" %<br/>                    (result,rtype)
                return result
                new_f.func_name = f.func_name
            return new_f
        return check_returns

        @accepts(int, (int,float))
        @returns((int,float))
        def func(arg1, arg2):
           return arg1 * arg2</pre>
<ol start="10">
<li>If you write unit tests using the&#160;<kbd>nose</kbd> library, the following example (from&#160;<a href="https://stackoverflow.com/users/9567/torsten-marek">https://stackoverflow.com/users/9567/torsten-marek</a>), demonstrates how a decorator can automatically pass parameters into a unit test function (the full code is not provided, just the implementation on the final function call):</li>
</ol>
<pre>        @parameters(<br/>            (2, 4, 6), <br/>            (5, 6, 11)<br/>        )<br/>        def test_add(a, b, expected):<br/>            assert a + b == expected</pre>


            </article>

            
        </section>
    </div>


  <div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">How it works...</h1>
                </header>
            
            <article>
                
<p>Once the <kbd>Flask</kbd> modules are imported, the login decorator function provides the main logic for handling user authentication. The Python standard library's&#160;<kbd>@wraps()</kbd> decorator call does the same thing we have done previously with the&#160;<kbd>def wrapper()</kbd> function, except we are utilizing the <kbd>functools.wraps</kbd> function provided by <kbd>Flask</kbd>. This is necessary because the login decorator wraps and replaces the original function; without a wrapper, that original data would be lost during the handover.</p>
<p>The&#160;<kbd>decorated_function()</kbd> takes any number of arguments, either as positional or keyword:value pairs. This function first checks to see whether the global object&#160;<kbd>g.user</kbd> is&#160;<kbd>None</kbd>, that is, a user not logged in. If this is the case, the user is automatically redirected to the&#160;<kbd>login</kbd> page. Because of how Flask works, each page URL is actually a function call; the function's name dictates the URI path (more information on Flask functionality is provided later).</p>
<p>If the user is already logged in, then the&#160;<kbd>f()</kbd> function (the original function called) is called with the arguments the login decorator received. Finally, the decorator function ends, returning logic control back to the original function.</p>


            </article>

            
        </section>
    </div>


  <div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">There's more...</h1>
                </header>
            
            <article>
                
<p>Here is a real-world example, <kbd>long_flask_program.py</kbd>&#160;from a blog project this author created, using the Flask web framework as part of an online mentoring curriculum (<a href="https://github.com/crystalattice/Blogful">https://github.com/crystalattice/Blogful</a>):</p>
<pre>@app.route("/") # Root (default) page to display when landing on web site<br/>@app.route("/page/&lt;int:page&gt;") # Specific site page<br/>@login_required # Force authentication<br/>def entries(page=1):<br/>    """<br/>    Query the database entries of the blog.<br/><br/>    :param page: The page number of the site.<br/>    :return: Template page with the number of entries specified, <br/>    Next/Previous links, page number, and total number of<br/>    pages in the site<br/>    """<br/>    # Zero-indexed page<br/>    default_entries = 10<br/>    max_entries = 50<br/><br/>    # Set the number of entries displayed per page<br/>    try:<br/>        entry_limit = int(request.args.get('limit', default_entries)) <br/>        # Get the limit from HTML argument 'limit'<br/>        assert entry_limit &gt; 0 # Ensure positive number<br/>        assert entry_limit &lt;= max_entries <br/>        # Ensure entries don't exceed max value<br/>    except (ValueError, AssertionError): <br/>        # Use default value if number of entries doesn't meet expectations<br/>        entry_limit = default_entries<br/><br/>    page_index = page - 1<br/><br/>    count = session.query(Entry).count()<br/><br/>    start = page_index * PAGINATE_BY # Index of first entry on page<br/>    end = start + PAGINATE_BY # Index of last entry on page<br/>    total_pages = (count - 1) // PAGINATE_BY + 1 # Total number of pages<br/>    has_next = page_index &lt; total_pages - 1 # Does following page exit?<br/>    has_prev = page_index &gt; 0 # Does previous page exist?<br/><br/>    entries = session.query(Entry)<br/>    entries = entries.order_by(Entry.datetime.desc())<br/>    entries = entries[start:end]<br/><br/>    return render_template("entries.html",<br/>                           entries=entries,<br/>                           has_next=has_next,<br/>                           has_prev=has_prev,<br/>                           page=page,<br/>                           total_pages=total_pages<br/>                           )</pre>
<p>In the preceding example, three decorators are applied to the function entries: <kbd>@app.route("/")</kbd>,&#160;<kbd>@app.route("/page/&lt;int:page&gt;")</kbd>, and&#160;<kbd>@login_required</kbd>. The decorators are built into&#160;Flask and are accessed via the Flask API.&#160;<kbd>@app.route()</kbd>&#160;captures URL requests and determines which function to call in relation to the URL.&#160;<kbd>@login_required</kbd><span>&#160;comes from the Flask login extension&#160;and&#160;</span>ensures that a user is logged in prior to processing a function; if not, the user is redirected to a login screen.</p>
<p>The&#160;<kbd>entries</kbd><span>&#160;</span>function simply populates a web page with the entries in a blog's database.&#160;<kbd>@app.route("/")</kbd><span>&#160;</span>specifies that, when the root URL is provided for the website, the browser will be brought to the&#160;<kbd>entries</kbd><span>&#160;</span>function, which will process the request and display the blog entries&#160;<span>(for the Flask framework, each function call in the&#160;</span><kbd>views.py</kbd><span>&#160;</span><span>file becomes a URL address. Thus,&#160;</span><kbd>entries</kbd> <span>would appear to a browser as <kbd>www.blog_website.com/entries</kbd>).</span></p>
<p>The decorator&#160;<kbd>@app.route("/page/&lt;int:page&gt;")</kbd><span>&#160;</span>specifies that with a URL with the resource locator ending in&#160;<kbd>/page/#</kbd>, such as&#160;<kbd>www.blog_website.com/page/2</kbd>, the decorator redirects the page request to&#160;<kbd>entries</kbd><span>&#160;</span>and displays the blog posts for the indicated page, in this case page 2.&#160;</p>
<p><kbd>entries</kbd><span>&#160;</span>defaults to the first page, as shown in the argument passed to it. The <kbd>default_entries</kbd> and&#160;<kbd>max_entries</kbd><span>&#160;</span>dictate how many pages are available on the site. Obviously, changing or removing those values can make the blog site dump all entries to a single page.</p>
<p>The&#160;<kbd>@login_required</kbd>&#160;decorator catches calls or redirects to the&#160;<kbd>entries</kbd><span>&#160;</span>function and makes a pit stop to Flask's authentication module. The user's session is queried to see whether the user has authenticated with the system; if not, the user is informed that authentication is required prior to accessing the site.</p>
<p>While functionality for the site could be set up without using decorators, it hopefully can be seen that using decorators makes it much easier to deal with website access. In this case, anytime the web server is told to send a page of blog posts to the browser, the URL is parsed to see whether it matches either the root "<kbd>/</kbd>" directory, or a specific page number. If so, then authentication is checked. If the user is logged into the site, then the blog post entries are finally displayed in the browser.</p>
<p>For this particular program, decorators are also available to catch requests to add and delete blog posts, display a particular blog entry (rather than an entire page), edit entries, display the login page, and logout a user.</p>
<p><kbd>decorator_args.py</kbd>, below, is from another portion of the Flask blog application, showing how one decorator can be used to do different things, depending on the arguments passed to it:</p>
<pre>@app.route("/entry/add", methods=["GET"])<br/>@login_required # Force authentication<br/>def add_entry_get():<br/>    """Display the web form for a new blog entry"""<br/>    return render_template("add_entry.html")<br/><br/><br/>@app.route("/entry/add", methods=["POST"])<br/>@login_required # Force authentication<br/>def add_entry_post():<br/>    """Take an entry form and put the data in the DB"""<br/>    entry = Entry(<br/>        title=request.form["title"],<br/>        content=request.form["content"],<br/>        author=current_user<br/>    )<br/>    session.add(entry)<br/>    session.commit()<br/>    return redirect(url_for("entries"))<br/><br/>@app.route("/login", methods=["GET"])<br/>def login_get():<br/>    """Display the login page"""<br/>    return render_template("login.html")<br/><br/>@app.route("/login", methods=["POST"])<br/>def login_post():<br/>    """Check if user is in database"""<br/>    email = request.form["email"]<br/>    password = request.form["password"]<br/>    user = session.query(User).filter_by(email=email).first()<br/>    if not user or not check_password_hash(user.password, password):<br/>        flash("Incorrect username or password", "danger")<br/>        return redirect(url_for("login_get"))<br/><br/>    login_user(user)<br/>    return redirect(request.args.get('next') or url_for("entries"))</pre>
<p>In these examples, both&#160;<kbd>/entry/add</kbd><span>&#160;</span>and&#160;<kbd>/login</kbd> <span>URI calls accept either a <kbd>GET</kbd> or <kbd>POST</kbd> HTTP request for the database</span>. In the case of a&#160;<kbd>GET</kbd><span>&#160;</span>request, the database is queried and the desired information is returned to the screen.&#160;If the HTTP request is a&#160;<kbd>POST</kbd>, the appropriate decorator is called and the data provided in the request is input to the database.</p>
<p>In both cases, the decorator function is effectively the same call; the only difference is whether it is<span>&#160;a&#160;</span><kbd>GET</kbd><span>&#160;</span><span>or&#160;</span><kbd>POST</kbd><span>&#160;request that is made. The decorator knows what to do, based on those arguments.&#160;</span></p>
<p><span>When dealing with login authentication, a better option is to use the&#160;</span><a href="https://flask-login.readthedocs.io/en/latest/">https://flask-login.readthedocs.io/en/latest/</a><span>&#160;extension, which provides the following features:</span></p>
<ul>
<li>Store active user's session ID</li>
<li>Easy user login and logout</li>
<li>Restricts views to logged in and logged out users</li>
<li>Handles "remember me" functionality</li>
<li>Protects session cookies</li>
<li>Integration with other Flask extensions</li>
</ul>


            </article>

            
        </section>
    </div>


  <div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">Using the decorators module</h1>
                </header>
            
            <article>
                
<p>With all the functionality that decorators provide, and their common use among Python packages, it's inevitable that someone would create a package just for decorators.&#160;<a href="https://pypi.python.org/pypi/decorator">https://pypi.python.org/pypi/decorator</a>&#160;provides a&#160;<kbd>pip</kbd> installable package to help when working with decorators.</p>
<p>The&#160;<kbd>decorator</kbd> module is a very stable (more than 10 years old) tool that provides the ability to preserve decorated functions across different Python versions. The aim of the module is to simplify decorator usage, reduce boilerplate code, and enhance program readability and maintainability.&#160;</p>
<p>Decorators can be broken down into two main types: signature-preserving and signature-changing. The preserving decorators take a function call and return a function as the output, without changing anything about the function call's signature. These decorators are the most common type.</p>
<p>Signature-changing decorators accept a function call, but change the signature when output, or simply return non-callable objects.&#160;<kbd>@staticmethod</kbd> and&#160;<kbd>@classmethod</kbd>, discussed previously, are examples of signature-changing decorators.</p>
<p>Identifying a function's signature is provided by Python's introspection capabilities. In essence, a signature provides all necessary information about a function, that is, input and output parameters, default arguments, and so on, so that a developer, or the program, knows how to use a function.</p>
<p>This module is designed to provide generic <em>factory of generators</em> to hide the complexity of making signature-preserving decorators. Preserving decorators, while more common, are not necessarily easy to code from scratch, especially if the decorator needs to accept all functions with any signature.</p>


            </article>

            
        </section>
    </div>


  <div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">How to do it...</h1>
                </header>
            
            <article>
                
<p>A common use of decorators, outside of frameworks, is to memoize functions. Memoization caches the results of a function call to a dictionary; if the function is called again with the same arguments, the result is pulled from the cache rather than rerunning the function again. Many memoization functions and decorators have been created, but most don't preserve the signature. The following examples are taken from the&#160;<kbd>decorator</kbd> module's documentation (<a href="http://decorator.readthedocs.io/en/latest/tests.documentation.html">http://decorator.readthedocs.io/en/latest/tests.documentation.html</a>):</p>
<ol start="1">
<li>A memoization decorator can be written to cache the input arguments to a dictionary (<kbd>memoize_dec.py</kbd>):</li>
</ol>
<pre><span class="k">        import functools<br/>        import time<br/> <br/>        def</span> <span class="nf">memoize_uw</span><span class="p">(</span><span class="n">func</span><span class="p">):</span>
            <span class="n">func</span><span class="o">.</span><span class="n">cache</span> <span class="o">=</span> <span class="p">{}</span>

            <span class="k">def</span> <span class="nf">memoize</span><span class="p">(</span><span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kw</span><span class="p">):</span>
                <span class="k">if</span> <span class="n">kw</span><span class="p">:</span>  <span class="c1"># frozenset is used to ensure hashability</span>
                    <span class="n">key</span> <span class="o">=</span> <span class="n">args</span><span class="p">,</span> <span class="nb">frozenset</span><span class="p">(</span><span class="n">kw</span><span class="o">.</span><span class="n">items</span><span class="p">())</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="n">key</span> <span class="o">=</span> <span class="n">args</span>
                <span class="k">if</span> <span class="n">key</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">func</span><span class="o">.</span><span class="n">cache</span><span class="p">:</span>
                    <span class="n">func</span><span class="o">.</span><span class="n">cache</span><span class="p">[</span><span class="n">key</span><span class="p">]</span> <span class="o">=</span> <span class="n">func</span><span class="p">(</span><span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kw</span><span class="p">)</span>
                <span class="k">return</span> <span class="n">func</span><span class="o">.</span><span class="n">cache</span><span class="p">[</span><span class="n">key</span><span class="p">]</span>
            <span class="k">return</span> <span class="n">functools</span><span class="o">.</span><span class="n">update_wrapper</span><span class="p">(</span><span class="n">memoize</span><span class="p">,</span> <span class="n">func</span><span class="p">)</span></pre>
<ol start="2">
<li>A simple function, with one input argument, works just fine (<kbd>memoize_funct.py</kbd>):</li>
</ol>
<pre><span class="nd">        @memoize_uw</span>
<span class="k">        def</span> <span class="nf">f1</span><span class="p">(</span><span class="n">x</span><span class="p">):</span>
            <span class="s2">"Simulate some long computation"</span>
            <span class="n">time</span><span class="o">.</span><span class="n">sleep</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span>
            <span class="k">return</span> <span class="n">x</span></pre>
<ol start="3">
<li><span>The problem comes when Python introspection tools, such as&#160;</span><kbd>pydoc</kbd> <span>get involved. These introspection tools will see that the decorator states that any number of arguments can be accepted, as it is a generic function signature. However, the reality is that the main function (</span><kbd>f1()</kbd><span>) only accepts one argument. Trying to use more than one argument will result in an error.</span></li>
<li>If the&#160;<kbd>decorate</kbd> function from the&#160;<kbd>decorator</kbd> modules is used, this problem is alleviated.&#160;<kbd>decorate</kbd> takes two arguments: a caller function that describes the decorator's functionality and the main function to be called.</li>
<li>In this case, the new decorator becomes two separate functions. The first one is the <kbd>main</kbd> decorator function, that is, the wrapper (<kbd>call_dec.py</kbd>:&#160;</li>
</ol>
<pre style="color: black"><span class="k">        import functools<br/>        import time<br/>        from decorator import *<br/><br/>        def</span> <span class="nf">_memoize</span><span class="p">(</span><span class="n">func</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kw</span><span class="p">):</span>
            <span class="k">if</span> <span class="n">kw</span><span class="p">:</span>  <span class="c1"># frozenset is used to ensure hashability</span>
                <span class="n">key</span> <span class="o">=</span> <span class="n">args</span><span class="p">,</span> <span class="nb">frozenset</span><span class="p">(</span><span class="n">kw</span><span class="o">.</span><span class="n">items</span><span class="p">())</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">key</span> <span class="o">=</span> <span class="n">args</span>
           <span class="n">cache</span> <span class="o">=</span> <span class="n">func</span><span class="o">.</span><span class="n">cache</span>  <span class="c1"># attribute added by memoize</span>
        <span class="k">if</span> <span class="n">key</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">cache</span><span class="p">:</span>
            <span class="n">cache</span><span class="p">[</span><span class="n">key</span><span class="p">]</span> <span class="o">=</span> <span class="n">func</span><span class="p">(</span><span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kw</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">cache</span><span class="p">[</span><span class="n">key</span><span class="p">]<br/></span></pre>
<ol start="6">
<li>The second function is the actual decorator that will be called (<kbd>def_memoize.py</kbd>):</li>
</ol>
<pre><span class="k">        def</span> <span class="nf">memoize</span><span class="p">(</span><span class="n">f</span><span class="p">):</span> <br/><span class="sd">            """</span> <span class="sd">A simple memoize implementation. <br/>            It works by adding a .cache dictionary</span> <span class="sd">to the  decorated <br/>            function. The cache will grow indefinitely, so it is</span> <span class="sd">your <br/>            responsibility to clear it, if needed.</span> <br/>            <span class="sd">"""</span> <br/><span class="n">            f</span><span class="o">.</span><span class="n">cache</span> <span class="o">=</span> <span class="p">{}</span> <br/><span class="k">            return</span> <span class="n">decorate</span><span class="p">(</span><span class="n">f</span><span class="p">,</span> <span class="n">_memoize</span><span class="p">)</span></pre>
<ol start="7">
<li>&#160;Having two separate functions makes the decorator remove the need for nested functions (making it easier to walk through the logic flow) and the developer is forced to explicitly pass the desired function for decoration; closures are no longer required.</li>
</ol>
<ol start="8">
<li>The following code is a simple sleep timer to simulate data processing (<kbd>run_memoize.py</kbd>):</li>
</ol>
<pre>        import time<br/><br/>        @memoize<br/>        def data_simulator():<br/>            time.sleep(2)<br/>            return "done"</pre>
<ol start="9">
<li>When the&#160;<kbd>data_simulator()</kbd> function is called for the first time, it will take the full two seconds to run, due to the sleep function call. However, when it is called in the future, the <kbd>done</kbd> response will be instantaneous because it is being pulled from the cache, rather than actually being processed.</li>
</ol>


            </article>

            
        </section>
    </div>


  <div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">How it works...</h1>
                </header>
            
            <article>
                
<p>The initial&#160;<kbd>memoize_uw()</kbd> decorator creates a blank dictionary to use as the cache. The enclosed&#160;<kbd>memoize()</kbd> function takes any number of arguments and looks to see whether any of them is a keyword; if so, a frozen set is used to take the arguments and use them as values for the keywords. If there are no keywords provided, then a new key:value item is created.</p>
<p>If the keyword is not already in the cache dictionary, then a new item is placed in the cache; otherwise, the cached item is pulled from the cache and becomes a return value. Finally, the entire decorator closes out and the final value is returned to the main program.</p>
<p>In the new&#160;<kbd>_memoize()</kbd> function, the same functionality is provided but, as the caller function to the decorator, its argument signature must be in the form of&#160;<kbd>(f, *args, **kw)</kbd>. It must also call the original function with the arguments; this is demonstrated with the line&#160;<kbd>cache[key] = func(*args, **kw)</kbd>.</p>
<p>The new&#160;<kbd>memoize()</kbd> decorator implements the cache as an empty dictionary, like before, but uses the&#160;<kbd>decorate()</kbd> function to return the&#160;<kbd>_memoize()</kbd> results to the original function.</p>


            </article>

            
        </section>
    </div>


  <div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">There's more...</h1>
                </header>
            
            <article>
                
<p>Honestly, there's a lot of moving parts here that can get confusing quickly, especially for inexperienced Python programmers. A lot of practice and documentation referencing is required to get a handle on both decorators and the&#160;<kbd>decorator</kbd>&#160;module.</p>
<p>Do you have to use decorators? No. They are just designed to make the life of a programmer easier. Plus, you should know about them because a lot of third-party libraries and packages, particularly web and GUI frameworks, utilize them.</p>
<p>Once you get a handle on decorators in general, the&#160;<kbd>decorator</kbd>&#160;module will probably make more sense, as well as show itself to be useful in minimizing hand-coded decorators. There is a lot of functionality included in the module that this book doesn't cover, such as converting a caller function directly into a decorator, class decorators, and dealing with blocking calls, that is, a process that won't allow the program to continue until the process is resolved.</p>


            </article>

            
        </section>
    </div>


  <div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">See also</h1>
                </header>
            
            <article>
                
<p>You can also refer to the&#160;<em>Using class decorators&#160;</em>recipe of this chapter.</p>


            </article>

            
        </section>
    </div>
</body>
</html>