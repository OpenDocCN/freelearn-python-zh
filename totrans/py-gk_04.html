<html><head></head><body>
		<div id="_idContainer030">
			<p><a id="_idTextAnchor111"/></p>
			<h1 id="_idParaDest-75"><em class="italic"><a id="_idTextAnchor112"/>Chapter 3</em>: Advanced Object-Oriented Python Programming</h1>
			<p>Python can be used as a declarative modular programming language such as C, as well as being used for imperative programming or full <strong class="bold">object-oriented programming</strong> (<strong class="bold">OOP</strong>) with programming languages such as Java. <strong class="bold">Declarative programming</strong> is a paradigm in which we focus on what we want to implement, while <strong class="bold">imperative programming</strong> is where we describe the exact steps of how to implement what we want. Python is suitable for both types of programming paradigms. OOP is a form of imperative programming in which we bundle the properties and behaviors of real-world objects into programs. Moreover, OOP also addresses the relations between different types of real-world objects.</p>
			<p>In this chapter, we will explore how the advanced concepts of OOP can be implemented using Python. We are assuming that you are familiar with general concepts such as classes, objects, and instances and have basic knowledge of inheritance between objects. </p>
			<p>We will cover the following topics in this chapter:</p>
			<ul>
				<li>Introducing classes and objects</li>
				<li>Understanding OOP principles</li>
				<li>Using composition as an alternative design approach</li>
				<li>Introducing duck typing in Python</li>
				<li>Learning when not to use OOP in Python</li>
			</ul>
			<h1 id="_idParaDest-76"><a id="_idTextAnchor113"/>Technical requirements</h1>
			<p>These are the technical requirements for this chapter:</p>
			<ul>
				<li>You need to have Python 3.7 or later installed on your computer.</li>
				<li>The sample code for this chapter can be found at <a href="https://github.com/PacktPublishing/Python-for-Geeks/tree/master/Chapter03">https://github.com/PacktPublishing/Python-for-Geeks/tree/master/Chapter03</a>.</li>
			</ul>
			<h1 id="_idParaDest-77"><a id="_idTextAnchor114"/>Introducing classes and objects</h1>
			<p>A class is a blueprint for how <a id="_idIndexMarker249"/>something should be defined. It doesn't actually contain any data—it is a template that is used to create instances as per the specifications defined in a template or a blueprint.</p>
			<p>An object of a class is an<a id="_idIndexMarker250"/> instance that is built from a class, and that is why it is also called an instance of a class. For the rest of this chapter and this book, we will refer to <em class="italic">object</em> and <em class="italic">instance</em> synonymously. Objects<a id="_idIndexMarker251"/> in OOP are occasionally represented by physical objects such as tables, chairs, or books. On most occasions, the objects in a software program represent abstracted entities that may not be physical, such as accounts, names, addresses, and payments.</p>
			<p>To refresh ourselves with basic concepts of classes and objects, we will define these terminologies with code examples.</p>
			<h2 id="_idParaDest-78"><a id="_idTextAnchor115"/>Distinguishing between class attributes and instance attributes</h2>
			<p><strong class="bold">Class attributes</strong> are defined as <a id="_idIndexMarker252"/>part of the class definition, and their values are meant to be the same across all instances created from that class. The class attributes can be accessed using the class name or instance name, although it is<a id="_idIndexMarker253"/> recommended to use a class name to access these attributes (for reading or updating). The state or data of an object is provided by <strong class="bold">instance attributes</strong>.</p>
			<p>Defining a class in Python is simply done by using the <strong class="source-inline">class</strong> keyword. As discussed in <a href="B17189_01_Final_PG_ePub.xhtml#_idTextAnchor013"><em class="italic">Chapter 1</em></a>, <em class="italic">Optimal Python Development Life Cycle,</em> the name of the class should be CamelCase. The following code snippet creates a <strong class="source-inline">Car</strong> class:</p>
			<p class="source-code">#carexample1.py</p>
			<p class="source-code">class Car:</p>
			<p class="source-code">    pass</p>
			<p>This class has no attributes and methods. It is an empty class, and you may think this class is useless until we add more components to it. Not exactly! In Python, you can add attributes on the fly without<a id="_idIndexMarker254"/> defining them in the class. The following<a id="_idIndexMarker255"/> snippet is a valid example of code in which we add attributes to a class instance at runtime:</p>
			<p class="source-code">#carexample1.py</p>
			<p class="source-code">class Car:</p>
			<p class="source-code">    pass</p>
			<p class="source-code">if __name__ == "__main__":</p>
			<p class="source-code">    car = Car ()</p>
			<p class="source-code">    car.color = "blue"</p>
			<p class="source-code">    car.miles = 1000</p>
			<p class="source-code">    print (car.color)</p>
			<p class="source-code">    print (car.miles)</p>
			<p>In this extended example, we created an instance (<strong class="source-inline">car</strong>) of our <strong class="source-inline">Car</strong> class and then added two attributes to this instance: <strong class="source-inline">color</strong> and <strong class="source-inline">miles</strong>. Note that the attributes added using this approach are instance attributes.</p>
			<p>Next, we will add class attributes and instance attributes using a constructor method (<strong class="source-inline">__init__</strong>), which is loaded at the time of object creation. A code snippet with two instance attributes (<strong class="source-inline">color</strong> and <strong class="source-inline">miles</strong>) and the <strong class="source-inline">init</strong> method is shown next:</p>
			<p class="source-code">#carexample2.py</p>
			<p class="source-code">class Car:</p>
			<p class="source-code">    c_mileage_units = "Mi"</p>
			<p class="source-code">    def __init__(self, color, miles):</p>
			<p class="source-code">        self.i_color = color</p>
			<p class="source-code">        self.i_mileage = miles</p>
			<p class="source-code">if __name__ == "__main__":</p>
			<p class="source-code">    car1 = Car ("blue", 1000)</p>
			<p class="source-code">    print (car.i_color)</p>
			<p class="source-code">    print (car.i_mileage)</p>
			<p class="source-code">    print (car.c_mileage_units)</p>
			<p class="source-code">    print (Car.c_mileage_units)</p>
			<p>In this program, we did the following:</p>
			<ol>
				<li>We created a <strong class="source-inline">Car</strong> class with a <strong class="source-inline">c_mileage_units</strong> class attribute and two instance variables, <strong class="source-inline">i_color</strong> and <strong class="source-inline">i_mileage</strong>.</li>
				<li>We created an instance (<strong class="source-inline">car</strong>) of the <strong class="source-inline">Car</strong> class.</li>
				<li>We printed out the instance attributes using the <strong class="source-inline">car</strong> instance variable.</li>
				<li>We printed out the<a id="_idIndexMarker256"/> class attribute using the <strong class="source-inline">car</strong> instance<a id="_idIndexMarker257"/> variable as well as the <strong class="source-inline">Car</strong> class name. The console output is the same for both cases.<p class="callout-heading">Important note</p><p class="callout"><strong class="source-inline">self</strong> is a reference to the instance that is being created. Use of <strong class="source-inline">self</strong> is common in Python to access the instance attributes and methods within the instance method, including the <strong class="source-inline">init</strong> method. <strong class="source-inline">self</strong> is not a keyword, and it is not mandatory to use the word <strong class="source-inline">self</strong>. It can be anything such as <strong class="source-inline">this</strong> or <strong class="source-inline">blah</strong>, except that it has to be the first parameter to the instance methods, but the convention of using <strong class="source-inline">self</strong> as the argument name is too strong.</p></li>
			</ol>
			<p>We can update the class attributes using an instance variable or class name, but the outcome can be different. When we update a class attribute using the class name, it is updated for all the instances of that class. But if we update a class attribute using an instance variable, it will be updated only for that particular instance. This is demonstrated in the following code snippet, which is using the <strong class="source-inline">Car</strong> class:</p>
			<p class="source-code">#<strong class="bold">carexample3.py</strong></p>
			<p class="source-code">#class definition of Class Car is same as in carexample2.py</p>
			<p class="source-code">if __name__ == "__main__":</p>
			<p class="source-code">    car1 = Car ("blue", 1000)</p>
			<p class="source-code">    car2 = Car("red", 2000)</p>
			<p class="source-code">    print("using car1: " + car1.c_mileage_units)</p>
			<p class="source-code">    print("using car2: " + car2.c_mileage_units)</p>
			<p class="source-code">    print("using Class: " + Car.c_mileage_units)</p>
			<p class="source-code">    <strong class="bold">car1.c_mileage_units = "km"</strong></p>
			<p class="source-code">    print("using car1: " + car1.c_mileage_units)</p>
			<p class="source-code">    print("using car2: " + car2.c_mileage_units)</p>
			<p class="source-code">    print("using Class: " + Car.c_mileage_units)</p>
			<p class="source-code">    <strong class="bold">Car.c_mileage_units = "NP"</strong></p>
			<p class="source-code">    print("using car1: " + car1.c_mileage_units)</p>
			<p class="source-code">    print("using car2: " + car2.c_mileage_units)</p>
			<p class="source-code">    print("using Class: " + Car.c_mileage_units)</p>
			<p>The console output of this <a id="_idIndexMarker258"/>program can be analyzed as<a id="_idIndexMarker259"/> follows: </p>
			<ol>
				<li value="1">The first set of <strong class="source-inline">print</strong> statements will output the default value of the class attribute, which is <strong class="source-inline">Mi</strong>.</li>
				<li>After executing the <strong class="source-inline">car1.c_mileage_units = "km"</strong> statement, the value of the class attribute will be the same (<strong class="source-inline">Mi</strong>) for the <strong class="source-inline">car2</strong> instance and the class-level attribute.</li>
				<li>After executing the <strong class="source-inline">Car.c_mileage_units = "NP"</strong> statement, the value of the class <a id="_idIndexMarker260"/>attribute for <strong class="source-inline">car2</strong> and the class level will<a id="_idIndexMarker261"/> change to <strong class="source-inline">NP,</strong> but it will stay the same (<strong class="source-inline">km</strong>) for <strong class="source-inline">car1</strong> as it was explicitly set by us.<p class="callout-heading">Important note</p><p class="callout">Attribute names start with <strong class="source-inline">c</strong> and <strong class="source-inline">i</strong> to indicate that they are class and instance variables, respectively, and not regular local or global variables. The name of non-public instance attributes must start with a single or double underscore to make them protected or private. This will be discussed later in the chapter.</p></li>
			</ol>
			<h2 id="_idParaDest-79"><a id="_idTextAnchor116"/>Using constructors and destructors with classes</h2>
			<p>As with any other OOP<a id="_idIndexMarker262"/> language, Python also has constructors and destructors, but the naming<a id="_idIndexMarker263"/> convention is different. The purpose of having constructors in a class is to initialize or assign values to the class- or instance-level attributes (mainly instance attributes) whenever an instance of a class is being created. In Python, the <strong class="source-inline">__init__</strong> method is known as the constructor and is always executed when a new instance is created. There are three types of constructors supported in Python, listed as follows:</p>
			<ul>
				<li><strong class="bold">Default constructor</strong>: When we do not include any constructor (the <strong class="source-inline">__init__</strong> method) in a class or <a id="_idIndexMarker264"/>forget to declare it, then that class will use a default constructor that is empty. The constructor does nothing other than initialize the instance of a class.</li>
				<li><strong class="bold">Non-parameterized constructor</strong>: This type<a id="_idIndexMarker265"/> of constructor does not take any arguments except a reference to the instance being created. The following code sample shows a non-parameterized constructor for a <strong class="source-inline">Name:</strong> class:<p class="source-code">class Name:</p><p class="source-code">    #non-parameterized constructor</p><p class="source-code">    <strong class="bold">def __init__(self)</strong>:</p><p class="source-code">        print("A new instance of Name class is \</p><p class="source-code">         created")</p><p>Since no arguments are passed with this constructor, we have limited functionality to add to it. For<a id="_idIndexMarker266"/> example, in our sample code, we sent a message to the console that a new instance has been created for the <strong class="source-inline">Name</strong> class</p></li>
				<li><strong class="bold">Parameterized constructor</strong>: A parametrized constructor can take one or more arguments, and the state of the<a id="_idIndexMarker267"/> instance can be set as per the input arguments provided through the constructor method. The <strong class="source-inline">Name</strong> class will be updated with a parameterized constructor, as follows:<p class="source-code">class Name:   </p><p class="source-code">    #parameterized constructor</p><p class="source-code">    <strong class="bold">def __init__(self, first, last):</strong></p><p class="source-code">        <strong class="bold">self.i_first = first</strong>    </p><p class="source-code">        <strong class="bold">self.i_last = last</strong></p></li>
			</ul>
			<p>Destructors are the opposite of constructors—they are executed when an instance is deleted or destroyed. In Python, destructors are hardly used because Python has a garbage collector that handles the deletion of the instances that are no longer referenced by any other instance or program. If we need to add logic inside a destructor method, we can implement it by using a special <strong class="source-inline">__del__</strong> method. It is automatically called when all references of an instance are deleted. Here is the syntax of how to define a destructor method in Python:</p>
			<p class="source-code">def __del__(self):</p>
			<p class="source-code">print("Object is deleted.")</p>
			<h2 id="_idParaDest-80"><a id="_idTextAnchor117"/>Distinguishing between class methods and instance methods</h2>
			<p>In Python, we can define three types of<a id="_idIndexMarker268"/> methods in a class, which are described next:</p>
			<ul>
				<li><strong class="bold">Instance methods</strong>: They are associated with an instance and need an instance to be created first before <a id="_idIndexMarker269"/>executing them. They accept the first attribute as a reference to the instance (<strong class="source-inline">self</strong>) and can read and update the state of the instance. <strong class="source-inline">__init__</strong>, which is a constructor method, is an example of an instance method.</li>
				<li><strong class="bold">Class methods</strong>: These methods are declared with the <strong class="source-inline">@classmethod</strong> decorator. These methods don't need a class instance for execution. For this method, the class reference (<strong class="source-inline">cls</strong> is used as a convention) will be automatically sent as the first argument.</li>
				<li><strong class="bold">Static methods</strong>: These methods<a id="_idIndexMarker270"/> are declared with the <strong class="source-inline">@staticmethod</strong> decorator. They don't have access to <strong class="source-inline">cls</strong> or <strong class="source-inline">self</strong> objects. Static methods are like utility functions that take certain arguments and provide the output based on the arguments' values—for example, if we need to evaluate certain input data or parse data for processing, we can write static methods to achieve these goals. Static methods work like regular functions that we define in modules but are available in the context of the class's namespace.</li>
			</ul>
			<p>To illustrate how these methods can be defined and then used in Python, we created a simple program, which is shown next:</p>
			<p class="source-code">#<strong class="bold">methodsexample1</strong>.py</p>
			<p class="source-code">class Car:</p>
			<p class="source-code">    c_mileage_units = "Mi"</p>
			<p class="source-code">    def __init__(self, color, miles):</p>
			<p class="source-code">        self.i_color = color</p>
			<p class="source-code">        self.i_mileage = miles</p>
			<p class="source-code">    <strong class="bold">def print_color (self):</strong></p>
			<p class="source-code">        print (f"Color of the car is {<strong class="bold">self.i_color</strong>}")</p>
			<p class="source-code">    <strong class="bold">@classmethod</strong></p>
			<p class="source-code">    <strong class="bold">def print_units(cls):</strong></p>
			<p class="source-code">        print (f"mileage unit are {<strong class="bold">cls.c_mileage_unit</strong>}")</p>
			<p class="source-code">        print(f"class name is {<strong class="bold">cls.__name__</strong>}")</p>
			<p class="source-code">    <strong class="bold">@staticmethod</strong></p>
			<p class="source-code">    <strong class="bold">def print_hello()</strong>:</p>
			<p class="source-code">        print ("Hello from a static method")</p>
			<p class="source-code">if __name__ == "__main__":</p>
			<p class="source-code">    car = Car ("blue", 1000)</p>
			<p class="source-code">    car.print_color()</p>
			<p class="source-code">    car.print_units()</p>
			<p class="source-code">    car.print_hello()</p>
			<p class="source-code">    Car.print_color(car);</p>
			<p class="source-code">    Car.print_units();</p>
			<p class="source-code">    Car.print_hello()</p>
			<p>In this program, we did the following:</p>
			<ol>
				<li value="1">We created a <strong class="source-inline">Car</strong> class with <a id="_idIndexMarker271"/>a class attribute (<strong class="source-inline">c_mileage_units</strong>), a class <a id="_idIndexMarker272"/>method (<strong class="source-inline">print_units</strong>), a static method (<strong class="source-inline">print_hello</strong>), instance attributes (<strong class="source-inline">i_color</strong> and <strong class="source-inline">i_mileage</strong>), an instance method (<strong class="source-inline">print_color</strong>), and a constructor method <strong class="source-inline">(__init__)</strong>.</li>
				<li>We created an instance of the <strong class="source-inline">Car</strong> class using its constructor as <strong class="source-inline">car</strong>.</li>
				<li>Using the instance variable (<strong class="source-inline">car</strong> in this example), we called the instance method, the class method, and the static method.</li>
				<li>Using the class<a id="_idIndexMarker273"/> name (<strong class="source-inline">Car</strong> in this example), we again triggered <a id="_idIndexMarker274"/>the instance method, the class method, and the static method. Note that we can trigger the instance method using the class name, but we need to pass the instance variable as a first argument (this also explains why we need the <strong class="source-inline">self</strong> argument for each instance method).</li>
			</ol>
			<p>The console output of this program is shown next for reference:</p>
			<p class="source-code">Color of the car is blue</p>
			<p class="source-code">mileage unit are Mi</p>
			<p class="source-code">class name is Car</p>
			<p class="source-code">Hello from a static method</p>
			<p class="source-code">Color of the car is blue</p>
			<p class="source-code">mileage unit are Mi</p>
			<p class="source-code">class name is Car</p>
			<p class="source-code">Hello from a static method</p>
			<h2 id="_idParaDest-81"><a id="_idTextAnchor118"/>Special methods</h2>
			<p>When we define a class <a id="_idIndexMarker275"/>in Python and try to print one of its instances using a <strong class="source-inline">print</strong> statement, we will get a string containing the class name and the reference of the object instance, which is the object's memory address. There is no default implementation of the <strong class="source-inline">to string</strong> functionality available with an instance or object. The code snippet showing this behavior is presented here:</p>
			<p class="source-code">#<strong class="bold">carexampl4.py</strong></p>
			<p class="source-code">class Car:</p>
			<p class="source-code">    def __init__(self, color, miles):</p>
			<p class="source-code">        self.i_color = color</p>
			<p class="source-code">        self.i_mileage = miles</p>
			<p class="source-code">if __name__ == "__main__":</p>
			<p class="source-code">    car = Car ("blue", 1000)</p>
			<p class="source-code">    <strong class="bold">print (car)</strong></p>
			<p>We will get console output similar to the <a id="_idIndexMarker276"/>following, which is not what is expected from a <strong class="source-inline">print</strong> statement:</p>
			<p class="source-code">&lt;__main__.Car object at 0x100caae80&gt;</p>
			<p>To get something meaningful from a <strong class="source-inline">print</strong> statement, we need to implement a special <strong class="source-inline">__str__</strong> method that will return a string with information about the instance and that can be customized as needed. Here is a code snippet showing the <strong class="source-inline">carexample4.py</strong> file with the <strong class="source-inline">__str__</strong> method: </p>
			<p class="source-code">#<strong class="bold">carexample4.py</strong></p>
			<p class="source-code">class Car:</p>
			<p class="source-code">    c_mileage_units = "Mi"</p>
			<p class="source-code">    def __init__(self, color, miles):</p>
			<p class="source-code">        self.i_color = color</p>
			<p class="source-code">        self.i_mileage = miles</p>
			<p class="source-code">    <strong class="bold">def __str__(self):</strong></p>
			<p class="source-code">        return f"car with color {self.i_color} and \</p>
			<p class="source-code">         mileage {self.i_mileage}"</p>
			<p class="source-code">if __name__ == "__main__":</p>
			<p class="source-code">    car = Car ("blue", 1000)</p>
			<p class="source-code">    <strong class="bold">print (car)</strong></p>
			<p>And the console output of the <strong class="source-inline">print</strong> statement is shown here:</p>
			<p class="source-code">car with color blue and mileage 1000</p>
			<p>With a proper <strong class="source-inline">__str__</strong> implementation, we can use a <strong class="source-inline">print</strong> statement without implementing special functions <a id="_idIndexMarker277"/>such as <strong class="source-inline">to_string()</strong>. It is the Pythonic way to control the string conversion. Another popular method used for similar reasons is <strong class="source-inline">__repr__</strong>, which is used by a Python interpreter for inspecting an object. The <strong class="source-inline">__repr__</strong> method is more for debugging purposes.</p>
			<p>These methods (and a few more) are <a id="_idIndexMarker278"/>called special methods or <strong class="bold">dunders</strong>, as they always start and end with double underscores. Normal methods should not use this convention. These methods are also known as magic <strong class="bold">methods</strong> in some literature, but it is not the <a id="_idIndexMarker279"/>official terminology. There are several dozen special methods available for implementation with a class. A comprehensive list of special methods is available with the official Python 3 documentation at https://docs.python.org/3/reference/datamodel.html#specialnames.</p>
			<p>We reviewed the classes and the objects with code examples in this section. In the next section, we will study different object-oriented principles available in Python.</p>
			<h1 id="_idParaDest-82"><a id="_idTextAnchor119"/>Understanding OOP principles</h1>
			<p>OOP is a way of bundling<a id="_idIndexMarker280"/> properties and behavior into a single entity, which we call objects. To make this bundling more efficient and modular, there are several principles available in Python, outlined as follows:</p>
			<ul>
				<li>Encapsulation of data</li>
				<li>Inheritance</li>
				<li>Polymorphism</li>
				<li>Abstraction</li>
			</ul>
			<p>In the next subsections, we will study each of these principles in detail.</p>
			<h2 id="_idParaDest-83"><a id="_idTextAnchor120"/>Encapsulation of data</h2>
			<p>Encapsulation is a fundamental concept in OOP and is also sometimes referred to as abstraction. But in reality, the encapsulation is <a id="_idIndexMarker281"/>more than the abstraction. In OOP, bundling of data and<a id="_idIndexMarker282"/> the actions associated with the data into a single unit is known as encapsulation. Encapsulation is <a id="_idIndexMarker283"/>actually more than just bundling data and the associated actions. We can enumerate three main objectives of encapsulation here, as follows:</p>
			<ul>
				<li>Encompass data and associated actions in a single unit.</li>
				<li>Hide the internal structure and implementation details of the object.</li>
				<li>Restrict access to certain components (attributes or methods) of the object.</li>
			</ul>
			<p>Encapsulation simplifies the use of the objects without knowing internal details on how it is implemented, and it also helps to control updates to the state of the object.</p>
			<p>In the next subsections, we will discuss these objectives in detail.</p>
			<h2 id="_idParaDest-84"><a id="_idTextAnchor121"/>Encompassing data and actions</h2>
			<p>To encompass data and<a id="_idIndexMarker284"/> actions in one init, we define attributes and methods in a class. A class in Python can have the following types of elements:</p>
			<ul>
				<li>Constructor and destructor</li>
				<li>Class methods and attributes</li>
				<li>Instance methods and attributes</li>
				<li><strong class="bold">Nested</strong> classes</li>
			</ul>
			<p>We have discussed these class elements already in the previous section, except nested or <strong class="bold">inner</strong> classes. We already<a id="_idIndexMarker285"/> provided the Python code examples to illustrate the implementation of constructors and destructors. We have used instance attributes to encapsulate data in our instances or objects. We have also discussed the class methods, static methods, and class attributes with code examples in the previous section.</p>
			<p>To complete the topic, we will discuss the following Python code snippet with a nested class. Let's take an example of our <strong class="source-inline">Car</strong> class and an <strong class="source-inline">Engine</strong> inner class within it. Every car needs an engine, so it <a id="_idIndexMarker286"/>makes sense to make it a nested or inner class:</p>
			<p class="source-code">#<strong class="bold">carwithinnerexample1.py</strong></p>
			<p class="source-code">class Car:</p>
			<p class="source-code">    """outer class"""</p>
			<p class="source-code">    c_mileage_units = "Mi"</p>
			<p class="source-code">    def __init__(self, color, miles, eng_size):</p>
			<p class="source-code">        self.i_color = color</p>
			<p class="source-code">        self.i_mileage = miles</p>
			<p class="source-code">        <strong class="bold">self.i_engine</strong> = <strong class="bold">self.Engine(eng_size)</strong></p>
			<p class="source-code">    def __str__(self):</p>
			<p class="source-code">        return f"car with color {self.i_color}, mileage \</p>
			<p class="source-code">        {self.i_mileage} and engine of {self.i_engine}"</p>
			<p class="source-code">    <strong class="bold">class Engine:</strong></p>
			<p class="source-code">        """inner class"""</p>
			<p class="source-code">        def __init__(self, size):</p>
			<p class="source-code">            self.i_size = size</p>
			<p class="source-code">        def __str__(self):</p>
			<p class="source-code">            return self.i_size</p>
			<p class="source-code">if __name__ == "__main__":</p>
			<p class="source-code">    car = Car ("blue", 1000, "2.5L")</p>
			<p class="source-code">    print(car)</p>
			<p class="source-code">    print(<strong class="bold">car.i_engine.i_size</strong>)</p>
			<p>In this example, we defined an <strong class="source-inline">Engine</strong> inner class inside our regular <strong class="source-inline">Car</strong> class. The <strong class="source-inline">Engine</strong> class has only one attribute—<strong class="source-inline">i_size</strong>, the constructor method (<strong class="source-inline">__init__)</strong>, and the <strong class="source-inline">__str__</strong> method. For the <strong class="source-inline">Car</strong> class, we updated<a id="_idIndexMarker287"/> the following as compared to our previous examples:</p>
			<ul>
				<li>The <strong class="source-inline">__init__</strong> method includes a new attribute for engine size, and a new line has been added to create a new instance of <strong class="source-inline">Engine</strong> associated with the <strong class="source-inline">Car</strong> instance.</li>
				<li>The <strong class="source-inline">__str__</strong> method of the <strong class="source-inline">Car</strong> class includes the <strong class="source-inline">i_size</strong> inner class attributes in it.</li>
			</ul>
			<p>The main program is using a <strong class="source-inline">print</strong> statement on the <strong class="source-inline">Car</strong> instance and also has a line to print the value of the <strong class="source-inline">i_size</strong> attribute of the <strong class="source-inline">Engine</strong> class. The console output of this program will be similar to what is shown here:</p>
			<p class="source-code">car with color blue, mileage 1000 and engine of 2.5L</p>
			<p class="source-code">2.5L</p>
			<p>The console output of the main program shows that we have access to the inner class from within the class implementation and we can access the inner class attributes from outside.</p>
			<p>In the next subsection, we will discuss how we can hide some of the attributes and methods to not be accessible or visible from outside the class.</p>
			<h2 id="_idParaDest-85"><a id="_idTextAnchor122"/>Hiding information</h2>
			<p>We have seen in our previous <a id="_idIndexMarker288"/>code examples that we have access to all class-level as well as instance-level attributes without any restrictions. Such an approach led us to a flat design, and the class will simply become a wrapper around the variables and methods. A better object-oriented design approach is to hide some of the instance attributes and make only the necessary attributes visible to the outside world. To discuss how this is achieved in Python, we introduce two terms: <strong class="bold">private</strong> and <strong class="bold">protected</strong>.</p>
			<h3>Private variables and methods</h3>
			<p>A private <strong class="bold">variable</strong> or attribute <a id="_idIndexMarker289"/>can be defined by using a double <em class="italic">underscore</em> as a prefix before a variable name. In Python, there is no keyword such as <em class="italic">private,</em> as we have in other programming languages. Both class and instance variables can be marked as private.</p>
			<p>A private <strong class="bold">method</strong> can also be <a id="_idIndexMarker290"/>defined by using a double <em class="italic">underscore</em> before a method name. A private method can only be called within the class and is not available outside the class.</p>
			<p>Whenever we define an attribute or a method as private, the Python interpreter doesn't allow access for such an attribute or a method outside of the class definition. The restriction also applies to subclasses; therefore, only the code within a class can access such attributes and methods. </p>
			<h3>Protected variables and methods</h3>
			<p>A <strong class="bold">protected</strong> variable or a method can be marked by adding a <em class="italic">single underscore</em> before the attribute name or the<a id="_idIndexMarker291"/> method name. A protected variable or method <em class="italic">should</em> be accessed or used by the code written within the class definition and within subclasses—for example, if we want to convert the <strong class="source-inline">i_color</strong> attribute from a public to a protected <a id="_idIndexMarker292"/>attribute, we just need to change its name to <strong class="source-inline">_i_color</strong>. The Python interpreter does not enforce this usage of the protected elements within a class or subclass. It is more to honor the naming convention and use or access the attribute or methods as per the definition of the protected variables and methods.</p>
			<p>By using private and protected variables and methods, we can hide some of the details of the implementation of an object. This is helpful, enabling us to have a tight and clean source code inside a large-sized class without exposing everything to the outside world. Another reason for hiding attributes is to control the way they can be accessed or updated. This is a topic for the next subsection. To conclude this section, we will discuss an updated version of our <strong class="source-inline">Car</strong> class with private and protected variables and a private method, which is shown next:</p>
			<p class="source-code">#<strong class="bold">carexample5.py</strong></p>
			<p class="source-code">class Car:</p>
			<p class="source-code">    c_mileage_units = "Mi"</p>
			<p class="source-code">    <strong class="bold">__max_speed = 200</strong></p>
			<p class="source-code">    def __init__(self, color, miles, model):</p>
			<p class="source-code">        self.i_color = color</p>
			<p class="source-code">        self.i_mileage = miles</p>
			<p class="source-code">        <strong class="bold">self.__no_doors = 4</strong></p>
			<p class="source-code">        <strong class="bold">self._model = model</strong></p>
			<p class="source-code">    def __str__(self):</p>
			<p class="source-code">        return f"car with color {self.i_color}, mileage           {self.i_mileage}, model {self._model} and doors             {self.__doors()}"</p>
			<p class="source-code">    <strong class="bold">def __doors(self)</strong>:</p>
			<p class="source-code">        return self.<strong class="bold">__no_doors</strong></p>
			<p class="source-code">if __name__ == "__main__":</p>
			<p class="source-code">    car = Car ("blue", 1000, "Camry")</p>
			<p class="source-code">    print (car)</p>
			<p>In this updated <strong class="source-inline">Car</strong> class, we <a id="_idIndexMarker293"/>have updated or added the following as per the previous example:</p>
			<ul>
				<li>A private <strong class="source-inline">__max_speed</strong> class<a id="_idIndexMarker294"/> variable with a default value</li>
				<li>A private <strong class="source-inline">__no_doors</strong> instance variable with a default value inside the <strong class="source-inline">__init__</strong> constructor method</li>
				<li>A <strong class="source-inline">_model</strong> protected instance variable, added for illustration purposes only</li>
				<li>A <strong class="source-inline">__doors()</strong> private instance method to get the number of doors</li>
				<li>The <strong class="source-inline">__str__</strong> method is updated to get the door by using the <strong class="source-inline">__doors()</strong> private method</li>
			</ul>
			<p>The console output of this<a id="_idIndexMarker295"/> program works as expected, but if we try to access any of the private methods or private variables from the main program, it is not available, and the<a id="_idIndexMarker296"/> Python interpreter will throw an error. This is as per the design, as the intended purpose of these private variables and private methods is to be only available within a class.</p>
			<p class="callout-heading">Important note</p>
			<p class="callout">Python does not really make the variables and methods private, but it pretends to make them private. Python actually mangles the variable names with the class name so that they are not easily visible outside the class that contains them.</p>
			<p>For the <strong class="source-inline">Car</strong> class example, we can access the private variables and private methods. Python provides access to these attributes and methods outside of the class definition with a different attribute name that is composed of a leading underscore, followed by the class name, and then a private attribute name. In the same way, we can access the private methods as well.</p>
			<p>The following lines of codes are valid but not encouraged and are against the definition of private and protected:</p>
			<p class="source-code">print (Car._Car__max_speed)    </p>
			<p class="source-code">print (car._Car__doors())</p>
			<p class="source-code">print (car._model)         </p>
			<p>As we can see, <strong class="source-inline">_Car</strong> is appended before the actual private variable name. This is done to minimize the conflicts with variables in inner classes as well.</p>
			<h2 id="_idParaDest-86"><a id="_idTextAnchor123"/>Protecting the data</h2>
			<p>We have seen in our<a id="_idIndexMarker297"/> previous code examples that we can access the instance attributes without any restrictions. We also implemented instance methods and we have no restriction on the use of these. We emulate to define them as private or protected, which works to hide the data and actions from the outside world.</p>
			<p>But in real-world problems, we need to provide access to the variables in a way that is controllable and easy to maintain. This is achieved in many object-oriented languages through <strong class="bold">access modifiers</strong> such as getters and setters, which are defined next:</p>
			<ul>
				<li><strong class="bold">Getters</strong>: These are methods used to access<a id="_idIndexMarker298"/> the private attributes from a <a id="_idIndexMarker299"/>class or its instance</li>
				<li><strong class="bold">Setters</strong>: These are methods <a id="_idIndexMarker300"/>used to set the private<a id="_idIndexMarker301"/> attributes of a class or its instance.</li>
			</ul>
			<p>Getters and setters methods can <a id="_idIndexMarker302"/>also be used to implement additional logic of accessing or setting the attributes, and it is convenient to maintain such an additional logic in one place. There are two ways to implement the getters and setters methods: a <em class="italic">traditional way</em> and a <em class="italic">decorative</em> way.</p>
			<h2 id="_idParaDest-87"><a id="_idTextAnchor124"/>Using traditional getters and setters</h2>
			<p>Traditionally, we write the instance <a id="_idIndexMarker303"/>methods with a <strong class="source-inline">get</strong> and <strong class="source-inline">set</strong> prefix, followed by the underscore and the variable name. We can transform our <strong class="source-inline">Car</strong> class to use the getter and setter methods for instance attributes, as follows:</p>
			<p class="source-code">#<strong class="bold">carexample6.py</strong></p>
			<p class="source-code">class Car:</p>
			<p class="source-code">    __mileage_units = "Mi"</p>
			<p class="source-code">    def __init__(self, col, mil):</p>
			<p class="source-code">        self.__color = col</p>
			<p class="source-code">        self.__mileage = mil</p>
			<p class="source-code">    def __str__(self):</p>
			<p class="source-code">        return f"car with color {self.get_color()} and \</p>
			<p class="source-code">         mileage {self.get_mileage()}"</p>
			<p class="source-code">    <strong class="bold">def get_color(self)</strong>:</p>
			<p class="source-code">        return self.__color</p>
			<p class="source-code">    <strong class="bold">def get_mileage(self)</strong>:</p>
			<p class="source-code">        return self.__mileage</p>
			<p class="source-code">    <strong class="bold">def set_mileage (self, new_mil)</strong>:</p>
			<p class="source-code">            self.__mileage = new_mil</p>
			<p class="source-code">if __name__ == "__main__":</p>
			<p class="source-code">    car = Car ("blue", 1000)</p>
			<p class="source-code">    print (car)</p>
			<p class="source-code">    print (<strong class="bold">car.get_color()</strong>)</p>
			<p class="source-code">    print(<strong class="bold">car.get_mileage</strong>())</p>
			<p class="source-code">    <strong class="bold">car.set_mileage</strong>(2000)</p>
			<p class="source-code">    print (<strong class="bold">car.get_color</strong>())</p>
			<p class="source-code">    print(<strong class="bold">car.get_mileage</strong>())</p>
			<p>In this updated <strong class="source-inline">Car</strong> class, we<a id="_idIndexMarker304"/> added the following:</p>
			<ul>
				<li><strong class="source-inline">color</strong> and <strong class="source-inline">mileage</strong> instance attributes were added as private variables.</li>
				<li>Getter methods for <strong class="source-inline">color</strong> and <strong class="source-inline">mileage</strong> instance attributes.</li>
				<li>A setter method only for the <strong class="source-inline">mileage</strong> attribute because <strong class="source-inline">color</strong> usually doesn't change once it is set at the time of object creation.</li>
				<li>In the main program, we get data for the newly created instance of the class using getter methods. Next, we updated the mileage using a setter method, and then we got data again for the <strong class="source-inline">color</strong> and <strong class="source-inline">mileage</strong> attributes.</li>
			</ul>
			<p>The console output of each statement in<a id="_idIndexMarker305"/> this example is trivial and as per expectations. As mentioned, we did not define a setter for each attribute, but only for those attributes where it makes sense and the design demands. Using getters and setters is a best practice in OOP, but they are not very popular in Python. The culture of Python developers (also known as the Pythonic way) is still to access attributes directly.</p>
			<h2 id="_idParaDest-88"><a id="_idTextAnchor125"/>Using property decorators</h2>
			<p>Using a <strong class="bold">decorator</strong> to define getters<a id="_idIndexMarker306"/> and setters is a modern approach that helps to achieve the Python way of programming.</p>
			<p>If you are into using decorators, then we have a <strong class="source-inline">@property</strong> decorator in Python to make the code simpler and cleaner. The <strong class="source-inline">Car</strong> class with traditional getters and setters is updated with decorators, and here is a code snippet showing this:</p>
			<p class="source-code">carexample7.py</p>
			<p class="source-code">class Car:</p>
			<p class="source-code">    __mileage_units = "Mi"</p>
			<p class="source-code">    def __init__(self, col, mil):</p>
			<p class="source-code">        self.__color = col</p>
			<p class="source-code">        self.__mileage = mil</p>
			<p class="source-code">    def __str__(self):</p>
			<p class="source-code">        return f"car with color {self.color} and mileage \</p>
			<p class="source-code">         {self.mileage}"</p>
			<p class="source-code">    <strong class="bold">@property</strong></p>
			<p class="source-code">    <strong class="bold">def color</strong>(self):</p>
			<p class="source-code">        return self.__color</p>
			<p class="source-code">    <strong class="bold">@property</strong></p>
			<p class="source-code">    <strong class="bold">def mileage</strong>(self):</p>
			<p class="source-code">        return self.__mileage</p>
			<p class="source-code">    <strong class="bold">@mileage.setter</strong></p>
			<p class="source-code">    <strong class="bold">def mileage</strong> (self, new_mil):</p>
			<p class="source-code">            self.__mileage = new_mil</p>
			<p class="source-code">if __name__ == "__main__":</p>
			<p class="source-code">    car = Car ("blue", 1000)</p>
			<p class="source-code">    print (car)</p>
			<p class="source-code">    print (<strong class="bold">car.color</strong>)</p>
			<p class="source-code">    print(<strong class="bold">car.mileage</strong>)</p>
			<p class="source-code">    <strong class="bold">car.mileage</strong> = 2000</p>
			<p class="source-code">    print (<strong class="bold">car.color</strong>)</p>
			<p class="source-code">    print(<strong class="bold">car.mileage</strong>)</p>
			<p>In this updated class<a id="_idIndexMarker307"/> definition, we updated or added the following:</p>
			<ul>
				<li>Instance attributes as private variables</li>
				<li>Getter methods for <strong class="source-inline">color</strong> and <strong class="source-inline">mileage</strong> by using the name of the attribute as the method name and using <strong class="source-inline">@property</strong></li>
				<li>Setter methods for <strong class="source-inline">mileage</strong> using the <strong class="source-inline">@mileage.setter</strong> decorator, giving the method the same name as the name of the attribute</li>
			</ul>
			<p>In the main script, we access the<a id="_idIndexMarker308"/> color and the mileage attributes by using the instance name followed by a dot and the attribute name (the Pythonic way). This makes the code syntax concise and readable. The use of decorators also makes the name of the methods simpler.</p>
			<p>In conclusion, we discussed all aspects of encapsulation in Python, using classes for the bundling of data and actions, hiding unnecessary information from the outside world of a class, and how to protect data in a class using getters, setters, and property features of Python. In the next section, we will discuss how inheritance is implemented in Python.</p>
			<h2 id="_idParaDest-89"><a id="_idTextAnchor126"/>Extending classes with inheritance</h2>
			<p>The concept<a id="_idIndexMarker309"/> of inheritance in OOP is similar to the concept of inheritance in the real world, where children inherit some of the characteristics from their parents on top of their own characteristics.</p>
			<p>Similarly, a class can inherit elements from another class. These elements include attributes and methods. The class from which we inherit another class is commonly known as a<a id="_idIndexMarker310"/> parent class, a <strong class="bold">superclass</strong>, or<a id="_idIndexMarker311"/> a <strong class="bold">base</strong> class. The class <a id="_idIndexMarker312"/>we inherit from another class is called a <strong class="bold">derived</strong> <strong class="bold">class</strong>, a <strong class="bold">child</strong> <strong class="bold">class</strong>, or a <strong class="bold">subclass</strong>. The following screenshot <a id="_idIndexMarker313"/>shows a simple relationship between a<a id="_idIndexMarker314"/> parent class and a child class:</p>
			<div>
				<div id="_idContainer028" class="IMG---Figure">
					<img src="image/B17189_03_01.jpg" alt="Figure 3.1 – Parent-and-child class relationship&#13;&#10;"/>
				</div>
			</div>
			<p class="figure-caption">Figure 3.1 – Parent-and-child class relationship</p>
			<p>In Python, when a class inherits from another class, it typically inherits all the elements that compose the parent class, but this can be controlled by using naming conventions (such as double underscore) and access modifiers.</p>
			<p>Inheritance can be of two types: <strong class="bold">simple</strong> or <strong class="bold">multiple</strong>. We will discuss these in the next sections.</p>
			<h2 id="_idParaDest-90"><a id="_idTextAnchor127"/>Simple inheritance</h2>
			<p>In simple or basic inheritance, a <a id="_idIndexMarker315"/>class is derived from a single parent. This<a id="_idIndexMarker316"/> is a commonly used inheritance form in OOP and is closer to the family tree of human beings. The syntax of a parent class and a child class using simple inheritance is shown next:</p>
			<p class="source-code">class <strong class="bold">BaseClass</strong>:</p>
			<p class="source-code">    &lt;attributes and methods of the base class &gt;</p>
			<p class="source-code">class <strong class="bold">ChildClass (BaseClass)</strong>:</p>
			<p class="source-code">    &lt;attributes and methods of the child class &gt;</p>
			<p>For this simple inheritance, we will modify our example of the <strong class="source-inline">Car</strong> class so that it is derived from a <strong class="source-inline">Vehicle</strong> parent class. We will also add a <strong class="source-inline">Truck</strong> child class to elaborate on the concept of inheritance. Here is the code with modifications:</p>
			<p class="source-code">#<strong class="bold">inheritance1.py</strong></p>
			<p class="source-code">class <strong class="bold">Vehicle</strong>:</p>
			<p class="source-code">    def __init__(self, color):</p>
			<p class="source-code">        self.i_color = color</p>
			<p class="source-code">    def print_vehicle_info(self):</p>
			<p class="source-code">        print(f"This is vehicle and I know my color is \</p>
			<p class="source-code">         {self.i_color}")</p>
			<p class="source-code">class <strong class="bold">Car (Vehicle)</strong>:</p>
			<p class="source-code">    def __init__(self, color, seats):</p>
			<p class="source-code">        self.i_color = color</p>
			<p class="source-code">        self.i_seats = seats</p>
			<p class="source-code">    def print_me(self):</p>
			<p class="source-code">        print( f"Car with color {self.i_color} and no of \</p>
			<p class="source-code">         seats {self.i_seats}")</p>
			<p class="source-code">class <strong class="bold">Truck (Vehicle)</strong>:</p>
			<p class="source-code">    def __init__(self, color, capacity):</p>
			<p class="source-code">        self.i_color = color</p>
			<p class="source-code">        self.i_capacity = capacity</p>
			<p class="source-code">    def print_me(self):</p>
			<p class="source-code">        print( f"Truck with color {self.i_color} and \</p>
			<p class="source-code">         loading capacity {self.i_capacity} tons")</p>
			<p class="source-code">if __name__ == "__main__":</p>
			<p class="source-code">    car = Car ("blue", 5)</p>
			<p class="source-code">    car.<strong class="bold">print_vehicle_info()</strong></p>
			<p class="source-code">    car.<strong class="bold">print_me()</strong></p>
			<p class="source-code">    truck = Truck("white", 1000)</p>
			<p class="source-code">    truck.<strong class="bold">print_vehicle_info()</strong></p>
			<p class="source-code">    truck.<strong class="bold">print_me()</strong></p>
			<p>In this example, we created a <strong class="source-inline">Vehicle</strong> parent class with one <strong class="source-inline">i_color</strong> attribute and one <strong class="source-inline">print_vehicle_info</strong> method. Both the<a id="_idIndexMarker317"/> elements are a candidate for inheritance. Next, we created two child classes, <strong class="source-inline">Car</strong> and <strong class="source-inline">Truck</strong>. Each child class has one additional attribute (<strong class="source-inline">i_seats</strong> and <strong class="source-inline">i_capacity</strong>) and one additional method (<strong class="source-inline">print_me</strong>). In the <strong class="source-inline">print_me</strong> methods in each child class, we access the parent <a id="_idIndexMarker318"/>class instance attribute as well as child class instance attributes.</p>
			<p>This design was intentional, to elaborate the idea of inheriting some elements from the parent class and adding some elements of its own in a child class. The two child classes are used in this example to demonstrate the role of inheritance toward reusability.</p>
			<p>In our main program, we created <strong class="source-inline">Car</strong> and <strong class="source-inline">Truck</strong> instances and tried to access the parent method as well as <a id="_idIndexMarker319"/>the instance method. The console output of this program is as expected and is shown next:</p>
			<p class="source-code">This is vehicle and I know my color is blue</p>
			<p class="source-code">Car with color blue and no of seats 5</p>
			<p class="source-code">This is vehicle and I know my color is white</p>
			<p class="source-code">Truck with color white and loading capacity 1000 tons </p>
			<h2 id="_idParaDest-91"><a id="_idTextAnchor128"/>Multiple inheritance</h2>
			<p>In multiple inheritance, a child class can <a id="_idIndexMarker320"/>be derived from multiple parents. The concept of multiple inheritance is applicable in advanced object-oriented designs<a id="_idIndexMarker321"/> where the objects have relationships with multiple objects, but we must be careful when inheriting from multiple classes, especially if those classes are inherited from a common superclass. This can lead us to problems such as the diamond problem. The diamond problem is a situation when we create an <strong class="source-inline">X</strong> class by inheriting from two classes, <strong class="source-inline">Y</strong> and <strong class="source-inline">Z</strong>, and the <strong class="source-inline">Y</strong> and <strong class="source-inline">Z</strong> classes are inherited from a common class, <strong class="source-inline">A</strong>. The <strong class="source-inline">X</strong> class will have ambiguity about the common code of the <strong class="source-inline">A</strong> class, which it inherits from classes <strong class="source-inline">Y</strong> and <strong class="source-inline">Z</strong>.  Multiple inheritance is not encouraged because of the possible issues it can bring with it.  </p>
			<p>To illustrate the concept, we will modify our <strong class="source-inline">Vehicle</strong> and <strong class="source-inline">Car</strong> classes and we will add an <strong class="source-inline">Engine</strong> class as one of the parents. The complete code with multiple inheritance of classes is shown in the following snippet:</p>
			<p class="source-code"> #<strong class="bold">inheritance2.py</strong></p>
			<p class="source-code">class Vehicle:</p>
			<p class="source-code">    def __init__(self, color):</p>
			<p class="source-code">        self.i_color = color</p>
			<p class="source-code">    def <strong class="bold">print_vehicle_info</strong>(self):</p>
			<p class="source-code">        print( f"This is vehicle and I know my color is \</p>
			<p class="source-code">         {self.i_color}")</p>
			<p class="source-code">class Engine:</p>
			<p class="source-code">    def __init__(self, size):</p>
			<p class="source-code">        self.i_size = size</p>
			<p class="source-code">    def <strong class="bold">print_engine_info</strong>(self):</p>
			<p class="source-code">        print(f"This is Engine and I know my size is \</p>
			<p class="source-code">         {self.i_size}")</p>
			<p class="source-code">class Car (Vehicle, Engine):</p>
			<p class="source-code">    def __init__(self, color, size, seat):</p>
			<p class="source-code">        self.i_color = color</p>
			<p class="source-code">        self.i_size = size</p>
			<p class="source-code">        self.i_seat = seat</p>
			<p class="source-code">    def <strong class="bold">print_car_info</strong>(self):</p>
			<p class="source-code">        print(f"This car of color {self.i_color} with \</p>
			<p class="source-code">         seats {self.i_seat} with engine of size \</p>
			<p class="source-code">         {self.i_size}")</p>
			<p class="source-code">if __name__ == "__main__":</p>
			<p class="source-code">    car = Car ("blue", "2.5L", 5 )</p>
			<p class="source-code">    <strong class="bold">car.print_vehicle_info()</strong></p>
			<p class="source-code">    <strong class="bold">car.print_engine_info()</strong></p>
			<p class="source-code">    <strong class="bold">car.print_car_info()</strong></p>
			<p>In this multiple inheritance example, we <a id="_idIndexMarker322"/>created two parent classes as a parent: <strong class="source-inline">Vehicle</strong> and <strong class="source-inline">Engine</strong>. The <strong class="source-inline">Vehicle</strong> parent class is the same as in<a id="_idIndexMarker323"/> the previous example. The <strong class="source-inline">Engine</strong> class has one attribute (<strong class="source-inline">i_size</strong>) and one method (<strong class="source-inline">print_engine_info</strong>). The <strong class="source-inline">Car</strong> class is derived from both <strong class="source-inline">Vehicle</strong> and <strong class="source-inline">Engine</strong> and adds one additional attribute (<strong class="source-inline">i_seats</strong>) and one additional method (<strong class="source-inline">print_car_info</strong>). In the instance method, we can access instance attributes of both parent classes.</p>
			<p>In the main program, we created an instance of the <strong class="source-inline">Car</strong> class. With this instance, we can access the instance methods of parent classes as well as child classes. The console output of the main program is shown here and is as expected:</p>
			<p class="source-code">This is vehicle and I know my color is blue</p>
			<p class="source-code">Car with color blue and no of seats 5</p>
			<p class="source-code">This is vehicle and I know my color is white</p>
			<p class="source-code">Truck with color white and loading capacity 1000 tons</p>
			<p>In this section, we introduced inheritance and its types as simple and multiple. Next, we will study the concept of polymorphism in Python.</p>
			<h1 id="_idParaDest-92"><a id="_idTextAnchor129"/>Polymorphism</h1>
			<p>In its literal meaning, a process<a id="_idIndexMarker324"/> of having multiple forms is called polymorphism. In OOP, <strong class="bold">polymorphism</strong> is the ability of an instance to behave in multiple ways and a way to use the same method with the same name and the same arguments, to behave differently in accordance with the class it belongs to.</p>
			<p>Polymorphism can be implemented in two ways: <strong class="bold">method overloading</strong> and <strong class="bold">method</strong> <strong class="bold">overriding</strong>. We will discuss each in the next subsections.</p>
			<h2 id="_idParaDest-93"><a id="_idTextAnchor130"/>Method overloading</h2>
			<p>Method overloading is a <a id="_idIndexMarker325"/>way to achieve polymorphism by having multiple methods with the same name, but with a different type or number of arguments. There is no<a id="_idIndexMarker326"/> clean way to implement method overloading in Python. Two methods cannot have the same name in Python. In Python, everything is an object, including classes and methods. When we write methods for a class, they are in fact attributes of a class from the namespace perspective and thus cannot have the same name. If we write two methods with the same name, there will be no syntax error, and the second one will simply replace the first one.</p>
			<p>Inside a class, a method can be overloaded by setting the default value to the arguments. This is not the perfect way of implementing method overloading, but it works. Here is an example of method overloading inside a class in Python:</p>
			<p class="source-code">#<strong class="bold">methodoverloading1.py</strong></p>
			<p class="source-code">class Car:</p>
			<p class="source-code">    def __init__(self, color, seats):</p>
			<p class="source-code">        self.i_color = color</p>
			<p class="source-code">        self.i_seat = seats</p>
			<p class="source-code">    def <strong class="bold">print_me(self, i='basic')</strong>:</p>
			<p class="source-code">        if(i =='basic'):</p>
			<p class="source-code">            print(f"This car is of color {self.i_color}")</p>
			<p class="source-code">        else:</p>
			<p class="source-code">            print(f"This car is of color {self.i_color} \</p>
			<p class="source-code">             with seats {self.i_seat}")</p>
			<p class="source-code">        </p>
			<p class="source-code">if __name__ == "__main__":</p>
			<p class="source-code">    car = Car("blue", 5 )</p>
			<p class="source-code">    car.<strong class="bold">print_me()</strong></p>
			<p class="source-code">    car.<strong class="bold">print_me('blah')</strong></p>
			<p class="source-code">    car.<strong class="bold">print_me('detail')</strong></p>
			<p>In this example, we add a <strong class="source-inline">print_me</strong> method with an argument that has a default value. The default value will be used when no parameter will be passed. When no parameter is passed to the <strong class="source-inline">print_me</strong> method, the console <a id="_idIndexMarker327"/>output will only provide the color of the <strong class="source-inline">Car</strong> instance. When an argument is passed to this method (regardless of the value), we have a <a id="_idIndexMarker328"/>different behavior of this method, which is providing both the color and the number of seats of the <strong class="source-inline">Car</strong> instance. Here is the console output of this program for reference:</p>
			<p class="source-code">This car is of color blue</p>
			<p class="source-code">This car is of color blue with seats 5</p>
			<p class="source-code">This car is of color blue with seats 5</p>
			<p class="callout-heading">Important note</p>
			<p class="callout">There are third-party libraries (for example, <strong class="source-inline">overload</strong>) available that can be used to implement method overloading in a cleaner way.</p>
			<h2 id="_idParaDest-94"><a id="_idTextAnchor131"/>Method overriding</h2>
			<p>Having the same method name in a<a id="_idIndexMarker329"/> child class as in a parent class is known as method overriding. The<a id="_idIndexMarker330"/> implementation of a method in a parent class and a child class is expected to be different. When we call an overriding method on an instance of a child class, the Python interpreter looks for the method in the child class definition, which is the overridden method. The interpreter executes the child class-level method. If the interpreter does not find a method at a child instance level, it looks for it in a parent class. If we have to specifically execute a method in a parent class that is overridden in a child class using the child class instance, we can use the <strong class="source-inline">super()</strong> method to access the parent class-level method. This is a more popular polymorphism concept in Python as it goes hand in hand with inheritance and is one of the powerful ways of implementing inheritance.</p>
			<p>To illustrate how to implement method overriding, we will update the <strong class="source-inline">inhertance1.py</strong> snippet by renaming the <strong class="source-inline">print_vehicle_info</strong> method name as <strong class="source-inline">print_me</strong>. As we know, <strong class="source-inline">print_me</strong> methods are already in the two child classes with different implementations. Here is the<a id="_idIndexMarker331"/> updated code with the changes highlighted:</p>
			<p class="source-code">#<strong class="bold">methodoverriding1.py</strong></p>
			<p class="source-code">class Vehicle:</p>
			<p class="source-code">    def __init__(self, color):</p>
			<p class="source-code">        self.i_color = color</p>
			<p class="source-code">    def <strong class="bold">print_me</strong>(self):</p>
			<p class="source-code">        print(f"This is vehicle and I know my color is \</p>
			<p class="source-code">         {self.i_color}")</p>
			<p class="source-code">class Car (Vehicle):</p>
			<p class="source-code">    def __init__(self, color, seats):</p>
			<p class="source-code">        self.i_color = color</p>
			<p class="source-code">        self.i_seats = seats</p>
			<p class="source-code">    def <strong class="bold">print_me</strong>(self):</p>
			<p class="source-code">        print( f"Car with color {self.i_color} and no of \</p>
			<p class="source-code">         seats {self.i_seats}")</p>
			<p class="source-code">class Truck (Vehicle):</p>
			<p class="source-code">    def __init__(self, color, capacity):</p>
			<p class="source-code">        self.i_color = color</p>
			<p class="source-code">        self.i_capacity = capacity</p>
			<p class="source-code">    def <strong class="bold">print_me</strong>(self):</p>
			<p class="source-code">        print( f"Truck with color {self.i_color} and \</p>
			<p class="source-code">         loading capacity {self.i_capacity} tons")</p>
			<p class="source-code">if __name__ == "__main__":</p>
			<p class="source-code">    vehicle = Vehicle("red")</p>
			<p class="source-code">    <strong class="bold">vehicle.print_me()</strong></p>
			<p class="source-code">    car = Car ("blue", 5)</p>
			<p class="source-code">    <strong class="bold">car.print_me()</strong></p>
			<p class="source-code">    truck = Truck("white", 1000)</p>
			<p class="source-code">    <strong class="bold">truck.print_me()</strong></p>
			<p>In this example, we override the <strong class="source-inline">print_me</strong> method in the child classes. When we create three different instances of <strong class="source-inline">Vehicle</strong>, <strong class="source-inline">Car</strong>, and <strong class="source-inline">Truck</strong> classes and execute the same method, we get <a id="_idIndexMarker332"/>different behavior. Here is the console output as a reference:</p>
			<p class="source-code">This is vehicle and I know my color is red</p>
			<p class="source-code">Car with color blue and no of seats 5</p>
			<p class="source-code">Truck with color white and loading capacity 1000 tons</p>
			<p>Method overriding has many practical applications in real-world problems—for example, we can inherit the built-in <strong class="source-inline">list</strong> class and can override its methods to add our functionality. Introducing a custom <em class="italic">sorting</em> approach is an example of method overriding for a <strong class="source-inline">list</strong> object. We will cover a few examples of method overriding in the next chapters.</p>
			<h2 id="_idParaDest-95"><a id="_idTextAnchor132"/>Abstraction</h2>
			<p>Abstraction is another powerful <a id="_idIndexMarker333"/>feature of OOP and is mainly related to hide the details of the implementation and show only the essential or high-level features of an object. A real-world example is a car that we derive with the main features available to us as a driver, without knowing the real details of how the feature works and which other objects are involved to provide these features.</p>
			<p>Abstraction is a concept that is related to encapsulation and inheritance together, and that is why we have kept this topic till the end to understand encapsulation and inheritance first. Another reason for having this as a separate topic is to emphasize the use of abstract classes in Python.</p>
			<h3>Abstract classes in Python</h3>
			<p>An abstract class <a id="_idIndexMarker334"/>acts like a blueprint for other classes. An <a id="_idIndexMarker335"/>abstract class allows you to create a set of abstract methods (empty) that are to be implemented by a child class. In simple terms, a class that contains one or more abstract methods is called an abstract <strong class="bold">class</strong>. On the other hand, an abstract <strong class="bold">method</strong> is one that only has a <a id="_idIndexMarker336"/>declaration but no implementation.</p>
			<p>There can be methods in an abstract class that are already implemented and that can be leveraged by a child class (<em class="italic">as is</em>) using inheritance. The concept of abstract classes is useful to implement common interfaces<a id="_idIndexMarker337"/> such as <strong class="bold">application programming interfaces</strong> (<strong class="bold">APIs</strong>) and also to define a common code base in one place that can be reused by child classes.</p>
			<p class="callout-heading">Tip</p>
			<p class="callout">Abstract classes cannot be instantiated.</p>
			<p>An abstract class can be <a id="_idIndexMarker338"/>implemented using a Python built-in module called <strong class="bold">Abstract Base Classes</strong> (<strong class="bold">ABC</strong>) from the <strong class="source-inline">abc</strong> package. The <strong class="source-inline">abc</strong> package also includes the <strong class="source-inline">Abstractmethod</strong> module, which utilizes decorators to declare the abstract methods. A simple Python example with the use of the <strong class="source-inline">ABC</strong> module and the <strong class="source-inline">abstractmethod</strong> decorator is shown next:</p>
			<p class="source-code">#<strong class="bold">abstraction1.py</strong></p>
			<p class="source-code"><strong class="bold">from abc import ABC, abstractmethod</strong></p>
			<p class="source-code">class <strong class="bold">Vehicle(ABC)</strong>:</p>
			<p class="source-code">    def hello(self):</p>
			<p class="source-code">        print(f"Hello from abstract class")</p>
			<p class="source-code">    <strong class="bold">@abstractmethod</strong></p>
			<p class="source-code">    def print_me(self):</p>
			<p class="source-code">       pass</p>
			<p class="source-code">class Car (Vehicle):</p>
			<p class="source-code">    def __init__(self, color, seats):</p>
			<p class="source-code">        self.i_color = color</p>
			<p class="source-code">        self.i_seats = seats</p>
			<p class="source-code">    </p>
			<p class="source-code">    """It is must to implemented this method"""</p>
			<p class="source-code">    def <strong class="bold">print_me</strong>(self):</p>
			<p class="source-code">        print( f"Car with color {self.i_color} and no of \</p>
			<p class="source-code">         seats {self.i_seats}")</p>
			<p class="source-code">if __name__ == "__main__":</p>
			<p class="source-code">   # vehicle = Vehicle()    #not possible</p>
			<p class="source-code">   # vehicle.hello()</p>
			<p class="source-code">    car = Car ("blue", 5)</p>
			<p class="source-code">    <strong class="bold">car.print_me()</strong></p>
			<p class="source-code">    car.hello()</p>
			<p>In this example, we did the following:</p>
			<ul>
				<li>We made the <strong class="source-inline">Vehicle</strong> class abstract by inheriting it from the <strong class="source-inline">ABC</strong> class and also by declaring one of the methods (<strong class="source-inline">print_me</strong>) as an abstract method. We used the <strong class="source-inline">@abstractmethod</strong> decorator to declare an abstract method.</li>
				<li>Next, we updated our famous <strong class="source-inline">Car</strong> class by implementing the <strong class="source-inline">print_me</strong> method in it and keeping the rest of the code the same as in the previous example.</li>
				<li>In the main part of the program, we attempted to create an instance of the <strong class="source-inline">Vehicle</strong> class (code commented in the illustration). We created an instance of the <strong class="source-inline">Car</strong> class and executed the <strong class="source-inline">print_me</strong> and <strong class="source-inline">hello</strong> methods.</li>
			</ul>
			<p>When we attempt to<a id="_idIndexMarker339"/> create an instance of the <strong class="source-inline">Vehicle</strong> class, it gives us an <a id="_idIndexMarker340"/>error like this:</p>
			<p class="source-code">Can't instantiate abstract class Vehicle with abstract methods print_me</p>
			<p>Also, if we try to not implement the <strong class="source-inline">print_me</strong> method in the <strong class="source-inline">Car</strong> child class, we get an error. For an instance of the <strong class="source-inline">Car</strong> class, we get the expected console output from the <strong class="source-inline">print_me</strong> and <strong class="source-inline">hello</strong> methods.</p>
			<h1 id="_idParaDest-96"><a id="_idTextAnchor133"/>Using composition as an alternative design approach</h1>
			<p>Composition is another popular <a id="_idIndexMarker341"/>concept in OOP that is again somewhat relevant to encapsulation. In simple words, composition means to include one or more objects inside an object to form a real-world object. A class that includes other <a id="_idIndexMarker342"/>class objects is called a <strong class="bold">composite</strong> class, and<a id="_idIndexMarker343"/> the classes whose objects are included in a composite class are known as <strong class="bold">component</strong> classes. In the<a id="_idIndexMarker344"/> following screenshot, we show an example of a composite class that has three component class objects, <strong class="bold">A</strong>, <strong class="bold">B</strong>, and <strong class="bold">C</strong>:</p>
			<div>
				<div id="_idContainer029" class="IMG---Figure">
					<img src="image/B17189_03_02.jpg" alt="Figure 3.2 – Relationship between a composite class and its component classes"/>
				</div>
			</div>
			<p class="figure-caption">Figure 3.2 – Relationship between a composite class and its component classes</p>
			<p>Composition is considered an alternative approach to inheritance. Both design approaches are meant to establish a relationship between objects. In the case of inheritance, the objects are tightly coupled because any changes in parent classes can break the code in child classes. On the other hand, the objects are loosely coupled in the case of composition, which facilitates changes in one class without breaking our code in another class. Because of the flexibility, the composition approach is quite popular, but this does not mean it is the<a id="_idIndexMarker345"/> right choice for every problem. How, then, can we determine which one to use for which problem? There is a rule of thumb for this. When we have an <em class="italic">is a</em> relationship between objects, inheritance is the right choice—for example, a car <em class="italic">is a</em> vehicle, and a cat <em class="italic">is an</em> animal. In the case of inheritance, a child class is an extension of a parent class, with additional functionality and the ability to reuse parent class functionality. If the relation between objects is that one object <em class="italic">has</em> another object, then it is better to use composition—for example, a car <em class="italic">has</em> a battery. </p>
			<p>We will take our previous example of the <strong class="source-inline">Car</strong> class and the <strong class="source-inline">Engine</strong> class. In the example code for multiple inheritance, we implemented the <strong class="source-inline">Car</strong> class as a child of the <strong class="source-inline">Engine</strong> class, which is not really a good use case of inheritance. It's time to use composition by implementing the <strong class="source-inline">Car</strong> class with the <strong class="source-inline">Engine</strong> object inside the <strong class="source-inline">Car</strong> class. We can have another class for <strong class="source-inline">Seat</strong> and we can include it inside the <strong class="source-inline">Car</strong> class as well.   </p>
			<p>We will illustrate this <a id="_idIndexMarker346"/>concept further in the following example, in which we build a <strong class="source-inline">Car</strong> class by including <strong class="source-inline">Engine</strong> and <strong class="source-inline">Seat</strong> classes in it:</p>
			<p class="source-code">#<strong class="bold">composition1.py</strong></p>
			<p class="source-code">class Seat:</p>
			<p class="source-code">    def __init__(self, type):</p>
			<p class="source-code">        self.i_type = type</p>
			<p class="source-code">    def __str__(self):</p>
			<p class="source-code">        return f"Seat type: {self.i_type}"</p>
			<p class="source-code">class Engine:</p>
			<p class="source-code">    def __init__(self, size):</p>
			<p class="source-code">        self.i_size = size</p>
			<p class="source-code">    def __str__(self):</p>
			<p class="source-code">        return f"Engine: {self.i_size}"</p>
			<p class="source-code">class Car:</p>
			<p class="source-code">    def __init__(self, color, eng_size, seat_type):</p>
			<p class="source-code">        self.i_color = color</p>
			<p class="source-code">        <strong class="bold">self.engine = Engine(eng_size)</strong></p>
			<p class="source-code">        <strong class="bold">self.seat = Seat(seat_type)</strong></p>
			<p class="source-code">    def print_me(self):</p>
			<p class="source-code">        print(f"This car of color {self.i_color} with \</p>
			<p class="source-code">         {self.engine} and {self.seat}")</p>
			<p class="source-code">if __name__ == "__main__":</p>
			<p class="source-code">    car = Car ("blue", "2.5L", "leather" )</p>
			<p class="source-code">    car.print_me()</p>
			<p class="source-code">    print(<strong class="bold">car.engine</strong>)</p>
			<p class="source-code">    print(<strong class="bold">car.seat</strong>)</p>
			<p class="source-code">    print(car.i_color)</p>
			<p class="source-code">    print(<strong class="bold">car.engine.i_size</strong>)</p>
			<p class="source-code">    print(<strong class="bold">car.seat.i_type</strong>)</p>
			<p>We can analyze this example <a id="_idIndexMarker347"/>code as follows:</p>
			<ol>
				<li value="1">We defined <strong class="source-inline">Engine</strong> and <strong class="source-inline">Seat</strong> classes with one attribute in each class: <strong class="source-inline">i_size</strong> for the <strong class="source-inline">Engine</strong> class and <strong class="source-inline">i_type</strong> for the <strong class="source-inline">Seat</strong> class.</li>
				<li>Later, we defined a <strong class="source-inline">Car</strong> class by adding the <strong class="source-inline">i_color</strong> attribute, an <strong class="source-inline">Engine</strong> instance, and a <strong class="source-inline">Seat</strong> instance in it. The <strong class="source-inline">Engine</strong> and <strong class="source-inline">Seat</strong> instances were created at the time of creating a <strong class="source-inline">Car</strong> instance.</li>
				<li>In this main program, we created an instance of <strong class="source-inline">Car</strong> and performed the following actions:<p>a) <strong class="source-inline">car.print_me</strong>: This accesses the <strong class="source-inline">print_me</strong> method on the <strong class="source-inline">Car</strong> instance.</p><p>b) <strong class="source-inline">print(car.engine</strong>): This executes the <strong class="source-inline">__str__</strong> method of the <strong class="source-inline">Engine</strong> class.</p><p>c) <strong class="source-inline">print(car.seat)</strong>: This executes the <strong class="source-inline">__str__</strong> method of the <strong class="source-inline">Seat</strong> class.</p><p>d) <strong class="source-inline">print(car.i_color)</strong>: This accesses the <strong class="source-inline">i_color</strong> attribute of the <strong class="source-inline">Car</strong> instance.</p><p>e) <strong class="source-inline">print(car.engine.i_size)</strong>: This accesses the <strong class="source-inline">i_size</strong> attribute of the <strong class="source-inline">Engine</strong> instance inside the <strong class="source-inline">Car</strong> instance.</p><p>f) <strong class="source-inline">print(car.seat.i_type)</strong>: This accesses the <strong class="source-inline">i_type</strong> attribute of the <strong class="source-inline">Seat</strong> instance inside the <strong class="source-inline">Car</strong> instance</p></li>
			</ol>
			<p>The console output<a id="_idIndexMarker348"/> of this program is shown here:</p>
			<p class="source-code">This car of color blue with Engine: 2.5L and Seat type: leather</p>
			<p class="source-code">Engine: 2.5L</p>
			<p class="source-code">Seat type: leather</p>
			<p class="source-code">blue</p>
			<p class="source-code">2.5L</p>
			<p class="source-code">leather</p>
			<p>Next, we will discuss duck typing, which is an alternative to polymorphism.</p>
			<h1 id="_idParaDest-97"><a id="_idTextAnchor134"/>Introducing duck typing in Python</h1>
			<p><strong class="bold">Duck typing</strong>, sometimes referred to as <strong class="bold">dynamic typing</strong>, is mostly adopted in programming<a id="_idIndexMarker349"/> languages that <a id="_idIndexMarker350"/>support dynamic typing, such as Python and JavaScript. The <a id="_idIndexMarker351"/>name <em class="italic">duck typing</em> is borrowed based on the following quote:</p>
			<p>"<em class="italic">If it looks like a duck, swims like a duck, and quacks like a duck, then it probably is a duck.</em>"</p>
			<p>This means that if a bird is behaving like a duck, it will likely be a duck. The point of mentioning this quote is that it is possible to identify an object by its behavior, which is the core principle of duck typing in Python.  </p>
			<p>In duck typing, the type of class of an object is less important than the method (behavior) it defines. Using duck typing, the types of the object are not checked, but the method that is expected is executed.</p>
			<p>To illustrate this concept, we take <a id="_idIndexMarker352"/>a simple example with three classes, <strong class="source-inline">Car</strong>, <strong class="source-inline">Cycle</strong>, and <strong class="source-inline">Horse</strong>, and we try to implement a <strong class="source-inline">start</strong> method in each of them. In the <strong class="source-inline">Horse</strong> class, instead<a id="_idIndexMarker353"/> of naming the method <strong class="source-inline">start</strong>, we call it <strong class="source-inline">push</strong>. Here is a code snippet with all three classes and the main program at the end:</p>
			<p class="source-code">#<strong class="bold">ducttype1.py</strong></p>
			<p class="source-code">class Car:</p>
			<p class="source-code">    def <strong class="bold">start</strong>(<strong class="bold">self</strong>):</p>
			<p class="source-code">        print ("start engine by ignition /battery")</p>
			<p class="source-code">class Cycle:</p>
			<p class="source-code">    def <strong class="bold">start</strong>(<strong class="bold">self</strong>):</p>
			<p class="source-code">        print ("start by pushing paddles")</p>
			<p class="source-code">class Horse:</p>
			<p class="source-code">    def <strong class="bold">push</strong>(<strong class="bold">self</strong>):</p>
			<p class="source-code">        print ("start by pulling/releasing the reins")</p>
			<p class="source-code">if __name__ == "__main__":</p>
			<p class="source-code">    for obj in Car(), Cycle(), Horse():</p>
			<p class="source-code">        <strong class="bold">obj.start()</strong></p>
			<p>In the main program, we try to iterate the instances of these classes dynamically and call the <strong class="source-inline">start</strong> method. As expected, the <strong class="source-inline">obj.start()</strong> line failed for the <strong class="source-inline">Horse</strong> object because the class does not have any such method. As we can see in this example, we can put different class or instance types in one statement and execute the methods across them. </p>
			<p>If we change the<a id="_idIndexMarker354"/> method named <strong class="source-inline">push</strong> to <strong class="source-inline">start</strong> inside the <strong class="source-inline">Horse</strong> class, the main program will execute without any error. Duck typing has many use cases, where it <a id="_idIndexMarker355"/>simplifies the solutions. Use of the <strong class="source-inline">len</strong> method in many objects and the use of iterators are a couple of many examples. We will explore iterators in detail in the next chapter.</p>
			<p>So far, we have reviewed different object-oriented concepts and principles and their benefits. In the next section, we will also discuss briefly when it is not very beneficial to use OOP.</p>
			<h1 id="_idParaDest-98"><a id="_idTextAnchor135"/>Learning when not to use OOP in Python</h1>
			<p>Python has the flexibility to <a id="_idIndexMarker356"/>develop programs using either OOP languages such as Java or using declarative programming such as C. OOP is always appealing to developers because it provides powerful tools such as encapsulation, abstraction, inheritance, and polymorphism, but these tools may not fit every<a id="_idIndexMarker357"/> scenario and use case. These tools are more beneficial when used to build a large and complex application, especially one that involves <strong class="bold">user interfaces</strong> (<strong class="bold">UIs</strong>) and user<a id="_idIndexMarker358"/> interactions.</p>
			<p>If your program is more like a script that has to execute certain tasks and there is no need to keep the state of objects, using OOP is overkill. Data science applications and intensive data processing are examples where it is less important to use OOP but more important to define how to execute tasks in a certain order to achieve goals. A real-world example is writing client programs for executing data-intensive jobs on a cluster of nodes, such as Apache Spark for parallel processing. We will cover these types of applications in later chapters. Here are a few more scenarios where using OOP is not necessary:</p>
			<ul>
				<li>Reading a file, applying logic, and writing back to a new file is a type of program that is easier to implement using functions in a module rather than using OOP.</li>
				<li>Configuring devices using Python is very popular and it is another candidate to be done using regular functions.</li>
				<li>Parsing and transforming data from one format to another format is also a use case that can be programmed by using declarative programming rather than OOP.</li>
				<li>Porting an old code base to a new one with OOP is not a good idea. We need to remember that the old code may not be built using OOP design patterns and we may end up with non-OOP functions wrapped in classes and objects that are hard to maintain and extend.</li>
			</ul>
			<p>In short, it is important to analyze the problem statement and requirements first before choosing whether to use OOP or not. It also depends on which third-party libraries you will be using with <a id="_idIndexMarker359"/>your program. If you are<a id="_idIndexMarker360"/> required to extend classes from third-party libraries, you will have to go along with OOP in that case.</p>
			<h1 id="_idParaDest-99"><a id="_idTextAnchor136"/>Summary</h1>
			<p>In this chapter, we learned the concept of classes and objects in Python and we also discussed how to build classes and use them to create objects and instances. Later, we deep-dived into the four pillars of OOP: encapsulation, inheritance, polymorphism, and abstraction. We also worked through simple and clear code examples to make it easier for readers to grasp the concepts of OOP. These four pillars are fundamental to using OOP in Python.</p>
			<p>In the later sections, we also covered duck typing, which is important for clarifying its non-dependency on classes, before ending the chapter by reviewing when it is not significantly beneficial to use OOP.</p>
			<p>By going through this chapter, you not only refreshed your knowledge of the main concepts of OOP but also learned how to apply the concepts using Python syntax. We will review a few Python libraries for advanced programming in the next chapter.</p>
			<h1 id="_idParaDest-100"><a id="_idTextAnchor137"/>Questions</h1>
			<ol>
				<li value="1">What are a class and an object?</li>
				<li>What are dunders?</li>
				<li>Does Python support inheriting a class from multiple classes?</li>
				<li>Can we create an instance of an abstract class?</li>
				<li>The type of a class is important in duct typing: true or false?</li>
			</ol>
			<h1 id="_idParaDest-101"><a id="_idTextAnchor138"/>Further reading</h1>
			<ul>
				<li><em class="italic">Modular Programming with Python</em>, by <em class="italic">Erik Westra</em></li>
				<li><em class="italic">Python 3 Object-Oriented Programming</em>, by <em class="italic">Dusty Phillips</em></li>
				<li><em class="italic">Learning Object-Oriented Programming</em>, by <em class="italic">Gaston C. Hillar</em></li>
				<li><em class="italic">Python for Everyone – Third edition</em>, by <em class="italic">Cay Horstmann</em> and <em class="italic">Rance Necaise</em></li>
			</ul>
			<h1 id="_idParaDest-102"><a id="_idTextAnchor139"/>Answers</h1>
			<ol>
				<li value="1">A class is a blueprint or a template to tell the Python interpreter how something needs to be defined. An object is an instance that is built from a class based on what is defined in that class.</li>
				<li>Dunders are special methods that always start and end with double underscores. There are a few dozen special methods available to be implemented with every class.</li>
				<li>Yes—Python supports inheriting a class from multiple classes.</li>
				<li>No—we can't create an instance of an abstract class.</li>
				<li>False. It is the methods that are more important than the class.</li>
			</ol>
		</div>
	</body></html>