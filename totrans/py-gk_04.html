<html><head></head><body>
		<div><p><a id="_idTextAnchor111"/></p>
			<h1 id="_idParaDest-75"><em class="italic"><a id="_idTextAnchor112"/>Chapter 3</em>: Advanced Object-Oriented Python Programming</h1>
			<p>Python can be used as a declarative modular programming language such as C, as well as being used for imperative programming or full <strong class="bold">object-oriented programming</strong> (<strong class="bold">OOP</strong>) with programming languages such as Java. <strong class="bold">Declarative programming</strong> is a paradigm in which we focus on what we want to implement, while <strong class="bold">imperative programming</strong> is where we describe the exact steps of how to implement what we want. Python is suitable for both types of programming paradigms. OOP is a form of imperative programming in which we bundle the properties and behaviors of real-world objects into programs. Moreover, OOP also addresses the relations between different types of real-world objects.</p>
			<p>In this chapter, we will explore how the advanced concepts of OOP can be implemented using Python. We are assuming that you are familiar with general concepts such as classes, objects, and instances and have basic knowledge of inheritance between objects. </p>
			<p>We will cover the following topics in this chapter:</p>
			<ul>
				<li>Introducing classes and objects</li>
				<li>Understanding OOP principles</li>
				<li>Using composition as an alternative design approach</li>
				<li>Introducing duck typing in Python</li>
				<li>Learning when not to use OOP in Python</li>
			</ul>
			<h1 id="_idParaDest-76"><a id="_idTextAnchor113"/>Technical requirements</h1>
			<p>These are the technical requirements for this chapter:</p>
			<ul>
				<li>You need to have Python 3.7 or later installed on your computer.</li>
				<li>The sample code for this chapter can be found at <a href="https://github.com/PacktPublishing/Python-for-Geeks/tree/master/Chapter03">https://github.com/PacktPublishing/Python-for-Geeks/tree/master/Chapter03</a>.</li>
			</ul>
			<h1 id="_idParaDest-77"><a id="_idTextAnchor114"/>Introducing classes and objects</h1>
			<p>A class is a blueprint for how <a id="_idIndexMarker249"/>something should be defined. It doesn't actually contain any data—it is a template that is used to create instances as per the specifications defined in a template or a blueprint.</p>
			<p>An object of a class is an<a id="_idIndexMarker250"/> instance that is built from a class, and that is why it is also called an instance of a class. For the rest of this chapter and this book, we will refer to <em class="italic">object</em> and <em class="italic">instance</em> synonymously. Objects<a id="_idIndexMarker251"/> in OOP are occasionally represented by physical objects such as tables, chairs, or books. On most occasions, the objects in a software program represent abstracted entities that may not be physical, such as accounts, names, addresses, and payments.</p>
			<p>To refresh ourselves with basic concepts of classes and objects, we will define these terminologies with code examples.</p>
			<h2 id="_idParaDest-78"><a id="_idTextAnchor115"/>Distinguishing between class attributes and instance attributes</h2>
			<p><strong class="bold">Class attributes</strong> are defined as <a id="_idIndexMarker252"/>part of the class definition, and their values are meant to be the same across all instances created from that class. The class attributes can be accessed using the class name or instance name, although it is<a id="_idIndexMarker253"/> recommended to use a class name to access these attributes (for reading or updating). The state or data of an object is provided by <strong class="bold">instance attributes</strong>.</p>
			<p>Defining a class in Python is simply done by using the <code>class</code> keyword. As discussed in <a href="B17189_01_Final_PG_ePub.xhtml#_idTextAnchor013"><em class="italic">Chapter 1</em></a>, <em class="italic">Optimal Python Development Life Cycle,</em> the name of the class should be CamelCase. The following code snippet creates a <code>Car</code> class:</p>
			<pre>#carexample1.py
class Car:
    pass</pre>
			<p>This class has no attributes and methods. It is an empty class, and you may think this class is useless until we add more components to it. Not exactly! In Python, you can add attributes on the fly without<a id="_idIndexMarker254"/> defining them in the class. The following<a id="_idIndexMarker255"/> snippet is a valid example of code in which we add attributes to a class instance at runtime:</p>
			<pre>#carexample1.py
class Car:
    pass
if __name__ == "__main__":
    car = Car ()
    car.color = "blue"
    car.miles = 1000
    print (car.color)
    print (car.miles)</pre>
			<p>In this extended example, we created an instance (<code>car</code>) of our <code>Car</code> class and then added two attributes to this instance: <code>color</code> and <code>miles</code>. Note that the attributes added using this approach are instance attributes.</p>
			<p>Next, we will add class attributes and instance attributes using a constructor method (<code>__init__</code>), which is loaded at the time of object creation. A code snippet with two instance attributes (<code>color</code> and <code>miles</code>) and the <code>init</code> method is shown next:</p>
			<pre>#carexample2.py
class Car:
    c_mileage_units = "Mi"
    def __init__(self, color, miles):
        self.i_color = color
        self.i_mileage = miles
if __name__ == "__main__":
    car1 = Car ("blue", 1000)
    print (car.i_color)
    print (car.i_mileage)
    print (car.c_mileage_units)
    print (Car.c_mileage_units)</pre>
			<p>In this program, we did the following:</p>
			<ol>
				<li>We created a <code>Car</code> class with a <code>c_mileage_units</code> class attribute and two instance variables, <code>i_color</code> and <code>i_mileage</code>.</li>
				<li>We created an instance (<code>car</code>) of the <code>Car</code> class.</li>
				<li>We printed out the instance attributes using the <code>car</code> instance variable.</li>
				<li>We printed out the<a id="_idIndexMarker256"/> class attribute using the <code>car</code> instance<a id="_idIndexMarker257"/> variable as well as the <code>Car</code> class name. The console output is the same for both cases.<p class="callout-heading">Important note</p><p class="callout"><code>self</code> is a reference to the instance that is being created. Use of <code>self</code> is common in Python to access the instance attributes and methods within the instance method, including the <code>init</code> method. <code>self</code> is not a keyword, and it is not mandatory to use the word <code>self</code>. It can be anything such as <code>this</code> or <code>blah</code>, except that it has to be the first parameter to the instance methods, but the convention of using <code>self</code> as the argument name is too strong.</p></li>
			</ol>
			<p>We can update the class attributes using an instance variable or class name, but the outcome can be different. When we update a class attribute using the class name, it is updated for all the instances of that class. But if we update a class attribute using an instance variable, it will be updated only for that particular instance. This is demonstrated in the following code snippet, which is using the <code>Car</code> class:</p>
			<pre>#<strong class="bold">carexample3.py</strong>
#class definition of Class Car is same as in carexample2.py
if __name__ == "__main__":
    car1 = Car ("blue", 1000)
    car2 = Car("red", 2000)
    print("using car1: " + car1.c_mileage_units)
    print("using car2: " + car2.c_mileage_units)
    print("using Class: " + Car.c_mileage_units)
    <strong class="bold">car1.c_mileage_units = "km"</strong>
    print("using car1: " + car1.c_mileage_units)
    print("using car2: " + car2.c_mileage_units)
    print("using Class: " + Car.c_mileage_units)
    <strong class="bold">Car.c_mileage_units = "NP"</strong>
    print("using car1: " + car1.c_mileage_units)
    print("using car2: " + car2.c_mileage_units)
    print("using Class: " + Car.c_mileage_units)</pre>
			<p>The console output of this <a id="_idIndexMarker258"/>program can be analyzed as<a id="_idIndexMarker259"/> follows: </p>
			<ol>
				<li value="1">The first set of <code>print</code> statements will output the default value of the class attribute, which is <code>Mi</code>.</li>
				<li>After executing the <code>car1.c_mileage_units = "km"</code> statement, the value of the class attribute will be the same (<code>Mi</code>) for the <code>car2</code> instance and the class-level attribute.</li>
				<li>After executing the <code>Car.c_mileage_units = "NP"</code> statement, the value of the class <a id="_idIndexMarker260"/>attribute for <code>car2</code> and the class level will<a id="_idIndexMarker261"/> change to <code>NP,</code> but it will stay the same (<code>km</code>) for <code>car1</code> as it was explicitly set by us.<p class="callout-heading">Important note</p><p class="callout">Attribute names start with <code>c</code> and <code>i</code> to indicate that they are class and instance variables, respectively, and not regular local or global variables. The name of non-public instance attributes must start with a single or double underscore to make them protected or private. This will be discussed later in the chapter.</p></li>
			</ol>
			<h2 id="_idParaDest-79"><a id="_idTextAnchor116"/>Using constructors and destructors with classes</h2>
			<p>As with any other OOP<a id="_idIndexMarker262"/> language, Python also has constructors and destructors, but the naming<a id="_idIndexMarker263"/> convention is different. The purpose of having constructors in a class is to initialize or assign values to the class- or instance-level attributes (mainly instance attributes) whenever an instance of a class is being created. In Python, the <code>__init__</code> method is known as the constructor and is always executed when a new instance is created. There are three types of constructors supported in Python, listed as follows:</p>
			<ul>
				<li><code>__init__</code> method) in a class or <a id="_idIndexMarker264"/>forget to declare it, then that class will use a default constructor that is empty. The constructor does nothing other than initialize the instance of a class.</li>
				<li><code>Name:</code> class:<pre>class Name:
    #non-parameterized constructor
    <code>Name</code> class</p></li>
				<li><code>Name</code> class will be updated with a parameterized constructor, as follows:<pre>class Name:   
    #parameterized constructor
    <strong class="bold">def __init__(self, first, last):</strong>
        <strong class="bold">self.i_first = first</strong>    
        <strong class="bold">self.i_last = last</strong></pre></li>
			</ul>
			<p>Destructors are the opposite of constructors—they are executed when an instance is deleted or destroyed. In Python, destructors are hardly used because Python has a garbage collector that handles the deletion of the instances that are no longer referenced by any other instance or program. If we need to add logic inside a destructor method, we can implement it by using a special <code>__del__</code> method. It is automatically called when all references of an instance are deleted. Here is the syntax of how to define a destructor method in Python:</p>
			<pre>def __del__(self):
print("Object is deleted.")</pre>
			<h2 id="_idParaDest-80"><a id="_idTextAnchor117"/>Distinguishing between class methods and instance methods</h2>
			<p>In Python, we can define three types of<a id="_idIndexMarker268"/> methods in a class, which are described next:</p>
			<ul>
				<li><code>self</code>) and can read and update the state of the instance. <code>__init__</code>, which is a constructor method, is an example of an instance method.</li>
				<li><code>@classmethod</code> decorator. These methods don't need a class instance for execution. For this method, the class reference (<code>cls</code> is used as a convention) will be automatically sent as the first argument.</li>
				<li><code>@staticmethod</code> decorator. They don't have access to <code>cls</code> or <code>self</code> objects. Static methods are like utility functions that take certain arguments and provide the output based on the arguments' values—for example, if we need to evaluate certain input data or parse data for processing, we can write static methods to achieve these goals. Static methods work like regular functions that we define in modules but are available in the context of the class's namespace.</li>
			</ul>
			<p>To illustrate how these methods can be defined and then used in Python, we created a simple program, which is shown next:</p>
			<pre>#<strong class="bold">methodsexample1</strong>.py
class Car:
    c_mileage_units = "Mi"
    def __init__(self, color, miles):
        self.i_color = color
        self.i_mileage = miles
    <strong class="bold">def print_color (self):</strong>
        print (f"Color of the car is {<strong class="bold">self.i_color</strong>}")
    <strong class="bold">@classmethod</strong>
    <strong class="bold">def print_units(cls):</strong>
        print (f"mileage unit are {<strong class="bold">cls.c_mileage_unit</strong>}")
        print(f"class name is {<strong class="bold">cls.__name__</strong>}")
    <strong class="bold">@staticmethod</strong>
    <strong class="bold">def print_hello()</strong>:
        print ("Hello from a static method")
if __name__ == "__main__":
    car = Car ("blue", 1000)
    car.print_color()
    car.print_units()
    car.print_hello()
    Car.print_color(car);
    Car.print_units();
    Car.print_hello()</pre>
			<p>In this program, we did the following:</p>
			<ol>
				<li value="1">We created a <code>Car</code> class with <a id="_idIndexMarker271"/>a class attribute (<code>c_mileage_units</code>), a class <a id="_idIndexMarker272"/>method (<code>print_units</code>), a static method (<code>print_hello</code>), instance attributes (<code>i_color</code> and <code>i_mileage</code>), an instance method (<code>print_color</code>), and a constructor method <code>(__init__)</code>.</li>
				<li>We created an instance of the <code>Car</code> class using its constructor as <code>car</code>.</li>
				<li>Using the instance variable (<code>car</code> in this example), we called the instance method, the class method, and the static method.</li>
				<li>Using the class<a id="_idIndexMarker273"/> name (<code>Car</code> in this example), we again triggered <a id="_idIndexMarker274"/>the instance method, the class method, and the static method. Note that we can trigger the instance method using the class name, but we need to pass the instance variable as a first argument (this also explains why we need the <code>self</code> argument for each instance method).</li>
			</ol>
			<p>The console output of this program is shown next for reference:</p>
			<pre>Color of the car is blue
mileage unit are Mi
class name is Car
Hello from a static method
Color of the car is blue
mileage unit are Mi
class name is Car
Hello from a static method</pre>
			<h2 id="_idParaDest-81"><a id="_idTextAnchor118"/>Special methods</h2>
			<p>When we define a class <a id="_idIndexMarker275"/>in Python and try to print one of its instances using a <code>print</code> statement, we will get a string containing the class name and the reference of the object instance, which is the object's memory address. There is no default implementation of the <code>to string</code> functionality available with an instance or object. The code snippet showing this behavior is presented here:</p>
			<pre>#<strong class="bold">carexampl4.py</strong>
class Car:
    def __init__(self, color, miles):
        self.i_color = color
        self.i_mileage = miles
if __name__ == "__main__":
    car = Car ("blue", 1000)
    <strong class="bold">print (car)</strong></pre>
			<p>We will get console output similar to the <a id="_idIndexMarker276"/>following, which is not what is expected from a <code>print</code> statement:</p>
			<pre>&lt;__main__.Car object at 0x100caae80&gt;</pre>
			<p>To get something meaningful from a <code>print</code> statement, we need to implement a special <code>__str__</code> method that will return a string with information about the instance and that can be customized as needed. Here is a code snippet showing the <code>carexample4.py</code> file with the <code>__str__</code> method: </p>
			<pre>#<strong class="bold">carexample4.py</strong>
class Car:
    c_mileage_units = "Mi"
    def __init__(self, color, miles):
        self.i_color = color
        self.i_mileage = miles
    <strong class="bold">def __str__(self):</strong>
        return f"car with color {self.i_color} and \
         mileage {self.i_mileage}"
if __name__ == "__main__":
    car = Car ("blue", 1000)
    <strong class="bold">print (car)</strong></pre>
			<p>And the console output of the <code>print</code> statement is shown here:</p>
			<pre>car with color blue and mileage 1000</pre>
			<p>With a proper <code>__str__</code> implementation, we can use a <code>print</code> statement without implementing special functions <a id="_idIndexMarker277"/>such as <code>to_string()</code>. It is the Pythonic way to control the string conversion. Another popular method used for similar reasons is <code>__repr__</code>, which is used by a Python interpreter for inspecting an object. The <code>__repr__</code> method is more for debugging purposes.</p>
			<p>These methods (and a few more) are <a id="_idIndexMarker278"/>called special methods or <strong class="bold">dunders</strong>, as they always start and end with double underscores. Normal methods should not use this convention. These methods are also known as magic <strong class="bold">methods</strong> in some literature, but it is not the <a id="_idIndexMarker279"/>official terminology. There are several dozen special methods available for implementation with a class. A comprehensive list of special methods is available with the official Python 3 documentation at https://docs.python.org/3/reference/datamodel.html#specialnames.</p>
			<p>We reviewed the classes and the objects with code examples in this section. In the next section, we will study different object-oriented principles available in Python.</p>
			<h1 id="_idParaDest-82"><a id="_idTextAnchor119"/>Understanding OOP principles</h1>
			<p>OOP is a way of bundling<a id="_idIndexMarker280"/> properties and behavior into a single entity, which we call objects. To make this bundling more efficient and modular, there are several principles available in Python, outlined as follows:</p>
			<ul>
				<li>Encapsulation of data</li>
				<li>Inheritance</li>
				<li>Polymorphism</li>
				<li>Abstraction</li>
			</ul>
			<p>In the next subsections, we will study each of these principles in detail.</p>
			<h2 id="_idParaDest-83"><a id="_idTextAnchor120"/>Encapsulation of data</h2>
			<p>Encapsulation is a fundamental concept in OOP and is also sometimes referred to as abstraction. But in reality, the encapsulation is <a id="_idIndexMarker281"/>more than the abstraction. In OOP, bundling of data and<a id="_idIndexMarker282"/> the actions associated with the data into a single unit is known as encapsulation. Encapsulation is <a id="_idIndexMarker283"/>actually more than just bundling data and the associated actions. We can enumerate three main objectives of encapsulation here, as follows:</p>
			<ul>
				<li>Encompass data and associated actions in a single unit.</li>
				<li>Hide the internal structure and implementation details of the object.</li>
				<li>Restrict access to certain components (attributes or methods) of the object.</li>
			</ul>
			<p>Encapsulation simplifies the use of the objects without knowing internal details on how it is implemented, and it also helps to control updates to the state of the object.</p>
			<p>In the next subsections, we will discuss these objectives in detail.</p>
			<h2 id="_idParaDest-84"><a id="_idTextAnchor121"/>Encompassing data and actions</h2>
			<p>To encompass data and<a id="_idIndexMarker284"/> actions in one init, we define attributes and methods in a class. A class in Python can have the following types of elements:</p>
			<ul>
				<li>Constructor and destructor</li>
				<li>Class methods and attributes</li>
				<li>Instance methods and attributes</li>
				<li><strong class="bold">Nested</strong> classes</li>
			</ul>
			<p>We have discussed these class elements already in the previous section, except nested or <strong class="bold">inner</strong> classes. We already<a id="_idIndexMarker285"/> provided the Python code examples to illustrate the implementation of constructors and destructors. We have used instance attributes to encapsulate data in our instances or objects. We have also discussed the class methods, static methods, and class attributes with code examples in the previous section.</p>
			<p>To complete the topic, we will discuss the following Python code snippet with a nested class. Let's take an example of our <code>Car</code> class and an <code>Engine</code> inner class within it. Every car needs an engine, so it <a id="_idIndexMarker286"/>makes sense to make it a nested or inner class:</p>
			<pre>#<strong class="bold">carwithinnerexample1.py</strong>
class Car:
    """outer class"""
    c_mileage_units = "Mi"
    def __init__(self, color, miles, eng_size):
        self.i_color = color
        self.i_mileage = miles
        <strong class="bold">self.i_engine</strong> = <strong class="bold">self.Engine(eng_size)</strong>
    def __str__(self):
        return f"car with color {self.i_color}, mileage \
        {self.i_mileage} and engine of {self.i_engine}"
    <strong class="bold">class Engine:</strong>
        """inner class"""
        def __init__(self, size):
            self.i_size = size
        def __str__(self):
            return self.i_size
if __name__ == "__main__":
    car = Car ("blue", 1000, "2.5L")
    print(car)
    print(<strong class="bold">car.i_engine.i_size</strong>)</pre>
			<p>In this example, we defined an <code>Engine</code> inner class inside our regular <code>Car</code> class. The <code>Engine</code> class has only one attribute—<code>i_size</code>, the constructor method (<code>__init__)</code>, and the <code>__str__</code> method. For the <code>Car</code> class, we updated<a id="_idIndexMarker287"/> the following as compared to our previous examples:</p>
			<ul>
				<li>The <code>__init__</code> method includes a new attribute for engine size, and a new line has been added to create a new instance of <code>Engine</code> associated with the <code>Car</code> instance.</li>
				<li>The <code>__str__</code> method of the <code>Car</code> class includes the <code>i_size</code> inner class attributes in it.</li>
			</ul>
			<p>The main program is using a <code>print</code> statement on the <code>Car</code> instance and also has a line to print the value of the <code>i_size</code> attribute of the <code>Engine</code> class. The console output of this program will be similar to what is shown here:</p>
			<pre>car with color blue, mileage 1000 and engine of 2.5L
2.5L</pre>
			<p>The console output of the main program shows that we have access to the inner class from within the class implementation and we can access the inner class attributes from outside.</p>
			<p>In the next subsection, we will discuss how we can hide some of the attributes and methods to not be accessible or visible from outside the class.</p>
			<h2 id="_idParaDest-85"><a id="_idTextAnchor122"/>Hiding information</h2>
			<p>We have seen in our previous <a id="_idIndexMarker288"/>code examples that we have access to all class-level as well as instance-level attributes without any restrictions. Such an approach led us to a flat design, and the class will simply become a wrapper around the variables and methods. A better object-oriented design approach is to hide some of the instance attributes and make only the necessary attributes visible to the outside world. To discuss how this is achieved in Python, we introduce two terms: <strong class="bold">private</strong> and <strong class="bold">protected</strong>.</p>
			<h3>Private variables and methods</h3>
			<p>A private <strong class="bold">variable</strong> or attribute <a id="_idIndexMarker289"/>can be defined by using a double <em class="italic">underscore</em> as a prefix before a variable name. In Python, there is no keyword such as <em class="italic">private,</em> as we have in other programming languages. Both class and instance variables can be marked as private.</p>
			<p>A private <strong class="bold">method</strong> can also be <a id="_idIndexMarker290"/>defined by using a double <em class="italic">underscore</em> before a method name. A private method can only be called within the class and is not available outside the class.</p>
			<p>Whenever we define an attribute or a method as private, the Python interpreter doesn't allow access for such an attribute or a method outside of the class definition. The restriction also applies to subclasses; therefore, only the code within a class can access such attributes and methods. </p>
			<h3>Protected variables and methods</h3>
			<p>A <code>i_color</code> attribute from a public to a protected <a id="_idIndexMarker292"/>attribute, we just need to change its name to <code>_i_color</code>. The Python interpreter does not enforce this usage of the protected elements within a class or subclass. It is more to honor the naming convention and use or access the attribute or methods as per the definition of the protected variables and methods.</p>
			<p>By using private and protected variables and methods, we can hide some of the details of the implementation of an object. This is helpful, enabling us to have a tight and clean source code inside a large-sized class without exposing everything to the outside world. Another reason for hiding attributes is to control the way they can be accessed or updated. This is a topic for the next subsection. To conclude this section, we will discuss an updated version of our <code>Car</code> class with private and protected variables and a private method, which is shown next:</p>
			<pre>#<strong class="bold">carexample5.py</strong>
class Car:
    c_mileage_units = "Mi"
    <strong class="bold">__max_speed = 200</strong>
    def __init__(self, color, miles, model):
        self.i_color = color
        self.i_mileage = miles
        <strong class="bold">self.__no_doors = 4</strong>
        <strong class="bold">self._model = model</strong>
    def __str__(self):
        return f"car with color {self.i_color}, mileage           {self.i_mileage}, model {self._model} and doors             {self.__doors()}"
    <strong class="bold">def __doors(self)</strong>:
        return self.<strong class="bold">__no_doors</strong>
if __name__ == "__main__":
    car = Car ("blue", 1000, "Camry")
    print (car)</pre>
			<p>In this updated <code>Car</code> class, we <a id="_idIndexMarker293"/>have updated or added the following as per the previous example:</p>
			<ul>
				<li>A private <code>__max_speed</code> class<a id="_idIndexMarker294"/> variable with a default value</li>
				<li>A private <code>__no_doors</code> instance variable with a default value inside the <code>__init__</code> constructor method</li>
				<li>A <code>_model</code> protected instance variable, added for illustration purposes only</li>
				<li>A <code>__doors()</code> private instance method to get the number of doors</li>
				<li>The <code>__str__</code> method is updated to get the door by using the <code>__doors()</code> private method</li>
			</ul>
			<p>The console output of this<a id="_idIndexMarker295"/> program works as expected, but if we try to access any of the private methods or private variables from the main program, it is not available, and the<a id="_idIndexMarker296"/> Python interpreter will throw an error. This is as per the design, as the intended purpose of these private variables and private methods is to be only available within a class.</p>
			<p class="callout-heading">Important note</p>
			<p class="callout">Python does not really make the variables and methods private, but it pretends to make them private. Python actually mangles the variable names with the class name so that they are not easily visible outside the class that contains them.</p>
			<p>For the <code>Car</code> class example, we can access the private variables and private methods. Python provides access to these attributes and methods outside of the class definition with a different attribute name that is composed of a leading underscore, followed by the class name, and then a private attribute name. In the same way, we can access the private methods as well.</p>
			<p>The following lines of codes are valid but not encouraged and are against the definition of private and protected:</p>
			<pre>print (Car._Car__max_speed)    
print (car._Car__doors())
print (car._model)         </pre>
			<p>As we can see, <code>_Car</code> is appended before the actual private variable name. This is done to minimize the conflicts with variables in inner classes as well.</p>
			<h2 id="_idParaDest-86"><a id="_idTextAnchor123"/>Protecting the data</h2>
			<p>We have seen in our<a id="_idIndexMarker297"/> previous code examples that we can access the instance attributes without any restrictions. We also implemented instance methods and we have no restriction on the use of these. We emulate to define them as private or protected, which works to hide the data and actions from the outside world.</p>
			<p>But in real-world problems, we need to provide access to the variables in a way that is controllable and easy to maintain. This is achieved in many object-oriented languages through <strong class="bold">access modifiers</strong> such as getters and setters, which are defined next:</p>
			<ul>
				<li><strong class="bold">Getters</strong>: These are methods used to access<a id="_idIndexMarker298"/> the private attributes from a <a id="_idIndexMarker299"/>class or its instance</li>
				<li><strong class="bold">Setters</strong>: These are methods <a id="_idIndexMarker300"/>used to set the private<a id="_idIndexMarker301"/> attributes of a class or its instance.</li>
			</ul>
			<p>Getters and setters methods can <a id="_idIndexMarker302"/>also be used to implement additional logic of accessing or setting the attributes, and it is convenient to maintain such an additional logic in one place. There are two ways to implement the getters and setters methods: a <em class="italic">traditional way</em> and a <em class="italic">decorative</em> way.</p>
			<h2 id="_idParaDest-87"><a id="_idTextAnchor124"/>Using traditional getters and setters</h2>
			<p>Traditionally, we write the instance <a id="_idIndexMarker303"/>methods with a <code>get</code> and <code>set</code> prefix, followed by the underscore and the variable name. We can transform our <code>Car</code> class to use the getter and setter methods for instance attributes, as follows:</p>
			<pre>#<strong class="bold">carexample6.py</strong>
class Car:
    __mileage_units = "Mi"
    def __init__(self, col, mil):
        self.__color = col
        self.__mileage = mil
    def __str__(self):
        return f"car with color {self.get_color()} and \
         mileage {self.get_mileage()}"
    <strong class="bold">def get_color(self)</strong>:
        return self.__color
    <strong class="bold">def get_mileage(self)</strong>:
        return self.__mileage
    <strong class="bold">def set_mileage (self, new_mil)</strong>:
            self.__mileage = new_mil
if __name__ == "__main__":
    car = Car ("blue", 1000)
    print (car)
    print (<strong class="bold">car.get_color()</strong>)
    print(<strong class="bold">car.get_mileage</strong>())
    <strong class="bold">car.set_mileage</strong>(2000)
    print (<strong class="bold">car.get_color</strong>())
    print(<strong class="bold">car.get_mileage</strong>())</pre>
			<p>In this updated <code>Car</code> class, we<a id="_idIndexMarker304"/> added the following:</p>
			<ul>
				<li><code>color</code> and <code>mileage</code> instance attributes were added as private variables.</li>
				<li>Getter methods for <code>color</code> and <code>mileage</code> instance attributes.</li>
				<li>A setter method only for the <code>mileage</code> attribute because <code>color</code> usually doesn't change once it is set at the time of object creation.</li>
				<li>In the main program, we get data for the newly created instance of the class using getter methods. Next, we updated the mileage using a setter method, and then we got data again for the <code>color</code> and <code>mileage</code> attributes.</li>
			</ul>
			<p>The console output of each statement in<a id="_idIndexMarker305"/> this example is trivial and as per expectations. As mentioned, we did not define a setter for each attribute, but only for those attributes where it makes sense and the design demands. Using getters and setters is a best practice in OOP, but they are not very popular in Python. The culture of Python developers (also known as the Pythonic way) is still to access attributes directly.</p>
			<h2 id="_idParaDest-88"><a id="_idTextAnchor125"/>Using property decorators</h2>
			<p>Using a <strong class="bold">decorator</strong> to define getters<a id="_idIndexMarker306"/> and setters is a modern approach that helps to achieve the Python way of programming.</p>
			<p>If you are into using decorators, then we have a <code>@property</code> decorator in Python to make the code simpler and cleaner. The <code>Car</code> class with traditional getters and setters is updated with decorators, and here is a code snippet showing this:</p>
			<pre>carexample7.py
class Car:
    __mileage_units = "Mi"
    def __init__(self, col, mil):
        self.__color = col
        self.__mileage = mil
    def __str__(self):
        return f"car with color {self.color} and mileage \
         {self.mileage}"
    <strong class="bold">@property</strong>
    <strong class="bold">def color</strong>(self):
        return self.__color
    <strong class="bold">@property</strong>
    <strong class="bold">def mileage</strong>(self):
        return self.__mileage
    <strong class="bold">@mileage.setter</strong>
    <strong class="bold">def mileage</strong> (self, new_mil):
            self.__mileage = new_mil
if __name__ == "__main__":
    car = Car ("blue", 1000)
    print (car)
    print (<strong class="bold">car.color</strong>)
    print(<strong class="bold">car.mileage</strong>)
    <strong class="bold">car.mileage</strong> = 2000
    print (<strong class="bold">car.color</strong>)
    print(<strong class="bold">car.mileage</strong>)</pre>
			<p>In this updated class<a id="_idIndexMarker307"/> definition, we updated or added the following:</p>
			<ul>
				<li>Instance attributes as private variables</li>
				<li>Getter methods for <code>color</code> and <code>mileage</code> by using the name of the attribute as the method name and using <code>@property</code></li>
				<li>Setter methods for <code>mileage</code> using the <code>@mileage.setter</code> decorator, giving the method the same name as the name of the attribute</li>
			</ul>
			<p>In the main script, we access the<a id="_idIndexMarker308"/> color and the mileage attributes by using the instance name followed by a dot and the attribute name (the Pythonic way). This makes the code syntax concise and readable. The use of decorators also makes the name of the methods simpler.</p>
			<p>In conclusion, we discussed all aspects of encapsulation in Python, using classes for the bundling of data and actions, hiding unnecessary information from the outside world of a class, and how to protect data in a class using getters, setters, and property features of Python. In the next section, we will discuss how inheritance is implemented in Python.</p>
			<h2 id="_idParaDest-89"><a id="_idTextAnchor126"/>Extending classes with inheritance</h2>
			<p>The concept<a id="_idIndexMarker309"/> of inheritance in OOP is similar to the concept of inheritance in the real world, where children inherit some of the characteristics from their parents on top of their own characteristics.</p>
			<p>Similarly, a class can inherit elements from another class. These elements include attributes and methods. The class from which we inherit another class is commonly known as a<a id="_idIndexMarker310"/> parent class, a <strong class="bold">superclass</strong>, or<a id="_idIndexMarker311"/> a <strong class="bold">base</strong> class. The class <a id="_idIndexMarker312"/>we inherit from another class is called a <strong class="bold">derived</strong> <strong class="bold">class</strong>, a <strong class="bold">child</strong> <strong class="bold">class</strong>, or a <strong class="bold">subclass</strong>. The following screenshot <a id="_idIndexMarker313"/>shows a simple relationship between a<a id="_idIndexMarker314"/> parent class and a child class:</p>
			<div><div><img src="img/B17189_03_01.jpg" alt="Figure 3.1 – Parent-and-child class relationship&#13;&#10;"/>
				</div>
			</div>
			<p class="figure-caption">Figure 3.1 – Parent-and-child class relationship</p>
			<p>In Python, when a class inherits from another class, it typically inherits all the elements that compose the parent class, but this can be controlled by using naming conventions (such as double underscore) and access modifiers.</p>
			<p>Inheritance can be of two types: <strong class="bold">simple</strong> or <strong class="bold">multiple</strong>. We will discuss these in the next sections.</p>
			<h2 id="_idParaDest-90"><a id="_idTextAnchor127"/>Simple inheritance</h2>
			<p>In simple or basic inheritance, a <a id="_idIndexMarker315"/>class is derived from a single parent. This<a id="_idIndexMarker316"/> is a commonly used inheritance form in OOP and is closer to the family tree of human beings. The syntax of a parent class and a child class using simple inheritance is shown next:</p>
			<pre>class <strong class="bold">BaseClass</strong>:
    &lt;attributes and methods of the base class &gt;
class <strong class="bold">ChildClass (BaseClass)</strong>:
    &lt;attributes and methods of the child class &gt;</pre>
			<p>For this simple inheritance, we will modify our example of the <code>Car</code> class so that it is derived from a <code>Vehicle</code> parent class. We will also add a <code>Truck</code> child class to elaborate on the concept of inheritance. Here is the code with modifications:</p>
			<pre>#<strong class="bold">inheritance1.py</strong>
class <strong class="bold">Vehicle</strong>:
    def __init__(self, color):
        self.i_color = color
    def print_vehicle_info(self):
        print(f"This is vehicle and I know my color is \
         {self.i_color}")
class <strong class="bold">Car (Vehicle)</strong>:
    def __init__(self, color, seats):
        self.i_color = color
        self.i_seats = seats
    def print_me(self):
        print( f"Car with color {self.i_color} and no of \
         seats {self.i_seats}")
class <strong class="bold">Truck (Vehicle)</strong>:
    def __init__(self, color, capacity):
        self.i_color = color
        self.i_capacity = capacity
    def print_me(self):
        print( f"Truck with color {self.i_color} and \
         loading capacity {self.i_capacity} tons")
if __name__ == "__main__":
    car = Car ("blue", 5)
    car.<strong class="bold">print_vehicle_info()</strong>
    car.<strong class="bold">print_me()</strong>
    truck = Truck("white", 1000)
    truck.<strong class="bold">print_vehicle_info()</strong>
    truck.<strong class="bold">print_me()</strong></pre>
			<p>In this example, we created a <code>Vehicle</code> parent class with one <code>i_color</code> attribute and one <code>print_vehicle_info</code> method. Both the<a id="_idIndexMarker317"/> elements are a candidate for inheritance. Next, we created two child classes, <code>Car</code> and <code>Truck</code>. Each child class has one additional attribute (<code>i_seats</code> and <code>i_capacity</code>) and one additional method (<code>print_me</code>). In the <code>print_me</code> methods in each child class, we access the parent <a id="_idIndexMarker318"/>class instance attribute as well as child class instance attributes.</p>
			<p>This design was intentional, to elaborate the idea of inheriting some elements from the parent class and adding some elements of its own in a child class. The two child classes are used in this example to demonstrate the role of inheritance toward reusability.</p>
			<p>In our main program, we created <code>Car</code> and <code>Truck</code> instances and tried to access the parent method as well as <a id="_idIndexMarker319"/>the instance method. The console output of this program is as expected and is shown next:</p>
			<pre>This is vehicle and I know my color is blue
Car with color blue and no of seats 5
This is vehicle and I know my color is white
Truck with color white and loading capacity 1000 tons </pre>
			<h2 id="_idParaDest-91"><a id="_idTextAnchor128"/>Multiple inheritance</h2>
			<p>In multiple inheritance, a child class can <a id="_idIndexMarker320"/>be derived from multiple parents. The concept of multiple inheritance is applicable in advanced object-oriented designs<a id="_idIndexMarker321"/> where the objects have relationships with multiple objects, but we must be careful when inheriting from multiple classes, especially if those classes are inherited from a common superclass. This can lead us to problems such as the diamond problem. The diamond problem is a situation when we create an <code>X</code> class by inheriting from two classes, <code>Y</code> and <code>Z</code>, and the <code>Y</code> and <code>Z</code> classes are inherited from a common class, <code>A</code>. The <code>X</code> class will have ambiguity about the common code of the <code>A</code> class, which it inherits from classes <code>Y</code> and <code>Z</code>.  Multiple inheritance is not encouraged because of the possible issues it can bring with it.  </p>
			<p>To illustrate the concept, we will modify our <code>Vehicle</code> and <code>Car</code> classes and we will add an <code>Engine</code> class as one of the parents. The complete code with multiple inheritance of classes is shown in the following snippet:</p>
			<pre> #<strong class="bold">inheritance2.py</strong>
class Vehicle:
    def __init__(self, color):
        self.i_color = color
    def <strong class="bold">print_vehicle_info</strong>(self):
        print( f"This is vehicle and I know my color is \
         {self.i_color}")
class Engine:
    def __init__(self, size):
        self.i_size = size
    def <strong class="bold">print_engine_info</strong>(self):
        print(f"This is Engine and I know my size is \
         {self.i_size}")
class Car (Vehicle, Engine):
    def __init__(self, color, size, seat):
        self.i_color = color
        self.i_size = size
        self.i_seat = seat
    def <strong class="bold">print_car_info</strong>(self):
        print(f"This car of color {self.i_color} with \
         seats {self.i_seat} with engine of size \
         {self.i_size}")
if __name__ == "__main__":
    car = Car ("blue", "2.5L", 5 )
    <strong class="bold">car.print_vehicle_info()</strong>
    <strong class="bold">car.print_engine_info()</strong>
    <strong class="bold">car.print_car_info()</strong></pre>
			<p>In this multiple inheritance example, we <a id="_idIndexMarker322"/>created two parent classes as a parent: <code>Vehicle</code> and <code>Engine</code>. The <code>Vehicle</code> parent class is the same as in<a id="_idIndexMarker323"/> the previous example. The <code>Engine</code> class has one attribute (<code>i_size</code>) and one method (<code>print_engine_info</code>). The <code>Car</code> class is derived from both <code>Vehicle</code> and <code>Engine</code> and adds one additional attribute (<code>i_seats</code>) and one additional method (<code>print_car_info</code>). In the instance method, we can access instance attributes of both parent classes.</p>
			<p>In the main program, we created an instance of the <code>Car</code> class. With this instance, we can access the instance methods of parent classes as well as child classes. The console output of the main program is shown here and is as expected:</p>
			<pre>This is vehicle and I know my color is blue
Car with color blue and no of seats 5
This is vehicle and I know my color is white
Truck with color white and loading capacity 1000 tons</pre>
			<p>In this section, we introduced inheritance and its types as simple and multiple. Next, we will study the concept of polymorphism in Python.</p>
			<h1 id="_idParaDest-92"><a id="_idTextAnchor129"/>Polymorphism</h1>
			<p>In its literal meaning, a process<a id="_idIndexMarker324"/> of having multiple forms is called polymorphism. In OOP, <strong class="bold">polymorphism</strong> is the ability of an instance to behave in multiple ways and a way to use the same method with the same name and the same arguments, to behave differently in accordance with the class it belongs to.</p>
			<p>Polymorphism can be implemented in two ways: <strong class="bold">method overloading</strong> and <strong class="bold">method</strong> <strong class="bold">overriding</strong>. We will discuss each in the next subsections.</p>
			<h2 id="_idParaDest-93"><a id="_idTextAnchor130"/>Method overloading</h2>
			<p>Method overloading is a <a id="_idIndexMarker325"/>way to achieve polymorphism by having multiple methods with the same name, but with a different type or number of arguments. There is no<a id="_idIndexMarker326"/> clean way to implement method overloading in Python. Two methods cannot have the same name in Python. In Python, everything is an object, including classes and methods. When we write methods for a class, they are in fact attributes of a class from the namespace perspective and thus cannot have the same name. If we write two methods with the same name, there will be no syntax error, and the second one will simply replace the first one.</p>
			<p>Inside a class, a method can be overloaded by setting the default value to the arguments. This is not the perfect way of implementing method overloading, but it works. Here is an example of method overloading inside a class in Python:</p>
			<pre>#<strong class="bold">methodoverloading1.py</strong>
class Car:
    def __init__(self, color, seats):
        self.i_color = color
        self.i_seat = seats
    def <strong class="bold">print_me(self, i='basic')</strong>:
        if(i =='basic'):
            print(f"This car is of color {self.i_color}")
        else:
            print(f"This car is of color {self.i_color} \
             with seats {self.i_seat}")
        
if __name__ == "__main__":
    car = Car("blue", 5 )
    car.<strong class="bold">print_me()</strong>
    car.<strong class="bold">print_me('blah')</strong>
    car.<strong class="bold">print_me('detail')</strong></pre>
			<p>In this example, we add a <code>print_me</code> method with an argument that has a default value. The default value will be used when no parameter will be passed. When no parameter is passed to the <code>print_me</code> method, the console <a id="_idIndexMarker327"/>output will only provide the color of the <code>Car</code> instance. When an argument is passed to this method (regardless of the value), we have a <a id="_idIndexMarker328"/>different behavior of this method, which is providing both the color and the number of seats of the <code>Car</code> instance. Here is the console output of this program for reference:</p>
			<pre>This car is of color blue
This car is of color blue with seats 5
This car is of color blue with seats 5</pre>
			<p class="callout-heading">Important note</p>
			<p class="callout">There are third-party libraries (for example, <code>overload</code>) available that can be used to implement method overloading in a cleaner way.</p>
			<h2 id="_idParaDest-94"><a id="_idTextAnchor131"/>Method overriding</h2>
			<p>Having the same method name in a<a id="_idIndexMarker329"/> child class as in a parent class is known as method overriding. The<a id="_idIndexMarker330"/> implementation of a method in a parent class and a child class is expected to be different. When we call an overriding method on an instance of a child class, the Python interpreter looks for the method in the child class definition, which is the overridden method. The interpreter executes the child class-level method. If the interpreter does not find a method at a child instance level, it looks for it in a parent class. If we have to specifically execute a method in a parent class that is overridden in a child class using the child class instance, we can use the <code>super()</code> method to access the parent class-level method. This is a more popular polymorphism concept in Python as it goes hand in hand with inheritance and is one of the powerful ways of implementing inheritance.</p>
			<p>To illustrate how to implement method overriding, we will update the <code>inhertance1.py</code> snippet by renaming the <code>print_vehicle_info</code> method name as <code>print_me</code>. As we know, <code>print_me</code> methods are already in the two child classes with different implementations. Here is the<a id="_idIndexMarker331"/> updated code with the changes highlighted:</p>
			<pre>#<strong class="bold">methodoverriding1.py</strong>
class Vehicle:
    def __init__(self, color):
        self.i_color = color
    def <strong class="bold">print_me</strong>(self):
        print(f"This is vehicle and I know my color is \
         {self.i_color}")
class Car (Vehicle):
    def __init__(self, color, seats):
        self.i_color = color
        self.i_seats = seats
    def <strong class="bold">print_me</strong>(self):
        print( f"Car with color {self.i_color} and no of \
         seats {self.i_seats}")
class Truck (Vehicle):
    def __init__(self, color, capacity):
        self.i_color = color
        self.i_capacity = capacity
    def <strong class="bold">print_me</strong>(self):
        print( f"Truck with color {self.i_color} and \
         loading capacity {self.i_capacity} tons")
if __name__ == "__main__":
    vehicle = Vehicle("red")
    <strong class="bold">vehicle.print_me()</strong>
    car = Car ("blue", 5)
    <strong class="bold">car.print_me()</strong>
    truck = Truck("white", 1000)
    <strong class="bold">truck.print_me()</strong></pre>
			<p>In this example, we override the <code>print_me</code> method in the child classes. When we create three different instances of <code>Vehicle</code>, <code>Car</code>, and <code>Truck</code> classes and execute the same method, we get <a id="_idIndexMarker332"/>different behavior. Here is the console output as a reference:</p>
			<pre>This is vehicle and I know my color is red
Car with color blue and no of seats 5
Truck with color white and loading capacity 1000 tons</pre>
			<p>Method overriding has many practical applications in real-world problems—for example, we can inherit the built-in <code>list</code> class and can override its methods to add our functionality. Introducing a custom <em class="italic">sorting</em> approach is an example of method overriding for a <code>list</code> object. We will cover a few examples of method overriding in the next chapters.</p>
			<h2 id="_idParaDest-95"><a id="_idTextAnchor132"/>Abstraction</h2>
			<p>Abstraction is another powerful <a id="_idIndexMarker333"/>feature of OOP and is mainly related to hide the details of the implementation and show only the essential or high-level features of an object. A real-world example is a car that we derive with the main features available to us as a driver, without knowing the real details of how the feature works and which other objects are involved to provide these features.</p>
			<p>Abstraction is a concept that is related to encapsulation and inheritance together, and that is why we have kept this topic till the end to understand encapsulation and inheritance first. Another reason for having this as a separate topic is to emphasize the use of abstract classes in Python.</p>
			<h3>Abstract classes in Python</h3>
			<p>An abstract class <a id="_idIndexMarker334"/>acts like a blueprint for other classes. An <a id="_idIndexMarker335"/>abstract class allows you to create a set of abstract methods (empty) that are to be implemented by a child class. In simple terms, a class that contains one or more abstract methods is called an abstract <strong class="bold">class</strong>. On the other hand, an abstract <strong class="bold">method</strong> is one that only has a <a id="_idIndexMarker336"/>declaration but no implementation.</p>
			<p>There can be methods in an abstract class that are already implemented and that can be leveraged by a child class (<em class="italic">as is</em>) using inheritance. The concept of abstract classes is useful to implement common interfaces<a id="_idIndexMarker337"/> such as <strong class="bold">application programming interfaces</strong> (<strong class="bold">APIs</strong>) and also to define a common code base in one place that can be reused by child classes.</p>
			<p class="callout-heading">Tip</p>
			<p class="callout">Abstract classes cannot be instantiated.</p>
			<p>An abstract class can be <a id="_idIndexMarker338"/>implemented using a Python built-in module called <code>abc</code> package. The <code>abc</code> package also includes the <code>Abstractmethod</code> module, which utilizes decorators to declare the abstract methods. A simple Python example with the use of the <code>ABC</code> module and the <code>abstractmethod</code> decorator is shown next:</p>
			<pre>#<strong class="bold">abstraction1.py</strong>
<strong class="bold">from abc import ABC, abstractmethod</strong>
class <strong class="bold">Vehicle(ABC)</strong>:
    def hello(self):
        print(f"Hello from abstract class")
    <strong class="bold">@abstractmethod</strong>
    def print_me(self):
       pass
class Car (Vehicle):
    def __init__(self, color, seats):
        self.i_color = color
        self.i_seats = seats
    
    """It is must to implemented this method"""
    def <strong class="bold">print_me</strong>(self):
        print( f"Car with color {self.i_color} and no of \
         seats {self.i_seats}")
if __name__ == "__main__":
   # vehicle = Vehicle()    #not possible
   # vehicle.hello()
    car = Car ("blue", 5)
    <strong class="bold">car.print_me()</strong>
    car.hello()</pre>
			<p>In this example, we did the following:</p>
			<ul>
				<li>We made the <code>Vehicle</code> class abstract by inheriting it from the <code>ABC</code> class and also by declaring one of the methods (<code>print_me</code>) as an abstract method. We used the <code>@abstractmethod</code> decorator to declare an abstract method.</li>
				<li>Next, we updated our famous <code>Car</code> class by implementing the <code>print_me</code> method in it and keeping the rest of the code the same as in the previous example.</li>
				<li>In the main part of the program, we attempted to create an instance of the <code>Vehicle</code> class (code commented in the illustration). We created an instance of the <code>Car</code> class and executed the <code>print_me</code> and <code>hello</code> methods.</li>
			</ul>
			<p>When we attempt to<a id="_idIndexMarker339"/> create an instance of the <code>Vehicle</code> class, it gives us an <a id="_idIndexMarker340"/>error like this:</p>
			<pre>Can't instantiate abstract class Vehicle with abstract methods print_me</pre>
			<p>Also, if we try to not implement the <code>print_me</code> method in the <code>Car</code> child class, we get an error. For an instance of the <code>Car</code> class, we get the expected console output from the <code>print_me</code> and <code>hello</code> methods.</p>
			<h1 id="_idParaDest-96"><a id="_idTextAnchor133"/>Using composition as an alternative design approach</h1>
			<p>Composition is another popular <a id="_idIndexMarker341"/>concept in OOP that is again somewhat relevant to encapsulation. In simple words, composition means to include one or more objects inside an object to form a real-world object. A class that includes other <a id="_idIndexMarker342"/>class objects is called a <strong class="bold">composite</strong> class, and<a id="_idIndexMarker343"/> the classes whose objects are included in a composite class are known as <strong class="bold">component</strong> classes. In the<a id="_idIndexMarker344"/> following screenshot, we show an example of a composite class that has three component class objects, <strong class="bold">A</strong>, <strong class="bold">B</strong>, and <strong class="bold">C</strong>:</p>
			<div><div><img src="img/B17189_03_02.jpg" alt="Figure 3.2 – Relationship between a composite class and its component classes"/>
				</div>
			</div>
			<p class="figure-caption">Figure 3.2 – Relationship between a composite class and its component classes</p>
			<p>Composition is considered an alternative approach to inheritance. Both design approaches are meant to establish a relationship between objects. In the case of inheritance, the objects are tightly coupled because any changes in parent classes can break the code in child classes. On the other hand, the objects are loosely coupled in the case of composition, which facilitates changes in one class without breaking our code in another class. Because of the flexibility, the composition approach is quite popular, but this does not mean it is the<a id="_idIndexMarker345"/> right choice for every problem. How, then, can we determine which one to use for which problem? There is a rule of thumb for this. When we have an <em class="italic">is a</em> relationship between objects, inheritance is the right choice—for example, a car <em class="italic">is a</em> vehicle, and a cat <em class="italic">is an</em> animal. In the case of inheritance, a child class is an extension of a parent class, with additional functionality and the ability to reuse parent class functionality. If the relation between objects is that one object <em class="italic">has</em> another object, then it is better to use composition—for example, a car <em class="italic">has</em> a battery. </p>
			<p>We will take our previous example of the <code>Car</code> class and the <code>Engine</code> class. In the example code for multiple inheritance, we implemented the <code>Car</code> class as a child of the <code>Engine</code> class, which is not really a good use case of inheritance. It's time to use composition by implementing the <code>Car</code> class with the <code>Engine</code> object inside the <code>Car</code> class. We can have another class for <code>Seat</code> and we can include it inside the <code>Car</code> class as well.   </p>
			<p>We will illustrate this <a id="_idIndexMarker346"/>concept further in the following example, in which we build a <code>Car</code> class by including <code>Engine</code> and <code>Seat</code> classes in it:</p>
			<pre>#<strong class="bold">composition1.py</strong>
class Seat:
    def __init__(self, type):
        self.i_type = type
    def __str__(self):
        return f"Seat type: {self.i_type}"
class Engine:
    def __init__(self, size):
        self.i_size = size
    def __str__(self):
        return f"Engine: {self.i_size}"
class Car:
    def __init__(self, color, eng_size, seat_type):
        self.i_color = color
        <strong class="bold">self.engine = Engine(eng_size)</strong>
        <strong class="bold">self.seat = Seat(seat_type)</strong>
    def print_me(self):
        print(f"This car of color {self.i_color} with \
         {self.engine} and {self.seat}")
if __name__ == "__main__":
    car = Car ("blue", "2.5L", "leather" )
    car.print_me()
    print(<strong class="bold">car.engine</strong>)
    print(<strong class="bold">car.seat</strong>)
    print(car.i_color)
    print(<strong class="bold">car.engine.i_size</strong>)
    print(<strong class="bold">car.seat.i_type</strong>)</pre>
			<p>We can analyze this example <a id="_idIndexMarker347"/>code as follows:</p>
			<ol>
				<li value="1">We defined <code>Engine</code> and <code>Seat</code> classes with one attribute in each class: <code>i_size</code> for the <code>Engine</code> class and <code>i_type</code> for the <code>Seat</code> class.</li>
				<li>Later, we defined a <code>Car</code> class by adding the <code>i_color</code> attribute, an <code>Engine</code> instance, and a <code>Seat</code> instance in it. The <code>Engine</code> and <code>Seat</code> instances were created at the time of creating a <code>Car</code> instance.</li>
				<li>In this main program, we created an instance of <code>Car</code> and performed the following actions:<p>a) <code>car.print_me</code>: This accesses the <code>print_me</code> method on the <code>Car</code> instance.</p><p>b) <code>print(car.engine</code>): This executes the <code>__str__</code> method of the <code>Engine</code> class.</p><p>c) <code>print(car.seat)</code>: This executes the <code>__str__</code> method of the <code>Seat</code> class.</p><p>d) <code>print(car.i_color)</code>: This accesses the <code>i_color</code> attribute of the <code>Car</code> instance.</p><p>e) <code>print(car.engine.i_size)</code>: This accesses the <code>i_size</code> attribute of the <code>Engine</code> instance inside the <code>Car</code> instance.</p><p>f) <code>print(car.seat.i_type)</code>: This accesses the <code>i_type</code> attribute of the <code>Seat</code> instance inside the <code>Car</code> instance</p></li>
			</ol>
			<p>The console output<a id="_idIndexMarker348"/> of this program is shown here:</p>
			<pre>This car of color blue with Engine: 2.5L and Seat type: leather
Engine: 2.5L
Seat type: leather
blue
2.5L
leather</pre>
			<p>Next, we will discuss duck typing, which is an alternative to polymorphism.</p>
			<h1 id="_idParaDest-97"><a id="_idTextAnchor134"/>Introducing duck typing in Python</h1>
			<p><strong class="bold">Duck typing</strong>, sometimes referred to as <strong class="bold">dynamic typing</strong>, is mostly adopted in programming<a id="_idIndexMarker349"/> languages that <a id="_idIndexMarker350"/>support dynamic typing, such as Python and JavaScript. The <a id="_idIndexMarker351"/>name <em class="italic">duck typing</em> is borrowed based on the following quote:</p>
			<p>"<em class="italic">If it looks like a duck, swims like a duck, and quacks like a duck, then it probably is a duck.</em>"</p>
			<p>This means that if a bird is behaving like a duck, it will likely be a duck. The point of mentioning this quote is that it is possible to identify an object by its behavior, which is the core principle of duck typing in Python.  </p>
			<p>In duck typing, the type of class of an object is less important than the method (behavior) it defines. Using duck typing, the types of the object are not checked, but the method that is expected is executed.</p>
			<p>To illustrate this concept, we take <a id="_idIndexMarker352"/>a simple example with three classes, <code>Car</code>, <code>Cycle</code>, and <code>Horse</code>, and we try to implement a <code>start</code> method in each of them. In the <code>Horse</code> class, instead<a id="_idIndexMarker353"/> of naming the method <code>start</code>, we call it <code>push</code>. Here is a code snippet with all three classes and the main program at the end:</p>
			<pre>#<strong class="bold">ducttype1.py</strong>
class Car:
    def <strong class="bold">start</strong>(<strong class="bold">self</strong>):
        print ("start engine by ignition /battery")
class Cycle:
    def <strong class="bold">start</strong>(<strong class="bold">self</strong>):
        print ("start by pushing paddles")
class Horse:
    def <strong class="bold">push</strong>(<strong class="bold">self</strong>):
        print ("start by pulling/releasing the reins")
if __name__ == "__main__":
    for obj in Car(), Cycle(), Horse():
        <strong class="bold">obj.start()</strong></pre>
			<p>In the main program, we try to iterate the instances of these classes dynamically and call the <code>start</code> method. As expected, the <code>obj.start()</code> line failed for the <code>Horse</code> object because the class does not have any such method. As we can see in this example, we can put different class or instance types in one statement and execute the methods across them. </p>
			<p>If we change the<a id="_idIndexMarker354"/> method named <code>push</code> to <code>start</code> inside the <code>Horse</code> class, the main program will execute without any error. Duck typing has many use cases, where it <a id="_idIndexMarker355"/>simplifies the solutions. Use of the <code>len</code> method in many objects and the use of iterators are a couple of many examples. We will explore iterators in detail in the next chapter.</p>
			<p>So far, we have reviewed different object-oriented concepts and principles and their benefits. In the next section, we will also discuss briefly when it is not very beneficial to use OOP.</p>
			<h1 id="_idParaDest-98"><a id="_idTextAnchor135"/>Learning when not to use OOP in Python</h1>
			<p>Python has the flexibility to <a id="_idIndexMarker356"/>develop programs using either OOP languages such as Java or using declarative programming such as C. OOP is always appealing to developers because it provides powerful tools such as encapsulation, abstraction, inheritance, and polymorphism, but these tools may not fit every<a id="_idIndexMarker357"/> scenario and use case. These tools are more beneficial when used to build a large and complex application, especially one that involves <strong class="bold">user interfaces</strong> (<strong class="bold">UIs</strong>) and user<a id="_idIndexMarker358"/> interactions.</p>
			<p>If your program is more like a script that has to execute certain tasks and there is no need to keep the state of objects, using OOP is overkill. Data science applications and intensive data processing are examples where it is less important to use OOP but more important to define how to execute tasks in a certain order to achieve goals. A real-world example is writing client programs for executing data-intensive jobs on a cluster of nodes, such as Apache Spark for parallel processing. We will cover these types of applications in later chapters. Here are a few more scenarios where using OOP is not necessary:</p>
			<ul>
				<li>Reading a file, applying logic, and writing back to a new file is a type of program that is easier to implement using functions in a module rather than using OOP.</li>
				<li>Configuring devices using Python is very popular and it is another candidate to be done using regular functions.</li>
				<li>Parsing and transforming data from one format to another format is also a use case that can be programmed by using declarative programming rather than OOP.</li>
				<li>Porting an old code base to a new one with OOP is not a good idea. We need to remember that the old code may not be built using OOP design patterns and we may end up with non-OOP functions wrapped in classes and objects that are hard to maintain and extend.</li>
			</ul>
			<p>In short, it is important to analyze the problem statement and requirements first before choosing whether to use OOP or not. It also depends on which third-party libraries you will be using with <a id="_idIndexMarker359"/>your program. If you are<a id="_idIndexMarker360"/> required to extend classes from third-party libraries, you will have to go along with OOP in that case.</p>
			<h1 id="_idParaDest-99"><a id="_idTextAnchor136"/>Summary</h1>
			<p>In this chapter, we learned the concept of classes and objects in Python and we also discussed how to build classes and use them to create objects and instances. Later, we deep-dived into the four pillars of OOP: encapsulation, inheritance, polymorphism, and abstraction. We also worked through simple and clear code examples to make it easier for readers to grasp the concepts of OOP. These four pillars are fundamental to using OOP in Python.</p>
			<p>In the later sections, we also covered duck typing, which is important for clarifying its non-dependency on classes, before ending the chapter by reviewing when it is not significantly beneficial to use OOP.</p>
			<p>By going through this chapter, you not only refreshed your knowledge of the main concepts of OOP but also learned how to apply the concepts using Python syntax. We will review a few Python libraries for advanced programming in the next chapter.</p>
			<h1 id="_idParaDest-100"><a id="_idTextAnchor137"/>Questions</h1>
			<ol>
				<li value="1">What are a class and an object?</li>
				<li>What are dunders?</li>
				<li>Does Python support inheriting a class from multiple classes?</li>
				<li>Can we create an instance of an abstract class?</li>
				<li>The type of a class is important in duct typing: true or false?</li>
			</ol>
			<h1 id="_idParaDest-101"><a id="_idTextAnchor138"/>Further reading</h1>
			<ul>
				<li><em class="italic">Modular Programming with Python</em>, by <em class="italic">Erik Westra</em></li>
				<li><em class="italic">Python 3 Object-Oriented Programming</em>, by <em class="italic">Dusty Phillips</em></li>
				<li><em class="italic">Learning Object-Oriented Programming</em>, by <em class="italic">Gaston C. Hillar</em></li>
				<li><em class="italic">Python for Everyone – Third edition</em>, by <em class="italic">Cay Horstmann</em> and <em class="italic">Rance Necaise</em></li>
			</ul>
			<h1 id="_idParaDest-102"><a id="_idTextAnchor139"/>Answers</h1>
			<ol>
				<li value="1">A class is a blueprint or a template to tell the Python interpreter how something needs to be defined. An object is an instance that is built from a class based on what is defined in that class.</li>
				<li>Dunders are special methods that always start and end with double underscores. There are a few dozen special methods available to be implemented with every class.</li>
				<li>Yes—Python supports inheriting a class from multiple classes.</li>
				<li>No—we can't create an instance of an abstract class.</li>
				<li>False. It is the methods that are more important than the class.</li>
			</ol>
		</div>
	</body></html>