<html><head></head><body>
<section id="chapter-12-decorator-design-techniques" class="level2 chapterHead" data-number="0.16">&#13;
<h2 class="chapterHead" data-number="0.16"><span class="titlemark"> 12</span><br/>&#13;
<span id="x1-25000012"/>Decorator Design Techniques</h2>&#13;
<p>Python offers us many ways to create higher-order functions. In <a href="Chapter_05.xhtml#x1-1000005"><span class="cmti-10x-x-109">Chapter</span><span class="cmti-10x-x-109"> 5</span></a>, <a href="Chapter_05.xhtml#x1-1000005"><span class="cmti-10x-x-109">Higher-Order Functions</span></a>, we looked at two techniques: defining a function that accepts a function as an argument, and defining a subclass of <span class="obeylines-h"><span class="verb"><code class="inlineCode">Callable</code></span></span>, which is either initialized with a function or called with a function as an argument.</p>&#13;
<p>One of the benefits of decorating functions is that it can create <span class="keyWord">composite</span> <span class="keyWord">functions</span>.<span id="dx1-250001"/> These are single functions that embody functionality from several sources. It’s often helpful to have the decoration syntax as a way to express complex processing.</p>&#13;
<p>We can also use decorators to identify classes or functions, often building<span id="dx1-250002"/> a <span class="keyWord">registry</span>—a collection of related definitions. We may not necessarily create a composite function when building a registry.</p>&#13;
<p>In this chapter, we’ll look at the following topics:</p>&#13;
<ul>&#13;
<li><p>Using a decorator<span id="dx1-250003"/> to build a function based on another function</p></li>&#13;
<li><p>The <span class="obeylines-h"><span class="verb"><code class="inlineCode">wraps()</code></span></span> function in the <span class="obeylines-h"><span class="verb"><code class="inlineCode">functools</code></span></span> module; this can help us build decorators</p></li>&#13;
<li><p>The <span class="obeylines-h"><span class="verb"><code class="inlineCode">update_wrapper()</code></span></span> function, which may be helpful in the rare case when we want access to the original function as well as the wrapped function</p></li>&#13;
</ul>&#13;
<p><span id="x1-250004r251"/></p>&#13;
<section id="decorators-as-higher-order-functions" class="level3 sectionHead" data-number="0.16.1">&#13;
<h3 class="sectionHead" data-number="0.16.1"><span class="titlemark">12.1 </span> <span id="x1-2510001"/>Decorators as higher-order functions</h3>&#13;
<p>The core idea of a decorator<span id="dx1-251001"/> is to transform some original function into a new function. Used like this, a decorator creates a composite function based on the decorator and the original function being decorated.</p>&#13;
<p>A decorator can be used in one of the two following ways:</p>&#13;
<ul>&#13;
<li><p>As a prefix that creates a new function with the same name as the base function, as follows:</p>&#13;
<pre id="listing-246" class="lstlisting"><code>@decorator &#13;
def base_function() -&gt; None: &#13;
    pass</code></pre></li>&#13;
<li><p>As an explicit operation that returns a new function, possibly with a new name:</p>&#13;
<pre id="listing-247" class="lstlisting"><code>def base_function() -&gt; None: &#13;
    pass &#13;
 &#13;
base_function = decorator(base_function)</code></pre></li>&#13;
</ul>&#13;
<p>These are two different syntaxes for the same operation. The prefix notation has the advantages of being tidy and succinct. The prefix location is also more visible to some readers. The suffix notation is explicit and slightly more flexible.</p>&#13;
<p>While the prefix notation is common, there is one reason for using the suffix notation: we may not want the resulting function to replace the original function. We may want to execute the following command, which allows us to use both the decorated and the undecorated functions:</p>&#13;
<pre id="listing-248" class="lstlisting"><code>new_function = decorator(base_function)</code></pre>&#13;
<p>This will build a new function, named <span class="obeylines-h"><span class="verb"><code class="inlineCode">new_function()</code></span></span>, from the original function. When using the <span class="obeylines-h"><span class="verb"><code class="inlineCode">@decorator</code></span></span> syntax, the original function is no longer available for use. Indeed, once the name is reassigned to a new function object, the original object may have no remaining references, and the memory it once occupied may be eligible for reclamation.</p>&#13;
<p>A decorator<span id="dx1-251010"/> is a function that accepts a function as an argument and returns a function as the result. This basic description is clearly a built-in feature of the language. Superficially, it may seem like we can update or adjust the internal code structure of a function.</p>&#13;
<p>Python doesn’t work by adjusting the internals of a function. Rather than messing about with the byte codes, Python uses a cleaner approach of defining a new function that wraps the original function. It’s easier to process the argument values or the result and leave the original function’s core processing alone.</p>&#13;
<p>We have two phases of higher-order functions involved in defining a decorator; they are as follows:</p>&#13;
<ul>&#13;
<li><p>At definition time, a decorator function applies a wrapper to a base function and returns the new, wrapped function. The decoration process can do some one-time-only evaluation as part of building the decorated function. Complex default values can be computed, for example.</p></li>&#13;
<li><p>At evaluation time, the wrapping function can (and usually does) evaluate the base function. The wrapping function can pre-process the argument values or post-process the return value (or do both). It’s also possible that the wrapping function may avoid calling the base function. In the case of managing a cache, for example, the primary reason for wrapping is to avoid expensive calls to the base function.</p></li>&#13;
</ul>&#13;
<p>Here’s an example of a decorator:</p>&#13;
<pre id="listing-249" class="lstlisting"><code>from collections.abc import Callable &#13;
from functools import wraps &#13;
 &#13;
def nullable(function: Callable[[float], float]) -&gt; Callable[[float | None], float | None]: &#13;
    @wraps(function) &#13;
    def null_wrapper(value: float | None) -&gt; float | None: &#13;
        return None if value is None else function(value) &#13;
    return null_wrapper</code></pre>&#13;
<p>We almost always want to use the <span class="obeylines-h"><span class="verb"><code class="inlineCode">@wraps</code></span></span> decorator<span id="dx1-251019"/> when creating our own decorators to ensure that the decorated function retains the attributes of the original function. Copying the <span class="obeylines-h"><span class="verb"><code class="inlineCode">__name__</code></span></span> and <span class="obeylines-h"><span class="verb"><code class="inlineCode">__doc__</code></span></span> attributes, for example, ensures that the resulting decorated function has the name and docstring of the original function.</p>&#13;
<p>The resulting composite<span id="dx1-251020"/> function, defined as the <span class="obeylines-h"><span class="verb"><code class="inlineCode">null_wrapper()</code></span></span> function in the definition of the decorator, is also a type of higher-order function that combines the original function, the <span class="obeylines-h"><span class="verb"><code class="inlineCode">function</code></span></span> callable object, in an expression that preserves the <span class="obeylines-h"><span class="verb"><code class="inlineCode">None</code></span></span> values. Within the resulting <span class="obeylines-h"><span class="verb"><code class="inlineCode">null_wrapper()</code></span></span> function, the original <span class="obeylines-h"><span class="verb"><code class="inlineCode">function</code></span></span> callable object is not an explicit argument; it is a free variable that will get its value from the context in which the <span class="obeylines-h"><span class="verb"><code class="inlineCode">null_wrapper()</code></span></span> function is defined.</p>&#13;
<p>The <span class="obeylines-h"><span class="verb"><code class="inlineCode">@nullable</code></span></span> decorator’s return value is the newly minted function. It will be assigned to the original function’s name. It’s important that decorators only return functions and they don’t attempt to process data. Decorators use meta-programming: code that creates more code. The resulting <span class="obeylines-h"><span class="verb"><code class="inlineCode">null_wrapper()</code></span></span> function is the function intended to process the application’s data.</p>&#13;
<div id="tcolobox-254" class="infobox note">&#13;
&#13;
&#13;
<p>The <span class="obeylines-h"><span class="verb"><code class="inlineCode">typing</code></span></span> module makes it particularly easy to describe the types of null-aware function and null-aware result, using the <span class="obeylines-h"><span class="verb"><code class="inlineCode">Optional</code></span></span> type definitions or the <span class="obeylines-h"><span class="verb"><code class="inlineCode">|</code></span></span> type operator. The definition <span class="obeylines-h"><span class="verb"><code class="inlineCode">float</code><code class="inlineCode"> |</code><code class="inlineCode"> None</code></span></span> or <span class="obeylines-h"><span class="verb"><code class="inlineCode">Optional[float]</code></span></span> means <span class="obeylines-h"><span class="verb"><code class="inlineCode">Union[float,</code><code class="inlineCode"> None]</code></span></span>; either a <span class="obeylines-h"><span class="verb"><code class="inlineCode">None</code></span></span> object or a <span class="obeylines-h"><span class="verb"><code class="inlineCode">float</code></span></span> object match the type hint’s description.</p>&#13;
&#13;
</div>&#13;
<p>As an example, we’ll assume we have a scaling function that converts input data from nautical miles to statute miles. This might be used with geolocation data that did calculations in nautical miles. The essential conversion from nautical miles, <span class="italic">n</span>, to statute miles, <span class="italic">s</span>, is a multiplication: <span class="italic">s </span>= 1<span class="italic">.</span>15078 <span class="cmsy-10x-x-109">× </span><span class="italic">n</span>.</p>&#13;
<p>We can apply our <span class="obeylines-h"><span class="verb"><code class="inlineCode">@nullable</code></span></span> decorator to create a composite function as follows:</p>&#13;
<pre id="listing-250" class="lstlisting"><code>import math &#13;
 &#13;
@nullable &#13;
def st_miles(nm: float) -&gt; float: &#13;
    return 1.15078 * nm</code></pre>&#13;
<p>This will create a function, <span class="obeylines-h"><span class="verb"><code class="inlineCode">st_miles()</code></span></span>, which is a null-aware version of a small mathematical operation. The decoration<span id="dx1-251026"/> process returns a version of the <span class="obeylines-h"><span class="verb"><code class="inlineCode">null_wrapper()</code></span></span> function that invokes the original <span class="obeylines-h"><span class="verb"><code class="inlineCode">st_miles()</code></span></span> function. This result will be named <span class="obeylines-h"><span class="verb"><code class="inlineCode">st_miles()</code></span></span> and will have the composite behavior of both the wrapper and the original base function.</p>&#13;
<p>We can use this composite <span class="obeylines-h"><span class="verb"><code class="inlineCode">st_miles()</code></span></span> function as follows:</p>&#13;
<div id="tcolobox-255" class="tcolorbox tcolorbox">&#13;
&#13;
&#13;
<pre class="lstinputlisting"><code>&gt;&gt;&gt; some_data = [8.7, 86.9, None, 43.4, 60] &#13;
&gt;&gt;&gt; scaled = map(st_miles, some_data) &#13;
&gt;&gt;&gt; list(scaled) &#13;
[10.011785999999999, 100.002782, None, 49.94385199999999, 69.04679999999999]</code></pre>&#13;
&#13;
</div>&#13;
<p>We’ve applied the function to a collection of data values. The <span class="obeylines-h"><span class="verb"><code class="inlineCode">None</code></span></span> value politely leads to a <span class="obeylines-h"><span class="verb"><code class="inlineCode">None</code></span></span> result. There was no exception processing involved.</p>&#13;
<p>As a second example, here’s how we can create a null-aware rounding function using the same decorator:</p>&#13;
<pre id="listing-251" class="lstlisting"><code>@nullable &#13;
def nround4(x: float) -&gt; float: &#13;
    return round(x, 4)</code></pre>&#13;
<p>This function<span id="dx1-251035"/> is a partial application of the <span class="obeylines-h"><span class="verb"><code class="inlineCode">round()</code></span></span> function, wrapped to be null-aware. We can use this <span class="obeylines-h"><span class="verb"><code class="inlineCode">nround4()</code></span></span> function to create a better test case for our <span class="obeylines-h"><span class="verb"><code class="inlineCode">st_miles()</code></span></span> function as follows:</p>&#13;
<div id="tcolobox-256" class="tcolorbox tcolorbox">&#13;
&#13;
&#13;
<pre class="lstinputlisting"><code>&gt;&gt;&gt; some_data = [8.7, 86.9, None, 43.4, 60] &#13;
&gt;&gt;&gt; scaled = map(st_miles, some_data) &#13;
&gt;&gt;&gt; [nround4(v) for v in scaled] &#13;
[10.0118, 100.0028, None, 49.9439, 69.0468]</code></pre>&#13;
&#13;
</div>&#13;
<p>This rounded result will be independent of any platform considerations. It’s very handy for <span class="obeylines-h"><span class="verb"><code class="inlineCode">doctest</code></span></span> testing.</p>&#13;
<p>As an alternative implementation, we could also create these null-aware functions using the following code:</p>&#13;
<pre id="listing-252" class="lstlisting"><code>st_miles_2: Callable[[float | None], float | None] = ( &#13;
    nullable(lambda nm: nm * 1.15078) &#13;
) &#13;
nround4_2: Callable[[float | None], float | None] = ( &#13;
    nullable(lambda x: round(x, 4)) &#13;
)</code></pre>&#13;
<p>We didn’t use the <span class="obeylines-h"><span class="verb"><code class="inlineCode">@nullable</code></span></span> decorator in front of the function definition <span class="obeylines-h"><span class="verb"><code class="inlineCode">def</code></span></span> statement. Instead, we applied the <span class="obeylines-h"><span class="verb"><code class="inlineCode">nullable()</code></span></span> function to another function defined as a lambda form. These expressions have the same effect as a decorator in front of a function definition.</p>&#13;
<div id="tcolobox-257" class="infobox note">&#13;
&#13;
&#13;
<p>Note how it is challenging to apply type hints to lambda forms. The variable <span class="obeylines-h"><span class="verb"><code class="inlineCode">nround4_2</code></span></span> is given a type hint of <span class="obeylines-h"><span class="verb"><code class="inlineCode">Callable</code></span></span> with an argument list of <span class="obeylines-h"><span class="verb"><code class="inlineCode">float</code><code class="inlineCode"> |</code><code class="inlineCode"> None</code></span></span> and a return type of <span class="obeylines-h"><span class="verb"><code class="inlineCode">float</code><code class="inlineCode"> |</code><code class="inlineCode"> None</code></span></span>. The use of the <span class="obeylines-h"><span class="verb"><code class="inlineCode">Callable</code></span></span> hint is appropriate only for positional arguments. In cases where there will be keyword arguments or other complexities, see <a href="https://mypy.readthedocs.io/en/stable/additional_features.html?highlight=callable#extended-callable-types" class="url">https://mypy.readthedocs.io/en/stable/additional_features.html?highlight=callable#extended-callable-types</a>.</p>&#13;
&#13;
</div>&#13;
<p>The <span class="obeylines-h"><span class="verb"><code class="inlineCode">@nullable</code></span></span> decorator<span id="dx1-251047"/> makes an assumption that the decorated function is unary. We would need to revisit this design to create a more general-purpose null-aware decorator that works with arbitrary collections of arguments.</p>&#13;
<p>In <a href="Chapter_13.xhtml#x1-26600013"><span class="cmti-10x-x-109">Chapter</span><span class="cmti-10x-x-109"> 13</span></a>, <a href="Chapter_13.xhtml#x1-26600013"><span class="cmti-10x-x-109">The PyMonad Library</span></a>, we’ll look at an alternative approach to this problem of tolerating the <span class="obeylines-h"><span class="verb"><code class="inlineCode">None</code></span></span> values. The PyMonad library defines a <span class="obeylines-h"><span class="verb"><code class="inlineCode">Maybe</code></span></span> class of objects, which may have a proper value or may be the <span class="obeylines-h"><span class="verb"><code class="inlineCode">None</code></span></span> value. <span id="x1-251048r257"/></p>&#13;
<section id="using-the-functools-update_wrapper-function" class="level4 subsectionHead" data-number="0.16.1.1">&#13;
<h4 class="subsectionHead" data-number="0.16.1.1"><span class="titlemark">12.1.1 </span> <span id="x1-2520001"/>Using the functools update_wrapper() function</h4>&#13;
<p>The <span class="obeylines-h"><span class="verb"><code class="inlineCode">@wraps</code></span></span> decorator applies the <span class="obeylines-h"><span class="verb"><code class="inlineCode">update_wrapper()</code></span></span> function<span id="dx1-252001"/> to preserve a few attributes of a wrapped function. In general, this does everything we need by default. This function copies a specific list of attributes from the original function to the resulting function created by a decorator.</p>&#13;
<p>The <span class="obeylines-h"><span class="verb"><code class="inlineCode">update_wrapper()</code></span></span> function relies on a global variable defined in the <span class="obeylines-h"><span class="verb"><code class="inlineCode">functools</code></span></span> module to determine what attributes to preserve. The <span class="obeylines-h"><span class="verb"><code class="inlineCode">WRAPPER_ASSIGNMENTS</code></span></span> variable defines the attributes that are copied by default. The default value is this list of attributes to copy:</p>&#13;
<div id="tcolobox-258" class="tcolorbox tcolorbox">&#13;
&#13;
&#13;
<pre class="lstinputlisting"><code>(’__module__’, ’__name__’, ’__qualname__’, ’__doc__’, &#13;
’__annotations__’)</code></pre>&#13;
&#13;
</div>&#13;
<p>It’s difficult to make meaningful modifications to this list. The internals of the <span class="obeylines-h"><span class="verb"><code class="inlineCode">def</code></span></span> statement aren’t open to simple modification or change. This detail is mostly interesting as a piece of reference information.</p>&#13;
<p>If we’re going to create callable objects, then we may have a class that provides some additional attributes as part of the definition. This could lead to a situation where a decorator must copy these additional attributes from the original wrapped callable object to the wrapping function being created. However, it seems simpler to make these kinds of changes through object-oriented class design, rather than exploit tricky decorator techniques. <span id="x1-252005r259"/></p>&#13;
</section>&#13;
</section>&#13;
<section id="cross-cutting-concerns" class="level3 sectionHead" data-number="0.16.2">&#13;
<h3 class="sectionHead" data-number="0.16.2"><span class="titlemark">12.2 </span> <span id="x1-2530002"/>Cross-cutting concerns</h3>&#13;
<p>One general principle<span id="dx1-253001"/> behind decorators is to allow us to build a composite function from the decorator and the original function to which the decorator is applied. The idea is to have a library of common decorators that can provide implementations for common concerns.</p>&#13;
<p>We often call these <span class="cmti-10x-x-109">cross-cutting </span>concerns because they apply across several functions. These are the sorts of things that we would like to design once through a decorator and have them applied in relevant classes throughout an application or a framework.</p>&#13;
<p>Concerns that are often centralized as decorator definitions include the following:</p>&#13;
<ul>&#13;
<li><p>Logging</p></li>&#13;
<li><p>Auditing</p></li>&#13;
<li><p>Security</p></li>&#13;
<li><p>Handling incomplete data</p></li>&#13;
</ul>&#13;
<p>A logging decorator, for example, may write standardized messages to the application’s log file. An audit decorator may write details surrounding a database update. A security decorator may check some runtime context to be sure that the login user has the necessary permissions.</p>&#13;
<p>Our example of a <span class="cmti-10x-x-109">null-aware </span>wrapper for a function is a cross-cutting concern. In this case, we’d like to have a number of functions handle the <span class="obeylines-h"><span class="verb"><code class="inlineCode">None</code></span></span> values by returning the <span class="obeylines-h"><span class="verb"><code class="inlineCode">None</code></span></span> values instead of raising an exception. In applications where data is incomplete, we may need to process rows in a simple, uniform way without having to write lots of distracting <span class="obeylines-h"><span class="verb"><code class="inlineCode">if</code></span></span> statements to handle missing values. <span id="x1-253002r261"/></p>&#13;
</section>&#13;
<section id="composite-design" class="level3 sectionHead" data-number="0.16.3">&#13;
<h3 class="sectionHead" data-number="0.16.3"><span class="titlemark">12.3 </span> <span id="x1-2540003"/>Composite design</h3>&#13;
<p>The common mathematical<span id="dx1-254001"/> notation for a composite function looks as follows:</p>&#13;
<div class="math-display" style="text-align:center">&#13;
<img src="../Images/file111.jpg" class="math-display" alt="f ∘g(x) = f(g(x)) "/>&#13;
</div>&#13;
<p>The idea is that we can define a new function, <span class="italic">f </span><span class="cmsy-10x-x-109">∘</span><span class="italic">g</span>(<span class="italic">x</span>), that combines two other functions, <span class="italic">f</span>(<span class="italic">y</span>) and <span class="italic">g</span>(<span class="italic">x</span>).</p>&#13;
<p>Python’s multiple-line definition of a composition function can be done through the following code:</p>&#13;
<pre id="listing-253" class="lstlisting"><code>@f_deco &#13;
def g(x): &#13;
    something</code></pre>&#13;
<p>The resulting function can be essentially equivalent to <span class="italic">f </span><span class="cmsy-10x-x-109">∘ </span><span class="italic">g</span>(<span class="italic">x</span>). The <span class="obeylines-h"><span class="verb"><code class="inlineCode">@f_deco</code></span></span> decorator must define and return the composite function by merging an internal definition of <span class="italic">f</span>(<span class="italic">y</span>) with the provided base function, <span class="italic">g</span>(<span class="italic">x</span>).</p>&#13;
<p>The implementation details show that Python actually provides a slightly more complex kind of composition. The structure of a wrapper makes it helpful to think of Python decorator composition as follows:</p>&#13;
<div class="math-display" style="text-align:center">&#13;
<img src="../Images/file112.jpg" class="math-display" alt=" ( ) w ∘g(x) = (wβ ∘g ∘w α)(x) = w β g(w α(x )) "/>&#13;
</div>&#13;
<p>A decorator applied to some application function, <span class="italic">g</span>(<span class="italic">x</span>), will include a wrapper function, <span class="italic">w</span>(<span class="italic">y</span>), that has two parts. One portion of the wrapper, <span class="italic">w</span><sub><span class="cmmi-8">α</span></sub>(<span class="italic">y</span>), applies to the <span class="cmti-10x-x-109">arguments </span>of the base function; the other portion, <span class="italic">w</span><sub><span class="cmmi-8">β</span></sub>(<span class="italic">z</span>), applies to the <span class="cmti-10x-x-109">result</span> of the base function.</p>&#13;
<p>Here’s a slightly more concrete idea, shown as a <span class="obeylines-h"><span class="verb"><code class="inlineCode">@stringify</code></span></span> decorator definition:</p>&#13;
<pre id="listing-254" class="lstlisting"><code>def stringify(argument_function: Callable[[int, int], int]) -&gt; Callable[[str], str]: &#13;
    @wraps(argument_function) &#13;
    def two_part_wrapper(text: str) -&gt; str: &#13;
        # The "before" part &#13;
        arg1, arg2 = map(int, text.split(",")) &#13;
        int_result = argument_function(arg1, arg2) &#13;
        # The "after" part &#13;
        return str(int_result) &#13;
    return two_part_wrapper</code></pre>&#13;
<p>This decorator inserts conversions<span id="dx1-254014"/> from string to integer, and integer back to string. Concealing the details of string processing may be helpful when working with CSV files, where the content is always string data.</p>&#13;
<p>We can apply this decorator to a function:</p>&#13;
<div id="tcolobox-259" class="tcolorbox tcolorbox">&#13;
&#13;
&#13;
<pre class="lstinputlisting"><code>&gt;&gt;&gt; @stringify &#13;
... def the_model(m: int, s: int) -&gt; int: &#13;
...     return m * 45 + s * 3 &#13;
... &#13;
&gt;&gt;&gt; the_model("5,6") &#13;
’243’</code></pre>&#13;
&#13;
</div>&#13;
<p>This shows the two places to inject additional processing before as well as after the original function. This emphasizes an important distinction between the abstract concept of functional composition and the Python implementation: it’s possible that a decorator can create either <span class="italic">f</span>(<span class="italic">g</span>(<span class="italic">x</span>)), or <span class="italic">g</span>(<span class="italic">f</span>(<span class="italic">x</span>)), or a more complex <span class="italic">f</span><sub><span class="cmmi-8">β</span></sub><span class="bbig"><img src="../Images/file113.jpg" class="left" data-align="middle" alt="("/></span><span class="italic">g</span>(<span class="italic">f</span><sub><span class="cmmi-8">α</span></sub>(<span class="italic">x</span>))<span class="bbig"><img src="../Images/file114.jpg" class="left" data-align="middle" alt=")"/></span>. The syntax of decoration doesn’t describe which kind of composition will be created.</p>&#13;
<p>The real value of decorators stems from the way any Python statement can be used in the wrapping function. A decorator can use <span class="obeylines-h"><span class="verb"><code class="inlineCode">if</code></span></span> or <span class="obeylines-h"><span class="verb"><code class="inlineCode">for</code></span></span> statements to transform a function into something used conditionally or iteratively. In the next section, the examples will leverage the <span class="obeylines-h"><span class="verb"><code class="inlineCode">try:</code></span></span> statement to perform an operation with a standard recovery from bad data. There are many things that can be done within this general framework.</p>&#13;
<p>A great deal of functional programming follows the essential <span class="italic">f </span><span class="cmsy-10x-x-109">∘ </span><span class="italic">g</span>(<span class="italic">x</span>) design pattern. Defining a composite from two smaller functions can help to summarize complex processing. In other cases, it can be more informative to keep the two functions separate.</p>&#13;
<p>It’s easy to create composites<span id="dx1-254024"/> of the common higher-order functions, such as <span class="obeylines-h"><span class="verb"><code class="inlineCode">map()</code></span></span>, <span class="obeylines-h"><span class="verb"><code class="inlineCode">filter()</code></span></span>, and <span class="obeylines-h"><span class="verb"><code class="inlineCode">functools.reduce()</code></span></span>. Because these functions are relatively simple, a composite function is often easy to describe, and can help to make the code more expressive.</p>&#13;
<p>For example, an application may include <span class="obeylines-h"><span class="verb"><code class="inlineCode">map(f,</code><code class="inlineCode"> map(g,</code><code class="inlineCode"> x))</code></span></span>. It may be more clear to create a composite function and use a <span class="obeylines-h"><span class="verb"><code class="inlineCode">map(f_g,</code><code class="inlineCode"> x)</code></span></span> expression to describe applying a composite to a collection. We can use <span class="obeylines-h"><span class="verb"><code class="inlineCode">f_g</code><code class="inlineCode"> =</code><code class="inlineCode"> lambda</code><code class="inlineCode"> x:</code><code class="inlineCode"> f(g(x))</code></span></span> to help explain a complex application as a composition of simpler functions. To make sure the type hints are correct, we’ll almost always want to define individual functions with the <span class="obeylines-h"><span class="verb"><code class="inlineCode">def</code></span></span> statement.</p>&#13;
<p>It’s important to note that there’s no real performance advantage to either technique. The <span class="obeylines-h"><span class="verb"><code class="inlineCode">map()</code></span></span> function is lazy: with two <span class="obeylines-h"><span class="verb"><code class="inlineCode">map()</code></span></span> functions, one item will be taken from the source collection, <span class="obeylines-h"><span class="verb"><code class="inlineCode">x</code></span></span>, processed by the <span class="obeylines-h"><span class="verb"><code class="inlineCode">g()</code></span></span> function, and then processed by the <span class="obeylines-h"><span class="verb"><code class="inlineCode">f()</code></span></span> function. With a single <span class="obeylines-h"><span class="verb"><code class="inlineCode">map()</code></span></span> function, an item will be taken from the source collection, <span class="obeylines-h"><span class="verb"><code class="inlineCode">x</code></span></span>, and then processed by the <span class="obeylines-h"><span class="verb"><code class="inlineCode">f_g()</code></span></span> composite function; the memory use is the same.</p>&#13;
<p>In <a href="Chapter_13.xhtml#x1-26600013"><span class="cmti-10x-x-109">Chapter</span><span class="cmti-10x-x-109"> 13</span></a>, <a href="Chapter_13.xhtml#x1-26600013"><span class="cmti-10x-x-109">The PyMonad Library</span></a>, we’ll look at an alternative approach to this problem of creating composite functions from individual curried functions. <span id="x1-254025r260"/></p>&#13;
<section id="preprocessing-bad-data" class="level4 subsectionHead" data-number="0.16.3.1">&#13;
<h4 class="subsectionHead" data-number="0.16.3.1"><span class="titlemark">12.3.1 </span> <span id="x1-2550001"/>Preprocessing bad data</h4>&#13;
<p>One cross-cutting concern<span id="dx1-255001"/> in some exploratory data analysis applications is how to handle numeric values that are missing or cannot be parsed. We often have a mixture of <span class="obeylines-h"><span class="verb"><code class="inlineCode">float</code></span></span>, <span class="obeylines-h"><span class="verb"><code class="inlineCode">int</code></span></span>, <span class="obeylines-h"><span class="verb"><code class="inlineCode">datetime.datetime</code></span></span>, and <span class="obeylines-h"><span class="verb"><code class="inlineCode">decimal.Decimal</code></span></span> currency values that we’d like to process with some consistency.</p>&#13;
<p>In other contexts, we have <span class="cmti-10x-x-109">not applicable </span>or <span class="cmti-10x-x-109">not available </span>placeholders instead of data values; these shouldn’t interfere with the main thread of the calculation. It’s often handy to allow the <span class="cmti-10x-x-109">not applicable </span>values to pass through an expression without raising an exception. We’ll focus on three bad-data conversion functions: <span class="obeylines-h"><span class="verb"><code class="inlineCode">bd_int()</code></span></span>, <span class="obeylines-h"><span class="verb"><code class="inlineCode">bd_float()</code></span></span>, and <span class="obeylines-h"><span class="verb"><code class="inlineCode">bd_decimal()</code></span></span>. We’ve left <span class="obeylines-h"><span class="verb"><code class="inlineCode">bd_datetime()</code></span></span> as an exercise for the reader.</p>&#13;
<p>The composite<span id="dx1-255002"/> feature we’re adding will be defined first. Then we’ll use this to wrap a built-in conversion function. Here’s a simple bad-data decorator:</p>&#13;
<pre id="listing-255" class="lstlisting"><code>from collections.abc import Callable &#13;
import decimal &#13;
from typing import Any, Union, TypeVar, TypeAlias &#13;
 &#13;
Number: TypeAlias = Union[decimal.Decimal, float] &#13;
NumT = TypeVar("NumT", bound=Number) &#13;
 &#13;
def bad_data( &#13;
         function: Callable[[str], NumT] &#13;
) -&gt; Callable[[str], NumT]: &#13;
    @wraps(function) &#13;
    def wrap_bad_data(source: str, **kwargs: Any) -&gt; NumT: &#13;
        try: &#13;
            return function(source, **kwargs) &#13;
        except (ValueError, decimal.InvalidOperation): &#13;
            cleaned = source.replace(",", "") &#13;
            return function(cleaned, **kwargs) &#13;
    return wrap_bad_data</code></pre>&#13;
<p>The decorator, <span class="obeylines-h"><span class="verb"><code class="inlineCode">@bad_data</code></span></span>, wraps a given conversion function, with the parameter name <span class="obeylines-h"><span class="verb"><code class="inlineCode">function</code></span></span>, to try a second conversion in the event the first conversion fails. The <span class="obeylines-h"><span class="verb"><code class="inlineCode">ValueError</code></span></span> and <span class="obeylines-h"><span class="verb"><code class="inlineCode">decimal.InvalidOperation</code></span></span> exceptions are generally indicators of data that has an invalid format: bad data. The second conversion will be attempted after <span class="obeylines-h"><span class="verb"><code class="inlineCode">","</code></span></span> characters are removed. This wrapper passes the <span class="obeylines-h"><span class="verb"><code class="inlineCode">*args</code></span></span> and <span class="obeylines-h"><span class="verb"><code class="inlineCode">**kwargs</code></span></span> parameters into the wrapped function. This ensures that the wrapped functions can have additional argument values provided.</p>&#13;
<p>The type variable <span class="obeylines-h"><span class="verb"><code class="inlineCode">NumT</code></span></span> is bound to the original return type of the base function being wrapped, the value of the <span class="obeylines-h"><span class="verb"><code class="inlineCode">function</code></span></span> parameter. The decorator is defined to return a function with the same type, <span class="obeylines-h"><span class="verb"><code class="inlineCode">NumT</code></span></span>. This type has an upper bound of the union of <span class="obeylines-h"><span class="verb"><code class="inlineCode">float</code></span></span> and <span class="obeylines-h"><span class="verb"><code class="inlineCode">Decimal</code></span></span> types. This boundary permits objects that are a subclass of <span class="obeylines-h"><span class="verb"><code class="inlineCode">float</code></span></span> or <span class="obeylines-h"><span class="verb"><code class="inlineCode">Decimal</code></span></span>.</p>&#13;
<div id="tcolobox-260" class="infobox note">&#13;
&#13;
&#13;
<p>The type hints for complex decorator design are evolving rapidly. In particular, PEP 612 ( <a href="https://peps.python.org/pep-0612/" class="url">https://peps.python.org/pep-0612/</a>) defines some new constructs that can allow even more flexible type hints. For decorators that do not make any type changes, we can use generic parameter variables like <span class="obeylines-h"><span class="verb"><code class="inlineCode">ParamSpec</code></span></span> to capture the actual parameters of the function being decorated. This lets us write generic decorators without having to wrestle with the details of the type hints of the functions being decorated. We’ll note where PEP 612’s <span class="obeylines-h"><span class="verb"><code class="inlineCode">ParamSpec</code></span></span> and <span class="obeylines-h"><span class="verb"><code class="inlineCode">Concatenate</code></span></span> will come in useful. Be sure to see the PEP 612 examples when designing generic decorators.</p>&#13;
&#13;
</div>&#13;
<p>We can use this wrapper<span id="dx1-255021"/> to create bad-data-sensitive functions as follows:</p>&#13;
<pre id="listing-256" class="lstlisting"><code>from decimal import Decimal &#13;
 &#13;
bd_int = bad_data(int) &#13;
bd_float = bad_data(float) &#13;
bd_decimal = bad_data(Decimal)</code></pre>&#13;
<p>This will create a suite of functions that can do conversions of good data as well as a limited amount of data cleansing to handle specific kinds of bad data.</p>&#13;
<p>It can be difficult to write type hints for some kinds of callable objects. For example, the <span class="obeylines-h"><span class="verb"><code class="inlineCode">int()</code></span></span> function has optional keyword arguments, with their own complex type hints. Our decorator summarizes these keyword arguments as <span class="obeylines-h"><span class="verb"><code class="inlineCode">**kwargs:</code><code class="inlineCode"> Any</code></span></span>. Ideally, a <span class="obeylines-h"><span class="verb"><code class="inlineCode">ParamSpec</code></span></span> can be used to capture the details of the parameters for the function being wrapped. See PEP 612 ( <a href="https://peps.python.org/pep-0612/" class="url">https://peps.python.org/pep-0612/</a>) for guidance on creating complex type signatures for callable objects.</p>&#13;
<p>The following are some examples of using the <span class="obeylines-h"><span class="verb"><code class="inlineCode">bd_int()</code></span></span> function:</p>&#13;
<div id="tcolobox-261" class="tcolorbox tcolorbox">&#13;
&#13;
&#13;
<pre class="lstinputlisting"><code>&gt;&gt;&gt; bd_int("13") &#13;
13 &#13;
&gt;&gt;&gt; bd_int("1,371") &#13;
1371 &#13;
&gt;&gt;&gt; bd_int("1,371", base=16) &#13;
4977</code></pre>&#13;
&#13;
</div>&#13;
<p>We’ve applied the <span class="obeylines-h"><span class="verb"><code class="inlineCode">bd_int()</code></span></span> function to a string that converted neatly and a string with the specific type of punctuation<span id="dx1-255034"/> that we’ll tolerate. We’ve also shown that we can provide additional parameters to each of these conversion functions.</p>&#13;
<p>We may like to have a more flexible decorator. One feature that we may like to add is the ability to handle a variety of data scrubbing alternatives. Simple <span class="obeylines-h"><span class="verb"><code class="inlineCode">","</code></span></span> removal isn’t always what we need. We may also need to remove <span class="obeylines-h"><span class="verb"><code class="inlineCode">$</code></span></span> or <span class="obeylines-h"><span class="verb"><span class="tctt-1095">°</span></span></span> symbols, too. We’ll look at more sophisticated, parameterized decorators in the next section. <span id="x1-255035r262"/></p>&#13;
</section>&#13;
</section>&#13;
<section id="adding-a-parameter-to-a-decorator" class="level3 sectionHead" data-number="0.16.4">&#13;
<h3 class="sectionHead" data-number="0.16.4"><span class="titlemark">12.4 </span> <span id="x1-2560004"/>Adding a parameter to a decorator</h3>&#13;
<p>A common requirement is to customize a decorator<span id="dx1-256001"/> with additional parameters. Rather than simply creating a composite <span class="italic">f </span><span class="cmsy-10x-x-109">∘ </span><span class="italic">g</span>(<span class="italic">x</span>), we can do something a bit more complex. With parameterized decorators,<span id="dx1-256002"/> we can create <span class="bbig"><img src="../Images/file115.jpg" class="left" data-align="middle" alt="("/></span><span class="italic">f</span>(<span class="italic">c</span>) <span class="cmsy-10x-x-109">∘ </span><span class="italic">g</span><span class="bbig"><img src="../Images/file116.jpg" class="left" data-align="middle" alt=")"/></span>(<span class="italic">x</span>). We’ve applied a parameter, <span class="cmti-10x-x-109">c</span>, as part of creating the wrapper, <span class="italic">f</span>(<span class="italic">c</span>). This parameterized composite function, <span class="italic">f</span>(<span class="italic">c</span>) <span class="cmsy-10x-x-109">∘ </span><span class="italic">g</span>, can then be applied to the actual data, <span class="italic">x</span>.</p>&#13;
<p>In Python syntax, we can write it as follows:</p>&#13;
<pre id="listing-257" class="lstlisting"><code>@deco(arg) &#13;
def func(x): &#13;
    base function processing...</code></pre>&#13;
<p>There are two steps to this. The first step applies the parameter to an abstract decorator to create a concrete decorator. Then the concrete decorator, the parameterized <span class="obeylines-h"><span class="verb"><code class="inlineCode">deco(arg)</code></span></span> function, is applied to the base function definition to create the decorated function.</p>&#13;
<p>The effect is as follows:</p>&#13;
<pre id="listing-258" class="lstlisting"><code>concrete_deco = deco(arg) &#13;
 &#13;
def func(x): &#13;
    base function processing... &#13;
 &#13;
func = concrete_deco(func)</code></pre>&#13;
<p>The parameterized<span id="dx1-256012"/> decorator worked by doing the following three things:</p>&#13;
<ol>&#13;
<li><div id="x1-256014x1">&#13;
<p>Applied the abstract decorator, <span class="obeylines-h"><span class="verb"><code class="inlineCode">deco()</code></span></span>, to its argument, <span class="obeylines-h"><span class="verb"><code class="inlineCode">arg</code></span></span>, to create a concrete decorator, <span class="obeylines-h"><span class="verb"><code class="inlineCode">concrete_deco()</code></span></span>.</p>&#13;
</div></li>&#13;
<li><div id="x1-256016x2">&#13;
<p>Defined the base function, <span class="obeylines-h"><span class="verb"><code class="inlineCode">func()</code></span></span>.</p>&#13;
</div></li>&#13;
<li><div id="x1-256018x3">&#13;
<p>Applied the concrete decorator, <span class="obeylines-h"><span class="verb"><code class="inlineCode">concrete_deco()</code></span></span>, to the base function to create the decorated version of the function; in effect, it’s <span class="obeylines-h"><span class="verb"><code class="inlineCode">deco(arg)(func)</code></span></span>.</p>&#13;
</div></li>&#13;
</ol>&#13;
<p>A decorator<span id="dx1-256019"/> with arguments involves indirect construction of the final function. We seem to have moved beyond merely higher-order functions into something even more abstract: higher-order functions that create higher-order functions.</p>&#13;
<p>We can expand our bad-data-aware decorator to create a slightly more flexible conversion. We’ll define a <span class="obeylines-h"><span class="verb"><code class="inlineCode">@bad_char_remove</code></span></span> decorator that can accept parameters of characters to remove. The following is a parameterized decorator:</p>&#13;
<pre id="listing-259" class="lstlisting"><code>from collections.abc import Callable &#13;
import decimal &#13;
from typing import Any, TypeVar &#13;
 &#13;
T = TypeVar(’T’) &#13;
 &#13;
def bad_char_remove( &#13;
    *bad_chars: str &#13;
) -&gt; Callable[[Callable[[str], T]], Callable[[str], T]]: &#13;
    def cr_decorator( &#13;
            function: Callable[[str], T] &#13;
    ) -&gt; Callable[[str], T]: &#13;
        def clean_list(text: str, *, to_replace: tuple[str, ...]) -&gt; str: &#13;
            if to_replace: &#13;
                return clean_list( &#13;
                    text.replace(to_replace[0], ""), &#13;
                    to_replace=to_replace[1:] &#13;
                ) &#13;
            return text &#13;
 &#13;
        @wraps(function) &#13;
        def wrap_char_remove(text: str, **kwargs: Any) -&gt; T: &#13;
            try: &#13;
                return function(text, **kwargs) &#13;
            except (ValueError, decimal.InvalidOperation): &#13;
                cleaned = clean_list(text, to_replace=bad_chars) &#13;
                return function(cleaned, **kwargs) &#13;
        return wrap_char_remove &#13;
    return cr_decorator</code></pre>&#13;
<p>A parameterized<span id="dx1-256049"/> decorator has two internal<span id="dx1-256050"/> function definitions:</p>&#13;
<ul>&#13;
<li><p>The concrete decorator; in this example, the <span class="obeylines-h"><span class="verb"><code class="inlineCode">cr_decorator()</code></span></span> function. This will have the free variable, <span class="obeylines-h"><span class="verb"><code class="inlineCode">bad_chars</code></span></span>, bound to the function being built. The concrete decorator is then returned; it will later be applied to a base function. When applied, the decorator will return a new function wrapped inside the <span class="obeylines-h"><span class="verb"><code class="inlineCode">wrap_char_remove()</code></span></span> function. This new <span class="obeylines-h"><span class="verb"><code class="inlineCode">wrap_char_remove()</code></span></span> function has type hints with a type variable, <span class="obeylines-h"><span class="verb"><code class="inlineCode">T</code></span></span>, that claim the wrapped function’s type will be preserved by the new <span class="obeylines-h"><span class="verb"><code class="inlineCode">wrap_char_remove()</code></span></span> function.</p></li>&#13;
<li><p>The decorating wrapper, the <span class="obeylines-h"><span class="verb"><code class="inlineCode">wrap_char_remove()</code></span></span> function in this example, will replace the original function with a wrapped version. Because of the <span class="obeylines-h"><span class="verb"><code class="inlineCode">@wraps</code></span></span> decorator, the <span class="obeylines-h"><span class="verb"><code class="inlineCode">__name__</code></span></span> (and other attributes) of the new function will be replaced with the name of the base function being wrapped.</p></li>&#13;
</ul>&#13;
<p>The overall decorator, the <span class="obeylines-h"><span class="verb"><code class="inlineCode">@bad_char_remove</code></span></span> function in this example, has the job of binding the parameter, named <span class="obeylines-h"><span class="verb"><code class="inlineCode">bad_chars</code></span></span>, to a function and returning the concrete decorator. The type hint clarifies the return value is a <span class="obeylines-h"><span class="verb"><code class="inlineCode">Callable</code></span></span> object that transforms a <span class="obeylines-h"><span class="verb"><code class="inlineCode">Callable</code></span></span> function into another <span class="obeylines-h"><span class="verb"><code class="inlineCode">Callable</code></span></span> function. The language rules will then apply the concrete decorator to the following function definition.</p>&#13;
<p>The internal <span class="obeylines-h"><span class="verb"><code class="inlineCode">clean_list()</code></span></span> function is used by the <span class="obeylines-h"><span class="verb"><code class="inlineCode">@bad_char_remove</code></span></span> decorator to remove all characters in a given argument value. This is defined as a recursion to keep it very short. It can be optimized<span id="dx1-256051"/> into an iteration if necessary. We’ve left that optimization as an exercise for the reader.</p>&#13;
<p>We can use the <span class="obeylines-h"><span class="verb"><code class="inlineCode">@bad_char_remove</code></span></span> decorator to create conversion<span id="dx1-256052"/> functions as follows:</p>&#13;
<pre id="listing-260" class="lstlisting"><code>from decimal import Decimal &#13;
from typing import Any &#13;
 &#13;
@bad_char_remove("$", ",") &#13;
def currency(text: str, **kw: Any) -&gt; Decimal: &#13;
    return Decimal(text, **kw)</code></pre>&#13;
<p>We’ve used our <span class="obeylines-h"><span class="verb"><code class="inlineCode">@bad_char_remove</code></span></span> decorator to wrap a base <span class="obeylines-h"><span class="verb"><code class="inlineCode">currency()</code></span></span> function. The essential feature of the <span class="obeylines-h"><span class="verb"><code class="inlineCode">currency()</code></span></span> function is a reference to the <span class="obeylines-h"><span class="verb"><code class="inlineCode">decimal.Decimal</code></span></span> constructor.</p>&#13;
<p>This <span class="obeylines-h"><span class="verb"><code class="inlineCode">currency()</code></span></span> function will now handle some variant data formats:</p>&#13;
<div id="tcolobox-262" class="tcolorbox tcolorbox">&#13;
&#13;
&#13;
<pre class="lstinputlisting"><code>&gt;&gt;&gt; currency("13") &#13;
Decimal(’13’) &#13;
&gt;&gt;&gt; currency("$3.14") &#13;
Decimal(’3.14’) &#13;
&gt;&gt;&gt; currency("$1,701.00") &#13;
Decimal(’1701.00’)</code></pre>&#13;
&#13;
</div>&#13;
<p>We can now process input data using a relatively simple <span class="obeylines-h"><span class="verb"><code class="inlineCode">map(currency,</code><code class="inlineCode"> row)</code></span></span> expression to convert source data from strings to usable <span class="obeylines-h"><span class="verb"><code class="inlineCode">Decimal</code></span></span> values. The <span class="obeylines-h"><span class="verb"><code class="inlineCode">try:</code></span></span>/<span class="obeylines-h"><span class="verb"><code class="inlineCode">except:</code></span></span> error-handling has been isolated to a function that we’ve used to build a composite conversion function.</p>&#13;
<p>We can use a similar design to create null-tolerant functions. These functions would use a similar <span class="obeylines-h"><span class="verb"><code class="inlineCode">try:</code></span></span>/<span class="obeylines-h"><span class="verb"><code class="inlineCode">except:</code></span></span> wrapper, but would return the <span class="obeylines-h"><span class="verb"><code class="inlineCode">None</code></span></span> values. This design variant is left as an exercise for the reader.</p>&#13;
<p>This decorator<span id="dx1-256066"/> is limited to conversion<span id="dx1-256067"/> functions that apply to a single string, and have a type hint like <span class="obeylines-h"><span class="verb"><code class="inlineCode">Callable[[str],</code><code class="inlineCode"> T]</code></span></span>. For generic decorators, it helps to follow the examples in PEP-612 and use the <span class="obeylines-h"><span class="verb"><code class="inlineCode">ParamSpec</code></span></span> and <span class="obeylines-h"><span class="verb"><code class="inlineCode">Concatenate</code></span></span> type hints to broaden the domain of the decorators. Because we’re interested in applying the internal <span class="obeylines-h"><span class="verb"><code class="inlineCode">clean_list()</code></span></span> function to the first argument value, we can look at the conversion function as <span class="obeylines-h"><span class="verb"><code class="inlineCode">Callable[Concatenate[str,</code><code class="inlineCode"> P],</code></span></span> <span class="obeylines-h"><span class="verb"><code class="inlineCode">T]</code></span></span>. We would define the first parameter as a string, and use a <span class="obeylines-h"><span class="verb"><code class="inlineCode">ParamSpec</code></span></span>, <span class="obeylines-h"><span class="verb"><code class="inlineCode">P</code></span></span>, to represent all other parameters of the conversion function. <span id="x1-256068r264"/></p>&#13;
</section>&#13;
<section id="implementing-more-complex-decorators" class="level3 sectionHead" data-number="0.16.5">&#13;
<h3 class="sectionHead" data-number="0.16.5"><span class="titlemark">12.5 </span> <span id="x1-2570005"/>Implementing more complex decorators</h3>&#13;
<p>To create more complex<span id="dx1-257001"/> compositions, Python allows the following kinds of function definitions:</p>&#13;
<pre id="listing-261" class="lstlisting"><code>@f_wrap &#13;
@g_wrap &#13;
def h(x): &#13;
    return something...</code></pre>&#13;
<p>Python permits stacking decorators that modify the results of other decorators. This has a meaning somewhat like <span class="italic">f </span><span class="cmsy-10x-x-109">∘</span><span class="italic">g </span><span class="cmsy-10x-x-109">∘</span><span class="italic">h</span>(<span class="italic">x</span>). However, the resulting name will be merely <span class="italic">h</span>(<span class="italic">x</span>), concealing the stack of decorations. Because of this potential confusion, we need to be cautious when creating functions that involve deeply nested decorators. If our intent is simply to handle some cross-cutting concerns, then each decorator should be designed to handle a separate concern while avoiding confusion.</p>&#13;
<p>While many things can be done with decoration, it’s essential to ask if using a decorator creates clear, succinct, expressive programming. When working with cross-cutting concerns, the features of the decorator are often essentially distinct from the function being decorated. This can be a wonderful simplification. Adding logging, debugging, or security checks<span id="dx1-257006"/> through decoration is a widely followed practice.</p>&#13;
<div id="tcolobox-263" class="packt_tip">&#13;
&#13;
&#13;
<p>One important consequence of an overly complex design is the difficulty in providing appropriate type hints. When the type hints devolve to simply using <span class="obeylines-h"><span class="verb"><code class="inlineCode">Callable[...,</code><code class="inlineCode"> Any]</code></span></span>, the design may have become too difficult to reason about clearly.</p>&#13;
&#13;
</div>&#13;
<p><span id="x1-257007r265"/></p>&#13;
</section>&#13;
<section id="complicated-design-considerations" class="level3 sectionHead" data-number="0.16.6">&#13;
<h3 class="sectionHead" data-number="0.16.6"><span class="titlemark">12.6 </span> <span id="x1-2580006"/>Complicated design considerations</h3>&#13;
<p>In the case of our data cleanup, the simplistic removal of stray characters may not be sufficient. When working<span id="dx1-258001"/> with the geolocation data, we may have a wide variety of input formats that include simple degrees (<span class="obeylines-h"><span class="verb"><code class="inlineCode">37.549016197</code></span></span>), degrees and minutes (<code class="inlineCode">37</code><span class="tctt-1095">° </span><code class="inlineCode">32.94097</code><span class="cmsy-10x-x-109">′</span>), and degrees-minutes-seconds (<code class="inlineCode">37</code><span class="tctt-1095">° </span><code class="inlineCode">32</code><span class="cmsy-10x-x-109">′ </span><code class="inlineCode">56.46</code><span class="cmsy-10x-x-109">′′</span>). Of course, there can be even more subtle cleaning problems: some devices will create an output with the Unicode <span class="obeylines-h"><span class="verb"><code class="inlineCode">U+00BA</code></span></span> character, <span class="obeylines-h"><span class="verb"><span class="tctt-1095">º</span></span></span>, the ”masculine ordinal indicator,” instead of the similar-looking degree character, <span class="obeylines-h"><span class="verb"><span class="tctt-1095">°</span></span></span>, which is <span class="obeylines-h"><span class="verb"><code class="inlineCode">U+00B0</code></span></span>.</p>&#13;
<p>For this reason, it is often necessary to provide a separate cleansing function that’s bundled with the conversion function. This function will handle the more sophisticated conversions required by inputs that are as wildly inconsistent in format as latitudes and longitudes are.</p>&#13;
<p>How can we implement this? We have a number of choices. Simple higher-order functions are a good choice. A decorator, on the other hand, doesn’t work out terribly well. We’ll look at a decorator-based design to see some limitations to what makes sense in a decorator.</p>&#13;
<p>The requirements have the following two orthogonal design considerations:</p>&#13;
<ul>&#13;
<li><p>The output conversion from <span class="obeylines-h"><span class="verb"><code class="inlineCode">string</code></span></span> to <span class="obeylines-h"><span class="verb"><code class="inlineCode">int</code></span></span>, <span class="obeylines-h"><span class="verb"><code class="inlineCode">float</code></span></span> or <span class="obeylines-h"><span class="verb"><code class="inlineCode">Decimal</code></span></span>, summarized as <span class="obeylines-h"><span class="verb"><code class="inlineCode">Callable[str,</code><code class="inlineCode"> T]</code></span></span></p></li>&#13;
<li><p>The input cleaning; removing stray characters, reformatting coordinates; summarized as <span class="obeylines-h"><span class="verb"><code class="inlineCode">Callable[str,</code><code class="inlineCode"> str]</code></span></span></p></li>&#13;
</ul>&#13;
<p>Ideally, one of these aspects could be considered as the <span class="keyWord">essential </span>function that gets wrapped, and the other aspect is something that’s included via a decoration. The choice of essence versus wrapper isn’t always clear.</p>&#13;
<p>Considering the previous examples, it appears that this should be seen as a three-part composite:</p>&#13;
<ul>&#13;
<li><p>The output conversion from <span class="obeylines-h"><span class="verb"><code class="inlineCode">string</code></span></span> to <span class="obeylines-h"><span class="verb"><code class="inlineCode">int</code></span></span>, <span class="obeylines-h"><span class="verb"><code class="inlineCode">float</code></span></span>, or <span class="obeylines-h"><span class="verb"><code class="inlineCode">decimal</code></span></span></p></li>&#13;
<li><p>The input cleansing: either a simple replace or a more complex multiple-character replacement</p></li>&#13;
<li><p>An overall processing function that first attempts the conversion, then does any cleansing as a response to an exception, and then attempts the conversion again</p></li>&#13;
</ul>&#13;
<p>The third part—attempting the conversion<span id="dx1-258002"/> and retrying—is the actual wrapper that also forms a part of the composite function. As we noted previously, a wrapper contains an argument phase and a return-value phase, which we can call <span class="italic">w</span><sub><span class="cmmi-8">α</span></sub>(<span class="italic">x</span>) and <span class="italic">w</span><sub><span class="cmmi-8">β</span></sub>(<span class="italic">x</span>), respectively.</p>&#13;
<p>We want to use this wrapper to create a composite of two additional functions. We have two choices for the design. We could include the cleansing function as an argument to the decorator on the conversion, as follows:</p>&#13;
<pre id="listing-262" class="lstlisting"><code>@cleanse_before(cleanser) &#13;
def convert(text: str) -&gt; int: &#13;
    # code to convert the text, trusting it was clean &#13;
    return # an int value</code></pre>&#13;
<p>This first design claims that the conversion function is central, and the cleansing is an ancillary detail that will modify the behavior but preserve the original intent of the conversion.</p>&#13;
<p>Or, we could include the conversion function as an argument to the decorator for a cleansing function as follows:</p>&#13;
<pre id="listing-263" class="lstlisting"><code>@then_convert(converter) &#13;
def cleanse(text: str) -&gt; str: &#13;
    # code to clean the text &#13;
    return # the str value for later conversion</code></pre>&#13;
<p>This second design claims that the cleansing is central and the conversion is an ancillary detail. This is a bit confusing because the cleansing type is generally <span class="obeylines-h"><span class="verb"><code class="inlineCode">Callable[[str],</code><code class="inlineCode"> str]</code></span></span>, while the conversion’s type of <span class="obeylines-h"><span class="verb"><code class="inlineCode">Callable[[str],</code><code class="inlineCode"> some</code><code class="inlineCode"> other</code><code class="inlineCode"> type]</code></span></span> is what is required for the overall wrapped function.</p>&#13;
<p>While both of these approaches<span id="dx1-258011"/> can create a usable composite function, the first version has an important advantage: the type signature of the <span class="obeylines-h"><span class="verb"><code class="inlineCode">conversion()</code></span></span> function is also the type signature of the resulting composite function. This highlights a general design pattern for decorators: the type annotations—the signatures—of the function being decorated are the easiest to preserve.</p>&#13;
<div id="tcolobox-264" class="packt_tip">&#13;
&#13;
&#13;
<p>When confronted with several choices for defining a composite function, it is generally easiest to preserve the type hints for the function being decorated. This helps identify the concept that’s central.</p>&#13;
&#13;
</div>&#13;
<p>Consequently, the <span class="obeylines-h"><span class="verb"><code class="inlineCode">@cleanse_before(cleaner)</code></span></span> style decorator is preferred. The decorator definition looks like the following example:</p>&#13;
<pre id="listing-264" class="lstlisting"><code>from collections.abc import Callable &#13;
from typing import Any, TypeVar &#13;
 &#13;
# Defined Earlier: &#13;
# T = TypeVar(’T’) &#13;
 &#13;
def cleanse_before( &#13;
    cleanse_function: Callable[[str], Any] &#13;
) -&gt; Callable[[Callable[[str], T]], Callable[[str], T]]: &#13;
    def concrete_decorator(converter: Callable[[str], T]) -&gt; Callable[[str], T]: &#13;
        @wraps(converter) &#13;
        def cc_wrapper(text: str, **kwargs: Any) -&gt; T: &#13;
            try: &#13;
                return converter(text, **kwargs) &#13;
            except (ValueError, decimal.InvalidOperation): &#13;
                cleaned = cleanse_function(text) &#13;
                return converter(cleaned, **kwargs) &#13;
        return cc_wrapper &#13;
    return concrete_decorator</code></pre>&#13;
<p>We’ve defined the following<span id="dx1-258031"/> multi-layer decorator:</p>&#13;
<ul>&#13;
<li><p>At the heart is the <span class="obeylines-h"><span class="verb"><code class="inlineCode">cc_wrapper()</code></span></span> function that applies the <span class="obeylines-h"><span class="verb"><code class="inlineCode">converter()</code></span></span> function. If this fails, then it uses the given <span class="obeylines-h"><span class="verb"><code class="inlineCode">cleanse_function()</code></span></span> function and then tries the <span class="obeylines-h"><span class="verb"><code class="inlineCode">converter()</code></span></span> function again.</p></li>&#13;
<li><p>The <span class="obeylines-h"><span class="verb"><code class="inlineCode">cc_wrapper()</code></span></span> function is built around the given <span class="obeylines-h"><span class="verb"><code class="inlineCode">cleanse_function()</code></span></span> and a <span class="obeylines-h"><span class="verb"><code class="inlineCode">converter()</code></span></span> function by the <span class="obeylines-h"><span class="verb"><code class="inlineCode">concrete_decorator()</code></span></span> decorator. The <span class="obeylines-h"><span class="verb"><code class="inlineCode">converter()</code></span></span> function is the function being decorated.</p></li>&#13;
<li><p>The top-most layer is the <span class="obeylines-h"><span class="verb"><code class="inlineCode">concrete_decorator()</code></span></span> function. This decorator has the <span class="obeylines-h"><span class="verb"><code class="inlineCode">cleanse_function()</code></span></span> function as a free variable.</p></li>&#13;
<li><p>The concrete decorator is created when the decorator interface, <span class="obeylines-h"><span class="verb"><code class="inlineCode">cleanse_before()</code></span></span>, is evaluated. The interface is customized by providing the <span class="obeylines-h"><span class="verb"><code class="inlineCode">cleanse_function</code></span></span> as an argument value.</p></li>&#13;
</ul>&#13;
<p>The type hints emphasize the role of the <span class="obeylines-h"><span class="verb"><code class="inlineCode">@cleanse_before</code></span></span> decorator. It expects some <span class="obeylines-h"><span class="verb"><code class="inlineCode">Callable</code></span></span> function, named <span class="obeylines-h"><span class="verb"><code class="inlineCode">cleanse_function</code></span></span>, and it creates a function, shown as <span class="obeylines-h"><span class="verb"><code class="inlineCode">Callable[[str],</code><code class="inlineCode"> T]</code></span></span>, which will transform a function into a wrapped function. This is a helpful reminder of how parameterized decorators work.</p>&#13;
<p>We can now build a slightly more flexible cleanse and convert function, <span class="obeylines-h"><span class="verb"><code class="inlineCode">to_int()</code></span></span>, as follows:</p>&#13;
<pre id="listing-265" class="lstlisting"><code>def drop_punct2(text: str) -&gt; str: &#13;
    return text.replace(",", "").replace("$", "") &#13;
 &#13;
@cleanse_before(drop_punct2) &#13;
def to_int(text: str, base: int = 10) -&gt; int: &#13;
    return int(text, base)</code></pre>&#13;
<p>The integer conversion is decorated with a cleansing function. In this case, the cleansing function removes <span class="obeylines-h"><span class="verb"><code class="inlineCode">$</code></span></span> and <span class="obeylines-h"><span class="verb"><code class="inlineCode">,</code></span></span> characters. The integer conversion is wrapped by this cleansing.</p>&#13;
<p>The <span class="obeylines-h"><span class="verb"><code class="inlineCode">to_int()</code></span></span> function defined previously leverages the built-in <span class="obeylines-h"><span class="verb"><code class="inlineCode">int()</code></span></span> function. An alternative definition<span id="dx1-258038"/> that avoids the <span class="obeylines-h"><span class="verb"><code class="inlineCode">def</code></span></span> statement would be the following:</p>&#13;
<pre id="listing-266" class="lstlisting"><code>to_int2 = cleanse_before(drop_punct2)(int)</code></pre>&#13;
<p>This uses <span class="obeylines-h"><span class="verb"><code class="inlineCode">drop_punct2()</code></span></span> to wrap the built-in <span class="obeylines-h"><span class="verb"><code class="inlineCode">int()</code></span></span> conversion function. Using the <span class="keyWord">mypy </span>tool’s <span class="obeylines-h"><span class="verb"><code class="inlineCode">reveal_type()</code></span></span> function shows that the type signature for <span class="obeylines-h"><span class="verb"><code class="inlineCode">to_int()</code></span></span> matches the type signature for the built-in <span class="obeylines-h"><span class="verb"><code class="inlineCode">int()</code></span></span>. It can be argued that this style is less readable than using a decorator.</p>&#13;
<p>We can use this enhanced integer conversion as follows:</p>&#13;
<div id="tcolobox-265" class="tcolorbox tcolorbox">&#13;
&#13;
&#13;
<pre class="lstinputlisting"><code>&gt;&gt;&gt; to_int("1,701") &#13;
1701 &#13;
&gt;&gt;&gt; to_int("42") &#13;
42</code></pre>&#13;
&#13;
</div>&#13;
<p>The type hints for the underlying <span class="obeylines-h"><span class="verb"><code class="inlineCode">int()</code></span></span> function have been rewritten (and simplified) for the decorated function, <span class="obeylines-h"><span class="verb"><code class="inlineCode">to_int()</code></span></span>. This is a consequence of trying to use decorators to wrap built-in functions.</p>&#13;
<p>Because of the complexity of defining parameterized decorators, it appears that this is the edge of the envelope. The decorator model doesn’t seem to be ideal for this kind of design. It seems like a definition of a composite function would be more clear than the machinery required to build decorators.</p>&#13;
<p>The alternative is to duplicate a few lines of code that will be the same for all of the conversion functions. We could use:</p>&#13;
<pre id="listing-267" class="lstlisting"><code>def to_int_flat(text: str, base: int = 10) -&gt; int: &#13;
    try: &#13;
        return int(text, base) &#13;
    except (ValueError, decimal.InvalidOperation): &#13;
        cleaned = drop_punct2(text) &#13;
        return int(cleaned, base)</code></pre>&#13;
<p>Each of the data type conversions will repeat the <span class="obeylines-h"><span class="verb"><code class="inlineCode">try-except</code></span></span> block. The use of a decorator isolates this design feature in a way that can be applied to any number of conversion functions without explicitly restating the code. Later changes to the design when using this alternative may require editing a number of similar functions instead of changing one decorator.</p>&#13;
<p>Generally, decorators work well when we have a number of relatively simple and fixed aspects that we want to include with a given function (or a class). Decorators are also important when these additional aspects can be looked at as infrastructure or as support, and not something<span id="dx1-258051"/> essential to the meaning of the application code.</p>&#13;
<p>For something that involves multiple orthogonal design aspects, we may want to result to a callable class definition with various kinds of plugin strategy objects. This might have a simpler class definition than the equivalent decorator. Another alternative to decorators is to look closely at creating higher-order functions. In some cases, partial functions with various combinations of parameters may be simpler than a decorator.</p>&#13;
<p>The typical examples for cross-cutting concerns include logging or security testing. These features can be considered as the kind of background processing that isn’t specific to the problem domain. When we have processing that is as ubiquitous as the air that surrounds us, then a decorator might be an appropriate design technique. <span id="x1-258052r266"/></p>&#13;
</section>&#13;
<section id="summary-11" class="level3 sectionHead" data-number="0.16.7">&#13;
<h3 class="sectionHead" data-number="0.16.7"><span class="titlemark">12.7 </span> <span id="x1-2590007"/>Summary</h3>&#13;
<p>In this chapter, we’ve looked at two kinds of decorators: simple decorators with no arguments and parameterized decorators. We’ve seen how decorators involve an indirect composition between functions: the decorator wraps a function (defined inside the decorator) around another function.</p>&#13;
<p>Using the <span class="obeylines-h"><span class="verb"><code class="inlineCode">functools.wraps()</code></span></span> decorator ensures that our decorators will properly copy attributes from the function being wrapped. This should be a piece of every decorator we write.</p>&#13;
<p>In the next chapter, we’ll look at the PyMonad library to express a functional programming concept directly in Python. We don’t require monads generally because Python is an imperative programming language under the hood. <span id="x1-259001r267"/></p>&#13;
</section>&#13;
<section id="exercises-11" class="level3 sectionHead" data-number="0.16.8">&#13;
<h3 class="sectionHead" data-number="0.16.8"><span class="titlemark">12.8 </span> <span id="x1-2600008"/>Exercises</h3>&#13;
<p>This chapter’s exercises are based on code available from Packt Publishing on GitHub. See <a href="https://github.com/PacktPublishing/Functional-Python-Programming-3rd-Edition" class="url">https://github.com/PacktPublishing/Functional-Python-Programming-3rd-Edition</a>.</p>&#13;
<p>In some cases, the reader will notice that the code provided on GitHub includes partial solutions to some of the exercises. These serve as hints, allowing the reader to explore alternative solutions.</p>&#13;
<p>In many cases, exercises will need unit test cases to confirm they actually solve the problem. These are often identical to the unit test cases already provided in the GitHub repository. The reader should replace the book’s example function name with their own solution to confirm that it works. <span id="x1-260001r263"/></p>&#13;
<section id="datetime-conversions" class="level4 subsectionHead" data-number="0.16.8.1">&#13;
<h4 class="subsectionHead" data-number="0.16.8.1"><span class="titlemark">12.8.1 </span> <span id="x1-2610001"/>Datetime conversions</h4>&#13;
<p>In the <a href="#x1-2550001"><span class="cmti-10x-x-109">Preprocessing bad data</span></a> section of this chapter, we introduced the concept of data conversion functions that included special <span class="cmti-10x-x-109">not applicable </span>or <span class="cmti-10x-x-109">not available</span> data values. These are often called null values; because of this, a database may have a universal <span class="obeylines-h"><span class="verb"><code class="inlineCode">NULL</code></span></span> literal. We’ll call them ”bad data” because that’s how we often discover them. When examining data for the first time, we find bad data that might represent missing, or not applicable, values.</p>&#13;
<p>This kind of data can have any of these possible processing paths:</p>&#13;
<ul>&#13;
<li><p>The bad data is silently ignored; it’s excluded from counts and averages. To make this work out, we’ll often want to replace bad values with a consistent object. The <span class="obeylines-h"><span class="verb"><code class="inlineCode">None</code></span></span> object is a good replacement value.</p></li>&#13;
<li><p>The bad data stops the processing, raising an exception. This is quite easy to implement, since Python tends to do this automatically. In some cases, we want to retry the conversion using alternative rules. We’ll focus on this approach for this exercise.</p></li>&#13;
<li><p>Bad data is replaced with interpolated or imputed values. This often means keeping two versions of a collection of data: the original with bad data present, and a more useful version with replacement values. This isn’t a simple computation.</p></li>&#13;
</ul>&#13;
<p>The idea of our core <span class="obeylines-h"><span class="verb"><code class="inlineCode">bad_data()</code></span></span> function is to try a conversion, replace known bad punctuation, and then try again. We might, for example, strip ”,” and ”<span class="obeylines-h"><span class="verb"><code class="inlineCode">$</code></span></span>” from numeric values.</p>&#13;
<p>Earlier in this chapter, we described three bad-data conversion functions: <span class="obeylines-h"><span class="verb"><code class="inlineCode">bd_int()</code></span></span>, <span class="obeylines-h"><span class="verb"><code class="inlineCode">bd_float()</code></span></span>, and <span class="obeylines-h"><span class="verb"><code class="inlineCode">bd_decimal()</code></span></span>. Each of these performed a relatively direct conversion-or-replacement algorithm. We left the <span class="obeylines-h"><span class="verb"><code class="inlineCode">bd_datetime()</code></span></span> function as an exercise for the reader. In this case, the alternative date formats can lead to a bit more complexity.</p>&#13;
<p>We’ll assume that dates must be in one of three formats: ”yyyy-mon-dd”, ”yyyy-mm-dd”, or ”mon-dd” without a year. In the first and third formats, the month name is spelled out. In the second format, the month name is numeric. These are handled by the <span class="obeylines-h"><span class="verb"><code class="inlineCode">datetime.strptime()</code></span></span> function using format strings like <span class="obeylines-h"><span class="verb"><code class="inlineCode">"%Y-%b-%d"</code></span></span>, <span class="obeylines-h"><span class="verb"><code class="inlineCode">"%b-%d"</code></span></span>, and <span class="obeylines-h"><span class="verb"><code class="inlineCode">"%Y-%m-%d"</code></span></span>.</p>&#13;
<p>Write a <span class="obeylines-h"><span class="verb"><code class="inlineCode">bd_datetime()</code></span></span> function to try multiple data format conversions, looking for one that produces a valid date. In the case of a missing year, the <span class="obeylines-h"><span class="verb"><code class="inlineCode">datetime.replace()</code></span></span> method can be used to build a final date result with the current year.</p>&#13;
<p>Once the basic implementation is complete, create appropriate test cases with a mix of valid and invalid dates.</p>&#13;
<p>Be sure to make the design flexible enough that adding another format can be done without too much struggle. <span id="x1-261001r269"/></p>&#13;
</section>&#13;
<section id="optimize-a-decorator" class="level4 subsectionHead" data-number="0.16.8.2">&#13;
<h4 class="subsectionHead" data-number="0.16.8.2"><span class="titlemark">12.8.2 </span> <span id="x1-2620002"/>Optimize a decorator</h4>&#13;
<p>In the <a href="#x1-2560004"><span class="cmti-10x-x-109">Adding a parameter to a decorator</span></a> section of this chapter, we defined a decorator to replace ”bad” characters in a given field and retry an attempted conversion.</p>&#13;
<p>This decorator had an internal function, <span class="obeylines-h"><span class="verb"><code class="inlineCode">clean_list()</code></span></span>, that provided a recursive definition for removing bad characters from a string.</p>&#13;
<p>Here’s the Python function definition:</p>&#13;
<pre id="listing-268" class="lstlisting"><code>    def clean_list(text: str, *, to_replace: tuple[str, ...]) -&gt; str: &#13;
        ...</code></pre>&#13;
<p>This recursion has two cases:</p>&#13;
<ul>&#13;
<li><p>When the <span class="obeylines-h"><span class="verb"><code class="inlineCode">to_replace</code></span></span> argument value is empty, there’s nothing to replace, and the value of the <span class="obeylines-h"><span class="verb"><code class="inlineCode">text</code></span></span> parameter is returned unchanged.</p></li>&#13;
<li><p>Otherwise, split the <span class="obeylines-h"><span class="verb"><code class="inlineCode">to_replace</code></span></span> string to separate the first character from the remaining characters. Remove any occurrence of the first character from the value of the <span class="obeylines-h"><span class="verb"><code class="inlineCode">text</code></span></span> parameter and apply this function again using the remaining characters of the <span class="obeylines-h"><span class="verb"><code class="inlineCode">to_replace</code></span></span> string.</p></li>&#13;
</ul>&#13;
<p>Looking back at <a href="Chapter_06.xhtml#x1-1260006"><span class="cmti-10x-x-109">Chapter</span><span class="cmti-10x-x-109"> 6</span></a>, <a href="Chapter_06.xhtml#x1-1260006"><span class="cmti-10x-x-109">Recursions and Reductions</span></a>, we recall that this kind of tail-call recursion can be transformed into a <span class="obeylines-h"><span class="verb"><code class="inlineCode">for</code></span></span> statement. Rewrite the <span class="obeylines-h"><span class="verb"><code class="inlineCode">clean_list()</code></span></span> function to eliminate the recursion. <span id="x1-262003r270"/></p>&#13;
</section>&#13;
<section id="none-tolerant-functions" class="level4 subsectionHead" data-number="0.16.8.3">&#13;
<h4 class="subsectionHead" data-number="0.16.8.3"><span class="titlemark">12.8.3 </span> <span id="x1-2630003"/>None-tolerant functions</h4>&#13;
<p>In the <a href="#x1-2560004"><span class="cmti-10x-x-109">Adding a parameter to a decorator</span></a> section of this chapter, we saw a design pattern of using a <span class="obeylines-h"><span class="verb"><code class="inlineCode">try:</code></span></span>/<span class="obeylines-h"><span class="verb"><code class="inlineCode">except:</code></span></span> wrapper to uncover numbers with spurious punctuation marks. A similar technique can be used to detect <span class="obeylines-h"><span class="verb"><code class="inlineCode">None</code></span></span> values and pass them through a function, unprocessed.</p>&#13;
<p>Write a decorator that can be used for <span class="obeylines-h"><span class="verb"><code class="inlineCode">Callable[[float],</code><code class="inlineCode"> float]</code></span></span> functions that will handle <span class="obeylines-h"><span class="verb"><code class="inlineCode">None</code></span></span> values gracefully.</p>&#13;
<p>If the none-tolerant decorator is called <span class="obeylines-h"><span class="verb"><code class="inlineCode">@none_tolerant</code></span></span>, here is a test case:</p>&#13;
<pre id="listing-269" class="lstlisting"><code>@none_tolerant &#13;
def x2(x: float) -&gt; float: &#13;
    return 2 * x &#13;
 &#13;
def test_x2() -&gt; None: &#13;
    assert x2(42.) == 84.0 &#13;
    assert x2(None) == None &#13;
    assert list(map(x2, [1, 2, None, 3])) == [2, 3, None, 6]</code></pre>&#13;
<p><span id="x1-263009r271"/></p>&#13;
</section>&#13;
<section id="logging" class="level4 subsectionHead" data-number="0.16.8.4">&#13;
<h4 class="subsectionHead" data-number="0.16.8.4"><span class="titlemark">12.8.4 </span> <span id="x1-2640004"/>Logging</h4>&#13;
<p>A common requirement for debugging is a consistent collection of logging messages. It can become tedious to include a <span class="obeylines-h"><span class="verb"><code class="inlineCode">logger.debug()</code></span></span> line in a number of closely-related functions. If the functions have a consistent set of type definitions, it can be helpful to define a decorator that can be applied to a number of related functions.</p>&#13;
<p>As example functions, we’ll define a collection of ”models” that compute an expected result from sample values. We’ll start with a dataclass to define each sample as having an identifier, an observed value, and a time-stamp. It looks like this:</p>&#13;
<pre id="listing-270" class="lstlisting"><code>from dataclasses import dataclass &#13;
@dataclass(frozen=True) &#13;
class Sample: &#13;
    id: int &#13;
    observation: float &#13;
    date_time: datetime.datetime</code></pre>&#13;
<p>We have three models to compute an expected value, <span class="italic">e</span>, from the observed value in the sample, <span class="italic">s</span><sub><span class="cmmi-8">o</span></sub>:</p>&#13;
<ul>&#13;
<li><p><span class="italic">e </span>= 0<span class="italic">.</span>7412 <span class="cmsy-10x-x-109">× </span><span class="italic">s</span><sub><span class="cmmi-8">o</span></sub></p></li>&#13;
<li><p><span class="italic">e </span>= 0<span class="italic">.</span>9 <span class="cmsy-10x-x-109">× </span><span class="italic">s</span><sub><span class="cmmi-8">o</span></sub> <span class="cmsy-10x-x-109">− </span>90</p></li>&#13;
<li><p><span class="italic">e </span>= 0<span class="italic">.</span>7724 <span class="cmsy-10x-x-109">× </span><span class="italic">s</span><sub><span class="cmmi-8">o</span></sub><sup><span class="cmr-8">1</span><span class="cmmi-8">.</span><span class="cmr-8">0134</span></sup></p></li>&#13;
</ul>&#13;
<p>First, define these three functions with appropriate test cases.</p>&#13;
<p>Second, define a <span class="obeylines-h"><span class="verb"><code class="inlineCode">@logging</code></span></span> decorator to use <span class="obeylines-h"><span class="verb"><code class="inlineCode">logger.info()</code></span></span> to record the sample value and the computed expectation.</p>&#13;
<p>Third, add the <span class="obeylines-h"><span class="verb"><code class="inlineCode">@logging</code></span></span> decorator in front of each function definition.</p>&#13;
<p>Create an overall application that uses <span class="obeylines-h"><span class="verb"><code class="inlineCode">logging.basicConfig()</code></span></span> to set the logging level to <span class="obeylines-h"><span class="verb"><code class="inlineCode">logging.INFO</code></span></span> to ensure that the informational messages are seen. (The default logging level only shows warnings and errors.)</p>&#13;
<p>This permits creating a consistent logging setup for the three ”model” functions. This reflects a complete separation between the logging aspect of the application and the computation of expected values from sample values. Is this separation clear and helpful? Are there circumstances where this separation might not be desirable?</p>&#13;
<p>The actual measurements are given here. One of the models is more accurate than the others:</p>&#13;
<div class="center">&#13;
<div class="tabular">&#13;
<table id="TBL-10" class="tabular">&#13;
<tbody>&#13;
<tr class="odd hline">&#13;
<td><hr/>&#13;
</td>&#13;
<td><hr/>&#13;
</td>&#13;
<td><hr/>&#13;
</td>&#13;
</tr>&#13;
<tr id="TBL-10-1-" class="even" style="vertical-align:baseline;">&#13;
<td id="TBL-10-1-1" class="td11" style="text-align: right; white-space: nowrap;">Sample Number</td>&#13;
<td id="TBL-10-1-2" class="td11" style="text-align: right; white-space: nowrap;">Observed</td>&#13;
<td id="TBL-10-1-3" class="td11" style="text-align: right; white-space: nowrap;">Actual</td>&#13;
</tr>&#13;
<tr class="odd hline">&#13;
<td><hr/>&#13;
</td>&#13;
<td><hr/>&#13;
</td>&#13;
<td><hr/>&#13;
</td>&#13;
</tr>&#13;
<tr id="TBL-10-2-" class="even" style="vertical-align:baseline;">&#13;
<td id="TBL-10-2-1" class="td11" style="text-align: right; white-space: nowrap;">1</td>&#13;
<td id="TBL-10-2-2" class="td11" style="text-align: right; white-space: nowrap;">1000</td>&#13;
<td id="TBL-10-2-3" class="td11" style="text-align: right; white-space: nowrap;">883</td>&#13;
</tr>&#13;
<tr id="TBL-10-3-" class="odd" style="vertical-align:baseline;">&#13;
<td id="TBL-10-3-1" class="td11" style="text-align: right; white-space: nowrap;">2</td>&#13;
<td id="TBL-10-3-2" class="td11" style="text-align: right; white-space: nowrap;">1500</td>&#13;
<td id="TBL-10-3-3" class="td11" style="text-align: right; white-space: nowrap;">1242</td>&#13;
</tr>&#13;
<tr id="TBL-10-4-" class="even" style="vertical-align:baseline;">&#13;
<td id="TBL-10-4-1" class="td11" style="text-align: right; white-space: nowrap;">3</td>&#13;
<td id="TBL-10-4-2" class="td11" style="text-align: right; white-space: nowrap;">1500</td>&#13;
<td id="TBL-10-4-3" class="td11" style="text-align: right; white-space: nowrap;">1217</td>&#13;
</tr>&#13;
<tr id="TBL-10-5-" class="odd" style="vertical-align:baseline;">&#13;
<td id="TBL-10-5-1" class="td11" style="text-align: right; white-space: nowrap;">4</td>&#13;
<td id="TBL-10-5-2" class="td11" style="text-align: right; white-space: nowrap;">1600</td>&#13;
<td id="TBL-10-5-3" class="td11" style="text-align: right; white-space: nowrap;">1306</td>&#13;
</tr>&#13;
<tr id="TBL-10-6-" class="even" style="vertical-align:baseline;">&#13;
<td id="TBL-10-6-1" class="td11" style="text-align: right; white-space: nowrap;">5</td>&#13;
<td id="TBL-10-6-2" class="td11" style="text-align: right; white-space: nowrap;">1750</td>&#13;
<td id="TBL-10-6-3" class="td11" style="text-align: right; white-space: nowrap;">1534</td>&#13;
</tr>&#13;
<tr id="TBL-10-7-" class="odd" style="vertical-align:baseline;">&#13;
<td id="TBL-10-7-1" class="td11" style="text-align: right; white-space: nowrap;">6</td>&#13;
<td id="TBL-10-7-2" class="td11" style="text-align: right; white-space: nowrap;">2000</td>&#13;
<td id="TBL-10-7-3" class="td11" style="text-align: right; white-space: nowrap;">1805</td>&#13;
</tr>&#13;
<tr id="TBL-10-8-" class="even" style="vertical-align:baseline;">&#13;
<td id="TBL-10-8-1" class="td11" style="text-align: right; white-space: nowrap;">7</td>&#13;
<td id="TBL-10-8-2" class="td11" style="text-align: right; white-space: nowrap;">2000</td>&#13;
<td id="TBL-10-8-3" class="td11" style="text-align: right; white-space: nowrap;">1720</td>&#13;
</tr>&#13;
<tr class="odd hline">&#13;
<td><hr/>&#13;
</td>&#13;
<td><hr/>&#13;
</td>&#13;
<td><hr/>&#13;
</td>&#13;
</tr>&#13;
<tr id="TBL-10-9-" class="even" style="vertical-align:baseline;">&#13;
<td id="TBL-10-9-1" class="td11" style="text-align: right; white-space: nowrap;"/>&#13;
<td/>&#13;
<td/>&#13;
</tr>&#13;
</tbody>&#13;
</table>&#13;
</div>&#13;
</div>&#13;
<p><span id="x1-264007r272"/></p>&#13;
</section>&#13;
<section id="dry-run-check" class="level4 subsectionHead" data-number="0.16.8.5">&#13;
<h4 class="subsectionHead" data-number="0.16.8.5"><span class="titlemark">12.8.5 </span> <span id="x1-2650005"/>Dry-run check</h4>&#13;
<p>Applications that can modify the file system require extensive unit testing as well as integration testing. To mitigate risk even further, these applications will often have a ”dry-run” mode where file system modifications are logged but not carried out; files are not moved, directories are not deleted, and so on.</p>&#13;
<p>The idea here is to write small functions for file system state changes. Each function can then be decorated with a <span class="obeylines-h"><span class="verb"><code class="inlineCode">@dry_run_check</code></span></span> decorator. This decorator can examine a global variable, <span class="obeylines-h"><span class="verb"><code class="inlineCode">DRY_RUN</code></span></span>. The decorator writes a log message. If the <span class="obeylines-h"><span class="verb"><code class="inlineCode">DRY_RUN</code></span></span> value is <span class="obeylines-h"><span class="verb"><code class="inlineCode">True</code></span></span>, nothing else is done. If the <span class="obeylines-h"><span class="verb"><code class="inlineCode">DRY_RUN</code></span></span> value is <span class="obeylines-h"><span class="verb"><code class="inlineCode">False</code></span></span>, the base function is evaluated to make the underlying state changes, such as removing files, or removing directories.</p>&#13;
<p>First, define a number of functions to copy a directory. The following state changes need separate functions:</p>&#13;
<ul>&#13;
<li><p>Create a new, empty, directory.</p></li>&#13;
<li><p>Copy a file from somewhere in the source directory to the target directory. We can use an expression like <span class="obeylines-h"><span class="verb"><code class="inlineCode">offset</code><code class="inlineCode"> =</code><code class="inlineCode"> source_path.relative_to(source_dir)</code></span></span> to compute the relative location of a file in the source directory. We can use <span class="obeylines-h"><span class="verb"><code class="inlineCode">target_dir</code><code class="inlineCode"> /</code><code class="inlineCode"> offset</code></span></span> to compute the new location in a target directory. The <span class="obeylines-h"><span class="verb"><code class="inlineCode">pathlib.Path</code></span></span> objects provide all of the features required.</p></li>&#13;
</ul>&#13;
<p>The <span class="obeylines-h"><span class="verb"><code class="inlineCode">pathlib.Path.glob()</code></span></span> method provides a useful view of a directory’s content. This can be used by an overall function that calls the other two functions to create subdirectories and copy files into them.</p>&#13;
<p>Second, define a decorator to block the action if this is a dry run. Apply the decorator to the directory creation function and the file copy function. Note that these two function signatures are different. One function uses a single path, the other function uses two paths.</p>&#13;
<p>Third, create a suitable unit test to confirm that dry-run mode goes through the motions, but doesn’t alter the underlying file system. The <span class="obeylines-h"><span class="verb"><code class="inlineCode">pytest.tmp_path</code></span></span> fixture provides a temporary working directory; using this prevents endlessly having to drop and recreate output directories while debugging.</p>&#13;
<p><span id="x1-265001r258"/></p>&#13;
</section>&#13;
</section>&#13;
</section>&#13;
</body></html>