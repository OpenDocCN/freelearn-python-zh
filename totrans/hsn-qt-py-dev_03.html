<html><head></head><body>
        

                            
                    <h1 class="header-title">An Overview of QML</h1>
                
            
            
                
<p class="mce-root CDPAlignLeft CDPAlign">There are various approaches that you can take and design decisions that you can make when creating a GUI. One of them is creating a GUI with the <strong>Qt Modeling Language </strong>(<strong>QML</strong>) implementation. This chapter will explore the basics of QML, uncover the most commonly used types, and conclude with some practice of using the QML when building applications.</p>
<p>In this chapter, we will cover the following topics:</p>
<ul>
<li>Introduction to QML</li>
<li>The basic syntax of QML</li>
<li>Language and engine</li>
<li>QML styling</li>
<li>QML animation</li>
</ul>


            

            
        
    

        

                            
                    <h1 class="header-title">About QML</h1>
                
            
            
                
<p>QML is a UI markup language and a multi-paradigm declarative language that's similar to CSS and JSON. It is used for designing applications with a GUI. QML is popular and is very important for creating high quality GUIs. QML is a language that allows developers to describe different interfaces in terms of their visual components and how they interact with and relate to each other. </p>
<p>QML is a highly readable language that allows the components to be interconnected dynamically. In this sense, components will be reused and customized within a UI. QML provides a readable and declarative JSON-like syntax with support for imperative JavaScript expressions, combined with dynamic property bindings. Application functionality can be scripted through JavaScript. QML uses Qt, which lets Qt features to be attainable from QML applications. In the Qt framework, the QML language and engine infrastructure is provided by the <kbd>QtQml</kbd> module. To fully understand QML, it is recommended to read the official Qt documentation (<a href="https://doc.qt.io">https://doc.qt.io</a>).</p>
<p>This chapter will present many examples of QML that will be shown as a script in a QML file. Commonly used modules such as <kbd>QtQML</kbd> and <kbd>QtQuick</kbd> (which will be discussed in <a href="519d24a6-7d2c-4f82-8c24-da4460c1ed29.xhtml">Chapter 3</a>, <em>Qt Quick Library</em> ) illustrate QML implementation with Qt. To run QML scripts and display the results, you can use the Qt Creator. To do this, you need to implement the following steps:</p>
<ol>
<li>Create a directory with the name <kbd>Qt/</kbd> inside the <kbd>App/</kbd> folder, for example, <kbd>App/Qt/</kbd>.</li>
<li>Open Qt Creator and navigate to File | New File or Project:</li>
</ol>
<p class="CDPAlignCenter CDPAlign"><img src="img/ac4e56db-f0eb-460e-946d-14230c9b4ba3.png"/></p>
<ol start="3">
<li>Navigate to Choose a template | Application | Qt Quick Application - Empty and click on Choose...: </li>
</ol>
<p class="CDPAlignCenter CDPAlign"><img src="img/6ec963e2-d83f-4620-aff0-05cf2fa48dda.png"/></p>
<ol start="4">
<li>Set the Name as <kbd>qml1</kbd> and enter <kbd>Path/To/The/App/Qt/</kbd> in the Create in field:</li>
</ol>
<p class="CDPAlignCenter CDPAlign"><img src="img/31a05958-73f2-42ec-b751-1f2fd9589ff6.png" style="font-size: 1em;text-align: center;color: #333333;"/></p>
<ol start="5">
<li>Click Next through the windows that follow and select all kits when you reach the Kits window. Then, click Next and Finish. </li>
<li>Add the <kbd>Rectangle</kbd> QML type to the <kbd>Window</kbd> QML type inside the <kbd>main.qml</kbd> file.</li>
<li>Click on the Build Project button.</li>
<li>Finally, click on the Run button:</li>
</ol>
<p class="CDPAlignCenter CDPAlign"><img src="img/458e7492-ad0a-413b-a33f-d561823ba054.png" style="width:58.83em;height:33.08em;"/></p>
<p class="mce-root"/>
<p class="mce-root"/>
<p style="padding-left: 90px">The following screenshot depicts the output of the preceding code:</p>
<p class="CDPAlignCenter CDPAlign"><img src="img/7654cf0c-65a3-4c48-9519-26b9c6b70833.png" style="width:58.42em;height:32.83em;"/></p>
<p>Alternatively, you can use Python. To run these examples using Python and PyQt5 binding (PySide2 can be used), you need to create a file, for example, <kbd>u_qml.qml</kbd>, inside the <kbd>App/</kbd> directory, as described in <a href="9de812dc-9446-4955-8437-4aebb2d991b3.xhtml">Chapter 1</a>, <em>Introduction to Python and Qt</em>, and then make some changes in the <kbd>u_app.py</kbd> and <kbd>u_tools.py</kbd> files. </p>
<p>The changes in the <kbd>u_tools.py</kbd> file are as follows:</p>
<pre># -*- coding: utf-8 -*-<br/>from PyQt5.QtCore import QUrl<br/>from PyQt5.QtQml import QQmlApplicationEngine<br/><br/>                                            <br/>class UTools(): <br/><br/>    def __init__(self):<br/>        self.us1 = "QML with Python."<br/><br/>    def u_qml(self):<br/>        self.qwid = QQmlApplicationEngine()<br/>        self.qwid.load(QUrl('u_qml.qml'))<br/><br/><br/>if __name__ == "__main__":<br/>    ut = UTools()</pre>
<p>The <kbd>u_qml()</kbd> function that's created in this class will be used to display the QML application. Using the QML application engine will load the QML file with a specified URL.</p>
<p>The changes in the <kbd>u_app.py</kbd> file are as follows:</p>
<pre># -*- coding: utf-8 -*-<br/>from PyQt5 import QtWidgets<br/>from u_tools import UTools<br/><br/><br/>class UApp(QtWidgets.QWidget, UTools):<br/><br/>    def __init__(self, parent=None):<br/>        QtWidgets.QWidget.__init__(self, parent)<br/>        UTools.__init__(self)<br/>        self.start_qml()<br/><br/>    def start_qml(self):<br/>        self.u_qml()<br/><br/><br/>if __name__ == "__main__":<br/>    import sys<br/>    app = QtWidgets.QApplication(sys.argv)<br/>    uap = UApp()<br/>    # uap.show()<br/>    sys.exit(app.exec_())</pre>
<p>The <kbd>start_qml()</kbd><strong> </strong>function will start the <kbd>u_qml()</kbd> function of the <kbd>UTools</kbd> class, which will display the QML application. Then, we need to create the <kbd>u_qml.qml</kbd> file in the <kbd>App/</kbd> folder, which will be the QML application. </p>
<p>The <kbd>u_qml.qml</kbd><strong> </strong>file looks like this:</p>
<pre>import QtQuick.Window 2.2<br/><br/>Window {<br/>    visible: true<br/>    width: 350<br/>    height: 590<br/>    title: qsTr("First Qml")<br/>}</pre>
<p>You should see a blank window with the title First Qml.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">Basics of the syntax</h1>
                
            
            
                
<p>Let's describe the basics of the QML syntax, step by step.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">Import statements</h1>
                
            
            
                
<p>A QML document may have one or more imports at the beginning of the file. An import can be any one of the following:</p>
<ul>
<li>A namespace into which types have been registered:</li>
</ul>
<pre style="padding-left: 60px">import QtQuick 2.7</pre>
<p>The version number of the <kbd>QtQuick</kbd> module and other QML-related modules may vary, depending on your installed Qt version.</p>
<ul>
<li>A directory that contains type definitions as QML documents:</li>
</ul>
<pre style="padding-left: 60px">import QtQuick.LocalStorage 2.0 as Database<br/>import "../privateComponents"</pre>
<ul>
<li>A JavaScript file: </li>
</ul>
<pre style="padding-left: 60px">import "somefile.js" as Script</pre>


            

            
        
    

        

                            
                    <h1 class="header-title">Import types</h1>
                
            
            
                
<p>QML has three different types of imports. Each import type has a slightly different syntax and semantics.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">Module namespace imports</h1>
                
            
            
                
<p>Module namespace imports are imported QML modules that register QML object types and JavaScript resources into a given namespace. An example is <kbd>import &lt;ModuleIdentifier&gt; &lt;Version.Number&gt; [as &lt;Qualifier&gt;]</kbd>. Here is an example of an unqualified module import:</p>
<pre>import QtQuick 2.7</pre>
<p>This allows us to use all types of <kbd>QtQuick 2.7</kbd> without specifying a qualifier.</p>
<p>The <kbd>u_qml.qml</kbd> file demonstrates using the imports in QML:</p>
<pre>import QtQuick 2.7<br/>import QtQuick.Window 2.2<br/><br/>Window {<br/>    ...<br/>}</pre>
<p>Here's a qualified module import:</p>
<pre>import QtQuick.Window 2.2 as UQml<br/><br/>UQml.Window {<br/>    visible: true<br/>    width: 350<br/>    height: 590<br/>    title: qsTr("First Qml")<br/>}</pre>
<p>This code imports <kbd>QtQuick.Window</kbd> as <kbd>UQml</kbd> and declares a window with properties. This prevents conflicting type names from being imported.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">Non-module namespace imports</h1>
                
            
            
                
<p>Types can also be registered into namespaces in C++ with registration functions such as <kbd>qmlRegisterType()</kbd>. If we import a namespace as if it were a module identifier, then these types can be imported. Similar to importing into a qualified local namespace, the <kbd>import</kbd> statement can use the <kbd>as</kbd> keyword to indicate that the types should be imported into a specific document-local namespace. Any references to the types that are made accessible by the import must be prefixed by the local namespace qualifier if a namespace is defined.</p>
<p>Here's an example in the <kbd>u_qml.qml</kbd><strong> </strong>file:</p>
<pre>import QtQuick 2.7 as UQml<br/>import QtQuick.Window 2.2 as UQml<br/><br/>UQml.Window {<br/>    ...<br/>    UQml.Rectangle {<br/>        color: "#FF0000"<br/>        width: 140<br/>        height: 140<br/>        border.color: "#FF0000"<br/>        border.width: 1<br/>        radius: width * 0.5<br/>    } <br/>}</pre>
<p>First is the declaration of the <kbd>Rectangle</kbd> QML type. Then, the hexadecimal value for the <kbd>color</kbd> of the <kbd>Rectangle</kbd> is set, along with the <kbd>width</kbd> and the <kbd>height</kbd>. Then, the hexadecimal value for the color of border is set, including the <kbd>border.width</kbd> of the <kbd>Rectangle</kbd> and the <kbd>radius</kbd>.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">Directory imports</h1>
                
            
            
                
<p class="mce-root">These import a directory containing QML documents that provides segmentation for QML types into reusable groups and directories in the filesystem.</p>
<p>An example of these imports is as follows:</p>
<pre>import "Path/To/The/Directory/With/Qml/" as <strong>Qualifier</strong></pre>
<p>To demonstrate this, divide the <kbd>u_qml.qml</kbd> file into two parts. The first part creates a window, while the second part creates a circle. Create the <kbd>qmls/</kbd> directory inside <kbd>App/</kbd> and put the <kbd>UCircle.qml</kbd> file inside it.</p>
<p>The content of the <kbd>UCircle.qml</kbd> file looks like this:</p>
<pre>import QtQuick 2.7<br/><br/>Rectangle {<br/>    color: Qt.rgba(1, 0, 0, 1);<br/>    border.color: Qt.rgba(0.9, 0, 0, 1);<br/>    border.width: 1<br/>    radius: width * 0.5<br/>}</pre>
<p>First is the declaration of the <kbd>Rectangle</kbd> QML type. Then, the RGBA value for the color of the <kbd>Rectangle</kbd>, the <kbd>width</kbd> of the <kbd>Rectangle</kbd>, the <kbd>height</kbd> of the <kbd>Rectangle</kbd>, the <kbd>border.width</kbd> of the <kbd>Rectangle</kbd>, and the <kbd>radius</kbd> for the change of the rectangle to the circle are set.</p>
<p>In the <kbd>u_qml.qml</kbd> file, we can add this circle by importing the <kbd>App/qmls/</kbd> folder:</p>
<pre>import QtQuick.Window 2.2 as UQml<br/>import "qmls" as Uqmls<br/><br/>UQml.Window {<br/>    ...<br/>    Uqmls.UCircle {<br/>        width: UQml.Window.width<br/>        height: UQml.Window.height<br/>    }<br/>}</pre>
<p>We used the circle that was created in a separate QML file.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">JavaScript resource imports</h1>
                
            
            
                
<p>These imports can import JavaScript resources directly into a QML document. Each JavaScript resource must have an identifier that it can be accessed with the following:</p>
<pre>import "Path/To/Javascript/File" as <strong>Identifier</strong></pre>
<p>To demonstrate this, let's create a directory inside our <kbd>App/</kbd> folder called <kbd>App/jscripts/</kbd> and put the <kbd>u_js.js</kbd> file there:</p>
<pre>function hsize(height) {<br/>    return height - 10;<br/>}</pre>
<p>In the <kbd>u_qml.qml</kbd> file, we can add an import of JavaScript:</p>
<pre>...<br/>import "qmls" as Uqmls<br/>import "jscripts/u_js.js" as Ujs<br/><br/>UQml.Window {<br/>    ...</pre>
<p>The following code shows how to add the circle and the mouse area to <kbd>UQml.Window</kbd> in the <kbd>u_qml.qml</kbd> file:</p>
<pre>...<br/>UQml.Window {<br/>    ...<br/>    Uqmls.UCircle {<br/>        id: rcircle<br/>        anchors.centerIn: parent<br/>        ...<br/>    }<br/>    MouseArea {<br/>        anchors.fill: parent<br/>        onClicked: rcircle.height = Ujs.hsize(rcircle.height);<br/>    }<br/>}</pre>
<p>In this example, we imported JavaScript to resize the circle. The <kbd>MouseArea</kbd> QML type realizes the area that can be clicked.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">QML object declaration</h1>
                
            
            
                
<p> QML has the following object declaration syntax in the QML document.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">Objects</h1>
                
            
            
                
<p>Objects are specified by the type, with a pair of braces. Each object type begins with a capital letter. Inside the curly brackets, we can specify information about the object, such as its properties. Properties are set as <kbd>property: value</kbd>. Each object may declare a child object as a nested object and may contain any number of child objects, as shown in the preceding examples. Let's see some new examples:</p>
<ol>
<li>Create a new QML file in the <kbd>qmls/</kbd> directory called <kbd>URect.qml</kbd> – this will be a rectangle. Add the following lines:</li>
</ol>
<pre style="padding-left: 60px">import QtQuick 2.7<br/><br/>Rectangle {}</pre>
<ol start="2">
<li>In the <kbd>u_qml.qml</kbd> file, add the created rectangle:</li>
</ol>
<pre style="padding-left: 60px">import QtQuick 2.7<br/>import QtQuick.Window 2.2 as UQml<br/>import "qmls" as Uqmls<br/><br/>UQml.Window {<br/>    visible: true<br/>    width: 350<br/>    height: 590<br/>    title: qsTr("First Qml")<br/>    ...<br/>}</pre>
<p style="padding-left: 60px">We're rewriting the previously created lines and adding the <kbd>Window</kbd> QML type and new properties.</p>
<ol start="3">
<li>Now,<kbd>rect1</kbd> will be added to the bottom of <kbd>UQml.Window</kbd>:</li>
</ol>
<pre style="padding-left: 60px">...<br/>    ....<br/>    Uqmls.URect {<br/>        id: rect1<br/>        color: "#000000"<br/>        width: parent.width - (parent.width / 5)<br/>        height: parent.height<br/>        MouseArea {<br/>            anchors.fill: parent<br/>            onClicked: rect1.color = "#222222";<br/>        }<br/>    }<br/>}</pre>
<p style="padding-left: 60px">We added the rectangle that was created in <kbd>URect.qml</kbd> file with the <kbd>id</kbd>, <kbd>width</kbd>, <kbd>height</kbd>, and <kbd>color</kbd> properties. The <kbd>MouseArea</kbd> QML type is used to click on the rectangle and, as a result, changes its color.</p>
<ol start="4">
<li>Then, add <kbd>rect2</kbd> after the first rectangle:</li>
</ol>
<pre style="padding-left: 60px">...<br/>    ...<br/>    Uqmls.URect {<br/>        id: rect2<br/>        color: "#00293b"<br/>        x: rect1.width<br/>        width: parent.width / 5 <br/>        height: parent.height<br/>        MouseArea {<br/>            anchors.fill: parent<br/>            onClicked: rect2.color = "#340147";<br/>        }<br/>    }<br/>}</pre>
<p style="padding-left: 60px">The second rectangle is the nested object of the window. The <kbd>id</kbd> attribute must be unique. The position of <kbd>rect2</kbd> is dependent on the position of <kbd>rect1</kbd> .</p>


            

            
        
    

        

                            
                    <h1 class="header-title">Comments</h1>
                
            
            
                
<p>QML comments can be both single and multilined. A single comment starts with <kbd>//</kbd> and ends at the end of the line. Multiline comments begin with <kbd>/*</kbd> and end with <kbd>*/</kbd>.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">Object attributes</h1>
                
            
            
                
<p>Each QML object type has a set of attributes. The instance of an object type is built with the set of attributes that has been defined for that object type. The QML object attribute types are as follows:</p>
<ul>
<li>The <kbd>id</kbd> attribute</li>
<li><kbd>property</kbd> attributes</li>
<li><kbd>signal</kbd> attributes</li>
<li>Signal handler attributes</li>
<li>Method attributes</li>
<li>Attached properties and attached signal handler attributes</li>
</ul>


            

            
        
    

        

                            
                    <h1 class="header-title">id attribute</h1>
                
            
            
                
<p class="mce-root">Every QML object type has an <kbd>id</kbd> attribute that is provided by the language itself, and it can't be redefined or overridden by any object type. A value can be assigned to the <kbd>id</kbd> attribute of an object instance, which identifies the object and allows it to be referred to by other objects. </p>
<p class="mce-root">An <kbd>id</kbd> attribute must begin with a lowercase letter or an underscore and can include characters such as numbers, letters, and underscores. Objects can be referred to by <kbd>id</kbd> from anywhere within the component scope in which it is declared. It is important that the <kbd>id</kbd> value is always unique. When an object is created, the value of its <kbd>id</kbd> attribute cannot be changed. To demonstrate this, implement the following steps:</p>
<ol>
<li class="mce-root">Create a file called <kbd>UText.qml</kbd> inside the <kbd>qmls/</kbd> directory, and add the following lines:</li>
</ol>
<pre style="padding-left: 60px">import QtQuick 2.7<br/><br/>Text {<br/>    color: "#FFFFFF"<br/>}</pre>
<p style="padding-left: 60px">This code creates text that will be displayed with a white color.</p>
<ol start="2">
<li>Add <kbd>Uqmls.UText</kbd> at the bottom of <kbd>rect1</kbd> in the <kbd>u_qml.qml</kbd> file:</li>
</ol>
<pre style="padding-left: 60px">...<br/>    ...<br/>        ...<br/>        Uqmls.UText {<br/>            id: utext1<br/>            x: 20<br/>            y: 50<br/>            font.family: "Open"<br/>            font.pixelSize: 37<br/>            width: rect1.width - (20 * 2)<br/>            text: "text 1"<br/>        }<br/>        Uqmls.UText {<br/>            id: utext2<br/>            x: 20<br/>            y: utext1.height + (50 * 2)<br/>            font.family: "Verdana"<br/>            font.pixelSize: 27<br/>            width: rect1.width - (20 * 2) <br/>        }<br/>        Uqmls.UText {<br/>            id: utext3<br/>            x: 20<br/>            y: (utext1.height + utext2.height) + (50 * 3)<br/>            font.family: "Open Sans"<br/>            font.pointSize: 14<br/>            width: rect1.width - (20 * 2)<br/>        }<br/>        ...<br/>    ...<br/>...</pre>
<p style="padding-left: 60px">This demonstrates properties such as font family and font size. </p>
<ol start="3">
<li>Add the second rectangle, which will be used as a right panel, to <kbd>UQml.Window</kbd>:</li>
</ol>
<pre style="padding-left: 60px">...<br/>    ...<br/>    Uqmls.URect {<br/>        ...<br/>        MouseArea {<br/>            anchors.fill: parent<br/>            onClicked: {<br/>                rect2.color = "#340147";<br/>                utext2.text = "text 2";<br/>                utext3.text = "text 3";<br/>            }<br/>        }<br/>    } <br/>}</pre>
<p style="padding-left: 60px">This code will add new features that will be used when <kbd>rect2</kbd> is clicked, such as changing the color and setting text of <kbd>rect2</kbd>. We can see the result of this QML as follows:</p>
<p class="CDPAlignCenter CDPAlign"><img src="img/61b9adc1-8b19-436e-a290-7110291a5759.png" style="width:21.08em;height:38.00em;"/></p>
<p style="padding-left: 60px">If we click on the left area of this window, the color of this area will change. If the right area is clicked, two pieces of text will be displayed, and the color of the right panel will change.</p>
<p class="mce-root"/>
<p class="mce-root"/>


            

            
        
    

        

                            
                    <h1 class="header-title">Property attributes</h1>
                
            
            
                
<p>Properties in QML are attributes of an object that can be assigned as static values or can be bound to a dynamic expression. You can define a property for a type in C++ by registering a <kbd>Q_PROPERTY()</kbd> macro and registering it with the QML type system. As described in the preceding examples, a custom property can be defined in an object declaration with the following syntax: <kbd>property propertyType propertyName</kbd>. The name of the declared property must begin with a lowercase letter and can contain letters, numbers, and underscores. It is not permitted to use reserved JavaScript words as property names. Custom properties implicitly create a value-change signal for that property. The signal handler associated with this property will be in the form of <kbd>onPropertyNameChanged</kbd>, where <kbd>PropertyName</kbd> is the name of the property, with the first letter capitalized. One of the main features of QML is the binding of properties. Binding allows us to use dynamic object behavior by specifying relationships between object properties, depending on changes. Let's implement the following steps:</p>
<ol>
<li>Create the <kbd>UButton.qml</kbd> file in the <kbd>qmls/</kbd> directory with a simple <kbd>Button</kbd> type inside it:</li>
</ol>
<pre style="padding-left: 60px">import QtQuick.Controls 2.2<br/><br/>Button {<br/>    flat: true<br/>    highlighted: true<br/>}</pre>
<p style="padding-left: 60px">This will create the standard QML button. </p>
<ol start="2">
<li>Look at the features in the <kbd>u_qml.qml</kbd> file. Change some lines and add the standard QML button.</li>
</ol>
<p style="padding-left: 60px">Add a custom property to the first rectangle and change the <kbd>MouseArea</kbd> so that you have something similar to the following code:</p>
<pre style="padding-left: 60px">...<br/>    ...<br/>    Uqmls.URect {<br/>        id: rect1<br/>        ...<br/>        property int rzwidth: parent.width - (parent.width / 5)<br/>        width: parent.width<br/>        height: parent.height<br/>        MouseArea {<br/>            ...<br/>            onClicked: {<br/>                rect1.width = rect1.rzwidth;<br/>                rect2.visible = true;<br/>            }<br/>        }<br/>    }<br/>    ...<br/>...</pre>
<p style="padding-left: 60px"><kbd>rzwidth</kbd> is a custom property on the initialization.</p>
<ol start="3">
<li>Change the second rectangle and add the button:</li>
</ol>
<pre style="padding-left: 60px">...<br/>    ...<br/>    Uqmls.URect {<br/>        id: rect2<br/>        visible: false<br/>        ...<br/>        Uqmls.UButton {<br/>            text: "Hide"<br/>            onClicked: {<br/>                rect2.visible = false;<br/>                rect1.width = UQml.Window.width;<br/>            }<br/>        }<br/>    } <br/>}</pre>
<p style="padding-left: 60px">Setting the visible property to <kbd>false</kbd> means that <kbd>rect2</kbd> will not be visible. When the button is clicked, the imperative value assignment is used for resizing <kbd>rect1</kbd>. The result looks as follows:</p>
<p class="CDPAlignCenter CDPAlign"><img src="img/df329f31-a3cf-4d1a-8790-ae90c4d0a025.png" style="width:23.58em;height:16.00em;"/></p>
<p>QML allows the following valid types with custom property definitions:</p>
<ul>
<li><kbd>int 1</kbd></li>
<li><kbd>string "String"</kbd></li>
<li><kbd>url "https://doc.qt.io"</kbd></li>
</ul>
<p>Any QML object type can be used as a property type, for example, <kbd>property Rectangle YouRectangle</kbd>.</p>
<p>The value of the property of the object instance may be specified as a value assignment on initialization or by imperative value assignment. Assigning a value to a property on initialization will be done in the following form:</p>
<pre>property int rzwidth: UQml.Window.width - (UQml.Window.width / 5)</pre>
<p>Imperative value assignment is where a property value is assigned to a property using imperative JavaScript code:</p>
<pre>onClicked: { rect2.visible = false; }</pre>
<p>Values that can be assigned to a property can be in static or binding expression form. A static value is a constant value that does not depend on other properties, and a binding expression is a JavaScript expression that describes the binding of a property with other properties. The property value must match the property type. Also, it can be assigned a list type property, where the list consists of QML object-type values as states, for example, <kbd>[State {name: "value1"}, State {name: "value2"}]</kbd>.  Properties can be grouped like so for <kbd>font</kbd> values of the <kbd>Text</kbd> object:</p>
<pre>Text {<br/>    font {pixelSize: 12; family: "Verdana"}<br/>}</pre>
<p>The property can be declared as an alias property, which means that the property connects the aliasing property as a reference to the aliased property. A property alias declaration is similar to an ordinary property definition with an added alias keyword and valid alias reference.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">Signal attributes</h1>
                
            
            
                
<p>A <strong>signal</strong> is a notification from an emitter object stating that an event has occurred. This may be a change in text, pressing a button, moving the cursor, and so on. Through the signal handler, some objects can be notified that a signal has been emitted. Signal declarations can be in the following forms:</p>
<pre>Item {<br/>    signal clicked<br/>    signal hovered()<br/>    signal actionPerformed(string action, var actionResult)<br/>}</pre>
<p>With such a property, a signal may be defined for a type in C++ by registering a <kbd>Q_SIGNAL</kbd> macro with the QML type system. Also, a custom signal can be defined in a QML document. Typically, a QML signal handler definition is provided inside the object where the signal will be issued, as in the preceding <kbd>MouseArea</kbd> example. Also, QML allows us to use signals separately from the object with the <kbd>Connections</kbd> type.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">Signal handler attributes</h1>
                
            
            
                
<p>To demonstrate the implementation of signal handlers, let's look at the <kbd>u_qml.qml</kbd> file:</p>
<pre>...<br/>UQml.Window {<br/>    ...<br/>    color: "#000F1F"</pre>
<p>This adds a background color to the application window. Now, let's perform the following steps:</p>
<ol>
<li>Add a <kbd>Connections</kbd> type and a custom handler to the first rectangle:</li>
</ol>
<pre style="padding-left: 60px">    Uqmls.URect {<br/>        id: rect1<br/>        signal colored(color uColor)<br/>        ...<br/>        property int rzwidth<br/>        ...<br/>        height: parent.height / 10<br/>        onColored: rect1.color = uColor;<br/>        MouseArea {<br/>            id: marea1<br/>            anchors.fill: parent<br/>        }<br/>        Connections {<br/>            target: marea1<br/>            onClicked: {<br/>                rect1.width = rect1.rzwidth;<br/>                rect2.visible = true;<br/>            }<br/>            onPressed: rect1.colored("#002737")<br/>        }<br/>    }</pre>
<p style="padding-left: 60px">This adds the <kbd>onColored</kbd><strong> </strong>signal handler and creates the connections for the mouse area of the rectangle. It also sets the target for <kbd>Connections</kbd> as the mouse area of <kbd>rect1</kbd>.</p>
<ol start="2">
<li>Add some additional properties for the button of the second rectangle:</li>
</ol>
<pre style="padding-left: 60px">    Uqmls.URect {<br/>        ...<br/>        Uqmls.UButton {<br/>            id: ubut1<br/>            width: rect2.width<br/>            height: rect2.height / 10<br/>            text: "Hide"<br/>            onClicked: {<br/>                rect2.visible = false;<br/>                rect1.width = UQml.Window.width;<br/>            }<br/>        }<br/>    }<br/>}</pre>
<p style="padding-left: 60px">This code adds the <kbd>width</kbd> and <kbd>height</kbd> properties to the button with the <kbd>id</kbd> specified. We can see the result of this if we run the <kbd>u_app.py</kbd> file:</p>
<p class="CDPAlignCenter CDPAlign"><img src="img/ab46069b-b525-4e78-a569-7b8c3a56fb33.png" style="width:20.50em;height:14.83em;"/></p>
<p>As we can see, the <kbd>colored()</kbd> signal was declared in the <kbd>rect1</kbd> object, and then was emitted with the <kbd>onPressed</kbd> signal handler of the <kbd>Connections</kbd> related to the <kbd>MouseArea</kbd> by <kbd>id</kbd>. This signal was received by the <kbd>onColored</kbd> signal handler of <kbd>rect1</kbd>.  A lot of QML types have defined signals. For example, text fields have <kbd>accepted()</kbd>, <kbd>editingFinished()</kbd>, <kbd>textEdited()</kbd>; buttons have <kbd>Button</kbd>, <kbd>RadioButton</kbd>, and <kbd>CheckBox</kbd>, while <kbd>ComboBox</kbd> has <kbd>clicked()</kbd>, <kbd>accepted()</kbd>, and <kbd>activated()</kbd> signals, respectively. Signals will be described in more detail in <a href="a3094641-a532-4f1a-adf1-72c85526f7bf.xhtml">Chapter 15</a>, <em>Signals, Slots, and Event Handler</em>s, along with how they are related to PyQt and PySide, but their logic is similar.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">Method attributes</h1>
                
            
            
                
<p>Some functions can be defined to realize a certain functionality. Methods can be registered with the QML type system with the <kbd>Q_INVOKABLE</kbd> macro or by registering it as a <kbd>Q_SLOT</kbd> macro, such as with signals. A custom method can be defined by adding <kbd>function functionName(parameterName) {body of the function}</kbd> to the object declaration. Usually, methods provide some functionality related to the calculation or usage of the JavaScript code. Let's look at an example of using this function with QML.</p>
<p>Let's add a method to <kbd>rect1</kbd>:</p>
<pre>...<br/>    ...<br/>    Uqmls.URect {<br/>        id: rect1<br/>        ...<br/>        function onUcolor(ucolor) {<br/>            if (ucolor=="#000F1D") {<br/>                return "#000F1F";<br/>            } else {<br/>                return "#000F1D";<br/>            };<br/>        } <br/>        onColored: rect1.color = onUcolor(rect1.color);<br/>        ...<br/>    ...<br/>...</pre>
<p>The <kbd>onUcolor</kbd> function will return a white color if <kbd>rect1</kbd> is not white and return <em>shuttle</em> color (the color that looks similar to dark blue) if the color is white.</p>
<p class="mce-root"/>


            

            
        
    

        

                            
                    <h1 class="header-title">JavaScript and QML</h1>
                
            
            
                
<p>One of the strongest features of QML is the ability to provide JavaScript functionality. This allows us to use various expressions and methods as JavaScript functions. QML has deep JavaScript integration, which allows it to use the definitions of methods and signal handlers in JavaScript form. We discussed using JavaScript as an imported resource in the <em>Import statements</em> section. Let's take a look at the JavaScript host environment and the restrictions of its use.</p>
<p>The QML engine provides a JavaScript environment, and this environment is slightly different from the environments provided by web browsers. QML documents may contain JavaScript code in the following forms:</p>
<ul>
<li>With property bindings, where the code describes relationships between QML object properties.</li>
<li>With the implementation of the signal handlers.</li>
<li>In the definition of the custom methods, where functions are defined within the body of a QML object and may consist of the variable setting, arrays, loops, and conditional operators.</li>
<li>As an import of the standalone JavaScript files.</li>
</ul>
<p>There are environment restrictions for JavaScript code:</p>
<ul>
<li>JavaScript code cannot modify the global object if this code is located inside <kbd>somefile.qml</kbd>, and can modify the global object from <kbd>somefile.js</kbd>.</li>
<li>Global code is run in a reduced scope, except for code with local script variables.</li>
<li>The <kbd>this</kbd> keyword is only available with binding properties and is not defined in QML.</li>
</ul>


            

            
        
    

        

                            
                    <h1 class="header-title">Type system and QML documents</h1>
                
            
            
                
<p>In QML, types can be used in the definition of an object natively by the QML language, registered via C++, or QML documents. This can be represented as follows:</p>
<ul>
<li><strong>Basic types</strong>:</li>
<li style="padding-left: 30px"><kbd>bool</kbd>: <kbd>true</kbd>/<kbd>false</kbd> values.</li>
<li style="padding-left: 30px"><kbd>double</kbd>: Decimal numbers with double precision.</li>
<li style="padding-left: 30px"><kbd>enumeration</kbd>: Named values.</li>
<li style="padding-left: 30px"><kbd>int</kbd>: Integer numbers.</li>
<li style="padding-left: 30px"><kbd>list</kbd>: Lists of QML objects.</li>
<li style="padding-left: 30px"><kbd>real</kbd>: Decimal numbers.</li>
<li style="padding-left: 30px"><kbd>string</kbd>: Text strings.</li>
<li style="padding-left: 30px"><kbd>url</kbd>: Universal resource locators.</li>
<li style="padding-left: 30px"><kbd>var</kbd>: Generic property.</li>
<li><strong>JavaScript types</strong>: Any JavaScript objects allowed by the QML engine.</li>
<li><strong>QML object types</strong>: Modules provided by QML, such as the <kbd>QtQuick</kbd> module.</li>
</ul>
<p>A QML document, represented as a string, written using the syntactical rules of a QML document, has a file extension of <kbd>.qml</kbd> and contains a validated structure. The structure of the document is usually in two parts. The first part is an <kbd>import</kbd> section while the second part is an object declaration section, separated by an empty line. Since QML is transparent to the network, this makes it possible to import QML documents from local and remote paths.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">The QtQml module</h1>
                
            
            
                
<p>In contrast with the <kbd>QtQuick</kbd> module, which provides the UI components and functionality, the <kbd>QtQml</kbd> module provides a framework for developing applications with QML and realizes the language and engine infrastructure. This module provides an API to extend QML with custom type implementation and allows us to integrate QML with JavaScript and C++. Some of the types that are usually used with <kbd>QtQml</kbd> are described here. The module has the <kbd>import</kbd> statement:</p>
<pre>import QtQml 2.0</pre>
<p>This can be interpreted as a C++ preprocessor:</p>
<pre>#include &lt;QtQml&gt;</pre>
<p>Let's go over the types of infrastructure objects that <kbd> QtQml</kbd> includes.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">Component</h1>
                
            
            
                
<p>A QML component definition has the following properties:</p>
<p><kbd>progress</kbd>: A <kbd>real</kbd> value that shows the progress of loading the component, and can range from <kbd>0.0</kbd> to <kbd>1.0</kbd>.</p>
<p><kbd>status</kbd>: This <kbd>enumeration</kbd> shows the status of the component loading.</p>
<p><kbd>url</kbd>: This is the <strong>Universal Resource Locator</strong> (<strong>URL</strong>) that's used for component construction.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">QtObject</h1>
                
            
            
                
<p>This type contains the <kbd>objectName</kbd> property:</p>
<p><kbd>objectName</kbd>: This is the name of the object for a specific string.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">Binding</h1>
                
            
            
                
<p>This type is for creating property bindings. This type has the following properties:</p>
<p><kbd>delayed</kbd>: This can be <kbd>true</kbd> or <kbd>false</kbd>. If it's <kbd>true</kbd>, the binding will be delayed.</p>
<p><kbd>property</kbd>: This can be any string and specifies the name of the property to be updated.</p>
<p><kbd>target</kbd>: This is the object to be updated.</p>
<p><kbd>value</kbd>: This can be any object or property and sets the value for the target object and property.</p>
<p><kbd>when</kbd>: This can be <kbd>true</kbd> or <kbd>false</kbd> and is set when a binding is active. An expression should return <kbd>true</kbd> or <kbd>false</kbd>.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">Connections</h1>
                
            
            
                
<p>This type provides connections to signals. These are the available properties:</p>
<p><kbd>enabled</kbd>: This can be <kbd>true</kbd> or <kbd>false</kbd>. Connections and events are enabled for an item.</p>
<p><kbd>ignoreUnknownSignals</kbd>: This can be <kbd>true</kbd> or <kbd>false</kbd> and allows us to ignore unknown signals, such as errors.</p>
<p><kbd>target</kbd>: This is an object, and the emitter of the signal.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">Timer</h1>
                
            
            
                
<p>This QML type provides the timer that triggers an action with an interval. It has the following properties:</p>
<p><kbd>interval</kbd>: This integer sets the interval in milliseconds (the default is <kbd>1000</kbd> ms).</p>
<p><kbd>repeat</kbd>: This can be <kbd>true</kbd> or <kbd>false</kbd>, and repeats this trigger if this property is <kbd>true</kbd>.</p>
<p><kbd>running</kbd>: This can be <kbd>true</kbd> or <kbd>false</kbd>. If the property is <kbd>true</kbd>, it starts the timer.</p>
<p><kbd>triggeredOnStart</kbd>: This can be <kbd>true</kbd> or <kbd>false</kbd>. If the property is <kbd>true</kbd>, it starts the trigger when the timer starts.</p>
<p class="mce-root">In addition, <kbd>QtQml</kbd> includes a submodule, <kbd>QtQml.Models</kbd>, that defines data models in QML.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">Styling in QML</h1>
                
            
            
                
<p>We've completed the short introduction to QML syntax. Let's try to implement some of the properties of objects to better visualize the elements and improve their style.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">Item</h1>
                
            
            
                
<p>The most commonly used QML type that is inherited by almost all geometrical visualized object types is <kbd>Item</kbd>. This is a base type for all visual items in <kbd>QtQuick</kbd>. The <kbd>import</kbd> statement that's used in QML is as follows:</p>
<pre>import QtQuick 2.7</pre>
<p>Note that versions of <kbd>QtQuick</kbd> can vary, depending on the version of Qt that you have installed. </p>
<p>The properties of the item type are as follows:</p>
<p><kbd>enabled</kbd>: This can be <kbd>true</kbd> or <kbd>false</kbd>. The item is enabled to receive mouse and keyboard events (the default is <kbd>true</kbd>).</p>
<p><kbd>x</kbd>: This is a <kbd>real</kbd> number that sets the position of this item on the <em>x</em> axis (the default is <kbd>0.0</kbd>).</p>
<p><kbd>y</kbd>: This is a <kbd>real</kbd> number that sets the position of this item on the <em>y</em> axis (the default is <kbd>0.0</kbd>).</p>
<p><kbd>z</kbd>: This is a <kbd>real</kbd> number that sets the stacking order of sibling items. Items with a <kbd>z</kbd> that are higher than other items will cover other items (the default is <kbd>0.0</kbd>).</p>
<p><kbd>width</kbd>: This is a <kbd>real</kbd> number that sets the width of this item.</p>
<p><kbd>height</kbd>: This is a <kbd>real</kbd> number that sets the height of this item.</p>
<p><kbd>implicitWidth</kbd>: This is a <kbd>real</kbd> number that sets the natural width of this item.</p>
<p><kbd>implicitHeight</kbd>:  This is a <kbd>real</kbd> number that sets the natural height of this item.</p>
<p><kbd>opacity</kbd>:  This is a <kbd>real</kbd> number that sets the opacity of this item. <kbd>0.0</kbd> is fully transparent and <kbd>1.0</kbd> is fully opaque (the default is <kbd>1.0</kbd>).</p>
<p><kbd>parent</kbd>: This (name of the parent) sets the parent for this item.</p>
<p><kbd>resources</kbd>: This is the resources list for this item.</p>
<p><kbd>clip</kbd>: This can be <kbd>true</kbd> or <kbd>false</kbd> and allows this item to clip its own painting. Clipping will be enabled (the default is <kbd>false</kbd>).</p>
<p><kbd>rotation</kbd>: This is a <kbd>real</kbd> number that rotates this item in degrees clockwise around its own axis (the default is <kbd>0</kbd>).</p>
<p><kbd>scale</kbd>: This is a real number and is the scale factor for this item (the default is <kbd>1.0</kbd>).</p>
<p><kbd>smooth</kbd>: This can be <kbd>true</kbd> or <kbd>false</kbd>. If <kbd>true</kbd>, smooth sampling will be used.</p>
<p><kbd>state</kbd>: This string sets the name of the current state of this item.</p>
<p><kbd>states</kbd>: This is the list of possible states for this item.</p>
<p><kbd>transform</kbd>: This is the list of transformations to apply to this item.</p>
<p><kbd>transformOrigin</kbd>: This <kbd>enumeration</kbd> sets the origin point around which scaling and rotation will transform this item (the default is <kbd>Item.Center</kbd>).</p>
<p><kbd>transitions</kbd>:<strong> </strong>This is the list of transitions for this item.</p>
<p class="mce-root"/>
<p><kbd>visible</kbd>: This can be <kbd>true</kbd> or <kbd>false</kbd> and sets this item to be visible (the default is <kbd>true</kbd>).</p>
<p><kbd>visibleChildren</kbd>: This is the list of children that will be visible.</p>
<p><kbd>antialiasing</kbd><strong>:</strong> This can be <kbd>true</kbd> or <kbd>false</kbd> and provides antialiasing for this item.</p>
<p><kbd>activeFocus</kbd>: This can be <kbd>true</kbd> or <kbd>false</kbd> and sets whether this item will have active focus or not.</p>
<p><kbd>activeFocusOnTab</kbd>: This can be <kbd>true</kbd> or <kbd>false</kbd> and sets whether the item will have active focus in the tab focus chain (the default is <kbd>false</kbd>).</p>
<p><kbd>focus</kbd>: This can be <kbd>true</kbd> or <kbd>false</kbd>. If <kbd>true</kbd>, it will gain active focus when the enclosing <kbd>FocusScope</kbd> gains active focus.</p>
<p><kbd>anchors.top</kbd>: This <kbd>AnchorLine</kbd> is the relationship between the top position of an item to this item.</p>
<p><kbd>anchors.bottom</kbd>: This <kbd>AnchorLine</kbd> is the relationship between the bottom position of an item to this item.</p>
<p><kbd>anchors.left</kbd>: This <kbd>AnchorLine</kbd> is the relationship between the left position of an item to this item.</p>
<p><kbd>anchors.right</kbd>: This <kbd>AnchorLine</kbd> is the relationship between the right position of the item to this item.</p>
<p><kbd>anchors.horizontalCenter</kbd>: This <kbd>AnchorLine</kbd> is the relationship between the horizontal center position of an item to this item.</p>
<p><kbd>anchors.verticalCenter</kbd>: This <kbd>AnchorLine</kbd> is the relationship between the vertical center position of an item to this item.</p>
<p><kbd>anchors.baseline</kbd>: This <kbd>AnchorLine</kbd> is the relationship between the positions of the imaginary line of text of this item and another item. If the text does not exist, this will be same as <kbd>anchors.top</kbd>.</p>
<p><kbd>anchors.fill</kbd>: This <kbd>Item</kbd> is the relationship between the positions that makes the geometry of one item the same as another item.</p>
<p><kbd>anchors.centerIn</kbd>: This <kbd>Item</kbd> in the relationship between the positions that sets the position of this item to the center of the specified <kbd>Item</kbd>.</p>
<p><kbd>anchors.margins</kbd>: This is a <kbd>real</kbd> number that sets the margins between anchors of the related items.</p>
<p><kbd>anchors.topMargin</kbd>: This is a <kbd>real</kbd> number that sets the top margin between this item and another.</p>
<p><kbd>anchors.bottomMargin</kbd>: This is a <kbd>real</kbd> number that sets the bottom margin between this item and another.</p>
<p><kbd>anchors.leftMargin</kbd>: This is a <kbd>real</kbd> number that sets the left margin between this item and another.</p>
<p><kbd>anchors.rightMargin</kbd>: This is a <kbd>real</kbd> number that sets the right margin between this item and another.</p>
<p><kbd>anchors.horizontalCenterOffset</kbd>: This is a <kbd>real</kbd> number that sets the offset of the horizontal center position of the related item.</p>
<p><kbd>anchors.verticalCenterOffset</kbd>: This is a <kbd>real</kbd> number that sets the offset of the vertical center position of the related item.</p>
<p><kbd>anchors.baselineOffset</kbd>: This is a <kbd>real</kbd> number that sets the offset to the imaginary line of the text.</p>
<p><kbd>anchors.alignWhenCentered</kbd>: This can be <kbd>true</kbd> or <kbd>false</kbd> and centers anchors to align to a whole pixel (the default is <kbd>true</kbd>).</p>
<p><kbd>baselineOffset</kbd>: This integer is the position of the item's baseline in local coordinates. For text items, it is the imaginary line where the text is located. For non-text items, it is <kbd>0</kbd> (the default is <kbd>0</kbd>).</p>
<p><kbd>children</kbd>: This is a list of the children of this item.</p>
<p><kbd>childrenRect.x</kbd>: This is a <kbd>real</kbd> number and is the <em>x</em> axis coordinate of the children of this item.</p>
<p><kbd>childrenRect.y</kbd>: This is a <kbd>real</kbd> number and is the <em>y</em> axis coordinate of the children of this item.</p>
<p><kbd>childrenRect.width</kbd>: This is a <kbd>real</kbd> number and is the width of the children of this item.</p>
<p><kbd>childrenRect.height</kbd><strong>:</strong> This is a <kbd>real</kbd> number and is the height of the children of this item.</p>
<p class="mce-root"/>
<p><kbd>data</kbd>: This list allows us to mix visual children and resources in an item.</p>
<p><kbd>layer.effect</kbd>: The component has the effect (for example, the <kbd>ShaderEffect</kbd> component) applied to the layer.</p>
<p><kbd>layer.enabled</kbd>: This can be <kbd>true</kbd> or <kbd>false</kbd>. If <kbd>true</kbd>, it allows this item to be layered (the default is <kbd>false</kbd>).</p>
<p><kbd>layer.format</kbd>: This <kbd>enumeration</kbd> defines the internal OpenGL format of the texture.</p>
<p><kbd>layer.mipmap</kbd>: This can be <kbd>true</kbd> or <kbd>false</kbd>. If <kbd>true</kbd>, it generates mipmaps for the texture.</p>
<p><kbd>layer.samplerName</kbd>: This string is the name of the effect's source texture property.</p>
<p><kbd>layer.smooth</kbd>: This can be <kbd>true</kbd> or <kbd>false</kbd>. If <kbd>true</kbd>, it smoothly transforms the layer.</p>
<p><kbd>layer.sourceRect</kbd>: This <kbd>Rectangle</kbd> is the rectangular area of this item that should be rendered into the texture.</p>
<p><kbd>layer.textureMirroring</kbd>: This <kbd>enumeration</kbd> sets how the OpenGL texture will be mirrored (the default is <kbd>ShaderEffectSource.MirrorVertically</kbd>).</p>
<p><kbd>layer.textureSize</kbd>: This <kbd>size</kbd> is the pixel size of the layer's texture.</p>
<p><kbd>layer.wrapMode</kbd>: This <kbd>enumeration</kbd> is the OpenGL wrap modes associated with the texture.</p>
<p>The following lines of code partially explain the features of <kbd>Item</kbd>. Create a file called <kbd>UItem.qml</kbd> in the <kbd>qmls/</kbd> directory and add the code that follows:</p>
<ol>
<li><kbd>main_item</kbd> is the parent item of all the items inside this <kbd>Item</kbd>:</li>
</ol>
<pre style="padding-left: 60px">import QtQuick 2.7<br/><br/>Item {<br/>    id: main_item<br/>    anchors.fill: parent<br/>    anchors.margins: 20</pre>
<p style="padding-left: 60px">The <kbd>id</kbd> of this item is <kbd>main_item</kbd>. This item will have a size that's similar to the <kbd>parent</kbd>, with a margin of <kbd>20</kbd> pixels.</p>
<p class="mce-root"/>
<ol start="2">
<li>Add the first item to the <kbd>Item</kbd> with <kbd>id: main_item</kbd>:</li>
</ol>
<pre style="padding-left: 60px">...<br/>    ...<br/>    Item {<br/>        id: i1<br/>        x: 50<br/>        width: parent.width / 2<br/>        height: parent.height / 4<br/>        z: 1<br/>        opacity: 0.5<br/>        Rectangle {<br/>            id: r1<br/>            width: parent.width<br/>            height: parent.height<br/>            color: "#FF0000"<br/>        }<br/>    }<br/>..</pre>
<p style="padding-left: 60px">This <kbd>Item</kbd> describes properties such as the <kbd>z</kbd> index (this item will cover the item with less index), <kbd>opacity</kbd> (this item will be half opaque), and so on.</p>
<ol start="3">
<li>Add the second item to the <kbd>Item</kbd> with <kbd>id: main_item</kbd>:</li>
</ol>
<pre style="padding-left: 60px">...<br/>    ...<br/>    Item {<br/>        id: i2<br/>        parent: i1<br/>        y: i1.height<br/>        width: parent.width / 2<br/>        height: parent.height / 4<br/>        scale: 2<br/>        z: 2<br/>        opacity: 0.7<br/>        Rectangle {<br/>            id: r2<br/>            width: parent.width<br/>            height: parent.height<br/>            color: "#00FF00"<br/>        }<br/>    }<br/>...</pre>
<p class="mce-root"/>
<p class="mce-root"/>
<p class="mce-root"/>
<p class="mceNonEditable"/>
<p style="padding-left: 60px">The second item has <kbd>parent</kbd> and <kbd>scale</kbd> properties. The <kbd>parent</kbd> property sets the <kbd>parent</kbd> for this item and the <kbd>scale</kbd> property sets the size, which will be two times more than the <kbd>parent</kbd> item's size.</p>
<ol start="4">
<li>Add the third item to the <kbd>Item</kbd> with <kbd>id: main_item</kbd>:</li>
</ol>
<pre style="padding-left: 60px">...<br/>    ...<br/>    Item {<br/>        id: i3<br/>        anchors.centerIn: parent<br/>        y: i1.height + i2.height<br/>        width: parent.width / 2<br/>        height: parent.height / 4<br/>        rotation: 90<br/>        z: 0<br/>        opacity: 0.9<br/>        Rectangle {<br/>            id: r3<br/>            width: parent.width<br/>            height: parent.height<br/>            color: "#FFFF00"<br/>        }<br/>    }<br/>...</pre>
<p style="padding-left: 60px">The third item has the <kbd>anchors.centerIn</kbd> and <kbd>rotation</kbd> properties. The <kbd>anchors.centerIn</kbd> property sets this item to the center of the <kbd>parent</kbd>, and the <kbd>rotation</kbd> property will rotate this item by <kbd>90</kbd> degrees. This item is almost opaque.</p>
<ol start="5">
<li>Then, add the fourth item to <kbd>main_item</kbd>:</li>
</ol>
<pre style="padding-left: 60px">...<br/>    ...<br/>    Item {<br/>        id: i4<br/>        parent: r3<br/>        width: parent.width<br/>        height: parent.height<br/>        z: 1<br/>        rotation: 45<br/>        scale: 0.7<br/>        Rectangle {<br/>            id: r4<br/>            anchors.centerIn: parent<br/>            width: parent.width<br/>            height: parent.height<br/>            antialiasing: true<br/>            color: "#770077"<br/>        }<br/>    }<br/>}</pre>
<p style="padding-left: 60px">The <kbd>rotation</kbd> property will rotate this item by <kbd>45</kbd> degrees clockwise, while the <kbd>scale</kbd> factor sets the size of this item equal to 70% of the parent item. The <kbd>antialiasing</kbd> property has been added to the rectangle of this item to get the best performance of the element visualization.</p>
<ol start="6">
<li>
<p>To run this file, you can use Qt Creator or add the following lines to the <kbd>u_qml.qml</kbd> file, somewhere after the first rectangle. Add the items to the QML application:</p>
</li>
</ol>
<pre style="padding-left: 60px">...<br/>    ...<br/>    Uqmls.UItem {<br/>        visible: true<br/>        width: rect1.width<br/>        height: parent.height - rect1.height<br/>        y: rect1.height<br/>    }<br/>    ...<br/>...</pre>
<p class="CDPAlignLeft CDPAlign" style="padding-left: 60px">The main item will be visible, with a <kbd>width</kbd> and <kbd>height</kbd> related to <kbd>rect1</kbd>. This is the result: </p>
<p class="CDPAlignCenter CDPAlign" style="padding-left: 60px"> <img src="img/8284f7ec-03e6-4ddc-84a6-dcad336b0325.png" style="width:15.00em;height:18.50em;"/></p>


            

            
        
    

        

                            
                    <h1 class="header-title">Rectangle</h1>
                
            
            
                
<p>The <kbd>Rectangle</kbd> type is a popular type when creating QML objects. <kbd>Rectangle</kbd> inherits from the <kbd>Item</kbd> type.</p>
<p>The <kbd>import</kbd> statement for using the <kbd>Rectangle</kbd> QML type is as follows:</p>
<pre>import QtQuick 2.7</pre>
<p>The <kbd>Rectangle</kbd> properties are as follows:</p>
<p><kbd>antialiasing</kbd>: This can be <kbd>true</kbd> or <kbd>false</kbd>. It is provided if the rectangle should use antialiasing.</p>
<p><kbd>border.width</kbd>: This <kbd>int</kbd> is the width of the rectangle's borders.</p>
<p><kbd>border.color</kbd>:  This is the color of the rectangle's borders.</p>
<p><kbd>color</kbd>: This is the color of the rectangle.</p>
<p><kbd>gradient</kbd>: This is the gradient color of the rectangle.</p>
<p><kbd>radius</kbd>: This is the radius of the rectangle item.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">RectangularGlow</h1>
                
            
            
                
<p>This is used to create a blurred and colorized rectangle with a glowing effect. The import statement is as follows:</p>
<pre>import QtGraphicalEffects 1.0</pre>
<p>The properties of <kbd>RectangularGlow</kbd> are as follows:</p>
<p><kbd>color</kbd>: This is the color that's used for the glow.</p>
<p><kbd>cornerRadius</kbd>: This is a <kbd>real</kbd> number to set the radius that is used to draw a glow with rounded corners.</p>
<p><kbd>glowRadius</kbd>: This is a <kbd>real</kbd> number  that sets the radius in pixels that is reached by the glow.</p>
<p><kbd>spread</kbd>: This is a <kbd>real</kbd> number that sets the strength of the glow color near the edges of the source.</p>
<p class="mce-root"/>
<p><kbd>cached</kbd>: This can be <kbd>true</kbd> or <kbd>false</kbd>. It allows the effect's output pixels to be cached to improve performance.</p>
<p>To demonstrate this effect, create a file called <kbd>URectGlow.qml</kbd> in the <kbd>qmls/</kbd> directory and implement the following steps:</p>
<ol>
<li> Add the parent rectangle and rectangular glow to the <kbd>URectGlow.qml</kbd> file:</li>
</ol>
<pre style="padding-left: 60px">import QtQuick 2.7<br/>import QtGraphicalEffects 1.0<br/><br/>Rectangle {<br/>    property color glowcolor<br/>    property color txglow<br/>    RectangularGlow {<br/>        id: rglow<br/>        anchors.fill: rectglow<br/>        glowRadius: 10<br/>        spread: 0.1<br/>        color: glowcolor<br/>          cornerRadius: rectglow.radius + glowRadius<br/>    }</pre>
<p style="padding-left: 60px">This code imports the graphical effects and adds the custom properties <kbd>glowcolor</kbd> and <kbd>txglow</kbd>. The <kbd>glowcolor</kbd> property is used to specify the color of the glow, while <kbd>txglow</kbd> is used for the color of the text glow.</p>
<ol start="2">
<li>Then, add the central rectangle after the <kbd>RectangularGlow</kbd>:</li>
</ol>
<pre style="padding-left: 60px">    Rectangle {<br/>        id: rectglow<br/>        color: parent.color<br/>        anchors.centerIn: parent<br/>        width: parent.width / 1.5<br/>        height: parent.height / 1.5<br/>        radius: 14</pre>
<p style="padding-left: 60px">The rectangle will have a glow effect with a color that's similar to the parent's rectangle color. Set the radius of the rectangle corners. </p>
<ol start="3">
<li>Add the <kbd>Text</kbd> and <kbd>Glow</kbd> types to the central rectangle:</li>
</ol>
<pre>        Text {<br/>            id: txt1<br/>            anchors.centerIn: parent<br/>            text: "PUSH"<br/>            font.family: "Helvetica"<br/>            font.pixelSize: parent.width / 8<br/>            font.weight: Font.Medium<br/>            font.letterSpacing: 2<br/>            color: parent.color<br/>        }<br/>        Glow {<br/>            anchors.fill: txt1<br/>            radius: 7<br/>            samples: 17<br/>            color: txglow<br/>            source: txt1<br/>        } <br/>    }<br/>}</pre>
<p>The preceding code adds the <kbd>Text</kbd> and <kbd>Glow</kbd> QML types to the central rectangle. <kbd>Text</kbd> is used to display the text on the rectangle, while <kbd>Glow</kbd> is used to make the text inside the rectangle glow.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">Gradients</h1>
                
            
            
                
<p class="mce-root">Gradients are used to visualize objects better. They provide more effective colors than using a simple color property. </p>


            

            
        
    

        

                            
                    <h1 class="header-title">Gradient</h1>
                
            
            
                
<p>This QML type provides a gradient color for the element. Here's the <kbd>import</kbd> statement:</p>
<pre>import QtQuick 2.7</pre>
<p>It has a property called <kbd>stops</kbd> that provides a list of the stops for the gradient. You can do this by using <kbd>GradientStop</kbd>.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">GradientStop</h1>
                
            
            
                
<p>This type defines the color at a position in a gradient. Here's the <kbd>import</kbd> statement:</p>
<pre>import QtQuick 2.7</pre>
<p>The properties are as follows:</p>
<p><kbd>color</kbd>: This is the color of the gradient. It allows named, hexadecimal, and RGBA colors.</p>
<p><kbd>position</kbd>: This is the position of the color in the gradient in a range from <kbd>0.0</kbd> to <kbd>1.0</kbd>.</p>
<p>Let's create a directory inside <kbd>App/qmls/</kbd> called <kbd>gradients/</kbd> and make a file called <kbd>UGradient1.qml</kbd> inside it. Then, add the gradient colors using the <kbd>Gradient</kbd> and <kbd>GradientStop</kbd> types:</p>
<pre>import QtQuick 2.7<br/><br/>Gradient {<br/>    GradientStop {<br/>        position: 0.0;<br/>        color: "red";<br/>    }<br/>    GradientStop {<br/>        position: 0.27;<br/>        color: "#AAFF00";<br/>    }<br/>    GradientStop {<br/>        position: 0.534;<br/>        color: Qt.rgba(0.95,0,0,1);<br/>    }<br/>    GradientStop {<br/>        position: 0.7147;<br/>        color: "yellow";<br/>    }<br/>    GradientStop {<br/>        position: 1.0;<br/>        color: Qt.rgba(1,0,0,1);<br/>    }<br/>}</pre>
<p>The first gradient stop and last gradient stop <kbd>position</kbd> properties must equal <kbd>0.0</kbd> and <kbd>1.0</kbd>, respectively. All gradient stops between these positions realize the gradient color. Named, RGB, and RGBA colors can be used.</p>
<p>Now, all you need to do is change the <kbd>UCircle.qml</kbd> file by adding a gradient color to the rectangle:</p>
<pre>import QtQuick 2.7<br/>import "gradients" as UG<br/><br/>Rectangle {<br/>    radius: width * 0.5<br/>    antialiasing: true<br/>    gradient: UG.UGradient1 {}<br/>}</pre>
<p class="mce-root">The created circle will have a gradient color instead of a simple color.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">LinearGradient</h1>
                
            
            
                
<p>This gradient object provides some extended features. With <kbd>LinearGradient</kbd>, colors start at the start point and end at the end point. Here's the <kbd>import</kbd> statement that we need:</p>
<pre>import QtGraphicalEffects 1.0</pre>
<p>These are the properties it takes:</p>
<p><kbd>start</kbd>: The starting point in pixels where the color at position <kbd>0.0</kbd> is rendered (the default is <kbd>Qt.point(0, 0)</kbd>).</p>
<p><kbd>end</kbd>: The ending point in pixels where the color at position <kbd>1.0</kbd> is rendered (the default is <kbd>Qt.point(0, height)</kbd>).</p>
<p><kbd>gradient</kbd>: The gradient, of the gradient type, with two or more colors.</p>
<p><kbd>source</kbd>: The item that is going to be filled with the gradient (such as an image or QML type).</p>
<p><kbd>cached</kbd>: This can be <kbd>true</kbd> or <kbd>false</kbd>. It allows the effect's output pixels to be cached to improve performance.</p>
<p>Here's an example. Create a file called <kbd>URectLG.qml</kbd> in the <kbd>qmls/</kbd> directory and add the following code to it:</p>
<pre>import QtQuick 2.7<br/>import QtGraphicalEffects 1.0<br/>import "gradients" as UG<br/><br/>Rectangle {<br/>    antialiasing: true<br/>    radius: width * 0.5<br/>    LinearGradient {<br/>        anchors.fill: parent<br/>        start: Qt.point(0, 0) <br/>        end: Qt.point(parent.height/2, parent.height/2)<br/>        source: parent<br/>        cached: true<br/>        gradient: UG.UGradient1 {}<br/>    }<br/>}</pre>
<p>In the linear gradient, use start and end points as Qt points. The gradient can only be defined with visual type objects, such as rectangle, and can blend two or more colors seamlessly.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">RadialGradient</h1>
                
            
            
                
<p>This type provides radial gradients. The following  <kbd>import</kbd> statement is used for radial gradient:</p>
<pre>import QtGraphicalEffects 1.0</pre>
<p>These are the properties:</p>
<p><kbd>angle</kbd>: This is a <kbd>real</kbd> number, and the angle of rotation of the gradient around the center point (the default is <kbd>0.0</kbd>).</p>
<p><kbd>gradient</kbd>: This is a gradient of the gradient type, with two or more colors.</p>
<p><kbd>source</kbd>: This is an item that is going to be filled with the gradient.</p>
<p><kbd>horizontalRadius</kbd>: This is a <kbd>real</kbd> number,  that is, the shape and size of the gradient.</p>
<p><kbd>verticalRadius</kbd>: This is a <kbd>real</kbd> number, that is, the shape and size of the gradient.</p>
<p><kbd>horizontalOffset</kbd>: This is a <kbd>real</kbd> number, that is, the offset in pixels from the center point of the gradient compared to the item center (the default is <kbd>0.0</kbd>).</p>
<p><kbd>verticalOffset</kbd>: This is a <kbd>real</kbd> number, that is, the offset in pixels from the center point of the gradient compared to the item center (the default is <kbd>0.0</kbd>).</p>
<p><kbd>cached</kbd>: This can be <kbd>true</kbd> or <kbd>false</kbd>. It allows the effect's output pixels to be cached to improve performance.</p>
<p class="mce-root"/>
<p>Here's an example of a radial gradient. Create a file called <kbd>URectRG.qml</kbd> inside the <kbd>qmls/</kbd> directory and add the following code:</p>
<pre>import QtQuick 2.7<br/>import QtGraphicalEffects 1.0<br/>import "gradients" as UG<br/><br/>Rectangle {<br/>    antialiasing: true<br/>    radius: width * 0.5<br/>    RadialGradient {<br/>        anchors.fill: parent<br/>        angle: 27<br/>        horizontalRadius: parent.width / 2<br/>        verticalRadius: parent.height / 2<br/>        horizontalOffset: 3<br/>        verticalOffset: 3<br/>        source: parent<br/>        cached: false<br/>        gradient: UG.UGradient1 {}<br/>    }<br/>}</pre>
<p>The source for this radial gradient is a parent rectangle. We've set the <kbd>angle</kbd> rotation around the center.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">ConicalGradient</h1>
                
            
            
                
<p>This type provides a conical gradient. The <kbd>import</kbd> statement for this type is as follows:</p>
<pre>import QtGraphicalEffects 1.0</pre>
<p>The properties of this type are as follows:</p>
<p><kbd>angle</kbd>: This is a <kbd>real</kbd> number and sets the angle of the gradient around the center point (the default is <kbd>0.0</kbd>).</p>
<p><kbd>gradient</kbd>: The gradient of the <kbd>Gradient</kbd> type, with two or more colors.</p>
<p><kbd>source</kbd>:  The item that is going to be filled with a gradient.</p>
<p><kbd>horizontalOffset</kbd>: This is a <kbd>real</kbd> number, that is, the offset in pixels from the center point of the gradient compared to the item center (the default is <kbd>0.0</kbd>).</p>
<p class="mce-root"/>
<p><kbd>verticalOffset</kbd>: This is a <kbd>real</kbd> number, that is, the offset in pixels for the center point of the gradient compared to the item center (the default is <kbd>0.0</kbd>).</p>
<p><kbd>cached</kbd>: This can be <kbd>true</kbd> or <kbd>false</kbd>. It allows the effect's output pixels to be cached to improve performance.</p>
<p>Here's an example. Create a file called<strong> </strong><kbd>URectCG.qml</kbd> inside the <kbd>qmls/</kbd> directory and add the following code:</p>
<pre>import QtQuick 2.7<br/>import QtGraphicalEffects 1.0<br/>import "gradients" as UG<br/><br/>Rectangle {<br/>    antialiasing: true<br/>    radius: width * 0.5.<br/>    ConicalGradient {<br/>        anchors.fill: parent<br/>        angle: 1<br/>        horizontalOffset: 7<br/>        verticalOffset: 5<br/>        source: parent<br/>        cached: false<br/>        gradient: UG.UGradient1 {}<br/>    }<br/>}</pre>
<p>The gradient of the color will be conical. The <kbd>source</kbd> is also the parent rectangle.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">Completion of the examples</h1>
                
            
            
                
<p>To complete the examples in this section, let's combine them into one grid and look at the result. To do this, add the grid somewhere after <kbd>rect1</kbd> in the <kbd>u_qml.qml</kbd> file:</p>
<ol>
<li>Adding the grid positioning mechanism of the items:</li>
</ol>
<pre style="padding-left: 60px">...<br/>    ...<br/>    Grid {<br/>        visible: true<br/>        id: grid1<br/>        columns: 2<br/>        spacing: 20<br/>        padding: 20<br/>        width: rect1.width<br/>        height: parent.height - rect1.height<br/>        y: rect1.height<br/>        Uqmls.UCircle {<br/>            id: circle1<br/>            width: (parent.width / 2 - (parent.spacing * 2)) + 10<br/>            height: width<br/>        }<br/>        ...<br/>        Uqmls.URectGlow {<br/>            id: rectg1<br/>            width: (parent.width / 2 - (parent.spacing * 2)) + 10<br/>            height: width<br/>            color: Qt.rgba(0, 0.07, 0.14, 1);<br/>            glowcolor: Qt.rgba(0.007, 1, 1, 1);<br/>            txglow: Qt.rgba(0.007, 0.7, 0.7, 1);<br/>       }<br/>        ...<br/>    }<br/>...</pre>
<p style="padding-left: 60px">We've used the <kbd>Grid</kbd> type to arrange items in the grid. Here, we've created four circles with gradients such as  <kbd>UCircle</kbd>, <kbd>URectLG</kbd>, <kbd>URectRG</kbd>, and <kbd>URectCG</kbd>, and four <kbd>URectGlow</kbd> items that can be added.</p>
<ol start="2">
<li>In the <em>Item</em> section where we created items, we need to change the <kbd>visible</kbd> property to <kbd>false</kbd>:</li>
</ol>
<pre style="padding-left: 60px">...<br/>    ...<br/>    Uqmls.UItem {<br/>        visible: false<br/>    ...<br/>...</pre>
<p style="padding-left: 60px">With the addition of these lines, the gradient elements will be visible, whereas previously created items will be invisible. The full file with some changes to the background color is available at <a href="https://github.com/PacktPublishing/Hands-On-QT-for-Python-developers">https://github.com/PacktPublishing/Hands-On-QT-for-Python-developers</a>. </p>
<p class="mce-root"/>
<p class="mce-root"/>
<p style="padding-left: 60px">If we click on the top-right corner of the application window, we will see the following result:</p>
<p class="CDPAlignCenter CDPAlign"><img src="img/b5b79a26-a863-4086-9162-4ef19e2b120c.png" style="width:28.00em;height:24.33em;"/></p>
<p>We've looked at a short explanation of styling with QML. In the next chapter, will continue learning about Qt Quick and will learn about important positioning instruments, such as layouts.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">Animations with QML</h1>
                
            
            
                
<p>Qt Quick is a standard library for creating user interfaces with QML, and it gives you the ability to implement animations. This animation can be implemented in several ways, such as states, transitions, and animation property changes. Animation can also be implemented with other animation-related approaches.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">State and transition objects</h1>
                
            
            
                
<p>This way of creating animations with QML uses the <kbd>State</kbd> object to declare the state of an object, and the <kbd>Transition</kbd> object to declare properties of the state changes during the animation process.</p>
<p class="mce-root"/>
<p class="mce-root"/>
<p>This approach can be described with the following lines:</p>
<pre>Item {<br/>    states: [ State { name: "state1"} ]<br/>    transitions: [ Transition {}]<br/>}</pre>
<p><kbd>Item</kbd> has <kbd>states</kbd> and <kbd>transitions</kbd> properties. <kbd>states</kbd> has a <kbd>State</kbd> object, and <kbd>transitions</kbd> has a list of <kbd>Transition</kbd> objects.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">State</h1>
                
            
            
                
<p>As part of the <kbd>QtQuick</kbd> module, the QML <kbd>State</kbd> type provides a set of changes related to the configuration of objects and properties. It has the following <kbd>import</kbd> statement:</p>
<pre>import QtQuick 2.7</pre>
<p>These are its properties:</p>
<p><kbd>name</kbd>: <kbd>string</kbd> (the name of the state).</p>
<p><kbd>changes</kbd>: List (changes to apply for the state).</p>
<p><kbd>extend</kbd>: <kbd>string</kbd> (the name of the state); state extends as the state.</p>
<p><kbd>when</kbd>: This can be <kbd>true</kbd> or <kbd>false</kbd> and sets when the state will be applied. An object for this property should return a Boolean value. For example, if <kbd>MouseArea.pressed</kbd> is pressed, then it returns <kbd>true</kbd>.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">PropertyChanges</h1>
                
            
            
                
<p><kbd>PropertyChanges</kbd> is used to define the property values in the state. This allows us to define new properties of the target object. The <kbd>import</kbd> statement is as follows:</p>
<pre>import QtQuick 2.7</pre>
<p>It has the following properties:</p>
<p><kbd>target</kbd>: An object whose properties need to be changed.</p>
<p><kbd>explicit</kbd>: Can be <kbd>true</kbd> or <kbd>false</kbd>. It provides explicit bindings of the properties (the default is <kbd>false</kbd>).</p>
<p><kbd>restoreEntryValues</kbd>: Can be <kbd>true</kbd> or <kbd>false</kbd>. If it's <kbd>true</kbd>, the previous values should be restored when leaving the state.</p>
<p>Here's an example. Open the <kbd>UItem.qml</kbd> file and add this <kbd>MouseArea</kbd> to the rectangle with  <kbd>id: r1</kbd>, as follows:</p>
<ol>
<li>Add the states of the item with <kbd>id: i1</kbd><strong> </strong>to the mouse area's <kbd>onClicked</kbd> signal handler:</li>
</ol>
<pre style="padding-left: 60px">...<br/>    ...<br/>        ...<br/>            ...<br/>            MouseArea {<br/>                anchors.fill: parent<br/>                onClicked: {i1.state == 'state1' ?;<br/>                    i1.state = '' : i1.state = 'state1';}<br/>            }<br/>        ...<br/>    ...<br/>...</pre>
<p style="padding-left: 60px">When <kbd>MouseArea</kbd> is clicked, the states of <kbd>Item</kbd> will be changed.</p>
<ol start="2">
<li>Add the states and transitions properties to the bottom of the <kbd>Item</kbd> with <kbd>id: i1</kbd>:</li>
</ol>
<pre style="padding-left: 60px">...<br/>    ...<br/>        ...<br/>        states: [<br/>            State {<br/>                name: "state1"<br/>                PropertyChanges { target: i1; x: 140 } <br/>            }<br/>        ]<br/>        transitions: [<br/>            Transition {<br/>                NumberAnimation { properties: "x, y" }<br/>            }<br/>        ]<br/>    ...<br/>...</pre>
<p class="mce-root"/>
<p class="mce-root"/>
<p class="mce-root"/>
<p class="mce-root"/>
<p class="mce-root"/>
<p class="mce-root"/>
<p class="mce-root"/>
<p class="mce-root"/>
<p class="mce-root"/>
<p class="mce-root"/>
<p class="mce-root"/>
<p class="mce-root"/>
<p class="mce-root"/>
<p class="mce-root"/>
<p class="mce-root"/>
<p class="mce-root"/>
<p class="mce-root"/>
<p class="mce-root"/>
<p class="mce-root"/>
<p class="mce-root"/>
<p class="mce-root"/>
<p class="mce-root"/>
<p class="mce-root"/>
<p class="mce-root"/>
<p class="mce-root"/>
<p class="mce-root"/>
<p class="mce-root"/>
<p class="mce-root"/>
<p class="mce-root"/>
<p class="mce-root"/>
<p class="mce-root"/>
<p class="mce-root"/>
<p class="mce-root"/>
<p class="mce-root"/>
<p class="mce-root"/>
<p class="mce-root"/>
<p class="mce-root"/>
<p class="mce-root"/>
<p class="mce-root"/>
<p class="mceNonEditable"/>
<p class="mce-root"/>
<p class="mce-root"/>
<p class="mce-root"/>
<p class="mceNonEditable"/>
<p class="mce-root"/>
<p class="mceNonEditable"/>
<p class="mceNonEditable"/>
<p class="mceNonEditable"/>
<p style="padding-left: 60px">In the <kbd>states</kbd> property, the <kbd>State</kbd> type with the <kbd>name</kbd> and <kbd>PropertyChanges</kbd> have been added, which will be used for the target item's <em>x</em> axis. The <kbd>transitions</kbd> property realizes animations. </p>


            

            
        
    

        

                            
                    <h1 class="header-title">AnchorChanges</h1>
                
            
            
                
<p>This type is used when you need to change the anchors of an item in the <kbd>State</kbd> of the object. The <kbd>import</kbd> statement of this type is as follows:</p>
<pre>import QtQuick 2.7</pre>
<p>The following properties are available:</p>
<p><kbd>target</kbd>: The item for which anchors will be changed.</p>
<p><kbd>anchors.left</kbd>: This <kbd>AnchorLine</kbd> will modify the left anchor.</p>
<p><kbd>anchors.right</kbd>: This <kbd>AnchorLine</kbd> will modify the right anchor.</p>
<p><kbd>anchors.horizontalCenter</kbd>: This <kbd>AnchorLine</kbd> will modify the horizontal center anchor's position relation.</p>
<p><kbd>anchors.top</kbd>: This <kbd>AnchorLine</kbd> will modify the top anchor.</p>
<p><kbd>anchors.bottom</kbd>: This <kbd>AnchorLine</kbd> will modify the bottom anchor.</p>
<p><kbd>anchors.verticalCenter</kbd>: This <kbd>AnchorLine</kbd> will modify the vertical center anchor position relation.</p>
<p><kbd>anchors.baseline</kbd>: This <kbd>AnchorLine</kbd> will modify the baseline anchors.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">StateChangeScript</h1>
                
            
            
                
<p>The <kbd>StateChangeScript</kbd> QML type is used to run a script in the state. The <kbd>import</kbd> statement is as follows:</p>
<pre>import QtQuick 2.7</pre>
<p>It has the following properties:</p>
<p><kbd>name</kbd>: This is a string, which is the name of the script. Use it with <kbd>ScriptAction</kbd> to target a specific script.</p>
<p><kbd>script</kbd>: The script that will be used, such as function.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">StateGroup</h1>
                
            
            
                
<p>With this type, QML provides support for non-item types. The <kbd>import</kbd> statement is the same as before:</p>
<pre>import QtQuick 2.7</pre>
<p>It has the following properties:</p>
<p><kbd>state</kbd>:  This is a <kbd>string</kbd>. It's the name of the state for this state group.</p>
<p><kbd>states</kbd>: This is a list that defines the list of the states related to the state group.</p>
<p><kbd>transitions</kbd>: This is a list. It provides the list of the transition objects for the state group.</p>
<p>The <kbd>QtQml</kbd> module also provides the <kbd>state</kbd> type, which is a part of the declarative State Machine framework. This is the <kbd>import</kbd> statement:</p>
<pre>import QtQml.StateMachine 1.0</pre>
<p>It has the following properties:</p>
<p><kbd>childMode</kbd>: This is an <kbd>enumeration</kbd> that specifies how states are treated. It can be <kbd>QState.ExclusiveStates</kbd> (states are mutually exclusive) or <kbd>QState.ParallelStates</kbd> (states are parallel).</p>
<p><kbd>errorState</kbd>: This <kbd>QAbstractState</kbd> is the error state.</p>
<p><kbd>initialState</kbd>:<strong> </strong>This <kbd>QAbstractState</kbd> is the initial state.</p>
<p>This type is related to the QML language infrastructure.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">Transition</h1>
                
            
            
                
<p>This QML type is used to implement the animations of the state changes and define animated transitions. The <kbd>import</kbd> statement is as follows:</p>
<pre>import QtQuick 2.7</pre>
<p class="mce-root"/>
<p>It has the following properties:</p>
<p><kbd>animations</kbd>: This is a list of the animations that are provided in list form.</p>
<p><kbd>enabled</kbd>: This can be <kbd>true</kbd> or <kbd>false</kbd> (the default is <kbd>true</kbd>) and shows whether the transition is enabled.</p>
<p><kbd>running</kbd>: This can be <kbd>true</kbd> or <kbd>false</kbd> and shows whether the transition is currently running.</p>
<p><kbd>from</kbd>: This is a <kbd>string</kbd> and shows that the transition is from these state changes.</p>
<p><kbd>to</kbd>: This is a <kbd>string</kbd> and shows that the transition is to these state changes.</p>
<p><kbd>reversible</kbd>: This can be <kbd>true</kbd> or <kbd>false</kbd>. If it's <kbd>true</kbd>, the transition is automatically applied when a state change is reversed.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">Animating property changes</h1>
                
            
            
                
<p>Another approach to implementing animations with QML is to use behaviors.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">Behavior</h1>
                
            
            
                
<p>This QML type provides a default animation that will be applied if a property value changes. The <kbd>import</kbd> statement is as follows:</p>
<pre>import QtQuick 2.7</pre>
<p>It has the following properties:</p>
<p><kbd>animation</kbd>: This sets the animation to run when the behavior is triggered.</p>
<p><kbd>enabled</kbd>: This can be <kbd>true</kbd> or <kbd>false</kbd>. This enables the type for use (the default is <kbd>true</kbd>).</p>
<p>The syntax is as follows:</p>
<pre>Behavior on width {<br/>    Animation {}<br/>}</pre>
<p>Here, the construction is using the <kbd>Behavior</kbd> of the <kbd>width</kbd> property. The animation will run depending on the behaviors of width.</p>
<p class="mce-root"/>
<p>Open the <kbd>UItem.qml</kbd> file and add the <kbd>MouseArea</kbd> and <kbd>Behavior</kbd> types to the rectangle with <kbd>id: r2</kbd>:</p>
<pre>...<br/>    ...<br/>        ...<br/>            ...<br/>            MouseArea {<br/>                anchors.fill: parent<br/>                onClicked: {parent.y == 140 ?<br/>                        parent.y = 270 : parent.y = 140}<br/>            }<br/>            Behavior on y {<br/>                NumberAnimation {<br/>                    duration: 7000<br/>                    easing.type: Easing.OutInElastic<br/>                }<br/>            }<br/>        ...<br/>    ...<br/>...</pre>
<p>If <kbd>MouseArea</kbd> is clicked, the green rectangle will move. We've set <kbd>Behavior</kbd> on the <em>y</em> axis, which will use an animation as the green rectangle falls down with a duration of seven seconds and the type of easing curve set to elastic (an exponentially decaying sine wave).</p>


            

            
        
    

        

                            
                    <h1 class="header-title">Animation types</h1>
                
            
            
                
<p><kbd>QtQuick</kbd> provides the following types to implement animations.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">Animation</h1>
                
            
            
                
<p>This is the base type for all QML animations. It has the following <kbd>import</kbd> statement:</p>
<pre>import QtQuick 2.7</pre>
<p>It has the following properties:</p>
<p><kbd>alwaysRunToEnd</kbd>: This can be <kbd>true</kbd> or <kbd>false</kbd>. If the animation is stopped, the animation loop should be completed.</p>
<p><kbd>loops</kbd>: This is an <kbd>int</kbd> and sets how many times the animation will play.</p>
<p class="mce-root"/>
<p><kbd>paused</kbd>: This is <kbd>true</kbd> or <kbd>false</kbd>. If <kbd>true</kbd>, the animation will pause.</p>
<p><kbd>running</kbd>: This is <kbd>true</kbd> or <kbd>false</kbd>. If <kbd>true</kbd>, the animation is running.</p>
<p>The following signals are available:</p>
<p><kbd>started()</kbd>: This is emitted when the animation begins.</p>
<p><kbd>stopped()</kbd>: This is emitted when the animation stops.</p>
<p>The following methods are available:</p>
<p><kbd>complete()</kbd>: Jumps to the final property values.</p>
<p><kbd>pause()</kbd>: Pauses the animation.</p>
<p><kbd>restart()</kbd>: Restarts the animation.</p>
<p><kbd>resume()</kbd>: Starts the paused animation.</p>
<p><kbd>start()</kbd>: Starts the animation.</p>
<p><kbd>stop()</kbd>: Stops the animation.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">AnimationController</h1>
                
            
            
                
<p>This allows the manual control of animations. This is the required <kbd>import</kbd> statement:</p>
<pre>import QtQuick 2.7</pre>
<p>It has the following properties:</p>
<p><kbd>animation</kbd>: The  <kbd>Animation</kbd> to be controlled.</p>
<p><kbd>progress</kbd>: The animation progresses between the values <kbd>0.0</kbd> and <kbd>1.0</kbd>.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">PropertyAnimation</h1>
                
            
            
                
<p>This is a useful type for animating changes to a property's value. The <kbd>import</kbd> statement is as follows:</p>
<pre>import QtQuick 2.7</pre>
<p class="mce-root"/>
<p class="mce-root"/>
<p>It has the following properties:</p>
<p><kbd>duration</kbd>: This <kbd>int</kbd> is the duration of the animation in milliseconds.</p>
<p><kbd>target</kbd>: This object sets the item whose properties need to be animated.</p>
<p><kbd>targets</kbd>: This list sets the items whose properties need to be animated.</p>
<p><kbd>property</kbd>: This <kbd>string</kbd> sets the property to be animated.</p>
<p><kbd>properties</kbd>: This <kbd>string</kbd> sets the properties to be animated.</p>
<p><kbd>from</kbd>: This is the starting value of the animation.</p>
<p><kbd>to</kbd>:  This is the end value of the animation.</p>
<p><kbd>exclude</kbd>: This is a list of objects that will not be animated.</p>
<p><kbd>easing.type</kbd>: This is an <kbd>enumeration</kbd> and is the type of easing curve that is used for the animation.</p>
<p><kbd>easing.amplitude</kbd>: This is the amplitude of the easing curve.</p>
<p><kbd>easing.overshoot</kbd>: This is the overshoot of the easing curve.</p>
<p><kbd>easing.period</kbd>: This is the period of the easing curve.</p>
<p><kbd>easing.bezierCurve</kbd>: This list is applicable if the easing type is <kbd>Easing.Bezier</kbd>. It's a list of <kbd>real</kbd> numbers containing groups of three points defining a curve from (0,0) to (1,1)—[x1, y1, x2, y2, endx, endy]. The last point must be (1,1).</p>


            

            
        
    

        

                            
                    <h1 class="header-title">NumberAnimation</h1>
                
            
            
                
<p>This is used to animate properties with numerical values. Use the following <kbd>import</kbd> statement:</p>
<pre>import QtQuick 2.7</pre>
<p>It has the following properties:</p>
<p><kbd>from</kbd>: This is a <kbd>real</kbd> number, and is the starting value of the animation.</p>
<p><kbd>to</kbd>: This is a <kbd>real</kbd> number, and is the end value of the animation.</p>
<p class="mce-root"/>


            

            
        
    

        

                            
                    <h1 class="header-title">SequentialAnimation</h1>
                
            
            
                
<p>This animation is used to run multiple animations, one after the other. This is the <kbd>import</kbd> statement:</p>
<pre>import QtQuick 2.7</pre>
<p>Here's an example of the syntax:</p>
<pre>SequentialAnimation {<br/>    Animation {}<br/>    Animation {}<br/>} <br/>// or:<br/>SequentialAnimation on width { <br/>    Animation {}<br/>    Animation {}<br/>}</pre>
<p>This realizes a sequential animation of the specified animations. </p>


            

            
        
    

        

                            
                    <h1 class="header-title">ParallelAnimation</h1>
                
            
            
                
<p>Similar to <kbd>SequentialAnimation</kbd>, this type is used to run multiple animations together, but they will run at the same time. Use the following <kbd>import</kbd> statement:</p>
<pre>import QtQuick 2.7</pre>
<p>Here's an example of the syntax:</p>
<pre>ParallelAnimation {<br/>    Animation {}<br/>    Animation {}<br/>}</pre>
<p>This realizes the parallel animation of the specified animations. </p>


            

            
        
    

        

                            
                    <h1 class="header-title">PauseAnimation</h1>
                
            
            
                
<p>This type is used to set a pause between animations. Use the following <kbd>import</kbd> statement:</p>
<pre>import QtQuick 2.7</pre>
<p class="mce-root"/>
<p>It has one property:</p>
<p><kbd>duration</kbd>: This is an <kbd>int</kbd> that sets the duration of the pause between animations in milliseconds</p>


            

            
        
    

        

                            
                    <h1 class="header-title">ColorAnimation</h1>
                
            
            
                
<p>This is a specialized property animation that will be applied when a color value changes. You need this <kbd>import</kbd> statement:</p>
<pre>import QtQuick 2.7</pre>
<p>It has the following properties:</p>
<p><kbd>from</kbd>: This is the color of the animation when it begins.</p>
<p><kbd>to</kbd>: This is the color of the animation when it ends.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">CoordinateAnimation</h1>
                
            
            
                
<p>This is an animation for geographical coordinate properties that are implemented between two coordinates. You need to use the following <kbd>import</kbd> statement:</p>
<pre>import QtPositioning 5.2</pre>
<p>It has the following properties:</p>
<p><kbd>direction</kbd>: This is an <kbd>enumeration</kbd> of the direction of the longitude animation of the coordinate.</p>
<p><kbd>from</kbd>: This is the coordinate where the animation begins.</p>
<p><kbd>to</kbd>: This is the coordinate where the animation ends.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">RotationAnimation</h1>
                
            
            
                
<p>This type is used to control the direction of rotation during an animation. Use the following  <kbd>import</kbd> statement:</p>
<pre>import QtQuick 2.7</pre>
<p class="mce-root"/>
<p>It has the following properties:</p>
<p><kbd>direction</kbd>: This is an <kbd>enumeration</kbd> of the direction of rotation (the default is <kbd>RotationAnimation.Numerical</kbd>).</p>
<p><kbd>from</kbd>: This <kbd>real</kbd> number is the starting value of the rotation of the animation.</p>
<p><kbd>to</kbd>: This <kbd>real</kbd> number is the end value of the rotation of the animation.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">AnchorAnimation</h1>
                
            
            
                
<p>This type animates anchors. You need the following <kbd>import</kbd> statement:</p>
<pre>import QtQuick 2.7</pre>
<p>It has the following properties:</p>
<p><kbd>targets</kbd>: This is a list of the items to reanchor.</p>
<p><kbd>duration</kbd>: This <kbd>int</kbd> is the duration of the animation in milliseconds.</p>
<p><kbd>easing.type</kbd>: This <kbd>enumeration</kbd> is the type of easing curve that's used for the animation.</p>
<p><kbd>easing.amplitude</kbd>: This <kbd>real</kbd> number is the amplitude of the easing curve.</p>
<p><kbd>easing.overshoot</kbd>: This <kbd>real</kbd> number is the overshoot of the easing curve.</p>
<p><kbd>easing.period</kbd>: This <kbd>real</kbd> number is the period of the easing curve.</p>
<p>These types are not a complete list of the animation instruments available in <kbd>QtQuick</kbd>.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">Animation examples</h1>
                
            
            
                
<p>Now, we need to practice using the animations types that we've looked at:</p>
<ol>
<li>Open the <kbd>UItem.qml</kbd> file and add the following lines to the bottom of the rectangle with <kbd>id: r3</kbd>:</li>
</ol>
<pre style="padding-left: 60px">...<br/>    ...<br/>        ...<br/>            ...<br/>            SequentialAnimation on x {<br/>                id: sa1<br/>                running: false<br/>                loops: Animation.Infinite<br/>                NumberAnimation {<br/>                    from: 140<br/>                    to: 270<br/>                    duration: 7000<br/>                    easing.type: Easing.OutInElastic<br/>                }<br/>                NumberAnimation {<br/>                    from: 270<br/>                    to: 140<br/>                    duration: 7000<br/>                    easing.type: Easing.OutInElastic<br/>                }<br/>                PauseAnimation { duration: 140 }<br/>            }<br/>            MouseArea {<br/>                anchors.fill: parent<br/>                onClicked: sa1.running = true<br/>            }<br/>        ...<br/>    ...<br/>...</pre>
<p style="padding-left: 60px">The sequential animation is used for two <kbd>NumberAnimation</kbd> implementations. Animations will change the position of the rectangles with some pause specified with the <kbd>PauseAnimation</kbd> type.</p>
<ol start="2">
<li>Add the following animation to the bottom of the rectangle with <kbd>id: r4</kbd>:</li>
</ol>
<pre style="padding-left: 60px">...<br/>    ...<br/>        ...<br/>            ...<br/>            ParallelAnimation {<br/>                id: sa2<br/>                running: false<br/>                loops: Animation.Infinite<br/>                PropertyAnimation {<br/>                    target: r4<br/>                    property: "rotation"<br/>                    from: 0<br/>                    to: 360<br/>                    duration: 7000<br/>                    easing.type: Easing.OutInElastic<br/>                }<br/>                PropertyAnimation {<br/>                    target: r1<br/>                    property: "rotation"<br/>                    from: 0<br/>                    to: 360<br/>                    duration: 7000<br/>                    easing.type: Easing.InQuart<br/>                }<br/>            }<br/>            MouseArea {<br/>                anchors.fill: parent<br/>                onClicked: sa2.running = true<br/>            }<br/>        ...<br/>    ...<br/>...</pre>
<p style="padding-left: 60px">The parallel animation is used for two <kbd>PropertyAnimation</kbd> implementations. These animations will rotate the rectangles. To view these animations, we need to make some changes in the <kbd>u_qml.qml</kbd> file with the visible properties of the items and set the visible property of the <kbd>Grid</kbd> to <kbd>false</kbd>.</p>
<ol start="3">
<li>Set the <kbd>visible</kbd> property of the group of animated items to <kbd>true</kbd>:</li>
</ol>
<pre style="padding-left: 60px">...<br/>    ...<br/>    Uqmls.UItem {<br/>        visible: true<br/>    ...<br/>...</pre>
<p style="padding-left: 60px">The group of items will be visible.</p>
<ol start="4">
<li>Set the <kbd>visible</kbd> property of the <kbd>Grid</kbd> to <kbd>false</kbd>:</li>
</ol>
<pre style="padding-left: 60px">...<br/>    ...<br/>    Grid {<br/>        visible: false<br/>    ...<br/>...</pre>
<p style="padding-left: 60px">The grid with items will be invisible. We have successfully implemented several animations with different approaches. The result is as follows:</p>
<p class="CDPAlignCenter CDPAlign"><img src="img/023c580e-0aa9-4740-a5ce-909b8ea99823.png"/></p>


            

            
        
    

        

                            
                    <h1 class="header-title">Summary</h1>
                
            
            
                
<p>This chapter has covered QML and its basic syntax. QML is useful when creating a GUI. Qt provides instruments to make GUIs, such as the <kbd>QtQml</kbd> and <kbd>QtQuick</kbd> modules. <kbd>QtQml</kbd> is more of a tool for working with the language and the QML engine infrastructure, but the <kbd>QtQuick</kbd> module provides libraries that help us to construct GUIs with wide functionality and visualization instruments. The language and QML engine infrastructure represent the core functionality of the library, and includes elements such as signal construction, binding properties, and running QML applications with Python. Almost all of the examples in this chapter use the <kbd>QtQuick</kbd> module to implement the visual components and functionality of the QML application. </p>
<p>The next chapter will be devoted to the <kbd>QtQuick</kbd> module and submodules, with a focus on control elements, positioning, layouts, and visualization.</p>


            

            
        
    </body></html>