- en: Interfacing with Technology
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In this chapter, we will cover the following topics:'
  prefs: []
  type: TYPE_NORMAL
- en: Automating your home with remotely controlled electrical sockets
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Using SPI to control an LED matrix
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Communicating using a serial interface
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Controlling Raspberry Pi using Bluetooth
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Controlling USB devices
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Introduction
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: One of the key aspects of Raspberry Pi that differentiates it from an average
    computer is its ability to interface with and control hardware. In this chapter,
    we use Raspberry Pi to control remotely activated mains sockets, send commands
    over serial connections from another computer, and control the GPIO remotely.
    We make use of SPI (another useful protocol) to drive an 8 x 8 LED matrix display.
  prefs: []
  type: TYPE_NORMAL
- en: We also use a Bluetooth module to connect with a smartphone, allowing information
    to be transferred wirelessly between devices. Finally, we take control of USB
    devices by tapping into the commands sent over USB.
  prefs: []
  type: TYPE_NORMAL
- en: Be sure to check out the *Hardware list* section in the Appendix, *Hardware
    and Software List*; it lists all the items used in this chapter and the places
    you can obtain them from.
  prefs: []
  type: TYPE_NORMAL
- en: Automating your home with remotely controlled electrical sockets
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Raspberry Pi can make an excellent tool for home automation by providing accurate
    timing, control, and the ability to respond to commands, button inputs, environmental
    sensors, or messages from the internet.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Great care must be taken when controlling devices that use electricity from
    the mains, because high voltage and currents are often involved.
  prefs: []
  type: TYPE_NORMAL
- en: Never attempt to modify or alter devices that are connected to mains electricity
    without proper training. You must never directly connect any homemade devices
    to the mains supply. All electronics must undergo rigorous safety testing to ensure
    that there will be no risk or harm to people or property in the event of a failure.
  prefs: []
  type: TYPE_NORMAL
- en: 'In this example, we will use remote-controlled **radio frequency** (**RF**)
    plug-in sockets; these use a separate remote unit to send a specific RF signal
    to switch any electrical device that is plugged into it on or off. This allows
    us to modify the remote control and use Raspberry Pi to activate the switches
    safely, without interfering with dangerous voltage:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/f157e836-9b25-4b59-b943-4385f5d8472b.png)'
  prefs: []
  type: TYPE_IMG
- en: Remote control and remote mains socket
  prefs: []
  type: TYPE_NORMAL
- en: 'The particular remote control used in this example has six buttons on it to
    directly switch three different sockets on or off and is powered by a 12V battery.
    It can be switched into four different channels, which allows you to control a
    total of 12 sockets (each socket has a similar selector that will be used to set
    the signal it will respond to):'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/4172e58f-4bf5-4714-938a-c643c00c6e48.png)'
  prefs: []
  type: TYPE_IMG
- en: Inside the remote control
  prefs: []
  type: TYPE_NORMAL
- en: The remote buttons, when pressed, will broadcast a specific RF signal (this
    one uses a transmission frequency of 433.92 MHz). This will trigger any socket(s)
    that are set to the corresponding channel (A, B, C, or D) and number (1, 2, or
    3).
  prefs: []
  type: TYPE_NORMAL
- en: Internally, each of the buttons connects two separate signals to ground, the
    number (1, 2,
  prefs: []
  type: TYPE_NORMAL
- en: 'or 3), and state (on or off). This triggers the correct broadcast that is to
    be made by the remote control:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/38875392-df46-4627-bd70-098b26c51b77.png)'
  prefs: []
  type: TYPE_IMG
- en: Connect the wires to ON and OFF, 1, 2, and 3, and GND at suitable points on
    the remote's PCB (only ON, OFF, 1, and GND are connected in the image)
  prefs: []
  type: TYPE_NORMAL
- en: It is recommended that you do not connect anything to your sockets that could
    cause a hazard if switched on or off. The signals sent by the remote are not unique
    (there are only four different channels available). This therefore makes it possible
    for someone else nearby who has a similar set of sockets to unknowingly activate/deactivate
    one of your sockets. It is recommended that you select a channel other than the
    default, A, which will slightly reduce the chance of someone else accidentally
    using the same channel.
  prefs: []
  type: TYPE_NORMAL
- en: To allow Raspberry Pi to simulate the button presses of the remote, we will
    need five
  prefs: []
  type: TYPE_NORMAL
- en: 'relays to allow us to select the number (1, 2, or 3) and state (on or off):'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/033eb712-9704-4532-927d-64cdac423a59.png)'
  prefs: []
  type: TYPE_IMG
- en: A prebuilt relay module can be used to switch the signals
  prefs: []
  type: TYPE_NORMAL
- en: Alternatively, the transistor and relay circuit from [Chapter 12](df3bebe6-c2d8-492c-92bb-298cc2bf49d9.xhtml),
    *Building Robots*, can be used to simulate the button presses.
  prefs: []
  type: TYPE_NORMAL
- en: 'Wire the relay control pins to the Raspberry Pi GPIO and connect the socket
    remote control to each relay output as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/a9183efb-b4a0-4d7e-b8a9-36dcf7e75f8a.png)'
  prefs: []
  type: TYPE_IMG
- en: The socket remote control circuit
  prefs: []
  type: TYPE_NORMAL
- en: Although the remote socket requires both the number (1, 2, or 3) and the state
    (on or off) to activate a socket, it is the state signal that activates the RF
    transmission. To avoid draining the remote's battery, we must ensure that we have
    turned off the state signal.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Create the following `socketControl.py` script:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: The socket control script performs a quick test by switching the first socket
    on for 5 seconds and then turning it off again.
  prefs: []
  type: TYPE_NORMAL
- en: 'To control the rest of the sockets, create a GUI menu as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/5273a07c-480a-432f-9047-e5f063374e78.png)'
  prefs: []
  type: TYPE_IMG
- en: Remote Switches GUI
  prefs: []
  type: TYPE_NORMAL
- en: 'Create the following `socketMenu.py` script:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: How it works...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The first script defines a class called `Switch`; it sets up the GPIO pins required
    to control the five relays (within the `setup` function). It also defines the
    `__enter__` and `__exit__` functions, which are special functions used by the
    `with..as` statement. When a class is created using `with..as`, it uses `__enter__`
    to perform any extra initialization or setup (if required), and then it performs
    any cleanup by calling `__exit__`. When the `Switch` class has been executed,
    all the relays are switched off to preserve the remote's battery and `GPIO.cleanup()`
    is called to release the GPIO pins. The parameters of the `__exit__` function
    (`type`, `value`, and `traceback`) allow the handling of any specific exceptions
    that may have occurred when the class was being executed within the `with..as`
    statement (if required).
  prefs: []
  type: TYPE_NORMAL
- en: To control the sockets, create two functions that will switch the relevant relays
    on or off to activate the remote control to send the required signal to the sockets.
    Then, shortly after, turn the relays off again using `clear()`. To make controlling
    the switches even easier, create a `message` function that will allow a switch
    number and state to be specified.
  prefs: []
  type: TYPE_NORMAL
- en: We make use of the `socketControl.py` script by creating a Tkinter GUI menu.
    The menu is made up of three sets of controls (one for each of the switches) that
    are defined by the `swButtons` class.
  prefs: []
  type: TYPE_NORMAL
- en: The `swButtons` class creates a `Tkinter` button and two `Radiobutton` controls.
    Each `swButtons` object is given an index and a reference to the `mySwitches`
    object. This allows us to set a name for the button and control a particular switch
    when it is pressed. The socket is activated/deactivated by calling `message()`,
    with the required switch number and state set by the `Radiobutton` controls.
  prefs: []
  type: TYPE_NORMAL
- en: There's more...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The previous example allows you to rewire the remotes of most remote-controlled
    sockets, but another option is to emulate the signals to control it directly.
  prefs: []
  type: TYPE_NORMAL
- en: Sending RF control signals directly
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Instead of rewiring the remote control, you can replicate the remote''s RF
    signals using a transmitter that uses the same frequency as your sockets (these
    particular units use 433.94 MHz). This will depend on the particular sockets and
    sometimes your location â€“ some countries prohibit the use of certain frequencies
    â€“ as you may require certification before making your own transmissions:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/3029bc19-2d83-4b74-a964-ca2c2e6e078d.png)'
  prefs: []
  type: TYPE_IMG
- en: The 433.94 MHz RF transmitter (left) and receiver (right)
  prefs: []
  type: TYPE_NORMAL
- en: The signals sent by the RF remote control can be recreated using 433Utils created
    by
  prefs: []
  type: TYPE_NORMAL
- en: '[http://ninjablocks.com](http://ninjablocks.com). The 433Utils uses WiringPi
    and is written in C++, allowing high speed capture and replication of the RF signals.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Obtain the code using the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: Next, we need to wire up our RF transmitter (so we can control the switches)
    and RF receiver (so we can determine the control codes) to the Raspberry Pi.
  prefs: []
  type: TYPE_NORMAL
- en: The transmitter (the smaller square module) has three pins, which are power
    (VCC), ground (GND), and data out (DATA). The voltage supplied on the power pin
    will govern the transmission range (we will use a 5V supply from Raspberry Pi,
    but you could replace this with 12V, as long as you ensure you connect the ground
    pin to both your 12V supply and Raspberry Pi).
  prefs: []
  type: TYPE_NORMAL
- en: 'Although the receiver has four pins, there is a power pin (VCC), ground pin
    (GND), and two data out pins (DATA), which are wired together, so we only need
    to connect three wires to Raspberry Pi:'
  prefs: []
  type: TYPE_NORMAL
- en: '| **RF Tx** | **RPi GPIO pin** | **RF Rx** | **RPi GPIO pin** |'
  prefs: []
  type: TYPE_TB
- en: '| VCC (5V) | 2 | VCC (3V3) | 1 |'
  prefs: []
  type: TYPE_TB
- en: '| Data out | 11 | Data in | 13 |'
  prefs: []
  type: TYPE_TB
- en: '| GND | 6 | GND | 9 |'
  prefs: []
  type: TYPE_TB
- en: Before we use the programs within the `RPi_Utils`, we will make a few adjustments
    to ensure our RX and TX pins are set correctly.
  prefs: []
  type: TYPE_NORMAL
- en: 'Locate `codesend.cpp` in `433Utils-master/RPi_utils/` to make the required
    changes:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: Change `int PIN = 0;` (located at around line 24) to `int PIN = 11;` (RPi physical
  prefs: []
  type: TYPE_NORMAL
- en: pin number).
  prefs: []
  type: TYPE_NORMAL
- en: 'Change `wiringPi` to use physical pin numbering (located around line 27) by
    replacing `wiringPiSetup()` with `wiringPiSetupPhy()`. Otherwise, the default
    is `wiringPi` GPIO numbers; for more details, see [http://wiringpi.com/reference/setup/](http://wiringpi.com/reference/setup/).
    Find the following line:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: 'Change it to this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: Save and exit `nano` using *Ctrl* + *X*, *Y*.
  prefs: []
  type: TYPE_NORMAL
- en: 'Make similar adjustments to `RFSniffer.cpp`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: 'Find the following line (located at around line 25):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: 'Change it to this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: 'Find the following line (located at around line 27):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: 'Change it to this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: Save and exit `nano` using *Ctrl* + *X*, *Y*.
  prefs: []
  type: TYPE_NORMAL
- en: 'Build the code using the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: 'This should build without errors, as shown here:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: 'Now that we have our RF modules connected to Raspberry Pi and our code ready,
    we can capture the control signals from our remote. Run the following command
    and take note of the reported output:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: 'Get the output by switching button 1 OFF with the remote set to channel A (note
    that we may pick up some random noise):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: 'We can now send out the signals using the `sendcode` command to switch the
    sockets OFF (`1381716`) and ON (`1381719`):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: You could even set up Raspberry Pi to use the receiver module to detect signals
    from the remote (on an unused channel) and to act upon them to start processes,
    control other hardware, or perhaps trigger a software shutdown/reboot.
  prefs: []
  type: TYPE_NORMAL
- en: Extending the range of the RF transmitter
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The range of the transmitter is very limited when it is powered by 5V and without
    an additional antenna. However, it is worth testing everything before you make
    any modifications.
  prefs: []
  type: TYPE_NORMAL
- en: 'Simple wire antenna can be made from 25 cm of single core wire, 17 mm side
    connected to the antenna solder point, then 16 turns (made using a thin screwdriver
    shaft or similar) and the remaining wire on top (approximately 53 mm):'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/23e8cd0a-11fe-46ab-b349-65ec56983419.png)'
  prefs: []
  type: TYPE_IMG
- en: The transmitter range is vastly improved with a simple antenna
  prefs: []
  type: TYPE_NORMAL
- en: Determining the structure of the remote control codes
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Recording the codes for each of the buttons, we can determine the codes for
    each (and break down the structure):'
  prefs: []
  type: TYPE_NORMAL
- en: '|  | **1** | **2** | **3** |'
  prefs: []
  type: TYPE_TB
- en: '|  | **ON** | **OFF** | **ON** | **OFF** | **ON** | **OFF** |'
  prefs: []
  type: TYPE_TB
- en: '| **A** | `0x15 15 57``(1381719)` | `0x15 15 54``(1381716)` | `0x15 45 57``(1394007)`
    | `0x15 45 54``(1394004)` | `0x15 51 57``(1397079)` | `0x15 51 54``(1397076)`
    |'
  prefs: []
  type: TYPE_TB
- en: '| **B** | `0x45 15 57``(4527447)` | `0x45 15 54``(4527444)` | `0x45 45 57``(4539735)`
    | `0x45 45 54``(4539732)` | `0x45 51 57``(4542807)` | `0x45 51 54``(4542804)`
    |'
  prefs: []
  type: TYPE_TB
- en: '| **C** | `0x51 15 57``(5313879)` | `0x51 15 54``(5313876)` | `0x51 45 57``(5326167)`
    | `0x51 45 54``(5326164)` | `0x51 51 57``(5329239)` | `0x51 51 54``(5329236)`
    |'
  prefs: []
  type: TYPE_TB
- en: '| **D** | `0x54 15 57``(5510487)` | `0x54 15 57``(5510487)` | `0x54 45 57``(5522775)`
    | `0x54 45 54``(5522772)` | `0x54 51 57``(5525847)` | `0x54 51 54``(5526612)`
    |'
  prefs: []
  type: TYPE_TB
- en: '| **A** | **B** | **C** | **D** | **1** | **2** | **3** | **na** | **na** |
    **na** | **na** | **ON/OFF** |  |'
  prefs: []
  type: TYPE_TB
- en: '| 01 | 01 | 01 | 01 | 01 | 01 | 01 | 01 | 01 | 01 | 01 | 11/00 |  |'
  prefs: []
  type: TYPE_TB
- en: The different codes are shown in hex format to help you see the structure; the
    sendcode command uses the decimal format (shown within the parentheses)
  prefs: []
  type: TYPE_NORMAL
- en: To select channel A, B, C, or D, set the two bits to 00\. Similarly, for button
    1, 2, or 3, set the two bits to 00 to select that button. Finally, set the last
    two bits to 11 for ON or 00 for OFF.
  prefs: []
  type: TYPE_NORMAL
- en: See [https://arduinodiy.wordpress.com/2014/08/12/433-mhz-system-for-your-arduino/](https://arduinodiy.wordpress.com/2014/08/12/433-mhz-system-for-your-arduino/),
    which analyses these and other similar RF remote controls.
  prefs: []
  type: TYPE_NORMAL
- en: Using SPI to control an LED matrix
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In [Chapter 10](18a915b2-803e-465d-a84a-0b9accdb54f2.xhtml), *Sensing and Displaying
    Real-World Data*, we connected to devices using a bus protocol called IÂ²C. Raspberry
    Pi also supports another chip-to-chip protocol calledÂ **Serial Peripheral Interface**Â (**SPI**).
    The SPI bus differs from IÂ²C because it uses two single direction data lines (where
    IÂ²C uses one bidirectional data line).
  prefs: []
  type: TYPE_NORMAL
- en: 'Although SPI requires more wires (IÂ²C uses two bus signals, SDA and SCL), it
    supports the simultaneous sending and receiving of data and much higher clock
    speeds than IÂ²C:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/afdd071d-ff0c-4244-b67d-c6e54625ebb5.png)'
  prefs: []
  type: TYPE_IMG
- en: General connections of SPI devices with Raspberry Pi
  prefs: []
  type: TYPE_NORMAL
- en: 'The SPI bus consists of the following four signals:'
  prefs: []
  type: TYPE_NORMAL
- en: '**SCLK**: This allows the clock edges to read/write data on the input/output
    lines; it is driven by the master device. As the clock signal changes from one
    state to another, the SPI device will check the state of the MOSI signal to read
    a single bit. Similarly, if the SPI device is sending data, it will use the clock
    signal edges to synchronize when it sets the state of the MISO signal.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**CE**: This refers to Chip Enable (typically, a separate Chip Enable is used
    for each slave device on the bus). The master device will set the Chip Enable
    signal to low for the device that it wants to communicate with. When the Chip
    Enable signal is set to high, it ignores any other signals on the bus. This signal
    is sometimes called **Chip Select** (**CS**) or **Slave Select** (**SS**).'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Master Output, Slave InputÂ (MOSI)**: It connects to Data Out of the master
    device and Data In of the slave device.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Master Input, Slave Output (MISO)**: It provides a response from the slave.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The following diagram shows each of the signals:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/f412c562-9822-401e-b6b9-3d9246592b93.png)'
  prefs: []
  type: TYPE_IMG
- en: 'The SPI signals: SCLK (1), CE(2), MOSI(3), and MISO(4)'
  prefs: []
  type: TYPE_NORMAL
- en: 'The previous scope trace shows two bytes being sent over SPI. Each byte is
    clocked into the SPI device using the **SCLK (1)** signal. A byte is signified
    by a burst of eight clock cycles (a low and then high period on the **SCLK (1)**
    signal), where the value of a specific bit is read when the clock state changes.
    The exact sample point is determined by the clock mode; in the following diagram,
    it is when the clock goes from low to high:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/0b4b046d-1e37-4fea-aa27-22c79ee2b224.png)'
  prefs: []
  type: TYPE_IMG
- en: The first data byte sent by Raspberry Pi to the SPI device using the MOSI(3)
    signal
  prefs: []
  type: TYPE_NORMAL
- en: The first byte sent is 0x01 (all the bits are low, except **Bit 0**) and the
    second sent is 0x03 (only **Bit 1** and **Bit 0** are high). At the same time,
    the **MOSI (4)** signal returns data from the SPI device-in this case, 0x08 (**Bit
    3** is high) and 0x00 (all the bits are low). The **SCLK (1)** signal is used
    to sync everything, even the data being sent from the SPI device.
  prefs: []
  type: TYPE_NORMAL
- en: The **CE (2)** signal is held low while the data is being sent to instruct that
    particular SPI device to listen to the **MOSI (4)** signal. When the **CE (2)**
    signal is set to high again, it indicates to the SPI device that the transfer
    has been completed.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following is an image of an 8 x 8 LED matrix that is controlled via the
    **SPI Bus**:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/7f668052-ccd1-451a-9e01-811859262828.png)'
  prefs: []
  type: TYPE_IMG
- en: An 8 x 8 LED module displaying the letter K
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The `wiringPi` library that we used previously for IÂ²C also supports SPI. Ensure
    that `wiringPi` is installed (see [Chapter 10](18a915b2-803e-465d-a84a-0b9accdb54f2.xhtml),
    *Sensing and Displaying Real-World Data*, for details) so that we can use it here.
  prefs: []
  type: TYPE_NORMAL
- en: 'Next, we need to enable SPI if we didn''t do so when we enabled IÂ²C previously:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: 'Remove the `#` before `#dtparam=spi=on` to enable it, so it reads, and save
    (*Ctrl* + *X*, *Y*, *Enter*):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: 'You can confirm that the SPI is active by listing all the running modules using
    the following command and locating `spi_bcm2835`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: 'You can test the SPI with the following `spiTest.py` script:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: 'Connect inputs **19** and **21** to create an SPI loopback for testing:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/1fc6523a-7814-4fbd-8c0c-09e4dbc2af52.png)'
  prefs: []
  type: TYPE_IMG
- en: The SPI loopback test
  prefs: []
  type: TYPE_NORMAL
- en: 'You should get the following result:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: The example that follows uses an LED 8 x 8 matrix display that is being driven
    by an
  prefs: []
  type: TYPE_NORMAL
- en: 'SPI-controlled **MAX7219 LED driver**:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/a18157d2-1ba5-449a-a279-3f5d5dfce1b5.png)'
  prefs: []
  type: TYPE_IMG
- en: An LED Controller MAX7219 pin-out, LED matrix pin-out, and LED matrix internal
    wiring (left to right)
  prefs: []
  type: TYPE_NORMAL
- en: 'Although the device has been designed to control eight separate seven-segment
    LED digits, we can use it for our LED matrix display. When used for digits, each
    of the seven segments (plus a decimal place) is wired to one of the SEG pins and
    the COM connection of each of the digits is wired to the DIG pins. The controller
    then switches each of the segments on as required, while setting the relevant
    digit COM to low to enable it. The controller can quickly cycle through each of
    the digits using the DIG pin quickly enough that all eight appear to be lit at
    the same time:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/046af381-a802-4f12-a6a4-8187b2941489.png)'
  prefs: []
  type: TYPE_IMG
- en: A seven-segment LED digit uses segments A to G, plus DP (decimal place)
  prefs: []
  type: TYPE_NORMAL
- en: We use the controller in a similar way, except each SEG pin will connect to
    a column in the matrix and the DIG pins will enable/disable a row.
  prefs: []
  type: TYPE_NORMAL
- en: 'We use an 8 x 8 module connected to the MAX7219 chip as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/67c17366-1d28-48d8-a6a5-a64c97fe129a.png)'
  prefs: []
  type: TYPE_IMG
- en: The MAX7219 LED controller driving an 8 x 8 LED matrix display
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'To control an LED matrix connected to an SPI MAX7219 chip, create the following
    `matrixControl.py` script:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: Running the script (`python3 matrixControl.py`) displays the letter `K`.
  prefs: []
  type: TYPE_NORMAL
- en: 'We can use a GUI to control the output of the LED matrix using `matrixMenu.py`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: 'The Matrix GUI allows us to switch each of the LEDs on/off by clicking on each
    of the squares (or by directly entering the hexadecimal value) to create the required
    pattern:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/24ec196a-5ac9-4b64-8920-4f0855eaeb4c.png)'
  prefs: []
  type: TYPE_IMG
- en: Using the Matrix GUI to control the 8 x 8 LED matrix
  prefs: []
  type: TYPE_NORMAL
- en: How it works...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Initially, we defined addresses for each of the control registers used by the
    MAX7219 device. View the datasheet at for more information:'
  prefs: []
  type: TYPE_NORMAL
- en: '[https://datasheets.maximintegrated.com/en/ds/MAX7219-MAX7221.pdf](https://datasheets.maximintegrated.com/en/ds/MAX7219-MAX7221.pdf).'
  prefs: []
  type: TYPE_NORMAL
- en: We created a class called `matrix` that will allow us to control the module.
    The `__init__()` function sets up the SPI of Raspberry Pi (using `SPI_CS` as pin
    26 CS1 and `SPI_SPEED` as 100 kHz).
  prefs: []
  type: TYPE_NORMAL
- en: 'The key function in our `matrix` class is the `sendCmd()` function; it uses
    `wiringpi.wiringPiSPIDataRW(SPI_CS,buff)` to send `buffer` (which is the raw byte
    data that we want to send) over the SPI bus (while also setting the `SPI_CS` pin
    to low when the transfer occurs). Each command consists of two bytes: the first
    specifies the address of the register, and the second sets the data that needs
    to be put into it. To display a row of lights, we send the address of one of the
    `ROW` registers (`MC.MAX7219_DIGIT`) and the bit-pattern we want to display (as
    a byte).'
  prefs: []
  type: TYPE_NORMAL
- en: After the `wiringpi.wiringPiSPIDataRW()` function is called, `buffer` contains
    the result of whatever is received on the MISO pin (which is read simultaneously
    as the data is sent via the MOSI pin). If connected, this will be the output of
    the LED module (a delayed copy of the data that was sent). Refer to the following
    *There's more...* section regarding daisy-chained SPI configurations to learn
    how the chip output can be used.
  prefs: []
  type: TYPE_NORMAL
- en: To initialize the MAX7219, we need to ensure that it is configured in the correct
    mode. First, we set the Scan Limit field to `7` (which enables all the DIG0 -
    DIG7 outputs). Next, we disable the built-in digit decoding since we are using
    the raw output for the display (and don't want it to try to display digits). We
    also want to ensure that the `MAX7219_DISPLAYTEST` register is disabled (if enabled,
    it would turn on all the LEDs).
  prefs: []
  type: TYPE_NORMAL
- en: We ensure the display is cleared by calling our own `clear()` function, which
    sends `0`
  prefs: []
  type: TYPE_NORMAL
- en: to each of the `MAX7219_DIGIT` registers to clear each of the rows. Finally,
    we use the `MAX7219_INTENSITY` register to set the brightness of the LEDs. The
    brightness is controlled using a PWM output to make the LEDs appear brighter or
    darker according to the brightness that is required.
  prefs: []
  type: TYPE_NORMAL
- en: 'Within the `main()` function, we perform a quick test to display the letter
    K on the grid by sending a set of 8 bytes (`0x0066763e1e366646`):'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/7a631f4d-d84f-4dd3-a1d4-f49476f7735c.png)'
  prefs: []
  type: TYPE_IMG
- en: Each 8 x 8 pattern consists of 8 bits in 8 bytes (one bit for each column, making
    each byte a row in the display)
  prefs: []
  type: TYPE_NORMAL
- en: The `matrixGUI` class creates a canvas object that is populated with a grid
    of rectangle objects to represent the 8 x 8 grid of LEDs we want to control (these
    are kept in `self.light`). We also add a text entry box to display the resulting
    bytes that we will send to the LED matrix module. We then bind the `<Button-1>`
    mouse event to the canvas so that `mouseClick` is called whenever a mouse click
    occurs within the area of the canvas.
  prefs: []
  type: TYPE_NORMAL
- en: We attach a function called `changedCode()` to the `codeText` variable using
    `trace`, a special Python function, which allows us to monitor specific variables
    or functions. If we use the `'w'` value with the `trace` function, the Python
    system will call the `callback` function whenever the value is written to.
  prefs: []
  type: TYPE_NORMAL
- en: When the `mouseClick()` function is called, we use the `event.x` and `event.y`
    coordinates to identify the object that is located there. If an item is detected,
    then the ID of the item is used (via `toggleLight()`) to toggle the corresponding
    bit in the `self.lightStatus` value, and the color of the light in the display
    changes accordingly (via `setLight()`). The `codeText` variable is also updated
    with the new hexadecimal representation of the `lightStatus` value.
  prefs: []
  type: TYPE_NORMAL
- en: The `changeCode()` function allows us to use the `codeText` variable and translate
    it into an integer. This allows us to check whether it is a valid value. Since
    it is possible to enter text here freely, we must validate it. If we are unable
    to convert it to an integer, the `codeValue` text is refreshed using the `lightStatus`
    value. Otherwise, we check if it is too large, in which case we perform a bit-shift
    by 4 to divide it by 16 until it is within a valid range. We update the `lightStatus`
    value, the GUI lights, the `codeText` variable, and also the hardware (by calling
    `updateHardware()`).
  prefs: []
  type: TYPE_NORMAL
- en: The `updateHardware()` function makes use of the `myMatrixHW` object that was
    created using the `MC.matrix` class. We send the bytes that we want to display
    to the matrix hardware one byte at a time (along with the corresponding `MAX7219_DIGIT`
    value to specify the row).
  prefs: []
  type: TYPE_NORMAL
- en: There's more...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The SPI bus allows us to control multiple devices on the same bus by using the
    Chip
  prefs: []
  type: TYPE_NORMAL
- en: Enable signal. Some devices, such as the MAX7219, also allow what is known as
    a
  prefs: []
  type: TYPE_NORMAL
- en: daisy-chain SPI configuration.
  prefs: []
  type: TYPE_NORMAL
- en: Daisy-chain SPI configuration
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: You may have noticed that the `matrix` class also returns a byte when we send
    the data on the MOSI line. This is the data output from the MAX7219 controller
    on the DOUT connection. The MAX7219 controller actually passes all the DIN data
    through to DOUT, which is one set of instructions behind the DIN data. In this
    way, the MAX7219 can be daisy-chained (with each DOUT feeding into the next DIN).
    By keeping the CE signal low, multiple controllers can be loaded with data by
    being passed though one another.
  prefs: []
  type: TYPE_NORMAL
- en: 'The data is ignored while CE is set to low; the output will only be changed
    when we set it to high again. In this way, you can clock in all the data for each
    of the modules in the chain and then set the CE to high to update them:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/11bafa78-73ba-47e9-8c55-dc53b6880c4e.png)'
  prefs: []
  type: TYPE_IMG
- en: The daisy-chain SPI configuration
  prefs: []
  type: TYPE_NORMAL
- en: We need to do this for each row that we wish to update (or use `MAX7219_NOOP`
    if we want to keep the current row the same). This is known as a daisy-chain SPI
    configuration, supported by some SPI devices, where data is passed through each
    device on the SPI bus to the next one, which allows the use of three bus control
    signals for multiple devices.
  prefs: []
  type: TYPE_NORMAL
- en: Communicating using a serial interface
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Traditionally, serial protocols such as RS232 are a common way to connect devices
    such as printers and scanners as well as joysticks and mouse devices to computers.
    Now, despite being superseded by USB, many peripherals still make use of this
    protocol for internal communication between components, to transfer data, and
    to update firmware. For electronics hobbyists, RS232 is a very useful protocol
    for debugging and controlling other devices while avoiding the complexities of
    USB.
  prefs: []
  type: TYPE_NORMAL
- en: The two scripts in this example allow for the control of the GPIO pins to illustrate
    how we can remotely control Raspberry Pi using the serial port. The serial port
    can be connected to a PC, another Raspberry Pi device, or even an embedded microcontroller
    (such as Arduino, PIC, or similar).
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The easiest way to connect to Raspberry Pi via a serial protocol will depend
    on whether your computer has a built-in serial port or not. The serial connection,
    software, and test setup are described in the following three steps:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Create an RS232 serial connection between your computer and Raspberry Pi. For
    this, you need one of the following setups:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: If your computer has a built-in serial port available, you can use
  prefs:
  - PREF_UL
  - PREF_UL
  type: TYPE_NORMAL
- en: 'a Null-Modem cable with an RS232-to-USB adaptor to connect to Raspberry Pi:'
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: '![](img/1e43a32d-07cc-4c10-b29a-3b5d38c666dc.png)'
  prefs: []
  type: TYPE_IMG
- en: RS232-to-USB adapter
  prefs: []
  type: TYPE_NORMAL
- en: 'A Null-Modem is a serial cable/adapter that has the TX and RX wires crossed
    over so that one side is connected to the TX pin of the serial port and the other
    side is connected to the RX pin:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/acf971b4-d912-4d17-b8e5-dc8a97b101ed.png)'
  prefs: []
  type: TYPE_IMG
- en: A PC serial port connected to Raspberry Pi via a Null-Modem cable and an RS232-to-USB
    adapter USB for an RS232 adapter
  prefs: []
  type: TYPE_NORMAL
- en: 'A list of supported USB-to-RS232 devices is available at the following link:'
  prefs: []
  type: TYPE_NORMAL
- en: '[http://elinux.org/RPi_VerifiedPeripherals#USB_UART_and_USB_to_Serial_.28RS-232.29_adapters](http://elinux.org/RPi_VerifiedPeripherals#USB_UART_and_USB_to_Serial_.28RS-232.29_adapters).'
  prefs: []
  type: TYPE_NORMAL
- en: Refer to the *There's more...* section for details on how to set them up.
  prefs: []
  type: TYPE_NORMAL
- en: If you do not have a serial port built in to your computer, you can use another
    USB-to-RS232 adapter to connect to the PC/laptop, converting the RS232 to the
    more common USB connection.
  prefs: []
  type: TYPE_NORMAL
- en: If you do not have any available USB ports on Raspberry Pi, you can use the
    GPIO serial pins directly with either a serial console cable or a Bluetooth serial
    module (refer to the *There's more...* section for details). Both of these will
    require some additional setup.
  prefs: []
  type: TYPE_NORMAL
- en: In all cases, you can use an RS232 loopback to confirm that everything is working
    and set up correctly (again, refer to the *There's more...* section).
  prefs: []
  type: TYPE_NORMAL
- en: Next, prepare the software you need for this example.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: You will need to install `pyserial` so we can use the serial port with Python.
  prefs: []
  type: TYPE_NORMAL
- en: 'Install `pyserial` with the following command (you will also need `pip` installed;
    refer to [Chapter 3](eb11b6c6-b334-42e0-941c-5d32db18cc9d.xhtml), *Using Python
    for Automation and Productivity*, for details):'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: 'Refer to the `pySerial` site for further documentation:'
  prefs: []
  type: TYPE_NORMAL
- en: '[https://pyserial.readthedocs.io/en/latest/](https://pyserial.readthedocs.io/en/latest/).'
  prefs: []
  type: TYPE_NORMAL
- en: In order to demonstrate the RS232 serial control, you will require some example
    hardware attached to Raspberry Pi's GPIO pins.
  prefs: []
  type: TYPE_NORMAL
- en: 'The `serialMenu.py` script allows the GPIO pins to be controlled using commands
    sent through the serial port. To fully test this, you can connect suitable output
    devices (such as LEDs) to each of the GPIO pins. You can ensure that the total
    current is kept low using 470-ohm resistors for each of the LEDs so that the maximum
    GPIO current that the Raspberry Pi can supply is not exceeded:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/a019b67d-3b3c-4793-bec9-74a1e7dac4af.png)'
  prefs: []
  type: TYPE_IMG
- en: A test circuit to test the GPIO output via serial control
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Create the following `serialControl.py` script:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: Ensure that the `serName` element is correct for the serial port you want to
    use (such as `/dev/ttyAMA0` for the GPIO pins or `/dev/ttyUSB0` for a USB RS232
    adapter).
  prefs: []
  type: TYPE_NORMAL
- en: Connect the other end to a serial port on your laptop or computer (the serial
    port can be another USB-to-RS232 adapter).
  prefs: []
  type: TYPE_NORMAL
- en: Monitor the serial port on your computer using a serial program such as HyperTerminal
    or RealTerm for Windows or Serial Tools for OS X. You will need to ensure that
    you have the correct COM port set and a baud rate of 9,600 bps (`Parity=None`,
    `Data Bits=8`, `Stop Bits=1`, and `Hardware Flow Control=None`).
  prefs: []
  type: TYPE_NORMAL
- en: The script will send a request for data to the user and wait for a response.
  prefs: []
  type: TYPE_NORMAL
- en: To send data to Raspberry Pi, write some text on the other computer and press
    *Enter* to send it over to Raspberry Pi.
  prefs: []
  type: TYPE_NORMAL
- en: 'You will see output similar to the following in the Raspberry Pi terminal:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/7020a150-d190-44bc-8c5b-53c79957578f.png)'
  prefs: []
  type: TYPE_IMG
- en: The text Switch on LED 1 has been sent via a USB-to-RS232 cable from a connected
    computer
  prefs: []
  type: TYPE_NORMAL
- en: 'You will also see output similar to the following in the serial monitoring
    program:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/f490dd93-6784-471c-92a7-efa990579863.png)'
  prefs: []
  type: TYPE_IMG
- en: RealTerm displaying typical output from the connected serial port
  prefs: []
  type: TYPE_NORMAL
- en: Press *Ctrl* + *C* on Raspberry Pi to stop the script.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Now, create a GPIO control menu. Create `serialMenu.py`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: 'When you run the script (`sudo python3 serialMenu.py`), type the control messages
    within the serial monitoring program:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/cd8061b0-5146-474b-9586-719162945205.png)'
  prefs: []
  type: TYPE_IMG
- en: The GPIO Serial Control menu
  prefs: []
  type: TYPE_NORMAL
- en: 'The Terminal output on Raspberry Pi will be similar to the following screenshot,
    and the LEDs should respond accordingly:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/3637fda1-fe71-4192-99c9-db6f793215c4.png)'
  prefs: []
  type: TYPE_IMG
- en: The GPIO Serial Control menu
  prefs: []
  type: TYPE_NORMAL
- en: Raspberry Pi validates the commands received from the serial connection and
    switches the LEDs connected to the GPIO pins 7 and 11 on and then off.
  prefs: []
  type: TYPE_NORMAL
- en: How it works...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The first script, `serialControl.py`, provides us with a `serPort` class. We
    define the class with the following functions:'
  prefs: []
  type: TYPE_NORMAL
- en: '`__init__(self,serName="/dev/ttyAMA0")`: This function will create a new serial
    device using `serName` â€“ the default of `/dev/ttyAMA0`Â is the ID for the GPIO
    serial pins (see the *There''s more...* section). After it is initialized, information
    about the device is displayed.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`__enter__(self)`: This is a dummy function that allows us to use the `with...as`
    method.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`send(self,message)`: This is used to check that the serial port is open and
    not in use; if this is the case, it will then send a message (after converting
    it to raw bytes using the `s2b()` function).'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`receive(self, chars=1, echo=True, terminate="r")`: After checking whether
    the serial port is open and not in use, this function then waits for data through
    the serial port. The function will collect data until the terminated characters
    are detected and then the full message is returned.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`__exit__(self,type,value,traceback)`: This function is called when the `serPort`
    object is no longer required by the `with...as` method, so we can close the port
    at this point.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The `main()` function in the script performs a quick test of the class by sending
    a prompt for data through the serial port to a connected computer and then waits
    for input that will be followed by the terminated character(s).
  prefs: []
  type: TYPE_NORMAL
- en: The next script, `serialMenu.py`, allows us to make use of the `serPort` class.
  prefs: []
  type: TYPE_NORMAL
- en: The `main()` function sets up the GPIO pins as output (via `gpioSetup()`), creates
    a new `serPort` object, and finally waits for commands coming from the serial
    port. Whenever a new command is received, the `handleCmd()` function is used to
    parse the message to ensure that it is correct before acting on it.
  prefs: []
  type: TYPE_NORMAL
- en: The script will switch a particular GPIO pin on or off as commanded via the
    serial port using the `GPIO` command keyword. We could add any number of command
    keywords and control (or read) whatever device (or devices) we attached to Raspberry
    Pi. We now have a very effective way to control Raspberry Pi using any devices
    connected via a serial link.
  prefs: []
  type: TYPE_NORMAL
- en: There's more...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In addition to the serial transmit and receive, the RS232 serial standard includes
    several other control signals. To test it, you can use a serial loopback to confirm
    if the serial ports
  prefs: []
  type: TYPE_NORMAL
- en: are set up correctly.
  prefs: []
  type: TYPE_NORMAL
- en: Configuring a USB-to-RS232 device for Raspberry Pi
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Once you have connected the USB-to-RS232 device to Raspberry Pi, check to see
    whether
  prefs: []
  type: TYPE_NORMAL
- en: 'a new serial device is listed by typing the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: 'The `dmesg` command lists events that occur on the system; using `grep`, we
    can filter any messages that mention `tty`, as shown in the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: This shows that a PL2303-based USB-RS232 device was attached (2,409 seconds
    after startup) and allocated the `ttyUSB0` identity. You will see that a new serial
    device has been added within the `/dev/` directory (usually `/dev/ttyUSB0` or
    something similar).
  prefs: []
  type: TYPE_NORMAL
- en: If the device has not been detected, you can try steps similar to the ones used
    in [Chapter 1](b2230c60-fd75-45fd-82c8-e477459db3e0.xhtml), *Getting Started with
    a Raspberry Pi 3 Computer*, to locate and install suitable drivers (if they are
    available).
  prefs: []
  type: TYPE_NORMAL
- en: RS232 signals and connections
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The RS232 serial standard has lots of variants and includes six additional control
    signals.
  prefs: []
  type: TYPE_NORMAL
- en: 'The Raspberry Pi GPIO serial drivers (and the Bluetooth TTL module used in
    the following example) only support RX and TX signals. If you require support
    for other signals, such as DTR, which is often used for a reset prior to the programming
    of AVR/Arduino devices, then alternative GPIO serial drivers may be needed to
    set these signals via other GPIO pins. Most RS232-to-USB adapters support the
    standard signals; however, ensure that anything you connect is able to handle
    standard RS232 voltages:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/51528259-42e7-4569-8158-ae7f567feca0.png)'
  prefs: []
  type: TYPE_IMG
- en: The RS232 9-Way D connector pin-out and signals
  prefs: []
  type: TYPE_NORMAL
- en: 'For more details on the RS232 serial protocol and to learn how these signals
    are used, visit the following link:'
  prefs: []
  type: TYPE_NORMAL
- en: '[http://en.wikipedia.org/wiki/Serial_port](http://en.wikipedia.org/wiki/Serial_port).'
  prefs: []
  type: TYPE_NORMAL
- en: Using the GPIO built-in serial pins
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Standard RS232 signals can range from -15V to +15V, so you must never directly
    connect any RS232 device to the GPIO serial pins. You must use an RS232 to TTL
    voltage-level converter (such as a MAX232 chip) or a device that uses TTL-level
    signals (such as another microcontroller or a TTL serial console cable):'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/a732198e-8bcb-49ff-97e9-54aa9e31528e.png)'
  prefs: []
  type: TYPE_IMG
- en: A USB-to-TTL serial console cable (voltage level is 3V)
  prefs: []
  type: TYPE_NORMAL
- en: 'Raspberry Pi has TTL-level serial pins on the GPIO header that allow the connection
    of a TTL serial USB cable. The wires will connect to the Raspberry Pi GPIO pins
    and the USB will plug in to your computer and be detected like a standard RS232-to-USB
    cable:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/d45db928-bd0e-448d-bf93-443c59267a0d.png)'
  prefs: []
  type: TYPE_IMG
- en: Connection of a USB-to-TTL serial console cable to the Raspberry Pi GPIO
  prefs: []
  type: TYPE_NORMAL
- en: It is possible to provide power from the USB port to the 5V pin; however, this
    will bypass the built-in polyfuse, so it is not recommended for general use (just
    leave the 5V wire disconnected and power it up as normal using the micro USB).
  prefs: []
  type: TYPE_NORMAL
- en: By default, these pins are set up to allow remote terminal access, allowing
    you to connect
  prefs: []
  type: TYPE_NORMAL
- en: to the COM port via PuTTY and to create a serial SSH session.
  prefs: []
  type: TYPE_NORMAL
- en: A serial SSH session can be helpful if you want to use Raspberry Pi without
    a display attached to it.
  prefs: []
  type: TYPE_NORMAL
- en: However, a serial SSH session is limited to text-only Terminal access since
    it does not support X10 forwarding, as used in the *Connecting remotely to Raspberry
    Pi over the network using SSH (and X11 forwarding)* section of [Chapter 1](b2230c60-fd75-45fd-82c8-e477459db3e0.xhtml),
    *Getting Started with a Raspberry Pi 3 Computer*.
  prefs: []
  type: TYPE_NORMAL
- en: In order to use it as a standard serial connection, we have to disable the serial
    console so it is available for us to use.
  prefs: []
  type: TYPE_NORMAL
- en: 'First, we need to edit `/boot/cmdline.txt` to remove the first `console` and
    `kgboc` options (do not remove the other `console=tty1` option, which is the default
    Terminal when you switch on):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: The previous command line becomes the following (ensure that this is still a
    single
  prefs: []
  type: TYPE_NORMAL
- en: 'command line):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: 'We also have to remove the task that runs the `getty` command (the program
    that handles the text Terminal for the serial connection) by commenting it out
    with `#`. This is set in `/etc/inittab` as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: 'The previous command line becomes the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: To reference the GPIO serial port in our script, we use its name, `/dev/ttyAMA0`.
  prefs: []
  type: TYPE_NORMAL
- en: The RS232 loopback
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: You can check whether the serial port connections are working correctly using
    a
  prefs: []
  type: TYPE_NORMAL
- en: serial loopback.
  prefs: []
  type: TYPE_NORMAL
- en: 'A simple loopback consists of connecting RXD and TXD together. These are pins
    8 and 10 on the Raspberry Pi GPIO header, or pins 2 and 3 on the standard RS232
    D9 connector on the USB-RS232 adapter:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/12505654-6822-4caa-8598-b5c4ddd62d07.png)'
  prefs: []
  type: TYPE_IMG
- en: Serial loopback connections to test the Raspberry Pi GPIO (left) and RS232 9-Way
    D connector (right)
  prefs: []
  type: TYPE_NORMAL
- en: 'An RS232 full loopback cable also connects pin 4 (DTR) and pin 6 (DSR) as well
    as pin 7 (RTS) and pin 8 (CTS) on the RS232 adapter. However, this is not required
    for most situations, unless these signals are used. By default, no pins are allocated
    on Raspberry Pi specifically for these additional signals:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/4cb2a5a1-40c9-4c0b-8682-a549c491034a.png)'
  prefs: []
  type: TYPE_IMG
- en: RS232 full loopback
  prefs: []
  type: TYPE_NORMAL
- en: 'Create the following `serialTest.py` script:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: 'When a loopback is connected, you will observe that the message is echoed back
    to the screen (when removed, `No data Received` will be displayed):'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/d5ba2a9f-3e18-4a10-bc04-0d9ba7282a18.png)'
  prefs: []
  type: TYPE_IMG
- en: An RS232 loopback test on GPIO serial pins
  prefs: []
  type: TYPE_NORMAL
- en: 'If we require non-default settings, they can be defined when the serial port
    is initialized (the pySerial documentation at [https://pyserial.readthedocs.io/en/latest/](https://pyserial.readthedocs.io/en/latest/)
    provides full details of all the options), as shown in the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs: []
  type: TYPE_PRE
- en: Controlling Raspberry Pi using Bluetooth
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Serial data can also be sent through Bluetooth by connecting a HC-05 Bluetooth
    module that supports the **Serial Port Profile** (**SPP**) to the GPIO serial
    RX/TX pins. This allows the serial connection to become wireless, which allows
    Android tablets or smartphones to be used to control things and to read data from
    Raspberry Pi:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/85c1c7b6-68c2-48df-ba23-d81bd93ec6cd.png)'
  prefs: []
  type: TYPE_IMG
- en: The HC-05 Bluetooth module for the TLL serial
  prefs: []
  type: TYPE_NORMAL
- en: While it is possible to achieve a similar result using a USB Bluetooth dongle,
    additional configuration would be required depending on the particular dongle
    used. The TTL Bluetooth module provides a drop-in replacement for a physical cable,
    requiring very little additional configuration.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Ensure that the serial console has been disabled (see the previous *There's
    more...* section).
  prefs: []
  type: TYPE_NORMAL
- en: 'The module should be connected using the following pins:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/c2cf2f1f-224d-401f-833f-67be4a33e960.png)'
  prefs: []
  type: TYPE_IMG
- en: Connection to a Bluetooth module for the TLL serial
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: With the Bluetooth module configured and connected, we can pair the module with
    a laptop or smartphone to send and receive commands wirelessly. Bluetooth spp
    pro provides an easy way to use a serial connection over Bluetooth to control
    or monitor Raspberry Pi for Android devices.
  prefs: []
  type: TYPE_NORMAL
- en: 'Alternatively, you may be able to set up a Bluetooth COM port on your PC/laptop
    and use it in the same way as the previous wired example:'
  prefs: []
  type: TYPE_NORMAL
- en: 'When the device is connected initially, the LED flashes quickly to indicate
    that it is waiting to be paired. Enable Bluetooth on your device and select the
    HC-05 device:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/eb5aa69e-f913-4bf7-94b6-6804a93f8993.png)'
  prefs: []
  type: TYPE_IMG
- en: The HC-05 Bluetooth module viewable in Bluetooth spp pro
  prefs: []
  type: TYPE_NORMAL
- en: 'Click on the Pair button to begin the pairing process and enter the device''s
    PIN (the default is `1234`):'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/eaacb1c8-65f6-408e-8ac4-7347cfcd283c.png)'
  prefs: []
  type: TYPE_IMG
- en: Pair the Bluetooth device with the PIN code (1234)
  prefs: []
  type: TYPE_NORMAL
- en: 'If the pairing was successful, you will be able to connect with the device
    and send and receive messages to and from Raspberry Pi:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/ea1f4551-307b-49b5-9cb3-ae5850c51155.png)'
  prefs: []
  type: TYPE_IMG
- en: Connect to the device and select the control method
  prefs: []
  type: TYPE_NORMAL
- en: In Keyboard mode, you can define actions for each of the buttons to send suitable
    commands when pressed.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: For example, Pin12 ON can be set to send `gpio 12 on` and Pin12 OFF can be set
    to send `gpio 12 off`.
  prefs: []
  type: TYPE_NORMAL
- en: Ensure that you set the end flag to `rn` via the menu options.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Ensure that `menuSerial.py` is set to use the GPIO serial connection:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs: []
  type: TYPE_PRE
- en: 'Run the `menuSerial.py` script (with the LEDs attached):'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs: []
  type: TYPE_PRE
- en: 'Check that the Bluetooth serial app displays the `GPIO Serial Control` menu
    as shown in the following screenshot:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/95a5b345-114c-48f2-a5ab-f7540890c12c.png)'
  prefs: []
  type: TYPE_IMG
- en: GPIO control over Bluetooth
  prefs: []
  type: TYPE_NORMAL
- en: 'We can see from the output in the following screenshot that the commands have
    been received and the LED connected to pin 12 has been switched on and off as
    required:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/c473b6fa-7f5d-4b90-b756-80754fb516bf.png)'
  prefs: []
  type: TYPE_IMG
- en: Raspberry Pi receiving GPIO control over Bluetooth
  prefs: []
  type: TYPE_NORMAL
- en: How it works...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: By default, the Bluetooth module is set up to act like a TTL serial slave device,
    so we can simply plug it in to the GPIO RX and TX pins. Once the module is paired
    with a device, it will transfer the serial communication over the Bluetooth connection.
    This allows us to send commands and receive data via Bluetooth and to control
    Raspberry Pi using a smartphone or PC.
  prefs: []
  type: TYPE_NORMAL
- en: This means you can attach a second module to another device (such as an Arduino)
    that
  prefs: []
  type: TYPE_NORMAL
- en: has TTL serial pins and control it using Raspberry Pi (either by pairing it
    with another
  prefs: []
  type: TYPE_NORMAL
- en: TTL Bluetooth module or suitably configuring a USB Bluetooth dongle). If the
    module is
  prefs: []
  type: TYPE_NORMAL
- en: set up as a master device, then you will need to reconfigure it to act as a
    slave (see the *There's more...* section).
  prefs: []
  type: TYPE_NORMAL
- en: There's more...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Now, let's understand how to configure the Bluetooth settings.
  prefs: []
  type: TYPE_NORMAL
- en: Configuring Bluetooth module settings
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The Bluetooth module can be set to one of two different modes using the KEY
    pin.
  prefs: []
  type: TYPE_NORMAL
- en: In a normal operation, serial messages are sent over Bluetooth; however, if
    we need to change the settings of the Bluetooth module itself, we can do so by
    connecting the KEY pin to 3V3 and putting it into AT mode.
  prefs: []
  type: TYPE_NORMAL
- en: AT mode allows us to directly configure the module, allowing us to change the
    baud rate, the pairing code, the device name, or even set it up as a master/slave
    device.
  prefs: []
  type: TYPE_NORMAL
- en: 'You can use `miniterm`, which is part of pySerial, to send the required messages,
    as shown in the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE37]'
  prefs: []
  type: TYPE_PRE
- en: 'The `miniterm` program, when started, will prompt you for the port to use:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE38]'
  prefs: []
  type: TYPE_PRE
- en: 'You can send the following commands (you will need to do this quickly, or paste
    them in, as the module will time out if there is a gap and respond with an error):'
  prefs: []
  type: TYPE_NORMAL
- en: '`AT`: This command should respond with OK.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`AT+UART?`: This command will report the current settings as `UART=<Param1>,<Param2>,<Param3>`.
    The output of this command will be OK.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: To change the current settings, use `AT+UART=<Param1>,<Param2>,<Param3>`, that
    is, `AT+UART=19200,0,0`.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '![](img/d0a9ec96-7589-4751-928e-ac2fbdd6294c.png)'
  prefs: []
  type: TYPE_IMG
- en: HC-05 AT mode AT+UART command parameters
  prefs: []
  type: TYPE_NORMAL
- en: 'Zak Kemble has written an excellent guide on how to configure modules as paired
    master and slave devices (for example, between two Raspberry Pi devices). It is
    available at the following link:'
  prefs: []
  type: TYPE_NORMAL
- en: '[http://blog.zakkemble.co.uk/getting-bluetooth-modules-talking-to-each-other/](http://blog.zakkemble.co.uk/getting-bluetooth-modules-talking-to-each-other/).'
  prefs: []
  type: TYPE_NORMAL
- en: 'For additional documentation on the HC-05 module, visit the following link:'
  prefs: []
  type: TYPE_NORMAL
- en: '[http://www.robotshop.com/media/files/pdf/rb-ite-12-bluetooth_hc05.pdf](http://www.robotshop.com/media/files/pdf/rb-ite-12-bluetooth_hc05.pdf).'
  prefs: []
  type: TYPE_NORMAL
- en: Controlling USB devices
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The **Universal Serial Bus** (**USB**) is used extensively by computers to provide
    additional peripherals and expansion through a common standard connection. We
    will use the
  prefs: []
  type: TYPE_NORMAL
- en: '`pyusb` Python library to send custom commands to connected devices over USB.'
  prefs: []
  type: TYPE_NORMAL
- en: 'The following example controls a USB toy missile launcher, which in turn allows
    it to be controlled by our Python control panel. We can see that the same principle
    can be applied to other USB devices, such as a robotic arm, using similar techniques,
    and the controls can be activated using a sensor connected to the Raspberry Pi
    GPIO:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/58c8a524-baa9-4bf4-b085-2b4e7672e8d8.png)'
  prefs: []
  type: TYPE_IMG
- en: The USB Tenx Technology SAM missile launcher
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'We will need to install `pyusb` for Python 3 using `pip-3.2` as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE39]'
  prefs: []
  type: TYPE_PRE
- en: 'You can test whether `pyusb` has installed correctly by running the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE40]'
  prefs: []
  type: TYPE_PRE
- en: This should allow you to view the package information, if it was installed correctly.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'We will create the following `missileControl.py` script, which will include
    two classes and a default `main()` function to test it:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Import the required modules as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE41]'
  prefs: []
  type: TYPE_PRE
- en: 'Define the `SamMissile()` class, which provides the specific commands for the
    USB device, as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE42]'
  prefs: []
  type: TYPE_PRE
- en: 'Define the `Missile()` class, which allows you to detect the USB device and
    provide command functions, as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE43]'
  prefs: []
  type: TYPE_PRE
- en: 'Finally, create a `main()` function, which provides a quick test of our `missileControl.py`
    module if the file is run directly, as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE44]'
  prefs: []
  type: TYPE_PRE
- en: 'When the script is run using the following command, you should see the missile
    launcher move downwards and then up again:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE45]'
  prefs: []
  type: TYPE_PRE
- en: 'To have easy control of the device, create the following GUI:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/0e2a7913-c477-481e-930e-c0128ef286bc.png)'
  prefs: []
  type: TYPE_IMG
- en: The Missile Command GUI
  prefs: []
  type: TYPE_NORMAL
- en: Although simple commands have been used here, you could use a series of preset
    commands if desired.
  prefs: []
  type: TYPE_NORMAL
- en: 'Create the GUI for the `missileMenu.py` missile command:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE46]'
  prefs: []
  type: TYPE_PRE
- en: How it works...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The control script consists of two classes: one called `Missile`, which provides
    a common interface for the control, and another called `SamMissile`, which provides
    all the specific details of the particular USB device being used.'
  prefs: []
  type: TYPE_NORMAL
- en: In order to drive a USB device, we need a lot of information about the device,
    such as its USB identification, its protocol, and the control messages it requires
    to be controlled.
  prefs: []
  type: TYPE_NORMAL
- en: The USB ID for the Tenx Technology SAM missile device is determined by the vendor
  prefs: []
  type: TYPE_NORMAL
- en: ID (`0x1130`) and the product ID (`0x0202`). This is the same identification
    information
  prefs: []
  type: TYPE_NORMAL
- en: you would see within Device Manager in Windows. These IDs are usually registered
    with [www.usb.org](http://www.usb.org); therefore, each device should be unique.
    Again, you can use the `dmesg | grep usb` command to discover these.
  prefs: []
  type: TYPE_NORMAL
- en: We use the device IDs to find the USB device using `usb.core.find`; then, we
    can send messages using `ctrl_transfer()`.
  prefs: []
  type: TYPE_NORMAL
- en: 'The USB message has five parts:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Request type (0x21)**: This defines the type of the message request, such
    as the message direction (host to device), its type (vendor), and the recipient
    (interface).'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Request** **(0x09)**: This is the set configuration.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Value** **(0x02)**: This is the configuration value.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Index** **(0x01)**: This is the command we want to send.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Data**: This is the command we want to send (as described next).'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The `SamMissile` device requires the following commands to move:'
  prefs: []
  type: TYPE_NORMAL
- en: It requires two initialization messages (`INITA` and `INITB`).
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: It also requires the control message. This consists of the `CMD`, which includes
    one of the control bytes that has been set to `1` for the required component.
    The `CMD` is then added to `CMDFILL` to complete the message.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: You will see that the other missile devices and the robot arm (see the following
    *There's more...* section) have similar message structures.
  prefs: []
  type: TYPE_NORMAL
- en: For each device, we created the `__init__()` and `move()` functions and defined
    values for each of the valid commands, which the `missile` class will use whenever
    the `left()`, `right()`, `up()`, `down()`, `fire()`, and `stop()` functions are
    called.
  prefs: []
  type: TYPE_NORMAL
- en: For the control GUI for our missile launcher, we create a small Tkinter window
    with five buttons, each of which will send a command to the missile device.
  prefs: []
  type: TYPE_NORMAL
- en: We import `missileControl` and create a `missile` object called `myMissile`
    that will be controlled by each of the buttons.
  prefs: []
  type: TYPE_NORMAL
- en: There's more...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The example only shows how to control one particular USB device; however, it
    is possible to extend this to support several types of missile devices and even
    other USB devices in general.
  prefs: []
  type: TYPE_NORMAL
- en: Controlling similar missile-type devices
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: There are several variants of USB missile-type devices, each with their own
    USB IDs and USB commands. We can add support for these other devices by defining
    their own classes to handle them.
  prefs: []
  type: TYPE_NORMAL
- en: Use `lsusb -vv` to determine the vendor and product ID that matches your device.
  prefs: []
  type: TYPE_NORMAL
- en: 'For `Chesen Electronics/Dream Link`, we have to add the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE47]'
  prefs: []
  type: TYPE_PRE
- en: 'For `Dream Cheeky Thunder`, we need the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE48]'
  prefs: []
  type: TYPE_PRE
- en: 'Finally, adjust the script to use the required class as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE49]'
  prefs: []
  type: TYPE_PRE
- en: Robot arm
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Another device that can be controlled in a similar manner is the OWI Robotic
    Arm with aÂ USB interface:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/1af76f13-d717-4b72-909a-41d8a6c59244.png)'
  prefs: []
  type: TYPE_IMG
- en: The OWI Robotic Arm with a USB interface (image courtesy of Chris Stagg)
  prefs: []
  type: TYPE_NORMAL
- en: This has featured in *The MagPi* magazine several times, thanks to *Stephen
    Richards's*
  prefs: []
  type: TYPE_NORMAL
- en: articles on Skutter; the USB control has been explained in detail in issue 3
    (page 14)
  prefs: []
  type: TYPE_NORMAL
- en: at [https://issuu.com/themagpi/docs/the_magpi_issue_3_final/14](https://issuu.com/themagpi/docs/the_magpi_issue_3_final/14).
    It can also be found at [https://www.raspberrypi.org/magpi/issues/3/](https://www.raspberrypi.org/magpi/issues/3/).
  prefs: []
  type: TYPE_NORMAL
- en: 'The robotic arm can be controlled using the following class. Remember that
    you will also need to adjust the commands,Â `UP`, `DOWN`, and so on, when calling
    the `move()` function, as shown in the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE50]'
  prefs: []
  type: TYPE_PRE
- en: Taking USB control further
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The theory and method of control used for the USB missile device can be applied
    to very complex devices such as the Xbox 360's Kinect (a special 3D camera add-on
    for the Xbox game console) as well.
  prefs: []
  type: TYPE_NORMAL
- en: Adafruit's website has a very interesting tutorial written by *Limor Fried*
    (also known as *Ladyada*) on how to analyze and investigate USB commands; access
    it at [http://learn.adafruit.com/hacking-the-kinect](http://learn.adafruit.com/hacking-the-kinect).
  prefs: []
  type: TYPE_NORMAL
- en: This is well worth a look if you intend to reverse engineer other USB items.
    In this chapter, we have used Raspberry Pi to control remotely activated mains
    sockets, to send commands over serial connections from another computer, and to
    control the GPIO remotely. We have also used SPI to drive an 8 x 8 LED matrix
    display.
  prefs: []
  type: TYPE_NORMAL
