<html><head></head><body>
<section id="chapter-11-the-toolz-package" class="level2 chapterHead" data-number="0.15">&#13;
<h2 class="chapterHead" data-number="0.15"><span class="titlemark"> 11</span><br/>&#13;
<span id="x1-23500011"/>The Toolz Package</h2>&#13;
<p>The <span class="obeylines-h"><span class="verb"><code class="inlineCode">toolz</code></span></span> package, offered by the <span class="keyWord">pytoolz </span>project on GitHub, contains a number of functional programming features. Specifically, these libraries offer iteration tools, higher-order function tools, and even some components to work with stateful dictionaries in an otherwise stateless function application.</p>&#13;
<p>There is some overlap between the <span class="obeylines-h"><span class="verb"><code class="inlineCode">toolz</code></span></span> package and components<span id="dx1-235001"/> of the standard library. The <span class="obeylines-h"><span class="verb"><code class="inlineCode">toolz</code></span></span> project decomposes into three significant parts: <span class="obeylines-h"><span class="verb"><code class="inlineCode">itertoolz</code></span></span>, <span class="obeylines-h"><span class="verb"><code class="inlineCode">functoolz</code></span></span>, and <span class="obeylines-h"><span class="verb"><code class="inlineCode">dicttoolz</code></span></span>. The <span class="obeylines-h"><span class="verb"><code class="inlineCode">itertoolz</code></span></span> and <span class="obeylines-h"><span class="verb"><code class="inlineCode">functoolz</code></span></span> modules are designed to mirror the standard library modules <span class="obeylines-h"><span class="verb"><code class="inlineCode">itertools</code></span></span> and <span class="obeylines-h"><span class="verb"><code class="inlineCode">functools</code></span></span>.</p>&#13;
<p>We’ll look at the following list of topics in this chapter:</p>&#13;
<ul>&#13;
<li><p>We’ll start with star-mapping, where a <span class="obeylines-h"><span class="verb"><code class="inlineCode">f(*args)</code></span></span> is used to provide multiple arguments to a mapping</p></li>&#13;
<li><p>We’ll also look at some additional <span class="obeylines-h"><span class="verb"><code class="inlineCode">functools.reduce()</code></span></span> topics using the <span class="obeylines-h"><span class="verb"><code class="inlineCode">operator</code></span></span> module</p></li>&#13;
<li><p>We’ll look at the <span class="obeylines-h"><span class="verb"><code class="inlineCode">toolz</code></span></span> package, which provides capabilities similar to the built-in <span class="obeylines-h"><span class="verb"><code class="inlineCode">itertools</code></span></span> and <span class="obeylines-h"><span class="verb"><code class="inlineCode">functools</code></span></span> packages, but offers a higher level of functional purity</p></li>&#13;
<li><p>We’ll also look at the <span class="obeylines-h"><span class="verb"><code class="inlineCode">operator</code></span></span> module and how it leads to some simplification and potential clarification when defining higher-order functions</p></li>&#13;
</ul>&#13;
<p>We’ll start with some more advanced use of <span class="obeylines-h"><span class="verb"><code class="inlineCode">itertools</code></span></span> and <span class="obeylines-h"><span class="verb"><code class="inlineCode">functools.reduce()</code></span></span>. These two topics will introduce the use cases for the <span class="obeylines-h"><span class="verb"><code class="inlineCode">toolz</code></span></span> package. <span id="x1-235002r238"/></p>&#13;
<section id="the-itertools-star-map-function" class="level3 sectionHead" data-number="0.15.1">&#13;
<h3 class="sectionHead" data-number="0.15.1"><span class="titlemark">11.1 </span> <span id="x1-2360001"/>The itertools star map function</h3>&#13;
<p>The <span class="obeylines-h"><span class="verb"><code class="inlineCode">itertools.starmap()</code></span></span> function is a variation of the <span class="obeylines-h"><span class="verb"><code class="inlineCode">map()</code></span></span> higher-order function. The <span class="obeylines-h"><span class="verb"><code class="inlineCode">map()</code></span></span> function applies a function against each item from a sequence. The <span class="obeylines-h"><span class="verb"><code class="inlineCode">starmap(f,</code><code class="inlineCode"> S)</code></span></span> function presumes each item, <span class="obeylines-h"><span class="verb"><code class="inlineCode">i</code></span></span>, from the sequence, <span class="obeylines-h"><span class="verb"><code class="inlineCode">S</code></span></span>, is a tuple, and uses <span class="obeylines-h"><span class="verb"><code class="inlineCode">f(*i)</code></span></span>. The number of items in each tuple must match the number of parameters in the given function.</p>&#13;
<p>Here’s an example that uses a number of features of the <span class="obeylines-h"><span class="verb"><code class="inlineCode">starmap()</code></span></span> function<span id="dx1-236001"/>:</p>&#13;
<div id="tcolobox-240" class="tcolorbox tcolorbox">&#13;
&#13;
&#13;
<pre class="lstinputlisting"><code>&gt;&gt;&gt; from itertools import starmap, zip_longest &#13;
&gt;&gt;&gt; d = starmap(pow, zip_longest([], range(4), fillvalue=60)) &#13;
&gt;&gt;&gt; list(d) &#13;
[1, 60, 3600, 216000]</code></pre>&#13;
&#13;
</div>&#13;
<p>The <span class="obeylines-h"><span class="verb"><code class="inlineCode">itertools.zip_longest()</code></span></span> function will create a sequence of pairs, <span class="lstinline"><span style="color:#000000"><code class="inlineCode">[(60,</code></span><span style="color:#000000"> </span><span style="color:#000000"><code class="inlineCode">0)</code></span><span style="color:#000000"><code class="inlineCode">,</code></span><span style="color:#000000"> </span><span style="color:#000000"><code class="inlineCode">(60,</code></span><span style="color:#000000"> </span><span style="color:#000000"><code class="inlineCode">1)</code></span><span style="color:#000000"><code class="inlineCode">,</code></span><span style="color:#000000"> </span><span style="color:#000000"><code class="inlineCode">(60,</code></span><span style="color:#000000"> </span><span style="color:#000000"><code class="inlineCode">2)</code></span><span style="color:#000000"><code class="inlineCode">,</code></span><span style="color:#000000"> </span><span style="color:#000000"><code class="inlineCode">(60,</code></span><span style="color:#000000"> </span><span style="color:#000000"><code class="inlineCode">3)</code></span><span style="color:#000000"><code class="inlineCode">]</code></span></span>. It does this because we provided two sequences: the <span class="obeylines-h"><span class="verb"><code class="inlineCode">[]</code></span></span> brackets and the <span class="obeylines-h"><span class="verb"><code class="inlineCode">range(4)</code></span></span> parameter. The <span class="obeylines-h"><span class="verb"><code class="inlineCode">fillvalue</code></span></span> parameter is used when the shorter sequence runs out of data.</p>&#13;
<p>When we use the <span class="obeylines-h"><span class="verb"><code class="inlineCode">starmap()</code></span></span> function, each pair becomes the argument to the given function. In this case, we used the the built-in <span class="obeylines-h"><span class="verb"><code class="inlineCode">pow()</code></span></span> function, which is the <span class="obeylines-h"><span class="verb"><code class="inlineCode">**</code></span></span> operator (we can also import this from the <span class="obeylines-h"><span class="verb"><code class="inlineCode">operator()</code></span></span> module; the definition is in both places). This expression calculates values for <span class="obeylines-h"><span class="verb"><code class="inlineCode">[60**0,</code><code class="inlineCode"> 60**1,</code><code class="inlineCode"> 60**2,</code><code class="inlineCode"> 60**3]</code></span></span>. The value of the <span class="obeylines-h"><span class="verb"><code class="inlineCode">d</code></span></span> variable is <span class="obeylines-h"><span class="verb"><code class="inlineCode">[1,</code><code class="inlineCode"> 60,</code><code class="inlineCode"> 3600,</code><code class="inlineCode"> 216000]</code></span></span>.</p>&#13;
<p>The <span class="obeylines-h"><span class="verb"><code class="inlineCode">starmap()</code></span></span> function expects a sequence of tuples. We have a tidy equivalence between the <span class="obeylines-h"><span class="verb"><code class="inlineCode">map(f,</code><code class="inlineCode"> x,</code><code class="inlineCode"> y)</code></span></span> and <span class="obeylines-h"><span class="verb"><code class="inlineCode">starmap(f,</code><code class="inlineCode"> zip(x,</code><code class="inlineCode"> y))</code></span></span> functions.</p>&#13;
<p>Here’s a continuation of the preceding example of the <span class="obeylines-h"><span class="verb"><code class="inlineCode">itertools.starmap()</code></span></span> function:</p>&#13;
<div id="tcolobox-241" class="tcolorbox tcolorbox">&#13;
&#13;
&#13;
<pre class="lstinputlisting"><code>&gt;&gt;&gt; p = (3, 8, 29, 44) &#13;
&gt;&gt;&gt; pi = sum(starmap(truediv, zip(p, d))) &#13;
&gt;&gt;&gt; pi &#13;
3.1415925925925925</code></pre>&#13;
&#13;
</div>&#13;
<p>We’ve zipped together two sequences of four values. The value of the <span class="obeylines-h"><span class="verb"><code class="inlineCode">d</code></span></span> variable was computed above using <span class="obeylines-h"><span class="verb"><code class="inlineCode">starmap()</code></span></span>. The <span class="obeylines-h"><span class="verb"><code class="inlineCode">p</code></span></span> variable refers to a simple list of literal items. We zipped these to make pairs of items. We used the <span class="obeylines-h"><span class="verb"><code class="inlineCode">starmap()</code></span></span> function with the <span class="obeylines-h"><span class="verb"><code class="inlineCode">operator.truediv()</code></span></span> function, which is the <span class="obeylines-h"><span class="verb"><code class="inlineCode">/</code></span></span> operator. This will compute a sequence of fractions that we sum. The sum is an approximation of <span class="italic">π </span><span class="cmsy-10x-x-109">≈</span><img src="../Images/file105.jpg" class="frac" data-align="middle" alt="-3- 600"/> + <img src="../Images/file106.jpg" class="frac" data-align="middle" alt="-8- 601"/> + <img src="../Images/file107.jpg" class="frac" data-align="middle" alt="29- 602"/> + <img src="../Images/file108.jpg" class="frac" data-align="middle" alt="-44- 603"/>.</p>&#13;
<p>Here’s a slightly simpler version that uses the <span class="obeylines-h"><span class="verb"><code class="inlineCode">map(f,</code><code class="inlineCode"> x,</code><code class="inlineCode"> y)</code></span></span> function instead of the <span class="obeylines-h"><span class="verb"><code class="inlineCode">starmap(f,</code><code class="inlineCode"> zip(x,y))</code></span></span> function:</p>&#13;
<div id="tcolobox-242" class="tcolorbox tcolorbox">&#13;
&#13;
&#13;
<pre class="lstinputlisting"><code>&gt;&gt;&gt; pi = sum(map(truediv, p, d)) &#13;
&gt;&gt;&gt; pi &#13;
3.1415925925925925</code></pre>&#13;
&#13;
</div>&#13;
<p>In this example, we effectively converted a base 60 fractional value to base 10. The sequence of values in the <span class="obeylines-h"><span class="verb"><code class="inlineCode">d</code></span></span> variable are the appropriate denominators. A technique similar to the one explained earlier in this section can be used to convert other bases.</p>&#13;
<p>Some approximations involve potentially infinite sums (or products). These can be evaluated using similar techniques explained previously in this section. We can leverage the <span class="obeylines-h"><span class="verb"><code class="inlineCode">count()</code></span></span> function in the <span class="obeylines-h"><span class="verb"><code class="inlineCode">itertools</code></span></span> module to generate an arbitrary number of terms in an approximation. We can then use the <span class="obeylines-h"><span class="verb"><code class="inlineCode">takewhile()</code></span></span> function to only accumulate values that contribute a useful level of precision to the answer. Looked at another way, <span class="obeylines-h"><span class="verb"><code class="inlineCode">takewhile()</code></span></span> yields a stream of significant values, and stops consuming values from the stream when an insignificant value is found.</p>&#13;
<p>For our next example, we’ll leverage the <span class="obeylines-h"><span class="verb"><code class="inlineCode">fact()</code></span></span> function defined in <a href="Chapter_06.xhtml#x1-1260006"><span class="cmti-10x-x-109">Chapter</span><span class="cmti-10x-x-109"> 6</span></a>, <a href="Chapter_06.xhtml#x1-1260006"><span class="cmti-10x-x-109">Recursions and Reductions</span></a>. Look at the <a href="Chapter_06.xhtml#x1-1280001"><span class="cmti-10x-x-109">Implementing manual tail-call</span> <span class="cmti-10x-x-109">optimization</span></a> section for the relevant code.</p>&#13;
<p>We’ll introduce a very similar function, the semifactorial, also called<span id="dx1-236016"/> <span class="keyWord">double</span> <span class="keyWord">factorial</span>, denoted by the !! symbol. The definition of semifactorial is similar to the definition of factorial. The important difference is that it is the product of <span class="cmti-10x-x-109">alternate </span>numbers instead of all numbers. For example, take a look at the following formulas:</p>&#13;
<ul>&#13;
<li><p>5!! = 5 <span class="cmsy-10x-x-109">× </span>3 <span class="cmsy-10x-x-109">× </span>1</p></li>&#13;
<li><p>7!! = 7 <span class="cmsy-10x-x-109">× </span>5 <span class="cmsy-10x-x-109">× </span>3 <span class="cmsy-10x-x-109">× </span>1</p></li>&#13;
</ul>&#13;
<p>Here’s the essential function definition:</p>&#13;
<pre id="listing-238" class="lstlisting"><code>def semifact(n: int) -&gt; int: &#13;
    match n: &#13;
        case 0 | 1: &#13;
            return 1 &#13;
        case 2: &#13;
            return 2 &#13;
        case _: &#13;
            return semifact(n-2)*n</code></pre>&#13;
<p>Here’s an example of computing a sum from a potentially infinite sequence of fractions using the <span class="obeylines-h"><span class="verb"><code class="inlineCode">fact()</code></span></span> and <span class="obeylines-h"><span class="verb"><code class="inlineCode">semifact()</code></span></span> functions:</p>&#13;
<div id="tcolobox-243" class="tcolorbox tcolorbox">&#13;
&#13;
&#13;
<pre class="lstinputlisting"><code>&gt;&gt;&gt; from Chapter06.ch06_ex1 import fact &#13;
&gt;&gt;&gt; from itertools import count, takewhile &#13;
&gt;&gt;&gt; num = map(fact, count()) &#13;
&gt;&gt;&gt; den = map(semifact, (2*n+1 for n in count())) &#13;
 &#13;
&gt;&gt;&gt; terms = takewhile( &#13;
... lambda t: t &gt; 1E-10, map(truediv, num, den)) &#13;
 &#13;
&gt;&gt;&gt; round(float(2*sum(terms)), 8) &#13;
3.14159265</code></pre>&#13;
&#13;
</div>&#13;
<p>The <span class="obeylines-h"><span class="verb"><code class="inlineCode">num</code></span></span> variable is a potentially infinite sequence of numerators, based on the <span class="obeylines-h"><span class="verb"><code class="inlineCode">fact()</code></span></span> function. The <span class="obeylines-h"><span class="verb"><code class="inlineCode">count()</code></span></span> function returns ascending values, starting from zero and continuing indefinitely. The <span class="obeylines-h"><span class="verb"><code class="inlineCode">den</code></span></span> variable is also a potentially infinite sequence of denominators, based on the semifactorial function. This <span class="obeylines-h"><span class="verb"><code class="inlineCode">den</code></span></span> computation also uses <span class="obeylines-h"><span class="verb"><code class="inlineCode">count()</code></span></span> to create a potentially infinite series of values.</p>&#13;
<p>To create terms, we used the <span class="obeylines-h"><span class="verb"><code class="inlineCode">map()</code></span></span> function to apply the <span class="obeylines-h"><span class="verb"><code class="inlineCode">operator.truediv()</code></span></span> function, the <span class="obeylines-h"><span class="verb"><code class="inlineCode">/</code></span></span> operator, to each pair of values. We wrapped this in a <span class="obeylines-h"><span class="verb"><code class="inlineCode">takewhile()</code></span></span> function so that we only take terms from the <span class="obeylines-h"><span class="verb"><code class="inlineCode">map()</code></span></span> output while the value is greater than some relatively small value, in this case, 10<sup><span class="cmsy-8">−</span><span class="cmr-8">10</span></sup>.</p>&#13;
<p>This is a series expansion based on this definition:</p>&#13;
<div class="math-display" style="text-align:center">&#13;
<img src="../Images/file109.jpg" class="math-display" alt=" ∑ ---n!---- 4 arctan (1) = π = 2 (2n + 1)!! 0≤n &lt;∞ "/>&#13;
</div>&#13;
<p>An interesting variation of the series expansion theme is to replace the <span class="obeylines-h"><span class="verb"><code class="inlineCode">operator.truediv()</code></span></span> function with the <span class="obeylines-h"><span class="verb"><code class="inlineCode">fractions.Fraction()</code></span></span> function. This will create exact rational values that don’t suffer from the limitations of floating-point approximations. We’ve left the implementation as an exercise for the reader.</p>&#13;
<p>All the built-in Python operators are available in the <span class="obeylines-h"><span class="verb"><code class="inlineCode">operator</code></span></span> module. This includes all of the bit-fiddling operators as well as the comparison operators. In some cases, a generator expression may be more succinct or expressive than a rather complicated-looking <span class="obeylines-h"><span class="verb"><code class="inlineCode">starmap()</code></span></span> function with a function that represents an operator.</p>&#13;
<p>The <span class="obeylines-h"><span class="verb"><code class="inlineCode">operator</code></span></span> module offers functions that can be more terse than a lambda. We can use the <span class="obeylines-h"><span class="verb"><code class="inlineCode">operator.add</code></span></span> method instead of the <span class="obeylines-h"><span class="verb"><code class="inlineCode">add=lambda</code><code class="inlineCode"> a,</code><code class="inlineCode"> b:</code><code class="inlineCode"> a+b</code></span></span> form. If we have expressions more complex than a single operator, then the lambda object is the only way to write them. <span id="x1-236036r244"/></p>&#13;
</section>&#13;
<section id="reducing-with-operator-module-functions" class="level3 sectionHead" data-number="0.15.2">&#13;
<h3 class="sectionHead" data-number="0.15.2"><span class="titlemark">11.2 </span> <span id="x1-2370002"/>Reducing with operator module functions</h3>&#13;
<p>We’ll look at one more<span id="dx1-237001"/> way that we can use the <span class="obeylines-h"><span class="verb"><code class="inlineCode">operator</code></span></span> module definitions: we can use them with the built-in <span class="obeylines-h"><span class="verb"><code class="inlineCode">functools.reduce()</code></span></span> function. The <span class="obeylines-h"><span class="verb"><code class="inlineCode">sum()</code></span></span> function, for example, can be implemented as follows:</p>&#13;
<pre id="listing-239" class="lstlisting"><code>sum = functools.partial(functools.reduce, operator.add)</code></pre>&#13;
<p>This creates a partially evaluated version of the <span class="obeylines-h"><span class="verb"><code class="inlineCode">reduce()</code></span></span> function with the first argument supplied. In this case, it’s the <span class="obeylines-h"><span class="verb"><code class="inlineCode">+</code></span></span> operator, implemented via the <span class="obeylines-h"><span class="verb"><code class="inlineCode">operator.add()</code></span></span> function.</p>&#13;
<p>If we have a requirement<span id="dx1-237003"/> for a similar function that computes a product, we can define it like this:</p>&#13;
<pre id="listing-240" class="lstlisting"><code>prod = functools.partial(functools.reduce, operator.mul)</code></pre>&#13;
<p>This follows the pattern shown in the previous example. We have a partially evaluated <span class="obeylines-h"><span class="verb"><code class="inlineCode">reduce()</code></span></span> function with the first argument of the <span class="obeylines-h"><span class="verb"><code class="inlineCode">*</code></span></span> operator, as implemented by the <span class="obeylines-h"><span class="verb"><code class="inlineCode">operator.mul()</code></span></span> function.</p>&#13;
<p>It’s not clear whether we can do similar things with too many of the other operators. We might be able to find a use for the <span class="obeylines-h"><span class="verb"><code class="inlineCode">operator.concat()</code></span></span> function.</p>&#13;
<div id="tcolobox-244" class="packt_tip">&#13;
&#13;
&#13;
<p>The <span class="obeylines-h"><span class="verb"><code class="inlineCode">and()</code></span></span> and <span class="obeylines-h"><span class="verb"><code class="inlineCode">or()</code></span></span> functions are the bit-wise <span class="obeylines-h"><span class="verb"><code class="inlineCode">&amp;</code></span></span> and <span class="obeylines-h"><span class="verb"><code class="inlineCode">|</code></span></span> operators. These are designed to create integer results.</p>&#13;
<p>If we want to perform a reduce using the proper Boolean operations, we should use the <span class="obeylines-h"><span class="verb"><code class="inlineCode">all()</code></span></span> and <span class="obeylines-h"><span class="verb"><code class="inlineCode">any()</code></span></span> functions instead of trying to create something with the <span class="obeylines-h"><span class="verb"><code class="inlineCode">reduce()</code></span></span> function.</p>&#13;
&#13;
</div>&#13;
<p>Once we have a <span class="obeylines-h"><span class="verb"><code class="inlineCode">prod()</code></span></span> function, this means that the factorial can be defined as follows:</p>&#13;
<pre id="listing-241" class="lstlisting"><code>fact = lambda n: 1 if n &lt; 2 else n * prod(range(1, n))</code></pre>&#13;
<p>This has the advantage of being succinct: it provides a single-line definition of factorial. It also has the advantage of not relying on recursion and avoids any problem with stack limitations.</p>&#13;
<p>It’s not clear that this has any dramatic advantages over the many alternatives we have in Python. However, the concept of building a complex function from primitive pieces such as the <span class="obeylines-h"><span class="verb"><code class="inlineCode">partial()</code></span></span> and <span class="obeylines-h"><span class="verb"><code class="inlineCode">reduce()</code></span></span> functions and the <span class="obeylines-h"><span class="verb"><code class="inlineCode">operator</code></span></span> module is very elegant. This is an important design<span id="dx1-237006"/> strategy for writing functional programs.</p>&#13;
<p>Some of the designs can be simplified by using features of the <span class="obeylines-h"><span class="verb"><code class="inlineCode">toolz</code></span></span> package. We’ll look at some of the <span class="obeylines-h"><span class="verb"><code class="inlineCode">toolz</code></span></span> package in the next section. <span id="x1-237007r245"/></p>&#13;
</section>&#13;
<section id="using-the-toolz-package" class="level3 sectionHead" data-number="0.15.3">&#13;
<h3 class="sectionHead" data-number="0.15.3"><span class="titlemark">11.3 </span> <span id="x1-2380003"/>Using the toolz package</h3>&#13;
<p>The <span class="obeylines-h"><span class="verb"><code class="inlineCode">toolz</code></span></span> package comprises<span id="dx1-238001"/> functions that are similar to some of the functions in the built-in <span class="obeylines-h"><span class="verb"><code class="inlineCode">itertools</code></span></span> and <span class="obeylines-h"><span class="verb"><code class="inlineCode">functools</code></span></span> modules. The <span class="obeylines-h"><span class="verb"><code class="inlineCode">toolz</code></span></span> package adds some functions to perform sophisticated processing on dictionary objects. This package has a narrow focus on iterables, dictionaries, and functions. This overlaps nicely with the data structures available in JSON and CSV documents. The idea of processing iterables that come from files or databases allows a Python program to deal with vast amounts of data without the complication of filling memory with the entire collection of objects.</p>&#13;
<p>We’ll look at a few example functions from the various subsections of the <span class="obeylines-h"><span class="verb"><code class="inlineCode">toolz</code></span></span> package. There are over sixty individual functions in the current release. Additionally, there is a <span class="obeylines-h"><span class="verb"><code class="inlineCode">cytoolz</code></span></span> implementation written in Cython that provides higher performance than the pure Python <span class="obeylines-h"><span class="verb"><code class="inlineCode">toolz</code></span></span> package. <span id="x1-238002r241"/></p>&#13;
<section id="some-itertoolz-functions" class="level4 subsectionHead" data-number="0.15.3.1">&#13;
<h4 class="subsectionHead" data-number="0.15.3.1"><span class="titlemark">11.3.1 </span> <span id="x1-2390001"/>Some itertoolz functions</h4>&#13;
<p>We’ll look at a common<span id="dx1-239001"/> data analysis problem<span id="dx1-239002"/> of cleaning and organizing data from a number of datasets. In <a href="Chapter_09.xhtml#x1-1990009"><span class="cmti-10x-x-109">Chapter</span><span class="cmti-10x-x-109"> 9</span></a>, <a href="Chapter_09.xhtml#x1-1990009"><span class="cmti-10x-x-109">Itertools for Combinatorics –</span> <span class="cmti-10x-x-109">Permutations and Combinations</span></a>, we mentioned several datasets available at <a href="https://www.tylervigen.com" class="url">https://www.tylervigen.com</a>.</p>&#13;
<p>Each correlation includes a table of the relevant data. The tables often look like the following example:</p>&#13;
<div class="tabular">&#13;
<table id="TBL-8" class="tabular">&#13;
<tbody>&#13;
<tr class="odd hline">&#13;
<td><hr/>&#13;
</td>&#13;
<td><hr/>&#13;
</td>&#13;
<td><hr/>&#13;
</td>&#13;
<td><hr/>&#13;
</td>&#13;
<td><hr/>&#13;
</td>&#13;
</tr>&#13;
<tr id="TBL-8-1-" class="even" style="vertical-align:baseline;">&#13;
<td id="TBL-8-1-1" class="td11" style="text-align: left; white-space: nowrap;"/>&#13;
<td id="TBL-8-1-2" class="td11" style="text-align: right; white-space: nowrap;">2000</td>&#13;
<td id="TBL-8-1-3" class="td11" style="text-align: right; white-space: nowrap;">2001</td>&#13;
<td id="TBL-8-1-4" class="td11" style="text-align: right; white-space: nowrap;">2002</td>&#13;
<td id="TBL-8-1-5" class="td11" style="text-align: right; white-space: nowrap;">...</td>&#13;
</tr>&#13;
<tr class="odd hline">&#13;
<td><hr/>&#13;
</td>&#13;
<td><hr/>&#13;
</td>&#13;
<td><hr/>&#13;
</td>&#13;
<td><hr/>&#13;
</td>&#13;
<td><hr/>&#13;
</td>&#13;
</tr>&#13;
<tr id="TBL-8-2-" class="even" style="vertical-align:baseline;">&#13;
<td id="TBL-8-2-1" class="td11" style="text-align: left; white-space: nowrap;">Per capita consumption of cheese (US)</td>&#13;
<td id="TBL-8-2-2" class="td11" style="text-align: right; white-space: nowrap;">29.8</td>&#13;
<td id="TBL-8-2-3" class="td11" style="text-align: right; white-space: nowrap;">30.1</td>&#13;
<td id="TBL-8-2-4" class="td11" style="text-align: right; white-space: nowrap;">30.5</td>&#13;
<td id="TBL-8-2-5" class="td11" style="text-align: right; white-space: nowrap;">...</td>&#13;
</tr>&#13;
<tr class="odd hline">&#13;
<td><hr/>&#13;
</td>&#13;
<td><hr/>&#13;
</td>&#13;
<td><hr/>&#13;
</td>&#13;
<td><hr/>&#13;
</td>&#13;
<td><hr/>&#13;
</td>&#13;
</tr>&#13;
<tr id="TBL-8-3-" class="even" style="vertical-align:baseline;">&#13;
<td id="TBL-8-3-1" class="td11" style="text-align: left; white-space: nowrap;">Number of people who died by becoming</td>&#13;
<td/>&#13;
<td/>&#13;
<td/>&#13;
<td/>&#13;
</tr>&#13;
<tr id="TBL-8-4-" class="odd" style="vertical-align:baseline;">&#13;
<td id="TBL-8-4-1" class="td11" style="text-align: left; white-space: nowrap;">tangled in their bedsheets</td>&#13;
<td id="TBL-8-4-2" class="td11" style="text-align: right; white-space: nowrap;">327</td>&#13;
<td id="TBL-8-4-3" class="td11" style="text-align: right; white-space: nowrap;">456</td>&#13;
<td id="TBL-8-4-4" class="td11" style="text-align: right; white-space: nowrap;">509</td>&#13;
<td id="TBL-8-4-5" class="td11" style="text-align: right; white-space: nowrap;">...</td>&#13;
</tr>&#13;
<tr class="even hline">&#13;
<td><hr/>&#13;
</td>&#13;
<td><hr/>&#13;
</td>&#13;
<td><hr/>&#13;
</td>&#13;
<td><hr/>&#13;
</td>&#13;
<td><hr/>&#13;
</td>&#13;
</tr>&#13;
<tr id="TBL-8-5-" class="odd" style="vertical-align:baseline;">&#13;
<td id="TBL-8-5-1" class="td11" style="text-align: left; white-space: nowrap;"/>&#13;
<td/>&#13;
<td/>&#13;
<td/>&#13;
<td/>&#13;
</tr>&#13;
</tbody>&#13;
</table>&#13;
</div>&#13;
<p>There are generally three rows of data in each example of a spurious correlation. Each row has 10 columns of data, a title, and an empty column that acts as a handy delimiter. A small parsing function, using Beautiful Soup, can extract the essential data from the HTML. This extract isn’t immediately useful; more transformations are required.</p>&#13;
<p>Here’s the core function<span id="dx1-239003"/> for extracting the relevant text from HTML:</p>&#13;
<pre id="listing-242" class="lstlisting"><code>from bs4 import BeautifulSoup  # type: ignore[import] &#13;
import urllib.request &#13;
from collections.abc import Iterator &#13;
 &#13;
def html_data_iter(url: str) -&gt; Iterator[str]: &#13;
    with urllib.request.urlopen(url) as page: &#13;
        soup = BeautifulSoup(page.read(), ’html.parser’) &#13;
        data = soup.html.body.table.table &#13;
        for subtable in data.table: &#13;
            for c in subtable.children: &#13;
                yield c.text</code></pre>&#13;
<p>This <span class="obeylines-h"><span class="verb"><code class="inlineCode">html_data_iter()</code></span></span> function uses <span class="obeylines-h"><span class="verb"><code class="inlineCode">urllib</code></span></span> to read the HTML pages. It creates a <span class="obeylines-h"><span class="verb"><code class="inlineCode">BeautifulSoup</code></span></span> instance from the raw data. The <span class="obeylines-h"><span class="verb"><code class="inlineCode">soup.html.body.table.table</code></span></span> expression provides a navigation path into the HTML structure. This digs down into nested <span class="obeylines-h"><span class="verb"><code class="inlineCode">&lt;table&gt;</code></span></span> tags to locate the data of interest. Within the nested table, there will be other sub-tables that contain rows and columns. Because the various structures can be somewhat inconsistent, it seems best to extract the text and impose a meaningful structure on the text separately.</p>&#13;
<p>This <span class="obeylines-h"><span class="verb"><code class="inlineCode">html_data_iter()</code></span></span> function is used like this to acquire data from an HTML page:</p>&#13;
<div id="tcolobox-245" class="tcolorbox tcolorbox">&#13;
&#13;
&#13;
<pre class="lstinputlisting"><code>&gt;&gt;&gt; s7 = html_data_iter("http://www.tylervigen.com/view_correlation?id=7")</code></pre>&#13;
&#13;
</div>&#13;
<p>The result of this expression is a sequence of strings of text. Many examples have 37 individual strings. These strings can can be divided into 3 rows of 12 strings and a fourth row with a single string value. We can understand these rows as follows:</p>&#13;
<ul>&#13;
<li><p>The first row has an empty string, ten values of years, plus one more zero-length string.</p></li>&#13;
<li><p>The second row has the first data series title, ten values, and an extra zero-length string.</p></li>&#13;
<li><p>The third row, like the second, has the second data series title, ten values, and an extra string.</p></li>&#13;
<li><p>A fourth row has a single string with the correlation value between the two series.</p></li>&#13;
</ul>&#13;
<p>This requires some reorganization<span id="dx1-239017"/> to create a set of sample values we can work with.</p>&#13;
<p>We can use <span class="obeylines-h"><span class="verb"><code class="inlineCode">toolz.itertoolz.partition</code></span></span> to divide the sequence of values into groups of 12. If we interleave the three collections<span id="dx1-239018"/> using <span class="obeylines-h"><span class="verb"><code class="inlineCode">toolz.itertoolz.interleave</code></span></span>, it will create a sequence with a value from each of the three rows: year, series one, and series two. If this is partitioned into groups of three, each year and the two sample values will be a small three-tuple. We’ll quietly drop the additional row with the correlation value.</p>&#13;
<p>This isn’t the ideal form of the data, but it gets us started on creating useful objects. In the long run, the <span class="obeylines-h"><span class="verb"><code class="inlineCode">toolz</code></span></span> framework encourages us to create dictionaries to contain the sample data. We’ll get to the dictionaries later. For now, we’ll start with rearranging the source data of the first 36 strings into 3 groups of 12 strings, and then 12 groups of 3 strings. This initial restructuring looks like this:</p>&#13;
<div id="tcolobox-246" class="tcolorbox tcolorbox">&#13;
&#13;
&#13;
<pre class="lstinputlisting"><code>&gt;&gt;&gt; from toolz.itertoolz import partition, interleave &#13;
 &#13;
&gt;&gt;&gt; data_iter = partition(3, interleave(partition(12, s7))) &#13;
&gt;&gt;&gt; data = list(data_iter) &#13;
 &#13;
&gt;&gt;&gt; from pprint import pprint &#13;
&gt;&gt;&gt; pprint(data) &#13;
[(’’, &#13;
  ’Per capita consumption of cheese (US)Pounds (USDA)’, &#13;
  ’Number of people who died by becoming tangled in their bedsheets Deaths (US) ’ &#13;
  ’(CDC)’), &#13;
 (’2000’, ’29.8’, ’327’), &#13;
 (’2001’, ’30.1’, ’456’), &#13;
 (’2002’, ’30.5’, ’509’), &#13;
 (’2003’, ’30.6’, ’497’), &#13;
 (’2004’, ’31.3’, ’596’), &#13;
 (’2005’, ’31.7’, ’573’), &#13;
 (’2006’, ’32.6’, ’661’), &#13;
 (’2007’, ’33.1’, ’741’), &#13;
 (’2008’, ’32.7’, ’809’), &#13;
 (’2009’, ’32.8’, ’717’), &#13;
 (’’, ’’, ’’)]</code></pre>&#13;
&#13;
</div>&#13;
<p>The first row, awkwardly, doesn’t have a title for the year column. Because this is the very first item in the sequence, we can use a pair of <span class="obeylines-h"><span class="verb"><code class="inlineCode">itertoolz</code></span></span> functions to drop the initial string, which is always <span class="obeylines-h"><span class="verb"><code class="inlineCode">""</code></span></span>, and replace it with something more useful, <span class="obeylines-h"><span class="verb"><code class="inlineCode">"year"</code></span></span>. The resulting sequence will then have empty cells only at the end of each row, allowing us to use <span class="obeylines-h"><span class="verb"><code class="inlineCode">partitionby()</code></span></span> to decompose the long series of strings into four separate rows. The following function<span id="dx1-239042"/> definition can be used to break the source data on empty strings into parallel sequences:</p>&#13;
<pre id="listing-243" class="lstlisting"><code>from toolz.itertoolz import cons, drop  # type: ignore[import] &#13;
from toolz.recipes import partitionby  # type: ignore[import] &#13;
 &#13;
ROW_COUNT = 0 &#13;
 &#13;
def row_counter(item: str) -&gt; int: &#13;
    global ROW_COUNT &#13;
    rc = ROW_COUNT &#13;
    if item == "": ROW_COUNT += 1 &#13;
    return rc</code></pre>&#13;
<p>The <span class="obeylines-h"><span class="verb"><code class="inlineCode">row_counter()</code></span></span> function uses a global variable, <span class="obeylines-h"><span class="verb"><code class="inlineCode">ROW_COUNT</code></span></span>, to maintain a stateful count of end-of-row strings. A slightly better design would use a callable object to encapsulate the state information into a class definition. We’ve left this variant as an exercise for the reader. Using an instance variable in a class with a <span class="obeylines-h"><span class="verb"><code class="inlineCode">__call__()</code></span></span> method has numerous advantages over a global; redesigning this function is helpful because it shows how to limit side effects to the state of objects. We can also use class-level variables and a <span class="obeylines-h"><span class="verb"><code class="inlineCode">@classmethod</code></span></span> to achieve the same kind of isolation.</p>&#13;
<p>The following snippet shows how this function<span id="dx1-239053"/> is used to partition the input:</p>&#13;
<div id="tcolobox-247" class="tcolorbox tcolorbox">&#13;
&#13;
&#13;
<pre class="lstinputlisting"><code>&gt;&gt;&gt; year_fixup = cons("year", drop(1, s7)) &#13;
&gt;&gt;&gt; year, series_1, series_2, extra = list(partitionby(row_counter, year_fixup)) &#13;
&gt;&gt;&gt; data = list(zip(year, series_1, series_2)) &#13;
 &#13;
&gt;&gt;&gt; from pprint import pprint &#13;
&gt;&gt;&gt; pprint(data) &#13;
[(’year’, &#13;
  ’Per capita consumption of cheese (US)Pounds (USDA)’, &#13;
  ’Number of people who died by becoming tangled in their bedsheets Deaths (US) ’ &#13;
  ’(CDC)’), &#13;
 (’2000’, ’29.8’, ’327’), &#13;
 (’2001’, ’30.1’, ’456’), &#13;
 (’2002’, ’30.5’, ’509’), &#13;
 (’2003’, ’30.6’, ’497’), &#13;
 (’2004’, ’31.3’, ’596’), &#13;
 (’2005’, ’31.7’, ’573’), &#13;
 (’2006’, ’32.6’, ’661’), &#13;
 (’2007’, ’33.1’, ’741’), &#13;
 (’2008’, ’32.7’, ’809’), &#13;
 (’2009’, ’32.8’, ’717’), &#13;
 (’’, ’’, ’’)]</code></pre>&#13;
&#13;
</div>&#13;
<p>The <span class="obeylines-h"><span class="verb"><code class="inlineCode">row_counter()</code></span></span> function is called with each individual string, of which only a few are end-of-row. This allows each row to be partitioned into a separate sequence by the <span class="obeylines-h"><span class="verb"><code class="inlineCode">partitionby()</code></span></span> function. The resulting three sequences are then combined via <span class="obeylines-h"><span class="verb"><code class="inlineCode">zip()</code></span></span> to create a sequence of three-tuples.</p>&#13;
<p>This result is identical to the previous example. This variant, however, doesn’t depend on there being precisely three rows of 12 values. This variation depends on being able to detect a cell that’s at the end of each row. This offers flexibility.</p>&#13;
<p>A more useful form for the result is a dictionary for each sample with keys for <span class="obeylines-h"><span class="verb"><code class="inlineCode">year</code></span></span>, <span class="obeylines-h"><span class="verb"><code class="inlineCode">series_1</code></span></span>, and <span class="obeylines-h"><span class="verb"><code class="inlineCode">series_2</code></span></span>. We can transform the sequence of three-tuples into a sequence of dictionaries with a generator<span id="dx1-239076"/> expression. The following example builds a sequence of dictionaries:</p>&#13;
<pre id="listing-244" class="lstlisting"><code>from toolz.itertoolz import cons, drop &#13;
from toolz.recipes import partitionby &#13;
 &#13;
def make_samples(source: list[str]) -&gt; list[dict[str, float]]: &#13;
    # Drop the first "" and prepend "year" &#13;
    year_fixup = cons("year", drop(1, source)) &#13;
    # Restructure to 12 groups of 3 &#13;
    year, series_1, series_2, extra = list(partitionby(row_counter, year_fixup)) &#13;
    # Drop the first and the (empty) last &#13;
    samples = [ &#13;
        {"year": int(year), "series_1": float(series_1), "series_2": float(series_2)} &#13;
        for year, series_1, series_2 in drop(1, zip(year, series_1, series_2)) &#13;
        if year &#13;
    ] &#13;
    return samples</code></pre>&#13;
<p>This <span class="obeylines-h"><span class="verb"><code class="inlineCode">make_samples()</code></span></span> function creates a sequence of dictionaries. This, in turn, lets us then use other tools to extract sequences that can be used to compute the coefficient of correlation among the two series. The essential patterns for some of the <span class="obeylines-h"><span class="verb"><code class="inlineCode">itertoolz</code></span></span> functions are similar to the built-in <span class="obeylines-h"><span class="verb"><code class="inlineCode">itertools</code></span></span>.</p>&#13;
<p>In some cases, function names conflict with each other, and the semantics are different. For example, <span class="obeylines-h"><span class="verb"><code class="inlineCode">itertoolz.count()</code></span></span> and <span class="obeylines-h"><span class="verb"><code class="inlineCode">itertools.count()</code></span></span> have radically different definitions. The <span class="obeylines-h"><span class="verb"><code class="inlineCode">itertoolz</code></span></span> function is similar to <span class="obeylines-h"><span class="verb"><code class="inlineCode">len()</code></span></span>, while the standard library <span class="obeylines-h"><span class="verb"><code class="inlineCode">itertools</code></span></span> function is a variation of <span class="obeylines-h"><span class="verb"><code class="inlineCode">enumerate()</code></span></span>.</p>&#13;
<div id="tcolobox-248" class="packt_tip">&#13;
&#13;
&#13;
<p>It can help to have the reference documentation for both libraries open when designing an application. This can help you to pick and choose the most useful option between the <span class="obeylines-h"><span class="verb"><code class="inlineCode">itertoolz</code></span></span> package and the standard library <span class="obeylines-h"><span class="verb"><code class="inlineCode">itertools</code></span></span> package.</p>&#13;
<p>Note that completely free mixing and matching between these two packages isn’t easy. The general approach is to choose the one that offers the right mix of features and use it consistently.</p>&#13;
&#13;
</div>&#13;
<p><span id="x1-239092r247"/></p>&#13;
</section>&#13;
<section id="some-dicttoolz-functions" class="level4 subsectionHead" data-number="0.15.3.2">&#13;
<h4 class="subsectionHead" data-number="0.15.3.2"><span class="titlemark">11.3.2 </span> <span id="x1-2400002"/>Some dicttoolz functions</h4>&#13;
<p>One of the ideas behind<span id="dx1-240001"/> the <span class="obeylines-h"><span class="verb"><code class="inlineCode">dicttoolz</code></span></span> module of <span class="obeylines-h"><span class="verb"><code class="inlineCode">toolz</code></span></span> is to make dictionary state changes into functions that have side effects. This allows a higher-order function like <span class="obeylines-h"><span class="verb"><code class="inlineCode">map()</code></span></span> to apply a number of updates to a dictionary<span id="dx1-240002"/> as part of a larger expression. It makes it slightly easier to manage caches of values, for example, or to accumulate summaries.</p>&#13;
<p>For example, the <span class="obeylines-h"><span class="verb"><code class="inlineCode">get_in()</code></span></span> function uses a sequence of key values to navigate down into deeply nested dictionary objects. When working with complex JSON documents, using <span class="obeylines-h"><span class="verb"><code class="inlineCode">get_in(["k1",</code><code class="inlineCode"> "k2"])</code></span></span> can be easier than writing a <span class="obeylines-h"><span class="verb"><code class="inlineCode">["k1"]["k2"]</code></span></span> expression.</p>&#13;
<p>In the previous examples, we created a sequence of sample dictionaries, named <span class="obeylines-h"><span class="verb"><code class="inlineCode">samples</code></span></span>. We can extract the various series values from each dictionary and use this to compute a correlation coefficient, as shown here:</p>&#13;
<div id="tcolobox-249" class="tcolorbox tcolorbox">&#13;
&#13;
&#13;
<pre class="lstinputlisting"><code>&gt;&gt;&gt; from toolz.dicttoolz import get_in &#13;
&gt;&gt;&gt; from Chapter04.ch04_ex4 import corr &#13;
 &#13;
&gt;&gt;&gt; samples = make_samples(s7) &#13;
&gt;&gt;&gt; s_1 = [get_in([’series_1’], s) for s in samples] &#13;
&gt;&gt;&gt; s_2 = [get_in([’series_2’], s) for s in samples] &#13;
&gt;&gt;&gt; round(corr(s_1, s_2), 6) &#13;
0.947091</code></pre>&#13;
&#13;
</div>&#13;
<p>In this example, our relatively flat document means we could use <span class="obeylines-h"><span class="verb"><code class="inlineCode">s[’series_1’]</code></span></span> instead of <span class="obeylines-h"><span class="verb"><code class="inlineCode">get_in([’series_1’],</code><code class="inlineCode"> s)</code></span></span>. There’s no dramatic advantage to the <span class="obeylines-h"><span class="verb"><code class="inlineCode">get_in()</code></span></span> function. Using <span class="obeylines-h"><span class="verb"><code class="inlineCode">get_in()</code></span></span> does, however, permit future<span id="dx1-240012"/> flexibility in situations where the sample’s structure needs to become<span id="dx1-240013"/> more deeply nested to reflect a shift in the problem domain.</p>&#13;
<p>The data, <span class="obeylines-h"><span class="verb"><code class="inlineCode">s7</code></span></span>, is described in <a href="#x1-2390001"><span class="cmti-10x-x-109">Some itertoolz functions</span></a>. It comes from the Spurious Correlations website.</p>&#13;
<p>We can set a path <span class="obeylines-h"><span class="verb"><code class="inlineCode">field</code><code class="inlineCode"> =</code><code class="inlineCode"> ["domain",</code><code class="inlineCode"> "example",</code><code class="inlineCode"> "series_1"]</code></span></span> and then use this path in a <span class="obeylines-h"><span class="verb"><code class="inlineCode">get_in(path,</code><code class="inlineCode"> document)</code></span></span> expression. This isolates the path through the data structure and makes changes easier to manage. This path to the relevant data can even become a configuration parameter if data structures change frequently. <span id="x1-240014r248"/></p>&#13;
</section>&#13;
<section id="some-functoolz-functions" class="level4 subsectionHead" data-number="0.15.3.3">&#13;
<h4 class="subsectionHead" data-number="0.15.3.3"><span class="titlemark">11.3.3 </span> <span id="x1-2410003"/>Some functoolz functions</h4>&#13;
<p>The <span class="obeylines-h"><span class="verb"><code class="inlineCode">functoolz</code></span></span> module of <span class="obeylines-h"><span class="verb"><code class="inlineCode">toolz</code></span></span> has a number<span id="dx1-241001"/> of functions that can help with functional design. One idea behind these functions<span id="dx1-241002"/> is to provide some names that match the <span class="keyWord">Clojure </span>language, permitting easier transitioning between the two languages.</p>&#13;
<p>For example, the <span class="obeylines-h"><span class="verb"><code class="inlineCode">@functoolz.memoize</code></span></span> decorator<span id="dx1-241003"/> is essentially<span id="dx1-241004"/> the same as the standard library <span class="obeylines-h"><span class="verb"><code class="inlineCode">functools.cache</code></span></span>. The word ”memoize” matches the <span class="keyWord">Clojure</span> language, which some programmers find helpful.</p>&#13;
<p>One significant feature of the <span class="obeylines-h"><span class="verb"><code class="inlineCode">@functoolz</code></span></span> module is the ability to compose multiple functions. This is perhaps the most flexible way to approach functional composition in Python.</p>&#13;
<p>Consider the earlier example of using the expression <span class="lstinline"><span style="color:#000000"><code class="inlineCode">partition</code></span><span style="color:#000000"><code class="inlineCode">(3,</code></span><span style="color:#000000"> </span><span style="color:#000000"><code class="inlineCode">interleave</code></span><span style="color:#000000"><code class="inlineCode">(</code></span><span style="color:#000000"><code class="inlineCode">partition</code></span><span style="color:#000000"><code class="inlineCode">(12,</code></span><span style="color:#000000"> </span><span style="color:#000000"><code class="inlineCode">s7</code></span><span style="color:#000000"><code class="inlineCode">)</code></span><span style="color:#000000"><code class="inlineCode">)</code></span><span style="color:#000000"><code class="inlineCode">)</code></span></span> to restructure source data from a sequence of 37 values to 12 three-tuples. The final string is quietly dropped.</p>&#13;
<p>This is in effect a composition of three functions. We can look at it as the following abstract formula:</p>&#13;
<div class="math-display" style="text-align:center">&#13;
<img src="../Images/file110.jpg" class="math-display" alt="( ) p(3)∘i ∘p(12) (s7) "/>&#13;
</div>&#13;
<p>In the above, <span class="italic">p</span>(3) is <span class="obeylines-h"><span class="verb"><code class="inlineCode">partition(3,</code><code class="inlineCode"> x)</code></span></span>, <span class="italic">i </span>is <span class="obeylines-h"><span class="verb"><code class="inlineCode">interleave(y)</code></span></span>, and <span class="italic">p</span>(12) is <span class="obeylines-h"><span class="verb"><code class="inlineCode">partition(12,</code><code class="inlineCode"> z)</code></span></span>. This sequence of functions is applied to the source data sequence, <span class="italic">s</span><sub><span class="cmr-8">7</span></sub>.</p>&#13;
<p>We can more directly implement the abstraction<span id="dx1-241005"/> using <span class="obeylines-h"><span class="verb"><code class="inlineCode">functoolz.compose()</code></span></span>. Before we can look at the <span class="obeylines-h"><span class="verb"><code class="inlineCode">functoolz.compose()</code></span></span> solution, we need to look at the <span class="obeylines-h"><span class="verb"><code class="inlineCode">curry()</code></span></span> function. In <a href="Chapter_10.xhtml#x1-21700010"><span class="cmti-10x-x-109">Chapter</span><span class="cmti-10x-x-109"> 10</span></a>, <a href="Chapter_10.xhtml#x1-21700010"><span class="cmti-10x-x-109">The Functools Module</span></a>, we looked at the <span class="obeylines-h"><span class="verb"><code class="inlineCode">functools.partial()</code></span></span> function. This is similar to the concept behind<span id="dx1-241006"/> the <span class="obeylines-h"><span class="verb"><code class="inlineCode">functoolz.curry()</code></span></span> function, with a small difference. When a curried function is evaluated with incomplete arguments, it returns a new curried function with more argument values supplied. When a curried function is evaluated with all of the arguments required, it computes a result:</p>&#13;
<div id="tcolobox-250" class="tcolorbox tcolorbox">&#13;
&#13;
&#13;
<pre class="lstinputlisting"><code>&gt;&gt;&gt; from toolz.functoolz import curry &#13;
&gt;&gt;&gt; def some_model(a: float, b: float, x: float) -&gt; float: &#13;
...     return x**a * b &#13;
 &#13;
&gt;&gt;&gt; curried_model = curry(some_model) &#13;
&gt;&gt;&gt; cm_a = curried_model(1.0134) &#13;
&gt;&gt;&gt; cm_ab = cm_a(0.7724) &#13;
&gt;&gt;&gt; expected = cm_ab(1500) &#13;
&gt;&gt;&gt; round(expected, 2) &#13;
1277.89</code></pre>&#13;
&#13;
</div>&#13;
<p>The initial evaluation<span id="dx1-241018"/> of <span class="obeylines-h"><span class="verb"><code class="inlineCode">curry(some_model)</code></span></span> created a curried function, which we assigned to the <span class="obeylines-h"><span class="verb"><code class="inlineCode">curried_model</code></span></span> variable. This function needs three argument values. When we evaluated <span class="obeylines-h"><span class="verb"><code class="inlineCode">curried_model(1.0134)</code></span></span>, we provided one of the three. The result of this evaluation is a new curried function with a value for the <span class="obeylines-h"><span class="verb"><code class="inlineCode">a</code></span></span> parameter. The evaluation of <span class="obeylines-h"><span class="verb"><code class="inlineCode">cm_a(0.7724)</code></span></span> provided the second of the three parameter values; this resulted in a new function with values for both the <span class="obeylines-h"><span class="verb"><code class="inlineCode">a</code></span></span> and <span class="obeylines-h"><span class="verb"><code class="inlineCode">b</code></span></span> parameters. We’ve provided the parameters incrementally to show how a curried function can either act as a higher-order function and return another curried function, or—if all the parameters have values—compute the expected result.</p>&#13;
<div id="tcolobox-251" class="infobox note">&#13;
&#13;
&#13;
<p>We’ll revisit currying again in <a href="Chapter_13.xhtml#x1-26600013"><span class="cmti-10x-x-109">Chapter</span><span class="cmti-10x-x-109"> 13</span></a>, <a href="Chapter_13.xhtml#x1-26600013"><span class="cmti-10x-x-109">The PyMonad Library</span></a>. This will provide another perspective on this idea of using a function and argument values to create a new function.</p>&#13;
&#13;
</div>&#13;
<p>It’s common to see expressions like <span class="obeylines-h"><span class="verb"><code class="inlineCode">model</code><code class="inlineCode"> =</code><code class="inlineCode"> curry(some_model,</code><code class="inlineCode"> 1.0134,</code><code class="inlineCode"> 0.7724)</code></span></span> to bind two parameters. Then the expression <span class="obeylines-h"><span class="verb"><code class="inlineCode">model(1500)</code></span></span> will provide a result because all three parameters have values.</p>&#13;
<p>The following example shows how to compose a larger function from three separate functions:</p>&#13;
<div id="tcolobox-252" class="tcolorbox tcolorbox">&#13;
&#13;
&#13;
<pre class="lstinputlisting"><code>&gt;&gt;&gt; from toolz.itertoolz import interleave, partition, drop &#13;
&gt;&gt;&gt; from toolz.functoolz import compose, curry &#13;
&gt;&gt;&gt; steps = [ &#13;
...     curry(partition, 3), &#13;
...     interleave, &#13;
...     curry(partition, 12), &#13;
... ] &#13;
&gt;&gt;&gt; xform = compose(*steps) &#13;
&gt;&gt;&gt; data = list(xform(s7)) &#13;
 &#13;
&gt;&gt;&gt; from pprint import pprint &#13;
&gt;&gt;&gt; pprint(data)  # doctest+ ELLIPSIS &#13;
[(’’, &#13;
  ’Per capita consumption of cheese (US) Pounds (USDA)’, &#13;
  ’Number of people who died by becoming tangled in their bedsheets Deaths (US) ’ &#13;
  ’(CDC)’), &#13;
 (’2000’, ’29.8’, ’327’), &#13;
... &#13;
 (’2009’, ’32.8’, ’717’), &#13;
 (’’, ’’, ’’)]</code></pre>&#13;
&#13;
</div>&#13;
<p>Because the <span class="obeylines-h"><span class="verb"><code class="inlineCode">partition()</code></span></span> function requires two parameters, we used the <span class="obeylines-h"><span class="verb"><code class="inlineCode">curry()</code></span></span> function to bind one parameter<span id="dx1-241040"/> value. The <span class="obeylines-h"><span class="verb"><code class="inlineCode">interleave()</code></span></span> function, on the other hand, doesn’t require multiple parameters, and there’s no real need to curry this. While there’s no harm done by currying this function, there’s no compelling reason to curry it.</p>&#13;
<p>The overall <span class="obeylines-h"><span class="verb"><code class="inlineCode">functoolz.compose()</code></span></span> function combines<span id="dx1-241041"/> the three individual steps into a single function, which we’ve assigned to the variable <span class="obeylines-h"><span class="verb"><code class="inlineCode">xform</code></span></span>. The <span class="obeylines-h"><span class="verb"><code class="inlineCode">s7</code></span></span> sequence of strings is provided to the composite function. This applies the functions in right-to-left order, following conventional mathematical rules. The expression (<span class="italic">f </span><span class="cmsy-10x-x-109">∘ </span><span class="italic">g </span><span class="cmsy-10x-x-109">∘ </span><span class="italic">h</span>)(<span class="italic">x</span>) means <span class="italic">f</span>(<span class="italic">g</span>(<span class="italic">h</span>(<span class="italic">x</span>))); the right-most function in the composition is applied first.</p>&#13;
<p>There is a <span class="obeylines-h"><span class="verb"><code class="inlineCode">functoolz.compose_left()</code></span></span> function<span id="dx1-241042"/> that doesn’t follow the mathematical convention. Additionally, there’s a <span class="obeylines-h"><span class="verb"><code class="inlineCode">functoolz.pipe()</code></span></span> function that many people find easier to visualize.</p>&#13;
<p>Here’s an example of using<span id="dx1-241043"/> the <span class="obeylines-h"><span class="verb"><code class="inlineCode">functoolz.pipe()</code></span></span> function:</p>&#13;
<div id="tcolobox-253" class="tcolorbox tcolorbox">&#13;
&#13;
&#13;
<pre class="lstinputlisting"><code>&gt;&gt;&gt; from toolz.itertoolz import interleave, partition, drop &#13;
&gt;&gt;&gt; from toolz.functoolz import pipe, curry &#13;
 &#13;
&gt;&gt;&gt; data_iter = pipe(s7, curry(partition, 12), interleave, curry(partition, 3)) &#13;
&gt;&gt;&gt; data = list(data_iter) &#13;
 &#13;
&gt;&gt;&gt; from pprint import pprint &#13;
&gt;&gt;&gt; pprint(data)  # doctext: +ELLIPSIS &#13;
[(’’, &#13;
  ’Per capita consumption of cheese (US Pounds (USDA)’, &#13;
  ’Number of people who died by becoming tangled in their bedsheets Deaths (US) ’ &#13;
  ’(CDC)’), &#13;
 (’2000’, ’29.8’, ’327’), &#13;
... &#13;
 (’2009’, ’32.8’, ’717’), &#13;
 (’’, ’’, ’’)]</code></pre>&#13;
&#13;
</div>&#13;
<p>This shows the processing<span id="dx1-241061"/> steps in the pipeline in left-to-right order. First, <span class="obeylines-h"><span class="verb"><code class="inlineCode">partition(12,</code><code class="inlineCode"> s7)</code></span></span> is evaluated. The results of this are presented to <span class="obeylines-h"><span class="verb"><code class="inlineCode">interleave()</code></span></span>. The interleaved results are presented to <span class="obeylines-h"><span class="verb"><code class="inlineCode">curry(partition(3))</code></span></span>. This pipeline concept can be a very flexible way to transform very large volumes of data using the <span class="obeylines-h"><span class="verb"><code class="inlineCode">toolz.itertoolz</code></span></span> library.</p>&#13;
<p>In this section, we’ve seen a number of the functions in the <span class="obeylines-h"><span class="verb"><code class="inlineCode">toolz</code></span></span> package. These functions provide extensive and sophisticated functional programming support. They complement functions that are part of the standard <span class="obeylines-h"><span class="verb"><code class="inlineCode">itertools</code></span></span> and <span class="obeylines-h"><span class="verb"><code class="inlineCode">functools</code></span></span> libraries. It’s common to use functions from both libraries to build applications. <span id="x1-241062r246"/></p>&#13;
</section>&#13;
</section>&#13;
<section id="summary-10" class="level3 sectionHead" data-number="0.15.4">&#13;
<h3 class="sectionHead" data-number="0.15.4"><span class="titlemark">11.4 </span> <span id="x1-2420004"/>Summary</h3>&#13;
<p>We started with a quick look at some <span class="obeylines-h"><span class="verb"><code class="inlineCode">itertools</code></span></span> and <span class="obeylines-h"><span class="verb"><code class="inlineCode">functools</code></span></span> component features that overlap with components of the <span class="obeylines-h"><span class="verb"><code class="inlineCode">toolz</code></span></span> package. A great many design decisions involve making choices. It’s important to know what’s built in via Python’s Standard Library. This makes it easier to see what the benefits of reaching out to another package might be.</p>&#13;
<p>The central topic of this chapter was a look at the <span class="obeylines-h"><span class="verb"><code class="inlineCode">toolz</code></span></span> package. This complements the built-in <span class="obeylines-h"><span class="verb"><code class="inlineCode">itertools</code></span></span> and <span class="obeylines-h"><span class="verb"><code class="inlineCode">functools</code></span></span> modules. The <span class="obeylines-h"><span class="verb"><code class="inlineCode">toolz</code></span></span> package extends the essential concepts using terminology that’s somewhat more accessible to folks with experience in other languages. It also provides a helpful focus on the data structures used by JSON and CSV.</p>&#13;
<p>In the following chapters, we’ll look at how we can build higher-order functions using decorators. These higher-order functions can lead to slightly simpler and clearer syntax. We can use decorators to define an isolated aspect that we need to incorporate into a number of other functions or classes. <span id="x1-242001r250"/></p>&#13;
</section>&#13;
<section id="exercises-10" class="level3 sectionHead" data-number="0.15.5">&#13;
<h3 class="sectionHead" data-number="0.15.5"><span class="titlemark">11.5 </span> <span id="x1-2430005"/>Exercises</h3>&#13;
<p>This chapter’s exercises are based on code available from Packt Publishing on GitHub. See <a href="https://github.com/PacktPublishing/Functional-Python-Programming-3rd-Edition" class="url">https://github.com/PacktPublishing/Functional-Python-Programming-3rd-Edition</a>.</p>&#13;
<p>In some cases, the reader will notice that the code provided on GitHub includes partial solutions to some of the exercises. These serve as hints, allowing the reader to explore alternative solutions.</p>&#13;
<p>In many cases, exercises will need unit test cases to confirm they actually solve the problem. These are often identical to the unit test cases already provided in the GitHub repository. The reader should replace the book’s example function name with their own solution to confirm that it works. <span id="x1-243001r249"/></p>&#13;
<section id="replace-true-division-with-a-fraction" class="level4 subsectionHead" data-number="0.15.5.1">&#13;
<h4 class="subsectionHead" data-number="0.15.5.1"><span class="titlemark">11.5.1 </span> <span id="x1-2440001"/>Replace true division with a fraction</h4>&#13;
<p>In the <a href="#x1-2360001"><span class="cmti-10x-x-109">The itertools star map function</span></a> section, we computed a sum of fractions computed using the <span class="obeylines-h"><span class="verb"><code class="inlineCode">/</code></span></span> true division operator, available from the <span class="obeylines-h"><span class="verb"><code class="inlineCode">operator</code></span></span> module as the <span class="obeylines-h"><span class="verb"><code class="inlineCode">operator.truediv()</code></span></span> function.</p>&#13;
<p>An interesting variation of the series expansion theme is to replace the <span class="obeylines-h"><span class="verb"><code class="inlineCode">operator.truediv()</code></span></span> function—which creates <span class="obeylines-h"><span class="verb"><code class="inlineCode">float</code></span></span> objects—with the <span class="obeylines-h"><span class="verb"><code class="inlineCode">fractions.Fraction()</code></span></span> function, which will create <span class="obeylines-h"><span class="verb"><code class="inlineCode">Fraction</code></span></span> objects. Doing this will create exact rational values that don’t suffer from the limitations of floating-point approximations.</p>&#13;
<p>Change this operator and be sure the summation still approximates <span class="italic">π</span>. <span id="x1-244001r252"/></p>&#13;
</section>&#13;
<section id="color-file-parsing" class="level4 subsectionHead" data-number="0.15.5.2">&#13;
<h4 class="subsectionHead" data-number="0.15.5.2"><span class="titlemark">11.5.2 </span> <span id="x1-2450002"/>Color file parsing</h4>&#13;
<p>In <a href="Chapter_03.xhtml#x1-510003"><span class="cmti-10x-x-109">Chapter</span><span class="cmti-10x-x-109"> 3</span></a>, <a href="Chapter_03.xhtml#x1-510003"><span class="cmti-10x-x-109">Functions, Iterators, and Generators</span></a>, the <span class="obeylines-h"><span class="verb"><code class="inlineCode">Crayola.GPL</code></span></span> file was presented without showing the details of the parser. In <a href="Chapter_08.xhtml#x1-1700008"><span class="cmti-10x-x-109">Chapter</span><span class="cmti-10x-x-109"> 8</span></a>, <a href="Chapter_08.xhtml#x1-1700008"><span class="cmti-10x-x-109">The Itertools</span> <span class="cmti-10x-x-109">Module</span></a>, a parser was presented that applied a sequence of transformations to the source file. This can be rewritten to use <span class="obeylines-h"><span class="verb"><code class="inlineCode">toolz.functoolz.pipe()</code></span></span>.</p>&#13;
<p>First, write and test the new parser.</p>&#13;
<p>Compare the two parses. In particular, look for possible extensions and changes to the parsing. What if a file had multiple named color sets? Would it be possible to skip over the irrelevant ones while looking for the relevant collection of colors to parse and extract? <span id="x1-245001r253"/></p>&#13;
</section>&#13;
<section id="anscombes-quartet-parsing" class="level4 subsectionHead" data-number="0.15.5.3">&#13;
<h4 class="subsectionHead" data-number="0.15.5.3"><span class="titlemark">11.5.3 </span> <span id="x1-2460003"/>Anscombe’s quartet parsing</h4>&#13;
<p>The Git repository for this book includes a file, <span class="obeylines-h"><span class="verb"><code class="inlineCode">Anscombe.txt</code></span></span>, that contains four series of <span class="cmti-10x-x-109">(x, y) </span>pairs. Each series has the same well-known mean and standard deviation. Four distinct models are required to compute an expected <span class="italic">y </span>value for a given <span class="italic">x </span>value, since each series is surprisingly different.</p>&#13;
<p>The data is in a table that starts like the following example:</p>&#13;
<div class="tabular">&#13;
&#13;
</div>&#13;
<div class="multicolumn" style="white-space:nowrap; text-align:center;">&#13;
Anscombe’s quartet&#13;
</div>&#13;
<p>I</p>&#13;
<p>II</p>&#13;
<p>III</p>&#13;
<p>IV</p>&#13;
<p>x</p>&#13;
<p>y</p>&#13;
<p>x</p>&#13;
<p>y</p>&#13;
<p>x</p>&#13;
<p>y</p>&#13;
<p>x</p>&#13;
<p>y</p>&#13;
<p>10.0</p>&#13;
<p>8.04</p>&#13;
<p>10.0</p>&#13;
<p>9.14</p>&#13;
<p>10.0</p>&#13;
<p>7.46</p>&#13;
<p>8.0</p>&#13;
<p>6.58</p>&#13;
<p>8.0</p>&#13;
<p>6.95</p>&#13;
<p>8.0</p>&#13;
<p>8.14</p>&#13;
<p>8.0</p>&#13;
<p>6.77</p>&#13;
<p>8.0</p>&#13;
<p>5.76</p>&#13;
<div class="multicolumn" style="white-space:nowrap; text-align:center;">&#13;
<span class="cmti-10x-x-109">etc.</span>&#13;
</div>&#13;
<p>The first row is a title. The second row has series names. The third row has the two column names for each series. The remaining rows all have <span class="italic">x </span>and <span class="italic">y </span>values for each series.</p>&#13;
<p>This needs to be decomposed into four separate sequences. Each sequence should have two-element dictionaries with keys of <span class="obeylines-h"><span class="verb"><code class="inlineCode">"x"</code></span></span> and <span class="obeylines-h"><span class="verb"><code class="inlineCode">"y"</code></span></span>.</p>&#13;
<p>The foundation of the parsing is the <span class="obeylines-h"><span class="verb"><code class="inlineCode">csv</code></span></span> module. This will transform each row into a sequence of strings. Each sequence, however, has eight samples from four distinct series in it.</p>&#13;
<p>The remaining parsing to decompose the four series can be done either with <span class="obeylines-h"><span class="verb"><code class="inlineCode">toolz.itertoolz</code></span></span> or <span class="obeylines-h"><span class="verb"><code class="inlineCode">itertools</code></span></span>. Write this parser to decompose the Anscombe datasets from each other. Be sure to convert the values from strings to float values so descriptive statistics can be computed for each series. <span id="x1-246001r254"/></p>&#13;
</section>&#13;
<section id="waypoint-computations" class="level4 subsectionHead" data-number="0.15.5.4">&#13;
<h4 class="subsectionHead" data-number="0.15.5.4"><span class="titlemark">11.5.4 </span> <span id="x1-2470004"/>Waypoint computations</h4>&#13;
<p>The Git repository for this book includes a file, <span class="obeylines-h"><span class="verb"><code class="inlineCode">Winter</code><code class="inlineCode"> 2012-2013.kml</code></span></span>, that contains a series of waypoints for a long trip. In <a href="Chapter_04.xhtml#x1-740004"><span class="cmti-10x-x-109">Chapter</span><span class="cmti-10x-x-109"> 4</span></a>, <a href="Chapter_04.xhtml#x1-740004"><span class="cmti-10x-x-109">Working with</span> <span class="cmti-10x-x-109">Collections</span></a>, the foundational <span class="obeylines-h"><span class="verb"><code class="inlineCode">row_iter_kml()</code></span></span> function is described. This emits a series of <span class="obeylines-h"><span class="verb"><code class="inlineCode">list[str]</code></span></span> objects for each waypoint along the journey.</p>&#13;
<p>To be useful, the waypoints must be processed in pairs. The <span class="obeylines-h"><span class="verb"><code class="inlineCode">toolz.itertoolz.sliding</code></span></span> <span class="obeylines-h"><span class="verb"><code class="inlineCode">_window()</code></span></span> function is one way to decompose a simple sequence into pairs. The <span class="obeylines-h"><span class="verb"><code class="inlineCode">itertools</code></span></span> <span class="obeylines-h"><span class="verb"><code class="inlineCode">.pairwise()</code></span></span> function is another candidate.</p>&#13;
<p>In <a href="Chapter_07.xhtml#x1-1530007"><span class="cmti-10x-x-109">Chapter</span><span class="cmti-10x-x-109"> 7</span></a>, <a href="Chapter_07.xhtml#x1-1530007"><span class="cmti-10x-x-109">Complex Stateless Objects</span></a>, a <span class="obeylines-h"><span class="verb"><code class="inlineCode">distance()</code></span></span> function is presented that computes a close-enough distance between two waypoints. Note that the function was designed to work with complex <span class="obeylines-h"><span class="verb"><code class="inlineCode">NamedTuple</code></span></span> objects. Redesign and reimplement this distance function to work with points represented as dictionaries with keys of ”latitude” and ”longitude.”</p>&#13;
<p>The foundation of the source data parsing is the <span class="obeylines-h"><span class="verb"><code class="inlineCode">row_iter_kml()</code></span></span> function, which depends on the underlying <span class="obeylines-h"><span class="verb"><code class="inlineCode">xml.etree</code></span></span> module. This transformed each waypoint into a sequence of strings.</p>&#13;
<p>Redesign the source data parsing to use the <span class="obeylines-h"><span class="verb"><code class="inlineCode">toolz</code></span></span> package. The general processing can use <span class="obeylines-h"><span class="verb"><code class="inlineCode">tools.functoolz.pipe</code></span></span> to transform source strings into more useful resulting dictionaries. Be sure to convert latitude and longitude values to properly signed float values.</p>&#13;
<p>After the redesign, compare and contrast the two implementations. Which seems more clear and concise? Use the <span class="obeylines-h"><span class="verb"><code class="inlineCode">timeit</code></span></span> module to compare the performance to see if either offers specific performance advantages. <span id="x1-247001r255"/></p>&#13;
</section>&#13;
<section id="waypoint-geofence" class="level4 subsectionHead" data-number="0.15.5.5">&#13;
<h4 class="subsectionHead" data-number="0.15.5.5"><span class="titlemark">11.5.5 </span> <span id="x1-2480005"/>Waypoint geofence</h4>&#13;
<p>The <a href="#x1-2470004"><span class="cmti-10x-x-109">Waypoint computations</span></a> exercise consumed a file with a number of waypoints. The waypoints were connected to form a journey from start to finish.</p>&#13;
<p>It’s also sensible to examine the waypoints as isolated location samples with a latitude and longitude. Given the points, a simple boundary can be computed from the greatest and least latitude as well as the greatest and least longitude.</p>&#13;
<p>Superficially, this describes a rectangle. Pragmatically, the closer to the North Pole, the closer together the longitude positions become. The area is actually a kind of trapezoid, narrower closer to the pole.</p>&#13;
<p>A parsing pipeline similar to the one described in the <a href="#x1-2470004"><span class="cmti-10x-x-109">Waypoint computations</span></a> exercise is required. The waypoints, however, do not have to be combined into pairs. Locate the extrema on each axis to define a box around the overall voyage.</p>&#13;
<p>There are several ways to bracket the voyage, as described below:</p>&#13;
<ul>&#13;
<li><p>Given the extreme edges of the voyage, it’s possible to define four points for the four corners of the bounding trapezoid. These four points can be used to locate a midpoint for the journey.</p></li>&#13;
<li><p>Given two sequences of latitudes and longitudes, a mean latitude and a mean longitude can be computed.</p></li>&#13;
<li><p>Given two sequences of latitudes and longitudes, a median latitude and a median longitude can be computed.</p></li>&#13;
</ul>&#13;
<p>Once the boundaries and center alternatives are known, the equirectangular distance computation (from <a href="Chapter_07.xhtml#x1-1530007"><span class="cmti-10x-x-109">Chapter</span><span class="cmti-10x-x-109"> 7</span></a>, <a href="Chapter_07.xhtml#x1-1530007"><span class="cmti-10x-x-109">Complex Stateless Objects</span></a>) can be used to locate the point on the journey closest to the center. <span id="x1-248001r256"/></p>&#13;
</section>&#13;
<section id="callable-object-for-the-row_counter-function" class="level4 subsectionHead" data-number="0.15.5.6">&#13;
<h4 class="subsectionHead" data-number="0.15.5.6"><span class="titlemark">11.5.6 </span> <span id="x1-2490006"/>Callable object for the row_counter() function</h4>&#13;
<p>In the <a href="#x1-2390001"><span class="cmti-10x-x-109">Some itertoolz functions</span></a> section of this chapter, a <span class="obeylines-h"><span class="verb"><code class="inlineCode">row_counter()</code></span></span> function was defined. It used a global variable to maintain a count of source data items that ended an input row.</p>&#13;
<p>A better design is a callable object with an internal state. Consider the following class definition as a base class for your solution:</p>&#13;
<pre id="listing-245" class="lstlisting"><code>class CountEndingItems: &#13;
    def __init__(self, ending_test_function: Callable[[Any], bool]) -&gt; None: &#13;
      ... &#13;
    def __call__(self, row: Any) -&gt; int: &#13;
      ... &#13;
    def reset(self) -&gt; None: &#13;
      ...</code></pre>&#13;
<p>The idea is to create a callable object, <span class="lstinline"><span style="color:#000000"><code class="inlineCode">row_test</code></span><span style="color:#000000"> </span><span style="color:#000000"><code class="inlineCode">=</code></span><span style="color:#000000"> </span><span style="color:#000000"><code class="inlineCode">CountEndingItems</code></span><span style="color:#000000"><code class="inlineCode">(</code></span><span style="color:#000000"><code class="inlineCode">lambda</code></span><span style="color:#000000"> </span><span style="color:#000000"><code class="inlineCode">item</code></span><span style="color:#000000"><code class="inlineCode">:</code></span><span style="color:#000000"> </span><span style="color:#000000"><code class="inlineCode">item</code></span><span style="color:#000000"> </span><span style="color:#000000"><code class="inlineCode">==</code></span><span style="color:#000000"> </span><span style="color:#000000"><code class="inlineCode">"")</code></span></span>. This callable object can then be used with <span class="obeylines-h"><span class="verb"><code class="inlineCode">toolz.itertoolz.partition_by()</code></span></span> as a way to partition the input based on a count of rows that match some given condition.</p>&#13;
<p>Finish this class definition. Use it with the <span class="obeylines-h"><span class="verb"><code class="inlineCode">toolz.itertoolz.partition_by()</code></span></span> solution for partitioning input. Contrast the use of a global variable with a stateful, callable object. <span id="x1-249008r243"/></p>&#13;
</section>&#13;
</section>&#13;
</section>&#13;
</body></html>