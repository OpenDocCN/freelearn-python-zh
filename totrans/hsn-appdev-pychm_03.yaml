- en: '3'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Customizing Interpreters and Virtual Environments
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The last chapter focused on configuration options. Configuration options are
    designed to help you customize your working environment to fit the project and
    also allow for customization to fit your personal tastes. These options are one
    of the many reasons that PyCharm is a great tool. Another great feature that makes
    PyCharm useful is the customization of interpreters and virtual environments.
  prefs: []
  type: TYPE_NORMAL
- en: 'This chapter will cover the following topics:'
  prefs: []
  type: TYPE_NORMAL
- en: The importance of working with virtual environments in Python
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: How to create a virtual environment manually using `virtualenv`
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: How to create a virtual environment using PyCharm
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: How to work with an existing virtual environment in PyCharm
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: How to add and remove third-party libraries using PyCharm
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: How to import projects created outside PyCharm
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: How to work with virtual environment settings within run configurations
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: At this point, many of you will have at least one installation of a Python interpreter
    installed. It either came with your system, as is the case with macOS or Linux,
    or you installed it, as is the case with Windows. Python is an **interpreted language**—this
    means the written code is not truly evaluated until it is run. Let’s take a moment
    to describe what this means by comparing Python to a few other languages and how
    they are executed.
  prefs: []
  type: TYPE_NORMAL
- en: 'There are three common ways to execute written code on your computer, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: Compilation
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Interpretation
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Intermediate compilation with a runtime
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Before we dig into these, let’s take a short trip back through time. I know
    it is history but stick with me. In the year 1522, the predominant religion throughout
    most of Western Europe was Roman Catholicism. This was a time of great turmoil
    in that church’s history, but we will put that aside for a moment. Instead, we
    will focus on a German priest named Martin Luther. In those days, the German people
    were completely reliant on the clerical establishment for their spiritual needs.
    The Bible, in 1522, was only available in Greek and Latin. Luther, who was imprisoned
    at the time, translated the Old Testament from Greek into the German Vulgate.
    This was a game changer for the Germans. Printers of the day snatched it up and
    printed hundreds of copies so that every family could read it. I’m going to use
    this as an analogy.
  prefs: []
  type: TYPE_NORMAL
- en: 'The first method of executing written code is *compilation*. This is similar
    to Martin Luther’s translation from Greek into German. Most people who cannot
    code will see a programming language and scratch their heads and think to themselves:
    “This is Greek to me!” The same thing is happening with computers because the
    computer can’t understand your code language either. Computers don’t “speak” C
    or C++ or Java. Instead, a programmer has written something in a language that
    is simple and easy to translate as compared to human language. Compilation refers
    to a process where your textual code files are translated once into a binary format
    that is understood by the computer. Examples of compiled languages include C and
    C++. The code files are run through a compiler, which translates the code into
    a separate and new format only one time. The process produces a new file, separate
    from the code, which is useful only to the computer. To finalize our analogy,
    after translating Greek into German, the printed books became the result of the
    compilation step. The ability to read the Bible was useful to the Germans.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Contrast that with the second form of code execution: the *interpreted language*.
    Prior to Luther’s translation, the Bible was translated on the fly in church.
    A priest would open the Bible and translate the text into German as he read it
    aloud. This is what happens with interpreted languages, including Python. The
    `python main.py`, the Python interpreter opens the code file, reads the code,
    translates (compiles) that code, and executes the instructions as it reads them
    line by line.'
  prefs: []
  type: TYPE_NORMAL
- en: This might be an oversimplification for those of you deeply familiar with compiler
    theory, but for most of us, the analogy holds. Python does some extra work during
    the process by way of caching and optimizing some of the translation so that it
    can be used again. By and large, each run of the program presents a new interpretation.
    Examples of interpreted languages include Python, JavaScript, and Lua.
  prefs: []
  type: TYPE_NORMAL
- en: The last category of code execution involves a middle ground between the other
    two. Languages such as C# and Java use a *compilation* step. Unlike regular compilers,
    the result isn’t a file that runs by itself on the bare metal of your computer.
    Instead, it produces an intermediate format that can be read by a **runtime**.
  prefs: []
  type: TYPE_NORMAL
- en: Think back to when you were in school. A common practice is for a professor
    or teacher to lecture the class and for the class to take notes. A good student
    can reproduce the lecture’s content from the notes. Those notes are an abbreviated
    form of the lecture. In this analogy, the teacher is the programmer and the student
    is the intermediate compiler. The output of the compiler, hopefully, is a stellar
    set of notes that will allow the student to get a good grade on the test. Your
    code files (the lecture) are translated into a compact, binary version of the
    code (your notes). When that intermediate file is executed, a runtime essentially
    “looks at the notes” and enables that code to run on the computer. The upside
    to this method is that the intermediate compilation can run on a variety of platforms
    without having to be recompiled. Programs written in C will run on a variety of
    platforms, ranging from Intel and ARM to old platforms such as mainframes. To
    accomplish this, however, you must recompile the program on that platform. The
    executables only run on the platform that compiles them. In the runtime system,
    the runtime is translated and made to run on different platforms. The intermediate
    compilation then runs on any platform that supports the runtime. You can compile
    once and distribute anywhere.
  prefs: []
  type: TYPE_NORMAL
- en: Python, for our purposes, is an interpreted language, and we need an interpreter.
    Furthermore, PyCharm needs to know a little bit about the interpreter. This chapter
    is all about the means by which you can make introductions. PyCharm, meet interpreter.
    Interpreter, meet PyCharm.
  prefs: []
  type: TYPE_NORMAL
- en: Technical requirements
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In order to proceed through this chapter, and indeed the rest of the book,
    you will need the following:'
  prefs: []
  type: TYPE_NORMAL
- en: An installed and working Python interpreter. I’ll be using the latest from [https://python.org](https://python.org).
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Installed copies of `pip` and `virtualenv`. You get these automatically when
    you install Python on Windows, and macOS has them included on every system. If
    you are using Linux, you need to install package managers, such as `pip`, and
    virtual environment tools, such as `virtualenv`, separately. Our examples will
    use `pip` and `virtualenv`.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: An installed and working copy of PyCharm. Installation was covered in [*Chapter
    2*](B19644_02.xhtml#_idTextAnchor028), *Installation and Configuration*, in case
    you are jumping into the middle of the book.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: This book’s sample source code from GitHub. We covered cloning the code in [*Chapter
    2*](B19644_02.xhtml#_idTextAnchor028), *Installation and Configuration*. You’ll
    find this chapter’s relevant code at [https://github.com/PacktPublishing/Hands-On-Application-Development-with-PyCharm---Second-Edition/tree/main/chapter-03](https://github.com/PacktPublishing/Hands-On-Application-Development-with-PyCharm---Second-Edition/tree/main/chapter-03).
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'There are several flavors of Python. I have used and referenced Python 3 from
    [https://www.python.org](https://www.python.org). Remember—because it is an open
    source project, it is possible to create an alternative version of Python. This
    has been done many times with varying degrees of success. Some of these variants
    include the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '`numpy`, `matplotlib`, and `pandas` included in the installation. The downside
    is the amount of space on your drives consumed by this bigger installation, but
    given the price of storage these days, it is likely not much of a consideration.
    These libraries are probably the most important variant to consider if you intend
    to do data science work.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**IronPython**—This is a variant of Python designed to run in the Microsoft
    .NET runtime. The implications of that are beyond the scope of this book. However,
    IronPython is interesting because, in addition to running in a .NET environment,
    this implementation isn’t hobbled by a **global interpreter lock** (**GIL**).
    GILs prevent efficient multithreading in your code. If you’re not aware of this
    limitation in Python, I’ll leave a link in the *Further reading* section of this
    chapter.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Jython**—This variant allows your Python code to execute within a **Java
    Virtual** **Machine** (**JVM**).'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**MicroPython**—This variant is used to run Python code with microcontrollers
    for use in the **Internet of Things** (**IoT**) and potentially embedded projects.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**ActiveState ActivePython**—This is a commercially supported implementation
    of Python, with special attention paid to Windows compatibility and execution.
    Traditionally, Python was designed with the assumption that it would be running
    in Unix or Linux environments. If you intend to run your Python code in production
    on a Windows server, you might consider this variant.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: You’ll find these documented officially at [https://www.python.org/download/alternatives/](https://www.python.org/download/alternatives/).
    While any of these variants should work in PyCharm, most developers using the
    IDE are working in vanilla Python (the one from [python.org](http://python.org))
    or Anaconda. As you work with virtual environments in Python, you will undoubtedly
    see different options for these alternative implementations. In general, I always
    use the vanilla version of Python 3.
  prefs: []
  type: TYPE_NORMAL
- en: Virtual environments
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We oriented ourselves with respect to project creation in [*Chapter 2*](B19644_02.xhtml#_idTextAnchor028),
    *Installation and Configuration*; however, we glossed over the details around
    creating or setting up a `matplotlib`, only runs in Python 3.6 on your Mac, but
    in Windows, it’s stable at Python 3.9\. While that project is going on, another
    project starts that requires Python 3.10.
  prefs: []
  type: TYPE_NORMAL
- en: If you were strictly working with the global or system-wide installations of
    Python, it would be very hard to switch back and forth between those two projects.
    You would have to futz with environment variables and fix your computer’s `PATH`
    environment variable. Then, you would have to try to remember which third-party
    libraries are installed globally and hope there isn’t a clash between those library
    requirements for the separate projects. Yuck.
  prefs: []
  type: TYPE_NORMAL
- en: Virtual environments allow you to manage these problems easily. While using
    them is purely optional, it is considered a best practice to create a virtual
    environment for every project. Before we dive back into PyCharm, I thought it
    would be fun to create a virtual environment manually. You can skip this if you’d
    like, but if you haven’t done this before, I think it will give you an appreciation
    for some of the work PyCharm takes off your plate at the onset of a new project.
  prefs: []
  type: TYPE_NORMAL
- en: Creating a virtual environment by hand
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Open up your computer’s terminal and find a spot on your drive where you can
    do a little temporary work. We won’t be keeping this for later; we’re just going
    to go through the process. We will then switch to PyCharm so that we can see a
    more automated version of the same workflow.
  prefs: []
  type: TYPE_NORMAL
- en: 'I’m running Windows, and I have a place in my home folder where I keep my projects;
    a folder simply called *Projects*. Having opened my computer’s terminal program,
    which in this case is **Windows Terminal** running **PowerShell**, I can type
    the commands for this experiment. You do not have to use Windows, nor do you have
    to use PowerShell. The normal **zshell** (**zsh**) terminal prompt in macOS or
    the **Bourne Again Shell** (**Bash**) prompt in Linux works the same. Most of
    the commands are identical in all terminals and operating systems. I’ll start
    by creating a new folder, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'This creates a new folder called `python-environment-demo`. Next, I need to
    change directory (`cd`) into it, like so:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: 'Now I’m inside that folder, I’ll create my virtual environment. If you are
    using macOS or Linux, there’s a good chance you have both Python 2 and 3 installed,
    and we want to be sure to make a virtual environment based on Python 3\. In order
    to differentiate, you need to type the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: 'If you’re on Windows, you probably only have Python 3 installed, so the command
    is this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: 'Here, we’re running the `python3` command, and we’re passing a switch (`-m`)
    that will execute the `venv` package to create a new virtual environment based
    on Python 3 within a new folder called `venv`. Once the command finishes, I can
    make sure it worked on Windows with this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: 'Or on macOS/Linux, I can use this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: 'You should see your system’s output. I’m using Windows, so mine appears as
    seen in *Figure 3**.1*:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 3.1: Terminal output checking whether my virtual environment creation
    was successful](img/B19644_03_01.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 3.1: Terminal output checking whether my virtual environment creation
    was successful'
  prefs: []
  type: TYPE_NORMAL
- en: It isn’t necessary for your virtual environment to be in the same folder as
    the rest of your project, but I usually organize things this way to make the virtual
    environment easy to find later.
  prefs: []
  type: TYPE_NORMAL
- en: If I intend to use Git or some other revision control system, it would be appropriate
    for me to have the revision control system ignore this folder. You should *not*
    check this folder into your repository.
  prefs: []
  type: TYPE_NORMAL
- en: 'The final step in working with a virtual environment is to activate it. The
    command is a little different in Windows compared to macOS and Linux. The command
    to activate a virtual environment in Windows is this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: 'While in macOS and Linux, it would be this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: 'If you successfully activated your virtual environment, the prompt should have
    changed to display the name of the virtual environment that is currently active.
    Bear in mind that if you have customized your terminal to prevent this, it might
    not work. You can see in *Figure 3**.2* that everything worked for me, as indicated
    by `(venv)` appearing at the front of my prompt. The top example shows activation
    in Windows 11, while the lower example shows the activation command in Linux,
    which is the same as it would be in macOS:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 3.2: My virtual environment has been activated](img/B19644_03_02.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 3.2: My virtual environment has been activated'
  prefs: []
  type: TYPE_NORMAL
- en: 'When I’m ready to stop working in my virtual environment, I can deactivate
    it by typing the following command in the terminal:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: That was a little bit of work. If you’ve been doing this for a while, it isn’t
    too bad—maybe just a few minutes. However, if you do not do this very often, you
    will have to look everything up, and this may take time. You really only do this
    at the beginning of a new project. Some people might only do this a few times
    per year. Now, let’s go back to PyCharm and see how this step is integrated into
    the new project creation workflow.
  prefs: []
  type: TYPE_NORMAL
- en: Creating a project in PyCharm (revisited)
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'If we go back to PyCharm and create a new pure Python project, you’ll see where
    the process of creating a virtual environment happens. In PyCharm, let’s create
    a new project by clicking **File** | **New Project…**, as seen in *Figure 3**.3*:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 3.3: Creating a new project in PyCharm](img/B19644_03_03.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 3.3: Creating a new project in PyCharm'
  prefs: []
  type: TYPE_NORMAL
- en: 'This will be a pure Python project. The Professional edition is not necessary
    to follow along. The new project dialog is something we saw before in [*Chapter
    2*](B19644_02.xhtml#_idTextAnchor028), *Installation and Configuration*, but this
    time we will focus on some of the details we skipped. *Figure 3**.4* shows the
    Professional edition of PyCharm’s new project window on the left. PyCharm Community
    lacks the project type menu since it can only create “pure Python” projects:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 3.4: A side-by-side comparison of the New Project window for the Professional
    edition (left) and the Community edition (right)](img/B19644_03_04.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 3.4: A side-by-side comparison of the New Project window for the Professional
    edition (left) and the Community edition (right)'
  prefs: []
  type: TYPE_NORMAL
- en: 'The section of the **New Project** dialog I’d like you to focus on is highlighted
    in *Figure 3**.5*. It is this section of the screen that allows you to set up
    your virtual environment. In [*Chapter 2*](B19644_02.xhtml#_idTextAnchor028),
    *Installation and Configuration*, we breezed right past this and just accepted
    the defaults. As it happens, the defaults nearly match the manual process we completed
    in the last section:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 3.5: The virtual environment settings from PyCharm enumerated for
    explanation](img/B19644_03_05.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 3.5: The virtual environment settings from PyCharm enumerated for explanation'
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s consider the numbered labels in *Figure 3**.5*:'
  prefs: []
  type: TYPE_NORMAL
- en: This is the Python interpreter settings section of the **New Project** window.
    You can hide it if you like by twirling the triangle next to the section label,
    though if we did that, we wouldn't be able to continue talking about what comes
    next.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: There are two options at play here. You can either create a new virtual environment
    or point to one you’ve already created. Let’s focus on creating a new one. The
    `virtualenv` virtual environment feature. Changing the mechanism using the dropdown
    will change the contents of the screen to match the settings for the virtual environment
    script you pick. For now, let’s leave it on **Virtualenv** since that is the oldest
    and likely the most widely used.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The `venv` within the folder for the project. You can set the location anywhere
    on your computer; it doesn’t have to be in the project folder. If you have several
    projects that share a virtual environment because they share dependencies, it
    makes sense to create a central location to hold the environment. Most of the
    time, I prefer to keep the virtual environment in the same folder as the project
    so that there is no question as to its location.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The **Base interpreter** field lets you choose which Python installation will
    be used to create the virtual environment. If you have more than one Python installation
    on your computer, PyCharm was probably able to find it automatically. The selection
    is presented as a drop-down list of the locations where PyCharm found a Python
    installation. If it somehow missed one, you can click the ellipsis button (**…**)
    and navigate to the Python installation you’re interested in using. If you do
    this, you need to navigate all the way to the Python executable and double-click
    it.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The **Inherit global site-packages** checkbox deals with any third-party libraries
    you might have installed globally. Checking this box will copy those into your
    virtual environment so that they are available locally in your project.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The **Make available to all projects** checkbox allows you to easily find and
    reuse this virtual environment in other projects.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Using an existing virtual environment
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Sometimes, you need to make a project with the exact same requirements used
    in another project. You can share or reuse a virtual environment easily in PyCharm.
    *Figure 3**.5* shows the **New Project** dialog in PyCharm.
  prefs: []
  type: TYPE_NORMAL
- en: 'To use an existing virtual environment, you’d need to change the default setting
    from **New environment** using to **Previously configured interpreter**, as seen
    in *Figure 3**.6*:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 3.6: You can point your project to an existing virtual environment
    by changing the setting for the project](img/B19644_03_06.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 3.6: You can point your project to an existing virtual environment by
    changing the setting for the project'
  prefs: []
  type: TYPE_NORMAL
- en: Once you do that, your options for selecting an existing environment become
    active. There is a drop-down list available to pick the interpreter. It works
    the same as the **Base interpreter** dropdown we saw earlier when creating a new
    virtual environment. If you created the existing environment in PyCharm, the IDE
    would remember it. In this case, I previously created a virtual environment using
    PyCharm when I created the demo project code for [*Chapter 1*](B19644_01.xhtml#_idTextAnchor014),
    *Introduction to PyCharm – The Most Popular IDE for Python*. PyCharm will remember
    virtual environments created using PyCharm and will offer them in the list.
  prefs: []
  type: TYPE_NORMAL
- en: 'If you used a manual method or some other tool, you’ll need to add the interpreter
    to the list using the **Add Interpreter** button. When you click the button, you’ll
    notice some possibilities, as seen in *Figure 3**.7*:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 3.7: When you click Add Interpreter, you have a myriad of options
    for the origin of the environment you might want to add](img/B19644_03_07.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 3.7: When you click Add Interpreter, you have a myriad of options for
    the origin of the environment you might want to add'
  prefs: []
  type: TYPE_NORMAL
- en: So far, we’re strictly limiting our discussion to adding a virtual environment
    that exists on your local computer. It is possible to add an environment on a
    remote computer, **virtual machine** (**VM**), **Windows Subsystem for Linux**
    (**WSL**, which is a VM), or a **Docker** container. We’re going to talk about
    those options much later in the book.
  prefs: []
  type: TYPE_NORMAL
- en: 'Once you select `bin` folder containing the Python executable. In Windows,
    the virtual environment has a `Scripts` folder that will contain a file that points
    to the Python executable. Your goal in any case is to select the executable:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 3.8: You need to select the Python executable within the virtual environment
    folder you’d like to use](img/B19644_03_08.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 3.8: You need to select the Python executable within the virtual environment
    folder you’d like to use'
  prefs: []
  type: TYPE_NORMAL
- en: Changing the interpreter for a project
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: One trick I employ when I’m working on a project that’s been ongoing for 6 months
    or longer is to create a new virtual environment with fully updated packages.
    This way, I can test the program with updated dependencies without corrupting
    my production-ready virtual environment. We’ll cover package management a little
    later in this chapter. For now, I want to show you where the setting for your
    project’s interpreter exists independently of the project creation process. I
    find this to be a little bit non-intuitive. It’s in **Settings**. The same **Settings**
    option you use to configure the IDE globally across all projects is used to set
    project-specific settings such as the interpreter settings.
  prefs: []
  type: TYPE_NORMAL
- en: 'Regardless of your reason, it is possible to change the interpreter, and by
    extension the virtual environment used in your project. You’ll find the project
    settings by clicking the gear icon in the top-left corner of the UI, as seen in
    *Figure 3**.9*:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 3.9: You’ll find global and project settings by clicking the gear](img/B19644_03_09.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 3.9: You’ll find global and project settings by clicking the gear'
  prefs: []
  type: TYPE_NORMAL
- en: 'Once you select **Settings**, you’ll be taken to the global settings screen
    we studied in [*Chapter 2*](B19644_02.xhtml#_idTextAnchor028), *Installation and
    Configuration*. Project properties are also stored here, as shown in *Figure 3**.10*:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 3.10: The project settings are in the middle of the list](img/B19644_03_10.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 3.10: The project settings are in the middle of the list'
  prefs: []
  type: TYPE_NORMAL
- en: Select the interpreter settings on the left side of the screen and change the
    interpreter using the same mechanism we used when we set the virtual environment
    the first time. You can create a new environment or browse to a new one. Don’t
    forget that when you browse to a new environment, you need to select the Python
    executable and not the folder where the Python installation is located. I forget
    this sometimes, and I’m left wondering why the selection dialog won’t go away.
    It’s looking for a file, which is the Python executable, not a folder.
  prefs: []
  type: TYPE_NORMAL
- en: Activating virtualenv
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In our manual exercise earlier in this chapter, we created a virtual environment
    from scratch using `virtualenv`. Once the environment is created, you must activate
    it in order to use it. An obvious question might be “*How do I activate the environment?*”
    Here’s the beautiful answer: you don’t have to. While you are in the IDE, the
    environment settings are always there and are always honored. When you add new
    third-party packages from the **Python Package Index** (**PyPI**), which we’ll
    cover shortly, they automatically go to the right place per your environment settings.'
  prefs: []
  type: TYPE_NORMAL
- en: When we run our program, we can override the **run configuration**, but by default,
    it uses the project’s environment setting. Frankly, it’s rare that the override
    in the run configuration is useful. With that said, I’ll show you how to override
    the run configuration later in this chapter.
  prefs: []
  type: TYPE_NORMAL
- en: Using the integrated terminal
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Another place to worry about the virtual environment being active is within
    the **terminal**. It’s true PyCharm can’t help you with your system terminal.
    However, PyCharm does have its own terminal window tab. If you use PyCharm’s terminal,
    the project’s interpreter settings are automatically applied. You will not have
    to manually activate anything. Since we are talking about it, let’s look at the
    integrated terminal in PyCharm. You can find the menu item for showing the terminal
    in the **View** menu, as seen in *Figure 3**.11*. Personally, I spend a lot of
    time in the terminal, so I have committed the keyboard shortcut to muscle memory:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 3.11: PyCharm’s integrated terminal can be found buried within the
    View menu](img/B19644_03_11.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 3.11: PyCharm’s integrated terminal can be found buried within the View
    menu'
  prefs: []
  type: TYPE_NORMAL
- en: 'Invoking the menu option brings up the terminal and, as promised, you can see
    in *Figure 3**.12* it honors our project’s virtual environment setting:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 3.12: You can see the terminal comes up with your virtual environment
    already active](img/B19644_03_12.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 3.12: You can see the terminal comes up with your virtual environment
    already active'
  prefs: []
  type: TYPE_NORMAL
- en: 'If the presence of `(venv)` in the prompt isn’t proof enough that it worked,
    I provided more in *Figure 3**.12*. If you use macOS or Linux, you can use the
    `which` command to find the path to any executable. Sorry, Windows users: there
    isn’t an equivalent command on your OS. The result of the `which` command is that
    it shows when I run `python3` it is using the one at the indicated path, rather
    than the system-wide installation, which is usually at `/usr/bin/python3`.'
  prefs: []
  type: TYPE_NORMAL
- en: Working with the REPL in the console window
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'One final tool in PyCharm that might cause you to wonder whether or not your
    environment settings are being honored is the `python3` by itself. PyCharm gives
    you an integrated tool so that you don’t have to. To get to the console, use the
    same menu you used to get to the terminal. I’ve shown it to you in *Figure 3**.13*:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 3.13: The Python console can be invoked via the View menu](img/B19644_03_13.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 3.13: The Python console can be invoked via the View menu'
  prefs: []
  type: TYPE_NORMAL
- en: 'Your console is not only aware of your interpreter settings, but it is also
    aware of the contents of your project. You can import and test anything in your
    project directly in the console. I find this useful when I’m tracking down the
    dreaded “*Module not found? Whaddya mean it’s not found?! It’s right there! I’m
    looking right at it!*” issues we sometimes face. It is also useful for experimenting
    with some of the terser syntax we find in Python, such as **regular expressions**
    (**regexes**) or list comprehensions. There’s a small example in *Figure 3**.14*:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 3.14: The console window in use to test a simple regex](img/B19644_03_14.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 3.14: The console window in use to test a simple regex'
  prefs: []
  type: TYPE_NORMAL
- en: 'The code I’m trying out in *Figure 3**.14* isn’t going to impress anyone in
    my big Python interview with Google:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: I type each line into the console. Remember—this is a live coding view, not
    a file that you execute. Every time I press *Enter*, the expression I just typed
    is evaluated, and the results appear in the debug-like window on the right side
    when appropriate. Think of it like a debugging session where you have a watch
    window on the right, and everything you type in next to the `>>>` prompt becomes
    an instant breakpoint.
  prefs: []
  type: TYPE_NORMAL
- en: Having pressed *Enter* to evaluate the third line, I can see that the `test`
    variable has a `re.Match` object as its value. Stare at the window a little longer,
    and you can see the characters were found at position (0, 5), or characters 0
    through 5 represented in a single tuple (`regs`).
  prefs: []
  type: TYPE_NORMAL
- en: Trying out complicated bits of code in the console saves a little bit of time
    versus the usual process comprised of running the program, reading `print` statements,
    making a change, and trying again, which eats up most of our days as developers.
    Then, you forget to take out the print statements, and you should because they
    can seriously slow down a long-running script.
  prefs: []
  type: TYPE_NORMAL
- en: The console executes everything instantly and feeds the results back to you.
    It is far more detailed than a print statement because you can see the internals
    of any object using the debug-like window, rather than just seeing a string. After
    some tinkering in the console window, you can go back to your code and just use
    what worked.
  prefs: []
  type: TYPE_NORMAL
- en: Working with third-party package libraries
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Python is famous for its “batteries included” philosophy, which is at odds with
    many other languages. Python’s creator, Guido van Rossum, believes a robust and
    complete standard library is important and that the language ought to be able
    to complete nearly any task without using any third-party dependencies.
  prefs: []
  type: TYPE_NORMAL
- en: By third-party dependencies, I mean libraries external to Python designed to
    perform a specialized functionality that is not implemented in Python “out of
    the box.” In other words, Python sets for itself a very lofty goal. It should
    be able to do literally anything all by itself using what is called the Python
    standard library.
  prefs: []
  type: TYPE_NORMAL
- en: Naturally, this goal can never be fully realized. The Python standard library
    is very complete. Eventually, though, you’ll find something the standard library
    either can’t do or the standard library’s implementation isn’t as easy to use
    as it could be. Let’s look at a couple of quick examples of third-party libraries
    that are widely used, and talk about why you might want to use them.
  prefs: []
  type: TYPE_NORMAL
- en: Let’s start with the `requests` library. This is a third-party library you’ll
    find on PyPI at [https://pypi.org/project/requests/](https://pypi.org/project/requests/).
    Every modern language has something similar. JavaScript has the **Node Package
    Manager** (**NPM**) at [https://npmjs.com](https://npmjs.com). **PHP** uses **Composer**
    to install packages from [https://packagist.org/](https://packagist.org/). The
    .NET languages use **NuGet** with packages registered at [https://nuget.org](https://nuget.org).
    Python has [https://pypi.org](https://pypi.org). It is a centralized listing of
    third-party modules and libraries you can add to your project, often free of charge.
    Metaphorically speaking, the idea is to prevent us from having to reinvent the
    wheel every time we want to build a new car. Since I work on a **software-as-a-service**
    (**SaaS**) project as my day job, I find myself needing an easy way to make **Hypertext
    Transfer Protocol** (**HTTP**) requests. The ability for my Python scripts to
    be able to make a call to some web service and process the results is crucial,
    and it is a very common task.
  prefs: []
  type: TYPE_NORMAL
- en: 'Python’s standard library has a few options for accomplishing this. I think
    the most obvious is `urllib` from the standard library. Here is some example code
    from the `urllib2` documentation at [https://docs.python.org/3/howto/urllib2.html](https://docs.python.org/3/howto/urllib2.html):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: First, we import two parts of the `urllib` package, remembering that is really
    `urllib2`. Next, we create a `url` variable. If you’re wondering what the references
    to `cgi` are in the sample, that’s a `cgi-bin` within the address. This style
    of development was supplanted long ago by the likes of **PHP**, classic **Active
    Server Pages** (**ASP**), **Java ServerPages** (**JSP**), and ColdFusion. Even
    those have since evolved into modern systems that use more sophisticated yet easier-to-code
    implementations of routing libraries that are very flexible. We’ll cover these
    later in the book when we talk about the web application development features
    in PyCharm Professional.
  prefs: []
  type: TYPE_NORMAL
- en: Once we have our `url` variable established, we need some data. In this example,
    we are using HTTP `POST` to send data to our web server for processing. This is
    done with the `values` variable, which contains a dictionary that mimics the fields
    and values you might find in a **Hypertext Markup Language** (**HTML**) form.
  prefs: []
  type: TYPE_NORMAL
- en: Once we’ve set that up, we must parse that dictionary into a format suitable
    for transmission. That is done with `urllib.parse.urlencode`. Next, we need to
    further encode the data as **American Standard Code for Information Interchange**
    (**ASCII**). This is another anachronism in the documentation. Modern systems
    use the 8-bit universal text format (UTF-8) since ASCII only encodes letters from
    Romance languages such as English, French, German, Italian, or Portuguese. The
    rest of the world is out of luck. UTF-8 handles every alphabet in common global
    use today; this way, only the ancient Egyptians are snubbed, since UTF-8 doesn’t
    support hieroglyphics —at least, not that I know of.
  prefs: []
  type: TYPE_NORMAL
- en: After we encode the text, we need to create a `request` object. We pass in our
    `url` variable and data to the constructor for `urllib.request.Request`. Only
    then are we ready to send the request in the last two lines of the sample.
  prefs: []
  type: TYPE_NORMAL
- en: 'We’ve established there is a way to make a `POST` request in Python’s standard
    library. So far, though, we’ve only handled a very basic requirement. What if
    I need to present a request that is authenticated? How would I deal with sessions
    or cookies? Could we make this even simpler? We can with the `requests` library.
    Here is some sample code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: Our previous code from `urllib` could be expressed as a one-liner using `requests`!
    More advanced requirements such as sessions, cookies, and so on are equally easy.
    The documentation is modern and contains useful examples. Popular PyPI libraries
    such as `requests` are very well documented, with tutorials on sites such as [https://realpython.com](https://realpython.com).
    I borrowed the preceding sample from [https://realpython.com/python-requests/](https://realpython.com/python-requests/),
    which is part of a large and very complete tutorial on using this powerful library.
  prefs: []
  type: TYPE_NORMAL
- en: The point of all this is to point out that a system of third-party code libraries
    is necessary, or at least useful, in the context of Python—a language that strives
    to include everything you could ever need, but never will. The standard library
    may come close, but it will never include everything I could ever want.
  prefs: []
  type: TYPE_NORMAL
- en: Another important example of necessary third-party libraries is with respect
    to scientific and financial work. The standard math capabilities in Python are
    about the same as you would find in any other language. Most languages are not
    incredibly precise at handling floating-point calculations. They are also not
    very nuanced at handling matrices of numeric data, which represents a common requirement.
    Thankfully, third-party libraries such as `numpy` and `pandas` exist to fill this
    void. These libraries open new possibilities to Python developers and are one
    of the main reasons Python continues to attract new users.
  prefs: []
  type: TYPE_NORMAL
- en: Adding third-party libraries in PyCharm
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'PyCharm includes a UI screen that allows you to manage the packages in your
    current project. However, if an IDE were not in use, you could use a package manager
    to do it manually. For example, to install `numpy` into your project, you could
    use the `pip` package manager with a command such as this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: You should make sure you have activated the virtual environment for the project
    in order for this to work correctly. Otherwise, `numpy` will be installed globally.
    The `pip` installer isn’t the only installer available. There’s `easy_install`,
    `pipenv`, `poetry`, and of course, `conda`. I’m not going to debate the relative
    merits of each since this is a matter of preference. PyCharm supports them all.
  prefs: []
  type: TYPE_NORMAL
- en: PyCharm’s package manager invokes the package manager set in your environment
    settings. It presents a graphical interface where you can search for packages,
    view their descriptions, and install, update, and uninstall any package in your
    project. Let’s take a look.
  prefs: []
  type: TYPE_NORMAL
- en: 'Going back to PyCharm, let’s return to our project settings. Click on **Python
    Interpreter**, as shown in *Figure 3**.15*:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 3.15: The interpreter settings show not only your interpreter but
    also a list of packages available to that interpreter](img/B19644_03_15.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 3.15: The interpreter settings show not only your interpreter but also
    a list of packages available to that interpreter'
  prefs: []
  type: TYPE_NORMAL
- en: The screen shows the interpreter in use for the current project. We saw earlier
    that we can change this environment at any time. Now, we are going to focus on
    the empty package list that takes up most of the screen. This is where you will
    be able to work with packages once we’ve installed them.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s install the `numpy` package. Start by clicking the `numpy`. As you type,
    you will see a list of packages from PyPI that satisfy your search. Click on the
    `numpy` entry and view the description. It is a good idea to scrutinize the description
    since if you misspell your search term, you might wind up with the wrong packages.
    This is definitely the `numpy` library, so I’ll install it by clicking the **Install
    Package** button at the bottom of the dialog. After a short wait, I’ll see a message,
    shown in *Figure 3**.16* (just above the grayed-out **Install Package** button),
    stating the package was successfully installed:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 3.16: The display at the bottom indicates the package was installed
    successfully](img/B19644_03_16.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 3.16: The display at the bottom indicates the package was installed
    successfully'
  prefs: []
  type: TYPE_NORMAL
- en: Go ahead and close the dialog box to go back to the project settings.
  prefs: []
  type: TYPE_NORMAL
- en: Removing third-party libraries in PyCharm
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Next to the `numpy` package, we see a few more buttons near the arrow in *Figure
    3**.17*:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 3.17: Tools for managing your package installations](img/B19644_03_17.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 3.17: Tools for managing your package installations'
  prefs: []
  type: TYPE_NORMAL
- en: You can likely guess what they do. The `pip` can be upgraded to version 23.0.1\.
    Clicking the up arrow will accomplish this. The eye button will show you pre-release
    package versions should you want to try out the bleeding-edge versions of the
    packages.
  prefs: []
  type: TYPE_NORMAL
- en: Now that we understand what the UI for package management does, I’d like to
    digress for a moment and talk about something that it does not do well. The present
    release of PyCharm does not have a good way, in my opinion, to work with a `requirements.txt`
    file.
  prefs: []
  type: TYPE_NORMAL
- en: Using a requirements.txt file
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'A best practice in using Python projects is to use a file named `requirements.txt`
    to list the third-party library dependencies for your project. If you’re starting
    your project from scratch, you can generate a `requirements.txt` file using `pip`
    in your terminal with this command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: '*Figure 3**.18* shows an example of the contents of the `requirements.txt`
    file we just generated. You might have to look hard to see it since it is only
    one line long. You can see the package name as well as the version requirements
    for `numpy==1.24.2`. If you are using a different package manager, review the
    specific process for generating your `requirements.txt` file:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 3.18: The contents of a sample requirements.txt file showing the third-party
    dependencies for our project](img/B19644_03_18.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 3.18: The contents of a sample requirements.txt file showing the third-party
    dependencies for our project'
  prefs: []
  type: TYPE_NORMAL
- en: If you have cloned an existing project and it has a `requirements.txt` file,
    PyCharm will recognize it when you open the project and offer to install the contents
    to your virtual environment. PyCharm will also monitor your project as you work.
    If you add new dependencies, either through the GUI we’ve discussed or manually
    from the terminal, PyCharm will offer to add those dependencies to your `requirements.txt`
    file automatically.
  prefs: []
  type: TYPE_NORMAL
- en: The new Python Packages window
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'New to the latest releases of PyCharm which uses the new UI is a **Python Packages**
    window. It adds similar functionality to the interpreter settings window in a
    different location and layout. Clearly, they were reading over my shoulder when
    I wrote earlier about how the Python environment settings being inside the general
    settings window is unintuitive. I doubt I’ll get credit for pointing it out, though.
    You’ll find the new **Python Packages** window in the **More Tool Windows** ellipsis,
    indicated in *Figure 3**.19*:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 3.19: The More Tools menu contains the new Python Packages window](img/B19644_03_19.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 3.19: The More Tools menu contains the new Python Packages window'
  prefs: []
  type: TYPE_NORMAL
- en: 'When you click the **Python Packages** icon, a new window will appear, as seen
    in *Figure 3**.20*:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 3.20: The new Python Packages window in PyCharm](img/B19644_03_20.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 3.20: The new Python Packages window in PyCharm'
  prefs: []
  type: TYPE_NORMAL
- en: 'As with the **Environment Settings** window, the **Python Packages** window
    shows a list of packages installed in the virtual environment, along with the
    accompanying version number. There is an **Add Package** button that allows you
    to add a package from PyPI or from a repository. You can search for packages using
    the search dialog, which shows a list of matching packages. Clicking one will
    show the documentation for that package. This is a step up from the **Environment
    Settings** window since this one displays the project’s markdown documentation.
    You can see an example in *Figure 3**.21*:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 3.21: Searching for the numpy package in the new Python Package window](img/B19644_03_21.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 3.21: Searching for the numpy package in the new Python Package window'
  prefs: []
  type: TYPE_NORMAL
- en: As you can see, I’ve searched for a package that was found on PyPI with 184
    matches. I’ve selected the `numpy` package, and PyCharm displays the documentation
    for the project. There’s a nice big **Install package** button and a selector
    to pick the version I’d like to install.
  prefs: []
  type: TYPE_NORMAL
- en: 'I can delete an installed package by clicking an installed package in the list.
    The version number is displayed along with the packages’ documentation. Beneath
    the ellipsis next to the installed version number is a **Delete Package** button,
    as seen in *Figure 3**.22*:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 3.22: Deleting a package can be done using the menu option beneath
    the ellipsis next to the version number in the Python Package window](img/B19644_03_22.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 3.22: Deleting a package can be done using the menu option beneath the
    ellipsis next to the version number in the Python Package window'
  prefs: []
  type: TYPE_NORMAL
- en: This feature is so new as I write this that it almost didn’t make it into the
    chapter. I happened to notice it while at work the other day. It presents, in
    my opinion, a less confusing and more convenient way to work with Python packages.
  prefs: []
  type: TYPE_NORMAL
- en: Professional features important to virtual environments
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'One major feature of the Professional edition of PyCharm is the ease of project
    creation compared to the more manual approach. Consider the Professional edition’s
    new project window, which has a set of project types, as seen in *Figure 3**.23*:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 3.23: The Professional edition lists many project templates in the
    New Project dialog](img/B19644_03_23.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 3.23: The Professional edition lists many project templates in the New
    Project dialog'
  prefs: []
  type: TYPE_NORMAL
- en: The Community edition of Python does not have any of these project options.
    You can only create pure Python projects, but to be fair, you can still create
    a Flask project or any of the other project types listed using the Community edition.
    However, the IDE isn’t going to help you do it.
  prefs: []
  type: TYPE_NORMAL
- en: Let’s look at the steps to create a Flask project. Flask is a library that allows
    us to easily create a dynamic web application. We’ll cover it extensively in [*Chapter
    8*](B19644_08.xhtml#_idTextAnchor203), *Building a Dynamic Web Application in
    Flask*. For now, we’re going to compare the level of work needed to do this without
    the Professional edition (that is, with no IDE at all).
  prefs: []
  type: TYPE_NORMAL
- en: 'These are the steps to manually set up the project:'
  prefs: []
  type: TYPE_NORMAL
- en: Create a new folder for your project.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Create a new virtual environment for your project.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Activate the virtual environment.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Use your favorite package manager to install the Flask library along with its
    dependencies.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Create a Python file to hold your starting code.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Research the web and find an example of a simple “Hello world” sample and put
    that in your Python file.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Create a script that can set any necessary environment variables such as `PYTHONPATH`,
    then run your program.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'I’ll bet many of you can do this in about 20-30 minutes, tops. Here’s my problem
    with that: when are you most fired up about your new project idea? It’s at the
    beginning of the project! You are ready to roll but then must stop and spend 30
    minutes doing this tedious setup. It isn’t a lot of time, but it is an interruption.
    There is a chance of hitting some unexpected snags, which can zap your enthusiasm.
    In extreme cases, sometimes, unexpected snags delay you hours or days. PyCharm
    automates the entire process. You step through a couple of dialog screens, usually
    accepting the defaults, and your project is ready in fewer than 30 seconds. You
    can immediately start banging out your idea in code by modifying the starting
    boilerplate generated by the IDE.'
  prefs: []
  type: TYPE_NORMAL
- en: The Professional edition will help you generate more complicated projects with
    very little effort on your part. The IDE will create your folder structure, a
    basic set of files with edit prompts to get started, and a virtual environment.
    PyCharm will even install the requirements for you.
  prefs: []
  type: TYPE_NORMAL
- en: Importing projects into PyCharm
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Perhaps it goes without saying, but I’m going to say it anyway. You can import
    existing projects created either manually or with another IDE into PyCharm. This
    seems obvious because, after all, it is just a matter of opening a folder on your
    computer. The import process really is as simple as opening a folder in PyCharm.
    However, there’s more to the story than that. PyCharm is your intelligent ally
    when it comes to working on getting a project running on your machine that was
    started, or entirely authored, on another without PyCharm involved. Let’s see
    this in action.
  prefs: []
  type: TYPE_NORMAL
- en: 'Within this book’s source code we cloned at the end of [*Chapter 2*](B19644_02.xhtml#_idTextAnchor028),
    *Installation and Configuration*, and within the `chapter-03` folder, there is
    a project that I created entirely from the command line. You can see the process
    I used in *Figure 3**.24*:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 3.24: The terminal window I used to create a Python project entirely
    outside of PyCharm](img/B19644_03_24.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 3.24: The terminal window I used to create a Python project entirely
    outside of PyCharm'
  prefs: []
  type: TYPE_NORMAL
- en: 'The process I followed is clearly shown, as described here:'
  prefs: []
  type: TYPE_NORMAL
- en: Within a new project folder called `manually-created`, I created a new virtual
    environment with the `python3 -m venv` `venv` command.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: I activated the virtual environment with the `source venv/bin/activate` command.
    In this case, I am working in Linux. This same command will work on a Mac. If
    I were using Windows, it would be `.\venv\Scripts\activate`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Next, I installed a third-party module called `tqdm`. You can find out more
    at [https://pypi.org/project/tqdm/](https://pypi.org/project/tqdm/). The short
    version of this module is used to easily format the terminal output of a program
    to include a nice-looking progress bar. You can see the blocky progress bar a
    little further down in *Figure 3**.24* after I run the program. I’m getting ahead
    of myself.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: I used `nano` to add some code to a new file called `main.py`. I’ll show you
    the contents in a moment, but all I did was copy and paste an example from the
    `tqdm` documentation on the [https://pypi.org](https://pypi.org) page I linked
    earlier. If you’re wondering what the `-l` switch does, it displays line numbers
    in the `nano` editor, which makes `nano` a quick, easy-to-use code editor.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: I ran the program using the `python` `main.py` command.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Having verified that it all worked, I created a `requirements.txt` file to
    document my program’s dependence on the `tqdm` module. The `pip freeze` command
    will output a dependency graph to the screen. In order to turn that into a text
    file I can include in my Git repository, I piped the output with `> requirements.txt`,
    making the full command look like this:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: This kind of command-line setup work is beneath us. In fact, I recommend you
    celebrate this by buying yourself a new pair of cargo pants and carrying yourself
    with a new air of swagger! If you identify as a non-cargo-pants-wearing sentient
    being, I hope you’ll use your imagination to translate my intent. On second thoughts,
    at the risk of generalizing, you probably should take neither wardrobe nor social
    behavior advice from me. Traditionally, *wardrobe advice* is not my *strong suit*.
  prefs: []
  type: TYPE_NORMAL
- en: Warning
  prefs: []
  type: TYPE_NORMAL
- en: If this is the first of my books you are reading, one ground rule I keep is
    that all puns are intended.
  prefs: []
  type: TYPE_NORMAL
- en: 'Thankfully, working with projects created outside of PyCharm is a strong suit
    of PyCharm. Since the project has already been created outside of PyCharm, let’s
    see what PyCharm makes of it. Let’s open the `chapter-03/manually-created` folder
    in PyCharm. To make things crystal clear, I’m showing you the project’s open dialog
    in *Figure 3**.25*:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 3.25: Opening the manually-created project that was created outside
    of PyCharm](img/B19644_03_25.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 3.25: Opening the manually-created project that was created outside
    of PyCharm'
  prefs: []
  type: TYPE_NORMAL
- en: For this project, I did something I would not usually do. The virtual environment
    (`venv`) folder is included in the git repository. Normally, it shouldn’t be,
    but it needs to be there for you to see the next little bit of magic.
  prefs: []
  type: TYPE_NORMAL
- en: 'Open the project folder and watch what happens. If you’re looking for a big
    display of software-empowered awesomeness, it might seem a little underwhelming.
    It isn’t even worthy of a screenshot. The project opened, and it’s just sitting
    there. That’s the cool part. PyCharm can see your virtual environment folder,
    so it automatically sets up your project for you. You can verify all this in your
    project settings, as seen in *Figure 3**.26*:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 3.26: The imported project has the correct interpreter settings with
    no effort on our part](img/B19644_03_26.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 3.26: The imported project has the correct interpreter settings with
    no effort on our part'
  prefs: []
  type: TYPE_NORMAL
- en: Importing a project cloned from a repository
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Our previous example showed importing a project I created manually on my computer.
    It is more likely you will import a project you’ve cloned from GitHub or some
    other repository. These projects when cloned will not have the virtual environment
    folder present. As such, you have to do a little more work to set up the project.
  prefs: []
  type: TYPE_NORMAL
- en: I’m going to reuse the same project, but I’m going to delete a few files so
    that PyCharm won’t remember anything about the project.
  prefs: []
  type: TYPE_NORMAL
- en: 'First, close the project in PyCharm, as seen in *Figure 3**.27*:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 3.27: Closing the project](img/B19644_03_27.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 3.27: Closing the project'
  prefs: []
  type: TYPE_NORMAL
- en: 'Next, use your operating system to delete the folders shown in *Figure 3**.28*:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 3.28: Deleting the venv and .idea folders to simulate a project you
    might have cloned from a version control system (VCS)](img/B19644_03_28.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 3.28: Deleting the venv and .idea folders to simulate a project you
    might have cloned from a version control system (VCS)'
  prefs: []
  type: TYPE_NORMAL
- en: 'We are getting rid of the `venv` folder and the `.idea` folder. The latter
    will be hidden on macOS and Linux systems, so make sure you turn on the ability
    to view hidden folders. The `.idea` folder is the PyCharm project folder, which
    was automatically created when you opened the project folder. With those two folders
    gone, PyCharm is now virtually ignorant of having ever opened the project. The
    folder will still show up in your **Recent** projects folder, but that is OK.
    Open the folder again with PyCharm. The result of opening the project in PyCharm
    is shown in *Figure 3**.29*:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 3.29: Importing a project created outside of PyCharm prompts to create
    a virtual environment](img/B19644_03_29.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 3.29: Importing a project created outside of PyCharm prompts to create
    a virtual environment'
  prefs: []
  type: TYPE_NORMAL
- en: PyCharm sees the `requirements.txt` file but it can’t find a suitable virtual
    environment because there isn’t a subfolder in the project containing a Python
    executable. PyCharm will prompt you to create an environment for your project.
    In my case, the default is to a local folder called `venv`. It is going to use
    the Python 3.10 executable it found at `/usr/bin/python3.10` as the base for the
    virtual environment, and it sees the `requirements.txt` file. If I hit **OK**,
    PyCharm will set up a virtual environment and then install my dependencies for
    me.
  prefs: []
  type: TYPE_NORMAL
- en: Dealing with invalid interpreters
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'No IDE is perfect. Sometimes, PyCharm can get confused about which virtual
    environment to use. This really only happens when you set up a new project with
    code not created in PyCharm. This is a corner case, but sooner or later, you’re
    going to see it, so I want to spend a minute talking about this scenario. Maybe
    you’re preparing to write a book on PyCharm. OK—that probably mostly happens to
    me. Say you’re preparing a demo. Maybe you are setting up a training session and
    you’ve fiddled around with things a little too much or a few too many times. If
    you are like me, you like things to be perfect. You’ve worked toward setting up
    a project, and you see listings for invalid environments such as the one in *Figure
    3**.30*:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 3.30: Invalid interpreter errors happen to the best of us](img/B19644_03_30.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 3.30: Invalid interpreter errors happen to the best of us'
  prefs: []
  type: TYPE_NORMAL
- en: Gross! There’s an ugly red message saying the base interpreter is invalid. We
    need to fix this. The good news is you know what to do! First, let’s solve your
    immediate problem. You need to set the base interpreter so that PyCharm can finish
    importing your project. The first thing to try is the drop-down list for the base
    interpreter. In all likelihood, your global Python installation will appear in
    the list. If it does, pick it then click **OK**, and PyCharm will do its thing.
  prefs: []
  type: TYPE_NORMAL
- en: If you can’t find one, you can still make a valid environment. You just need
    to create a virtual environment the same way we did when we were creating our
    project from scratch. You’d need to cancel out of the dialog you’re seeing in
    *Figure 3**.32* and use the project settings to add a new environment.
  prefs: []
  type: TYPE_NORMAL
- en: 'Click **File** | **Settings** to get into the **Settings** dialog and find
    the project settings, as shown in *Figure 3**.31*:'
  prefs: []
  type: TYPE_NORMAL
- en: "![Figure 3.31: The worst-case scenario\uFEFF (it doesn’t happen often, but\
    \ it does happen\uFEFF)](img/B19644_03_31.jpg)"
  prefs: []
  type: TYPE_IMG
- en: 'Figure 3.31: The worst-case scenario (it doesn’t happen often, but it does
    happen)'
  prefs: []
  type: TYPE_NORMAL
- en: This is the worst-case scenario! The list doesn’t show the base interpreter,
    and the only option is our invalid virtual environment. Admittedly, you must work
    hard to get PyCharm to do this, but this usually happens exactly 5 minutes before
    you need PyCharm to work in front of a lot of people. I’m here for you.
  prefs: []
  type: TYPE_NORMAL
- en: 'At the bottom of the drop-down list is the **Show All…** option. This will
    allow us to fix everything! Click it! You’ll see a very useful dialog, shown in
    *Figure 3**.32*:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 3.32: The Python interpreters dialog allows you to manage all your
    Python environments in one place](img/B19644_03_32.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 3.32: The Python interpreters dialog allows you to manage all your Python
    environments in one place'
  prefs: []
  type: TYPE_NORMAL
- en: Note the arrow in *Figure 3**.32*. You can use the **+** and **–** icons to
    add and remove environments. You can select your invalid environment and remove
    it with the **–** icon. Next, you can add a new, valid environment with the **+**
    icon. The workflow for adding a new interpreter is the same as it was when we
    created one from scratch with a new project. We’ve covered the process already,
    so I won’t go through it again.
  prefs: []
  type: TYPE_NORMAL
- en: Working with run configurations
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Run configurations in PyCharm allow you to set up different ways to run your
    programs from the IDE. The heart of the run configurations is a cluster of blue
    buttons toward the top of the main window. Follow the arrow in *Figure 3**.33*:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 3.33: There are several run buttons at the top of the screen along
    with a drop-down list that allows you to work with various run configurations](img/B19644_03_33.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 3.33: There are several run buttons at the top of the screen along with
    a drop-down list that allows you to work with various run configurations'
  prefs: []
  type: TYPE_NORMAL
- en: Since we have the `manually-created` project already open from earlier, why
    don’t we continue exploring using that project? That cluster of buttons I pointed
    to in *Figure 3**.33* consists of a **Run** button, a **Debug** button, and a
    dropdown that lets you set and manage your run configurations. When we imported
    the project, it generated a run configuration called **Current File**.
  prefs: []
  type: TYPE_NORMAL
- en: 'With this set in the drop-down menu, the file in the **Focused** tab will be
    executed when you click either the run or debug button:'
  prefs: []
  type: TYPE_NORMAL
- en: This is the regular `main.py` script because that is in the currently focused
    tab.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: This is the **Run** (debug) button. Clicking this will run your selected run
    configuration with an attached debugger. We’ll see this in action in [*Chapter
    6*](B19644_06.xhtml#_idTextAnchor145), *Seamless Testing, Debugging,* *and Profiling*.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The ellipsis button contains more options for running a profiler and checking
    your test coverage. We’ll cover these in later chapters.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The **Run configuration** dropdown lets you select a run configuration. There
    is an option to create and edit existing configurations as well as create new
    ones.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: For now, let’s focus on the run configurations themselves since these have their
    own environment settings independent from the rest of the project.
  prefs: []
  type: TYPE_NORMAL
- en: 'Click the drop-down menu where it says **Current File** and click **Edit Configurations…**,
    as shown in *Figure 3**.34*. This brings up a dialog for managing your run configurations.
    You can add, edit, and delete your configurations here. Note the Professional
    edition will have more tooling available in this window than will the Community
    edition. I will focus on the Professional edition:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 3.34: Adding a new run configuration for our manually-created project](img/B19644_03_34.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 3.34: Adding a new run configuration for our manually-created project'
  prefs: []
  type: TYPE_NORMAL
- en: 'There are plenty of prompts in the dialog that allow you to create a new run
    configuration. Let’s ignore those because once you add one, those options will
    go away. Click the **+** icon at the top of the dialog, as shown in *Figure 3**.35*:'
  prefs: []
  type: TYPE_NORMAL
- en: "![Figure 3.35: Clicking the + button to add a new run configuration\uFEFF (the\
    \ list shown is for the Professional edition, and you’ll need to scroll down to\
    \ find the Python item shown\uFEFF)](img/B19644_03_35.jpg)"
  prefs: []
  type: TYPE_IMG
- en: 'Figure 3.35: Clicking the + button to add a new run configuration (the list
    shown is for the Professional edition, and you’ll need to scroll down to find
    the Python item shown)'
  prefs: []
  type: TYPE_NORMAL
- en: If you are running the Professional edition, you’ll see a long list of options,
    as in *Figure 3**.35*. The Community edition list is considerably shorter since
    it only has tooling for pure Python projects.
  prefs: []
  type: TYPE_NORMAL
- en: 'I’m going to pick the Pure Python project type since that’s one we can all
    use. Each option may present a different dialog box with different settings based
    on what is appropriate for your selection. The Pure Python options look like what
    is shown in *Figure 3**.36*:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 3.36: The options for a run configuration using the Pure Python template](img/B19644_03_36.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 3.36: The options for a run configuration using the Pure Python template'
  prefs: []
  type: TYPE_NORMAL
- en: 'There are a lot of settings here. Let’s review the most important settings
    by the numbers provided in *Figure 3**.36*:'
  prefs: []
  type: TYPE_NORMAL
- en: You should give the run configuration a name. If you don’t, it will default
    to the name of the script. You can use a human-friendly name here; it doesn’t
    have to relate to the running file in any way.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: This setting is probably the most obvious. It lets you select the script you’d
    like to run. You can browse to it or type the path. You can also change this from
    a script file to a module name by clicking the triangle next to the script path
    text entry box. If you change the setting to run a module, the folder **Browse**
    button will change to an ellipsis, and you’ll be able to browse the modules in
    your program to find the one you’d like to run.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The `argparse`, you can pass them here. This textbox is fairly interactive.
    Note the **+** icon. Clicking this allows you to invoke some macros available
    in the tool. For example, if you need the path for the current directory, you’ll
    find an option for that in the macro list.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'These are the environment settings. The default uses the project settings.
    You can set a different virtual environment for your run configurations than for
    your project if you need to test-run your software in different environments.
    You can also set environment variables here without jumping out to your operating
    system. This is handy if you rely on environment variables for your program settings.
    If you use OS-level environment variables for sensitive data such as passwords
    or connection strings, I recommend against setting them here. These settings can
    wind up in the project configuration files, which means they could make it into
    your source repository. There’s nothing worse than realizing your hackathon project
    files contain your personal password or access tokens for your favorite cloud
    provider. `SuperH4xr1337@some-evil-hacker-org.darkweb.net` (*note*: hopefully
    not a real address) loves it when you do this. There are bots that troll GitHub
    looking for this stuff, so be careful. Personally, I use configuration files for
    this using one of the many `env` libraries. I’ll put a link in the *Further reading*
    section if you’re interested in this.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: You can set a working directory should any part of your script rely on relative
    file paths.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: This checkbox controls whether the content roots from your project are injected
    into the `PYTHONPATH` environment variable when you run your program. The `PYTHONPATH`
    environment variable controls where the Python interpreter searches for modules.
    Content roots refer to project structure settings where you define content folders.
    This is generally only used with web projects. A content folder might contain
    images or other static content. The `PYTHONPATH` environment variable. I’ve worked
    on microservice architecture projects where this was useful. Sometimes, you might
    have a module in another project that you need to leverage, but it belongs in
    its own separate project rather than being directly managed in the current project.
    You can set your source roots to include other projects with dependencies, and
    checking this box will make those available to your running program.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: As you can see, there are a lot of options and ways you can customize the way
    a program is run using PyCharm. If your application has several executable scripts,
    you can set each one up with its own run configuration.
  prefs: []
  type: TYPE_NORMAL
- en: PyCharm’s project files
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Most IDEs have some sort of project file designed to contain project-level settings.
    If you’ve ever used any of Microsoft’s IDEs, you might remember folders such as
    `.vscode` for Visual Studio Code and `.vs` in a Visual Studio project. Java IDEs
    such as NetBeans and Eclipse also use a set of files to contain their project
    settings. PyCharm too has a set of files stored in a folder within each project,
    called `.idea`. This might seem like a strange name until you remember that JetBrains
    began with only one IDE project, IntelliJ IDEA. IntelliJ IDEA garnered a reputation
    for being the best IDE for Java development, bar none. It is so good that Google
    contracted with JetBrains to create Android Studio; a natural fit given Android
    applications are written entirely in Java. All the IDEs from JetBrains have the
    same lineage. They are all descendants of IntelliJ IDEA, and that’s why the project
    folder is called `.idea`. Remember—Windows users will plainly see this folder,
    while on Linux and Mac, any folder name beginning with a dot (`.`) is hidden.
  prefs: []
  type: TYPE_NORMAL
- en: By default, there isn’t anything particularly interesting inside these folders
    should you ever be tempted to try to edit them. In fact, if you were to delete
    them, PyCharm would simply recreate them when you reopen the project.
  prefs: []
  type: TYPE_NORMAL
- en: 'That said, there are options in PyCharm that let you store your run configurations
    within these files, as shown in *Figure 3**.37*:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 3.37: You can opt to store run configurations as part of the project
    files in the .idea folder](img/B19644_03_37.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 3.37: You can opt to store run configurations as part of the project
    files in the .idea folder'
  prefs: []
  type: TYPE_NORMAL
- en: If you opt to do this, you have the capability to check the `.idea` files into
    your VCS repository and share them with your team. This means everybody will have
    the same configurations, so you might want to have a meeting and standardize your
    project structure so that you’re not stepping on each other.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: This chapter was all about setting up your virtual environment for a Python
    project. Each project typically has its own virtual environment. We use virtual
    environments to insulate our projects from the requirements of other projects
    and to keep our global Python installation from becoming polluted with lots of
    global packages that were used for only one project.
  prefs: []
  type: TYPE_NORMAL
- en: A virtual environment is a copy of a Python interpreter along with all supporting
    tools such as a package manager and third-party libraries needed for your project.
    PyCharm has features built in for creating and managing virtual environments.
  prefs: []
  type: TYPE_NORMAL
- en: We first see these tools during the creation of a new project. PyCharm prompts
    us to create a new virtual environment every time. We can also select an existing
    environment if that is appropriate. PyCharm gives us the ability to change the
    virtual environment for the project at any time.
  prefs: []
  type: TYPE_NORMAL
- en: Our virtual environments also house all the third-party libraries needed for
    our project. You can find thousands of ready-made modules at [https://pypi.org](https://pypi.org).
    These modules can be installed and used in your projects by means of a package
    manager. The most common package manager is `pip`, but others exist, such as `conda`,
    `pipenv`, and `poetry`. PyCharm supports all of these tools, and you are afforded
    the opportunity to select your tool of choice when you create your virtual environment.
  prefs: []
  type: TYPE_NORMAL
- en: Having selected your package manager, PyCharm has a GUI that allows you to see,
    add, remove, and update your library dependencies from PyPI. You’ll find this
    GUI within your project settings, which are bundled inside the general settings
    for PyCharm itself.
  prefs: []
  type: TYPE_NORMAL
- en: PyCharm can easily import projects created outside of PyCharm. All you need
    to do is open the folder where the code resides. PyCharm creates a set of project
    files within that folder called `.idea`, then prompts you to set an interpreter
    if it couldn’t find one within the project folder. PyCharm will also look for
    a `requirements.txt` file and offer to install your dependencies for you.
  prefs: []
  type: TYPE_NORMAL
- en: When you are ready to run some code within the IDE, PyCharm offers a powerful
    run system that uses run configurations created in the GUI. PyCharm Professional
    ships with many project types, and each one has its own run configuration settings.
    We covered the extensive settings found in a pure Python project since that is
    available to Community edition users. The run configuration can manage—and in
    some cases mimic—a wide gamut of settings you would normally have to set manually
    at the operating system level.
  prefs: []
  type: TYPE_NORMAL
- en: All totaled, PyCharm gives you a very complete set of tools for managing virtual
    environments for development and running your code. In the next chapter, we’ll
    switch our focus to the primary tools you’ll use every day to manage, write, and
    edit your code.
  prefs: []
  type: TYPE_NORMAL
- en: Questions
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: What are virtual environments and why are they important?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: What are the tools used by the Python community to create virtual environments?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Which virtual environment tools are supported in PyCharm?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Can a run configuration use a different virtual environment from the main project?
    How might this be useful?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Where does PyCharm keep its project configuration files?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Further reading
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '*Alternative Python* *Implementations*: [https://www.python.org/download/alternatives/](https://www.python.org/download/alternatives/)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`The env` library: [https://pypi.org/project/env/](https://pypi.org/project/env/)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*Ajitsaria*, *A.* *What is the Python Global Interpreter Lock (**GIL)?*: [https://realpython.com/python-gil/](https://realpython.com/python-gil/)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Be sure to check out the companion website for the book at [https://www.pycharm-book.com.](https://www.pycharm-book.com.)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
