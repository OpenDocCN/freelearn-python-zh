- en: '3'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '3'
- en: Customizing Interpreters and Virtual Environments
  id: totrans-1
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 自定义解释器和虚拟环境
- en: The last chapter focused on configuration options. Configuration options are
    designed to help you customize your working environment to fit the project and
    also allow for customization to fit your personal tastes. These options are one
    of the many reasons that PyCharm is a great tool. Another great feature that makes
    PyCharm useful is the customization of interpreters and virtual environments.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 上一章重点介绍了配置选项。配置选项旨在帮助您根据项目定制工作环境，同时也允许根据个人喜好进行定制。这些选项是PyCharm成为一款优秀工具的许多原因之一。PyCharm的另一个优秀特性是解释器和虚拟环境的定制。
- en: 'This chapter will cover the following topics:'
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 本章将涵盖以下主题：
- en: The importance of working with virtual environments in Python
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在Python中使用虚拟环境的重要性
- en: How to create a virtual environment manually using `virtualenv`
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如何使用`virtualenv`手动创建虚拟环境
- en: How to create a virtual environment using PyCharm
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如何使用PyCharm创建虚拟环境
- en: How to work with an existing virtual environment in PyCharm
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如何在PyCharm中处理现有的虚拟环境
- en: How to add and remove third-party libraries using PyCharm
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如何使用PyCharm添加和删除第三方库
- en: How to import projects created outside PyCharm
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如何导入PyCharm外创建的项目
- en: How to work with virtual environment settings within run configurations
  id: totrans-10
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如何在运行配置中处理虚拟环境设置
- en: At this point, many of you will have at least one installation of a Python interpreter
    installed. It either came with your system, as is the case with macOS or Linux,
    or you installed it, as is the case with Windows. Python is an **interpreted language**—this
    means the written code is not truly evaluated until it is run. Let’s take a moment
    to describe what this means by comparing Python to a few other languages and how
    they are executed.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，你们中的许多人至少安装了一个Python解释器。它可能随系统一起提供，例如在macOS或Linux中，或者你自己在Windows上安装了它。Python是一种**解释型语言**——这意味着编写的代码只有在运行时才会真正被评估。让我们花一点时间来描述这意味着什么，通过将Python与其他一些语言进行比较，以及它们是如何执行的。
- en: 'There are three common ways to execute written code on your computer, as follows:'
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 在你的计算机上执行编写好的代码有三种常见方式，如下所示：
- en: Compilation
  id: totrans-13
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 编译
- en: Interpretation
  id: totrans-14
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 解释
- en: Intermediate compilation with a runtime
  id: totrans-15
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 带运行时的中间编译
- en: Before we dig into these, let’s take a short trip back through time. I know
    it is history but stick with me. In the year 1522, the predominant religion throughout
    most of Western Europe was Roman Catholicism. This was a time of great turmoil
    in that church’s history, but we will put that aside for a moment. Instead, we
    will focus on a German priest named Martin Luther. In those days, the German people
    were completely reliant on the clerical establishment for their spiritual needs.
    The Bible, in 1522, was only available in Greek and Latin. Luther, who was imprisoned
    at the time, translated the Old Testament from Greek into the German Vulgate.
    This was a game changer for the Germans. Printers of the day snatched it up and
    printed hundreds of copies so that every family could read it. I’m going to use
    this as an analogy.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们深入探讨这些之前，让我们短暂地回顾一下历史。我知道这是历史，但请跟我来。在1522年，整个西欧占主导地位的宗教是罗马天主教。这是该教会历史上动荡不安的时期，但我们将暂时将其放在一边。相反，我们将关注一位名叫马丁·路德的德国牧师。在当时，德国人民完全依赖于教会机构来满足他们的精神需求。在1522年，《圣经》只提供希腊语和拉丁语版本。当时被监禁的路德将旧约从希腊语翻译成了德语的通俗拉丁语。这对德国人来说是一个转折点。当时的印刷商抢购了它，并印刷了数百份，以便每个家庭都能阅读。我将用它做一个类比。
- en: 'The first method of executing written code is *compilation*. This is similar
    to Martin Luther’s translation from Greek into German. Most people who cannot
    code will see a programming language and scratch their heads and think to themselves:
    “This is Greek to me!” The same thing is happening with computers because the
    computer can’t understand your code language either. Computers don’t “speak” C
    or C++ or Java. Instead, a programmer has written something in a language that
    is simple and easy to translate as compared to human language. Compilation refers
    to a process where your textual code files are translated once into a binary format
    that is understood by the computer. Examples of compiled languages include C and
    C++. The code files are run through a compiler, which translates the code into
    a separate and new format only one time. The process produces a new file, separate
    from the code, which is useful only to the computer. To finalize our analogy,
    after translating Greek into German, the printed books became the result of the
    compilation step. The ability to read the Bible was useful to the Germans.'
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 执行书面代码的第一种方法是*编译*。这类似于马丁·路德将希腊语翻译成德语的过程。大多数无法编写代码的人看到编程语言时会挠头，心想：“对我来说这是希腊语！”同样的事情也发生在计算机上，因为计算机也无法理解你的代码语言。计算机不会说C或C++或Java。相反，程序员用一种与人类语言相比简单且易于翻译的语言编写了某些内容。编译指的是将你的文本代码文件翻译成一次性的二进制格式，这种格式是计算机可以理解的。编译语言的例子包括C和C++。代码文件会通过编译器运行，编译器将代码翻译成一种新的格式，只进行一次。这个过程产生了一个新文件，与代码分开，对计算机来说是有用的。为了完成我们的类比，在将希腊语翻译成德语之后，印刷的书籍就是编译步骤的结果。阅读圣经的能力对德国人来说是有用的。
- en: 'Contrast that with the second form of code execution: the *interpreted language*.
    Prior to Luther’s translation, the Bible was translated on the fly in church.
    A priest would open the Bible and translate the text into German as he read it
    aloud. This is what happens with interpreted languages, including Python. The
    `python main.py`, the Python interpreter opens the code file, reads the code,
    translates (compiles) that code, and executes the instructions as it reads them
    line by line.'
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 与第二种代码执行形式相对比的是*解释型语言*。在路德翻译之前，圣经在教堂中被即时翻译。牧师打开圣经，在朗读的同时将文本翻译成德语。这就是解释型语言，包括Python的工作方式。当你运行`python
    main.py`时，Python解释器会打开代码文件，读取代码，将其翻译（编译），并在逐行读取的同时执行指令。
- en: This might be an oversimplification for those of you deeply familiar with compiler
    theory, but for most of us, the analogy holds. Python does some extra work during
    the process by way of caching and optimizing some of the translation so that it
    can be used again. By and large, each run of the program presents a new interpretation.
    Examples of interpreted languages include Python, JavaScript, and Lua.
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 对于那些对编译理论非常熟悉的人来说，这可能是一种过于简化的说法，但对于我们大多数人来说，这个类比是成立的。Python在过程中通过缓存和优化一些翻译工作，以便可以再次使用。总的来说，每次程序运行都呈现一个新的解释。解释型语言的例子包括Python、JavaScript和Lua。
- en: The last category of code execution involves a middle ground between the other
    two. Languages such as C# and Java use a *compilation* step. Unlike regular compilers,
    the result isn’t a file that runs by itself on the bare metal of your computer.
    Instead, it produces an intermediate format that can be read by a **runtime**.
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 最后一种代码执行类别介于其他两种之间。例如C#和Java这样的语言使用*编译*步骤。与常规编译器不同，结果并不是一个可以在电脑裸机上独立运行的文件。相反，它产生了一种中间格式，可以被**运行时**读取。
- en: Think back to when you were in school. A common practice is for a professor
    or teacher to lecture the class and for the class to take notes. A good student
    can reproduce the lecture’s content from the notes. Those notes are an abbreviated
    form of the lecture. In this analogy, the teacher is the programmer and the student
    is the intermediate compiler. The output of the compiler, hopefully, is a stellar
    set of notes that will allow the student to get a good grade on the test. Your
    code files (the lecture) are translated into a compact, binary version of the
    code (your notes). When that intermediate file is executed, a runtime essentially
    “looks at the notes” and enables that code to run on the computer. The upside
    to this method is that the intermediate compilation can run on a variety of platforms
    without having to be recompiled. Programs written in C will run on a variety of
    platforms, ranging from Intel and ARM to old platforms such as mainframes. To
    accomplish this, however, you must recompile the program on that platform. The
    executables only run on the platform that compiles them. In the runtime system,
    the runtime is translated and made to run on different platforms. The intermediate
    compilation then runs on any platform that supports the runtime. You can compile
    once and distribute anywhere.
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 回想一下你在学校的时候。一个常见的做法是教授或老师向全班授课，而学生们做笔记。一个好的学生可以从笔记中复述讲座的内容。这些笔记是讲座的简略形式。在这个类比中，老师是程序员，学生是中间编译器。编译器的输出，希望是一套出色的笔记，这将使学生能够在考试中取得好成绩。你的代码文件（讲座）被转换成代码的紧凑、二进制版本（你的笔记）。当这个中间文件执行时，运行时基本上“查看笔记”，并使代码能够在计算机上运行。这种方法的好处是中间编译可以在各种平台上运行，而无需重新编译。用C语言编写的程序可以在各种平台上运行，从英特尔和ARM到旧平台如大型机。然而，为了实现这一点，你必须在该平台上重新编译程序。可执行文件只能在编译它们的平台上运行。在运行时系统中，运行时被转换并使其能够在不同的平台上运行。中间编译随后在任何支持运行时的平台上运行。你可以编译一次，然后分发到任何地方。
- en: Python, for our purposes, is an interpreted language, and we need an interpreter.
    Furthermore, PyCharm needs to know a little bit about the interpreter. This chapter
    is all about the means by which you can make introductions. PyCharm, meet interpreter.
    Interpreter, meet PyCharm.
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 对于我们的目的，Python是一种解释型语言，我们需要一个解释器。此外，PyCharm需要了解一些关于解释器的情况。本章全部关于你如何进行介绍的方法。PyCharm，认识解释器。解释器，认识PyCharm。
- en: Technical requirements
  id: totrans-23
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 技术要求
- en: 'In order to proceed through this chapter, and indeed the rest of the book,
    you will need the following:'
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 为了继续阅读本章，以及本书的其余部分，你需要以下内容：
- en: An installed and working Python interpreter. I’ll be using the latest from [https://python.org](https://python.org).
  id: totrans-25
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 安装并运行良好的Python解释器。我将使用来自[https://python.org](https://python.org)的最新版本。
- en: Installed copies of `pip` and `virtualenv`. You get these automatically when
    you install Python on Windows, and macOS has them included on every system. If
    you are using Linux, you need to install package managers, such as `pip`, and
    virtual environment tools, such as `virtualenv`, separately. Our examples will
    use `pip` and `virtualenv`.
  id: totrans-26
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 安装了`pip`和`virtualenv`。当你在Windows上安装Python时，这些会自动安装，macOS系统上默认包含它们。如果你使用Linux，你需要单独安装包管理器，如`pip`，以及虚拟环境工具，如`virtualenv`。我们的示例将使用`pip`和`virtualenv`。
- en: An installed and working copy of PyCharm. Installation was covered in [*Chapter
    2*](B19644_02.xhtml#_idTextAnchor028), *Installation and Configuration*, in case
    you are jumping into the middle of the book.
  id: totrans-27
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 安装并运行良好的PyCharm副本。安装过程在[*第二章*](B19644_02.xhtml#_idTextAnchor028)，“安装和配置”中已有介绍，以防你在书中间开始阅读。
- en: This book’s sample source code from GitHub. We covered cloning the code in [*Chapter
    2*](B19644_02.xhtml#_idTextAnchor028), *Installation and Configuration*. You’ll
    find this chapter’s relevant code at [https://github.com/PacktPublishing/Hands-On-Application-Development-with-PyCharm---Second-Edition/tree/main/chapter-03](https://github.com/PacktPublishing/Hands-On-Application-Development-with-PyCharm---Second-Edition/tree/main/chapter-03).
  id: totrans-28
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 本书从GitHub提供的示例源代码。我们在[*第二章*](B19644_02.xhtml#_idTextAnchor028)，“安装和配置”中介绍了如何克隆代码。你可以在[https://github.com/PacktPublishing/Hands-On-Application-Development-with-PyCharm---Second-Edition/tree/main/chapter-03](https://github.com/PacktPublishing/Hands-On-Application-Development-with-PyCharm---Second-Edition/tree/main/chapter-03)找到本章的相关代码。
- en: 'There are several flavors of Python. I have used and referenced Python 3 from
    [https://www.python.org](https://www.python.org). Remember—because it is an open
    source project, it is possible to create an alternative version of Python. This
    has been done many times with varying degrees of success. Some of these variants
    include the following:'
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: Python有多种版本。我使用并参考了来自[https://www.python.org](https://www.python.org)的Python
    3。记住——因为它是一个开源项目，所以有可能创建Python的替代版本。这已经多次尝试过，并且成功程度各不相同。以下是一些这些变体的例子：
- en: '`numpy`, `matplotlib`, and `pandas` included in the installation. The downside
    is the amount of space on your drives consumed by this bigger installation, but
    given the price of storage these days, it is likely not much of a consideration.
    These libraries are probably the most important variant to consider if you intend
    to do data science work.'
  id: totrans-30
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 安装中包含`numpy`、`matplotlib`和`pandas`。缺点是这种更大的安装会消耗你驱动器上的空间，但考虑到现在的存储价格，这可能不是什么大问题。如果你打算进行数据科学工作，这些库可能是需要考虑的最重要变体。
- en: '**IronPython**—This is a variant of Python designed to run in the Microsoft
    .NET runtime. The implications of that are beyond the scope of this book. However,
    IronPython is interesting because, in addition to running in a .NET environment,
    this implementation isn’t hobbled by a **global interpreter lock** (**GIL**).
    GILs prevent efficient multithreading in your code. If you’re not aware of this
    limitation in Python, I’ll leave a link in the *Further reading* section of this
    chapter.'
  id: totrans-31
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**IronPython**——这是一个为在Microsoft .NET运行时中运行而设计的Python变体。其影响超出了本书的范围。然而，IronPython很有趣，因为它除了在.NET环境中运行外，这个实现并没有受到全局解释器锁（GIL）的限制。GIL阻止了代码中的高效多线程。如果你不了解Python中的这个限制，我将在本章的*进一步阅读*部分留下一个链接。'
- en: '**Jython**—This variant allows your Python code to execute within a **Java
    Virtual** **Machine** (**JVM**).'
  id: totrans-32
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**Jython**——这个变体允许你的Python代码在Java虚拟机（JVM）中执行。'
- en: '**MicroPython**—This variant is used to run Python code with microcontrollers
    for use in the **Internet of Things** (**IoT**) and potentially embedded projects.'
  id: totrans-33
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**MicroPython**——这个变体用于在物联网（IoT）和潜在的嵌入式项目中运行Python代码。'
- en: '**ActiveState ActivePython**—This is a commercially supported implementation
    of Python, with special attention paid to Windows compatibility and execution.
    Traditionally, Python was designed with the assumption that it would be running
    in Unix or Linux environments. If you intend to run your Python code in production
    on a Windows server, you might consider this variant.'
  id: totrans-34
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**ActiveState ActivePython**——这是一个商业支持的Python实现，特别关注Windows兼容性和执行。传统上，Python的设计假设它将在Unix或Linux环境中运行。如果你打算在Windows服务器上运行你的Python代码，你可能需要考虑这个变体。'
- en: You’ll find these documented officially at [https://www.python.org/download/alternatives/](https://www.python.org/download/alternatives/).
    While any of these variants should work in PyCharm, most developers using the
    IDE are working in vanilla Python (the one from [python.org](http://python.org))
    or Anaconda. As you work with virtual environments in Python, you will undoubtedly
    see different options for these alternative implementations. In general, I always
    use the vanilla version of Python 3.
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以在[https://www.python.org/download/alternatives/](https://www.python.org/download/alternatives/)上官方找到这些文档。虽然这些变体中的任何一个都应该在PyCharm中工作，但大多数使用IDE的开发者都在使用纯Python（来自[python.org](http://python.org)）或Anaconda。随着你在Python中使用虚拟环境，你无疑会看到这些替代实现的不同选项。一般来说，我总是使用Python
    3的纯版本。
- en: Virtual environments
  id: totrans-36
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 虚拟环境
- en: We oriented ourselves with respect to project creation in [*Chapter 2*](B19644_02.xhtml#_idTextAnchor028),
    *Installation and Configuration*; however, we glossed over the details around
    creating or setting up a `matplotlib`, only runs in Python 3.6 on your Mac, but
    in Windows, it’s stable at Python 3.9\. While that project is going on, another
    project starts that requires Python 3.10.
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在[*第二章*](B19644_02.xhtml#_idTextAnchor028)，“安装和配置”中定位了项目创建；然而，我们只是简要地提到了创建或设置`matplotlib`的细节，它只在Mac上的Python
    3.6上运行，但在Windows上，它在Python 3.9上稳定。当这个项目在进行时，另一个需要Python 3.10的项目开始了。
- en: If you were strictly working with the global or system-wide installations of
    Python, it would be very hard to switch back and forth between those two projects.
    You would have to futz with environment variables and fix your computer’s `PATH`
    environment variable. Then, you would have to try to remember which third-party
    libraries are installed globally and hope there isn’t a clash between those library
    requirements for the separate projects. Yuck.
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你严格使用 Python 的全局或系统级安装，在两个项目之间切换会非常困难。你将不得不调整环境变量并修复你电脑的 `PATH` 环境变量。然后，你还得尝试记住哪些第三方库是全局安装的，并希望这些库的要求不会在独立项目之间发生冲突。真糟糕。
- en: Virtual environments allow you to manage these problems easily. While using
    them is purely optional, it is considered a best practice to create a virtual
    environment for every project. Before we dive back into PyCharm, I thought it
    would be fun to create a virtual environment manually. You can skip this if you’d
    like, but if you haven’t done this before, I think it will give you an appreciation
    for some of the work PyCharm takes off your plate at the onset of a new project.
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 虚拟环境允许你轻松地管理这些问题。虽然使用它们完全是可选的，但为每个项目创建一个虚拟环境被认为是最佳实践。在我们回到 PyCharm 之前，我想手动创建一个虚拟环境，这会很有趣。如果你想跳过这个步骤，也可以，但如果你之前没有这样做过，我认为这将让你对
    PyCharm 在新项目开始时为你分担的一些工作有所欣赏。
- en: Creating a virtual environment by hand
  id: totrans-40
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 手动创建虚拟环境
- en: Open up your computer’s terminal and find a spot on your drive where you can
    do a little temporary work. We won’t be keeping this for later; we’re just going
    to go through the process. We will then switch to PyCharm so that we can see a
    more automated version of the same workflow.
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 打开你的电脑终端，在你的驱动器上找到一个可以进行一些临时工作的地方。我们不会保留这个文件夹以供以后使用；我们只是会走一遍这个过程。然后我们将切换到 PyCharm，以便我们可以看到同一工作流程的更自动化版本。
- en: 'I’m running Windows, and I have a place in my home folder where I keep my projects;
    a folder simply called *Projects*. Having opened my computer’s terminal program,
    which in this case is **Windows Terminal** running **PowerShell**, I can type
    the commands for this experiment. You do not have to use Windows, nor do you have
    to use PowerShell. The normal **zshell** (**zsh**) terminal prompt in macOS or
    the **Bourne Again Shell** (**Bash**) prompt in Linux works the same. Most of
    the commands are identical in all terminals and operating systems. I’ll start
    by creating a new folder, as follows:'
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 我使用的是 Windows，并在我的主文件夹中有一个专门存放项目的位置；一个简单地叫做 *Projects* 的文件夹。打开电脑的终端程序后，在这个例子中是运行
    **PowerShell** 的 **Windows Terminal**，我可以输入这个实验的命令。你不必使用 Windows，也不必使用 PowerShell。macOS
    或 Linux 上的正常 **zshell** （**zsh**） 终端提示符或 **Bourne Again Shell** （**Bash**） 提示符工作方式相同。大多数命令在所有终端和操作系统上都是相同的。我将首先创建一个新文件夹，如下所示：
- en: '[PRE0]'
  id: totrans-43
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'This creates a new folder called `python-environment-demo`. Next, I need to
    change directory (`cd`) into it, like so:'
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 这将创建一个名为 `python-environment-demo` 的新文件夹。接下来，我需要更改目录（`cd`）进入它，如下所示：
- en: '[PRE1]'
  id: totrans-45
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'Now I’m inside that folder, I’ll create my virtual environment. If you are
    using macOS or Linux, there’s a good chance you have both Python 2 and 3 installed,
    and we want to be sure to make a virtual environment based on Python 3\. In order
    to differentiate, you need to type the following:'
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我已经在这个文件夹里了，我将创建我的虚拟环境。如果你使用的是 macOS 或 Linux，你很可能同时安装了 Python 2 和 3，而我们想确保基于
    Python 3 创建虚拟环境。为了区分，你需要输入以下内容：
- en: '[PRE2]'
  id: totrans-47
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'If you’re on Windows, you probably only have Python 3 installed, so the command
    is this:'
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你使用的是 Windows，你可能只安装了 Python 3，所以命令是这样的：
- en: '[PRE3]'
  id: totrans-49
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'Here, we’re running the `python3` command, and we’re passing a switch (`-m`)
    that will execute the `venv` package to create a new virtual environment based
    on Python 3 within a new folder called `venv`. Once the command finishes, I can
    make sure it worked on Windows with this:'
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 这里，我们运行 `python3` 命令，并传递一个开关（`-m`），这将执行 `venv` 包来在名为 `venv` 的新文件夹中创建一个基于 Python
    3 的新虚拟环境。一旦命令执行完毕，我可以用以下方式确保它在 Windows 上工作：
- en: '[PRE4]'
  id: totrans-51
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'Or on macOS/Linux, I can use this:'
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 或者，在 macOS/Linux 上，我可以使用以下命令：
- en: '[PRE5]'
  id: totrans-53
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'You should see your system’s output. I’m using Windows, so mine appears as
    seen in *Figure 3**.1*:'
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 你应该能看到你系统的输出。我使用的是 Windows，所以我的输出如 *图 3**.1* 所示：
- en: '![Figure 3.1: Terminal output checking whether my virtual environment creation
    was successful](img/B19644_03_01.jpg)'
  id: totrans-55
  prefs: []
  type: TYPE_IMG
  zh: '![图 3.1：检查我的虚拟环境创建是否成功的终端输出](img/B19644_03_01.jpg)'
- en: 'Figure 3.1: Terminal output checking whether my virtual environment creation
    was successful'
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 图 3.1：检查我的虚拟环境创建是否成功的终端输出
- en: It isn’t necessary for your virtual environment to be in the same folder as
    the rest of your project, but I usually organize things this way to make the virtual
    environment easy to find later.
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 你的虚拟环境不需要与项目的其余部分放在同一个文件夹中，但我通常这样组织是为了让虚拟环境以后更容易找到。
- en: If I intend to use Git or some other revision control system, it would be appropriate
    for me to have the revision control system ignore this folder. You should *not*
    check this folder into your repository.
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我打算使用Git或其他版本控制系统，我最好让版本控制系统忽略这个文件夹。你不应该将这个文件夹检入到你的仓库中。
- en: 'The final step in working with a virtual environment is to activate it. The
    command is a little different in Windows compared to macOS and Linux. The command
    to activate a virtual environment in Windows is this:'
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 使用虚拟环境的最后一步是激活它。在Windows、macOS和Linux中，命令略有不同。在Windows中激活虚拟环境的命令如下：
- en: '[PRE6]'
  id: totrans-60
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'While in macOS and Linux, it would be this:'
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 在macOS和Linux中，它会是这样的：
- en: '[PRE7]'
  id: totrans-62
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'If you successfully activated your virtual environment, the prompt should have
    changed to display the name of the virtual environment that is currently active.
    Bear in mind that if you have customized your terminal to prevent this, it might
    not work. You can see in *Figure 3**.2* that everything worked for me, as indicated
    by `(venv)` appearing at the front of my prompt. The top example shows activation
    in Windows 11, while the lower example shows the activation command in Linux,
    which is the same as it would be in macOS:'
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你成功激活了虚拟环境，提示符应该会改变以显示当前激活的虚拟环境名称。请注意，如果你已经自定义了终端以防止这种情况发生，它可能不会工作。你可以在*图3.2*中看到，对我来说一切正常，因为我的提示符前出现了`(venv)`。上面的例子显示了Windows
    11中的激活，而下面的例子显示了Linux中的激活命令，它与macOS中的相同：
- en: '![Figure 3.2: My virtual environment has been activated](img/B19644_03_02.jpg)'
  id: totrans-64
  prefs: []
  type: TYPE_IMG
  zh: '![图3.2：我的虚拟环境已激活](img/B19644_03_02.jpg)'
- en: 'Figure 3.2: My virtual environment has been activated'
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 图3.2：我的虚拟环境已激活
- en: 'When I’m ready to stop working in my virtual environment, I can deactivate
    it by typing the following command in the terminal:'
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 当我准备好停止在虚拟环境中工作时，我可以在终端中输入以下命令来停用它：
- en: '[PRE8]'
  id: totrans-67
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: That was a little bit of work. If you’ve been doing this for a while, it isn’t
    too bad—maybe just a few minutes. However, if you do not do this very often, you
    will have to look everything up, and this may take time. You really only do this
    at the beginning of a new project. Some people might only do this a few times
    per year. Now, let’s go back to PyCharm and see how this step is integrated into
    the new project creation workflow.
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 这需要一点工作。如果你已经这样做了一段时间，这并不是太糟糕——可能只是几分钟。然而，如果你不经常这样做，你将不得不查找所有内容，这可能会花费时间。你实际上只在新的项目开始时做这件事。有些人可能一年只做几次。现在，让我们回到PyCharm，看看这一步是如何集成到新项目创建工作流程中的。
- en: Creating a project in PyCharm (revisited)
  id: totrans-69
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 在PyCharm中创建项目（重新审视）
- en: 'If we go back to PyCharm and create a new pure Python project, you’ll see where
    the process of creating a virtual environment happens. In PyCharm, let’s create
    a new project by clicking **File** | **New Project…**, as seen in *Figure 3**.3*:'
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们回到PyCharm并创建一个新的纯Python项目，你会看到创建虚拟环境的过程。在PyCharm中，让我们通过点击**文件** | **新建项目…**来创建一个新项目，如图3.3所示：
- en: '![Figure 3.3: Creating a new project in PyCharm](img/B19644_03_03.jpg)'
  id: totrans-71
  prefs: []
  type: TYPE_IMG
  zh: '![图3.3：在PyCharm中创建新项目](img/B19644_03_03.jpg)'
- en: 'Figure 3.3: Creating a new project in PyCharm'
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 图3.3：在PyCharm中创建新项目
- en: 'This will be a pure Python project. The Professional edition is not necessary
    to follow along. The new project dialog is something we saw before in [*Chapter
    2*](B19644_02.xhtml#_idTextAnchor028), *Installation and Configuration*, but this
    time we will focus on some of the details we skipped. *Figure 3**.4* shows the
    Professional edition of PyCharm’s new project window on the left. PyCharm Community
    lacks the project type menu since it can only create “pure Python” projects:'
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 这将是一个纯Python项目。不需要专业版来跟随。新项目对话框是我们之前在[*第2章*](B19644_02.xhtml#_idTextAnchor028)，“安装和配置”中看到的，但这次我们将关注一些我们跳过的细节。*图3.4*显示了PyCharm专业版的新项目窗口在左侧。PyCharm社区版缺少项目类型菜单，因为它只能创建“纯Python”项目：
- en: '![Figure 3.4: A side-by-side comparison of the New Project window for the Professional
    edition (left) and the Community edition (right)](img/B19644_03_04.jpg)'
  id: totrans-74
  prefs: []
  type: TYPE_IMG
  zh: '![图3.4：专业版（左侧）和社区版（右侧）新项目窗口的并排比较](img/B19644_03_04.jpg)'
- en: 'Figure 3.4: A side-by-side comparison of the New Project window for the Professional
    edition (left) and the Community edition (right)'
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 图3.4：专业版（左）和社区版（右）的新项目窗口的并排比较
- en: 'The section of the **New Project** dialog I’d like you to focus on is highlighted
    in *Figure 3**.5*. It is this section of the screen that allows you to set up
    your virtual environment. In [*Chapter 2*](B19644_02.xhtml#_idTextAnchor028),
    *Installation and Configuration*, we breezed right past this and just accepted
    the defaults. As it happens, the defaults nearly match the manual process we completed
    in the last section:'
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 我希望您关注的**新项目**对话框部分在*图3*.*5*中被突出显示。这是屏幕上的这部分允许您设置您的虚拟环境。在[*第2章*](B19644_02.xhtml#_idTextAnchor028)，*安装和配置*中，我们迅速跳过这部分并接受了默认设置。实际上，默认设置几乎与我们在上一节中完成的手动过程相匹配：
- en: '![Figure 3.5: The virtual environment settings from PyCharm enumerated for
    explanation](img/B19644_03_05.jpg)'
  id: totrans-77
  prefs: []
  type: TYPE_IMG
  zh: '![图3.5：为说明目的而列举的PyCharm的虚拟环境设置](img/B19644_03_05.jpg)'
- en: 'Figure 3.5: The virtual environment settings from PyCharm enumerated for explanation'
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 图3.5：为说明目的而列举的PyCharm的虚拟环境设置
- en: 'Let’s consider the numbered labels in *Figure 3**.5*:'
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们考虑*图3*.*5*中的编号标签：
- en: This is the Python interpreter settings section of the **New Project** window.
    You can hide it if you like by twirling the triangle next to the section label,
    though if we did that, we wouldn't be able to continue talking about what comes
    next.
  id: totrans-80
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 这是**新项目**窗口中的Python解释器设置部分。如果您喜欢，可以通过旋转部分标签旁边的三角形来隐藏它，尽管如果我们这样做，我们就无法继续谈论接下来会发生什么。
- en: There are two options at play here. You can either create a new virtual environment
    or point to one you’ve already created. Let’s focus on creating a new one. The
    `virtualenv` virtual environment feature. Changing the mechanism using the dropdown
    will change the contents of the screen to match the settings for the virtual environment
    script you pick. For now, let’s leave it on **Virtualenv** since that is the oldest
    and likely the most widely used.
  id: totrans-81
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 这里有两个选项在起作用。您可以选择创建一个新的虚拟环境或指向您已经创建的一个。让我们专注于创建一个新的。`virtualenv`虚拟环境功能。通过下拉列表更改机制将更改屏幕内容以匹配您选择的虚拟环境脚本的设置。目前，让我们将其保留在**Virtualenv**，因为这是最古老的可能也是使用最广泛的。
- en: The `venv` within the folder for the project. You can set the location anywhere
    on your computer; it doesn’t have to be in the project folder. If you have several
    projects that share a virtual environment because they share dependencies, it
    makes sense to create a central location to hold the environment. Most of the
    time, I prefer to keep the virtual environment in the same folder as the project
    so that there is no question as to its location.
  id: totrans-82
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 项目文件夹内的`venv`。您可以在计算机上的任何位置设置位置；它不必在项目文件夹中。如果您有多个项目共享虚拟环境，因为它们共享依赖项，那么创建一个中央位置来保存环境是有意义的。大多数时候，我更喜欢将虚拟环境与项目文件夹放在同一位置，这样就不会对其位置产生疑问。
- en: The **Base interpreter** field lets you choose which Python installation will
    be used to create the virtual environment. If you have more than one Python installation
    on your computer, PyCharm was probably able to find it automatically. The selection
    is presented as a drop-down list of the locations where PyCharm found a Python
    installation. If it somehow missed one, you can click the ellipsis button (**…**)
    and navigate to the Python installation you’re interested in using. If you do
    this, you need to navigate all the way to the Python executable and double-click
    it.
  id: totrans-83
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**基本解释器**字段允许您选择用于创建虚拟环境的Python安装。如果您在计算机上安装了多个Python版本，PyCharm可能已经自动找到它。选择以PyCharm找到Python安装的位置的下拉列表形式呈现。如果它遗漏了某个安装，您可以点击省略号按钮（**…**）并导航到您想要使用的Python安装。如果您这样做，您需要导航到Python可执行文件并双击它。'
- en: The **Inherit global site-packages** checkbox deals with any third-party libraries
    you might have installed globally. Checking this box will copy those into your
    virtual environment so that they are available locally in your project.
  id: totrans-84
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**继承全局站点包**复选框处理您可能全局安装的任何第三方库。勾选此复选框将它们复制到您的虚拟环境中，以便在您的项目中本地使用。'
- en: The **Make available to all projects** checkbox allows you to easily find and
    reuse this virtual environment in other projects.
  id: totrans-85
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**对所有项目可用**复选框允许您轻松在其他项目中找到并重用此虚拟环境。'
- en: Using an existing virtual environment
  id: totrans-86
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用现有的虚拟环境
- en: Sometimes, you need to make a project with the exact same requirements used
    in another project. You can share or reuse a virtual environment easily in PyCharm.
    *Figure 3**.5* shows the **New Project** dialog in PyCharm.
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 有时候，你可能需要使用与另一个项目完全相同的精确要求来制作一个项目。在 PyCharm 中，你可以轻松地共享或重用虚拟环境。*图 3**.5* 展示了
    PyCharm 中的 **新建项目** 对话框。
- en: 'To use an existing virtual environment, you’d need to change the default setting
    from **New environment** using to **Previously configured interpreter**, as seen
    in *Figure 3**.6*:'
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 要使用现有的虚拟环境，你需要将默认设置从 **新建环境** 更改为 **先前配置的解释器**，如 *图 3**.6* 所示：
- en: '![Figure 3.6: You can point your project to an existing virtual environment
    by changing the setting for the project](img/B19644_03_06.jpg)'
  id: totrans-89
  prefs: []
  type: TYPE_IMG
  zh: '![图 3.6：你可以通过更改项目的设置来将项目指向现有的虚拟环境](img/B19644_03_06.jpg)'
- en: 'Figure 3.6: You can point your project to an existing virtual environment by
    changing the setting for the project'
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 图 3.6：你可以通过更改项目的设置来将项目指向现有的虚拟环境
- en: Once you do that, your options for selecting an existing environment become
    active. There is a drop-down list available to pick the interpreter. It works
    the same as the **Base interpreter** dropdown we saw earlier when creating a new
    virtual environment. If you created the existing environment in PyCharm, the IDE
    would remember it. In this case, I previously created a virtual environment using
    PyCharm when I created the demo project code for [*Chapter 1*](B19644_01.xhtml#_idTextAnchor014),
    *Introduction to PyCharm – The Most Popular IDE for Python*. PyCharm will remember
    virtual environments created using PyCharm and will offer them in the list.
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦你这样做，选择现有环境的选项就会变得活跃。有一个下拉列表可供选择解释器。它的工作方式与我们之前在创建新虚拟环境时看到的 **基本解释器** 下拉列表相同。如果你在
    PyCharm 中创建了现有环境，IDE 会记住它。在这种情况下，我在创建 *第 1 章* 的演示项目代码时，使用了 PyCharm 创建了一个虚拟环境，*《PyCharm
    简介 – 最受欢迎的 Python IDE》*。PyCharm 会记住使用 PyCharm 创建的虚拟环境，并将它们列出来。
- en: 'If you used a manual method or some other tool, you’ll need to add the interpreter
    to the list using the **Add Interpreter** button. When you click the button, you’ll
    notice some possibilities, as seen in *Figure 3**.7*:'
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你使用的是手动方法或其他工具，你需要使用 **添加解释器** 按钮将解释器添加到列表中。当你点击按钮时，你会注意到一些可能性，如 *图 3**.7*
    所示：
- en: '![Figure 3.7: When you click Add Interpreter, you have a myriad of options
    for the origin of the environment you might want to add](img/B19644_03_07.jpg)'
  id: totrans-93
  prefs: []
  type: TYPE_IMG
  zh: '![图 3.7：当你点击添加解释器时，你有很多选择来添加你想要添加的环境的来源](img/B19644_03_07.jpg)'
- en: 'Figure 3.7: When you click Add Interpreter, you have a myriad of options for
    the origin of the environment you might want to add'
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 图 3.7：当你点击添加解释器时，你有很多选择来添加你想要添加的环境的来源
- en: So far, we’re strictly limiting our discussion to adding a virtual environment
    that exists on your local computer. It is possible to add an environment on a
    remote computer, **virtual machine** (**VM**), **Windows Subsystem for Linux**
    (**WSL**, which is a VM), or a **Docker** container. We’re going to talk about
    those options much later in the book.
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们严格限制讨论的范围仅限于添加存在于你本地计算机上的虚拟环境。有可能添加远程计算机、**虚拟机**（**VM**）、**Windows Subsystem
    for Linux**（**WSL**，它是一个虚拟机）或 **Docker** 容器上的环境。我们将在本书的后面部分详细讨论这些选项。
- en: 'Once you select `bin` folder containing the Python executable. In Windows,
    the virtual environment has a `Scripts` folder that will contain a file that points
    to the Python executable. Your goal in any case is to select the executable:'
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦你选择了包含 Python 可执行文件的 `bin` 文件夹。在 Windows 中，虚拟环境有一个 `Scripts` 文件夹，它将包含一个指向
    Python 可执行文件的文件。在任何情况下，你的目标都是选择可执行文件：
- en: '![Figure 3.8: You need to select the Python executable within the virtual environment
    folder you’d like to use](img/B19644_03_08.jpg)'
  id: totrans-97
  prefs: []
  type: TYPE_IMG
  zh: '![图 3.8：你需要选择你想要使用的虚拟环境文件夹内的 Python 可执行文件](img/B19644_03_08.jpg)'
- en: 'Figure 3.8: You need to select the Python executable within the virtual environment
    folder you’d like to use'
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 图 3.8：你需要选择你想要使用的虚拟环境文件夹内的 Python 可执行文件
- en: Changing the interpreter for a project
  id: totrans-99
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 更改项目的解释器
- en: One trick I employ when I’m working on a project that’s been ongoing for 6 months
    or longer is to create a new virtual environment with fully updated packages.
    This way, I can test the program with updated dependencies without corrupting
    my production-ready virtual environment. We’ll cover package management a little
    later in this chapter. For now, I want to show you where the setting for your
    project’s interpreter exists independently of the project creation process. I
    find this to be a little bit non-intuitive. It’s in **Settings**. The same **Settings**
    option you use to configure the IDE globally across all projects is used to set
    project-specific settings such as the interpreter settings.
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 当我处理一个持续了 6 个月或更长时间的项目时，我会使用的一个技巧是创建一个带有完全更新包的新虚拟环境。这样，我可以在不破坏我的生产就绪虚拟环境的情况下测试带有更新依赖关系的程序。我们将在本章稍后介绍包管理。现在，我想向您展示您的项目解释器设置在哪里独立于项目创建过程。我发现这有点不直观。它在
    **设置** 中。您用于在所有项目中全局配置 IDE 的相同 **设置** 选项也用于设置特定于项目的设置，例如解释器设置。
- en: 'Regardless of your reason, it is possible to change the interpreter, and by
    extension the virtual environment used in your project. You’ll find the project
    settings by clicking the gear icon in the top-left corner of the UI, as seen in
    *Figure 3**.9*:'
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 无论您的理由是什么，您都可以更改解释器，以及由此扩展的项目中使用的虚拟环境。您可以通过点击 UI 左上角的齿轮图标找到项目设置，如图 *图 3.9* 所示：
- en: '![Figure 3.9: You’ll find global and project settings by clicking the gear](img/B19644_03_09.jpg)'
  id: totrans-102
  prefs: []
  type: TYPE_IMG
  zh: '![图 3.9：通过点击齿轮图标，您可以找到全局和项目设置](img/B19644_03_09.jpg)'
- en: 'Figure 3.9: You’ll find global and project settings by clicking the gear'
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 图 3.9：通过点击齿轮图标，您可以找到全局和项目设置
- en: 'Once you select **Settings**, you’ll be taken to the global settings screen
    we studied in [*Chapter 2*](B19644_02.xhtml#_idTextAnchor028), *Installation and
    Configuration*. Project properties are also stored here, as shown in *Figure 3**.10*:'
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦您选择 **设置**，您将被带到我们在 [*第 2 章*](B19644_02.xhtml#_idTextAnchor028) 中研究的全局设置屏幕，即
    *安装和配置*。项目属性也存储在这里，如图 *图 3.10* 所示：
- en: '![Figure 3.10: The project settings are in the middle of the list](img/B19644_03_10.jpg)'
  id: totrans-105
  prefs: []
  type: TYPE_IMG
  zh: '![图 3.10：项目设置位于列表中间](img/B19644_03_10.jpg)'
- en: 'Figure 3.10: The project settings are in the middle of the list'
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 图 3.10：项目设置位于列表中间
- en: Select the interpreter settings on the left side of the screen and change the
    interpreter using the same mechanism we used when we set the virtual environment
    the first time. You can create a new environment or browse to a new one. Don’t
    forget that when you browse to a new environment, you need to select the Python
    executable and not the folder where the Python installation is located. I forget
    this sometimes, and I’m left wondering why the selection dialog won’t go away.
    It’s looking for a file, which is the Python executable, not a folder.
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 在屏幕左侧选择解释器设置，并使用我们第一次设置虚拟环境时使用的相同机制更改解释器。您可以创建一个新的环境或浏览到一个新的环境。别忘了，当您浏览到一个新的环境时，您需要选择
    Python 可执行文件，而不是 Python 安装所在的文件夹。我有时会忘记这一点，然后我会 wonder 为什么选择对话框不会消失。它正在寻找一个文件，即
    Python 可执行文件，而不是一个文件夹。
- en: Activating virtualenv
  id: totrans-108
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 激活 virtualenv
- en: 'In our manual exercise earlier in this chapter, we created a virtual environment
    from scratch using `virtualenv`. Once the environment is created, you must activate
    it in order to use it. An obvious question might be “*How do I activate the environment?*”
    Here’s the beautiful answer: you don’t have to. While you are in the IDE, the
    environment settings are always there and are always honored. When you add new
    third-party packages from the **Python Package Index** (**PyPI**), which we’ll
    cover shortly, they automatically go to the right place per your environment settings.'
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章前面的手动练习中，我们使用 `virtualenv` 从头开始创建了一个虚拟环境。一旦环境创建完成，您必须激活它才能使用它。一个可能的问题可能是“*我该如何激活环境？*”这是一个美丽的答案：您不必这样做。当您在
    IDE 中时，环境设置始终存在，并且始终得到尊重。当您从 **Python 包索引**（**PyPI**）添加新的第三方包，我们将在稍后介绍，它们会根据您的环境设置自动放置到正确的位置。
- en: When we run our program, we can override the **run configuration**, but by default,
    it uses the project’s environment setting. Frankly, it’s rare that the override
    in the run configuration is useful. With that said, I’ll show you how to override
    the run configuration later in this chapter.
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们运行我们的程序时，我们可以覆盖 **运行配置**，但默认情况下，它使用项目的环境设置。坦白说，在运行配置中覆盖的情况很少有用。话虽如此，我将在本章后面向您展示如何覆盖运行配置。
- en: Using the integrated terminal
  id: totrans-111
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用集成终端
- en: 'Another place to worry about the virtual environment being active is within
    the **terminal**. It’s true PyCharm can’t help you with your system terminal.
    However, PyCharm does have its own terminal window tab. If you use PyCharm’s terminal,
    the project’s interpreter settings are automatically applied. You will not have
    to manually activate anything. Since we are talking about it, let’s look at the
    integrated terminal in PyCharm. You can find the menu item for showing the terminal
    in the **View** menu, as seen in *Figure 3**.11*. Personally, I spend a lot of
    time in the terminal, so I have committed the keyboard shortcut to muscle memory:'
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 另一个需要担心虚拟环境是否激活的地方是在**终端**内部。诚然，PyCharm无法帮助你处理系统终端。然而，PyCharm确实有自己的终端窗口标签页。如果你使用PyCharm的终端，项目的解释器设置会自动应用。你不需要手动激活任何内容。既然我们提到了它，让我们看看PyCharm中的集成终端。你可以在**视图**菜单中找到显示终端的菜单项，如图*图3.11*所示。我个人在终端上花费了很多时间，所以我将键盘快捷键记在了肌肉记忆中：
- en: '![Figure 3.11: PyCharm’s integrated terminal can be found buried within the
    View menu](img/B19644_03_11.jpg)'
  id: totrans-113
  prefs: []
  type: TYPE_IMG
  zh: '![图3.11：PyCharm的集成终端可以在视图菜单中找到](img/B19644_03_11.jpg)'
- en: 'Figure 3.11: PyCharm’s integrated terminal can be found buried within the View
    menu'
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 图3.11：PyCharm的集成终端可以在视图菜单中找到
- en: 'Invoking the menu option brings up the terminal and, as promised, you can see
    in *Figure 3**.12* it honors our project’s virtual environment setting:'
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 调用菜单选项会弹出终端，正如承诺的那样，你可以在*图3.12*中看到它尊重我们项目的虚拟环境设置：
- en: '![Figure 3.12: You can see the terminal comes up with your virtual environment
    already active](img/B19644_03_12.jpg)'
  id: totrans-116
  prefs: []
  type: TYPE_IMG
  zh: '![图3.12：你可以看到终端已经激活了你的虚拟环境](img/B19644_03_12.jpg)'
- en: 'Figure 3.12: You can see the terminal comes up with your virtual environment
    already active'
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 图3.12：你可以看到终端已经激活了你的虚拟环境
- en: 'If the presence of `(venv)` in the prompt isn’t proof enough that it worked,
    I provided more in *Figure 3**.12*. If you use macOS or Linux, you can use the
    `which` command to find the path to any executable. Sorry, Windows users: there
    isn’t an equivalent command on your OS. The result of the `which` command is that
    it shows when I run `python3` it is using the one at the indicated path, rather
    than the system-wide installation, which is usually at `/usr/bin/python3`.'
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 如果提示符中`(venv)`的存在不足以证明它已经工作，我在*图3.12*中提供了更多内容。如果你使用macOS或Linux，你可以使用`which`命令找到任何可执行文件的路径。抱歉，Windows用户：在您的操作系统上没有等效的命令。`which`命令的结果是，它显示当我运行`python3`时，它使用的是指定路径上的那个，而不是系统范围内的安装，通常在`/usr/bin/python3`。
- en: Working with the REPL in the console window
  id: totrans-119
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 在控制窗口中与REPL一起工作
- en: 'One final tool in PyCharm that might cause you to wonder whether or not your
    environment settings are being honored is the `python3` by itself. PyCharm gives
    you an integrated tool so that you don’t have to. To get to the console, use the
    same menu you used to get to the terminal. I’ve shown it to you in *Figure 3**.13*:'
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 'PyCharm中一个可能让你怀疑环境设置是否被尊重的最终工具是单独的`python3`。PyCharm为你提供了一个集成工具，因此你不必这样做。要进入控制台，使用你用来进入终端的相同菜单。我在*图3.13*中向你展示了它。 '
- en: '![Figure 3.13: The Python console can be invoked via the View menu](img/B19644_03_13.jpg)'
  id: totrans-121
  prefs: []
  type: TYPE_IMG
  zh: '![图3.13：可以通过视图菜单调用Python控制台](img/B19644_03_13.jpg)'
- en: 'Figure 3.13: The Python console can be invoked via the View menu'
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 图3.13：可以通过视图菜单调用Python控制台
- en: 'Your console is not only aware of your interpreter settings, but it is also
    aware of the contents of your project. You can import and test anything in your
    project directly in the console. I find this useful when I’m tracking down the
    dreaded “*Module not found? Whaddya mean it’s not found?! It’s right there! I’m
    looking right at it!*” issues we sometimes face. It is also useful for experimenting
    with some of the terser syntax we find in Python, such as **regular expressions**
    (**regexes**) or list comprehensions. There’s a small example in *Figure 3**.14*:'
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 你的控制台不仅了解你的解释器设置，而且还了解你项目的内容。你可以在控制台中直接导入和测试项目中的任何内容。我发现这在追踪我们有时遇到的可怕的“*模块未找到？你什么意思它没找到？！它就在那里！我正看着它!*”问题时很有用。它也适用于实验Python中我们发现的一些更简洁的语法，例如**正则表达式**（**regexes**）或列表推导式。*图3.14*中有一个小例子：
- en: '![Figure 3.14: The console window in use to test a simple regex](img/B19644_03_14.jpg)'
  id: totrans-124
  prefs: []
  type: TYPE_IMG
  zh: '![图3.14：正在使用的控制窗口来测试一个简单的正则表达式](img/B19644_03_14.jpg)'
- en: 'Figure 3.14: The console window in use to test a simple regex'
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 图3.14：正在使用的控制窗口来测试一个简单的正则表达式
- en: 'The code I’m trying out in *Figure 3**.14* isn’t going to impress anyone in
    my big Python interview with Google:'
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 我在*图 3**.14*中尝试的代码不会在谷歌的 Python 面试中给人留下深刻印象：
- en: '[PRE9]'
  id: totrans-127
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: I type each line into the console. Remember—this is a live coding view, not
    a file that you execute. Every time I press *Enter*, the expression I just typed
    is evaluated, and the results appear in the debug-like window on the right side
    when appropriate. Think of it like a debugging session where you have a watch
    window on the right, and everything you type in next to the `>>>` prompt becomes
    an instant breakpoint.
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 我将每一行都输入到控制台中。记住——这是一个实时编码视图，而不是一个你可以执行的文件。每次我按下*Enter*，我刚才输入的表达式就会被评估，并且当适当的时候，结果会出现在右侧的调试窗口中。把它想象成一个调试会话，其中你有一个右侧的监视窗口，而你输入到`>>>`提示符旁边的每一行都成为了一个即时断点。
- en: Having pressed *Enter* to evaluate the third line, I can see that the `test`
    variable has a `re.Match` object as its value. Stare at the window a little longer,
    and you can see the characters were found at position (0, 5), or characters 0
    through 5 represented in a single tuple (`regs`).
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 在评估了第三行后按下*Enter*，我可以看到`test`变量有一个`re.Match`对象作为其值。多看一会儿窗口，你可以看到字符位于位置（0，5），或者字符
    0 到 5 表示为一个单一的元组（`regs`）。
- en: Trying out complicated bits of code in the console saves a little bit of time
    versus the usual process comprised of running the program, reading `print` statements,
    making a change, and trying again, which eats up most of our days as developers.
    Then, you forget to take out the print statements, and you should because they
    can seriously slow down a long-running script.
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 在控制台中尝试复杂的代码片段比通常的过程节省时间，通常的过程包括运行程序、阅读`print`语句、进行更改，然后再次尝试，这占用了我们作为开发者的大部分时间。然后，你忘记移除`print`语句，你应该这样做，因为它们可能会严重减慢长时间运行的脚本。
- en: The console executes everything instantly and feeds the results back to you.
    It is far more detailed than a print statement because you can see the internals
    of any object using the debug-like window, rather than just seeing a string. After
    some tinkering in the console window, you can go back to your code and just use
    what worked.
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 控制台立即执行所有操作并将结果反馈给你。它比`print`语句详细得多，因为你可以使用调试窗口查看任何对象的内部结构，而不仅仅是看到字符串。在控制台窗口中做一些调整后，你可以回到你的代码中并直接使用那些有效的工作。
- en: Working with third-party package libraries
  id: totrans-132
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 与第三方包库一起工作
- en: Python is famous for its “batteries included” philosophy, which is at odds with
    many other languages. Python’s creator, Guido van Rossum, believes a robust and
    complete standard library is important and that the language ought to be able
    to complete nearly any task without using any third-party dependencies.
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: Python 以其“内置电池”哲学而闻名，这与许多其他语言相矛盾。Python 的创造者 Guido van Rossum 认为，一个强大而完整的标准库非常重要，并且语言应该能够几乎完成任何任务，而无需使用任何第三方依赖。
- en: By third-party dependencies, I mean libraries external to Python designed to
    perform a specialized functionality that is not implemented in Python “out of
    the box.” In other words, Python sets for itself a very lofty goal. It should
    be able to do literally anything all by itself using what is called the Python
    standard library.
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 我所说的第三方依赖是指那些设计用于执行 Python “开箱即用”未实现的专业功能的、外部于 Python 的库。换句话说，Python 为自己设定了一个非常崇高的目标。它应该能够仅使用所谓的
    Python 标准库就完成任何事情。
- en: Naturally, this goal can never be fully realized. The Python standard library
    is very complete. Eventually, though, you’ll find something the standard library
    either can’t do or the standard library’s implementation isn’t as easy to use
    as it could be. Let’s look at a couple of quick examples of third-party libraries
    that are widely used, and talk about why you might want to use them.
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 自然，这个目标永远无法完全实现。Python 的标准库非常完整。然而，最终你会发现标准库要么无法完成某些功能，要么其实现方式不如预期那么易于使用。让我们看看几个广泛使用的第三方库的快速示例，并讨论为什么你可能想要使用它们。
- en: Let’s start with the `requests` library. This is a third-party library you’ll
    find on PyPI at [https://pypi.org/project/requests/](https://pypi.org/project/requests/).
    Every modern language has something similar. JavaScript has the **Node Package
    Manager** (**NPM**) at [https://npmjs.com](https://npmjs.com). **PHP** uses **Composer**
    to install packages from [https://packagist.org/](https://packagist.org/). The
    .NET languages use **NuGet** with packages registered at [https://nuget.org](https://nuget.org).
    Python has [https://pypi.org](https://pypi.org). It is a centralized listing of
    third-party modules and libraries you can add to your project, often free of charge.
    Metaphorically speaking, the idea is to prevent us from having to reinvent the
    wheel every time we want to build a new car. Since I work on a **software-as-a-service**
    (**SaaS**) project as my day job, I find myself needing an easy way to make **Hypertext
    Transfer Protocol** (**HTTP**) requests. The ability for my Python scripts to
    be able to make a call to some web service and process the results is crucial,
    and it is a very common task.
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们从`requests`库开始。这是一个你可以在PyPI上找到的第三方库，网址是[https://pypi.org/project/requests/](https://pypi.org/project/requests/)。每种现代语言都有类似的东西。JavaScript有**Node包管理器**（**NPM**），网址是[https://npmjs.com](https://npmjs.com)。**PHP**使用**Composer**从[https://packagist.org/](https://packagist.org/)安装包。.NET语言使用**NuGet**，包注册在[https://nuget.org](https://nuget.org)。Python有[https://pypi.org](https://pypi.org)。这是一个集中列出的第三方模块和库，你可以将其添加到项目中，通常免费。从比喻的角度来说，这个想法是为了防止我们每次想要建造一辆新车时都要重新发明轮子。由于我在我的日常工作是从事**软件即服务**（**SaaS**）项目，我发现自己需要一种简单的方法来发送**超文本传输协议**（**HTTP**）请求。我的Python脚本能够调用某个网络服务并处理结果的能力至关重要，这是一个非常常见的任务。
- en: 'Python’s standard library has a few options for accomplishing this. I think
    the most obvious is `urllib` from the standard library. Here is some example code
    from the `urllib2` documentation at [https://docs.python.org/3/howto/urllib2.html](https://docs.python.org/3/howto/urllib2.html):'
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: Python的标准库提供了一些完成此任务的方法。我认为最明显的是标准库中的`urllib`。以下是从`urllib2`文档中的示例代码[https://docs.python.org/3/howto/urllib2.html](https://docs.python.org/3/howto/urllib2.html)：
- en: '[PRE10]'
  id: totrans-138
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: First, we import two parts of the `urllib` package, remembering that is really
    `urllib2`. Next, we create a `url` variable. If you’re wondering what the references
    to `cgi` are in the sample, that’s a `cgi-bin` within the address. This style
    of development was supplanted long ago by the likes of **PHP**, classic **Active
    Server Pages** (**ASP**), **Java ServerPages** (**JSP**), and ColdFusion. Even
    those have since evolved into modern systems that use more sophisticated yet easier-to-code
    implementations of routing libraries that are very flexible. We’ll cover these
    later in the book when we talk about the web application development features
    in PyCharm Professional.
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们导入`urllib`包的两个部分，记住它实际上是`urllib2`。然后，我们创建一个`url`变量。如果你在样本中想知道`cgi`引用是什么，那是在地址中的`cgi-bin`。这种开发风格很久以前就被**PHP**、经典**活动服务器页面**（**ASP**）、**Java服务器页面**（**JSP**）和ColdFusion等所取代。即使是这些，也随后演变成了使用更复杂但更容易编码的路由库的现代系统，这些库非常灵活。我们将在本书后面讨论PyCharm
    Professional中的Web应用程序开发功能时介绍这些内容。
- en: Once we have our `url` variable established, we need some data. In this example,
    we are using HTTP `POST` to send data to our web server for processing. This is
    done with the `values` variable, which contains a dictionary that mimics the fields
    and values you might find in a **Hypertext Markup Language** (**HTML**) form.
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦我们建立了`url`变量，我们需要一些数据。在这个例子中，我们使用HTTP `POST`将数据发送到我们的Web服务器进行处理。这是通过`values`变量完成的，它包含一个字典，模拟了你在**超文本标记语言**（**HTML**）表单中可能找到的字段和值。
- en: Once we’ve set that up, we must parse that dictionary into a format suitable
    for transmission. That is done with `urllib.parse.urlencode`. Next, we need to
    further encode the data as **American Standard Code for Information Interchange**
    (**ASCII**). This is another anachronism in the documentation. Modern systems
    use the 8-bit universal text format (UTF-8) since ASCII only encodes letters from
    Romance languages such as English, French, German, Italian, or Portuguese. The
    rest of the world is out of luck. UTF-8 handles every alphabet in common global
    use today; this way, only the ancient Egyptians are snubbed, since UTF-8 doesn’t
    support hieroglyphics —at least, not that I know of.
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦我们设置好，我们必须将那个字典解析成适合传输的格式。这是通过`urllib.parse.urlencode`完成的。接下来，我们需要进一步将数据编码为**美国信息交换标准代码**（**ASCII**）。这是文档中的另一个时代错误。现代系统使用8位通用文本格式（UTF-8），因为ASCII只编码来自罗曼语系的语言，如英语、法语、德语、意大利语或葡萄牙语。世界上其他地方的人就不那么幸运了。UTF-8处理今天全球普遍使用的所有字母表；这样，只有古埃及人被忽视，因为UTF-8不支持象形文字——至少，据我所知。
- en: After we encode the text, we need to create a `request` object. We pass in our
    `url` variable and data to the constructor for `urllib.request.Request`. Only
    then are we ready to send the request in the last two lines of the sample.
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们对文本进行编码后，我们需要创建一个`request`对象。我们将`url`变量和数据传递给`urllib.request.Request`构造函数。只有在那时，我们才准备好在示例的最后两行发送请求。
- en: 'We’ve established there is a way to make a `POST` request in Python’s standard
    library. So far, though, we’ve only handled a very basic requirement. What if
    I need to present a request that is authenticated? How would I deal with sessions
    or cookies? Could we make this even simpler? We can with the `requests` library.
    Here is some sample code:'
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经确定在Python的标准库中存在一种发送`POST`请求的方法。然而，到目前为止，我们只处理了一个非常基本的需求。如果我需要发送一个经过身份验证的请求怎么办？我该如何处理会话或cookies？我们能否使这个过程更加简单？我们可以使用`requests`库。以下是一些示例代码：
- en: '[PRE11]'
  id: totrans-144
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: Our previous code from `urllib` could be expressed as a one-liner using `requests`!
    More advanced requirements such as sessions, cookies, and so on are equally easy.
    The documentation is modern and contains useful examples. Popular PyPI libraries
    such as `requests` are very well documented, with tutorials on sites such as [https://realpython.com](https://realpython.com).
    I borrowed the preceding sample from [https://realpython.com/python-requests/](https://realpython.com/python-requests/),
    which is part of a large and very complete tutorial on using this powerful library.
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 我们之前的`urllib`代码可以用`requests`库表达为一个单行代码！像会话、cookies等更高级的需求同样简单。文档是现代的，并包含有用的示例。像`requests`这样的流行PyPI库有很好的文档，例如在[https://realpython.com](https://realpython.com)网站上。我从[https://realpython.com/python-requests/](https://realpython.com/python-requests/)借用了前面的示例，这是关于使用这个强大库的庞大而完整的教程的一部分。
- en: The point of all this is to point out that a system of third-party code libraries
    is necessary, or at least useful, in the context of Python—a language that strives
    to include everything you could ever need, but never will. The standard library
    may come close, but it will never include everything I could ever want.
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 所有这些的目的是指出，在Python的背景下，一个第三方代码库系统是必要的，或者至少是有用的——Python是一种力求包含你所需一切的语言，但永远不会包含你想要的一切。标准库可能很接近，但永远不会包含我可能想要的每一件事。
- en: Another important example of necessary third-party libraries is with respect
    to scientific and financial work. The standard math capabilities in Python are
    about the same as you would find in any other language. Most languages are not
    incredibly precise at handling floating-point calculations. They are also not
    very nuanced at handling matrices of numeric data, which represents a common requirement.
    Thankfully, third-party libraries such as `numpy` and `pandas` exist to fill this
    void. These libraries open new possibilities to Python developers and are one
    of the main reasons Python continues to attract new users.
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 另一个必要的第三方库的重要例子是关于科学和金融工作。Python中的标准数学功能与其他任何语言相比大致相同。大多数语言在处理浮点计算方面并不非常精确。它们在处理数值数据的矩阵方面也不太细腻，而这是一种常见的需求。幸运的是，像`numpy`和`pandas`这样的第三方库存在，以填补这一空白。这些库为Python开发者打开了新的可能性，也是Python继续吸引新用户的主要原因之一。
- en: Adding third-party libraries in PyCharm
  id: totrans-148
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 在PyCharm中添加第三方库
- en: 'PyCharm includes a UI screen that allows you to manage the packages in your
    current project. However, if an IDE were not in use, you could use a package manager
    to do it manually. For example, to install `numpy` into your project, you could
    use the `pip` package manager with a command such as this:'
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  id: totrans-150
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: You should make sure you have activated the virtual environment for the project
    in order for this to work correctly. Otherwise, `numpy` will be installed globally.
    The `pip` installer isn’t the only installer available. There’s `easy_install`,
    `pipenv`, `poetry`, and of course, `conda`. I’m not going to debate the relative
    merits of each since this is a matter of preference. PyCharm supports them all.
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
- en: PyCharm’s package manager invokes the package manager set in your environment
    settings. It presents a graphical interface where you can search for packages,
    view their descriptions, and install, update, and uninstall any package in your
    project. Let’s take a look.
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
- en: 'Going back to PyCharm, let’s return to our project settings. Click on **Python
    Interpreter**, as shown in *Figure 3**.15*:'
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 3.15: The interpreter settings show not only your interpreter but
    also a list of packages available to that interpreter](img/B19644_03_15.jpg)'
  id: totrans-154
  prefs: []
  type: TYPE_IMG
- en: 'Figure 3.15: The interpreter settings show not only your interpreter but also
    a list of packages available to that interpreter'
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
- en: The screen shows the interpreter in use for the current project. We saw earlier
    that we can change this environment at any time. Now, we are going to focus on
    the empty package list that takes up most of the screen. This is where you will
    be able to work with packages once we’ve installed them.
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s install the `numpy` package. Start by clicking the `numpy`. As you type,
    you will see a list of packages from PyPI that satisfy your search. Click on the
    `numpy` entry and view the description. It is a good idea to scrutinize the description
    since if you misspell your search term, you might wind up with the wrong packages.
    This is definitely the `numpy` library, so I’ll install it by clicking the **Install
    Package** button at the bottom of the dialog. After a short wait, I’ll see a message,
    shown in *Figure 3**.16* (just above the grayed-out **Install Package** button),
    stating the package was successfully installed:'
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 3.16: The display at the bottom indicates the package was installed
    successfully](img/B19644_03_16.jpg)'
  id: totrans-158
  prefs: []
  type: TYPE_IMG
- en: 'Figure 3.16: The display at the bottom indicates the package was installed
    successfully'
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
- en: Go ahead and close the dialog box to go back to the project settings.
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
- en: Removing third-party libraries in PyCharm
  id: totrans-161
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Next to the `numpy` package, we see a few more buttons near the arrow in *Figure
    3**.17*:'
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 3.17: Tools for managing your package installations](img/B19644_03_17.jpg)'
  id: totrans-163
  prefs: []
  type: TYPE_IMG
- en: 'Figure 3.17: Tools for managing your package installations'
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
- en: You can likely guess what they do. The `pip` can be upgraded to version 23.0.1\.
    Clicking the up arrow will accomplish this. The eye button will show you pre-release
    package versions should you want to try out the bleeding-edge versions of the
    packages.
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 您可能可以猜到它们的作用。`pip`可以升级到版本23.0.1。点击向上箭头即可完成此操作。眼睛按钮会显示预发布包版本，如果您想尝试包的最新版本。
- en: Now that we understand what the UI for package management does, I’d like to
    digress for a moment and talk about something that it does not do well. The present
    release of PyCharm does not have a good way, in my opinion, to work with a `requirements.txt`
    file.
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经了解了包管理UI的功能，我想暂时偏离一下话题，谈谈它做得不好的地方。在我看来，PyCharm当前版本没有很好的方法来处理`requirements.txt`文件。
- en: Using a requirements.txt file
  id: totrans-167
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用requirements.txt文件
- en: 'A best practice in using Python projects is to use a file named `requirements.txt`
    to list the third-party library dependencies for your project. If you’re starting
    your project from scratch, you can generate a `requirements.txt` file using `pip`
    in your terminal with this command:'
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 在使用Python项目时，一个最佳实践是使用名为`requirements.txt`的文件来列出项目的第三方库依赖。如果您是从零开始创建项目，您可以使用终端中的`pip`生成`requirements.txt`文件，命令如下：
- en: '[PRE13]'
  id: totrans-169
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: '*Figure 3**.18* shows an example of the contents of the `requirements.txt`
    file we just generated. You might have to look hard to see it since it is only
    one line long. You can see the package name as well as the version requirements
    for `numpy==1.24.2`. If you are using a different package manager, review the
    specific process for generating your `requirements.txt` file:'
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: '*图3.18*显示了刚刚生成的`requirements.txt`文件的内容示例。您可能需要仔细查看才能看到它，因为它只有一行长。您可以看到包名以及`numpy==1.24.2`的版本要求。如果您使用的是不同的包管理器，请查看生成您的`requirements.txt`文件的具体过程：'
- en: '![Figure 3.18: The contents of a sample requirements.txt file showing the third-party
    dependencies for our project](img/B19644_03_18.jpg)'
  id: totrans-171
  prefs: []
  type: TYPE_IMG
  zh: '![图3.18：显示我们项目第三方依赖关系的示例requirements.txt文件内容](img/B19644_03_18.jpg)'
- en: 'Figure 3.18: The contents of a sample requirements.txt file showing the third-party
    dependencies for our project'
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 图3.18：显示我们项目第三方依赖关系的示例requirements.txt文件内容
- en: If you have cloned an existing project and it has a `requirements.txt` file,
    PyCharm will recognize it when you open the project and offer to install the contents
    to your virtual environment. PyCharm will also monitor your project as you work.
    If you add new dependencies, either through the GUI we’ve discussed or manually
    from the terminal, PyCharm will offer to add those dependencies to your `requirements.txt`
    file automatically.
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您已克隆现有项目并且它包含`requirements.txt`文件，当您打开项目时，PyCharm将识别它，并建议将内容安装到您的虚拟环境中。PyCharm还会在您工作时监控您的项目。如果您添加了新的依赖项，无论是通过我们讨论的GUI还是从终端手动添加，PyCharm都会自动建议将这些依赖项添加到您的`requirements.txt`文件中。
- en: The new Python Packages window
  id: totrans-174
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 新的Python包窗口
- en: 'New to the latest releases of PyCharm which uses the new UI is a **Python Packages**
    window. It adds similar functionality to the interpreter settings window in a
    different location and layout. Clearly, they were reading over my shoulder when
    I wrote earlier about how the Python environment settings being inside the general
    settings window is unintuitive. I doubt I’ll get credit for pointing it out, though.
    You’ll find the new **Python Packages** window in the **More Tool Windows** ellipsis,
    indicated in *Figure 3**.19*:'
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 对于使用最新版本PyCharm（该版本使用新的UI）的用户来说，新增了一个**Python包**窗口。它在不同的位置和布局中添加了与解释器设置窗口类似的功能。显然，他们在我之前提到Python环境设置在通用设置窗口中不够直观时，是在我的肩膀后面阅读的。虽然我怀疑我无法因此获得认可，但您可以在**更多工具窗口**的省略号中找到新的**Python包**窗口，如图*3.19*所示：
- en: '![Figure 3.19: The More Tools menu contains the new Python Packages window](img/B19644_03_19.jpg)'
  id: totrans-176
  prefs: []
  type: TYPE_IMG
  zh: '![图3.19：更多工具菜单包含新的Python包窗口](img/B19644_03_19.jpg)'
- en: 'Figure 3.19: The More Tools menu contains the new Python Packages window'
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 图3.19：更多工具菜单包含新的Python包窗口
- en: 'When you click the **Python Packages** icon, a new window will appear, as seen
    in *Figure 3**.20*:'
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: 当您点击**Python包**图标时，将出现一个新窗口，如图*3.20*所示：
- en: '![Figure 3.20: The new Python Packages window in PyCharm](img/B19644_03_20.jpg)'
  id: totrans-179
  prefs: []
  type: TYPE_IMG
  zh: '![图3.20：PyCharm中的新Python包窗口](img/B19644_03_20.jpg)'
- en: 'Figure 3.20: The new Python Packages window in PyCharm'
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: 图3.20：PyCharm中的新Python包窗口
- en: 'As with the **Environment Settings** window, the **Python Packages** window
    shows a list of packages installed in the virtual environment, along with the
    accompanying version number. There is an **Add Package** button that allows you
    to add a package from PyPI or from a repository. You can search for packages using
    the search dialog, which shows a list of matching packages. Clicking one will
    show the documentation for that package. This is a step up from the **Environment
    Settings** window since this one displays the project’s markdown documentation.
    You can see an example in *Figure 3**.21*:'
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 3.21: Searching for the numpy package in the new Python Package window](img/B19644_03_21.jpg)'
  id: totrans-182
  prefs: []
  type: TYPE_IMG
- en: 'Figure 3.21: Searching for the numpy package in the new Python Package window'
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
- en: As you can see, I’ve searched for a package that was found on PyPI with 184
    matches. I’ve selected the `numpy` package, and PyCharm displays the documentation
    for the project. There’s a nice big **Install package** button and a selector
    to pick the version I’d like to install.
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
- en: 'I can delete an installed package by clicking an installed package in the list.
    The version number is displayed along with the packages’ documentation. Beneath
    the ellipsis next to the installed version number is a **Delete Package** button,
    as seen in *Figure 3**.22*:'
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 3.22: Deleting a package can be done using the menu option beneath
    the ellipsis next to the version number in the Python Package window](img/B19644_03_22.jpg)'
  id: totrans-186
  prefs: []
  type: TYPE_IMG
- en: 'Figure 3.22: Deleting a package can be done using the menu option beneath the
    ellipsis next to the version number in the Python Package window'
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
- en: This feature is so new as I write this that it almost didn’t make it into the
    chapter. I happened to notice it while at work the other day. It presents, in
    my opinion, a less confusing and more convenient way to work with Python packages.
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
- en: Professional features important to virtual environments
  id: totrans-189
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'One major feature of the Professional edition of PyCharm is the ease of project
    creation compared to the more manual approach. Consider the Professional edition’s
    new project window, which has a set of project types, as seen in *Figure 3**.23*:'
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 3.23: The Professional edition lists many project templates in the
    New Project dialog](img/B19644_03_23.jpg)'
  id: totrans-191
  prefs: []
  type: TYPE_IMG
- en: 'Figure 3.23: The Professional edition lists many project templates in the New
    Project dialog'
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
- en: The Community edition of Python does not have any of these project options.
    You can only create pure Python projects, but to be fair, you can still create
    a Flask project or any of the other project types listed using the Community edition.
    However, the IDE isn’t going to help you do it.
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
- en: Let’s look at the steps to create a Flask project. Flask is a library that allows
    us to easily create a dynamic web application. We’ll cover it extensively in [*Chapter
    8*](B19644_08.xhtml#_idTextAnchor203), *Building a Dynamic Web Application in
    Flask*. For now, we’re going to compare the level of work needed to do this without
    the Professional edition (that is, with no IDE at all).
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
- en: 'These are the steps to manually set up the project:'
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
- en: Create a new folder for your project.
  id: totrans-196
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Create a new virtual environment for your project.
  id: totrans-197
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Activate the virtual environment.
  id: totrans-198
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Use your favorite package manager to install the Flask library along with its
    dependencies.
  id: totrans-199
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Create a Python file to hold your starting code.
  id: totrans-200
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Research the web and find an example of a simple “Hello world” sample and put
    that in your Python file.
  id: totrans-201
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Create a script that can set any necessary environment variables such as `PYTHONPATH`,
    then run your program.
  id: totrans-202
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'I’ll bet many of you can do this in about 20-30 minutes, tops. Here’s my problem
    with that: when are you most fired up about your new project idea? It’s at the
    beginning of the project! You are ready to roll but then must stop and spend 30
    minutes doing this tedious setup. It isn’t a lot of time, but it is an interruption.
    There is a chance of hitting some unexpected snags, which can zap your enthusiasm.
    In extreme cases, sometimes, unexpected snags delay you hours or days. PyCharm
    automates the entire process. You step through a couple of dialog screens, usually
    accepting the defaults, and your project is ready in fewer than 30 seconds. You
    can immediately start banging out your idea in code by modifying the starting
    boilerplate generated by the IDE.'
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
- en: The Professional edition will help you generate more complicated projects with
    very little effort on your part. The IDE will create your folder structure, a
    basic set of files with edit prompts to get started, and a virtual environment.
    PyCharm will even install the requirements for you.
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
- en: Importing projects into PyCharm
  id: totrans-205
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Perhaps it goes without saying, but I’m going to say it anyway. You can import
    existing projects created either manually or with another IDE into PyCharm. This
    seems obvious because, after all, it is just a matter of opening a folder on your
    computer. The import process really is as simple as opening a folder in PyCharm.
    However, there’s more to the story than that. PyCharm is your intelligent ally
    when it comes to working on getting a project running on your machine that was
    started, or entirely authored, on another without PyCharm involved. Let’s see
    this in action.
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
- en: 'Within this book’s source code we cloned at the end of [*Chapter 2*](B19644_02.xhtml#_idTextAnchor028),
    *Installation and Configuration*, and within the `chapter-03` folder, there is
    a project that I created entirely from the command line. You can see the process
    I used in *Figure 3**.24*:'
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 3.24: The terminal window I used to create a Python project entirely
    outside of PyCharm](img/B19644_03_24.jpg)'
  id: totrans-208
  prefs: []
  type: TYPE_IMG
- en: 'Figure 3.24: The terminal window I used to create a Python project entirely
    outside of PyCharm'
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
- en: 'The process I followed is clearly shown, as described here:'
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
- en: Within a new project folder called `manually-created`, I created a new virtual
    environment with the `python3 -m venv` `venv` command.
  id: totrans-211
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: I activated the virtual environment with the `source venv/bin/activate` command.
    In this case, I am working in Linux. This same command will work on a Mac. If
    I were using Windows, it would be `.\venv\Scripts\activate`.
  id: totrans-212
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Next, I installed a third-party module called `tqdm`. You can find out more
    at [https://pypi.org/project/tqdm/](https://pypi.org/project/tqdm/). The short
    version of this module is used to easily format the terminal output of a program
    to include a nice-looking progress bar. You can see the blocky progress bar a
    little further down in *Figure 3**.24* after I run the program. I’m getting ahead
    of myself.
  id: totrans-213
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: I used `nano` to add some code to a new file called `main.py`. I’ll show you
    the contents in a moment, but all I did was copy and paste an example from the
    `tqdm` documentation on the [https://pypi.org](https://pypi.org) page I linked
    earlier. If you’re wondering what the `-l` switch does, it displays line numbers
    in the `nano` editor, which makes `nano` a quick, easy-to-use code editor.
  id: totrans-214
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: I ran the program using the `python` `main.py` command.
  id: totrans-215
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Having verified that it all worked, I created a `requirements.txt` file to
    document my program’s dependence on the `tqdm` module. The `pip freeze` command
    will output a dependency graph to the screen. In order to turn that into a text
    file I can include in my Git repository, I piped the output with `> requirements.txt`,
    making the full command look like this:'
  id: totrans-216
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE14]'
  id: totrans-217
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE14]'
- en: This kind of command-line setup work is beneath us. In fact, I recommend you
    celebrate this by buying yourself a new pair of cargo pants and carrying yourself
    with a new air of swagger! If you identify as a non-cargo-pants-wearing sentient
    being, I hope you’ll use your imagination to translate my intent. On second thoughts,
    at the risk of generalizing, you probably should take neither wardrobe nor social
    behavior advice from me. Traditionally, *wardrobe advice* is not my *strong suit*.
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
- en: Warning
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
- en: If this is the first of my books you are reading, one ground rule I keep is
    that all puns are intended.
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
- en: 'Thankfully, working with projects created outside of PyCharm is a strong suit
    of PyCharm. Since the project has already been created outside of PyCharm, let’s
    see what PyCharm makes of it. Let’s open the `chapter-03/manually-created` folder
    in PyCharm. To make things crystal clear, I’m showing you the project’s open dialog
    in *Figure 3**.25*:'
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 3.25: Opening the manually-created project that was created outside
    of PyCharm](img/B19644_03_25.jpg)'
  id: totrans-222
  prefs: []
  type: TYPE_IMG
- en: 'Figure 3.25: Opening the manually-created project that was created outside
    of PyCharm'
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
- en: For this project, I did something I would not usually do. The virtual environment
    (`venv`) folder is included in the git repository. Normally, it shouldn’t be,
    but it needs to be there for you to see the next little bit of magic.
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
- en: 'Open the project folder and watch what happens. If you’re looking for a big
    display of software-empowered awesomeness, it might seem a little underwhelming.
    It isn’t even worthy of a screenshot. The project opened, and it’s just sitting
    there. That’s the cool part. PyCharm can see your virtual environment folder,
    so it automatically sets up your project for you. You can verify all this in your
    project settings, as seen in *Figure 3**.26*:'
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 3.26: The imported project has the correct interpreter settings with
    no effort on our part](img/B19644_03_26.jpg)'
  id: totrans-226
  prefs: []
  type: TYPE_IMG
- en: 'Figure 3.26: The imported project has the correct interpreter settings with
    no effort on our part'
  id: totrans-227
  prefs: []
  type: TYPE_NORMAL
- en: Importing a project cloned from a repository
  id: totrans-228
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Our previous example showed importing a project I created manually on my computer.
    It is more likely you will import a project you’ve cloned from GitHub or some
    other repository. These projects when cloned will not have the virtual environment
    folder present. As such, you have to do a little more work to set up the project.
  id: totrans-229
  prefs: []
  type: TYPE_NORMAL
- en: I’m going to reuse the same project, but I’m going to delete a few files so
    that PyCharm won’t remember anything about the project.
  id: totrans-230
  prefs: []
  type: TYPE_NORMAL
- en: 'First, close the project in PyCharm, as seen in *Figure 3**.27*:'
  id: totrans-231
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 3.27: Closing the project](img/B19644_03_27.jpg)'
  id: totrans-232
  prefs: []
  type: TYPE_IMG
- en: 'Figure 3.27: Closing the project'
  id: totrans-233
  prefs: []
  type: TYPE_NORMAL
- en: 'Next, use your operating system to delete the folders shown in *Figure 3**.28*:'
  id: totrans-234
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 3.28: Deleting the venv and .idea folders to simulate a project you
    might have cloned from a version control system (VCS)](img/B19644_03_28.jpg)'
  id: totrans-235
  prefs: []
  type: TYPE_IMG
- en: 'Figure 3.28: Deleting the venv and .idea folders to simulate a project you
    might have cloned from a version control system (VCS)'
  id: totrans-236
  prefs: []
  type: TYPE_NORMAL
- en: 'We are getting rid of the `venv` folder and the `.idea` folder. The latter
    will be hidden on macOS and Linux systems, so make sure you turn on the ability
    to view hidden folders. The `.idea` folder is the PyCharm project folder, which
    was automatically created when you opened the project folder. With those two folders
    gone, PyCharm is now virtually ignorant of having ever opened the project. The
    folder will still show up in your **Recent** projects folder, but that is OK.
    Open the folder again with PyCharm. The result of opening the project in PyCharm
    is shown in *Figure 3**.29*:'
  id: totrans-237
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 3.29: Importing a project created outside of PyCharm prompts to create
    a virtual environment](img/B19644_03_29.jpg)'
  id: totrans-238
  prefs: []
  type: TYPE_IMG
- en: 'Figure 3.29: Importing a project created outside of PyCharm prompts to create
    a virtual environment'
  id: totrans-239
  prefs: []
  type: TYPE_NORMAL
- en: PyCharm sees the `requirements.txt` file but it can’t find a suitable virtual
    environment because there isn’t a subfolder in the project containing a Python
    executable. PyCharm will prompt you to create an environment for your project.
    In my case, the default is to a local folder called `venv`. It is going to use
    the Python 3.10 executable it found at `/usr/bin/python3.10` as the base for the
    virtual environment, and it sees the `requirements.txt` file. If I hit **OK**,
    PyCharm will set up a virtual environment and then install my dependencies for
    me.
  id: totrans-240
  prefs: []
  type: TYPE_NORMAL
- en: Dealing with invalid interpreters
  id: totrans-241
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'No IDE is perfect. Sometimes, PyCharm can get confused about which virtual
    environment to use. This really only happens when you set up a new project with
    code not created in PyCharm. This is a corner case, but sooner or later, you’re
    going to see it, so I want to spend a minute talking about this scenario. Maybe
    you’re preparing to write a book on PyCharm. OK—that probably mostly happens to
    me. Say you’re preparing a demo. Maybe you are setting up a training session and
    you’ve fiddled around with things a little too much or a few too many times. If
    you are like me, you like things to be perfect. You’ve worked toward setting up
    a project, and you see listings for invalid environments such as the one in *Figure
    3**.30*:'
  id: totrans-242
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 3.30: Invalid interpreter errors happen to the best of us](img/B19644_03_30.jpg)'
  id: totrans-243
  prefs: []
  type: TYPE_IMG
- en: 'Figure 3.30: Invalid interpreter errors happen to the best of us'
  id: totrans-244
  prefs: []
  type: TYPE_NORMAL
- en: Gross! There’s an ugly red message saying the base interpreter is invalid. We
    need to fix this. The good news is you know what to do! First, let’s solve your
    immediate problem. You need to set the base interpreter so that PyCharm can finish
    importing your project. The first thing to try is the drop-down list for the base
    interpreter. In all likelihood, your global Python installation will appear in
    the list. If it does, pick it then click **OK**, and PyCharm will do its thing.
  id: totrans-245
  prefs: []
  type: TYPE_NORMAL
- en: If you can’t find one, you can still make a valid environment. You just need
    to create a virtual environment the same way we did when we were creating our
    project from scratch. You’d need to cancel out of the dialog you’re seeing in
    *Figure 3**.32* and use the project settings to add a new environment.
  id: totrans-246
  prefs: []
  type: TYPE_NORMAL
- en: 'Click **File** | **Settings** to get into the **Settings** dialog and find
    the project settings, as shown in *Figure 3**.31*:'
  id: totrans-247
  prefs: []
  type: TYPE_NORMAL
- en: "![Figure 3.31: The worst-case scenario\uFEFF (it doesn’t happen often, but\
    \ it does happen\uFEFF)](img/B19644_03_31.jpg)"
  id: totrans-248
  prefs: []
  type: TYPE_IMG
- en: 'Figure 3.31: The worst-case scenario (it doesn’t happen often, but it does
    happen)'
  id: totrans-249
  prefs: []
  type: TYPE_NORMAL
- en: This is the worst-case scenario! The list doesn’t show the base interpreter,
    and the only option is our invalid virtual environment. Admittedly, you must work
    hard to get PyCharm to do this, but this usually happens exactly 5 minutes before
    you need PyCharm to work in front of a lot of people. I’m here for you.
  id: totrans-250
  prefs: []
  type: TYPE_NORMAL
- en: 'At the bottom of the drop-down list is the **Show All…** option. This will
    allow us to fix everything! Click it! You’ll see a very useful dialog, shown in
    *Figure 3**.32*:'
  id: totrans-251
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 3.32: The Python interpreters dialog allows you to manage all your
    Python environments in one place](img/B19644_03_32.jpg)'
  id: totrans-252
  prefs: []
  type: TYPE_IMG
- en: 'Figure 3.32: The Python interpreters dialog allows you to manage all your Python
    environments in one place'
  id: totrans-253
  prefs: []
  type: TYPE_NORMAL
- en: Note the arrow in *Figure 3**.32*. You can use the **+** and **–** icons to
    add and remove environments. You can select your invalid environment and remove
    it with the **–** icon. Next, you can add a new, valid environment with the **+**
    icon. The workflow for adding a new interpreter is the same as it was when we
    created one from scratch with a new project. We’ve covered the process already,
    so I won’t go through it again.
  id: totrans-254
  prefs: []
  type: TYPE_NORMAL
- en: Working with run configurations
  id: totrans-255
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Run configurations in PyCharm allow you to set up different ways to run your
    programs from the IDE. The heart of the run configurations is a cluster of blue
    buttons toward the top of the main window. Follow the arrow in *Figure 3**.33*:'
  id: totrans-256
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 3.33: There are several run buttons at the top of the screen along
    with a drop-down list that allows you to work with various run configurations](img/B19644_03_33.jpg)'
  id: totrans-257
  prefs: []
  type: TYPE_IMG
- en: 'Figure 3.33: There are several run buttons at the top of the screen along with
    a drop-down list that allows you to work with various run configurations'
  id: totrans-258
  prefs: []
  type: TYPE_NORMAL
- en: Since we have the `manually-created` project already open from earlier, why
    don’t we continue exploring using that project? That cluster of buttons I pointed
    to in *Figure 3**.33* consists of a **Run** button, a **Debug** button, and a
    dropdown that lets you set and manage your run configurations. When we imported
    the project, it generated a run configuration called **Current File**.
  id: totrans-259
  prefs: []
  type: TYPE_NORMAL
- en: 'With this set in the drop-down menu, the file in the **Focused** tab will be
    executed when you click either the run or debug button:'
  id: totrans-260
  prefs: []
  type: TYPE_NORMAL
- en: This is the regular `main.py` script because that is in the currently focused
    tab.
  id: totrans-261
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: This is the **Run** (debug) button. Clicking this will run your selected run
    configuration with an attached debugger. We’ll see this in action in [*Chapter
    6*](B19644_06.xhtml#_idTextAnchor145), *Seamless Testing, Debugging,* *and Profiling*.
  id: totrans-262
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The ellipsis button contains more options for running a profiler and checking
    your test coverage. We’ll cover these in later chapters.
  id: totrans-263
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The **Run configuration** dropdown lets you select a run configuration. There
    is an option to create and edit existing configurations as well as create new
    ones.
  id: totrans-264
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: For now, let’s focus on the run configurations themselves since these have their
    own environment settings independent from the rest of the project.
  id: totrans-265
  prefs: []
  type: TYPE_NORMAL
- en: 'Click the drop-down menu where it says **Current File** and click **Edit Configurations…**,
    as shown in *Figure 3**.34*. This brings up a dialog for managing your run configurations.
    You can add, edit, and delete your configurations here. Note the Professional
    edition will have more tooling available in this window than will the Community
    edition. I will focus on the Professional edition:'
  id: totrans-266
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 3.34: Adding a new run configuration for our manually-created project](img/B19644_03_34.jpg)'
  id: totrans-267
  prefs: []
  type: TYPE_IMG
- en: 'Figure 3.34: Adding a new run configuration for our manually-created project'
  id: totrans-268
  prefs: []
  type: TYPE_NORMAL
- en: 'There are plenty of prompts in the dialog that allow you to create a new run
    configuration. Let’s ignore those because once you add one, those options will
    go away. Click the **+** icon at the top of the dialog, as shown in *Figure 3**.35*:'
  id: totrans-269
  prefs: []
  type: TYPE_NORMAL
- en: "![Figure 3.35: Clicking the + button to add a new run configuration\uFEFF (the\
    \ list shown is for the Professional edition, and you’ll need to scroll down to\
    \ find the Python item shown\uFEFF)](img/B19644_03_35.jpg)"
  id: totrans-270
  prefs: []
  type: TYPE_IMG
- en: 'Figure 3.35: Clicking the + button to add a new run configuration (the list
    shown is for the Professional edition, and you’ll need to scroll down to find
    the Python item shown)'
  id: totrans-271
  prefs: []
  type: TYPE_NORMAL
- en: If you are running the Professional edition, you’ll see a long list of options,
    as in *Figure 3**.35*. The Community edition list is considerably shorter since
    it only has tooling for pure Python projects.
  id: totrans-272
  prefs: []
  type: TYPE_NORMAL
- en: 'I’m going to pick the Pure Python project type since that’s one we can all
    use. Each option may present a different dialog box with different settings based
    on what is appropriate for your selection. The Pure Python options look like what
    is shown in *Figure 3**.36*:'
  id: totrans-273
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 3.36: The options for a run configuration using the Pure Python template](img/B19644_03_36.jpg)'
  id: totrans-274
  prefs: []
  type: TYPE_IMG
- en: 'Figure 3.36: The options for a run configuration using the Pure Python template'
  id: totrans-275
  prefs: []
  type: TYPE_NORMAL
- en: 'There are a lot of settings here. Let’s review the most important settings
    by the numbers provided in *Figure 3**.36*:'
  id: totrans-276
  prefs: []
  type: TYPE_NORMAL
- en: You should give the run configuration a name. If you don’t, it will default
    to the name of the script. You can use a human-friendly name here; it doesn’t
    have to relate to the running file in any way.
  id: totrans-277
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: This setting is probably the most obvious. It lets you select the script you’d
    like to run. You can browse to it or type the path. You can also change this from
    a script file to a module name by clicking the triangle next to the script path
    text entry box. If you change the setting to run a module, the folder **Browse**
    button will change to an ellipsis, and you’ll be able to browse the modules in
    your program to find the one you’d like to run.
  id: totrans-278
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The `argparse`, you can pass them here. This textbox is fairly interactive.
    Note the **+** icon. Clicking this allows you to invoke some macros available
    in the tool. For example, if you need the path for the current directory, you’ll
    find an option for that in the macro list.
  id: totrans-279
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'These are the environment settings. The default uses the project settings.
    You can set a different virtual environment for your run configurations than for
    your project if you need to test-run your software in different environments.
    You can also set environment variables here without jumping out to your operating
    system. This is handy if you rely on environment variables for your program settings.
    If you use OS-level environment variables for sensitive data such as passwords
    or connection strings, I recommend against setting them here. These settings can
    wind up in the project configuration files, which means they could make it into
    your source repository. There’s nothing worse than realizing your hackathon project
    files contain your personal password or access tokens for your favorite cloud
    provider. `SuperH4xr1337@some-evil-hacker-org.darkweb.net` (*note*: hopefully
    not a real address) loves it when you do this. There are bots that troll GitHub
    looking for this stuff, so be careful. Personally, I use configuration files for
    this using one of the many `env` libraries. I’ll put a link in the *Further reading*
    section if you’re interested in this.'
  id: totrans-280
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: You can set a working directory should any part of your script rely on relative
    file paths.
  id: totrans-281
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: This checkbox controls whether the content roots from your project are injected
    into the `PYTHONPATH` environment variable when you run your program. The `PYTHONPATH`
    environment variable controls where the Python interpreter searches for modules.
    Content roots refer to project structure settings where you define content folders.
    This is generally only used with web projects. A content folder might contain
    images or other static content. The `PYTHONPATH` environment variable. I’ve worked
    on microservice architecture projects where this was useful. Sometimes, you might
    have a module in another project that you need to leverage, but it belongs in
    its own separate project rather than being directly managed in the current project.
    You can set your source roots to include other projects with dependencies, and
    checking this box will make those available to your running program.
  id: totrans-282
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: As you can see, there are a lot of options and ways you can customize the way
    a program is run using PyCharm. If your application has several executable scripts,
    you can set each one up with its own run configuration.
  id: totrans-283
  prefs: []
  type: TYPE_NORMAL
- en: PyCharm’s project files
  id: totrans-284
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Most IDEs have some sort of project file designed to contain project-level settings.
    If you’ve ever used any of Microsoft’s IDEs, you might remember folders such as
    `.vscode` for Visual Studio Code and `.vs` in a Visual Studio project. Java IDEs
    such as NetBeans and Eclipse also use a set of files to contain their project
    settings. PyCharm too has a set of files stored in a folder within each project,
    called `.idea`. This might seem like a strange name until you remember that JetBrains
    began with only one IDE project, IntelliJ IDEA. IntelliJ IDEA garnered a reputation
    for being the best IDE for Java development, bar none. It is so good that Google
    contracted with JetBrains to create Android Studio; a natural fit given Android
    applications are written entirely in Java. All the IDEs from JetBrains have the
    same lineage. They are all descendants of IntelliJ IDEA, and that’s why the project
    folder is called `.idea`. Remember—Windows users will plainly see this folder,
    while on Linux and Mac, any folder name beginning with a dot (`.`) is hidden.
  id: totrans-285
  prefs: []
  type: TYPE_NORMAL
- en: By default, there isn’t anything particularly interesting inside these folders
    should you ever be tempted to try to edit them. In fact, if you were to delete
    them, PyCharm would simply recreate them when you reopen the project.
  id: totrans-286
  prefs: []
  type: TYPE_NORMAL
- en: 'That said, there are options in PyCharm that let you store your run configurations
    within these files, as shown in *Figure 3**.37*:'
  id: totrans-287
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 3.37: You can opt to store run configurations as part of the project
    files in the .idea folder](img/B19644_03_37.jpg)'
  id: totrans-288
  prefs: []
  type: TYPE_IMG
- en: 'Figure 3.37: You can opt to store run configurations as part of the project
    files in the .idea folder'
  id: totrans-289
  prefs: []
  type: TYPE_NORMAL
- en: If you opt to do this, you have the capability to check the `.idea` files into
    your VCS repository and share them with your team. This means everybody will have
    the same configurations, so you might want to have a meeting and standardize your
    project structure so that you’re not stepping on each other.
  id: totrans-290
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  id: totrans-291
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: This chapter was all about setting up your virtual environment for a Python
    project. Each project typically has its own virtual environment. We use virtual
    environments to insulate our projects from the requirements of other projects
    and to keep our global Python installation from becoming polluted with lots of
    global packages that were used for only one project.
  id: totrans-292
  prefs: []
  type: TYPE_NORMAL
- en: A virtual environment is a copy of a Python interpreter along with all supporting
    tools such as a package manager and third-party libraries needed for your project.
    PyCharm has features built in for creating and managing virtual environments.
  id: totrans-293
  prefs: []
  type: TYPE_NORMAL
- en: We first see these tools during the creation of a new project. PyCharm prompts
    us to create a new virtual environment every time. We can also select an existing
    environment if that is appropriate. PyCharm gives us the ability to change the
    virtual environment for the project at any time.
  id: totrans-294
  prefs: []
  type: TYPE_NORMAL
- en: Our virtual environments also house all the third-party libraries needed for
    our project. You can find thousands of ready-made modules at [https://pypi.org](https://pypi.org).
    These modules can be installed and used in your projects by means of a package
    manager. The most common package manager is `pip`, but others exist, such as `conda`,
    `pipenv`, and `poetry`. PyCharm supports all of these tools, and you are afforded
    the opportunity to select your tool of choice when you create your virtual environment.
  id: totrans-295
  prefs: []
  type: TYPE_NORMAL
- en: Having selected your package manager, PyCharm has a GUI that allows you to see,
    add, remove, and update your library dependencies from PyPI. You’ll find this
    GUI within your project settings, which are bundled inside the general settings
    for PyCharm itself.
  id: totrans-296
  prefs: []
  type: TYPE_NORMAL
- en: PyCharm can easily import projects created outside of PyCharm. All you need
    to do is open the folder where the code resides. PyCharm creates a set of project
    files within that folder called `.idea`, then prompts you to set an interpreter
    if it couldn’t find one within the project folder. PyCharm will also look for
    a `requirements.txt` file and offer to install your dependencies for you.
  id: totrans-297
  prefs: []
  type: TYPE_NORMAL
- en: When you are ready to run some code within the IDE, PyCharm offers a powerful
    run system that uses run configurations created in the GUI. PyCharm Professional
    ships with many project types, and each one has its own run configuration settings.
    We covered the extensive settings found in a pure Python project since that is
    available to Community edition users. The run configuration can manage—and in
    some cases mimic—a wide gamut of settings you would normally have to set manually
    at the operating system level.
  id: totrans-298
  prefs: []
  type: TYPE_NORMAL
- en: All totaled, PyCharm gives you a very complete set of tools for managing virtual
    environments for development and running your code. In the next chapter, we’ll
    switch our focus to the primary tools you’ll use every day to manage, write, and
    edit your code.
  id: totrans-299
  prefs: []
  type: TYPE_NORMAL
- en: Questions
  id: totrans-300
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: What are virtual environments and why are they important?
  id: totrans-301
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: What are the tools used by the Python community to create virtual environments?
  id: totrans-302
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Which virtual environment tools are supported in PyCharm?
  id: totrans-303
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Can a run configuration use a different virtual environment from the main project?
    How might this be useful?
  id: totrans-304
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Where does PyCharm keep its project configuration files?
  id: totrans-305
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Further reading
  id: totrans-306
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '*Alternative Python* *Implementations*: [https://www.python.org/download/alternatives/](https://www.python.org/download/alternatives/)'
  id: totrans-307
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`The env` library: [https://pypi.org/project/env/](https://pypi.org/project/env/)'
  id: totrans-308
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*Ajitsaria*, *A.* *What is the Python Global Interpreter Lock (**GIL)?*: [https://realpython.com/python-gil/](https://realpython.com/python-gil/)'
  id: totrans-309
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Be sure to check out the companion website for the book at [https://www.pycharm-book.com.](https://www.pycharm-book.com.)
  id: totrans-310
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
