- en: Chapter 7. Scripting for Rendering
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In this chapter, we''ll be looking at the following topics:'
  prefs: []
  type: TYPE_NORMAL
- en: Creating and editing lights
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Creating GUI to control all lights
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Creating cameras from code
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Rendering a sprite sheet
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Introduction
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: So far, we've looked at ways scripting can help with modeling, texturing, rigging,
    and animation. Once all of that is done, all that's left is to actually render
    out your scene. In this chapter, we'll be looking at how to set up lights and
    cameras, as well as how to render out scenes.
  prefs: []
  type: TYPE_NORMAL
- en: Creating and editing lights
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this example, we'll be building a script to quickly and easily set up a simple
    three-point lighting setup via script.
  prefs: []
  type: TYPE_NORMAL
- en: This will end up providing us with a nice overview of creating different types
    of lights with script, as well as leaving us with a handy tool.
  prefs: []
  type: TYPE_NORMAL
- en: '![Creating and editing lights](img/4657_07_01.jpg)'
  prefs: []
  type: TYPE_IMG
- en: The result of running the script-key, fill, and back lights all pointed at the
    origin
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: For best results, make sure that you have an object with a decent level of detail
    in your scene before running the script.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Create a new file and add the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: Run the preceding code, and you'll see that you're left with three lights created—two
    spotlights and one directional light.
  prefs: []
  type: TYPE_NORMAL
- en: How it works...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'We''ll be creating three lights—two spotlights and one directional light. To
    simplify the positioning, we''ll create a few helper variables:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: 'The `offsetAmount` variable will be the amount by which each of the lights
    is moved away from the origin, and `lightRotation` will control the amount by
    which the lights are rotated. Next, we create the first of our lights—the key
    light:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: Creating the light is easy enough; we just call the `spotLight` command. While
    we're at it, we'll use the `rgb` flag to set the color of the light (full intensity
    white), and we'll set the name to easily identify the light later. We store the
    result to a `newLight` variable.
  prefs: []
  type: TYPE_NORMAL
- en: 'One slight complication arises in that the light creation command returns the
    name of the shape node, rather than the transform. Because setting up the position
    and rotation requires making changes to the transform, we''ll use the `listRelatives`
    command to grab the associated transform node:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: 'As we''ve seen in previous examples, we have to account for the fact that the
    `listRelatives` command always returns a list of nodes, even if there''s at most
    one possible node (as is the case with the parent flag). We store the first entry
    to a variable that we''ll use to identify our light for the rest of the script:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: 'At this point, we''ve created the first of our three lights. We''ll do the
    exactly same thing to create a second spotlight for our fill light, with the only
    difference is that we start it off with something a bit less than full white:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: 'Finally, we set up our back light. We start it out with a dark gray light,
    and we create a directional light rather than a spot:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: 'Now that we have all of our lights created, we''re ready to set their positions
    and rotations to give us a nice default three-light setup. To do this, we''ll
    be taking the following steps for each light:'
  prefs: []
  type: TYPE_NORMAL
- en: Move the light a set distance away from the origin along the z-axis.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Move the light's rotational pivot back to the origin.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Set the light's rotation to give us the position we want.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: We could also calculate the light positions directly using some trigonometry,
    but having the lights each rotate around the origin will not only make the script
    more straightforward, but will also make it easier to change after creation.
  prefs: []
  type: TYPE_NORMAL
- en: 'First off, we move the light along the z-axis:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: 'Once we''ve done this, we want to move the rotate pivot back to the origin.
    We''ll use the move command for that as well:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: Note that we append `.rotatePivot` to the name of the light so that we move
    just the pivot and not the light itself. Also note that we're moving it to (0,0,0).
    This will end up giving us what we want because the move command defaults to absolute
    coordinates. So, moving by (0,0,0) is actually telling Maya to move the object
    in question to the origin.
  prefs: []
  type: TYPE_NORMAL
- en: 'Once we''ve done it, we can use the rotate command to rotate the light in question
    around the origin. For the key light, we''ll rotate it around the *x*-axis to
    move it up and around the *y-*axis to move it to the right. Note that we negate
    the value for the *x*-axis so that the light is rotated counter-clockwise rather
    than clockwise around the *x*-axis. This will ensure that the light moves up,
    rather than down, relative to the *X*-*Z* plane:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: 'We repeat the preceding code two more times to set up our fill and back lights
    with default positions:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: 'The fill light is rotated around the *x*-axis by the same amount as the key
    light, but in the opposite direction around the *y*-axis:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: And the back light is rotated around the *x*-axis by 180 degrees (to place it
    behind the origin) plus our `lightRotation` value to move it above the origin.
  prefs: []
  type: TYPE_NORMAL
- en: At this point, we have three lights with default settings and positions, but
    we'll want to make the entire rig easier to manipulate. To do this, we'll create
    a new transform node and add all three lights as children.
  prefs: []
  type: TYPE_NORMAL
- en: 'To create the new transform node, we''ll use the group command with the `empty`
    flag, to allow us to create an empty group. We''ll also be sure to set the base
    name with the name flag:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: 'Once we''ve done this, we use the parent command to make all three lights the
    children of the `LightRig` node:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: 'As a final touch, we make sure that we have the parent node selected, with
    a call to select, with the `replace` option:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: It's always a good practice, when creating new nodes or groups of nodes, to
    leave the newly created object(s) selected at the end of your script so that the
    end user can easily make further changes as necessary (such as moving the entire
    rig around).
  prefs: []
  type: TYPE_NORMAL
- en: There's more...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'In this example, we set the color of the lights to different values to make
    the fill and back lights have less of an effect. Alternatively, we could set all
    of the lights to be a single color and use the intensity to provide variation.
    This might end up looking like the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: 'The preceding code would give us three lights that are all white, but at varying
    intensities. If you want to set the intensity of a light after creating it, you
    can do so with the `setAttr` command. For example, if we wanted to change the
    intensity of `keyLight` after the fact, we could do the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: One nice possible addition to the script might be to better account for varying
    scales of geometry. In the current version, we can use the scale of that parent
    group to increase or decrease the spacing of the lights. A slightly better way
    would be to pass in a value for the offset amount to our function. We could also
    pass in a value for the rotation amount to support a wider range of use cases.
  prefs: []
  type: TYPE_NORMAL
- en: 'Doing this would lead us to take the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: 'It will be changed to:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: Creating GUI to control all lights
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Most scenes will end up containing multiple lights, and controlling them all
    can get to be a real hassle. In this example, we'll be creating GUI that will
    present the user with an easy way to control the colors of all the lights in the
    scene.
  prefs: []
  type: TYPE_NORMAL
- en: 'Running the script with three lights in the scene would result in something
    like the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Creating GUI to control all lights](img/4657_07_02.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Getting ready
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Make sure that you have at least a few lights in your scene. Alternatively,
    use the three-point lighting example above to quickly set up a system of lights.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Create a new file and add the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: Run the preceding script, and you'll get a new window with a control for each
    light in the scene. The control will provide both a color swatch and a slider,
    and changing it will cause the relevant light's color to update.
  prefs: []
  type: TYPE_NORMAL
- en: How it works...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The first thing to note is that we''re adding a second `import` statement:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: The `functools` library provides capabilities to create functions and work with
    them as variables. This will come in handy later when we're wiring up our controls.
  prefs: []
  type: TYPE_NORMAL
- en: The next thing to note is that we're once again setting up a proper class for
    this example. Because we're going to need to maintain a list of all the lights
    in the scene (as well as a list of the controls for each one), wrapping our script
    in a proper class is the best way to go.
  prefs: []
  type: TYPE_NORMAL
- en: 'Having said this, let''s move onto our `__init__` function. We start off by
    initializing some member variables—one to hold a list of lights, one to hold a
    list of controls, and one to help us link the proper light to the proper control:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: 'We then perform our boilerplate initialization work for a new window—creating
    a window, setting its title, and adding a column layout. Before we create the
    window, we first delete the previous one (if it exists):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: 'Once we''ve done this, we create our window, being sure to pass in the same
    name we checked for:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: 'Now we''re ready to set up our controls. We''ll need to create one for each
    light in the scene, which means we first have to get a list of all the lights.
    Luckily for us, the ls command makes that easy. All we have to do is to set the
    `lights` flag to `true`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: Note that there are a few different flags (`lights`, `cameras`, and `geometry`)
    that can be used with the `ls` command to grab specific types of objects. If you
    want to grab nodes of a type that doesn't have a specific flag, you can do that
    too; just use either the `type` or `exactType` flags and specify the type of node
    you're looking for.
  prefs: []
  type: TYPE_NORMAL
- en: Once we have a list of all the objects in the scene, we run through the list
    and create a control for each one, using our `createLightControl` method, which
    we'll get to next.
  prefs: []
  type: TYPE_NORMAL
- en: 'Once all the controls have been created, we show the window to the user:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: 'Before we dive into actually creating our controls, we''ll need to have a function
    that can be used to update a given light to the color in a given slider. For that,
    we create the following function:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: The function looks like it takes three arguments, but only one really matters.
    First, since we're building this script as a class, we have to account for the
    fact that Python will pass the class instance to every member function, which
    we do with the self argument. Next is the thing we actually care about, in this
    case, an integer representing which control/light to work with. Finally, we have
    a catch-all in `*args`.
  prefs: []
  type: TYPE_NORMAL
- en: Using `*args` will provide a way to grab a variable number of arguments into
    a single array. This is necessary, as many UI controls will pass extra data to
    functions that they call. We don't actually want to make use of that in this case,
    but if we left out the `*args`, we would end up with Maya passing three arguments
    in to a function that only takes two, generating an error.
  prefs: []
  type: TYPE_NORMAL
- en: 'The argument that we *do* care about, `lightID`, tells us which light/control
    to work with. Both the lights and the controls are stored in class member variables—`self.lights`
    and `self.lightControls`. In order to set a given light to a given slider, we
    have to first get the current value of the slider by running the `colorSliderGrp`
    command in query mode, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: Note that we pass in an entry in our `self.lightControls` array to specify the
    control, we run the command in query mode, and we set the `rgb` flag to `True`
    to tell Maya that it's the specific attribute that we're querying.
  prefs: []
  type: TYPE_NORMAL
- en: Once we've done it, we use `setAttr` to set the color of the corresponding light
    to the given red, green, and blue values. We'll use `setAttr` to do that, but
    we'll need to make sure that we specify the type because we'll be using multiple
    values.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: 'Okay, so at this point, we have a function that we can call to update a given
    light to the current color value of a given slider. So, if we were to call the
    function, we would set the first light to the current color of the first slider:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: That's a big part of what we need, but we'll want to make sure that this gets
    called every time a slider's value is changed.
  prefs: []
  type: TYPE_NORMAL
- en: 'On to creating an individual control. We create a function that takes a given
    light and does the following:'
  prefs: []
  type: TYPE_NORMAL
- en: Stores a reference to the light so we can later alter its properties
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Creates a new `colorSliderGrp` control for the light
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The function will pass the light we want to create a control for, and we''ll
    once again need to account for the fact that Python passes in the class instance
    itself, giving us the following function signature:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: 'Within the function, we''ll start out by grabbing the transform node associated
    with the light. That''s not strictly necessary because the node that we''ll want
    to alter (to set color) is the actual shape node. However, it''s a lot nicer to
    have our controls labeled something like `Key Light` rather than `keyLightShape`.
    Grabbing the transform is done in the same way that we did it in the previous
    example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: 'Before we create the control, there are a few things we''ll want to do first.
    We''ll want to make sure that the `colorSliderGrp` starts out with the same color
    value as the light. To do it, we''ll need to grab the light''s current color with
    the `getAttr` (get attribute) command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: The `getAttr` command is a real workhorse, and (as is the case with many other
    commands) it always returns an array because some of the uses to which it can
    be put will return multiple values. What's a bit surprising about its behavior
    in this specific case is that we'll end up with a one-element array, with that
    one element being itself a three-element list of the red, green, and blue values.
    So, when we make use of the color variable, we'll need to use `color[0]`, instead
    of (as you would likely suspect) just `color`.
  prefs: []
  type: TYPE_NORMAL
- en: The next thing that we'll want to do is to create the function that gets called
    when the slider has its value changed. In the case of a `colorSliderGrp` control,
    this includes both moving the slider or clicking on the color swatch to select
    a color. In either case, we'll want to respond by running some code to update
    our light's color value.
  prefs: []
  type: TYPE_NORMAL
- en: Here's where it gets tricky because the function we call will need to be aware
    of the specific UI control to grab data from, as well as the specific light to
    apply changes to.
  prefs: []
  type: TYPE_NORMAL
- en: We'll create the slider with the `colorSliderGrp` command, which provides a
    flag, `changeCommand`, which can be used to specify a command that should be run
    every time the slider's value changes.
  prefs: []
  type: TYPE_NORMAL
- en: 'If we wanted the slider to run a function that took zero arguments when it
    changes, we could do the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: 'However, in this case, we want to call our `updateColor` function, while passing
    in an integer to specify which light/control to update. You might be tempted to
    do something like the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs: []
  type: TYPE_PRE
- en: Unfortunately, it's not quite that simple. The preceding code would cause Python
    to actually run the `updateColor` function at the time we create the control.
    As a result, the actual value of the `changeCommand` flag would be whatever the
    return value of self.`updateColor` is (in this case, `None`).
  prefs: []
  type: TYPE_NORMAL
- en: 'That''s where the partial command, included in the `functools` library, comes
    in. We can use the `partial` function to create a copy of a function with specific
    arguments baked in. It''s almost as if we had written a separate function for
    each light and slider combo. We''ll use the `partial` command to create a copy
    of our `self.updateColor` command, with a number representing the current light
    baked in, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs: []
  type: TYPE_PRE
- en: 'The first argument to partial is a function. Note the lack of parentheses after
    `self.updateColor`, indicating that we''re making use of the function itself,
    rather than running it. After the function, we can pass in one or more arguments
    to bind to the function. For example, if we had the following function:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs: []
  type: TYPE_PRE
- en: 'And we used partial in the following way:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE37]'
  prefs: []
  type: TYPE_PRE
- en: The value of `newFunction` would itself be a new function with exactly the same
    behavior as if we had called `printANum(23)`.
  prefs: []
  type: TYPE_NORMAL
- en: 'So, at this point in the script, our `changeCommandFunc` variable holds a new
    function that will have identical behavior to calling our `updateColor` function
    with a specific input. With this, we''re ready to create our slider:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE38]'
  prefs: []
  type: TYPE_PRE
- en: We use our `lightName` variable to label the slider and pass in our color variable
    (note the `[0]`, since it's an array) to make sure that the slider starts with
    the current color of the light.
  prefs: []
  type: TYPE_NORMAL
- en: 'We''re almost done, except for a bit of bookkeeping. We''ll want to make sure
    that we maintain references to both the slider and the light to which it corresponds.
    To do this, we insert the light''s shape node (originally passed in to the `createLightControl`
    function) into the class member variable, lights. We also insert the newly created
    slider into the `lightControls` list:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE39]'
  prefs: []
  type: TYPE_PRE
- en: 'Finally, we increment our `lightNum` variable by one so that the next time
    through the function, we''ll pass the correct value into the `partial` command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE40]'
  prefs: []
  type: TYPE_PRE
- en: 'And that''s it! We''re done creating our class, and finish off our script with
    a command to create an instance:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE41]'
  prefs: []
  type: TYPE_PRE
- en: There's more...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'In this example, we created controls to alter the color of the lights in the
    scene. It''s likely that you would also want to control the intensity of the lights
    as well. That could be done easily enough by creating an additional control (likely
    either `floatField` or `floatSlider`) in the `createLightControl` function. Either
    way, you would want to:'
  prefs: []
  type: TYPE_NORMAL
- en: Create a separate class member variable to hold references to the intensity
    controls.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Make sure that changing the value on the intensity slider also calls the `updateColor`
    function.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: In the `updateColor` function, make sure that you grab the current value of
    the control and use it to set the intensity of the light with the `setAttr` command.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Creating cameras from code
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this example, we'll be looking at how to use code to create cameras. We'll
    create a collection of four orthographic cameras, suitable for use in rendering
    out multiple views of an object for use as assets for an isometric game.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Isometric games have a long history and are characterized by using 2D assets
    to create a three-quarters overhead view of a game environment. This approach
    was very common before full 3D games became the norm, and it still shows up often
    in web and mobile games. Creating assets for isometric games often means rendering
    out a view for each side of an object and making sure that there is no perspective
    distortion in the rendering, which is exactly what we'll be doing in this example.
  prefs: []
  type: TYPE_NORMAL
- en: '![Creating cameras from code](img/4657_07_03.jpg)'
  prefs: []
  type: TYPE_IMG
- en: The result of the script-four orthographic cameras, all pointed at the origin
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: For best results, make sure that you have some geometry in your scene, placed
    at the origin.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Create a new file and add the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE42]'
  prefs: []
  type: TYPE_PRE
- en: Run the script, and you should have four isometric cameras, all looking at the
    origin.
  prefs: []
  type: TYPE_NORMAL
- en: How it works...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Making a camera is easy enough; all we need to do is to use the `camera` command.
    However, there's no direct way to create a camera and aim setup with code. Instead,
    we have to manually create an aim constraint for each of the cameras we create.
  prefs: []
  type: TYPE_NORMAL
- en: We start our script by creating a locator to serve as the target for the aim
    constraint.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE43]'
  prefs: []
  type: TYPE_PRE
- en: The locator will be positioned at the origin by default, which is fine for our
    purposes. Now that we have an aim object, we're ready to create our cameras. We
    kick off a for loop to create four cameras, one for each of the diagonal directions.
  prefs: []
  type: TYPE_NORMAL
- en: 'Actually, creating the camera is simple; we just call the `camera` command.
    In this case, we''ll want to have orthographic cameras, so we''ll set the `orthographic`
    flag to `true`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE44]'
  prefs: []
  type: TYPE_PRE
- en: Next, we'll set up the aim constraint. To create an aim constraint, we need
    to pass in two transform nodes, with the first being the target and the second
    being the one that will have its rotations controlled. Note that because both
    the `spaceLocator` and `camera` commands return two nodes (one transform, one
    shape), we'll need to specify the first index of the variables we used to hold
    the results.
  prefs: []
  type: TYPE_NORMAL
- en: '![How it works...](img/4657_07_04.jpg)'
  prefs: []
  type: TYPE_IMG
- en: A default camera, pointed down the negative z-axis
  prefs: []
  type: TYPE_NORMAL
- en: We'll also want to make sure that our cameras look down their axis at the locator
    by setting the proper aim vector. Because the default position of a camera will
    have it looking along the z-axis in the negative direction, we'll want to use
    (0, 0, -1) as the aim vector.
  prefs: []
  type: TYPE_NORMAL
- en: 'Putting this all together gives us the following line to create the `aim` constraint:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE45]'
  prefs: []
  type: TYPE_PRE
- en: Now we just need to move the camera to the proper location. Because the aim
    constraint will take care of the rotations, all we have to worry about is the
    position. In this case, we want to make sure that each camera lies on a line that
    is some multiple of 45 degrees from the origin. To do this, we'll want to make
    sure that the *X* and *Z* positions have the same magnitude, with only the signs
    changing from camera to camera.
  prefs: []
  type: TYPE_NORMAL
- en: 'First off, we''ll create variables for each of the x, y, and z positions, with
    the `ypos` variable being set to a default value:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE46]'
  prefs: []
  type: TYPE_PRE
- en: 'For X and Z, we''ll want to have values for each of the four quadrants- (+,+),
    (+,-), (-,-), and (-,+). To do this, we''ll have one of the values be negative
    when our index is odd, and the other be negative when the index is greater than
    or equal to `2`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE47]'
  prefs: []
  type: TYPE_PRE
- en: Note that we're making use of the `offset` variable, which was set outside of
    the loop.
  prefs: []
  type: TYPE_NORMAL
- en: Having done this, we use the `move` command to position the camera at the proper
    location.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE48]'
  prefs: []
  type: TYPE_PRE
- en: And with this, we're done!
  prefs: []
  type: TYPE_NORMAL
- en: There's more...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In this example, we created an `aim` constraint to replicate the behavior that
    one gets when creating a *Camera and Aim* from Maya's UI. The nice thing about
    this is that we can move the locator in order to change the look at location.
  prefs: []
  type: TYPE_NORMAL
- en: 'If all we wanted was to have the camera look at a given location though, we
    could do it with the `viewPlace` command, which can both move a camera and rotate
    it to look at a given location. For example, if we wanted to have a camera positioned
    at (5,6,5) and looking at a point slightly above the origin (let''s say 0,2,0),
    we could do the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE49]'
  prefs: []
  type: TYPE_PRE
- en: We also only scratched the surface of what can be done when creating cameras;
    you'll often want to set things such as the near/far clip planes, depth of field,
    and so on. You can either set such things directly on creation or use `setAttr`
    to alter them after the fact. For more details, be sure to consult the documentation
    for the `camera` command.
  prefs: []
  type: TYPE_NORMAL
- en: Rendering a sprite sheet
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this example, we'll be building a tool to render out multiple views of an
    object to a single image. This could be used to create a sprite sheet for use
    in an isometric game.
  prefs: []
  type: TYPE_NORMAL
- en: In the course of the example, we'll use both Maya's Python library (to render
    out frames) and the **Python Imaging Library** (**PIL**) to combine them into
    a single image.
  prefs: []
  type: TYPE_NORMAL
- en: '![Rendering a sprite sheet](img/4657_07_05.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Four views rendered out and combined into a single image
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Make sure that you have an object in your scene and it is at the origin. Also
    make sure that you have some number of cameras set up. You can either do it manually,
    or refer to the previous example on how to create cameras from script.
  prefs: []
  type: TYPE_NORMAL
- en: You'll also want to make sure that you have PIL installed on your system. The
    best way to do that is to grab Pillow (a fork of PIL). More information on Pillow
    can be found at [http://pillow.readthedocs.io/en/3.2.x/](http://pillow.readthedocs.io/en/3.2.x/).
  prefs: []
  type: TYPE_NORMAL
- en: In order to install Pillow in a (relatively) painless way, you'll probably want
    to grab PIP, which is a robust package manager for Python. For more information
    on PIP, check [https://pypi.python.org/pypi/pip](https://pypi.python.org/pypi/pip).
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Create a new file and add the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE50]'
  prefs: []
  type: TYPE_PRE
- en: Run the script, and you should get a new image, named `frames.tga` in the `images`
    directory of your project folder, containing a view from each of the (nonstandard)
    cameras. If you haven't set up a project, the images will be in the default project
    directory. If you want them to be in a specific location, be sure to set your
    project before running the script.
  prefs: []
  type: TYPE_NORMAL
- en: How it works...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'First off, we''re importing a few additional libraries to make the script work.
    First is the `os` library, to let us combine paths and file names in a safe, cross-platform
    way. Then, we also import the Image module from PIL, which we''ll use to create
    our combined image:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE51]'
  prefs: []
  type: TYPE_PRE
- en: 'Next, we define a couple of variables that we''ll use to set the size of our
    rendered images. We''ll use that both to set the render size, as well as to calculate
    the size of the combined image:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE52]'
  prefs: []
  type: TYPE_PRE
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Note that the variables are all caps, that is by no means necessary. Capitalized
    variables are often used to indicate constants that are used in multiple places
    and don't vary during the course of a script. The dimensions of the frames to
    render are a good example of that kind of variable, so I've given them all-caps
    names, but feel free to use a different style if you so choose.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now we''re ready to get started rendering out images. To do it, we''ll want
    to first get a list of all the cameras in our scene, then filter out the default
    views. We *could* use the ls command to do it, but it''s easier to use the `listCameras`
    command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE53]'
  prefs: []
  type: TYPE_PRE
- en: To ignore the default camera views, we'll start by creating a new (empty) list,
    then running through our `allCams` list. Each camera that is *not* in the list
    of defaults gets added, leaving us with a handy list of all the nondefault cameras
    in the scene.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE54]'
  prefs: []
  type: TYPE_PRE
- en: 'At this point, we have a list of all the cameras that we''ll want to render
    out. Before we render anything, we''ll want to make sure that we''re rendering
    the proper image format. In this case, we''ll render out Targa files because they''re
    both uncompressed and include an alpha channel:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE55]'
  prefs: []
  type: TYPE_PRE
- en: To set the image type, we use the `setAttr` command, but the value is less clear
    than we might like. It just so happens that the `targa` format happens to correspond
    to 19\. Other common formats include JPG (8), PNG (32), and PSD (31). To check
    the value of any given format, open the render globals window, select the desired
    format from the dropdown, and observe the output in the script editor.
  prefs: []
  type: TYPE_NORMAL
- en: 'Before we start rendering our images, we''ll want to use PIL to create a larger
    image to hold all of the frames. We''ll create a single image that has the same
    height as our render size and a width equal to the render width multiplied by
    the number of cameras. We''ll also set up the image to default to black:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE56]'
  prefs: []
  type: TYPE_PRE
- en: Note that we pass in `RGBA` to set the image mode to full color plus alpha.
    With our base image created, we're ready to run through our cameras and render
    each frame.
  prefs: []
  type: TYPE_NORMAL
- en: 'For each camera, we''ll want to:'
  prefs: []
  type: TYPE_NORMAL
- en: Render the current view at our specified width and height
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Paste the rendered image into the combined image
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'To render out a given view, we use the `render` command with three arguments-the
    camera to render from, followed by the width and the height for the rendered image:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE57]'
  prefs: []
  type: TYPE_PRE
- en: We store the result of the `render` command into a result variable for later
    use. It's important to note that the output isn't the image itself, but rather
    the path to the image (something like `/Documents/maya/projects/default/images/tmp/MyScene.tga`).
  prefs: []
  type: TYPE_NORMAL
- en: 'Now that we''ve rendered out the image, we''ll want to use PIL to create the
    second `Image` object from the specified path:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE58]'
  prefs: []
  type: TYPE_PRE
- en: 'We use `Image.open` instead of `Image.create` because we want to create an
    image from a given file, rather than a new blank image. Finally, we copy the new
    image into our combined image with the `paste` command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE59]'
  prefs: []
  type: TYPE_PRE
- en: PIL's paste command allows one image to be pasted into another at a specific
    location. In this case, we call it on our `fullImage` image and pass in the image
    we just rendered out (`tempImg`), as well as a tuple for the location. The *Y*
    location is locked to `0` in all cases, and the *X* location is set to `FRAME_WIDTH`
    multiplied by the loop index so that our images are placed in an orderly horizontal
    line.
  prefs: []
  type: TYPE_NORMAL
- en: 'Once we''ve finished that loop, we''re ready to save out the combined image.
    There are any number of places we could put it, but it probably makes sense to
    put it somewhere in our project directory. To do that, we''ll need to first grab
    the current project directory using the `workspace` command in the query mode
    as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE60]'
  prefs: []
  type: TYPE_PRE
- en: 'Where you save the image is up to you, but in this case, I decided to go with
    saving it out as `frames.tga` in the `images` folder of the project directory.
    We could build up the path by adding strings, but using Python''s `os` library
    to join the path guarantees that our script will have better cross-platform support:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE61]'
  prefs: []
  type: TYPE_PRE
- en: 'Finally, we call `Image.save` on our `fullImage` variable and pass in the path
    we just created:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE62]'
  prefs: []
  type: TYPE_PRE
- en: There's more...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Although there is certainly a wide range of options offered by Maya's rendering
    capabilities, some things may be easier to achieve by postprocessing after the
    fact. The PIL is quite powerful and well worth digging into. If you ever find
    yourself needed to perform 2D operations on your renders, it's quite possible
    that doing so with the PIL could be a good choice.
  prefs: []
  type: TYPE_NORMAL
- en: This script, or something like it, could easily be used to build a robust asset
    pipeline for an isometric game. You could easily add the ability to send the combined
    image to a central server along with metadata on the particular structure or object.
    We'll look at sending data across the Web in [Chapter 9](ch09.html "Chapter 9. Communicating
    with the Web"), *Communicating with the Web*.
  prefs: []
  type: TYPE_NORMAL
- en: See also
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: PIL is capable of a great deal more than what we used it for in this example.
    For more details, you'll want to dig into the documentation on *effbot.org* ([http://effbot.org/imagingbook/pil-index.htm](http://effbot.org/imagingbook/pil-index.htm)).
  prefs: []
  type: TYPE_NORMAL
