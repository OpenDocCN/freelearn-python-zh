- en: Chapter 7. Scripting for Rendering
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In this chapter, we''ll be looking at the following topics:'
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
- en: Creating and editing lights
  id: totrans-2
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Creating GUI to control all lights
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Creating cameras from code
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Rendering a sprite sheet
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Introduction
  id: totrans-6
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: So far, we've looked at ways scripting can help with modeling, texturing, rigging,
    and animation. Once all of that is done, all that's left is to actually render
    out your scene. In this chapter, we'll be looking at how to set up lights and
    cameras, as well as how to render out scenes.
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
- en: Creating and editing lights
  id: totrans-8
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this example, we'll be building a script to quickly and easily set up a simple
    three-point lighting setup via script.
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
- en: This will end up providing us with a nice overview of creating different types
    of lights with script, as well as leaving us with a handy tool.
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
- en: '![Creating and editing lights](img/4657_07_01.jpg)'
  id: totrans-11
  prefs: []
  type: TYPE_IMG
- en: The result of running the script-key, fill, and back lights all pointed at the
    origin
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  id: totrans-13
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: For best results, make sure that you have an object with a decent level of detail
    in your scene before running the script.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  id: totrans-15
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Create a new file and add the following code:'
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  id: totrans-17
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: Run the preceding code, and you'll see that you're left with three lights created—two
    spotlights and one directional light.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
- en: How it works...
  id: totrans-19
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'We''ll be creating three lights—two spotlights and one directional light. To
    simplify the positioning, we''ll create a few helper variables:'
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  id: totrans-21
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'The `offsetAmount` variable will be the amount by which each of the lights
    is moved away from the origin, and `lightRotation` will control the amount by
    which the lights are rotated. Next, we create the first of our lights—the key
    light:'
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  id: totrans-23
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: Creating the light is easy enough; we just call the `spotLight` command. While
    we're at it, we'll use the `rgb` flag to set the color of the light (full intensity
    white), and we'll set the name to easily identify the light later. We store the
    result to a `newLight` variable.
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
- en: 'One slight complication arises in that the light creation command returns the
    name of the shape node, rather than the transform. Because setting up the position
    and rotation requires making changes to the transform, we''ll use the `listRelatives`
    command to grab the associated transform node:'
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  id: totrans-26
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'As we''ve seen in previous examples, we have to account for the fact that the
    `listRelatives` command always returns a list of nodes, even if there''s at most
    one possible node (as is the case with the parent flag). We store the first entry
    to a variable that we''ll use to identify our light for the rest of the script:'
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  id: totrans-28
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'At this point, we''ve created the first of our three lights. We''ll do the
    exactly same thing to create a second spotlight for our fill light, with the only
    difference is that we start it off with something a bit less than full white:'
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  id: totrans-30
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'Finally, we set up our back light. We start it out with a dark gray light,
    and we create a directional light rather than a spot:'
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  id: totrans-32
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'Now that we have all of our lights created, we''re ready to set their positions
    and rotations to give us a nice default three-light setup. To do this, we''ll
    be taking the following steps for each light:'
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经创建了所有灯光，我们准备设置它们的位置和旋转，以获得一个漂亮的默认三灯光设置。为此，我们将为每个灯光执行以下步骤：
- en: Move the light a set distance away from the origin along the z-axis.
  id: totrans-34
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 沿着 z 轴将灯光移动到离原点一定的距离。
- en: Move the light's rotational pivot back to the origin.
  id: totrans-35
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将灯光的旋转支点移回到原点。
- en: Set the light's rotation to give us the position we want.
  id: totrans-36
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 设置灯光的旋转以获得我们想要的位置。
- en: We could also calculate the light positions directly using some trigonometry,
    but having the lights each rotate around the origin will not only make the script
    more straightforward, but will also make it easier to change after creation.
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 我们也可以直接使用一些三角函数来计算灯光位置，但让灯光各自绕原点旋转不仅会使脚本更简单，而且创建后也更容易更改。
- en: 'First off, we move the light along the z-axis:'
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们沿着 z 轴移动灯光：
- en: '[PRE7]'
  id: totrans-39
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'Once we''ve done this, we want to move the rotate pivot back to the origin.
    We''ll use the move command for that as well:'
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦完成，我们想将旋转支点移回原点。我们将使用移动命令来完成此操作：
- en: '[PRE8]'
  id: totrans-41
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: Note that we append `.rotatePivot` to the name of the light so that we move
    just the pivot and not the light itself. Also note that we're moving it to (0,0,0).
    This will end up giving us what we want because the move command defaults to absolute
    coordinates. So, moving by (0,0,0) is actually telling Maya to move the object
    in question to the origin.
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，我们在灯光名称后追加 `.rotatePivot`，这样我们只移动支点而不是灯光本身。另外，注意我们将它移动到 (0,0,0)。这将最终给我们想要的结果，因为移动命令默认使用绝对坐标。所以，通过
    (0,0,0) 移动实际上是告诉Maya将相关对象移动到原点。
- en: 'Once we''ve done it, we can use the rotate command to rotate the light in question
    around the origin. For the key light, we''ll rotate it around the *x*-axis to
    move it up and around the *y-*axis to move it to the right. Note that we negate
    the value for the *x*-axis so that the light is rotated counter-clockwise rather
    than clockwise around the *x*-axis. This will ensure that the light moves up,
    rather than down, relative to the *X*-*Z* plane:'
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦完成，我们可以使用旋转命令将灯光绕原点旋转。对于主光，我们将绕 *x* 轴旋转以将其向上移动，并绕 *y* 轴旋转以将其向右移动。注意，我们对于 *x*
    轴的值取反，这样灯光在 *X*-*Z* 平面相对于顺时针旋转而不是逆时针旋转。这将确保灯光向上移动，而不是向下移动：
- en: '[PRE9]'
  id: totrans-44
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'We repeat the preceding code two more times to set up our fill and back lights
    with default positions:'
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 我们重复前面的代码两次，以设置填充光和背光，并使用默认位置：
- en: '[PRE10]'
  id: totrans-46
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'The fill light is rotated around the *x*-axis by the same amount as the key
    light, but in the opposite direction around the *y*-axis:'
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 填充光绕 *x* 轴旋转的量与主光相同，但在 *y* 轴的相反方向：
- en: '[PRE11]'
  id: totrans-48
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: And the back light is rotated around the *x*-axis by 180 degrees (to place it
    behind the origin) plus our `lightRotation` value to move it above the origin.
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 背光则绕 *x* 轴旋转 180 度（以放置在原点后面）加上我们的 `lightRotation` 值，使其移动到原点上方。
- en: At this point, we have three lights with default settings and positions, but
    we'll want to make the entire rig easier to manipulate. To do this, we'll create
    a new transform node and add all three lights as children.
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们有了三个具有默认设置和位置的灯光，但我们会希望使整个装置更容易操作。为此，我们将创建一个新的变换节点并将所有三个灯光作为子节点添加。
- en: 'To create the new transform node, we''ll use the group command with the `empty`
    flag, to allow us to create an empty group. We''ll also be sure to set the base
    name with the name flag:'
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 要创建新的变换节点，我们将使用带有 `empty` 标志的 `group` 命令，以允许我们创建一个空组。我们还将确保使用名称标志设置基本名称：
- en: '[PRE12]'
  id: totrans-52
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'Once we''ve done this, we use the parent command to make all three lights the
    children of the `LightRig` node:'
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦完成，我们使用 `parent` 命令将所有三个灯光作为 `LightRig` 节点的子节点：
- en: '[PRE13]'
  id: totrans-54
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'As a final touch, we make sure that we have the parent node selected, with
    a call to select, with the `replace` option:'
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 作为最后的润色，我们确保选择了父节点，使用 `select` 调用并带有 `replace` 选项：
- en: '[PRE14]'
  id: totrans-56
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: It's always a good practice, when creating new nodes or groups of nodes, to
    leave the newly created object(s) selected at the end of your script so that the
    end user can easily make further changes as necessary (such as moving the entire
    rig around).
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 当创建新的节点或节点组时，始终是一个好习惯，在脚本结束时保留新创建的对象（或对象组）选中状态，以便最终用户可以轻松地进行必要的进一步更改（例如移动整个装置）。
- en: There's more...
  id: totrans-58
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 还有更多...
- en: 'In this example, we set the color of the lights to different values to make
    the fill and back lights have less of an effect. Alternatively, we could set all
    of the lights to be a single color and use the intensity to provide variation.
    This might end up looking like the following:'
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个例子中，我们将灯光的颜色设置为不同的值，以使填充光和背光的影响更小。或者，我们也可以将所有灯光设置为单一颜色，并使用强度来提供变化。这可能会看起来像以下这样：
- en: '[PRE15]'
  id: totrans-60
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'The preceding code would give us three lights that are all white, but at varying
    intensities. If you want to set the intensity of a light after creating it, you
    can do so with the `setAttr` command. For example, if we wanted to change the
    intensity of `keyLight` after the fact, we could do the following:'
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 前面的代码会给我们三个都是白色的灯光，但强度不同。如果你想在创建灯光后设置其强度，可以使用`setAttr`命令。例如，如果我们想在事后更改`keyLight`的强度，我们可以这样做：
- en: '[PRE16]'
  id: totrans-62
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: One nice possible addition to the script might be to better account for varying
    scales of geometry. In the current version, we can use the scale of that parent
    group to increase or decrease the spacing of the lights. A slightly better way
    would be to pass in a value for the offset amount to our function. We could also
    pass in a value for the rotation amount to support a wider range of use cases.
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 脚本的一个很好的可能补充是更好地考虑几何形状的不同比例。在当前版本中，我们可以使用父组的比例来增加或减少灯光的间距。一个稍微好一点的方法是为我们的函数传递一个偏移量值。我们还可以传递一个旋转量值以支持更广泛的使用案例。
- en: 'Doing this would lead us to take the following code:'
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 这样做将导致我们采取以下代码：
- en: '[PRE17]'
  id: totrans-65
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'It will be changed to:'
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 它将被更改为：
- en: '[PRE18]'
  id: totrans-67
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: Creating GUI to control all lights
  id: totrans-68
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 创建用于控制所有灯光的GUI
- en: Most scenes will end up containing multiple lights, and controlling them all
    can get to be a real hassle. In this example, we'll be creating GUI that will
    present the user with an easy way to control the colors of all the lights in the
    scene.
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 大多数场景最终都会包含多个灯光，控制它们可能会变得非常麻烦。在这个例子中，我们将创建一个GUI，它将向用户提供一种简单的方式来控制场景中所有灯光的颜色。
- en: 'Running the script with three lights in the scene would result in something
    like the following:'
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 在场景中有三个灯光的情况下运行脚本会产生以下类似的结果：
- en: '![Creating GUI to control all lights](img/4657_07_02.jpg)'
  id: totrans-71
  prefs: []
  type: TYPE_IMG
  zh: '![创建用于控制所有灯光的GUI](img/4657_07_02.jpg)'
- en: Getting ready
  id: totrans-72
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备工作
- en: Make sure that you have at least a few lights in your scene. Alternatively,
    use the three-point lighting example above to quickly set up a system of lights.
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 确保你的场景中至少有几点灯光。或者，可以使用上面的三点照明示例快速设置灯光系统。
- en: How to do it...
  id: totrans-74
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何操作...
- en: 'Create a new file and add the following code:'
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 创建一个新文件并添加以下代码：
- en: '[PRE19]'
  id: totrans-76
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: Run the preceding script, and you'll get a new window with a control for each
    light in the scene. The control will provide both a color swatch and a slider,
    and changing it will cause the relevant light's color to update.
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 运行前面的脚本，你将得到一个新窗口，其中包含场景中每个灯光的控制。控制将提供颜色样本和滑块，更改它将导致相关灯光的颜色更新。
- en: How it works...
  id: totrans-78
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何工作...
- en: 'The first thing to note is that we''re adding a second `import` statement:'
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 首先要注意的是，我们添加了一个第二个`import`语句：
- en: '[PRE20]'
  id: totrans-80
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: The `functools` library provides capabilities to create functions and work with
    them as variables. This will come in handy later when we're wiring up our controls.
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: '`functools`库提供了创建函数和将它们作为变量使用的能力。这在我们将要连接我们的控件时将非常有用。'
- en: The next thing to note is that we're once again setting up a proper class for
    this example. Because we're going to need to maintain a list of all the lights
    in the scene (as well as a list of the controls for each one), wrapping our script
    in a proper class is the best way to go.
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 下一个要注意的是，我们再次为这个例子设置了一个合适的类。因为我们需要维护场景中所有灯光的列表（以及每个灯光的控制列表），所以将我们的脚本包裹在一个合适的类中是最好的方法。
- en: 'Having said this, let''s move onto our `__init__` function. We start off by
    initializing some member variables—one to hold a list of lights, one to hold a
    list of controls, and one to help us link the proper light to the proper control:'
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 话虽如此，让我们继续我们的`__init__`函数。我们首先初始化一些成员变量——一个用于存储灯光列表，一个用于存储控制列表，一个帮助我们将适当的灯光链接到适当的控制：
- en: '[PRE21]'
  id: totrans-84
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'We then perform our boilerplate initialization work for a new window—creating
    a window, setting its title, and adding a column layout. Before we create the
    window, we first delete the previous one (if it exists):'
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 然后我们为新窗口执行一些标准的初始化工作——创建窗口，设置其标题，并添加列布局。在我们创建窗口之前，我们首先删除之前的窗口（如果存在）：
- en: '[PRE22]'
  id: totrans-86
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'Once we''ve done this, we create our window, being sure to pass in the same
    name we checked for:'
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦我们完成了这个操作，我们创建我们的窗口，确保传递与我们检查的相同名称：
- en: '[PRE23]'
  id: totrans-88
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'Now we''re ready to set up our controls. We''ll need to create one for each
    light in the scene, which means we first have to get a list of all the lights.
    Luckily for us, the ls command makes that easy. All we have to do is to set the
    `lights` flag to `true`:'
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经准备好设置我们的控制。我们需要为场景中的每一盏灯创建一个控制，这意味着我们首先必须获取所有灯的列表。幸运的是，对于我们来说，`ls` 命令使得这变得很容易。我们只需要将
    `lights` 标志设置为 `true`：
- en: '[PRE24]'
  id: totrans-90
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: Note that there are a few different flags (`lights`, `cameras`, and `geometry`)
    that can be used with the `ls` command to grab specific types of objects. If you
    want to grab nodes of a type that doesn't have a specific flag, you can do that
    too; just use either the `type` or `exactType` flags and specify the type of node
    you're looking for.
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，`ls` 命令可以与几个不同的标志（`lights`、`cameras` 和 `geometry`）一起使用，以获取特定类型的对象。如果你想要获取没有特定标志的类型节点，你也可以这样做；只需使用
    `type` 或 `exactType` 标志并指定你正在寻找的节点类型。
- en: Once we have a list of all the objects in the scene, we run through the list
    and create a control for each one, using our `createLightControl` method, which
    we'll get to next.
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦我们有了场景中所有对象的列表，我们就遍历列表并为每个对象创建一个控制，使用我们的 `createLightControl` 方法，我们将在下一部分介绍。
- en: 'Once all the controls have been created, we show the window to the user:'
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦所有控制都创建完成，我们向用户显示窗口：
- en: '[PRE25]'
  id: totrans-94
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'Before we dive into actually creating our controls, we''ll need to have a function
    that can be used to update a given light to the color in a given slider. For that,
    we create the following function:'
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们真正创建我们的控制之前，我们需要一个函数，该函数可以用来更新特定的灯到给定滑块中的颜色。为此，我们创建了以下函数：
- en: '[PRE26]'
  id: totrans-96
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: The function looks like it takes three arguments, but only one really matters.
    First, since we're building this script as a class, we have to account for the
    fact that Python will pass the class instance to every member function, which
    we do with the self argument. Next is the thing we actually care about, in this
    case, an integer representing which control/light to work with. Finally, we have
    a catch-all in `*args`.
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 这个函数看起来像它接受三个参数，但实际上只有一个很重要。首先，由于我们正在将此脚本作为类构建，我们必须考虑到 Python 将将类实例传递给每个成员函数的事实，我们通过
    `self` 参数来实现这一点。接下来是我们真正关心的东西，在这种情况下，一个表示我们正在与之工作的控制/灯的整数值。最后，我们在 `*args` 中有一个通配符。
- en: Using `*args` will provide a way to grab a variable number of arguments into
    a single array. This is necessary, as many UI controls will pass extra data to
    functions that they call. We don't actually want to make use of that in this case,
    but if we left out the `*args`, we would end up with Maya passing three arguments
    in to a function that only takes two, generating an error.
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 使用 `*args` 将提供一种方法，将可变数量的参数抓取到一个单独的数组中。这是必要的，因为许多 UI 控件会向它们调用的函数传递额外的数据。在这种情况下，我们实际上并不想使用它，但如果我们省略了
    `*args`，Maya 就会向一个只接受两个参数的函数传递三个参数，从而产生错误。
- en: 'The argument that we *do* care about, `lightID`, tells us which light/control
    to work with. Both the lights and the controls are stored in class member variables—`self.lights`
    and `self.lightControls`. In order to set a given light to a given slider, we
    have to first get the current value of the slider by running the `colorSliderGrp`
    command in query mode, as follows:'
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 我们真正关心的参数，`lightID`，告诉我们应该使用哪个灯/控制。灯和控制都存储在类成员变量中——`self.lights` 和 `self.lightControls`。为了将特定的灯设置到特定的滑块上，我们必须首先通过以查询模式运行
    `colorSliderGrp` 命令来获取滑块的当前值，如下所示：
- en: '[PRE27]'
  id: totrans-100
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: Note that we pass in an entry in our `self.lightControls` array to specify the
    control, we run the command in query mode, and we set the `rgb` flag to `True`
    to tell Maya that it's the specific attribute that we're querying.
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，我们传递 `self.lightControls` 数组中的一个条目来指定控制，我们以查询模式运行命令，并将 `rgb` 标志设置为 `True`
    来告诉 Maya 我们正在查询特定的属性。
- en: Once we've done it, we use `setAttr` to set the color of the corresponding light
    to the given red, green, and blue values. We'll use `setAttr` to do that, but
    we'll need to make sure that we specify the type because we'll be using multiple
    values.
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦我们完成了这个操作，我们使用 `setAttr` 来设置相应灯的颜色为给定的红色、绿色和蓝色值。我们将使用 `setAttr` 来做这件事，但我们需要确保我们指定了类型，因为我们将会使用多个值。
- en: '[PRE28]'
  id: totrans-103
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: 'Okay, so at this point, we have a function that we can call to update a given
    light to the current color value of a given slider. So, if we were to call the
    function, we would set the first light to the current color of the first slider:'
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 好的，所以到目前为止，我们有一个可以调用的函数来更新特定的灯光到特定滑块的当前颜色值。所以，如果我们调用这个函数，我们会将第一盏灯设置为第一个滑块的当前颜色：
- en: '[PRE29]'
  id: totrans-105
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: That's a big part of what we need, but we'll want to make sure that this gets
    called every time a slider's value is changed.
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 这是我们需要的一部分，但我们还想确保每次滑块值改变时都会调用这个函数。
- en: 'On to creating an individual control. We create a function that takes a given
    light and does the following:'
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来是创建单个控件。我们创建一个函数，它接受一个特定的灯光并执行以下操作：
- en: Stores a reference to the light so we can later alter its properties
  id: totrans-108
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 存储对灯光的引用，以便我们稍后可以更改其属性
- en: Creates a new `colorSliderGrp` control for the light
  id: totrans-109
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 为灯光创建一个新的`colorSliderGrp`控件
- en: 'The function will pass the light we want to create a control for, and we''ll
    once again need to account for the fact that Python passes in the class instance
    itself, giving us the following function signature:'
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 该函数将传递我们想要创建控件的灯光，我们还需要考虑到Python传递的是类实例本身，这给我们以下函数签名：
- en: '[PRE30]'
  id: totrans-111
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: 'Within the function, we''ll start out by grabbing the transform node associated
    with the light. That''s not strictly necessary because the node that we''ll want
    to alter (to set color) is the actual shape node. However, it''s a lot nicer to
    have our controls labeled something like `Key Light` rather than `keyLightShape`.
    Grabbing the transform is done in the same way that we did it in the previous
    example:'
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 在函数内部，我们首先会获取与灯光关联的变换节点。这并不是严格必要的，因为我们想要更改的节点（用于设置颜色）实际上是形状节点。然而，将我们的控件命名为类似`Key
    Light`而不是`keyLightShape`会更好一些。获取变换的方式与我们在上一个示例中做的方式相同：
- en: '[PRE31]'
  id: totrans-113
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: 'Before we create the control, there are a few things we''ll want to do first.
    We''ll want to make sure that the `colorSliderGrp` starts out with the same color
    value as the light. To do it, we''ll need to grab the light''s current color with
    the `getAttr` (get attribute) command:'
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们创建控制之前，有一些事情我们需要先做。我们需要确保`colorSliderGrp`从与灯光相同的颜色值开始。为了做到这一点，我们需要使用`getAttr`（获取属性）命令来获取灯光的当前颜色：
- en: '[PRE32]'
  id: totrans-115
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: The `getAttr` command is a real workhorse, and (as is the case with many other
    commands) it always returns an array because some of the uses to which it can
    be put will return multiple values. What's a bit surprising about its behavior
    in this specific case is that we'll end up with a one-element array, with that
    one element being itself a three-element list of the red, green, and blue values.
    So, when we make use of the color variable, we'll need to use `color[0]`, instead
    of (as you would likely suspect) just `color`.
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: '`getAttr`命令是一个真正的多面手，并且（就像许多其他命令一样）它总是返回一个数组，因为它的某些用途可能会返回多个值。关于它在特定情况下的行为，有一点令人惊讶的是，我们最终会得到一个只有一个元素的数组，而这个元素本身是一个包含红色、绿色和蓝色值的三个元素的列表。因此，当我们使用颜色变量时，我们需要使用`color[0]`，而不是（正如你可能猜测的那样）只是`color`。'
- en: The next thing that we'll want to do is to create the function that gets called
    when the slider has its value changed. In the case of a `colorSliderGrp` control,
    this includes both moving the slider or clicking on the color swatch to select
    a color. In either case, we'll want to respond by running some code to update
    our light's color value.
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们想要做的是创建一个当滑块值改变时被调用的函数。在`colorSliderGrp`控件的情况下，这包括移动滑块或点击颜色样本来选择颜色。在任一情况下，我们都会通过运行一些代码来更新我们的灯光颜色值。
- en: Here's where it gets tricky because the function we call will need to be aware
    of the specific UI control to grab data from, as well as the specific light to
    apply changes to.
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 这里会变得有些棘手，因为我们将调用的函数需要知道从哪个特定的UI控件获取数据，以及应用到哪个特定的灯光上。
- en: We'll create the slider with the `colorSliderGrp` command, which provides a
    flag, `changeCommand`, which can be used to specify a command that should be run
    every time the slider's value changes.
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将使用`colorSliderGrp`命令创建滑块，该命令提供了一个标志`changeCommand`，可以用来指定每次滑块值改变时应运行的命令。
- en: 'If we wanted the slider to run a function that took zero arguments when it
    changes, we could do the following:'
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们想让滑块在改变时运行一个不接受任何参数的函数，我们可以这样做：
- en: '[PRE33]'
  id: totrans-121
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: 'However, in this case, we want to call our `updateColor` function, while passing
    in an integer to specify which light/control to update. You might be tempted to
    do something like the following:'
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，在这种情况下，我们想要调用我们的`updateColor`函数，同时传递一个整数来指定要更新的灯光/控件。你可能想做一些如下所示的事情：
- en: '[PRE34]'
  id: totrans-123
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: Unfortunately, it's not quite that simple. The preceding code would cause Python
    to actually run the `updateColor` function at the time we create the control.
    As a result, the actual value of the `changeCommand` flag would be whatever the
    return value of self.`updateColor` is (in this case, `None`).
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 不幸的是，事情并没有那么简单。前面的代码会导致Python在我们创建控件时实际运行`updateColor`函数。因此，`changeCommand`标志的实际值将是`self.updateColor`的返回值（在这种情况下，`None`）。
- en: 'That''s where the partial command, included in the `functools` library, comes
    in. We can use the `partial` function to create a copy of a function with specific
    arguments baked in. It''s almost as if we had written a separate function for
    each light and slider combo. We''ll use the `partial` command to create a copy
    of our `self.updateColor` command, with a number representing the current light
    baked in, as follows:'
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 这就是`functools`库中包含的`partial`命令的作用所在。我们可以使用`partial`函数来创建一个带有特定参数的函数副本。这几乎就像我们为每个灯光和滑块组合编写了一个单独的函数。我们将使用`partial`命令来创建`self.updateColor`命令的副本，其中包含一个表示当前灯光的数字，如下所示：
- en: '[PRE35]'
  id: totrans-126
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: 'The first argument to partial is a function. Note the lack of parentheses after
    `self.updateColor`, indicating that we''re making use of the function itself,
    rather than running it. After the function, we can pass in one or more arguments
    to bind to the function. For example, if we had the following function:'
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: '`partial`的第一个参数是一个函数。注意在`self.updateColor`之后没有括号，这表明我们正在使用函数本身，而不是运行它。在函数之后，我们可以传递一个或多个参数来绑定到函数。例如，如果我们有以下函数：'
- en: '[PRE36]'
  id: totrans-128
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: 'And we used partial in the following way:'
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 我们以以下方式使用了`partial`：
- en: '[PRE37]'
  id: totrans-130
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: The value of `newFunction` would itself be a new function with exactly the same
    behavior as if we had called `printANum(23)`.
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: '`newFunction`的值本身将是一个具有与调用`printANum(23)`完全相同行为的新函数。'
- en: 'So, at this point in the script, our `changeCommandFunc` variable holds a new
    function that will have identical behavior to calling our `updateColor` function
    with a specific input. With this, we''re ready to create our slider:'
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，在这个脚本的这个点上，我们的`changeCommandFunc`变量包含一个新函数，它将具有与调用我们的`updateColor`函数并带有特定输入时的相同行为。有了这个，我们就准备好创建我们的滑块：
- en: '[PRE38]'
  id: totrans-133
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: We use our `lightName` variable to label the slider and pass in our color variable
    (note the `[0]`, since it's an array) to make sure that the slider starts with
    the current color of the light.
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 我们使用`lightName`变量来标记滑块，并传入我们的颜色变量（注意`[0]`，因为它是一个数组），以确保滑块从当前灯光的颜色开始。
- en: 'We''re almost done, except for a bit of bookkeeping. We''ll want to make sure
    that we maintain references to both the slider and the light to which it corresponds.
    To do this, we insert the light''s shape node (originally passed in to the `createLightControl`
    function) into the class member variable, lights. We also insert the newly created
    slider into the `lightControls` list:'
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 我们几乎完成了，但还需要做一些账目管理。我们想要确保我们维护对滑块及其对应灯光的引用。为此，我们将灯光的形状节点（最初传递给`createLightControl`函数）插入到类成员变量`lights`中。我们还将新创建的滑块插入到`lightControls`列表中：
- en: '[PRE39]'
  id: totrans-136
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: 'Finally, we increment our `lightNum` variable by one so that the next time
    through the function, we''ll pass the correct value into the `partial` command:'
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们将`lightNum`变量增加一，以便下一次通过函数时，我们将传递正确的值到`partial`命令中：
- en: '[PRE40]'
  id: totrans-138
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: 'And that''s it! We''re done creating our class, and finish off our script with
    a command to create an instance:'
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 就这样！我们已经完成了类的创建，并使用创建实例的命令来完成脚本：
- en: '[PRE41]'
  id: totrans-140
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: There's more...
  id: totrans-141
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 还有更多...
- en: 'In this example, we created controls to alter the color of the lights in the
    scene. It''s likely that you would also want to control the intensity of the lights
    as well. That could be done easily enough by creating an additional control (likely
    either `floatField` or `floatSlider`) in the `createLightControl` function. Either
    way, you would want to:'
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个例子中，我们创建了控件来改变场景中灯光的颜色。你很可能会也想控制灯光的强度。这可以通过在`createLightControl`函数中创建一个额外的控件（可能是`floatField`或`floatSlider`）轻松实现。无论如何，你都会想要：
- en: Create a separate class member variable to hold references to the intensity
    controls.
  id: totrans-143
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个单独的类成员变量来保存对强度控件的引用。
- en: Make sure that changing the value on the intensity slider also calls the `updateColor`
    function.
  id: totrans-144
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 确保更改强度滑块的值也会调用`updateColor`函数。
- en: In the `updateColor` function, make sure that you grab the current value of
    the control and use it to set the intensity of the light with the `setAttr` command.
  id: totrans-145
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`updateColor`函数中，确保你获取控制器的当前值，并使用它通过`setAttr`命令设置光线的强度。
- en: Creating cameras from code
  id: totrans-146
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 从代码中创建相机
- en: In this example, we'll be looking at how to use code to create cameras. We'll
    create a collection of four orthographic cameras, suitable for use in rendering
    out multiple views of an object for use as assets for an isometric game.
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个例子中，我们将探讨如何使用代码来创建相机。我们将创建一组四个正交相机，适合用于渲染对象的多个视图，用作等距游戏的资源。
- en: Note
  id: totrans-148
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: Isometric games have a long history and are characterized by using 2D assets
    to create a three-quarters overhead view of a game environment. This approach
    was very common before full 3D games became the norm, and it still shows up often
    in web and mobile games. Creating assets for isometric games often means rendering
    out a view for each side of an object and making sure that there is no perspective
    distortion in the rendering, which is exactly what we'll be doing in this example.
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 等距游戏有着悠久的历史，其特点是用2D资源创建一个三分之四的俯视图来展示游戏环境。在完全3D游戏成为常态之前，这种方法非常普遍，它仍然经常出现在网页和移动游戏中。为等距游戏创建资源通常意味着为对象的每一面渲染一个视图，并确保渲染中没有透视畸变，这正是我们在这个例子中将要做的。
- en: '![Creating cameras from code](img/4657_07_03.jpg)'
  id: totrans-150
  prefs: []
  type: TYPE_IMG
  zh: '![从代码中创建相机](img/4657_07_03.jpg)'
- en: The result of the script-four orthographic cameras, all pointed at the origin
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 脚本的结果是四个正交相机，它们都指向原点
- en: Getting ready
  id: totrans-152
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备工作
- en: For best results, make sure that you have some geometry in your scene, placed
    at the origin.
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 为了获得最佳效果，请确保你的场景中有些几何体，放置在原点。
- en: How to do it...
  id: totrans-154
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何操作...
- en: 'Create a new file and add the following code:'
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 创建一个新文件并添加以下代码：
- en: '[PRE42]'
  id: totrans-156
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: Run the script, and you should have four isometric cameras, all looking at the
    origin.
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 运行脚本，你应该有四个等距相机，它们都朝向原点。
- en: How it works...
  id: totrans-158
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何工作...
- en: Making a camera is easy enough; all we need to do is to use the `camera` command.
    However, there's no direct way to create a camera and aim setup with code. Instead,
    we have to manually create an aim constraint for each of the cameras we create.
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 制作相机相当简单；我们只需要使用`camera`命令。然而，没有直接的方法可以通过代码创建相机和目标设置。相反，我们必须为每个我们创建的相机手动创建一个目标约束。
- en: We start our script by creating a locator to serve as the target for the aim
    constraint.
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 我们从创建一个定位器开始，作为目标约束的目标。
- en: '[PRE43]'
  id: totrans-161
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: The locator will be positioned at the origin by default, which is fine for our
    purposes. Now that we have an aim object, we're ready to create our cameras. We
    kick off a for loop to create four cameras, one for each of the diagonal directions.
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 定位器将默认位于原点，这对我们的目的来说很合适。现在我们有了目标对象，我们就可以创建我们的相机了。我们启动一个for循环来创建四个相机，每个对角方向一个。
- en: 'Actually, creating the camera is simple; we just call the `camera` command.
    In this case, we''ll want to have orthographic cameras, so we''ll set the `orthographic`
    flag to `true`:'
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 实际上，创建相机很简单；我们只需调用`camera`命令。在这种情况下，我们希望有正交相机，所以我们将`orthographic`标志设置为`true`：
- en: '[PRE44]'
  id: totrans-164
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: Next, we'll set up the aim constraint. To create an aim constraint, we need
    to pass in two transform nodes, with the first being the target and the second
    being the one that will have its rotations controlled. Note that because both
    the `spaceLocator` and `camera` commands return two nodes (one transform, one
    shape), we'll need to specify the first index of the variables we used to hold
    the results.
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们将设置目标约束。要创建一个目标约束，我们需要传递两个变换节点，第一个是目标节点，第二个是将会控制其旋转的节点。请注意，由于`spaceLocator`和`camera`命令都返回两个节点（一个变换节点，一个形状节点），我们需要指定我们用来保存结果的变量的第一个索引。
- en: '![How it works...](img/4657_07_04.jpg)'
  id: totrans-166
  prefs: []
  type: TYPE_IMG
  zh: '![如何工作...](img/4657_07_04.jpg)'
- en: A default camera, pointed down the negative z-axis
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 默认相机，指向负z轴
- en: We'll also want to make sure that our cameras look down their axis at the locator
    by setting the proper aim vector. Because the default position of a camera will
    have it looking along the z-axis in the negative direction, we'll want to use
    (0, 0, -1) as the aim vector.
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还希望确保我们的相机通过设置正确的目标向量向下看定位器。由于相机的默认位置将使其沿z轴的负方向看去，我们将使用(0, 0, -1)作为目标向量。
- en: 'Putting this all together gives us the following line to create the `aim` constraint:'
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 将所有这些放在一起，我们得到以下创建`aim`约束的行：
- en: '[PRE45]'
  id: totrans-170
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: Now we just need to move the camera to the proper location. Because the aim
    constraint will take care of the rotations, all we have to worry about is the
    position. In this case, we want to make sure that each camera lies on a line that
    is some multiple of 45 degrees from the origin. To do this, we'll want to make
    sure that the *X* and *Z* positions have the same magnitude, with only the signs
    changing from camera to camera.
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们只需要将相机移动到正确的位置。因为目标约束将处理旋转，我们只需要担心位置。在这种情况下，我们想要确保每个相机都位于从原点出发的45度倍数的直线上。为此，我们需要确保*X*和*Z*的位置具有相同的幅度，只是从相机到相机符号改变。
- en: 'First off, we''ll create variables for each of the x, y, and z positions, with
    the `ypos` variable being set to a default value:'
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们将为每个x、y和z位置创建变量，其中`ypos`变量被设置为默认值：
- en: '[PRE46]'
  id: totrans-173
  prefs: []
  type: TYPE_PRE
  zh: '[PRE46]'
- en: 'For X and Z, we''ll want to have values for each of the four quadrants- (+,+),
    (+,-), (-,-), and (-,+). To do this, we''ll have one of the values be negative
    when our index is odd, and the other be negative when the index is greater than
    or equal to `2`:'
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 对于X和Z，我们希望每个象限都有值 - (+,+), (+,-), (-,-), 和 (-,+)。为了做到这一点，当我们的索引是奇数时，我们将其中一个值设为负，当索引大于或等于`2`时，另一个值设为负：
- en: '[PRE47]'
  id: totrans-175
  prefs: []
  type: TYPE_PRE
  zh: '[PRE47]'
- en: Note that we're making use of the `offset` variable, which was set outside of
    the loop.
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 注意我们正在使用`offset`变量，它是在循环外部设置的。
- en: Having done this, we use the `move` command to position the camera at the proper
    location.
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 完成这些后，我们使用`move`命令将相机定位到正确的位置。
- en: '[PRE48]'
  id: totrans-178
  prefs: []
  type: TYPE_PRE
  zh: '[PRE48]'
- en: And with this, we're done!
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: 就这样，我们完成了！
- en: There's more...
  id: totrans-180
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 还有更多...
- en: In this example, we created an `aim` constraint to replicate the behavior that
    one gets when creating a *Camera and Aim* from Maya's UI. The nice thing about
    this is that we can move the locator in order to change the look at location.
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个例子中，我们创建了一个`aim`约束来复制从Maya的用户界面创建`相机和瞄准`时得到的行为。这个功能的好处在于我们可以移动定位器来改变观察位置。
- en: 'If all we wanted was to have the camera look at a given location though, we
    could do it with the `viewPlace` command, which can both move a camera and rotate
    it to look at a given location. For example, if we wanted to have a camera positioned
    at (5,6,5) and looking at a point slightly above the origin (let''s say 0,2,0),
    we could do the following:'
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们只想让相机看向一个特定的位置，我们可以使用`viewPlace`命令，该命令可以移动相机并旋转它以看向特定位置。例如，如果我们想将相机定位在（5,6,5）并看向原点稍高的点（比如说0,2,0），我们可以这样做：
- en: '[PRE49]'
  id: totrans-183
  prefs: []
  type: TYPE_PRE
  zh: '[PRE49]'
- en: We also only scratched the surface of what can be done when creating cameras;
    you'll often want to set things such as the near/far clip planes, depth of field,
    and so on. You can either set such things directly on creation or use `setAttr`
    to alter them after the fact. For more details, be sure to consult the documentation
    for the `camera` command.
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: 我们也仅仅触及了创建相机时可以做到的一些事情；你通常会想要设置诸如近/远裁剪平面、景深等。你可以直接在创建时设置这些，或者使用`setAttr`在之后修改它们。更多详情，请务必查阅`camera`命令的文档。
- en: Rendering a sprite sheet
  id: totrans-185
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 渲染精灵图集
- en: In this example, we'll be building a tool to render out multiple views of an
    object to a single image. This could be used to create a sprite sheet for use
    in an isometric game.
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个例子中，我们将构建一个工具，将一个对象的多个视图渲染到单个图像中。这可以用来创建等距游戏中的精灵图集。
- en: In the course of the example, we'll use both Maya's Python library (to render
    out frames) and the **Python Imaging Library** (**PIL**) to combine them into
    a single image.
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个例子过程中，我们将使用Maya的Python库（用于渲染帧）和**Python图像库**（**PIL**）将它们合并成单个图像。
- en: '![Rendering a sprite sheet](img/4657_07_05.jpg)'
  id: totrans-188
  prefs: []
  type: TYPE_IMG
  zh: '![渲染精灵图集](img/4657_07_05.jpg)'
- en: Four views rendered out and combined into a single image
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: 四个视图渲染并合并成单个图像
- en: Getting ready
  id: totrans-190
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备工作
- en: Make sure that you have an object in your scene and it is at the origin. Also
    make sure that you have some number of cameras set up. You can either do it manually,
    or refer to the previous example on how to create cameras from script.
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: 确保你的场景中有一个对象并且它位于原点。还确保你设置了一些数量的相机。你可以手动完成，或者参考如何从脚本创建相机的上一个例子。
- en: You'll also want to make sure that you have PIL installed on your system. The
    best way to do that is to grab Pillow (a fork of PIL). More information on Pillow
    can be found at [http://pillow.readthedocs.io/en/3.2.x/](http://pillow.readthedocs.io/en/3.2.x/).
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
- en: In order to install Pillow in a (relatively) painless way, you'll probably want
    to grab PIP, which is a robust package manager for Python. For more information
    on PIP, check [https://pypi.python.org/pypi/pip](https://pypi.python.org/pypi/pip).
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  id: totrans-194
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Create a new file and add the following code:'
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE50]'
  id: totrans-196
  prefs: []
  type: TYPE_PRE
  zh: '[PRE50]'
- en: Run the script, and you should get a new image, named `frames.tga` in the `images`
    directory of your project folder, containing a view from each of the (nonstandard)
    cameras. If you haven't set up a project, the images will be in the default project
    directory. If you want them to be in a specific location, be sure to set your
    project before running the script.
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
- en: How it works...
  id: totrans-198
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'First off, we''re importing a few additional libraries to make the script work.
    First is the `os` library, to let us combine paths and file names in a safe, cross-platform
    way. Then, we also import the Image module from PIL, which we''ll use to create
    our combined image:'
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE51]'
  id: totrans-200
  prefs: []
  type: TYPE_PRE
  zh: '[PRE51]'
- en: 'Next, we define a couple of variables that we''ll use to set the size of our
    rendered images. We''ll use that both to set the render size, as well as to calculate
    the size of the combined image:'
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE52]'
  id: totrans-202
  prefs: []
  type: TYPE_PRE
  zh: '[PRE52]'
- en: Note
  id: totrans-203
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Note that the variables are all caps, that is by no means necessary. Capitalized
    variables are often used to indicate constants that are used in multiple places
    and don't vary during the course of a script. The dimensions of the frames to
    render are a good example of that kind of variable, so I've given them all-caps
    names, but feel free to use a different style if you so choose.
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
- en: 'Now we''re ready to get started rendering out images. To do it, we''ll want
    to first get a list of all the cameras in our scene, then filter out the default
    views. We *could* use the ls command to do it, but it''s easier to use the `listCameras`
    command:'
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE53]'
  id: totrans-206
  prefs: []
  type: TYPE_PRE
  zh: '[PRE53]'
- en: To ignore the default camera views, we'll start by creating a new (empty) list,
    then running through our `allCams` list. Each camera that is *not* in the list
    of defaults gets added, leaving us with a handy list of all the nondefault cameras
    in the scene.
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE54]'
  id: totrans-208
  prefs: []
  type: TYPE_PRE
  zh: '[PRE54]'
- en: 'At this point, we have a list of all the cameras that we''ll want to render
    out. Before we render anything, we''ll want to make sure that we''re rendering
    the proper image format. In this case, we''ll render out Targa files because they''re
    both uncompressed and include an alpha channel:'
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE55]'
  id: totrans-210
  prefs: []
  type: TYPE_PRE
  zh: '[PRE55]'
- en: To set the image type, we use the `setAttr` command, but the value is less clear
    than we might like. It just so happens that the `targa` format happens to correspond
    to 19\. Other common formats include JPG (8), PNG (32), and PSD (31). To check
    the value of any given format, open the render globals window, select the desired
    format from the dropdown, and observe the output in the script editor.
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
- en: 'Before we start rendering our images, we''ll want to use PIL to create a larger
    image to hold all of the frames. We''ll create a single image that has the same
    height as our render size and a width equal to the render width multiplied by
    the number of cameras. We''ll also set up the image to default to black:'
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE56]'
  id: totrans-213
  prefs: []
  type: TYPE_PRE
  zh: '[PRE56]'
- en: Note that we pass in `RGBA` to set the image mode to full color plus alpha.
    With our base image created, we're ready to run through our cameras and render
    each frame.
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
- en: 'For each camera, we''ll want to:'
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
- en: Render the current view at our specified width and height
  id: totrans-216
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Paste the rendered image into the combined image
  id: totrans-217
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'To render out a given view, we use the `render` command with three arguments-the
    camera to render from, followed by the width and the height for the rendered image:'
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE57]'
  id: totrans-219
  prefs: []
  type: TYPE_PRE
  zh: '[PRE57]'
- en: We store the result of the `render` command into a result variable for later
    use. It's important to note that the output isn't the image itself, but rather
    the path to the image (something like `/Documents/maya/projects/default/images/tmp/MyScene.tga`).
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
- en: 'Now that we''ve rendered out the image, we''ll want to use PIL to create the
    second `Image` object from the specified path:'
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE58]'
  id: totrans-222
  prefs: []
  type: TYPE_PRE
  zh: '[PRE58]'
- en: 'We use `Image.open` instead of `Image.create` because we want to create an
    image from a given file, rather than a new blank image. Finally, we copy the new
    image into our combined image with the `paste` command:'
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE59]'
  id: totrans-224
  prefs: []
  type: TYPE_PRE
  zh: '[PRE59]'
- en: PIL's paste command allows one image to be pasted into another at a specific
    location. In this case, we call it on our `fullImage` image and pass in the image
    we just rendered out (`tempImg`), as well as a tuple for the location. The *Y*
    location is locked to `0` in all cases, and the *X* location is set to `FRAME_WIDTH`
    multiplied by the loop index so that our images are placed in an orderly horizontal
    line.
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
- en: 'Once we''ve finished that loop, we''re ready to save out the combined image.
    There are any number of places we could put it, but it probably makes sense to
    put it somewhere in our project directory. To do that, we''ll need to first grab
    the current project directory using the `workspace` command in the query mode
    as follows:'
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE60]'
  id: totrans-227
  prefs: []
  type: TYPE_PRE
  zh: '[PRE60]'
- en: 'Where you save the image is up to you, but in this case, I decided to go with
    saving it out as `frames.tga` in the `images` folder of the project directory.
    We could build up the path by adding strings, but using Python''s `os` library
    to join the path guarantees that our script will have better cross-platform support:'
  id: totrans-228
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE61]'
  id: totrans-229
  prefs: []
  type: TYPE_PRE
  zh: '[PRE61]'
- en: 'Finally, we call `Image.save` on our `fullImage` variable and pass in the path
    we just created:'
  id: totrans-230
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE62]'
  id: totrans-231
  prefs: []
  type: TYPE_PRE
  zh: '[PRE62]'
- en: There's more...
  id: totrans-232
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Although there is certainly a wide range of options offered by Maya's rendering
    capabilities, some things may be easier to achieve by postprocessing after the
    fact. The PIL is quite powerful and well worth digging into. If you ever find
    yourself needed to perform 2D operations on your renders, it's quite possible
    that doing so with the PIL could be a good choice.
  id: totrans-233
  prefs: []
  type: TYPE_NORMAL
- en: This script, or something like it, could easily be used to build a robust asset
    pipeline for an isometric game. You could easily add the ability to send the combined
    image to a central server along with metadata on the particular structure or object.
    We'll look at sending data across the Web in [Chapter 9](ch09.html "Chapter 9. Communicating
    with the Web"), *Communicating with the Web*.
  id: totrans-234
  prefs: []
  type: TYPE_NORMAL
  zh: 这个脚本，或者类似的东西，可以很容易地用来构建一个用于等距游戏的健壮的资产管道。你可以轻松地添加将组合图像连同特定结构或对象的元数据发送到中央服务器的功能。我们将在第9章[第9章。与Web通信](ch09.html
    "第9章。与Web通信")中探讨如何在Web上发送数据。
- en: See also
  id: totrans-235
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 参见
- en: PIL is capable of a great deal more than what we used it for in this example.
    For more details, you'll want to dig into the documentation on *effbot.org* ([http://effbot.org/imagingbook/pil-index.htm](http://effbot.org/imagingbook/pil-index.htm)).
  id: totrans-236
  prefs: []
  type: TYPE_NORMAL
  zh: PIL的功能远不止我们在本例中使用的那样。更多详情，你可以在*effbot.org*的文档中深入了解(*http://effbot.org/imagingbook/pil-index.htm*)。
