- en: '13'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '13'
- en: Simulating a Robot in Gazebo
  id: totrans-1
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 在Gazebo中模拟机器人
- en: In the previous chapters, you wrote a URDF to describe a robot, published the
    TFs for that robot, and properly organized all files into the **my_robot_description**
    package.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的章节中，你编写了一个URDF来描述机器人，发布了该机器人的TFs，并将所有文件正确地组织到**my_robot_description**包中。
- en: You are now going to simulate the robot in Gazebo. This will be the end of the
    *Part 3* project. The goal here is to finish the book with a working simulation.
    After that, I will conclude by giving you some hints on what to do to further
    with ROS.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，你将要在Gazebo中模拟机器人。这将标志着*第3部分*项目的结束。目标是带着一个可工作的模拟完成这本书。之后，我将通过给你一些关于如何进一步使用ROS的建议来结束。
- en: We will start the chapter by understanding what Gazebo is, how it is integrated
    with ROS 2, and how to work with it. This will allow us to adapt the robot URDF
    for Gazebo, spawn it in the simulator, and control it with a plugin. We will also
    properly package the application so that we can start everything from one single
    launch file.
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将首先了解Gazebo是什么，它是如何与ROS 2集成的，以及如何与之工作。这将使我们能够为Gazebo调整机器人URDF，在模拟器中生成它，并使用插件来控制它。我们还将正确地打包应用程序，以便我们可以从一个单独的启动文件开始一切。
- en: By the end of this chapter, you will be able to simulate a robot in Gazebo and
    interact with it using ROS 2\. After you’ve done the process once, it will be
    much easier for the next robot you want to simulate.
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 到本章结束时，你将能够模拟一个机器人在Gazebo中，并使用ROS 2与之交互。一旦你完成这个过程一次，模拟下一个机器人将变得容易得多。
- en: The level of this chapter is more advanced than what we did before. We will
    reach a point where the documentation lacks a lot. Finding useful information
    usually means doing a lot of research on Google, as well as finding GitHub code
    that works and that you can use as an inspiration.
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: 本章的难度比我们之前所做的高。我们将达到一个文档缺乏很多信息的地方。通常，找到有用的信息意味着在Google上做大量的研究，以及找到可以使用的GitHub代码，作为灵感的来源。
- en: To complete this chapter, you will also need to utilize what you have previously
    learned from this book —for example, creating and organizing packages, working
    with topics and parameters, and writing launch files. Don’t hesitate to refer
    to previous chapters if you have any doubts.
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: 为了完成本章，你还需要利用在这本书中学到的先前知识——例如，创建和组织包，处理主题和参数，以及编写启动文件。如果你有任何疑问，不要犹豫，参考前面的章节。
- en: We will use the code inside the **ch12** folder (on the GitHub repository at
    [https://github.com/PacktPublishing/ROS-2-from-Scratch](https://github.com/PacktPublishing/ROS-2-from-Scratch))
    as a starting point. You can find the final code in the **ch13** folder.
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将使用**ch12**文件夹中的代码（位于[https://github.com/PacktPublishing/ROS-2-from-Scratch](https://github.com/PacktPublishing/ROS-2-from-Scratch)的GitHub仓库中）作为起点。你可以在**ch13**文件夹中找到最终代码。
- en: 'In this chapter, we will cover the following topics:'
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将涵盖以下主题：
- en: How Gazebo works
  id: totrans-10
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Gazebo的工作原理
- en: Adapting the URDF for Gazebo
  id: totrans-11
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 为Gazebo调整URDF
- en: Spawning the robot in Gazebo
  id: totrans-12
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在Gazebo中生成机器人
- en: Controlling the robot in Gazebo
  id: totrans-13
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在Gazebo中控制机器人
- en: Technical requirements
  id: totrans-14
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 技术要求
- en: If you installed ROS 2 in a **VM** (as explained with VirtualBox at the beginning
    of the book), it probably worked well for all chapters in *Part 1* and *Part 2*,
    and possibly for the previous chapters in *Part 3*, even when running RViz.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你像书中开头用VirtualBox解释的那样在虚拟机（VM）中安装了ROS 2，那么它可能对*第1部分*和*第2部分*的所有章节以及*第3部分*的前几章都工作得很好，即使是在运行RViz时也是如此。
- en: However, with Gazebo, chances are that the VM won’t be enough. VirtualBox doesn’t
    work well with 3D simulation tools. From now on, I would strongly recommend that
    you have Ubuntu installed with a dual boot. I know that some people had more success
    with VMware Workstation (using the free version for personal use) or WSL 2 on
    Windows. If you find another combination that works for you, fine, but I would
    still recommend a dual boot, which will possibly be less buggy and bring you a
    better experience overall.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，使用Gazebo，虚拟机可能不够用。VirtualBox与3D模拟工具配合得不好。从现在开始，我强烈建议你安装带有双启动的Ubuntu。我知道有些人使用VMware
    Workstation（使用个人使用的免费版本）或Windows上的WSL 2取得了更大的成功。如果你找到了对你有效的工作组合，那很好，但我仍然推荐双启动，这可能会带来更少的错误，并为你提供更好的整体体验。
- en: So, if you are currently running a VM, take the time to set up a dual boot and
    install Ubuntu 24.04\. Then, follow the instructions from [*Chapter 2*](B22403_02.xhtml#_idTextAnchor048)
    again to install ROS Jazzy. This will take you a bit of time in the short term,
    but it will surely be more efficient in the long term.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
- en: How Gazebo works
  id: totrans-18
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Before we work on our application, it’s important to understand what Gazebo
    is and how it works.
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
- en: Gazebo is a 3D simulation engine. It contains a physics engine (with gravity,
    friction, and other physical constraints) with which you can simulate a robot,
    just like if it were in the real world.
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
- en: That’s one of the strengths of Gazebo. You can develop your application using
    mostly the Gazebo simulation and then work with the real robot. This brings a
    lot of benefits. For example, you can work on robots that don’t exist yet, test
    extreme use cases without damaging the real robot, create custom environments
    you can’t access on a daily basis, work remotely, and so on.
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
- en: In this section, we will start Gazebo and explore a few functionalities. We
    will also see how to connect Gazebo with ROS 2 and understand the steps we need
    to take to adapt our robot for Gazebo. Before getting started with this, a common
    question that lots of people have at this point is, what is the difference between
    Gazebo and RViz?
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
- en: Clarifying – Gazebo versus RViz
  id: totrans-23
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: We are starting with this because I believe this is one of the first confusions
    you can have. We have already used RViz previously, and we could visualize the
    robot in it, as well as lots of other information. So, why do we need Gazebo?
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
- en: To understand this, let’s first go back to what RViz is. RViz is a 3D visualization
    tool. With RViz, you can visualize the URDF, the TFs, and the data you get from
    ROS topics. This is a great tool to use when developing, as you can check that
    what you are doing is correct.
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
- en: Now, RViz **is not** a simulation tool. You don’t simulate anything; you **only
    visualize** what already exists. So, the robot and all the data you see in RViz
    is only the representation of what’s happening externally (of RViz). Instead of
    seeing and interacting with all the data in the terminal, you can do that with
    a graphical interface and see the data in 3D. That’s (very simply put) what RViz
    brings to you.
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
- en: For example, with TFs, RViz will subscribe to the **/tf** topic and display
    the TFs on the screen. However, RViz doesn’t control the TFs; it just shows them.
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
- en: Conversely, Gazebo is a simulation tool. It will simulate gravity and the real
    physical properties of the robot. It also has some control plugins so that you
    can simulate the hardware control, and even publish the joint states and TFs for
    your robot.
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
- en: So, what do we use here—Gazebo or RViz? Ultimately, it’s not a competition;
    both are complementary.
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
- en: Gazebo is available if you don’t have a real robot, if you don’t want to use
    it, or if you want to test a robotics system in a different environment, for example.
    With Gazebo, you can replicate the behavior of your robot, and make it very close
    to what it would do in real life.
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您没有真实机器人，或者不想使用它，或者想要在不同的环境中测试机器人系统，例如，Gazebo 是可用的。使用 Gazebo，您可以复制您机器人的行为，使其非常接近现实生活中的表现。
- en: 'On top of Gazebo, you can use RViz to visualize the TFs and other important
    data from your application. RViz is still a very useful tool to have during the
    development phase. So, the dilemma is not *Gazebo versus RViz*, but instead, *real
    robot versus Gazebo*. In the end, you can have either:'
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 在 Gazebo 之上，您可以使用 RViz 来可视化您的应用程序中的 TFs 和其他重要数据。RViz 在开发阶段仍然是一个非常有用的工具。因此，困境不是
    *Gazebo 与 RViz* 的比较，而是 *真实机器人 与 Gazebo* 的比较。最终，您可以选择以下任一方式：
- en: Real robot and RViz
  id: totrans-32
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 真实机器人与 RViz
- en: Gazebo simulation and RViz
  id: totrans-33
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Gazebo 模拟与 RViz
- en: In this chapter, we will use the second combination. We will spawn and control
    our robot in Gazebo. Then, we will also visualize it in RViz. What we see in RViz
    will be a reflection of what’s happening in Gazebo. If, later on, we switched
    to a real robot, we would ditch Gazebo but still use RViz to see whether everything
    still works well.
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将使用第二种组合。我们将在 Gazebo 中生成并控制我们的机器人。然后，我们还将使用 RViz 来可视化它。我们在 RViz 中看到的内容将是
    Gazebo 中发生情况的反映。如果我们后来切换到真实机器人，我们将放弃 Gazebo，但仍然使用 RViz 来查看一切是否仍然运行良好。
- en: Now that we have made this clarification, we can get started with Gazebo.
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经澄清了这一点，我们可以开始使用 Gazebo。
- en: Starting Gazebo
  id: totrans-36
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 启动 Gazebo
- en: Let’s run Gazebo and get used to the interface.
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们运行 Gazebo 并熟悉界面。
- en: 'First, you need to install Gazebo. We installed ROS 2 previously with **ros-<distro>-desktop**,
    which already contains a lot of packages. To get everything we need for Gazebo,
    install this additional package:'
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，您需要安装 Gazebo。我们之前已经使用 **ros-<distro>-desktop** 安装了 ROS 2，它已经包含了很多软件包。为了获取
    Gazebo 所需的一切，请安装此附加软件包：
- en: '[PRE0]'
  id: totrans-39
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: Make sure to replace **<distro>** with your current ROS 2 distribution, and
    after running this command, source your environment.
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 请确保将 **<distro>** 替换为您的当前 ROS 2 发行版，并在运行此命令后，source 您的环境。
- en: Note
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: 'Since we are using Ubuntu 24.04, this will install **Gazebo Harmonic**. For
    other Ubuntu versions, you can find the recommended Gazebo versions here: [https://gazebosim.org/docs/latest/getstarted/](https://gazebosim.org/docs/latest/getstarted/).'
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 由于我们使用的是 Ubuntu 24.04，这将安装**Gazebo Harmonic**。对于其他 Ubuntu 版本，您可以在以下位置找到推荐的 Gazebo
    版本：[https://gazebosim.org/docs/latest/getstarted/](https://gazebosim.org/docs/latest/getstarted/)。
- en: It’s important to note that Gazebo is actually independent from ROS 2\. You
    can run Gazebo on its own, without ROS 2\. In fact, you could even install Gazebo
    without any ROS 2 packages.
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 需要注意的是，Gazebo 实际上与 ROS 2 独立。您可以在没有 ROS 2 的情况下运行 Gazebo。实际上，您甚至可以在没有任何 ROS 2
    软件包的情况下安装 Gazebo。
- en: Gazebo has been designed as an independent robotics simulator that you can then
    use with ROS 2, as well as other robotics frameworks. Here, I will only focus
    on ROS 2\. The reason I mention this is just to make you understand that Gazebo
    and ROS are separate projects.
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: Gazebo 被设计为一个独立的机器人仿真器，您可以使用它与 ROS 2 一起使用，以及其他机器人框架。在这里，我将只关注 ROS 2。我之所以提到这一点，只是为了让您明白
    Gazebo 和 ROS 是独立的项目。
- en: We will start by running Gazebo on its own. Then, we will see how to connect
    Gazebo and ROS, which will be useful for planning the steps to adapt our project
    and simulate our ROS robot on Gazebo.
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将首先单独运行 Gazebo。然后，我们将看到如何连接 Gazebo 和 ROS，这对于规划适应我们的项目和在 Gazebo 上模拟我们的 ROS
    机器人非常有用。
- en: 'So, to start Gazebo (without ROS), run this command in a terminal:'
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，要启动 Gazebo（不使用 ROS），请在终端中运行此命令：
- en: '[PRE1]'
  id: totrans-47
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: You will be taken to a Gazebo quick-start menu. There, you can click on **Empty**
    to load an empty world. You also have other existing worlds (click on the different
    images, or use the search bar) that you can explore later on your own. Warning—some
    of these worlds may contain bugs and not work properly.
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 您将被带到 Gazebo 快速入门菜单。在那里，您可以点击**空**来加载一个空世界。您还有其他现有的世界（点击不同的图片或使用搜索栏），您可以在以后自己探索。警告——这些世界中的一些可能包含错误并且无法正常工作。
- en: To stop the simulation, press *Ctrl* + *C* in the terminal where you started
    Gazebo.
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 要停止模拟，请在启动 Gazebo 的终端中按 *Ctrl* + *C*。
- en: 'When running the Gazebo command, you can also directly specify the world you
    want to launch. World description files in Gazebo use the SDF format (a file with
    a **.sdf** extension), which is quite similar to URDF. Let’s start Gazebo with
    the empty world:'
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 当运行Gazebo命令时，你也可以直接指定你想要启动的世界。Gazebo中的世界描述文件使用SDF格式（一个带有**.sdf**扩展名的文件），这与URDF非常相似。让我们用空世界启动Gazebo：
- en: '[PRE2]'
  id: totrans-51
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: Now, take the time to move around the space using mouse controls. You can also
    use a laptop touchpad, but if possible, I really recommend that you have a mouse,
    which will make things easier going forward.
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，请花些时间使用鼠标控制移动空间。你也可以使用笔记本电脑的触摸板，但如果可能的话，我强烈建议你使用鼠标，这样会更容易进行下一步操作。
- en: At the bottom left of the screen, you will see a play button. Click on it to
    start the simulation.
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 在屏幕的左下角，你会看到一个播放按钮。点击它以开始模拟。
- en: After starting the simulation, you will see a percentage at the bottom-right
    part of the screen, representing the real-time factor. Basically, this will tell
    you immediately whether your computer is powerful enough for Gazebo. Personally,
    I have a real-time factor of about 98%, which means that the simulated time in
    Gazebo keeps up with real time at 98% speed (i.e., after 100 real seconds, 98
    seconds have passed in Gazebo). If your percentage is too low, it may be a sign
    that you need better performance. If you’re not sure, continue with the chapter,
    and you will quickly see whether the robot simulation works properly or not.
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 在启动模拟后，你会在屏幕的右下角看到一个百分比，表示实时因子。基本上，这将立即告诉你你的计算机是否足够强大以运行Gazebo。我个人有一个大约98%的实时因子，这意味着在Gazebo中的模拟时间以98%的速度与实时保持同步（即，在100个真实秒后，Gazebo中过去了98秒）。如果你的百分比太低，这可能是一个你需要更好的性能的信号。如果你不确定，继续阅读本章，你将很快看到机器人模拟是否正常工作。
- en: Note
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: Gazebo can be quite buggy, so don’t be surprised if it crashes at some point—even
    on a powerful computer. If you can’t close Gazebo properly (with *Ctrl* + *C*
    in the terminal), you may have some trouble when starting it again. In this case,
    you can try to stop all Gazebo processes that might still be running in the background.
    To do that, run `ps aux | grep gz` to find all related processes. You will find
    a `pid` with four numbers for each `gz` process (if any). To stop a process, run
    `kill –9 <pid>`. If nothing works, the best thing to do is to restart your computer.
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: Gazebo可能会出现很多问题，所以如果你在某些时候看到它崩溃，甚至是在功能强大的计算机上，也不要感到惊讶。如果你无法正确关闭Gazebo（在终端中使用*Ctrl*
    + *C*），当你再次启动它时可能会遇到一些麻烦。在这种情况下，你可以尝试停止所有可能仍在后台运行的Gazebo进程。为此，运行`ps aux | grep
    gz`以找到所有相关进程。对于每个`gz`进程（如果有），你将找到一个包含四个数字的`pid`。要停止一个进程，运行`kill –9 <pid>`。如果什么方法都不奏效，最好的办法是重新启动你的计算机。
- en: Let’s return to the simulation we started—at the top of the screen, you can
    click on the different shapes and add them to the empty space. Take some time
    to experiment with this. Add a box into the space. Find the translation mode and
    rotation mode. Move the box around (especially on the *z* axis) and see what happens.
    If you lift the box up, then you should see the box falling down on the floor.
    This is because of the gravity and physical properties of the box.
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们回到我们开始模拟的场景——在屏幕顶部，你可以点击不同的形状并将它们添加到空空间中。花些时间来实验一下。将一个盒子添加到空间中。找到平移模式和旋转模式。移动盒子（尤其是在*z*轴上）并看看会发生什么。如果你把盒子举起来，你应该看到盒子掉到地板上。这是因为重力和盒子的物理属性。
- en: '![Figure 13.1: The Gazebo simulator with a box in an empty world](img/B22403_13_1.jpg)'
  id: totrans-58
  prefs: []
  type: TYPE_IMG
  zh: '![图13.1：Gazebo模拟器中空世界中的盒子](img/B22403_13_1.jpg)'
- en: 'Figure 13.1: The Gazebo simulator with a box in an empty world'
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 图13.1：Gazebo模拟器中空世界中的盒子
- en: What we can do next is explore the communications used by Gazebo. Gazebo also
    uses topics and services, but those are not the same as ROS 2 topics and services.
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 我们接下来可以探索Gazebo使用的通信。Gazebo也使用主题和服务，但它们与ROS 2的主题和服务并不相同。
- en: 'For example, you can list all Gazebo topics with this command:'
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，你可以使用此命令列出所有Gazebo主题：
- en: '[PRE3]'
  id: totrans-62
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: You will see a lot of topics, but if you try to run **ros2 topic list** in another
    terminal, none of those topics will appear. Also, when running **ros2 node list**,
    you won’t see any nodes.
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 你将看到很多主题，但如果你在另一个终端中尝试运行**ros2 topic list**，这些主题将不会出现。同样，当运行**ros2 node list**时，你也不会看到任何节点。
- en: With this, you can see that Gazebo is completely independent of ROS 2, and they
    do not interact with each other.
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 通过这个，你可以看到Gazebo完全独立于ROS 2，并且它们之间没有交互。
- en: How Gazebo works with ROS 2
  id: totrans-65
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: Gazebo如何与ROS 2协同工作
- en: We will now explore how Gazebo and ROS 2 can be connected.
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在将探讨如何将Gazebo和ROS 2连接起来。
- en: 'First of all, you can start Gazebo using a ROS 2 launch file from the **ros_gz_sim**
    package. This will be more practical for us because when we write our own launch
    file, we can include this one:'
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，你可以使用**ros_gz_sim**软件包中的ROS 2启动文件启动Gazebo。这对我们来说将更加实用，因为当我们编写自己的启动文件时，我们可以包括这个文件：
- en: '[PRE4]'
  id: totrans-68
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'This will start Gazebo the same way we did with the **gz sim** command. You
    can also specify the world to launch with the **gz_args** argument:'
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 这将以与**gz sim**命令相同的方式启动Gazebo。你也可以使用**gz_args**参数指定要启动的世界：
- en: '[PRE5]'
  id: totrans-70
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: However, even if we started Gazebo from a ROS 2 launch file, Gazebo is still
    independent. Try to list all the nodes and topics in a terminal; you will see
    the same result as before.
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，即使我们从ROS 2启动文件启动了Gazebo，Gazebo仍然是独立的。尝试在终端中列出所有节点和主题；你将看到与之前相同的结果。
- en: To connect Gazebo and ROS 2 topics (or services), you need to create a bridge
    between them. The **ros_gz_bridge** package does that for us, so we will use this
    package. We will only need to provide some configuration to specify which topics
    we want to bridge; how to write this configuration will be covered later in the
    chapter.
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 要连接Gazebo和ROS 2的主题（或服务），你需要在这两者之间创建一个桥梁。**ros_gz_bridge**软件包为我们做了这件事，所以我们将使用这个软件包。我们只需要提供一些配置来指定我们想要桥接的主题；如何编写这个配置将在本章后面介绍。
- en: '![Figure 13.2: Connecting Gazebo and ROS 2 with ros_gz_bridge](img/B22403_13_2.jpg)'
  id: totrans-73
  prefs: []
  type: TYPE_IMG
  zh: '![图13.2：使用ros_gz_bridge连接Gazebo和ROS 2](img/B22403_13_2.jpg)'
- en: 'Figure 13.2: Connecting Gazebo and ROS 2 with ros_gz_bridge'
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 图13.2：使用ros_gz_bridge连接Gazebo和ROS 2
- en: 'In *Figure 13**.2*, you can see the following:'
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 在*图13.2*中，你可以看到以下内容：
- en: On the right, our current ROS 2 application with the `robot_state_publisher`
    node, publishing on the `/``tf` topic.
  id: totrans-76
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在右侧，我们的当前ROS 2应用程序与`robot_state_publisher`节点，发布在`/tf`主题上。
- en: On the left, `Gazebo`. Inside `Gazebo`, we will add plugins (also called systems)
    to simulate the hardware behavior of the robot. For example, you could have one
    plugin to control the two wheels, and one plugin to publish the joint states for
    the wheels. This is what we will implement in this chapter.
  id: totrans-77
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在左侧，`Gazebo`。在`Gazebo`内部，我们将添加插件（也称为系统）来模拟机器人的硬件行为。例如，你可以有一个插件来控制两个轮子，另一个插件来发布轮子的关节状态。这就是我们在本章中要实现的内容。
- en: Then, to make everything work together, we will use the `ros_gz_bridge` package.
    With the joint state example, the Gazebo Joint state publisher plugin will publish
    the joint states with a Gazebo topic. Using `ros_gz_bridge`, we will match this
    topic with the ROS 2 `/``joint_states` topic.
  id: totrans-78
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 然后，为了使所有组件协同工作，我们将使用`ros_gz_bridge`软件包。在关节状态示例中，Gazebo关节状态发布插件将使用Gazebo主题发布关节状态。通过使用`ros_gz_bridge`，我们将匹配此主题与ROS
    2的`/joint_states`主题。
- en: The important thing to understand here is that Gazebo and ROS 2 exist in two
    different environments, but you can make them work together. Your ROS 2 application
    will be the same, whether you work on a Gazebo simulation or a real robot. If
    you work on a real robot, then you would directly control the wheels and get the
    joint state data from encoders. With Gazebo, you use plugins to simulate the hardware.
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 这里需要理解的重要一点是，Gazebo和ROS 2存在于两个不同的环境中，但你可以使它们协同工作。无论你在Gazebo模拟还是真实机器人上工作，你的ROS
    2应用程序都是一样的。如果你在真实机器人上工作，那么你将直接控制轮子，并从编码器获取关节状态数据。使用Gazebo，你使用插件来模拟硬件。
- en: 'Now, here are the steps we will take in the following sections to create the
    Gazebo simulation for our robot:'
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，以下是我们在以下章节中将要采取的步骤来创建机器人的Gazebo模拟：
- en: Adapt the URDF for Gazebo. For a robot to work on Gazebo, we first need to provide
    inertial and collision properties in the URDF.
  id: totrans-81
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 为Gazebo适配URDF。为了让机器人在Gazebo上工作，我们首先需要在URDF中提供惯性和碰撞属性。
- en: Once the URDF is correct, we will start Gazebo and spawn the URDF in it. At
    this point, we will also create a package with a launch file.
  id: totrans-82
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 一旦URDF正确，我们将启动Gazebo并在其中生成URDF。在这个时候，我们还将创建一个包含启动文件的软件包。
- en: We will then add some plugins (systems) to control the robot, using the `ros_gz_bridge`
    package to make those plugins communicate with our ROS 2 application.
  id: totrans-83
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后，我们将添加一些插件（系统）来控制机器人，使用`ros_gz_bridge`软件包使这些插件与我们的ROS 2应用程序通信。
- en: You can follow this process for basically any ROS 2 robot you want to simulate
    in Gazebo. If some things are still not clear, continue with the chapter, work
    on the implementation, and come back to this section at the end. Everything will
    make more sense.
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以遵循这个过程来模拟任何你想要在Gazebo中模拟的ROS 2机器人。如果某些事情仍然不清楚，继续阅读本章，进行实现工作，并在最后回到这一节。一切都会变得更有意义。
- en: Let’s start with the first step.
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们从第一步开始。
- en: Adapting the URDF for Gazebo
  id: totrans-86
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 适配URDF以用于Gazebo
- en: We could try to spawn our robot directly into Gazebo, but it won’t work, as
    the URDF is missing two key elements—inertial and collision properties. Gazebo
    needs those to correctly simulate a robot.
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以尝试直接在Gazebo中生成我们的机器人，但这是不可能的，因为URDF缺少两个关键元素——惯性和碰撞属性。Gazebo需要这些来正确模拟机器人。
- en: Thus, before we do anything with Gazebo, we need to come back to our URDF and
    add those properties. For each link of the robot that represents a physical part,
    we will add an **<inertial>** tag and a **<collision>** tag. In this section,
    you will learn how to properly configure those.
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，在我们对Gazebo做任何事情之前，我们需要回到我们的URDF并添加这些属性。对于代表物理部分的每个机器人链接，我们将添加一个**<inertial>**标签和一个**<collision>**标签。在本节中，你将学习如何正确配置这些标签。
- en: We will modify the URDF we created in the **my_robot_description** package.
    As a quick recap, this package contains the URDF, a launch file to display the
    robot model in RViz, and an RViz configuration. The most important thing in this
    package is the URDF. The launch file will help us validate that the values we
    set in the URDF are correct.
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将修改在**my_robot_description**包中创建的URDF。快速回顾一下，这个包包含URDF、一个用于在RViz中显示机器人模型的启动文件和一个RViz配置文件。这个包中最重要的东西是URDF。启动文件将帮助我们验证我们在URDF中设置的值是否正确。
- en: Let’s start with the inertial properties and then add the collision ones.
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们从惯性特性开始，然后添加碰撞特性。
- en: Inertial tags
  id: totrans-91
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 惯量标签
- en: A URDF without inertial properties won’t load in Gazebo. Thus, this is the first
    thing you need to add.
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 没有惯性特性的URDF无法在Gazebo中加载。因此，这是你需要添加的第一件事。
- en: An **<inertial>** tag will contain a few elements, including a 3x3 matrix representing
    an inertia tensor. In this book, we won’t dive into the theoretical inertia details;
    you can look that up on your own if you want, as there is pretty good documentation
    on the internet. Instead, we will focus on finding the correct formulas and applying
    them, allowing us to spawn the robot and quickly move on to the next steps.
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 一个**<inertial>**标签将包含几个元素，包括一个表示惯量张量的3x3矩阵。在这本书中，我们不会深入探讨理论上的惯量细节；如果你有兴趣，可以自己查阅，因为互联网上有相当好的文档。相反，我们将专注于找到正确的公式并应用它们，这样我们就可以生成机器人并快速进入下一步。
- en: 'So, currently, our URDF is split into three files. We will add some code to
    those files:'
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，目前我们的URDF被分成三个文件。我们将向这些文件添加一些代码：
- en: '`common_properties.xacro`: Here, we will add some macros to specify the inertial
    properties for a box, a cylinder, and a sphere. This way, we only need to write
    the inertial formulas once for those shapes, and you can reuse them in any of
    your projects.'
  id: totrans-95
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`common_properties.xacro`：在这里，我们将添加一些宏来指定盒子、圆柱体和球体的惯性特性。这样，我们只需要为这些形状写一次惯性公式，你可以在任何项目中重复使用它们。'
- en: '`mobile_robot.xacro`: Inside each link representing a physical part, we will
    use the corresponding inertial macro we defined previously.'
  id: totrans-96
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`mobile_robot.xacro`：在代表物理部分的每个链接内，我们将使用之前定义的相应惯性宏。'
- en: '`my_robot.urdf.xacro`: Nothing changes here; we still import the two previous
    files.'
  id: totrans-97
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`my_robot.urdf.xacro`：这里没有变化；我们仍然导入前两个文件。'
- en: Now, how do we write the inertial macros for the shapes we have in our URDF?
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们如何为URDF中的形状编写惯性宏？
- en: What do we write inside an <inertial> tag?
  id: totrans-99
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 我们在**<inertial>**标签内写什么？
- en: 'We will create three Xacro macros containing an **<inertial>** tag—one for
    a box, one for a cylinder, and one for a sphere. Inside a URDF **<inertial>**
    tag, you will need to provide:'
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将创建三个包含**<inertial>**标签的Xacro宏——一个用于盒子，一个用于圆柱体，一个用于球体。在URDF的**<inertial>**标签内，你需要提供：
- en: The mass of the element (in kg).
  id: totrans-101
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 元素的质量（以千克为单位）。
- en: The origin for the inertia (in meters and radians).
  id: totrans-102
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 惯性的起源（以米和弧度为单位）。
- en: The nine elements of the inertia tensor, or matrix (in kg per sqm). Since the
    matrix is symmetrical, we only need six elements—`ixx`, `ixy`, `ixz`, `iyy`, `iyz`,
    and `izz` (for example, `ixy` and `iyx` are the same, so we omit the second one).
  id: totrans-103
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 惯量张量或矩阵的九个元素（以千克每平方米为单位）。由于矩阵是对称的，我们只需要六个元素——`ixx`、`ixy`、`ixz`、`iyy`、`iyz`和`izz`（例如，`ixy`和`iyx`是相同的，所以我们省略第二个）。
- en: As we don’t have a physical robot for this project, we will arbitrarily decide
    on a mass property for each link—while, of course, trying to have values that
    make sense.
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 由于我们在这个项目中没有物理机器人，我们将任意决定每个连杆的质量属性—当然，同时尽量使这些值有意义。
- en: Now, how do we compute the inertia matrix? This is usually the hardest part
    when writing the **<****inertial>** tags.
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 那么，我们如何计算惯性矩阵呢？这通常是编写 **<inertial>** 标签时最困难的部分。
- en: If you are designing your robot with CAD software—for example, with **SolidWorks**—then
    you can export each property directly from the software and add them to your URDF.
    As we don’t have this software, we will need to make the computation ourselves.
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你使用 CAD 软件设计你的机器人—例如，使用 **SolidWorks**—那么你可以直接从软件中导出每个属性并将它们添加到你的 URDF 中。由于我们没有这个软件，我们需要自己进行计算。
- en: 'Fortunately, there are some helpful resources on the internet. You can find
    a list of moments of inertia on Wikipedia: [https://en.wikipedia.org/wiki/List_of_moments_of_inertia](https://en.wikipedia.org/wiki/List_of_moments_of_inertia).
    There, you can also find the moment of inertia for each simple shape that we have,
    as well as a list of 3D inertia tensors, which are basically the matrices we need
    for the URDF. One thing to note is that the matrices only have three non-zero
    components—**ixx**, **iyy**, and **izz**. All the other components are set to
    **0**.'
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 幸运的是，互联网上有一些有用的资源。你可以在维基百科上找到一个惯性矩的列表：[https://en.wikipedia.org/wiki/List_of_moments_of_inertia](https://en.wikipedia.org/wiki/List_of_moments_of_inertia)。在那里，你还可以找到我们拥有的每个简单形状的惯性矩，以及一个
    3D 惯性张量列表，这基本上是我们为 URDF 需要的矩阵。需要注意的是，矩阵只有三个非零分量—**ixx**、**iyy** 和 **izz**。所有其他分量都设置为
    **0**。
- en: With this information, we can start writing the **<****inertial>** tags.
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 有了这个信息，我们可以开始编写 **<inertial>** 标签。
- en: Adding inertial macros for basic shapes
  id: totrans-109
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 为基本形状添加惯性宏
- en: As the inertial macros for basic shapes could be used by any robot, we will
    add all macros in the **common_properties.xacro** file. This way, if you want
    to create another URDF for another robot, you can just reuse this Xacro file.
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 由于基本形状的惯性宏可以被任何机器人使用，我们将在 **common_properties.xacro** 文件中添加所有宏。这样，如果你想为另一个机器人创建另一个
    URDF，你只需重用这个 Xacro 文件即可。
- en: The first macro will be for a box inertia. Now, if you look at the preceding
    Wikipedia link, things could be a bit confusing, as they use **width**, **depth**,
    and **height** (*w*, *d*, and *h*). In ROS 2, we have specified the length, width,
    and height for the *x*, *y*, and *z* dimensions. Which one corresponds to which?
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 第一个宏将是用于盒子的惯性。现在，如果你查看前面的维基百科链接，可能会有些困惑，因为它们使用 **width**、**depth** 和 **height**（*w*、*d*
    和 *h*）。在 ROS 2 中，我们为 *x*、*y* 和 *z* 维度指定了长度、宽度和高度。哪一个对应哪一个？
- en: One easy way to write this matrix properly is to realize that one component
    for one dimension uses the two other dimensions. For example, to compute the *w*
    component (**ixx** in the matrix), we use *h* (*z*) and *d* (*y*). Only following
    this can remove a lot of confusion, especially with the different naming conventions.
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 正确编写这个矩阵的一个简单方法就是意识到一个维度的分量使用了其他两个维度。例如，为了计算 *w* 分量（矩阵中的 **ixx**），我们使用 *h*（z）和
    *d*（y）。只有遵循这一点才能消除很多困惑，特别是与不同的命名约定有关。
- en: 'Here is what we will use (on the left, the Wikipedia value, and on the right,
    the ROS 2 value):'
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 这里是我们将使用的内容（左边是维基百科的值，右边是 ROS 2 的值）：
- en: '**w**: the *x* dimension'
  id: totrans-114
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**w**: x 轴维度'
- en: '**d**: the *y* dimension'
  id: totrans-115
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**d**: y 轴维度'
- en: '**h**: the *z* dimension (this is also the axis pointing up)'
  id: totrans-116
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**h**: z 轴维度（这同时也是指向上的轴）'
- en: 'Here is the **<inertial>** tag for a box. You can add this after the **<material>**
    tags, inside the **<****robot>** tag:'
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 这里是盒子的 **<inertial>** 标签。你可以在 **<material>** 标签之后，在 **<robot>** 标签内添加这个标签：
- en: '[PRE6]'
  id: totrans-118
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: To make it simple, I used **x**, **y**, and **z** directly (instead of *w*,
    *d*, and *h*), which will make things easier when we need to use the macro in
    our links, where the box dimensions are defined with **x**, **y**, and **z**.
    When you develop an API/interface/macro/function, the best practice is to design
    the interface for the client of the API, not for the developer who’s writing the
    API.
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 为了简化，我直接使用了 **x**、**y** 和 **z**（而不是 *w*、*d* 和 *h*），这样在我们需要使用链接中的宏时，会更容易，因为盒子的尺寸是用
    **x**、**y** 和 **z** 定义的。当你开发 API/接口/宏/函数时，最佳实践是为 API 的客户端设计接口，而不是为编写 API 的开发者设计。
- en: 'Let’s now write the macro for a cylinder. This one is a bit easier. We have
    two components—radius and height. This will correspond to the radius and length
    we defined in the URDF:'
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们编写圆柱体的宏。这个稍微简单一些。我们有两个组件——半径和高度。这将与我们在 URDF 中定义的半径和长度相对应：
- en: '[PRE7]'
  id: totrans-121
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'Finally, we can write the macro for a (solid) sphere. This is the easiest,
    and we only have one component —the sphere radius:'
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们可以为（实心）球体编写宏。这是最简单的，我们只有一个组件——球体半径：
- en: '[PRE8]'
  id: totrans-123
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: With those three macros, we have everything we need for all the basic URDF shapes.
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 通过这三个宏，我们拥有了所有基本 URDF 形状所需的一切。
- en: Including the inertial macros in the links
  id: totrans-125
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 包括链接中的惯性宏
- en: We can now use those macros to provide the inertial property for each link of
    the robot.
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在可以使用这些宏为机器人的每个链接提供惯性属性。
- en: As the **base_footprint** doesn’t represent a physical part (it’s what we call
    a virtual link), it won’t have an inertia. For all the other links (base, right
    wheel, left wheel, and sphere), we will use the inertial macros.
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 由于 **base_footprint** 不代表一个物理部分（我们称之为虚拟链接），它不会有惯性。对于所有其他链接（基础、右轮、左轮和球体），我们将使用惯性宏。
- en: Open the **mobile_base.xacro** file, which is where we will continue with the
    code.
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 打开 **mobile_base.xacro** 文件，这是我们继续编写代码的地方。
- en: Now, to add the inertial property for a link, you need to add an **<inertial>**
    tag inside the **<link>** tag. To add this tag, we will use the macros we previously
    created.
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，要添加链接的惯性属性，你需要在 `<link>` 标签内添加一个 **<inertial>** 标签。为了添加这个标签，我们将使用之前创建的宏。
- en: 'Let’s start with **base_link**. Inside the **<link name="base_link"></link>**
    tag, and after the **<visual>** tag, add the **box_inertia** macro:'
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们从 **base_link** 开始。在 `<link name="base_link"></link>` 标签内，并在 `<visual>` 标签之后，添加
    **box_inertia** 宏：
- en: '[PRE9]'
  id: totrans-131
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: Note
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: Both the `<visual>` and `<inertial>` tags are children of the `<link>` tag;
    do not add the `<inertial>` tag inside the `<``visual>` tag.
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: '`<visual>` 和 `<inertial>` 标签都是 `<link>` 标签的子标签；不要在 `<visual>` 标签内添加 `<inertial>`
    标签。'
- en: 'We specify all the parameters required for the macro:'
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 我们指定了宏所需的全部参数：
- en: '`5.0` kg.'
  id: totrans-135
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`5.0` kg。'
- en: '`x`, `y`, and `z` dimensions (we have created the macro so that we can use
    the ROS 2 axis system convention).'
  id: totrans-136
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`x`、`y` 和 `z` 维度（我们创建了宏以便可以使用 ROS 2 轴系约定）。'
- en: '`<inertial>` tags, we will verify the inertia in RViz. There, you can easily
    see whether the inertia is correctly placed.'
  id: totrans-137
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`<inertial>` 标签，我们将在 RViz 中验证惯性。在那里，你可以轻松地看到惯性是否放置正确。'
- en: 'Now, add the inertia for the two wheels. You will add the **cylinder_inertia**
    macro inside the **wheel_link** macro (it’s perfectly fine to use a macro within
    another macro). Make sure to place it inside the **<link>** tag and after the
    **<visual>** tag. This inertia macro will apply to both wheels:'
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，添加两个轮子的惯性。你需要在 `wheel_link` 宏内添加 **cylinder_inertia** 宏（在宏内使用另一个宏是完全可行的）。确保将其放置在
    `<link>` 标签内，并在 `<visual>` 标签之后。这个惯性宏将应用于两个轮子：
- en: '[PRE10]'
  id: totrans-139
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'Here are the parameters we specify:'
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 这里是我们指定的参数：
- en: '`1.0` kg.'
  id: totrans-141
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`1.0` kg。'
- en: '**Cylinder properties**: The radius and length of the cylinder.'
  id: totrans-142
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**圆柱体属性**：圆柱体的半径和长度。'
- en: '`z` axis. The wheels’ visual has been shifted by 90° on the `x` axis so that
    the rotation axis becomes the `y` axis. Here, we provide the same rotation for
    the origin. Basically, once again, you can use the same values you wrote in the
    visual origin.'
  id: totrans-143
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`z` 轴。轮子的视觉在 `x` 轴上已旋转 90°，以便旋转轴成为 `y` 轴。在这里，我们提供相同的旋转给原点。基本上，再次使用你在视觉原点中写的相同值。'
- en: 'Finally, we add the **sphere_inertia** macro for **caster_wheel_link**:'
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们为 `caster_wheel_link` 添加了 **sphere_inertia** 宏：
- en: '[PRE11]'
  id: totrans-145
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: This one is quite easy. We choose **0.5** kg for the mass, and then we provide
    **radius**, which is the only sphere property. We don’t need to specify any offset
    for the origin.
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 这个很简单。我们选择 **0.5** kg 的质量，然后提供 **半径**，这是唯一的球体属性。我们不需要指定原点的任何偏移量。
- en: That’s it for the **<inertial>** tags. The main difficulty was to define the
    macro for the simple shapes (but you only need to do this once), and then to correctly
    use the macros and provide the correct origin. Let’s now verify that we provided
    the correct dimension values and origins, using RViz.
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 这就是 `<inertial>` 标签的全部内容。主要困难在于定义简单形状的宏（但你需要只做一次），然后正确使用宏并提供正确的原点。现在，让我们使用 RViz
    验证我们提供的正确尺寸值和原点。
- en: Validating inertia with RViz
  id: totrans-148
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 使用 RViz 验证惯性
- en: To make sure that the inertial property is correct for each link, you can use
    RViz. As we already have created a launch file inside the **my_robot_description**
    package, let’s use it to visualize the URDF in RViz.
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
- en: 'Don’t forget to build and source the workspace before you start RViz. Then,
    start the launch file:'
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  id: totrans-151
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'You will see the same view and configuration from the previous chapter. To
    see the inertia, first disable the visual. On the left menu, open **RobotModel**
    and uncheck **Visual Enabled**. Then, still inside **RobotModel**, open **Mass
    Properties** and check the **Inertia** box. You should see something like this:'
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 13.3: Visualizing inertia in RViz](img/B22403_13_3.jpg)'
  id: totrans-153
  prefs: []
  type: TYPE_IMG
- en: 'Figure 13.3: Visualizing inertia in RViz'
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
- en: With this view, you can easily spot errors. For example, if the offset for the
    **base_link** inertia is not right, then the box will not be correctly placed.
    Another common error will be in the rotation of the wheel inertia. In the preceding
    figure, you can see that the inertia box is more or less on top of the wheel,
    correctly orientated. If that’s not the case, you know you have to fix the inertia
    in the code.
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
- en: Once you are done with the **<inertial>** tags, you can add the **<****collision>**
    tags.
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
- en: Collision tags
  id: totrans-157
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: So far, inside each link of our URDF, we have a **<visual>** tag to see the
    link and an **<inertial>** tag to describe the physical properties for Gazebo.
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
- en: However, there is something missing. The visual is only for you to visualize
    the link in RViz or Gazebo. However, Gazebo needs more than this to simulate the
    robot. You will have to add **<collision>** tags to the links so that Gazebo can
    compute how two parts collide with each other.
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
- en: To give you an idea, if you don’t have any collision property for your robot,
    then the robot will fall through the ground and continue falling indefinitely.
    With a collision property, the robot will *collide* with the ground and, thus,
    not fall. On top of that, that property will be used to compute collisions between
    different parts of the robot, or collisions with other robots and elements in
    an environment. For example, if the robot collides with a wall or an object, it
    will bump into it and not go through it. Once again, the **<visual>** tag doesn’t
    do any of this.
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
- en: Before we write the **<collision>** tags for our robot, let’s understand how
    to define a collision.
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
- en: How to define a collision element
  id: totrans-162
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'A **<collision>** tag will contain more or less the same thing as a **<visual>**
    tag: **<geometry>** and **<origin>** tags. You will basically define a shape.'
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
- en: As a general rule, for a collision, you will use a simpler shape than for the
    visual (if possible). The reason is simple—the more complex the shape, the more
    computation power will be required to compute the collision between the link and
    other elements. This could slow down the simulation a lot. Thus, designing simpler
    shapes is a best practice.
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
- en: 'Here are a few more details about defining a collision element:'
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
- en: If you are using complex Collada files (a few MB) for visuals, use simpler Collada
    or even STL files for the collisions. You can add those files to the `meshes`
    folder and include them in the URDF.
  id: totrans-166
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: If the shape is close to a basic one (a box, cylinder, or sphere), then you
    can use a basic shape for the collision. For example, if you design a mobile robot
    and the base of the robot looks like a box, then you can use a complex Collada
    or STL file for the visual, only using a box for the collision. For a wheel, you
    can use a cylinder, sphere, and so on.
  id: totrans-167
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Even when using basic shapes, you could reduce the complexity—for example, by
    using a box for a collision when the visual is a cylinder or a sphere (however,
    we will see an exception to this later in this section in order to reduce friction
    in Gazebo).
  id: totrans-168
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: To find real examples of this shape simplification, you can simply search on
    GitHub for existing projects. Find a robot powered by ROS 2, and type **<name
    of the robot>** + **description** + **github** into Google—you can try with the
    *TurtleBot 3* (or a more recent version) robot. You will usually find a package
    similar to the one you created in the previous chapter. In this package, search
    for the URDF or Xacro files, and find the **<collision>** tags. You will often
    see that the collision uses a simplified STL file or a basic URDF shape.
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
- en: Now that we have this simplification mindset, let’s add the **<collision>**
    tags inside the URDF.
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
- en: Adding collision properties for the links
  id: totrans-171
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: You will add **<collision>** tags inside the **<link>** tags, in the **mobile_base.xacro**
    file.
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
- en: Pay attention to where you add those tags. They should be at the same level
    as the **<visual>** and **<inertial>** tags, not inside them. The order doesn’t
    really matter, but to keep things clean, I usually start with **<visual>**, then
    **<collision>**, and finally, **<inertial>**.
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
- en: 'Here is the **<collision>** tag for **base_link**:'
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  id: totrans-175
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: A box is already the simplest shape you can have, so we just use another box.
    Then, we set the same dimensions and origin as for the visual. As you can see,
    adding the collision for this link basically means copying and pasting the content
    of the **<visual>** tag (except for **<material>**).
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
- en: Now, for the two wheels, the situation is a bit unique. They are cylinders,
    so it’s a quite basic shape. We could keep the same, or even use a box, which
    is much simpler.
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
- en: However, those wheels will be in direct contact with the floor in Gazebo. Using
    a box is not a good idea—imagine a car with square wheels; it’s probably not going
    to work well.
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
- en: We could keep a cylinder, which is the second most simple shape, but if you
    do this, you might experience some unwanted friction later on in Gazebo, which
    will result in the robot not moving exactly how we want. For wheels that you control
    and that touch the floor, it’s best to use a sphere for the collision, as this
    reduces the number of contact points with the ground (basically, just one contact
    point) and, thus, reduces the unwanted friction.
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
- en: Note
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
- en: This is more of a Gazebo *hack* than a real logical choice. Let’s be clear here—there
    is no way you can come up with this conclusion at this point; it’s something you
    have to experience in Gazebo and fix later. I’m not a big fan of such hacks, but
    sometimes, you don’t have a choice. Also, I’m giving you the correct solution
    beforehand to not make this chapter too long.
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s add a sphere collision for our wheels, inside the **wheel_link** macro:'
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  id: totrans-183
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: We just use the wheel radius property; there is no need for the wheel length
    here. And since it’s a sphere, there’s no need to add any rotation for the origin.
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
- en: 'Finally, we add the collision for the caster wheel. As stated before, we could
    simplify the sphere with a box, but as the caster wheel is in direct contact with
    the ground, we don’t want to add unwanted friction. Thus, we use the same sphere
    for the visual and the collision:'
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  id: totrans-186
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: That’s it for the **<collision>** tags. The URDF for our mobile robot is now
    complete.
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
- en: Validating collision with RViz
  id: totrans-188
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: As with everything we have written in the URDF, you can also visualize the collision
    properties in RViz.
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
- en: Build your workspace, source the environment, and start the **display.launch.xml**
    launch file again.
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
- en: Open the **RobotModel** menu and uncheck the **Visual Enabled** box. Then, check
    the **Collision** **Enabled** box.
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 13.4: Visualizing collision in RViz](img/B22403_13_4.jpg)'
  id: totrans-192
  prefs: []
  type: TYPE_IMG
- en: 'Figure 13.4: Visualizing collision in RViz'
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
- en: There, you can see whether the collision properties are correct. In the **Links**
    menu (inside **RobotModel**), you can enable only some links if necessary, giving
    you a more precise view.
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
- en: If you see that some collision elements are not correctly placed, or if they
    are too big or too small, you can then go back to your URDF and fix them.
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
- en: As you can see in the preceding figure, the collision view for the robot is
    almost the same as the visual. The difference is with the wheels, which are now
    spheres. You might also wonder, if the wheels are spheres, a part of them is inside
    the box, and thus they will collide with the box. That’s true, but this collision
    between adjacent links will not be taken into account by Gazebo.
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
- en: Now that you’ve added both the **<inertial>** and **<collision>** tags, we can
    go to the next step and spawn the robot in Gazebo.
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
- en: Spawning the robot in Gazebo
  id: totrans-198
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The first step of adapting the URDF for Gazebo was crucial, as without this,
    the robot either wouldn’t appear on Gazebo or behave incorrectly.
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
- en: Now that the URDF is done (and has been verified in RViz), we can spawn the
    robot in Gazebo. In this section, you will see what commands you need to run,
    and then we will create another package with a launch file to start everything.
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
- en: 'Here is what we will do:'
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
- en: Run the `robot_state_publisher` node with the URDF as a parameter.
  id: totrans-202
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Start the Gazebo simulator.
  id: totrans-203
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Spawn the robot in Gazebo.
  id: totrans-204
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Let’s start this with the terminal commands.
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
- en: Spawning the robot from the terminal
  id: totrans-206
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: As usual, before creating a launch file, we will run each command one by one
    in different terminals, enabling us to clearly understand what we need to run,
    with all the necessary details.
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
- en: Open three terminals to start all the commands.
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
- en: The first thing to start is the **robot_state_publisher** node. This is what
    we did in [*Chapter 12*](B22403_12.xhtml#_idTextAnchor573), and this is also usually
    the first thing you will start in any ROS 2 application.
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
- en: 'In Terminal 1, run the following command:'
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  id: totrans-211
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: This is the same as in the previous chapter. We pass the URDF with the **robot_description**
    parameter.
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
- en: After executing this command, the **robot_state_publisher** node starts and
    does three things—subscribes to **/joint_states**, publishes on **/tf**, and also
    publishes the URDF on **/robot_description**. You can verify this with **rqt_graph**
    if needed (in this case, make sure to uncheck the **Dead sinks** and **Leaf**
    **topics** boxes).
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
- en: In a second terminal, we start Gazebo. In fact, you could start Gazebo before
    **robot_state_publisher**; the order doesn’t matter for those first two steps.
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
- en: 'In Terminal 2, run the following command:'
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  id: totrans-216
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: With this, we start an empty world in Gazebo. By default, the time is stopped
    when you launch Gazebo. We add the **-r** option to start the time directly so
    that we don’t have to click the play button.
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
- en: Finally, once you have done the first two steps, you can spawn the robot in
    Gazebo. For this, we will use the **create** executable from the **ros_gz_sim**
    package. This will spawn a robot in Gazebo, using the URDF of the robot, which
    we can pass as a topic with the **-topic** option. As the **robot_state_publisher**
    node publishes the URDF on the **robot_description** topic, we can use this topic.
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
- en: 'In Terminal 3, run the following command:'
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  id: totrans-220
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'After running this command, you should see the robot in Gazebo:'
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 13.5: The robot spawned in Gazebo](img/B22403_13_5.jpg)'
  id: totrans-222
  prefs: []
  type: TYPE_IMG
- en: 'Figure 13.5: The robot spawned in Gazebo'
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
- en: If you get any error in any terminal, it probably means that your URDF is not
    correct. In this case, go back to the Xacro files and double-check everything.
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
- en: Note
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
- en: To see the importance of the `<inertial>` and `<collision>` tags, go back to
    the URDF, comment the inertia for the wheels, and then run the commands again.
    You will see that the wheels do not appear in Gazebo. Then, put the inertia back
    and comment the collision for the wheels. This time, the wheels will appear, but
    as they do not collide with the ground, you will see them going into the ground.
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
- en: Now that we know which commands to run, let’s write a launch file.
  id: totrans-227
  prefs: []
  type: TYPE_NORMAL
- en: Spawning the robot from a launch file
  id: totrans-228
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: We are now going to write a launch file to start those three commands. This
    will be a good base on which we can add more things later on.
  id: totrans-229
  prefs: []
  type: TYPE_NORMAL
- en: Let’s start by creating a new package in our workspace.
  id: totrans-230
  prefs: []
  type: TYPE_NORMAL
- en: Creating a _bringup package
  id: totrans-231
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: If you remember what we did in [*Chapter 9*](B22403_09.xhtml#_idTextAnchor443),
    the best practice is to create a dedicated package for launch files and configuration
    files (we don’t have any configuration files yet, but we will add one later in
    this chapter).
  id: totrans-232
  prefs: []
  type: TYPE_NORMAL
- en: We made an exception for the **display.launch.xml** file, which we placed inside
    the **my_robot_description** package. As explained in [*Chapter 12*](B22403_12.xhtml#_idTextAnchor573),
    this launch file is only used during development to visualize the URDF. Thus,
    it makes sense to have the launch file in the same package as the URDF. Here,
    and for any future launch and configuration files in our application, we will
    use a new dedicated package.
  id: totrans-233
  prefs: []
  type: TYPE_NORMAL
- en: Following the naming convention for such a package, we will start with the name
    of the robot or application, adding the **_bringup** suffix. Thus, we will create
    the **my_robot_bringup** package.
  id: totrans-234
  prefs: []
  type: TYPE_NORMAL
- en: Note
  id: totrans-235
  prefs: []
  type: TYPE_NORMAL
- en: Be careful not to confuse this package with the `my_robot_bringup` package in
    the `ros2_ws` we created in *Part 2* of the book. Here, in *Part 3*, we are using
    another workspace, named `my_robot_ws`, so the `my_robot_bringup` package is a
    completely different one.
  id: totrans-236
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s create this package, remove the unnecessary folders, and add a **launch**
    folder. We will also add a **config** folder, which we will use later in the chapter:'
  id: totrans-237
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  id: totrans-238
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'Now, in the **CMakeLists.txt** file of the **my_robot_bringup** package, add
    the instruction to install the **launch** and **config** folders:'
  id: totrans-239
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  id: totrans-240
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: The package is correctly set up, so we can now add and install files.
  id: totrans-241
  prefs: []
  type: TYPE_NORMAL
- en: Writing the launch file
  id: totrans-242
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Let’s create, write, and install the launch file to spawn the robot in Gazebo.
  id: totrans-243
  prefs: []
  type: TYPE_NORMAL
- en: 'First, create a new file inside the launch folder. As this launch file will
    be the main one, let’s simply use the name of the robot (or robotics application),
    **my_robot.launch.xml**:'
  id: totrans-244
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  id: totrans-245
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'Open the file and write the minimal code for an XML launch file:'
  id: totrans-246
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  id: totrans-247
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: Then, inside this **<launch>** tag, let’s add everything we need, step by step.
  id: totrans-248
  prefs: []
  type: TYPE_NORMAL
- en: 'The beginning of the launch file will be very similar to the **display.launch.xml**
    file that we wrote in the previous chapter, so we can basically copy and paste
    a few parts. We start by adding a variable for the path to the URDF file:'
  id: totrans-249
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  id: totrans-250
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'Now, we can start the **robot_state_publisher** node:'
  id: totrans-251
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  id: totrans-252
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'Then, we start Gazebo with an empty world, and we also use the **-r** option
    to start the time automatically:'
  id: totrans-253
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  id: totrans-254
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'Finally, we spawn the robot in Gazebo:'
  id: totrans-255
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  id: totrans-256
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: That’s it for the launch file for now. Later, we will add more things and also
    start RViz to visualize the TFs. For now, we just want to see the robot in Gazebo.
  id: totrans-257
  prefs: []
  type: TYPE_NORMAL
- en: 'There is one thing we can do to make things a bit cleaner—as we are using files,
    nodes, and launch files from other packages, let’s add a dependency to them in
    the **package.xml** file of the **my_robot_bringup** package. After the **<buildtool_depend>**
    line, add these lines:'
  id: totrans-258
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  id: totrans-259
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: We use the less strict **<exec_depend>** tag instead of **<depend>**, as we
    only require those dependencies to run the launch file, not to compile any code.
    With this, if, for example, you didn’t install the **ros_gz_sim** package and
    you try to build the **my_robot_bringup** package, you will get an error when
    running **colcon build**, and then you can fix things right away. Without those
    lines, the build would work, but you would then get an error when starting the
    launch file, which can be a big problem, especially in a production environment.
    So, the best practice is to specify all the dependencies you need in the **package.xml**
    file.
  id: totrans-260
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, save all the files, build the workspace, source the environment, and start
    the launch file (make sure that Gazebo is not running in another terminal before
    you do this):'
  id: totrans-261
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  id: totrans-262
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: You should get the same result as when we ran all three commands in the terminal.
  id: totrans-263
  prefs: []
  type: TYPE_NORMAL
- en: Controlling the robot in Gazebo
  id: totrans-264
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Our mobile robot is now simulated in Gazebo with physics properties. Now what?
    The robot is not doing anything. We will finish this chapter by adding control
    plugins so that we can simulate the hardware of the robot and do the following:'
  id: totrans-265
  prefs: []
  type: TYPE_NORMAL
- en: Send commands to make the robot move in Gazebo, just as if it were in the real
    world
  id: totrans-266
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Read all necessary joint states from the robot to get all the TFs in our ROS
    2 application
  id: totrans-267
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Before we start discussing Gazebo systems and bridges, let’s dive a little bit
    deeper and understand what’s missing and what we need to add.
  id: totrans-268
  prefs: []
  type: TYPE_NORMAL
- en: What do we need to do?
  id: totrans-269
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: When you start the **my_robot.launch.xml** launch file, you see the robot in
    Gazebo. However, we don’t have any way to control it. In a terminal, if you list
    all nodes, topics, services, or even actions, you won’t find anything we can use.
  id: totrans-270
  prefs: []
  type: TYPE_NORMAL
- en: 'Also, after starting the launch file, if you print the TF tree, you won’t see
    the TF for the right or left wheel. You can observe the same thing with RViz—to
    make things simple, you can start RViz using the previous configuration we saved:'
  id: totrans-271
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  id: totrans-272
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: You should see some errors in **RobotModel**, saying **No transform from [left_wheel_link]**
    and **No transform** **from [right_wheel_link]**.
  id: totrans-273
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 13.6: TF errors in RViz after spawning the robot in Gazebo](img/B22403_13_6.jpg)'
  id: totrans-274
  prefs: []
  type: TYPE_IMG
- en: 'Figure 13.6: TF errors in RViz after spawning the robot in Gazebo'
  id: totrans-275
  prefs: []
  type: TYPE_NORMAL
- en: This lack of TF is because nobody is publishing on the **/joint_states** topic.
    In [*Chapter 12*](B22403_12.xhtml#_idTextAnchor573), when we were just visualizing
    the robot model, we used a fake joint state publisher. We won’t do this here.
  id: totrans-276
  prefs: []
  type: TYPE_NORMAL
- en: So, what do we need to do?
  id: totrans-277
  prefs: []
  type: TYPE_NORMAL
- en: For a real robot, you would create a hardware driver to be able to control the
    wheels. This driver would expose a topic/service/action interface so that you
    could make the robot move. Then, you would read position/velocity data from encoders
    and publish this data on the **/joint_states** topic. With this, the loop is closed.
  id: totrans-278
  prefs: []
  type: TYPE_NORMAL
- en: For a Gazebo simulation, we will do the same thing but, of course, without hardware.
    We will use Gazebo plugins (also called systems) to simulate the control of the
    robot and get the joint states. Then, we will configure a *bridge* to make those
    plugins communicate with our ROS 2 application.
  id: totrans-279
  prefs: []
  type: TYPE_NORMAL
- en: Let’s start with the Gazebo systems.
  id: totrans-280
  prefs: []
  type: TYPE_NORMAL
- en: Adding Gazebo systems
  id: totrans-281
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: A Gazebo system is basically the simulation of a hardware component. You could
    have a system simulating a camera and publishing images, another one monitoring
    a battery state, and so on. For this book, we will use two systems—one to control
    a differential drive robot (two parallel wheels), and one to publish the joint
    states.
  id: totrans-282
  prefs: []
  type: TYPE_NORMAL
- en: Now, the good news is that there are a lot of existing systems already available
    to use, including the two that we need.
  id: totrans-283
  prefs: []
  type: TYPE_NORMAL
- en: The bad news is that documentation for those systems is almost non-existent
    (at the time of writing), and you will have to dive into the code itself to find
    what to include in your own code. Don’t worry about that—we will do this process
    step by step, and it is replicable for any other system that you use.
  id: totrans-284
  prefs: []
  type: TYPE_NORMAL
- en: 'For Gazebo Harmonic and ROS 2 Jazzy, you can find all available Gazebo systems
    here on GitHub: [https://github.com/gazebosim/gz-sim/tree/gz-sim8/src/systems](https://github.com/gazebosim/gz-sim/tree/gz-sim8/src/systems)
    (for other Gazebo versions, you might have to use a different branch).'
  id: totrans-285
  prefs: []
  type: TYPE_NORMAL
- en: Note
  id: totrans-286
  prefs: []
  type: TYPE_NORMAL
- en: If there was not enough confusion already, on the internet you will often see
    the term *plugin* or *system*; they both refer to the same thing. Even if the
    word *system* should be preferred, in practice it’s not clear which one to use;
    for example, to include a system in our code, we will need to use a `<plugin>`
    tag. So, in this section, I will have to use both terms.
  id: totrans-287
  prefs: []
  type: TYPE_NORMAL
- en: Now, where are we going to add our systems for the robot we want to simulate?
    We will do this in the URDF.
  id: totrans-288
  prefs: []
  type: TYPE_NORMAL
- en: Xacro file for Gazebo
  id: totrans-289
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The Gazebo systems for our robot will be specified in the URDF. So, we need
    to return to the **my_robot_description** package.
  id: totrans-290
  prefs: []
  type: TYPE_NORMAL
- en: 'Our URDF is now split into three files: one with common properties, one with
    the description of the robot (links and joints), and one to include the other
    two.'
  id: totrans-291
  prefs: []
  type: TYPE_NORMAL
- en: To add the Gazebo systems, we will create yet another Xacro file, dedicated
    to all Gazebo-related stuff. By separating this file from the other ones, we make
    things cleaner. If, later on, you want to use the URDF without Gazebo, you only
    need to remove the inclusion of the Gazebo file.
  id: totrans-292
  prefs: []
  type: TYPE_NORMAL
- en: In the **urdf** folder of your **my_robot_description** package, add a fourth
    file, named **mobile_base_gazebo.xacro**.
  id: totrans-293
  prefs: []
  type: TYPE_NORMAL
- en: 'Open the file and add the minimal Xacro code:'
  id: totrans-294
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  id: totrans-295
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: 'Now, in **my_robot.urdf.xacro**, include the file after the two other ones:'
  id: totrans-296
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  id: totrans-297
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: The Xacro file is ready, and we can now add the systems.
  id: totrans-298
  prefs: []
  type: TYPE_NORMAL
- en: Differential drive controller
  id: totrans-299
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The first system we will add is a **differential drive controller**. By differential
    drive, we mean a robot controlled by two wheels, one on each side of the robot.
  id: totrans-300
  prefs: []
  type: TYPE_NORMAL
- en: If you browse the available systems (the link is provided on the preceding page),
    you can find a **diff_drive** folder—usually in ROS, we use **diff drive** as
    an abbreviation of **differential drive**.
  id: totrans-301
  prefs: []
  type: TYPE_NORMAL
- en: In this folder, you will see a **DiffDrive.hh** file. Open this file, and there,
    near the beginning, you will find the XML tags related to the system (it’s possible
    that some tags will be missing here; for some systems, you might have to read
    the complete source code to find all available tags).
  id: totrans-302
  prefs: []
  type: TYPE_NORMAL
- en: 'Here is how to add the system to our Xacro file (**mobile_base_gazebo.xacro**):'
  id: totrans-303
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  id: totrans-304
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: We start with a **<gazebo>** tag. Everything related to Gazebo will be in such
    tags. Then, we include the system with a **<plugin>** tag. We also need to specify
    the filename and name for the system.
  id: totrans-305
  prefs: []
  type: TYPE_NORMAL
- en: Note
  id: totrans-306
  prefs: []
  type: TYPE_NORMAL
- en: 'Usually, the filename and name will follow this syntax:'
  id: totrans-307
  prefs: []
  type: TYPE_NORMAL
- en: '`gz-sim-<name-with-dashes>-system`'
  id: totrans-308
  prefs: []
  type: TYPE_NORMAL
- en: '`gz::sim::systems::<UpperCamelCaseName>` (you can also find the name at the
    bottom of the `.cc` file of the system)'
  id: totrans-309
  prefs: []
  type: TYPE_NORMAL
- en: 'Here is a bit more information about the different parameters for this diff
    drive system:'
  id: totrans-310
  prefs: []
  type: TYPE_NORMAL
- en: '`left_joint` and `right_joint`: You need to provide the exact name of the joints
    you have defined for the wheels in the URDF.'
  id: totrans-311
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`frame_id`: As the robot moves, we will keep track of where it is relative
    to its starting position. This starting position will be called `odom` (short
    for **odometry**).'
  id: totrans-312
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`child_frame_id`: We write `base_footprint`, as it is the root link for our
    robot and the one we want to use for odometry tracking.'
  id: totrans-313
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`wheel_separation`: We can compute that from the URDF. The base width is 0.4,
    and the origin for each wheel is centered on the wheel. As each wheel length is
    0.05, we need to add 0.4 + 0.025 + 0.025, which makes `0.45`.'
  id: totrans-314
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`wheel_radius`: We get this value from the URDF, which is defined as `0.1`.'
  id: totrans-315
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Acceleration and velocity min and max: Optionally, you can set some limits.
    This can be a good idea so that the controller doesn’t accept a command that would
    make the robot move too fast and, potentially, become dangerous to itself or an
    environment. For the values, once again, you should use the metric system and
    radians for angles.'
  id: totrans-316
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: That’s it for the diff drive system. Now, in addition, there is one setting
    we need to add for the caster wheel. If you remember, the caster wheel is a passive
    joint, so we defined it as a fixed sphere.
  id: totrans-317
  prefs: []
  type: TYPE_NORMAL
- en: As the wheels turn and the robot moves, there will be some friction between
    the ground and the caster wheel. You won’t see the friction that much in Gazebo,
    but it will slow down the robot a bit, and later on, if you visualize the robot
    in RViz, you won’t have the same result.
  id: totrans-318
  prefs: []
  type: TYPE_NORMAL
- en: 'So, we will reduce the friction for the caster wheel. You can add this code
    just before the code for the diff drive system:'
  id: totrans-319
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  id: totrans-320
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: There are two parameters, **mu1** and **mu2**, that you can set to have more
    control over the friction. I have chosen the value **0.1**; later, you could reduce
    this value even more.
  id: totrans-321
  prefs: []
  type: TYPE_NORMAL
- en: Joint state publisher
  id: totrans-322
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: We have added a system to control the wheels, but before we test it, let’s finish
    the Xacro file and add the second system we need. The diff drive system alone
    won’t publish the joint states for the wheels; we need to add a joint state publisher
    system.
  id: totrans-323
  prefs: []
  type: TYPE_NORMAL
- en: Go back to the systems page on GitHub, and you will find a **joint_state_publisher**
    folder. In this folder, you can get the *documentation* for the XML tags in the
    **JointStatePublisher.hh** file.
  id: totrans-324
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s add the system to the Xacro file, after the previous one:'
  id: totrans-325
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE34]'
  id: totrans-326
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: The joint state publisher system is easier to set up. Also, we don’t specify
    any **<joint_name>** tag here to publish all available joint states. If your robotics
    system contains a lot of joints, it could be useful to only specify the joints
    you want to use.
  id: totrans-327
  prefs: []
  type: TYPE_NORMAL
- en: Our **mobile_base_gazebo.xacro** file is now complete, and we won’t need to
    modify anything else in the URDF. We can spawn the robot in Gazebo again and see
    how it interacts with those systems.
  id: totrans-328
  prefs: []
  type: TYPE_NORMAL
- en: Bridging Gazebo and ROS 2 communications
  id: totrans-329
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The last thing we need to do, for this simulation to be complete, is to bridge
    Gazebo and ROS 2 communications.
  id: totrans-330
  prefs: []
  type: TYPE_NORMAL
- en: Let’s first understand what’s missing.
  id: totrans-331
  prefs: []
  type: TYPE_NORMAL
- en: What topics do we need to bridge?
  id: totrans-332
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: If you remember, we talked about this at the beginning of the chapter. Gazebo
    uses topics and services, but those are independent from ROS 2\. Thus, the systems
    we have just added will work, but they will only have a Gazebo interface.
  id: totrans-333
  prefs: []
  type: TYPE_NORMAL
- en: You can verify this by starting the **my_robot.launch.xml** file again—make
    sure to compile and source the workspace beforehand so that you get the updated
    URDF.
  id: totrans-334
  prefs: []
  type: TYPE_NORMAL
- en: 'Then, in another terminal, list all Gazebo topics. The list will contain quite
    a lot of things; here, I only include the ones that we will use:'
  id: totrans-335
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE35]'
  id: totrans-336
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: The first topic that ends with **/tf** will contain the TF from the **odom**
    frame to **base_footprint**. The one with **/joint_state** will contain the joint
    states for both wheels, and the topic with **/cmd_vel** will be used to send a
    velocity command to the robot.
  id: totrans-337
  prefs: []
  type: TYPE_NORMAL
- en: However, if you check the ROS 2 topics with **ros2 topic list**, you won’t see
    the **/cmd_vel** topic. You will have **/joint_states** and **/tf**, but only
    because the **robot_state_publisher** node creates a subscriber and publisher
    for those topics. Nothing is published; you can verify this with **ros2 topic**
    **echo <topic>**.
  id: totrans-338
  prefs: []
  type: TYPE_NORMAL
- en: Thus, from the ROS 2 side, we can’t communicate with Gazebo. We will need to
    create a bridge between ROS 2 and Gazebo using the **ros_gz_bridge** package (see
    *Figure 13**.2* at the beginning of the chapter).
  id: totrans-339
  prefs: []
  type: TYPE_NORMAL
- en: To do that, we will run the **parameter_bridge** node from the **ros_gz_bridge**
    package, with a configuration for the interfaces that we want to bridge.
  id: totrans-340
  prefs: []
  type: TYPE_NORMAL
- en: Adding a configuration file to bridge topics
  id: totrans-341
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Let’s start with the configuration file. In the **my_robot_bringup** package,
    inside the **config** folder (that we already created before), create a new file
    named **gazebo_bridge.yaml**.
  id: totrans-342
  prefs: []
  type: TYPE_NORMAL
- en: 'Open this file to write the configuration. Here is the first bridge we will
    create:'
  id: totrans-343
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE36]'
  id: totrans-344
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: 'Here are the different fields that we will use:'
  id: totrans-345
  prefs: []
  type: TYPE_NORMAL
- en: '`ros_topic_name`: The topic name on the ROS 2 side. Either you choose the topic
    name (`/cmd_vel` doesn’t exist yet, so we create it) or you make it match with
    an existing one (for the next one, we will have to specify exactly `/joint_states`).'
  id: totrans-346
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`gz_topic_name`: The topic name on the Gazebo size. We found it with `gz` `topic
    -l`.'
  id: totrans-347
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`ros_type_name`: The topic interface for ROS 2.'
  id: totrans-348
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`gz_type_name`: The topic interface for Gazebo. You can find it with `gz topic
    -i -``t <topic>`.'
  id: totrans-349
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`direction`: Either `ROS_TO_GZ`, `GZ_TO_ROS`, or `BIDIRECTIONAL`. For example,
    `/cmd_vel` is a topic that we publish in ROS 2 and subscribe in Gazebo, so we
    use `ROS_TO_GZ`. For `/joint_states`, we publish in Gazebo and subscribe in ROS
    2, so that will be `GZ_TO_ROS`. You can use `BIDIRECTIONAL` if you want to have
    publishers and subscribers on both sides of the same topic.'
  id: totrans-350
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: As you can see, we need to provide the topic name and interface on both sides
    and specify which direction to use for the communication. With this, the **ros_gz_bridge**
    will create the connection.
  id: totrans-351
  prefs: []
  type: TYPE_NORMAL
- en: 'With this first bridge, we will be able to send commands to the robot to make
    it move with the diff drive system. Let’s now add the configuration for the **/joint_states**
    topic (published by the joint state publisher system):'
  id: totrans-352
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE37]'
  id: totrans-353
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: 'That will allow us to get all joint states for the robot and, thus, see the
    wheel TFs in RViz. Finally, to get the **odom** to **base_footprint** TF (published
    by the diff drive system), we also add this bridge:'
  id: totrans-354
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE38]'
  id: totrans-355
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: The configuration file is complete. As we have already added the instruction
    to install it in **CMakeLists.txt**, there is no need to do anything else.
  id: totrans-356
  prefs: []
  type: TYPE_NORMAL
- en: Starting the Gazebo bridge with the configuration
  id: totrans-357
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: We can now add a new node to our **my_robot.launch.xml** file to start the bridge,
    using the YAML configuration file we’ve just created.
  id: totrans-358
  prefs: []
  type: TYPE_NORMAL
- en: 'First, at the beginning of the file, let’s add a new variable to find the path
    for the configuration file:'
  id: totrans-359
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE39]'
  id: totrans-360
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: 'Then, after you spawn the robot in Gazebo with the **create** executable from
    **ros_gz_sim**, start the Gazebo bridge. You will need to pass the configuration
    file inside a **config_file** parameter:'
  id: totrans-361
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE40]'
  id: totrans-362
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: 'As we use the **ros_gz_bridge** package inside **my_robot_bringup**, we will
    also add a new dependency inside the **package.xml** file:'
  id: totrans-363
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE41]'
  id: totrans-364
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: The Gazebo bridge is now correctly configured. When you start your application,
    ROS 2 and Gazebo will be able to communicate with each other.
  id: totrans-365
  prefs: []
  type: TYPE_NORMAL
- en: Testing the robot
  id: totrans-366
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In this final section, we will make sure that everything works by testing the
    behavior of the robot, and also by visualizing the robot and TFs in RViz.
  id: totrans-367
  prefs: []
  type: TYPE_NORMAL
- en: Save all files, build and source the workspace, and start the **my_robot.launch.xml**
    file again.
  id: totrans-368
  prefs: []
  type: TYPE_NORMAL
- en: 'In another terminal, list all the topics, and you will see the **/cmd_vel**
    topic that we configured previously. The interface for this topic is the same
    one we used for Turtlesim in *Part 2* of the book, so you should be familiar with
    it. Send a velocity command from the terminal:'
  id: totrans-369
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE42]'
  id: totrans-370
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: 'The robot should start moving in Gazebo (to stop, send the same command with
    **{x: 0.0}**). If you see the robot moving, it means that the bridge is correctly
    configured, as the ROS 2 topic can reach the Gazebo system. It also means that
    the diff drive system works.'
  id: totrans-371
  prefs: []
  type: TYPE_NORMAL
- en: 'To achieve a better way to control the robot and make more tests, you can run
    this node instead:'
  id: totrans-372
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE43]'
  id: totrans-373
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: This will listen to your keyboard and publish to the **/cmd_vel** topic (if
    you use a different name for the topic, simply add a remapping with **–-****ros-args
    -r**).
  id: totrans-374
  prefs: []
  type: TYPE_NORMAL
- en: Now, we have validated that the robot can move in Gazebo when we send a command.
  id: totrans-375
  prefs: []
  type: TYPE_NORMAL
- en: 'To check the TFs, you can do the following:'
  id: totrans-376
  prefs: []
  type: TYPE_NORMAL
- en: Subscribe to the `/joint_states` topic and see the states for both the right
    and left wheels
  id: totrans-377
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Subscribe to the `/tf` topic and see all published TFs
  id: totrans-378
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Print the TF tree (`ros2 run tf2_tools view_frames`), which should contain all
    the TFs, including the two TFs for the wheels and an additional one between the
    `odom` and `base_footprint`
  id: totrans-379
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Note
  id: totrans-380
  prefs: []
  type: TYPE_NORMAL
- en: If something does not work or if some topic data is missing, then either one
    of the systems or bridges is not correctly configured. To solve this, first check
    the topics on the Gazebo side (the `gz topic` command line). If you see the correct
    data, then the bridge is wrong; if you don’t, start with the system.
  id: totrans-381
  prefs: []
  type: TYPE_NORMAL
- en: 'So, we can control the robot and get the correct TFs in our ROS 2 application.
    Finally, let’s start RViz. You can use the command line, but you can also add
    RViz directly inside the launch file if you want to. In this case, we will first
    create a variable to find the RViz config path:'
  id: totrans-382
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE44]'
  id: totrans-383
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: 'We will use the file we previously created in **my_robot_description**. You
    could also create a new RViz configuration file and install it in **my_robot_bringup**.
    Then, we start RViz after all the other nodes:'
  id: totrans-384
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE45]'
  id: totrans-385
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: With this, when you start the launch file, you will have both Gazebo and RViz.
    The TF errors that we previously got in RViz (see *Figure 13**.6*) should not
    be there anymore.
  id: totrans-386
  prefs: []
  type: TYPE_NORMAL
- en: One thing you can do is to select **odom** as the fixed frame, inside **Global
    Options**. With this setting, when the robot moves in Gazebo, you will also see
    it moving from its starting position in RViz.
  id: totrans-387
  prefs: []
  type: TYPE_NORMAL
- en: Our application is now finished. The Gazebo systems correctly work and can communicate
    with the ROS 2 side. The loop is closed.
  id: totrans-388
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  id: totrans-389
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, you learned how to simulate your robot in Gazebo.
  id: totrans-390
  prefs: []
  type: TYPE_NORMAL
- en: You first discovered how Gazebo works. Gazebo is a 3D simulation tool that can
    simulate gravity and the physical properties of your robot in the environment—unlike
    RViz, which is only a visualization tool, helpful for developing and debugging.
  id: totrans-391
  prefs: []
  type: TYPE_NORMAL
- en: 'Then, you followed the process to simulate a robot in Gazebo. Here is a recap
    of the steps:'
  id: totrans-392
  prefs: []
  type: TYPE_NORMAL
- en: Before you even get started, make sure you have a URDF that properly describes
    all the links and joints of your robot (this is what we did in the previous chapters).
  id: totrans-393
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Adapt the URDF for Gazebo by adding `<inertial>` and `<collision>` tags for
    each link. You can use RViz to visualize those properties and make sure they are
    correct.
  id: totrans-394
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Spawn the robot in Gazebo. To do this, you first start the Gazebo simulator
    and the `robot_state_publisher` node. Then, you can spawn the robot.
  id: totrans-395
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Control the robot with plugins (i.e., systems). To use a system, you will add
    a `<plugin>` tag to your URDF. Then, to be able to connect the Gazebo systems
    with ROS 2, you can use the `ros_gz_bridge` package and provide the bridge configuration
    in a YAML file.
  id: totrans-396
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'All along the way, we organized the application into two packages:'
  id: totrans-397
  prefs: []
  type: TYPE_NORMAL
- en: '`my_robot_description`: This contains the URDF, including the links, joints,
    inertial and collision properties, and Gazebo systems'
  id: totrans-398
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`my_robot_bringup`: This contains the launch file to start the application
    and the YAML configuration file for the Gazebo bridge'
  id: totrans-399
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The project we started in *Part 3* is now complete. You have a fully working
    3D simulation of a robot, and you can apply the whole process (not only from this
    chapter but also from all the previous ones) to any other custom robot that you
    create.
  id: totrans-400
  prefs: []
  type: TYPE_NORMAL
- en: Now, of course, that’s not the end; there are more things you may want to do
    with your robot and ROS 2\. In the next chapter, we will conclude the book, and
    we will provide additional resources and tips for you to go further.
  id: totrans-401
  prefs: []
  type: TYPE_NORMAL
