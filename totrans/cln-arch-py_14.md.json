["```py\n# order_system/app.py\nfrom flask import Flask, request, jsonify\nimport sqlite3\nimport requests\napp = Flask(__name__)\ndef get_db_connection():\n    conn = sqlite3.connect('orders.db')\n    conn.row_factory = sqlite3.Row\n    return conn\n@app.route('/orders', methods=['POST'])\ndef create_order():\n    data = request.get_json()\n    # Input validation mixed with business logic\n    if not data or not 'customer_id' in data or not 'items' in data:\n        return jsonify({'error': 'Missing required fields'}), 400\n\n    # Direct database access in route handler\n    conn = get_db_connection() \n```", "```py\n# def create_order(): <continued>\n    # Business logic mixed with data access\n    total_price = 0\n    for item in data['items']:\n        # Inventory check via direct database query\n        product = conn.execute('SELECT * FROM products WHERE id = ?',\n                              (item['product_id'],)).fetchone()\n        if not product or product['stock'] < item['quantity']:\n            conn.close()\n            return jsonify({\n                'error': f'Product {item[\"product_id\"]} out of stock'\n            }), 400\n\n        # Price calculation mixed with HTTP response preparation\n        price = product['price'] * item['quantity']\n        total_price += price\n\n    # External payment service call directly in route handler\n    payment_result = requests.post(\n        'https://payment-gateway.example.com/process',\n        json={\n            'customer_id': data['customer_id'],\n            'amount': total_price,\n            'currency': 'USD'\n        }\n    ) \n```", "```py\n# def create_order(): <continued>\n    if payment_result.status_code != 200:\n        conn.close()\n        return jsonify({'error': 'Payment failed'}), 400\n    # Order creation directly in route handler\n    order_id = conn.execute(\n        'INSERT INTO orders (customer_id, total_price, status) '\n        'VALUES (?, ?, ?)',\n        (\n            data['customer_id'],\n            total_price, 'PAID'\n        )\n    ).lastrowid\n\n    # Order items creation and inventory update\n    for item in data['items']:\n        conn.execute(\n            'INSERT INTO order_items (order_id, product_id, '\n            'quantity, price) VALUES (?, ?, ?, ?)',\n            (order_id, item['product_id'], item['quantity'], price)\n        )\n        conn.execute( # Update inventory\n            'UPDATE products SET stock = stock - ? WHERE id = ?',\n            (item['quantity'], item['product_id'])\n        )\n    conn.commit()\n    conn.close()\n    return jsonify({'order_id': order_id, 'status': 'success'}), 201 \n```", "```py\n# order_system/domain/entities/order.py\nclass OrderStatus(Enum):\n    CREATED = \"CREATED\"\n    PAID = \"PAID\"\n    FULFILLING = \"FULFILLING\"\n    SHIPPED = \"SHIPPED\"\n    DELIVERED = \"DELIVERED\"\n    CANCELED = \"CANCELED\"\n@dataclass\nclass OrderItem:\n    product_id: UUID\n    quantity: int\n    price: float\n\n    @property\n    def total_price(self) -> float:\n        return self.price * self.quantity \n```", "```py\n@dataclass\nclass Order:\n    customer_id: UUID\n    items: List[OrderItem] = field(default_factory=list)\n    id: UUID = field(default_factory=uuid4)\n    status: OrderStatus = OrderStatus.CREATED\n    created_at: datetime = field(default_factory=lambda: datetime.now())\n    updated_at: Optional[datetime] = None\n\n    @property\n    def total_price(self) -> float:\n        return sum(item.total_price for item in self.items)\n\n    def add_item(self, item: OrderItem) -> None:\n        self.items.append(item)\n        self.updated_at = datetime.now()\n\n    def mark_as_paid(self) -> None:\n        if self.status != OrderStatus.CREATED:\n            raise ValueError(\n                f\"Cannot mark as paid: order is {self.status.value}\"\n            )\n        self.status = OrderStatus.PAID\n        self.updated_at = datetime.now() \n```", "```py\n# order_system/domain/entities/product.py\n@dataclass\nclass Product:\n    name: str\n    price: float\n    stock: int\n    id: UUID = field(default_factory=uuid4)\n\n    def decrease_stock(self, quantity: int) -> None:\n        if quantity <= 0:\n            raise ValueError(\"Quantity must be positive\")\n        if quantity > self.stock:\n            raise ValueError(\n                f\"Insufficient stock: requested {quantity}, \"\n                f\"available {self.stock}\")\n        self.stock -= quantity \n```", "```py\n# order_system/domain/repositories/order_repository.py\nfrom order_system.domain.entities.order import Order\nclass OrderRepository(ABC):\n    @abstractmethod\n    def save(self, order: Order) -> None:\n        \"\"\"Save an order to the repository\"\"\"\n        pass\n\n    @abstractmethod\n    def get_by_id(self, order_id: UUID) -> Optional[Order]:\n        \"\"\"Retrieve an order by its ID\"\"\"\n        pass\n\n    @abstractmethod\n    def get_by_customer(self, customer_id: UUID) -> List[Order]:\n        \"\"\"Retrieve all orders for a customer\"\"\"\n        pass \n```", "```py\n# order_system/domain/services/payment_service.py\nfrom order_system.domain.entities.order import Order\n@dataclass\nclass PaymentResult:\n    success: bool\n    error_message: Optional[str] = None\nclass PaymentService(ABC):\n    @abstractmethod\n    def process_payment(self, order: Order) -> PaymentResult:\n        \"\"\"Process payment for an order\"\"\"\n        pass \n```", "```py\n# order_system/app.py\n@app.route('/orders', methods=['POST'])\ndef create_order():\n    data = request.get_json()\n\n    # Input validation mixed with business logic\n    if not data or not 'customer_id' in data or not 'items' in data:\n        return jsonify({'error': 'Missing required fields'}), 400\n\n    # Direct database access in route handler\n    conn = get_db_connection()\n\n    # Business logic implementation\n    # ... existing implementation ...\n\n    return jsonify({'order_id': order_id, 'status': 'success'}), 201 \n```", "```py\n# test_order_creation.py\ndef test_create_order_success():\n    # Setup test data and expected results\n    response = client.post('/orders', json={\n        'customer_id': '12345',\n        'items': [{'product_id': '789', 'quantity': 2}]\n    })\n\n    # Verify status code and response structure\n    assert response.status_code == 201\n    assert 'order_id' in response.json\n\n    # Verify database state - order was created with correct values\n    conn = get_db_connection()\n    order = conn.execute('SELECT * FROM orders WHERE id = ?',\n                        (response.json['order_id'],)).fetchone()\n    assert order['status'] == 'PAID'\n# Additional order creation test scenarios ... \n```", "```py\n# order_system/infrastructure/repositories/sqlite_order_repository.py\nclass SQLiteOrderRepository(OrderRepository):\n    # ... truncated implementation\n\n    def save(self, order: Order) -> None:\n        conn = sqlite3.connect(self.db_path)\n        try:\n            cursor = conn.cursor()\n            # Check if order exists and perform insert or update\n            if self._order_exists(conn, order.id):\n                # ... SQL update operation ...\n            else:\n                # ... SQL insert operation ...\n\n                # ... SQL operations for order items ...\n            conn.commit()\n        except Exception as e:\n            conn.rollback()\n            raise RepositoryError(f\"Failed to save order: {str(e)}\")\n        finally:\n            conn.close() \n```", "```py\n# order_system/application/use_cases/create_order.py\n@dataclass\nclass CreateOrderRequest:\n    customer_id: UUID\n    items: List[Dict[str, Any]]\n@dataclass\nclass CreateOrderUseCase:\n    order_repository: OrderRepository\n    product_repository: ProductRepository\n    payment_service: PaymentService\n\n    def execute(self, request: CreateOrderRequest) -> Order:\n        # Create order entity with basic information\n        order = Order(customer_id=request.customer_id)\n\n        # Add items to order, checking inventory\n        for item_data in request.items:\n            product_id = UUID(item_data['product_id'])\n            quantity = item_data['quantity']\n\n            # ... inventory validation logic ...\n\n            # Update inventory\n            product.decrease_stock(quantity)\n            self.product_repository.update(product) \n```", "```py\n# order_system/application/use_cases/create_order.py\n    # def execute <continued>\n\n        # Process payment\n        payment_result = self.payment_service.process_payment(order)\n        if not payment_result.success:\n            raise ValueError(\n                f\"Payment failed: {payment_result.error_message}\"\n            )\n        # Mark order as paid and save\n        order.mark_as_paid()\n        self.order_repository.save(order)\n\n        return order \n```", "```py\n# order_system/interfaces/controllers/order_controller.py\n@dataclass\nclass OrderController:\n    create_use_case: CreateOrderUseCase\n\n    def handle_create_order(\n        self, request_data: Dict[str, Any]\n    ) -> Dict[str, Any]:\n        try:\n            # Transform web request to domain request format\n            customer_id = UUID(request_data['customer_id'])\n            items = request_data['items']\n\n            request = CreateOrderRequest(\n                customer_id=customer_id,\n                items=items\n            )\n\n            # Execute use case\n            order = self.create_use_case.execute(request)\n\n            # Transform domain response to web response format\n            return {\n                'order_id': str(order.id),\n                'status': order.status.value\n            }\n        except ValueError as e:\n            # ... exception logic \n```", "```py\n# Modified route in order_system/app.py\n@app.route('/orders', methods=['POST'])\ndef create_order():\n    data = request.get_json()\n\n    # Basic input validation remains in the route handler\n    if not data or not 'customer_id' in data or not 'items' in data:\n        return jsonify({'error': 'Missing required fields'}), 400\n\n    try:\n        # Feature flag to control which implementation handles the request\n        if app.config.get('USE_CLEAN_ARCHITECTURE', False):\n            # Use the clean implementation\n            result = order_controller.handle_create_order(data)\n            return jsonify(result), 201\n        else:\n            # ... original implementation remains here ...\n    except ValidationError as e:\n        return jsonify({'error': str(e)}), 400\n    except SystemError:\n        return jsonify({'error': 'Internal server error'}), 500 \n```"]