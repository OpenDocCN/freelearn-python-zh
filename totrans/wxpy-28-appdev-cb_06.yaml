- en: Chapter 6. Retrieving Information from Users
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In this chapter, we will cover:'
  prefs: []
  type: TYPE_NORMAL
- en: Selecting files with a `FileDialog`
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Searching text with a `FindReplaceDialog`
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Getting images with `ImageDialog`
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Using the Print dialogs
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Introduction
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Being able to retrieve information from users is an essential part of any application.
    Dialogs are one of the many ways of retrieving information from users; most desktop
    applications use a number of common dialogs for tasks such as opening, saving,
    and printing files.
  prefs: []
  type: TYPE_NORMAL
- en: 'There are two main types of dialogs: Modal and Modeless. Modal dialogs are
    dialogs that, when shown, block and disable interaction with their parent window
    or all other windows in an application (in the case of an application-modal dialog).
    Modal dialogs are used for cases where a program must retrieve data from a user
    before proceeding to its next task. Modeless dialogs, on the other hand, behave
    similarly to Frames. When modeless dialogs are shown, the other windows in the
    application remain accessible. When closed, modeless dialogs will usually post
    an event to their parent window to inform it that the dialog has closed.'
  prefs: []
  type: TYPE_NORMAL
- en: wxPython supplies many built-in dialogs that can fill the needs of almost any
    common circumstance. So let's take a look at a handful of these common dialogs
    in action with the recipes in this chapter.
  prefs: []
  type: TYPE_NORMAL
- en: Selecting files with a FileDialog
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Allowing users to open and save files is one of the most fundamental capabilities
    of many applications. To provide this functionality, it is often necessary to
    give the user the ability to select which files to open, what to name a file,
    and where to put it when saving a new file. The `FileDialog` can be used to fill
    this role in your application. This recipe creates a simple text editor application
    that can open and save text files to show how to use the `FileDialog`.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Here, we will create a complete text-editor application:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'Our main application window is defined here, and consists of a Frame, TextCtrl,
    and MenuBar:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: Here are the event handlers for the `MenuItems` we added to the Frame's MenuBar
    above. These event handlers are used mostly to just delegate to the method that
    performs the action the user requested.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: 'Here, in the `DoOpen` method, we make the first use of the `FileDialog` in
    `OPEN` mode to allow the user to select the file they wish to open:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: In `DoSaveAs`, we see the second use of the `FileDialog` to allow the user to
    choose where to save the file to, by creating the dialog in `SAVE` mode.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: How it works...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Just to provide a feel of how quickly you can create a usable application in
    wxPython, let's just look at the recipe above. In roughly 100 lines of code, we
    have basically implemented a Windows Notepad clone. Since this recipe was about
    the `FileDialog`, let's just focus in on the `DoOpen` and `DoSaveAs` methods of
    our text editor application, to see how it works.
  prefs: []
  type: TYPE_NORMAL
- en: 'The `FileDialog` has two basic modes: Open and Save. The mode of the dialog
    depends upon which style flags it was created with. Our `DoOpen` method creates
    it with the `FD_OPEN` style flag, which puts it into Open mode. Open mode differs
    from Save mode in that it only allows you to select a file and not enter a name
    in order to create a new one.'
  prefs: []
  type: TYPE_NORMAL
- en: 'In both of our uses of the `FileDialog` in this application, we used the same
    set of optional parameters for creating it. The `wildcards` parameter accepts
    a specially-formatted string to specify the file filter list in the dialog. This
    string must be formatted as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: 'The fields in this string are interpreted as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: Each field is a description followed by the pipe character as a separator, and
    then the `wx.ID_OK` wildcards to associate with that description. Multiple wildcards
    are separated by a semicolon.
  prefs: []
  type: TYPE_NORMAL
- en: Once the dialog is set up, its usage is quite simple. It just needs to be shown
    by using `ShowModal`. Then, if the user closed it with the affirmative, we just
    need to call the dialog's `GetPath` method in order to get the path that was selected
    or entered into the dialog by the user.
  prefs: []
  type: TYPE_NORMAL
- en: There's more...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The `FileDialog's` constructor takes a number of parameters to customize its
    behavior; see below for more information on how to setup a `FileDIalog`.
  prefs: []
  type: TYPE_NORMAL
- en: Default paths
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The `FileDialog` has a few extra parameters that we did not use in our application,
    and that can be used to customize its initial state. The first is the `defaultDir`
    parameter, which takes a directory path as a value. This path must exist, and
    will ensure that the dialog is shown with that directory selected initially. The
    other additional parameter is `defaultFile`, which takes the name of a file as
    a value. This will be put as the default value in the dialog's filename field.
  prefs: []
  type: TYPE_NORMAL
- en: Style flags
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'The style flags and their descriptions are shown in the following table:'
  prefs: []
  type: TYPE_NORMAL
- en: '| Style Flags | Description |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| `wx.FD_DEFAULT_STYLE` | Same as `wx.FD_OPEN` |'
  prefs: []
  type: TYPE_TB
- en: '| `wx.FD_OPEN` | Create it as an Open dialog. Cannot be combined with `wx.FD_SAVE`.
    |'
  prefs: []
  type: TYPE_TB
- en: '| `wx.FD_SAVE` | Create it as a Save dialog. Cannot be combined with `wx.FD_OPEN`.
    |'
  prefs: []
  type: TYPE_TB
- en: '| `wx.FD_OVERWRITE_PROMPT` | Prompt for confirmation if the path already exists.
    For Save dialog only. |'
  prefs: []
  type: TYPE_TB
- en: '| `wx.FD_FILE_MUST_EXIST` | Allow users to select only files that actually
    exist. For Open dialog only. |'
  prefs: []
  type: TYPE_TB
- en: '| `wx.FD_MULTIPLE` | Allow multiple files to be selected. For Open dialog only.
    Should use the dialogs `GetPaths` method to get the list of selected paths. |'
  prefs: []
  type: TYPE_TB
- en: '| `wx.FD_PREVIEW` | Show a preview of the selected file. |'
  prefs: []
  type: TYPE_TB
- en: '| `wx.FD_CHANGE_DIR` | Change the current working directory to where the user
    selected the file(s). If not using the `defaultDir` parameter, the next time the
    dialog is opened, it will open to the last-used location. |'
  prefs: []
  type: TYPE_TB
- en: See also
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The *Utilizing Stock IDs* recipe in [Chapter 1](ch01.html "Chapter 1. Getting
    Started with wxPython"), *Getting Started with wxPython* explains the usage of
    the built-in IDs.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The *Handling events* recipe in [Chapter 2](ch02.html "Chapter 2. Responding
    to Events"), *Responding to Events* covers the basics of event handling.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The *Adding Menus and MenuBars* recipe in [Chapter 3](ch03.html "Chapter 3. Basic
    Building Blocks of a User Interface"), *Basic Building Blocks of a User Interface*
    discusses how to add menus to a Frame.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Searching text with a FindReplaceDialog
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The `FindReplaceDialog` is a common dialog for getting information from the
    user in order to perform find and replace actions in an application. The `FindReplaceDialog`
    is always used as a modeless dialog, and emits events when its buttons are clicked
    that notify the parent window of the action that the user wishes to perform. This
    recipe will extend the previous recipe (`FileDialog`) to show how to add the Find
    and Replace functionality to an application using the `FindReplaceDialog`.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Here we will show how we subclassed the `FileEditorFrame` to add find and replace
    functionality with the `FindReplaceDialog:`
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: 'This method is a helper method that creates the `FindReplaceDialog` in the
    correct mode, depending on which action the user selects from the Menu:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: This first event handler is used to handle the events when a menu item is selected,
    and will be used to create and show the appropriate version of the `FindReplaceDialog:`
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: 'These next four event handlers handle events that are generated by the `FindReplaceDialog`
    in response to user actions:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: 'Finally, here we have a very simple method of searching for a given string
    in the `TextCtrl`, and setting the selection if a match is found:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: 'Running the previous code will result in a window like the following being
    shown:'
  prefs: []
  type: TYPE_NORMAL
- en: '![How to do it...](img/1780_06_01.jpg)'
  prefs: []
  type: TYPE_IMG
- en: How it works...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In this recipe, we took the `FileEditorFrame` class that we created in the last
    recipe and extended it to have find and replace functionality, by using the `FindReplaceDialog`.
    So let's take a look at how we made use of the `FindReplaceDialog` by walking
    through what we added to this class from top to bottom.
  prefs: []
  type: TYPE_NORMAL
- en: 'In our `FindReplaceEditorFrame` class''s `__init__` method, we added two instance
    attributes, `finddlg` and `finddata`. Since the `FindReplaceDialog` is modeless,
    we need to keep track of it in our class so we can properly clean it up later,
    to ensure that it will get assigned to the `finddlg` attribute when it is created.
    The second attribute, `finddata`, holds a reference to the `FindReplaceData` that
    is used for initializing the dialog, as well as for passing data back and forth
    between the dialog, and its parent window. We keep a reference to this item for
    two firstly, one it allows convenient access to the dialogs flags and user entered
    find and replace field strings, and secondly, by using the same `FindReplaceData`
    object each time, the dialog will be initialized with the same settings that the
    user last used it with. The last thing to take note of in `__init__` is the event
    binding: we bound to five of the events that the `FindReplaceDialog` can emit
    as a user interacts with it.'
  prefs: []
  type: TYPE_NORMAL
- en: The next new method is the `_InitFindDialog` method. This method is what we
    use to initialize the `FindReplaceDialog` in response to the **Find** or **Replace**
    menu item events. Since our application is only going to support a simple one-direction,
    case-insensitive search, we disabled all the extra options in the dialog with
    the appropriate style flags. Then we simply create the dialog with the `FR_REPLACEDIALOG`
    flag if we are in replace mode, or without it if we are not, and finally assign
    the new dialog instance to our `finddlg` attribute.
  prefs: []
  type: TYPE_NORMAL
- en: The next section to look at is our `FindReplaceDialog` event handlers. This
    is where we handle the requested actions made by the user that is using the dialog.
    `OnFind` handles the situation where the user clicks the **Find** or **Find Next**
    buttons in the dialog. Here, we first get the string that was entered into the
    dialog by using our `finddata` attribute to access it. Then we perform a simple
    search in the text of the base class's `TextCtrl`, selecting the match if one
    is found, or use `wx.Bell` to make the computer beep at the user if no match is
    found.
  prefs: []
  type: TYPE_NORMAL
- en: '`OnReplace` is called in response to the `FindReplaceDialogs` **Replace** button
    in the `FindReplaceDialog` being clicked. Here we get both the entered find and
    replace strings from the `FindReplaceData`. We then try to find a match and replace
    that match with the entered replace string. `OnReplaceAll` is called in response
    to the dialog''s **Replace All** button being clicked, and does basically the
    same thing as `OnReplace`, but applies it to all matches in the `TextCtrl` text.'
  prefs: []
  type: TYPE_NORMAL
- en: The last event handler is `OnFindClose`. This is called when the user closes
    the `FindReplaceDialog`. We need to handle this event so that we can clean up
    the dialog by calling `Destroy` on it. That's it. Now we have a text editor application
    that has find and replace functionality!
  prefs: []
  type: TYPE_NORMAL
- en: There's more...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: For simplicity's sake, this recipe disabled the dialog's extra find options.
    When these options are selected in the dialog, they can be checked for, just like
    the find and replace strings, by using the `FindReplaceData` object. It will have
    the selected option's flags set in the value returned from `GetFlags`, which is
    a bitmask of the `FindReplaceData` flags. Due to the way in which these flags
    and the dialog's style flags are named, it can be a little confusing to know which
    are which, so please refer to the following two tables to distinguish between
    these two different, yet similarly-named sets of flags.
  prefs: []
  type: TYPE_NORMAL
- en: FindReplaceDialog style flags
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'These flags are flags that should be passed to the dialog''s constructor''s
    style parameter:'
  prefs: []
  type: TYPE_NORMAL
- en: '| Flags | Description |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| `wx.FR_NOMATCHCASE` | Disable the "match case" checkbox |'
  prefs: []
  type: TYPE_TB
- en: '| `wx.FR_NOUPDOWN` | Disable the "up" and "down" radio buttons |'
  prefs: []
  type: TYPE_TB
- en: '| `wx.FR_NOWHOLEWORD` | Disable the "whole word" checkbox |'
  prefs: []
  type: TYPE_TB
- en: '| `wx.FR_REPLACEDIALOG` | Create the dialog in Replace mode |'
  prefs: []
  type: TYPE_TB
- en: FindReplaceData flags
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The following flags are flags that can be set in `FindReplaceData` to set the
    initial state of the dialog and to identify the user's selected find preferences.
  prefs: []
  type: TYPE_NORMAL
- en: '| Flags | Description |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| `wx.FR_DOWN` | The "down" radio button is selected |'
  prefs: []
  type: TYPE_TB
- en: '| `wx.FR_MATCHCASE` | The "match case" checkbox is selected |'
  prefs: []
  type: TYPE_TB
- en: '| `wx.FR_WHOLEWORD` | The "whole word" checkbox is selected |'
  prefs: []
  type: TYPE_TB
- en: See also
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: See the *Selecting files with a FileDialog* recipe for the base example that
    this recipe extends.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The *Understanding event propagation* recipe in [Chapter 2](ch02.html "Chapter 2. Responding
    to Events"), *Responding to Events* contains more information on how events are
    delivered to different windows.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Getting images with ImageDialog
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '`ImageDialog` is a custom dialog class provided by the `wx.lib.imagebrowser`
    module. It is similar in purpose to the default `FileDialog`, but is specialized
    for allowing the user to select and preview images. This recipe shows how to use
    this dialog to retrieve a user-selected image and load it into a `StaticBitmap`
    for display in the application''s main window.'
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Here we will create a very simple image viewer application that allows the
    user to select an image to view with the ImageDialog:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: 'Running the previous code and clicking on the Choose Image button will result
    in the following dialog being shown:'
  prefs: []
  type: TYPE_NORMAL
- en: '![How to do it...](img/1780_06_02.jpg)'
  prefs: []
  type: TYPE_IMG
- en: How it works...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In this recipe we created a simple little image viewer application that allows
    the user to use the `ImageDialog` to choose an image that is on the computer's
    hard drive, and have this image displayed in the application's window.
  prefs: []
  type: TYPE_NORMAL
- en: This application follows the common pattern of most simple applications. So
    let's take a detailed look at how we used the `ImageDialog`. First, we had to
    import the `wx.lib.imagebrowser` module, as the `ImageDialog` is not a part of
    the standard wx module. In our `ImageDialogFrame` class, we added three instance
    attributes. The first is to hold the path that was last used by the `ImageDialog`.
    We did this as a way to improve the usability of the application so that we can
    open the dialog to the last path the user used the next time they open it. The
    second attribute is a `StaticBitmap` object, which we will use to display the
    image that the user selects with the `ImageDialog`. Note that we used a `StaticBitmap`
    in this example for simplicity. To better support larger-sized images, it would
    be better to draw the image on the `Panel` ourselves. This approach will be covered
    by topics in [Chapter 8](ch08.html "Chapter 8. Drawing to the Screen"), *Drawing
    to the Screen*. The last attribute is just a button that will be used to trigger
    the event to show the `ImageDialog`.
  prefs: []
  type: TYPE_NORMAL
- en: This application follows the common pattern of most simple applications. So
    let's take a detailed look at how we used the `ImageDialog`. First, we had to
    import the `wx.lib.imagebrowser` module, as the `ImageDialog` is not a part of
    the standard wx module. In our `ImageDialogFrame` class, we added three instance
    attributes. The first is to hold the path that was last used by the `ImageDialog`.
    We did this as a way to improve the usability of the application so that we can
    open the dialog to the last path the user used the next time they open it. The
    second attribute is a `StaticBitmap` object, which we will use to display the
    image that the user selects with the `ImageDialog`. Note that we used a `StaticBitmap`
    in this example for simplicity. To better support larger-sized images, it would
    be better to draw the image on the `Panel` ourselves. This approach will be covered
    by topics in [Chapter 8](ch08.html "Chapter 8. Drawing to the Screen"), *Drawing
    to the Screen*. The last attribute is just a button that will be used to trigger
    the event to show the `ImageDialog`.
  prefs: []
  type: TYPE_NORMAL
- en: Our `OnShowDialog` method in this recipe creates the `ImageDialog` and initializes
    it to the last path used. The first time, it will be None, which defaults to the
    current working directory. The dialog is then shown, in order to allow the user
    to navigate to and select an image to display. If they click on the dialog's **Open**
    button, the dialog will return `wx.ID_OK`. At this point, we first get and save
    a reference to the last directory that the dialog was at so that we can restore
    it next time the dialog is shown. Then all that is left is to create the Bitmap
    and call the `StaticBitmap's SetBitmap` method to change the image that is displayed.
    After this, it is necessary to call `Layout` on the `Panel`, to make sure the
    sizers can compensate for the new `Bitmap's` size, and then we finally call `Refresh`
    on the `StaticBitmap` to make sure it is completely repainted.
  prefs: []
  type: TYPE_NORMAL
- en: There's more...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The only other option available in the current version of the `ImageDialog`
    is the ability to change the list of supported file filters. This can be done
    by passing to the dialog's `ChangeFileTypes` method a list of tuples that contain
    the file type's description and wildcard string.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: See also
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The *Using Bitmaps* recipe in [Chapter 1](ch01.html "Chapter 1. Getting Started
    with wxPython"), *Getting Started* with wxPython has additional examples of using
    Bitmaps and the `StaticBitmap` class.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Using the Print dialogs
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Adding printing support to an application can be a difficult task, as there
    are a number of tasks that need to be handled. These include selecting and configuring
    a printer, translating your on-screen presentation to paper, and ultimately sending
    the data to the printer.
  prefs: []
  type: TYPE_NORMAL
- en: 'In wxPython, there are three dialog classes related to printing: the `PageSetupDialog,
    PreviewFrame`, and `Printer` classes. In addition to these classes, there are
    a number of supporting classes that must be used in conjunction with these dialogs,
    in order to add printing support to an application. This recipe shows some of
    the basics of how to use the wx printing framework, by creating a class that encapsulates
    the usage of the three printing dialogs and allows an application to print a `Bitmap`.'
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'In order to simplify and condense the many different steps required to support
    printing in an application, we will start by defining a class to encapsulate the
    different tasks into a few simple method calls:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: 'The `PageSetup` method handles the display of the printer setup dialog, and
    storage of the settings in the `print_data` attributes:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: 'In Preview, we create the `PrintPreview` dialog to give a preview of what the
    printout will look like:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: 'Finally, in the `Print` method, we show the `Printer` dialog to allow the user
    to request a printout of a `Bitmap`, and send it to the printer to be printed:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: 'Here we will implement the `Printout` object for printing `Bitmaps`. The `Printout`
    object is the object that is responsible for managing the print job and drawing
    the bitmap to the printer''s device context:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: How it works...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The `BitmapPrinter` class encapsulates the three main print-related tasks that
    an application may need to support: printer setup, print preview, and printing.
    This class is the interface that the application which wants to allow printing
    `Bitmaps` will use for all of its printing needs. All that the application requires
    is a `Bitmap`, and all that it needs to do is to use one of the three methods,
    `PageSetup, Preview`, and `Print`. So let''s take a look at how this class and
    these three methods work.'
  prefs: []
  type: TYPE_NORMAL
- en: The constructor takes one argument for a parent window. This will be used as
    the parent window for all of the dialogs. This will typically be an application's
    main window. We also create and store a reference to a `PrintData` object in the
    constructor. All of the print dialogs use `PrintData` in one form or another.
    This allows us to save any print configuration changes a user may make while using
    one of the dialogs.
  prefs: []
  type: TYPE_NORMAL
- en: '`PageSetup` is used to create and show the `PageSetupDialog`. To use the `PageSetupDialog`,
    we first create a `PageSetupDialogData` object by passing our `PrintData` object
    to its constructor, so it will use any settings that may already be persisted
    in our data object. We then simply create the dialog by passing in the `PageSetupDialogData`
    object. If the dialog is closed by the OK button, we then get the `PrintData`
    from the dialog and make a copy of it to store. It is important to make a copy,
    because when the `PageSetupDialog` is destroyed it will delete the data.'
  prefs: []
  type: TYPE_NORMAL
- en: '`Preview` creates a preview of what the printout will look like, and shows
    it with the `PreviewFrame`. The `PreviewFrame` requires a `PrintPreview` object.
    To create the `PrintPreview` object, it must be passed two `Printout` objects
    and a `PrintData` object. A `Printout` object is what does the actual work of
    rendering what will be printed by the printer. We will come back to the details
    about how the `Printout` works when we get to our `BitmapPrintout` class. The
    first `Printout` object is used for the `PreviewFrame`, and the second one is
    used for the actual printing if the user clicks on the `PreviewFrame''s` Print
    button.'
  prefs: []
  type: TYPE_NORMAL
- en: '`Print` creates a `Printer` object that will show the printer dialog when its
    `Print` method is called. Like the `Preview` object, the `Printer` object is created
    with some `PrintData` and an instance of a `Printout` object. When the print dialog''s
    Print button is clicked, it will use the `Printout` object to tell the physical
    printer what to draw on the paper.'
  prefs: []
  type: TYPE_NORMAL
- en: 'The `BitmapPrintout` class implements a `Printout` object that is used for
    printing a single bitmap to a single sheet of paper at a time. `Printout` objects
    must always be subclassed in order to implement the application-specific requirements
    of the data that needs to be printed as the base class only provides an interface
    of virtual methods to override in the subclass. In our class, we overrode the
    three following methods: `GetPageInfo, HasPage`, and `OnPrintPage`. The first
    two are for returning information about the number of pages that will be printed;
    since we are only supporting one page, these are quite trivial in this recipe.
    The `OnPrintPage` method is what does the actual drawing to the printer''s device
    context. This method gets called to do the drawing of each page that will be printed.'
  prefs: []
  type: TYPE_NORMAL
- en: Drawing the `Printout` is done by using the device context object returned by
    the call to `GetDC`. The use of device contexts are covered in detail in [Chapter
    8](ch08.html "Chapter 8. Drawing to the Screen"), *Drawing to the Screen* so just
    too keep things simple all we did here was just to set the scale of the canvas
    calculations to try and center the image on the paper, and then used the DC's
    `DrawBitmap` method to draw the `Bitmap` to the device context. For an example
    of the `BitmapPrinter` class in action, see the sample code that accompanies this
    chapter.
  prefs: []
  type: TYPE_NORMAL
- en: There's more...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Included below is some additional information about the print framework.
  prefs: []
  type: TYPE_NORMAL
- en: Printout
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The `wx.Printout` object has a number of other overrideable methods that may
    be of use for different types of documents. The following table is a reference
    to some of these other interface methods.
  prefs: []
  type: TYPE_NORMAL
- en: '| Interface methods | Description |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| `OnBeginDocument(start, end)` | Called at the beginning of each copy of a
    document that is in the print job. If this method is overridden, the base class''s
    method must still be called in it. |'
  prefs: []
  type: TYPE_TB
- en: '| `OnEndDocument()` | Called at the end of printing each copy of a document
    in the print job. If this method is overridden, the base class method must be
    called in it. |'
  prefs: []
  type: TYPE_TB
- en: '| `OnBeginPrinting()` | Called once and only once at the beginning of a print
    job. |'
  prefs: []
  type: TYPE_TB
- en: '| `OnEndPrinting()` | Called once and only once at the end of a print job.
    |'
  prefs: []
  type: TYPE_TB
- en: '| `OnPreparePrinting()` | Called before any other use of the `Printout` object.
    This is usually where the calculations about things such as the number of pages
    in a document are done. |'
  prefs: []
  type: TYPE_TB
- en: Bug notice
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: There is a bug in wxPython 2.8 where the page orientation (Portrait or Landscape)
    cannot be retrieved from the `PageSetup` or `Print` dialog's `PrintData`.
  prefs: []
  type: TYPE_NORMAL
- en: See also
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The *Understanding inheritance limitations* recipe in [Chapter 1](ch01.html
    "Chapter 1. Getting Started with wxPython"), *Getting Started with wxPython* includes
    a detailed explanation of how to override virtual methods in wxPython classes.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The *Screen drawing* recipe in [Chapter 8](ch08.html "Chapter 8. Drawing to
    the Screen"), *Drawing to the Screen* discusses the use of Device Contexts (DCs)
    and their drawing commands.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
