<html><head></head><body><div><div><div><div><h1 class="title"><a id="ch03"/>Chapter 3. The First Project – Motion-triggered LEDs</h1></div></div></div><p>In the preceding chapter, you learned the basics of Python-Arduino interfacing. We went through some exercises to provide hands-on experience with a useful Arduino protocol, Firmata, and the Python library. Now, it's time for your first 'Python + Arduino' project.</p><p>We will start this chapter by discussing the project goals and the required components to design the software flow and the hardware layout for the project. Just like any other microcontroller-based hardware project, you can use code and implement the entire logic of your project on Arduino itself. However, the goal of this book is to help you to utilize Python in such a way that you can simplify and extend your hardware projects. Although we will be using a hybrid approach with a Python program assisted by an Arduino sketch in the upcoming chapters, we would like you to get familiar with both ways of programming. As this is your first experience of building a hardware project, the chapter provides you with two different programming methods for the project: just using an Arduino sketch and using a Python program with the Firmata protocol on Arduino. The method with the Arduino sketch is included so that you get the complete experience with the Arduino components such as I/O pins and serial communication.</p><div><div><div><div><h1 class="title"><a id="ch03lvl1sec21"/>Motion-triggered LEDs – the project description</h1></div></div></div><p>When you <a id="id289" class="indexterm"/>start learning any programming language, in most cases, you will be writing code to print 'Hello World!'. Meanwhile, in hardware projects, the majority of tutorials begin by helping a user to write the code to blink an LED. These exercises or projects are useful for developers to get started with the language, but mostly, they do not carry any importance towards real-world applications. However, we don't want to overwhelm you with a complex and sophisticated project that might require you to have a good amount of domain knowledge.</p><p>While working with the Firmata protocol in the previous chapter, we already blinked an LED on the Arduino board. To keep the tradition alive (of having a blinking LED as a first major project) and also build excitement towards the project, let's put a twist in the blinking LED project. In this project, we will blink two different LEDs, but instead of performing <a id="id290" class="indexterm"/>these actions in a random manner, we will do it for events that are measured using a motion sensor. Although the difficultly level of the project is simple since it is your first project, it carries real-world application value and can be used as a simple application in your day-to-day life.</p></div></div>
<div><div><div><div><h1 class="title"><a id="ch03lvl1sec22"/>The project goal</h1></div></div></div><p>The<a id="id291" class="indexterm"/> project goal can be described in one sentence as follows: "Generate an alert using a red LED for any detected motion and display the normal condition using a green LED." In comprehensive list of goals, you will have to perform the following tasks to satisfy the mentioned project goal:</p><div><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">Detect any<a id="id292" class="indexterm"/> motion in the environment as an event using a <strong>passive infrared</strong> (<strong>PIR</strong>) sensor</li><li class="listitem" style="list-style-type: disc">Perform a blink action using a red LED for this event</li><li class="listitem" style="list-style-type: disc">Otherwise, perform a blink action using a green LED</li><li class="listitem" style="list-style-type: disc">Keep the system in loop after the action has been performed and wait for the next event</li></ul></div><p>The project can be implemented as a DIY application or as part of other projects with minor modifications. The following are some examples where the concepts from this project <a id="id293" class="indexterm"/>can be utilized:</p><div><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">As a <a id="id294" class="indexterm"/>DIY security system, to monitor movement in a room (<a class="ulink" href="http://www.instructables.com/id/PIR-Sensor-Security/">http://www.instructables.com/id/PIR-Sensor-Security/</a>)</li><li class="listitem" style="list-style-type: disc">In smart home applications, it can be used to automatically turn off lights if no one is present (<a class="ulink" href="http://www.instructables.com/id/Arduino-Home-Monitor-System/">http://www.instructables.com/id/Arduino-Home-Monitor-System/</a>)</li><li class="listitem" style="list-style-type: disc">It can be used in automatic garage door opener applications with the support of additional hardware components and appropriate code</li><li class="listitem" style="list-style-type: disc">In DIY wildlife recording projects, it can be used to trigger a camera instead of an LED when any motion is detected (<a class="ulink" href="http://www.instructables.com/id/Motion-triggered-camera/">http://www.instructables.com/id/Motion-triggered-camera/</a>)</li></ul></div><div><div><div><div><h2 class="title"><a id="ch03lvl2sec46"/>The list of components</h2></div></div></div><p>In the previous chapter, we only used an LED for programming using Arduino, an Arduino USB cable, and a computer. The major hardware component required for this project is a PIR motion sensor. You will also need an additional LED. We recommend that you have a different colored LED than the one that you already have. The description of the necessary components is as follows:</p><div><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc"><strong>PIR sensors</strong>: These <a id="id295" class="indexterm"/>are widely <a id="id296" class="indexterm"/>used as motion detection sensors for DIY projects. They are small, inexpensive, consume less power, and are compatible with hardware platforms such as Arduino. A PIR sensor uses a pair of pyroelectric sensors that detect infrared radiation. If there is no motion, the output of these sensors cancels each other out. Any movement in the environment will produce different levels of infrared radiation by these pyroelectric sensors and the difference will trigger an output that is <code class="literal">HIGH</code> (+5 volts). We will be using the PIR sensor that is sold by SparkFun, <a id="id297" class="indexterm"/>and you can obtain it from <a class="ulink" href="https://www.sparkfun.com/products/8630">https://www.sparkfun.com/products/8630</a>. The PIR sensor comes equipped with the required printed circuit board (PCB). It has range of up to 20 feet (6 meters), which is sufficient for the project. The following image displays the PIR sensor available on the SparkFun website:<div><img src="img/5938OS_03_01.jpg" alt="The list of components"/><div><p>Source: Sparkfun Inc.</p></div></div></li><li class="listitem" style="list-style-type: disc"><strong>LEDs</strong>: We<a id="id298" class="indexterm"/> recommend that you use green and red LEDs for the project. If they are unavailable, you can use any two LEDs with different colors.</li><li class="listitem" style="list-style-type: disc"><strong>Wires, resistors, and the breadboard</strong>: You will require a bunch of wires and a breadboard<a id="id299" class="indexterm"/> to complete the<a id="id300" class="indexterm"/> connections. As a best <a id="id301" class="indexterm"/>practice, have at least three different colors of wire connectors to represent power, ground, and signal. You will also need two 220 ohm and one 10 kilo-ohm pull resistors.</li><li class="listitem" style="list-style-type: disc"><strong>The Arduino board</strong>: The Arduino Uno board is sufficient for the project requirements. You can also use Arduino Mega or any other Arduino board for this <a id="id302" class="indexterm"/>project. The project requires only three I/O pins and any available Arduino board is equipped with more than three I/O pins.</li><li class="listitem" style="list-style-type: disc"><strong>A USB cable</strong>: You <a id="id303" class="indexterm"/>will need a USB cable to upload the Arduino code and perform serial communication with the Arduino board.</li><li class="listitem" style="list-style-type: disc"><strong>A computer</strong>: We have already configured a computer with Python and the Arduino IDE for<a id="id304" class="indexterm"/> your favorite operating system in the previous chapters. You will need this computer for the project. Make sure that you have all the software components that we installed and configured in the previous chapters.</li></ul></div></div><div><div><div><div><h2 class="title"><a id="ch03lvl2sec47"/>The software flow design</h2></div></div></div><p>The first step, before jumping to work on any hardware system, is to design the project flow using<a id="id305" class="indexterm"/> logic. We recommend that you have your project sketched as a flowchart to better understand the layout of the components and the flow of the code. The following diagram shows the flow of the project where you can see that the project runs in loops once motion is detected and the appropriate LED actions are performed:</p><div><img src="img/5938OS_03_02.jpg" alt="The software flow design"/></div><p>As you can <a id="id306" class="indexterm"/>see, the program logic starts by detecting the state of the PIR sensor and performs the appropriate actions accordingly. With a single Arduino instruction, you can only turn the LED on or off. To perform the blinking operation, we will need to repeatedly perform the turning-on and turning-off actions with a time delay between the actions. We will also insert a delay between the execution of each successive loop so that the PIR sensor output can settle down. Note that we will use the same flow when writing the code for both the programming methods.</p></div><div><div><div><div><h2 class="title"><a id="ch03lvl2sec48"/>The hardware system design</h2></div></div></div><p>Designing a diagram for your software flow helps you to write the program and also assists you in identifying<a id="id307" class="indexterm"/> actions and events for the project. The process of hardware system design includes circuit connections, schematic design, simulation, verification, and testing. This design process provides a detailed understanding of the project and the hardware components. It also helps in preliminary verification and testing of the project architecture. Before we jump to the hardware <a id="id308" class="indexterm"/>design process of this project, let's get ourselves familiar with the helpful tools.</p><div><div><div><div><h3 class="title"><a id="ch03lvl3sec23"/>Introducing Fritzing – a hardware prototyping software</h3></div></div></div><p>You are not required to design the hardware system for this project. By and large, in this book, the <a id="id309" class="indexterm"/>hardware system designs will be provided, as the primary focus of the book is on programming <a id="id310" class="indexterm"/>rather than hardware design.</p><p>If you are interested in system design or rapid prototyping of the hardware components, the open source software tool used for this purpose is called <strong>Fritzing</strong>. The schematics for your <a id="id311" class="indexterm"/>projects can be designed using Fritzing and it can be obtained from <a class="ulink" href="http://fritzing.org/download/">http://fritzing.org/download/</a>.</p><p>Fritzing is a community-supported electronic design automation software initiative for designers, artists, and hobbyists. It lets you convert your hardware sketch from paper to software as a circuit diagram. Fritzing also provides you with a tool to create PCB layouts from your designs. Fritzing extensively supports Arduino and other popular open source DIY hardware platforms. You can explore Fritzing via built-in example projects.</p><p>Install and run Fritzing. The following screenshot shows one of the default projects that are displayed after opening Fritzing:</p><div><img src="img/5938OS_03_03.jpg" alt="Introducing Fritzing – a hardware prototyping software"/></div><p>As <a id="id312" class="indexterm"/>you can see, a toolbox containing virtual hardware components is located to the right of the opened window. The<a id="id313" class="indexterm"/> main editing space, located in the center, lets the user drag and drop components from the toolbox and also allows the user to complete connections between these components. You can learn more about the features provided by Fritzing <a id="id314" class="indexterm"/>and go through some hands-on tutorials at <a class="ulink" href="http://fritzing.org/learning/">http://fritzing.org/learning/</a>.</p></div><div><div><div><div><h3 class="title"><a id="ch03lvl3sec24"/>Working with the breadboard</h3></div></div></div><p>Once you are familiar with Fritzing, you have the flexibility to create your own circuits, or you can always use the Fritzing files provided with the book. However, there is another challenge, that is, porting your virtual circuit to a physical one. One of the fundamental components used by <a id="id315" class="indexterm"/>electronics projects that let you implement connections and build the physical circuit is the <strong>breadboard</strong>.</p><p>The <a id="id316" class="indexterm"/>breadboard contains intelligently organized metal rows hidden under an assembly containing plastic holes. This assembly helps the user to connect wires without going through any soldering work. It is really easy to insert and remove wires or electronics components through the holes. The following figure shows a small breadboard with a couple of components and a few wire connections:</p><div><img src="img/5938OS_03_09.jpg" alt="Working with the breadboard"/></div><div><div><h3 class="title"><a id="note18"/>Note</h3><p>Find out <a id="id317" class="indexterm"/>more about breadboards and the tutorials to use them at <a class="ulink" href="http://learn.sparkfun.com/tutorials/how-to-use-a-breadboard">http://learn.sparkfun.com/tutorials/how-to-use-a-breadboard</a>.</p></div></div><p>A breadboard mostly has two types of connection strips: terminal strips and power rails. As displayed in the preceding figure, terminal strips are vertical columns with electrically shorted holes. In <a id="id318" class="indexterm"/>simple words, once you connect any component to one of the terminal strips, the component<a id="id319" class="indexterm"/> will be electrically connected to each hole in the column. The columns of terminal strips are separated by the <strong>Dual in-line Package</strong> (<strong>DIP</strong>) support <a id="id320" class="indexterm"/>gap. (DIP is a common housing for electronics components.) In the same column, terminal strips above and below the DIP support gap are electrically independent. Meanwhile, the power rails are shorted horizontally throughout the entire row of the breadboard. The power rails are mostly used to connect positive and ground connections from the power supply, so it can be distributed easily to all components.</p><div><div><h3 class="title"><a id="note19"/>Note</h3><p>
<strong>History of breadboards</strong>
</p><p>In the early<a id="id321" class="indexterm"/> years of electronics, people used actual breadboards (that were used to cut bread) to connect their large components with just nails and wires. Once electronics components started getting smaller, the board to assemble circuits also became better. The term stuck through this evolution, and we still call the modern boards breadboards. If you are interested, you can check out <a class="ulink" href="http://www.instructables.com/id/Use-a-real-Bread-Board-for-prototyping-your-circui/">http://www.instructables.com/id/Use-a-real-Bread-Board-for-prototyping-your-circui/</a>, which provides instructions to assemble a circuit <a id="id322" class="indexterm"/>using the original breadboards.</p></div></div></div><div><div><div><div><h3 class="title"><a id="ch03lvl3sec25"/>Designing the hardware prototype</h3></div></div></div><p>It's time to <a id="id323" class="indexterm"/>collect the hardware components mentioned earlier and start building the system. The next figure shows the circuit for the project that has been developed using Fritzing. If you have prior experience of working with circuit assembly, go ahead and connect the components as displayed in the figure:</p><div><img src="img/5938OS_03_04.jpg" alt="Designing the hardware prototype"/></div><p>If this <a id="id324" class="indexterm"/>is your first experience of working with sensors and the breadboard, use the following steps to complete the circuit assembly:</p><div><ol class="orderedlist arabic"><li class="listitem">Connect VCC (+5V) and ground from the Arduino to the breadboard.</li><li class="listitem">Connect the anode (long lead) of the red LED to digital pin 12 of the Arduino board. Connect the cathode (short lead) of the red LED to ground with 220 ohm resistors.</li><li class="listitem">Connect the anode (long lead) of the green LED to digital pin 13 of the Arduino board. Connect the cathode (short lead) of the green LED to ground with 220 ohm resistors.</li><li class="listitem">Connect VDD of the PIR sensor to VCC on the breadboard. Use the same wire color to represent the same category of connections. This will greatly help in troubleshooting the circuit.</li><li class="listitem">Connect the signal (middle pin) of the PIR sensor to Arduino digital pin 7 with a 10 kilo-ohm pull-up resistor.</li></ol></div><p>The <a id="id325" class="indexterm"/>majority of experts prefer a schematic diagram instead of the prototype diagram that we used previously. Schematic diagrams are useful when you are using compatible components instead of the exact components from the prototype diagram. The following is a schematic diagram of the electronics circuit that we designed earlier. This diagram is also obtained using Fritzing:</p><div><img src="img/5938OS_03_05.jpg" alt="Designing the hardware prototype"/></div><p>Your system is now ready to run the Arduino program. As we will be using the same hardware for both the programming methods, you are almost done working with electronics unless you encounter a problem. Just to make sure that everything is connected <a id="id326" class="indexterm"/>perfectly, let's check out these connections in the next section.</p><div><div><h3 class="title"><a id="note20"/>Note</h3><p>Note that pull-up resistors are used to make sure that the output signal from a PIR sensor settles at the expected logic level.</p></div></div></div></div><div><div><div><div><h2 class="title"><a id="ch03lvl2sec49"/>Testing hardware connections</h2></div></div></div><p>Once the circuit connections are complete, you can go directly to the programming sections. As a best practice, we recommend that you verify the circuit connections and check the sensor's <a id="id327" class="indexterm"/>status. We are assuming that your Arduino board is already equipped with the <strong>StandardFirmata</strong> sketch that we discussed in the previous chapter. Otherwise, refer to the previous chapter and upload the <strong>StandardFirmata</strong> sketch to your Arduino board.</p><p>The best way to verify our circuit implementation is to use the Firmata test program that we used in the previous chapter. According to the project setup, the PIR sensor provides event inputs to Arduino pin 7. In the test program, change the type of pin 7 to <strong>Input</strong> and wave your hand over the sensor, and you should be able to see the status of the pin as <strong>High</strong>, as displayed in the following screenshot:</p><div><img src="img/5938OS_03_06.jpg" alt="Testing hardware connections"/></div><p>Check the LED connections by setting up pins 12 and 13 as output pins and toggling the buttons <a id="id328" class="indexterm"/>to set the status of the pins. If you see the LEDs blinking while you are toggling the button, then your connections are working perfectly.</p><p>If you cannot successfully perform these checks, verify and repeat the design steps.</p></div></div>
<div><div><div><div><h1 class="title"><a id="ch03lvl1sec23"/>Method 1 – using a standalone Arduino sketch</h1></div></div></div><p>As we <a id="id329" class="indexterm"/>discussed in the previous chapters, a project can be implemented by creating project-specific native Arduino code or by using a Python-Arduino hybrid approach.</p><p>The native Arduino sketches are useful in applications where negligible or no communication with a computer system is required. Although this type of standalone project enables continuous operation in the absence of serial connectivity, it is difficult to keep<a id="id330" class="indexterm"/> updating and uploading an Arduino sketch for minor modifications.</p><p>If you look at the various applications of this project, you will notice that only a few of them require the project to be implemented as a standalone system that just detects motion and blinks LEDs. This type of system can be easily implemented by a simple Arduino sketch.</p><div><div><div><div><h2 class="title"><a id="ch03lvl2sec50"/>The project setup</h2></div></div></div><p>Before we<a id="id331" class="indexterm"/> go ahead with the project, make sure that you have the following things in place:</p><div><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">The hardware components are set up and are functioning correctly</li><li class="listitem" style="list-style-type: disc">Your Arduino is connected to the computer using a USB cable</li><li class="listitem" style="list-style-type: disc">Your computer has the Arduino IDE and you can access the connected Arduino board through the IDE</li></ul></div></div><div><div><div><div><h2 class="title"><a id="ch03lvl2sec51"/>The Arduino sketch</h2></div></div></div><p>This <a id="id332" class="indexterm"/>section describes the Arduino code for the project. Before we get into a step-by-step description of the code, let's first follow these steps to run the project:</p><div><ol class="orderedlist arabic"><li class="listitem">Open the Arduino IDE.</li><li class="listitem">From the <strong>File</strong> menu, open a new sketchbook.</li><li class="listitem">Copy the following Arduino code to the sketch and save it:<div><pre class="programlisting">int pirPin = 7; //Pin number for PIR sensor
int redLedPin = 12; //Pin number for Red LED
int greenLedPin = 13; //Pin number for Green LED

void setup(){
 Serial.begin(9600); 
 pinMode(pirPin, INPUT);
 pinMode(redLedPin, OUTPUT);
 pinMode(greenLedPin, OUTPUT);
}
void loop(){
  int pirVal = digitalRead(pirPin);
  if(pirVal == LOW){ //was motion detected
    blinkLED(greenLedPin, "No motion detected.");
  } else {
    blinkLED(redLedPin, "Motion detected.");
  }
}
// Function which blinks LED at specified pin number
void blinkLED(int pin, String message){
  digitalWrite(pin,HIGH);
  Serial.println(message); 
  delay(1000);
  digitalWrite(pin,LOW);
  delay(2000);
}</pre></div></li><li class="listitem">Compile and upload the sketch to the Arduino board.</li></ol></div><p>Now, you <a id="id333" class="indexterm"/>have completed your project with the first programming method and successfully deployed it to your hardware. It should be running the designed algorithm to detect motion events and perform the blink action.</p><p>As your project is functioning properly, it's time to understand the code. Like any other Arduino program, the code has two mandatory functions: <code class="literal">setup()</code> and <code class="literal">loop()</code>. It also has a custom function, <code class="literal">blinkLED()</code>, for a specific action that will be explained later.</p><div><div><div><div><h3 class="title"><a id="ch03lvl3sec26"/>The setup() function</h3></div></div></div><p>As you <a id="id334" class="indexterm"/>can see in the<a id="id335" class="indexterm"/> preceding code snippet, we assigned variables to the Arduino pin at the beginning of the program. In the <code class="literal">setup()</code> function, we configured these variables to be defined as input or output pins:</p><div><pre class="programlisting">pinMode(pirPin, INPUT);
pinMode(redLedPin, OUTPUT);
pinMode(greenLedPin, OUTPUT);</pre></div><p>Here, <code class="literal">pirPin</code>, <code class="literal">redLedPin</code>, and <code class="literal">greenLedPin</code> are digital pins 7, 12, and 13 respectively. In the same function, we also configured the Arduino board to provide serial connectively at the <a id="id336" class="indexterm"/>baud rate <a id="id337" class="indexterm"/>of 9600 bps:</p><div><pre class="programlisting">Serial.begin(9600);</pre></div></div><div><div><div><div><h3 class="title"><a id="ch03lvl3sec27"/>The loop() function</h3></div></div></div><p>In the <code class="literal">loop()</code> function, we are repeatedly monitoring the input from the <code class="literal">pirPin</code> digital pin to <a id="id338" class="indexterm"/>detect motion. The output of this pin is <code class="literal">HIGH</code> when motion is detected and <code class="literal">LOW</code> otherwise. This <a id="id339" class="indexterm"/>logic is implemented using a simple <code class="literal">if-else</code> statement. When this condition is satisfied, the function calls a user-defined function, <code class="literal">blinkLED()</code>, to perform the appropriate action on the LEDs.</p><p>User-defined functions are a very important aspect of any programming language. Let's spend some time learning how you can create your own Arduino functions to perform various actions.</p></div></div><div><div><div><div><h2 class="title"><a id="ch03lvl2sec52"/>Working with custom Arduino functions</h2></div></div></div><p>Functions are used when a segment of code is repeatedly executed to perform the same action. A <a id="id340" class="indexterm"/>user can create a custom function to organize the code or perform reoccurring actions. To successfully utilize a custom function, a user needs to call them from mandatory Arduino functions such as <code class="literal">loop()</code>, <code class="literal">setup()</code>, or any other function that leads to these mandatory functions:</p><div><pre class="programlisting">return-type function_name (parameters){
  # Action to be performed
  Action_1;
  Action_2;
  Return expression;
}</pre></div><p>In the preceding Arduino function framework, <code class="literal">return-type</code> can be any Arduino data type such as <code class="literal">int</code>, <code class="literal">float</code>, <code class="literal">string</code>, and so on, or <code class="literal">void</code> if the code is not returning anything. The following is the custom function that we used in our project code:</p><div><pre class="programlisting">void blinkLED(int pin, String message){
  digitalWrite(pin,HIGH);
  Serial.println(message); 
  delay(1000);
  digitalWrite(pin,LOW);
  delay(2000);
}</pre></div><p>In <a id="id341" class="indexterm"/>our project, the <code class="literal">blinkLED()</code> function is not retuning any value when it is called from the <code class="literal">loop()</code> function. Hence, <code class="literal">return-type</code> is <code class="literal">void</code>. When calling the function, we pass the pin number and a message as parameters:</p><div><pre class="programlisting">blinkLED(greenLedPin, "No motion detected.");</pre></div><p>These parameters are then utilized in the performed action (writing a message on a serial port and setting up the LED status) by the <code class="literal">blinkLED()</code> function. This function also introduces a delay to perform the blink action by using the <code class="literal">delay()</code> function.</p></div><div><div><div><div><h2 class="title"><a id="ch03lvl2sec53"/>Testing</h2></div></div></div><p>We <a id="id342" class="indexterm"/>verified the designed system in the <em>Testing hardware connection</em> section using manual inputs via the Firmata test program. As we have now implemented the software design, we need to verify that the project is performing objective tasks autonomously and repeatedly.</p><p>With the USB port connected to the computer, open the serial monitoring tool from the Arduino IDE by navigating to <strong>Tools</strong> | <strong>Serial Monitor</strong> or by pressing <em>Ctrl</em> + <em>Shift</em> + <em>M</em>. You should start seeing a message similar to the one displayed in the following screenshot on the <strong>Serial Monitor</strong> window:</p><div><img src="img/5938OS_03_07.jpg" alt="Testing"/></div><p>While <a id="id343" class="indexterm"/>writing the <code class="literal">blinkLED()</code> function to perform actions, we included an action to write a string via a serial port. Move your hand over the PIR sensor in such a way that the PIR sensor can detect motion. This event should trigger the system to blink the red LED and display a string, <code class="literal">Motion detected</code>, on the serial monitor. Once you stay steady and avoid any motion for a while, you will be able to see the green LED blinking until the next movement gets detected via the PIR sensor.</p></div><div><div><div><div><h2 class="title"><a id="ch03lvl2sec54"/>Troubleshooting</h2></div></div></div><p>Troubleshooting is an important process if anything goes awry. These are a few example problems and the <a id="id344" class="indexterm"/>troubleshooting steps for them:</p><div><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">Serial output is correct, but there are no blinking LEDs:<div><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">Check the LED connections on the breadboard</li></ul></div></li><li class="listitem" style="list-style-type: disc">The LED blinks, but there is no serial output:<div><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">Check the port on which the serial monitor is configured</li><li class="listitem" style="list-style-type: disc">Check whether the baud rate in the serial monitor is correct (9600 bps)</li></ul></div></li><li class="listitem" style="list-style-type: disc">There<a id="id345" class="indexterm"/> is no serial output and no blinking LEDs:<div><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">Check the PIR sensor connection and make sure that you are getting signal from the PIR sensor</li><li class="listitem" style="list-style-type: disc">Check your Arduino code</li><li class="listitem" style="list-style-type: disc">Check power and ground connections</li></ul></div></li></ul></div></div></div>
<div><div><div><div><h1 class="title"><a id="ch03lvl1sec24"/>Method 2 – using Python and Firmata</h1></div></div></div><p>In the previous chapter, we discussed the benefits of using Python programming that is assisted by<a id="id346" class="indexterm"/> Firmata over using native Arduino sketches. The Python-based programming approach provides tangible experience when performing any algorithmic or parametric changes. In this section, we are going to explore these benefits and also learn important Python programming paradigms.</p><div><div><div><div><h2 class="title"><a id="ch03lvl2sec55"/>The project setup</h2></div></div></div><p>Let's<a id="id347" class="indexterm"/> make sure that you have done the following before we go ahead with Python programming:</p><div><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">Made sure that the hardware components are set up, as described in the system design</li><li class="listitem" style="list-style-type: disc">Connected the Arduino to your computer using a USB cable</li><li class="listitem" style="list-style-type: disc">Uploaded the <strong>StandardFirmata</strong> sketch back to Arduino</li><li class="listitem" style="list-style-type: disc">Made sure that you have Python and the Python packages (<code class="literal">pySerial</code> and <code class="literal">pyFirmata</code>) installed on your computer</li><li class="listitem" style="list-style-type: disc">Obtained a text editor to write Python codes</li></ul></div></div><div><div><div><div><h2 class="title"><a id="ch03lvl2sec56"/>Working with Python executable files</h2></div></div></div><p>In the <a id="id348" class="indexterm"/>previous<a id="id349" class="indexterm"/> chapters, we explored Python programming using the interactive Python interpreter. However, when working with large projects, it is very difficult to keep using the Python interactive interpreter for repetitive tasks. Like other programming languages, the preferred method is to create Python executable files and run them from the terminal.</p><p>Python executable files carry the <code class="literal">.py</code> extension and are formatted as plain text. Any text editor can be used to create these files. The popular editors used to create and edit Python files are Notepad++, nano, vi, and so on. This list also includes the default editor that is shipped with the Python setup files called IDLE. You can use the editor of your choice, but make sure that<a id="id350" class="indexterm"/> you <a id="id351" class="indexterm"/>save the files with the <code class="literal">.py</code> extension. Let's copy the following lines of code in a new file and save it as <code class="literal">test.py</code>:</p><div><pre class="programlisting">#!/usr/bin/python
a = "Python"
b = "Programming"
print a + " "+ b</pre></div><p>To run this file, execute the following command on the terminal where the <code class="literal">test.py</code> file is saved:</p><div><pre class="programlisting">
<strong>$ python test.py</strong>
</pre></div><p>You should be able to see the text <code class="literal">Python Programming</code> printed on the terminal. As you can see, the file starts with <code class="literal">#!/usr/bin/python</code>, which is the default Python installation location. By adding this line in your Python code, you can directly execute a Python file from the terminal. In Unix-based operating systems, you need to make the <code class="literal">test.py</code> file executable through the following command:</p><div><pre class="programlisting">
<strong>$ chmod +x test.py</strong>
</pre></div><p>Now, as your file is executable, you can directly run the file using the following command:</p><div><pre class="programlisting">
<strong>$./test.py</strong>
</pre></div><div><div><h3 class="title"><a id="note21"/>Note</h3><p>For Unix-based operating systems, an alternative way to provide the Python interpreter location is to use the following line of code instead of the one that we used:</p><div><pre class="programlisting">#!/usr/bin/env python</pre></div><p>In Windows operating systems, Python files automatically become executable because of the <code class="literal">.py</code> extension. You can just run the program files by double-clicking and opening them.</p></div></div></div><div><div><div><div><h2 class="title"><a id="ch03lvl2sec57"/>The Python code</h2></div></div></div><p>As you <a id="id352" class="indexterm"/>now know how to create and run Python code, let's create a new Python file with the following code snippet and run it. Make sure to change the value of the <code class="literal">port</code> variable according to your operating system, as described in the previous chapter:</p><div><pre class="programlisting">#!/usr/bin/python

# Import required libraries
import pyfirmata
from time import sleep

# Define custom function to perform Blink action
def blinkLED(pin, message):
    print message
    board.digital[pin].write(1)
    sleep(1)
    board.digital[pin].write(0)
    sleep(1)

# Associate port and board with pyFirmata
port = '/dev/ttyACM0'
board = pyfirmata.Arduino(port)

# Use iterator thread to avoid buffer overflow
it = pyfirmata.util.Iterator(board)
it.start()

# Define pins 
pirPin = board.get_pin('d:7:i')
redPin = 12
greenPin = 13

# Check for PIR sensor input
while True:
    # Ignore case when receiving None value from pin
    value = pirPin.read()
    while value is None:
        pass
    
    if value is True:
        # Perform Blink using custom function
        blinkLED(redPin, "Motion Detected")
        
    else:
        # Perform Blink using custom function
        blinkLED(greenPin, "No motion Detected")

# Release the board
board.exit()</pre></div><p>You<a id="id353" class="indexterm"/> have successfully created and executed your first Arduino project using Python. There are two main programming components in this code: <code class="literal">pyFirmata</code> methods and the Python function to perform the blinking action. The program repeatedly detects the motion events and performs the blinking action. In the previous section, this problem was solved by using the default Arduino function <code class="literal">loop()</code>. In this method, we have implemented the <code class="literal">while</code> statement to keep the program in loop until the code is manually terminated by the user. You can terminate the code using the keyboard combination <em>Ctrl</em> + <em>C</em>.</p></div><div><div><div><div><h2 class="title"><a id="ch03lvl2sec58"/>Working with pyFirmata methods</h2></div></div></div><p>As part of <a id="id354" class="indexterm"/>working with the Arduino board and the Firmata protocol, you have to start by initializing the Arduino board as a variable. The <code class="literal">pyFirmata</code> method that lets a user assign the board to a Python variable is as follows:</p><div><pre class="programlisting">board = pyfirmata.Arduino(port)</pre></div><p>Once the value of the variable is assigned, you can perform various actions such as reading a pin or sending a signal to the pin using that variable. To assign a role to a pin, the <code class="literal">get_pin()</code> method is used. In the following line of code, <code class="literal">d</code> represents the digital pin, <code class="literal">7</code> is the pin number, and <code class="literal">i</code> represents that the type of pin is an input pin:</p><div><pre class="programlisting">pirPin = board.get_pin('d:7:i')</pre></div><p>Once a pin and its role are assigned to a variable, that variable can be used to read or write values on the pin:</p><div><pre class="programlisting">Value = pirPin.read()</pre></div><p>One <a id="id355" class="indexterm"/>can directly write data to a specific pin, as described in following code:</p><div><pre class="programlisting">board.digital[pin].write(1)</pre></div><p>Here, the <code class="literal">write(1)</code> method sends a <code class="literal">HIGH</code> signal to the pin. We will be learning additional <code class="literal">pyFirmata</code> methods in the upcoming chapters.</p></div><div><div><div><div><h2 class="title"><a id="ch03lvl2sec59"/>Working with Python functions</h2></div></div></div><p>A Python function begins with the <code class="literal">def</code> keyword followed by the function name and the input <a id="id356" class="indexterm"/>parameters <a id="id357" class="indexterm"/>or arguments. The function definition ends with a colon (<code class="literal">:</code>) and it is indented afterwards. The <code class="literal">return</code> statement terminates the function. It also passes the expression to the place where the function is called<a id="id358" class="indexterm"/>. If the <code class="literal">return</code> statement is kept without an expression, it is considered to pass the return value <code class="literal">None</code>:</p><div><pre class="programlisting">def function_name(parameters):
  action_1
  action_2
  return [expression]</pre></div><p>The preceding framework can be used to create custom functions to perform recurring tasks. In our project, we have the <code class="literal">blinkLED(pin, message)</code> function to perform the blinking LED action. This function sends <code class="literal">1</code> (<code class="literal">HIGH</code>) and <code class="literal">0</code> (<code class="literal">LOW</code>) value to the specified digital pin while also printing <code class="literal">message</code> on the terminal. It also introduces delay to simulate the blinking action:</p><div><pre class="programlisting">def blinkLED(pin, message):
    print message
    board.digital[pin].write(1)
    sleep(1)
    board.digital[pin].write(0)
    sleep(1)</pre></div></div><div><div><div><div><h2 class="title"><a id="ch03lvl2sec60"/>Testing</h2></div></div></div><p>You can <a id="id359" class="indexterm"/>start testing the project as soon as you run the Python code on the terminal. If everything goes according to design, you should be able to see the following output in the terminal:</p><div><img src="img/5938OS_03_08.jpg" alt="Testing"/></div><p>You <a id="id360" class="indexterm"/>should be able to see the <code class="literal">Motion Detected</code> string on the terminal when any motion is detected by the PIR sensor. If you find any abnormal behavior in the output, then please check the Python code.</p><p>A benefit of using Python is that minor modifications such as changing the blinking speed or swapping roles of the LEDs can be performed by just changing the Python code, without dealing with the Arduino or the electrical circuit.</p></div><div><div><div><div><h2 class="title"><a id="ch03lvl2sec61"/>Troubleshooting</h2></div></div></div><p>When <a id="id361" class="indexterm"/>you run the project, you might require troubleshooting for the following probable problems:</p><div><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">Serial output is correct, but there are no blinking LEDs:<div><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">Check the LED connections on the breadboard</li></ul></div></li><li class="listitem" style="list-style-type: disc">The LED blinks, but there is no serial output:<div><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">Check whether you have successfully installed the standard Firmata sketch to the board</li></ul></div></li><li class="listitem" style="list-style-type: disc"> There is<a id="id362" class="indexterm"/> no serial output and no blinking LEDs:<div><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">Check whether any program other than Python is using the serial port. Close any program that might be using that serial port, including the Arduino IDE.</li><li class="listitem" style="list-style-type: disc">Verify all the circuit connections.</li><li class="listitem" style="list-style-type: disc">Make sure that the port name specified in the Python code is correct.</li></ul></div></li></ul></div></div></div>
<div><div><div><div><h1 class="title"><a id="ch03lvl1sec25"/>Summary</h1></div></div></div><p>Between the two programming methods that you learned in this chapter, the method that uses just an Arduino sketch represents the traditional paradigm of programming a microcontroller. While this method is simple to implement, it lacks the extensiveness that is achieved by Python-Arduino interfacing. Although we will use extensive Arduino coding in all the projects beginning from now, exercises and projects will have Python-Arduino interfacing as the primary way of programming.</p><p>Starting from the next chapter, we are going to explore the additional aspects of Python programming that can extend the usability of an Arduino-based hardware project while keeping the programming difficulty levels to a minimum. We will begin with Python-Arduino prototyping and then create graphical interfaces for user interaction, before stopping for the second project that utilizes these concepts.</p></div></body></html>