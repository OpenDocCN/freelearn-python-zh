- en: '*Chapter 10:* Programming Paradigms'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: If we look at all the programming languages, we can see patterns and similarities
    between them, and we can use these to classify them into different paradigms.
    The word **paradigm** means a typical example or pattern of something, and this
    is precisely what we are looking for in programming languages when grouping them.
  prefs: []
  type: TYPE_NORMAL
- en: The reason we want to do this classification is because the way we write a program
    in one of these groups will differ significantly from how we do so in languages
    belonging to another group.
  prefs: []
  type: TYPE_NORMAL
- en: A computer program will almost always, in one way or another, model something
    in the real world. We are solving real-world problems using software. The question
    is how best we can model and represent real-world things in code and how best
    we can structure the solution we have to this real-world problem.
  prefs: []
  type: TYPE_NORMAL
- en: 'In this chapter, you will learn about the following topics:'
  prefs: []
  type: TYPE_NORMAL
- en: Understanding structured programming
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Understanding object-oriented programming
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Understanding functional programming
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Understanding logic programming
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Understanding other paradigms
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Understanding multi-paradigm languages
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Let''s begin with the paradigm that we are most familiar with: structured programming.'
  prefs: []
  type: TYPE_NORMAL
- en: Understanding structured programming
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Structured programming is what we have looked at in this book. Loops, conditionals,
    and functions define the flow of a program that uses this paradigm. If you have
    read the previous chapters of this book, then they should all be familiar to you
    by now.
  prefs: []
  type: TYPE_NORMAL
- en: Structured programming is a branch of a family of paradigms called **imperative
    programming**. Languages that use the concepts of imperative programming use statements
    to change the program's state.
  prefs: []
  type: TYPE_NORMAL
- en: If we look at that definition, we must first learn what statements and program
    state are.
  prefs: []
  type: TYPE_NORMAL
- en: Statements
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In the first part of this definition, we'll talk about statements. A statement,
    as described in [*Chapter 5*](B15554_05_Final_NM_ePub.xhtml#_idTextAnchor081),
    *Sequence – The Basic Building Block of a Computer Program*, in the *Understanding
    statements* section, this can be viewed as a command that we give to the application.
    In natural language, we have something that is called the imperative mood. The
    imperative mood is something that forms a command, such as *Move!*, *Don't be
    late!*, or *Work hard!*. In imperative programming, we give instructions to the
    computer with something that is like the imperative mood; that is, a command that
    is expressed in the form of a statement.
  prefs: []
  type: TYPE_NORMAL
- en: That is the first half of the definition of imperative programming. The second
    part talks about changing the program's state.
  prefs: []
  type: TYPE_NORMAL
- en: Program state
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: A program is said to have a state if it remembers previous events that have
    occurred. A program stores data in variables. At any given point, during the program's
    execution, we can look at the data that is currently in all the variables we have
    defined. The combined value in all these variables is what makes up the state
    of the program.
  prefs: []
  type: TYPE_NORMAL
- en: If we change one variable, the state of the program will also change. When we
    are talking about imperative programming, we mean that as soon as a statement
    changes the content of a variable, it has changed the program state.
  prefs: []
  type: TYPE_NORMAL
- en: This is what forms the memory of preceding events. When an event – a statement,
    in our case – occurs and it changes a variable, it will affect the behavior of
    the program. If we have an application that will launch a rocket, we might have
    a function that takes care of the countdown. To keep track of what number we are
    currently at, we need to have a variable. Changing this variable during the countdown
    will change the state of the application. When the variable reaches zero, it will
    trigger the event of sending the start signal to the rocket.
  prefs: []
  type: TYPE_NORMAL
- en: If this is imperative programming, how are things different in structured programming?
    Let's compare them.
  prefs: []
  type: TYPE_NORMAL
- en: Comparing imperative and structured programming
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Programs written in assembly language use a concept known as GOTOs. It is a
    technique that's used to control the flow in a program. To use them, we insert
    labels into the code, and we can then instruct the program to jump to one such
    label and resume its execution there.
  prefs: []
  type: TYPE_NORMAL
- en: 'A small code snippet of assembly language can illustrate this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: Here, we have a label called `exit`. On the first line, we move the value `3`
    into a register (remember that a register in an assembly is like a variable) called
    `eax`. On the second line, we do an unconditional jump to our label, `exit`. The
    jump being unconditional means that we will always do this jump. In the assembly
    language, there are also conditional jumps where we only jump if a register is
    equal to, less than, or higher than some value.
  prefs: []
  type: TYPE_NORMAL
- en: Since the jump is unconditional, line three will never execute as we will always
    jump past this line.
  prefs: []
  type: TYPE_NORMAL
- en: 'Many languages that came into existence in the 60s and 70s also had the same
    concept of an unconditional jump. Here, we can find languages such as BASIC and
    C. In these languages, it is not called a jump. Instead, the term *GOTO* is used.
    The programming language C++ is based upon C, so it also uses GOTO. The same program
    written in C++ will look like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: Today, it is, under most circumstances, considered a bad practice to use GOTOs
    as the code will be hard to read, understand, and maintain. There is hardly ever
    any need to perform a GOTO as languages such as BASIC and C support constructs
    that can let us achieve the same result and maintain good code quality.
  prefs: []
  type: TYPE_NORMAL
- en: Using this style of programming was what first defined imperative programming.
    As programming languages developed and we got other tools, such as loops, `if`
    statements, and functions, there was a need to distinguish these more modern languages
    from the older style. Even though these programming languages use the same ideas
    as assembly language, these statements will change the state of the program. This
    is because they no longer rely on jumps or GOTOs to accomplish this. This was
    when we got the definition structured programming. A language that supports structured
    programming is a language that modifies the state of the program using statements
    and has functions, loops, and `if` statements as tools to accomplish this.
  prefs: []
  type: TYPE_NORMAL
- en: We will sometimes also hear the terms *procedural* and *modular* languages.
    There is no need to go into the details of what the difference is between these
    as this is mostly academic. We can safely consider all these the same thing.
  prefs: []
  type: TYPE_NORMAL
- en: 'Some well-known languages that support structured programming or their relatives,
    procedural and imperative programming, are as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: Ada
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: ALGOL
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: BASIC
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: C
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: C++
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: C#
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: COBOL
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Fortran
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Go
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Java
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: JavaScript
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Pascal
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Perl
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: PHP
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Python
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Ruby
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Rust
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Swift
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Visual Basic
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Structured programming is a popular paradigm, as this long list of languages
    proves. In the 90s, another paradigm gained popularity and is still one of the
    essential paradigms in use. It is called object-oriented programming. Let's see
    what this is about.
  prefs: []
  type: TYPE_NORMAL
- en: Understanding object-orientated programming
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The main idea within object-oriented programming is to model the code in the
    same way as we as humans look at the world.
  prefs: []
  type: TYPE_NORMAL
- en: Even if you've never thought about it, we are always classifying things and
    grouping things together using abstraction. We can talk about vehicles, and we
    have shared knowledge of what is included in this group. Cars, bicycles, boats,
    and airplanes are, while pencils, ducks, and swimsuits are not.
  prefs: []
  type: TYPE_NORMAL
- en: I could say, *I need to go to town. Can anyone lend me a vehicle?*
  prefs: []
  type: TYPE_NORMAL
- en: You will interpret this in such a way that the actual kind does not matter,
    but it must be something that can transport me to town. It could just as well
    be a car as it could be a skateboard.
  prefs: []
  type: TYPE_NORMAL
- en: Grouping things into these abstractions make our lives easier as we will not
    go into details every single time, we talk about something. I can ask for a vehicle
    instead of describing that I need a device that can transport me from my current
    location to town.
  prefs: []
  type: TYPE_NORMAL
- en: Things within such an abstraction can be very different, but if they share some
    key characteristics, we will understand it. Take a look at the following image.
    Here, we have two items that can both be grouped into something that we can call
    remote controls.
  prefs: []
  type: TYPE_NORMAL
- en: 'One of them will control your TV and let you change channels and change the
    volume. The other one will let you lock and unlock your car:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 10.1 – Remote controls](img/Fig_10.1_B15554.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 10.1 – Remote controls
  prefs: []
  type: TYPE_NORMAL
- en: Even though they work with different devices and the result of pushing their
    buttons will be very different, they share the behavior in that they control something
    from a distance wirelessly. We have labeled these devices remote controls to make
    our communication more convenient.
  prefs: []
  type: TYPE_NORMAL
- en: What if we could do the same when writing software? This is where object orientation
    comes in. It will let us use the same approach.
  prefs: []
  type: TYPE_NORMAL
- en: If we are going to write a program that keeps track of the warehouse inventory
    and we want to do so object-oriented style, we can look at a real warehouse and
    describe it just as we see it.
  prefs: []
  type: TYPE_NORMAL
- en: 'In the warehouse, we have things such as the following:'
  prefs: []
  type: TYPE_NORMAL
- en: Products
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Shelves
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A coffee machine
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Warehouse employees
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A dead flower in the window
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Our system will need to know about some of these things, but not all of them.
    In the preceding list, we can ignore the flower and the coffee machine, but the
    other three are good candidates for making it into our program.
  prefs: []
  type: TYPE_NORMAL
- en: If we look at one of these products, we will see that it can be several things,
    all the way from tiny screws and bolts to machines or devices of some sort. But
    from the perspective of a warehouse, they share the same characteristics. They
    are all items that we store, and we can describe them using the same attributes.
    They have a name, a weight, and manufacturer; we have a certain amount of them;
    and so on.
  prefs: []
  type: TYPE_NORMAL
- en: In object-oriented programming, we try to preserve this way of describing things
    and represent them in a way that is not too different from how we just described
    them here.
  prefs: []
  type: TYPE_NORMAL
- en: To understand how object-oriented programming works, we will need to break it
    down into some main concepts that we will need to understand. Let's check them
    out.
  prefs: []
  type: TYPE_NORMAL
- en: Classes and objects
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In object-orientated programming, a class is like a blueprint, or description,
    of something. Let's take the concept of a person as an example. How can we describe
    a person? We can start to make a list of things that apply to all people. It might
    look something like this.
  prefs: []
  type: TYPE_NORMAL
- en: 'A person has the following attributes:'
  prefs: []
  type: TYPE_NORMAL
- en: A name
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: An age
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A gender
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Height
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Weight
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Hair color
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Eye color
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Shoe size
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Nationality
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Address
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Telephone number
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The list can go on. We can now decide that these are things that apply to all
    people. If we think about it, this is all data about a person. We have not described
    any behavior. We could make another list that describes things a person can do.
  prefs: []
  type: TYPE_NORMAL
- en: 'A person can do the following:'
  prefs: []
  type: TYPE_NORMAL
- en: Jump
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Run
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Walk
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Sit
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Stand
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Sleep
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Chill
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Work
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Play
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Dance
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The same thing applies here – this list can be very long.
  prefs: []
  type: TYPE_NORMAL
- en: 'If we are going to represent a person in a program, we won''t need all the
    available data and behavior. Instead, we need to make an abstract of a person
    in such a way that we can represent them with the things that are interesting
    for us. Name, age, and sex might all be such things, but shoe size will most likely
    not be unless we are writing an application for a shoe store. Let''s focus on
    the data and pick some things that might be interesting enough to implement in
    an application. We might pick the following:'
  prefs: []
  type: TYPE_NORMAL
- en: Name
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Age (most likely in the form of date of birth)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Gender
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Address
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Nationality
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Phone number
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Email address
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Now, we'll learn how to define a blueprint – called a class in object-oriented
    programming – for a person since we have a list of data that applies to all people.
  prefs: []
  type: TYPE_NORMAL
- en: 'We give it a descriptive name and list the things we are interested in. It
    might look something like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 10.2 – A class called person](img/Fig_10.2_B15554.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 10.2 – A class called person
  prefs: []
  type: TYPE_NORMAL
- en: The preceding image depicts a class in a simplified way; that is, a rectangle
    with three sections. In the top section, we have the name that we have given this
    class. In the middle section, we've described the data we want to use to describe
    a person. The last section is for behavior, which is something we will come back
    to soon.
  prefs: []
  type: TYPE_NORMAL
- en: Object-oriented programming is very focused around data, so when we're deciding
    what a class will look like, this is often where we start. The data that makes
    it into our class will often dictate what kind of behavior we want it to have.
    This behavior often dictates the operations we need to perform on the data.
  prefs: []
  type: TYPE_NORMAL
- en: The behavior we identified for a person earlier, such as jump, run, and sleep,
    will most likely not be something we will need to represent. Instead, we will
    usually find things that will modify the data, such as changing the address.
  prefs: []
  type: TYPE_NORMAL
- en: For now, we will leave the third section of the class empty, but we will come
    back to it later.
  prefs: []
  type: TYPE_NORMAL
- en: Now, we have a class and the blueprint for a person, but we haven't represented
    any actual people yet. A representation of a thing – in our case, a person – is
    called an *object*. An object will always belong to a class. Now that we have
    a class, we can create an object from it, and each object will represent one person.
  prefs: []
  type: TYPE_NORMAL
- en: 'If we have a group of people that we want to represent in our application,
    a representation of them could look as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 10.3 – Four objects from the person class](img/Fig_10.3_B15554.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 10.3 – Four objects from the person class
  prefs: []
  type: TYPE_NORMAL
- en: As we can see in the preceding diagram, all four objects have their own set
    of data; a name, a date of birth, a gender, an address, a nationality, a phone
    number, and an email address. The data in one object is independent of the data
    in other objects that belong to the same class. If we change the address in one
    object, it will not affect any other object.
  prefs: []
  type: TYPE_NORMAL
- en: To summarize this, we can state that a class is a model or the blueprint for
    the objects. The data that is defined within the class is often referred to as
    **member variables** or **attributes**.
  prefs: []
  type: TYPE_NORMAL
- en: Member variables
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'A member variable is just like any other variable, with one key difference:
    it lives inside of an object.'
  prefs: []
  type: TYPE_NORMAL
- en: 'To illustrate this, we can consider a very minimal class for a person. It could
    look something like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: 'Here, we''re defining a class called `Person`. It has two variables inside
    it: `name` and `age`.'
  prefs: []
  type: TYPE_NORMAL
- en: At this point, no actual variables exist in the computer's memory as this is
    just a blueprint for what a person object will look like. To make them come into
    existence, we need to create objects, often referred to as instances, from this
    class.
  prefs: []
  type: TYPE_NORMAL
- en: 'This can be done like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: 'This creates two objects. We use the variable names `p1` and `p2` to reference
    them. The interesting part is what happens when we create these objects. If we
    take a closer look at line one, we will see that a chain of events will occur:'
  prefs: []
  type: TYPE_NORMAL
- en: The first thing that happens is that, somewhere in the computer's memory, an
    object from the `Person` class is created with a set of two variables called `name`
    and `age`, as shown in the following image![Figure 10.4 – An object from the person
    class](img/Fig_10.4_B15554.jpg)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Figure 10.4 – An object from the person class
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: The next step is that the member variables get initialized with the data we
    passed in when we created the object. This is illustrated in the following image:![Figure
    10.5 – The member variables in the object are initialized](img/Fig_10.5_B15554.jpg)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Figure 10.5 – The member variables in the object are initialized
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'The last step is that the `p1` variable now points out where in memory this
    object is located, as illustrated in the following image:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![Figure 10.6 – The object is referenced by the p1 variable](img/Fig_10.6_B15554.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 10.6 – The object is referenced by the p1 variable
  prefs: []
  type: TYPE_NORMAL
- en: 'Then, this process is repeated for the object that contains the name `Manfred`.
    By doing this, we get something that looks similar to the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 10.7 – Two objects from the Person class](img/Fig_10.7_B15554.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 10.7 – Two objects from the Person class
  prefs: []
  type: TYPE_NORMAL
- en: Now that we have two objects, we can see that we have two variables called `name`
    and `age`. One of each is inside the `p1` object and the `p2` object. For every
    object we create from the `Person` class, we will get a new set of these two.
  prefs: []
  type: TYPE_NORMAL
- en: 'We will soon change this class, but as it looks now, we can access these variables
    like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: 'This will give us the following output:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: Object-oriented programming states that member data should be encapsulated within
    its object and that direct access to this data from the outside should be prevented.
    Let's see why this is a critical concept in object orientation.
  prefs: []
  type: TYPE_NORMAL
- en: Understanding encapsulation
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Encapsulation, also known as information hiding, is a concept where the object's
    internal implementation is hidden from everything outside the object.
  prefs: []
  type: TYPE_NORMAL
- en: 'Encapsulation can be described in many ways. The American computer engineers
    James Rumbaugh and Michael Blaha described it like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '*"One design goal is to treat classes as "black boxes," whose external interface
    is public but whose internal details are hidden from view. Hiding internal information
    permits implementation of a class to be changed without requiring any clients
    of the class to modify code."*'
  prefs: []
  type: TYPE_NORMAL
- en: The vital key here is the *interface*. An interface is what we use to communicate
    with an object. Look at the remote controls in *Figure 10.1*. The buttons we can
    push is the interface. We use them to communicate with the internal logic inside
    the device.
  prefs: []
  type: TYPE_NORMAL
- en: The remote control object is a *black box* as we can't see the internals of
    the remote, and there is no need for us to either. The only thing we need to understand
    to be able to use the object is the interface. If the remote is not working correctly,
    we can take it to someone who understands the inner workings of it, and they can
    repair it. If they don't change the interface, the buttons, and what functionality
    that is associated with them, we won't need to change the way we use the remote
    before and after the modification.
  prefs: []
  type: TYPE_NORMAL
- en: One thing we should hide from the outside world is the data. No, wait! If the
    data is hidden inside an object, how could we then use it? Let's look at an example
    to see what we mean by hiding the data inside an object.
  prefs: []
  type: TYPE_NORMAL
- en: 'If you walk down the street and you meet another person, you cannot, just by
    observing that person, see things such as the person''s name, what they had for
    breakfast, their age, and where they live. This data is encapsulated inside the
    object:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 10.8 – Data encapsulated inside a real-world object](img/Fig_10.8_B15554.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 10.8 – Data encapsulated inside a real-world object
  prefs: []
  type: TYPE_NORMAL
- en: 'To get this information, we will need to ask the person. We say that objects
    communicate by passing messages to each other. This looks something like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 10.9 – Two objects communicating by sending messages](img/Fig_10.9_B15554.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 10.9 – Two objects communicating by sending messages
  prefs: []
  type: TYPE_NORMAL
- en: We will need to modify our class so that the data is hidden and we have a way
    to communicate with it.
  prefs: []
  type: TYPE_NORMAL
- en: 'We can hide the data by using the `private` keyword. The class will now look
    something like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: By declaring `name` and `age` as private, we can no longer access them from
    outside the class. This means that the lines where we printed the name and age
    of the two objects will no longer work.
  prefs: []
  type: TYPE_NORMAL
- en: The class, as it looks now, is useless as we can create an object and assign
    values to its variables, but there is no way for us to do anything with this data
    after this point as it is hidden from us. We will need to create an interface,
    such as the buttons on the remote control, that will let us work with the data.
    We will do that with the help of class methods.
  prefs: []
  type: TYPE_NORMAL
- en: Class methods
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: A class method is nothing but a function that belongs to a class. The reason
    we have a different name for these functions is so that we can distinguish between
    a function that is part of a class and one that is not. As soon as you hear someone
    mention a method, you know that it is a function that belongs to a class.
  prefs: []
  type: TYPE_NORMAL
- en: Two popular methods that we will find in classes are what are called *getters*
    and *setters*. A getter is a method that returns the value of a private member
    variable, while a setter is a method that lets us change its value.
  prefs: []
  type: TYPE_NORMAL
- en: 'To make a method available outside the class, we can use the `public` keyword.
    To this, we can add getters and setters for our class, and it will then look like
    this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: This will give us access to the member variables. We can now create objects,
    get the private data stored inside of them, and change their value if needed.
  prefs: []
  type: TYPE_NORMAL
- en: 'It will look something like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: 'This will produce the following output:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: A natural question at this point is why we need to bother having these getters
    and setters. Why can't we just say that `name` and `age` are `public` and let
    anyone read and change them as they want? The reason is that keeping the data
    private and controlling access to it through methods will give us control.
  prefs: []
  type: TYPE_NORMAL
- en: If a stranger walks up to you and asks for your name, you will have some options.
    You could respond with your actual name, you could tell them that it is none of
    their business, or you could lie and tell them a different name. You have control
    over the access to your private data, just as the class will have control over
    the access to its private data with the help of these methods.
  prefs: []
  type: TYPE_NORMAL
- en: 'When the `set_age` method is called, we could, for example, check the value
    that is being passed in to make sure that it is within a valid range. We could,
    for example, refuse to set the age if it is a negative number or higher than any
    expected human age. We could make use of exceptions, which we covered in [*Chapter
    9*](B15554_09_Final_NM_ePub.xhtml#_idTextAnchor127), *When Things Go Wrong – Bugs
    and  Exceptions*, in the *Working with exceptions* section. The `set_age` method
    would then look something like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: We will now get an exception if the value that's being passed to the method
    is below `0` or greater than `130`.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, we can add some class methods to the diagram we looked at previously in
    *Figure 10.2* . In the following image, we can see that we''re making use of the
    lower part of the rectangle for this:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 10.10 – A class with member variables and methods](img/Fig_10.10_B15554.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 10.10 – A class with member variables and methods
  prefs: []
  type: TYPE_NORMAL
- en: 'A class can, of course, have methods other than just getters and setters. It
    is up to us to decide what methods we want our class to have. Our `Person` class
    could, for example, have a method called `birthday` where we increase the age
    of a person by one, as shown in the following code snippet:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: 'We could now use it like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: 'The output of this program will be the same as it was previously:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: As we can see, the power of object-oriented programming is that objects are
    self-contained entities that control their data. But object-oriented programming
    has another powerful feature that will let us reuse code, and that is the concept
    of inheritance.
  prefs: []
  type: TYPE_NORMAL
- en: Inheritance
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'If I asked you if I could borrow your phone to make a call, it would not matter
    if you gave me your smartphone, an old mobile phone from 2005, or even access
    to a landline telephone. They all share some of the same features, with one of
    them being the ability to make phone calls. We could define this with a chain
    of statements, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: A smartphone is a mobile phone
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A mobile phone is a telephone
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A telephone can make phone calls
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A smartphone can, therefore, make phone calls
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'We could say that we have several levels of abstractions where we have a relationship
    between the levels. This is what we call an *is-a* relation. We can illustrate
    this with the following diagram:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 10.11 – Is-a relations between telephones](img/Fig_10.11_B15554.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 10.11 – Is-a relations between telephones
  prefs: []
  type: TYPE_NORMAL
- en: We can say that because a smartphone is a mobile phone, it can do anything a
    mobile phone can. We also know that a smartphone can do things that an old-style
    mobile phone can't, such as allowing us to use the GPS together with a map app
    to help us navigate.
  prefs: []
  type: TYPE_NORMAL
- en: A mobile phone, on the other hand, can do everything the landline telephone
    can; that is, make and receive calls. But it can also do other things, such as
    allow us to send text messages.
  prefs: []
  type: TYPE_NORMAL
- en: We can also view this relationship as a parent-child relationship. The smartphone
    is a child of the mobile phone, and the mobile phone is its parent. This also
    means that a child will inherit from its parent. This is how inheritance works
    in object-oriented programming.
  prefs: []
  type: TYPE_NORMAL
- en: 'A class can inherit another class, and by that, get everything that is defined
    in the parent class and just add the things that make this class unique.  To see
    what this might look like, we will need two classes. We can have a `Person` class
    that is defined like the one we saw in *figure 10.10*. It might look something
    like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: In this class, we define all the member variables as private members of the
    class, and all the getters and setters are defined as public.
  prefs: []
  type: TYPE_NORMAL
- en: 'The information used here applies to all people, but we might have some people
    that we need to store additional information for. This could, for example, be
    employees. They are people, and by that, all the information we store about a
    person will apply to them as well, but we have additional data that we want to
    store about employees. This could be things such as salary and department. We
    don''t want to define them, however, as shown in the following image:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 10.12 – Two classes not using inheritance](img/Fig_10.12_B15554.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 10.12 – Two classes not using inheritance
  prefs: []
  type: TYPE_NORMAL
- en: 'Here, we can see that everything we have in the `Person` class is repeated
    in the `Employee` class. The only difference is that we have added `Employee`
    class will inherit from the `Person` class and, by that, they automatically get
    everything that is defined in `Person`. This will look something like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 10.13 – Employee inheriting from Person](img/Fig_10.13_B15554_New.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 10.13 – Employee inheriting from Person
  prefs: []
  type: TYPE_NORMAL
- en: Here, the `Employee` c;ass will inherit everything from `Person`. The only thing
    we will need to define in the `Employee` class is the things that make this class
    unique. Just as we usually represent classes with the rectangle with three sections,
    inheritance is visualized with a hollow, arrow-like symbol, as shown in the preceding
    image.
  prefs: []
  type: TYPE_NORMAL
- en: 'When implementing this inheritance in code, we don''t need to make any changes
    to the `Person` class. So, the `Employee` class will look like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: Even though we only have code for the salary and department in this class, from
    the first line we can say that we inherit the `Person` class.
  prefs: []
  type: TYPE_NORMAL
- en: Exactly how object-oriented programming is implemented differs from language
    to language. Languages that support object-orientation will also sometimes have
    slightly different rules for how object-orientation is used. As always, we will
    need to learn how the language we are using has defined the object-oriented principles.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following is a list of some popular languages that support object orientation,
    either entirely or as an option:'
  prefs: []
  type: TYPE_NORMAL
- en: C++
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: C#
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Java
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: JavaScript
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Object-C
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: PHP
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Python
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Ruby
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Scala
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Swift
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Object orientation is one of the major paradigms. It has many fans who like
    it and think it is a good way to structure code. The next paradigm we will look
    at has been around for a long time but has gained in popularity in the last few
    years: functional programming. It is now considered one of the more interesting
    paradigms by many programmers.'
  prefs: []
  type: TYPE_NORMAL
- en: Understanding functional programming
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Functional programming is a paradigm that has gained popularity. It is not new;
    we can trace its roots back to Lambda calculus, which was introduced in the 1930s.
    In the 1950s, the programming language Lisp was developed and implemented this
    paradigm.
  prefs: []
  type: TYPE_NORMAL
- en: As we will see, this paradigm has a very different approach to how programs
    are structured and implemented. You will need to rethink the way you look at programming
    and code structure to be able to understand the strength of this paradigm.
  prefs: []
  type: TYPE_NORMAL
- en: We will begin by looking at a definition of functional programming. The definition
    will, itself, be hard to understand, so we will also need to look at some parts
    of it to understand what this is all about.
  prefs: []
  type: TYPE_NORMAL
- en: 'One definition is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '*"Functional programming is a way of structuring a computer program that treats
    computation as the evaluation of mathematical functions and avoids changing the
    state of the program and the use of mutable data."*'
  prefs: []
  type: TYPE_NORMAL
- en: Let's start by deciphering this definition. The *treats computation as the evaluation
    of mathematical functions* part might sound scary. If we look closely at this,
    we will see that this is rather straightforward. Let's look at two mathematical
    functions and see how we can use and understand them in order to understand what
    the definition of functional programming is talking about.
  prefs: []
  type: TYPE_NORMAL
- en: Pure functions
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'We will start simple with the following function:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/Formula_10_001.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Here, *x* is the input we provide to the function and *y* is the result. This
    simple function just states that whatever we pass a value to it, it will also
    be returned.  A diagram for this function looks as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 10.14 – Diagram for y = x](img/Fig_10.14_B15554.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 10.14 – Diagram for y = x
  prefs: []
  type: TYPE_NORMAL
- en: Here, we can see that if **x** is **1**, **y** is also **1** and that if **x**
    is **-3**, **y** is also **-3**. What's even more essential for us to understand
    regarding what the definition talks about is the fact that the same input to **x**
    will always yield the same value as a result in **y**. If we input **5** for **x**,
    we will always get **5** for **y**.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s look at another function to see if the same thing is true:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/Formula_10_002.png)'
  prefs: []
  type: TYPE_IMG
- en: 'This is a function for a straight line. The value of `2` and `3`, we will get
    the following diagram:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 10.15 –  Diagram for y = mx + c when m = 2 and c = 3](img/Fig_10.15_B15554.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 10.15 –  Diagram for y = mx + c when m = 2 and c = 3
  prefs: []
  type: TYPE_NORMAL
- en: Again, the most important thing to learn from this is that the result, the value
    of `3` if `0`, and always be `1` if `-1`.
  prefs: []
  type: TYPE_NORMAL
- en: 'When talking about mathematical functions in terms of functional programming,
    it is this fact that is the crucial thing: a function with the same input will
    always return the same answer. In functional programming, this is known as a *pure
    function*.'
  prefs: []
  type: TYPE_NORMAL
- en: 'But isn''t this always true for any function? Look at the following function:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: 'Let''s call this function:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: 'On calling the function, we will always get the following response:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: We can say that this is a pure function. But what happens when we call this
    function from the `math` module?
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, the output might look like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: Calling the random function with the same arguments (none in our case) will
    not give us the same answer. This is not a pure function. This is the meaning
    of evaluating mathematical functions in the preceding definition.
  prefs: []
  type: TYPE_NORMAL
- en: Next up is the second part of the definition, *avoids changing the state of
    the program and the use of mutable data*. Changing the state is something we recognize
    from when we talked about structured programming. There, we said that *structured
    programming uses statements to change the program's state*. It seems like functional
    programming is talking about the absolute opposite of what structured programming
    did. We said that the state the program is in is defined by the combination of
    the data stored in all its variables at any given time. Changing the value of
    one variable will change the state of the program.
  prefs: []
  type: TYPE_NORMAL
- en: 'What would it mean if a program avoids changing its state? Would we not be
    able to change any variables? The answer to this is yes, and that is what is part
    of the final part of the definition: that it also avoids the use of mutable data.
    What does mutable data mean? We''ll see what this is about in the next section.'
  prefs: []
  type: TYPE_NORMAL
- en: Mutable and immutable data
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Mutable means liable to change, while immutable means unable to be changed.
    The term *mutable data* means that we have data that we can change. We know that
    we store data in variables and that we can change it as we please, as shown in
    the following code block:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: Here, we first assign the value `10` to the `x` variable and then assign the
    value `20` to the `y` variable. On the last line, we change the value of `x` so
    that it's the same as `y`, which is `20`. We could say that `x` is mutable as
    we can change it. But is this proof that `x` is mutable? In some languages, it
    is, but in others, this is not true at all, even if the final value in `x` will
    always be `20`. How is it possible that `x` changes its value from `10` to `20`
    if we cannot change it? This sounds impossible.
  prefs: []
  type: TYPE_NORMAL
- en: The answer is in the way a language treats its variables. If we just think of
    a variable like a box where we can store a value and, at any time, replace it
    with another value, it is changeable, but if instead we treat a variable like
    something that is pointing out a value somewhere in the computer's memory, things
    will be slightly different.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s perform a little thought experiment. We can start with the two variables,
    `x` and `y`, and again assign the values `10` and `20` to them, as we did previously:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: 'The following diagram illustrates what it may look like if `x` and `y` reference
    a memory location:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 10.16 – Two variables referencing two memory locations](img/Fig_10.16_B15554.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 10.16 – Two variables referencing two memory locations
  prefs: []
  type: TYPE_NORMAL
- en: As we can see, the values `10` and `20` are not stored inside the variables.
    Instead, the variables are pointing out where these values are located in memory.
    What will happen if we change the value `x` references from `10` to `20`?
  prefs: []
  type: TYPE_NORMAL
- en: 'It will look something like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 10.17 – Two variables that reference the same memory location](img/Fig_10.17_B15554.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 10.17 – Two variables that reference the same memory location
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, let''s consider what would happen if the value at the memory location
    can be changed if we change one of the variables if we, for example, run this
    line of code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: 'We would then have a situation similar to the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 10.18 – Changing the value of one variable reference](img/Fig_10.18_B15554.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 10.18 – Changing the value of one variable reference
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, let''s print the value of the `x` reference, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: 'We would get the following result:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: Even if we never assigned `22` to `x`, it would have that value as we allowed
    `y` to change the content of the memory location of both references.
  prefs: []
  type: TYPE_NORMAL
- en: 'If we instead make the memory location immutable, what would happen when we
    assign `22` to `y`? We would get something like the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 10.19 – Assigning a new value to an immutable variable](img/Fig_10.19_B15554.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 10.19 – Assigning a new value to an immutable variable
  prefs: []
  type: TYPE_NORMAL
- en: As we can see, the value did not change at all. Instead, `y` is now referencing
    a new memory location. If `y` was redeclared, we would get a new fresh variable
    with the same name as the old `y` variable.
  prefs: []
  type: TYPE_NORMAL
- en: This is how immutability works. The variables are not changed. Instead, a new
    value is created in another location in memory. As we cannot change any variables,
    we can't change the state of the program either.
  prefs: []
  type: TYPE_NORMAL
- en: But why is it important that our variables are immutable and that we can't change
    the state of the program? The answer is called side effects.
  prefs: []
  type: TYPE_NORMAL
- en: Avoiding side effects
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'A side effect in computer programming is when an expression modifies some values
    in the variables that are outside its local environment. To understand this, let''s
    look at an example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: 'First, this program is very naïve, but it illustrates the point we need to
    make. Here, we have a variable, `x`, and a function called `some_func`. The variable
    is declared outside of the function but is modified inside it. We can now use
    the following expression:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: This is modifying a value outside its environment, and the body of the function
    is the environment that expression lives in.
  prefs: []
  type: TYPE_NORMAL
- en: This is true if the language we are using has defined `x` as mutable so that
    we can change it. But in a language where `x` is immutable, there would be no
    change. Instead, we would get a new `x` variable that only exists inside of the
    function.
  prefs: []
  type: TYPE_NORMAL
- en: 'What would the disadvantage be if we did this in a language where `x` was mutable?
    To see this, we can call the function twice and print its result, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: 'The output will look as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: This is not a good behavior as calling the function with the same arguments
    should always return the same value. Here, it does not, and the reason this happens
    is because the program has side effects. This is because the result the function
    returns is dependent on what happened in previous calls to the function.
  prefs: []
  type: TYPE_NORMAL
- en: If we have a program that has no side effects, it will be very predictable what
    will happen when the program runs. If we think about the previous small program,
    we saw that it will be almost impossible for us to predict what a call to the
    function will result in as the result will depend on previous calls, as well as
    what data we provided as arguments in these calls.
  prefs: []
  type: TYPE_NORMAL
- en: The next principle of functional programming is called declarative programming.
    Let's see what it's all about.
  prefs: []
  type: TYPE_NORMAL
- en: Declarative programming
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: To understand what declarative programming is, we can compare it to something
    we know, and that is imperative programming. In imperative programming, we focus
    on describing how something will be done. In declarative programming, on the other
    hand, the focus is on what we want to achieve.
  prefs: []
  type: TYPE_NORMAL
- en: To understand this, we will look at some real-world examples. If you go to a
    restaurant, you can either be an imperative or declarative guest.
  prefs: []
  type: TYPE_NORMAL
- en: 'The imperative guest would make an order like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '*"I would like the cod, please. First, bake it in the oven for 10 to 12 minutes.
    In the end, check it regularly so it won''t overcook. While the cod is in the
    oven, please boil the potatoes. To prepare the cream sauce, first, melt some butter
    in a medium-sized pan over medium heat. Slowly add corn starch and stir for about
    a minute. While constantly whisking, slowly add whipping cream and milk. Finally,
    add some parmesan cheese. Let the sauce reduce on a low heat while you whisk occasionally."*'
  prefs: []
  type: TYPE_NORMAL
- en: 'If, on the other hand, you are a declarative restaurant guest, you would say
    something like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '*"I would like the cod, please."*'
  prefs: []
  type: TYPE_NORMAL
- en: The first guest answers the question of how, while the second one focuses on
    what.
  prefs: []
  type: TYPE_NORMAL
- en: 'An excellent example of something declarative in computer science is **SQL**.
    It is an abbreviation of **Structured Query Language** and is used to store and
    retrieve data from databases. If we want to get the first and last name of all
    the customers stored in the customer''s table, we could write the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: This is declarative as we say what we want – the first and last names of the
    customers – but we say nothing about how the data will be retrieved. Somewhere
    in the underlying database system, some parts must know how this will be done,
    but if we are using SQL, we don't need to understand how this is done.
  prefs: []
  type: TYPE_NORMAL
- en: Python is a programming language where we can write both imperative and declarative
    programs. Let's look at two programs that perform the same thing, one in an imperative
    way and one in a declarative way.
  prefs: []
  type: TYPE_NORMAL
- en: 'First is a short program that has been written in an imperative style:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: 'From the preceding code, we can observe the following:'
  prefs: []
  type: TYPE_NORMAL
- en: On the first line, we define a list of strings. Each string contains a two-digit
    number. Values below 10 will be prefixed with a 0.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: On the second line, we declare an empty list. We will convert the numbers in
    the first list from strings into integer values and store them in this array.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: We will then enter a `for` loop. In each iteration of this loop, a value from
    the first list will be assigned to the `value` variable. The first time it will
    be `06`, the second time it will be `68`, and so on.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: We then have an `if` statement. It will convert the value into an integer and
    compare it to zero. If that is false – that is, it is anything but zero – we will
    enter the `if` block.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Inside this block, we will append the value we converted into an integer to
    the list numbers.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'When we have gone through all the values in the first list, we print the contents
    of the second list and get the following output:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: As you can see, the zero prefixes we had for the first value are now gone as
    these are integers, and 06 is just 6\. Also, the value that had a double zero
    is not in the list at all as it made the `if` statement false, and the line where
    we appended the value was skipped in that iteration.
  prefs: []
  type: TYPE_NORMAL
- en: 'The second version of this program is written in a declarative style and looks
    as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: This program does the same thing as the previous one, but the way it is written
    is very different. It uses something called a *list comprehension*. It is the
    part after `numbers =`. If you look closely, you can see a `for` loop in the middle
    of this expression. It looks just like the `for` loop in the other example. Following
    this loop, we can see an `if`, and it looks just like the `if` statement in the
    first program. An `if` at this location in a comprehension serves as a filter.
    If this is evaluated as true, the current value will be passed to the front of
    this expression. Here, we convert the value into an integer. This converted value
    will be part of a list called `numbers`.
  prefs: []
  type: TYPE_NORMAL
- en: This is declarative because we don't say how this value will get into the new
    list, we just say what will go into the list.
  prefs: []
  type: TYPE_NORMAL
- en: The final principle used by functional programming that we will cover is called
    first-class functions.
  prefs: []
  type: TYPE_NORMAL
- en: First-class functions
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Functional programming uses the principle of first-class functions. A function
    is said to be first-class if it is treated as a first-class citizen of the programming
    language in question. A first-class citizen is something that we can modify, pass
    as an argument to a function, return from a function, and so on.
  prefs: []
  type: TYPE_NORMAL
- en: 'In a programming language that supports first-class functions, we can do things
    such as the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs: []
  type: TYPE_PRE
- en: This program declares two functions, `formal_greeter` and `informal_greeter`.
    Both accept a `name` as its argument and will return a greeting with the name
    appended.
  prefs: []
  type: TYPE_NORMAL
- en: We then have a function called `greeter`. This function accepts a reference
    to a function as its first argument and a name as its second. The two last lines
    in the program are calling the `greeter` function. The first one is passing a
    reference to the formal greeter function, while the second is passing one to the
    informal greeter.
  prefs: []
  type: TYPE_NORMAL
- en: 'The `greeter` function will use the function passed to it, so the two calls
    will result in the following output:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs: []
  type: TYPE_PRE
- en: Being able to work with functions like this has several benefits. Let's look
    at an example. Earlier in this chapter, we talked about object-oriented programming,
    and we defined a class called `Person`. We saw that we could create several objects
    from this class, each one representing one person.
  prefs: []
  type: TYPE_NORMAL
- en: Later in this chapter, we will see that programming languages can use more than
    one paradigm, and if we use one that lets us define classes and use functions
    as first-class citizens, we can do something very useful.
  prefs: []
  type: TYPE_NORMAL
- en: 'If we create a couple of person objects with `name` and `age` and insert them
    into a list structure, this might look something like the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs: []
  type: TYPE_PRE
- en: We now have four person objects stored in a list called `persons`. If we want
    to sort the list, we can use a sorting function provided by the language. But
    there is a problem. The sorting function will not know what we want to sort on;
    that is, `name` or `age`. It does not even know anything about `Person` objects
    as they are defined by a class that we have written. What it knows is how to sort
    a list, but it needs the help of a function that can receive two objects from
    the `Person` class, and which returns `true` if the first object is larger than
    the second and `false` if it is not. We will need to write that function and,
    in it, define what makes one object larger than the other one. We can decide if
    it should be `name` or `age`.
  prefs: []
  type: TYPE_NORMAL
- en: 'If we want to sort the objects by their `age`, we could do the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE37]'
  prefs: []
  type: TYPE_PRE
- en: Here, we have a function called `compare`. It will accept two `person` objects
    as its arguments. If the age of the first person is greater than the age of the
    second person, this function will return `true`. Otherwise, it returns `false`.
  prefs: []
  type: TYPE_NORMAL
- en: The `sort` function accepts as its first argument a reference to this function.
    When it is performing the sort, it will need to compare two different objects
    to determine in what order it should place them in the sorted list.
  prefs: []
  type: TYPE_NORMAL
- en: In our example, it will first pass `Dipika`, who is `34`, and `Manfred`, who
    is `58`, to the function. The `compare` function will return `false` since the
    age of `Manfred` is greater than the age of `Dipika`.
  prefs: []
  type: TYPE_NORMAL
- en: The `sort` function will now take the winner from the last round, `Manfred`,
    and pass this object along with Ahmed's object. This time, `Manfred` will be passed
    first, so he will be the `person1` object in the function, while `Ahmed` will
    be `person2`.
  prefs: []
  type: TYPE_NORMAL
- en: This time, the first object has an age that is greater than the second one,
    so the function returns `true`.
  prefs: []
  type: TYPE_NORMAL
- en: This is how the `sort` function can use a function that we provide to fulfill
    its task to sort the list. If we want to sort on the names instead, we will only
    need to change the `compare` function so that it compares the names instead of
    the ages.
  prefs: []
  type: TYPE_NORMAL
- en: 'If we print the `sorted_persons` list, which contains the sorted list, we will
    get this result if we sort on age:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE38]'
  prefs: []
  type: TYPE_PRE
- en: 'If, instead, we sort on the names, we will get the following result:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE39]'
  prefs: []
  type: TYPE_PRE
- en: First-class functions are a compelling feature that let us write functions that
    are more general-purpose as we can pass another function that will do parts of
    its job, just as the sort function works.
  prefs: []
  type: TYPE_NORMAL
- en: Functional programming has several concepts that are both powerful and let us
    write higher quality code. That is the reason why functional programming is constantly
    gaining popularity and why many non-functional programming languages are borrowing
    functional concepts.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following is a list of some popular languages that support functional programming,
    either as its primary paradigm or are using many concepts from functional programming:'
  prefs: []
  type: TYPE_NORMAL
- en: C++ (since C++ 11)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: C#
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Clojure
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Common Lisp
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Erlang
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: F#
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Haskell
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: JavaScript
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Python
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Ruby
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Functional programming is not only a very interesting paradigm, but it is also
    influencing many established languages to incorporate functional concepts. The
    next paradigm is not as widely used as the ones we have looked at so far, but
    it has some interesting concepts.
  prefs: []
  type: TYPE_NORMAL
- en: Understanding logic programming
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: This paradigm is based on formal logic. A program written in a language that
    implements this paradigm is constructed of a set of sentences in a logical form
    that will express facts and rules about a specific problem domain.
  prefs: []
  type: TYPE_NORMAL
- en: 'This might sound complicated and strange, but as we will see, the basic concepts
    of this paradigm are rather simple. Consider the following diagram:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/Fig_10.20_B15554.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 10.20 – A family tree
  prefs: []
  type: TYPE_NORMAL
- en: 'In the preceding diagram, we can see a family tree. Looking at it, we can see
    the following:'
  prefs: []
  type: TYPE_NORMAL
- en: Anna and Bob have a child, Lisa.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Lisa and Fred have a child, Karen.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Fred and Sue have a child, John.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Karen's grandparents are Anna and Bob.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'In a programming language that uses logic programming, we can define this family
    tree using something called *predicates*. This will look something like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE40]'
  prefs: []
  type: TYPE_PRE
- en: They might seem to come in an odd order, but most logic languages want us to
    group all predicates of the same kind together so, in this case, we first define
    all the mothers and, after that, all the fathers.
  prefs: []
  type: TYPE_NORMAL
- en: On the first line, we can see that `Anna` is the mother of Lisa, while on the
    fourth line, we can see that `Bob` is the father of `Lisa`. The names are called
    *atoms* because they represent a single value, and atoms need to be defined by
    lowercase letters only.
  prefs: []
  type: TYPE_NORMAL
- en: 'We can now define some rules that dictate what makes someone a parent and grandparent.
    It might look like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE41]'
  prefs: []
  type: TYPE_PRE
- en: Here, `X`, `Y`, and `Z` are variables. Variables are defined with an initial
    capital letter. We can read this as
  prefs: []
  type: TYPE_NORMAL
- en: '*For any X, Y, Z,*'
  prefs: []
  type: TYPE_NORMAL
- en: If X is a parent of Y, and Y is a parent of Z
  prefs: []
  type: TYPE_NORMAL
- en: Then X is the grandparent of Z
  prefs: []
  type: TYPE_NORMAL
- en: The two last rows define what a parent is. It is either if `X` is the father
    of `Y` or if `X` is the mother of `Y`.
  prefs: []
  type: TYPE_NORMAL
- en: 'We can now use this to ask questions like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE42]'
  prefs: []
  type: TYPE_PRE
- en: 'This question will produce the following answer:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE43]'
  prefs: []
  type: TYPE_PRE
- en: This is true as `Anna` is the grandmother of `Karen`.
  prefs: []
  type: TYPE_NORMAL
- en: 'We can also ask who Karen''s grandparents are, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE44]'
  prefs: []
  type: TYPE_PRE
- en: 'Here, `Q` is a variable, and we will get the following response:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE45]'
  prefs: []
  type: TYPE_PRE
- en: 'We could also ask who the grandchild of Anna is:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE46]'
  prefs: []
  type: TYPE_PRE
- en: 'This will tell us that it is `Karen`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE47]'
  prefs: []
  type: TYPE_PRE
- en: There are, of course, more things that you can do in a logic programming language,
    but this was a little taste of what logic programming can look like.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following is a list of some languages that support logic programming:'
  prefs: []
  type: TYPE_NORMAL
- en: ALF
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Curry
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Fril
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Janus
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Prolog
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The way we structure the code in logic programming is very different from all
    other paradigms, making it an interesting *outsider*.
  prefs: []
  type: TYPE_NORMAL
- en: We have now looked at the leading players in the paradigm field. But before
    we leave these paradigms behind, let's just mention a few more to get a more complete
    picture.
  prefs: []
  type: TYPE_NORMAL
- en: Other paradigms
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The paradigms we have covered so far in this chapter are the most commonly used,
    but there are several others. Let's have a quick look at some of them.
  prefs: []
  type: TYPE_NORMAL
- en: Function-level
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In function-level programming, we have no variables at all. Instead, programs
    are built from elementary functions, combined with function-to-function operations,
    sometimes referred to as *functionals* or *functional forms*.
  prefs: []
  type: TYPE_NORMAL
- en: 'Languages that implement this paradigm are built around the following hierarchy:'
  prefs: []
  type: TYPE_NORMAL
- en: Atoms are the data that the functions operate on. They will only appear as input
    or output to the programs and will never be found inside the actual program.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Functions will convert atoms into other atoms. The programming language will
    define a set of functions, and the programmer can create new ones using functional
    forms. The program itself is also a function.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Functional forms are used to convert functions into other functions. They can
    be used by the programmer to create new forms.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Array programming
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In array programming, operations will be performed on an entire set of values
    at once. These solutions are commonly used for scientific and engineering applications.
  prefs: []
  type: TYPE_NORMAL
- en: Operations are generalized to apply to both scalars and arrays. In this book,
    we have encountered scalars in the form of variables that can only hold one single
    value at a time. We have also looked at arrays. If you need a refresh your memory
    on variables and arrays, you can read more about them in [*Chapter 6*](B15554_06_Final_NM_ePub.xhtml#_idTextAnchor091),
    *Working with Data – Variables*.
  prefs: []
  type: TYPE_NORMAL
- en: The *a + b* operation will act differently if *a* and *b* are scalars and if
    they are arrays. If they are scalars, the result will be the sum of adding the
    two values. If they are arrays, the result will be the sum of all values stored
    in the two arrays.
  prefs: []
  type: TYPE_NORMAL
- en: Array programming can simplify programming at the cost of efficiency. This means
    that it can be easier to use these kinds of languages when we write the code but
    running them might take a longer time than if the program is written in a language
    that uses another paradigm.
  prefs: []
  type: TYPE_NORMAL
- en: Quantum programming
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: This is the paradigm of the future. To be able to use this paradigm, we will
    need quantum computers. A quantum computer uses the quantum-mechanical properties
    particles defined in quantum physics. These particles have a superposition, meaning
    that before we observe them, they will be in any possible position. A quantum
    computer will use this by defining something known as a *qubit*. A normal computer
    has bits that can either be 0 or 1\. A qubit will be both, and using this property,
    a quantum computer will be able to calculate all possible results of any given
    input in a fraction of the time it takes to perform the same calculations with
    the kind of computers we are using today.
  prefs: []
  type: TYPE_NORMAL
- en: 'Quantum programming is not a paradigm per se, but to be able to write programs
    for quantum computers, we will need languages that will support other kinds of
    operations than the ones we are using today:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 10.21 – Part of a quantum computer built at IBM Research in Zurich.'
  prefs: []
  type: TYPE_NORMAL
- en: Photo by IBM Zurich Lab, cc-by-2.0.](img/Fig_10.21_B15554.jpg)
  prefs: []
  type: TYPE_NORMAL
- en: Figure 10.21 – Part of a quantum computer built at IBM Research in Zurich. Photo
    by IBM Zurich Lab, cc-by-2.0.
  prefs: []
  type: TYPE_NORMAL
- en: Even though we are just seeing the first quantum computers slowly take form,
    several languages that we can use for them are already defined. They are built
    upon already existing paradigms, such as imperative and functional programming.
    When we have fully functional and accessible quantum computers, we will see an
    explosion of new languages that will utilize the powers of these computers.
  prefs: []
  type: TYPE_NORMAL
- en: Multi-paradigm languages
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Most programming languages will not stick to just one paradigm but instead
    use several. This is why they are called *multi-paradigm languages*. We can make
    a table of some of the most popular languages to see what paradigms they support:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Table 10.1](img/B15554_Table_10.1.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Table 10.1
  prefs: []
  type: TYPE_NORMAL
- en: It can always be argued how much a paradigm influences a programming language.
    Here, I have looked at the main paradigms we have looked at in this chapter and
    how the documentation of the languages describes themselves.
  prefs: []
  type: TYPE_NORMAL
- en: A language that is marked with *Some* has implemented some concepts of this
    paradigm. A language that has a *Yes* in the column for a paradigm might not have
    this paradigm as its main one but has implemented many of its features.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we looked at some of the most popular programming paradigms.
  prefs: []
  type: TYPE_NORMAL
- en: The first two that we looked at, structured and object-oriented programming,
    are the two paradigms that have dominated programming over the last 35-40 years.
  prefs: []
  type: TYPE_NORMAL
- en: In structured programming, the program state is modified using statements, and
    the flow of the program is controlled using loops and selections, such as if statements.
  prefs: []
  type: TYPE_NORMAL
- en: Object-oriented programming builds upon the ideas of structured programming,
    but the code is organized using concepts known to us humans, such as classifying
    things that have similar data and behavior. This is described in classes that
    act as blueprints for objects that represent real-world things, such as people
    or bank accounts.
  prefs: []
  type: TYPE_NORMAL
- en: Functional programming is the oldest of the paradigms we covered in this book
    but has gained popularity in the last decade. In functional programming, we don't
    want to modify the state of the program and are using the concept of pure functions
    to achieve this. Writing programs using this paradigm can reduce errors in the
    code and make our applications more stable.
  prefs: []
  type: TYPE_NORMAL
- en: In logical programming, we define predicates that will define rules that we
    can use to answer logical questions. Compared to the other three paradigms, local
    programming is far less popular.
  prefs: []
  type: TYPE_NORMAL
- en: There are many other paradigms available, and they are often rather specialized
    or used by a few obscure languages.
  prefs: []
  type: TYPE_NORMAL
- en: Most programming languages are multi-paradigm in that they use concepts from
    more than one paradigm.
  prefs: []
  type: TYPE_NORMAL
- en: In the next chapter, we will see that our work, as programmers, is not done
    when the code is written.
  prefs: []
  type: TYPE_NORMAL
