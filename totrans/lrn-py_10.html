<html><head></head><body><div class="chapter" title="Chapter&#xA0;10.&#xA0;Web Development Done Right"><div class="titlepage"><div><div><h1 class="title"><a id="ch10"/>Chapter 10. Web Development Done Right</h1></div></div></div><div class="blockquote"><table border="0" width="100%" cellspacing="0" cellpadding="0" class="blockquote" summary="Block quote"><tr><td valign="top"> </td><td valign="top"><p><span class="emphasis"><em>"Don't believe everything you read on the Web."</em></span></p></td><td valign="top"> </td></tr><tr><td valign="top"> </td><td colspan="2" align="right" valign="top" style="text-align: center">--<span class="attribution"><span class="emphasis"><em>Confucius</em></span></span></td></tr></table></div><p>In this chapter, we're going to work on a website together. By working on a small project, my aim is to open a window for you to take a peek on what web development is, along with the main concepts and tools you should know if you want to be successful with it.</p><div class="section" title="What is the Web?"><div class="titlepage"><div><div><h1 class="title"><a id="ch10lvl1sec76"/>What is the Web?</h1></div></div></div><p>The <span class="strong"><strong>World Wide Web</strong></span>, or simply <span class="strong"><strong>Web</strong></span>, is a way of accessing information through the use of <a id="id675" class="indexterm"/>a medium called the <span class="strong"><strong>Internet</strong></span>. The Internet is a <a id="id676" class="indexterm"/>huge network of networks, a networking infrastructure. Its purpose is to connect billions of devices together, all around the globe, so that they can communicate with one another. Information travels through the Internet in a rich variety<a id="id677" class="indexterm"/> of languages called <span class="strong"><strong>protocols</strong></span>, which allow different devices to speak the same tongue in order to share content.</p><p>The Web<a id="id678" class="indexterm"/> is an information-sharing model, built on top of the Internet, which employs the <span class="strong"><strong>Hypertext Transfer Protocol</strong></span> (<span class="strong"><strong>HTTP</strong></span>) as a basis for data communication. The Web, therefore, is just one of the several different ways information can be exchanged over the Internet: e-mail, instant messaging, news groups, and so on, they all rely on different protocols.</p></div></div>
<div class="section" title="How does the Web work?"><div class="titlepage"><div><div><h1 class="title"><a id="ch10lvl1sec77"/>How does the Web work?</h1></div></div></div><p>In a<a id="id679" class="indexterm"/> nutshell, HTTP is an asymmetric <span class="strong"><strong>request-response</strong></span>
<a id="id680" class="indexterm"/>
<span class="strong"><strong> client-server</strong></span> protocol. An HTTP client sends a request message to an HTTP server. The server, in turn, returns a response message. In <a id="id681" class="indexterm"/>other words, HTTP is a <span class="strong"><strong>pull protocol</strong></span> in which the client pulls information from the server (as opposed to a <span class="strong"><strong>push protocol</strong></span> in which the<a id="id682" class="indexterm"/> server pushes information down to the client). Take a look at the following image:</p><div class="mediaobject"><img src="graphics/4715_10_01.jpg" alt="How does the Web work?"/></div><p>HTTP is <a id="id683" class="indexterm"/>based on <span class="strong"><strong>TCP/IP</strong></span> (<span class="strong"><strong>Transmission Control Protocol/Internet Protocol</strong></span>), which provides the tools for a reliable communication exchange.</p><p>An <a id="id684" class="indexterm"/>important feature of the HTTP protocol is that it's <span class="emphasis"><em>stateless</em></span>. This means that the current request has no knowledge about what happened in previous requests. This is a limitation, but you can browse a website with the illusion of being logged in. Under the covers though, what happens is that, on login, a token of user information is saved (most often on the client side, in special <a id="id685" class="indexterm"/>files called <span class="strong"><strong>cookies</strong></span>) so that each request the user makes carries the means for the server to recognize the user and provide a custom interface by showing their name, keeping their basket populated, and so on.</p><p>Even though it's very interesting, we're not going to delve into the rich details of HTTP and how it works. However, we're going to write a small website, which means we'll have to write the code to handle HTTP requests and return HTTP responses. I won't keep prepending HTTP to the terms <span class="emphasis"><em>request</em></span> and <span class="emphasis"><em>response</em></span> from now on, as I trust there won't be any confusion.</p></div>
<div class="section" title="The Django web framework"><div class="titlepage"><div><div><h1 class="title"><a id="ch10lvl1sec78"/>The Django web framework</h1></div></div></div><p>For our<a id="id686" class="indexterm"/> project, we're going to use one of the most popular web frameworks you can find in the Python ecosystem: Django.</p><p>A <span class="strong"><strong>web framework</strong></span> is<a id="id687" class="indexterm"/> a set of tools (libraries, functions, classes, and so on) that we can use to code a website. We need to decide what kind of requests we want to allow to be issued against our web server and how we respond to them. A web framework is the perfect tool to do that because it takes care of many things for us so that we can concentrate only on the important bits without having to reinvent the wheel.</p><div class="note" title="Note" style=""><div class="inner"><h3 class="title"><a id="note58"/>Note</h3><p>There are different types of frameworks. Not all of them are designed for writing code<a id="id688" class="indexterm"/> for the web. In general, a <span class="strong"><strong>framework</strong></span> is a tool that provides functionalities to facilitate the development of software applications, products and solutions.</p></div></div><div class="section" title="Django design philosophy"><div class="titlepage"><div><div><h2 class="title"><a id="ch10lvl2sec115"/>Django design philosophy</h2></div></div></div><p>Django is designed according to the following principles:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc"><span class="strong"><strong>DRY</strong></span>: As in, <span class="strong"><strong>Don't Repeat Yourself</strong></span>. Don't repeat code, and code in a way that <a id="id689" class="indexterm"/>makes the framework deduce as much as possible from as little as possible.</li><li class="listitem" style="list-style-type: disc"><span class="strong"><strong>Loose coupling</strong></span>: The various layers of the framework shouldn't know about each<a id="id690" class="indexterm"/> other (unless absolutely necessary for whatever reason). Loose coupling works best when paralleled with high cohesion. To quote Robert Martin: putting together things which change for the same reason, and spreading apart those which change for different reasons.</li><li class="listitem" style="list-style-type: disc"><span class="strong"><strong>Less code</strong></span>: Applications should use the least possible amount of code, and be written in<a id="id691" class="indexterm"/> a way that favors reuse as much as possible.</li><li class="listitem" style="list-style-type: disc"><span class="strong"><strong>Consistency</strong></span>: When using the Django framework, regardless of which layer you're<a id="id692" class="indexterm"/> coding against, your experience will be very consistent with the design patterns and paradigms that were chosen to lay out the project.</li></ul></div><p>The<a id="id693" class="indexterm"/> framework itself is designed around the <span class="strong"><strong>model-template-view</strong></span> (<span class="strong"><strong>MTV</strong></span>) pattern, which is a variant <a id="id694" class="indexterm"/>of <span class="strong"><strong>model-view-controller</strong></span> (<span class="strong"><strong>MVC</strong></span>), which is widely employed by other frameworks. The purpose of such patterns is to separate concerns and promote code reuse and quality.</p><div class="section" title="The model layer"><div class="titlepage"><div><div><h3 class="title"><a id="ch10lvl3sec31"/>The model layer</h3></div></div></div><p>Of the<a id="id695" class="indexterm"/> three layers, this is the one that defines the structure of the data that is handled by the application, and deals with data sources. A <span class="strong"><strong>model</strong></span> is<a id="id696" class="indexterm"/> a class that represents a data structure. Through some Django magic, models are mapped to database tables so that you can store your data in a relational database.</p><div class="note" title="Note" style=""><div class="inner"><h3 class="title"><a id="note59"/>Note</h3><p>A <span class="strong"><strong>relational database</strong></span> stores data in tables in which each column is a property of the <a id="id697" class="indexterm"/>data and each row represents a single item or entry in the collection represented by that table. Through the <span class="strong"><strong>primary key</strong></span> of <a id="id698" class="indexterm"/>each table, which is that part of the data that allows to uniquely identify each item, it is possible to establish relationships between items belonging to different tables, that is, to put them into <span class="emphasis"><em>relation</em></span>.</p></div></div><p>The beauty of this system is that you don't have to write database-specific code in order to handle your data. You will just have to configure your models correctly and simply use them. The<a id="id699" class="indexterm"/> work on the database is done for you by the Django <span class="strong"><strong>object-relational mapping</strong></span> (<span class="strong"><strong>ORM</strong></span>), which takes care of translating operations<a id="id700" class="indexterm"/> done on Python objects into a language that a relational database can understand: <span class="strong"><strong>SQL</strong></span> (<span class="strong"><strong>Structured Query Language</strong></span>).</p><p>One benefit of this approach is that you will be able to change databases without rewriting your code since all the database specific code is produced by Django on the fly, according to which database it's connected to. Relational databases speak SQL, but each of them has its own unique flavor of it; therefore, not having to hardcode any SQL in our application is a tremendous advantage.</p><p>Django allows you to modify your models at any time. When you do, you can run a command that creates a migration, which is the set of instructions needed to port the database in a state that represents the current definition of your models.</p><p>To summarize, this layer deals with defining the data structures you need to handle in your website and gives you the means to save and load them from and to the database by simply accessing the models, which are Python objects.</p></div><div class="section" title="The view layer"><div class="titlepage"><div><div><h3 class="title"><a id="ch10lvl3sec32"/>The view layer</h3></div></div></div><p>The function <a id="id701" class="indexterm"/>of a view is handling a request, performing whatever action needs to be carried out, and eventually returning a response. For example, if you open your browser and request a page corresponding to a category of products in an e-commerce shop, the view will likely talk to the database, asking for all the categories that are children of the selected category (for example, to display them in a navigation sidebar) and for all the products that belong to the selected category, in order to display them on the page.</p><p>Therefore, the view is the mechanism through which we can fulfill a request. Its result, the response object, can assume several different forms: a JSON payload, text, an HTML page, and so on. When you code a website, your responses usually consist of HTML or JSON.</p><div class="note" title="Note" style=""><div class="inner"><h3 class="title"><a id="note60"/>Note</h3><p>The <span class="strong"><strong>Hypertext Markup Language</strong></span>, or <span class="strong"><strong>HTML</strong></span>, is the standard markup language<a id="id702" class="indexterm"/> used to create web pages. Web browsers run engines that are capable of interpreting HTML code and render it into what we see when we open a page of a website.</p></div></div></div><div class="section" title="The template layer"><div class="titlepage"><div><div><h3 class="title"><a id="ch10lvl3sec33"/>The template layer</h3></div></div></div><p>This is the layer that provides the bridge between backend and frontend development. When a<a id="id703" class="indexterm"/> view has to return HTML, it usually <a id="id704" class="indexterm"/>does it by preparing a <span class="strong"><strong>context object</strong></span> (a dict) with some data, and then it feeds this context to a template, which is rendered (that is to say, transformed into HTML) and returned to the caller in the form of a response (more precisely, the body of the response). This mechanism allows for maximum code reuse. If you go back to the category example, it's easy to see that, if you browse a website that sells products, it doesn't really matter which category you click on or what type of search you perform, the layout of the products page doesn't change. What does change is the data with which that page is populated.</p><p>Therefore, the layout of the page is defined by a template, which is written in a mixture of HTML and Django template language. The view that serves that page collects all the products to be displayed in the context dict, and feeds it to the template which will be rendered into an HTML page by the Django template engine.</p></div></div><div class="section" title="The Django URL dispatcher"><div class="titlepage"><div><div><h2 class="title"><a id="ch10lvl2sec116"/>The Django URL dispatcher</h2></div></div></div><p>The way<a id="id705" class="indexterm"/> Django<a id="id706" class="indexterm"/> associates a <span class="strong"><strong>Uniform Resource Locator</strong></span> (<span class="strong"><strong>URL</strong></span>) with a view is through matching the requested URL with the patterns that are registered in a special file. A URL represents a page in a website so, for example, <code class="literal">http://mysite.com/categories?id=123</code> would probably point to the page for the category with ID <code class="literal">123</code> on my website, while <code class="literal">https://mysite.com/login</code> would probably be the user login page.</p><div class="note" title="Note" style=""><div class="inner"><h3 class="title"><a id="tip20"/>Tip</h3><p>The difference between HTTP and HTTPS is that the latter adds encryption to the protocol so that the data that you exchange with the website is secured. When you put your credit card details on a website, or log in anywhere, or do anything around sensitive data, you want to make sure that you're using HTTPS.</p></div></div><div class="section" title="Regular expressions"><div class="titlepage"><div><div><h3 class="title"><a id="ch10lvl3sec34"/>Regular expressions</h3></div></div></div><p>The way Django matches URLs to patterns is through a regular expression. A <span class="strong"><strong>regular expression</strong></span> is <a id="id707" class="indexterm"/>a sequence of characters that defines a search pattern with which we can carry out operations such as pattern <a id="id708" class="indexterm"/>and string matching, find/replace, and so on.</p><p>Regular expressions have a special syntax to indicate things like digits, letters, spaces, and so on, as well as how many times we expect a character to appear, and much more. A complete explanation of this topic is beyond of the scope of the book. However, it is a very important topic, so the project we're going to work on together will evolve around it, in the hope that you will be stimulated to find the time to explore it a bit more on your own.</p><p>To give you a quick example, imagine that you wanted to specify a pattern to match a date such as <code class="literal">"26-12-1947"</code>. This string consists of two digits, one dash, two digits, one dash, and finally four digits. Therefore, we could write it like this: <code class="literal">r'[0-9]{2}-[0-9]{2}-[0-9]{4}'</code>. We created a class by using square brackets, and we defined a range of digits inside, from 0 to 9, hence all the possible digits. Then, between curly braces, we say that we expect two of them. Then a dash, then we repeat this pattern once as it is, and once more, by changing how many digits we expect, and without the final dash. Having a class like <code class="literal">[0-9]</code> is such a common pattern that a special notation has been created as a shortcut: <code class="literal">'\d'</code>. Therefore, we can rewrite the pattern like this: <code class="literal">r'\d{2}-\d{2}-\d{4}'</code> and it will work exactly the same. That <code class="literal">r</code> in front of the string stands for <span class="emphasis"><em>raw</em></span>, and its purpose is to alter the way every backslash <code class="literal">'\'</code> is interpreted by the regular expression engine.</p></div></div></div>
<div class="section" title="A regex website"><div class="titlepage"><div><div><h1 class="title"><a id="ch10lvl1sec79"/>A regex website</h1></div></div></div><p>So, here <a id="id709" class="indexterm"/>we are. We'll code a website that stores regular expressions so that we'll be able to play with them a little bit.</p><div class="note" title="Note" style=""><div class="inner"><h3 class="title"><a id="note61"/>Note</h3><p>Before we proceed creating the project, I'd like to spend a word about CSS. <span class="strong"><strong>CSS</strong></span> (<span class="strong"><strong>Cascading Style Sheets</strong></span>) are files in which we specify how the various elements <a id="id710" class="indexterm"/>on an HTML page look. You can set all sorts of properties such as shape, size, color, margins, borders, fonts, and so on. In this project, I have tried my best to achieve a decent result on the pages, but I'm neither a frontend developer nor a designer, so please don't pay too much attention to how things look. Try and focus on how they work.</p></div></div><div class="section" title="Setting up Django"><div class="titlepage"><div><div><h2 class="title"><a id="ch10lvl2sec117"/>Setting up Django</h2></div></div></div><p>On the <a id="id711" class="indexterm"/>Django website (<a class="ulink" href="https://www.djangoproject.com/">https://www.djangoproject.com/</a>), you can follow the tutorial, which gives you a pretty <a id="id712" class="indexterm"/>good <a id="id713" class="indexterm"/>idea of Django's capabilities. If you want, you can follow that tutorial first and then come back to this example. So, first things first; let's install Django in your virtual environment:</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong>$ pip install django</strong></span>
</pre></div><p>When this command is done, you can test it within a console (try doing it with bpython, it gives you a shell similar to IPython but with nice introspection capabilities):</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong>&gt;&gt;&gt; import django</strong></span>
<span class="strong"><strong>&gt;&gt;&gt; django.VERSION</strong></span>
<span class="strong"><strong>(1, 8, 4, 'final', 0)</strong></span>
</pre></div><p>Now that Django is installed, we're good to go. We'll have to do some scaffolding, so I'll quickly guide you through that.</p><div class="section" title="Starting the project"><div class="titlepage"><div><div><h3 class="title"><a id="ch10lvl3sec35"/>Starting the project</h3></div></div></div><p>Choose <a id="id714" class="indexterm"/>a folder in the book's environment and change into that. I'll use <code class="literal">ch10</code>. From there, we start a Django project with the following command:</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong>$ django-admin startproject regex</strong></span>
</pre></div><p>This will prepare the skeleton for a Django project called <code class="literal">regex</code>. Change into the <code class="literal">regex</code> folder and run the following:</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong>$ python manage.py runserver</strong></span>
</pre></div><p>You should be able to go to <code class="literal">http://127.0.0.1:8000/</code> with your browser and see the <span class="emphasis"><em>It worked!</em></span> default Django page. This means that the project is correctly set up. When you've seen the page, kill the server with <span class="emphasis"><em>Ctrl</em></span> + <span class="emphasis"><em>C</em></span> (or whatever it says in the console). I'll paste the final structure for the project now so that you can use it as a reference:</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong>$ tree -A regex  # from the ch10 folder</strong></span>
<span class="strong"><strong>regex</strong></span>
<span class="strong"><strong>├── db.sqlite3</strong></span>
<span class="strong"><strong>├── entries</strong></span>
<span class="strong"><strong>│   ├── admin.py</strong></span>
<span class="strong"><strong>│   ├── forms.py</strong></span>
<span class="strong"><strong>│   ├── __init__.py</strong></span>
<span class="strong"><strong>│   ├── migrations</strong></span>
<span class="strong"><strong>│   │   ├── 0001_initial.py</strong></span>
<span class="strong"><strong>│   │   └── __init__.py</strong></span>
<span class="strong"><strong>│   ├── models.py</strong></span>
<span class="strong"><strong>│   ├── static</strong></span>
<span class="strong"><strong>│   │   └── entries</strong></span>
<span class="strong"><strong>│   │       └── css</strong></span>
<span class="strong"><strong>│   │           └── main.css</strong></span>
<span class="strong"><strong>│   ├── templates</strong></span>
<span class="strong"><strong>│   │   └── entries</strong></span>
<span class="strong"><strong>│   │       ├── base.html</strong></span>
<span class="strong"><strong>│   │       ├── footer.html</strong></span>
<span class="strong"><strong>│   │       ├── home.html</strong></span>
<span class="strong"><strong>│   │       ├── insert.html</strong></span>
<span class="strong"><strong>│   │       └── list.html</strong></span>
<span class="strong"><strong>│   └── views.py</strong></span>
<span class="strong"><strong>├── manage.py</strong></span>
<span class="strong"><strong>└── regex</strong></span>
<span class="strong"><strong>    ├── __init__.py</strong></span>
<span class="strong"><strong>    ├── settings.py</strong></span>
<span class="strong"><strong>    ├── urls.py</strong></span>
<span class="strong"><strong>    └── wsgi.py</strong></span>
</pre></div><p>Don't worry<a id="id715" class="indexterm"/> if you're missing files, we'll get there. A Django project is typically a collection of several different applications. Each application is meant to<a id="id716" class="indexterm"/> provide a functionality in a self-contained, reusable fashion. We'll create just one, called <span class="strong"><strong>entries</strong></span>:</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong>$ python manage.py startapp entries</strong></span>
</pre></div><p>Within the <code class="literal">entries</code> folder that has been created, you can get rid of the <code class="literal">tests.py</code> module.</p><p>Now, let's fix the <code class="literal">regex/settings.py</code> file in the <code class="literal">regex</code> folder. We need to add our application to the <code class="literal">INSTALLED_APPS</code> tuple so that we can use it (add it at the bottom of the tuple):</p><div class="informalexample"><pre class="programlisting">INSTALLED_APPS = (
    ... django apps ...
    'entries',
)</pre></div><p>Then, you may want to fix the language and time zone according to your personal preference. I live in London, so I set them like this:</p><div class="informalexample"><pre class="programlisting">LANGUAGE_CODE = 'en-gb'
TIME_ZONE = 'Europe/London'</pre></div><p>There is nothing else to do in this file, so you can save and close it.</p><p>Now it's time to apply the <span class="strong"><strong>migrations</strong></span> to the database. Django needs database support to handle users, sessions, and things like that, so we need to create a database and populate it with the necessary<a id="id717" class="indexterm"/> data. Luckily, this is very easily done with<a id="id718" class="indexterm"/> the following command:</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong>$ python manage.py migrate</strong></span>
</pre></div><div class="note" title="Note" style=""><div class="inner"><h3 class="title"><a id="note62"/>Note</h3><p>For this project, we use a SQLite database, which is basically just a file. On a real project, you would probably use a different database engine like MySQL or PostgreSQL.</p></div></div></div><div class="section" title="Creating users"><div class="titlepage"><div><div><h3 class="title"><a id="ch10lvl3sec36"/>Creating users</h3></div></div></div><p>Now that <a id="id719" class="indexterm"/>we have a database, we can create a superuser using the console.</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong>$ python manage.py createsuperuser</strong></span>
</pre></div><p>After entering username and other details, we have a user with admin privileges. This is enough to access the Django admin section, so try and start the server:</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong>$ python manage.py runserver</strong></span>
</pre></div><p>This will start the Django development server, which is a very useful built-in web server that you can use while working with Django. Now that the server is running, we can access the admin page at <code class="literal">http://localhost:8000/admin/</code>. I will show you a screenshot of this section later. If you log in with the credentials of the user you just created and head to the <span class="strong"><strong>Authentication and Authorization</strong></span> section, you'll find <span class="strong"><strong>Users</strong></span>. Open that and you will be able to see the list of users. You can edit the details of any user you want as an admin. In our case, make sure you create a different one so that there are at least two users in the system (we'll need them later). I'll call the first user <span class="emphasis"><em>Fabrizio</em></span> (username: <code class="literal">fab</code>) and the second one <span class="emphasis"><em>Adriano</em></span> (username: <code class="literal">adri</code>) in honor of my father.</p><p>By the way, you should see that the Django admin panel comes for free automatically. You define your models, hook them up, and that's it. This is an incredible tool that shows how advanced Django's introspection capabilities are. Moreover, it is completely customizable and extendable. It's truly an excellent piece of work.</p></div></div><div class="section" title="Adding the Entry model"><div class="titlepage"><div><div><h2 class="title"><a id="ch10lvl2sec118"/>Adding the Entry model</h2></div></div></div><p>Now that <a id="id720" class="indexterm"/>the boilerplate is out of the way, and we have a couple of users, we're ready to code. We start by adding the <code class="literal">Entry</code> model to our application so that we can store objects in the database. Here's the code you'll need to add (remember to use the project tree for reference):</p><p>
<code class="literal">entries/models.py</code>
</p><div class="informalexample"><pre class="programlisting">from django.db import models
from django.contrib.auth.models import User
from django.utils import timezone

class Entry(<span class="strong"><strong>models.Model</strong></span>):
    user = models.ForeignKey(User)
    pattern = models.CharField(max_length=255)
    test_string = models.CharField(max_length=255)
    date_added = models.DateTimeField(default=<span class="strong"><strong>timezone.now</strong></span>)

    class <span class="strong"><strong>Meta</strong></span>:
        verbose_name_plural = 'entries'</pre></div><p>This is the model we'll use to store regular expressions in our system. We'll store a pattern, a test string, a reference to the user who created the entry, and the moment of creation. You can see that creating a model is actually quite easy, but nonetheless, let's go through it line by line.</p><p>First we need to import the models module from <code class="literal">django.db</code>. This will give us the base class for our <code class="literal">Entry</code> model. Django models are special classes and much is done for us behind the scenes when we inherit from <code class="literal">models.Model</code>.</p><p>We want a reference to the user who created the entry, so we need to import the <code class="literal">User</code> model from Django's authorization application and we also need to import the timezone model to get access to the <code class="literal">timezone.now()</code> function, which provides us with a timezone-aware version of <code class="literal">datetime.now()</code>. The beauty of this is that it's hooked up with the <code class="literal">TIME_ZONE</code> settings I showed you before.</p><p>As for the <a id="id721" class="indexterm"/>primary key for this class, if we don't set one explicitly, Django will add one for us. A <span class="strong"><strong>primary key</strong></span> is a key that allows us to uniquely identify an <code class="literal">Entry</code> object in the database (in this case, Django will add an auto-incrementing integer ID).</p><p>So, we define our class, and we set up four class attributes. We have a <code class="literal">ForeignKey</code> attribute that is our reference to the <span class="emphasis"><em>User</em></span> model. We also have two <code class="literal">CharField</code> attributes that hold the pattern and test strings for our regular expressions. We also have a <code class="literal">DateTimeField,</code> whose default value is set to <code class="literal">timezone.now</code>. Note that we don't call <code class="literal">timezone.now</code> right there, it's <code class="literal">now</code>, not <code class="literal">now()</code>. So, we're not passing a <code class="literal">DateTime</code> instance (set at the moment in time when that line is parsed) rather, we're passing a <span class="emphasis"><em>callable</em></span>, a function that is called when we save an entry in the database. This is similar to the callback mechanism we used in <a class="link" href="ch08.html" title="Chapter 8. The Edges – GUIs and Scripts">Chapter 8</a>, <span class="emphasis"><em>The Edges – GUIs and Scripts</em></span>, when we were assigning commands to button clicks.</p><p>The last two lines are very interesting. We define a class <code class="literal">Meta</code> within the <code class="literal">Entry</code> class itself. The <code class="literal">Meta</code> class is used by Django to provide all sorts of extra information for a model. Django has a great deal of logic under the hood to adapt its behavior according to the information we put in the <code class="literal">Meta</code> class. In this case, in the admin panel, the pluralized version of <code class="literal">Entry</code> would be <span class="emphasis"><em>Entrys</em></span>, which is wrong, therefore we need to manually set it. We specify the plural all lowercase, as Django takes care of capitalizing it for us when needed.</p><p>Now that we have a new model, we need to update the database to reflect the new state of the code. In order to do this, we need to instruct Django that it needs to create the code to update the <a id="id722" class="indexterm"/>database. This code is called <span class="strong"><strong>migration</strong></span>. Let's create it and execute it:</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong>$ python manage.py makemigrations entries</strong></span>
<span class="strong"><strong>$ python manage.py migrate</strong></span>
</pre></div><p>After these <a id="id723" class="indexterm"/>two instructions, the database will be ready to store <code class="literal">Entry</code> objects.</p><div class="note" title="Note" style=""><div class="inner"><h3 class="title"><a id="note63"/>Note</h3><p>There are two different kinds of migrations: data and schema migration. <span class="strong"><strong>Data migrations</strong></span> port<a id="id724" class="indexterm"/> data from one state to another without altering its structure. For example, a data migration could set all products for a category as out of stock by switching a flag to <code class="literal">False</code> or <code class="literal">0</code>. A <span class="strong"><strong>schema migration</strong></span> is<a id="id725" class="indexterm"/> a set of instructions that alter the structure of the database schema. For example, that could be adding an <code class="literal">age</code> column to a <code class="literal">Person</code> table, or increasing the maximum length of a field to account for very long addresses. When developing with Django, it's quite common to have to perform both kinds of migrations over the course of development. Data evolves continuously, especially if you code in an agile environment.</p></div></div></div><div class="section" title="Customizing the admin panel"><div class="titlepage"><div><div><h2 class="title"><a id="ch10lvl2sec119"/>Customizing the admin panel</h2></div></div></div><p>The next <a id="id726" class="indexterm"/>step is to hook the <code class="literal">Entry</code> model up with the admin panel. You can do it with one line of code, but in this case, I want to add some options to customize a bit the way the admin panel shows the entries, both in the list view of all entry items in the database and in the form view that allows us to create and modify them.</p><p>All we need to do is to add the following code:</p><p>
<code class="literal">entries/admin.py</code>
</p><div class="informalexample"><pre class="programlisting">from django.contrib import admin
from .models import Entry

<span class="strong"><strong>@admin.register(Entry)</strong></span>
class EntryAdmin(<span class="strong"><strong>admin.ModelAdmin</strong></span>):
    fieldsets = [
        ('Regular Expression',
         {'fields': ['pattern', 'test_string']}),
        ('Other Information',
         {'fields': ['user', 'date_added']}),
    ]
    list_display = ('pattern', 'test_string', 'user')
    list_filter = ['user']
    search_fields = ['test_string']</pre></div><p>This is simply beautiful. My guess is that you probably already understand most of it, even if you're new to Django.</p><p>So, we <a id="id727" class="indexterm"/>start by importing the admin module and the <code class="literal">Entry</code> model. Because we want to foster code reuse, we import the <code class="literal">Entry</code> model using a relative import (there's a dot before <code class="literal">models</code>). This will allow us to move or rename the app without too much trouble. Then, we define the <code class="literal">EntryAdmin</code> class, which inherits from <code class="literal">admin.ModelAdmin</code>. The decoration on the class tells Django to display the <code class="literal">Entry</code> model in the admin panel, and what we put in the <code class="literal">EntryAdmin</code> class tells Django how to customize the way it handles this model.</p><p>Firstly, we specify the <code class="literal">fieldsets</code> for the create/edit page. This will divide the page into two sections so that we get a better visualization of the content (<span class="emphasis"><em>pattern</em></span> and <span class="emphasis"><em>test string</em></span>) and the other details (<span class="emphasis"><em>user</em></span> and <span class="emphasis"><em>timestamp</em></span>) separately.</p><p>Then, we customize the way the list page displays the results. We want to see all the fields, but not the date. We also want to be able to filter on the user so that we can have a list of all the entries by just one user, and we want to be able to search on <code class="literal">test_string</code>.</p><p>I will go ahead and add three entries, one for myself and two on behalf of my father. The result is shown in the next two images. After inserting them, the list page looks like this:</p><div class="mediaobject"><img src="graphics/4715_10_02.jpg" alt="Customizing the admin panel"/></div><p>I have<a id="id728" class="indexterm"/> highlighted the three parts of this view that we customized in the <code class="literal">EntryAdmin</code> class. We can filter by user, we can search and we have all the fields displayed. If you click on a pattern, the edit view opens up.</p><p>After our customization, it looks like this:</p><div class="mediaobject"><img src="graphics/4715_10_03.jpg" alt="Customizing the admin panel"/></div><p>Notice<a id="id729" class="indexterm"/> how we have two sections: <span class="strong"><strong>Regular</strong></span> <span class="strong"><strong>Expression</strong></span> and <span class="strong"><strong>Other</strong></span> <span class="strong"><strong>Information</strong></span>, thanks to our custom <code class="literal">EntryAdmin</code> class. Have a go with it, add some entries to a couple of different users, get familiar with the interface. Isn't it nice to have all this for free?</p></div><div class="section" title="Creating the form"><div class="titlepage"><div><div><h2 class="title"><a id="ch10lvl2sec120"/>Creating the form</h2></div></div></div><p>Every<a id="id730" class="indexterm"/> time<a id="id731" class="indexterm"/> you fill in your details on a web page, you're inserting data in form fields. A <span class="strong"><strong>form</strong></span> is a part of the <span class="strong"><strong>HTML Document Object Model</strong></span> (<span class="strong"><strong>DOM</strong></span>) <span class="strong"><strong>tree</strong></span>. In HTML, you create a form by using the <code class="literal">form</code> tag. When <a id="id732" class="indexterm"/>you click on the submit button, your browser normally packs the form data together and puts it in the body of a <code class="literal">POST</code> request. As opposed to <code class="literal">GET</code> requests, which are used to ask the web server for a resource, a <code class="literal">POST</code> request normally sends data to the web server with the aim of creating or updating a resource. For this reason, handling <code class="literal">POST</code> requests usually requires more care than <code class="literal">GET</code> requests.</p><p>When the server receives data from a <code class="literal">POST</code> request, that data needs to be validated. Moreover, the server needs to employ security mechanisms to protect against various types<a id="id733" class="indexterm"/> of attacks. One attack that is very dangerous is the <span class="strong"><strong>cross-site request forgery</strong></span> (<span class="strong"><strong>CSRF</strong></span>) attack, which happens when data is sent from a domain that is not the one the user is authenticated on. Django allows you to handle this issue in a very elegant way.</p><p>So, instead of being lazy and using the Django admin to create the entries, I'm going to show you how to do it using a Django form. By using the tools the framework gives you, you get a very good degree of validation work already done (in fact, we won't need to add any custom validation ourselves).</p><p>There are two kinds of form classes in Django: <code class="literal">Form</code> and <code class="literal">ModelForm</code>. You use the former to create a form whose shape and behavior depends on how you code the class, what fields you add, and so on. On the other hand, the latter is a type of form that, albeit still customizable, infers fields and behavior from a model. Since we need a form for the <code class="literal">Entry</code> model, we'll use that one.</p><p>
<code class="literal">entries/forms.py</code>
</p><div class="informalexample"><pre class="programlisting">from django.forms import ModelForm
from .models import Entry

class EntryForm(<span class="strong"><strong>ModelForm</strong></span>):
    class Meta:
        <span class="strong"><strong>model = Entry</strong></span>
        fields = ['pattern', 'test_string']</pre></div><p>Amazingly enough, this is all we have to do to have a form that we can put on a page. The only notable thing here is that we restrict the fields to only <code class="literal">pattern</code> and <code class="literal">test_string</code>. Only logged-in users will be allowed access to the insert page, and therefore we don't need to ask who the user is: we know that. As for the date, when we save an <code class="literal">Entry,</code> the <code class="literal">date_added</code> field will be set according to its default, therefore <a id="id734" class="indexterm"/>we don't need to specify that as well. We'll see in the view how to feed the user information to the form before saving. So, all the background work is done, all we need is the views and the templates. Let's start with the views.</p></div><div class="section" title="Writing the views"><div class="titlepage"><div><div><h2 class="title"><a id="ch10lvl2sec121"/>Writing the views</h2></div></div></div><p>We need to <a id="id735" class="indexterm"/>write three views. We need one for the home page, one<a id="id736" class="indexterm"/> to display the list of all entries for a user, and one to create a new entry. We also need views to log in and log out. But thanks to Django, we don't need to write them. I'll paste all the code, and then we'll go through it together, step by step.</p><p>
<code class="literal">entries/views.py</code>
</p><div class="informalexample"><pre class="programlisting">import re
from django.contrib.auth.decorators import login_required
from django.contrib.messages.views import SuccessMessageMixin
from django.core.urlresolvers import reverse_lazy
from django.utils.decorators import method_decorator
from django.views.generic import FormView, TemplateView
from .forms import EntryForm
from .models import Entry

class HomeView(<span class="strong"><strong>TemplateView</strong></span>):
    <span class="strong"><strong>template_name</strong></span> = 'entries/home.html'

    @method_decorator(
        login_required(login_url=reverse_lazy('login')))
    def get(self, request, *args, **kwargs):
        context = self.get_context_data(**kwargs)
        return self.render_to_response(context)

class EntryListView(<span class="strong"><strong>TemplateView</strong></span>):
    <span class="strong"><strong>template_name</strong></span> = 'entries/list.html'

    @method_decorator(
        login_required(login_url=reverse_lazy('login')))
    def get(self, request, *args, **kwargs):
        context = <span class="strong"><strong>self.get_context_data</strong></span>(**kwargs)
        entries = <span class="strong"><strong>Entry.objects.filter(</strong></span>
<span class="strong"><strong>            user=request.user).order_by('-date_added')</strong></span>
        matches = (self._parse_entry(entry) for entry in entries)
        context['entries'] = list(zip(entries, matches))
        return <span class="strong"><strong>self.render_to_response</strong></span>(context)

    def _parse_entry(self, entry):
        match = <span class="strong"><strong>re.search(entry.pattern, entry.test_string)</strong></span>
        if match is not None:
            return (
                match.group(),
                match.groups() or None,
                match.groupdict() or None
            )
        return None

class EntryFormView(<span class="strong"><strong>SuccessMessageMixin</strong></span>, <span class="strong"><strong>FormView</strong></span>):
    template_name = 'entries/insert.html'
    <span class="strong"><strong>form_class</strong></span> = EntryForm
    success_url = reverse_lazy('insert')
    success_message = "Entry was created successfully"

    @method_decorator(
        login_required(login_url=reverse_lazy('login')))
    def get(self, request, *args, **kwargs):
        return super(EntryFormView, self).get(
            request, *args, **kwargs)

    @method_decorator(
        login_required(login_url=reverse_lazy('login')))
    def post(self, request, *args, **kwargs):
        return super(EntryFormView, self).post(
            request, *args, **kwargs)

    def <span class="strong"><strong>form_valid</strong></span>(self, form):
        self._save_with_user(form)
        return super(EntryFormView, self).form_valid(form)

    def _save_with_user(self, form):
        self.object = form.save(<span class="strong"><strong>commit=False</strong></span>)
        self.object.user = <span class="strong"><strong>self.request.user</strong></span>
        <span class="strong"><strong>self.object.save()</strong></span>
</pre></div><p>Let's start <a id="id737" class="indexterm"/>with the imports. We need the <code class="literal">re</code> module to handle <a id="id738" class="indexterm"/>regular expressions, then we need a few classes and functions from Django, and finally, we need the <code class="literal">Entry</code> model and the <code class="literal">EntryForm</code> form.</p><div class="section" title="The home view"><div class="titlepage"><div><div><h3 class="title"><a id="ch10lvl3sec37"/>The home view</h3></div></div></div><p>The first <a id="id739" class="indexterm"/>view is <code class="literal">HomeView</code>. It inherits from <code class="literal">TemplateView</code>, which means that the response will be created by rendering a template with the context we'll create in the view. All we have to do is specify the <code class="literal">template_name</code> class attribute to point to the correct template. Django promotes code reuse to a point that if we didn't need to make this view accessible only to logged-in users, the first two lines would have been all we needed.</p><p>However, we want this view to be accessible only to logged-in users; therefore, we need to decorate it with <code class="literal">login_required</code>. Now, historically views in Django used to be functions; therefore, this decorator was designed to accept a <span class="emphasis"><em>function</em></span> not a <span class="emphasis"><em>method</em></span> like we have in this class. We're using Django class-based views in this project so, in order to make things work, we need to transform <code class="literal">login_required</code> so that it accepts a method (the difference being in the first argument: <code class="literal">self</code>). We do this by passing <code class="literal">login_required</code> to <code class="literal">method_decorator</code>.</p><p>We also need to feed the <code class="literal">login_required</code> decorator with <code class="literal">login_url</code> information, and here comes another wonderful feature of Django. As you'll see after we're done with the views, in Django, you tie a view to a URL through a pattern, consisting of a regular expression and other information. You can give a name to each entry in the <code class="literal">urls.py</code> file so that when you want to refer to a URL, you don't have to hardcode its value into your code. All you have to do is get Django to reverse-engineer that URL from the name we gave to the entry in <code class="literal">urls.py</code> defining the URL and the view that is tied to it. This mechanism will become clearer later. For now, just think of <code class="literal">reverse('...')</code> as a way of getting a URL from an identifier. In this way, you only write the actual URL once, in the <code class="literal">urls.py</code> file, which is brilliant. In the <code class="literal">views.py</code> code, we need to use <code class="literal">reverse_lazy</code>, which works exactly like <code class="literal">reverse</code> with one major difference: it only finds the URL when we actually need it (in a lazy fashion). This is needed when the <code class="literal">urls.py</code> file hasn't been loaded yet when the <code class="literal">reverse</code> function is used.</p><p>The <code class="literal">get</code> method, which we just decorated, simply calls the <code class="literal">get</code> method of the parent class. Of course, the <code class="literal">get</code> method is the method that Django calls when a <code class="literal">GET</code> request is performed against the URL tied to this view.</p></div><div class="section" title="The entry list view"><div class="titlepage"><div><div><h3 class="title"><a id="ch10lvl3sec38"/>The entry list view</h3></div></div></div><p>This view<a id="id740" class="indexterm"/> is much more interesting than the previous one. First of all, we decorate the <code class="literal">get</code> method as we did before. Inside of it, we need to prepare a list of <code class="literal">Entry</code> objects and feed it to the template, which shows it to the user. In order to do so, we start by getting the <code class="literal">context</code> dict like we're supposed to do, by calling the <code class="literal">get_context_data</code> method of the <code class="literal">TemplateView</code> class. Then, we use the ORM to get a list of the entries. We do this by accessing the objects manager, and calling a filter on it. We filter the entries according to which user is logged in, and we ask for them to be sorted in a descending order (that <code class="literal">'-'</code> in front of the name specifies the descending order). The <code class="literal">objects</code> manager is the default <span class="strong"><strong>manager</strong></span> every Django model is augmented with on creation, it <a id="id741" class="indexterm"/>allows us to interact with the database through its methods.</p><p>We parse each entry to get a list of matches (actually, I coded it so that <code class="literal">matches</code> is a generator expression). Finally, we add to the context an <code class="literal">'entries'</code> key whose value is the coupling of <code class="literal">entries</code> and <code class="literal">matches</code>, so that each <code class="literal">Entry</code> instance is paired with the resulting match of its pattern and test string.</p><p>On the last line, we simply ask Django to render the template using the context we created.</p><p>Take a look at the <code class="literal">_parse_entry</code> method. All it does is perform a search on the <code class="literal">entry.test_string</code> with the <code class="literal">entry.pattern</code>. If the resulting <code class="literal">match</code> object is not <code class="literal">None</code>, it means that we found something. If so, we return a tuple with three elements: the overall group, the subgroups, and the group dictionary. If you're not familiar with these terms, don't worry, you'll see a screenshot soon with an example. We return <code class="literal">None</code> if there is no match.</p></div><div class="section" title="The form view"><div class="titlepage"><div><div><h3 class="title"><a id="ch10lvl3sec39"/>The form view</h3></div></div></div><p>Finally, let's<a id="id742" class="indexterm"/> examine <code class="literal">EntryFormView</code>. This is particularly interesting for a few reasons. Firstly, it shows us a nice example of Python's multiple inheritance. We want to display a message on the page, after having inserted an <code class="literal">Entry</code>, so we inherit from <code class="literal">SuccessMessageMixin</code>. But we want to handle a form as well, so we also inherit from <code class="literal">FormView</code>.</p><div class="note" title="Note" style=""><div class="inner"><h3 class="title"><a id="note64"/>Note</h3><p>Note that, when you deal with mixins and inheritance, you may have to consider the order in which you specify the base classes in the class declaration.</p></div></div><p>In order to set up this view correctly, we need to specify a few attributes at the beginning: the template to be rendered, the form class to be used to handle the data from the <code class="literal">POST</code> request, the URL we need to redirect the user to in the case of success, and the success message.</p><p>Another interesting feature is that this view needs to handle both <code class="literal">GET</code> and <code class="literal">POST</code> requests. When we land on the form page for the first time, the form is empty, and that is the <code class="literal">GET</code> request. On the other hand, when we fill in the form and want to submit the <code class="literal">Entry</code>, we make a <code class="literal">POST</code> request. You can see that the body of <code class="literal">get</code> is conceptually identical to <code class="literal">HomeView</code>. Django does everything for us.</p><p>The <code class="literal">post</code> method is just like <code class="literal">get</code>. The only reason we need to code these two methods is so that we can decorate them to require login.</p><p>Within the Django form handling process (in the <code class="literal">FormView</code> class), there are a few methods that we can override in order to customize the overall behavior. We need to do it with the <code class="literal">form_valid</code> method. This method will be called when the form validation is successful. Its purpose is to save the form so that an <code class="literal">Entry</code> object is created out of it, and then stored in the database.</p><p>The only problem is that our form is missing the user. We need to intercept that moment in the chain of calls and put the user information in ourselves. This is done by calling the <code class="literal">_save_with_user</code> method, which is very simple.</p><p>Firstly, we ask Django to save the form with the <code class="literal">commit</code> argument set to <code class="literal">False</code>. This creates an <code class="literal">Entry</code> instance without attempting to save it to the database. Saving it immediately would fail because the <code class="literal">user</code> information is not there.</p><p>The next line updates the <code class="literal">Entry</code> instance (<code class="literal">self.object</code>), adding the <code class="literal">user</code> information and, on the last line, we can safely save it. The reason I called it <code class="literal">object</code> and set it on the instance like that was to follow what the original <code class="literal">FormView</code> class does.</p><p>We're fiddling with the Django mechanism here, so if we want the whole thing to work, we need to pay attention to when and how we modify its behavior, and make sure we don't alter it incorrectly. For this reason, it's very important to remember to call the <code class="literal">form_valid</code> method of the base class (we use <code class="literal">super</code> for that) at the end of our own customized version, to make sure that every other action that method usually performs is carried out correctly.</p><p>Note how<a id="id743" class="indexterm"/> the request is tied to each view instance (<code class="literal">self.request</code>) so that we don't need to pass it through when we refactor our logic into methods. Note also that the user information has been added to the request automatically by Django. Finally, note that the reason why all the process is split into very small methods like these is so that we can only override those that we need to customize. All this removes the need to write a lot of code.</p><p>Now that we have the views covered, let's see how we couple them to the URLs.</p></div></div><div class="section" title="Tying up URLs and views"><div class="titlepage"><div><div><h2 class="title"><a id="ch10lvl2sec122"/>Tying up URLs and views</h2></div></div></div><p>In the <code class="literal">urls.py</code> module, we tie each view to a URL. There are many ways of doing this. I chose the<a id="id744" class="indexterm"/> simplest one, which works perfectly for the extent of this exercise, but you may want to explore this argument more deeply if you intend to work with Django. This is the core around which the whole website logic will revolve; therefore, you should try to get it down correctly. Note that the <code class="literal">urls.py</code> module belongs to the project folder.</p><p>
<code class="literal">regex/urls.py</code>
</p><div class="informalexample"><pre class="programlisting">from django.conf.urls import include, url
from django.contrib import admin
from django.contrib.auth import views as auth_views
from django.core.urlresolvers import reverse_lazy
from entries.views import HomeView, EntryListView, EntryFormView

urlpatterns = [
    url(r'^admin/', include(admin.site.urls)),
    <span class="strong"><strong>url(r'^entries/$', EntryListView.as_view(), name='entries'),</strong></span>
<span class="strong"><strong>    url(r'^entries/insert$',</strong></span>
<span class="strong"><strong>        EntryFormView.as_view(),</strong></span>
<span class="strong"><strong>        name='insert'),</strong></span>

    url(r'^login/$',
        auth_views.login,
        kwargs={'template_name': 'admin/login.html'},
        name='login'),
    url(r'^logout/$',
        auth_views.logout,
        kwargs={'next_page': reverse_lazy('home')},
        name='logout'),

    <span class="strong"><strong>url(r'^$', HomeView.as_view(), name='home'),</strong></span>
]</pre></div><p>As you can see, the magic comes from the <code class="literal">url</code> function. Firstly, we pass it a regular expression; then the view; and finally, a name, which is what we will use in the <code class="literal">reverse</code> and <code class="literal">reverse_lazy</code> functions to recover the URL.</p><p>Note that, when using class-based views, we have to transform them into functions, which is what <code class="literal">url</code> is expecting. To do that, we call the <code class="literal">as_view()</code> method on them.</p><p>Note also that the first <code class="literal">url</code> entry, for the admin, is special. Instead of specifying a URL and a view, it specifies a URL prefix and another <code class="literal">urls.py</code> module (from the <code class="literal">admin.site</code> package). In this way, Django will complete all the URLs for the admin section by <a id="id745" class="indexterm"/>prepending <code class="literal">'admin/'</code> to all the URLs specified in <code class="literal">admin.site.urls</code>. We could have done the same for our entries app (and we should have), but I feel it would have been a bit too much for this simple project.</p><p>In the regular expression language, the <code class="literal">'^'</code> and <code class="literal">'$'</code> symbols represent the <span class="emphasis"><em>start</em></span> and <span class="emphasis"><em>end</em></span> of a string. Note that if you use the inclusion technique, as for the admin, the <code class="literal">'$'</code> is missing. Of course, this is because <code class="literal">'admin/'</code> is just a prefix, which needs to be completed by all the definitions in the included <code class="literal">urls</code> module.</p><p>Something else worth noticing is that we can also include the stringified version of a path to a view, which we do for the <code class="literal">login</code> and <code class="literal">logout</code> views. We also add information about which templates to use with the <code class="literal">kwargs</code> argument. These views come straight from the <code class="literal">django.contrib.auth</code> package, by the way, so that we don't need to write a single line of code to <a id="id746" class="indexterm"/>handle authentication. This is brilliant and saves us a lot of time.</p><p>Each <code class="literal">url</code> declaration must be done within the <code class="literal">urlpatterns</code> list and on this matter, it's important to consider that, when Django is trying to find a view for a URL that has been requested, the patterns are exercised in order, from top to bottom. The first one that matches is the one that will provide the view for it so, in general, you have to put specific patterns before generic ones, otherwise they will never get a chance to be caught. For example, <code class="literal">'^shop/categories/$'</code> needs to come before <code class="literal">'^shop'</code> (note the absence of the <code class="literal">'$'</code> in the latter), otherwise it would never be called. Our example for the entries works fine because I thoroughly specified URLs using the <code class="literal">'$'</code> at the end.</p><p>So, models, forms, admin, views and URLs are all done. All that is left to do is take care of the templates. I'll have to be very brief on this part because HTML can be very verbose.</p></div><div class="section" title="Writing the templates"><div class="titlepage"><div><div><h2 class="title"><a id="ch10lvl2sec123"/>Writing the templates</h2></div></div></div><p>All templates<a id="id747" class="indexterm"/> inherit from a base one, which provides the HTML structure for all others, in a very OOP type of fashion. It also specifies a few blocks, which are areas that can be overridden by children so that they can provide custom content for those areas. Let's start with the base template:</p><p>
<code class="literal">entries/templates/entries/base.html</code>
</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong>{% load static from staticfiles %}</strong></span>
&lt;!DOCTYPE html&gt;
&lt;html lang="en"&gt;
  &lt;head&gt;
    {% block meta %}
      &lt;meta charset="utf-8"&gt;
      &lt;meta name="viewport"
       content="width=device-width, initial-scale=1.0"&gt;
    {% endblock meta %}

    {% block styles %}
      &lt;link href="<span class="strong"><strong>{% static "entries/css/main.css" %}</strong></span>"
       rel="stylesheet"&gt;
    {% endblock styles %}

    &lt;title&gt; {% block title %}Title{% endblock title %} &lt;/title&gt;
  &lt;/head&gt;

  &lt;body&gt;
    &lt;div id="page-content"&gt;
      <span class="strong"><strong>{% block page-content %}</strong></span>
      <span class="strong"><strong>{% endblock page-content %}</strong></span>
    &lt;/div&gt;
    &lt;div id="footer"&gt;
      <span class="strong"><strong>{% block footer %}</strong></span>
<span class="strong"><strong>      {% endblock footer %}</strong></span>
    &lt;/div&gt;
  &lt;/body&gt;
&lt;/html&gt;</pre></div><p>There is <a id="id748" class="indexterm"/>a good reason to repeat the <code class="literal">entries</code> folder from the <code class="literal">templates</code> one. When you deploy a Django website, you collect all the template files under one folder. If you don't specify the paths like I did, you may get a <code class="literal">base.html</code> template in the entries app, and a <code class="literal">base.html</code> template in another app. The last one to be collected will override any other file with the same name. For this reason, by putting them in a <code class="literal">templates/entries</code> folder and using this technique for each Django app you write, you avoid the risk of name collisions (the same goes for any other static file).</p><p>There is not much to say about this template, really, apart from the fact that it loads the <code class="literal">static</code> tag so that we can get easy access to the <code class="literal">static</code> path without hardcoding it in the template by using <code class="literal">{% static ... %}</code>. The code in the special <code class="literal">{% ... %}</code> sections is code that defines logic. The code in the special <code class="literal">{{ ... }}</code> represents variables that will be rendered on the page.</p><p>We define three blocks: <code class="literal">title</code>, <code class="literal">page-content,</code> and <code class="literal">footer</code>, whose purpose is to hold the title, the content of the page, and the footer. Blocks can be optionally overridden by child templates in order to provide different content within them.</p><p>Here's the footer:</p><p>
<code class="literal">entries/templates/entries/footer.html</code>
</p><div class="informalexample"><pre class="programlisting">&lt;div class="footer"&gt;
  Go back &lt;a href="{% url "home" %}"&gt;home&lt;/a&gt;.
&lt;/div&gt;</pre></div><p>It gives us a nice link to the home page.</p><p>The home page template is the following:</p><p>
<code class="literal">entries/templates/entries/home.html</code>
</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong>{% extends "entries/base.html" %}</strong></span>
{% block title%}Welcome to the Entry website.{% endblock title %}

{% block page-content %}
  &lt;h1&gt;Welcome {{ user.first_name }}!&lt;/h1&gt;

  &lt;div class="home-option"&gt;To see the list of your entries
    please click &lt;a href="{% url "entries" %}"&gt;here.&lt;/a&gt;
  &lt;/div&gt;
  &lt;div class="home-option"&gt;To insert a new entry please click
    &lt;a href="{% url "insert" %}"&gt;here.&lt;/a&gt;
  &lt;/div&gt;
  &lt;div class="home-option"&gt;To login as another user please click
    &lt;a href="{% url "logout" %}"&gt;here.&lt;/a&gt;
  &lt;/div&gt;
    &lt;div class="home-option"&gt;To go to the admin panel
    please click &lt;a href="{% url "admin:index" %}"&gt;here.&lt;/a&gt;
  &lt;/div&gt;
{% endblock page-content %}</pre></div><p>It extends the <code class="literal">base.html</code> template, and overrides <code class="literal">title</code> and <code class="literal">page-content</code>. You can see that <a id="id749" class="indexterm"/>basically all it does is provide four links to the user. These are the list of entries, the insert page, the logout page, and the admin page. All of this is done without hardcoding a single URL, through the use of the <code class="literal">{% url ... %}</code> tag, which is the template equivalent of the <code class="literal">reverse</code> function.</p><p>The template for inserting an <code class="literal">Entry</code> is as follows:</p><p>
<code class="literal">entries/templates/entries/insert.html</code>
</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong>{% extends "entries/base.html" %}</strong></span>
{% block title%}Insert a new Entry{% endblock title %}

{% block page-content %}
  <span class="strong"><strong>{% if messages %}</strong></span>
    <span class="strong"><strong>{% for message in messages %}</strong></span>
      &lt;p class="{{ message.tags }}"&gt;{{ message }}&lt;/p&gt;
    <span class="strong"><strong>{% endfor %}</strong></span>
  <span class="strong"><strong>{% endif %}</strong></span>

  &lt;h1&gt;Insert a new Entry&lt;/h1&gt;
  &lt;form action="{% url "insert" %}" method="post"&gt;
    <span class="strong"><strong>{% csrf_token %}{{ form.as_p }}</strong></span>
    &lt;input type="submit" value="Insert"&gt;
  &lt;/form&gt;&lt;br&gt;
{% endblock page-content %}

{% block footer %}
  &lt;div&gt;&lt;a href="{% url "entries" %}"&gt;See your entries.&lt;/a&gt;&lt;/div&gt;
  {% include "entries/footer.html" %}
{% endblock footer %}</pre></div><p>There is <a id="id750" class="indexterm"/>some conditional logic at the beginning to display messages, if any, and then we define the form. Django gives us the ability to render a form by simply calling <code class="literal">{{ form.as_p }}</code> (alternatively, <code class="literal">form.as_ul</code> or <code class="literal">form.as_table</code>). This creates all the necessary fields and labels for us. The difference between the three commands is in the way the form is laid out: as a paragraph, as an unordered list or as a table. We only need to wrap it in form tags and add a submit button. This behavior was designed for our convenience; we need the freedom to shape that <code class="literal">&lt;form&gt;</code> tag as we want, so Django isn't intrusive on that. Also, note that <code class="literal">{% csrf_token %}</code>. It will be rendered into a token by Django and will become part of the data sent to the server on submission. This way Django will be able to verify that the request was from an allowed source, thus avoiding the aforementioned <span class="emphasis"><em>cross-site request forgery</em></span> issue. Did you see how we handled the token when we wrote the view for the <code class="literal">Entry</code> insertion? Exactly. We didn't write a single line of code for it. Django takes care of it automatically thanks to a <span class="strong"><strong>middleware</strong></span> class (<code class="literal">CsrfViewMiddleware</code>). Please refer to the official<a id="id751" class="indexterm"/> Django documentation to explore this subject further.</p><p>For this page, we also use the footer block to display a link to the home page. Finally, we have the list template, which is the most interesting one.</p><p>
<code class="literal">entries/templates/entries/list.html</code>
</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong>{% extends "entries/base.html" %}</strong></span>
{% block title%} Entries list {% endblock title %}

{% block page-content %}
 {% if entries %}
  &lt;h1&gt;Your entries ({{ entries|length }} found)&lt;/h1&gt;
  &lt;div&gt;&lt;a href="{% url "insert" %}"&gt;Insert new entry.&lt;/a&gt;&lt;/div&gt;

  &lt;table class="entries-table"&gt;
   &lt;thead&gt;
     &lt;tr&gt;&lt;th&gt;Entry&lt;/th&gt;&lt;th&gt;Matches&lt;/th&gt;&lt;/tr&gt;
   &lt;/thead&gt;
   &lt;tbody&gt;
    <span class="strong"><strong>{% for entry, match in entries %}</strong></span>
     &lt;tr class="entries-list <span class="strong"><strong>{% cycle 'light-gray' 'white' %}</strong></span>"&gt;
      &lt;td&gt;
        Pattern: &lt;code class="code"&gt;
         "{{ entry.pattern }}"&lt;/code&gt;&lt;br&gt;
        Test String: &lt;code class="code"&gt;
         "{{ entry.test_string }}"&lt;/code&gt;&lt;br&gt;
        Added: {{ entry.date_added }}
      &lt;/td&gt;
      &lt;td&gt;
        <span class="strong"><strong>{% if match %}</strong></span>
         Group: {{ match.0 }}&lt;br&gt;
         Subgroups:
          {{ match.1|default_if_none:"none" }}&lt;br&gt;
         Group Dict: {{ match.2|default_if_none:"none" }}
        <span class="strong"><strong>{% else %}</strong></span>
         No matches found.
        <span class="strong"><strong>{% endif %}</strong></span>
      &lt;/td&gt;
     &lt;/tr&gt;
    <span class="strong"><strong>{% endfor %}</strong></span>
   &lt;/tbody&gt;
  &lt;/table&gt;
 <span class="strong"><strong>{% else %}</strong></span>
  &lt;h1&gt;You have no entries&lt;/h1&gt;
  &lt;div&gt;&lt;a href="{% url "insert" %}"&gt;Insert new entry.&lt;/a&gt;&lt;/div&gt;
 <span class="strong"><strong>{% endif %}</strong></span>
{% endblock page-content %}

{% block footer %}
 {% include "entries/footer.html" %}
{% endblock footer %}</pre></div><p>It may take<a id="id752" class="indexterm"/> you a while to get used to the template language, but really, all there is to it is the creation of a table using a <code class="literal">for</code> loop. We start by checking if there are any entries and, if so, we create a table. There are two columns, one for the <code class="literal">Entry</code>, and the other for the match.</p><p>In the <code class="literal">Entry</code> column, we display the <code class="literal">Entry</code> object (apart from the user) and in the <code class="literal">Matches</code> column, we display that 3-tuple we created in the <code class="literal">EntryListView</code>. Note that to access the attributes of an object, we use the same dot syntax we use in Python, for example <code class="literal">{{ entry.pattern }}</code> or <code class="literal">{{ entry.test_string }}</code>, and so on.</p><p>When dealing with lists and tuples, we cannot access items using the square brackets syntax, so we use the dot one as well (<code class="literal">{{ match.0 }}</code> is equivalent to <code class="literal">match[0]</code>, and so on.). We also use a filter, through the pipe (<code class="literal">|</code>) operator to display a custom value if a match is <code class="literal">None</code>.</p><p>The Django template language (which is not properly Python) is kept simple for a precise reason. If you find yourself limited by the language, it means you're probably trying to do something in the template that should actually be done in the view, where that logic is more relevant.</p><p>Allow me to show you a couple of screenshots of the <span class="emphasis"><em>list</em></span> and <span class="emphasis"><em>insert</em></span> templates. This is what the list of entries looks like for my father:</p><div class="mediaobject"><img src="graphics/4715_10_04.jpg" alt="Writing the templates"/></div><p>Note how<a id="id753" class="indexterm"/> the use of the cycle tag alternates the background color of the rows from white to light gray. Those classes are defined in the <code class="literal">main.css</code> file.</p><p>The <code class="literal">Entry</code> insertion page is smart enough to provide a few different scenarios. When you land on it at first, it presents you with just an empty form. If you fill it in correctly, it will display a nice message for you (see the following picture). However, if you fail to fill in both fields, it will display an error message before them, alerting you that those fields are required.</p><p>Note also the custom footer, which includes both a link to the entries list and a link to the home page:</p><div class="mediaobject"><img src="graphics/4715_10_05.jpg" alt="Writing the templates"/></div><p>And that's it! You can play around with the CSS styles if you wish. Download the code for the book and have fun exploring and extending this project. Add something else to the model, create and apply a migration, play with the templates, there's lots to do!</p><p>Django is<a id="id754" class="indexterm"/> a very powerful framework, and offers so much more than what I've been able to show you in this chapter, so you definitely <a id="id755" class="indexterm"/>want to check it out. The beauty of it is that it's Python, so reading its source code is a very useful exercise.</p></div></div>
<div class="section" title="The future of web development"><div class="titlepage"><div><div><h1 class="title"><a id="ch10lvl1sec80"/>The future of web development</h1></div></div></div><p>Computer<a id="id756" class="indexterm"/> science is a very young subject, compared to other branches of science that have existed alongside humankind for centuries or more. One of its main characteristics is that it moves extremely fast. It leaps forward with such speed that, in just a few years, you can see changes that are comparable to real world changes that took a century to happen. Therefore, as a coder, you must pay attention to what happens in this world, all the time.</p><p>Something that is happening now is that because powerful computers are now quite cheap and almost everyone has access to them, the trend is to try and avoid putting too much workload on the backend, and let the frontend handle part of it. Therefore, in the last few years, JavaScript frameworks and libraries like jQuery and Backbone have become very popular and web development has shifted from a paradigm where the backend takes care of handling data, preparing it, and serving it to the frontend to display it, to a paradigm where the backend is sometimes just used as an API, a sheer data provider. The <a id="id757" class="indexterm"/>frontend fetches the data from the backend with an API call, and then it takes care of the rest. This shift facilitates the existence of paradigms like <span class="strong"><strong>Single-Page Application</strong></span> (<span class="strong"><strong>SPA</strong></span>), where, ideally, the whole page is <a id="id758" class="indexterm"/>loaded once and then evolves, based on the content that usually comes from the backend. E-commerce websites that load the results of a search in a page that doesn't refresh the surrounding structure, are made with similar techniques. Browsers can perform asynchronous calls (<span class="strong"><strong>AJAX</strong></span>) that can return data <a id="id759" class="indexterm"/>which can be read, manipulated and injected back into the page with JavaScript code.</p><p>So, if you're planning to work on web development, I strongly suggest you to get acquainted with JavaScript (if you're not already), and also with APIs. In the last few pages of this chapter, I'll give you an example of how to make a simple API using two different Python microframeworks: Flask and Falcon.</p><div class="section" title="Writing a Flask view"><div class="titlepage"><div><div><h2 class="title"><a id="ch10lvl2sec124"/>Writing a Flask view</h2></div></div></div><p>Flask (<a class="ulink" href="http://flask.pocoo.org/">http://flask.pocoo.org/</a>) is<a id="id760" class="indexterm"/> a Python microframework. It provides fewer features<a id="id761" class="indexterm"/> than Django, but it's supposedly faster and <a id="id762" class="indexterm"/>quicker to get up and running. To be honest, getting Django up and running nowadays is also very quickly done, but Flask is so popular that it's good to see an example of it, nonetheless.</p><p>In your <code class="literal">ch10</code> folder, create a <code class="literal">flask</code> folder with the following structure:</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong>$ tree -A flask  # from the ch10 folder</strong></span>
<span class="strong"><strong>flask</strong></span>
<span class="strong"><strong>├── main.py</strong></span>
<span class="strong"><strong>└── templates</strong></span>
<span class="strong"><strong>    └── main.html</strong></span>
</pre></div><p>Basically, we're going to code two simple files: a Flask application and an HTML template. Flask uses Jinja2 as template engine. It's extremely popular and very fast, and just recently even Django has started to offer native support for it, which is something that Python coders have longed for, for a long time.</p><p>
<code class="literal">flask/templates/main.html</code>
</p><div class="informalexample"><pre class="programlisting">&lt;!doctype html&gt;
&lt;title&gt;Hello from Flask&lt;/title&gt;
&lt;h1&gt;
  {% if name %}
    Hello {{ name }}!
  {% else %}
    Hello shy person!
  {% endif %}
&lt;/h1&gt;</pre></div><p>The template is almost offensively simple; all it does is to change the greeting according to the presence of the <code class="literal">name</code> variable. A bit more interesting is the Flask application that renders it:</p><p>
<code class="literal">flask/main.py</code>
</p><div class="informalexample"><pre class="programlisting">from flask import Flask, render_template

app = Flask(__name__)

<span class="strong"><strong>@app.route('/')</strong></span>
<span class="strong"><strong>@app.route('/&lt;name&gt;')</strong></span>
def hello(name=None):
    return <span class="strong"><strong>render_template('main.html', name=name)</strong></span>

if __name__ == '__main__':
    app.run()</pre></div><p>We create an <code class="literal">app</code> object, which is a Flask application. We only feed the fully-qualified name of the module, which is stored in <code class="literal">__name__</code>.</p><p>Then, we write a simple <code class="literal">hello</code> view, which takes an optional <code class="literal">name</code> argument. In the body of the view, we simply render the <code class="literal">main.html</code> template, passing to it the <code class="literal">name</code> argument, regardless of its value.</p><p>What's interesting is the routing. Differently from Django's way of tying up views and URLs (the <code class="literal">urls.py</code> module), in Flask you decorate your view with one or more <code class="literal">@app.route</code> decorators. In this case, we accept both the root URL without anything else, or with name information.</p><p>Change into the <code class="literal">flask</code> folder and type (make sure you have Flask installed with <code class="literal">$ pip install flask</code>):</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong>$ python main.py</strong></span>
</pre></div><p>You can open a browser and go to <code class="literal">http://127.0.0.1:5000/</code>. This URL has no name information; therefore, you will see <span class="strong"><strong>Hello shy person!</strong></span> It is written all nice and big. Try to add something to that URL like <code class="literal">http://127.0.0.1:5000/Adriano</code>. Hit <span class="emphasis"><em>Enter</em></span> and the page will change to <span class="strong"><strong>Hello Adriano!</strong></span>.</p><p>Of course, Flask <a id="id763" class="indexterm"/>offers you much more than this but we don't have the room to see a more complex example. It's definitely worth exploring, though. Several projects use it successfully and it's fun and it is nice to create websites or APIs with it. Flask's author, Armin Ronacher, is a successful and very prolific coder. He also created or collaborated on several other interesting projects like Werkzeug, Jinja2, Click, and Sphinx.</p></div><div class="section" title="Building a JSON quote server in Falcon"><div class="titlepage"><div><div><h2 class="title"><a id="ch10lvl2sec125"/>Building a JSON quote server in Falcon</h2></div></div></div><p>Falcon (<a class="ulink" href="http://falconframework.org/">http://falconframework.org/</a>) is another microframework written in Python, which <a id="id764" class="indexterm"/>was designed to be light, fast and<a id="id765" class="indexterm"/> flexible. I think this relatively young project <a id="id766" class="indexterm"/>will evolve to become something really popular due to its speed, which<a id="id767" class="indexterm"/> is impressive, so I'm happy to show you a tiny example using it.</p><p>We're going to build a view that returns a randomly chosen quote from the <span class="emphasis"><em>Buddha</em></span>.</p><p>In your <code class="literal">ch10</code> folder, create a new one called <code class="literal">falcon</code>. We'll have two files: <code class="literal">quotes.py</code> and <code class="literal">main.py</code>. To run this example, install Falcon and Gunicorn (<code class="literal">$ pip install falcon gunicorn</code>). Falcon<a id="id768" class="indexterm"/> is the framework, and <span class="strong"><strong>Gunicorn</strong></span> (<span class="strong"><strong>Green Unicorn</strong></span>) is a Python WSGI HTTP Server for Unix (which, in layman terms, means the technology that is used to run the server). When you're all set up, start by creating the <code class="literal">quotes.py</code> file.</p><p>
<code class="literal">falcon/quotes.py</code>
</p><div class="informalexample"><pre class="programlisting">quotes = [
    "Thousands of candles can be lighted from a single candle, "
    "and the life of the candle will not be shortened. "
    "Happiness never decreases by being shared.",
    ...
    "Peace comes from within. Do not seek it without.",
]</pre></div><p>You will find the complete list of quotes in the source code for this book. If you don't have it, you can also fill in your favorite quotes. Note that not every line has a comma at the end. In Python, it's possible to concatenate strings like that, as long as they are in brackets (or braces). It's <a id="id769" class="indexterm"/>called <span class="strong"><strong>implicit concatenation</strong></span>.</p><p>The code for the main app is not long, but it is interesting:</p><p>
<code class="literal">falcon/main.py</code>
</p><div class="informalexample"><pre class="programlisting">import json
import random
import falcon
from quotes import quotes

class QuoteResource:
    def <span class="strong"><strong>on_get</strong></span>(self, req, resp):
        quote = {
            'quote': random.choice(quotes),
            'author': 'The Buddha'
        }
        resp.body = json.dumps(quote)

<span class="strong"><strong>api = falcon.API()</strong></span>
<span class="strong"><strong>api.add_route('/quote', QuoteResource())</strong></span>
</pre></div><p>Let's start with the class. In Django we had a <code class="literal">get</code> method, in Flask we defined a function, and here <a id="id770" class="indexterm"/>we write an <code class="literal">on_get</code> method, a naming <a id="id771" class="indexterm"/>style that reminds me of C# event handlers. It takes a request and a response argument, both automatically fed by the framework. In its body, we define a dict with a randomly chosen quote, and the author information. Then we dump that dict to a JSON string and set the response body to its value. We don't need to return anything, Falcon will take care of it for us.</p><p>At the end of the file, we create the Falcon application, and we call <code class="literal">add_route</code> on it to tie the handler we have just written to the URL we want.</p><p>When you're all set up, change to the <code class="literal">falcon</code> folder and type:</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong>$ gunicorn main:api</strong></span>
</pre></div><p>Then, make a request (or simply open the page with your browser) to <code class="literal">http://127.0.0.1:8000/quote</code>. When I did it, I got this JSON in response:</p><div class="informalexample"><pre class="programlisting">{
    quote: "The mind is everything. What you think you become.",
    author: "The Buddha"
}</pre></div><p>Whatever the framework you end up using for your web development, try and keep yourself informed about other choices too. Sometimes you may be in situations where a different framework is the right way to go, and having a working knowledge of different tools will give you an advantage.</p></div></div>
<div class="section" title="Summary"><div class="titlepage"><div><div><h1 class="title"><a id="ch10lvl1sec81"/>Summary</h1></div></div></div><p>In this chapter, we caught a glimpse of web development. We talked about important concepts like the DRY philosophy and the concept of a framework as a tool that provides us with many things we need in order to write code to serve requests. We also talked about the MTV pattern, and how nicely these three layers play together to realize a request-response path.</p><p>Later on, we briefly introduced regular expressions, which is a subject of paramount importance, and it's the layer which provides the tools for URL routing.</p><p>There are many different frameworks out there, and Django is definitely one of the best and most widely used, so it's definitely worth exploring, especially its source code, which is very well written.</p><p>There are other very interesting and important frameworks too, like Flask. They provide fewer features but, in general, they are faster, both in execution time and to set up. One that is extremely fast is the relatively young Falcon project, whose benchmarks are outstanding.</p><p>It's important to get a solid understanding of how the request-response mechanism works, and how the Web in general works, so that eventually it won't matter too much which framework you have to use. You will be able to pick it up quickly because it will only be a matter of getting familiar with a way of doing something you already know a lot about.</p><p>Explore at least three frameworks and try to come up with different use cases to decide which one of them could be the ideal choice. When you are able to make that choice, you will know you have a good enough understanding of them.</p><p>The next chapter is about debugging and troubleshooting. We'll learn how to deal with errors and issues so that if you get in trouble when coding (don't worry, normally it only happens about all the time), you will be able to quickly find the solution to your problem and move on.</p></div></body></html>