- en: Chapter 7. Developing a Test-Driven Project
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第7章. 开发测试驱动型项目
- en: '*In this chapter, we won''t talk about new techniques for testing in Python,
    neither will we spend much time talking about the philosophy of testing. Instead,
    what we''ll do is walk step-by-step through a record of an actual development
    process. Your humble and sadly fallible author has memorialized his mistakes—and
    the ways that testing helped him fix them—while developing part of a personal
    scheduling program.*'
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: '*在本章中，我们不会讨论Python中测试的新技术，也不会花太多时间讨论测试的哲学。相反，我们将逐步通过一个实际开发过程的记录。谦逊且不幸易犯错的作者记录了他的错误——以及测试如何帮助他修复这些错误——在开发个人调度程序的一部分时。*'
- en: 'In this chapter, we shall:'
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将：
- en: Write a testable specification
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 编写可测试的规范
- en: Write unit tests
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 编写单元测试
- en: Write code that complies with the specification and unit tests
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 编写符合规范和单元测试的代码
- en: Use the testable specification and unit tests to help debug
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用可测试的规范和单元测试来帮助调试
- en: You'll be prompted to design and build your own module as you read through this
    chapter, so that you can walk through your own process as well.
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: 阅读本章时，你将被提示设计和构建自己的模块，这样你就可以走自己的过程了。
- en: Writing the specification
  id: totrans-8
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 编写规范
- en: As usual, the process starts with a written specification. The specification
    is a doctest, (which we learned about in Chapters 2 and 3), so the computer can
    use it to check the implementation. The specification isn't strictly a set of
    unit tests though; the discipline of unit testing has been sacrificed (for the
    moment) in exchange for making the document more accessible to a human reader.
    That's a common trade-off, and it's fine as long as you make up for it by also
    writing unit tests covering the code.
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 如往常一样，过程从书面规范开始。规范是一个doctest（我们在第2章和第3章中了解过），因此计算机可以使用它来检查实现。尽管规范并不是一组单元测试；为了使文档更易于人类读者阅读，我们暂时牺牲了单元测试的纪律。这是一个常见的权衡，只要你也编写覆盖代码的单元测试来弥补，那就没问题。
- en: The goal of the project is to make a Python package capable of representing
    personal time management information.
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 项目目标是创建一个能够表示个人时间管理信息的Python包。
- en: 'The following code goes in a file called `docs/outline.txt`:'
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 以下代码放在一个名为`docs/outline.txt`的文件中：
- en: '[PRE0]'
  id: totrans-12
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'This doctest will serve as a testable specification for my project, which means
    that it will be the foundation stone on which all of my other tests (and my program
    code) will be built on. Let''s look at each section in more detail:'
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 这个doctest将作为我项目的可测试规范，这意味着它将成为所有其他测试（以及我的程序代码）的基础。让我们更详细地看看每个部分：
- en: '[PRE1]'
  id: totrans-14
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: The above code consists of some introductory English text and a couple of import
    statements that bring in code that we need for these tests. By doing so, they
    also tell us about some of the structure of the `planner` package. Specifically,
    they tell us that it contains a module called `data`, which defines activities
    and statuses.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 上述代码包含一些简介性英文文本和几个导入语句，这些导入语句引入了我们需要用于这些测试的代码。通过这样做，它们也告诉我们`planner`包的一些结构。具体来说，它们告诉我们它包含一个名为`data`的模块，该模块定义了活动和状态。
- en: '[PRE2]'
  id: totrans-16
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: The above tests describe some of the desired behavior of `schedules` for `activities`
    and `statuses`. According to these tests, `schedules` must accept `activities`
    and `statuses` as parameters of its `add` and `remove` methods. Once they're added,
    the `in` operator must return `True` for an object until it is removed. Furthermore,
    two `activities` that have the same parameters must be treated as the same object
    by `schedules`.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 上述测试描述了`schedules`对`activities`和`statuses`的一些期望行为。根据这些测试，`schedules`必须接受`activities`和`statuses`作为其`add`和`remove`方法的参数。一旦它们被添加，`in`运算符必须返回`True`，直到对象被移除。此外，具有相同参数的两个`activities`必须被`schedules`视为同一个对象。
- en: '[PRE3]'
  id: totrans-18
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: The above test code describes what should happen when overlapping activities
    are added to a schedule. Specifically, a `schedule_error` should be raised.
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 上述测试代码描述了当重叠活动被添加到日程表中时应该发生什么。具体来说，应该引发一个`schedule_error`。
- en: '[PRE4]'
  id: totrans-20
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'The above test code describes what should happen when overlapping statuses
    are added to a schedule: the schedule should accept them. Furthermore, if a status
    and an activity overlap, they can still both be added.'
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 上述测试代码描述了当重叠状态被添加到日程表中时应该发生什么：日程表应该接受它们。此外，如果状态和活动重叠，它们仍然都可以被添加。
- en: '[PRE5]'
  id: totrans-22
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: The above code describes how schedule storage should work. It also tells us
    that the `planner` package needs to contain a `persistence` module, which in turn
    should contain `file`.
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 上述代码描述了调度存储应该如何工作。它还告诉我们，`planner` 包需要包含一个 `persistence` 模块，而这个模块反过来应该包含 `file`。
- en: Time for action – what are you going to do?
  id: totrans-24
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 行动时间——你打算做什么？
- en: 'It''s time for you to come up with a project of your own, something that you
    can work on by yourself; we step through the development process:'
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 是时候你自己想出一个项目了，一个你可以独立工作的项目；我们逐步通过开发过程：
- en: Think of a project of approximately the same complexity as the one described
    in this chapter. It should be a single module or a few modules in a single package.
  id: totrans-26
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 想想一个与本章所述项目大致相同复杂性的项目。它应该是一个单独的模块或一个包中的几个模块。
- en: Imagine that the project is already done, and you need to write a description
    of what you've done, along with a little bit of demonstration code. Then go ahead
    and write your description and demo code in the form of a doctest file.
  id: totrans-27
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 想象一下项目已经完成，你需要编写一个描述你所做的工作，以及一些演示代码的说明。然后继续编写你的描述和演示代码，以 doctest 文件的形式。
- en: As you're writing the doctest file, look out for places where your original
    idea has to change a little bit to make the demo easier to write, or work better.
    When you find such cases, pay attention to them! At this stage, it's better to
    change the idea a little bit and save yourself effort all through the process.
  id: totrans-28
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 当你编写 doctest 文件时，要注意那些你的原始想法需要稍作改变以使演示更容易编写或工作得更好的地方。当你找到这样的案例时，请注意它们！在这个阶段，最好稍作改变，以便在整个过程中节省精力。
- en: '*What just happened?*'
  id: totrans-29
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: '*刚才发生了什么？*'
- en: We've got testable specifications for moderately-sized projects, now. These
    will help us to write unit tests and code, and they'll give us a sense of how
    complete the project is, as a whole.
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在有了适度规模项目的可测试规范，这将帮助我们编写单元测试和代码，并让我们对整个项目的完整性有一个整体的感觉。
- en: In addition, the process of writing code into the doctest gave us a chance to
    test-drive our ideas. We've probably improved our projects a little bit by using
    them in a concrete manner, even though the project implementation is still merely
    imaginary.
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，将代码写入 doctest 的过程给了我们测试驱动我们想法的机会。我们可能通过具体使用它们来改进我们的项目，尽管项目实现仍然仅仅是想象中的。
- en: Once again, it's important that we have written these tests *before* writing
    the code that they will test. By writing the tests first, we give ourselves a
    touchstone that we can use to judge how well our code conforms to what we intended.
    If we write the code first, and then the tests, all we end up doing is enshrining
    what the code actually does—as opposed to what we meant for it to do—into the
    tests.
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 再次强调，在编写将要测试的代码之前编写这些测试非常重要。通过先编写测试，我们给自己提供了一个可以用来判断我们的代码是否符合我们意图的基准。如果我们先编写代码，然后编写测试，最终我们只是将代码实际执行的行为——而不是我们希望它执行的行为——神圣化到测试中。
- en: Writing initial unit tests
  id: totrans-33
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 编写初始单元测试
- en: Since the specification doesn't contain unit tests, there's still a need for
    unit tests before the coding of the module can begin. The `planner.data` classes
    are the first target for implementation, so they're the first ones to get tests.
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 由于规范不包含单元测试，在模块编码开始之前，仍然需要单元测试。`planner.data` 类是第一个要实现的目标，因此它们是第一个接受测试的。
- en: Activities and statuses are defined to be very similar, so their test modules
    are also similar. They're not identical though, and they're not required to have
    any particular inheritance relationship, so the tests remain distinct.
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 活动和状态被定义为非常相似，因此它们的测试模块也是相似的。尽管它们并不完全相同，也不需要具有任何特定的继承关系，所以测试仍然是独立的。
- en: 'The following tests are in `tests/test_activities.py`:'
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 以下测试位于 `tests/test_activities.py`：
- en: '[PRE6]'
  id: totrans-37
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'Let''s take a look at each section of the above unit test code:'
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们来看看上述单元测试代码的每个部分：
- en: '[PRE7]'
  id: totrans-39
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: The `test_valid` method checks that the constructor works correctly when all
    of the parameters are correct. This is an important test, because it defines what
    correct behavior in the normal case should be. We need more tests though, to define
    correct behavior in abnormal situations.
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: '`test_valid` 方法检查当所有参数都正确时构造函数是否工作正常。这是一个重要的测试，因为它定义了正常情况下正确行为应该是什么。但我们还需要更多的测试来定义异常情况下的正确行为。'
- en: '[PRE8]'
  id: totrans-41
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: Here, we'll make sure that you can't create an activity that ends before it
    begins. That doesn't make any sense, and could easily throw off assumptions made
    during the implementation.
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们将确保你不能创建一个在开始之前就结束的活动。这没有任何意义，并且很容易在实现过程中导致假设错误。
- en: '[PRE9]'
  id: totrans-43
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: We don't want extremely short activities either. In the real world, an activity
    that takes no time is meaningless, so we have a test here to make sure that such
    things are not allowed.
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 我们也不希望活动非常短。在现实世界中，一个不占用时间的活动是没有意义的，所以我们在这里有一个测试来确保不允许这种情况发生。
- en: '[PRE10]'
  id: totrans-45
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: While `repr(activity)` isn't likely to be used in any production code paths,
    it's handy during development and debugging. This test defines how the text representation
    of an activity should look, to make sure that it contains the desired information.
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然 `repr(activity)` 在任何生产代码路径中可能不太可能被使用，但在开发和调试期间非常方便。这个测试定义了活动文本表示应该如何看起来，以确保它包含所需的信息。
- en: '[PRE11]'
  id: totrans-47
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: Since activities are supposed to be exclusive of each other when they overlap,
    we check that here. The activity obviously overlaps with itself, so the `excludes`
    method should return `True`. On the other hand, an activity shouldn't just assume
    it excludes everything, so calling `excludes` on unknown objects (such as `None`)
    should return `False`.
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 由于活动在重叠时应该相互排斥，所以我们在这里进行检查。显然，活动与其自身重叠，因此 `excludes` 方法应该返回 `True`。另一方面，活动不应该仅仅假设它排除了所有其他事物，因此在对未知对象（如
    `None`）调用 `excludes` 时应该返回 `False`。
- en: '[PRE12]'
  id: totrans-49
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: Here we created a test fixture that creates a mock object which pretends to
    be an activity or status. We'll use this mock object (called `self.other`) in
    several of the following tests.
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们创建了一个测试固定装置，它创建了一个模拟对象，该对象假装是一个活动或状态。我们将在接下来的几个测试中使用这个模拟对象（称为 `self.other`）。
- en: '[PRE13]'
  id: totrans-51
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'These tests describe the behavior of activity overlap checking in the cases
    where the activity:'
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 这些测试描述了活动重叠检查在以下情况下的行为：
- en: Comes after the mock object
  id: totrans-53
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在模拟对象之后
- en: Overlaps the end of the mock object
  id: totrans-54
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 与模拟对象重叠的末尾
- en: Overlaps the beginning of the mock object
  id: totrans-55
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 与模拟对象的开始重叠
- en: Starts after the mock object and ends before it
  id: totrans-56
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在模拟对象之后开始并在其之前结束
- en: Starts before the mock object and ends after it
  id: totrans-57
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在模拟对象之前开始并在其之后结束
- en: 'The following tests are in `tests/test_statuses.py`. Many of these are similar
    to the tests for `activities`. We''ll concentrate on the differences:'
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 以下测试位于 `tests/test_statuses.py` 文件中。其中许多测试与 `activities` 的测试类似。我们将重点关注它们之间的差异：
- en: '[PRE14]'
  id: totrans-59
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: There's one significant area of difference between this test file and the previous
    one, the `test_excludes` method.
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 与前一个测试文件相比，这个测试文件有一个显著的不同点，即 `test_excludes` 方法。
- en: '[PRE15]'
  id: totrans-61
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: Unlike an activity, a status should never force itself to be exclusive with
    something else, so this test uses `assertFalse`, instead of `assertTrue` for the
    first assertion.
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 与活动不同，状态永远不应该强迫自己与其他事物相互排斥，因此这个测试使用 `assertFalse` 而不是 `assertTrue` 进行第一个断言。
- en: The following tests are in `tests/test_schedules.py`. We define several mock
    objects in the `setUp` method that behave as if they were `activities` or `statuses`.
    These mock objects simulate activities or statuses, and so by using them instead
    of real activities or statuses they allow us to check that the `schedules` class
    correctly handles events that either do or do not overlap, and that either do
    or do not exclude each other, all without actually using code from outside the
    unit being tested.
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 以下测试位于 `tests/test_schedules.py` 文件中。我们在 `setUp` 方法中定义了几个模拟对象，它们的行为就像 `activities`
    或 `statuses` 一样。这些模拟对象模拟活动或状态，因此通过使用它们而不是真实的活动或状态，我们可以检查 `schedules` 类是否正确处理了重叠或非重叠的事件，以及它们是否相互排除，所有这些都不需要使用正在测试的单元外的代码。
- en: '[PRE16]'
  id: totrans-64
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: Let's go over those tests section by section.
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们逐节回顾那些测试。
- en: '[PRE17]'
  id: totrans-66
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'We created four mock objects here: `overlap_exclude`, `overlap_include`, `distinct_exclude`,
    and d`istinct_include`. Each of them represents a different combination of behavior
    of its `overlaps` method and its `excludes` method. Between these four mock objects,
    we have every combination of overlapping or not overlapping, and excluding or
    not excluding. In the following tests, we''ll add various combinations of these
    mock objects to a schedule, and make sure it does the right things.'
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在这里创建了四个模拟对象：`overlap_exclude`、`overlap_include`、`distinct_exclude` 和 `distinct_include`。每个对象代表其
    `overlaps` 方法和 `excludes` 方法的行为的不同组合。在这四个模拟对象之间，我们有重叠或不重叠、排除或不排除的每一种组合。在接下来的测试中，我们将添加这些模拟对象的多种组合到日程表中，并确保它做正确的事情。
- en: '[PRE18]'
  id: totrans-68
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: These four tests cover cases, where we add a non-overlapping object to a schedule.
    All of them are expected to accept the non-overlapping object, except the first.
    In that test, we've previously added an object that claims that it does indeed
    overlap, and furthermore it excludes anything it overlaps. That test shows that
    if either the object being added or an object already in the schedule believes
    there's an overlap, the schedule must treat it as an overlap.
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 这四个测试涵盖了将非重叠对象添加到调度中的情况。所有这些都应该接受非重叠对象，除了第一个。在那个测试中，我们之前添加了一个声称确实重叠的对象，并且进一步排除了它所重叠的任何东西。这个测试表明，如果被添加的对象或已经在调度中的对象认为存在重叠，那么调度必须将其视为重叠。
- en: '[PRE19]'
  id: totrans-70
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: In this test, we'll make sure that if an object already in the schedule overlaps
    a new object and claims exclusivity, then adding the new object will fail.
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个测试中，我们将确保如果一个已经在调度中的对象与新的对象重叠并声称具有排他性，那么添加新的对象将失败。
- en: '[PRE20]'
  id: totrans-72
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: In this test, we'll make sure that even though the object already in the schedule
    doesn't think it overlaps with the new object, it excludes the new object because
    the new object thinks that there's an overlap.
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个测试中，我们将确保即使已经在调度中的对象认为它没有与新的对象重叠，它也会排除新的对象，因为新的对象认为存在重叠。
- en: '[PRE21]'
  id: totrans-74
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: These tests make sure that inclusive objects don't somehow interfere with adding
    each other to a schedule.
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 这些测试确保包容性对象不会以某种方式干扰将它们添加到调度中。
- en: '[PRE22]'
  id: totrans-76
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: These two tests describe schedule behavior with respect to the `in` operator.
    Specifically, `in` should return `True` when the object in question is actually
    in the schedule.
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 这两个测试描述了与`in`操作符相关的调度行为。具体来说，当问题中的对象实际上在调度中时，`in`应该返回`True`。
- en: Time for action – nailing down the specification with unit tests
  id: totrans-78
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 是时候采取行动了——用单元测试确定规范
- en: A specification—even a testable specification written in doctest—is still home
    to a lot of ambiguities that can be ironed out with good unit tests. Add that
    to the fact that the specification doesn't maintain separation between different
    tests, and you can see that it's time for your project to gain some unit tests.
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 即使是可测试的规范（使用doctest编写），也仍然存在许多可以通过良好的单元测试消除的歧义。再加上规范没有在不同测试之间保持分离，你就知道你的项目需要一些单元测试了。
- en: Find some element of your project which is described in (or implied by) your
    specification
  id: totrans-80
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 找到你的项目中描述在（或由）规范中（或暗示）的某个元素
- en: Write a unit test that describes the behavior of that element when given correct
    input
  id: totrans-81
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 编写一个单元测试，描述当给定正确输入时该元素的行为。
- en: Write a unit test that describes the behavior of that element when given incorrect
    input
  id: totrans-82
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 编写一个单元测试，描述当给定错误输入时该元素的行为。
- en: Write unit tests that describe the behavior of the element at the boundaries
    between correct and incorrect input
  id: totrans-83
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 编写描述元素在正确和错误输入边界之间行为的单元测试。
- en: Go back to step 1 if you can find another untested part of your program.
  id: totrans-84
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果你可以找到程序中另一个未测试的部分，请回到步骤1。
- en: '*What just happened?*'
  id: totrans-85
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: '*刚才发生了什么？*'
- en: It doesn't take many bullet points to describe the procedure, but this is an
    important process. This is where you really take what was an ill-defined idea
    and turn it into a precise description of what you're going to do.
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 描述程序不需要很多项目符号，但这是一个重要的过程。这是你真正将一个定义不明确的想法转化为你将要做的精确描述的地方。
- en: The end result can be quite lengthy, which shouldn't come as much of a surprise.
    After all, your goal at this stage is to completely define the behavior of your
    project; and even without bothering yourself with the details of how that behavior
    is implemented, that's a lot of information.
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 最终结果可能相当长，这不应该让人感到惊讶。毕竟，在这个阶段，你的目标是完全定义你项目的行为；即使你不关心该行为是如何实现的细节，这也是很多信息。
- en: Coding planner.data
  id: totrans-88
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 编码`planner.data`
- en: It's time to write some code, using the specification document and the unit
    tests as guides. Specifically, it's time to write the `planner.data` module, which
    contains `statuses`, `activities`, and `schedules`.
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 是时候编写一些代码了，使用规范文档和单元测试作为指南。具体来说，是时候编写`planner.data`模块了，该模块包含`statuses`、`activities`和`schedules`。
- en: I made a directory called `planner`, and within that directory created a file
    called `__init__.py`. There's no need to put anything inside `__init__.py`, but
    the file itself needs to exist to tell Python that the `planner` directory is
    a package.
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 我创建了一个名为`planner`的目录，并在该目录中创建了一个名为`__init__.py`的文件。不需要在`__init__.py`中放置任何内容，但该文件本身需要存在，以便告诉Python`planner`目录是一个包。
- en: 'The following code goes in `planner/data.py`:'
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 以下代码放在`planner/data.py`中：
- en: '[PRE23]'
  id: totrans-92
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'Let''s go over this section by section:'
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们逐节讨论：
- en: '[PRE24]'
  id: totrans-94
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: The `_tasks` class here contains most of the behavior that is needed for both
    the `activities` and the `statuses` classes. Since so much of what they do is
    common to both, it makes sense to write the code once and reuse it. Only the `excludes`
    method needs to be different in each of the subclasses.
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 这里的`_tasks`类包含了`activities`和`statuses`类所需的大部分行为。由于它们所做的许多事情都是共同的，因此编写一次代码并重用是有意义的。只有`excludes`方法在每个子类中都需要不同。
- en: '[PRE25]'
  id: totrans-96
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: Here we have the implementations of the classes that our tests actually require
    to exist. The `activities` and `statuses` classes are very simple, by virtue of
    inheriting from `_tasks`. The `schedules` class turns out to be pretty easy, too.
    But is it right? Our tests will tell us.
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 这里是我们测试实际上需要的类的实现。`activities`和`statuses`类非常简单，因为它们继承自`_tasks`。`schedules`类也相当简单。但是，它是正确的吗？我们的测试会告诉我们。
- en: Using the tests to get the code right
  id: totrans-98
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用测试来确保代码正确
- en: 'All right, so that code looks fairly good. Unfortunately, Nose tells us there
    are a few problems. Actually, Nose reports quite a large number of problems, but
    the first ones needing to be fixed are shown below:'
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 好吧，所以代码看起来相当不错。不幸的是，Nose告诉我们还有一些问题。实际上，Nose报告了相当多的问题，但需要首先修复的是下面显示的：
- en: '![Using the tests to get the code right](img/8846_07_01.jpg)'
  id: totrans-100
  prefs: []
  type: TYPE_IMG
  zh: '![使用测试来确保代码正确](img/8846_07_01.jpg)'
- en: The reason for focusing on those errors, when we have so many to choose from,
    is simple. A lot of the other errors seem to be derived from these. The unit tests
    also report problems with exclude, so we know that one isn't derived from some
    other error—remember that unit tests aren't influenced by each other, unlike the
    tests in our specification.
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 我们之所以关注这些错误，而不是选择其他错误，原因很简单。许多其他错误似乎都是由此产生的。单元测试也报告了`exclude`的问题，因此我们知道这不是由其他错误引起的——记住，单元测试不会相互影响，这与我们规范中的测试不同。
- en: Fixing the code
  id: totrans-102
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 修复代码
- en: 'To fix the first error, add the following code to the `_tasks` class in `planner/data.py`:'
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 要修复第一个错误，请将以下代码添加到`planner/data.py`中的`_tasks`类：
- en: '[PRE26]'
  id: totrans-104
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: (Beware of the wrapped line in `__eq__`)
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: （注意`__eq__`中的换行）
- en: As you can probably tell, that code overrides the equality comparison between
    two `_tasks`, declaring them to be equal if they have the same name, begin time
    and end time. That's the equality metric that's implicitly assumed by the test
    code.
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 你可能已经注意到了，这段代码覆盖了两个`_tasks`之间的相等比较，如果它们具有相同的名称、开始时间和结束时间，则声明它们相等。这是测试代码隐含假设的相等度量标准。
- en: 'The second error can be fixed by fixing the typographical errors in `schedules.add`:'
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 第二个错误可以通过修复`schedules.add`中的拼写错误来解决：
- en: '[PRE27]'
  id: totrans-108
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: In this case, we changed the incorrect method name `exclude` to the correct
    method name `excludes`. (Again, watch out for wrapped lines)
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 在这种情况下，我们将错误的方法名`exclude`更改为正确的方法名`excludes`。（再次提醒，注意换行）
- en: 'So now, I run Nose again and it breaks:'
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，我现在再次运行Nose，它又中断了：
- en: '![Fixing the code](img/8846_07_02.jpg)'
  id: totrans-111
  prefs: []
  type: TYPE_IMG
  zh: '![修复代码](img/8846_07_02.jpg)'
- en: 'Fortunately, this is an easy fix: take out the extra ''e'' in ''contained'':'
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 幸运的是，这是一个简单的修复：从`contained`中移除多余的`e`：
- en: '[PRE28]'
  id: totrans-113
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: For the skeptical reader, I'm compelled to admit that, yes, that typo really
    did slip by until the test caught it. Sometimes tests catch boring mistakes instead
    of dramatic problems, typos instead of logic errors. It doesn't really matter,
    because either way the test is helping you make your code more solid, more reliable,
    and better.
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 对于怀疑的读者，我不得不承认，是的，那个拼写错误确实在测试捕捉到之前滑过去了。有时测试会捕捉到无聊的错误，而不是戏剧性的问题，是拼写错误而不是逻辑错误。这并不重要，因为无论如何，测试都在帮助你使代码更加稳固、更加可靠和更好。
- en: 'So now, when I run Nose it breaks:'
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，当我运行Nose时，它会中断：
- en: '![Fixing the code](img/8846_07_03.jpg)'
  id: totrans-116
  prefs: []
  type: TYPE_IMG
  zh: '![修复代码](img/8846_07_03.jpg)'
- en: 'Okay, fine, this is easy to fix too. The error is just formatted wrongly. Fix
    that by replacing the ''raise'' in `schedules.add`:'
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 好吧，这个也容易修复。错误只是格式错误。通过替换`schedules.add`中的`raise`来修复它：
- en: '[PRE29]'
  id: totrans-118
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: 'This time when I run Nose, it tells me that my unit test is broken:'
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 这次当我运行Nose时，它告诉我我的单元测试是错误的：
- en: '![Fixing the code](img/8846_07_04.jpg)'
  id: totrans-120
  prefs: []
  type: TYPE_IMG
  zh: '![修复代码](img/8846_07_04.jpg)'
- en: 'Specifically, it''s telling me that my mockups of `activities` and `statuses`
    are missing the `name` attribute. This too is simply fixed by changing the `setUp`
    method of `add_tests` in `tests/test_schedules.py`:'
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 具体来说，它告诉我我的`activities`和`statuses`的mockups缺少了`name`属性。这个问题也可以通过更改`tests/test_schedules.py`中的`add_tests`的`setUp`方法简单地解决：
- en: '[PRE30]'
  id: totrans-122
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: Having fixed that, Nose still reports errors, but all of them have to do with
    persistence. Those errors aren't surprising, because there's no persistence implementation
    yet.
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 修复了那个问题后，Nose仍然报告错误，但所有这些错误都与持久性有关。这些错误并不令人惊讶，因为没有持久性实现。
- en: Time for action – writing and debugging code
  id: totrans-124
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 行动时间 - 编写和调试代码
- en: The basic procedure (as we've discussed before), is to write some code and run
    the tests to find problems with the code, and repeat. When you come across an
    error that isn't covered by an existing test, you write a new test and continue
    the process.
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 基本程序（正如我们之前讨论的），是编写一些代码并运行测试以找到代码中的问题，然后重复。当你遇到一个现有测试未涵盖的错误时，你编写一个新的测试并继续这个过程。
- en: Write code that ought to satisfy at least some of your tests
  id: totrans-126
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 编写应该满足至少一些测试的代码
- en: 'Run your tests. If you used it when we talked about it in previous chapters,
    you should be able to run everything simply by executing:'
  id: totrans-127
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 运行你的测试。如果你在我们之前章节讨论它时使用了它，你应该能够通过执行以下操作来运行一切：
- en: '[PRE31]'
  id: totrans-128
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE31]'
- en: If there are errors in the code you've already written, use the test output
    to help you locate and identity them. Once you understand the bugs, try to fix
    them and then go back to step 2.
  id: totrans-129
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果你编写的代码中存在错误，请使用测试输出帮助你定位和识别它们。一旦你理解了错误，尝试修复它们，然后回到步骤 2。
- en: Once you've fixed all the errors in the code you've written, and if your project
    isn't complete, choose some new tests to concentrate on and go back to step 1.
  id: totrans-130
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 一旦你修复了你编写的代码中的所有错误，如果你的项目还没有完成，选择一些新的测试来集中精力，然后回到步骤 1。
- en: '*What just happened?*'
  id: totrans-131
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: '*发生了什么？*'
- en: Enough iterations on this procedure leads you to having a complete and tested
    project. Of course, the real task is more difficult than simply saying "it will
    work," but in the end, it will work. You will produce a codebase that you can
    be confident in. It will also be an easier process than it would have been without
    the tests.
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 对这个过程的足够迭代将使你拥有一个完整且经过测试的项目。当然，实际的任务比仅仅说“它会工作”要困难得多，但最终，它会工作。你将产生一个你可以自信的代码库。这也会比没有测试的过程更容易。
- en: Your project may be done, but there's still more to do on the personal scheduler.
    At this stage of the chapter, I haven't finished going through the writing and
    debugging process. It's time to do that.
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 你的项目可能已经完成，但在个人计划中还有更多的事情要做。在这一章的这个阶段，我还没有完成编写和调试过程。现在是时候去做这件事了。
- en: Writing persistence tests
  id: totrans-134
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 编写持久性测试
- en: 'Since I don''t have any actual unit tests for the persistence code yet, I''ll
    start off by making some. In the process, I have to figure how persistence will
    actually work. The following code goes in `tests/test_persistence.py`:'
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 由于我还没有实际的持久性代码单元测试，我将开始编写一些。在这个过程中，我必须弄清楚持久性实际上是如何工作的。以下代码放在 `tests/test_persistence.py`
    中：
- en: '[PRE32]'
  id: totrans-136
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: 'Looking at each of the important sections of the test code, we see the following:'
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 查看测试代码的每个重要部分，我们看到以下内容：
- en: '[PRE33]'
  id: totrans-138
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: The `test_basic` test creates a `storage`, stores a single object under the
    name `tag1`, and then loads that object back from storage and checks that it is
    equal to the original object.
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: '`test_basic` 测试创建一个 `storage`，在名为 `tag1` 的名称下存储一个单一对象，然后从存储中加载该对象并检查它是否等于原始对象。'
- en: '[PRE34]'
  id: totrans-140
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: The `test_multiple_tags` test creates a storage, and then stores multiple objects
    in it, some with duplicate tags. It then checks that the storage keeps all of
    the objects with a given tag, and returns all of them on request.
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: '`test_multiple_tags` 测试创建一个存储，然后在其中存储多个对象，其中一些具有重复的标签。然后它检查存储是否保留了所有具有给定标签的对象，并在请求时返回所有这些对象。'
- en: In other words, a persistence file is a multimap from string keys to object
    values.
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 换句话说，持久性文件是从字符串键到对象值的多元映射。
- en: Writing persistence code
  id: totrans-143
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 编写持久性代码
- en: 'Now that there are at least basic unit tests covering the persistence mechanism,
    it''s time to write the persistence code itself. The following goes in `planner/persistence.py`:'
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 现在至少有基本的单元测试覆盖了持久性机制，是时候编写持久性代码本身了。以下代码放在 `planner/persistence.py` 中：
- en: '[PRE35]'
  id: totrans-145
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: The `store_object` method runs a short SQL statement to store the object into
    a database field. The object serialization is handled by the `dumps` function
    from the `cPickle` module.
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: '`store_object` 方法运行一个简短的 SQL 语句将对象存储到数据库字段中。对象序列化由 `cPickle` 模块的 `dumps` 函数处理。'
- en: The `load_object` method uses SQL to query the database for the serialized version
    of every object stored under a given tag, and then uses `cPickle.loads` to transform
    those serializations into real objects for it to return.
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: '`load_object`方法使用SQL查询数据库以获取存储在给定标签下的每个对象的序列化版本，然后使用`cPickle.loads`将这些序列化转换为实际对象以返回。'
- en: 'Now I run Nose to find out what''s broken:'
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我运行Nose来找出什么出了问题：
- en: '![Writing persistence code](img/8846_07_05.jpg)'
  id: totrans-149
  prefs: []
  type: TYPE_IMG
  zh: '![编写持久化代码](img/8846_07_05.jpg)'
- en: 'I forgot that `sqlite` returns text data as unicode. Pickle is understandably
    unwilling to work with a Unicode string: it expects a byte string, and the correct
    way to interpret Unicode as a byte string is ambiguous. This can be solved by
    telling `sqlite` to store the pickled object as a BLOB (Binary Large Object).
    Modify the `store_object` and `load_objects` methods of `file` in `planner/persistence.py`:'
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 我忘记了`sqlite`返回的是Unicode文本数据。Pickle自然不愿意与Unicode字符串一起工作：它期望一个字节字符串，将Unicode解释为字节字符串的正确方式是不明确的。这可以通过告诉`sqlite`将序列化的对象存储为BLOB（二进制大对象）来解决。修改`planner/persistence.py`中`file`的`store_object`和`load_objects`方法：
- en: '[PRE36]'
  id: totrans-151
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: 'Now Nose is saying that the schedules class doesn''t have `store` and `load`
    methods, which is true. Furthermore, there aren''t any unit tests that check those
    methods... the only error is coming from the specification doctest. Time to write
    some more unit tests in `tests/test_schedules.py`:'
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，Nose表示`schedules`类没有`store`和`load`方法，这是真的。此外，没有单元测试检查这些方法...唯一的错误来自规范doctest。是时候在`tests/test_schedules.py`中编写更多的单元测试了：
- en: '[PRE37]'
  id: totrans-153
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: 'Now that I have some tests to check against, it''s time to write the `store`
    and `load` methods of the `schedules` class in `planner/data.py`:'
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我有一些测试可以检查，是时候在`planner/data.py`中编写`schedules`类的`store`和`load`方法了：
- en: '[PRE38]'
  id: totrans-155
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: Note
  id: totrans-156
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: The `@` `staticmethod` notation means that you can call `load` without first
    creating an instance of `schedules`. Notice that the `load` method does not receive
    a `self` parameter.
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: '`@` `staticmethod`符号表示你可以调用`load`而不必首先创建` schedules`的实例。注意，`load`方法不接收`self`参数。'
- en: 'The `@` syntax for function decorators was introduced in Python 2.4\. In earlier
    versions back to Python 2.2, you could instead write `load = staticmethod(load)`
    after the method definition, which means the same thing. Before Python 2.2, there
    was no `staticmethod` function: the easiest way to do static "methods" was to
    write one as a standalone function in the same module.'
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 函数装饰器的`@`语法是在Python 2.4中引入的。在Python 2.2之前的早期版本中，你可以在方法定义后写`load = staticmethod(load)`，这具有相同的意思。在Python
    2.2之前，没有`staticmethod`函数：实现静态“方法”的最简单方法是将其作为同一模块中的独立函数编写。
- en: This new bunch of tests and code allows us to save and restore schedules from
    files, and clears up most of the remaining test failures. The `planner` package
    is nearly finished!
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 这组新的测试和代码使我们能够从文件中保存和恢复计划，并消除了大多数剩余的测试失败。`planner`包几乎完成了！
- en: Finishing up
  id: totrans-160
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 完成工作
- en: Now, Nose only reports one failed test, the check to see whether the original
    `schedules` instance and the one loaded from the file are equal. The problem here
    is that, once again, there's a need to redefine what it means to be equal.
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，Nose只报告一个失败的测试，即检查原始`schedules`实例和从文件中加载的实例是否相等。这里的问题是，又一次，需要重新定义什么是相等。
- en: 'That can be fixed by adding the following to the definition of `schedules`
    in `planner/data.py`:'
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 可以通过在`planner/data.py`中` schedules`的定义中添加以下内容来修复这个问题：
- en: '[PRE39]'
  id: totrans-163
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: Note
  id: totrans-164
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: 'The `key` parameter of `sort` was added in Python 2.4\. Prior to that version,
    doing such a `sort` would have looked like `left_tasks.sort(cmp = (lambda t1,
    t2: cmp(t1.begins, t2.begins)))`.'
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: '`sort`的`key`参数是在Python 2.4中添加的。在那之前版本中，这样的`sort`看起来会像`left_tasks.sort(cmp =
    (lambda t1, t2: cmp(t1.begins, t2.begins)))`。'
- en: These methods define equality between schedules to be when they contain exactly
    the same tasks, and define inequality to be whenever they aren't equal (It may
    sound silly to have to define inequality that way, but it turns out that there
    actually are some situations where you'd want to define it differently).
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 这些方法定义了计划之间的相等性，即它们包含完全相同的任务，并定义不等性为它们不相等的情况（这样定义不等性可能听起来很愚蠢，但实际情况是确实有一些情况你可能希望以不同的方式定义它）。
- en: 'Now, the tests all pass. There''s something worth paying attention to though,
    in the way that they pass. Specifically, a couple of them are very slow. A little
    investigation reveals that the slow tests are the ones that deal with schedules
    that contain a larger number of tasks. That reveals something very important:
    the `schedules` implementation is now conformant with the tests and specifications,
    but it stores and organizes data in a naïve way, and so it doesn''t scale up well.'
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，所有的测试都通过了。不过，在它们通过的方式上，有一些值得注意的地方。具体来说，有几个测试非常慢。一点点的调查揭示，这些慢速测试是处理包含更多任务调度的情况的。这揭示了一个非常重要的事实：`schedules`实现现在符合测试和规范，但它以天真的方式存储和组织数据，因此扩展性不好。
- en: Now that there is a working implementation, well covered by unit tests, the
    time is ripe for optimization.
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 现在已经有了经过单元测试充分覆盖的工作实现，是时候进行优化了。
- en: Pop quiz – test-driven development
  id: totrans-169
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 快速问答——测试驱动开发
- en: I didn't follow unit testing discipline when I wrote my testable specification.
    What did I have to do because of that, which I wouldn't have had to do otherwise?
    Was it wrong to choose that path?
  id: totrans-170
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我在编写可测试规范时没有遵循单元测试的纪律。因为我这样做，我不得不做什么，否则我就不会这样做？选择这条路径是错误的吗？
- en: Is it desirable to minimize the number of times you run your tests?
  id: totrans-171
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 是否希望最小化你运行测试的次数？
- en: If you start writing code before you write any tests, what opportunities have
    you lost?
  id: totrans-172
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果你开始编写代码之前没有编写任何测试，你失去了哪些机会？
- en: Have a go hero
  id: totrans-173
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 来试试吧，英雄
- en: You worked through your own project, and we worked through a project together.
    Now it's time to try something completely on your own. I'll give you a little
    help coming up with a goal, but from there on out, it's your time to shine.
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 你完成了自己的项目，我们一起完成了一个项目。现在，是时候尝试完全独立的事情了。我会给你一点帮助来设定目标，但从那里开始，就轮到你了，展示你的才华。
- en: Note
  id: totrans-175
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: A `Skip list` is another dictionary-like data structure. You can find quite
    a bit of information about them on Wikipedia at [http://en.wikipedia.org/wiki/Skip_list](http://
    http://en.wikipedia.org/wiki/Skip_list). Using that information (and any other
    references you can find, if you feel like it) and the test-driven process, write
    your own skip list module.
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: '`跳表`是另一种类似于字典的数据结构。你可以在维基百科上找到很多关于它们的信息，网址是[http://en.wikipedia.org/wiki/Skip_list](http://en.wikipedia.org/wiki/Skip_list)。使用这些信息（以及你可以找到的任何其他参考资料，如果你愿意的话）和测试驱动的过程，编写你自己的跳表模块。'
- en: Summary
  id: totrans-177
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: In this chapter, we looked at how to apply the skills covered in earlier parts
    of this book. We did this by stepping through a recording of your humble author's
    actual process in writing a package. At the same time, you had the chance to work
    through your own project, making your own decisions, and designing your own tests.
    You've taken the lead in a test-driven project, and you should be able to do it
    again whenever you want.
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们探讨了如何应用本书前面部分介绍过的技能。我们通过回顾你谦逊的作者实际编写包的过程的录音来做到这一点。同时，你也有机会处理自己的项目，做出自己的决定，并设计自己的测试。你已经在一个测试驱动型项目中担任了领导角色，并且应该能够在任何时候再次这样做。
- en: Now that we've covered the heart of Python testing, we're ready to talk about
    testing web-based user interfaces with Python and Twill—which is the topic of
    the next chapter.
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经涵盖了Python测试的核心内容，我们准备讨论使用Python和Twill测试基于Web的用户界面——这是下一章的主题。
