- en: Chapter 7. Developing a Test-Driven Project
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '*In this chapter, we won''t talk about new techniques for testing in Python,
    neither will we spend much time talking about the philosophy of testing. Instead,
    what we''ll do is walk step-by-step through a record of an actual development
    process. Your humble and sadly fallible author has memorialized his mistakes—and
    the ways that testing helped him fix them—while developing part of a personal
    scheduling program.*'
  prefs: []
  type: TYPE_NORMAL
- en: 'In this chapter, we shall:'
  prefs: []
  type: TYPE_NORMAL
- en: Write a testable specification
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Write unit tests
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Write code that complies with the specification and unit tests
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Use the testable specification and unit tests to help debug
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: You'll be prompted to design and build your own module as you read through this
    chapter, so that you can walk through your own process as well.
  prefs: []
  type: TYPE_NORMAL
- en: Writing the specification
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: As usual, the process starts with a written specification. The specification
    is a doctest, (which we learned about in Chapters 2 and 3), so the computer can
    use it to check the implementation. The specification isn't strictly a set of
    unit tests though; the discipline of unit testing has been sacrificed (for the
    moment) in exchange for making the document more accessible to a human reader.
    That's a common trade-off, and it's fine as long as you make up for it by also
    writing unit tests covering the code.
  prefs: []
  type: TYPE_NORMAL
- en: The goal of the project is to make a Python package capable of representing
    personal time management information.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following code goes in a file called `docs/outline.txt`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'This doctest will serve as a testable specification for my project, which means
    that it will be the foundation stone on which all of my other tests (and my program
    code) will be built on. Let''s look at each section in more detail:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: The above code consists of some introductory English text and a couple of import
    statements that bring in code that we need for these tests. By doing so, they
    also tell us about some of the structure of the `planner` package. Specifically,
    they tell us that it contains a module called `data`, which defines activities
    and statuses.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: The above tests describe some of the desired behavior of `schedules` for `activities`
    and `statuses`. According to these tests, `schedules` must accept `activities`
    and `statuses` as parameters of its `add` and `remove` methods. Once they're added,
    the `in` operator must return `True` for an object until it is removed. Furthermore,
    two `activities` that have the same parameters must be treated as the same object
    by `schedules`.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: The above test code describes what should happen when overlapping activities
    are added to a schedule. Specifically, a `schedule_error` should be raised.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: 'The above test code describes what should happen when overlapping statuses
    are added to a schedule: the schedule should accept them. Furthermore, if a status
    and an activity overlap, they can still both be added.'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: The above code describes how schedule storage should work. It also tells us
    that the `planner` package needs to contain a `persistence` module, which in turn
    should contain `file`.
  prefs: []
  type: TYPE_NORMAL
- en: Time for action – what are you going to do?
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'It''s time for you to come up with a project of your own, something that you
    can work on by yourself; we step through the development process:'
  prefs: []
  type: TYPE_NORMAL
- en: Think of a project of approximately the same complexity as the one described
    in this chapter. It should be a single module or a few modules in a single package.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Imagine that the project is already done, and you need to write a description
    of what you've done, along with a little bit of demonstration code. Then go ahead
    and write your description and demo code in the form of a doctest file.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: As you're writing the doctest file, look out for places where your original
    idea has to change a little bit to make the demo easier to write, or work better.
    When you find such cases, pay attention to them! At this stage, it's better to
    change the idea a little bit and save yourself effort all through the process.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '*What just happened?*'
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: We've got testable specifications for moderately-sized projects, now. These
    will help us to write unit tests and code, and they'll give us a sense of how
    complete the project is, as a whole.
  prefs: []
  type: TYPE_NORMAL
- en: In addition, the process of writing code into the doctest gave us a chance to
    test-drive our ideas. We've probably improved our projects a little bit by using
    them in a concrete manner, even though the project implementation is still merely
    imaginary.
  prefs: []
  type: TYPE_NORMAL
- en: Once again, it's important that we have written these tests *before* writing
    the code that they will test. By writing the tests first, we give ourselves a
    touchstone that we can use to judge how well our code conforms to what we intended.
    If we write the code first, and then the tests, all we end up doing is enshrining
    what the code actually does—as opposed to what we meant for it to do—into the
    tests.
  prefs: []
  type: TYPE_NORMAL
- en: Writing initial unit tests
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Since the specification doesn't contain unit tests, there's still a need for
    unit tests before the coding of the module can begin. The `planner.data` classes
    are the first target for implementation, so they're the first ones to get tests.
  prefs: []
  type: TYPE_NORMAL
- en: Activities and statuses are defined to be very similar, so their test modules
    are also similar. They're not identical though, and they're not required to have
    any particular inheritance relationship, so the tests remain distinct.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following tests are in `tests/test_activities.py`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: 'Let''s take a look at each section of the above unit test code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: The `test_valid` method checks that the constructor works correctly when all
    of the parameters are correct. This is an important test, because it defines what
    correct behavior in the normal case should be. We need more tests though, to define
    correct behavior in abnormal situations.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: Here, we'll make sure that you can't create an activity that ends before it
    begins. That doesn't make any sense, and could easily throw off assumptions made
    during the implementation.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: We don't want extremely short activities either. In the real world, an activity
    that takes no time is meaningless, so we have a test here to make sure that such
    things are not allowed.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: While `repr(activity)` isn't likely to be used in any production code paths,
    it's handy during development and debugging. This test defines how the text representation
    of an activity should look, to make sure that it contains the desired information.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: Since activities are supposed to be exclusive of each other when they overlap,
    we check that here. The activity obviously overlaps with itself, so the `excludes`
    method should return `True`. On the other hand, an activity shouldn't just assume
    it excludes everything, so calling `excludes` on unknown objects (such as `None`)
    should return `False`.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: Here we created a test fixture that creates a mock object which pretends to
    be an activity or status. We'll use this mock object (called `self.other`) in
    several of the following tests.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: 'These tests describe the behavior of activity overlap checking in the cases
    where the activity:'
  prefs: []
  type: TYPE_NORMAL
- en: Comes after the mock object
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Overlaps the end of the mock object
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Overlaps the beginning of the mock object
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Starts after the mock object and ends before it
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Starts before the mock object and ends after it
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The following tests are in `tests/test_statuses.py`. Many of these are similar
    to the tests for `activities`. We''ll concentrate on the differences:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: There's one significant area of difference between this test file and the previous
    one, the `test_excludes` method.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: Unlike an activity, a status should never force itself to be exclusive with
    something else, so this test uses `assertFalse`, instead of `assertTrue` for the
    first assertion.
  prefs: []
  type: TYPE_NORMAL
- en: The following tests are in `tests/test_schedules.py`. We define several mock
    objects in the `setUp` method that behave as if they were `activities` or `statuses`.
    These mock objects simulate activities or statuses, and so by using them instead
    of real activities or statuses they allow us to check that the `schedules` class
    correctly handles events that either do or do not overlap, and that either do
    or do not exclude each other, all without actually using code from outside the
    unit being tested.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: Let's go over those tests section by section.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: 'We created four mock objects here: `overlap_exclude`, `overlap_include`, `distinct_exclude`,
    and d`istinct_include`. Each of them represents a different combination of behavior
    of its `overlaps` method and its `excludes` method. Between these four mock objects,
    we have every combination of overlapping or not overlapping, and excluding or
    not excluding. In the following tests, we''ll add various combinations of these
    mock objects to a schedule, and make sure it does the right things.'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: These four tests cover cases, where we add a non-overlapping object to a schedule.
    All of them are expected to accept the non-overlapping object, except the first.
    In that test, we've previously added an object that claims that it does indeed
    overlap, and furthermore it excludes anything it overlaps. That test shows that
    if either the object being added or an object already in the schedule believes
    there's an overlap, the schedule must treat it as an overlap.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: In this test, we'll make sure that if an object already in the schedule overlaps
    a new object and claims exclusivity, then adding the new object will fail.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: In this test, we'll make sure that even though the object already in the schedule
    doesn't think it overlaps with the new object, it excludes the new object because
    the new object thinks that there's an overlap.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: These tests make sure that inclusive objects don't somehow interfere with adding
    each other to a schedule.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: These two tests describe schedule behavior with respect to the `in` operator.
    Specifically, `in` should return `True` when the object in question is actually
    in the schedule.
  prefs: []
  type: TYPE_NORMAL
- en: Time for action – nailing down the specification with unit tests
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: A specification—even a testable specification written in doctest—is still home
    to a lot of ambiguities that can be ironed out with good unit tests. Add that
    to the fact that the specification doesn't maintain separation between different
    tests, and you can see that it's time for your project to gain some unit tests.
  prefs: []
  type: TYPE_NORMAL
- en: Find some element of your project which is described in (or implied by) your
    specification
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Write a unit test that describes the behavior of that element when given correct
    input
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Write a unit test that describes the behavior of that element when given incorrect
    input
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Write unit tests that describe the behavior of the element at the boundaries
    between correct and incorrect input
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Go back to step 1 if you can find another untested part of your program.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*What just happened?*'
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: It doesn't take many bullet points to describe the procedure, but this is an
    important process. This is where you really take what was an ill-defined idea
    and turn it into a precise description of what you're going to do.
  prefs: []
  type: TYPE_NORMAL
- en: The end result can be quite lengthy, which shouldn't come as much of a surprise.
    After all, your goal at this stage is to completely define the behavior of your
    project; and even without bothering yourself with the details of how that behavior
    is implemented, that's a lot of information.
  prefs: []
  type: TYPE_NORMAL
- en: Coding planner.data
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: It's time to write some code, using the specification document and the unit
    tests as guides. Specifically, it's time to write the `planner.data` module, which
    contains `statuses`, `activities`, and `schedules`.
  prefs: []
  type: TYPE_NORMAL
- en: I made a directory called `planner`, and within that directory created a file
    called `__init__.py`. There's no need to put anything inside `__init__.py`, but
    the file itself needs to exist to tell Python that the `planner` directory is
    a package.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following code goes in `planner/data.py`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: 'Let''s go over this section by section:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: The `_tasks` class here contains most of the behavior that is needed for both
    the `activities` and the `statuses` classes. Since so much of what they do is
    common to both, it makes sense to write the code once and reuse it. Only the `excludes`
    method needs to be different in each of the subclasses.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: Here we have the implementations of the classes that our tests actually require
    to exist. The `activities` and `statuses` classes are very simple, by virtue of
    inheriting from `_tasks`. The `schedules` class turns out to be pretty easy, too.
    But is it right? Our tests will tell us.
  prefs: []
  type: TYPE_NORMAL
- en: Using the tests to get the code right
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'All right, so that code looks fairly good. Unfortunately, Nose tells us there
    are a few problems. Actually, Nose reports quite a large number of problems, but
    the first ones needing to be fixed are shown below:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Using the tests to get the code right](img/8846_07_01.jpg)'
  prefs: []
  type: TYPE_IMG
- en: The reason for focusing on those errors, when we have so many to choose from,
    is simple. A lot of the other errors seem to be derived from these. The unit tests
    also report problems with exclude, so we know that one isn't derived from some
    other error—remember that unit tests aren't influenced by each other, unlike the
    tests in our specification.
  prefs: []
  type: TYPE_NORMAL
- en: Fixing the code
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'To fix the first error, add the following code to the `_tasks` class in `planner/data.py`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: (Beware of the wrapped line in `__eq__`)
  prefs: []
  type: TYPE_NORMAL
- en: As you can probably tell, that code overrides the equality comparison between
    two `_tasks`, declaring them to be equal if they have the same name, begin time
    and end time. That's the equality metric that's implicitly assumed by the test
    code.
  prefs: []
  type: TYPE_NORMAL
- en: 'The second error can be fixed by fixing the typographical errors in `schedules.add`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: In this case, we changed the incorrect method name `exclude` to the correct
    method name `excludes`. (Again, watch out for wrapped lines)
  prefs: []
  type: TYPE_NORMAL
- en: 'So now, I run Nose again and it breaks:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Fixing the code](img/8846_07_02.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Fortunately, this is an easy fix: take out the extra ''e'' in ''contained'':'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: For the skeptical reader, I'm compelled to admit that, yes, that typo really
    did slip by until the test caught it. Sometimes tests catch boring mistakes instead
    of dramatic problems, typos instead of logic errors. It doesn't really matter,
    because either way the test is helping you make your code more solid, more reliable,
    and better.
  prefs: []
  type: TYPE_NORMAL
- en: 'So now, when I run Nose it breaks:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Fixing the code](img/8846_07_03.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Okay, fine, this is easy to fix too. The error is just formatted wrongly. Fix
    that by replacing the ''raise'' in `schedules.add`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: 'This time when I run Nose, it tells me that my unit test is broken:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Fixing the code](img/8846_07_04.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Specifically, it''s telling me that my mockups of `activities` and `statuses`
    are missing the `name` attribute. This too is simply fixed by changing the `setUp`
    method of `add_tests` in `tests/test_schedules.py`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: Having fixed that, Nose still reports errors, but all of them have to do with
    persistence. Those errors aren't surprising, because there's no persistence implementation
    yet.
  prefs: []
  type: TYPE_NORMAL
- en: Time for action – writing and debugging code
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The basic procedure (as we've discussed before), is to write some code and run
    the tests to find problems with the code, and repeat. When you come across an
    error that isn't covered by an existing test, you write a new test and continue
    the process.
  prefs: []
  type: TYPE_NORMAL
- en: Write code that ought to satisfy at least some of your tests
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Run your tests. If you used it when we talked about it in previous chapters,
    you should be able to run everything simply by executing:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: If there are errors in the code you've already written, use the test output
    to help you locate and identity them. Once you understand the bugs, try to fix
    them and then go back to step 2.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Once you've fixed all the errors in the code you've written, and if your project
    isn't complete, choose some new tests to concentrate on and go back to step 1.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '*What just happened?*'
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Enough iterations on this procedure leads you to having a complete and tested
    project. Of course, the real task is more difficult than simply saying "it will
    work," but in the end, it will work. You will produce a codebase that you can
    be confident in. It will also be an easier process than it would have been without
    the tests.
  prefs: []
  type: TYPE_NORMAL
- en: Your project may be done, but there's still more to do on the personal scheduler.
    At this stage of the chapter, I haven't finished going through the writing and
    debugging process. It's time to do that.
  prefs: []
  type: TYPE_NORMAL
- en: Writing persistence tests
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Since I don''t have any actual unit tests for the persistence code yet, I''ll
    start off by making some. In the process, I have to figure how persistence will
    actually work. The following code goes in `tests/test_persistence.py`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: 'Looking at each of the important sections of the test code, we see the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: The `test_basic` test creates a `storage`, stores a single object under the
    name `tag1`, and then loads that object back from storage and checks that it is
    equal to the original object.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs: []
  type: TYPE_PRE
- en: The `test_multiple_tags` test creates a storage, and then stores multiple objects
    in it, some with duplicate tags. It then checks that the storage keeps all of
    the objects with a given tag, and returns all of them on request.
  prefs: []
  type: TYPE_NORMAL
- en: In other words, a persistence file is a multimap from string keys to object
    values.
  prefs: []
  type: TYPE_NORMAL
- en: Writing persistence code
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Now that there are at least basic unit tests covering the persistence mechanism,
    it''s time to write the persistence code itself. The following goes in `planner/persistence.py`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs: []
  type: TYPE_PRE
- en: The `store_object` method runs a short SQL statement to store the object into
    a database field. The object serialization is handled by the `dumps` function
    from the `cPickle` module.
  prefs: []
  type: TYPE_NORMAL
- en: The `load_object` method uses SQL to query the database for the serialized version
    of every object stored under a given tag, and then uses `cPickle.loads` to transform
    those serializations into real objects for it to return.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now I run Nose to find out what''s broken:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Writing persistence code](img/8846_07_05.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'I forgot that `sqlite` returns text data as unicode. Pickle is understandably
    unwilling to work with a Unicode string: it expects a byte string, and the correct
    way to interpret Unicode as a byte string is ambiguous. This can be solved by
    telling `sqlite` to store the pickled object as a BLOB (Binary Large Object).
    Modify the `store_object` and `load_objects` methods of `file` in `planner/persistence.py`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs: []
  type: TYPE_PRE
- en: 'Now Nose is saying that the schedules class doesn''t have `store` and `load`
    methods, which is true. Furthermore, there aren''t any unit tests that check those
    methods... the only error is coming from the specification doctest. Time to write
    some more unit tests in `tests/test_schedules.py`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE37]'
  prefs: []
  type: TYPE_PRE
- en: 'Now that I have some tests to check against, it''s time to write the `store`
    and `load` methods of the `schedules` class in `planner/data.py`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE38]'
  prefs: []
  type: TYPE_PRE
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The `@` `staticmethod` notation means that you can call `load` without first
    creating an instance of `schedules`. Notice that the `load` method does not receive
    a `self` parameter.
  prefs: []
  type: TYPE_NORMAL
- en: 'The `@` syntax for function decorators was introduced in Python 2.4\. In earlier
    versions back to Python 2.2, you could instead write `load = staticmethod(load)`
    after the method definition, which means the same thing. Before Python 2.2, there
    was no `staticmethod` function: the easiest way to do static "methods" was to
    write one as a standalone function in the same module.'
  prefs: []
  type: TYPE_NORMAL
- en: This new bunch of tests and code allows us to save and restore schedules from
    files, and clears up most of the remaining test failures. The `planner` package
    is nearly finished!
  prefs: []
  type: TYPE_NORMAL
- en: Finishing up
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Now, Nose only reports one failed test, the check to see whether the original
    `schedules` instance and the one loaded from the file are equal. The problem here
    is that, once again, there's a need to redefine what it means to be equal.
  prefs: []
  type: TYPE_NORMAL
- en: 'That can be fixed by adding the following to the definition of `schedules`
    in `planner/data.py`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE39]'
  prefs: []
  type: TYPE_PRE
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'The `key` parameter of `sort` was added in Python 2.4\. Prior to that version,
    doing such a `sort` would have looked like `left_tasks.sort(cmp = (lambda t1,
    t2: cmp(t1.begins, t2.begins)))`.'
  prefs: []
  type: TYPE_NORMAL
- en: These methods define equality between schedules to be when they contain exactly
    the same tasks, and define inequality to be whenever they aren't equal (It may
    sound silly to have to define inequality that way, but it turns out that there
    actually are some situations where you'd want to define it differently).
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, the tests all pass. There''s something worth paying attention to though,
    in the way that they pass. Specifically, a couple of them are very slow. A little
    investigation reveals that the slow tests are the ones that deal with schedules
    that contain a larger number of tasks. That reveals something very important:
    the `schedules` implementation is now conformant with the tests and specifications,
    but it stores and organizes data in a naïve way, and so it doesn''t scale up well.'
  prefs: []
  type: TYPE_NORMAL
- en: Now that there is a working implementation, well covered by unit tests, the
    time is ripe for optimization.
  prefs: []
  type: TYPE_NORMAL
- en: Pop quiz – test-driven development
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: I didn't follow unit testing discipline when I wrote my testable specification.
    What did I have to do because of that, which I wouldn't have had to do otherwise?
    Was it wrong to choose that path?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Is it desirable to minimize the number of times you run your tests?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: If you start writing code before you write any tests, what opportunities have
    you lost?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Have a go hero
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: You worked through your own project, and we worked through a project together.
    Now it's time to try something completely on your own. I'll give you a little
    help coming up with a goal, but from there on out, it's your time to shine.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: A `Skip list` is another dictionary-like data structure. You can find quite
    a bit of information about them on Wikipedia at [http://en.wikipedia.org/wiki/Skip_list](http://
    http://en.wikipedia.org/wiki/Skip_list). Using that information (and any other
    references you can find, if you feel like it) and the test-driven process, write
    your own skip list module.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we looked at how to apply the skills covered in earlier parts
    of this book. We did this by stepping through a recording of your humble author's
    actual process in writing a package. At the same time, you had the chance to work
    through your own project, making your own decisions, and designing your own tests.
    You've taken the lead in a test-driven project, and you should be able to do it
    again whenever you want.
  prefs: []
  type: TYPE_NORMAL
- en: Now that we've covered the heart of Python testing, we're ready to talk about
    testing web-based user interfaces with Python and Twill—which is the topic of
    the next chapter.
  prefs: []
  type: TYPE_NORMAL
