- en: RESTful API Design Tips
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Enterprise-scale applications across industry verticals are being increasingly
    built as a collection of polyglot microservices. Due to the surging popularity
    of the **microservices architecture** (**MSA**) as the most optimized and organized
    application architecture, most business-critical applications are being meticulously
    designed, developed, and deployed as a set of independent, yet interactive, microservices.
    Another noteworthy trend is the tremendous success of REST APIs for services and
    applications. All kinds of applications (operational, transactional, and analytical)
    are being fitted with REST APIs in order to simplify application integration.
    Further down the line, web, cloud, mobile, and IoT applications are being stuffed
    with REST APIs.
  prefs: []
  type: TYPE_NORMAL
- en: Modern application platforms for design, development, debugging, delivery, deployment,
    and decommissioning purposes are also attached to REST APIs. Integration, orchestration,
    governance, brokerage, compliance, and management platforms are being exposed
    to the outside world through REST APIs. Because of its simplicity and lightweight
    nature, the REST paradigm has captured both minds and market share in large quantities.
    Precisely speaking, every worthwhile microservice, application, and platform is
    being frontended with a REST interface. Without a shred of doubt, RESTful APIs
    have become penetrative, pervasive, and persuasive. That is, RESTful APIs play
    a vital role in building and integrating applications.
  prefs: []
  type: TYPE_NORMAL
- en: This chapter is dedicated to discussing the design patterns and best practices
    to build competent and compatible REST APIs that can easily cope with technological
    and business changes.
  prefs: []
  type: TYPE_NORMAL
- en: 'This chapter will deal with the following topics:'
  prefs: []
  type: TYPE_NORMAL
- en: Articulating the importance of APIs
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Accentuating API design patterns and best practices
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Enumerating API security guidelines
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Explaining the various tools and platforms associated with API design, development,
    integration, security, and management
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Tending toward the API-driven digital world
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Technical requirements
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: This chapter details the various best practices for designing efficient RESTful
    APIs. Readers are expected to have some knowledge of, and basic programming experience
    in, the REST architectural style in order to fully grasp and implement the best
    practices discussed in this chapter.
  prefs: []
  type: TYPE_NORMAL
- en: Beginning with APIs
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The concept of the **application pr****ogramm****ing interface** (**API**) is
    gaining dominance due to its significant contribution toward exposing any application
    or service to the outside world to find and use its unique business and technical
    competencies. To enable application, service, and data integration, APIs are being
    widely recognized as the way forward. Data gets exchanged between different applications
    and services. There are mandates for bringing forth highly integrated systems.
    This means that a variety of third-party applications and backend systems have
    to be systematically integrated. The middleware solutions, in the form of enterprise
    application hubs, enterprise service buses, message brokers and queues, API gateways
    and management suites, and service meshes, are seeing significant utilization
    toward local as well as remote application integration. All these integration
    engines are being fitted with well-intended and -designed APIs.
  prefs: []
  type: TYPE_NORMAL
- en: As we all know, the device ecosystem grows rapidly with the availability of
    scores of slim and sleek, handy and trendy, and purpose-agnostic, as well as specific,
    devices in large quantities; that is, connected devices are increasingly participating
    in mainstream computing. Here, too, the contributions of APIs for enabling devices,
    data sources, and services toward data and logic exchange are growing steadily.
    APIs hide the heterogeneity and multiplicity of devices to the outside world.
    That is, every device is expressed and exposed as a service, and every service
    is getting partitioned into an interface and implementation. This segregation
    goes a long way in maintaining up devices for longer periods of time. When it
    comes to dynamically equipping devices with additional capabilities, APIs are
    indispensable.
  prefs: []
  type: TYPE_NORMAL
- en: In short, an API is a kind of a messenger that receives and processes requests
    and ensures it runs enterprise systems successfully. Social networking sites,
    such as Facebook and Twitter, are a few of the companies that use open or public
    APIs for the benefit of their business. A start-up can open its APIs in order
    to enable third-party software to use its software. For an integrated world, setting
    up, composing, securing, controlling, and enhancing APIs becomes paramount for
    global enterprises in showcasing their distinct capabilities to their customers,
    partners, and employees. With digital technologies taking center stage in the
    IT world, the elegance of APIs is assuming top spot.
  prefs: []
  type: TYPE_NORMAL
- en: Learning about application programming interfaces
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: According to accomplished experts, an API is a set of rules and tools for initiating
    and governing how business workloads interact. Now, with the faster proliferation
    of the cloud, the interaction level has gone up and beyond business applications.
    That is, scores of IT optimization and automation services also have to interact
    with one another in order to simplify and streamline business-process automation.
    APIs have to uniquely and uniformly find one another, initiate data interchange,
    and verify information for software applications to leverage one another for their
    business benefits. Let's use a few comparisons to explain APIs and their roles
    and responsibilities in our increasingly connected world.
  prefs: []
  type: TYPE_NORMAL
- en: If applications were vehicles on the road, APIs would be the traffic rules.
    The rules prescribe how vehicles must behave on the road.
  prefs: []
  type: TYPE_NORMAL
- en: If applications were food items, APIs would be recipes. APIs specify and govern
    how various ingredients fuse together to create tasty and trendy meals.
  prefs: []
  type: TYPE_NORMAL
- en: If applications were houses, APIs would be the blueprint, which articulate how
    different construction artifacts blend to form a house.
  prefs: []
  type: TYPE_NORMAL
- en: Why have APIs become a mainstream concept?
  prefs: []
  type: TYPE_NORMAL
- en: Having understood the crucial roles of APIs in our increasingly software-defined
    and -designed world, faster API production becomes a crucial task for API developers.
    That is, forming appropriate rules for the intended success of the APIs is vital.
    API designers create and publish APIs, which allow other applications to find
    and interact with them.
  prefs: []
  type: TYPE_NORMAL
- en: Suppose you are exposing one or more customer-facing web and mobile applications
    that run on cloud environments. These applications are diligently being fitted
    with one or more APIs. Now, having API-attached applications enables other developers
    to build their own applications that can easily be integrated with the web and
    mobile applications. This integration makes applications bigger and better. Implementing
    business processes becomes easier, faster, risk-free, and rewarding. The customer
    experience with the omni-channel aggregation capability goes up significantly.
    There's no need for a web-scale company to devise and design APIs. Even for an
    idea, an application gets built and decorated with a simple API. Application developers
    are becoming accustomed to creating and sustaining APIs in order to expose their
    applications to a larger audience.
  prefs: []
  type: TYPE_NORMAL
- en: As we've emphasized several times, application integration becomes simpler with
    APIs. There were other options for enterprise integration, but they were insufficient
    in many ways. APIs have emerged as the standard for process integration. When
    an API designer releases an officially accepted and clearly defined set of rules,
    others can confidently embark on API-inspired application and platform integration.
    Thus, APIs provide fresh possibilities and opportunities. APIs grant developers
    the requisite power to control not only what others can do with their applications,
    but also prescribe what others can't do with their applications.
  prefs: []
  type: TYPE_NORMAL
- en: APIs have become indispensable
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Path-breaking technologies are emerging and evolving fast toward digital innovation,
    disruption, and transformation. A variety of breakthroughs are being unearthed
    and popularized in order to bring in a variety of acceleration, automation, and
    augmentation in IT and business spaces. We are being bombarded with a number of
    application architectures, ranging from **service-oriented architecture** (**SOA**),
    **event-driven architecture** (**EDA**), and **resource-oriented architecture**
    (**ROA**) to MSA. Containers have become the default runtime for services. Cloud
    servers are being expressed and exposed as a collection of containers. With the
    surging popularity of container-orchestration platforms, creating container clusters
    and using them to run software applications and services has become the most prominent
    way to develop, deploy, and manage software. The cool convergence, as explained
    elsewhere in this book, between containers and microservices has propelled the
    next generation of application delivery. Each microservice is being fitted with
    one or more APIs. Further on, each microservice has its own data store. For data
    security and effective data management, each database is also being given an API
    to perform data operations with confidence and clarity.
  prefs: []
  type: TYPE_NORMAL
- en: The other prominent advancements are the faster proliferation of cloud environments
    and the fact that each cloud center is being stuffed with thousands of applications
    and platforms. Cloud-hosted platforms enable third-party application developers
    not only to develop newer applications, but also facilitate a seamless and spontaneous
    integration with their applications. As we are heading toward federated cloud
    environments to create composite applications, APIs emerge as the most crucial
    entity toward fulfilling the fast-emerging multi-cloud idea. **Device-to-device**
    (**D2D**), **device-to-cloud** (**D2C**), and **cloud-to-cloud** (**C2C**) integration
    gets facilitated through APIs.
  prefs: []
  type: TYPE_NORMAL
- en: Learning about the major types of APIs
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: There are a few API types. **Remote procedure call** (**RPC**) is the one that
    enables applications to call one or more functions in other applications remotely.
    XML and JSON are the content types and there are RPC APIs for both XML and JSON.
    In the web services world, SOAP has been ruling the world with a number of standard
    specifications for different purposes. But then, due to the extreme complexity,
    the adoption rate has come down sharply. Now, with the lightweight REST architectural
    style, every service, application, platform, middleware, and database is exposing
    RESTful APIs.
  prefs: []
  type: TYPE_NORMAL
- en: Describing API platforms
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Considering the importance of APIs for the forthcoming digital era, tool and
    product vendors have come out with a variety of integrated platforms to enable
    API life cycle activities. The following sections discuss different platform solutions
    that empower the API world.
  prefs: []
  type: TYPE_NORMAL
- en: Creating API development platforms
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: There are several ways to produce high-quality APIs. Creating new APIs from
    the ground up, refurbishing the existing ones, and automatically generating APIs
    out of currently-running integration are the well-known ways. Here, we need platform
    support to create APIs in other ways. There are API design and integration platforms
    available for accomplishing this need. We now have thousands of **software as
    a service** (**SaaS**) applications being delivered through cloud environments.
    These services are generally API-attached. These APIs can be reused across. However,
    these APIs could be limited in their functionality. Thus, APIs have to be customized
    and enhanced in order to fulfill our requirements. Building fresh APIs from scratch
    is time-consuming and error-prone. Freshly-built APIs have to go through several
    iterations in order to be categorized as reasonably stable and mature.
  prefs: []
  type: TYPE_NORMAL
- en: However, with high-end API design and integration platforms, it's possible to
    speed up the creation of APIs from an existing integration with a few clicks.
    This way, we aren't discarding the functioning applications and can save a lot
    of time by leveraging the existing investments. That is, API platforms enhance
    the **return on investment** (**RoI**).
  prefs: []
  type: TYPE_NORMAL
- en: 'Typically, the client-side team designs and develops the application, the server-side
    team readies the backend IT infrastructure for application deployment, and the
    testing team is mandated to test client as well as server-side output. These teams
    should work in a collaborative manner to develop a REST API for the project:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/de6a4d80-b000-4838-98c7-db4a2c0629fb.png)'
  prefs: []
  type: TYPE_IMG
- en: REST APIs are changing frequently with the insights being put forward by business
    consumers, partners, and employees. These changes have to be incorporated into
    the APIs and their mapped services. This definitely takes up time and, hence,
    the time-to-market is bound to increase. In order to accelerate and augment the
    REST API design, development, documentation, and testing, a number of automated
    solutions are available that enhance team collaboration substantially.
  prefs: []
  type: TYPE_NORMAL
- en: '**RestCase** is a cloud-based API development platform. This unique platform
    empowers developers to collaboratively create REST APIs. This enablement is being
    achieved through a number of distinct platform modules. The key modules include
    an intuitive browser-based interface, which automatically generates documentation,
    tests, and mocks. This platform enables rapid iterations and testing by creating
    a mock of the API.'
  prefs: []
  type: TYPE_NORMAL
- en: In order for development teams to work with QA and operation teams, the API
    development platform comes to the rescue. This platform helps development teams
    to build better APIs with ease. Developers' productivity goes up significantly
    when they are being empowered through an API-development platform. The development
    time and costs will come down. The API platform increases innovation through sharing
    and collaboration with the distributed research and development teams.
  prefs: []
  type: TYPE_NORMAL
- en: API-integration platforms
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We are steadily moving toward the digital era. Everyday objects are being empowered
    with digitization and edge technologies in order to become digital. That is, everything
    in our everyday environments becomes computational, communicative, sensitive,
    responsive, and active. Every digital artifact is being fitted with an appropriate
    API to be publicly found, network-accessible, and easily usable. For simplifying
    API integration, the most competent solution is API integration platforms. There
    are several use cases being mentioned by integration experts and architects as
    to why enterprises should adopt API-integration platforms.
  prefs: []
  type: TYPE_NORMAL
- en: With the emergence of cloud environments as the one-stop IT solution for all
    kinds of business offerings and operations, it's projected that in the years ahead,
    most enterprise, personal, mobile, and web applications will reside in clouds
    (public, private, hybrid, and edge). The popular enterprise-grade applications
    are **enterprise resource planning** (**ERP**), **supply chain management** (**SCM**),
    knowledge and content management, HR, finance and facility management, and asset
    management. Besides, all kinds of operational, transactional, and analytical applications
    are also being modernized and migrated to cloud environments in order to reap
    the benefits (user, technical, and business) of the cloud.
  prefs: []
  type: TYPE_NORMAL
- en: Thus, it's becoming mandatory for IoT devices, desktop, wearable, and smartphone
    applications to connect with cloud applications and databases. Cloud applications,
    platforms, and infrastructures are predominantly API-enabled. That is, D2D, D2C,
    and C2C integration requirements grow sharply in the extremely connected world.
    To gain best-in-class applications, the role of API integration platforms is simply
    awe-inspiring.
  prefs: []
  type: TYPE_NORMAL
- en: Legacy integration
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We've inherited a lot from the mainframe era. We have a number of legacy applications
    running in various industry verticals. Banking applications are still running
    legacy code. No one can dispute that the mainframe computer gives the highest
    performance. Typically, legacy applications follow the monolithic architecture.
    Also, legacy applications are massive. There are several other drawbacks associated
    with the legacy era. Still, due to their unique capabilities, enterprises are
    pretty slow to modernize their legacy investments. This encourages to bring an
    integration pipeline between modern and legacy applications. Legacy systems carry
    and store a lot of business transaction data. The API-integration platform enables
    data integration. That is, data can be extracted, transformed, and loaded into
    databases and warehouses associated with, and attached to, new applications. To
    produce and sustain integrated systems, it's mandatory to get and use legacy data.
    API-integration platforms are handy for this persisting need.
  prefs: []
  type: TYPE_NORMAL
- en: API integration platforms facilitate the formation of composite applications.
    With MSA becoming the shrewdest choice of application architectures, composing
    (through orchestration, choreography, or hybrid methods) is an important job for
    producing process-aware and business-critical applications. As we all know, every
    microservice exposes an API. Thus, to combine multiple microservices to produce
    composite applications, the contributions of API integration platforms are manifold.
  prefs: []
  type: TYPE_NORMAL
- en: 'API integration platforms ensure faster cloud adoption and future-proof enterprise
    integration. You need an API-integration platform to future-proof enterprise integration.
    The following is forecast in years to come:'
  prefs: []
  type: TYPE_NORMAL
- en: Millions of software services
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Billions of connected devices
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Trillions of digitized artifacts
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: As every physical, mechanical, electrical, and electronic system is fitted with
    APIs and presented as services, the adoption of API integration platform solutions
    is bound to escalate in the years to come.
  prefs: []
  type: TYPE_NORMAL
- en: API management platforms
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: As businesses build enterprise and mobile applications for their end users,
    partners, and employees, APIs are becoming indispensable. Applications have to
    perform well over any kind of network. APIs provide design time and runtime access
    to data services hosted in cloud infrastructures. Enterprises are predominantly
    transactional. Increasingly, mobile commerce and business applications are transactional.
    Thus, we need API management platforms in order to precisely manage APIs.
  prefs: []
  type: TYPE_NORMAL
- en: 'We have discussed the various features and needs for API development and integration
    platforms, and how they assist software developers and integrators in arriving
    at integrated systems with confidence and clarity. Now, we are moving toward API
    management and its automation through management platforms. Generally, API management
    is all about designing high-quality APIs, and then publishing and analyzing them
    in order to continuously track their usage. There can be both internal as well
    as external-looking APIs, which have to be search-friendly and consumable. As
    the world is tending toward embracing the API economy, there are several products
    and platforms that simplify and streamline API-management activities. The primary
    purposes of an API-management solution are as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '**API design**: API-management solutions empower developers and external parties
    with all the requisite knowledge and capability to design, produce, and deploy
    APIs. Further down the line, it helps in making API documents, and setting security
    policies, service levels, and runtime capabilities.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**API gateway**: We have allocated a separate chapter to describe the various
    functionalities of API gateways and how microservices benefit through the leveraging
    of API gateway solutions. These days, API-management solutions are also empowered
    to contribute as an API gateway, which is a centralized and clustered frontend
    for any service user to leverage distributed microservices. API gateways function
    as a gatekeeper for all downstream APIs and regulate service interactions in a
    secure manner.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**API store**: APIs should be stored in a centralized place so that internal
    and external users can leverage them. Thus, as service marketplaces, API marketplaces
    are evolving fast.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**API analytics**: With the heightened usage of APIs, it''s important to track
    key metrics, such as API usage, transactions, and performance. Capturing this
    decision-enabling and value-adding data, and processing it, helps to extract useful
    insights to improve service quality.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The end-to-end API life cycle activities (authentication, provisioning roles
    for users, policy establishment and enforcement, rate limiting of user requests,
    API data analytics, and monitoring) are being taken care of by management platform
    solutions. These solutions also enable and enhance API consumption by developers,
    external parties, and employees. API documentation is also being automated. The
    API-management suite uses caching to lessen the load on services. API log, operational,
    performance, scalability, and security data gets collected and subjected to a
    variety of investigations through the API analytics feature in order to understand
    the service state so we can perform tuning. Almost all enterprises are embracing
    APIs in order to be online and strive for improved market reach. Further on, the
    API catalogue is being published in the company portal. The versatile solution
    is to deploy API-management platforms to substantially increase business agility
    and adaptability.
  prefs: []
  type: TYPE_NORMAL
- en: APIs have to be artistically architected. APIs aren't just to enable every software
    package to have a frontend toward integration, they have to be extremely user-friendly.
    API endpoints have to be easy to understand and use for performing basic tasks.
    APIs are expected to remarkably enhance developers' productivity. Learning design
    patterns has to be fast and easy in order to empower developers to create well-designed
    APIs. APIs have to be designed to be long-lasting. That is, API consistency has
    to be ensured. API quality also has to be seriously verified and validated, otherwise,
    defective APIs waste a lot of time for developers. Both API providers and consumers
    demand top-quality APIs. With automated tools for API design, deployment, and
    management, better and more consistent results are being realized by enterprises
    across the globe.
  prefs: []
  type: TYPE_NORMAL
- en: APIs have shown glimpses of successes and are used to fulfil application integration,
    which has been a hassle for business-enterprise IT teams. APIs are positioned
    as the proven way forward for all kinds of integration requirements. Besides web
    and cloud enablement, the process of mobile enablement is gaining a lot of mind
    and market shares in order to provide any time, anywhere, any device, and any
    network information and service access. APIs have to be designed not only to tackle
    currently available devices, but also futuristic devices. There are a number of
    artistically designed I/O devices hitting the market consistently. Every connected
    device and clustered infrastructure, besides software systems, is being enabled
    by attaching efficient and extensible APIs in order to be found and bound to create
    business value.
  prefs: []
  type: TYPE_NORMAL
- en: There are a multitude of techniques and tools you can use to speed up API-based
    integration in a risk-free and rewarding manner. As previously discussed, we have
    integrated platform solutions (open source as well as commercial-grade) aplenty
    toward the API economy. These platforms intrinsically guarantee the quality of
    the APIs being produced and used. The quality is mandated to attain the benefits
    of the API phenomenon.
  prefs: []
  type: TYPE_NORMAL
- en: Demystifying the RESTful services paradigm
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: This book takes a deep dive into RESTful services and APIs. Despite being simple,
    REST is a fully-featured architectural style. Producing, exposing, and sustaining
    high-quality RESTful APIs to achieve smooth functional integration is a crucial
    yet challenging job for IT professionals. Predominantly, REST is implemented with
    the HTTP protocol. However, REST is not tied to HTTP alone. REST APIs are implemented
    for a *resource*,and the resource can be an entity or a service. These APIs provide
    a way to identify a resource by its URI. URIs can be used to transfer the current
    state of a resource representation. APIs can be represented as a set of endpoints
    stuffed with verbs and nouns. A verb typically represents an action, such as get,
    put, or delete, while the nouns indicate arguments appropriate to the action.
    It's always a good practice to have a mechanism to communicate error messages
    and successful execution. APIs have to clearly articulate their services and parameters
    in order to lessen developer errors. The error messages also have to be comprehensive
    in order to unambiguously convey what's happening to the end users.
  prefs: []
  type: TYPE_NORMAL
- en: With the widespread usage of the service paradigm, there has been a surge popularity
    for RESTful services, which are quite lightweight compared to SOAP services. Service-oriented
    application development and assembly have become the *de facto* standard in software
    engineering. For developing and deploying internet applications, leveraging RESTful
    services as application components has grown sharply. RESTful applications and
    services are fitted with compatible and competent APIs. RESTful services bring
    up the much-needed agility, adaptability, and simplicity for application development.
    APIs have become so common across IT services and business workloads. In addition,
    APIs are the most common elements for software infrastructure, middleware solutions,
    integration servers, containerization platforms, and backend database systems.
    APIs come as a standardization mechanism for enterprise applications to interact
    in a consistent and cognitive manner.
  prefs: []
  type: TYPE_NORMAL
- en: Due to the phenomenal growth of cloud-native and enabled applications, there
    is a need to establish a seamless and spontaneous link between enterprise and
    personal applications with cloud-hosted applications and data sources. Here, the
    REST paradigm scores well over other options. We have a bevy of programming and
    scripting languages for the client- and server-side applications. Not only desktop
    and laptop computers, but also handhelds, wearable, portables, nomadic, wireless,
    and mobile devices are becoming integrated with web applications. The environments
    become highly complicated and heterogeneous. Also, many devices and services have
    to collaborate to fulfill business processes. The REST paradigm comes to the rescue
    here. The REST concept is an abstraction for running web applications on different
    environments, such as Windows or Linux.
  prefs: []
  type: TYPE_NORMAL
- en: RESTful services guarantee the much-needed flexibility to host and run applications
    coded using different programming languages and platforms. Heterogeneous applications
    are being enabled to interoperate with one another through the power of RESTful
    services. Devices are being exposed as device services, which are being frontended
    with a RESTful API. Another widespread trend is that cloud applications are REST
    API-driven. Not only resource-intensive systems, but also resource-constraint
    embedded devices, are benefitting from the RESTful services paradigm in order
    to be connected. There are several device-centric communication and data transmission
    protocols, and the REST phenomenon is using them to become the favorite of service
    developers and users. There are several constraints imposed on this service implementation
    concept in order to be hugely benevolent for a number of usage scenarios.
  prefs: []
  type: TYPE_NORMAL
- en: Characterizing the REST architecture style
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: First and foremost, the REST paradigm is an architectural pattern. There were
    a number of design patterns published by experts in order to design and develop
    RESTful services. There are integration and deployment patterns for the quick
    realization of the pioneering REST paradigm.
  prefs: []
  type: TYPE_NORMAL
- en: 'The REST paradigm is compliant with the famous RoA pattern. The application
    state and functionality are methodically divided into distributed resources. These
    resources are available online and, hence, each resource can be accessed and used
    with the ubiquitous HTTP commands (`GET`, `PUT`, `POST`, and `Delete`). If we
    want to put a file in a file server, we need to use `PUT` or `POST`. If we want
    to get a file from the server, we can use the `GET` command. If we want to delete
    the file, the `DELETE` command is our go-to option. The REST architecture, is
    as usual, client-server and layered. It supports caching on the client side. Also,
    REST applications are stateless. This means they don''t store the state of the
    application. The distinct characteristics are explained as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Client-server**: The client can be anything that sends a service request
    to the server. The server side will host a RESTful service, which provides the
    business functionality to the client.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Stateless**: The server doesn''t store the client session information. Clients
    have to share all the required details with the server to get the appropriate
    answer. That is, RESTful services are self-defined, self-contained, autonomous,
    highly scalable, and performing.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Cache**: As the server doesn''t store the client information, it''s the responsibility
    of clients to keep all the relevant information. Thus, the concept of the cache
    has emerged and become popular. Sometimes, the client sends the same request to
    the server again. As REST services are independent, the client would get the same
    response. In order to reduce network traffic, the idea of a cache got introduced
    on the client side. The speed of getting the service response is quicker here
    as the cache is storing the previous response and the cache is positioned on the
    client side.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Caching** is all about storing copies of frequently-accessed data in several
    locations along the client and server route. Typically, a client request gets
    passed to the server on the other side of the world. However, a series of caches
    are being incorporated between client and server components. That is, the request
    first knocks the local cache at the client side, and then the reverse proxy at
    the server side. If any of the caches have the latest resource representation,
    it can be used by the client. If not, the request will be sent to the server component
    to fetch the latest information.'
  prefs: []
  type: TYPE_NORMAL
- en: '**Layered system**: Due to the growing complexity of enterprise applications,
    layering was introduced. This means it''s possible to incorporate additional modules
    between the client and server. We''re comfortable with three-tier and multi-tier
    applications. This is a complexity-mitigation technique.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: REST Resource Representation Compression
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: REST APIs can return the resource representations in a variety of formats (XML,
    JSON, HTML, and text). Resource representations can be compressed to save network
    bandwidth and storage requirements. There are different transmission protocols
    that enable compression, and clients are accordingly notified about the compression
    algorithm used.
  prefs: []
  type: TYPE_NORMAL
- en: '**Hypermedia as the Engine of Application State** (**HATEOAS**) is an important
    constraint of the REST paradigm. The term *hypermedia *refers to the links that
    point to various types of multimedia content (images, videos, audios, or text).
    This architectural style helps to use hypermedia links in the response message
    so that clients can dynamically go to the correct resource.'
  prefs: []
  type: TYPE_NORMAL
- en: Idempotent REST APIs
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: If we make multiple identical requests and receive the same response every time,
    the APIs are generally called **idempotent**. Some API consumers knowingly or
    unknowingly make the same request twice or thrice. The APIs have to understand
    this and reply with the same response.
  prefs: []
  type: TYPE_NORMAL
- en: The point is that we have to build and deploy *intelligent APIs. One trait of
    them is the idempotent APIs.* We have to have *idempotent REST APIs* for all the
    standard HTTP operations, such as `GET`, `PUT`, and `DELETE`. Only `POST` APIs
    will not be idempotent.
  prefs: []
  type: TYPE_NORMAL
- en: As previously mentioned, RESTful communication takes place on the HTTP protocol,
    and the HTTP commands are being used by the REST client to interact with the REST
    server. This uniformity and simplicity works wonders for the faster and easier
    adoption of the REST paradigm, which becomes an important concept in the increasingly
    connected world.
  prefs: []
  type: TYPE_NORMAL
- en: REST API design considerations
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: With the usage of APIs increasing rapidly, the API design process is getting
    a lot of attention from a variety of sources these days. Not only is it important
    to insightfully blueprint and implement highly-optimized and -organized APIs,
    but we also need to empower them to be resilient, robust, and versatile for the
    web, mobile, and cloud worlds. The availability of APIs for the continued function
    of applications is essential. The high performance and throughput of APIs is vital.
    The number of user requests, the number of transactions, and the amount of data
    getting processed are critical for APIs to contribute their might to the application
    world. APIs have to scale well in order to tackle extra user and data loads automatically
    in order to be relevant for their consumers and stakeholders. There shouldn't
    be any API-induced application slowdown and breakdown. We discussed the importance
    of API security in a separate section. Any kinds of internal errors, security
    holes, or vulnerabilities in APIs have to be weeded out through testing procedures
    and tools. Any kind of outsider attack also needs to be given sufficient consideration.
  prefs: []
  type: TYPE_NORMAL
- en: 'Applications have to fully comply with all the stated API requirements. That
    is, applications have to send correct data and protocols, as etched in the API
    rulebook. If there''s any deliberate deviation, the result can be irreparable
    damage. Thus, API monitoring, log collection, and adept management are necessary
    for success. When designing APIs, service architects and API developers have to
    take the following into serious consideration. APIs play a  crucial role in fulfilling
    the **non-functional requirements** (**NFRs**)/**quality of service** (**QoS**)
    attributes for RESTful services. As we all know, RESTful services guarantee simplicity
    and ubiquity. Thus, when designing REST APIs, architects and designers have to
    give special importance to the following NFRs:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Performance**: This is an important parameter when designing APIs for RESTful
    services to interact and collaborate.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Scalability**: RESTful APIs have to be designed to support a large number
    of application components. The number of interactions among those components should
    also be on the higher side.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Modifiability**: Newer technologies keep coming up, business sentiments keep
    being chopped and changed, and user expectations are also evolving. Since *change
    is the only constant*, APIs have to be built to be adaptive to changing requirements.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Portability**: APIs are being used, tested, refined, and deployed in API
    stores. APIs have to be made portable to work across systems.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Reliability**: APIs have to be reliable to withstand any kind of failures
    and faults at the system level. There may be failures at the component and data
    levels, but the system should still continue to function and deliver its obligations.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: As we struggle to build and deploy highly-scalable, -available, and -reliable
    systems with high performance, the arrival of APIs as a soothing element toward
    fulfilling the previous NFRs is being viewed and welcomed with appreciation.
  prefs: []
  type: TYPE_NORMAL
- en: Enumerating RESTful API design patterns
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'API design is turning out to be a core pillar for any API product strategy
    to attain the desired success for software products. Any software package has
    to be attached with appropriate APIs in order to be found and bound remotely.
    Exposing APIs helps any third-party service or software provider to get linked
    and used. Therefore, producing easy-to-use, forward-looking, and sustainable APIs
    is vital for the API-driven world. Good API design considerably enhances the **developer
    experience** (**DX**) and can improve performance and long-term maintainability.
    The API implementation is typically hidden from API clients. Such a separation
    brings much-needed flexibility for any kind of advancements to be brought to the
    API implementation without affecting any API client. A well-designed API has to
    have the following properties:'
  prefs: []
  type: TYPE_NORMAL
- en: APIs have to support all standard and mutually-agreed platforms
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: With the growing device ecosystem, any client can call and use APIs
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Nothing is going to be static
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: API changes are mandated then and there, as applications and services are bound
    to be constantly modernized
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: API design and modification has to be done in such a way that clients aren't
    negatively impacted
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Media types
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: As everyone knows, clients and servers normally exchange resource representations.
    Typically, in a `POST` request, the request body contains a representation for
    a resource to be created. On the reverse side, in a `GET` request, the response
    body contains a representation of the received resource. Generally, formats are
    specified through the use of *media types* (alternatively termed MIME types).
    For non-binary data, it's JSON (`media type = application/json`) and XML (`media
    type = application/xml`). The Content-Type header in a request or response specifies
    the format of the representation.
  prefs: []
  type: TYPE_NORMAL
- en: 'Having understood the relevance of APIs for creating composite enterprises,
    IT professionals have unearthed a number of API design patterns, which are easy
    for API designers and developers to understand and use:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Statelessness**: For web-scale applications, the number of users employing
    a variety of client devices to get served through REST services is in the millions
    at any point in time. Web applications made through RESTful services have to be
    internally and externally scalable. Thus, storing client session information in
    an application server can degrade application performance. That is, application
    servers have to be stateless. APIs have to be designed to support the statelessness
    property.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Content-negotiation**: We know that a resource can have multiple representations
    in order to fulfill the varied needs of different client devices. Requesting a
    suitable presentation by a client is termed content-negotiation. Another option
    is that different representation can be referred to using different URLs.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Uniform resource identifier** (**URI**) **templates**: The URIs with placeholders
    in them. By using named substitution variables, the templates can be used to create
    URIs for specific resources. The templates are used in specification documents
    to describe where resources reside. Clients should be aware of these templates
    to generate the full URI for any resource. This is due to the fact that resources
    are not typically linked to other resources. It''s the responsibility of clients
    to decide on a resource''s URI manually. The proper solution to this predicament
    is to link those resources from a known place. Individual product offerings have
    to be linked from a centralized product listing resource. Thus, URI templates
    come in handy for unambiguously identifying the URI for any resource.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Versioning**: This is an important practice. APIs keep changing to accommodate
    business and technology changes. API compatibility is a serious stuff. Developers
    are being continuously pressed to bring in verified changes on APIs. Occasionally,
    backward compatibility is being required in order to enable work with older versions
    of APIs. The idea is that if the version number is attached with an API, there''s
    no conflict and it makes light of users'' tasks. API versioning also helps to
    precisely track the API''s evolution.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Bulk operations**: Services are being decorated with fine-grained and coarse-grained
    methods. Bulk operations are being typically implemented through coarse-grained
    methods. API designers have to take care of this thing. Fine-grained methods typically
    demand multiple requests and responses, which wastes a lot of network bandwidth
    resources. With a few requests, bigger and better operations can be accomplished.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Pagination**: Exposing a variety of resources through a single URI can lead
    to applications fetching a large amount of data for the client. It''s not possible
    to show all the representation details in a single page. Pagination comes to the
    rescue here in reducing the amount of data that will be communicated to the client,
    so the network bandwidth can be conserved. This pattern also avoids any unnecessary
    processing at the server side. During the API design phase, though it’s a challenging
    task to foresee the amount of data that will be returned as part of response,
    its necessary for API designers to anticipate and planned for the paging resources
    requirements'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Sorting**: Sorting is an important feature for any API endpoint that returns
    a large quantity of data to the client. To facilitate the sorting functionality,
    many APIs add a *sort* or *sort_by* URL parameter, which can take a field name
    as the value. Good API designs let you specify *ascending *or *descending *order
    when sorting. A sort parameter should contain the names of the attributes on which
    the sorting is performed, separated by a comma.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Filtering**: It''s an accepted statement that URL parameters is the way to
    go for embedding basic filtering to REST APIs. If we have a `/products` endpoint,
    which is products for sale, we can filter via the property name, such as `GET
    /products?state=active` or `GET /products?state=active&seller_id=1234`. The problem
    here is that this only works for exact matches. If we want to filter for a range
    (price, or date), there is a challenge. URL parameters typically have a key and
    a value, but for performing advanced filtering, we need a minimum of three components:
    the property/field name, the operator, and the filter value.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'There are ways to encode these components into URL parameter keys/values. You
    can find more details on the options here: [https://www.moesif.com/blog/technical/api-design/REST-API-Design-Filtering-Sorting-and-Pagination/](https://www.moesif.com/blog/technical/api-design/REST-API-Design-Filtering-Sorting-and-Pagination/).
    Restricting resources or responses by restricting number of queries (resources)
    with specific and limited attributes along with their expected values is called
    filtering. So it would be possible that one can apply filters in a collection
    on multiple attributes or allowing several values for one filtered attribute.:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Unicode**: Modern-day APIs have to support more than English characters.
    If Unicode characters are embedded in a URL, the API has to be developed accordingly.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Error logging**: All kinds of error messages have to be meticulously collected
    and subjected to a variety of investigations to extract any useful insights from
    logs. The client request may have errors. There may be errors being caused by
    the API itself. Thus, log collection is an important process for error analytics.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Stateless authentication and authorization**: As mentioned many times, REST
    APIs have to be designed to be stateless. Each request has to be self-contained
    to fulfill user requests without the knowledge of clients. If the primary service
    fails to transact, its various instances have to come to life to implement requests
    in time. Not just for service requests, but also for authenticating and authorizing
    users, stateless services need to be involved and invoked. Typically, user information
    gets stored on the server side so that the subsequent requests don''t need to
    go to the authentication service. However, this approach fails the scalability
    test, and hence, every request has to carry all the relevant information in order
    to be authenticated and authorized. This isn''t restricted to users—service-to-service
    authorization is also being facilitated through this approach.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The expert recommendation is to use JWT with OAuth2 for user authentication.
    For service-to-service communication, it''s paramount to have the encrypted API
    key in the header component of the request message:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Swagger for documentation**: API documentation is very important for developers
    to gain a deeper understanding of APIs and their unique capabilities. The accuracy
    of API documents is far more important for the envisioned success. Instead of
    using human resources to generate API documents, it''s easier and faster to employ
    automation techniques and tools to create API documents. APIs, along with the
    annotations and metadata, contribute to producing documents in an automated manner.
    Swagger is a widely-used tool for documenting REST APIs. The document generated
    contains the details regarding the usage of a specific API. It also provides the
    relevant details of the input and output information for a method in the API.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**HTTP status codes**: There are many articles and blogs in the web that table
    HTTP status codes. These help clients to understand the real situation facing
    servers. That is, when a client request reaches server-side services, the server
    will generate a litany of responses back to the client. There may be a failure
    or success. The status codes sheds some light on what happened at the server side.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**HATEOAS**: Each HTTP `GET` request has to supply all the information in the
    response message. These details help to find the various resources related directly
    to the requested object through hyperlinks, which are embedded in the response.
    Also, it has to have all the details that describe the pertinent operations being
    made available on each of those resources. This is termed HATEOAS. HATEOAS simplifies
    the navigation through a resource and its available actions. This facilitates
    clients interaction with an application for different actions. All the metadata
    is getting embedded in responses from the server.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: We have discussed most of the API design patterns, which are sourced from multiple
    sources, such as blogs written by experienced practitioners. There are design
    patterns, best practices, metrics, and other knowledge guides for risk-free and
    rewarding experiences in relation to application, service, device, middleware,
    and database APIs.
  prefs: []
  type: TYPE_NORMAL
- en: API security design patterns
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'API security is essential. If there''s any manipulation allowed on APIs, the
    results may be catastrophic. Here''s an article that enumerates all the things
    an API developer has to minutely make in order to arrive at impenetrable and unbreakable
    APIs: [https://dzone.com/articles/top-5-rest-api-security-guidelines](https://dzone.com/articles/top-5-rest-api-security-guidelines).
    First, the identification and authentication are being performed in order to empower
    users to access RESTful APIs. Next in line is none other than authorization. The
    RESTful API design has to be done in such a way that it''s possible to establish
    and enforce authorization rights. Also, bringing the correct changes into authorization
    policies/rules also has to be part of the API design. The rights-based access
    of resources has to be made mandatory.'
  prefs: []
  type: TYPE_NORMAL
- en: It's API designer/developer responsibility to ensure the design is mandating
    the API key or session token validation for the specific resource collection and
    action. For an example, if there is an API exposed for a book, then allowing any
    user to delete the entries is not prudent.. But it's OK to allow anyone to get
    a book catalogue entry. Further down the line, the session token or API key has
    to be embedded in the message body or sent as a cookie to diligently protect privileged
    collections or actions from any unauthorized use.
  prefs: []
  type: TYPE_NORMAL
- en: Whitelist allowable methods
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'We all know that REST services allow multiple methods for performing different
    operations on a resource. To avoid any kind of conflicts, RESTful services have
    to be developed and deployed to ensure that only correct methods are accepted
    for processing. Other methods automatically are made to get an appropriate error
    message. The key security attacks are detailed as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Cross-site request forgery**: Resources are being exposed by REST services
    to the outside, along with a well-designed API. It is crucial to protect `PUT`,
    `POST`, and `DELETE` request **cross-site request forgery** (**CSRF**). The standard
    protection approach is to use one of the token-based approaches. If there''s any
    **cross-site scripting** (**XSS**) in our application, CSRF can still be easily
    done even if we use random tokens, hence, experts recommend leveraging viable
    mechanisms to prevent XSS.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Input validation**: We execute validation both on the client and the server
    side. The client- and server-side script languages have innate capabilities to
    properly validate requests and responses. If there''s an incorrect user input,
    it''s better to reject that. Also, it''s better to log input validation failures.
    If there are more failed input validations, the option to consider is rate limiting
    the API.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**URL validations**: It''s possible for attackers to tamper with any part of
    an HTTP request to break into the employed security methods. The key parts making
    up an HTTP request include the URL, query string, headers, cookies, form, and
    hidden fields.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Secure parsing**: All incoming messages have to be systematically parsed
    for any security violations. It''s true that REST can accept messages being framed
    through multiple mechanisms, including XML and JSON.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Validate incoming content types**: When we use the `POST` and `PUT` methods
    for submitting new data, the client is expected to clearly specify the content-type
    (such as XML or Java).'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**The servers never assume the content type**: Servers always have to verify
    whether the content type and the content are the same. If they don''t match, an
    appropriate error message has to be communicated back.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Validate response types**: This is another validation. REST services allow
    multiple response types and, hence, the client has to articulate the preferred
    order of response types in the Accept header, which is part of the request message.
    Also, there are many MIME types for the typical response types, so clients have
    to specify which MIME types should be used in the reply message.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**XML input validation**: There are XML-specific attacks (XML External Entity
    and XML signature wrapping) and hence, XML-based services have to securely parse
    XML messages to be protected against attacks.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Security headers**: To correctly interpret server messages, the server has
    to embed the content-type header with the correct content type.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**XML encoding**: XML messages should be constructed using an XML serializer.
    Then, only the XML content can be parsed by the browser and be devoid of any XML
    injection errors.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Cryptography**: When data is getting transmitted, it gets encrypted. That
    is, the **transport-level security** (**TLS**) has to be enabled. TLS is important
    when credentials, updates, deletions, and any other value-added information get
    transmitted across. Even experts recommend using mutually-authenticated client-side
    certificates to guarantee the utmost security to RESTful web services. Similarly,
    when data gets persisted, the data has to be encrypted, and when data is being
    used by any application, appropriate security measures have to be in place.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Message integrity**: Cryptography ensures confidentiality, but we need message
    integrity. That is, we leverage the message digest/hashing algorithms toward message
    integrity. A **JSON web token** (**JWT**) is a standardized, optionally validated,
    and/or encrypted container format. This is used to securely transfer information
    between two parties.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'JWT defines the structure of the information that''s being communicated across
    the network and it comes in two forms: serialized and deserialized. The serialized
    form is used to transfer data through the network with each request and response.
    The deserialized form is used to read and write data to the token. JWT is useful
    for the following scenarios:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Authorization: **JWT (Jason Web Tokens) enables logged in user to access
    routes, services and resources as the JWT tokens would be part of subsequent incoming
    requests (after the initial request), and JWT is a popular adoption for SSO (Single
    Sign On) implementations as well.'
  prefs: []
  type: TYPE_NORMAL
- en: '**Information Exchange**: JWT is emerging as a way to securely transmit information
    across parties. JWTs can be signed using public and private keys, so it''s easy
    to understand who the senders are. Also, through message digest, it''s proved
    that the message wasn''t tampered with along the way.'
  prefs: []
  type: TYPE_NORMAL
- en: API security is an important phenomenon. There is a growing array of best practices
    and patterns for securing APIs. Collecting error logs comes in handy when visualizing
    any kind of security implications, In time, this is the surest way forward to
    guarantee fool-proof security for APIs being designed, published, and maintained.
  prefs: []
  type: TYPE_NORMAL
- en: In conclusion, developers should try to understand the prevailing context and
    the future. It's not easy to come out with a strategically sound API off the bat.
    APIs can make or mark the whole scenario if done with passion and discussion.
    API designers have to start thinking in terms of user perspectives. A robust design
    is a key factor in producing and sustaining state-of-the-art and multifaceted
    APIs. A poorly designed API may lead to failure or the customer may not be satisfied
    with the applications and services.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The microservices architecture is the prime architectural pattern and style
    for producing multifaceted and enterprise-scale applications to be elegantly hosted
    and run on cloud environments (local and remote). Microservices are lightweight,
    simple to build and deploy, self-defined, fine-grained, and network accessible.
    They also follow the single functionality principle.
  prefs: []
  type: TYPE_NORMAL
- en: Nowadays, everything that communicates over HTTP and uses JSON- or XML-formatted
    messages or the HTTP methods (`GET`, `POST`, `PUT`, or `DELETE`) gets called a
    RESTful API. RESTful APIs are easy to design and build. The seamless and spontaneous
    combination of microservices and RESTful APIs opens up fresh possibilities and
    opportunities. Hence, designing high-quality RESTful APIs acquires special significance
    in our increasingly connected and services-oriented world. This chapter provided
    the relevant patterns, best practices, and general guidelines to come up with
    top-quality RESTful APIs.
  prefs: []
  type: TYPE_NORMAL
- en: Further reading
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '[https://www.packtpub.com/application-development/hands-restful-python-web-services-second-edition](https://www.packtpub.com/application-development/hands-restful-python-web-services-second-edition)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[https://www.packtpub.com/application-development/building-restful-apis-go-video](https://www.packtpub.com/application-development/building-restful-apis-go-video)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[https://www.packtpub.com/web-development/restful-web-services-scala](https://www.packtpub.com/web-development/restful-web-services-scala)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
