<html><head></head><body>
  <div><div><div><div><div><h1 class="title"><a id="ch06"/>Chapter 6. Kivy Player – a TED Video Streamer</h1></div></div></div><p>In this chapter, we will learn how to search, display, and control videos. We will integrate knowledge from previous chapters to build a responsive application with the ability to adjust to different screens and maximize the use of space. We will produce an enhanced <strong>video</strong> widget<a id="id568" class="indexterm"/> with controls and subtitle support, and learn how to display a <a id="id569" class="indexterm"/>search result query from the TED API services (<a class="ulink" href="http://developer.ted.com">developer.ted.com</a>). Here are the main topics that we will cover in this chapter:</p><div><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">Control the progression of a streamed video</li><li class="listitem" style="list-style-type: disc">Use the progression of a video to display subtitles at the right moment</li><li class="listitem" style="list-style-type: disc">Apply strategies and components to make our application responsive</li><li class="listitem" style="list-style-type: disc">Display and navigate a local file directory tree</li><li class="listitem" style="list-style-type: disc">Use the Kivy inspector to debug our applications</li><li class="listitem" style="list-style-type: disc">Add scroll functionality to a list of results obtained from an Internet query</li></ul></div><p>This chapter wraps up a lot of knowledge acquired so far. We will be reviewing and combining the use of properties, events, animations, touches, behaviors, layouts, and even graphics. At the same time, we will introduce new widgets that will complement your knowledge, and serve as good examples of new programming situations. We will also review the Kivy inspector that will help us detect GUI bugs. At the end of this chapter, we will finish with a professional looking interface.</p><div><div><div><div><h1 class="title"><a id="ch06lvl1sec52"/>Video – play, pause, and stop</h1></div></div></div><p>We will<a id="id570" class="indexterm"/> start <a id="id571" class="indexterm"/>with simple<a id="id572" class="indexterm"/> code in this<a id="id573" class="indexterm"/> section, and then gradually include functionality until we get a complete video player. In this section, we will discuss how to use the <strong><code class="literal">Video</code></strong> widget in order to stream a <em>video</em> from the Internet. Let's start with the code in the <code class="literal">video.kv</code> file:</p><div><pre class="programlisting">1. # File name: video.kv
2. #:set _default_video "http://video.ted.com/talk/stream/2004/None/DanGilbert_2004-180k.mp4"
3. 
4. &lt;Video&gt;:
5.     allow_stretch: True
6.     color: 0,0,0,0
7.     source: _default_video</pre></div><p>In this<a id="id574" class="indexterm"/> code, we initially create a constant value with the <strong><code class="literal">set</code></strong> directive (line 2). This <a id="id575" class="indexterm"/>directive allows us to have global <a id="id576" class="indexterm"/>values that we can use inside the Kivy language <a id="id577" class="indexterm"/>scope. For example, we set the <code class="literal">source</code> property of the <code class="literal">Video</code> class with the value of the <code class="literal">_default_video</code> constant (line 7).</p><p>We set up<a id="id578" class="indexterm"/> three properties for the <strong><code class="literal">Video</code></strong> class. The <strong><code class="literal">allow_stretch</code></strong> property (line 5) allows<a id="id579" class="indexterm"/> the video to<a id="id580" class="indexterm"/> stretch according to the screen size available. The <strong><code class="literal">color</code></strong> property (line 6) will tint the video black, to serve as a foreground when the <em>video</em> is not <a id="id581" class="indexterm"/>playing (and a background for the <em>cover</em> image). The <strong><code class="literal">source</code></strong> property (line 7) contains the URL (or filename) of the video we want to play. These<a id="id582" class="indexterm"/> three properties actually belong to the <strong><code class="literal">Image</code></strong> widget, which is the base class for <code class="literal">Video</code>. This makes sense if we think of a video as a sequence of images (accompanied by a sound).</p><div><div><h3 class="title"><a id="tip22"/>Tip</h3><p>For test purposes, if you want to avoid constantly downloading the video from the Internet (or if the URL is not available anymore), you can replace the URL in <code class="literal">default_video</code> with a sample file that is included with the code: <code class="literal">samples/BigBuckBunny.ogg</code>.</p></div></div><p>We will use the <strong><code class="literal">Factory</code></strong> class to use the technique that we learned about in <a class="link" href="ch04.html" title="Chapter 4. Improving the User Experience">Chapter 4</a>, <em>Improving the User Experience</em>. Back then, we used the <strong><code class="literal">Factory</code></strong> class to replace the <code class="literal">Line</code> vertex instruction with our personalized implementation, a ticker <code class="literal">Line</code>.</p><div><div><h3 class="title"><a id="note52"/>Note</h3><p>The <strong><code class="literal">Factory</code></strong> class follows<a id="id583" class="indexterm"/> an oriented-object software <a id="id584" class="indexterm"/>design pattern called a factory pattern. A factory pattern returns default new objects (instances) of a subset of classes according to the called identifier, usually a method, but in the case of the Kivy languate we just use a name. (<a class="ulink" href="http://en.wikipedia.org/wiki/Factory_%28object-oriented_programming%29">http://en.wikipedia.org/wiki/Factory_%28object-oriented_programming%29</a>).</p></div></div><p>We will do something similar now, but this time we will personalize our <code class="literal">Video</code> widget:</p><div><pre class="programlisting">8. # File name: video.py
9. from kivy.uix.video import Video as KivyVideo
10. 
11. from kivy.factory import Factory
12. from kivy.lang import Builder
13. 
14. Builder.load_file('video.kv')
15. 
16. class Video(KivyVideo): 
17. 
18.     def on_state(self, instance, value):
19.         if self.state == 'stop':
20.             self.seek(0) 
21.         return super(self.__class__, self).on_state(instance, value)
22. 
23.     def on_eos(self, instance, value):
24.         if value:
25.             self.state = 'stop'
26. 
27.     def _on_load(self, *largs):
28.         super(self.__class__, self)._on_load(largs)
29.         self.color = (1,1,1,1)
30. 
31.     def on_source(self, instance, value):
32.         self.color = (0, 0, 0, 0)
33. 
34. Factory.unregister('Video')
35. Factory.register('Video', cls=Video)</pre></div><p>The <code class="literal">video.py</code> file <a id="id585" class="indexterm"/>will import the Kivy <code class="literal">Video</code> widget with an alias <a id="id586" class="indexterm"/>name <code class="literal">KivyVideo</code> (line 9). We will now be able to<a id="id587" class="indexterm"/> create our personalized widget (lines 16 to 32) using <a id="id588" class="indexterm"/>the <code class="literal">Video</code> class name and not a less attractive alternative name such as <code class="literal">MyVideo</code>. At the end of the file, we replace the default <code class="literal">Video</code> widget with our personalized <code class="literal">Video</code> to the <code class="literal">Factory</code> (lines 34 and 35). From now on, the referenced <code class="literal">Video</code> class in the Kivy language will correspond to our implementation in this file.</p><p>We created four methods (<strong><code class="literal">on_state</code></strong>, <strong><code class="literal">on_eos</code></strong>, <strong><code class="literal">_on_load</code></strong>, and <strong><code class="literal">on_source</code></strong>) in the <code class="literal">Video</code> class. All of them correspond to events:</p><div><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">The <strong><code class="literal">on_state</code></strong> method (line 18) is called when the state of the <em>video</em> changes among <a id="id589" class="indexterm"/>its three possible states: playing (<code class="literal">'play'</code>), paused (<code class="literal">'pause'</code>), or stopped (<code class="literal">'stop'</code>). We make sure that when the video is stopped, it is re-positioned at the beginning with the <strong><code class="literal">seek</code></strong> method (line 20).</li><li class="listitem" style="list-style-type: disc">The <strong><code class="literal">on_eos</code></strong> method (line 23) will<a id="id590" class="indexterm"/> be called when <a id="id591" class="indexterm"/>the <strong>end of stream</strong> (<strong>EOS</strong>) has been reached. We <a id="id592" class="indexterm"/>will make sure that the state is set to <code class="literal">stop</code> when<a id="id593" class="indexterm"/> this occurs (line 19).</li><li class="listitem" style="list-style-type: disc">We also <a id="id594" class="indexterm"/>need to remember that we tinted the <a id="id595" class="indexterm"/>video with black color using the <code class="literal">color</code> property in the Kivy language (line 6). Therefore, we need to put light (<code class="literal">1,1,1,1</code>) on the video in order to be able to see it (line 29). The method <strong><code class="literal">_on_load</code></strong> (line 27) is <a id="id596" class="indexterm"/>called when the video is loaded into memory and ready to play. We use this method in order to set the proper (and original Kivy default) <code class="literal">color</code> property.<div><div><h3 class="title"><a id="note53"/>Note</h3><p>Remember in <a class="link" href="ch02.html" title="Chapter 2. Graphics – the Canvas">Chapter 2</a>, <em>Graphics – the Canvas</em> that the <code class="literal">color</code> property of an <code class="literal">Image</code> widget (base class of the <code class="literal">Video</code> class) acts as a tint or light over the display. The same effect occurs for the <code class="literal">Video</code> widget.</p></div></div></li><li class="listitem" style="list-style-type: disc">Finally, the <strong><code class="literal">on_source</code></strong> method, also inherited from the <code class="literal">Image</code> class, will restore<a id="id597" class="indexterm"/> the black tint on top of the video when the source of the video is changed.</li></ul></div><p>Let's proceed to create a <code class="literal">kivyplayer.py</code> file to execute our application, and also play, pause, and stop our video:</p><div><pre class="programlisting">36. # File name: kivyplayer.py
37. from kivy.app import App
38. 
39. from video import Video
40. 
41. class KivyPlayerApp(App):
42. 
43.     def build(self):
44.         self.video = Video()
45.         self.video.bind(on_touch_down=self.touch_down)
46.         return self.video
47. 
48.     def touch_down(self, instance, touch):
49.         if self.video.state == 'play':
50.             self.video.state = 'pause'
51.         else:
52.             self.video.state = 'play'
53.         if touch.is_double_tap:
54.             self.video.state = 'stop'
55. 
56. if __name__ == "__main__":
57.     KivyPlayerApp().run()</pre></div><p>For now, we will control the video with touches. In the <code class="literal">build</code> method (line 43), we have bound the <code class="literal">on_touch_down</code> event (line 45) of the video to the <code class="literal">touch_down</code> method (lines 48 to 54). One touch will play or pause the video according to its current <strong><code class="literal">state</code></strong> property (lines 49 and 52). The <a id="id598" class="indexterm"/>state property controls whether the video is in one<a id="id599" class="indexterm"/> of <a id="id600" class="indexterm"/>three possible states. If it<a id="id601" class="indexterm"/> is playing, it will pause it; otherwise (paused or stopped), it will play it. We will use the <strong><code class="literal">double_tap</code></strong> key that indicates a double touch (double tap or double click) in<a id="id602" class="indexterm"/> order to stop the video. Next <a id="id603" class="indexterm"/>time we touch the screen, the video will start from the beginning. Now, run the application (<code class="literal">Python kivyplayer.py</code>), and see how, as soon as you click on the screen, Kivy starts streaming Dan Gilbert's video, <em>The Surprising Science of Happiness</em>, from<a id="id604" class="indexterm"/> TED (<a class="ulink" href="http://www.ted.com/">http://www.ted.com/</a>):</p><div><img src="img/B04244_06_01.jpg" alt="Video – play, pause, and stop"/></div></div></div></div>


  <div><div><div><div><div><h1 class="title"><a id="ch06lvl1sec53"/>AsyncImage – creating a cover for the video</h1></div></div></div><p>In this <a id="id605" class="indexterm"/>section, we will learn how to put up a <em>cover</em> that will be displayed when the video is not playing. This image will serve as a decoration when the video hasn't started, and in the case of the TED video, it is usually an image that involves the speaker. Let's start introducing a few changes in the code of <code class="literal">video.kv</code>:</p><div><pre class="programlisting">58. # File name: video.kv 
59. ...
60. #:set _default_image "http://images.ted.com/images/ted/016a827cc0757092a0439ab2a63feca8655b6c29_1600x1200.jpg"
61. 
62. &lt;Video&gt;:
63.     cover: _cover
64.     image: _default_image
65.     ...
66.     AsyncImage:
67.         id: _cover
68.         source: root.image
69.         size: root.width,root.height</pre></div><p>In this code, we created another constant (<code class="literal">_default_image</code>) with the <strong><code class="literal">set</code></strong> directive (line 60), and <a id="id606" class="indexterm"/>a related property (<code class="literal">image</code>) for the <code class="literal">Video</code> class that references the constant (line 64). We also created the <code class="literal">cover</code> property (line 63) to reference <code class="literal">AsyncImage</code> that we added to the <code class="literal">Video</code> class (line 66), and that will serve as the cover for the video.</p><div><div><h3 class="title"><a id="note54"/>Note</h3><p>The main difference between <code class="literal">Image</code> and <code class="literal">AsyncImage</code> is that the <strong><code class="literal">AsyncImage</code></strong> widget<a id="id607" class="indexterm"/> allows us to continue using the program while the image is loading, instead of blocking the application until the image is completely downloaded.</p></div></div><p>This is important, since we download the image from the Internet and it could be a big file. When you run the code, you will notice that a waiting image will appear while the image is loading:</p><div><img src="img/B04244_06_02.jpg" alt="AsyncImage – creating a cover for the video"/></div><p>We also set<a id="id608" class="indexterm"/> some of the <code class="literal">AsyncImage</code> properties. We initialized the <code class="literal">source</code> property (line 68) with the new property (<code class="literal">root.image</code>) that we created in the <code class="literal">Video</code> widget to reference the cover image (line 64). Remember that this will internally bind the properties, meaning that each time that we change the <code class="literal">image</code> property, the <code class="literal">source</code> property will be updated to the same value. Line 69 repeats the same idea in order to keep the cover's <code class="literal">size</code> property equal to the dimensions of the video.</p><div><div><h3 class="title"><a id="tip23"/>Tip</h3><p>For test purposes, you can replace the URL in <code class="literal">default_image</code> with the following sample file included with the code:</p><p>
<code class="literal">samples/BigBuckBunny.png</code>.</p></div></div><p>We will introduce some changes to our <code class="literal">Video</code> widget in order to make sure that the cover is removed (hidden) when the video is being played:</p><div><pre class="programlisting">70. # File name: video.py
71.  ...
72. from kivy.properties import ObjectProperty
73.  ...
74. class Video(KivyVideo): 
75.     image = ObjectProperty(None)
76. 
77.     def on_state(self, instance, value):
78.         if self.state == 'play':
79.             self.cover.opacity = 0
80.         elif self.state == 'stop':
81.             self.seek(0) 
82.             self.cover.opacity = 1
83.         return super(self.__class__, self).on_state(instance, value)
84. 
85.     def on_image(self, instance, value):
86.         self.cover.opacity = 1
87.  ...</pre></div><p>We<a id="id609" class="indexterm"/> changed the <strong><code class="literal">on_state</code></strong> method to uncover the video when it is <a id="id610" class="indexterm"/>playing (line 79), and cover it again when the video is stopped (line 82) using the <em>opacity</em> property.</p><div><div><h3 class="title"><a id="tip24"/>Tip</h3><p>Avoid removing widgets that are declared in the <code class="literal">.kv</code> file. Most of the time, these widgets have internal bounds with other widgets (for example, property bounds), and can cause unexpected runtime errors related to missing internal references and inconsistent bound properties.</p></div></div><p>Instead of removing widgets, there are several alternatives; for example, firstly, use the <strong><code class="literal">opacity</code></strong> property<a id="id611" class="indexterm"/> to make a widget invisible, secondly, make the widget area equal to zero using the <code class="literal">size</code> property (<code class="literal">size = (0,0)</code>), and thirdly, use the <code class="literal">pos</code> property to place the widget in a location that will never be displayed (<code class="literal">pos= (99999,999999)</code>). We chose the first approach; in this case, it is the most elegant. We set the <strong><code class="literal">opacity</code></strong> property of <code class="literal">AsyncImage</code> to make it visible (<code class="literal">opacity = 1</code>) or invisible (<code class="literal">opacity = 0</code>).</p><div><div><h3 class="title"><a id="tip25"/>Tip</h3><p>Even though controlling the cover with the opacity to make it invisible may be the most elegant solution here, you have to be careful because the widget is still there, occupying space on the screen. Depending on the situation, you might have to extend the strategy. For example, if the widget captures some touch events, you can<a id="id612" class="indexterm"/> combine the <strong><code class="literal">opacity</code></strong> and <strong><code class="literal">disabled</code></strong> properties<a id="id613" class="indexterm"/> to hide and disable the widget.</p></div></div><p>We also created the <code class="literal">image</code> property (line 75), and used its <code class="literal">on_image</code> associated event (line 85) to make sure that the opacity is restored (line 86) if the image is changed. Now, an image of Dan Gilbert will appear when you run the application (<code class="literal">python kivyplayer.py</code>).</p></div></div>


  <div><div><div><div><div><h1 class="title"><a id="ch06lvl1sec54"/>Subtitles – tracking the video progression</h1></div></div></div><p>Let's add <a id="id614" class="indexterm"/>subtitles to our application. We will do this in four simple steps:</p><div><ol class="orderedlist arabic"><li class="listitem">Create a <code class="literal">Subtitle</code> widget (<code class="literal">subtitle.kv</code>) derived from the <code class="literal">Label</code> class that will display the subtitles</li><li class="listitem">Place a <code class="literal">Subtitle</code> instance (<code class="literal">video.kv</code>) on top of the video widget</li><li class="listitem">Create a <code class="literal">Subtitles</code> class (<code class="literal">subtitles.py</code>) that will read and parse a subtitle file</li><li class="listitem">Track the <code class="literal">Video</code> progression (<code class="literal">video.py</code>) to display the corresponding subtitle</li></ol></div><p>The <em>Step 1</em> involves the creation of a new widget in the <code class="literal">subtitle.kv</code> file:</p><div><pre class="programlisting">88. # File name: subtitle.kv
89. &lt;Subtitle@Label&gt;:
90.     halign: 'center'
91.     font_size: '20px'
92.     size: self.texture_size[0] + 20, self.texture_size[1] + 20
93.     y: 50
94.     bcolor: .1, .1, .1, 0
95.     canvas.before:
96.         Color:
97.             rgba: self.bcolor
98.         Rectangle:
99.             pos: self.pos
100.             size: self.size</pre></div><p>There are two interesting elements in this code. The first one is the definition of the size property (line 92). We define it as 20 pixels bigger than the <strong><code class="literal">texture_size</code></strong> width and height. The <strong><code class="literal">texture_size</code></strong> property indicates the size of the text determined by the font size and<a id="id615" class="indexterm"/> text, and we use it to adjust the <code class="literal">Subtitles</code> widget size to its content.</p><div><div><h3 class="title"><a id="note55"/>Note</h3><p>The <strong><code class="literal">texture_size</code></strong> is a read-only property because its value is calculated and dependent on other parameters, such as font size and height for text display. This means that we will read from this property but not write on it.</p></div></div><p>The second element is the creation of the <code class="literal">bcolor</code> property (line 94) to store a background color, and how the <code class="literal">rgba</code> color of the rectangle has been bound to it (line 97). The <code class="literal">Label</code> widget (like many other widgets) doesn't have a background color, and creating a rectangle is the usual way to create such features. We add the <code class="literal">bcolor</code> property in order to change the color of the rectangle from outside the instance.</p><div><div><h3 class="title"><a id="tip26"/>Tip</h3><p>We cannot directly modify parameters of the vertex instructions; however, we can create properties that control parameters inside the vertex instructions.</p></div></div><p>Let's move <a id="id616" class="indexterm"/>on to <em>Step 2</em> mentioned earlier. We need to add a <code class="literal">Subtitle</code> instance to our current <code class="literal">Video</code> widget in the <code class="literal">video.kv</code> file:</p><div><pre class="programlisting">101. # File name: video.kv 
102. ...
103. #:set _default_surl "http://www.ted.com/talks/subtitles/id/97/lang/en"
104. 
105. &lt;Video&gt;:
106.     surl: _default_surl
107.     slabel: _slabel
108.     ...
109. 
110.     Subtitle:
111.         id: _slabel
112.         x: (root.width - self.width)/2</pre></div><p>We added another constant variable called <code class="literal">_default_surl</code> (line 103), which contains the link to the URL with the corresponding subtitle TED video file. We set this value to the <code class="literal">surl</code> property (line 106), which we just created to store the subtitles' URL. We added the <code class="literal">slabel</code> property (line 107), that references the <code class="literal">Subtitle</code> instance through its ID (line 111). Then we made sure that the subtitle is centered (line 112).</p><p>In order to start <em>Step 3</em> (parse the subtitle file), we need to take a look at the format of the TED subtitles:</p><div><pre class="programlisting">113. {
114.     "captions": [{
115.         "duration":1976,
116.         "content": "When you have 21 minutes to speak,",
117.         "startOfParagraph":true,
118.         "startTime":0,
119.     }, ...</pre></div><p>TED uses a <a id="id617" class="indexterm"/>very simple JSON format (<a class="ulink" href="https://en.wikipedia.org/wiki/JSON">https://en.wikipedia.org/wiki/JSON</a>) with a list of <code class="literal">captions</code>. Each <code class="literal">caption</code> contains four keys but we will only use <code class="literal">duration</code>, <code class="literal">content</code>, and <code class="literal">startTime</code>. We need to parse this file, and luckily Kivy <a id="id618" class="indexterm"/>provides a <strong><code class="literal">UrlRequest</code></strong> class (line 121) that will do most of the <a id="id619" class="indexterm"/>work for us. Here is the code for <code class="literal">subtitles.py</code> that <a id="id620" class="indexterm"/>creates the <code class="literal">Subtitles</code> class:</p><div><pre class="programlisting">120. # File name: subtitles.py
121. from kivy.network.urlrequest import UrlRequest
122. 
123. class Subtitles:
124. 
125.     def __init__(self, url):
126.         self.subtitles = []
127.         req = UrlRequest(url, self.got_subtitles)
128. 
129.     def got_subtitles(self, req, results):
130         self.subtitles = results['captions']
131. 
132.     def next(self, secs):
133.         for sub in self.subtitles:
134.             ms = secs*1000 - 12000
135.             st = 'startTime'
136.             d = 'duration'
137.             if ms &gt;= sub[st] and ms &lt;= sub[st] + sub[d]:
138.                 return sub
139.         return None </pre></div><p>The constructor of the <code class="literal">Subtitles</code> class will receive a URL (line 125) as a parameter. Then, it will make the petition to instantiate the <strong><code class="literal">UrlRequest</code></strong> class (line 127). The first parameter of the class instantiation is the URL of the petition, and the second is the method that is<a id="id621" class="indexterm"/> called when the result of the petition is returned (downloaded). Once the request returns the result, the method <code class="literal">got_subtitles</code> is called(line 129). The <strong><code class="literal">UrlRequest</code></strong> extracts<a id="id622" class="indexterm"/> the JSON and places it in the second parameter of <code class="literal">got_subtitles</code>. All we had to do is put the captions in a class attribute, which we called <code class="literal">subtitles</code> (line 130).</p><p>The <code class="literal">next</code> method (line 132) receives the seconds (<code class="literal">secs</code>) as a parameter and will traverse the loaded JSON dictionary in order to search for the corresponding subtitle that belongs to that time. As soon as it finds one, the method returns it. We subtracted <code class="literal">12000</code> microseconds (line 134, <code class="literal">ms = secs*1000 - 12000</code>) because the TED videos have an introduction of approximately 12 seconds before the talk starts.</p><p>Everything is ready for <em>Step 4</em>, in which we put the pieces together in order to see the subtitles working. Here are the modifications to the header of the <code class="literal">video.py</code> file:</p><div><pre class="programlisting">140. # File name: video.py
141. ...
142. from kivy.properties import StringProperty
143. ...
144. from kivy.lang import Builder
145. 
146. Builder.load_file('subtitle.kv')
147. 
148. class Video(KivyVideo):
149.     image = ObjectProperty(None)
150.     surl = StringProperty(None)</pre></div><p>We imported <code class="literal">StringProperty</code> and added the corresponding property (line 142). We will use this property by the end of this chapter when we we can switch TED talks from the GUI. For now, we will just use <code class="literal">_default_surl</code> defined in <code class="literal">video.kv</code> (line 150). We also loaded the <code class="literal">subtitle.kv</code> file (line 146). Now, let's analyze the rest of the changes to the <code class="literal">video.py</code> file:</p><div><pre class="programlisting">151.     ...
152.     def on_source(self, instance, value):
153.         self.color = (0,0,0,0)
154.         self.subs = Subtitles(name, self.surl)
155.         self.sub = None
156. 
157.     def on_position(self, instance, value):
158.         next = self.subs.next(value)
159.         if next is None:
160.             self.clear_subtitle()
161.         else:
162.             sub = self.sub
163.             st = 'startTime'
164.             if sub is None or sub[st] != next[st]:
165.                 self.display_subtitle(next)
166. 
167.     def clear_subtitle(self):
168.         if self.slabel.text != "":
169.             self.sub = None
170.             self.slabel.text = ""
171.             self.slabel.bcolor = (0.1, 0.1, 0.1, 0)
172. 
173.     def display_subtitle(self, sub):
174.         self.sub = sub
175.         self.slabel.text = sub['content']
176.         self.slabel.bcolor = (0.1, 0.1, 0.1, .8)
177. (...)</pre></div><p>We introduced a few code lines to the <code class="literal">on_source</code> method in order to initialize the subtitles attribute with a <code class="literal">Subtitles</code> instance (line 154) using the <code class="literal">surl</code> property and initialize the <code class="literal">sub</code> attribute that contains the currently displayed subtitle (line 155), if any.</p><p>Now, let's<a id="id623" class="indexterm"/> study how we keep track of the progression to display the corresponding subtitle. When the video plays inside the <code class="literal">Video</code> widget, the <code class="literal">on_position</code> event is triggered every second. Therefore, we implemented the logic to display the subtitles in the <code class="literal">on_position</code> method (lines 157 to 165). Each time the <code class="literal">on_position</code> method is called (each second), we ask the <code class="literal">Subtitles</code> instance (line 158) for the next subtitle. If nothing is returned, we clear the subtitle with the <code class="literal">clear_subtitle</code> method (line 160). If there is already a subtitle in the current second (line 161), then we make sure that there is no subtitle being displayed, or that the returned subtitle is not the one that we already display (line 164). If the conditions are met, we display the subtitle using the <code class="literal">display_subtitle</code> method (line 165).</p><p>Notice that the <code class="literal">clear_subtitle</code> (lines 167 to 171) and <code class="literal">display_subtitle</code> (lines 173 to 176) methods use the <code class="literal">bcolor</code> property in order to hide the subtitle. This is another trick to make a widget invisible without removing it from its parent. Let's take a look at the current result of our videos and subtitles in the following screenshot:</p><div><img src="img/B04244_06_03.jpg" alt="Subtitles – tracking the video progression"/></div></div></div>


  <div><div><div><div><div><h1 class="title"><a id="ch06lvl1sec55"/>Control bar – adding buttons to control the video</h1></div></div></div><p>In this <a id="id624" class="indexterm"/>section, we will work on user interaction with the application. Right now, we control the video with touches on the screen that play, pause, and stop the video. However, this is not very intuitive for a new user of our application. So, let's add some buttons to improve the usability of our application.</p><p>We will use <code class="literal">Image</code> widgets enhanced with <code class="literal">ToggleButtonBehaviour</code> and <code class="literal">ToggleBehaviour</code> classes in order to create buttons for a <em>play</em>/<em>pause</em> button and a <em>stop</em> button, respectively. Here is a cropped screenshot of the simple <em>control bar</em> that we will be implementing in this section:</p><div><img src="img/B04244_06_04.jpg" alt="Control bar – adding buttons to control the video"/></div><p>Let's start defining our two widgets for <code class="literal">controlbar.kv</code>. We will cover each widget one by one. Let's start with the header of the file and the <code class="literal">ControlBar</code> class definition:</p><div><pre class="programlisting">178. # File name: controlbar.kv
179. &lt;ControlBar@GridLayout&gt;:
180.     rows: 1
181.     size_hint: None, None
182.     pos_hint: {'right': 1}
183.     padding: [10,0,0,0]
184.     play_pause: _play_pause
185.     progress: 0</pre></div><p>We derived the <code class="literal">ControlBar</code> class from the <code class="literal">GridLayout</code> class and set some familiar properties. We also created a reference to the <em>play</em>/<em>pause</em> button, and one new property (<code class="literal">progress</code>) that will track the percentage (from 0 to 1) of the progress of the video. Let's continue with the first embedded widget, <code class="literal">VideoPlayPause</code>:</p><div><pre class="programlisting">186.     VideoPlayPause:
187.         id: _play_pause
188.         start: 'atlas://data/images/defaulttheme/media-playback-start'
189.         pause: 'atlas://data/images/defaulttheme/media-playback-pause'
190.         size_hint: [None, None]
191.         width: 44
192.         source: self.start if self.state == 'normal' else self.pause</pre></div><p>As we will see in <code class="literal">controlbar.py</code>, <code class="literal">VideoPlayPause</code> is a combination of <code class="literal">Image</code> and <code class="literal">ToggleButtonBehavior</code>. We implemented the <code class="literal">source</code> property (line 192) in a way that changes the image of the widget according to the changes in the <code class="literal">state</code> property, <code class="literal">normal</code> and <code class="literal">down</code>. Let's now see the code for <code class="literal">VideoStop</code>:</p><div><pre class="programlisting">193.     VideoStop:
194.         size_hint: [None, None]
195.         width: 44
196.         source: 'atlas://data/images/defaulttheme/media-playback-stop'
197.         on_press: self.stop(root.parent.video, _play_pause)</pre></div><p>Apart<a id="id625" class="indexterm"/> from defining some familiar properties, we have bound the event <code class="literal">on_press</code> to the <code class="literal">stop</code> method (line 197), which will be shown in the corresponding <code class="literal">controlbar.py</code> file. Notice that we are assuming that the parent of the root contains a reference to the video (<code class="literal">root.parent.video</code>). We will continue working under this assumption in <code class="literal">controlbar.py</code>:</p><div><pre class="programlisting">198. # File name: controlbar.py 
199. from kivy.uix.behaviors import ButtonBehavior, ToggleButtonBehavior
200. from kivy.uix.image import Image
201. from kivy.lang import Builder
202. 
203. Builder.load_file('controlbar.kv')
204. 
205. class VideoPlayPause(ToggleButtonBehavior, Image):
206.     pass
207. 
208. class VideoStop(ButtonBehavior, Image):
209. 
210.     def stop(self, video, play_pause):
211.         play_pause.state = 'normal'
212.         video.state = 'stop'</pre></div><p>This code imports the necessary classes as well as <code class="literal">'controlbar.kv'</code> (lines 198 to 203). Then, using multiple inheritance, it defines the <code class="literal">VideoPlayPause</code> and <code class="literal">VideoStop</code> classes as a combination of the <code class="literal">Image</code> class and the appropriate behavior (lines 205 and 208). The <code class="literal">VideoStop</code> class contains the <code class="literal">stop</code> method, which is called when the button is pressed (line 208). This will set the <em>play</em>/<em>pause</em> button state to normal and stop the video (line 212).</p><p>We will also define a <em>video controller</em>, which will be the parent of the <em>control bar</em> and <em>video</em>, in the <code class="literal">videocontroller.kv</code> file:</p><div><pre class="programlisting">213. # File name: videocontroller.kv
214. &lt;VideoController &gt;:
215.     video: _video
216.     control_bar: _control_bar
217.     play_pause: _control_bar.play_pause
218.     control_bar_width: self.width
219.     playing: _video.state == 'play'
220. 
221.     Video:
222.         id: _video
223.         state: 'pause' if _control_bar.play_pause.state == 'normal' else 'play'
224. 
225.     ControlBar:
226.         id: _control_bar
227.         width: root.control_bar_width
228.         progress: _video.position / _video.duration</pre></div><p>First, we <a id="id626" class="indexterm"/>defined five properties for <code class="literal">VideoContoller</code> (lines 215 to 219): <code class="literal">video</code>, <code class="literal">control_bar</code>,  <code class="literal">play_pause</code>, <code class="literal">control_bar_width</code>, and <code class="literal">playing</code>. The first three properties reference components of the interface, <code class="literal">control_bar_width</code> will be used to externally control the width of the <em>control bar</em>, and the <code class="literal">playing</code> property will indicate whether the video is playing or not (line 219).</p><p>We then added a <code class="literal">Video</code> instance (line 221), whose state will depend on the state of the <em>play</em>/<em>pause</em> button (line 223), and a <code class="literal">ControlBar</code> instance. The <code class="literal">width</code> property of the <em>control bar</em> will be controlled by <code class="literal">control_bar_width</code> (line 227) that we previously created (line 218), and the <code class="literal">progress</code> property will be expressed as a percentage of the duration (line 228).</p><p>Now, we need to create the <code class="literal">VideoController</code> class in its respective <code class="literal">videocontroller.py</code> file:</p><div><pre class="programlisting">229. # File name: videocontroller.py
230. from kivy.uix.floatlayout import FloatLayout
231. from kivy.lang import Builder
232. 
233. import video
234. import controlbar
235. 
236. Builder.load_file('videocontroller.kv')
237. 
238. class VideoController(FloatLayout):
239.     pass</pre></div><p>We just included the necessary imports, and defined <code class="literal">VideoController</code> as a derived class of <code class="literal">FloatLayout</code>. The <code class="literal">kivyplayer.py</code> file also has to be updated in order to display a <code class="literal">VideoController</code> instance instead of <code class="literal">Video</code>:</p><div><pre class="programlisting">240. # File name: kivyplayer.py
241. from kivy.app import App
242. from videocontroller import VideoController
243. 
244. class KivyPlayerApp(App):
245.     def build(self):
246.         return VideoController()
247. 
248. if __name__=="__main__":
249.     KivyPlayerApp().run()</pre></div><p>Feel <a id="id627" class="indexterm"/>free to run an application again to test the <em>play</em>/<em>pause</em> and <em>stop</em> buttons. The next section will introduce a <em>progression bar</em> to our application.</p></div></div>


  <div><div><div><div><div><h1 class="title"><a id="ch06lvl1sec56"/>Slider – including a progression bar</h1></div></div></div><p>In this<a id="id628" class="indexterm"/> section, we will introduce a new widget called <strong><code class="literal">Slider</code></strong>. This widget will serve as a <em>progression bar</em>, but at the same time it will allow the user to forward and reverse the video. We will integrate the <em>progression bar</em> into the <em>control bar</em>, as shown in the following cropped screenshot:</p><div><img src="img/B04244_06_05.jpg" alt="Slider – including a progression bar"/></div><p>As you can see, <code class="literal">Slider</code> appears to the left of the <em>play</em>/<em>pause</em> and <em>stop</em> buttons. Let's change <code class="literal">controlbar.kv</code> to add <code class="literal">Slider</code> to reflect this order. Let's start with the header of the file and the <code class="literal">ControlBar</code> class definition:</p><div><pre class="programlisting">250. # File name: controlbar.kv
251. &lt;ControlBar@GridLayout&gt;:
252.     ...
253.     VideoSlider:
254.         value: root.progress
255.         max: 1
256.     VideoPlayPause:
257.         ...</pre></div><p>
<code class="literal">VideoSlider</code> will<a id="id629" class="indexterm"/> keep the <strong><code class="literal">value</code></strong> property updated with the progression of the video. The <a id="id630" class="indexterm"/>
<strong><code class="literal">value</code></strong> property indicates the location of the <a id="id631" class="indexterm"/>slider on the bar, and the <strong><code class="literal">max</code></strong> property is the maximum value that it can take. In this case, <code class="literal">1</code> is appropriate <a id="id632" class="indexterm"/>because we express the progression as a percentage (from 0 to 1) of the duration (line 255).</p><p>Let's now add the definition of <code class="literal">VideoSlider</code> in the <code class="literal">controlbar.py</code> file:</p><div><pre class="programlisting">258. # File name: controlbar.py 
259. ...
260. class VideoSlider(Slider):
261. 
262.     def on_touch_down(self, touch):
263.         video = self.parent.parent.video
264.         if self.collide_point(*touch.pos):
265.             self.prev_state = video.state
266.             self.prev_touch = touch
267.             video.state = 'pause'
268.         return super(self.__class__, self).on_touch_down(touch)
269. 
270.     def on_touch_up(self, touch):
271.         if self.collide_point(*touch.pos) and \
272.             hasattr(self, 'prev_touch') and \
273.             touch is self.prev_touch:
274.             video = self.parent.parent.video
275.             video.seek(self.value)
276.             if prev_state != 'stop':
277.                 video.state = self.prev_state
278.         return super(self.__class__, self).on_touch_up(touch)</pre></div><p>Controlling the progression of the video with a slider is tricky because the video and the slider need to constantly update each other. The video updates the slider to indicate its progress, and the slider updates the video when the user wants to forward or reverse the video. This creates an entangled logic, in which we have to take into account the following considerations:</p><div><ol class="orderedlist arabic"><li class="listitem">We need to use touch events because we want to make sure it is the user who is moving the slider and not the video progression.</li><li class="listitem">There seems to be an infinite loop; we update the slider, the slider uploads the <a id="id633" class="indexterm"/>video, and the video updates the slider.</li><li class="listitem">The user might not necessarily just click on the slider, he could potentially drag it, and during the dragging time, the video updates the slider again.</li></ol></div><p>For these reasons, we need to execute the following steps:</p><div><ol class="orderedlist arabic"><li class="listitem">Pause the video before updating the progression (line 267).</li><li class="listitem">Not update the slider directly with the value property, but instead update the video progression with the <code class="literal">seek</code> method (line 275).</li><li class="listitem">Use the two events <code class="literal">on_touch_down</code> (line 262) and <code class="literal">on_touch_up</code> (line 270), in order to safely change the progression percentage of the video.</li></ol></div><p>In the <code class="literal">on_touch_down</code> method (lines 262 to 268), we have stored the current state of the video (line 265), and a reference to the touch (line 266), and then we have paused the video (line 267). If we don't pause the video, the progression of the video could affect the slider (remember that the <code class="literal">value</code> of slider is bound to the <code class="literal">progression</code> property in line 254) before we update the video to the progression of the slider. In the <code class="literal">on_touch_up</code> event, we made sure that the touch instance corresponds to the one that we stored in the <code class="literal">on_touch_down</code> method (lines 272 and 273). Then, we set the video to the right place according to the position of the slider, with the <strong><code class="literal">seek</code></strong> method (line 275). Finally, we re-established the previous state of the video if it was different from <code class="literal">stop</code> (lines 276 and 277).</p><p>Feel free<a id="id634" class="indexterm"/> to run the application again. You can also experiment with the slider and different options to update the video. Try, for example, a real-time update while you drag the slider through the <code class="literal">on_touch_move</code> event.</p></div></div>


  <div><div><div><div><div><h1 class="title"><a id="ch06lvl1sec57"/>Animation – hiding a widget</h1></div></div></div><p>In this <a id="id635" class="indexterm"/>section, we will make the <em>control bar</em> disappear when the video starts playing in order to watch the video without visual distractions. We need to change the <code class="literal">videocontroller.py</code> file in order to animate the <code class="literal">ControlBar</code> instance:</p><div><pre class="programlisting">279. # File name: videocontroller.py
280. from kivy.animation import Animation
281. from kivy.properties import ObjectProperty
282. ...
283. class VideoController(FloatLayout):
284.     playing = ObjectProperty(None)
285. 
286.     def on_playing(self, instance, value):
287.         if value:
288.             self.animationVB = Animation(top=0)
289.             self.control_bar.disabled = True
290.             self.animationVB.start(self.control_bar)
291.         else:
292.             self.play_pause.state = 'normal'
293.             self.control_bar.disabled = False
294.             self.control_bar.y = 0
295. 
296.     def on_touch_down(self, touch):
297.         if self.collide_point(*touch.pos):
298.             if hasattr(self, 'animationVB'):
299.                self.animationVB.cancel(self.control_bar)
300.             self.play_pause.state = 'normal'
301.         return super(self.__class__, self).on_touch_down(touch)</pre></div><p>Along with the necessary imports at the beginning of the file (lines 280 and 281), we introduced the <code class="literal">playing</code> property (line 284) and two methods associated with the <code class="literal">on_playing</code> event and the <code class="literal">on_touch_down</code> event. The <code class="literal">playing</code> property was already defined in the Kivy language (line 219), but remember that, due to the file parsing order, we also need to define it in the Python language if we want to use the property in the same class.</p><p>When the <code class="literal">playing</code> property changes, the <code class="literal">on_playing</code> event is triggered (line 286). This method starts an animation (line 290) and disables the <em>control bar</em> when the video is playing (line 289). The animation will hide the <em>control bar</em> at the bottom of the screen. The <code class="literal">on_playing</code> method will also restore the <em>control bar</em> (lines 292 to 294), when the video is not playing so it will be visible again.</p><p>Since the <em>control bar</em> will be hidden when the video is playing, we need an alternate way to stop<a id="id636" class="indexterm"/> the video (different from the <strong>Stop</strong> button). This is the reason we included the <code class="literal">on_touch_down</code> event (line 296). As soon as we touch the screen, the animation, if it exists, is cancelled (line 298), and the <em>play</em>/<em>pause</em> button is set to <code class="literal">'normal'</code> (line 300). This will pause the video and therefore, trigger the <code class="literal">on_playing</code> event (in this case, because it stopped playing) that we just defined.</p><p>You can now run the application again and appreciate how the <em>control bar</em> slowly disappears down the bottom of the screen as soon as we press the <strong>Play</strong>/<strong>Pause</strong> button.</p></div></div>


  <div><div><div><div><div><h1 class="title"><a id="ch06lvl1sec58"/>Kivy inspector – debugging interfaces</h1></div></div></div><p>Sometimes,<a id="id637" class="indexterm"/> we encounter problems when we implement our interfaces, and it can be difficult to understand what went wrong, especially when many of the widgets don't have a graphic display. In this section, we will use the application that we created in this chapter to introduce the Kivy <strong>inspector</strong>, a <a id="id638" class="indexterm"/>simple tool to debug interfaces. In order to start the inspector, you run the following command: <code class="literal">python kivyplayer.py –m inspector</code>. You won't notice any difference at the beginning but if you press <em>Ctrl</em> + <em>E</em>, a bar will appear at the bottom of the screen, just like the one in the left screenshot of the following image:</p><div><img src="img/B04244_06_06.jpg" alt="Kivy inspector – debugging interfaces"/></div><p>If we press the button <strong>Move to Top</strong> (the first from left to right in the bar), the bar will move to the top of the screen as you can see in the right screenshot, a more convenient position<a id="id639" class="indexterm"/> for our particular application. The second button <strong>Inspect</strong> activates or deactivates the inspector behavior. We can now highlight components by clicking on them. </p><p>For example, if you click on the <em>play</em>/<em>pause</em> button, the video won't play; instead, the button will be highlighted with a red tone as you can see in the following left screenshot:</p><div><img src="img/B04244_06_07.jpg" alt="Kivy inspector – debugging interfaces"/></div><p>Moreover, if we want to visualize the widget that is currently highlighted, we just have to press the button <strong>Parent</strong> (third left to right on the bar). In the right screenshot, you can see how the <em>control bar</em> (parent of the <em>play</em>/<em>pause</em> button) is highlighted instead. You should also notice how the long button (fourth left to right on the bar) shows the class that the highlighted instance belongs to. If we click on this button, the entire list of properties for that widget will be displayed, as shown in the following left screenshot:</p><div><img src="img/B04244_06_08.jpg" alt="Kivy inspector – debugging interfaces"/></div><p>Finally, when we select one of the properties, we are able to modify it. For example, in the right screenshot, we modified the width property of the <em>control bar</em>, and we can see how the <em>control bar</em> immediately adjusts to the changes.</p><p>Remember that since the <a id="id640" class="indexterm"/>Kivy widgets are kept as simple as possible, it means that a lot of the times they are invisible because a more complex graphic to display means an unnecessary overload. However, this behavior makes it difficult for us to find errors in the GUI. So when our interface does not display what we expect, the inspector becomes very handy to help us understand the underlying tree structure of the GUI.</p></div></div>


  <div><div><div><div><div><h1 class="title"><a id="ch06lvl1sec59"/>ActionBar – a responsive bar</h1></div></div></div><p>A new <a id="id641" class="indexterm"/>set of widgets were introduced in Kivy 1.8.0, all of them<a id="id642" class="indexterm"/> related to the <strong><code class="literal">ActionBar</code></strong> widget. This widget resembles the Android's action bar. This will not only give your applications a modern and professional look, but it also includes more subtle properties such as responsiveness to small screens. Depending on the <code class="literal">ActionBar</code> widget hierarchy and components, the different widgets will collapse in order to adapt to the screen space available in the device. First, let's take a look at the final result of our planned <code class="literal">ActionBar</code>:</p><div><img src="img/B04244_06_09.jpg" alt="ActionBar – a responsive bar"/></div><p>We add the <a id="id643" class="indexterm"/>Kivy language code to produce the previous bar in a new file <code class="literal">kivyplayer.kv</code>, as presented here:</p><div><pre class="programlisting">302. # File name: kivyplayer.kv
303. 
304. &lt;KivyPlayer&gt;:
305.     list_button: _list_button
306.     action_bar: _action_bar
307.     video_controller: _video_controller
308. 
309.     VideoController:
310.         id: _video_controller
311.         on_playing: root.hide_bars(*args)
312. 
313.     ActionBar:
314.         id: _action_bar
315.         top: root.height
316.         ActionView:
317.             use_separator: True
318.             ActionListButton:
319.                 id: _list_button
320.                 root: root
321.                 title: 'KPlayer'
322.             ActionToggleButton:
323.                 text: 'Mute'
324.                 on_state: root.toggle_mute(*args)
325.             ActionGroup:
326.                 text: 'More Options...'
327.                 ActionButton:
328.                     text: 'Open List'
329.                     on_release: root.show_load_list()
330.                 ActionTextInput: 
331.                     on_text_validate: root.search(self.text)</pre></div><p>The <a id="id644" class="indexterm"/>hierarchy of the previous code is complicated, so it is also presented in the following diagram:</p><div><img src="img/B04244_06_10.jpg" alt="ActionBar – a responsive bar"/></div><p>As you can see<a id="id645" class="indexterm"/> in the preceding diagram, the <strong>KivyPlayer</strong> contains two <a id="id646" class="indexterm"/>main components, the <code class="literal">VideoController</code> that we created two<a id="id647" class="indexterm"/> sections ago, and the <strong>ActionBar</strong>. If you remember, we created the property playing for the <code class="literal">VideoController</code> (line 219), so we bound the associated event <code class="literal">on_playing</code> to the method <code class="literal">hide_bars</code> (line 311) that later on will basically hide the action bar. Right now, let's focus our attention to the hierarchy of <code class="literal">ActionBar</code>.</p><p>An <strong><code class="literal">ActionBar</code></strong> will<a id="id648" class="indexterm"/> always contain one <strong><code class="literal">ActionView</code></strong>. In this case, we<a id="id649" class="indexterm"/> just add an <code class="literal">ActionView</code> with three<a id="id650" class="indexterm"/> widgets: <code class="literal">ActionListButton</code>, <strong><code class="literal">ActionToggleButton</code></strong>, and <strong><code class="literal">ActionGroup</code></strong>. All of them inherit from <strong><code class="literal">ActionItem</code></strong>.</p><div><div><h3 class="title"><a id="note56"/>Note</h3><p>An <strong><code class="literal">ActionView</code></strong> should <a id="id651" class="indexterm"/>contain only widgets that inherit from <strong><code class="literal">ActionItem</code></strong>. We can create our own action items by inheriting from <code class="literal">ActionItem</code>.</p></div></div><p>The <strong><code class="literal">ActionGroup</code></strong> groups<a id="id652" class="indexterm"/> <code class="literal">ActionItem</code> instances in order to organize the responsive display. In this case, it contains one <strong><code class="literal">ActionButton</code></strong> instance and one <code class="literal">ActionTextInput</code> instance. <code class="literal">ActionListButton</code> and <code class="literal">ActionTextInput</code> are personalized widgets that we have to create. <code class="literal">ActionListButton</code> will inherit <a id="id653" class="indexterm"/>from <strong><code class="literal">ActionPrevious</code></strong> and <code class="literal">ToggleButtonBehaviour</code>, whereas <code class="literal">ActionTextInput</code> inherits from <strong><code class="literal">TextInput</code></strong> and <strong><code class="literal">ActionItem</code></strong>.</p><p>Before<a id="id654" class="indexterm"/> continuing, there<a id="id655" class="indexterm"/> are a few new properties<a id="id656" class="indexterm"/> in the code that deserve an explanation. The <strong><code class="literal">use_separator</code></strong> property of <code class="literal">ActionView</code> (line 317) indicates whether a separator will be used before every <code class="literal">ActionGroup</code>. The <code class="literal">title</code> property (line 321), which displays a title in the component of <code class="literal">ActionListButton</code>, is inherited from <code class="literal">ActionPrevious</code>. <code class="literal">ActionPrevious</code> is just a button with some extra GUI features (such as the title, but also the Kivy icon that<a id="id657" class="indexterm"/> could be modified with <strong><code class="literal">app_icon</code></strong>), but, more importantly, its <a id="id658" class="indexterm"/>parent (<code class="literal">ActionView</code>) will keep a reference to it with the <strong><code class="literal">action_previous</code></strong> property.</p><p>Let's now see the definition of <code class="literal">ActionTextInput</code> in the <code class="literal">actiontextinput.kv</code> file:</p><div><pre class="programlisting">332. # File name: actiontextinput.kv
333. &lt;ActionTextInput@TextInput+ActionItem&gt;
334.     background_color: 0.2,0.2,0.2,1
335.     foreground_color: 1,1,1,1
336.     cursor_color: 1,1,1,1
337.     hint_text: 'search' 
338.     multiline: False
339.     padding: 14
340.     size_hint: None, 1</pre></div><p>As we said before, <code class="literal">ActionTextInput</code> inherits from <strong><code class="literal">TextInput</code></strong> and <strong><code class="literal">ActionItem</code></strong>, The <strong><code class="literal">TextInput</code></strong> widget is a simple widget that displays a text input field in which the user can write. It inherits <a id="id659" class="indexterm"/>directly from the <code class="literal">Widget</code> class and the <strong><code class="literal">FocusBehaviour</code></strong> class, which was introduced in Kivy 1.9.0. The multiple inheritance notations that we used (line 333) are new to us.</p><div><div><h3 class="title"><a id="note57"/>Note</h3><p>In order to use multiple inheritance in the Kivy language, we use the notation <code class="literal">&lt;DerivedClass@BaseClass1+BaseClass2&gt;</code>.</p></div></div><p>The <strong><code class="literal">TextInput</code></strong> widget is<a id="id660" class="indexterm"/> one of the most flexible widgets in Kivy and contains a lot of properties<a id="id661" class="indexterm"/> that can be used to configure it. We used the <code class="literal">background_color</code>, <code class="literal">foreground_color</code>, and <code class="literal">cursor_color</code> properties (lines 334 to 336) to set the background, foreground, and cursor color, respectively. The <code class="literal">hint_text</code> property will display a hint background text, which will disappear when <code class="literal">TextInput</code> gains focus (for example, when we click or touch it). The <code class="literal">multiline</code> property will indicate whether <code class="literal">TextInput</code> will accept multiple lines, and will also activate the <code class="literal">on_text_validate</code> event when we hit the <em>Enter</em> key, and that we use in the <code class="literal">kivyplayer.kv</code> file (line 331).</p><p>Notice<a id="id662" class="indexterm"/> that we also added a few references in <code class="literal">KivyPlayer</code> (lines 305 to 307). We use those references on the Python side of <code class="literal">KivyPlayer</code>, which is <code class="literal">kivyplayer.py</code>. We will cover this code in three fragments:</p><div><pre class="programlisting">341. # File name: kivyplayer.py (Fragment 1 of 3)
342. from kivy.app import App
343. from kivy.uix.floatlayout import FloatLayout
344. from kivy.animation import Animation
345. from kivy.uix.behaviors import ToggleButtonBehavior
346. from kivy.uix.actionbar import ActionPrevious
347. 
348. from kivy.lang import Builder
349. 
350. import videocontroller
351. 
352. Builder.load_file('actiontextinput.kv')
353. 
354. 
355. class ActionListButton(ToggleButtonBehavior, ActionPrevious):
356.     pass</pre></div><p>In this fragment, we added all the necessary imports of the code. We also loaded the <code class="literal">actiontextinput.kv</code> file, and defined the <code class="literal">ActionListButton</code> class inherited from <code class="literal">ToggleButtonBehaviour</code> and <code class="literal">ActionPrevious</code>, as we indicated before.</p><p>In fragment 2 of <code class="literal">kivyplayer.py</code>, we added all the necessary methods that are called on by <code class="literal">ActionItems</code>:</p><div><pre class="programlisting">357. # File name: kivyplayer.py (Fragment 2 of 3)
358. class KivyPlayer(FloatLayout):
359. 
360.     def hide_bars(self, instance, playing):
361.         if playing:
362.             self.list_button.state = 'normal'
363.             self.animationAB = Animation(y=self.height)
364.             self.action_bar.disabled = True
365.             self.animationAB.start(self.action_bar)
366.         else:
367.             self.action_bar.disabled = False
368.             self.action_bar.top = self.height
369.             if hasattr(self, 'animationAB'):
370.                 self.animationAB.cancel(self.action_bar)
371. 
372.     def toggle_mute(self, instance, state):
373.         if state == 'down':
374.             self.video_controller.video.volume = 0
375.         else:
376.             self.video_controller.video.volume = 1
377. 
378.     def show_load_list(self):
379.         pass
380. 
381.     def search(self, text):
382.         pass</pre></div><p>For this <a id="id663" class="indexterm"/>section, we just implemented the <code class="literal">hide_bars</code> and <code class="literal">toggle_mute</code> methods. The <code class="literal">hide_bars</code> method (lines 360 to 371) hides the <em>action bar</em> when the video is playing in a similar way as we hid the <em>control bar</em> before. The <code class="literal">toggle_button</code> method (lines 372 to 382) uses the <strong><code class="literal">volume</code></strong> property to toggle<a id="id664" class="indexterm"/> between the full volume and mute state. The fragment 3 of the code just contains the final commands to run the code:</p><div><pre class="programlisting">383. # File name: kivyplayer.py (Fragment 3 of 3)
384. class KivyPlayerApp(App):
385.     def build(self):
386.         return KivyPlayer()
387. 
388. if __name__=="__main__":
389.     KivyPlayerApp().run()</pre></div><p>You can now run the application again. You might want to resize the window to see how the <em>action bar</em> reorganizes<a id="id665" class="indexterm"/> the components according to the screen size. Here are two examples for medium (left) and small (right) size:</p><div><img src="img/B04244_06_11.jpg" alt="ActionBar – a responsive bar"/></div></div></div>


  <div><div><div><div><div><h1 class="title"><a id="ch06lvl1sec60"/>LoadDialog – displaying a directory of files</h1></div></div></div><p>In this<a id="id666" class="indexterm"/> section, we will discuss how to display a directory tree in Kivy in order to select a file. First, we will define the interface in <code class="literal">loaddialog.kv</code>:</p><div><pre class="programlisting">390. # File name: loaddialog.kv
391. &lt;LoadDialog&gt;:
392.     BoxLayout:
393.         size: root.size
394.         pos: root.pos
395.         orientation: "vertical"
396.         FileChooserListView:
397.             id: filechooser
398.             path: './'
399.         BoxLayout:
400.             size_hint_y: None
401.             height: 30
402.             Button:
403.                 text: "Cancel"
404.                 on_release: root.cancel()
405.             Button:
406.                 text: "Load"
407.                 on_release: root.load(filechooser.path, filechooser.selection)</pre></div><p>There is nothing new in this code except for the use of the <strong><code class="literal">FileChooserListView</code></strong> widget. It<a id="id667" class="indexterm"/> will display the directory tree of files. The <em>path</em> property (line 398) will indicate the base path of where to start displaying the files. Apart from this, we add the <strong>Cancel</strong> (line 402)and <strong>Load</strong> buttons (line 405), and they call respective functions in the <code class="literal">LoadDialog</code> class that is defined in the <code class="literal">loaddialog.py</code> file:</p><div><pre class="programlisting">408. # File name: loaddialog.py
409. 
410. from kivy.uix.floatlayout import FloatLayout
411. from kivy.properties import ObjectProperty
412. from kivy.lang import Builder
413. 
414. Builder.load_file('loaddialog.kv')
415. 
416. class LoadDialog(FloatLayout):
417.     load = ObjectProperty(None)
418.     cancel = ObjectProperty(None)</pre></div><p>There<a id="id668" class="indexterm"/> are actually no explicitly defined parameters in this class definition, just a couple of properties. We will assign methods to these properties in the <code class="literal">kivyplayer.py</code> file, and Kivy/Python will call them respectively:</p><div><pre class="programlisting">419.     def show_load_list(self):
420.         content = LoadDialog(load=self.load_list, cancel=self.dismiss_popup)
421.         self._popup = Popup(title="Load a file list", content=content, size_hint=(1, 1))
422.         self._popup.open()
423. 
424.     def load_list(self, path, filename):
425.         pass
426. 
427.     def dismiss_popup(self):
428.         self._popup.dismiss() </pre></div><p>If you remember, the <strong>Open List</strong> button of the <code class="literal">ActionBar</code> instance calls the <code class="literal">show_load_list</code> method (line 329). This method will create an instance of <code class="literal">LoadDialog</code> (line 420), and will send, as parameters of the constructor, two others methods: <code class="literal">load_list</code> (line 424) and <code class="literal">dismiss_popup</code> (line 427). These methods will be assigned to the <code class="literal">load</code> and <code class="literal">cancel</code> properties. Once the instance is created, we display it in a <code class="literal">Popup</code> (instance line 421 and 422). </p><p>Now, the <code class="literal">load_list</code> method will be called, when we click on the <strong>Load</strong> button of <code class="literal">LoadDialog</code> (line 420), and the <code class="literal">dismiss_popup</code> method when the <strong>Cancel</strong> button is pressed. Don't forget to add the corresponding imports in <code class="literal">kivyplayer.py</code>:</p><div><pre class="programlisting">429. from kivy.uix.popup import Popup
430. from loaddialog import LoadDialog
431. from sidebar import ListItem</pre></div><p>Here is<a id="id669" class="indexterm"/> the resulting screenshot, where we can appreciate the tree directory:</p><div><img src="img/B04244_06_12.jpg" alt="LoadDialog – displaying a directory of files"/></div></div></div>


  <div><div><div><div><div><h1 class="title"><a id="ch06lvl1sec61"/>ScrollView – displaying a list of videos</h1></div></div></div><p>In<a id="id670" class="indexterm"/> this section, we will display the results of a search performed on the TED video site in a <em>side bar</em> that we can scroll up and down, as shown in the following screenshot:</p><div><img src="img/B04244_06_13.jpg" alt="ScrollView – displaying a list of videos"/></div><p>Let's <a id="id671" class="indexterm"/>start defining the components of the side bar in the <code class="literal">sidebar.kv</code> file:</p><div><pre class="programlisting">432. # File name: sidebar.kv
433. &lt;ListItem&gt;:
434.     size_hint: [1,None]
435.     height: 70
436.     group: 'listitem'
437.     text_size: [self.width-20, None]
438. 
439. 
440. &lt;Sidebar@ScrollView&gt;:
441.     playlist: _playlist
442.     size_hint: [None, None]
443.     canvas.before:
444.         Color:
445.             rgba: 0,0,0,.9
446.         Rectangle:
447.             pos: 0,0,
448.             size: self.width,self.height
449. 
450.     GridLayout:
451.         id: _playlist
452.         size_hint_y: None
453.         cols: 1</pre></div><p>The <code class="literal">ListItem</code> class inherits from <code class="literal">ToggleButton</code>. The <code class="literal">text_size</code> property will establish a boundary for the text. If the titles of the videos are too long, two lines will<a id="id672" class="indexterm"/> be used instead. The <code class="literal">Sidebar</code> class<a id="id673" class="indexterm"/> inherits from <strong><code class="literal">ScrollView</code></strong>, which will allow scrolling down the list of videos, similar to the way we scrolled the files in <code class="literal">LoadDialog</code> of the last section. The <code class="literal">GridLayout</code> instance inside <code class="literal">Sidebar</code> is the actual widget that will contain and organize the <code class="literal">ListItem</code> instances. This is referenced by <code class="literal">Sidebar</code> in the <code class="literal">playlist</code> property (line 442)</p><div><div><h3 class="title"><a id="tip27"/>Tip</h3><p>The contained element inside <code class="literal">ScrollView</code> has to be allowed to be bigger than <code class="literal">ScrollView</code> in order to scroll. Set <code class="literal">size_hint_y</code> to <code class="literal">None</code> if you want to add vertical scrolling or <code class="literal">size_hint_x</code> to <code class="literal">None</code> if you want to add horizontal scrolling.</p></div></div><p>Let's continue with the definition of the sidebar on the Python file (<code class="literal">sidebar.py</code>):</p><div><pre class="programlisting">454. # File name: sidebar.py
455. 
456. import json
457. 
458. from kivy.uix.togglebutton import ToggleButton
459. from kivy.properties import ObjectProperty
460. from kivy.lang import Builder
461. 
462. Builder.load_file('sidebar.kv')
463. 
464. class ListItem(ToggleButton):
465.     video = ObjectProperty(None)
466. 
467.     def __init__(self, video, meta, surl, **kwargs):
468.         super(self.__class__, self).__init__(**kwargs)
469.         self.video = video
470.         self.meta = meta
471.         self.surl = surl
472. 
473.     def on_state(self, instance, value):
474.         if self.state == 'down':            
475.             data = json.load(open(self.meta))['talk']
476.             self.video.surl = self.surl
477.             self.video.source = data['media']['internal']['950k']['uri']
478.             self.video.image = data['images'][-1]['image']['url']</pre></div><p>This file provides the implementation of the <code class="literal">ListItem</code> class. There are three parameters in the constructor (line 473): an instance of the <code class="literal">video</code> widget, the <code class="literal">meta</code> filename that contains metadata of the video as provided by TED videos, and <code class="literal">surl</code> that contains the subtitle URL. When the <code class="literal">state</code> property of the <code class="literal">ListItem</code> widget changes, the <code class="literal">on_state</code> method (line 474) is called. This <a id="id674" class="indexterm"/>method will open the file provided by TED in a JSON format and extract the necessary information to update the video widget properties. We included in the code of this section, a collection of TED metadata files in the results folder, in order to test the code before you include your own API. For example, <code class="literal">results/97.json</code> contains the metadata for the video of Dan Gilbert we have been using so far. You can verify the JSON structure of the lines 477 and 478 in this subtitle file.</p><p>Now, we need to add a <code class="literal">Sidebar</code> instance to <code class="literal">KivyPlayer</code> in the <code class="literal">kivyplayer.kv</code> file:</p><div><pre class="programlisting">479. # File name: kivyplayer.kv
480. &lt;KivyPlayer&gt;:
481.     list_button: _list_button
482.     action_bar: _action_bar
483.     video_controller: _video_controller
484.     side_bar: _side_bar
485.     playlist: _side_bar.playlist
486. 
487.     VideoController:
488.         id: _video_controller
489.         control_bar_width: root.width - _side_bar.right
490. 
491. (...)
492. 
493.     Sidebar:
494.         id: _side_bar
495.         width: min(_list_button.width,350)
496.         height: root.height - _action_bar.height
497.         top: root.height - _action_bar.height
498.         x: 0 - self.width if _list_button.state == 'normal' else 0</pre></div><p>We have added the <code class="literal">Sidebar</code> instance and defined some <code class="literal">position</code> properties based on the other elements of the screen (lines 495 to 498). We also adjusted <code class="literal">width</code> of the <em>control bar</em> to <code class="literal">side_bar</code> (line 480). When <code class="literal">Sidebar</code> is displayed, then the <em>control bar</em> will<a id="id675" class="indexterm"/> adjust automatically to the available space. We control the display of the sidebar with the <code class="literal">ActionListButton</code> class (line 512), which we are going to define in <code class="literal">kivyplayer.py</code>:</p><div><pre class="programlisting">499. # File name: kivyplayer.py
500. import json
501. import os
502. 
503. (...)
504. 
505. from sidebar import ListItem
506. 
507. Builder.load_file('actiontextinput.kv')
508. 
509. _surl = 'http://www.ted.com/talks/subtitles/id/%s/lang/en'
510. _meta = 'results/%s.json'
511. 
512. class ActionListButton(ToggleButtonBehavior, ActionPrevious):
513.     def on_state(self, instance, value):
514.         if self.state == 'normal':
515.             self.animationSB = Animation(right=0)
516.             self.animationSB.start(self.root.side_bar)
517.         else:
518.             self.root.side_bar.x=0
519. 
520. class KivyPlayer(FloatLayout):
521. 
522.     def __init__(self, **kwargs):
523.         super(self.__class__, self).__init__(**kwargs)
524.         self.playlist.bind(minimum_height= self.playlist.setter('height'))</pre></div><p>The animation of the sidebar is similar to the others we have seen in this chapter. We also included two global variables: <code class="literal">_surl</code> and <code class="literal">_meta</code> (lines 509 and 510). These are strings that will serve as templates for the subtitles and metadata files. Notice that <code class="literal">%s</code> inside the strings will be replaced. We also introduced a constructor (<code class="literal">__init__</code>) to the <code class="literal">KivyPlayer</code> class definition (line 522 and 524). Line 524 is necessary to guarantee that the <code class="literal">GridLayout</code> instance (inside <code class="literal">ScrollView</code>) adapts to its height and therefore, allows scrolling.</p><p>We now need to add the <code class="literal">ListItem</code> instances to the <code class="literal">Sidebar</code> widget. In order to do this, we will define the <code class="literal">load_list</code> method (line 525) and the <code class="literal">load_from_json</code> method (line 532) in <code class="literal">kivyplayer.py</code>:</p><div><pre class="programlisting">525.     def load_list(self, path, filename):
526.         json_data=open(os.path.join(path, filename[0]))
527.         data = json.load(json_data)
528.         json_data.close()
529.         self.load_from_json(data)
530.         self.dismiss_popup()
531. 
532.     def load_from_json(self, data):
533.         self.playlist.clear_widgets()
534.         for val in data['results']:
535.             t = val['talk']
536.             video = self.video_controller.video
537.             meta = _meta % t['id']
538.             surl = _surl % t['id']
539.             item = ListItem(video, meta, surl, text=t['name'])
540.             self.playlist.add_widget(item)
541.         self.list_button.state = 'down'</pre></div><p>We<a id="id676" class="indexterm"/> included a <code class="literal">results.json</code> file that contains an example search result list obtained from the TED site. This result is in the JSON format, which you can check in the file. We need to open this file and display its content in the <em>side bar</em>. In order to do this, we select the <code class="literal">result.json</code> file with the <code class="literal">LoadDialog</code> display using the <strong>Open List</strong> button. Once selected, the <code class="literal">load_list</code> method is called. The method opens the data and loads the JSON data (line 527). Once loaded, it calls the <code class="literal">load_from_json</code> method (line 528). In this method, we create a <code class="literal">ListItem</code> instance (line 539) per result obtained from the search on the TED site, and add the instances to the playlist (that is, the <code class="literal">GridLayout</code> instance inside the <em>side bar</em> (line 451)). The lines 537 and 538 are a common way of concatenating strings in Python. It replaces <code class="literal">%s</code> which are present in strings (lines 509 and 510) with the corresponding parameters after <code class="literal">%</code>. Now, we will see the results as a side bar list in our application when we open the <code class="literal">results.json</code> file as was shown in the screenshot at the beginning of this section.</p></div></div>


  <div><div><div><div><div><h1 class="title"><a id="ch06lvl1sec62"/>Search – query the TED Developer API</h1></div></div></div><p>This<a id="id677" class="indexterm"/> final section will introduce a few changes to the code so that we can search the TED site.</p><div><div><h3 class="title"><a id="tip28"/>Tip</h3><p>The first thing <a id="id678" class="indexterm"/>you need to do is to get an API key from the TED site using the following link:</p><p>
<a class="ulink" href="http://developer.ted.com/member/register">http://developer.ted.com/member/register</a>.</p></div></div><p>A TED API key is an alphanumeric number (something like <code class="literal">'1a3bc2'</code>) that allows you to query <a id="id679" class="indexterm"/>the TED website directly, and get requests in the JSON format we have been using throughout the last section. Once you receive your API key in your e-mail account, you can modify <code class="literal">kivyplayer.py</code> and put it in an <code class="literal">_api global</code> variable. For now, we can use a placeholder like this in the <code class="literal">kivyplayer.py</code> file:</p><div><pre class="programlisting">_api = 'YOUR_API_KEY_GOES_HERE'</pre></div><p>Also, in <code class="literal">kivyplayer.py</code>, we need to introduce a global variable that contains the search template (_<code class="literal">search</code>), and replace the content of the <code class="literal">_meta</code> global variable:</p><div><pre class="programlisting">_search = 'https://api.ted.com/v1/search.json?q=%s&amp;categories=talks&amp;api-key=%s'
_meta = 'https://api.ted.com/v1/talks/%s.json?api-key=%s'</pre></div><p>Notice that the <code class="literal">_meta</code> variable now has two <code class="literal">%</code>. Therefore, we will need to replace the <code class="literal">meta = meta % t['id']</code> code line with <code class="literal">meta = _meta % (t['id'], _api)</code> inside the <code class="literal">load_from_json</code> method (line 533). Also, since we are not opening a file, we also need to replace the way we load the JSON in the <code class="literal">ListItem</code> class since we don't have a file anymore, but a URL. First, we need to import the <code class="literal">URLRequest</code> class (<code class="literal">from kivy.network.urlrequest import UrlRequest</code>) at the beginning of the <code class="literal">sidebar.py</code> file, and then modify the <code class="literal">on_state</code> method to use the <code class="literal">URLRequest</code> class as we learned with the subtitles:</p><div><pre class="programlisting">542.     def on_state(self, instance, value):
543.         if self.state == 'down':
544.             req = UrlRequest(self.meta, self.got_meta)
545.         
546.     def got_meta(self, req, results):
547.         data = results['talk']
548.         self.video.surl = self.surl
549.         self.video.source = data['media']['internal']['950k']['uri']
550.         self.video.image = data['images'][-1]['image']['url'] </pre></div><p>We also need to import the <code class="literal">URLRequest</code> class in <code class="literal">kivyplayer.py</code>, in order to implement the <code class="literal">search</code> method in the <code class="literal">KivyPlayer</code> class definition:</p><div><pre class="programlisting">551.     def search(self, text):
552.         url = _search % (text, _api)
553.         req = UrlRequest(url, self.got_search)
554. 
555.     def got_search(self, req, results):
556.         self.load_from_json(results) </pre></div><p>Now, you <a id="id680" class="indexterm"/>can go and check whether you received your TED API key. Once you have replaced the <code class="literal">_api</code> variable, you will be able to use the search box in the action bar to query the TED API. You can now use the search on <code class="literal">ActionTextInput</code>:</p><div><img src="img/B04244_06_14.jpg" alt="Search – query the TED Developer API"/></div><div><div><h3 class="title"><a id="tip29"/>Tip</h3><p>Keep in mind that the API key you just created can identify you and your application as a user of the TED site. All the activity registered with that API is your responsibility. <em>You shouldn't give this API Key to anyone.</em>
</p></div></div><p>Controlling the use of your API Key involves setting up your own server, where the API key is safely<a id="id681" class="indexterm"/> stored. This server will act as a proxy (<a class="ulink" href="https://en.wikipedia.org/wiki/Proxy_server">https://en.wikipedia.org/wiki/Proxy_server</a>) of your application, and it should limit the queries. For example, it should avoid abusive behavior such as a massive number of queries.</p></div></div>


  <div><div><div><div><div><h1 class="title"><a id="ch06lvl1sec63"/>Summary</h1></div></div></div><p>In this chapter, we created an application that integrates many Kivy components. We discussed how to control a video and how to associate different elements of the screen with it. We explored different Kivy widgets and implemented a complex interaction to display a scrollable list of elements. Here is the list of new classes and components that we used in this chapter:</p><div><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc"><code class="literal">Video</code>: The <code class="literal">allow_stretch</code> and <code class="literal">source</code> properties inherited from <code class="literal">Image</code>; the <code class="literal">state</code> and <code class="literal">progress</code> properties; the <code class="literal">_on_load</code>, <code class="literal">on_eos</code>, <code class="literal">on_source</code> and <code class="literal">on_state</code>, <code class="literal">on_position</code>, <code class="literal">seek</code> methods</li><li class="listitem" style="list-style-type: disc"><code class="literal">AsyncImage</code>: The <code class="literal">source</code> property inherited from <code class="literal">Image</code>; the <code class="literal">opacity</code> (inherited from <code class="literal">Widget</code>) property</li><li class="listitem" style="list-style-type: disc"><code class="literal">Label</code>: The <code class="literal">texture_size</code> property</li><li class="listitem" style="list-style-type: disc"><code class="literal">Slider</code>: The <code class="literal">value</code> and <code class="literal">max</code> properties <code class="literal">Touch</code>: The <code class="literal">double_tap</code> key</li><li class="listitem" style="list-style-type: disc">The Kivy Inspector class</li><li class="listitem" style="list-style-type: disc">The <code class="literal">ActionBar</code>, <code class="literal">ActionView</code>, <code class="literal">ActionItem</code> <code class="literal">ActionPrevious</code>, <code class="literal">ActionToggleButton</code> <code class="literal">ActionGroup</code>, and <code class="literal">ActionButton</code> classes, with <code class="literal">use_separator</code> of <code class="literal">ActionView</code> and title of <code class="literal">ActionPrevious</code> properties</li><li class="listitem" style="list-style-type: disc"><code class="literal">Textinput</code>: The <code class="literal">background_color</code>, <code class="literal">foreground_color</code>, <code class="literal">cursor_color</code> and <code class="literal">multiLine</code> properties</li><li class="listitem" style="list-style-type: disc"><code class="literal">FileChooserListView</code>: The <code class="literal">path</code> property </li><li class="listitem" style="list-style-type: disc">The <code class="literal">ScrollView</code> class</li></ul></div><p>As a side result of the way this chapter, we have obtained an organized is an enhanced <code class="literal">Video</code> widget that we can use in other applications. This <code class="literal">Video</code> widget incorporates synchronization of subtitles that we receive in a JSON format file with the progression of the video and a responsive <em>control bar</em>.</p><p>We have mastered the use of the <code class="literal">Video</code> widget. We learned how to control its progression and add subtitles to it. We also covered how to query the TED Developer API in order to get a result lists, and we have practiced our skills manipulating the JSON format. We also learned how to use the Kivy debugger in order to detect errors in our interfaces.</p><p>We also made an effort to make our <code class="literal">KivyPlayer</code> application look professional. We optimized the use of the screen by introducing animations that hide the GUI components when unnecessary. As part of this process, we used many Kivy elements to make our widget consistent, and we reviewed interesting topics such as behaviors, the factory, animations, touch events, and the use of properties in order to create versatile components.</p><p>The beginning is at the end, so it is now your turn to start your own applications. I really hope that what you have learned from this book will help you to implement your ideas and start your own application.</p></div></div>
</body></html>