- en: Chapter 8. The Template Method Pattern – Encapsulating Algorithm
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In the previous chapter, we started with an introduction to the Command design
    pattern in which an object is used to encapsulate all the information needed to
    perform an action or trigger an event at a later time. We understood the concept
    of the Command design pattern with a UML diagram and also saw how it's applied
    in the real world with the help of the Python implementation. We discussed the
    pros and cons of Command patterns, explored more in the FAQ section, and summarized
    the discussion at the end of the chapter.
  prefs: []
  type: TYPE_NORMAL
- en: In this chapter, we will talk about the Template design pattern, such as the
    Command pattern and Template pattern that falls under the hood of Behavioral patterns.
    We will get introduced to the Template design pattern and discuss how it is used
    in software application development. We will also work with a sample use case
    and implement it in Python v3.5.
  prefs: []
  type: TYPE_NORMAL
- en: 'In this chapter, we will cover the following topics in brief:'
  prefs: []
  type: TYPE_NORMAL
- en: An introduction to the Template Method design pattern
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The Template pattern and its UML diagram
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A real-world use case with the Python v3.5 code implementation
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The Template pattern – pros and cons
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The Hollywood principle, Template Method, and Template hook
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Frequently asked questions
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: At the end of this chapter, you will be able to analyze situations where the
    Template design pattern is applicable and efficiently use them to solve design-related
    problems. We will also summarize the entire discussion on the Template Method
    pattern as a takeaway.
  prefs: []
  type: TYPE_NORMAL
- en: Defining the Template Method pattern
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: As we saw in the previous chapter, Behavioral patterns focus on the responsibilities
    that an object has. It deals with the interaction among objects to achieve larger
    functionality. The Template Method pattern is a behavioral design pattern that
    defines the program skeleton or an algorithm in a method called the Template Method.
    For example, you could define the steps to prepare a beverage as an algorithm
    in a Template Method. The Template Method pattern also helps redefine or customize
    certain steps of the algorithm by deferring the implementation of some of these
    steps to subclasses. This means that the subclasses can redefine their own behavior.
    For example, in this case, subclasses can implement steps to prepare tea using
    the Template Method to prepare a beverage. It is important to note that the change
    in the steps (as done by the subclasses) don't impact the original algorithm's
    structure. Thus, the facility of overriding by subclasses in the Template Method
    pattern allows the creation of different behaviors or algorithms.
  prefs: []
  type: TYPE_NORMAL
- en: To talk about the Template Method pattern in software development terminology,
    an abstract class is used to define the steps of the algorithm. These steps are
    also known as *primitive operations* in the context of the Template Method pattern.
    These steps are defined with abstract methods, and the Template Method defines
    the algorithm. The `ConcreteClass` (that subclasses the abstract class) implements
    subclass-specific steps of the algorithm.
  prefs: []
  type: TYPE_NORMAL
- en: 'The Template Method pattern is used in the following cases:'
  prefs: []
  type: TYPE_NORMAL
- en: When multiple algorithms or classes implement similar or identical logic
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The implementation of algorithms in subclasses helps reduce code duplication
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Multiple algorithms can be defined by letting the subclasses implement the behavior
    through overriding
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Let''s understand the pattern with a very simple day-to-day example. Think
    of what all you do when you prepare tea or coffee. In the case of coffee, you
    perform the following steps to prepare the beverage:'
  prefs: []
  type: TYPE_NORMAL
- en: Boil water.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Brew coffee beans.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Pour it in the coffee cup.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Add sugar and milk to the cup.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Stir, and the coffee is done.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Now, if you want to prepare a cup of tea, you will perform the following steps:'
  prefs: []
  type: TYPE_NORMAL
- en: Boil water.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Steep the tea bag.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Pour the tea in a cup.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Add lemon to the tea.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Stir, and the tea is done.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: If you analyze both the preparations, you will find that both the procedures
    are more or less the same. In this case, we can use the Template Method pattern
    effectively. How do we implement it? We define a `Beverage` class that has abstract
    methods common to preparing tea and coffee, such as `boilWater()`. We also define
    the `preparation()` Template Method that will call out the sequence of steps in
    preparing the beverage (the algorithm). We let the concrete classes, `PrepareCoffee`
    and `PrepareTea`, define the customized steps to achieve the goals of preparing
    coffee and tea. This is how the Template Method pattern avoids code duplication.
  prefs: []
  type: TYPE_NORMAL
- en: 'Another easy example is that of the compiler used by computer languages. A
    compiler essentially does two things: collects the source and compiles to the
    target object. Now, if we need to define a cross compiler for iOS devices, we
    can implement this with the help of the Template Method pattern. We will read
    about this example in detail later in the chapter.'
  prefs: []
  type: TYPE_NORMAL
- en: Understanding the Template Method design pattern
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'In short, the main intentions of the Template Method pattern are as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: Defining a skeleton of an algorithm with primitive operations
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Redefining certain operations of the subclass without changing the algorithm's
    structure
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Achieving code reuse and avoiding duplicate efforts
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Leveraging common interfaces or implementations
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The Template Method pattern works with the following terms—`AbstractClass`,
    `ConcreteClass`, Template Method, and `Client`:'
  prefs: []
  type: TYPE_NORMAL
- en: '`AbstractClass`: This declares an interface to define the steps of the algorithm'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`ConcreteClass`: This defines subclass-specific step definitions'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`template_method()`: This defines the algorithm by calling the step methods'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: We talked about the example of a compiler earlier in the chapter. Consider that
    we want to develop our own cross compiler for an iOS device and run the program.
  prefs: []
  type: TYPE_NORMAL
- en: We first develop an abstract class (compiler) that defines the algorithm of
    a compiler. The operations done by the compiler are collecting the source of the
    code written in a program language and then compiling it to get the object code
    (binary format). We define these steps as the `collectSource()` and `compileToObject()`
    abstract methods and also define the `run()` method that is responsible for executing
    the program. The algorithm is defined by the `compileAndRun()` method, which internally
    calls the `collectSource()`, `compileToObject()`, and `run()` methods to define
    the algorithm of the compiler. The `iOSCompiler` concrete class now implements
    the abstract methods and compiles/runs the Swift code on the iOS device.
  prefs: []
  type: TYPE_NORMAL
- en: Tip
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The Swift programming language is used to develop applications on the iOS platform.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following Python code implements the Template Method design pattern:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'The output of the preceding code should look as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Understanding the Template Method design pattern](img/00026.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: A UML class diagram for the Template Method pattern
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Let's understand more about the Template method pattern with the help of a UML
    diagram.
  prefs: []
  type: TYPE_NORMAL
- en: 'As we discussed in the previous section, the Template method pattern has the
    following main participants: the abstract class, concrete class, Template method,
    and client. Let''s put these in a UML diagram and see how the classes look:'
  prefs: []
  type: TYPE_NORMAL
- en: '![A UML class diagram for the Template Method pattern](img/00027.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: 'As we look at the UML diagram, you''ll realize that there are four main participants
    in this pattern:'
  prefs: []
  type: TYPE_NORMAL
- en: '`AbstractClass`: This defines the operations or steps of an algorithm with
    the help of abstract methods. These steps are overridden by concrete subclasses.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`template_method()`: This defines the skeleton of the algorithm. Multiple steps
    as defined by abstract methods are called in the Template method to define the
    sequence or the algorithm itself.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`ConcreteClass`: This implements the steps (as defined by the abstract methods)
    to perform subclass-specific steps of the algorithm.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The following is a code example to understand the pattern with all the participants
    involved:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: 'The output of the preceding code should look as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '![A UML class diagram for the Template Method pattern](img/00028.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: The Template Method pattern in the real world
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Let's take a very easy-to-understand scenario to implement the Template method
    pattern. Imagine the case of a travel agency, say, Dev Travels. Now how do they
    typically work? They define various trips to various locations and come up with
    a holiday package for you. A package is essentially a trip that you, as a customer,
    undertakes. A trip has details such as the places visited, transportation used,
    and other factors that define the trip itinerary. This same trip can be customized
    differently based on the needs of the customers. This calls for the Template Method
    pattern, doesn't it?
  prefs: []
  type: TYPE_NORMAL
- en: 'Design Considerations:'
  prefs: []
  type: TYPE_NORMAL
- en: For the preceding scenario, based on the UML diagram, we should create an `AbstractClass`
    interface that defines a trip
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The trip should contain multiple abstract methods that define the transportation
    used, places visited on `day1`, `day2`, and `day3`, assuming that it's a three-day
    long weekend trip, and also define the return journey
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The `itinerary()` Template Method will actually define the trip's itinerary
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: We should define `ConcreteClasses` that would help us customize trips differently
    based on the customer's needs
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Let''s develop an application in Python v3.5 and implement the preceding use
    case. We start with the abstract class, `Trip`:'
  prefs: []
  type: TYPE_NORMAL
- en: The abstract object is represented by the `Trip` class. It is an interface (Python's
    abstract base class) that defines the details such as the transportation used
    and places to visit on different days.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The `setTransport` is an abstract method that should be implemented by `ConcreteClass`
    to set the mode of transportation.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The `day1()`, `day2()`, `day3()` abstract methods define the places visited
    on the given day.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The `itinerary()` Template Method creates the complete itinerary (the algorithm,
    in this case, the trip). The sequence of the trip is to first define the transportation
    mode, then the places to visit on each day, and the `returnHome`.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The following code implements the scenario of Dev Travels:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: 'We have also developed certain classes that represent the concrete class:'
  prefs: []
  type: TYPE_NORMAL
- en: In this case, we have two main concrete classes—`VeniceTrip` and `MaldivesTrip`—that
    implement the `Trip` interface
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Concrete classes represent two different trips taken by the tourists based on
    their choice and interests
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`VeniceTrip` and `MaldivesTrip` both implement `setTransport()`, `day1()`,
    `day2()`, `day3()`, and `returnHome()`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Let''s define the concrete classes in Python code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, let''s talk about the travel agency and tourists who want to have an awesome
    vacation:'
  prefs: []
  type: TYPE_NORMAL
- en: The `TravelAgency` class represents the `Client` object in this example
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: It defines the `arrange_trip()` method that provides customers with the choice
    of whether they want to have a historical trip or beach trip
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Based on the choice made by the tourist, an appropriate class is instantiated
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: This object then calls the `itinerary()` Template Method and the trip is arranged
    for the tourists as per the choice of the customers
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The following is the implementation for the Dev travel agency and how they
    arrange for the trip based on the customer''s choice:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: 'The output of the preceding code should look as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '![The Template Method pattern in the real world](img/00029.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: 'If you decide to go on a historical trip, this will be the output of the code:'
  prefs: []
  type: TYPE_NORMAL
- en: '![The Template Method pattern in the real world](img/00030.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: The Template Method pattern – hooks
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: A hook is a method that is declared in the abstract class. It is generally given
    a default implementation. The idea behind hooks is to give a subclass the ability
    to *hook into* the algorithm whenever needed. It's not imperative for the subclass
    to use hooks and it can easily ignore this.
  prefs: []
  type: TYPE_NORMAL
- en: For example, in the beverage example, we can add a simple hook to see if condiments
    need to be served along with tea or coffee based on the wish of the customer.
  prefs: []
  type: TYPE_NORMAL
- en: Another example of hook can be in the case of the travel agency example. Now,
    if we have a few elderly tourists, they may not want to go out on all three days
    of the trip as they may get tired easily. In this case, we can develop a hook
    that will ensure `day2` is lightly loaded, which means that they can go to a few
    nearby places and be back with the plan of `day3`.
  prefs: []
  type: TYPE_NORMAL
- en: Basically, we use abstract methods when the subclass must provide the implementation,
    and hook is used when it is optional for the subclass to implement it.
  prefs: []
  type: TYPE_NORMAL
- en: The Hollywood principle and the Template Method
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The Hollywood principle is the design principle that is summarized by *Don't
    call us, we'll call you*. It comes from the Hollywood philosophy where the production
    houses call actors if there is any role for the actor.
  prefs: []
  type: TYPE_NORMAL
- en: In the object-oriented world, we allow low-level components to hook themselves
    into the system with the Hollywood principle. However, the high-level components
    determine how the low-level systems are needed and when they are needed. In other
    words, high-level components treat low-level components as *Don't call us, we'll
    call you*.
  prefs: []
  type: TYPE_NORMAL
- en: This relates to the Template Method pattern in the sense that it's the high-level
    abstract class that arranges the steps to define the algorithm. Based on how the
    algorithm is, low-level classes are called on to define the concrete implementation
    for the steps.
  prefs: []
  type: TYPE_NORMAL
- en: The advantages and disadvantages of the Template Method pattern
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The Template Method pattern provides you with the following advantages:'
  prefs: []
  type: TYPE_NORMAL
- en: As we saw earlier in the chapter, there is no code duplication.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Code reuse happens with the Template Method pattern as it uses inheritance and
    not composition. Only a few methods need to be overridden.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Flexibility lets subclasses decide how to implement steps in an algorithm.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The disadvantages of Template Method patterns are as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: Debugging and understanding the sequence of flow in the Template Method pattern
    can be confusing at times. You may end up implementing a method that shouldn't
    be implemented or not implementing an abstract method at all. Documentation and
    strict error handling has to be done by the programmer.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Maintenance of the template framework can be a problem as changes at any level
    (low-level or high-level) can disturb the implementation. Hence, maintenance can
    be painful with the Template Method pattern.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Frequently asked questions
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Q1\. Should a low-level component be disallowed from calling a method in a higher-level
    component?
  prefs: []
  type: TYPE_NORMAL
- en: 'A: No, a low-level component would definitely call the higher-level component
    through inheritance. However, what the programmer needs to make sure is that there
    is no circular dependency where the low-level and high-level components are dependent
    on each other.'
  prefs: []
  type: TYPE_NORMAL
- en: Q2\. Isn't the strategy pattern similar to the Template pattern?
  prefs: []
  type: TYPE_NORMAL
- en: 'A: The strategy pattern and Template pattern both encapsulate algorithms. Template
    depends on inheritance while strategy uses composition. The Template Method pattern
    is a compile-time algorithm selection by sub-classing while the strategy pattern
    is a runtime selection.'
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We began the chapter by understanding the Template Method design pattern and
    how it is effectively used in software architecture.
  prefs: []
  type: TYPE_NORMAL
- en: We also looked at how the Template Method design pattern is used to encapsulate
    the algorithm and provide the flexibility of implementing different behavior by
    overriding the methods in the subclasses.
  prefs: []
  type: TYPE_NORMAL
- en: You learned the pattern with a UML diagram and sample code implementation in
    Python v3.5 along with the explanation.
  prefs: []
  type: TYPE_NORMAL
- en: We also covered a section on FAQs that would help you get a better idea of the
    pattern and its possible advantages/disadvantages.
  prefs: []
  type: TYPE_NORMAL
- en: We will now talk about a composite pattern in the next chapter—the MVC design
    pattern.
  prefs: []
  type: TYPE_NORMAL
