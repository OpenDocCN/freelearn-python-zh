["```py\n    ob('Knob').RotZ*(360/(2*m.pi))/10\n    ```", "```py\nob('Knob').RotZ*(360/(2*m.pi))/10/12\n```", "```py\nif a>b:\n   c=14\nelse:\n   c=109\n```", "```py\nc = (a>b)*14 + (a<=b)*109\n```", "```py\ndef clamp(a,low,high):\n   if a<low : a=low\n   if a>high: a=high\n   return a\n```", "```py\nob('Flywheel').RotX/(2*m.pi)*36\n```", "```py\nm.degrees(ob('Flywheel').RotX*-0.5)/10.0\n```", "```py\nob('DriveShaftPart').RotX/(2*m.pi)*18+9\n```", "```py\nob('DriveShaftPart').RotX/(2*m.pi)*18+24\n```", "```py\ndef q(l,r,a): return r*cos(a)+sqrt(l**2-(r*sin(a))**2)\n```", "```py\np.q(1.542,0.655,ob('DriveShaftPart').RotX)\n```", "```py\ndef topa(l,r,a):\n   Q=q(l,r,a)\n   ac=acos((Q**2+l**2-r**2)/(2*Q*l))\n   if a%(2*pi)>pi : ac = -ac\n   return -ac\n```", "```py\nm.degrees(p.topa(1.542,0.655,ob('DriveShaftPart').RotX))/10.0\n```", "```py\ndef spike(angle):\n   t = (cos(angle)+1.0)/2.0\n   return t**4\n```", "```py\ndef valveZ(angle,tilt,travel,offset):\n   return cos(radians(tilt))*spike(angle)*travel+offset\ndef valveY(angle,tilt,travel,offset):\n   return sin(radians(tilt))*spike(angle)*travel+offset\n```", "```py\np.valveZ(ob('CamInlet').RotX+m.pi,-10.0,-0.1,6.55)\n```", "```py\np.valveY(ob('CamInlet').RotX+m.pi,-10.0,-0.1,-0.03)\n```", "```py\ndef topi(a,h,i):\n   m = a%(2*pi)\n   r=0.0\n   if m<h: r=i\n   return r\n```", "```py\np.topi(ob('DriveShaftPart').RotX/2+m.pi,0.3,0.5)\n```", "```py\nfrom Blender.Constraint import Type\nfrom Blender.Constraint import Settings\n```", "```py\ndef zrotonly(obbones,bone):\n   poseob = obbones.getPose()\n   bigarmpose = poseob.bones[bone]\n   c=bigarmpose.constraints.append(Type.LIMITROT)\n   c[Settings.LIMIT]=Settings.LIMIT_XROT|Settings.LIMIT_YROT\n   c[Settings.XMIN]=0.0\n   c[Settings.XMAX]=0.0\n   c[Settings.YMIN]=0.0\n   c[Settings.YMAX]=0.0\n   poseob.update()\n```", "```py\n#BPYCONSTRAINT\n```", "```py\ndef doConstraint(obmatrix, targetmatrices, idprop):\n   # Separate out the transformation components for easy access.\n   obloc = obmatrix.translationPart()   # Translation\n   obrot = obmatrix.toEuler()         # Rotation\n   obsca = obmatrix.scalePart()      # Scale\n\n   # code to actually change location, rotation or scale goes here\n\n   # Convert back into a matrix for loc, scale, rotation,\n   mtxloc = Mathutils.TranslationMatrix(obloc)\n   mtxrot = obrot.toMatrix().resize4x4()\n   mtxsca = Mathutils.Matrix([obsca[0],0,0,0], [0,obsca[1],0,0],[0,0,obsca[2],0], [0,0,0,1])\n\n   # Recombine the separate elements into a transform matrix.\n   outputmatrix = mtxsca * mtxrot * mtxloc\n\n   # Return the new matrix.\n   return outputmatrix\n```", "```py\ndef doTarget(target_object, subtarget_bone, target_matrix,id_properties_of_constraint):\n   return target_matrix\n```", "```py\ndef getSettings(idprop):\n   return\n```", "```py\ndef doConstraint(obmatrix, targetmatrices, idprop):\n   obloc = obmatrix.translationPart()   # Translation\n   obrot = obmatrix.toEuler()         # Rotation\n   obsca = obmatrix.scalePart()      # Scale\n\n   tloc = targetmatrices[0].translationPart()\n   d = abs((obloc-tloc).length)\n   d = max(0.01,d)\n   f = 1.0+1.0/d\n   obsca[1]*=f\n\n   mtxloc = Mathutils.TranslationMatrix(obloc)\n   mtxrot = obrot.toMatrix().resize4x4()\n   mtxsca = Mathutils.Matrix([obsca[0],0,0,0], [0,obsca[1],0,0],[0,0,obsca[2],0], [0,0,0,1])\n\n   outputmatrix = mtxsca * mtxrot * mtxloc\n\n   return outputmatrix\n```", "```py\ndef doConstraint(obmatrix, targetmatrices, idprop):\n\n   obloc = obmatrix.translationPart().resize3D()\n   obrot = obmatrix.toEuler()      \n   obsca = obmatrix.scalePart()\n\n   # get the target mesh\n   **to = Blender.Object.Get(idprop['target_object'])**\n   me = to.getData(mesh=1)\n\n   # get the location of the target object\n   tloc = targetmatrices[0].translationPart().resize3D()\n\n   # find the nearest vertex in the target object\n   smallest = 1000000.0\n   delta_ob=tloc-obloc\n   for v in me.verts:\n      d = (v.co+delta_ob).length\n      if d < smallest:\n         smallest=d\n         sv=v\n   obloc = sv.co + tloc\n\n   # reconstruct the object matrix\n   mtxrot = obrot.toMatrix().resize4x4()\n   mtxloc = Mathutils.TranslationMatrix(obloc)\n   mtxsca = Mathutils.Matrix([obsca[0],0,0,0], [0,obsca[1],0,0],[0,0,obsca[2],0], [0,0,0,1])\n   outputmatrix = mtxsca * mtxrot * mtxloc\n   return outputmatrix\n\ndef doTarget(target_object, subtarget_bone, target_matrix,id_properties_of_constraint):\n **  id_properties_of_constraint['target_object']=target_object.name**\n   return target_matrix\n```", "```py\n vnormal = sv.no\n   if idprop['NormalAlign'] :\n      zunit=Mathutils.Vector(0,0,1)\n **     a=Mathutils.AngleBetweenVecs(vnormal,zunit)**\n **     rotaxis=zunit.cross(vnormal)**\n **     rotmatrix=Mathutils.RotationMatrix(a,4,\"r\",rotaxis)**\n      mtxrot = rotmatrix\n   else:\n      mtxrot = obrot.toMatrix().resize4x4()\n```", "```py\ndef getSettings(idprop):\n   if not idprop.has_key('NormalAlign'): idprop['NormalAlign'] = True\n\n   align = Draw.Create(idprop['NormalAlign'])\n\n   block = []\n   block.append(\"Additional restrictions: \")\n   block.append((\"Alignment: \",align,\"Align along vertex normal\"))\n\n   retval = Draw.PupBlock(\"Zoning Constraint\", block)\n\n   if (retval):\n      idprop['NormalAlign']= align.val\n```", "```py\n # get the target mesh\n   to = Blender.Object.Get(idprop['target_object'])\n   me = to.getData(mesh=1)\n\n   # get the location of the target object\n   tloc = targetmatrices[0].translationPart().resize3D()\n\n   # find the nearest vertex in the target object\n   smallest = 1000000.0\n   delta_ob=tloc-obloc\n\n **  try:**\n **     verts = me.getVertsFromGroup(idprop['VertexGroup'])**\n **     for vi in verts:**\n **        d = (me.verts[vi].co+delta_ob).length**\n **        if d < smallest :**\n **           smallest = d**\n **           si = vi**\n **     obloc = me.verts[si].co+tloc**\n **     vnormal = me.verts[si].no**\n **  except AttributeError:**\n      for v in me.verts:\n         d = (v.co+delta_ob).length\n         if d < smallest:\n            smallest=d\n            sv=v\n      obloc = sv.co + tloc\n      vnormal = sv.no \n```", "```py\ndef getSettings(idprop):\n **  if not idprop.has_key('VertexGroup'): idprop['VertexGroup'] ='Zone'**\n   if not idprop.has_key('NormalAlign'): idprop['NormalAlign'] = True\n\n **  vgroup = Draw.Create(idprop['VertexGroup'])**\n   align = Draw.Create(idprop['NormalAlign'])\n\n   block = []\n   block.append(\"Additional restrictions: \")\n **  block.append((\"Vertex Group: \",vgroup,0,30,\"Vertex Group torestrict location to\"))**\n   block.append((\"Alignment: \",align,\"Align along vertex normal\"))\n\n   retval = Draw.PupBlock(\"Zoning Constraint\", block)\n\n   if (retval):\n **     idprop['VertexGroup']= vgroup.val**\n      idprop['NormalAlign']= align.val\n```"]