- en: Creating API Views
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In this chapter, we have to run our first version of a RESTful Web Service
    powered by Django. We will write API views to process different HTTP requests
    and we will perform HTTP requests with command-line and GUI tools. We will analyze
    how Django and Django REST framework process each HTTP request. We will gain an
    understanding of:'
  prefs: []
  type: TYPE_NORMAL
- en: Creating Django views combined with serializer classes
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: CRUD operations with Django views and the request methods
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Launching Django's development server
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Making HTTP GET requests that target a collection of instances with command-line
    tools
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Making HTTP GET requests that target a single instance with command-line tools
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Making HTTP GET requests with command-line tools
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Making HTTP POST requests with command-line tools
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Making HTTP PUT requests with command-line tools
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Making HTTP DELETE requests with command-line tools
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Making HTTP GET requests with Postman
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Making HTTP POST requests with Postman
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Creating Django views combined with serializer classes
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'We have created the necessary model and its serializer. It is time to code
    the necessary elements to process HTTP requests and produce HTTP responses. Now,
    we will create Django views that use the `ToySerializer` class that we created
    previously to return JSON representations of the entities for each HTTP request
    that our web service will handle. Open the `toys/views.py` file. The following
    lines show the initial code for this file with just one import statement and a
    comment that indicates we should create the views:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: We will create our first version of the web service and we will use functions
    to keep the code as simple as possible. We will work with classes and more complex
    code in later examples. First, it is very important to understand how Django and
    Django REST framework work by way of a simple example.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, write the following lines in the `restful01/toys/views.py` file to create
    a `JSONResponse` class and declare two functions: `toy_list` and `toy_detail`.
    The code file for the sample is included in the `hillar_django_restful_03_01`
    folder, in the `restful01/toys/views.py` file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: The highlighted lines show the expressions that evaluate the value of the `request.method`
    attribute to determine the actions to be performed based on the HTTP verb. The
    `JSONResponse` class is a subclass of the `django.http.HttpResponse` class. The
    `django.http.HttpResponse` superclass represents an HTTP response with string
    content.
  prefs: []
  type: TYPE_NORMAL
- en: The `JSONResponse` class renders its content in JSON. The class just declares
    the `__init__` method that creates a `rest_framework.renderers.JSONRenderer` instance
    and calls its `render` method to render the received data in JSON and save the
    returned byte string in the `content` local variable. Then, the code adds the
    `'content_type'` key to the response header with `'application/json'` as its value.
    Finally, the code calls the initializer for the base class with the JSON byte
    string and the key-value pair added to the header. This way, the class represents
    a JSON response that we use in the two functions to easily return a JSON response
    in each HTTP request our web service will process. Since Django 1.7, the `django.http.JsonResponse`
    class has accomplished the same goal. However, we created our own class for educational
    purposes in this example as well as to understand the difference between an `HttpResponse`
    and a `JSONResponse`.
  prefs: []
  type: TYPE_NORMAL
- en: The code uses the `@csrf_exempt` decorator in the two functions to ensure that
    the view sets a **CSRF** (short for **Cross-Site Request Forgery**) cookie. We
    do this to make it easier to test this example, which doesn't represent a production-ready
    web service. We will add security features to our RESTful Web Service later. Of
    course, it is very important to understand that we should never put a web service
    into production before configuring security and throttling rules.
  prefs: []
  type: TYPE_NORMAL
- en: Note that the previous code has many problems that we will analyze and fix in
    the forthcoming chapters. However, first, we need to understand how some basic
    things work.
  prefs: []
  type: TYPE_NORMAL
- en: Understanding CRUD operations with Django views and the request methods
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: When the Django server receives an HTTP request, Django creates an `HttpRequest`
    instance, specifically a `django.http.HttpRequest` object. This instance contains
    metadata about the request, and this metadata includes an HTTP verb such as GET,
    POST, or PUT. The `method` attribute provides a string representing the HTTP verb
    or method used in the request.
  prefs: []
  type: TYPE_NORMAL
- en: When Django loads the appropriate view that will process the request, it passes
    the `HttpRequest` instance as the first argument to the `view` function. The `view`
    function has to return an `HttpResponse` instance, specifically a `django.http.HttpResponse`
    instance.
  prefs: []
  type: TYPE_NORMAL
- en: 'The `toy_list` function lists all the toys or creates a new toy. The function
    receives an `HttpRequest` instance in the `request` argument. The function is
    capable of processing two HTTP verbs: `GET` and `POST`. The code checks the value
    of the `request.method` attribute to determine the code to be executed based on
    the HTTP verb.'
  prefs: []
  type: TYPE_NORMAL
- en: If the HTTP verb is `GET`, the expression `request.method == 'GET'` will evaluate
    to `True` and the code has to list all the toys. The code will retrieve all the
    `Toy` objects from the database, use the `ToySerializer` to serialize all of them
    and return a `JSONResponse` instance built with the data generated by the `ToySerializer`
    serializer. The code creates the `ToySerializer` instance with the `many=True`
    argument to specify that multiple instances have to be serialized and not just
    one. Under the hood, Django uses a `ListSerializer` instance when the `many` argument
    value is set to `True`. This way, Django is capable of serializing a list of objects.
  prefs: []
  type: TYPE_NORMAL
- en: If the HTTP verb is `POST`, the code has to create a new toy based on the JSON
    data that is included in the body of the HTTP request. First, the code uses a
    `JSONParser` instance and calls its `parse` method with the `request` parameter
    that the `toy_list` function receives as an argument to parse the toy data provided
    as `JSON` data in the request body and saves the results in the `toy_data` local
    variable. Then, the code creates a `ToySerializer` instance with the previously
    retrieved data and calls the `is_valid` method to determine whether the `Toy`
    instance is valid or not. If the instance is valid, the code calls the `save`
    method to persist the instance in the database and returns a `JSONResponse` with
    the saved data in its body and a status equal to `status.HTTP_201_CREATED`, that
    is, `201 Created`.
  prefs: []
  type: TYPE_NORMAL
- en: Whenever we have to return a specific status different from the default `200
    OK` status, it is a good practice to use the module variables defined in the `rest_framework.status`
    module and avoid using hard-coded numeric values. If you see `status=status.HTTP_201_CREATED`,
    as in the sample code, it is easy to understand that the status is an HTTP `201
    Created` status. If you read `status=201`, you have to remember what the number
    201 stands for in the HTTP status codes.
  prefs: []
  type: TYPE_NORMAL
- en: 'The `toy_detail` function retrieves, updates, or deletes an existing toy. The
    function receives an `HttpRequest` instance in the `request` argument and the
    identifier for the toy to be retrieved, updated, or deleted in the `pk` argument.
    The function is capable of processing three HTTP verbs: `GET`, `PUT`, and `DELETE`.
    The code checks the value of the `request.method` attribute to determine the code
    to be executed based on the HTTP verb.'
  prefs: []
  type: TYPE_NORMAL
- en: No matter what the HTTP verb is, the `toy_detail` function calls the `Toy.objects.get`
    method with the received `pk` as the `pk` argument to retrieve a `Toy` instance
    from the database based on the specified identifier, and saves it in the `toy`
    local variable. In case a toy with the specified identifier doesn't exist in the
    database, the code returns an `HttpResponse` with its status set to `status.HTTP_404_NOT_FOUND`,
    that is, `404 Not Found`.
  prefs: []
  type: TYPE_NORMAL
- en: If the HTTP verb is `GET`, the code creates a `ToySerializer` instance with
    `toy` as an argument and returns the data for the serialized toy in a `JSONResponse`
    that will include the default HTTP `200 OK` status. The code returns the retrieved
    toy serialized as JSON in the response body.
  prefs: []
  type: TYPE_NORMAL
- en: If the HTTP verb is `PUT`, the code has to create a new toy based on the JSON
    data that is included in the HTTP request and use it to replace an existing toy.
    First, the code uses a `JSONParser` instance and calls its `parse` method with
    `request` as an argument to parse the toy data provided as JSON data in the request
    and saves the results in the `toy_data` local variable. Then, the code creates
    a `ToySerializer` instance with the `Toy` instance previously retrieved from the
    database (`toy`) and the retrieved data that will replace the existing data (`toy_data`).
    Then, the code calls the `is_valid` method to determine whether the `Toy` instance
    is valid or not. If the instance is valid, the code calls the `save` method to
    persist the instance with the replaced values in the database and returns a `JSONResponse`
    with the saved data serialized as JSON in its body and the default HTTP `200 OK`
    status. If the parsed data doesn't generate a valid `Toy` instance, the code returns
    a `JSONResponse` with a status equal to `status.HTTP_400_BAD_REQUEST`, that is
    `400 Bad Request`.
  prefs: []
  type: TYPE_NORMAL
- en: If the HTTP verb is `DELETE`, the code calls the `delete` method for the `Toy`
    instance previously retrieved from the database (`toy`). The call to the `delete`
    method erases the underlying row in the `toys_toy` table that we analyzed in the
    previous chapter. Thus, the toy won't be available anymore. Then, the code returns
    a `JSONResponse` with a status equal to `status`. `HTTP_204_NO_CONTENT` that is,
    `204 No Content`.
  prefs: []
  type: TYPE_NORMAL
- en: Routing URLs to Django views and functions
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Now, we have to create a new Python file named `urls.py` in the `toys` folder,
    specifically, the `toys/urls.py` file. The following lines show the code for this
    file, which defines the URL patterns that specify the regular expressions that
    have to be matched in the request to run a specific function previously defined
    in the `views.py` file. The code file for the sample is included in the `hillar_django_restful_03_01`
    folder, in the `restful01/toys/urls.py` file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: The `urlpatterns` list makes it possible to route URLs to views. The code calls
    the `django.conf.urls.url` function with the regular expression that has to be
    matched and the `view` function defined in the `views` module as arguments to
    create a `RegexURLPattern` instance for each entry in the `urlpatterns` list.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, we have to replace the code in the `urls.py` file in the `restful01` folder,
    specifically, the `restful01/urls.py` file. The file defines the root URL configurations,
    and therefore we must include the URL patterns declared in the previously coded
    `toys/urls.py` file. The following lines show the new code for the `restful01/urls.py`
    file. The code file for the sample is included in the `hillar_django_restful_03_01`
    folder, in the `restful01/urls.py` file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: Launching Django's development server
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Now, we can launch Django's development server to compose and send HTTP requests
    to our unsecured web service. Remember that we will add security later.
  prefs: []
  type: TYPE_NORMAL
- en: 'Execute the following command in a Linux or macOS Terminal, or in the Windows
    Command Prompt or Powershell that has our previously created virtual environment
    activated. Make sure you are in the `restful01` folder within the virtual environment''s
    main folder:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: 'The following lines show the output after we execute the previous command.
    The development server is listening at port `8000`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: With the previous command, we will start the Django development server and we
    will only be able to access it on our development computer. The previous command
    starts the development server at the default IP address, that is, `127.0.0.1`
    (`localhost`). It is not possible to access this IP address from other computers
    or devices connected to our LAN. Thus, if we want to make HTTP requests to our
    API from other computers or devices connected to our LAN, we should use the development
    computer IP address, `0.0.0.0` (for IPv4 configurations) or `::` (for IPv6 configurations)
    as the desired IP address for our development server.
  prefs: []
  type: TYPE_NORMAL
- en: 'If we specify `0.0.0.0` as the desired IP address for IPv4 configurations,
    the development server will listen on every interface on port 8000\. When we specify
    `::` for IPv6 configurations, it will have the same effect. In addition, it is
    necessary to open the default port `8000` in our firewalls (software and/or hardware)
    and configure port-forwarding to the computer that is running the development
    server. The following command launches Django''s development server in an IPv4
    configuration and allows requests to be made from other computers and devices
    connected to our LAN:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: If you decide to compose and send HTTP requests from other computers or devices
    connected to the LAN, remember that you have to use the development computer's
    assigned IP address instead of `localhost`. For example, if the computer's assigned
    IPv4 IP address is `192.168.2.103`, instead of `localhost:8000`, you should use
    `192.168.2.103:8000`. Of course, you can also use the hostname instead of the
    IP address.
  prefs: []
  type: TYPE_NORMAL
- en: The previously explained configurations are very important because mobile devices
    might be the consumers of our RESTful Web Services and we will always want to
    test the apps that make use of our web services and APIs in our development environments.
  prefs: []
  type: TYPE_NORMAL
- en: Making HTTP GET requests that target a collection of instances
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In [Chapter 1](dj-rst-websvc_ch11.html), *Installing the Required Software and
    Tools*, we installed command-line and GUI tools that were going to allow us to
    compose and send HTTP requests to the web services we were going to build throughout
    this book. Now, we will use the curl utility to make HTTP GET requests, specifically,
    HTTP GET requests that target a collection of toys. In case curl is not included
    in the path, make sure you replace curl with the full path to this utility.
  prefs: []
  type: TYPE_NORMAL
- en: Make sure you leave the Django development server running. Don't close the terminal
    or Command Prompt that is running this development server. Open a new Terminal
    in Linux or macOS, or a Command Prompt in Windows, and run the following command.
    It is very important that you enter the ending slash (`/`) because `/toys` won't
    match any of the patterns specified in `urlpatterns` in the `toys/urls.py` file.
    We aren't going to use options to follow redirects. Thus, we must enter `/toys/`,
    including the ending slash (`/`).
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: 'The previous command will compose and send the following HTTP request: `GET
    http://localhost:8000/toys/`. The request is the simplest case in our RESTful
    Web Service because it will match and run the `views.toy_list` function, that
    is, the `toy_list` function we coded within the `toys/views.py` file. The function
    just receives `request` as a parameter because the URL pattern doesn''t include
    any parameters. As the HTTP verb for the request is `GET`, the `request.method`
    property is equal to `''GET''`, and therefore, the function will execute the code
    that retrieves all the `Toy` objects and generates a JSON response with all of
    these `Toy` objects serialized.'
  prefs: []
  type: TYPE_NORMAL
- en: 'The following lines show an example response for the HTTP request, with three
    `Toy` objects in the JSON response:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: As we might notice from the previous response, the curl utility displays the
    JSON response in a single line, and therefore, it is a bit difficult to read.
    It is possible to use different tools, including some Python scripts, to provide
    a better format to the response. However, we will use the HTTPie command-line
    tool we installed in our virtual environment for this purpose later.
  prefs: []
  type: TYPE_NORMAL
- en: In this case, we know that the value of the `Content-Type` header key of the
    response is `application/json`. However, in case we want more details about the
    response, we can use the `-i` option to request curl to print the HTTP response
    headers and their key-value pairs. We can combine the `-i` and `-X` options by
    entering `-iX`.
  prefs: []
  type: TYPE_NORMAL
- en: 'Go back to the terminal in Linux or macOS, or the Command prompt in Windows,
    and run the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: 'The following lines show an example response for the HTTP request. The first
    lines show the HTTP response headers, including the status (`200 OK`) and the
    `Content-Type: application/json`. After the HTTP response headers, we can see
    the details for the three `Toy` objects in the JSON response:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: After we run the two requests, we will see the following lines in the window
    running the Django development server. The output indicates that the server received
    two HTTP requests with the `GET` verb and `/toys/` as the URI. The server processed
    both HTTP requests, returned a status code equal to `200`, and the response length
    was equal to `548` characters.
  prefs: []
  type: TYPE_NORMAL
- en: 'The response length might be different because the value for the primary key
    assigned to each toy will have an incidence in the response length. The first
    number after `HTTP/1.1."` indicates the returned status code (`200`) and the second
    number the response length (`548`):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: 'The following image shows two Terminal windows side-by-side on macOS. The Terminal
    window on the left-hand side is running the Django development server and displays
    the received and processed HTTP requests. The Terminal window on the right-hand
    side is running `curl` commands to generate the HTTP requests. It is a good idea
    to use a similar configuration to check the output while we compose and send the
    HTTP requests. Notice that the JSON outputs are a bit difficult to read because
    they don''t use syntax highlighting:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/58c92084-44cd-45fa-9d0d-309ab5577703.png)'
  prefs: []
  type: TYPE_IMG
- en: Now, open a new Terminal in Linux or macOS, or a new Command Prompt in Windows,
    and activate the virtual environment we created. This way, you will be able to
    access the HTTPie utility we installed within the virtual environment.
  prefs: []
  type: TYPE_NORMAL
- en: 'We will use the `http` command to easily compose and send HTTP requests to
    `localhost:8000` and test the RESTful Web Service. HTTPie supports curl-like shorthand
    for localhost, and therefore we can use `:8000` as a shorthand that expands to
    `http://localhost:8000`. Run the following command and remember to enter the ending
    slash (`/`):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: 'The previous command will compose and send the following HTTP request: `GET
    http://localhost:8000/toys/`. The request is the same one we previously composed
    with the `curl` command. However, in this case, the HTTPie utility will display
    a colorized output and it will use multiple lines to display the JSON response,
    without any additional tweaks. The previous command is equivalent to the following
    command that specifies the `GET` method after `http`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: 'The following lines show an example response for the HTTP request, with the
    headers and the three `Toy` objects in the JSON response. It is indeed easier
    to understand the response compared with the results that were generated when
    we composed the HTTP request with curl. HTTPie automatically formats the JSON
    data received as a response and applies syntax highlighting, specifically, both
    colors and formatting:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: We can achieve the same results by combining the output generated with the curl
    command with other utilities. However, HTTPie provides us exactly what we need
    for working with RESTful Web Services such as the one we are building with Django.
    We will use HTTPie to compose and send HTTP requests, but we will always provide
    the equivalent curl command. Remember that curl is faster when you need to execute
    it many times, such as when you prepare automated scripts.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following image shows two Terminal windows side-by-side on macOS. The Terminal
    window on the left-hand side is running the Django development server and displays
    the received and processed HTTP requests. The Terminal window on the right-hand
    side is running HTTPie commands to generate the HTTP requests. Notice that the
    JSON output is easier to read compared to the output generated by the curl command:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/9a42efd6-5ca6-49ae-b908-4f8517f64a0b.png)'
  prefs: []
  type: TYPE_IMG
- en: 'We can execute the `http` command with the `-b` option in case we don''t want
    to include the header in the response. For example, the following line performs
    the same HTTP request but doesn''t display the header in the response output,
    and therefore, the output will just display the JSON response:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: Making HTTP GET requests that target a single instance
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Now, we will make HTTP GET requests that target a single `Toy` instance. We
    will select one of the toys from the previous list and we will compose an HTTP
    request to retrieve only the chosen toy. For example, in the previous list, the
    first toy has a `pk` value equal to `3` because the results are ordered by the
    toy''s name in ascending order. Run the following command to retrieve this toy.
    Use the `pk` value you have retrieved in the previous command for the first toy,
    as the pk number might be different if you execute the sample code or the commands
    more than once or you make changes to the `toys_toy` table. In this case, you
    don''t have to enter an ending slash (`/`) because `/toys/3/` won''t match any
    of the patterns specified in `urlpatterns` in the `toys/urls.py` file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: 'The following is the equivalent `curl` command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: 'The previous commands will compose and send the following HTTP request: `GET
    http://localhost:8000/toys/3/`. The request has a number after `/toys/`, and therefore,
    it will match `''^toys/(?P<pk>[0-9]+)$''` and run the `views.toy_detail` function,
    that is, the `toy_detail` function declared within the `toys/views.py` file. The
    function receives `request` and `pk` as parameters because the URL pattern passes
    the number specified after `/toys/` in the `pk` parameter.'
  prefs: []
  type: TYPE_NORMAL
- en: 'As the HTTP verb for the request is `GET`, the `request.method` property is
    equal to `''GET''`, and therefore, the `toy_detail` function will execute the
    code that retrieves the `Toy` object whose primary key matches the `pk` value
    received as an argument and, if found, generates a JSON response with this `Toy`
    object serialized. The following lines show an example response for the HTTP request,
    with the `Toy` object that matches the `pk` value in the JSON response:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, we will compose and send an HTTP request to retrieve a toy that doesn''t
    exist. For example, in the previous list, there is no toy with a `pk` value equal
    to `17500`. Run the following command to try to retrieve this toy. Make sure you
    use a `pk` value that doesn''t exist. We must make sure that the utilities display
    the headers as part of the response because the response won''t have a body:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: 'The following is the equivalent `curl` command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: 'The previous commands will compose and send the following HTTP request: `GET
    http://localhost:8000/toys/17500`. The request is the same as the previous one
    we analyzed, with a different number for the `pk` parameter. The server will run
    the `views.toy_detail` function, that is, the `toy_detail` function declared within
    the `toys/views.py` file. The function will execute the code that retrieves the
    `Toy` object whose primary key matches the `pk` value received as an argument
    and a `Toy.DoesNotExist` exception will be thrown and captured because there is
    no toy with the specified `pk` value. Thus, the code will return an HTTP `404
    Not Found` status code. The following lines show an example header response for
    the HTTP request:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: Making HTTP POST requests
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Now, we will compose and send an HTTP request to create a new toy:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: 'The following is the equivalent `curl` command. It is very important to use
    the `-H "Content-Type: application/json"` option to indicate to curl that it should
    send the data specified after the `-d` option as `application/json` instead of
    the default `application/x-www-form-urlencoded`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: 'The previous commands will compose and send the following HTTP request: `POST
    http://localhost:8000/toys/` with the following JSON key-value pairs:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: 'The request specifies `/toys/`, and therefore, it will match the `''^toys/$''`
    regular expression and run the `views.toy_list` function, that is, the `toy_detail`
    function declared within the `toys/views.py` file. The function just receives
    `request` as a parameter because the URL pattern doesn''t include any parameters.
    As the HTTP verb for the request is `POST`, the `request.method` property is equal
    to `''POST''`, and therefore, the function will execute the code that parses the
    JSON data received in the request. Then, the function creates a new `Toy` and,
    if the data is valid, it saves the new `Toy` to the `toys_toy` table in the SQLite
    database. If the new `Toy` was successfully persisted in the database, the function
    returns an HTTP `201 Created` status code and the recently persisted `Toy` serialized
    to JSON in the response body. The following lines show an example response for
    the HTTP request, with the new `Toy` object in the JSON response:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: Making HTTP PUT requests
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Now, we will compose and send an HTTP request to update an existing toy, specifically,
    the previously added toy. We have to check the value assigned to `pk` in the previous
    response and replace `4` in the command with the returned value. For example,
    if the value for `pk` was `4`, you should use `:8000/toys/4` instead of `:8000/toys/4`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: 'The following is the equivalent `curl` command. As with the previous curl example,
    it is very important to use the `-H "Content-Type: application/json"` option to
    indicate `curl` to send the data specified after the `-d` option as `application/json`
    instead of the default `application/x-www-form-urlencoded`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: 'The previous commands will compose and send the following HTTP request: `PUT
    http://localhost:8000/toys/4` with the following JSON key-value pairs:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: 'The request has a number after `/toys/`, and therefore, it will match the `''^toys/(?P<pk>[0-9]+)$''`
    regular expression and run the `views.toy_detail` function, that is, the `toy_detail`
    function declared within the `toys/views.py` file. The function receives `request`
    and `pk` as parameters because the URL pattern passes the number specified after
    `/toys/` in the `pk` parameter. As the HTTP verb for the request is `PUT`, the
    `request.method` property is equal to `''PUT''`, and therefore, the function will
    execute the code that parses the JSON data received in the request. Then, the
    function will create a `Toy` instance from this data and update the existing toy
    in the database. If the toy was successfully updated in the database, the function
    returns an HTTP `200 OK` status code and the recently updated `Toy` serialized
    to JSON in the response body. The following lines show an example response for
    the HTTP request, with the updated `Toy` object in the JSON response:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: 'In order to successfully process a `PUT` HTTP request that updates an existing
    toy, we must provide values for all the required fields. We will compose and send
    an HTTP request to try to update an existing toy, and we will fail to do so because
    we will just provide a value for the name. As in the previous request, we will
    use the value assigned to `pk` in the last toy we added:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: 'The following is the equivalent `curl` command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: 'The previous commands will compose and send the following HTTP request: `PUT
    http://localhost:8000/toys/4` with the following JSON key-value pair:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: 'The request will execute the same code we explained for the previous request.
    As we didn''t provide all the required values for a `Toy` instance, the `toy_serializer.is_valid()`
    method will return `False` and the function will return an HTTP `400 Bad Request`
    status code and the details generated in the `toy_serializer.errors` attribute
    serialized to JSON in the response body. The following lines show an example response
    for the HTTP request, with the required fields that our request didn''t include
    values in the JSON response (`description`, `release_date`, and `toy_category`):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: When we want our API to be able to update a single field for an existing resource,
    in this case, an existing toy, we should provide an implementation for the PATCH
    method. The PUT method is meant to replace an entire resource and the PATCH method
    is meant to apply a delta to an existing resource. We can write code in the handler
    for the PUT method to apply a delta to an existing resource, but it is a better
    practice to use the PATCH method for this specific task. We will work with the
    PATCH method later.
  prefs: []
  type: TYPE_NORMAL
- en: Making HTTP DELETE requests
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Now, we will compose and send an HTTP request to delete an existing toy, specifically,
    the last toy we added. As in our last HTTP request, we have to check the value
    assigned to `pk` in the previous response and replace `4` in the command with
    the returned value:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs: []
  type: TYPE_PRE
- en: 'The following is the equivalent `curl` command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs: []
  type: TYPE_PRE
- en: 'The previous commands will compose and send the following HTTP request: `DELETE
    http://localhost:8000/toys/4`. The request has a number after `/toys/`, and therefore,
    it will match the `''^toys/(?P<pk>[0-9]+)$''` regular expression and run the `views.toy_detail`
    function, that is, the `toy_detail` function declared within the `toys/views.py`
    file. The function receives `request` and `pk` as parameters because the URL pattern
    passes the number specified after `/toys/` in the `pk` parameter. As the HTTP
    verb for the request is `DELETE`, the `request.method` property is equal to `''DELETE''`,
    and therefore, the function will execute the code that parses the JSON data received
    in the request. Then, the function creates a `Toy` instance from this data and
    deletes the existing toy in the database. If the toy was successfully deleted
    in the database, the function returns an HTTP `204 No Content` status code. The
    following lines show an example response to the HTTP request after successfully
    deleting an existing toy:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs: []
  type: TYPE_PRE
- en: Making HTTP GET requests with Postman
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Now, we will use one of the GUI tools we installed in [Chapter 1](dj-rst-websvc_ch11.html),
    *Installing the Required Software and Tools*, specifically Postman. We will use
    this GUI tool to compose and send HTTP requests to the web service.
  prefs: []
  type: TYPE_NORMAL
- en: The first time you execute Postman, you will see a modal that provides shortcuts
    to the most common operations. Make sure you close this modal so that we can focus
    on the main UI for Postman.
  prefs: []
  type: TYPE_NORMAL
- en: We will use the Builder tab in Postman to easily compose and send diverse HTTP
    requests to `localhost:8000` and test the RESTful Web Service with this GUI tool.
    Postman doesn't support curl-like shorthand for localhost, and therefore, we cannot
    use the same shorthand we have been using when composing requests with HTTPie.
  prefs: []
  type: TYPE_NORMAL
- en: 'Select GET in the drop-down menu on the left-hand side of the Enter request
    URL textbox, and enter `localhost:8000/toys/` in this textbox on the right-hand
    side of the drop-down menu. Then, click Send and Postman will display the following
    information:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Status: `200 OK`.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Time: The time it took for the request to be processed.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Size: The approximate response size (sum of body size plus headers size).'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Body: The response body with all the toys formatted as JSON with syntax highlighting.
    The default view for the body is Pretty and it activates syntax highlighting.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The following screenshot shows the JSON response body in Postman for the HTTP
    GET request to `localhost:8000/toys/`.
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/ca8e5bd9-10b8-49a1-9119-8747a04f05f9.png)'
  prefs: []
  type: TYPE_IMG
- en: Click on the Headers tab on the right-hand side of the Body and Cookies tab
    to read the response headers. The following screenshot shows the layout for the
    response headers that Postman displays for the previous response. Notice that
    Postman displays the Status on the right-hand side of the response and doesn't
    include it as the first line of the key-value pairs that compose the headers,
    as when we worked with both the `curl` and `http` command-line utilities.
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/3ce07f6d-f8a9-4954-956b-e0ad58987534.png)'
  prefs: []
  type: TYPE_IMG
- en: Making HTTP POST requests with Postman
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Now, we will use the Builder tab in Postman to compose and send an HTTP POST
    request to create a new toy. Perform the following steps:'
  prefs: []
  type: TYPE_NORMAL
- en: Click on the plus (**+**) button on the right-hand side of the tab that displayed
    the previous request. This way, you will create a new tab.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Select Request in the New drop-down menu located in the upper-left corner.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Select POST in the drop-down menu on the left-hand side of the Enter request
    URL textbox.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Enter `localhost:8000/toys/` in that textbox on the right-hand side of the drop-down
    menu.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Click Body on the right-hand side of Authorization and Headers, within the panel
    that composes the request.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Activate the raw radio button and select JSON (application/json) in the drop-down
    menu on the right-hand side of the binary radio button. Postman will automatically
    add a `Content-type = application/json` header, and therefore, you will notice
    the Headers tab will be renamed to Headers (1), indicating to us that there is
    one key-value pair specified for the request headers.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Enter the following lines in the textbox below the radio buttons, within the
    Body tab:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE37]'
  prefs: []
  type: TYPE_PRE
- en: 'The following screenshot shows the request body in Postman:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/c6eb6181-8157-4d1b-aab0-acba39bb9d62.png)'
  prefs: []
  type: TYPE_IMG
- en: 'We followed the necessary steps to create an HTTP POST request with a JSON
    body that specifies the necessary key-value pairs to create a new toy. Click Send
    and Postman will display the following information:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Status: `201 Created`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Time: The time it took for the request to be processed'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Size: The approximate response size (sum of body size plus headers size)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Body: The response body with the recently added toy formatted as JSON with
    syntax highlighting'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The following screenshot shows the JSON response body in Postman for the HTTP
    POST request:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/6405c361-5bce-4de4-a0cf-c2ae264a7139.png)'
  prefs: []
  type: TYPE_IMG
- en: If we want to compose and send an HTTP PUT request with Postman, it is necessary
    to follow the previously explained steps to provide JSON data within the request
    body.
  prefs: []
  type: TYPE_NORMAL
- en: 'One of the nice features included in Postman is that we can easily review and
    run the HTTP requests we have made again by browsing the saved History shown on
    the left-hand side of the Postman window. The History panel displays a list with
    the HTTP verb followed by the URL for each HTTP request we have composed and sent.
    We just need to click on the desired HTTP request and click Send to run it again.
    The following screenshot shows the many HTTP requests in the History panel and
    the first HTTP GET request that was executed selected so it can be easily resent:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/8bcea9b6-c921-4579-a657-906a1762f270.png)'
  prefs: []
  type: TYPE_IMG
- en: Test your knowledge
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Let''s see whether you can answer the following questions correctly:'
  prefs: []
  type: TYPE_NORMAL
- en: 'The `urlpatterns` list declared in the `urls.py` file makes it possible to:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Route URLs to Django models
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: Route URLs to Django views
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: Route URLs to Python primitives
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: When the Django server receives an HTTP request, Django creates an instance
    of which of the following classes?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '`django.restframework.HttpRequest`'
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: '`django.http.HttpRequest`'
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: '`django.http.Request`'
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: A view function has to return an instance of which of the following classes?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '`django.http.HttpResponse`'
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: '`django.http.Response`'
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: '`django.restfremework.HttpResponse`'
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: Whenever you have to return a specific status different from the default `200
    OK` status, it is a good practice to use the module variables defined in which
    of the following modules?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '`rest_framework.HttpStatus`'
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: '`django.status`'
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: '`rest_framework.status`'
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: If you want to retrieve a Toy instance whose primary key value is equal to `10`
    and save it in the toy variable, which line of code would you write?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: toy = Toy.get_by(pk=10)
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: toy = Toy.objects.all(pk=10)
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: toy = Toy.objects.get(pk=pk)
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: The rights answers are included in the [Appendix](https://cdp.packtpub.com/django_restful_web_services__/wp-admin/post.php?post=44&action=edit#post_454), *Solutions*.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In this chapter, we executed our first version of a simple Django RESTful Web
    Service that interacts with an SQLite database. We wrote API views to process
    diverse HTTP requests on a collection of toys and on a specific toy. We worked
    with the following HTTP verbs: GET, POST, and PUT. We configured the URL patterns
    list to route URLs to views.'
  prefs: []
  type: TYPE_NORMAL
- en: Then, we started the Django development server and we used command-line tools
    (curl and HTTPie) to compose and send diverse HTTP requests to our RESTful Web
    Service. We learned how HTTP requests were processed in Django and our code. Finally,
    we worked with Postman, a GUI tool, to compose and send other HTTP requests to
    our RESTful Web Service.
  prefs: []
  type: TYPE_NORMAL
- en: Now that we understand the basics of a RESTful Web Service with Django REST
    framework and a simple SQLite database, we will work with a seriously powerful
    PostgreSQL database, use class-based views instead of function views, and we will
    take advantage of advanced features included in Django REST framework to work
    with different content types, without writing a huge amount of code. We will cover
    these topics in the next chapter.
  prefs: []
  type: TYPE_NORMAL
