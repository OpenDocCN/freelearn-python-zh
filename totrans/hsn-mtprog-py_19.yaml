- en: '*Chapter 16*: Following Best Practices'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we will learn some of the best practices from Python programming
    that we can follow and apply to metaprogramming too. The practices suggested in
    Python Enhancement Proposal 8 (PEP 8), the style guide for Python code, also apply
    to metaprogramming.
  prefs: []
  type: TYPE_NORMAL
- en: The concepts behind PEP 8 originated and are explained in detail in the documentation
    by Guido van Rossum, Barry Warsaw, and Nick Coghlan at [https://peps.python.org/pep-0008/](https://peps.python.org/pep-0008/).
    This chapter will cover some of the important concepts from PEP 8 with examples
    using *ABC Megamart* of how they can be implemented in metaprogramming as well
    as general Python programming.
  prefs: []
  type: TYPE_NORMAL
- en: 'In this chapter, we will be looking at the following main topics:'
  prefs: []
  type: TYPE_NORMAL
- en: Following PEP 8 standards
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Writing clear comments for debugging and reusability
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Adding documentation strings
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Naming conventions
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Avoiding the reuse of names
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Avoiding metaprogramming where not required
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: By the end of this chapter, you will know the best practices for performing
    Python metaprogramming.
  prefs: []
  type: TYPE_NORMAL
- en: Technical requirements
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The code examples shared in this chapter are available on GitHub under the code
    for this chapter at [https://github.com/PacktPublishing/Metaprogramming-with-Python/tree/main/Chapter16](https://github.com/PacktPublishing/Metaprogramming-with-Python/tree/main/Chapter16).
  prefs: []
  type: TYPE_NORMAL
- en: Following PEP 8 standards
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this section, we will be looking at the PEP 8 standards that we should follow
    while coding applications with Python metaprogramming. We will apply these standards
    from the PEP 8 documentation using our example of *ABC Megamart*.
  prefs: []
  type: TYPE_NORMAL
- en: In this section, rather than looking at whether the coding standards we follow
    are right, we will consider the difference between coding standards that are easy
    to maintain in comparison to those that are not.
  prefs: []
  type: TYPE_NORMAL
- en: Indentation
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Python is a language that is very sensitive to indentation and can throw many
    errors when this is not done correctly. Having discipline with the overall indentation
    of your code helps to avoid errors and also makes the code more readable. In this
    example, let’s look at how we can keep the indentation correct.
  prefs: []
  type: TYPE_NORMAL
- en: 'To start looking at the indentation, let’s begin with an example of a greater-than-10-items
    counter. We first define a class named `GreaterThan10Counter` with a `return_cart`
    method to return the cart items:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: 'Let’s also create an object instance for the class:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: Next, we create a variable named `cart`, which will store the values returned
    by the `return_cart` method. Given that the class is for the greater-than-10-items
    counter, the number of items returned by the cart will be more than 10, hence
    the code will not be readable.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following screenshot shows how the code would look in a code editor:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 16.1 – The cart variable assignment ](img/Figure_16.1_B13426.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 16.1 – The cart variable assignment
  prefs: []
  type: TYPE_NORMAL
- en: Hard to maintain
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'The code of the `cart` variable in *Figure 16.1* will look as follows if we
    move the invisible part of the code onto the next line:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 16.2 – The cart variable adjusted without alignment ](img/Figure_16.2_B13426.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 16.2 – The cart variable adjusted without alignment
  prefs: []
  type: TYPE_NORMAL
- en: The preceding code is not incorrect since it will still execute without errors
    if we run it. The only problem is that it will be difficult to maintain.
  prefs: []
  type: TYPE_NORMAL
- en: Easy to maintain
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Let’s now change the indentation by aligning the code with symbols to make
    it readable and easily maintained if another developer needs to take it over for
    editing. The realigned code looks as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 16.3 – The cart variable adjusted with alignment ](img/Figure_16.3_B13426.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 16.3 – The cart variable adjusted with alignment
  prefs: []
  type: TYPE_NORMAL
- en: Now that we understand this, let’s look at the next best practice, which is
    to present code in a neat fashion.
  prefs: []
  type: TYPE_NORMAL
- en: Neat representation
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Let’s now look at how and where to add white spaces while writing code.
  prefs: []
  type: TYPE_NORMAL
- en: Hard to maintain
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Let’s look at the following example where we will define a `decorator` function
    named `signature` with no white spaces between operators and their corresponding
    variables:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: 'Let’s further call the `decorator` on another function named `manager_manhattan`
    without spaces between operators and variables:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: 'Next, let’s call the function as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: 'The preceding code will still run without errors but the code is not presented
    neatly nor is it easy to maintain since it is not easy to differentiate between
    a variable and its operator:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: Let’s add white spaces to this code.
  prefs: []
  type: TYPE_NORMAL
- en: Easy to maintain
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Let’s add spaces to the `signature` function:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: 'Similarly, let’s also add white spaces in the `manager_manhattan` function:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE35]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE36]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE37]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE38]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE39]'
  prefs: []
  type: TYPE_PRE
- en: 'Let’s call the function now:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE40]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE41]'
  prefs: []
  type: TYPE_PRE
- en: 'Running the preceding code produces the following output:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE42]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE43]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE44]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE45]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE46]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE47]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE48]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE49]'
  prefs: []
  type: TYPE_PRE
- en: The preceding code makes it easier to differentiate between variables and their
    corresponding operators due to the addition of white space.
  prefs: []
  type: TYPE_NORMAL
- en: With this understanding, let’s look at the next best practice, which is to add
    comments in the code.
  prefs: []
  type: TYPE_NORMAL
- en: Writing clear comments for debugging and reusability
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Writing inline comments helps us understand why a specific code block is written
    and we can keep the comments updated as the code changes. We recommend writing
    comments to make the code easy to debug in the future. However, keep the comments
    relevant to the code. Let’s look at a few examples of inline comments.
  prefs: []
  type: TYPE_NORMAL
- en: Redundant comments
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Let’s look at the following example where we are creating a meta class and
    calling the meta class from another class:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE50]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE51]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE52]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE53]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE54]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE55]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE56]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE57]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE58]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE59]'
  prefs: []
  type: TYPE_PRE
- en: In the preceding code, the comment explains exactly the same thing that is done
    by the code, which can be easily understood simply by looking at the code. This
    will not be helpful when we want to debug or modify the code in the future.
  prefs: []
  type: TYPE_NORMAL
- en: Relevant comment
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Let’s look at the Singleton design pattern and add a relevant comment:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE60]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE61]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE62]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE63]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE64]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE65]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE66]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE67]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE68]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE69]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE70]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE71]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE72]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE73]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE74]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE75]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE76]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE77]'
  prefs: []
  type: TYPE_PRE
- en: In the preceding code, the comment specifies the purpose of `SingletonBilling`
    rather than mentioning the obvious task performed by the code.
  prefs: []
  type: TYPE_NORMAL
- en: With this understanding, let’s look at the next best practice, which is to add
    documentation strings.
  prefs: []
  type: TYPE_NORMAL
- en: Adding documentation strings
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Documentation strings are added to provide more information on code that is
    intended to be imported and used in some other program or application. Documentation
    strings will provide the end user with information on the code that they are going
    to call from their programs. This is especially helpful as the end user of the
    code is not the developer of the library, but a user. Let’s look at an example
    of where to use documentation strings.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s start by creating a Python file named `vegcounter.py` and adding the
    following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE78]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE79]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE80]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE81]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE82]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE83]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE84]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE85]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE86]'
  prefs: []
  type: TYPE_PRE
- en: In the preceding code, we defined the docstring by providing a description of
    the function and its arguments.
  prefs: []
  type: TYPE_NORMAL
- en: 'The Python file looks as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 16.4 – Documentation string added to vegcounter.py ](img/Figure_16.4_B13426.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 16.4 – Documentation string added to vegcounter.py
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s further import `vegcounter.py` into another program as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE87]'
  prefs: []
  type: TYPE_PRE
- en: Note that in this program, the code for the functions inside `vegcounter` is
    not accessible to the end user, but the functions in `vegcounter` can be called
    by the end user's program.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following screenshot demonstrates how docstrings provide the information
    required in this example:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 16.5 – Documentation string example ](img/Figure_16.5_B13426.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 16.5 – Documentation string example
  prefs: []
  type: TYPE_NORMAL
- en: In this example, the documentation string we added in the Python file provides
    the end user with information on the function and its corresponding arguments
    along with an example.
  prefs: []
  type: TYPE_NORMAL
- en: Documentation string for metaprogramming
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'In this example, let’s define a metaclass named `BranchMetaClass` and add a
    docstring that states that this is a meta class and is not meant to be inherited
    as a super class or parent class. Save this code into `branch.py`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE88]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE89]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE90]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE91]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE92]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE93]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE94]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE95]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE96]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE97]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE98]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE99]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE100]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE101]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE102]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE103]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE104]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE105]'
  prefs: []
  type: TYPE_PRE
- en: 'Let’s now import the branch and its corresponding meta class as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE106]'
  prefs: []
  type: TYPE_PRE
- en: 'Let’s now call `BranchMetaclass` to check the docstring:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE107]'
  prefs: []
  type: TYPE_PRE
- en: 'The docstring is displayed in the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 16.6 – Documentation string for BranchMetaclass ](img/Figure_16.6_B13426.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 16.6 – Documentation string for BranchMetaclass
  prefs: []
  type: TYPE_NORMAL
- en: This is an example of how documentation strings should be included as a best
    practice. Adding documentation strings in the class definition provides end users
    with the information required to correctly apply a method or a class in their
    application.
  prefs: []
  type: TYPE_NORMAL
- en: With this understanding, let’s further look at the naming conventions to be
    followed in Python code.
  prefs: []
  type: TYPE_NORMAL
- en: Naming conventions
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Naming conventions in Python are recommendations of how various elements in
    a Python program need to be named to ensure ease of navigation and consistency.
    Navigating through code, connecting the dots, and understanding the flow are all
    made easier by following consistent naming conventions throughout the code. This
    is another important standard that helps in developing maintainable applications.
  prefs: []
  type: TYPE_NORMAL
- en: In this section, we will see how you should ideally name classes, variables,
    functions, and methods.
  prefs: []
  type: TYPE_NORMAL
- en: Class names
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: While creating a new class, it is recommended to start the class name with an
    uppercase letter followed by lowercase letters and capitalize whenever there are
    words that need differentiation within the class name.
  prefs: []
  type: TYPE_NORMAL
- en: For example, let’s define a class for the billing counter.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following style is not the preferred naming convention:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE108]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE109]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE110]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE111]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE112]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE113]'
  prefs: []
  type: TYPE_PRE
- en: 'With the preceding naming convention, we will still be able to execute the
    code and it will work as expected. But maintaining the class names with one well-defined
    naming style will make future management of the libraries easier. The preferred
    class naming style is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE114]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE115]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE116]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE117]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE118]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE119]'
  prefs: []
  type: TYPE_PRE
- en: Camel case is used to name classes so that they can be differentiated from variables,
    methods, and functions. The naming conventions for variables are explained next,
    followed by methods and functions.
  prefs: []
  type: TYPE_NORMAL
- en: Variables
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: While creating new variables, it is preferred to use all lowercase letters for
    variable names followed by numbers, if relevant. When there is more than one word
    in a variable name, it is a good practice to separate them using an underscore
    operator. This also helps us to differentiate variables from classes since they
    follow camel case conventions.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s look at an example of how variables should not be named:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE120]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE121]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE122]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE123]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE124]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE125]'
  prefs: []
  type: TYPE_PRE
- en: 'Let’s now look at an example of one preferred method of naming variables:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE126]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE127]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE128]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE129]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE130]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE131]'
  prefs: []
  type: TYPE_PRE
- en: 'Let’s further look at another preferred method for naming variables:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE132]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE133]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE134]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE135]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE136]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE137]'
  prefs: []
  type: TYPE_PRE
- en: Functions and methods
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Similar to variables, using lowercase for function and method names is the best-practice
    preference. When there is more than one word in a variable name, it is a good
    practice to separate them using an underscore operator.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s look at an example of how a function or method should not be named:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE138]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE139]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE140]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE141]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE142]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE143]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE144]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE145]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE146]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE147]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE148]'
  prefs: []
  type: TYPE_PRE
- en: 'Let’s now look at an example of the preferred method for naming methods or
    functions:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE149]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE150]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE151]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE152]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE153]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE154]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE155]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE156]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE157]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE158]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE159]'
  prefs: []
  type: TYPE_PRE
- en: These naming conventions are recommendations that can be followed while developing
    new code or a library from scratch. However, if the code has already been developed
    and is being actively maintained, it is recommended to follow the naming conventions
    used throughout the code.
  prefs: []
  type: TYPE_NORMAL
- en: Avoiding the reuse of names
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this example, let’s look at another best practice of how to use variable
    or class names such that the reusability aspect of your code is preserved. Sometimes
    it might seem easy to reuse the same class or variable names while writing code
    in a sequence. Reusing names will make it difficult to reuse the classes, variables,
    methods, or functions in your code as calling them in multiple scenarios will
    be impacted since the same names are reused for different elements.
  prefs: []
  type: TYPE_NORMAL
- en: Let’s look at an example to understand the method that is not preferred. Let’s
    define two classes for `Branch` with a method named `maintenance_cost` with different
    definitions.
  prefs: []
  type: TYPE_NORMAL
- en: 'The first `Branch` class is defined as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE160]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE161]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE162]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE163]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE164]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE165]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE166]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE167]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE168]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE169]'
  prefs: []
  type: TYPE_PRE
- en: 'The second `Branch` class is defined as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE170]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE171]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE172]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE173]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE174]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE175]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE176]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE177]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE178]'
  prefs: []
  type: TYPE_PRE
- en: 'In the preceding code, we have two `Branch` classes doing different tasks.
    Let’s now instantiate the `Branch` class, assuming the first `Branch` class needs
    to be executed at a later point in the code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE179]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE180]'
  prefs: []
  type: TYPE_PRE
- en: 'The preceding code calls the `Branch` class defined last, and thus ends up
    losing the definition of the first `Branch` class:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE181]'
  prefs: []
  type: TYPE_PRE
- en: To avoid such confusion, it is always preferred to provide different names for
    different elements in code.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s look at the preferred method now. We will define a class named `Brooklyn`
    where FMCG products are stocked as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE182]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE183]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE184]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE185]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE186]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE187]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE188]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE189]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE190]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE191]'
  prefs: []
  type: TYPE_PRE
- en: 'We will define another class named `Queens` where electronic products are stocked
    as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE192]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE193]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE194]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE195]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE196]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE197]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE198]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE199]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE200]'
  prefs: []
  type: TYPE_PRE
- en: 'We can now call both the classes and their methods without any issues:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE201]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE202]'
  prefs: []
  type: TYPE_PRE
- en: 'The output for `Brooklyn` is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE203]'
  prefs: []
  type: TYPE_PRE
- en: 'Similarly, we can instantiate the `Queens` class separately:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE204]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE205]'
  prefs: []
  type: TYPE_PRE
- en: 'The output for `Queens` is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE206]'
  prefs: []
  type: TYPE_PRE
- en: Having looked at why we should avoid reusing names, we can further look at where
    to avoid metaprogramming.
  prefs: []
  type: TYPE_NORMAL
- en: Avoiding metaprogramming where not required
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Writing too much metaprogramming just because the feature is available in Python
    also makes the overall code very complex and hard to handle. The following aspects
    should be kept in mind while choosing to write a metaprogram for your application:'
  prefs: []
  type: TYPE_NORMAL
- en: Identify your use case and determine the need for metaprogramming based on how
    frequently you need to modify the code.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Understand how frequently you need to manipulate your code outside of its core
    elements such as classes, methods, and variables.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Check whether your solution can be developed with object-oriented programming
    alone or whether it depends on elements such as metaclasses, decorators, and code
    generation.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Check whether your team has the relevant skills to maintain the metaprogramming
    features after development.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Check that you don’t have a dependency on earlier versions of Python that do
    not support some of the metaprogramming features.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: These are some of the points to consider when planning to apply metaprogramming
    techniques during the application design phase.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we covered various examples to understand the best practices
    recommended in the PEP 8 standards for Python. We looked at the preferred methods
    for indentation and the correct use of white spaces. We also looked at how to
    write useful comments and where to include documentation strings.
  prefs: []
  type: TYPE_NORMAL
- en: We learned the recommended naming conventions through some examples. We also
    looked at why we need to avoid reusing names and where to avoid metaprogramming.
  prefs: []
  type: TYPE_NORMAL
- en: While the concepts of metaprogramming are advanced and complex, we have tried
    to explain them with simple, straightforward examples throughout this book to
    keep it interesting and engaging. Learning Python and its features is a continuous
    journey. Keep following the future versions of Python and explore the new capabilities
    it provides for metaprogramming.
  prefs: []
  type: TYPE_NORMAL
