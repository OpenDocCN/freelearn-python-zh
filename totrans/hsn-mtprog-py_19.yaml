- en: '*Chapter 16*: Following Best Practices'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '*第16章*：遵循最佳实践'
- en: In this chapter, we will learn some of the best practices from Python programming
    that we can follow and apply to metaprogramming too. The practices suggested in
    Python Enhancement Proposal 8 (PEP 8), the style guide for Python code, also apply
    to metaprogramming.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将学习一些Python编程的最佳实践，这些实践我们可以遵循并将其应用于元编程。Python增强提案8（PEP 8）中建议的实践，即Python代码的风格指南，也适用于元编程。
- en: The concepts behind PEP 8 originated and are explained in detail in the documentation
    by Guido van Rossum, Barry Warsaw, and Nick Coghlan at [https://peps.python.org/pep-0008/](https://peps.python.org/pep-0008/).
    This chapter will cover some of the important concepts from PEP 8 with examples
    using *ABC Megamart* of how they can be implemented in metaprogramming as well
    as general Python programming.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: PEP 8背后的概念起源于Guido van Rossum、Barry Warsaw和Nick Coghlan的文档，并在[https://peps.python.org/pep-0008/](https://peps.python.org/pep-0008/)中进行了详细解释。本章将涵盖PEP
    8的一些重要概念，并通过使用*ABC Megamart*的示例来展示它们如何在元编程以及一般的Python编程中实现。
- en: 'In this chapter, we will be looking at the following main topics:'
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将探讨以下主要主题：
- en: Following PEP 8 standards
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 遵循PEP 8标准
- en: Writing clear comments for debugging and reusability
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 编写清晰的注释以供调试和重用
- en: Adding documentation strings
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 添加文档字符串
- en: Naming conventions
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 命名约定
- en: Avoiding the reuse of names
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 避免重用名称
- en: Avoiding metaprogramming where not required
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 避免不必要的元编程
- en: By the end of this chapter, you will know the best practices for performing
    Python metaprogramming.
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 到本章结束时，你将了解执行Python元编程的最佳实践。
- en: Technical requirements
  id: totrans-11
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 技术要求
- en: The code examples shared in this chapter are available on GitHub under the code
    for this chapter at [https://github.com/PacktPublishing/Metaprogramming-with-Python/tree/main/Chapter16](https://github.com/PacktPublishing/Metaprogramming-with-Python/tree/main/Chapter16).
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 本章中分享的代码示例可在GitHub上找到，地址为[https://github.com/PacktPublishing/Metaprogramming-with-Python/tree/main/Chapter16](https://github.com/PacktPublishing/Metaprogramming-with-Python/tree/main/Chapter16)。
- en: Following PEP 8 standards
  id: totrans-13
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 遵循PEP 8标准
- en: In this section, we will be looking at the PEP 8 standards that we should follow
    while coding applications with Python metaprogramming. We will apply these standards
    from the PEP 8 documentation using our example of *ABC Megamart*.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们将探讨在用Python元编程编写应用程序时应遵循的PEP 8标准。我们将使用*ABC Megamart*的示例来应用PEP 8文档中的这些标准。
- en: In this section, rather than looking at whether the coding standards we follow
    are right, we will consider the difference between coding standards that are easy
    to maintain in comparison to those that are not.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们不会考虑我们遵循的编码标准是否正确，而是将考虑易于维护的编码标准与不易维护的编码标准之间的区别。
- en: Indentation
  id: totrans-16
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 缩进
- en: Python is a language that is very sensitive to indentation and can throw many
    errors when this is not done correctly. Having discipline with the overall indentation
    of your code helps to avoid errors and also makes the code more readable. In this
    example, let’s look at how we can keep the indentation correct.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: Python是一种对缩进非常敏感的语言，如果缩进不正确，可能会抛出许多错误。对代码的整体缩进保持纪律有助于避免错误，并使代码更易于阅读。在这个例子中，让我们看看我们如何保持正确的缩进。
- en: 'To start looking at the indentation, let’s begin with an example of a greater-than-10-items
    counter. We first define a class named `GreaterThan10Counter` with a `return_cart`
    method to return the cart items:'
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 要开始查看缩进，让我们从一个大于10项的计数器示例开始。我们首先定义一个名为`GreaterThan10Counter`的类，并包含一个`return_cart`方法来返回购物车中的商品：
- en: '[PRE0]'
  id: totrans-19
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: '[PRE1]'
  id: totrans-20
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: '[PRE2]'
  id: totrans-21
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: '[PRE3]'
  id: totrans-22
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: '[PRE4]'
  id: totrans-23
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: '[PRE5]'
  id: totrans-24
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'Let’s also create an object instance for the class:'
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们再为这个类创建一个对象实例：
- en: '[PRE6]'
  id: totrans-26
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: Next, we create a variable named `cart`, which will store the values returned
    by the `return_cart` method. Given that the class is for the greater-than-10-items
    counter, the number of items returned by the cart will be more than 10, hence
    the code will not be readable.
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们创建一个名为`cart`的变量，它将存储`return_cart`方法返回的值。鉴于这个类是用于大于10项的计数器，购物车返回的商品数量将超过10，因此代码将不易阅读。
- en: 'The following screenshot shows how the code would look in a code editor:'
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 以下截图显示了代码在代码编辑器中的样子：
- en: '![Figure 16.1 – The cart variable assignment ](img/Figure_16.1_B13426.jpg)'
  id: totrans-29
  prefs: []
  type: TYPE_IMG
  zh: '![图16.1 – 购物车变量赋值](img/Figure_16.1_B13426.jpg)'
- en: Figure 16.1 – The cart variable assignment
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 图16.1 – 购物车变量赋值
- en: Hard to maintain
  id: totrans-31
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 难以维护
- en: 'The code of the `cart` variable in *Figure 16.1* will look as follows if we
    move the invisible part of the code onto the next line:'
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们将代码的无形部分移到下一行，*图16.1* 中 `cart` 变量的代码将如下所示：
- en: '![Figure 16.2 – The cart variable adjusted without alignment ](img/Figure_16.2_B13426.jpg)'
  id: totrans-33
  prefs: []
  type: TYPE_IMG
  zh: '![图16.2 – 未对齐调整的 cart 变量](img/Figure_16.2_B13426.jpg)'
- en: Figure 16.2 – The cart variable adjusted without alignment
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 图16.2 – 未对齐调整的 cart 变量
- en: The preceding code is not incorrect since it will still execute without errors
    if we run it. The only problem is that it will be difficult to maintain.
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 上述代码本身并没有错误，因为我们运行它时它仍然会执行而不会出错。唯一的问题是它将很难维护。
- en: Easy to maintain
  id: totrans-36
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 易于维护
- en: 'Let’s now change the indentation by aligning the code with symbols to make
    it readable and easily maintained if another developer needs to take it over for
    editing. The realigned code looks as follows:'
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 现在让我们通过将代码与符号对齐来改变缩进，使其易于阅读和维护，如果其他开发者需要接管编辑，代码看起来如下：
- en: '![Figure 16.3 – The cart variable adjusted with alignment ](img/Figure_16.3_B13426.jpg)'
  id: totrans-38
  prefs: []
  type: TYPE_IMG
  zh: '![图16.3 – 调整后的 cart 变量](img/Figure_16.3_B13426.jpg)'
- en: Figure 16.3 – The cart variable adjusted with alignment
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 图16.3 – 调整后的 cart 变量
- en: Now that we understand this, let’s look at the next best practice, which is
    to present code in a neat fashion.
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经理解了这一点，让我们看看下一个最佳实践，即以整洁的方式展示代码。
- en: Neat representation
  id: totrans-41
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 整洁的表示
- en: Let’s now look at how and where to add white spaces while writing code.
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 现在让我们看看在编写代码时如何以及在哪里添加空格。
- en: Hard to maintain
  id: totrans-43
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 难以维护
- en: 'Let’s look at the following example where we will define a `decorator` function
    named `signature` with no white spaces between operators and their corresponding
    variables:'
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看以下示例，我们将定义一个名为 `signature` 的 `decorator` 函数，操作符和它们对应的变量之间没有空格：
- en: '[PRE7]'
  id: totrans-45
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: '[PRE8]'
  id: totrans-46
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: '[PRE9]'
  id: totrans-47
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: '[PRE10]'
  id: totrans-48
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: '[PRE11]'
  id: totrans-49
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: '[PRE12]'
  id: totrans-50
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'Let’s further call the `decorator` on another function named `manager_manhattan`
    without spaces between operators and variables:'
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们进一步在另一个名为 `manager_manhattan` 的函数上调用 `decorator`，操作符和变量之间没有空格：
- en: '[PRE13]'
  id: totrans-52
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: '[PRE14]'
  id: totrans-53
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: '[PRE15]'
  id: totrans-54
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: '[PRE16]'
  id: totrans-55
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: '[PRE17]'
  id: totrans-56
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: '[PRE18]'
  id: totrans-57
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'Next, let’s call the function as follows:'
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，让我们按照以下方式调用函数：
- en: '[PRE19]'
  id: totrans-59
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'The preceding code will still run without errors but the code is not presented
    neatly nor is it easy to maintain since it is not easy to differentiate between
    a variable and its operator:'
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 上述代码仍然可以正常运行而不会出错，但代码的展示并不整洁，也不容易维护，因为很难区分变量和它的操作符：
- en: '[PRE20]'
  id: totrans-61
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: '[PRE21]'
  id: totrans-62
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: '[PRE22]'
  id: totrans-63
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: '[PRE23]'
  id: totrans-64
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: '[PRE24]'
  id: totrans-65
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: '[PRE25]'
  id: totrans-66
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: '[PRE26]'
  id: totrans-67
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: '[PRE27]'
  id: totrans-68
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: Let’s add white spaces to this code.
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们在代码中添加空格。
- en: Easy to maintain
  id: totrans-70
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 易于维护
- en: 'Let’s add spaces to the `signature` function:'
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们在 `signature` 函数中添加空格：
- en: '[PRE28]'
  id: totrans-72
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: '[PRE29]'
  id: totrans-73
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: '[PRE30]'
  id: totrans-74
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: '[PRE31]'
  id: totrans-75
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: '[PRE32]'
  id: totrans-76
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: '[PRE33]'
  id: totrans-77
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: 'Similarly, let’s also add white spaces in the `manager_manhattan` function:'
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 同样，让我们也在 `manager_manhattan` 函数中添加空格：
- en: '[PRE34]'
  id: totrans-79
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: '[PRE35]'
  id: totrans-80
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: '[PRE36]'
  id: totrans-81
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: '[PRE37]'
  id: totrans-82
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: '[PRE38]'
  id: totrans-83
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: '[PRE39]'
  id: totrans-84
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: 'Let’s call the function now:'
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 现在让我们调用这个函数：
- en: '[PRE40]'
  id: totrans-86
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: '[PRE41]'
  id: totrans-87
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: 'Running the preceding code produces the following output:'
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 运行上述代码会产生以下输出：
- en: '[PRE42]'
  id: totrans-89
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: '[PRE43]'
  id: totrans-90
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: '[PRE44]'
  id: totrans-91
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: '[PRE45]'
  id: totrans-92
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: '[PRE46]'
  id: totrans-93
  prefs: []
  type: TYPE_PRE
  zh: '[PRE46]'
- en: '[PRE47]'
  id: totrans-94
  prefs: []
  type: TYPE_PRE
  zh: '[PRE47]'
- en: '[PRE48]'
  id: totrans-95
  prefs: []
  type: TYPE_PRE
  zh: '[PRE48]'
- en: '[PRE49]'
  id: totrans-96
  prefs: []
  type: TYPE_PRE
  zh: '[PRE49]'
- en: The preceding code makes it easier to differentiate between variables and their
    corresponding operators due to the addition of white space.
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 由于添加了空格，上述代码使得区分变量和它们对应的操作符变得更加容易。
- en: With this understanding, let’s look at the next best practice, which is to add
    comments in the code.
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 通过这个理解，让我们看看下一个最佳实践，即在代码中添加注释。
- en: Writing clear comments for debugging and reusability
  id: totrans-99
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 为调试和重用编写清晰的注释
- en: Writing inline comments helps us understand why a specific code block is written
    and we can keep the comments updated as the code changes. We recommend writing
    comments to make the code easy to debug in the future. However, keep the comments
    relevant to the code. Let’s look at a few examples of inline comments.
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 编写内联注释有助于我们理解为什么编写特定的代码块，并且我们可以随着代码的变化更新注释。我们建议编写注释，以便将来更容易调试代码。然而，请确保注释与代码相关。让我们看看几个内联注释的例子。
- en: Redundant comments
  id: totrans-101
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 冗余注释
- en: 'Let’s look at the following example where we are creating a meta class and
    calling the meta class from another class:'
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看以下示例，其中我们创建一个元类并从另一个类中调用元类：
- en: '[PRE50]'
  id: totrans-103
  prefs: []
  type: TYPE_PRE
  zh: '[PRE50]'
- en: '[PRE51]'
  id: totrans-104
  prefs: []
  type: TYPE_PRE
  zh: '[PRE51]'
- en: '[PRE52]'
  id: totrans-105
  prefs: []
  type: TYPE_PRE
  zh: '[PRE52]'
- en: '[PRE53]'
  id: totrans-106
  prefs: []
  type: TYPE_PRE
  zh: '[PRE53]'
- en: '[PRE54]'
  id: totrans-107
  prefs: []
  type: TYPE_PRE
  zh: '[PRE54]'
- en: '[PRE55]'
  id: totrans-108
  prefs: []
  type: TYPE_PRE
  zh: '[PRE55]'
- en: '[PRE56]'
  id: totrans-109
  prefs: []
  type: TYPE_PRE
  zh: '[PRE56]'
- en: '[PRE57]'
  id: totrans-110
  prefs: []
  type: TYPE_PRE
  zh: '[PRE57]'
- en: '[PRE58]'
  id: totrans-111
  prefs: []
  type: TYPE_PRE
  zh: '[PRE58]'
- en: '[PRE59]'
  id: totrans-112
  prefs: []
  type: TYPE_PRE
  zh: '[PRE59]'
- en: In the preceding code, the comment explains exactly the same thing that is done
    by the code, which can be easily understood simply by looking at the code. This
    will not be helpful when we want to debug or modify the code in the future.
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的代码中，注释清楚地解释了代码所执行的内容，这可以通过简单地查看代码来理解。当我们想要将来调试或修改代码时，这不会很有帮助。
- en: Relevant comment
  id: totrans-114
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 相关注释
- en: 'Let’s look at the Singleton design pattern and add a relevant comment:'
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看 Singleton 设计模式并添加相关注释：
- en: '[PRE60]'
  id: totrans-116
  prefs: []
  type: TYPE_PRE
  zh: '[PRE60]'
- en: '[PRE61]'
  id: totrans-117
  prefs: []
  type: TYPE_PRE
  zh: '[PRE61]'
- en: '[PRE62]'
  id: totrans-118
  prefs: []
  type: TYPE_PRE
  zh: '[PRE62]'
- en: '[PRE63]'
  id: totrans-119
  prefs: []
  type: TYPE_PRE
  zh: '[PRE63]'
- en: '[PRE64]'
  id: totrans-120
  prefs: []
  type: TYPE_PRE
  zh: '[PRE64]'
- en: '[PRE65]'
  id: totrans-121
  prefs: []
  type: TYPE_PRE
  zh: '[PRE65]'
- en: '[PRE66]'
  id: totrans-122
  prefs: []
  type: TYPE_PRE
  zh: '[PRE66]'
- en: '[PRE67]'
  id: totrans-123
  prefs: []
  type: TYPE_PRE
  zh: '[PRE67]'
- en: '[PRE68]'
  id: totrans-124
  prefs: []
  type: TYPE_PRE
  zh: '[PRE68]'
- en: '[PRE69]'
  id: totrans-125
  prefs: []
  type: TYPE_PRE
  zh: '[PRE69]'
- en: '[PRE70]'
  id: totrans-126
  prefs: []
  type: TYPE_PRE
  zh: '[PRE70]'
- en: '[PRE71]'
  id: totrans-127
  prefs: []
  type: TYPE_PRE
  zh: '[PRE71]'
- en: '[PRE72]'
  id: totrans-128
  prefs: []
  type: TYPE_PRE
  zh: '[PRE72]'
- en: '[PRE73]'
  id: totrans-129
  prefs: []
  type: TYPE_PRE
  zh: '[PRE73]'
- en: '[PRE74]'
  id: totrans-130
  prefs: []
  type: TYPE_PRE
  zh: '[PRE74]'
- en: '[PRE75]'
  id: totrans-131
  prefs: []
  type: TYPE_PRE
  zh: '[PRE75]'
- en: '[PRE76]'
  id: totrans-132
  prefs: []
  type: TYPE_PRE
  zh: '[PRE76]'
- en: '[PRE77]'
  id: totrans-133
  prefs: []
  type: TYPE_PRE
  zh: '[PRE77]'
- en: In the preceding code, the comment specifies the purpose of `SingletonBilling`
    rather than mentioning the obvious task performed by the code.
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的代码中，注释指定了 `SingletonBilling` 的用途，而不是提及代码执行的明显任务。
- en: With this understanding, let’s look at the next best practice, which is to add
    documentation strings.
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 通过这个理解，让我们看看下一个最佳实践，即添加文档字符串。
- en: Adding documentation strings
  id: totrans-136
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 添加文档字符串
- en: Documentation strings are added to provide more information on code that is
    intended to be imported and used in some other program or application. Documentation
    strings will provide the end user with information on the code that they are going
    to call from their programs. This is especially helpful as the end user of the
    code is not the developer of the library, but a user. Let’s look at an example
    of where to use documentation strings.
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 添加文档字符串是为了提供更多关于打算在其他程序或应用中导入和使用的代码的信息。文档字符串将为最终用户提供有关他们将要从程序中调用的代码的信息。这对于最终用户不是库的开发者，而是一个用户来说特别有帮助。让我们看看文档字符串应该在哪里使用的一个例子。
- en: 'Let’s start by creating a Python file named `vegcounter.py` and adding the
    following code:'
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们首先创建一个名为 `vegcounter.py` 的 Python 文件，并添加以下代码：
- en: '[PRE78]'
  id: totrans-139
  prefs: []
  type: TYPE_PRE
  zh: '[PRE78]'
- en: '[PRE79]'
  id: totrans-140
  prefs: []
  type: TYPE_PRE
  zh: '[PRE79]'
- en: '[PRE80]'
  id: totrans-141
  prefs: []
  type: TYPE_PRE
  zh: '[PRE80]'
- en: '[PRE81]'
  id: totrans-142
  prefs: []
  type: TYPE_PRE
  zh: '[PRE81]'
- en: '[PRE82]'
  id: totrans-143
  prefs: []
  type: TYPE_PRE
  zh: '[PRE82]'
- en: '[PRE83]'
  id: totrans-144
  prefs: []
  type: TYPE_PRE
  zh: '[PRE83]'
- en: '[PRE84]'
  id: totrans-145
  prefs: []
  type: TYPE_PRE
  zh: '[PRE84]'
- en: '[PRE85]'
  id: totrans-146
  prefs: []
  type: TYPE_PRE
  zh: '[PRE85]'
- en: '[PRE86]'
  id: totrans-147
  prefs: []
  type: TYPE_PRE
  zh: '[PRE86]'
- en: In the preceding code, we defined the docstring by providing a description of
    the function and its arguments.
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的代码中，我们通过提供函数及其参数的描述来定义了文档字符串。
- en: 'The Python file looks as follows:'
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: Python 文件看起来如下所示：
- en: '![Figure 16.4 – Documentation string added to vegcounter.py ](img/Figure_16.4_B13426.jpg)'
  id: totrans-150
  prefs: []
  type: TYPE_IMG
  zh: '![图 16.4 – 添加到 vegcounter.py 的文档字符串](img/Figure_16.4_B13426.jpg)'
- en: Figure 16.4 – Documentation string added to vegcounter.py
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 图 16.4 – 添加到 vegcounter.py 的文档字符串
- en: 'Let’s further import `vegcounter.py` into another program as follows:'
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 现在让我们按照以下方式将 `vegcounter.py` 导入到另一个程序中：
- en: '[PRE87]'
  id: totrans-153
  prefs: []
  type: TYPE_PRE
  zh: '[PRE87]'
- en: Note that in this program, the code for the functions inside `vegcounter` is
    not accessible to the end user, but the functions in `vegcounter` can be called
    by the end user's program.
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，在这个程序中，`vegcounter` 内部的函数代码对最终用户不可访问，但 `vegcounter` 中的函数可以被最终用户的程序调用。
- en: 'The following screenshot demonstrates how docstrings provide the information
    required in this example:'
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 下面的截图演示了文档字符串如何提供本例中所需的信息：
- en: '![Figure 16.5 – Documentation string example ](img/Figure_16.5_B13426.jpg)'
  id: totrans-156
  prefs: []
  type: TYPE_IMG
  zh: '![图 16.5 – 文档字符串示例](img/Figure_16.5_B13426.jpg)'
- en: Figure 16.5 – Documentation string example
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 图 16.5 – 文档字符串示例
- en: In this example, the documentation string we added in the Python file provides
    the end user with information on the function and its corresponding arguments
    along with an example.
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个例子中，我们在 Python 文件中添加的文档字符串为最终用户提供有关函数及其相应参数以及示例的信息。
- en: Documentation string for metaprogramming
  id: totrans-159
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 元编程的文档字符串
- en: 'In this example, let’s define a metaclass named `BranchMetaClass` and add a
    docstring that states that this is a meta class and is not meant to be inherited
    as a super class or parent class. Save this code into `branch.py`:'
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个例子中，让我们定义一个名为 `BranchMetaClass` 的元类，并添加一个文档字符串，说明这是一个元类，不应作为超类或父类继承。将此代码保存到
    `branch.py`：
- en: '[PRE88]'
  id: totrans-161
  prefs: []
  type: TYPE_PRE
  zh: '[PRE88]'
- en: '[PRE89]'
  id: totrans-162
  prefs: []
  type: TYPE_PRE
  zh: '[PRE89]'
- en: '[PRE90]'
  id: totrans-163
  prefs: []
  type: TYPE_PRE
  zh: '[PRE90]'
- en: '[PRE91]'
  id: totrans-164
  prefs: []
  type: TYPE_PRE
  zh: '[PRE91]'
- en: '[PRE92]'
  id: totrans-165
  prefs: []
  type: TYPE_PRE
  zh: '[PRE92]'
- en: '[PRE93]'
  id: totrans-166
  prefs: []
  type: TYPE_PRE
  zh: '[PRE93]'
- en: '[PRE94]'
  id: totrans-167
  prefs: []
  type: TYPE_PRE
  zh: '[PRE94]'
- en: '[PRE95]'
  id: totrans-168
  prefs: []
  type: TYPE_PRE
  zh: '[PRE95]'
- en: '[PRE96]'
  id: totrans-169
  prefs: []
  type: TYPE_PRE
  zh: '[PRE96]'
- en: '[PRE97]'
  id: totrans-170
  prefs: []
  type: TYPE_PRE
  zh: '[PRE97]'
- en: '[PRE98]'
  id: totrans-171
  prefs: []
  type: TYPE_PRE
  zh: '[PRE98]'
- en: '[PRE99]'
  id: totrans-172
  prefs: []
  type: TYPE_PRE
  zh: '[PRE99]'
- en: '[PRE100]'
  id: totrans-173
  prefs: []
  type: TYPE_PRE
  zh: '[PRE100]'
- en: '[PRE101]'
  id: totrans-174
  prefs: []
  type: TYPE_PRE
  zh: '[PRE101]'
- en: '[PRE102]'
  id: totrans-175
  prefs: []
  type: TYPE_PRE
  zh: '[PRE102]'
- en: '[PRE103]'
  id: totrans-176
  prefs: []
  type: TYPE_PRE
  zh: '[PRE103]'
- en: '[PRE104]'
  id: totrans-177
  prefs: []
  type: TYPE_PRE
  zh: '[PRE104]'
- en: '[PRE105]'
  id: totrans-178
  prefs: []
  type: TYPE_PRE
  zh: '[PRE105]'
- en: 'Let’s now import the branch and its corresponding meta class as follows:'
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: 现在让我们按照以下方式导入分支及其相应的元类：
- en: '[PRE106]'
  id: totrans-180
  prefs: []
  type: TYPE_PRE
  zh: '[PRE106]'
- en: 'Let’s now call `BranchMetaclass` to check the docstring:'
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: 现在让我们调用 `BranchMetaclass` 来检查文档字符串：
- en: '[PRE107]'
  id: totrans-182
  prefs: []
  type: TYPE_PRE
  zh: '[PRE107]'
- en: 'The docstring is displayed in the following screenshot:'
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: 文档字符串在以下屏幕截图中显示：
- en: '![Figure 16.6 – Documentation string for BranchMetaclass ](img/Figure_16.6_B13426.jpg)'
  id: totrans-184
  prefs: []
  type: TYPE_IMG
  zh: '![图 16.6 – BranchMetaclass 的文档字符串](img/Figure_16.6_B13426.jpg)'
- en: Figure 16.6 – Documentation string for BranchMetaclass
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: 图 16.6 – BranchMetaclass 的文档字符串
- en: This is an example of how documentation strings should be included as a best
    practice. Adding documentation strings in the class definition provides end users
    with the information required to correctly apply a method or a class in their
    application.
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一个关于如何将文档字符串作为最佳实践包含在内的例子。在类定义中添加文档字符串为最终用户提供正确应用方法或类所需的信息。
- en: With this understanding, let’s further look at the naming conventions to be
    followed in Python code.
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: 通过这个理解，让我们进一步看看在 Python 代码中应遵循的命名约定。
- en: Naming conventions
  id: totrans-188
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 命名约定
- en: Naming conventions in Python are recommendations of how various elements in
    a Python program need to be named to ensure ease of navigation and consistency.
    Navigating through code, connecting the dots, and understanding the flow are all
    made easier by following consistent naming conventions throughout the code. This
    is another important standard that helps in developing maintainable applications.
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: Python中的命名约定是关于如何在Python程序中命名各种元素的建议，以确保易于导航和一致性。遵循代码中的统一命名约定可以简化代码导航、连接点和理解流程。这是另一个重要的标准，有助于开发可维护的应用程序。
- en: In this section, we will see how you should ideally name classes, variables,
    functions, and methods.
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们将了解如何理想地命名类、变量、函数和方法。
- en: Class names
  id: totrans-191
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 类名
- en: While creating a new class, it is recommended to start the class name with an
    uppercase letter followed by lowercase letters and capitalize whenever there are
    words that need differentiation within the class name.
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: 在创建一个新类时，建议以大写字母开头，后面跟小写字母，并在类名中需要区分单词时进行大写。
- en: For example, let’s define a class for the billing counter.
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，让我们定义一个用于计费计数器的类。
- en: 'The following style is not the preferred naming convention:'
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: 以下风格不是首选的命名约定：
- en: '[PRE108]'
  id: totrans-195
  prefs: []
  type: TYPE_PRE
  zh: '[PRE108]'
- en: '[PRE109]'
  id: totrans-196
  prefs: []
  type: TYPE_PRE
  zh: '[PRE109]'
- en: '[PRE110]'
  id: totrans-197
  prefs: []
  type: TYPE_PRE
  zh: '[PRE110]'
- en: '[PRE111]'
  id: totrans-198
  prefs: []
  type: TYPE_PRE
  zh: '[PRE111]'
- en: '[PRE112]'
  id: totrans-199
  prefs: []
  type: TYPE_PRE
  zh: '[PRE112]'
- en: '[PRE113]'
  id: totrans-200
  prefs: []
  type: TYPE_PRE
  zh: '[PRE113]'
- en: 'With the preceding naming convention, we will still be able to execute the
    code and it will work as expected. But maintaining the class names with one well-defined
    naming style will make future management of the libraries easier. The preferred
    class naming style is as follows:'
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: 使用前面的命名约定，我们仍然能够执行代码，并且它将按预期工作。但是，使用一个定义良好的命名风格来维护类名将使未来库的管理更容易。首选的类命名风格如下：
- en: '[PRE114]'
  id: totrans-202
  prefs: []
  type: TYPE_PRE
  zh: '[PRE114]'
- en: '[PRE115]'
  id: totrans-203
  prefs: []
  type: TYPE_PRE
  zh: '[PRE115]'
- en: '[PRE116]'
  id: totrans-204
  prefs: []
  type: TYPE_PRE
  zh: '[PRE116]'
- en: '[PRE117]'
  id: totrans-205
  prefs: []
  type: TYPE_PRE
  zh: '[PRE117]'
- en: '[PRE118]'
  id: totrans-206
  prefs: []
  type: TYPE_PRE
  zh: '[PRE118]'
- en: '[PRE119]'
  id: totrans-207
  prefs: []
  type: TYPE_PRE
  zh: '[PRE119]'
- en: Camel case is used to name classes so that they can be differentiated from variables,
    methods, and functions. The naming conventions for variables are explained next,
    followed by methods and functions.
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: 驼峰式命名法用于命名类，以便它们可以与变量、方法和函数区分开来。接下来将解释变量的命名约定，然后是方法和函数。
- en: Variables
  id: totrans-209
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 变量
- en: While creating new variables, it is preferred to use all lowercase letters for
    variable names followed by numbers, if relevant. When there is more than one word
    in a variable name, it is a good practice to separate them using an underscore
    operator. This also helps us to differentiate variables from classes since they
    follow camel case conventions.
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: 在创建新变量时，建议使用全部小写字母作为变量名，如果相关，后面跟数字。当变量名中有多个单词时，使用下划线操作符分隔它们是一种好习惯。这也帮助我们区分变量和类，因为它们遵循驼峰式命名约定。
- en: 'Let’s look at an example of how variables should not be named:'
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看一个变量不应该如何命名的例子：
- en: '[PRE120]'
  id: totrans-212
  prefs: []
  type: TYPE_PRE
  zh: '[PRE120]'
- en: '[PRE121]'
  id: totrans-213
  prefs: []
  type: TYPE_PRE
  zh: '[PRE121]'
- en: '[PRE122]'
  id: totrans-214
  prefs: []
  type: TYPE_PRE
  zh: '[PRE122]'
- en: '[PRE123]'
  id: totrans-215
  prefs: []
  type: TYPE_PRE
  zh: '[PRE123]'
- en: '[PRE124]'
  id: totrans-216
  prefs: []
  type: TYPE_PRE
  zh: '[PRE124]'
- en: '[PRE125]'
  id: totrans-217
  prefs: []
  type: TYPE_PRE
  zh: '[PRE125]'
- en: 'Let’s now look at an example of one preferred method of naming variables:'
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们来看一个变量命名首选方法的例子：
- en: '[PRE126]'
  id: totrans-219
  prefs: []
  type: TYPE_PRE
  zh: '[PRE126]'
- en: '[PRE127]'
  id: totrans-220
  prefs: []
  type: TYPE_PRE
  zh: '[PRE127]'
- en: '[PRE128]'
  id: totrans-221
  prefs: []
  type: TYPE_PRE
  zh: '[PRE128]'
- en: '[PRE129]'
  id: totrans-222
  prefs: []
  type: TYPE_PRE
  zh: '[PRE129]'
- en: '[PRE130]'
  id: totrans-223
  prefs: []
  type: TYPE_PRE
  zh: '[PRE130]'
- en: '[PRE131]'
  id: totrans-224
  prefs: []
  type: TYPE_PRE
  zh: '[PRE131]'
- en: 'Let’s further look at another preferred method for naming variables:'
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们进一步看看另一个变量命名的首选方法：
- en: '[PRE132]'
  id: totrans-226
  prefs: []
  type: TYPE_PRE
  zh: '[PRE132]'
- en: '[PRE133]'
  id: totrans-227
  prefs: []
  type: TYPE_PRE
  zh: '[PRE133]'
- en: '[PRE134]'
  id: totrans-228
  prefs: []
  type: TYPE_PRE
  zh: '[PRE134]'
- en: '[PRE135]'
  id: totrans-229
  prefs: []
  type: TYPE_PRE
  zh: '[PRE135]'
- en: '[PRE136]'
  id: totrans-230
  prefs: []
  type: TYPE_PRE
  zh: '[PRE136]'
- en: '[PRE137]'
  id: totrans-231
  prefs: []
  type: TYPE_PRE
  zh: '[PRE137]'
- en: Functions and methods
  id: totrans-232
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 函数和方法
- en: Similar to variables, using lowercase for function and method names is the best-practice
    preference. When there is more than one word in a variable name, it is a good
    practice to separate them using an underscore operator.
  id: totrans-233
  prefs: []
  type: TYPE_NORMAL
  zh: 与变量类似，对于函数和方法名称使用小写字母是最佳实践偏好。当变量名中有多个单词时，使用下划线操作符分隔它们是一种好习惯。
- en: 'Let’s look at an example of how a function or method should not be named:'
  id: totrans-234
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看一个函数或方法不应该如何命名的例子：
- en: '[PRE138]'
  id: totrans-235
  prefs: []
  type: TYPE_PRE
  zh: '[PRE138]'
- en: '[PRE139]'
  id: totrans-236
  prefs: []
  type: TYPE_PRE
  zh: '[PRE139]'
- en: '[PRE140]'
  id: totrans-237
  prefs: []
  type: TYPE_PRE
  zh: '[PRE140]'
- en: '[PRE141]'
  id: totrans-238
  prefs: []
  type: TYPE_PRE
  zh: '[PRE141]'
- en: '[PRE142]'
  id: totrans-239
  prefs: []
  type: TYPE_PRE
  zh: '[PRE142]'
- en: '[PRE143]'
  id: totrans-240
  prefs: []
  type: TYPE_PRE
  zh: '[PRE143]'
- en: '[PRE144]'
  id: totrans-241
  prefs: []
  type: TYPE_PRE
  zh: '[PRE144]'
- en: '[PRE145]'
  id: totrans-242
  prefs: []
  type: TYPE_PRE
  zh: '[PRE145]'
- en: '[PRE146]'
  id: totrans-243
  prefs: []
  type: TYPE_PRE
  zh: '[PRE146]'
- en: '[PRE147]'
  id: totrans-244
  prefs: []
  type: TYPE_PRE
  zh: '[PRE147]'
- en: '[PRE148]'
  id: totrans-245
  prefs: []
  type: TYPE_PRE
  zh: '[PRE148]'
- en: 'Let’s now look at an example of the preferred method for naming methods or
    functions:'
  id: totrans-246
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们来看一个命名方法或函数的首选方法的例子：
- en: '[PRE149]'
  id: totrans-247
  prefs: []
  type: TYPE_PRE
  zh: '[PRE149]'
- en: '[PRE150]'
  id: totrans-248
  prefs: []
  type: TYPE_PRE
  zh: '[PRE150]'
- en: '[PRE151]'
  id: totrans-249
  prefs: []
  type: TYPE_PRE
  zh: '[PRE151]'
- en: '[PRE152]'
  id: totrans-250
  prefs: []
  type: TYPE_PRE
  zh: '[PRE152]'
- en: '[PRE153]'
  id: totrans-251
  prefs: []
  type: TYPE_PRE
  zh: '[PRE153]'
- en: '[PRE154]'
  id: totrans-252
  prefs: []
  type: TYPE_PRE
  zh: '[PRE154]'
- en: '[PRE155]'
  id: totrans-253
  prefs: []
  type: TYPE_PRE
  zh: '[PRE155]'
- en: '[PRE156]'
  id: totrans-254
  prefs: []
  type: TYPE_PRE
  zh: '[PRE156]'
- en: '[PRE157]'
  id: totrans-255
  prefs: []
  type: TYPE_PRE
  zh: '[PRE157]'
- en: '[PRE158]'
  id: totrans-256
  prefs: []
  type: TYPE_PRE
  zh: '[PRE158]'
- en: '[PRE159]'
  id: totrans-257
  prefs: []
  type: TYPE_PRE
  zh: '[PRE159]'
- en: These naming conventions are recommendations that can be followed while developing
    new code or a library from scratch. However, if the code has already been developed
    and is being actively maintained, it is recommended to follow the naming conventions
    used throughout the code.
  id: totrans-258
  prefs: []
  type: TYPE_NORMAL
  zh: 这些命名约定是在从头开发新代码或库时可以遵循的建议。然而，如果代码已经开发并且正在积极维护，建议遵循代码中使用的命名约定。
- en: Avoiding the reuse of names
  id: totrans-259
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 避免名称重复
- en: In this example, let’s look at another best practice of how to use variable
    or class names such that the reusability aspect of your code is preserved. Sometimes
    it might seem easy to reuse the same class or variable names while writing code
    in a sequence. Reusing names will make it difficult to reuse the classes, variables,
    methods, or functions in your code as calling them in multiple scenarios will
    be impacted since the same names are reused for different elements.
  id: totrans-260
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个例子中，让我们看看如何使用变量或类名以保持代码的可重用性的另一个最佳实践。有时在按顺序编写代码时，可能会觉得重用相同的类或变量名很容易。重用名称将使重用代码中的类、变量、方法或函数变得困难，因为在多个场景中调用它们时，相同的名称被用于不同的元素。
- en: Let’s look at an example to understand the method that is not preferred. Let’s
    define two classes for `Branch` with a method named `maintenance_cost` with different
    definitions.
  id: totrans-261
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们通过一个例子来了解不推荐使用的方法。让我们定义两个名为 `Branch` 的类，并分别给它们定义一个名为 `maintenance_cost` 的方法。
- en: 'The first `Branch` class is defined as follows:'
  id: totrans-262
  prefs: []
  type: TYPE_NORMAL
  zh: 第一个 `Branch` 类的定义如下：
- en: '[PRE160]'
  id: totrans-263
  prefs: []
  type: TYPE_PRE
  zh: '[PRE160]'
- en: '[PRE161]'
  id: totrans-264
  prefs: []
  type: TYPE_PRE
  zh: '[PRE161]'
- en: '[PRE162]'
  id: totrans-265
  prefs: []
  type: TYPE_PRE
  zh: '[PRE162]'
- en: '[PRE163]'
  id: totrans-266
  prefs: []
  type: TYPE_PRE
  zh: '[PRE163]'
- en: '[PRE164]'
  id: totrans-267
  prefs: []
  type: TYPE_PRE
  zh: '[PRE164]'
- en: '[PRE165]'
  id: totrans-268
  prefs: []
  type: TYPE_PRE
  zh: '[PRE165]'
- en: '[PRE166]'
  id: totrans-269
  prefs: []
  type: TYPE_PRE
  zh: '[PRE166]'
- en: '[PRE167]'
  id: totrans-270
  prefs: []
  type: TYPE_PRE
  zh: '[PRE167]'
- en: '[PRE168]'
  id: totrans-271
  prefs: []
  type: TYPE_PRE
  zh: '[PRE168]'
- en: '[PRE169]'
  id: totrans-272
  prefs: []
  type: TYPE_PRE
  zh: '[PRE169]'
- en: 'The second `Branch` class is defined as follows:'
  id: totrans-273
  prefs: []
  type: TYPE_NORMAL
  zh: 第二个 `Branch` 类的定义如下：
- en: '[PRE170]'
  id: totrans-274
  prefs: []
  type: TYPE_PRE
  zh: '[PRE170]'
- en: '[PRE171]'
  id: totrans-275
  prefs: []
  type: TYPE_PRE
  zh: '[PRE171]'
- en: '[PRE172]'
  id: totrans-276
  prefs: []
  type: TYPE_PRE
  zh: '[PRE172]'
- en: '[PRE173]'
  id: totrans-277
  prefs: []
  type: TYPE_PRE
  zh: '[PRE173]'
- en: '[PRE174]'
  id: totrans-278
  prefs: []
  type: TYPE_PRE
  zh: '[PRE174]'
- en: '[PRE175]'
  id: totrans-279
  prefs: []
  type: TYPE_PRE
  zh: '[PRE175]'
- en: '[PRE176]'
  id: totrans-280
  prefs: []
  type: TYPE_PRE
  zh: '[PRE176]'
- en: '[PRE177]'
  id: totrans-281
  prefs: []
  type: TYPE_PRE
  zh: '[PRE177]'
- en: '[PRE178]'
  id: totrans-282
  prefs: []
  type: TYPE_PRE
  zh: '[PRE178]'
- en: 'In the preceding code, we have two `Branch` classes doing different tasks.
    Let’s now instantiate the `Branch` class, assuming the first `Branch` class needs
    to be executed at a later point in the code:'
  id: totrans-283
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的代码中，我们有两个执行不同任务的 `Branch` 类。现在让我们实例化 `Branch` 类，假设第一个 `Branch` 类需要在代码的稍后位置执行：
- en: '[PRE179]'
  id: totrans-284
  prefs: []
  type: TYPE_PRE
  zh: '[PRE179]'
- en: '[PRE180]'
  id: totrans-285
  prefs: []
  type: TYPE_PRE
  zh: '[PRE180]'
- en: 'The preceding code calls the `Branch` class defined last, and thus ends up
    losing the definition of the first `Branch` class:'
  id: totrans-286
  prefs: []
  type: TYPE_NORMAL
  zh: 前面的代码调用了最后定义的 `Branch` 类，因此最终丢失了第一个 `Branch` 类的定义：
- en: '[PRE181]'
  id: totrans-287
  prefs: []
  type: TYPE_PRE
  zh: '[PRE181]'
- en: To avoid such confusion, it is always preferred to provide different names for
    different elements in code.
  id: totrans-288
  prefs: []
  type: TYPE_NORMAL
  zh: 为了避免这种混淆，始终为代码中的不同元素提供不同的名称是首选的。
- en: 'Let’s look at the preferred method now. We will define a class named `Brooklyn`
    where FMCG products are stocked as follows:'
  id: totrans-289
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们来看一下推荐的方法。我们将定义一个名为 `Brooklyn` 的类，其中 FMCG 产品按以下方式存储：
- en: '[PRE182]'
  id: totrans-290
  prefs: []
  type: TYPE_PRE
  zh: '[PRE182]'
- en: '[PRE183]'
  id: totrans-291
  prefs: []
  type: TYPE_PRE
  zh: '[PRE183]'
- en: '[PRE184]'
  id: totrans-292
  prefs: []
  type: TYPE_PRE
  zh: '[PRE184]'
- en: '[PRE185]'
  id: totrans-293
  prefs: []
  type: TYPE_PRE
  zh: '[PRE185]'
- en: '[PRE186]'
  id: totrans-294
  prefs: []
  type: TYPE_PRE
  zh: '[PRE186]'
- en: '[PRE187]'
  id: totrans-295
  prefs: []
  type: TYPE_PRE
  zh: '[PRE187]'
- en: '[PRE188]'
  id: totrans-296
  prefs: []
  type: TYPE_PRE
  zh: '[PRE188]'
- en: '[PRE189]'
  id: totrans-297
  prefs: []
  type: TYPE_PRE
  zh: '[PRE189]'
- en: '[PRE190]'
  id: totrans-298
  prefs: []
  type: TYPE_PRE
  zh: '[PRE190]'
- en: '[PRE191]'
  id: totrans-299
  prefs: []
  type: TYPE_PRE
  zh: '[PRE191]'
- en: 'We will define another class named `Queens` where electronic products are stocked
    as follows:'
  id: totrans-300
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将定义另一个名为 `Queens` 的类，其中电子产品按以下方式存储：
- en: '[PRE192]'
  id: totrans-301
  prefs: []
  type: TYPE_PRE
  zh: '[PRE192]'
- en: '[PRE193]'
  id: totrans-302
  prefs: []
  type: TYPE_PRE
  zh: '[PRE193]'
- en: '[PRE194]'
  id: totrans-303
  prefs: []
  type: TYPE_PRE
  zh: '[PRE194]'
- en: '[PRE195]'
  id: totrans-304
  prefs: []
  type: TYPE_PRE
  zh: '[PRE195]'
- en: '[PRE196]'
  id: totrans-305
  prefs: []
  type: TYPE_PRE
  zh: '[PRE196]'
- en: '[PRE197]'
  id: totrans-306
  prefs: []
  type: TYPE_PRE
  zh: '[PRE197]'
- en: '[PRE198]'
  id: totrans-307
  prefs: []
  type: TYPE_PRE
  zh: '[PRE198]'
- en: '[PRE199]'
  id: totrans-308
  prefs: []
  type: TYPE_PRE
  zh: '[PRE199]'
- en: '[PRE200]'
  id: totrans-309
  prefs: []
  type: TYPE_PRE
  zh: '[PRE200]'
- en: 'We can now call both the classes and their methods without any issues:'
  id: totrans-310
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在可以无任何问题地调用这两个类及其方法：
- en: '[PRE201]'
  id: totrans-311
  prefs: []
  type: TYPE_PRE
  zh: '[PRE201]'
- en: '[PRE202]'
  id: totrans-312
  prefs: []
  type: TYPE_PRE
  zh: '[PRE202]'
- en: 'The output for `Brooklyn` is as follows:'
  id: totrans-313
  prefs: []
  type: TYPE_NORMAL
  zh: '`Brooklyn` 的输出如下：'
- en: '[PRE203]'
  id: totrans-314
  prefs: []
  type: TYPE_PRE
  zh: '[PRE203]'
- en: 'Similarly, we can instantiate the `Queens` class separately:'
  id: totrans-315
  prefs: []
  type: TYPE_NORMAL
  zh: 同样，我们可以单独实例化 `Queens` 类：
- en: '[PRE204]'
  id: totrans-316
  prefs: []
  type: TYPE_PRE
  zh: '[PRE204]'
- en: '[PRE205]'
  id: totrans-317
  prefs: []
  type: TYPE_PRE
  zh: '[PRE205]'
- en: 'The output for `Queens` is as follows:'
  id: totrans-318
  prefs: []
  type: TYPE_NORMAL
  zh: '`Queens` 的输出如下：'
- en: '[PRE206]'
  id: totrans-319
  prefs: []
  type: TYPE_PRE
  zh: '[PRE206]'
- en: Having looked at why we should avoid reusing names, we can further look at where
    to avoid metaprogramming.
  id: totrans-320
  prefs: []
  type: TYPE_NORMAL
  zh: 在了解了为什么我们应该避免重用名称之后，我们可以进一步了解在哪里避免元编程。
- en: Avoiding metaprogramming where not required
  id: totrans-321
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 避免在不必要的地方使用元编程
- en: 'Writing too much metaprogramming just because the feature is available in Python
    also makes the overall code very complex and hard to handle. The following aspects
    should be kept in mind while choosing to write a metaprogram for your application:'
  id: totrans-322
  prefs: []
  type: TYPE_NORMAL
  zh: 仅因为 Python 中有这个特性就写太多的元编程会使整体代码非常复杂且难以处理。在选择为你的应用程序编写元编程时，以下方面应予以考虑：
- en: Identify your use case and determine the need for metaprogramming based on how
    frequently you need to modify the code.
  id: totrans-323
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 确定你的用例，并根据你需要修改代码的频率来确定是否需要元编程。
- en: Understand how frequently you need to manipulate your code outside of its core
    elements such as classes, methods, and variables.
  id: totrans-324
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 理解你需要多频繁地操作代码的核心元素（如类、方法、变量）之外的部分。
- en: Check whether your solution can be developed with object-oriented programming
    alone or whether it depends on elements such as metaclasses, decorators, and code
    generation.
  id: totrans-325
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 检查你的解决方案是否仅使用面向对象编程即可开发，或者它是否依赖于元类、装饰器和代码生成等元素。
- en: Check whether your team has the relevant skills to maintain the metaprogramming
    features after development.
  id: totrans-326
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 检查你的团队在开发后是否具备维护元编程特性的相关技能。
- en: Check that you don’t have a dependency on earlier versions of Python that do
    not support some of the metaprogramming features.
  id: totrans-327
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 确认你没有依赖于不支持某些元编程特性的早期版本的 Python。
- en: These are some of the points to consider when planning to apply metaprogramming
    techniques during the application design phase.
  id: totrans-328
  prefs: []
  type: TYPE_NORMAL
  zh: 在应用设计阶段计划应用元编程技术时，以下是一些需要考虑的点。
- en: Summary
  id: totrans-329
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: In this chapter, we covered various examples to understand the best practices
    recommended in the PEP 8 standards for Python. We looked at the preferred methods
    for indentation and the correct use of white spaces. We also looked at how to
    write useful comments and where to include documentation strings.
  id: totrans-330
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们通过各种示例了解了 PEP 8 标准推荐的 Python 最佳实践。我们探讨了缩进的推荐方法和正确使用空白字符。我们还探讨了如何编写有用的注释以及在哪里包含文档字符串。
- en: We learned the recommended naming conventions through some examples. We also
    looked at why we need to avoid reusing names and where to avoid metaprogramming.
  id: totrans-331
  prefs: []
  type: TYPE_NORMAL
  zh: 我们通过一些示例学习了推荐的命名约定。我们还探讨了为什么需要避免重用名称以及在哪里避免元编程。
- en: While the concepts of metaprogramming are advanced and complex, we have tried
    to explain them with simple, straightforward examples throughout this book to
    keep it interesting and engaging. Learning Python and its features is a continuous
    journey. Keep following the future versions of Python and explore the new capabilities
    it provides for metaprogramming.
  id: totrans-332
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然元编程的概念是高级且复杂的，但我们试图通过本书中的简单、直接的示例来解释它们，以保持内容的趣味性和吸引力。学习 Python 及其特性是一个持续的过程。继续关注
    Python 的未来版本，并探索它为元编程提供的新功能。
