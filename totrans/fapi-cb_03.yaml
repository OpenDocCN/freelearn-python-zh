- en: '3'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Building RESTful APIs with FastAPI
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we delve into the essentials of building **RESTful APIs**.
    RESTful APIs are the backbone of web services, enabling applications to communicate
    and exchange data efficiently.
  prefs: []
  type: TYPE_NORMAL
- en: You will build a RESTful API for a Task Manager application. The application
    will interact with a CSV file, although the typical approach for such applications
    would be to use a database such as SQL or NoSQL. This approach is unconventional
    and not recommended for most scenarios due to scalability and performance limitations.
    However, in certain contexts, particularly in legacy systems or when dealing with
    large volumes of structured data files, managing data through CSV can be a practical
    solution.
  prefs: []
  type: TYPE_NORMAL
- en: Our Task Manager API will allow users to **create, read, update, and delete**
    (**CRUD**) tasks, each represented as a record in a CSV file. This example will
    provide insights into handling data in non-standard formats within FastAPI.
  prefs: []
  type: TYPE_NORMAL
- en: We will see how to test the API’s endpoint. As your API grows, managing complex
    queries and filtering becomes essential. We’ll explore techniques to implement
    advanced query capabilities, enhancing the usability and flexibility of your API.
  prefs: []
  type: TYPE_NORMAL
- en: Furthermore, we’ll tackle the important aspect of versioning your API. Versioning
    is key to evolving your API over time without breaking existing clients. You’ll
    learn strategies to manage API versions, ensuring backward compatibility and smooth
    transitions for users.
  prefs: []
  type: TYPE_NORMAL
- en: Lastly, we’ll cover securing API with OAuth2, an industry-standard protocol
    for authorization. Security is paramount in API development, and you’ll gain practical
    experience in implementing authentication and protecting your endpoints.
  prefs: []
  type: TYPE_NORMAL
- en: 'In this chapter, we’re going to cover the following recipes:'
  prefs: []
  type: TYPE_NORMAL
- en: Creating CRUD operations
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Creating RESTful endpoints
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Testing your RESTful API
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Handling complex queries and filtering
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Versioning your API
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Securing your API with OAuth2
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Documenting your API with Swagger and Redoc
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Technical requirements
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'To fully engage with this chapter in our *FastAPI Cookbook* and effectively
    build RESTful APIs, you’ll need to have the following technologies and tools installed
    and configured:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Python**: Make sure you have a Python version higher than 3.9 in your environment.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**FastAPI**: This should be installed with all required dependencies. If you
    haven’t done it from the previous chapters, you can do so simply from your terminal
    with the following command:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '**Pytest**: You can install this framework by running the following:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Note that it can be very useful to already have some knowledge of the Pytest
    framework to better follow the *Testing your RESTful* *API* recipe.
  prefs: []
  type: TYPE_NORMAL
- en: 'The code used in the chapter is available on GitHub at the address: [https://github.com/PacktPublishing/FastAPI-Cookbook/tree/main/Chapter03](https://github.com/PacktPublishing/FastAPI-Cookbook/tree/main/Chapter03).'
  prefs: []
  type: TYPE_NORMAL
- en: Feel free to follow along or consult it in case you get stuck.
  prefs: []
  type: TYPE_NORMAL
- en: Creating CRUD operations
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: This recipe will show you how to make the basic CRUD operations work with the
    CSV file that acts as a database.
  prefs: []
  type: TYPE_NORMAL
- en: We will begin by making a draft for a simple list of tasks in CSV format and
    we will put the operations in a separate Python module. By the end of the recipe,
    you will have all the operations ready to be used by the API’s endpoints.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it…
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Let’s start by creating a project root directory called `task_manager_app`
    to host our code base for our application:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Move into the root project folder and create a `tasks.csv` file, which we will
    use as a database and put a few tasks inside:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Then, create a file called `models.py`, containing the Pydantic models that
    we will use internally for the code. It will look like the following:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: We created two separate classes for task objects because `id` won’t be used
    all along the code.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: In a new file called `operations.py`, we will define the function that interacts
    with our database.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: We can start creating the CRUD operation
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Create a function to retrieve all the tasks from a `.``csv` file:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Now, we need to create a function to read a specific task based on `id`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: To write a task, we need a strategy to assign a new `id` to the task that will
    written into the database.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: A good strategy can be to implement a logic based on the IDs already present
    in the database, then write the task into our CSV file, and group both operations
    into a new function. We can split the create task operation into three functions.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'First, let’s create the function that retrieves the new ID based on the existing
    ones in the database:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Then, we define the function to write the task with the ID in the CSV file:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'After that, we can leverage these last two functions to define the function
    that creates the task:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Then, let’s create the function to modify the task:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Finally, let’s create the function to remove the task with a specific `id`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: You’ve just created the basic CRUD operations. We are now ready to expose those
    operations through the API endpoints.
  prefs: []
  type: TYPE_NORMAL
- en: How it works...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The structure of your API is fundamental in RESTful design. It involves defining
    endpoints (URIs) and associating them with HTTP methods to perform the desired
    operations.
  prefs: []
  type: TYPE_NORMAL
- en: 'In our Task Management system, we’ll create endpoints to handle tasks, mirroring
    common CRUD operations. Here’s an overview:'
  prefs: []
  type: TYPE_NORMAL
- en: '`List Tasks` (`GET /tasks`) retrieves a list of all tasks'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`Retrieve Task` (`GET /tasks/{task_id}`) gets details of a specific task'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`Create Task` (`POST /task`) adds a new task'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`Update Task` (`PUT /tasks/{task_id}`) modifies an existing task'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`Delete Task` (`DELETE /tasks/{task_id}`) removes a task'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Each endpoint represents a specific function in the API, clearly defined and
    purpose driven. FastAPI’s routing system allows us to map these operations to
    Python functions easily.
  prefs: []
  type: TYPE_NORMAL
- en: Exercise
  prefs: []
  type: TYPE_NORMAL
- en: Try to write your unit tests for each one of the CRUD operations. If you follow
    along with the GitHub repository, you can find the tests in the `Chapter03/task_manager_rest_api/test_operations.py`
    file.
  prefs: []
  type: TYPE_NORMAL
- en: Creating RESTful Endpoints
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Now, we will create the routes to expose each of the CRUD operations with a
    specific endpoint. In this recipe, we will see how FastAPI leverages Python type
    annotations to define expected request and response data types, streamlining the
    process of validation and serializing data.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready…
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Before starting the recipe, make sure you know how to set up your local environment
    and create a basic FastAPI server. You can review it in the *Creating a new FastAPI
    project* and *Understanding FastAPI basics* recipes in [*Chapter 1*](B21025_01.xhtml#_idTextAnchor020),
    *First Steps* *with FastAPI*.
  prefs: []
  type: TYPE_NORMAL
- en: Also, we will use the CRUD operations created in the previous recipe.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it…
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Let’s create a `main.py` file in the project root folder to code the server
    with the endpoints. FastAPI simplifies the implementation of different HTTP methods,
    aligning them with the corresponding CRUD operations.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s now write the endpoints for each operation:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Create the server with the endpoint to list all the tasks by using the `read_all_tasks`
    operation:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Now, let’s write the endpoint to read a specific task based on `id`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'The endpoint to add a task will be as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'To update the task, we can modify each field (`description`, `status`, or `title`).
    To do this, we create a specific model to be used in the body called `UpdateTask`.
    The endpoint will look like this:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Finally, here is the endpoint to delete a task:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: You have just implemented the operations to interact with the CSV file used
    as a database.
  prefs: []
  type: TYPE_NORMAL
- en: 'From a command terminal at the project root folder level, spin up the server
    with the `uvicorn` command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: In the browser, go to `http://localhost:8000/docs` and you will see the endpoints
    of your RESTful API that you just made.
  prefs: []
  type: TYPE_NORMAL
- en: You can experiment by creating some tasks, then listing them, updating them,
    and deleting some of them directly with the interactive documentation.
  prefs: []
  type: TYPE_NORMAL
- en: Testing your RESTful API
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Testing is a critical part of API development. In FastAPI, you can use various
    testing frameworks such as `pytest` to write tests for your API endpoints.
  prefs: []
  type: TYPE_NORMAL
- en: In this recipe, we are going to write unit tests for each of the endpoints we
    created earlier.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready…
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'If not done yet, ensure you have `pytest` installed in your environment by
    running:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: It’s a good practice in testing to use a dedicated database to avoid interaction
    with the production one. To accomplish this, we will create a test fixture that
    generates the database before each test.
  prefs: []
  type: TYPE_NORMAL
- en: 'We will define this in a `conftest.py` module so that the fixture is applied
    to all tests under the project’s root folder. Let’s create the module in the project
    root folder and start by defining a list of test tasks and the name of the CSV
    file used for the tests:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: We can now create a fixture that will be used for all the tests. This fixture
    will set up the test database before each test function execution.
  prefs: []
  type: TYPE_NORMAL
- en: 'We can achieve this by passing the `autouse=True` argument to the `pytest.fixture`
    decorator, which indicates that the feature will run before every single test:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: Since the fixture is defined in a `conftest.py` module, each test module will
    automatically import it.
  prefs: []
  type: TYPE_NORMAL
- en: Now, we can proceed with creating the actual unit test functions for the endpoints
    created in the previous recipe.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: To test the endpoints, FastAPI provides a specific `TestClient` class that allows
    the testing of the endpoints without running the server.
  prefs: []
  type: TYPE_NORMAL
- en: 'In a new module called `test_main.py`, let’s define our test client:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: We can create the tests for each endpoint as follows.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s start with the `GET /tasks` endpoint, which lists all the tasks in the
    database:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: We are asserting the response’s status code and the `json` body.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'As easy as that, we can go on by creating the test for `GET /tasks/{task_id}`
    to read a task with a specific `id`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Besides the `200` status code for an existing task, we also asserted the status
    code is equal to `404` when the task does not exist in the database.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'In a similar way, we can test the `POST /task` endpoint to add a new task into
    the database by asserting the new assigned `id` for the task:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'The test for the `PUT /tasks/{task_id}` endpoint to modify a task will then
    be the following:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Finally, we test the `DELETE /tasks/{task_id}` endpoint to delete a task:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: You’ve just written all the unit tests for each of the API endpoints.
  prefs: []
  type: TYPE_NORMAL
- en: 'You can now run the tests from the project root folder by running in the terminal,
    or with the GUI support of your favorite editor:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: Pytest will collect all the tests and run them. If everything is correctly done,
    you will see a message that says you got a 100% score in the output of the console
    if you have written the tests correctly.
  prefs: []
  type: TYPE_NORMAL
- en: See also
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'You can check test fixtures in the Pytest documentation:'
  prefs: []
  type: TYPE_NORMAL
- en: '*Pytest Fixtures* *Reference*: [https://docs.pytest.org/en/7.1.x/reference/fixtures.xhtml](https://docs.pytest.org/en/7.1.x/reference/fixtures.xhtml)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'You can dig into FastAPI testing tools and the `TestClient` API in the official
    documentation:'
  prefs: []
  type: TYPE_NORMAL
- en: '*FastAPI* *Testing*: [https://fastapi.tiangolo.com/tutorial/testing/](https://fastapi.tiangolo.com/tutorial/testing/)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*FastAPI* *TestClient*: [https://fastapi.tiangolo.com/reference/testclient/](https://fastapi.tiangolo.com/reference/testclient/)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Handling complex queries and filtering
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In any RESTful API, providing the functionality to filter data based on certain
    criteria is essential. In this recipe, we’ll enhance our Task Manager API to allow
    users to filter tasks based on different parameters and create a search endpoint.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready…
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The filtering functionality will be implemented in the existing `GET /tasks`
    endpoint to show how to overcharge an endpoint, while the search functionality
    will be shown on a brand-new endpoint. Make sure you have at least the CRUD operations
    already in place before continuing.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'We will start by overcharging `GET /tasks` endpoint with filters. We modify
    the endpoint to accept two query parameters: `status` and `title`.'
  prefs: []
  type: TYPE_NORMAL
- en: 'The endpoint will then look like the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: The two parameters can be optionally specified to filter the tasks that match
    their value.
  prefs: []
  type: TYPE_NORMAL
- en: 'Next, we implement a search functionality. Beyond basic filtering, implementing
    a search functionality can significantly improve the usability of an API. We’ll
    add a search feature that allows users to find tasks based on a keyword present
    in the title or description in a new endpoint:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: In the `search_tasks` endpoint, the function filters tasks to include only those
    where the keyword appears in either the title or the description.
  prefs: []
  type: TYPE_NORMAL
- en: 'To start the server as usual, run this command from the command line:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: Then, go to the interactive documentation address at `http://localhost:8000/docs`,
    and you will see the new endpoint we’ve just made.
  prefs: []
  type: TYPE_NORMAL
- en: Play around by specifying some keywords that could be in the title or the description
    of one of your tasks.
  prefs: []
  type: TYPE_NORMAL
- en: Versioning your API
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '**API versioning** is essential in maintaining and evolving web services without
    disrupting the existing users. It allows developers to introduce changes, improvements,
    or even breaking changes while providing backward compatibility. In this recipe,
    we will implement versioning in our Task Manager API.'
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready…
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: To follow the recipe, you will need to have endpoints already defined. If you
    don’t have them, you can first check the *Creating RESTful* *endpoints* recipe.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: There are several strategies for API versioning. We will use the most common
    approach, URL path versioning, for our API.
  prefs: []
  type: TYPE_NORMAL
- en: Let’s consider that we want to improve the task information by adding a new
    `str` field called `priority` that is set to `"lower"` by default. Let's do it
    through the following steps.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s create a `TaskV2` object class in the `models.py` module:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'In the `operations.py` module, let’s create a new function called `read_all_tasks_v2`,
    which reads all the tasks, and add the `priority` field:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'We have now all we need to create version two of `read_all_tasks` function.
    We will do this in the `main.py` module:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: You’ve just created version two of the endpoint. In this way, you can develop
    and improve your API with several versions of your endpoint.
  prefs: []
  type: TYPE_NORMAL
- en: 'To test it, let''s modify our `tasks.csv` file by manually adding the new field
    to test the new endpoint:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: 'Start the server once more from the command line:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs: []
  type: TYPE_PRE
- en: Now, the interactive documentation at `http://localhost:8000/docs` will show
    the new `GET /v2/tasks` endpoint to list all the tasks in version 2 mode.
  prefs: []
  type: TYPE_NORMAL
- en: Check that the endpoint lists the tasks with the new `priority` field and that
    the old `GET /tasks` is still working as expected.
  prefs: []
  type: TYPE_NORMAL
- en: Exercise
  prefs: []
  type: TYPE_NORMAL
- en: You might have noticed that using a CSV file as a database might not be the
    most reliable solution. If the process crashes during an update or removal, you
    can lose all of the data. So, improve the API with a newer version of the endpoints
    that use operational functions that interact with an SQLite database.
  prefs: []
  type: TYPE_NORMAL
- en: There’s more…
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: When you version an API, you are essentially providing a way to differentiate
    between different releases or versions of your API, allowing clients to choose
    which version they want to interact with.
  prefs: []
  type: TYPE_NORMAL
- en: 'Besides the URL-based approach that we used in the recipe, there are other
    common approaches to API versioning, such as the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Query parameter versioning**: Version information is passed as a query parameter
    in the API request. For example, see the following:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: This method keeps the base URL uniform across versions.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '**Header versioning**: The version is specified in a custom header of the HTTP
    request:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: This keeps the URL clean but requires clients to explicitly set the version
    in their requests.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '**Consumer-based versioning**: This strategy allows customers to choose the
    version they need. The version available at their first interaction is saved with
    their details and used in all future interactions unless they make changes.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Furthermore, it can be relevant to use `MAJOR.MINOR.PATCH`). Changes in the
    `MAJOR` version indicate incompatible API changes, while `MINOR` and `PATCH` versions
    indicate backward-compatible changes.
  prefs: []
  type: TYPE_NORMAL
- en: Versioning allows API providers to introduce changes (such as adding new features,
    modifying existing behavior, or deprecating endpoints and sunset policies) without
    breaking existing client integrations.
  prefs: []
  type: TYPE_NORMAL
- en: It also gives consumers control over when and how they adopt new versions, minimizing
    disruptions and maintaining stability in the API ecosystem.
  prefs: []
  type: TYPE_NORMAL
- en: See also
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'You can have a look at an interesting article from the Postman blog on API
    versioning strategies:'
  prefs: []
  type: TYPE_NORMAL
- en: '*Postman Blog API* *Versioning*: [https://www.postman.com/api-platform/api-versioning/](https://www.postman.com/api-platform/api-versioning/)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Securing your API with OAuth2
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In web applications, securing endpoints from unauthorized users is crucial.
    **OAuth2** is a common authorization framework that enables applications to be
    accessed by user accounts with restricted permissions. It works by issuing tokens
    instead of credentials. This recipe will show how to use OAuth2 in our Task Manager
    API to protect endpoints.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready…
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: FastAPI provides support for OAuth2 with a password, including the use of external
    tokens. Data compliance regulations require that passwords are not stored in plain
    text. Instead, a usual method is to store the outcome of the hashing operation,
    which changes the plain text into a string that is not readable by humans and
    cannot be reversed.
  prefs: []
  type: TYPE_NORMAL
- en: Important note
  prefs: []
  type: TYPE_NORMAL
- en: With the only purpose of showing the functionality, we will fake the hashing
    mechanism as well the token creation with trivial ones. For obvious security reasons,
    do not use it in a production environment.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it…
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Let’s start by creating a `security.py` module in the project root folder where
    we are going to implement all tools used to secure our service. Then let's create
    a secured endpoint as follows.
  prefs: []
  type: TYPE_NORMAL
- en: 'First, let’s create a dictionary containing a list of users with their usernames
    and passwords:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE37]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Passwords should not be stored in plain text, but encrypted or hashed. To demonstrate
    the feature, we fake the hashing mechanism by inserting `"hashed"` before the
    password string:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE38]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Let’s create the classes to handle the users and a function to retrieve the
    user from the `dict` database we created:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE39]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Using a similar logic to what we’ve just used for hashing, let’s make a fake
    token generator and a fake token resolver:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE40]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Now, let’s create a function to retrieve the user from the token. To this,
    we will make use of the `Depends` class to use dependency injection provided by
    FastAPI (see [https://fastapi.tiangolo.com/tutorial/dependencies/](https://fastapi.tiangolo.com/tutorial/dependencies/)),
    with the `OAuthPasswordBearer` class to handle the token:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE41]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '`oauth2scheme` contains the `/token` URL endpoint that will be used by the
    interactive documentation to authenticate the browser.'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Important note
  prefs: []
  type: TYPE_NORMAL
- en: We have used a dependency injection to retrieve the token from the `get_user_token`
    function with the `fastapi.Depends` object. A dependency injection pattern is
    not native to the Python language and it is strictly related to the FastAPI framework.
    In [*Chapter 8*](B21025_08.xhtml#_idTextAnchor262), *Advanced Features and Best
    Practices*, you will find a dedicated recipe about that called *Implementing*
    *dependency injection*.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s create the endpoint in the `main.py` module:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE42]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: We now have all we need to create a secured endpoint with OAuth2 authentication.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'The endpoint we are going to create will return information about the current
    user from the token provided. If the token does not have authorization, it will
    return a `400` exception:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE43]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: The endpoint we just created will be reachable only by allowed users.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Let''s now test our secured endpoint. From the command line terminal at the
    project root folder level, spin up the server by running:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE44]'
  prefs: []
  type: TYPE_PRE
- en: Then, open the browser, go to `http://localhost:8000/docs`, and you will notice
    the new `token` and `users/me` endpoints in the interactive documentation.
  prefs: []
  type: TYPE_NORMAL
- en: You might notice a little padlock icon on the `users/me` endpoint. If you click
    on it, you will see a form window that allows you to get the token and store it
    directly in your browser, so you don’t have to provide it each time you call the
    secured endpoint.
  prefs: []
  type: TYPE_NORMAL
- en: Exercise
  prefs: []
  type: TYPE_NORMAL
- en: You’ve just learned how to create a secured endpoint for your RESTful API. Now,
    try to secure some of the endpoints you created in the previous recipes.
  prefs: []
  type: TYPE_NORMAL
- en: There’s more…
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: With OAuth2, we can define a **scope** parameter, which is used to specify the
    level of access that an access token grants to a client application when it is
    used to access a protected resource. Scopes can be used to define what actions
    or resources the client application is allowed to perform or access on behalf
    of the user.
  prefs: []
  type: TYPE_NORMAL
- en: When a client requests authorization from the resource owner (user), it includes
    one or more scopes in the authorization request. In FastAPI, these scopes are
    represented as `dict`, where keys represent the scope’s name and the value is
    a description.
  prefs: []
  type: TYPE_NORMAL
- en: The authorization server then uses these scopes to determine the appropriate
    access controls and permissions to grant to the client application when issuing
    an access token.
  prefs: []
  type: TYPE_NORMAL
- en: 'It is not the purpose of this recipe to go into the details of implementing
    OAuth2 scopes in FastAPI. However, you can find practical examples on the official
    documentation page at the link: [https://fastapi.tiangolo.com/advanced/security/oauth2-scopes/](https://fastapi.tiangolo.com/advanced/security/oauth2-scopes/).'
  prefs: []
  type: TYPE_NORMAL
- en: See also
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'You can check on how FastAPI integrates OAuth2 at the following link:'
  prefs: []
  type: TYPE_NORMAL
- en: '*Simple OAuth2 with Password and* *Bearer*: https://fastapi.tiangolo.com/tutorial/security/simple-oauth2/'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Also, you can find more on dependency injection in FastAPI on the official
    documentation page:'
  prefs: []
  type: TYPE_NORMAL
- en: '*Dependencies*: [https://fastapi.tiangolo.com/tutorial/dependencies/](https://fastapi.tiangolo.com/tutorial/dependencies/)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Documenting your API with Swagger and Redoc
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: FastAPI automatically generates documentation for your API using **Swagger UI**
    and **Redoc**, when spinning the server.
  prefs: []
  type: TYPE_NORMAL
- en: This documentation is derived from your route functions and Pydantic models,
    making it incredibly beneficial for both development and consumption by frontend
    teams or API consumers.
  prefs: []
  type: TYPE_NORMAL
- en: In this recipe, we will see how to customize the documentation’s specific needs.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready…
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'By default, FastAPI provides two documentation interfaces:'
  prefs: []
  type: TYPE_NORMAL
- en: '`/docs` endpoint (e.g., `http://127.0.0.1:8000/docs`)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`/redoc` endpoint (e.g., `http://127.0.0.1:8000/redoc`)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: These interfaces offer dynamic documentation where users can see and test the
    API endpoints and their details. However, both pieces of documentation can be
    modified.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: FastAPI allows the customization of Swagger UI. You can add metadata, customize
    the look, and add additional documentation through the `FastAPI` class parameters.
  prefs: []
  type: TYPE_NORMAL
- en: 'You can enhance your API documentation by providing additional metadata such
    as `title`, `description`, and `version` to the `app` object in the `main.py`
    module:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE45]'
  prefs: []
  type: TYPE_PRE
- en: This metadata will appear in both Swagger UI and Redoc documentation.
  prefs: []
  type: TYPE_NORMAL
- en: You can push things further by completely customizing your Swagger UI in case
    you need to expose it to a third user under certain conditions.
  prefs: []
  type: TYPE_NORMAL
- en: Let’s try to hide the `/token` endpoint from the documentation.
  prefs: []
  type: TYPE_NORMAL
- en: 'In this case, you can use the `utils`, module provided by FastAPI to retrieve
    the OpenAPI schema of the Swagger UI in a `dict` object as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE46]'
  prefs: []
  type: TYPE_PRE
- en: That’s all you need to customize your API documentation.
  prefs: []
  type: TYPE_NORMAL
- en: If you spin up the server with the `uvicorn main:app` command and go to one
    of the two documentation pages, the `/token` endpoint won’t appear anymore.
  prefs: []
  type: TYPE_NORMAL
- en: You are now able to customize your API documentation to elevate the way you
    present it to your customers.
  prefs: []
  type: TYPE_NORMAL
- en: See also
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'You find out more about FastAPI generation for metadata, features, and OpenAPI
    integration on the official documentation pages:'
  prefs: []
  type: TYPE_NORMAL
- en: '*Metadata and Docs* *URLs*: [https://fastapi.tiangolo.com/tutorial/metadata/](https://fastapi.tiangolo.com/tutorial/metadata/)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*FastAPI* *Features*: [https://fastapi.tiangolo.com/features/](https://fastapi.tiangolo.com/features/)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*Extending* *OpenAPI*: [https://fastapi.tiangolo.com/how-to/extending-openapi/](https://fastapi.tiangolo.com/how-to/extending-openapi/)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
