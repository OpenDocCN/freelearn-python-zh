<html><head></head><body>
<div><div><div><h1 id="_idParaDest-65" class="contributor"><a id="_idTextAnchor071" class="calibre7 pcalibre3 pcalibre pcalibre4 pcalibre1 pcalibre2"/>4</h1>
			<h1 id="_idParaDest-66" class="contributor"><a id="_idTextAnchor072" class="calibre7 pcalibre3 pcalibre pcalibre4 pcalibre1 pcalibre2"/>Getting Started with FastAPI</h1>
			<p class="calibre5">The <strong class="bold">application programming interface</strong> (<strong class="bold">API</strong>) is the cornerstone of your FARM stack, functioning as the brain of the system. It implements business logic that dictates how the data flows in and out of the system, but more importantly, how it relates to the business requirements inside your system.</p>
			<p class="calibre5">Frameworks such as FastAPI are much easier to showcase through examples. In this chapter, you’ll explore some simple endpoints that make up for a minimal, self-contained REST API. These examples will help you understand how FastAPI handles requests and responses.</p>
			<p class="calibre5">This chapter focuses on introducing the framework, along with the standard REST API practices and how they are implemented in FastAPI. You’ll learn how to send requests and modify them according to your needs, and how to retrieve all the data from HTTP requests, including parameters and request bodies. You’ll also understand how to handle responses and how you can use FastAPI to easily set cookies, headers, and other standard web-related topics.</p>
			<p class="calibre5">This chapter will cover the following topics:</p>
			<ul class="calibre14">
				<li class="calibre17">An overview of the FastAPI framework</li>
				<li class="calibre17">Setup and requirements for a simple FastAPI app</li>
				<li class="calibre17">Python features in FastAPI, such as type hinting, annotations, and <code>async/await</code> syntax</li>
				<li class="calibre17">How FastAPI handles typical REST API tasks</li>
				<li class="calibre17">Working with form data</li>
				<li class="calibre17">Anatomy of a FastAPI project and routers</li>
			</ul>
			<h1 id="_idParaDest-67" class="contributor"><a id="_idTextAnchor073" class="calibre7 pcalibre3 pcalibre pcalibre4 pcalibre1 pcalibre2"/>Technical requirements</h1>
			<p class="calibre5">For this chapter, you will need the following:</p>
			<ul class="calibre14">
				<li class="calibre17">Python setup</li>
				<li class="calibre17">Virtual environments</li>
				<li class="calibre17">Code editor and plugins</li>
				<li class="calibre17">REST client</li>
			</ul>
			<p class="calibre5">The following sections cover these requirements in more detail.</p>
			<h2 id="_idParaDest-68" class="about-the-author"><a id="_idTextAnchor074" class="calibre7 pcalibre3 pcalibre pcalibre4 pcalibre1 pcalibre2"/>Python setup</h2>
			<p class="calibre5">If you do not have Python installed, visit the Python download site (<a href="https://www.python.org/downloads/" class="calibre7 pcalibre3 pcalibre pcalibre4 pcalibre1 pcalibre2">https://www.python.org/downloads/</a>) to get the installer for your OS. In this book, you will be using <strong class="bold">version</strong> <strong class="bold">3.11.7</strong> or later.</p>
			<p class="calibre5">FastAPI relies heavily on Python hints and annotations, and Python versions after 3.6 treat type hints in a similar, modern way; so, while theoretically any version later than 3.6 should work, the code in this book uses Python version 3.11.7, for compatibility reasons.</p>
			<p class="calibre5">Ensure that your Python installation is upgraded to one of the latest Python versions—as stated, at least version 3.11.7—and is reachable and the default version. You can check this by:</p>
			<ul class="calibre14">
				<li class="calibre17">Typing <code>python</code> in your terminal of choice.</li>
				<li class="calibre17">Using <strong class="bold">pyenv</strong>, a handy tool that manages multiple Python versions on the same machine.</li>
			</ul>
			<h2 id="_idParaDest-69" class="about-the-author"><a id="_idTextAnchor075" class="calibre7 pcalibre3 pcalibre pcalibre4 pcalibre1 pcalibre2"/>Virtual environments</h2>
			<p class="calibre5">If you have ever worked with a Python project before, chances are you needed to include some, if not dozens, Python third-party packages. After all, one of Python’s main strengths lies in its vast ecosystem, which is one of the primary reasons it's chosen for the FARM stack.</p>
			<p class="calibre5">Without getting into the detailed specifics of how Python manages third-party package installations, let’s just go over the main problems that can arise should you decide to use only one Python installation for all of your projects, or even worse, should that installation be the default operating system Python installation.</p>
			<p class="calibre5">Following are a few challenges: </p>
			<ul class="calibre14">
				<li class="calibre17">Operating systems often lag in terms of Python versions, so the latest couple of versions likely won’t be available. </li>
				<li class="calibre17">Packages will get installed into the same namespace or in the same packages folder, creating havoc in any application or package that depends on that package.</li>
				<li class="calibre17">Python packages depend on other packages and those packages also have versions. Let’s suppose that you are using package A, which depends on packages B and C, and for some reason, you need to keep package B to a specific version (i.e., 1.2.3). You might need package B for a totally different project and that project might require a different version.</li>
				<li class="calibre17">Reduced or impossible reproducibility: without a separate Python virtual environment, it would prove very difficult to quickly replicate the desired functionality with all the required packages.</li>
			</ul>
			<p class="calibre5">Python virtual environments are the solution to the aforementioned problems as they allow you to work in a pristine Python development with only the packages and package versions that you need. In our case, the virtual environment will certainly include the core packages: FastAPI and Uvicorn. FastAPI, on the other hand, depends on Starlette, Pydantic, and so on, so it is really important to have the package versions under control.</p>
			<p class="calibre5">The best practice for Python development states that each project, no matter how big or small, should have its own virtual environment. While there are several ways of creating a virtual environment, which is a separated and isolated Python environment, you will use <code>virtualenv</code>.</p>
			<p class="calibre5">The basic syntax for creating new virtual environments with <code>virtualenv</code> is given in the following command. Once you are in the project folder, name your folder <code>FARM</code> or <code>chapter4</code>, open a terminal, and enter the following command:</p>
			<pre class="console">
python – m venv venv</pre>			<p class="calibre5">This command will create a new virtual environment for your project, a copy of the Python interpreter (or if you are using macOS, a brand new Python interpreter) and the necessary folder structure, a couple of commands necessary for activating and deactivating the environment, as well as a copy of the <code>pip</code> installer (pip installs packages).</p>
			<p class="calibre5">In order to activate your new virtual environment, you will choose one of the following commands, depending on your operating system. For Windows systems, type the following in the shell:</p>
			<pre class="console">
venv/Scripts/activate</pre>			<p class="calibre5">On Linux or macOS systems, use the following command:</p>
			<pre class="console">
source venv/bin/activate</pre>			<p class="calibre5">In both cases, your shell should now be prepended with the name that you have given to your environment. In the command to create a new virtual environment, the final parameter is the name of the environment, so it was <code>venv</code> in this case.</p>
			<p class="calibre5">Some considerations when working with virtual environments are as follows:</p>
			<ul class="calibre14">
				<li class="calibre17">There are different schools of thought when it comes to virtual environment placement. For now, it will suffice if you keep them inside your project folder like you did.</li>
				<li class="calibre17">Similar to the <code>activate</code> command, there is also a <code>deactivate</code> command to exit your virtual environment.</li>
				<li class="calibre17">Saving the exact package versions in a <code>requirements.txt</code> file and pinning the dependencies is not only useful but also often mandatory when deploying.</li>
			</ul>
			<p class="calibre5">There are many alternatives to <code>virtualenv</code> in the Python community, as well as many complementary packages. Poetry is a tool that manages virtual environments and dependencies simultaneously, <code>virtualenvwrapper</code> is a set of utilities that further simplify the process of environment management. <code>pyenv</code> is a bit more complex—it manages Python versions and allows you to have different virtual environments based on different Python versions.</p>
			<h2 id="_idParaDest-70" class="about-the-author"><a id="_idTextAnchor076" class="calibre7 pcalibre3 pcalibre pcalibre4 pcalibre1 pcalibre2"/>Code editors</h2>
			<p class="calibre5">While there are many great code editors and <strong class="bold">integrated development environments</strong> (<strong class="bold">IDEs</strong>) for Python, a common choice is <strong class="bold">Visual Studio Code</strong> (<strong class="bold">VS Code</strong>) from Microsoft. Released in 2015, it’s cross-platform, providing a lot of integrated tools, such as an integrated terminal for running your development server. It’s lightweight and offers hundreds of plugins for virtually any programming task you may have. Since you’ll be working with JavaScript, Python, React, and CSS for styling, along with running command-line processes, using VS Code is the easiest option.</p>
			<p class="calibre5">There’s also an excellent MongoDB plugin named <strong class="bold">MongoDB for VS Code</strong>, that allows you to connect to a MongoDB or Atlas cluster, navigate through databases and collections, get a quick overview of the schema and indexes, and view documents in collections. This proves very handy in a full stack scenario when you find yourself dealing with backend code in Python, frontend code in JavaScript and React or Next.js, running shells, and needing to quickly view the state of the MongoDB database. The extension is available here: <a href="https://marketplace.visualstudio.com/items?itemName=mongodb.mongodb-vscode" class="calibre7 pcalibre3 pcalibre pcalibre4 pcalibre1 pcalibre2">https://marketplace.visualstudio.com/items?itemName=mongodb.mongodb-vscode</a>. You can install it from the <strong class="bold">Extensions</strong> tab in Visual Studio Code as well, just by searching for MongoDB.</p>
			<h2 id="_idParaDest-71" class="about-the-author"><a id="_idTextAnchor077" class="calibre7 pcalibre3 pcalibre pcalibre4 pcalibre1 pcalibre2"/>Terminal</h2>
			<p class="calibre5">Besides Python and Git, you’ll need a shell program. Linux and Mac users usually have one pre-installed. For Windows, you can use Windows PowerShell or a console emulator such as <strong class="bold">Cmder</strong> (<a href="https://cmder.app/" class="calibre7 pcalibre3 pcalibre pcalibre4 pcalibre1 pcalibre2">https://cmder.app</a>), which offers additional features.</p>
			<h2 id="_idParaDest-72" class="about-the-author"><a id="_idTextAnchor078" class="calibre7 pcalibre3 pcalibre pcalibre4 pcalibre1 pcalibre2"/>REST clients</h2>
			<p class="calibre5">To effectively test your REST API, you’ll need a REST client. While <strong class="bold">Postman</strong> (<a href="https://www.postman.com/" class="calibre7 pcalibre3 pcalibre pcalibre4 pcalibre1 pcalibre2">https://www.postman.</a>) is robust and customizable, there are other viable alternatives. <strong class="bold">Insomnia</strong> () and the REST GUI offer a simpler interface, while <strong class="bold">HTTPie</strong> (), a command-line REST API client, allows quick testing without leaving the shell. It offers features such as an expressive syntax, handling of forms and uploads, and sessions.</p>
			<p class="calibre5">HTTPie is probably the easiest REST client to install, as it can be done using <code>pip</code> or some other package manager, such as Chocolatey, apt (for Linux), or Homebrew.</p>
			<p class="calibre5">The easiest way to install HTTPie is to activate your virtual environment and use <code>pip</code>, as shown in the following command:</p>
			<pre class="console">
pip install httpie</pre>			<p class="calibre5">Once it’s been installed, you can test HTTPie with the following command:</p>
			<pre class="console">
(venv) http GET "http://jsonplaceholder.typicode.com/todos/1"</pre>			<p class="calibre5">The output should begin with an <code>HTTP/1.1 200 </code><code>OK</code> response.</p>
			<p class="calibre5"><code>venv</code> signifies that the virtual environment is active. HTTPie simplifies issuing HTTP requests by simply adding <code>POST</code> for <code>POST</code> requests, payloads, form values, and so on.</p>
			<h2 id="_idParaDest-73" class="about-the-author"><a id="_idTextAnchor079" class="calibre7 pcalibre3 pcalibre pcalibre4 pcalibre1 pcalibre2"/>Installing the necessary packages</h2>
			<p class="calibre5">After setting up the virtual environment, you should activate it and install the Python libraries required for your first simple application: FastAPI and Uvicorn.</p>
			<p class="calibre5">For FastAPI to run, it needs a server. In this case, a server is a software designed to serve web applications (or REST APIs). FastAPI relies on the <strong class="bold">asynchronous server gateway interface</strong> (<strong class="bold">ASGI</strong>), which enables async non-blocking applications, which is something you can completely use with your FastAPI capabilities. You can read more about ASGI in the following documentation: <a href="https://asgi.readthedocs.io/" class="calibre7 pcalibre3 pcalibre pcalibre4 pcalibre1 pcalibre2">https://asgi.readthedocs.io/</a>.</p>
			<p class="calibre5">At present, the FastAPI documentation lists three compatible Python ASGI-compatible servers: <strong class="bold">Uvicorn</strong>, <strong class="bold">Hypercorn</strong>, and <strong class="bold">Daphne</strong>. This book will focus on Uvicorn, the most widely used and recommended option for working with FastAPI. Uvicorn offers high performance, and if you get stuck, there’s extensive documentation available online.</p>
			<p class="calibre5">To install the first two dependencies, ensure you’re in your working directory with the desired virtual environment activated, then execute the following:</p>
			<pre class="console">
pip install fastapi uvicorn</pre>			<p class="calibre5">Now, you have a Python coding environment that contains a shell, one or two REST clients, a great editor, and a great REST framework. If you’ve previously developed a <strong class="bold">Django</strong> or <strong class="bold">Flask</strong> application, this should all be familiar ground.</p>
			<p class="calibre5">Finally, choose a folder or clone this book’s GitHub repository and activate a virtual environment. It is customary to create the environment in a folder named <code>venv</code> within the working directory, but feel free to structure your directories and code as you prefer.</p>
			<p class="calibre5">Later, this chapter will briefly discuss some options for structuring your FastAPI code. For now, ensure you’re in a folder with your newly created virtual environment activated.</p>
			<h1 id="_idParaDest-74" class="contributor"><a id="_idTextAnchor080" class="calibre7 pcalibre3 pcalibre pcalibre4 pcalibre1 pcalibre2"/>FastAPI in a nutshell</h1>
			<p class="calibre5">In <a href="B22406_01.xhtml#_idTextAnchor010" class="calibre7 pcalibre3 pcalibre pcalibre4 pcalibre1 pcalibre2"><em class="italic">Chapter 1</em></a>, <em class="italic">Web Development and the FARM Stack</em>, it was mentioned why FastAPI is the preferred REST framework in the FARM stack. What sets FastAPI apart is its coding speed and the resulting clean code, with which you can spot bugs quickly and early. The author of the framework himself, <em class="italic">Sebastian Ramirez</em>, often modestly emphasizes that FastAPI is just a mix of Starlette and Pydantic, while heavily relying on modern Python features, especially type hinting.</p>
			<p class="calibre5">Before diving into an example and building a FastAPI app, it is useful to quickly go over the frameworks that FastAPI is based on.</p>
			<h2 id="_idParaDest-75" class="about-the-author"><a id="_idTextAnchor081" class="calibre7 pcalibre3 pcalibre pcalibre4 pcalibre1 pcalibre2"/>Starlette</h2>
			<p class="calibre5">Starlette is an ASGI framework known for its top performance and numerous features, which are also available in FastAPI. These include WebSocket support, events on startup and shutdown, session and cookie support, background tasks, middleware implementations, and templates. While you will not be coding directly in Starlette, it is important to know how FastAPI works under the hood and what its origins are.</p>
			<p class="calibre5">If you’re interested in knowing its functionalities, visit Starlette’s excellent documentation (https://www.starlette.io/).</p>
			<h2 id="_idParaDest-76" class="about-the-author"><a id="_idTextAnchor082" class="calibre7 pcalibre3 pcalibre pcalibre4 pcalibre1 pcalibre2"/>Asynchronous programming</h2>
			<p class="calibre5">You will likely have learned about the asynchronous programming paradigm when developing apps with Node.js. It involves running slow operations, such as network calls and file reading, allowing the system to respond to other requests without blocking. This is achieved by using an event loop, an asynchronous task manager that enables it to move requests to the next one, even though the previous one hasn’t finished and yielded a response.</p>
			<p class="calibre5">Python added support for asynchronous I/O programming in version 3.4 and the <code>async</code>/<code>await</code> keywords in version 3.6. ASGI emerged shortly afterward in the Python world, outlining how applications should be structured and called, and defining the events that can be sent and received. FastAPI relies on ASGI and returns an ASGI-compatible app.</p>
			<p class="calibre5">In this book, all the endpoint functions are prefixed with the <code>async</code> keyword, even before they become necessary, since you will be using the asynchronous Motor Python MongoDB driver.</p>
			<p class="callout-heading">Note</p>
			<p class="callout">If you are developing a simple application not expecting high stress, you can use simple synchronous code and the official PyMongo driver.</p>
			<p class="calibre5">Functions with the <code>async</code> keyword are coroutines; they run on the event loop. While simple examples in this chapter may work without <code>async</code>, the real power of asynchronous programming in FastAPI will be visible when you connect to your MongoDB server through an <code>async</code> driver, such as <strong class="bold">Motor </strong>(https://motor.readthedocs.io/en/stable/).</p>
			<h2 id="_idParaDest-77" class="about-the-author"><a id="_idTextAnchor083" class="calibre7 pcalibre3 pcalibre pcalibre4 pcalibre1 pcalibre2"/>Standard REST API operations</h2>
			<p class="calibre5">This section will discuss some common terminologies in API development. Usually, communication occurs via the HTTP protocol, through HTTP requests and responses. You’ll explore how FastAPI handles these aspects and leverages additional libraries such as Pydantic and type hints to improve efficiency. In the examples, you’ll be using Uvicorn as the server.</p>
			<p class="calibre5">The basis of any REST API communication is a system of URLs and paths. The URL for your local web development server will be <code>http://localhost:8000</code> since <code>8000</code> is the default port that Uvicorn uses. The path part (optional) of an endpoint could be <code>/cars</code>, while <code>http</code> is the scheme. You will see how FastAPI handles paths, query strings, and the request and response bodies, the significance of defining endpoint functions in a certain order, and how to extract variables from dynamic path segments effectively.</p>
			<p class="calibre5">In every path or address, the URL and the path combined, there’s a set of approved actions that can be performed on it—HTTP verbs. For example, a page or URL might list all the cars on sale, but you cannot issue a <code>POST</code> request since this is not allowed.</p>
			<p class="calibre5">In FastAPI, these verbs are implemented as Python <strong class="bold">decorators</strong>. To put it better, they are exposed as decorators, and they are implemented only if you, the developer, implement them.</p>
			<p class="calibre5">FastAPI encourages the proper and semantic use of HTTP verbs for data resource operations. For example, you should always use <code>POST</code> (or the <code>@post</code> decorator) when creating new resources, <code>GET</code> for reading data (individual or lists of items), <code>PATCH</code> for updating, and so on.</p>
			<p class="calibre5">HTTP messages consist of a request/status line, headers, and, optionally, body data. FastAPI offers tools to easily create and modify headers, set response codes, and manipulate request and response bodies in a clean and intuitive way.</p>
			<p class="calibre5">This section describes the programming concepts and specific Python features that underpin FastAPI’s performance and enable maintainable code. In the next section, you’ll learn about standard REST API operations and see how they’re achieved with FastAPI.</p>
			<h2 id="_idParaDest-78" class="about-the-author"><a id="_idTextAnchor084" class="calibre7 pcalibre3 pcalibre pcalibre4 pcalibre1 pcalibre2"/>How does FastAPI speak REST?</h2>
			<p class="calibre5">Observing even a minimal FastAPI application, the classic <strong class="bold">Hello World</strong> example, you can start examining how FastAPI structures endpoints. In this context, an endpoint specifies the following details:</p>
			<ul class="calibre14">
				<li class="calibre17">A unique combination of a URL: This will be the same in your development server—<code>localhost:8000</code>.</li>
				<li class="calibre17">A path: The part after the slash.</li>
				<li class="calibre17">An HTTP method.</li>
			</ul>
			<p class="calibre5">In a new folder named <code>Chapter4</code>, for example, create a new Python file named <code>chapter4_01.py</code> by using Visual Studio Code:</p>
			<pre class="source-code">
from fastapi import FastAPI
app = FastAPI()
@app.get("/")
async def root():
    return {"message": "Hello FastAPI"}</pre>			<p class="calibre5">With this code, you can accomplish several things. Here’s a breakdown of what each part does:</p>
			<ul class="calibre14">
				<li class="calibre17">In the first line of <code>chapter4_01.py</code>, you imported the FastAPI class from the <code>fastapi</code> package.</li>
				<li class="calibre17">Next, you instantiated an application object. This is just a Python class with all the API functionalities that exposes an ASGI-compatible application, which must be passed to Uvicorn.</li>
			</ul>
			<p class="calibre5">Now, the application is ready and instantiated. But without endpoints, it can’t do or say much. It has one endpoint, the root, which you can view at <code>http://127.0.0.1:8000/</code>. FastAPI exposes decorators for HTTP methods to tell the application how and whether to respond. However, you must implement them.</p>
			<p class="calibre5">After that, you used the <code>@get</code> decorator, which corresponds to the <code>GET</code> method, and passed a URL—in this case, the root path, <code>/</code>, is used.</p>
			<p class="calibre5">The decorated function, named <code>root</code>, is responsible for responding to requests. It accepts any arguments (in this case, there aren’t any). The value returned by the function, typically a Python dictionary, will be transformed into a <strong class="bold">JavaScript Object Notation</strong> (<strong class="bold">JSON</strong>) response by the ASGI server and returned as an HTTP response. This may seem obvious, but it is useful to break things down to understand the fundamentals.</p>
			<p class="calibre5">The preceding code defines a fully functional application with a single endpoint. To test it, you need a Uvicorn server. Now, you must run the live server with Uvicorn in your command line:</p>
			<pre class="source-code">
uvicorn chapter4_01:app --reload</pre>			<p class="calibre5">You will use this code snippet quite often when developing with FastAPI, so the following note will break it down.</p>
			<p class="callout-heading">Note</p>
			<p class="callout">Uvicorn is your ASGI-compatible web server. You can call it directly by passing it the combination of the executable Python file (without the extension) and the instantiated app (the FastAPI instance), separated by a colon (<code>:</code>). The <code>--reload</code> flag instructs Uvicorn to reload the server each time you save your code, similar to <em class="italic">Nodemon</em> in Node.js. Unless specified otherwise, you can run all the examples in this book containing FastAPI apps using this syntax.</p>
			<p class="calibre5">Here’s the output when testing your only endpoint with HTTPie. Remember, when you omit the keyword for the method, it defaults to a <code>GET</code> request:</p>
			<pre class="source-code">
(venv) http http://localhost:8000/
HTTP/1.1 200 OK
content-length: 27
content-type: application/json date: Fri, 01 Apr 2022 17:35:48 GMT
server: uvicorn
{
  "message": "Hello FastAPI"
}</pre>			<p class="calibre5">HTTPie informs you that your simple endpoint is running. You will get a <code>200 OK</code> status code, the <code>content-type</code> is correctly set to <code>application/json</code>, and the response is a JSON object containing the desired message.</p>
			<p class="calibre5">Every REST API guide begins with similar <em class="italic">hello world</em> examples, but with FastAPI, this is particularly useful. With a couple of lines of code, you can see the anatomy of a simple endpoint. This endpoint only covers the <code>GET</code> method directed toward the root URL (<code>/</code>). So, if you try to test this app with a <code>POST</code> request, you should get a <code>405 Method Not Allowed</code> error (or any method other than <code>GET</code>).</p>
			<p class="calibre5">If you want to create an endpoint that responds with the same message but for <code>POST</code> requests, you will just have to change the decorator. Add the following code to the end of your file (<code>chapter4_01.py</code>):</p>
			<pre class="source-code">
@app.<strong class="bold">post</strong>("/")
async def post_root():
    return {"message": "Post request success!"}</pre>			<p class="calibre5">HTTPie will respond accordingly in the terminal:</p>
			<pre class="source-code">
(venv) http POST http://localhost:8000 HTTP/1.1 200 OK
content-length: 35
content-type: application/json date: Sat, 26 Mar 2022 12:49:25 GMT
server: uvicorn
{
    "message": "Post request success!"
}</pre>			<p class="calibre5">Now that you’ve created a couple of endpoints, head over to <code>http://localhost:8000/docs</code> and see what FastAPI has generated for you.</p>
			<h2 id="_idParaDest-79" class="about-the-author"><a id="_idTextAnchor085" class="calibre7 pcalibre3 pcalibre pcalibre4 pcalibre1 pcalibre2"/>Automatic documentation</h2>
			<p class="calibre5">When developing REST APIs, you will find yourself needing to constantly perform API calls—<code>GET</code> and <code>POST</code> requests—analyze the responses, set payloads and headers, and so on. Choosing a viable REST client is largely a matter of preference and is something that should be carefully considered. While there are numerous clients on the market— ranging from full-blown API IDEs such as Postman (<a href="https://www.postman.com/" class="calibre7 pcalibre3 pcalibre pcalibre4 pcalibre1 pcalibre2">https://www.postman.com/</a>) to the slightly more lightweight Insomnia (<a href="https://insomnia.rest/" class="calibre7 pcalibre3 pcalibre pcalibre4 pcalibre1 pcalibre2">https://insomnia.rest/</a>) or Visual Studio Code’s REST Client (<a href="https://marketplace.visualstudio.com/items?itemName=humao.rest-client" class="calibre7 pcalibre3 pcalibre pcalibre4 pcalibre1 pcalibre2">https://marketplace.visualstudio.com/items?itemName=humao.rest-client</a>)—this book mostly uses the very simple command-line based HTTPie client, which exposes a minimalistic command-line interface. </p>
			<p class="calibre5">This, however, is the right moment to introduce another of FastAPI’s most beloved features—interactive documentation—a tool that facilitates the development process of REST APIs in FastAPI.</p>
			<p class="calibre5">With each endpoint or router that you develop, FastAPI creates automatically generated documentation. It is interactive, allowing you to test your API as you develop it. FastAPI lists all the endpoints you define and provides information about expected inputs and responses. The documentation is based on the OpenAPI specification and relies heavily on Python hints and the Pydantic library. It allows setting the JSON or form data to be sent to the endpoints, displays responses or errors, is tightly coupled with Pydantic, and is able to handle simple authorization procedures such as the bearer token flow that will be implemented in <a href="B22406_06.xhtml#_idTextAnchor105" class="calibre7 pcalibre3 pcalibre pcalibre4 pcalibre1 pcalibre2"><em class="italic">Chapter 6</em></a><em class="italic">, Authentication and Authorization</em>. Rather than having to use a REST client, you can just open the documentation, select the desired endpoint to be tested, input the test data conveniently into a standard web page, and hit the <strong class="bold">Submit</strong> button!</p>
			<p class="calibre5">In this section, you created a minimal, yet fully functional API with a single endpoint, giving you insights into the syntax and structure of an app. In the next section, you will learn about the basic elements of a REST API request-response cycle and how you can control every single aspect of the process. Standard REST clients provide a more transferable experience and enable you to compare different APIs, even those that aren’t Python-based.</p>
			<h1 id="_idParaDest-80" class="contributor"><a id="_idTextAnchor086" class="calibre7 pcalibre3 pcalibre pcalibre4 pcalibre1 pcalibre2"/>Building a showcase API</h1>
			<p class="calibre5">REST APIs revolve around HTTP requests and responses, which power the web and are implemented in every web framework using the HTTP protocol. To showcase the capabilities of FastAPI, you will now create simple endpoints that focus on specific parts of code that achieve the desired functionalities. Rather than the usual CRUD operations, the next sections will focus on the process of retrieving and setting request and response elements.</p>
			<h2 id="_idParaDest-81" class="about-the-author"><a id="_idTextAnchor087" class="calibre7 pcalibre3 pcalibre pcalibre4 pcalibre1 pcalibre2"/>Retrieving path and query parameters</h2>
			<p class="calibre5">The first endpoint will be for retrieving a fictional car by its unique ID.</p>
			<ol class="calibre14">
				<li class="calibre15">Create a file called <code>chapter4_02.py</code> and insert the following code:<pre class="source-code">
from fastapi import FastAPI
app = FastAPI()
@app.get("/car/{id}")
async def root(id):
    return {"car_id": id}
car/:id</strong>, while <code>{id}</code> is a standard Python string-formatted dynamic parameter in the sense that it can be anything—a string or a number since you haven’t used any hinting.</pre></li>				<li class="calibre15">Try it out and test the endpoint with an ID equal to <code>1</code>:<pre class="source-code">
(venv) http "http://localhost:8000/car/1"
HTTP/1.1 200 OK
content-length: 14
content-type: application/json date: Mon, 28 Mar 2022 20:31:58 GMT
server: uvicorn
{
    "car_id": "1"
}</pre></li>				<li class="calibre15">You got your JSON response back, but here, <code>1</code> in the response is a string (hint: quotes). You can try this same route with an ID equal to a string:<pre class="source-code">
(venv) http http://localhost:8000/car/billy HTTP/1.1 200 OK
{
    "car_id": "billy"
}</pre><p class="list-inset">FastAPI returns your string, which was provided as part of the dynamic parameter. However, Python’s newer features, such as type hinting, come into play.</p></li>				<li class="calibre15">Returning to your FastAPI route (or endpoint) to make the car ID become an integer, it is enough to hint at the type of the variable parameter. The endpoint will look like this:<pre class="source-code">
@app.get("/carh/{id}")
async def hinted_car_id(id: int):
    return {"car_id": id}</pre></li>			</ol>
			<p class="calibre5">You have given it a new path: <code>/carh/{id}</code> (the <code>h</code> after <code>car</code> means hint). Apart from the function’s name (<code>hinted_car_id</code>), the only difference is in the argument: the semicolon followed by <code>int</code> means that you can expect an integer, but FastAPI takes this very seriously and you can already see how the framework puts the hinting system to good use.</p>
			<p class="calibre5">If you take a look at the interactive documentation at <code>http://localhost:8000/docs</code> and try to insert a string in the <code>id</code> field for the <code>/carh/</code> endpoint, you will get an error.</p>
			<p class="calibre5">Now, try it out in your REST client and test the <code>/carh/</code> route by passing it a string. First, FastAPI sets the status code for you correctly—that is, <code>422 Unprocessable Entity</code>—and in the body of the response, it pointed out what the problem was—the value is not a valid integer. It also informs you of the exact location where the error occurred: in the <code>id</code> path.</p>
			<p class="calibre5">This is a trivial example but imagine that you are sending a complex request with a complicated path, several query strings, and maybe additional information in the header. Using type hinting quickly solves these problems.</p>
			<p class="calibre5">If you try to access the endpoint without specifying any ID, you will get yet another error:</p>
			<pre class="source-code">
(venv) http http://localhost:8000/carh/ HTTP/1.1 404 Not Found
{
    "detail": "Not Found"
}</pre>			<p class="calibre5">FastAPI has, again, correctly set the status code, giving you a <code>404 Not Found</code> error, and repeated this message in the body. The endpoint you hit does not exist; you must specify a value after the slash.</p>
			<p class="calibre5">Situations may arise where you have similar paths: both dynamic and static. A typical case is an application that has numerous users. Directing the API at the URL defined by <code>/users/id</code> would give you some information about the user with the selected ID, while <code>/users/me</code> would typically be an endpoint that displays your information and allows you to modify it, in some way.</p>
			<p class="calibre5">In these situations, it is important to remember that, like in other web frameworks, order matters. Because of said order of path handler declarations, the following piece of code will not yield the desired results as the application will try to match the <code>/me</code> route with the first endpoint that it encounters—the one that requires an ID—and since the <code>/me</code> part is not a valid ID, you will get an error.</p>
			<p class="calibre5">Create a new file called <code>chapter4_03.py</code> and paste the following code:</p>
			<pre class="source-code">
from fastapi import FastAPI
app = FastAPI()
@app.get("/user/{id}")
async def user(id: int):
    return {"User_id": <a href="mailto:id%7d@app.get(%22/user/me%22)" class="calibre7 pcalibre3 pcalibre pcalibre4 pcalibre1 pcalibre2">id}</a>
@app.get("/user/me")
async def me_user():
    return {"User_id": "This is me!"}</pre>			<p class="calibre5">When you run the application and test the <code>/user/me</code> endpoint, you will get a <code>422 Unprocessable Entity</code> error, like previously. This is quite logical once you remember that order matters—FastAPI finds the first matching URL, checks the types, and throws an error. If the first match is the one with the fixed path, everything works as intended. Just change the order of the two routes and everything will work as expected.</p>
			<p class="calibre5">Another powerful feature of the path treatment of FastAPI is how it limits the path to a specific set of values and a path function, imported from FastAPI, which enables you to perform additional validation on the path.</p>
			<p class="calibre5">Suppose you want to have a URL path that accepts two values and allows the following:</p>
			<ul class="calibre14">
				<li class="calibre17"><code>account_type</code>: This can be <code>free</code> or <code>pro</code>.</li>
				<li class="calibre17"><code>months</code>: This must be an integer between 3 and 12.</li>
			</ul>
			<p class="calibre5">FastAPI solves this by letting you create a class based on <code>Enum</code> for the account type. This class defines all the possible values for the account variable. In this case, there are just two—<code>free</code> and <code>pro</code>. Create a new file and name it <code>chapter4_04.py</code> and edit it:</p>
			<pre class="source-code">
from enum import Enum
from fastapi import FastAPI, Path
app = FastAPI()
class AccountType(str, Enum):
    FREE = "free"
    PRO = "pro"</pre>			<p class="calibre5">Finally, in the actual endpoint, you can combine this class with the utilities from the <code>Path</code> function (do not forget to import it along with FastAPI from <code>fastapi</code>). Paste the following code at the end of the file:</p>
			<pre class="source-code">
@app.get("/account/{acc_type}/{months}")
async def account(acc_type: AccountType, months: int = Path(..., ge=3, le=12)):
    return {"message": "Account created", "account_type": acc_type, "months": months}</pre>			<p class="calibre5">In the preceding code, FastAPI sets the type of the <code>acc_type</code> part of the path to your previously defined class and ensures that only the <code>free</code> or <code>pro</code> value can be passed. The <code>months</code> variable, however, is handled by the <code>Path</code> utility function. When you try to hit this endpoint, <code>account_type</code> will show that there are only two values available, while the actual value of the enumeration can be accessed through the <code>.</code><code>value</code> syntax.</p>
			<p class="calibre5">FastAPI allows you to declare path parameters using standard Python types. If no type is declared, FastAPI will assume that you’re working with strings.</p>
			<p class="calibre5">For more details on these topics, you can visit the excellent documentation site and see what other options are available (https://fastapi.tiangolo.com/tutorial/path-params/). In this case, the <code>Path</code> function received three parameters. The three dots mean that the value is required and that no default value has been provided, <code>ge=3</code> means that the value can be greater than or equal to <code>3</code>, while <code>le=12</code> means that it can be smaller than or equal to <code>12</code>. This syntax allows you to define validation right inside the path functions quickly.</p>
			<h3 class="calibre8">Query parameters</h3>
			<p class="calibre5">Now that you’ve learned how to validate, restrict, and properly order your path parameters and endpoints, it’s time to look at <strong class="bold">query parameters</strong>. These parameters are a simple mechanism of passing data to a server through the URL and they are represented as key-value pairs, separated by an equals sign (=). You can have multiple pairs of keys and values separated by an ampersand (&amp;).</p>
			<p class="calibre5">Query parameters are added at the end of the URL by using the question mark/equals notation: <code>?</code><code>min_ price=2000&amp;max_price=4000</code>.</p>
			<p class="calibre5">The question mark, <code>?</code>, is a separator that tells you where the query string begins, while the ampersand, <code>&amp;</code>, allows you to add more than one (the equals sign, <code>=</code>) assignment.</p>
			<p class="calibre5">Query parameters are usually used to apply filters, sort, order, or limit query sets, paginate a long list of results, and similar tasks. FastAPI treats them very similarly to path parameters as it automatically picks them up and makes them available for processing in your endpoint functions.</p>
			<ol class="calibre14">
				<li class="calibre15">Create a simple endpoint that accepts two query parameters for the minimum and maximum prices of the car, and name it <code>chapter4_05.py</code>:<pre class="source-code">
from fastapi import FastAPI
app = FastAPI()
@app.get("/cars/price")
async def cars_by_price(min_price: int = 0, max_price: int = 100000):
    return {"Message": f"Listing cars with prices between {min_price} and {max_price}"}</pre></li>				<li class="calibre15">Test this endpoint with HTTPie:<pre class="source-code">
(venv) http "http://localhost:8000/cars/price?min_price=2000&amp;max_price=4000"
HTTP/1.1 200 OK
content-length: 60
content-type: application/json date: Mon, 28 Mar 2022 21:20:24 GMT
server: uvicorn
{
"Message": "Listing cars with prices between 2000 and 4000"
}</pre></li>			</ol>
			<p class="calibre5">In this solution, you can’t ensure the basic condition that the minimum price should be lower than the maximum price. This is handled by the object-level validation of Pydantic.</p>
			<p class="calibre5">FastAPI picks your query parameters and performs the same parsing and validation checks it did previously. It provides the <code>Query</code> function, like the <code>Path</code> function. You can use the <em class="italic">greater than</em>, <em class="italic">less than</em>, or <em class="italic">equal</em> conditions, as well as set default values. They can also be set to default to <code>None</code>. Query parameters will be converted into Boolean values as needed. You can write rather complex combinations of path and query parameters, as FastAPI can distinguish between them and handle them inside the function.</p>
			<p class="calibre5">With that, you’ve seen how FastAPI enables working with data that is passed through the path and query parameters, as well as the tools it uses under the hood to perform parsing and validation as soon as possible. Now, you will examine the main data vehicle of REST APIs: the <strong class="bold">request body</strong>.</p>
			<h3 class="calibre8">The request body—the bulk of the data</h3>
			<p class="calibre5">REST APIs enable two-way communication between a client—a web browser or a mobile application and an API server. The bulk of this data is carried over in the request and response body. A request body has data sent from the client to your API, while the response body is data sent from the API server to the client(s).</p>
			<p class="calibre5">This data can be encoded in various ways, but many users prefer to encode data with JSON since it is exceptionally nice with our database solution of choice, MongoDB—which operates with BSON, a close relative to JSON.</p>
			<p class="calibre5">When modifying data on the server, you should always use:</p>
			<ul class="calibre14">
				<li class="calibre17"><code>POST</code> requests: To create new resources</li>
				<li class="calibre17"><code>PUT</code> and <code>PATCH</code>: To update resources</li>
				<li class="calibre17"><code>DELETE</code>: To delete resources</li>
			</ul>
			<p class="calibre5">Since the body of a request will contain raw data—in this case, MongoDB documents or arrays of documents—you can use Pydantic models. But first, see how the mechanism works, without any validation or modeling. In HTTP terminology, the <code>GET</code> method should be <em class="italic">idempotent</em>, meaning it should always return the same value for the same set of parameters. </p>
			<p class="calibre5">In the following code for a hypothetical endpoint used to insert new cars in your future database, you can pass the generic request body as the data. It can be a dictionary without entering into the specifics of how that dictionary should be shaped. Create a new file called <code>chapter4_06.py</code> and paste the following code:</p>
			<pre class="source-code">
from typing import Dict
from fastapi import FastAPI, Body
app = FastAPI()
@app.post("/cars")
async def new_car(data: Dict = Body(...)):
    print(data)
    return {"message": data}</pre>			<p class="calibre5">Intuitively, the <code>Body</code> function is similar to the previously introduced <code>Path</code> and <code>Query</code> functions. Yet the difference is, when working with the request body, this function is mandatory.</p>
			<p class="calibre5">The three dots indicate that the body is required (you must send something), but this is the only requirement. Try to insert a car (a Fiat 500, made in 2015):</p>
			<pre class="source-code">
(venv) http POST "http://localhost:8000/cars" brand="FIAT" model="500" year=2015
HTTP/1.1 200 OK
content-length: 56
content-type: application/json date: Mon, 28 Mar 2022 21:27:31 GMT
server: uvicorn
{
  "message": {
  "brand": "FIAT",
  "model": "500",
  "year": "2015"
}</pre>			<p class="calibre5">FastAPI does the heavy lifting. You can retrieve all the data passed to the request body and make it available to your function for further processing – database insertion, optional preprocessing, and so on.</p>
			<p class="calibre5">On the other hand, you could have passed any key-value pairs to the body. Of course, this is just an illustration of the general mechanism—in reality, Pydantic will be your data guardian, ensuring you only let the right data in.</p>
			<p class="calibre5">While all went well, FastAPI sends you a <code>200 response</code> status again, even though a <code>201 Resource Created</code> error is more appropriate and exact. You could, for instance, have some document inserted into MongoDB at the end of the function and a <code>201 CREATED</code> status message would be appropriate. You will see how easy it is to modify the response body as well, but for now, you will be able to see why Pydantic shines when it comes to request bodies.</p>
			<p class="calibre5">To create new car entries, you would only need the <code>brand</code>, <code>model</code>, and production <code>year</code> fields.</p>
			<p class="calibre5">So, create a simple Pydantic model with the desired types in the <code>chapter4_07.py</code> file:</p>
			<pre class="source-code">
from fastapi import FastAPI, Body
from pydantic import BaseModel
class InsertCar(BaseModel):
    brand: str
    model: str
    year: int
app = FastAPI()
@app.post("/cars")
async def new_car(data: InsertCar):
    print(data)
    return {"message": data}</pre>			<p class="calibre5">By now, you know that the first two parameters are expected to be strings, while the year must be an integer; all of them are required.</p>
			<p class="calibre5">Now, if you try to post the same data that you did previously but with additional fields, you will only get these three fields back. Also, these fields will go through Pydantic parsing and validation and throw meaningful error messages if something does not conform to the data specification.</p>
			<p class="calibre5">This combination of Pydantic model validation and the <code>Body</code> function provides all the necessary flexibility when working with request data. This is because you can combine them and pass different bits of information using the same request bus ride.</p>
			<p class="calibre5">If you want to pass a promo code attached to a user, along with the new car data, you could try defining a Pydantic model for the user and extracting the promo code with the <code>Body</code> function. First, define a minimal user model in a new file and name it <code>chapter4_08.py</code>:</p>
			<pre class="source-code">
class UserModel(BaseModel):
    username: str
    name: str</pre>			<p class="calibre5">Now, create a more complex function that will process two Pydantic models and an optional user promo code – set the default value to <code>None</code>:</p>
			<pre class="source-code">
@app.post("/car/user")
async def new_car_model(car: InsertCar, user: UserModel, code: int = Body(None)):
    return {"car": car, "user": user, "code": code}</pre>			<p class="calibre5">For this request, which contains a full-fledged JSON object with two nested objects and some code, you might opt to use Insomnia or a similar GUI client since it’s easier than typing JSON in the command prompt or resorting to piping. While it is largely a matter of preference, when developing and testing REST APIs, it is useful to have a GUI tool such as Insomnia or Postman and a command-line client (such as cURL or HTTPie).</p>
			<p class="calibre5">The <code>Body</code> class constructor’s parameters are very similar to the <code>Path</code> and <code>Query</code> constructors, and since they will often be much more complex, it is useful to try and tame them with Pydantic. Parsing, validation, and meaningful error messages – Pydantic provides us with the whole package before allowing the request body data to make it to the real data processing functionality. The <code>POST</code> requests are almost exclusively fed an appropriate Pydantic model as a parameter.</p>
			<p class="calibre5">After playing around with the combination of request bodies and Pydantic models, you have seen that you can control the inflow of the data and be confident that the data that’s available to your API endpoint will be what you want and expect it to be. Sometimes, however, you may want to go to the bare metal, and work with the raw request object. FastAPI covers that case too, as is discussed in the next section.</p>
			<h3 class="calibre8">The request object</h3>
			<p class="calibre5">FastAPI is built on the Starlette web framework. The raw request object in FastAPI is Starlette’s request object and it can be accessed in your functions once it’s been imported from FastAPI directly. By using the request object directly, you are missing out on FastAPI’s most important features: Pydantic’s parsing and validation and self-documentation! However, there might be situations in which you need to have the raw request.</p>
			<p class="calibre5">Look at the following example in the <code>chapter4_09.py</code> file:</p>
			<pre class="source-code">
from fastapi import FastAPI, Request
app = FastAPI()
@app.get("/cars")
async def raw_request(request: Request):
    return {"message": request.base_url, "all": dir(request)}</pre>			<p class="calibre5">In the preceding code, you created a minimal FastAPI app, imported the <code>Request</code> class, and used it in the endpoint. If you test this endpoint with your <code>REST</code> client, you will only get the base URL as the message, while the <code>all</code> part lists all the methods and properties of the <code>Request</code> object so that you have an idea of what is available.</p>
			<p class="calibre5">All of these methods and properties are available for you to use in your application.</p>
			<p class="calibre5">With that, you’ve seen how FastAPI facilitates your work with the main HTTP transport mechanisms—request bodies, query strings, and paths. Next, you’ll explore equally important aspects of any web framework solution—cookies, headers, form data, and files.</p>
			<h3 class="calibre8">Cookies and headers, form data, and files</h3>
			<p class="calibre5">Speaking of the ways the web framework ingests data, topics such as handling form data, handling files, and manipulating cookies and headers must be included. This section will provide simple examples of how FastAPI handles these tasks.</p>
			<h4 class="calibre37">Headers</h4>
			<p class="calibre5">Header parameters are handled in a similar way to query and path parameters and, as you’ll see later, cookies. You can collect them, so to speak, using the <code>Header</code> function. Headers are essential in topics such as authentication and authorization as they often carry <strong class="bold">JSON Web Tokens</strong> (<strong class="bold">JWTs</strong>), which are used for identifying users and their permissions.</p>
			<p class="calibre5">Try to read the user agent by using the <code>Header</code> function in a new file called <code>chapter4_10.py</code>:</p>
			<pre class="source-code">
from typing import Annotated
from fastapi import FastAPI, Header
app = FastAPI()
@app.get("/headers")
async def read_headers(user_agent: Annotated[str | None, Header()] = None):
    return {"User-Agent": user_agent}</pre>			<p class="calibre5">Depending on the software you use to execute the test for the endpoint, you’ll get different results. Here’s an example of using HTTPie:</p>
			<pre class="source-code">
(venv) http GET "http://localhost:8000/headers"
HTTP/1.1 200 OK
content-length: 29
content-type: application/json date: Sun, 27 Mar 2022 09:26:49 GMT
server: uvicorn
{
"User-Agent": "HTTPie/3.2.2"
}</pre>			<p class="calibre5">You can extract all the headers in this way and FastAPI will provide further assistance—it will convert names into lowercase, convert the keys into snake case, and so on.</p>
			<h4 class="calibre37">Cookies</h4>
			<p class="calibre5">Cookies work similarly, although they can be extracted manually from the <code>Cookies</code> header. The framework offers a utility function, conveniently named <code>Cookie</code>, that does all the work in a way similar to <code>Query</code>, <code>Path</code>, and <code>Header</code>.</p>
			<h4 class="calibre37">Forms (and files)</h4>
			<p class="calibre5">So far, you’ve only dealt with JSON data. It is the ubiquitous language of the web and your main vehicle for moving data back and forth. There are cases, however, that require a different data encoding – forms might be processed directly by your API, with data encoded as <code>multipart</code>/<code>form-data</code> or <code>form-urlencoded</code>. Since the arrival of modern React Server Actions, form data has become more popular in frontend development too.</p>
			<p class="callout-heading">Note</p>
			<p class="callout">Although you can have multiple Form parameters in a path operation, you cannot declare the <code>Body</code> fields expected in JSON. The HTTP request will have the body encoded using only <code>application/x-www-form-urlencoded instead of application/json</code>. This limitation is part of the HTTP protocol and is not specific to FastAPI.</p>
			<p class="calibre5">The simplest way to cover both form cases—with and without including files for upload—is to start by installing <code>python-multipart</code>, a streaming multipart parser for Python. For this, you must stop your server and use <code>pip</code> to install it:</p>
			<pre class="console">
pip install python-multipart==0.0.9</pre>			<p class="calibre5">The <code>Form</code> function works similarly to the previously examined utility functions, but with the difference that it looks for form-encoded parameters. For simple fields, data is usually encoded using the media type (<code>application/x-www-form-urlencoded</code>), while if files are included, the encoding corresponds to <code>mutlipart/form-data</code>.</p>
			<p class="calibre5">Look at a simple example in which you wish to upload an image and a couple of form fields, such as the brand and the model.</p>
			<p class="calibre5">You will use a photo that can be found on Pexels (<a href="https://www.pexels.com/photo/white-vintage-car-parked-on-green-grass-8746027/" class="calibre7 pcalibre3 pcalibre pcalibre4 pcalibre1 pcalibre2">https://www.pexels.com/photo/white-</a>), renamed to <code>car.jpeg</code> and saved in the current directory.</p>
			<p class="calibre5">Create a file named <code>chapter4_11.py</code> and paste the following code:</p>
			<pre class="source-code">
from fastapi import FastAPI, Form, File, UploadFile
app = FastAPI()
@app.post("/upload")
async def upload(
    file: UploadFile = File(...), brand: str = Form(...), model: str = Form(...)
):
    return {"brand": brand, "model": model, "file_name": file.filename}</pre>			<p class="calibre5">The preceding code handles the form parameters via the <code>Form</code> function and the uploaded file by using the <code>UploadFile</code> utility class.</p>
			<p class="calibre5">The photo, however, isn’t saved on the disk—its presence is merely acknowledged, and the filename is returned. Testing this endpoint, that has a file upload, in HTTPie looks like this:</p>
			<pre class="source-code">
http -f POST localhost:8000/upload  brand='Ferrari' model='Testarossa'  <a href="mailto:file@car.jpeg" class="calibre7 pcalibre3 pcalibre pcalibre4 pcalibre1 pcalibre2">file@car.jpeg</a></pre>			<p class="calibre5">The preceding HTTPie call returns the following output:</p>
			<pre class="source-code">
HTTP/1.1 200 OK
content-length: 63
content-type: application/json
date: Fri, 22 Mar 2024 11:01:38 GMT
server: uvicorn
{
    "brand": "Ferrari",
    "file_name": "car.jpeg",
    "model": "Testarossa"
}</pre>			<p class="calibre5">To save the image to a disk, you must copy the buffer to an actual file on the disk. The following code achieves this (<code>chapter4_12.py</code>):</p>
			<pre class="source-code">
import shutil
from fastapi import FastAPI, Form, File, UploadFile
app = FastAPI()
@app.post("/upload")
async def upload(
    picture: UploadFile = File(...),
    brand: str = Form(...),
    model: str = Form(...)
):
    with open("saved_file.png", "wb") as buffer:
        shutil.copyfileobj(picture.file, buffer)
    return {"brand": brand, "model": model, "file_name": picture.filename}</pre>			<p class="calibre5">The <code>open</code> block opens a file on the disk using a specified filename and copies the FastAPI file that’s sent through the form. You will have hardcoded the filename, so any new upload will simply overwrite the existing file, but you could use some randomly generated filename while using the <strong class="bold">universally unique identifier</strong> (<strong class="bold">UUID</strong>) library, for example.</p>
			<p class="calibre5">File uploading is an operation that can be achieved in different ways—file uploads can be also handled by the Python <code>async</code> file library known as <code>aiofiles</code> or as a background task, which is another feature of FastAPI, as will be shown later in <a href="B22406_05.xhtml#_idTextAnchor090" class="calibre7 pcalibre3 pcalibre pcalibre4 pcalibre1 pcalibre2"><em class="italic">Chapter 5</em></a>, <em class="italic">Setting Up a </em><em class="italic">React Workflow</em>.</p>
			<h2 id="_idParaDest-82" class="about-the-author"><a id="_idTextAnchor088" class="calibre7 pcalibre3 pcalibre pcalibre4 pcalibre1 pcalibre2"/>FastAPI response customization</h2>
			<p class="calibre5">The previous sections discussed numerous examples of FastAPI requests how you can reach every corner of the request—the path, the query string, the request body, headers, and cookies—and how to work with form-encoded requests.</p>
			<p class="calibre5">Now, let’s take a closer look at FastAPI’s response objects. In all previous cases, you returned a Python dictionary that was serialized into JSON by FastAPI. The framework enables customizations to the response.</p>
			<p class="calibre5">The first thing you might want to change in an HTTP response is the status code, for instance to  provide some meaningful errors when things do not go as planned. FastAPI conveniently raises classic Python exceptions when HTTP errors are present. It also uses standard-compliant meaningful response codes that minimize the need to create custom payload messages. For instance, you don’t want to send a <code>200 OK</code> status code for everything and then notify users of errors by using the payload—FastAPI encourages good practices.</p>
			<h4 class="calibre37">Setting status codes</h4>
			<p class="calibre5">HTTP status codes indicate whether an operation was successful or there was an error. These codes also provide information about the type of operation, and they can be divided into several groups: informational, successful, client errors, server errors, and so on. It isn’t necessary to memorize the status codes, although you probably know what a <code>404</code> or <code>500</code> code is.</p>
			<p class="calibre5">FastAPI makes it incredibly easy to set a status code—it is enough to just pass the desired <code>status_code</code> variable to the decorator. Here, you are using the <code>208 status</code> code for a simple endpoint (<code>chapter4_13.py</code>):</p>
			<pre class="source-code">
from fastapi import FastAPI, status
app = FastAPI()
@app.get("/", status_code=status.HTTP_208_ALREADY_REPORTED)
async def raw_fa_response():
    return {"message": "fastapi response"}</pre>			<p class="calibre5">Testing the root route in HTTPie yields the following output:</p>
			<pre class="source-code">
(venv) http GET "http://localhost:8000"
HTTP/1.1 <strong class="bold">208 Already Reported</strong> content-length: 30
content-type: application/json date: Sun, 27 Mar 2022 20:14:25 GMT
server: uvicorn
{
    "message": "fastapi response"
}</pre>			<p class="calibre5">Similarly, you can set status codes for the <code>delete</code>, <code>update</code>, and <code>create</code> operations.</p>
			<p class="calibre5">FastAPI sets the <code>200 status</code> code by default if it doesn’t encounter exceptions, so it is up to you to set the correct codes for the various API operations, such as <code>204 No Content</code> for deleting and <code>201</code> for creating. This is a good practice that is particularly encouraged.</p>
			<p class="calibre5">Pydantic can be used for response modeling. You can limit or modify the fields that should appear in the response and perform similar checks that it does for the request body by using the <code>response_model</code> argument.</p>
			<p class="calibre5">FastAPI does not enable customizing the response, but modifying and setting headers and cookies is as simple as reading them from the HTTP request and the framework has you covered.</p>
			<p class="calibre5">Although beyond the scope of this book, it is worth noting that JSON is by no means the only response that FastAPI can provide: you can output an <code>HTMLResponse</code> and use classic Flask-like Jinja templates, <code>StreamingResponse</code>, <code>FileResponse</code>, <code>RedirectResponse</code>, and so on.</p>
			<h4 class="calibre37">HTTP errors</h4>
			<p class="calibre5">Errors are bound to happen. For example, users somehow find a way to send the wrong parameters to a query, the frontend sends the wrong request body, or the database goes offline (although this is unlikely with MongoDB)—anything can happen. It is crucial to detect these errors as soon as possible (this is a leitmotiv in FastAPI) and send clear and complete messages to the frontend, as well as the user by raising exceptions.</p>
			<p class="calibre5">FastAPI relies on web standards and enforces good practices in every facet of the development process, so it puts a lot of emphasis on using HTTP status codes. These codes provide a clear indication of the type of problem that has arisen, while the payload can be used to further clarify the cause of the problem.</p>
			<p class="calibre5">FastAPI uses a Python exception, aptly called <code>HTTPException</code>, to raise HTTP errors. This class allows you to set a status code and set an error message.</p>
			<p class="calibre5">Returning to the example of inserting new cars into the database, you could set a custom exception like the following (<code>chapter4_14.py</code>):</p>
			<pre class="source-code">
from pydantic import BaseModel
from fastapi import Fastapi, HTTPException, status
app = FastAPI()
class InsertCar(BaseModel):
    brand: str
    model: str
    year: int
@app.post("/carsmodel")
async def new_car_model(car: InsertCar):
    if car.year &gt; 2022:
        <strong class="bold">raise HTTPException(</strong>
            <strong class="bold">status.HTTP_406_NOT_ACCEPTABLE, detail="The car doesn't exist yet!"</strong>
        )
    return {"message": car}</pre>			<p class="calibre5">When trying to insert a car that hasn’t been built yet, the response is as follows:</p>
			<pre class="source-code">
(venv) λ http POST http://localhost:8000/carsmodel brand="fiat" mode3
l="500L" year=2023
HTTP/1.1 406 Not Acceptable content-length: 39
content-type: application/json date: Tue, 29 Mar 2022 18:37:42 GMT
server: uvicorn
{
    "detail": "The car doesn't exist yet!"
}</pre>			<p class="calibre5">This is a pretty contrived example of making custom exceptions for a possible problem that might arise. However, this gives a good idea of what is possible and the flexibility that FastAPI gives you.</p>
			<h4 class="calibre37">Dependency injection</h4>
			<p class="calibre5">To make a brief but self-contained introduction to FastAPI, the system of dependency injection must be mentioned. In broad terms, <strong class="bold">dependency injection</strong> (<strong class="bold">DI</strong>) is a way of providing necessary functionalities (classes, functions, database connections, authorization statuses and so on) to a path operation function at the right time. FastAPI’s DI system is very useful for sharing logic across endpoints, sharing database connections, for instance, as you will see when you connect to your MongoDB Atlas instance—performing security and authentication checks, and so on.</p>
			<p class="calibre5">Dependencies aren’t special; they are just normal functions that can take the same arguments as path operations. In fact, the official documentation compares them to path operations without the decorator. Dependencies are used a bit differently, though. They are given a single parameter (typically a callable) and they are not called directly; they are just passed as a parameter to <code>Depends()</code>.</p>
			<p class="calibre5">An example inspired by the official FastAPI documentation is the following; you can use a pagination dependency and use it in different resources (<code>chapter4_15.py</code>):</p>
			<pre class="source-code">
from typing import Annotated
from fastapi import Depends, FastAPI
app = FastAPI()
async def pagination(q: str | None = None, skip: int = 0, limit: int = 100):
    return {"q": q, "skip": skip, "limit": limit}
@app.get("/cars/")
async def read_items(commons: Annotated[dict, Depends(pagination)]):
    return commons
@app.get("/users/")
async def read_users(commons: Annotated[dict, Depends(pagination)]):
    return commons</pre>			<p class="calibre5">One of the most common cases of DI used in a full stack FastAPI project is authentication; you can use the same authentication logic, that is, some class or function that checks the header for an authorization token and applies it to all the routes or routers that need to require authentication, as you will see in <a href="B22406_06.xhtml#_idTextAnchor105" class="calibre7 pcalibre3 pcalibre pcalibre4 pcalibre1 pcalibre2"><em class="italic">Chapter 6</em></a><em class="italic">, Authentication </em><em class="italic">and Authorization</em>.</p>
			<h4 class="calibre37">Structuring FastAPI applications with routers</h4>
			<p class="calibre5">Although putting all of our <code>request</code>/<code>response</code> logic in one big file is possible, as you start building even a moderately sized project, you will quickly see that this is not feasible, maintainable, or pleasant to work with. FastAPI, like Express.js in the Node.js world, or Flask with its blueprints, provides <code>cars</code>, at the <code>/cars</code> path, another to handle the creation and management of users at <code>/users</code>, and so on. FastAPI proposes a type of project structure that is simple and intuitive enough, yet able to accommodate the most common cases.</p>
			<h3 class="calibre8">API Routers</h3>
			<p class="calibre5">FastAPI provides a class named APIRouter that is used for grouping routes, usually related to the same type of resource (users, shopping items, and so on). This concept, known in Flask as <strong class="bold">Blueprints</strong> and present in every modern web framework, allows the code to be more modular and distributed in smaller units, with each router managing only a certain type of resource. These APIRouters are finally included in the main FastAPI instance and provide very similar functionality.</p>
			<p class="calibre5">Instead of applying the path decorators (<code>@get</code>, <code>@post</code> and so on) directly on the main application instance (usually called app), they are applied to the APIRouter instance. Below is a simple example of an application broken into two APIRouters:</p>
			<ol class="calibre14">
				<li class="calibre15">First, create a <code>chapter4_16.py</code> file that will host the main FastAPI instance:<pre class="source-code">
from fastapi import FastAPI
from routers.cars import router as cars_router
from routers.user import router as users_router
app = FastAPI()
app.include_router(cars_router, prefix="/cars", tags=["cars"])
app.include_router(users_router, prefix="/users", tags=["users"])</pre></li>				<li class="calibre15">Now, create a new folder named <code>/routers</code>, and in this folder, create an APIRouter in a file named <code>users.py</code>:<pre class="source-code">
from fastapi import APIRouter
router = APIRouter()
@router.get("/")
async def get_users():
    return {"message": "All users here"}</pre></li>				<li class="calibre15">Create another file, in the same <code>/routers</code> directory, named <code>cars.py</code>:<pre class="source-code">
from fastapi import APIRouter
router = APIRouter()
@router.get("/")
async def get_cars():
    return {"message": "All cars here"}</pre></li>			</ol>
			<p class="calibre5">When connecting the routers to the main application, in the <code>chapter4_17.py</code> file, you are able to provide different optional arguments to the APIRouter—tags and a set of dependencies, such as an authentication requirement. The prefix, however, is mandatory, as the application needs to know at which URL to mount the APIRouter.</p>
			<p class="calibre5">If you test this application with Uvicorn with the following command:</p>
			<pre class="source-code">
uvicorn chapter4_17:app</pre>			<p class="calibre5">And then, head over to the automatically generated documentation, you will see that the two APIRouters are mounted just as if you defined two separate endpoints. They are, however, grouped under the respective tags, for easier navigation and testing.</p>
			<p class="calibre5">If you now navigate to the documentation, you should indeed find just one route defined at <code>/cars</code> and responding only to <code>GET</code> requests. It is intuitive that this procedure can have you build parallel or same-level routers in no time, but one of the biggest benefits of using APIRouters is that they support nesting, which enables managing quite complex hierarchies of endpoints effortlessly!</p>
			<p class="calibre5">Routers are subsystems of an application and are not meant to be used autonomously, although you are free to mount entire separate FastAPI applications under specific paths, but that is beyond the scope of this book.</p>
			<h4 class="calibre37">Middleware</h4>
			<p class="calibre5">FastAPI implements the concept of <code>request</code>/<code>response</code> cycle, intercepting the request, manipulating it in some desired way, then taking the response before it is sent to the browser or client, performing additional manipulation if needed, and finally, returning the final response.</p>
			<p class="calibre5">Middleware is based on the ASGI specification, and it is implemented in Starlette, so FastAPI enables using it in all your routes and optionally tying it to a part of an application (via APIRouter) or the entire app.</p>
			<p class="calibre5">Similarly to the mentioned frameworks, the FastAPI middleware is just a function that receives the request and a <code>call_next</code> function. Create a new file named <code>chapter4_17.py</code>:</p>
			<pre class="source-code">
from fastapi import FastAPI, Request
from random import randint
app = FastAPI()
@app.middleware("http")
async def add_random_header(request: Request, call_next):
    number = randint(1,10)
    response = await call_next(request)
    response.headers["X-Random-Integer "] = str(number)
    return response
@app.get("/")
async def root():
    return {"message": "Hello World"}</pre>			<p class="calibre5">If you now start this small application, and test the only route, the route at <a href="http://127.0.0.1:8000/" class="calibre7 pcalibre3 pcalibre pcalibre4 pcalibre1 pcalibre2"><code>http://127.0.0.1:8000/</code></a>, you will notice that the returned headers contain an integer between 1 and 10, and on every request this integer will be different.</p>
			<p class="calibre5">Middleware plays a large role in authentication with <strong class="bold">cross-origin resource sharing</strong> (<strong class="bold">CORS</strong>), something you’re bound to face when developing full stack applications, but also for redirecting, managing proxies, and so on. It is a very powerful concept that can greatly simplify and enhance your application efficiency.</p>
			<h1 id="_idParaDest-83" class="contributor"><a id="_idTextAnchor089" class="calibre7 pcalibre3 pcalibre pcalibre4 pcalibre1 pcalibre2"/>Summary</h1>
			<p class="calibre5">This chapter covered very simple examples of how FastAPI achieves the most common REST API tasks and the way it can help you by leveraging modern Python features and libraries such as Pydantic.</p>
			<p class="calibre5">This chapter also detailed how FastAPI enables you to perform requests and responses through HTTP and how you can tap into it, at any point, and customize and access the elements of the request, as well as the response. Finally, it also detailed how to split your API into routers and how to organize your app into logical resource-based units.</p>
			<p class="calibre5">The next chapter will give you a quick introduction to React—the user interface library of choice in the FARM stack.</p>
		</div>
	</div>
</div>
</body></html>