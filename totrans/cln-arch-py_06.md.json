["```py\nfrom dataclasses import dataclass, field\nfrom uuid import UUID, uuid4\n@dataclass\nclass Entity:\n    # Automatically generates a unique UUID for the 'id' field;\n    # excluded from the __init__ method\n    id: UUID = field(default_factory=uuid4, init=False)\n    def __eq__(self, other: object) -> bool:\n        if not isinstance(other, type(self)):\n            return NotImplemented\n        return self.id == other.id\n    def __hash__(self) -> int:\n        return hash(self.id) \n```", "```py\nfrom dataclasses import dataclass, field\nfrom typing import Optional\n@dataclass\nclass Task(Entity):\n    title: str\n    description: str\n    due_date: Optional[Deadline] = None\n    priority: Priority = Priority.MEDIUM\n    status: TaskStatus = field(default=TaskStatus.TODO, init=False) \n```", "```py\nfrom enum import Enum\nfrom dataclasses import dataclass\nfrom datetime import datetime, timedelta\nclass TaskStatus(Enum):\n    TODO = \"TODO\"\n    IN_PROGRESS = \"IN_PROGRESS\"\n    DONE = \"DONE\"\nclass Priority(Enum):\n    LOW = 1\n    MEDIUM = 2\n    HIGH = 3\n# frozen=True makes this immutable as it should be for a Value Object\n@dataclass(frozen=True)\nclass Deadline:\n    due_date: datetime\n    def __post_init__(self):\n        if self.due_date < datetime.now(timezone.utc):\n            raise ValueError(\"Deadline cannot be in the past\")\n    def is_overdue(self) -> bool:\n        return datetime.now(timezone.utc) > self.due_date\n    def time_remaining(self) -> timedelta:\n        return max(\n            timedelta(0),\n            self.due_date - datetime.now(timezone.utc)\n        )\n    def is_approaching(\n        self, warning_threshold: timedelta = timedelta(days=1)\n    ) -> bool:\n        return timedelta(0) < self.time_remaining() <= warning_threshold \n```", "```py\n# Create a new task\ntask = Task(\n    title=\"Complete project proposal\",\n    description=\"Draft and review the proposal for the \n                 new client project\",\n    priority=Priority.HIGH\n)\n# Check task properties\nprint(task.title)     # \"Complete project proposal\"\nprint(task.priority)  # Priority.HIGH\nprint(task.status)    # TaskStatus.TODO \n```", "```py\n@dataclass\nclass Task(Entity):\n    # ... previous attributes ...\n    def start(self) -> None:\n        if self.status != TaskStatus.TODO:\n            raise ValueError(\n                \"Only tasks with 'TODO' status can be started\")\n        self.status = TaskStatus.IN_PROGRESS\n    def complete(self) -> None:\n        if self.status == TaskStatus.DONE:\n            raise ValueError(\"Task is already completed\")\n        self.status = TaskStatus.DONE\n    def is_overdue(self) -> bool:\n        return self.due_date is not None and self.due_date.is_overdue() \n```", "```py\nfrom datetime import datetime, timedelta\n# Create a task\ntask = Task(\n    title=\"Complete project proposal\",\n    description=\"Draft and review the proposal for the \n                 new client project\",\n    due_date=Deadline(datetime.now(timezone.utc) + timedelta(days=7)),\n    priority=Priority.HIGH\n)\n# Start the task\ntask.start()\nprint(task.status)  # TaskStatus.IN_PROGRESS\n# Complete the task\ntask.complete()\nprint(task.status)  # TaskStatus.DONE\n# Try to start a completed task\ntry:\n    task.start()  # This will raise a ValueError\nexcept ValueError as e:\n    print(str(e))  # \"Only tasks with 'TODO' status can be started\"\n# Check if the task is overdue\nprint(task.is_overdue())  # False \n```", "```py\n# Using string (problematic)\ntask = Task(\"Complete project\", \"The important project\")\ntask.status = \"Finished\"  # Allowed, but invalid\nprint(task.status == \"done\")  # False, case-sensitive\n# Using TaskStatus enum (robust)\ntask = Task(\"Complete project\", \"The important project\")\ntask.status = TaskStatus.DONE  # Type-safe\nprint(task.status == TaskStatus.DONE)  # True, no case issues \n```", "```py\nclass TaskPriorityCalculator:\n    @staticmethod\n    def calculate_priority(task: Task) -> Priority:\n        if task.is_overdue():\n            return Priority.HIGH\n        elif (\n            task.due_date and task.due_date.time_remaining() <=\n            timedelta(days=2)\n        ):\n            return Priority.MEDIUM\n        else:\n            return Priority.LOW \n```", "```py\n# TodoApp/todo_app/domain/entities/project.py\nfrom dataclasses import dataclass, field\nfrom typing import Optional\nfrom uuid import UUID\n@dataclass\nclass Project(Entity):\n    name: str\n    description: str = \"\"\n    _tasks: dict[UUID, Task] = field(default_factory=dict, init=False)\n    def add_task(self, task: Task) -> None:\n        self._tasks[task.id] = task\n    def remove_task(self, task_id: UUID) -> None:\n        self._tasks.pop(task_id, None)\n    def get_task(self, task_id: UUID) -> Optional[Task]:\n        return self._tasks.get(task_id)\n    @property\n    def tasks(self) -> list[Task]:\n        return list(self._tasks.values()) \n```", "```py\nfrom datetime import datetime\n# Project usage\nproject = Project(\"Website Redesign\")\ntask1 = Task(\n    title=\"Design homepage\",\n    description=\"Create new homepage layout\",\n    due_date=Deadline(datetime(2023, 12, 31)),\n    priority=Priority.HIGH,\n)\ntask2 = Task(\n    title=\"Implement login\",\n    description=\"Add user authentication\",\n    due_date=Deadline(datetime(2023, 11, 30)),\n    priority=Priority.MEDIUM,\n)\nproject.add_task(task1)\nproject.add_task(task2)\nprint(f\"Project: {project.name}\")\nprint(f\"Number of tasks: {len(project.tasks)}\")\nprint(f\"First task: {project.tasks[0].title}\") \n```", "```py\n@dataclass\nclass Task(Entity):\n    title: str\n    description: str\n    due_date: Optional[Deadline] = None\n    priority: Priority = Priority.MEDIUM\n    status: TaskStatus = field(default=TaskStatus.TODO, init=False) \n```", "```py\n@dataclass\nclass Task(Entity):\n    # ... existing attributes ...\n    @classmethod\n    def create_urgent_task(cls, title: str, description: str,\n                           due_date: Deadline):\n        return cls(title, description, due_date, Priority.HIGH) \n```", "```py\n@dataclass\nclass Task(Entity):\n    # ... existing attributes ...\n\n    def __post_init__(self):\n        if not self.title.strip():\n            raise ValueError(\"Task title cannot be empty\")\n        if len(self.description) > 500:\n            raise ValueError(\n                \"Task description cannot exceed 500 characters\") \n```", "```py\nclass TaskFactory:\n    def __init__(self, user_service, project_repository):\n        self.user_service = user_service\n        self.project_repository = project_repository\n    def create_task_in_project(self, title: str, description: str,\n                               project_id: UUID, assignee_id: UUID):\n        project = self.project_repository.get_by_id(project_id)\n        assignee = self.user_service.get_user(assignee_id)\n        task = Task(title, description)\n        task.project = project\n        task.assignee = assignee\n\n        if project.is_high_priority() and assignee.is_manager():\n            task.priority = Priority.HIGH\n        project.add_task(task)\n        return task \n```", "```py\n@dataclass\nclass TaskWithDatabase:\n    title: str\n    description: str\n    db: DbConnection  # This violates the Dependency Rule\n    due_date: Optional[Deadline] = None\n    priority: Priority = Priority.MEDIUM\n    status: TaskStatus = field(default=TaskStatus.TODO, init=False)\n    def mark_as_complete(self):\n        self.status = TaskStatus.DONE\n        self.db.update(self) # This violates the Dependency Rule \n```", "```py\n@dataclass\nclass ProjectWithUI(Entity):\n    name: str\n    ui: UiComponent  # Violates the Dependency Rule\n    description: str = \"\"\n    _tasks: dict[UUID, Task] = field(default_factory=dict, init=False)\n    def add_task(self, task: Task):\n        self._tasks[task.id] = task\n        self.ui.refresh()  # Violates the Dependency Rule \n```", "```py\n# In the Domain layer :\n# (e.g., todo_app/domain/repositories/task_repository.py)\nfrom abc import ABC, abstractmethod\nfrom todo_app.domain.entities.task import Task\nclass TaskRepository(ABC):\n    @abstractmethod\n    def save(self, task: Task):\n        pass\n    @abstractmethod\n    def get(self, task_id: str) -> Task:\n        pass \n```", "```py\n# In the Domain layer (e.g., todo_app/domain/services/task_service.py)\nfrom todo_app.domain.entities.task import Task\nfrom todo_app.domain.repositories.task_repository import TaskRepository\nclass TaskService:\n    def __init__(self, task_repository: TaskRepository):\n        self.task_repository = task_repository\n    def create_task(self, title: str, description: str) -> Task:\n        task = Task(title, description)\n        self.task_repository.save(task)\n        return task\n    def mark_task_as_complete(self, task_id: str) -> Task:\n        task = self.task_repository.get(task_id)\n        task.complete()\n        self.task_repository.save(task)\n        return task \n```", "```py\n# In an outer layer\n# .../infrastructure/persistence/sqlite_task_repository.py\nfrom todo_app.domain.entities.task import Task\nfrom todo_app.domain.repositories.task_repository import TaskRepository\nclass SQLiteTaskRepository(TaskRepository):\n    def __init__(self, db_connection):\n        self.db = db_connection\n    def save(self, task: Task):\n        # Implementation details...\n        pass\n    def get(self, task_id: str) -> Task:\n        # Implementation details...\n        pass \n```", "```py\nfrom dataclasses import dataclass, field\nfrom typing import Optional\n# Before refactoring\n@dataclass\nclass Task(Entity):\n    title: str\n    description: str\n    due_date: Optional[Deadline] = None\n    priority: Priority = Priority.MEDIUM\n    status: TaskStatus = field(default=TaskStatus.TODO, init=False)\n    def mark_as_complete(self):\n        self.status = TaskStatus.DONE\n        # Sending an email notification - this violates domain purity\n        self.send_completion_email()\n    def send_completion_email(self):\n        # Code to send an email notification\n        print(f\"Sending email: Task '{self.title}' has been completed.\") \n```", "```py\n# After refactoring\nfrom abc import ABC, abstractmethod\nfrom dataclasses import dataclass, field\nfrom typing import Optional\n@dataclass\nclass Task(Entity):\n    title: str\n    description: str\n    due_date: Optional[Deadline] = None\n    priority: Priority = Priority.MEDIUM\n    status: TaskStatus = field(default=TaskStatus.TODO, init=False)\n    def mark_as_complete(self):\n        self.status = TaskStatus.DONE\n        # No email sending here;\n        # this is now the responsibility of an outer layer\nclass TaskCompleteNotifier(ABC):\n    @abstractmethod\n    def notify_completion(self, task):\n        pass\n# This would be implemented in an outer layer\nclass EmailTaskCompleteNotifier(TaskCompleteNotifier):\n    def notify_completion(self, task):\n        print(f\"Sending email: Task '{task.title}' has been completed.\") \n```"]