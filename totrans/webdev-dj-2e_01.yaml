- en: 1\. Introduction to Django
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 1. Django简介
- en: Overview
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 概述
- en: This chapter introduces you to Django and its role in web development. You will
    begin by learning how the `manage.py` command (used to orchestrate Django actions).
    You will use this command to start the Django development server and test whether
    the code you've written works as expected. You will also learn how to work with
    **PyCharm**, a popular Python IDE that you'll be using throughout this book. You
    will use it to write code that returns a **response** to your web browser. Finally,
    you'll learn how to use PyCharm's debugger to troubleshoot problems with your
    code. By the end of this chapter, you'll have the necessary skills to start creating
    projects using Django.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 本章向您介绍Django及其在Web开发中的作用。您将从学习如何使用`manage.py`命令（用于协调Django操作）开始。您将使用此命令启动Django开发服务器并测试您编写的代码是否按预期工作。您还将学习如何使用**PyCharm**，这是一种流行的Python集成开发环境（IDE），您将在本书的整个过程中使用它。您将使用它编写返回给Web浏览器的**响应**的代码。最后，您将学习如何使用PyCharm的调试器来调试代码中的问题。到本章结束时，您将具备使用Django创建项目的必要技能。
- en: Introduction
  id: totrans-3
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 简介
- en: '*"The web framework for perfectionists with deadlines."* It''s a tagline that
    aptly describes Django, a framework that has been around for over 10 years now.
    It is battle-tested and widely used, with more and more people using it every
    day. All this might make you think that Django is old and no longer relevant.
    On the contrary, its longevity has proved that its Application Programming Interface
    (API) is reliable and consistent, and even those who learned Django v1.0 in 2007
    can mostly write the same code for Django 3 today. Django is still in active development,
    with bugfixes and security patches being released monthly.'
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: '*"为完美主义者设计的具有截止日期的Web框架。"* 这是一条恰如其分的标语，描述了Django，一个已经存在超过10年的框架。它经过实战检验，被广泛使用，每天都有越来越多的人使用它。所有这些可能让你认为Django已经过时，不再相关。相反，它的长期存在证明了它的应用程序编程接口（API）是可靠和一致的，甚至那些在2007年学习Django
    v1.0的人现在也能为Django 3编写相同的代码。Django仍在积极开发中，每月都会发布错误修复和安全补丁。'
- en: Like Python, the language in which it is written, Django is easy to learn, yet
    powerful and flexible enough to grow with your needs. It is a "batteries-included"
    framework, which is to say that you do not have to find and install many other
    libraries or components to get your application up and running. Other frameworks,
    such as **Flask** or **Pylons**, require manually installing third-party frameworks
    for database connections or template rendering. Instead, Django has built-in support
    for database querying, URL mapping, and template rendering (we'll go into detail
    on what these mean soon). But just because Django is easy to use doesn't mean
    it is limited. Django is used by many large sites, including Disqus ([https://disqus.com/](https://disqus.com/)),
    Instagram ([https://www.instagram.com/](https://www.instagram.com/)), Mozilla
    ([https://www.mozilla.org/](https://www.mozilla.org/)), Pinterest ([https://www.pinterest.com/](https://www.pinterest.com/)),
    Open Stack ([https://www.openstack.org/](https://www.openstack.org/)), and National Geographic
    ([http://www.nationalgeographic.com/](http://www.nationalgeographic.com/)).
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 与它所写的语言Python一样，Django易于学习，但功能强大且足够灵活，可以满足您的需求增长。它是一个“内置电池”的框架，这意味着您不需要寻找和安装许多其他库或组件来使您的应用程序运行。其他框架，如**Flask**或**Pylons**，需要手动安装第三方框架来进行数据库连接或模板渲染。相反，Django内置了对数据库查询、URL映射和模板渲染的支持（我们很快会详细介绍这些功能）。但仅仅因为Django易于使用，并不意味着它有限制。Django被许多大型网站使用，包括Disqus
    ([https://disqus.com/](https://disqus.com/))、Instagram ([https://www.instagram.com/](https://www.instagram.com/))、Mozilla
    ([https://www.mozilla.org/](https://www.mozilla.org/))、Pinterest ([https://www.pinterest.com/](https://www.pinterest.com/))、OpenStack
    ([https://www.openstack.org/](https://www.openstack.org/))和National Geographic
    ([http://www.nationalgeographic.com/](http://www.nationalgeographic.com/))。
- en: Where does Django fit into the web? When talking about web frameworks, you might
    think of frontend JavaScript frameworks such as ReactJS, Angular, or Vue. These
    frameworks are used to enhance or add interactivity to already-generated web pages.
    Django sits in the layer beneath these tools and instead is responsible for routing
    a URL, fetching data from databases, rendering templates, and handling form input
    from users. However, this does not mean you must pick one or the other; JavaScript
    frameworks can be used to enhance the output from Django, or to interact with
    a REST API generated by Django.
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: Django在Web中处于什么位置？当谈到Web框架时，你可能会想到前端JavaScript框架，如ReactJS、Angular或Vue。这些框架用于增强或添加交互性到已经生成的网页。Django位于这些工具的下一层，负责路由URL、从数据库获取数据、渲染模板以及处理用户表单输入。然而，这并不意味着你必须选择其中一个；JavaScript框架可以用来增强Django的输出，或者与Django生成的REST
    API交互。
- en: In this book, we will build a Django project using the methods that professional
    Django developers use every day. The application is called **Bookr**, and it allows
    browsing and adding books and book reviews. This book is divided into four sections.
    In the first section, we'll start with the basics of scaffolding a Django app
    and quickly build some pages and serve them with the Django development server.
    You'll be able to add data to the database using the Django admin site.
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: 在这本书中，我们将使用专业Django开发者每天使用的方法来构建一个Django项目。该应用程序被称为**Bookr**，允许浏览和添加书籍及书评。本书分为四个部分。在第一部分，我们将从搭建Django应用的基础开始，快速构建一些页面，并使用Django开发服务器来提供服务。你将能够通过Django管理站点向数据库添加数据。
- en: The next section focuses on adding enhancements to Bookr. You'll serve static
    files to add styles and images to the site. By using Django's `form` library,
    you'll add interactivity, and by using file uploads, you will be able to upload
    book covers and other files. You'll then implement user login and learn how to
    store information about the current user in the session.
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 下一部分将专注于增强Bookr。你将为网站添加样式和图片来提供静态文件。通过使用Django的`form`库，你将添加交互性，并通过使用文件上传，你将能够上传书籍封面和其他文件。然后，你将实现用户登录，并学习如何在会话中存储当前用户的信息。
- en: In section three, you'll build on your existing knowledge and move to the next
    level of development. You'll customize the Django admin site and then learn about
    advanced templating. Next, you'll learn how to build a **REST API** and generate
    non-HTML data (such as CSVs and PDFs), and you'll finish the section by learning
    about testing Django.
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 在第三部分，你将在现有知识的基础上进一步提升。你将定制Django管理站点，然后学习高级模板技术。接下来，你将学习如何构建**REST API**并生成非HTML数据（如CSV和PDF），并通过学习测试Django来结束本部分。
- en: Many third-party libraries are available to add functionality to Django and
    to make development easier and thus save time. In the final section, you'll learn
    about some of the useful ones and how to integrate them into your application.
    Applying this knowledge, you'll integrate a JavaScript library to communicate
    with the REST framework you built in the previous section. Finally, you'll learn
    how to deploy your Django application to a virtual server.
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 许多第三方库可用于增强Django功能，使开发更简单，从而节省时间。在最后一部分，你将了解一些有用的库以及如何将它们集成到你的应用程序中。应用这些知识，你将集成一个JavaScript库来与上一节中构建的REST框架通信。最后，你将学习如何将你的Django应用程序部署到虚拟服务器。
- en: By the end of the book, you will have enough experience to design and build
    your own Django project from start to finish.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 到本书结束时，你将拥有足够的设计和从头到尾构建自己的Django项目的经验。
- en: Scaffolding a Django Project and App
  id: totrans-12
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 搭建Django项目和应用程序
- en: Before diving deep into the theory behind Django paradigms and HTTP requests,
    we'll show you how easy it is to get a Django project up and running. After this
    first section and exercise, you will have created a Django project, made a request
    to it with your browser, and seen the response.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 在深入探讨Django范式和HTTP请求背后的理论之前，我们将向你展示如何轻松地将Django项目搭建起来。在完成本部分和练习之后，你将已经创建了一个Django项目，用浏览器向其发送请求，并看到了响应。
- en: 'A Django project is a directory that contains all the data for your project:
    code, settings, templates, and assets. It is created and scaffolded by running
    the `django-admin.py` command on the command line with the `startproject` argument
    and providing the project name. For example, to create a Django project with the
    name `myproject`, the command that is run is this:'
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: Django 项目是一个包含您项目所有数据的目录：代码、设置、模板和资产。它是通过在命令行上运行带有 `startproject` 参数的 `django-admin.py`
    命令并输入项目名称来创建和构建的。例如，要创建一个名为 `myproject` 的 Django 项目，运行的命令如下：
- en: '[PRE0]'
  id: totrans-15
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'This will create the `myproject` directory, which Django populates with the
    necessary files to run the project. Inside the `myproject` directory are two files
    (shown in *Figure 1.1*):'
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 这将创建 `myproject` 目录，Django 会填充运行项目所需的必要文件。在 `myproject` 目录内有两个文件（如图 *1.1* 所示）：
- en: '![Figure 1.1: Project directory for myproject'
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: '![图 1.1：myproject 的项目目录'
- en: '](img/B15509_01_01.jpg)'
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/B15509_01_01.jpg)'
- en: 'Figure 1.1: Project directory for myproject'
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 图 1.1：myproject 的项目目录
- en: '`manage.py` is a Python script that is executed at the command line to interact
    with your project. We will use it to start the `django-admin.py`, commands are
    passed in on the command line. Unlike `django-admin.py`, this script is not mapped
    in your system path, so we must execute it using Python. We will need to use the
    command line to do that. For example, inside the project directory, run the following
    command:'
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: '`manage.py` 是一个 Python 脚本，在命令行中执行以与您的项目交互。我们将使用它来启动 `django-admin.py`，命令通过命令行传入。与
    `django-admin.py` 不同，此脚本未映射到您的系统路径，因此我们必须使用 Python 来执行它。我们需要使用命令行来完成此操作。例如，在项目目录内，运行以下命令：'
- en: '[PRE1]'
  id: totrans-21
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: This passes the `runserver` command to the `manage.py` script, which starts
    the Django dev server. We will examine more of the commands that `manage.py` accepts
    in the *Django Project* section. When interacting with `manage.py` in this way,
    we call these management commands. For example, we might say that we are *"executing
    the runserver management command."*
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 这将 `runserver` 命令传递给 `manage.py` 脚本，从而启动 Django 开发服务器。我们将在 *Django 项目* 部分检查
    `manage.py` 接受的更多命令。以这种方式与 `manage.py` 交互时，我们称这些管理命令。例如，我们可能会说我们在 *"执行 runserver
    管理命令。"*
- en: The `startproject` command also created a directory with the same name as the
    project, in this case, `myproject` (*Figure 1.1*). This is a Python package that
    contains settings and some other configuration files that your project needs to
    run. We will examine its contents in the *Django Project* section.
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: '`startproject` 命令还创建了一个与项目同名的目录，在本例中为 `myproject` (*图 1.1*)。这是一个包含设置和一些其他配置文件（您的项目运行所需的）的
    Python 包。我们将在 *Django 项目* 部分检查其内容。'
- en: 'After starting the Django project, the next thing to do is to start a Django
    app. We should try to segregate our Django project into different apps, grouped
    by functionality. For example, with Bookr, we will have a `reviews` app. This
    will hold all the code, HTML, assets, and database classes specific to working
    with book reviews. If we decided to expand Bookr to sell books as well, we might
    add a `store` application, containing the files for the bookstore. Apps are created
    with the `startapp` management command, passing in the application name. For example:'
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 在启动 Django 项目后，接下来要做的事情是启动一个 Django 应用。我们应该尝试将我们的 Django 项目分割成不同的应用程序，按功能分组。例如，在
    Bookr 中，我们将有一个 `reviews` 应用。这将包含所有与书评工作相关的代码、HTML、资产和数据库类。如果我们决定将 Bookr 扩展为销售书籍，我们可能会添加一个
    `store` 应用程序，包含书店的文件。应用程序通过 `startapp` 管理命令创建，传入应用程序名称。例如：
- en: '[PRE2]'
  id: totrans-25
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: This creates the app directory (`myapp`) inside the project directory. Django
    automatically populates this with files for the app that are ready to be filled
    in when you start developing. We'll examine these files and discuss what makes
    a good app in the *Django Apps* section.
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 这将在项目目录内创建应用程序目录 (`myapp`)。Django 会自动填充此目录，以便在您开始开发时填充应用程序所需的文件。我们将在 *Django
    应用* 部分检查这些文件并讨论什么使一个应用程序变得良好。
- en: Now that we've introduced the basic commands to scaffold a Django project and
    application, let's put them into practice by starting the Bookr project in the
    first exercise of this book.
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经介绍了构建 Django 项目和应用程序的基本命令，让我们通过启动本书的第一个练习中的 Bookr 项目来将它们付诸实践。
- en: 'Exercise 1.01: Creating a Project and App, and Starting the Dev Server'
  id: totrans-28
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 练习 1.01：创建项目和应用程序，并启动开发服务器
- en: Throughout this book, we will be building a book review website named Bookr.
    It will allow you to add fields for publishers, contributors, books, and reviews.
    A publisher will publish one or more books, and each book will have one or more
    contributors (author, editor, co-author, and so on). Only admin users will be
    allowed to modify these fields. Once a user has signed up for an account on the
    site, they will be able to start adding reviews to a book.
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 在本书中，我们将构建一个名为 Bookr 的书评网站。它将允许你添加出版商、贡献者、书籍和评论的字段。出版商将出版一本或多本书，每本书将有一个或多个贡献者（作者、编辑、合著者等等）。只有管理员用户才能修改这些字段。一旦用户在该网站上注册了账户，他们就可以开始为书籍添加评论。
- en: In this exercise, you will scaffold the `bookr` Django project, test that Django
    is working by running the dev server, then create the `reviews` Django app.
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个练习中，你将构建 `bookr` Django 项目，通过运行开发服务器来测试 Django 是否工作，然后创建 `reviews` Django
    应用。
- en: 'You should already have a virtual environment set up with Django installed.
    To learn how to do that, you can refer to the *Preface*. Once you''re ready, let''s
    start by creating the Bookr project:'
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 你应该已经设置了一个包含 Django 的虚拟环境。要了解如何做，你可以参考 *前言*。一旦准备好，让我们开始创建 Bookr 项目：
- en: 'Open a Terminal and run the following command to create the `bookr` project
    directory and the default subfolders:'
  id: totrans-32
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 打开一个终端并运行以下命令来创建 `bookr` 项目目录和默认子目录：
- en: '[PRE3]'
  id: totrans-33
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'This command does not generate any output but will create a folder called `bookr`
    inside the directory in which you ran the command. You can look inside this directory
    and see the items we described before for the `myproject` example: the `bookr`
    package directory and `manage.py` file.'
  id: totrans-34
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 此命令不会生成任何输出，但将在你运行命令的目录中创建一个名为 `bookr` 的文件夹。你可以查看这个目录，看看我们之前在 `myproject` 示例中描述的项目：`bookr`
    包目录和 `manage.py` 文件。
- en: We can now test that the project and Django are set up correctly by running
    the Django dev server. Starting the server is done with the `manage.py` script.
  id: totrans-35
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们现在可以通过运行 Django 开发服务器来测试项目和 Django 是否设置正确。启动服务器是通过 `manage.py` 脚本完成的。
- en: In your Terminal (or Command Prompt), change into the `bookr` project directory
    (using the `cd` command), then run the `manage.py runserver` command.
  id: totrans-36
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 在你的终端（或命令提示符）中，切换到 `bookr` 项目目录（使用 `cd` 命令），然后运行 `manage.py runserver` 命令。
- en: '[PRE4]'
  id: totrans-37
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE4]'
- en: You will probably have some warnings about unapplied migrations, but that's
    okay for now.
  id: totrans-38
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 你可能会收到一些关于未应用迁移的警告，但就目前来说这没关系。
- en: 'Open up a web browser and go to `http://127.0.0.1:8000/`, which will show you
    the Django welcome screen (*Figure 1.2*). If you see this, you know your Django
    project was created successfully and it all is working fine for now:![Figure 1.2:
    Django welcome screen'
  id: totrans-39
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 打开一个网页浏览器并访问 `http://127.0.0.1:8000/`，这将显示 Django 欢迎界面（*图 1.2*）。如果你看到这个界面，你就知道你的
    Django 项目已成功创建，目前一切运行正常：![图 1.2：Django 欢迎界面
- en: '](img/B15509_01_02.jpg)'
  id: totrans-40
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '](img/B15509_01_02.jpg)'
- en: 'Figure 1.2: Django welcome screen'
  id: totrans-41
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 图 1.2：Django 欢迎界面
- en: Go back to your Terminal and stop the development server running using the *Ctrl*
    + *C* key combination.
  id: totrans-42
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 返回你的终端并使用 *Ctrl* + *C* 键组合停止运行的开发服务器。
- en: 'We''ll now create the `reviews` app for the `bookr` project. In your Terminal,
    make sure you are in the `bookr` project directory, then execute the following
    command to create the `reviews` app:'
  id: totrans-43
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们现在将为 `bookr` 项目创建 `reviews` 应用。在你的终端中，确保你处于 `bookr` 项目目录中，然后执行以下命令来创建 `reviews`
    应用：
- en: '[PRE5]'
  id: totrans-44
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE5]'
- en: Note
  id: totrans-45
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 注意
- en: 'After creating the `reviews` app, the files in your `bookr` project directory
    would look like this: [http://packt.live/3nZGy5D](http://packt.live/3nZGy5D).'
  id: totrans-46
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 创建 `reviews` 应用后，你的 `bookr` 项目目录中的文件将如下所示：[http://packt.live/3nZGy5D](http://packt.live/3nZGy5D)。
- en: 'There is no output if the command was successful, but a `reviews` app directory
    has been created. You can look inside this directory to see the files that were
    created: the `migrations` directory, `admin.py`, `models.py`, and so on. We''ll
    examine these in detail in the *Django Apps* section.'
  id: totrans-47
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 如果命令成功执行，则没有输出，但已创建一个 `reviews` 应用目录。你可以查看这个目录，看看创建的文件：`migrations` 目录、`admin.py`、`models.py`
    等等。我们将在 *Django 应用* 部分详细检查这些文件。
- en: In this exercise, we created the `bookr` project, tested that the project was
    working by starting the Django dev server, then created the `reviews` app for
    the project. Now that we've had some hands-on time with a Django project, we'll
    return to some of the theory behind Django's design and HTTP requests and responses.
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个练习中，我们创建了 `bookr` 项目，通过启动 Django 开发服务器来测试项目是否工作，然后为该项目创建了 `reviews` 应用。现在我们已经对
    Django 项目有了实际操作的经验，我们将回到 Django 设计和 HTTP 请求与响应背后的理论。
- en: Model View Template
  id: totrans-49
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 模型视图模板
- en: A common design pattern in application design is **Model View Controller** (**MVC**),
    where the model of the application (its data) is displayed in one or more views
    and a controller marshals interaction between the model and view. Django follows
    a somewhat similar paradigm called **Model View Template** (**MVT**).
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 应用程序设计中的一种常见设计模式是 **模型视图控制器**（**MVC**），其中应用程序的模型（其数据）在一个或多个视图中显示，控制器协调模型和视图之间的交互。Django
    遵循一个类似但略有不同的范式，称为 **模型视图模板**（**MVT**）。
- en: Like MVC, MVT also uses models for storing data. However, with MVT, a view will
    query a model and then render it with a template. Usually, with MVC languages,
    all three components need to be developed with the same language. With MVT, the
    template can be in a different language. In the case of Django, the models and
    views are written in Python and the Template in HTML. This means that a Python
    developer could work on the models and views, while a specialist HTML developer
    works on the HTML. We'll first explain models, views, and templates in more detail,
    and then look at some example scenarios where they are used.
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 与 MVC 类似，MVT 也使用模型来存储数据。然而，在 MVT 中，视图将查询模型，然后使用模板渲染它。通常，在 MVC 语言中，所有三个组件都需要用相同的语言开发。在
    MVT 中，模板可以是不同的语言。在 Django 的情况下，模型和视图是用 Python 编写的，而模板是用 HTML 编写的。这意味着 Python 开发者可以处理模型和视图，而专门的
    HTML 开发者可以处理 HTML。我们首先将更详细地解释模型、视图和模板，然后看看它们在哪些示例场景中被使用。
- en: Models
  id: totrans-52
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 模型
- en: Django models define the data for your application and provide an abstraction
    layer to SQL database access through an **Object Relational Mapper** (**ORM**).
    An ORM lets you define your data schema (classes, fields, and their relationships)
    using Python code, without needing an understanding of the underlying database.
    This means you can define your database layer in Python code and Django will take
    care of generating SQL queries for you. ORMs will be discussed in detail in *Chapter
    2*, *Models and Migrations*.
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: Django 模型定义了应用程序的数据并提供了一个通过 **对象关系映射器**（**ORM**）访问 SQL 数据库的抽象层。ORM 允许你使用 Python
    代码定义你的数据模式（类、字段及其关系），而不需要了解底层数据库。这意味着你可以在 Python 代码中定义你的数据库层，而 Django 将为你生成 SQL
    查询。ORM 将在 *第 2 章*，*模型和迁移* 中详细讨论。
- en: Note
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: '`SELECT`), add or change data (`INSERT` and `UPDATE` respectively), and remove
    data (`DELETE`). There are many SQL database servers to choose from, such as SQLite,
    PostgreSQL, MySQL, or Microsoft SQL Server. Much of the SQL syntax is similar
    between databases, but there can be some differences in dialect. Django''s ORM
    takes care of these differences for you: when we start coding, we will use the
    SQLite database to store data on disk, but later when we deploy to a server, we
    will switch to PostgreSQL but won''t need to make any code changes.'
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: (`SELECT`) 添加或更改数据（分别使用 `INSERT` 和 `UPDATE`），以及删除数据（使用 `DELETE`）。有许多 SQL 数据库服务器可供选择，例如
    SQLite、PostgreSQL、MySQL 或 Microsoft SQL Server。SQL 语法在数据库之间有很多相似之处，但可能会有一些方言上的差异。Django
    的 ORM 会为你处理这些差异：当我们开始编码时，我们将使用 SQLite 数据库在磁盘上存储数据，但当我们部署到服务器时，我们将切换到 PostgreSQL，而无需对代码进行任何更改。
- en: Normally, when querying a database, the results come back as primitive Python
    objects, (for example, lists of strings, integers, floats, or bytes). When using
    the ORM, results are automatically converted into instances of the model classes
    you have defined. Using an ORM means that you are automatically protected from
    a type of vulnerability known as a SQL injection attack.
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 通常，当查询数据库时，结果会以原始 Python 对象的形式返回（例如，字符串列表、整数、浮点数或字节）。当使用 ORM 时，结果会自动转换为已定义的模型类实例。使用
    ORM 意味着你自动受到一种称为 SQL 注入攻击的漏洞的保护。
- en: If you're more familiar with databases and SQL, you always have the option of
    writing your own queries too.
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你更熟悉数据库和 SQL，你也可以选择编写自己的查询。
- en: Views
  id: totrans-58
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 视图
- en: 'A Django view is where most of the logic for your application is defined. When
    a user visits your site, their web browser will send a request to retrieve data
    from your site (in the next section, we will go into more detail on what an HTTP
    request is and what information it contains). A view is a function that you write
    that will receive this request in the form of a Python object (specifically, a
    Django `HttpRequest` object). It is up to your view to decide how it should respond
    to the request and what it should send back to the user. Your view must return
    an `HttpResponse` object that encapsulates all the information being provided
    to the client: content, HTTP status, and other headers.'
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: Django视图是定义应用程序大部分逻辑的地方。当用户访问你的网站时，他们的网络浏览器会发送一个请求以从你的网站检索数据（在下一节中，我们将更详细地介绍HTTP请求是什么以及它包含的信息）。视图是你编写的一个函数，它将以Python对象的形式接收这个请求（具体来说，是一个Django
    `HttpRequest`对象）。你的视图必须决定如何响应请求以及向用户发送什么信息。你的视图必须返回一个`HttpResponse`对象，该对象封装了提供给客户端的所有信息：内容、HTTP状态和其他头信息。
- en: The view can also optionally receive information from the URL of the request,
    for example, an ID number. A common design pattern of a view is to query a database
    via the Django ORM using an ID that is passed into your view. Then the view can
    render a template (more on this in a moment) by providing it with data from the
    model retrieved from the database. The rendered template becomes the content of
    `HttpResponse` and is returned from the view function. Django takes care of the
    communication of the data back to the browser.
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 视图还可以可选地从请求的URL中接收信息，例如，一个ID号。视图的一个常见设计模式是通过Django ORM使用传递给视图的ID查询数据库。然后视图可以通过提供从数据库检索到的模型的数据来渲染一个模板（稍后我们将详细介绍这一点）。渲染的模板成为`HttpResponse`的内容，并从视图函数返回。Django负责将数据回传到浏览器。
- en: Templates
  id: totrans-61
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 模板
- en: A template is a `<` and `>` symbols (among others) are special characters in
    HTML. If you try to use them in a variable, then Django automatically encodes
    them so they render correctly in a browser.
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 模板中的`<`和`>`符号（以及其他符号）是HTML中的特殊字符。如果你尝试在变量中使用它们，那么Django会自动编码它们，以便在浏览器中正确渲染。
- en: MVT in Practice
  id: totrans-63
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: MVT实践
- en: We'll now look at some examples to illustrate how MVT works in practice. In
    the examples, we have a `Book` model that stores information about different books,
    and a `Review` model that stores information about different reviews of the books.
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在将查看一些示例，以说明MVT在实际中的应用。在示例中，我们有一个`Book`模型，它存储有关不同书籍的信息，以及一个`Review`模型，它存储有关书籍不同评论的信息。
- en: 'In the first example, we want to be able to edit the information about a book
    or review. Take the first scenario, editing a book''s details. We would have a
    view to fetch the `Book` data from the database and provide the `Book` model.
    Then, we would pass context information containing the `Book` object (and other
    data) to a template that would show a form to capture the new information. The
    second scenario (editing a review) is similar: fetch a `Review` model from the
    database, then pass the `Review` object and other data to a template to display
    an edit form. These scenarios might be so similar that we can reuse the same template
    for both. Refer to *Figure 1.3*.'
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 在第一个例子中，我们希望能够编辑书籍或评论的信息。以编辑书籍详情的第一个场景为例。我们会有一个视图从数据库中获取`Book`数据并提供`Book`模型。然后，我们会将包含`Book`对象（和其他数据）的上下文信息传递给一个模板，该模板将显示一个表单以捕获新信息。第二个场景（编辑评论）类似：从数据库中获取`Review`模型，然后将`Review`对象和其他数据传递给模板以显示编辑表单。这些场景可能非常相似，以至于我们可以为两者重用相同的模板。请参阅*图1.3*。
- en: '![Figure 1.3: Editing a single book or review'
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: '![图1.3：编辑单个书籍或评论'
- en: '](img/B15509_01_03.jpg)'
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/B15509_01_03.jpg)'
- en: 'Figure 1.3: Editing a single book or review'
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 图1.3：编辑单个书籍或评论
- en: You can see here that we use two models, two views, and one template. Each view
    fetches a single instance of its associated model, but they can both use the same
    template, which is a generic HTML page to display a form. The views can provide
    extra context data to slightly alter the display of the template for each model
    type. Also illustrated in the diagram are the parts of the code that are written
    in Python and those that are written in HTML.
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以在这里看到我们使用了两种模型、两种视图和一种模板。每个视图都会获取其关联模型的一个实例，但它们都可以使用相同的模板，这是一个通用的HTML页面，用于显示表单。视图可以为每种模型类型提供额外的上下文数据，以略微改变模板的显示。图中还展示了用Python和HTML编写的代码部分。
- en: 'In the second example, we want to be able to show the user a list of the books
    or reviews that are stored in the application. Furthermore, we want to allow the
    user to search for books and get a list of all that match their criteria. We will
    use the same two models as the previous example (`Book` and `Review`), but we
    will create new views and templates. Since there are three scenarios, we''ll use
    three views this time: the first fetches all books, the second fetches all reviews,
    and the last searches for books based on some search criteria. Once again, if
    we write a template well, we might be able to just use a single HTML template
    again. Refer to *Figure 1.4*:'
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 在第二个例子中，我们希望能够向用户显示存储在应用程序中的书籍或评论列表。此外，我们希望允许用户搜索书籍并获取所有符合他们标准的列表。我们将使用与上一个例子相同的两个模型（`Book`
    和 `Review`），但我们将创建新的视图和模板。由于有三个场景，我们这次将使用三个视图：第一个获取所有书籍，第二个获取所有评论，最后一个根据某些搜索标准搜索书籍。再次强调，如果我们编写了一个好的模板，我们可能再次只使用一个
    HTML 模板。参见 *图 1.4*：
- en: '![Figure 1.4: Viewing multiple books or reviews'
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: '![图 1.4：查看多本书或评论'
- en: '](img/B15509_01_04.jpg)'
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/B15509_01_04.jpg)'
- en: 'Figure 1.4: Viewing multiple books or reviews'
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 图 1.4：查看多本书或评论
- en: The `Book` and `Review` models remain unchanged from the previous example. The
    three views will fetch many (zero or more) books or reviews. Then, each view can
    use the same template, which is a generic HTML file that iterates over a list
    of objects that it is given and renders them. Once again, the views can send extra
    data in the context to alter how the template behaves, but the majority of the
    template will be as generic as possible.
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: '`Book` 和 `Review` 模型与上一个例子保持不变。这三个视图将获取许多（零个或多个）书籍或评论。然后，每个视图都可以使用相同的模板，这是一个通用的
    HTML 文件，它遍历它给出的对象列表并渲染它们。再次强调，视图可以在上下文中发送额外的数据以改变模板的行为，但模板的大部分内容将尽可能通用。'
- en: 'In Django, a model does not always need to be used to render an HTML template.
    A view can generate the context data itself and render a template with it, without
    requiring any model data. See *Figure 1.5* for a view sending data straight to
    a template:'
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 在 Django 中，不一定需要使用模型来渲染 HTML 模板。视图可以自己生成上下文数据，并使用它渲染一个模板，而不需要任何模型数据。参见 *图 1.5*，一个视图直接将数据发送到模板：
- en: '![Figure 1.5: From view to template without a model'
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: '![图 1.5：无需模型从视图到模板'
- en: '](img/B15509_01_05.jpg)'
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/B15509_01_05.jpg)'
- en: 'Figure 1.5: From view to template without a model'
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 图 1.5：无需模型从视图到模板
- en: In this example, there is a welcome view to welcome a user to the site. It doesn't
    need any information from the database, so it can just generate the context data
    itself. The context data depends on the type of information you want to display;
    for example, you could pass the user information to greet them by name if they
    are logged in. It is also possible for a view to render a template without any
    context data. This can be useful if you have static information in an HTML file
    that you want to serve.
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个例子中，有一个欢迎视图用于欢迎用户访问网站。它不需要从数据库获取任何信息，因此它可以自己生成上下文数据。上下文数据取决于你想要显示的信息类型；例如，如果你想要通过用户名问候他们，你可以传递用户信息。视图也可以在没有上下文数据的情况下渲染模板。如果你有一个包含静态信息的
    HTML 文件并希望提供服务，这可能很有用。
- en: Introduction to HTTP
  id: totrans-80
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: HTTP 简介
- en: Now that you have been introduced to MVT in Django, we can look at how Django
    processes an HTTP request and generates an HTTP response. But first, we need to
    explain in more detail what HTTP requests and responses are, and what information
    they contain.
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 现在你已经了解了 Django 中的 MVT（模型-视图-模板），我们可以看看 Django 如何处理 HTTP 请求并生成 HTTP 响应。但首先，我们需要更详细地解释
    HTTP 请求和响应是什么，以及它们包含哪些信息。
- en: 'Let''s say someone wants to visit your web page. They type in its URL or click
    a link to your site from a page they are already on. Their web browser creates
    an HTTP request, which is sent to the server hosting your website. Once a web
    server receives the HTTP request from your browser, it can interpret it and then
    send back a response. The response that the server sends might be simple, such
    as just reading an HTML or image file from disk and sending it. Or, the response
    might be more complex, maybe using server-side software (such as Django) to dynamically
    generate the content before sending it:'
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 假设有人想访问你的网页。他们输入其 URL 或从他们已经所在的页面点击链接到你的网站。他们的网络浏览器创建一个 HTTP 请求，并将其发送到托管你网站的服务器。一旦网络服务器从你的浏览器接收到
    HTTP 请求，它就可以解释它，然后发送回一个响应。服务器发送的响应可能很简单，例如只是从磁盘读取 HTML 或图像文件并发送它。或者，响应可能更复杂，可能使用服务器端软件（如
    Django）在发送之前动态生成内容：
- en: '![Figure 1.6: HTTP request and HTTP response'
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: '![图 1.6：HTTP 请求和 HTTP 响应'
- en: '](img/B15509_01_06.jpg)'
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: '![图 B15509_01_06](img/B15509_01_06.jpg)'
- en: 'Figure 1.6: HTTP request and HTTP response'
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 图 1.6：HTTP 请求和 HTTP 响应
- en: 'The request is made up of four main parts: the method, path, headers, and body.
    Some types of requests don''t have a body. If you just visit a web page, your
    browser will not send a body, whereas if you are submitting a form (for example,
    by logging into a site or performing a search), then your request will have a
    body containing the data you''re submitting. We''ll look at two example requests
    now to illustrate this.'
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 请求由四个主要部分组成：方法、路径、头和主体。某些类型的请求没有主体。如果你只是访问一个网页，你的浏览器不会发送主体，而如果你正在提交一个表单（例如，通过登录一个网站或执行搜索），那么你的请求将包含一个包含你提交的数据的主体。现在我们将查看两个示例请求来阐述这一点。
- en: 'The first request will be to an example page with the URL `https://www.example.com/page`.
    When your browser visits that page, behind the scenes, this is what it''s sending:'
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 第一个请求将是一个示例页面，URL 为 `https://www.example.com/page`。当你的浏览器访问该页面时，幕后它会发送以下内容：
- en: '[PRE6]'
  id: totrans-88
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: The first line contains the method (`GET`) and the path (`/page`). It also contains
    the HTTP version, in this case, `1.1`, although you don't have to worry about
    this. Many different HTTP methods can be used, depending on how you want to interact
    with the remote page. Some common ones are `GET` (retrieve the remote page), `POST`
    (send data to the remote page), `PUT` (create a remote page), and `DELETE` (delete
    the remote page). Note that the descriptions of the actions are somewhat simplified—the
    remote server can choose how it responds to different methods, and even experienced
    developers can disagree on the correct method to implement for a particular action.
    It's also important to note that even if a server supports a particular method,
    you will probably need the correct permissions to perform that action—you can't
    just use `DELETE` on a web page you don't like, for example.
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 第一行包含方法（`GET`）和路径（`/page`）。它还包含 HTTP 版本，在这种情况下，`1.1`，尽管你不必担心这一点。根据你如何与远程页面交互，可以使用许多不同的
    HTTP 方法。一些常见的方法有 `GET`（检索远程页面）、`POST`（向远程页面发送数据）、`PUT`（创建远程页面）和 `DELETE`（删除远程页面）。请注意，动作的描述有些简化——远程服务器可以选择如何响应不同的方法，即使是经验丰富的开发者也可能对实现特定动作的正确方法意见不一。还重要的是要注意，即使服务器支持某种特定方法，你可能也需要正确的权限才能执行该操作——你不能只是在一个你不喜欢网站上使用
    `DELETE`，例如。
- en: When writing a web application, the vast majority of the time, you will only
    deal with `GET` requests. When you start accepting forms, you'll also have to
    use `POST` requests. It is only when you are working with advanced features such
    as creating REST APIs that you will have to worry about `PUT`, `DELETE`, and other
    methods.
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 当编写 web 应用程序时，绝大多数时间你只会处理 `GET` 请求。当你开始接受表单时，你也将不得不使用 `POST` 请求。只有当你处理创建 REST
    API 等高级功能时，你才需要担心 `PUT`、`DELETE` 和其他方法。
- en: 'Referring back to the example request again, from line 2 onward are the headers
    of the request. The headers contain extra metadata about the request. Each header
    is on its own line, with the header name and its value separated by a colon. Most
    are optional (except for `Host`—more on that soon). Header names are not case
    sensitive. For the sake of the example, we''re only showing three common headers
    here. Let''s look at the example headers in order:'
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 回顾一下示例请求，从第二行开始是请求的头。头包含关于请求的额外元数据。每个头都在自己的行上，头名称和其值由冒号分隔。大多数是可选的（除了 `Host`——稍后会有更多说明）。头名称不区分大小写。为了说明，我们这里只展示了三个常见的头。让我们按顺序查看示例头：
- en: '`Host`: As mentioned, this is the only header that is required (for HTTP 1.1
    or later). It is needed for the webserver to know which website or application
    should respond to the request, in case there are multiple sites hosted on a single server.'
  id: totrans-92
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Host`：如前所述，这是唯一必需的头（对于 HTTP 1.1 或更高版本）。它是必需的，以便 web 服务器知道哪个网站或应用程序应该响应该请求，以防单个服务器上托管了多个网站。'
- en: '`User-Agent`: Your browser usually sends to the server a string identifying
    its version and operating system. Your server application could use this to serve
    different pages to different devices (for example, a mobile-specific page for
    smartphones).'
  id: totrans-93
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`User-Agent`：你的浏览器通常会向服务器发送一个字符串，以标识其版本和操作系统。你的服务器应用程序可以使用这个信息为不同的设备提供不同的页面（例如，为智能手机提供特定的移动页面）。'
- en: '`Cookie`: You have probably seen a message when visiting a web page that lets
    you know that it is storing a cookie in the browser. These are small pieces of
    information that a website can store in your browser that can be used to identify
    you or save settings for when you return to the site. If you were wondering about
    how your browser sends these cookies back to the server, it is through this header.'
  id: totrans-94
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Cookie`：你可能见过当访问网页时显示的消息，告诉你它在浏览器中存储了一个 cookie。这些是网站可以在你的浏览器中存储的小块信息，可以用来识别你或保存你返回网站时的设置。如果你想知道浏览器是如何将这些
    cookie 发送回服务器的，它就是通过这个标题。'
- en: There are many other standard headers defined and it would take up too much
    space to list them all. They can be used to authenticate to the server (`Authorization`),
    tell the server what kind of data you can receive (`Accept`), or even state what
    language you'd like for the page (`Accept-Language`, although this will only work
    if the page creator has made the content available in the particular language
    you request). You can even define your own headers that only your application
    knows how to respond to.
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 定义了许多其他标准标题，列出所有这些标题会占用太多空间。它们可以用来向服务器进行身份验证（`Authorization`），告诉服务器你能够接收什么类型的数据（`Accept`），或者甚至声明你希望页面使用的语言（`Accept-Language`，尽管这只有在页面创建者已经将内容提供为请求的特定语言时才会生效）。你甚至可以定义只有你的应用程序知道如何响应的自定义标题。
- en: 'Now let''s look at a slightly more advanced request: one that sends some information
    to a server, and thus (unlike the previous example) contains a body. In this example,
    we are logging into a web page by sending a username and password. For example,
    you visit `https://www.example.com/login` and it displays a form to enter username
    and password. After you click the `Login` button, this is the request that is
    sent to the server:'
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 现在让我们看看一个稍微复杂一点的请求：它向服务器发送一些信息，因此（与之前的示例不同）包含一个正文。在这个示例中，我们通过发送用户名和密码来登录网页。例如，你访问
    `https://www.example.com/login`，它显示一个输入用户名和密码的表单。在你点击 `Login` 按钮后，这就是发送到服务器的请求：
- en: '[PRE7]'
  id: totrans-97
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'As you can see, this looks similar to the first example, but there are a few
    differences. The method is now `POST`, and two new headers have been introduced
    (you can assume your browser would still be sending the other headers that were
    in the previous example too):'
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 如你所见，这看起来与第一个示例类似，但有一些不同。方法现在是 `POST`，并且引入了两个新的标题（你可以假设浏览器仍然会发送之前示例中的其他标题）：
- en: '`Content-Type` : This tells the server the type of data that is included in
    the body. In the case of `application/x-www-form-urlencoded`, the body is a set
    of key-value pairs. An HTTP client could set this header to tell the server if
    it was sending other types of data, such as JSON or XML, for example.'
  id: totrans-99
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Content-Type`：这告诉服务器正文中包含的数据类型。在 `application/x-www-form-urlencoded` 的情况下，正文是一组键值对。HTTP
    客户端可以设置此标题来告诉服务器它是否正在发送其他类型的数据，例如 JSON 或 XML。'
- en: '`Content-Length`: For the server to know how much data to read, the client
    must tell it how much data is being sent. The `Content-Length` header contains
    the length of the body. If you count the length of the body in this example, you''ll
    see it''s 32 characters.'
  id: totrans-100
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Content-Length`：为了服务器知道要读取多少数据，客户端必须告诉它正在发送多少数据。`Content-Length` 标题包含正文的长度。如果你计算这个示例中正文的长度，你会看到它是
    32 个字符。'
- en: 'The headers are always separated from the body by a blank line. By looking
    at the example, you should be able to tell how the form data is encoded in the
    body: `username` has the value `user1` and `password` the value `password1`.'
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 标题始终由一个空行与正文隔开。通过查看示例，你应该能够了解表单数据是如何在正文中编码的：`username` 的值为 `user1`，而 `password`
    的值为 `password1`。
- en: These requests were quite simple, but most requests don't get much more complicated.
    They might have different methods and headers but should follow the same format.
    Now that you've seen requests, we'll take a look at the HTTP responses that come
    back from the server.
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 这些请求相当简单，但大多数请求并没有变得更加复杂。它们可能有不同的方法和标题，但应该遵循相同的格式。现在你已经看到了请求，我们将查看从服务器返回的 HTTP
    响应。
- en: 'An HTTP response looks similar to a request and consists of three main parts:
    a status, headers, and a body. Like a request, though, depending on the type of
    response, it might not have a body. The first response example is a simple successful response:'
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: HTTP 响应看起来与请求类似，由三个主要部分组成：状态、标题和正文。然而，与请求一样，根据响应的类型，它可能没有正文。第一个响应示例是一个简单的成功响应：
- en: '[PRE8]'
  id: totrans-104
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'The first line contains the HTTP version, a numeric status code (`200`), and
    then a text description of what the code means (`OK`—the request was a success).
    We''ll show some more statuses after the next example. Lines 2 to 5 contain headers,
    similar to a request. Some headers you have seen before; we will explain them
    all in this context:'
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 第一行包含HTTP版本、数字状态码（`200`）以及状态码的文本描述（`OK`——请求成功）。在下一个示例之后，我们将展示更多状态。第2行到第5行包含标题，类似于请求。您之前已经看到一些标题；我们将在这种情况下解释所有这些标题：
- en: '`Server`: This is similar to but the opposite of the `User-Agent` header: this
    is the server telling the client what software it is running.'
  id: totrans-106
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Server`：这与`User-Agent`标题类似，但相反：这是服务器告诉客户端它正在运行什么软件。'
- en: '`Content-Length`: The client uses this value to determine how much data to
    read from the server to get the body.'
  id: totrans-107
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Content-Length`：客户端使用此值来确定从服务器读取多少数据以获取主体。'
- en: '`Content-Type`: The server uses this header to indicate to the client what
    type of data it is sending. The client can then choose how it will display the
    data—an image must be displayed differently to HTML, for example.'
  id: totrans-108
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Content-Type`：服务器使用此标题向客户端指示发送的数据类型。客户端可以选择如何显示数据——例如，图像必须以与HTML不同的方式显示。'
- en: '`Set-Cookie`: We saw in the first request example how a client sends a cookie
    to the server. This is the corresponding header that a server sends to set that
    cookie in the browser.'
  id: totrans-109
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Set-Cookie`：我们在第一个请求示例中看到客户端如何向服务器发送cookie。这是服务器向浏览器设置该cookie的相应标题。'
- en: After the headers is a blank line, and then the body of the response. We haven't
    shown it all here, just the first few characters of the HTML that is being received,
    out of the 18,132 that the server has sent.
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 在标题之后是一个空行，然后是响应的主体。我们在这里没有展示全部内容，只是展示了接收到的HTML的前几个字符，而服务器共发送了18,132个字符。
- en: 'Next, we''ll show an example of a response that is returned if a requested
    page is not found:'
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们将展示一个示例，说明如果请求的页面未找到时返回的响应：
- en: '[PRE9]'
  id: totrans-112
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'It is similar to the previous example, but the status is now `404 Not Found`.
    If you''ve ever been browsing the internet and received a `404` error, this is
    the type of response your browser received. The various status codes are grouped
    by the type of success or failure they indicate:'
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 这与上一个示例类似，但状态现在是`404 未找到`。如果您曾经在网上浏览并收到`404`错误，那么这就是您的浏览器收到的响应类型。各种状态码根据它们指示的成功或失败类型分组：
- en: '**100-199**: The server sends codes in this range to indicate protocol changes
    or that more data is required. You don''t have to worry about these.'
  id: totrans-114
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**100-199**：服务器发送此范围内的代码以指示协议更改或需要更多数据。您不必担心这些问题。'
- en: '`200 OK`.'
  id: totrans-115
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`200 OK`。'
- en: '`301 Moved Permanently` or `302 Found`. When sending a redirect response, the
    server will also include a `Location` header that contains the URL that should
    be redirected to.'
  id: totrans-116
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`301 永久移动`或`302 找到`。在发送重定向响应时，服务器还会包括一个包含应重定向到的URL的`Location`标题。'
- en: '`401 Unauthorized` (the client should log in) and `403 Forbidden` (the client
    is not allowed to access the specific resource). Both problems could be avoided
    by having the client login, hence them being considered client-side (request) problems.'
  id: totrans-117
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`401 未授权`（客户端应登录）和`403 禁止访问`（客户端不允许访问特定资源）。这两个问题可以通过让客户端登录来避免，因此它们被认为是客户端（请求）问题。'
- en: '`500 Internal Server Error`. This will be generated if your code raises an
    exception. Another common one is `504 Gateway Timeout`, which might occur if your
    code is taking too long to run. The other variants that are common to see are
    `502 Bad Gateway` and `503 Service Unavailable`, which generally mean there is
    a problem with your application''s hosting in some way.'
  id: totrans-118
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`500 内部服务器错误`。如果您的代码抛出异常，将会生成此错误。另一个常见的是`504 网关超时`，这可能会发生在您的代码运行时间过长的情况下。其他常见的变体包括`502
    网关错误`和`503 服务不可用`，这通常意味着您的应用程序托管存在问题。'
- en: These are only some of the most common HTTP statuses. You can find a more complete
    list at [https://developer.mozilla.org/en-US/docs/Web/HTTP/Status](https://developer.mozilla.org/en-US/docs/Web/HTTP/Status).
    Like HTTP headers, though, statuses are arbitrary, and an application can return
    custom statuses. It is up to the server and clients to decide what these custom
    statuses and codes mean.
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 这些只是最常见的HTTP状态之一。您可以在[https://developer.mozilla.org/en-US/docs/Web/HTTP/Status](https://developer.mozilla.org/en-US/docs/Web/HTTP/Status)找到更完整的列表。然而，与HTTP标题一样，状态是任意的，应用程序可以返回自定义状态。这取决于服务器和客户端来决定这些自定义状态和代码的含义。
- en: If this is your first time being introduced to the HTTP protocol, there's quite
    a lot of information to take in. Luckily, Django does all the hard work and encapsulates
    the incoming data into an `HttpRequest` object. Most of the time, you don't need
    to know about most of the information coming in, but it's available if you need
    it. Likewise, when sending a response, Django encapsulates your data in an `HttpResponse`
    object. Normally you just set the content to return, but you also have the freedom
    to set HTTP status codes and headers. We will discuss how to access and set the
    information in `HttpRequest` and `HttpResponse` later in this chapter.
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你第一次接触 HTTP 协议，有很多信息需要吸收。幸运的是，Django 做了所有艰苦的工作，并将传入的数据封装到 `HttpRequest` 对象中。大多数时候，你不需要了解大部分传入的信息，但如果你需要，这些信息都是可用的。同样，在发送响应时，Django
    将你的数据封装到 `HttpResponse` 对象中。通常你只需设置要返回的内容，但你也可以自由地设置 HTTP 状态码和头信息。我们将在本章后面讨论如何访问和设置
    `HttpRequest` 和 `HttpResponse` 中的信息。
- en: Processing a Request
  id: totrans-121
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 处理请求
- en: This is a basic timeline of the request and response flows, so you can get an
    idea of what the code you'll be writing does at each stage. In terms of writing
    code, the first part you will write is your view. The view you create will perform
    some actions, such as querying the database for data. Then the view will pass
    this data to another function to render a template, finally returning the `HttpResponse`
    object encompassing the data you want to send back to the client.
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一个请求和响应流程的基本时间线，这样你可以了解你将在每个阶段编写的代码做什么。在编写代码方面，你将首先编写的是你的视图。你创建的视图将执行一些操作，例如查询数据库以获取数据。然后视图将把数据传递给另一个函数以渲染模板，最后返回包含你想要发送回客户端的数据的
    `HttpResponse` 对象。
- en: Next, Django needs to know how to map a specific URL to your view, so that it
    can load the correct view for the URL it receives as part of a request. You will
    write this URL mapping in a URL configuration Python file.
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，Django 需要知道如何将特定的 URL 映射到你的视图，以便它可以加载请求中作为请求一部分的 URL 的正确视图。你将在 URL 配置 Python
    文件中编写这个 URL 映射。
- en: 'When Django receives a request, it parses the URL config file, then finds the
    corresponding view. It calls the view, passing in an `HttpRequest` object representing
    the request. Your view will return its `HttpResponse`, then Django takes over
    again to send this data to its host web server and back out to the client that
    requested it:'
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 当 Django 接收到一个请求时，它会解析 URL 配置文件，然后找到相应的视图。它调用视图，传入一个代表请求的 `HttpRequest` 对象。你的视图将返回其
    `HttpResponse`，然后 Django 再次接管，将数据发送到其宿主 Web 服务器，并返回给请求它的客户端：
- en: '![Figure 1.7: Request and response flow'
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: '![图 1.7：请求和响应流程'
- en: '](img/B15509_01_07.jpg)'
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: '![图片 B15509_01_07.jpg]'
- en: 'Figure 1.7: Request and response flow'
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: '![图 1.7：请求和响应流程]'
- en: The request-response flow is illustrated in *Figure 1.7*; the sections indicated
    as *Your Code* are code that you write—the first and last steps are taken care
    of by Django. Django does the URL matching for you, calls your view code, then
    handles passing the response back to the client.
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 请求-响应流程如图 *图 1.7* 所示；标记为 *你的代码* 的部分是你编写的代码——第一个和最后一步由 Django 处理。Django 为你进行
    URL 匹配，调用你的视图代码，然后处理将响应传递回客户端。
- en: Django Project
  id: totrans-129
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: Django 项目
- en: 'We already introduced Django projects in a previous section. To remind ourselves
    of what happens when we run `startproject` (for a project named `myproject`):
    the command creates a `myproject` directory with a file called `manage.py`, and
    a directory called `myproject` (this matches the project name, in *Exercise 1.01*,
    *Creating a Project and App, and Starting the Dev Server*; this folder was called
    `bookr`, the same as the project). The directory layout is shown in *Figure 1.8*.
    We''ll now examine the `manage.py` file and the `myproject` package contents in
    more detail:'
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在前面一个章节中已经介绍了 Django 项目。为了提醒自己运行 `startproject`（对于名为 `myproject` 的项目）时会发生什么：该命令创建一个名为
    `myproject` 的目录，其中包含一个名为 `manage.py` 的文件，以及一个名为 `myproject` 的目录（这与项目名称匹配，在 *练习
    1.01*，*创建项目和应用程序，并启动开发服务器* 中；这个文件夹被命名为 `bookr`，与项目名称相同）。目录布局如图 *图 1.8* 所示。我们现在将更详细地检查
    `manage.py` 文件和 `myproject` 包的内容：
- en: '![Figure 1.8: Project directory for myproject'
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: '![图 1.8：myproject 项目目录]'
- en: '](img/B15509_01_08.jpg)'
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: '![图片 B15509_01_08.jpg]'
- en: 'Figure 1.8: Project directory for myproject'
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: '![图 1.8：myproject 项目目录]'
- en: '**manage.py**'
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: '**manage.py**'
- en: 'As the name suggests, this is a script that is used to manage your Django project.
    Most of the commands that are used to interact with your project will be supplied
    to this script on the command line. The commands are supplied as an argument to
    this script; for example, if we say to run the `manage.py runserver` command,
    we would mean running the `manage.py` script like this:'
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 如其名所示，这是一个用于管理您的Django项目的脚本。您与项目交互的大多数命令将通过命令行提供给此脚本。命令作为参数传递给此脚本；例如，如果我们说要运行`manage.py
    runserver`命令，我们的意思是以这种方式运行`manage.py`脚本：
- en: '[PRE10]'
  id: totrans-136
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'There are a number of useful commands that `manage.py` provides. You will be
    introduced to them in more detail throughout the book; some of the more common
    ones are listed here:'
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: '`manage.py`提供了许多有用的命令。您将在本书的后续章节中详细了解它们；其中一些更常见的命令在此列出：'
- en: '`runserver`: Starts the Django development HTTP server, to serve your Django
    app on your local computer.'
  id: totrans-138
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`runserver`：启动Django开发HTTP服务器，在您的本地计算机上提供Django应用。'
- en: '`startapp`: Creates a new Django app in your project. We''ll talk about what
    apps are in more depth soon.'
  id: totrans-139
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`startapp`：在您的项目中创建一个新的Django应用。我们将在稍后更深入地讨论应用是什么。'
- en: '`shell`: Starts a Python interpreter with the Django settings pre-loaded. This
    is useful for interacting with your application without having to manually load
    in your Django settings.'
  id: totrans-140
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`shell`：启动一个预加载Django设置的Python解释器。这对于在不手动加载Django设置的情况下与您的应用程序交互非常有用。'
- en: '`dbshell`: Starts an interactive shell connected to your database, using the
    default parameters from your Django settings. You can run manual SQL queries in
    this way.'
  id: totrans-141
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`dbshell`：启动一个连接到您的数据库的交互式shell，使用Django设置中的默认参数。您可以通过这种方式运行手动SQL查询。'
- en: '`makemigrations`: Generate database change instructions from your model definitions.
    You will learn what this means and how to use this command in *Chapter 2*, *Models
    and Migrations*.'
  id: totrans-142
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`makemigrations`：从您的模型定义生成数据库更改指令。您将在*第2章*，*模型和迁移*中了解这意味着什么以及如何使用此命令。'
- en: '`migrate`: Applies migrations generated by the `makemigrations` command. You
    will use this in *Chapter 2*, *Models and Migrations*, as well.'
  id: totrans-143
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`migrate`：应用由`makemigrations`命令生成的迁移。您也将在*第2章*，*模型和迁移*中使用此命令。'
- en: '`test`: Run automated tests that you have written. You''ll use this command
    in *Chapter 14*, *Testing*.'
  id: totrans-144
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`test`：运行您编写的自动化测试。您将在*第14章*，*测试*中使用此命令。'
- en: A full list of all commands is available at [https://docs.djangoproject.com/en/3.0/ref/django-admin/](https://docs.djangoproject.com/en/3.0/ref/django-admin/).
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 所有命令的完整列表可在[https://docs.djangoproject.com/en/3.0/ref/django-admin/](https://docs.djangoproject.com/en/3.0/ref/django-admin/)找到。
- en: The myproject Directory
  id: totrans-146
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '`myproject`目录'
- en: 'Moving on from the `manage.py` file, the other file item created by `startproject`
    is the `myproject` directory. This is the actual Python package for your project.
    It contains settings for the project, some configuration files for your web server,
    and the global URL maps. Inside the `myproject` directory are five files:'
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 从`manage.py`文件继续，`startproject`创建的另一个文件项是`myproject`目录。这是您的项目的实际Python包。它包含项目设置，一些用于您的Web服务器的配置文件，以及全局URL映射。在`myproject`目录内包含五个文件：
- en: '`__init__.py`'
  id: totrans-148
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`__init__.py`'
- en: '`asgi.py`'
  id: totrans-149
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`asgi.py`'
- en: '`settings.py`'
  id: totrans-150
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`settings.py`'
- en: '`urls.py`'
  id: totrans-151
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`urls.py`'
- en: '`wsgi.py`![Figure 1.9: The myproject package (inside the myproject project
    directory)'
  id: totrans-152
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`wsgi.py`![Figure 1.9: The myproject package (inside the myproject project
    directory)]'
- en: '](img/B15509_01_09.jpg)'
  id: totrans-153
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '![Figure 1.9: The myproject package (inside the myproject project directory)]'
- en: 'Figure 1.9: The myproject package (inside the myproject project directory)'
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 图1.9：myproject包（位于myproject项目目录内）
- en: '`__init__.py`'
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: '`__init__.py`'
- en: An empty file that lets Python know that the `myproject` directory is a Python
    module. You'll be familiar with these files if you've worked with Python before.
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 一个空文件，让Python知道`myproject`目录是一个Python模块。如果您之前使用过Python，您会熟悉这些文件。
- en: '`settings.py`'
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: '`settings.py`'
- en: This contains all the Django settings for your application. We will explain
    the contents soon.
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 这包含您应用程序的所有Django设置。我们将在稍后解释其内容。
- en: '`urls.py`'
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: '`urls.py`'
- en: This has the global URL mappings that Django will initially use to locate views
    or other child URL mappings. You will add a URL map to this file soon.
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 这包含Django将最初用于定位视图或其他子URL映射的全局URL映射。您很快就会向此文件添加URL映射。
- en: '`asgi.py` and `wsgi.py`'
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: '`asgi.py`和`wsgi.py`'
- en: These files are what ASGI or WSGI web servers use to communicate with your Django
    app when you deploy it to a production web server. You normally don't need to
    edit these at all, and they aren't used in day-to-day development. Their use will
    be discussed more in *Chapter 17*, *Deployment of a Django Application*.
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 这些文件是 ASGI 或 WSGI 网络服务器在将你的 Django 应用部署到生产网络服务器时用来与你的 Django 应用通信的。你通常不需要编辑这些文件，它们在日常开发中也不被使用。它们的使用将在
    *第 17 章*，*Django 应用程序的部署* 中进一步讨论。
- en: Django Development Server
  id: totrans-163
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: Django 开发服务器
- en: You have already started the Django dev server in *Exercise 1.01*, *Creating
    a Project and App, and Starting the Dev Server*. As we mentioned previously, it
    is a web server intended to only be run on the developer's machine during development.
    It is not intended for use in production.
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 你已经在 *练习 1.01* 中启动了 Django 开发服务器，即 *创建项目和应用程序，并启动开发服务器*。正如我们之前提到的，这是一个仅在开发期间运行在开发者机器上的网络服务器。它不适用于生产环境。
- en: 'By default, the server listens on port `8000` on `localhost (127.0.0.1)`, but
    this can be changed by adding a port number or address and port number after the
    `runserver` argument:'
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 默认情况下，服务器在 `localhost (127.0.0.1)` 的端口 `8000` 上监听，但可以通过在 `runserver` 参数后添加端口号或地址和端口号来更改此设置：
- en: '[PRE11]'
  id: totrans-166
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: This will have the server listen on port `8001` on `localhost (127.0.0.1)`.
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 服务器将在 `localhost (127.0.0.1)` 的端口 `8001` 上监听。
- en: 'You can also have it listen on a specific address if your computer has more
    than one, or `0.0.0.0` for all addresses:'
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你的电脑有多个地址，你也可以让它监听特定的地址，或者对所有地址使用 `0.0.0.0`：
- en: '[PRE12]'
  id: totrans-169
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: This will have the server listen on all your computer's addresses on port `8000`,
    which can be useful if you want to test your application from another computer
    or your smartphone.
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 服务器将在所有电脑的地址上监听端口 `8000`，如果你想在另一台电脑或你的智能手机上测试应用程序，这可能会很有用。
- en: The development server watches your Django project directory and will restart
    automatically every time you save a file so that any code changes you make are
    automatically reloaded into the server. You still have to manually refresh your
    browser to see changes there, though.
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 开发服务器会监视你的 Django 项目目录，每次你保存文件时都会自动重启，这样你做的任何代码更改都会自动重新加载到服务器中。尽管如此，你仍然需要手动刷新浏览器来查看更改。
- en: 'When you want to stop the `runserver` command, it can be done in the usual
    way for stopping processes in the Terminal: by using the *Ctrl* + *C* key combination.'
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 当你想停止 `runserver` 命令时，可以在终端中按照停止进程的常规方式操作：通过使用 *Ctrl* + *C* 键组合。
- en: Django Apps
  id: totrans-173
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: Django 应用
- en: Now that we've covered a bit of theory about apps, we can be more specific about
    their purpose. An app directory contains all the models, views, and templates
    (and more) that they need to provide application functionality. A Django project
    will contain at least one app (unless it has been heavily customized to not rely
    on a lot of Django functionality). If well designed, an app should be able to
    be removed from a project and moved to another project without modification. Usually,
    an app will contain models for a single design domain, and this can be a useful
    way of determining whether your app should be split into multiple apps.
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经介绍了一些关于应用的理论，我们可以更具体地讨论它们的目的。应用目录包含所有必要的模型、视图、模板（以及更多）以提供应用程序功能。Django
    项目至少包含一个应用（除非它已经被高度定制，不依赖于大量的 Django 功能）。如果设计得当，一个应用应该能够从项目中移除并移动到另一个项目而无需修改。通常，一个应用将包含单个设计域的模型，这可以是一个有用的方法来确定你的应用是否应该拆分为多个应用。
- en: 'Your app can have any name as long as it is a valid Python module name (that
    is, using only letters, numbers, and underscores) and does not conflict with other
    files in your project directory. For example, as we have seen, there is already
    a directory called `myproject` in the project directory (containing the `settings.py`
    file), so you could not have an app called `myproject`. As we saw in *Exercise
    1.01*, *Creating a Project and App, and Starting the Dev Server*, creating an
    app uses the `manage.py startapp appname` command. For example:'
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 你的应用可以有任何名称，只要它是有效的 Python 模块名称（即，只使用字母、数字和下划线）并且不与项目目录中的其他文件冲突。例如，正如我们所看到的，项目目录中已经有一个名为
    `myproject` 的目录（包含 `settings.py` 文件），因此你不能有一个名为 `myproject` 的应用。正如我们在 *练习 1.01*，*创建项目和应用程序，并启动开发服务器*
    中所看到的，创建应用使用 `manage.py startapp appname` 命令。例如：
- en: '[PRE13]'
  id: totrans-176
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'The `startapp` command creates a directory within your project with the name
    of the app specified. It also scaffolds files for the app. Inside the `app` directory
    are several files and a folder, as shown in *Figure 1.10*:'
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: '`startapp` 命令在你的项目目录中创建一个以应用程序命名的目录。它还会为应用程序生成文件框架。在 `app` 目录中包含几个文件和一个文件夹，如图
    1.10 所示：'
- en: '![Figure 1.10: The contents of the myapp app directory'
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: '![图 1.10: myapp 应用程序目录的内容'
- en: '](img/B15509_01_10.jpg)'
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: '![img/B15509_01_10.jpg]'
- en: 'Figure 1.10: The contents of the myapp app directory'
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: '图 1.10: myapp 应用程序目录的内容'
- en: '`__init.py__`: An empty file indicating that this directory is a Python module.'
  id: totrans-181
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`__init__.py`: 一个空文件，表示这个目录是一个 Python 模块。'
- en: '`admin.py`: Django has a built-in admin site for viewing and editing data with
    a Graphical User Interface (GUI). In this file, you will define how your app''s
    models are exposed in the Django admin site. We''ll cover this in more detail
    in *Chapter 4*, *Introduction to Django Admin*.'
  id: totrans-182
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`admin.py`: Django 内置了一个具有图形用户界面 (GUI) 的管理站点，用于查看和编辑数据。在这个文件中，你将定义你的应用程序模型如何在
    Django 管理站点中暴露。我们将在第 4 章 *Django 管理介绍* 中更详细地讲解。'
- en: '`apps.py`: This contains some configuration for the metadata of your app. You
    won''t need to edit this file.'
  id: totrans-183
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`apps.py`: 这包含了一些关于你的应用程序元数据的配置。你不需要编辑这个文件。'
- en: '`models.py`: This is where you will define the models for your application.
    You''ll read about this in more detail in *Chapter 2*, *Models and Migrations*.'
  id: totrans-184
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`models.py`: 这是你定义应用程序模型的地方。你将在第 2 章 *模型和迁移* 中更详细地了解。'
- en: '`migrations`: Django uses migration files to automatically record changes to
    your underlying database as the models change. They are generated by Django when
    you run the `manage.py makemigrations` command and are stored in this directory.
    They do not get applied to the database until you run `manage.py migrate`. They
    will be also be covered in *Chapter 2*, *Models and Migrations*.'
  id: totrans-185
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`migrations`: Django 使用迁移文件来自动记录模型变化时底层数据库的变化。这些文件在运行 `manage.py makemigrations`
    命令时由 Django 生成，并存储在这个目录中。它们只有在运行 `manage.py migrate` 命令后才会应用到数据库中。它们将在第 2 章 *模型和迁移*
    中详细讲解。'
- en: '`tests.py`: To test that your code is behaving correctly, Django supports writing
    tests (unit, functional, or integration) and will look for them inside this file.
    We will write some tests throughout this book and cover testing in detail in *Chapter 14*,
    *Testing*.'
  id: totrans-186
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`tests.py`: 为了测试你的代码是否运行正确，Django 支持编写测试（单元、功能或集成）并将它们放在这个文件中。本书中我们将编写一些测试，并在第
    14 章 *测试* 中详细讲解。'
- en: '`views.py`: Your Django views (the code that responds to HTTP requests) will
    go in here. You will create a basic view soon, and views will be covered in more
    detail in *Chapter 3*, *URL Mapping, Views, and Templates*.'
  id: totrans-187
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`views.py`: 你的 Django 视图（响应 HTTP 请求的代码）将放在这里。你将很快创建一个基本视图，视图将在第 3 章 *URL 映射、视图和模板*
    中详细讲解。'
- en: We will examine the contents of these files more later, but for now, we'll get
    Django up and running in our second exercise.
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将在稍后更详细地检查这些文件的内容，但现在，我们将通过第二个练习来让 Django 在我们的环境中运行起来。
- en: PyCharm Setup
  id: totrans-189
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: PyCharm 设置
- en: We confirmed in *Exercise 1.01*, *Creating a Project and App, and Starting the
    Dev Server*, that the Bookr project has been set up properly (since the dev server
    runs successfully), so we can now start using **PyCharm** to run and edit our
    project. PyCharm is an IDE for Python development, and it includes features such
    as code completion, automatic style formatting, and a built-in debugger. We will
    then use PyCharm to start writing our URL maps, views, and templates. It will
    also be used to start and stop the development server, which will allow the debugging
    of our code by setting breakpoints.
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: 在 *练习 1.01*，*创建项目和应用程序，并启动开发服务器* 中，我们确认了 Bookr 项目已经正确设置（因为开发服务器运行成功），因此我们现在可以使用
    **PyCharm** 来运行和编辑我们的项目。PyCharm 是一个 Python 开发 IDE，它包括代码补全、自动格式化风格和内置调试器等功能。然后我们将使用
    PyCharm 来编写我们的 URL 映射、视图和模板。它还将用于启动和停止开发服务器，这将允许我们通过设置断点来调试我们的代码。
- en: 'Exercise 1.02: Project Setup in PyCharm'
  id: totrans-191
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: '练习 1.02: 在 PyCharm 中设置项目'
- en: 'In this exercise, we will open the Bookr project in PyCharm and set up the
    project interpreter so that PyCharm can run and debug the project:'
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个练习中，我们将打开 PyCharm 中的 Bookr 项目，并设置项目解释器，以便 PyCharm 可以运行和调试项目：
- en: 'Open PyCharm. When you first open PyCharm, you will be shown the `Welcome to
    PyCharm` screen, which asks you what you want to do:![Figure 1.11: PyCharm welcome
    screen'
  id: totrans-193
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '打开 PyCharm。当你第一次打开 PyCharm 时，你会看到 `欢迎使用 PyCharm` 界面，它会询问你想要做什么：![图 1.11: PyCharm
    欢迎界面'
- en: '](img/B15509_01_11.jpg)'
  id: totrans-194
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '![img/B15509_01_11.jpg]'
- en: 'Figure 1.11: PyCharm welcome screen'
  id: totrans-195
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '图 1.11: PyCharm 欢迎界面'
- en: Click `Open`, then browse to the `bookr` project you just created, then open
    it. Make sure you are opening the `bookr` project directory and not the `bookr`
    package directory inside.
  id: totrans-196
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 点击 `打开`，然后浏览到您刚刚创建的 `bookr` 项目，然后打开它。请确保您打开的是 `bookr` 项目目录，而不是 `bookr` 包目录内部。
- en: 'If you haven''t used PyCharm before, it will ask you about what settings and
    themes you want to use, and once you have answered all those questions, you will
    see your `bookr` project structure open in the `Project` pane on the left of the
    window:'
  id: totrans-197
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 如果您之前没有使用过 PyCharm，它将询问您想要使用哪些设置和主题，一旦您回答了所有这些问题，您将看到 `bookr` 项目结构在窗口左侧的 `项目`
    窗格中打开：
- en: '![Figure 1.12: PyCharm Project pane'
  id: totrans-198
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '![图 1.12：PyCharm 项目窗格'
- en: '](img/B15509_01_12.jpg)'
  id: totrans-199
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '![img/B15509_01_12.jpg](img/B15509_01_12.jpg)'
- en: 'Figure 1.12: PyCharm Project pane'
  id: totrans-200
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 图 1.12：PyCharm 项目窗格
- en: Your `Project` pane should look like *Figure 1.12* and show the `bookr` and
    `reviews` directories, and the `manage.py` file. If you do not see these and instead
    see `asgi.py`, `settings.py`, `urls.py`, and `wsgi.py`, then you have opened the
    `bookr` package directory instead. Select `File` -> `Open`, then browse and open
    the `bookr` project directory.
  id: totrans-201
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 您的 `项目` 窗格应该看起来像 *图 1.12* 并显示 `bookr` 和 `reviews` 目录，以及 `manage.py` 文件。如果您没有看到这些，而是看到
    `asgi.py`、`settings.py`、`urls.py` 和 `wsgi.py`，那么您已经打开了 `bookr` 包目录。选择 `文件` ->
    `打开`，然后浏览并打开 `bookr` 项目目录。
- en: Before PyCharm knows how to execute your project to start the Django dev server,
    the interpreter must be set to the Python binary inside your virtual environment.
    This is done first by adding the interpreter to the global interpreter settings.
  id: totrans-202
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 在 PyCharm 知道如何执行您的项目以启动 Django 开发服务器之前，解释器必须设置为虚拟环境中的 Python 二进制文件。这是通过首先将解释器添加到全局解释器设置来完成的。
- en: Open the `Preferences` (macOS) or `Settings` (Windows/Linux) window inside PyCharm.
  id: totrans-203
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 PyCharm 中打开 `首选项`（macOS）或 `设置`（Windows/Linux）窗口。
- en: 'macOS:'
  id: totrans-204
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: macOS：
- en: '`PyCharm Menu` -> `Preferences`'
  id: totrans-205
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '`PyCharm 菜单` -> `首选项`'
- en: 'Windows and Linux:'
  id: totrans-206
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: Windows 和 Linux：
- en: '`File` -> `Settings`'
  id: totrans-207
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '`文件` -> `设置`'
- en: 'In the preferences list pane on the left, open the `Project: bookr` item, then
    click `Project Interpreter`:![Figure 1.13: Project interpreter settings'
  id: totrans-208
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '在左侧的偏好设置列表窗格中，打开 `项目: bookr` 项，然后点击 `项目解释器`：![图 1.13：项目解释器设置'
- en: '](img/B15509_01_13.jpg)'
  id: totrans-209
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '![img/B15509_01_13.jpg](img/B15509_01_13.jpg)'
- en: 'Figure 1.13: Project interpreter settings'
  id: totrans-210
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 图 1.13：项目解释器设置
- en: Sometimes PyCharm can automatically determine virtual environments, so in this
    case, `Project Interpreter` may already be populated with the correct interpreter.
    If it is, and you see Django in the list of packages, you can click `OK` to close
    the window and complete this exercise.
  id: totrans-211
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 有时 PyCharm 可以自动确定虚拟环境，因此在这种情况下，`项目解释器` 可能已经填充了正确的解释器。如果是这样，并且您在包列表中看到 Django，您可以点击
    `确定` 关闭窗口并完成此练习。
- en: In most cases, though, the Python interpreter must be set manually. Click the
    cog icon next to the `Project Interpreter` dropdown, then click `Add…`.
  id: totrans-212
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 然而，在大多数情况下，必须手动设置 Python 解释器。点击 `项目解释器` 下拉菜单旁边的齿轮图标，然后点击 `添加…`。
- en: 'The `Add Python Interpreter` window is now displayed. Select the `Existing
    environment` radio button and then click the ellipses (`…`) next to the `Interpreter`
    dropdown. You should then browse and select the Python interpreter for your virtual
    environment:![Figure 1.14: The Add Python Interpreter window'
  id: totrans-213
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在显示 `添加 Python 解释器` 窗口。选择 `现有环境` 单选按钮，然后点击 `解释器` 下拉菜单旁边的省略号 (`…`)。然后您应该浏览并选择虚拟环境中的
    Python 解释器：![图 1.14：添加 Python 解释器窗口
- en: '](img/B15509_01_14.jpg)'
  id: totrans-214
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '![img/B15509_01_14.jpg](img/B15509_01_14.jpg)'
- en: 'Figure 1.14: The Add Python Interpreter window'
  id: totrans-215
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 图 1.14：添加 Python 解释器窗口
- en: On macOS (assuming you called the virtual environment `bookr`), the path is
    usually `/Users/<yourusername>/.virtualenvs/bookr/bin/python3`. Similarly, in
    Linux, it should be `/home/<yourusername>/.virtualenvs/bookr/bin/python3`.
  id: totrans-216
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 macOS 上（假设您将虚拟环境命名为 `bookr`），路径通常是 `/Users/<您的用户名>/.virtualenvs/bookr/bin/python3`。同样，在
    Linux 上，它应该是 `/home/<您的用户名>/.virtualenvs/bookr/bin/python3`。
- en: 'If you''re unsure, you can run the `which python3` command in the Terminal
    where you previously ran the `python manage.py` command and it will tell you the
    path to the Python interpreter:'
  id: totrans-217
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 如果您不确定，您可以在之前运行 `python manage.py` 命令的终端中运行 `which python3` 命令，它将告诉您 Python
    解释器的路径：
- en: '[PRE14]'
  id: totrans-218
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE14]'
- en: On Windows, it will be wherever you created your virtual environment with the
    `virtualenv` command.
  id: totrans-219
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 在 Windows 上，它将是您使用 `virtualenv` 命令创建虚拟环境的位置。
- en: After selecting the interpreter, your `Add Python Interpreter` window should
    look like *Figure 1.14*.
  id: totrans-220
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 选择解释器后，您的 `添加 Python 解释器` 窗口应该看起来像 *图 1.14*。
- en: Click `OK` to close the `Add Python interpreter` window.
  id: totrans-221
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 点击 `确定` 关闭 `添加 Python 解释器` 窗口。
- en: 'You should now see the main preferences window, and Django (and other packages
    in your virtual environment) will be listed (see *Figure 1.15*):![Figure 1.15:
    Packages in the virtual environment are listed'
  id: totrans-222
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在你应该能看到主偏好设置窗口，Django（以及你虚拟环境中的其他包）将被列出（见 *图 1.15*）：![图 1.15：虚拟环境中的包列表
- en: '](img/B15509_01_15.jpg)'
  id: totrans-223
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '](img/B15509_01_15.jpg)'
- en: 'Figure 1.15: Packages in the virtual environment are listed'
  id: totrans-224
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 图 1.15：虚拟环境中的包列表
- en: Click `OK` in the main `Preferences` window to close it. PyCharm will now take
    a few seconds to index your environment and the libraries installed. You can see
    the process in its bottom-right status bar. Wait for this process to finish and
    the progress bar will disappear.
  id: totrans-225
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在主 `偏好设置` 窗口中点击 `OK` 以关闭它。PyCharm 现在将花费几秒钟来索引你的环境和已安装的库。你可以在其底部的状态栏中看到这个过程。等待此过程完成，进度条将消失。
- en: To run the Django dev server, Python needs to be configured with a run configuration.
    You will set this up now.
  id: totrans-226
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 要运行 Django 开发服务器，Python 需要配置一个运行配置。你现在将设置它。
- en: 'Click `Add Configuration…` in the top right of the PyCharm project window,
    to open the `Run/Debug Configuration` window:'
  id: totrans-227
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 点击 PyCharm 项目窗口右上角的 `添加配置…` 以打开 `运行/调试配置` 窗口：
- en: '![Figure 1.16: The Add Configuration… button in the top right of the PyCharm
    window'
  id: totrans-228
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '![图 1.16：PyCharm 窗口右上角的“添加配置…”按钮'
- en: '](img/B15509_01_16.jpg)'
  id: totrans-229
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '](img/B15509_01_16.jpg)'
- en: 'Figure 1.16: The Add Configuration… button in the top right of the PyCharm
    window'
  id: totrans-230
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 图 1.16：PyCharm 窗口右上角的“添加配置…”按钮
- en: 'Click the `+` button in the top left of this window and select `Python` from
    the dropdown menu:![Figure 1.17: Adding a new Python configuration in the Run/Debug
    Configuration window'
  id: totrans-231
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在此窗口的左上角点击 `+` 按钮，从下拉菜单中选择 `Python`：![图 1.17：在运行/调试配置窗口中添加新的 Python 配置
- en: '](img/B15509_01_17.jpg)'
  id: totrans-232
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '](img/B15509_01_17.jpg)'
- en: 'Figure 1.17: Adding a new Python configuration in the Run/Debug Configuration
    window'
  id: totrans-233
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 图 1.17：在运行/调试配置窗口中添加新的 Python 配置
- en: A new configuration panel with fields regarding how to run your project will
    display on the right of the window. You should fill out the fields as follows.
  id: totrans-234
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 一个新的配置面板将在窗口的右侧显示，其中包含有关如何运行你的项目的字段。你应该按照以下方式填写字段。
- en: The `Name` field can be anything but should be understandable. Enter `Django
    Dev Server`.
  id: totrans-235
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '`名称` 字段可以是任何内容，但应该是可理解的。输入 `Django Dev Server`。'
- en: '`Script Path` is the path to your `manage.py` file. If you click the folder
    icon in this field, you can browse your filesystem to select the `manage.py` file
    inside the `bookr` project directory.'
  id: totrans-236
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '`脚本路径` 是你的 `manage.py` 文件的路径。如果你点击此字段中的文件夹图标，你可以浏览你的文件系统来选择 `bookr` 项目目录中的
    `manage.py` 文件。'
- en: '`Parameters` are the arguments that come after the `manage.py` script, the
    same as if running it from the command line. We will use the same argument here
    to start the server, so enter `runserver`.'
  id: totrans-237
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '`参数` 是在 `manage.py` 脚本之后出现的参数，就像从命令行运行它一样。我们将在这里使用相同的参数来启动服务器，所以输入 `runserver`。'
- en: Note
  id: totrans-238
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 注意
- en: As mentioned earlier, the `runserver` command can also accept an argument for
    the port or address to listen to. If you want to, you can add this argument after
    `runserver` in the same `Parameters` field.
  id: totrans-239
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 如前所述，`runserver` 命令也可以接受一个用于监听端口或地址的参数。如果你想，你可以在相同的 `参数` 字段中添加此参数在 `runserver`
    之后。
- en: The `Python interpreter` setting should have been automatically set to the one
    that was set in *steps 5* to *8*. If not, you can click the arrow dropdown on
    the right to select it.
  id: totrans-240
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '`Python 解释器` 设置应该已经自动设置为在 *步骤 5* 到 *8* 中设置的设置。如果不是，你可以点击右侧的箭头下拉菜单来选择它。'
- en: '`Working directory` should be set to the `bookr` project directory. This has
    probably already been set correctly.'
  id: totrans-241
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '`工作目录` 应设置为 `bookr` 项目目录。这很可能已经设置正确了。'
- en: '`Add content roots to PYTHONPATH` and `Add source roots to PYTHONPATH` should
    both be checked. This will ensure that PyCharm adds your `bookr` project directory
    to `PYTHONPATH` (the list of paths that the Python interpreter searches when loading
    a module). Without those checked, the imports from your project will not work
    correctly:'
  id: totrans-242
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '`将内容根添加到 PYTHONPATH` 和 `将源根添加到 PYTHONPATH` 都应该被选中。这将确保 PyCharm 将你的 `bookr`
    项目目录添加到 `PYTHONPATH`（Python 解释器在加载模块时搜索的路径列表）。如果没有选中这些选项，你的项目中的导入将无法正确工作：'
- en: '![Figure 1.18: Configuration settings'
  id: totrans-243
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '![图 1.18：配置设置'
- en: '](img/B15509_01_18.jpg)'
  id: totrans-244
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '](img/B15509_01_18.jpg)'
- en: 'Figure 1.18: Configuration settings'
  id: totrans-245
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 图 1.18：配置设置
- en: Ensure that your `Run/Debug configurations` window looks similar to *Figure
    1.18*, then click `OK` to save the configuration.
  id: totrans-246
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 确保你的 `运行/调试配置` 窗口看起来类似于 *图 1.18*，然后点击 `OK` 保存配置。
- en: 'Now, instead of starting the Django dev server in a Terminal, you can click
    the play icon in the top right of the `Project` window to start it (see *Figure
    1.19*):![Figure 1.19: Django dev server configuration with play, debug, and stop
    buttons'
  id: totrans-247
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，你不再需要在终端中启动 Django 开发服务器，而是可以点击 `项目` 窗口右上角的播放图标来启动它（见 *图 1.19*）：![图 1.19：带有播放、调试和停止按钮的
    Django 开发服务器配置
- en: '](img/B15509_01_19.jpg)'
  id: totrans-248
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '![图片](img/B15509_01_19.jpg)'
- en: 'Figure 1.19: Django dev server configuration with play, debug, and stop buttons'
  id: totrans-249
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 图 1.19：带有播放、调试和停止按钮的 Django 开发服务器配置
- en: Click the play icon to start the Django dev server.
  id: totrans-250
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 点击播放图标以启动 Django 开发服务器。
- en: Note
  id: totrans-251
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 注意
- en: Make sure you stop any other instances of the Django dev server that are running
    (such as in a Terminal) otherwise the one you are starting will not be able to
    bind to port `8000` and will fail to start.
  id: totrans-252
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 确保停止任何正在运行的 Django 开发服务器实例（例如在终端中），否则你启动的服务器将无法绑定到端口 `8000` 并无法启动。
- en: 'A console will open at the bottom of the PyCharm window, which will show output
    indicating that the dev server has started (*Figure 1.20*):![Figure 1.20: Console
    with the Django dev server running'
  id: totrans-253
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: PyCharm 窗口的底部将打开一个控制台，显示输出信息，表明开发服务器已启动（*图 1.20*）：![图 1.20：运行中的 Django 开发服务器的控制台
- en: '](img/B15509_01_20.jpg)'
  id: totrans-254
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '![图片](img/B15509_01_20.jpg)'
- en: 'Figure 1.20: Console with the Django dev server running'
  id: totrans-255
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 图 1.20：运行中的 Django 开发服务器的控制台
- en: Open a web browser and navigate to `http://127.0.0.1:8000`. You should see the
    same Django example screen as you did earlier, in *Exercise 1.01*, *Creating a
    Project and App, and Starting the Dev Server* (*Figure 1.2*), which will confirm
    that once again everything is set up correctly.
  id: totrans-256
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 打开一个网页浏览器并导航到 `http://127.0.0.1:8000`。你应该会看到与之前在 *练习 1.01*、*创建项目和应用程序，以及启动开发服务器*
    中相同的 Django 示例屏幕（*图 1.2*），这将确认一切再次设置正确。
- en: In this exercise, we opened the Bookr project in PyCharm, then set the Python
    interpreter for our project. We then added a run configuration in PyCharm, which
    allows us to start and stop the Django dev server from within PyCharm. We will
    also be able to debug our project later by running it inside PyCharm's debugger.
  id: totrans-257
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个练习中，我们在 PyCharm 中打开了 Bookr 项目，然后为我们的项目设置了 Python 解释器。我们接着在 PyCharm 中添加了一个运行配置，这允许我们从
    PyCharm 内部启动和停止 Django 开发服务器。我们还将能够在 PyCharm 的调试器中运行项目以进行调试。
- en: View Details
  id: totrans-258
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 查看详情
- en: You now have everything set up to start writing your own Django views and configure
    the URLs that will map to them. As we saw earlier in this chapter, a view is simply
    a function that takes an `HttpRequest` instance (built by Django) and (optionally)
    some parameters from the URL. It will then do some operations, such as fetching
    data from a database. Finally, it returns `HttpResponse`.
  id: totrans-259
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，你已经设置好了一切，可以开始编写自己的 Django 视图并配置映射到它们的 URL。正如我们在本章前面所看到的，视图只是一个函数，它接受一个 `HttpRequest`
    实例（由 Django 构建）以及（可选的）来自 URL 的某些参数。然后它将执行一些操作，例如从数据库中获取数据。最后，它返回 `HttpResponse`。
- en: 'To use our Bookr app as an example, we might have a view that receives a request
    for a certain book. It queries the database for this book, then returns a response
    containing an HTML page showing information about the book. Another view could
    receive a request to list all the books, then return a response with another HTML
    page containing this list. Views can also create or modify data: another view
    could receive a request to create a new book; it would then add the book to the
    database and return a response with HTML that displays the new book''s information.'
  id: totrans-260
  prefs: []
  type: TYPE_NORMAL
  zh: 以我们的 Bookr 应用程序为例，我们可能有一个视图，它接收对某本书的请求。它查询数据库以获取这本书，然后返回一个包含有关这本书信息的 HTML 页面的响应。另一个视图可以接收列出所有书籍的请求，然后返回包含此列表的另一个
    HTML 页面的响应。视图还可以创建或修改数据：另一个视图可以接收创建新书的请求；然后它会将这本书添加到数据库中，并返回显示新书信息的 HTML 响应。
- en: In this chapter, we will only be using functions as views, but Django also supports
    class-based views, which allow you to leverage object-oriented paradigms (such
    as inheritance). This allows you to simplify code used in multiple views that
    have the same business logic. For example, you might want to show all books or
    just books by a certain publisher. Both views need to query a list of books from
    the database and render them to a book list template. One view class could inherit
    from the other and just implement the data fetching differently and leave the
    rest of the functionality (such as rendering) identical. Class-based views can
    be more powerful but also harder to learn. They will be introduced later, in *Chapter
    11*, *Advanced Templates and Class-Based Views*, when you have more experience
    with Django.
  id: totrans-261
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们只会使用函数作为视图，但Django也支持基于类的视图，这允许你利用面向对象范式（如继承）。这允许你简化多个具有相同业务逻辑的视图所使用的代码。例如，你可能想显示所有书籍或仅显示某个出版商的书籍。两个视图都需要从数据库中查询书籍列表并将其渲染到书籍列表模板中。一个视图类可以继承另一个类，只需实现数据获取的不同方式，其余的功能（如渲染）保持相同。基于类的视图可能更强大，但也更难学习。它们将在你有了更多Django经验后，在*第11章*，*高级模板和基于类的视图*中介绍。
- en: 'The `HttpRequest` instance that is passed to the view contains all the data
    related to the request, with attributes such as these:'
  id: totrans-262
  prefs: []
  type: TYPE_NORMAL
  zh: 传递给视图的`HttpRequest`实例包含与请求相关的所有数据，具有诸如这些属性：
- en: '`method`: A string containing the HTTP method the browser used to request the
    page; usually this is `GET`, but it will be `POST` if the user has submitted a
    form. You can use this to change the flow of the view, for example, show an empty
    form on `GET`, or validate and process a form submission on `POST`.'
  id: totrans-263
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`method`: 一个包含浏览器用于请求页面的HTTP方法的字符串；通常这是`GET`，但如果用户提交了表单，它将是`POST`。你可以使用这个属性来改变视图的流程，例如，在`GET`时显示一个空表单，或者在`POST`时验证并处理表单提交。'
- en: '`GET`: A `QueryDict` instance containing the parameters used in the URL query
    string. This is the part of the URL after the `?`, if it contains one. We go further
    into `QueryDict` soon. Note that this attribute is always available even if the
    request was not `GET`.'
  id: totrans-264
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`GET`: 一个包含URL查询字符串中使用的参数的`QueryDict`实例。这是URL中`?`之后的部分，如果有的话。我们很快会进一步介绍`QueryDict`。请注意，即使请求不是`GET`，此属性也始终可用。'
- en: '`POST`: Another `QueryDict` containing the parameters sent to the view in a
    `POST` request, like from a form submission. Usually, you would use this in conjunction
    with a Django form, which will be covered in *Chapter 6*, *Forms*.'
  id: totrans-265
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`POST`: 另一个包含在`POST`请求中发送到视图的参数的`QueryDict`，例如来自表单提交。通常，你会与Django表单一起使用这个属性，这将在*第6章*，*表单*中介绍。'
- en: '`headers`: A case-insensitive key dictionary with the HTTP headers from the
    request. For example, you could vary the response with different content for different
    browsers based on the `User-Agent` header. We discussed some HTTP headers that
    are sent by the client earlier in this chapter.'
  id: totrans-266
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`headers`: 一个不区分大小写的键字典，包含请求中的HTTP头。例如，你可以根据`User-Agent`头为不同的浏览器提供不同的内容。我们之前在本章中讨论了一些客户端发送的HTTP头。'
- en: '`path`: This is the path used in the request. Normally, you don''t need to
    examine this because Django will automatically parse the path and pass it to view
    function as parameters, but it can be useful in some instances.'
  id: totrans-267
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`path`: 这是请求中使用的路径。通常，你不需要检查这个属性，因为Django会自动解析路径并将其作为参数传递给视图函数，但在某些情况下这可能很有用。'
- en: We won't be using all these attributes yet, and others will be introduced later,
    but you can now see what role the `HttpRequest` argument plays in your view.
  id: totrans-268
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在不会使用所有这些属性，其他属性将在以后介绍，但现在你可以看到`HttpRequest`参数在你的视图中扮演的角色。
- en: URL Mapping Detail
  id: totrans-269
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: URL映射详情
- en: We briefly mentioned URL maps earlier in the *Processing a Request* section.
    Django does not automatically know which view function should be executed when
    it receives a request for a particular URL. The role of a URL mapping to build
    this link between a URL and a view. For example, in Bookr, you might want to map
    the URL `/books/` to a `books_list` view that you have created.
  id: totrans-270
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在*处理请求*部分简要提到了URL映射。Django在接收到特定URL的请求时不会自动知道应该执行哪个视图函数。URL映射的作用是建立URL和视图之间的这种联系。例如，在Bookr中，你可能想将URL
    `/books/` 映射到你创建的`books_list`视图。
- en: The URL-to-view mapping is defined in the file that Django automatically created
    called `urls.py`, inside the `bookr` package directory (although a different file
    can be set in `settings.py`; more on that later).
  id: totrans-271
  prefs: []
  type: TYPE_NORMAL
  zh: URL到视图的映射定义在Django自动创建的文件中，该文件名为`urls.py`，位于`bookr`包目录内（尽管可以在`settings.py`中设置不同的文件；关于这一点稍后会有更多说明）。
- en: This file contains a variable, `urlpatterns`, which is a list of paths that
    Django evaluates in turn until it finds a match for the URL being requested. The
    match will either resolve to a view function, or to another `urls.py` file also
    containing a `urlpatterns` variable, which will be resolved in the same manner.
    URL files can be chained in this manner for as long as you want. In this way,
    you can split URL maps into separate files (such as one or more per app) so that
    they don't become too large. Once a view has been found, Django calls it with
    an `HttpRequest` instance and any parameters parsed from the URL.
  id: totrans-272
  prefs: []
  type: TYPE_NORMAL
  zh: 此文件包含一个变量`urlpatterns`，它是一个路径列表，Django将依次评估，直到找到与请求的URL匹配的路径。匹配将解析为一个视图函数，或者解析为另一个也包含`urlpatterns`变量的`urls.py`文件，它将以相同的方式解析。你可以按这种方式将URL文件链式连接，直到你想要的程度。这样，你可以将URL映射拆分为单独的文件（例如每个应用一个或多个），这样它们就不会变得太大。一旦找到视图，Django就会使用一个`HttpRequest`实例和从URL解析出的任何参数来调用它。
- en: Rules are set by calling the `path` function, which takes the path of the URL
    as the first argument. The path can contain named parameters that will be passed
    to a view as function parameters. Its second argument is either a view or another
    file also containing `urlpatterns`.
  id: totrans-273
  prefs: []
  type: TYPE_NORMAL
  zh: 规则是通过调用`path`函数来设置的，该函数将URL路径作为第一个参数。路径可以包含命名参数，这些参数将被作为函数参数传递给视图。其第二个参数是一个视图或另一个也包含`urlpatterns`的文件。
- en: There is also the `re_path` function, which is similar to `path` except it takes
    a regular expression as the first argument for a more advanced configuration.
    There is much more to URL mapping; however, and it will be covered in *Chapter
    3*, *URL Mapping, Views, and Templates*.
  id: totrans-274
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，还有一个`re_path`函数，它与`path`类似，但它将正则表达式作为第一个参数，用于更高级的配置。URL映射还有很多其他内容；然而，它将在*第3章*，*URL映射、视图和模板*中介绍。
- en: '![Figure 1.21: The default urls.py file'
  id: totrans-275
  prefs: []
  type: TYPE_NORMAL
  zh: '![图1.21：默认的urls.py文件'
- en: '](img/B15509_01_21.jpg)'
  id: totrans-276
  prefs: []
  type: TYPE_NORMAL
  zh: '![img/B15509_01_21.jpg]'
- en: 'Figure 1.21: The default urls.py file'
  id: totrans-277
  prefs: []
  type: TYPE_NORMAL
  zh: 图1.21：默认的urls.py文件
- en: To illustrate these concepts, *Figure 1.21* shows the default `urls.py` file
    that Django generates. You can see the `urlpatterns` variable, which lists all
    the URLs that are set up. Currently, there is only one rule set up, which maps
    any path starting with `admin/` to the admin URL maps (the `admin.site.urls` module).
    This is not a mapping to a view; instead, it is an example of chaining URL maps
    together—the `admin.site.urls` module will define the remainder of the paths (after
    `admin/`) that map to the admin views. We will cover the Django admin site in
    *Chapter 4*, *Introduction to Django Admin*.
  id: totrans-278
  prefs: []
  type: TYPE_NORMAL
  zh: 为了说明这些概念，*图1.21*展示了Django生成的默认`urls.py`文件。你可以看到`urlpatterns`变量，它列出了所有已设置的URL。目前，只有一个规则被设置，它将任何以`admin/`开头的路径映射到管理URL映射（`admin.site.urls`模块）。这不是一个映射到视图的映射；相反，它是一个将URL映射链式连接的例子——`admin.site.urls`模块将定义剩余的路径（`admin/`之后），这些路径映射到管理视图。我们将在*第4章*，*Django管理简介*中介绍Django管理站点。
- en: We will now write a view and set up a URL map to it to see these concepts in
    action.
  id: totrans-279
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在将编写一个视图，并设置一个URL映射到它，以观察这些概念的实际应用。
- en: 'Exercise 1.03: Writing a View and Mapping a URL to It'
  id: totrans-280
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 练习1.03：编写视图并将URL映射到它
- en: 'Our first view will be very simple and will just return some static text content.
    In this exercise, we will see how to write a view, and how to set up a URL map
    to resolve to a view:'
  id: totrans-281
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的第一个视图将非常简单，它只会返回一些静态文本内容。在这个练习中，我们将看到如何编写视图，以及如何设置URL映射以解析到视图：
- en: Note
  id: totrans-282
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: As you make changes to files in your project and save them, you might see the
    Django development server automatically restarting in the Terminal or console
    in which it is running. This is normal; it automatically restarts to load any
    code changes that you make. Please also note that it won't automatically apply
    changes to the database if you edit models or migrations—more on this in *Chapter
    2*, *Models and Migrations*.
  id: totrans-283
  prefs: []
  type: TYPE_NORMAL
  zh: 当你在项目中的文件进行更改并保存时，你可能会在运行它的终端或控制台中看到Django开发服务器自动重启。这是正常的；它会自动重启以加载你做出的任何代码更改。请注意，如果你编辑模型或迁移，它不会自动将更改应用到数据库中——关于这一点，我们将在*第2章*，*模型和迁移*中详细说明。
- en: 'In PyCharm, expand the `reviews` folder in the project browser on the left,
    then double-click the `views.py` file inside to open it. In the right (editor)
    pane in PyCharm, you should see the Django automatically generated placeholder
    text:'
  id: totrans-284
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 PyCharm 中，在左侧的项目浏览器中展开 `reviews` 文件夹，然后双击 `views.py` 文件以打开它。在 PyCharm 的右侧（编辑器）面板中，你应该能看到
    Django 自动生成的占位文本：
- en: '[PRE15]'
  id: totrans-285
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'It should look like this in the editor pane:'
  id: totrans-286
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 在编辑器面板中应该看起来像这样：
- en: '![Figure 1.22: views.py default content'
  id: totrans-287
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '![图 1.22：views.py 默认内容'
- en: '](img/B15509_01_22.jpg)'
  id: totrans-288
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '![图片 B15509_01_22.jpg](img/B15509_01_22.jpg)'
- en: 'Figure 1.22: views.py default content'
  id: totrans-289
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 图 1.22：views.py 默认内容
- en: 'Remove this placeholder text from `views.py` and instead insert this content:'
  id: totrans-290
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 从 `views.py` 中删除此占位文本，并插入以下内容：
- en: '[PRE16]'
  id: totrans-291
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE16]'
- en: First, the `HttpResponse` class needs to be imported from `django.http`. This
    is what is used to create the response that goes back to the web browser. You
    can also use it to control things such as the HTTP headers or status code. For
    now, it will just use the default headers and `200 Success` status code. Its first
    argument is the string content to send as the body of the response.
  id: totrans-292
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 首先，需要从 `django.http` 中导入 `HttpResponse` 类。这是用来创建返回给网页浏览器的响应的。你也可以用它来控制诸如 HTTP
    标头或状态码之类的功能。现在，它将只使用默认的标头和 `200 Success` 状态码。它的第一个参数是要发送为响应正文的字符串内容。
- en: 'Then, the view function returns an `HttpResponse` instance with the content
    we defined (`Hello, world!`):'
  id: totrans-293
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 然后，视图函数返回一个包含我们定义的内容的 `HttpResponse` 实例（`Hello, world!`）：
- en: '![Figure 1.23: The contents of views.py after editing'
  id: totrans-294
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '![图 1.23：编辑后的 views.py 内容'
- en: '](img/B15509_01_23.jpg)'
  id: totrans-295
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '![图片 B15509_01_23.jpg](img/B15509_01_23.jpg)'
- en: 'Figure 1.23: The contents of views.py after editing'
  id: totrans-296
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 图 1.23：编辑后的 views.py 内容
- en: We will now set up a URL map to the `index` view. This will be very simple and
    won't contain any parameters. Expand the `bookr` directory in the `Project` pane,
    then open `urls.py`. Django has automatically generated this file.
  id: totrans-297
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在我们将设置一个 URL 映射到 `index` 视图。这将非常简单，不会包含任何参数。在 `Project` 面板中展开 `bookr` 目录，然后打开
    `urls.py`。Django 已经自动生成了此文件。
- en: For now, we'll just add a simple URL to replace the default index that Django provides.
  id: totrans-298
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 目前，我们只需添加一个简单的 URL 来替换 Django 提供的默认索引。
- en: 'Import your views into the `urls.py` file, by adding this line after the other
    existing imports:'
  id: totrans-299
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 通过在现有导入之后添加此行将你的视图导入到 `urls.py` 文件中：
- en: '[PRE17]'
  id: totrans-300
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'Add a map to the index view to the `urlpatterns` list by adding a call to the
    `path` function with an empty string and a reference to the `index` function:'
  id: totrans-301
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 通过向 `urlpatterns` 列表中添加对 `path` 函数的调用（一个空字符串和一个对 `index` 函数的引用）来将映射添加到索引视图：
- en: '[PRE18]'
  id: totrans-302
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE18]'
- en: '![Figure 1.24: urls.py after editing'
  id: totrans-303
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '![图 1.24：编辑后的 urls.py'
- en: '](img/B15509_01_24.jpg)'
  id: totrans-304
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '![图片 B15509_01_24.jpg](img/B15509_01_24.jpg)'
- en: 'Figure 1.24: urls.py after editing'
  id: totrans-305
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 图 1.24：编辑后的 urls.py
- en: 'Switch back to your web browser and refresh. The Django default welcome screen
    should be replaced with the text defined in the view, `Hello, world!`:![Figure
    1.25: The web browser should now display the Hello, world! message'
  id: totrans-306
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 切换回你的网页浏览器并刷新。Django 默认欢迎屏幕应该被视图定义中的文本 `Hello, world!` 替换：![图 1.25：现在网页浏览器应该显示
    Hello, world! 消息
- en: '](img/B15509_01_25.jpg)'
  id: totrans-307
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '![图片 B15509_01_25.jpg](img/B15509_01_25.jpg)'
- en: 'Figure 1.25: The web browser should now display the Hello, world! message'
  id: totrans-308
  prefs: []
  type: TYPE_NORMAL
  zh: 图 1.25：现在网页浏览器应该显示 Hello, world! 消息
- en: We just saw how to write a view function and map a URL to it. We then tested
    the view by loading it in a web browser.
  id: totrans-309
  prefs: []
  type: TYPE_NORMAL
  zh: 我们刚刚看到了如何编写视图函数并将 URL 映射到它。然后我们通过在网页浏览器中加载它来测试了视图。
- en: GET, POST, and QueryDict Objects
  id: totrans-310
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: GET、POST 和 QueryDict 对象
- en: Data can come through an HTTP request as parameters on a URL or inside the body
    of a `POST` request. You might have noticed parameters in a URL when browsing
    the web—the text after a `?`—for example, `http://www.example.com/?parameter1=value1&parameter2=value2`.
    We also saw earlier in this chapter an example of form data in a `POST` request,
    for logging in a user (the request body was `username=user1&password=password1`).
  id: totrans-311
  prefs: []
  type: TYPE_NORMAL
  zh: 数据可以通过 HTTP 请求作为 URL 上的参数或 `POST` 请求正文中的内容传入。你可能已经注意到在浏览网页时 URL 中的参数——`?` 后面的文本——例如，`http://www.example.com/?parameter1=value1&parameter2=value2`。我们也在本章前面看到了一个
    `POST` 请求中表单数据的例子，用于用户登录（请求正文是 `username=user1&password=password1`）。
- en: Django automatically parses these parameter strings into `QueryDict` objects.
    The data is then available on the `HttpRequest` object that is passed to your
    view—specifically, in the `HttpRequest`.`GET` and `HttpRequest`.`POST` attributes,
    for URL parameters and body parameters respectively. `QueryDict` objects are objects
    that mostly behave like dictionaries, except that they can contain multiple values
    for a key.
  id: totrans-312
  prefs: []
  type: TYPE_NORMAL
  zh: Django自动将这些参数字符串解析为`QueryDict`对象。然后，这些数据在传递给视图函数的`HttpRequest`对象上可用——具体来说，在`HttpRequest`.`GET`和`HttpRequest`.`POST`属性中，分别对应URL参数和表单参数。`QueryDict`对象是主要像字典一样行为的对象，除了它们可以为键包含多个值。
- en: 'To show different methods of accessing items, we''ll use a simple `QueryDict`
    named `qd` with only one key (`k`) as an example. The `k` item has three values
    in a list: the strings `a`, `b`, and `c`. The following code snippets show output
    from a Python interpreter.'
  id: totrans-313
  prefs: []
  type: TYPE_NORMAL
  zh: 为了展示访问项的不同方法，我们将使用一个简单的名为`qd`的`QueryDict`作为示例，它只有一个键（`k`）。`k`项在列表中有三个值：字符串`a`、`b`和`c`。以下代码片段显示了Python解释器的输出。
- en: 'First, the `QueryDict` `qd` is constructed from a parameter string:'
  id: totrans-314
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，`QueryDict` `qd`是从一个参数字符串构建的：
- en: '[PRE19]'
  id: totrans-315
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'When accessing items with square bracket notation or the `get` method, the
    last value for that key is returned:'
  id: totrans-316
  prefs: []
  type: TYPE_NORMAL
  zh: 当使用方括号符号或`get`方法访问项时，返回该键的最后一个值：
- en: '[PRE20]'
  id: totrans-317
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'To access all the values for a key, the `getlist` method should be used:'
  id: totrans-318
  prefs: []
  type: TYPE_NORMAL
  zh: 要访问一个键的所有值，应使用`getlist`方法：
- en: '[PRE21]'
  id: totrans-319
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: '`getlist` will always return a list—it will be empty if the key does not exist:'
  id: totrans-320
  prefs: []
  type: TYPE_NORMAL
  zh: '`getlist`始终返回一个列表——如果键不存在，它将是空的：'
- en: '[PRE22]'
  id: totrans-321
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: While `getlist` does not raise an exception for keys that do not exist, accessing
    a key that does not exist with square bracket notation will raise `KeyError`,
    like a normal dictionary. Use the `get` method to avoid this error.
  id: totrans-322
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然`getlist`对于不存在的键不会引发异常，但使用方括号符号访问不存在的键将引发`KeyError`，就像普通字典一样。使用`get`方法来避免这个错误。
- en: 'The `QueryDict` objects for `GET` and `POST` are immutable (they cannot be
    changed), so the `copy` method should be used to get a mutable copy if you need
    to change its values:'
  id: totrans-323
  prefs: []
  type: TYPE_NORMAL
  zh: '`GET`和`POST`的`QueryDict`对象是不可变的（它们不能被更改），所以如果你需要更改其值，应使用`copy`方法来获取一个可变副本：'
- en: '[PRE23]'
  id: totrans-324
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'To give an example of how `QueryDict` is populated from a URL, imagine an example
    URL: `http://127.0.0.1:8000?val1=a&val2=b&val2=c&val3`.'
  id: totrans-325
  prefs: []
  type: TYPE_NORMAL
  zh: 为了说明`QueryDict`是如何从URL中填充的，想象一个示例URL：`http://127.0.0.1:8000?val1=a&val2=b&val2=c&val3`。
- en: 'Behind the scenes, Django passes the query from the URL (everything after the
    `?`) to instantiate a `QueryDict` object and attach it to the `request` instance
    that is passed to the view function. Something like this:'
  id: totrans-326
  prefs: []
  type: TYPE_NORMAL
  zh: 在幕后，Django将URL中的查询（`?`之后的所有内容）传递给`QueryDict`对象以实例化，并将其附加到传递给视图函数的`request`实例。类似于以下内容：
- en: '[PRE24]'
  id: totrans-327
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: Remember, this is done to the `request` instance before you receive it inside
    your view function; you do not need to do this.
  id: totrans-328
  prefs: []
  type: TYPE_NORMAL
  zh: 记住，这在你将`request`实例传递到视图函数内部之前就完成了；你不需要这样做。
- en: 'In the case of our example URL, we could access the parameters inside the view
    function as follows:'
  id: totrans-329
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的示例URL的情况下，我们可以在视图函数内部如下访问参数：
- en: '[PRE25]'
  id: totrans-330
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'Using standard dictionary access, it would return the value `a`:'
  id: totrans-331
  prefs: []
  type: TYPE_NORMAL
  zh: 使用标准字典访问，它将返回值`a`：
- en: '[PRE26]'
  id: totrans-332
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: 'Again, using standard dictionary access, there are two values set for the `val2`
    key, so it would return the last value, `c`:'
  id: totrans-333
  prefs: []
  type: TYPE_NORMAL
  zh: 再次，使用标准字典访问，`val2`键设置了两个值，因此它会返回最后一个值，`c`：
- en: '[PRE27]'
  id: totrans-334
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: 'This would return a list of all the values for `val2`: `["b", "c"]`:'
  id: totrans-335
  prefs: []
  type: TYPE_NORMAL
  zh: '这将返回`val2`的所有值列表：`["b", "c"]`:'
- en: '[PRE28]'
  id: totrans-336
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: 'This key is in the query string but has no value set, so this returns an empty
    string:'
  id: totrans-337
  prefs: []
  type: TYPE_NORMAL
  zh: 这个键在查询字符串中存在但没有设置值，因此返回一个空字符串：
- en: '[PRE29]'
  id: totrans-338
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: 'This key is not set, so `KeyError` will be raised. Use `request.GET.get("val4")`
    instead, which will return `None`:'
  id: totrans-339
  prefs: []
  type: TYPE_NORMAL
  zh: 这个键没有设置，所以会引发`KeyError`。请使用`request.GET.get("val4")`代替，它将返回`None`：
- en: '[PRE30]'
  id: totrans-340
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: Since this key is not set, an empty list (`[]`) will be returned.
  id: totrans-341
  prefs: []
  type: TYPE_NORMAL
  zh: 由于这个键没有设置，将返回一个空列表（`[]`）。
- en: We will now look at `QueryDict` in action using the `GET` parameters. You will
    examine `POST` parameters further in *Chapter 6*, *Forms*.
  id: totrans-342
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们将通过`GET`参数来观察`QueryDict`的实际应用。你将在*第6章*，*表单*中进一步了解`POST`参数。
- en: 'Exercise 1.04: Exploring GET Values and QueryDict'
  id: totrans-343
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 练习1.04：探索GET值和QueryDict
- en: 'We will now make some changes to our `index` view from the previous exercise
    to read values from the URL in the `GET` attribute, and then we will experiment
    with passing different parameters to see the result:'
  id: totrans-344
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们将对之前练习中的`index`视图进行一些修改，以便从URL的`GET`属性中读取值，然后我们将尝试传递不同的参数以查看结果：
- en: 'Open the `views.py` file in PyCharm. Add a new variable called `name` that
    reads the user''s name from the `GET` parameters. Add this line after the `index`
    function definition:'
  id: totrans-345
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在PyCharm中打开`views.py`文件。添加一个名为`name`的新变量，该变量从`GET`参数中读取用户的名称。在`index`函数定义之后添加此行：
- en: '[PRE31]'
  id: totrans-346
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE31]'
- en: 'Change the return value so the name is used as part of the content that is returned:'
  id: totrans-347
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将返回值修改为使用名称作为返回内容的一部分：
- en: '[PRE32]'
  id: totrans-348
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE32]'
- en: 'In PyCharm, the changed code will look like this:'
  id: totrans-349
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 在PyCharm中，更改后的代码将看起来像这样：
- en: '![Figure 1.26: Updated views.py file'
  id: totrans-350
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '![图1.26：更新后的views.py文件'
- en: '](img/B15509_01_26.jpg)'
  id: totrans-351
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '![图片 B15509_01_26.jpg]'
- en: 'Figure 1.26: Updated views.py file'
  id: totrans-352
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 图1.26：更新后的views.py文件
- en: 'Visit `http://127.0.0.1:8000` in your browser. You should notice that the page
    still says `Hello, world!` This is because we have not supplied a `name` parameter.
    You can add your name into the URL, for example, `http://127.0.0.1:8000?name=Ben`:![Figure
    1.27: Setting the name in the URL'
  id: totrans-353
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在你的浏览器中访问`http://127.0.0.1:8000`。你应该注意到页面仍然显示`Hello, world!`这是因为我们没有提供`name`参数。你可以在URL中添加你的名字，例如，`http://127.0.0.1:8000?name=Ben`：![图1.27：在URL中设置名称
- en: '](img/B15509_01_27.jpg)'
  id: totrans-354
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '![图片 B15509_01_27.jpg]'
- en: 'Figure 1.27: Setting the name in the URL'
  id: totrans-355
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 图1.27：在URL中设置名称
- en: 'Try adding two names, for example, `http://127.0.0.1:8000?name=Ben&name=John`.
    As we mentioned, the last value for the parameter is retrieved with the `get`
    function, so you should see `Hello, John!`:![Figure 1.28: Setting multiple names
    in the URL'
  id: totrans-356
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 尝试添加两个名称，例如，`http://127.0.0.1:8000?name=Ben&name=John`。正如我们提到的，参数的最后一个值是通过`get`函数检索的，所以你应该看到`Hello,
    John!`：![图1.28：在URL中设置多个名称
- en: '](img/B15509_01_28.jpg)'
  id: totrans-357
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '![图片 B15509_01_28.jpg]'
- en: 'Figure 1.28: Setting multiple names in the URL'
  id: totrans-358
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 图1.28：在URL中设置多个名称
- en: 'Try setting no name, like this: `http://127.0.0.1:8000?name=`. The page should
    go back to displaying `Hello, world!`:![Figure 1.29: No name set in the URL'
  id: totrans-359
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 尝试不设置名称，如下所示：`http://127.0.0.1:8000?name=`。页面应该会回到显示`Hello, world!`：![图1.29：URL中没有设置名称
- en: '](img/B15509_01_29.jpg)'
  id: totrans-360
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '![图片 B15509_01_29.jpg]'
- en: 'Figure 1.29: No name set in the URL'
  id: totrans-361
  prefs: []
  type: TYPE_NORMAL
  zh: 图1.29：URL中没有设置名称
- en: Note
  id: totrans-362
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: You might wonder why we set `name` to the default `world` by using `or` instead
    of passing `'world'` as the default value to `get`. Consider what happened in
    *step 5* when we passed in a blank value for the `name` parameter. If we had passed
    `'world'` as a default value for `get`, then the `get` function would still have
    returned an empty string. This is because a value `name`, it's just that it's
    blank. Keep this in mind when developing your views, as there is a difference
    between no value being set, and a blank value being set. Depending on your use
    case, you might choose to pass the default value for `get`.
  id: totrans-363
  prefs: []
  type: TYPE_NORMAL
  zh: 你可能会想知道为什么我们使用`or`而不是将`'world'`作为默认值传递给`get`函数来将`name`设置为默认值。考虑一下在*步骤5*中我们为`name`参数传递了一个空白值时发生了什么。如果我们为`get`函数传递了`'world'`作为默认值，那么`get`函数仍然会返回一个空字符串。这是因为有一个`name`值，只是它是空的。在开发你的视图时请记住这一点，因为没有设置值和设置了空白值是有区别的。根据你的使用情况，你可能会选择传递`get`的默认值。
- en: In this exercise, we retrieved values from the URL in our view using the `GET`
    attribute of the incoming request. We saw how to set default values and which
    value is retrieved if multiple values are set for the same parameter.
  id: totrans-364
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个练习中，我们使用传入请求的`GET`属性从我们的视图中检索值。我们看到了如何设置默认值以及如果为同一参数设置了多个值，则检索哪个值。
- en: Exploring Django Settings
  id: totrans-365
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 探索Django设置
- en: We haven't yet looked at how Django stores its settings. Now that we've seen
    the different parts of Django, it is a good time to examine the `settings.py`
    file. This file contains many settings that can be used to customize Django. A
    default `settings.py` file was created for you when you started the Bookr project.
  id: totrans-366
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还没有查看Django如何存储其设置。现在我们已经看到了Django的不同部分，现在是检查`settings.py`文件的好时机。这个文件包含许多可以用来自定义Django的设置。当你开始Bookr项目时，为你创建了一个默认的`settings.py`文件。
- en: We will discuss some of the more important settings in the file now, and a few
    others that might be useful as you become more fluent with Django. You should
    open your `settings.py` file in PyCharm and follow along so you can see where
    and what the values are for your project.
  id: totrans-367
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们将讨论文件中的一些重要设置，以及一些在你更熟悉Django时可能有用的其他设置。你应该在PyCharm中打开你的`settings.py`文件并跟随，这样你就可以看到你的项目中的值在哪里以及是什么。
- en: 'Each setting in this file is just a file-global variable. The order in which
    we will discuss the settings is the same order in which they appear in this file,
    although we may skip over some—for example, there is the `ALLOWED_HOSTS` setting
    between `DEBUG` and `INSTALLED_APPS`, which we won''t cover in this part of the
    book (you''ll see it in *Chapter 17*, *Deployment of a Django Application (Part
    1 – Server Setup)*):'
  id: totrans-368
  prefs: []
  type: TYPE_NORMAL
  zh: 此文件中的每个设置都是一个全局变量。我们将讨论设置的顺序与它们在此文件中出现的顺序相同，尽管我们可能会跳过一些——例如，在`DEBUG`和`INSTALLED_APPS`之间有`ALLOWED_HOSTS`设置，我们不会在本部分书中介绍（您将在*第17章*，*Django应用程序的部署（第1部分
    - 服务器设置）*中看到它）：
- en: '[PRE33]'
  id: totrans-369
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: This is an automatically generated value that shouldn't be shared with anyone.
    It is used for hashing, tokens, and other cryptographic functions. If you had
    existing sessions in a cookie and changed this value, the sessions would no longer
    be valid.
  id: totrans-370
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一个自动生成的值，不应与任何人共享。它用于散列、令牌和其他加密函数。如果您在cookie中已有会话并且更改了此值，会话将不再有效。
- en: '[PRE34]'
  id: totrans-371
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: 'With this value set to `True`, Django will automatically display exceptions
    to the browser to allow you to debug any problems you encounter. It should be
    set to `False` when deploying your app to production:'
  id: totrans-372
  prefs: []
  type: TYPE_NORMAL
  zh: 将此值设置为`True`，Django将自动将异常显示在浏览器中，以便您调试遇到的任何问题。当您将应用程序部署到生产环境时，应将其设置为`False`：
- en: '[PRE35]'
  id: totrans-373
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: 'As you write your own Django apps (such as the `reviews` app) or install third-party
    applications (which will be covered in *Chapter 15*, *Django Third-Party Libraries*),
    they should be added to this list. As we''ve seen, it is not strictly necessary
    to add them here (our `index` view worked without our `reviews` app being in this
    list). However, for Django to be able to automatically find the app''s templates,
    static files, migrations, and other configuration, it must be listed here:'
  id: totrans-374
  prefs: []
  type: TYPE_NORMAL
  zh: 当您编写自己的Django应用程序（如`reviews`应用程序）或安装第三方应用程序（将在*第15章*，*Django第三方库*中介绍）时，它们应添加到此列表中。正如我们所看到的，将它们添加到这里并不是严格必要的（我们的`index`视图在没有`reviews`应用程序在此列表中的情况下也能工作）。然而，为了Django能够自动找到应用程序的模板、静态文件、迁移和其他配置，它必须列在此处：
- en: '[PRE36]'
  id: totrans-375
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: 'This is the Python module that Django will load first to find URLs. Note that
    it is the file we added our index view URL map to previously:'
  id: totrans-376
  prefs: []
  type: TYPE_NORMAL
  zh: 这是Django首先加载以查找URL的Python模块。请注意，这是我们之前添加索引视图URL映射的文件：
- en: '[PRE37]'
  id: totrans-377
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: 'Right now, it''s not too important to understand everything in this setting
    as you won''t be changing it; the important line to point out is this one:'
  id: totrans-378
  prefs: []
  type: TYPE_NORMAL
  zh: 目前，您不需要理解这个设置中的所有内容，因为您不会更改它；需要指出的重要行是这一行：
- en: '[PRE38]'
  id: totrans-379
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: This tells Django it should look in a `templates` directory inside each `INSTALLED_APP`
    when loading a template to render. We don't have a `templates` directory for `reviews`
    yet, but we will add one in the next exercise.
  id: totrans-380
  prefs: []
  type: TYPE_NORMAL
  zh: 这告诉Django在加载模板以进行渲染时应在每个`INSTALLED_APP`内部的`templates`目录中查找。我们目前还没有为`reviews`创建`templates`目录，但我们将在下一次练习中添加一个。
- en: Django has more settings available that aren't listed in the `settings.py` file,
    and so it will use its built-in defaults in these cases. You can also use the
    file to set arbitrary settings that you make up for your application. Third-party
    applications might want settings to be added here as well. In later chapters,
    we will add settings here for other applications. You can find a list of all settings,
    and their defaults, at [https://docs.djangoproject.com/en/3.0/ref/settings/](https://docs.djangoproject.com/en/3.0/ref/settings/).
  id: totrans-381
  prefs: []
  type: TYPE_NORMAL
  zh: Django还有更多设置可用，这些设置在`settings.py`文件中未列出，因此在这些情况下它将使用其内置默认值。您还可以使用该文件设置您为应用程序创建的任意设置。第三方应用程序可能也希望在此处添加设置。在后面的章节中，我们将为其他应用程序在此处添加设置。您可以在[https://docs.djangoproject.com/en/3.0/ref/settings/](https://docs.djangoproject.com/en/3.0/ref/settings/)找到所有设置的列表及其默认值。
- en: Using Settings in Your Code
  id: totrans-382
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 在您的代码中使用设置
- en: 'It can sometimes be useful to refer to settings from `settings.py` in your
    own code, whether they be Django''s built-in settings or ones you have defined
    yourself. You might be tempted to write code like this to do it:'
  id: totrans-383
  prefs: []
  type: TYPE_NORMAL
  zh: 有时引用`settings.py`中的设置在您的代码中可能很有用，无论是Django的内置设置还是您自己定义的设置。您可能会想编写如下代码来完成此操作：
- en: '[PRE39]'
  id: totrans-384
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: Note
  id: totrans-385
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: The `#` symbol in the preceding code snippet denotes a code comment. Comments
    are added into code to help explain specific bits of logic.
  id: totrans-386
  prefs: []
  type: TYPE_NORMAL
  zh: 前面的代码片段中的`#`符号表示代码注释。注释被添加到代码中以帮助解释特定的逻辑。
- en: 'This method is incorrect, for a number of reasons:'
  id: totrans-387
  prefs: []
  type: TYPE_NORMAL
  zh: 由于以下多个原因，这种方法是不正确的：
- en: It is possible to run Django and specify a different settings file to read from,
    in which case the previous code would cause an error as it would not be able to
    find that particular file. Or, if the file exists, the import would succeed but
    would contain the wrong settings.
  id: totrans-388
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 有可能运行 Django 并指定一个不同的设置文件来读取，在这种情况下，之前的代码会导致错误，因为它将无法找到那个特定的文件。或者，如果文件存在，导入将成功，但将包含错误的设置。
- en: Django has settings that might not be listed in the `settings.py` file, and
    if they aren't, it will use its own internal defaults. For example, if you removed
    the `DEBUG = True` line from your `settings.py` file, Django would fall back to
    using its internal value for `DEBUG` (which is `False`). You would get an error
    if you tried to access it using `settings.DEBUG` directly, though.
  id: totrans-389
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Django 有一些设置可能不会在 `settings.py` 文件中列出，如果没有列出，它将使用其内部默认值。例如，如果你从你的 `settings.py`
    文件中移除了 `DEBUG = True` 行，Django 将回退到使用其内部的 `DEBUG` 值（这是 `False`）。如果你直接使用 `settings.DEBUG`
    尝试访问它，你会得到一个错误。
- en: Third-party libraries can change how your settings are defined, so your `settings.py`
    file would look completely different. None of the expected variables may exist
    at all. The behavior of all these applications is beyond the scope of this book,
    but it is something to be aware of.
  id: totrans-390
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 第三方库可以更改你的设置定义方式，所以你的 `settings.py` 文件可能看起来完全不同。所有预期的变量可能根本不存在。所有这些应用程序的行为超出了本书的范围，但这是需要注意的。
- en: 'The preferred way is to use `django.conf` module instead, like this:'
  id: totrans-391
  prefs: []
  type: TYPE_NORMAL
  zh: 优先的方式是使用 `django.conf` 模块，如下所示：
- en: '[PRE40]'
  id: totrans-392
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: 'When importing `settings` from `django.conf`, Django mitigates the three issues
    we just discussed:'
  id: totrans-393
  prefs: []
  type: TYPE_NORMAL
  zh: 当从 `django.conf` 导入 `settings` 时，Django 缓解了我们刚才讨论的三个问题：
- en: Settings are read from whatever Django settings file has been specified.
  id: totrans-394
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 设置是从指定的任何 Django 设置文件中读取的。
- en: Any default settings values are interpolated.
  id: totrans-395
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 任何默认设置值都会被插值。
- en: Django takes care of parsing any settings defined by a third-party library.
  id: totrans-396
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Django 负责解析由第三方库定义的任何设置。
- en: In our new short example code snippet, even if `DEBUG` is missing from the `settings.py`
    file, it will fall back to the default value that Django has internally (which
    is `False`). The same is true for all other settings that Django defines; however,
    if you define your own custom settings in this file, Django will not have internal
    values for them, so in your code, you should have some provision for them not
    existing—how your code behaves is your choice and beyond the scope of this book.
  id: totrans-397
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们新的简短示例代码片段中，即使 `DEBUG` 在 `settings.py` 文件中缺失，它也会回退到 Django 内部默认值（这是 `False`）。对于
    Django 定义的所有其他设置也是如此；然而，如果你在这个文件中定义了自己的自定义设置，Django 将不会为它们提供内部值，所以在你代码中，你应该有一些处理它们可能不存在的方案——你的代码如何行为是你的选择，并且超出了本书的范围。
- en: Finding HTML Templates in App Directories
  id: totrans-398
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 在应用目录中查找 HTML 模板
- en: Many options are available to tell Django how to find templates, which can be
    set in the `TEMPLATES` setting of `settings.py`, but the easiest one (for now)
    is to create a `templates` directory inside the `reviews` directory. Django will
    look in this (and in other apps' `templates` directories) because of `APP_DIRS`
    being `True` in the `settings.py` file, as we saw in the previous section.
  id: totrans-399
  prefs: []
  type: TYPE_NORMAL
  zh: 有许多选项可以告诉 Django 如何查找模板，这些选项可以在 `settings.py` 文件的 `TEMPLATES` 设置中设置，但最简单的一个（目前）是在
    `reviews` 目录内创建一个 `templates` 目录。由于 `settings.py` 文件中的 `APP_DIRS` 设置为 `True`，Django
    将会查找这个目录（以及其他应用中的 `templates` 目录），正如我们在上一节中看到的。
- en: 'Exercise 1.05: Creating a Templates Directory and a Base Template'
  id: totrans-400
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 练习 1.05：创建模板目录和基本模板
- en: 'In this exercise, you will create a `templates` directory for the `reviews`
    app. Then, you will add an HTML template file that Django will be able to render
    to an HTTP response:'
  id: totrans-401
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个练习中，你将为 `reviews` 应用创建一个 `templates` 目录。然后，你将添加一个 Django 可以渲染到 HTTP 响应中的
    HTML 模板文件：
- en: 'We discussed `settings.py` and its `INSTALLED_APPS` setting in the previous
    section (*Exploring Django Settings*). We need to add the `reviews` app to `INSTALLED_APPS`
    for Django to be able to find templates. Open `settings.py` in PyCharm. Update
    the `INSTALLED_APPS` setting and add `reviews` to the end. It should look like
    this:'
  id: totrans-402
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们在上一节（*探索 Django 设置*）中讨论了 `settings.py` 和其 `INSTALLED_APPS` 设置。我们需要将 `reviews`
    应用添加到 `INSTALLED_APPS` 中，以便 Django 能够找到模板。在 PyCharm 中打开 `settings.py`。更新 `INSTALLED_APPS`
    设置并在末尾添加 `reviews`。它应该看起来像这样：
- en: '[PRE41]'
  id: totrans-403
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE41]'
- en: 'In PyCharm, the file should look like this now:'
  id: totrans-404
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 在 PyCharm 中，文件现在应该看起来像这样：
- en: '![Figure 1.30: The reviews app added to settings.py'
  id: totrans-405
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '![图 1.30：已将 reviews 应用添加到 settings.py](img/B15509_01_30.jpg)'
- en: '](img/B15509_01_30.jpg)'
  id: totrans-406
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '![img/B15509_01_30.jpg](img/B15509_01_30.jpg)'
- en: 'Figure 1.30: The reviews app added to settings.py'
  id: totrans-407
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 图 1.30：已将 reviews 应用添加到 settings.py
- en: Save and close `settings.py`.
  id: totrans-408
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 保存并关闭 `settings.py`。
- en: 'In the PyCharm Project browser, right-click the `reviews` directory and select
    `New` -> `Directory`:![Figure 1.31: Creating a new directory inside the reviews
    directory'
  id: totrans-409
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 PyCharm 项目浏览器中，右键单击 `reviews` 目录并选择 `New` -> `Directory`：![图 1.31：在 reviews
    目录内创建新的目录
- en: '](img/B15509_01_31.jpg)'
  id: totrans-410
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '](img/B15509_01_31.jpg)'
- en: 'Figure 1.31: Creating a new directory inside the reviews directory'
  id: totrans-411
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 图 1.31：在 reviews 目录内创建新的目录
- en: 'Enter the name `templates` and click `OK` to create it:![Figure 1.32: Name
    the directory templates'
  id: totrans-412
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 输入名称 `templates` 并点击 `OK` 以创建它：![图 1.32：命名目录 templates
- en: '](img/B15509_01_32.jpg)'
  id: totrans-413
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '](img/B15509_01_32.jpg)'
- en: 'Figure 1.32: Name the directory templates'
  id: totrans-414
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 图 1.32：命名目录 templates
- en: 'Right-click the newly created `templates` directory and select `New` -> `HTML
    File`:![Figure 1.33: Creating a new HTML file in the templates directory'
  id: totrans-415
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 右键单击新创建的 `templates` 目录并选择 `New` -> `HTML File`：![图 1.33：在 templates 目录中创建新的
    HTML 文件
- en: '](img/B15509_01_33.jpg)'
  id: totrans-416
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '](img/B15509_01_33.jpg)'
- en: 'Figure 1.33: Creating a new HTML file in the templates directory'
  id: totrans-417
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 图 1.33：在 templates 目录中创建新的 HTML 文件
- en: 'In the window that appears, enter the name `base.html`, leave `HTML 5 file`
    selected, and then press `Enter` to create the file:![Figure 1.34: The New HTML
    File window'
  id: totrans-418
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在出现的窗口中，输入名称 `base.html`，保持 `HTML 5 file` 选中状态，然后按 `Enter` 创建文件：![图 1.34：新的
    HTML 文件窗口
- en: '](img/B15509_01_34.jpg)'
  id: totrans-419
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '](img/B15509_01_34.jpg)'
- en: 'Figure 1.34: The New HTML File window'
  id: totrans-420
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 图 1.34：新的 HTML 文件窗口
- en: 'After PyCharm creates the file, it will automatically open it too. It will
    have this content:'
  id: totrans-421
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 PyCharm 创建文件后，它也会自动打开它。它将包含以下内容：
- en: '[PRE42]'
  id: totrans-422
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE42]'
- en: 'Between the `<body>…</body>` tags, add a short message to verify that the template
    is being rendered:'
  id: totrans-423
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 `<body>…</body>` 标签之间添加一条简短的消息以验证模板正在被渲染：
- en: '[PRE43]'
  id: totrans-424
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE43]'
- en: 'Here is how it will look like in PyCharm:'
  id: totrans-425
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 这是在 PyCharm 中的样子：
- en: '![Figure 1.35: The base.html template with some example text'
  id: totrans-426
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '![图 1.35：包含一些示例文本的 base.html 模板'
- en: '](img/B15509_01_35.jpg)'
  id: totrans-427
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '](img/B15509_01_35.jpg)'
- en: 'Figure 1.35: The base.html template with some example text'
  id: totrans-428
  prefs: []
  type: TYPE_NORMAL
  zh: 图 1.35：包含一些示例文本的 base.html 模板
- en: In this exercise, we created a `templates` directory for the `reviews` app and
    added an HTML template to it. The HTML template will be rendered once we implement
    the use of the `render` function on our view.
  id: totrans-429
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个练习中，我们为 `reviews` 应用程序创建了一个 `templates` 目录，并向其中添加了一个 HTML 模板。一旦我们在视图中实现了
    `render` 函数的使用，HTML 模板就会被渲染。
- en: Rendering a Template with the render Function
  id: totrans-430
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用 render 函数渲染模板
- en: 'We now have a template to use, but we need to update our `index` view so that
    it renders the template instead of returning the `Hello (name)!` text that it
    is currently displaying (refer to *Figure 1.29* for how it currently looks). We
    will do this by using the `render` function and providing the name of the template.
    `render` is a shortcut function that returns an `HttpResponse` instance. There
    are other ways to render a template to provide more control over how it is rendered,
    but for now, this function is fine for our needs. `render` takes at least two
    arguments: the first is always the request that was passed to the view, and the
    second is the name/relative path of the template being rendered. We will also
    call it with a third argument, the render context that contains all the variables
    that will be available in the template—more on this in *Exercise 1.07*, *Using
    Variables in Templates*.'
  id: totrans-431
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们有了可以使用的模板，但我们需要更新我们的 `index` 视图，使其渲染模板而不是返回当前显示的 `Hello (name)!` 文本（参考 *图
    1.29* 了解其当前的外观）。我们将通过使用 `render` 函数并提供模板的名称来完成此操作。`render` 是一个快捷函数，它返回一个 `HttpResponse`
    实例。还有其他方法可以渲染模板以提供更多控制渲染的方式，但就目前而言，这个函数对我们的需求来说已经足够好了。`render` 至少需要两个参数：第一个始终是传递给视图的请求，第二个是正在渲染的模板的名称/相对路径。我们还将使用第三个参数调用它，即渲染上下文，它包含在模板中将可用的所有变量——更多关于这一点将在
    *练习 1.07*，*在模板中使用变量* 中介绍。
- en: 'Exercise 1.06: Rendering a Template in a View'
  id: totrans-432
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 练习 1.06：在视图中渲染模板
- en: 'In this exercise, you will update your `index` view function to render the
    HTML template you created in *Exercise 1.05*, *Creating a Templates Directory
    and a Base Template*. You will make use of the `render` function, which loads
    your template from disk, renders it, and sends it to the browser. This will replace
    the static text you are currently returning from the `index` view function:'
  id: totrans-433
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个练习中，你将更新你的 `index` 视图函数以渲染你在 *练习 1.05*，*创建模板目录和基本模板* 中创建的 HTML 模板。你将使用 `render`
    函数，该函数从磁盘加载你的模板，渲染它，并将其发送到浏览器。这将替换你当前从 `index` 视图函数返回的静态文本：
- en: In PyCharm, open `views.py` in the `reviews` directory.
  id: totrans-434
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 PyCharm 中，打开 `reviews` 目录中的 `views.py`。
- en: 'We no longer manually create an `HttpResponse` instance, so remove the `HttpResponse`
    import line:'
  id: totrans-435
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们不再手动创建 `HttpResponse` 实例，因此请删除 `HttpResponse` 导入行：
- en: '[PRE44]'
  id: totrans-436
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE44]'
- en: 'Replace it with an import of the `render` function from `django.shortcuts`:'
  id: totrans-437
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 用从 `django.shortcuts` 导入的 `render` 函数替换它：
- en: '[PRE45]'
  id: totrans-438
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE45]'
- en: 'Update the `index` function so that instead of returning `HttpResponse`, it''s
    returning a call to `render`, passing in the `request` instance and template name:'
  id: totrans-439
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 更新 `index` 函数，使其返回 `render` 调用，而不是返回 `HttpResponse`，传递 `request` 实例和模板名称：
- en: '[PRE46]'
  id: totrans-440
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE46]'
- en: 'Here is how it will look like in PyCharm:'
  id: totrans-441
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 在 PyCharm 中，它将看起来如下：
- en: '![Figure 1.36: Completed views.py file'
  id: totrans-442
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '![图 1.36：完成的 views.py 文件'
- en: '](img/B15509_01_36.jpg)'
  id: totrans-443
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '](img/B15509_01_36.jpg)'
- en: 'Figure 1.36: Completed views.py file'
  id: totrans-444
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 图 1.36：完成的 views.py 文件
- en: 'Start the dev server if it''s not already running. Then, open your web browser
    and refresh `http://127.0.0.1:8000`. You should see the `Hello from a template!`
    message rendered, as in *Figure 1.37*:![Figure 1.37: Your first rendered HTML
    template'
  id: totrans-445
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果开发服务器尚未运行，请启动它。然后，打开您的网页浏览器并刷新 `http://127.0.0.1:8000`。你应该会看到 *图 1.37* 中所示的
    `Hello from a template!` 消息被渲染出来。
- en: '](img/B15509_01_37.jpg)'
  id: totrans-446
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '](img/B15509_01_37.jpg)'
- en: 'Figure 1.37: Your first rendered HTML template'
  id: totrans-447
  prefs: []
  type: TYPE_NORMAL
  zh: 图 1.37：您的第一个渲染的 HTML 模板
- en: Rendering Variables in Templates
  id: totrans-448
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 在模板中渲染变量
- en: 'Templates aren''t just static HTML. Most of the time, they will contain variables
    that are interpolated as part of the rendering process. These variables are passed
    from the view to the template using a context: a dictionary (or dictionary-like
    object) that contains names for all the variables a template can use. We''ll take
    Bookr again as an example. Without variables in your template, you would need
    a different HTML file for each book you wanted to display. Instead, we use a variable
    such as `book_name` inside the template, and then the view provides the template
    with a `book_name` variable set to the title of the book model it has loaded.
    When displaying a different book, the HTML does not need to change; the view just
    passes a different book to it. You can see how model, view, and template are all
    now coming together.'
  id: totrans-449
  prefs: []
  type: TYPE_NORMAL
  zh: 模板不仅仅是静态的 HTML。大多数情况下，它们将包含变量，这些变量在渲染过程中被插值。这些变量通过上下文从视图传递到模板：一个包含所有模板可以使用变量名称的字典（或类似字典的对象）。我们将再次以
    Bookr 为例。如果你的模板中没有变量，你需要为每个要显示的书籍创建不同的 HTML 文件。相反，我们在模板内部使用一个如 `book_name` 的变量，然后视图为模板提供一个
    `book_name` 变量，其值设置为已加载的书籍模型标题。当显示不同的书籍时，HTML 不需要改变；视图只需传递一个不同的书籍给它。你可以看到模型、视图和模板现在是如何全部结合在一起的。
- en: Unlike some other languages, such as PHP, variables must be explicitly passed
    to the template, and variables in the view aren't automatically available to the
    template. This is for security as well as to avoid accidentally polluting the
    template's namespace (we don't want any unexpected variables in the template).
  id: totrans-450
  prefs: []
  type: TYPE_NORMAL
  zh: 与 PHP 等一些其他语言不同，变量必须显式传递到模板中，视图中的变量不会自动对模板可用。这是出于安全考虑，以及避免意外污染模板的命名空间（我们不希望在模板中出现任何意外的变量）。
- en: Inside a template, variables are denoted by double braces, `{{ }}`. While not
    strictly a standard, this style is quite common and used in other templating tools
    such as Vue.js and Mustache. Symfony (a PHP framework) also uses double braces
    in its Twig templating language, so you might have seen them used similarly there.
  id: totrans-451
  prefs: []
  type: TYPE_NORMAL
  zh: 在模板内部，变量通过双大括号 `{{ }}` 表示。虽然这并非严格的标准，但这种风格相当常见，并被用于其他模板工具，如 Vue.js 和 Mustache。Symfony（一个
    PHP 框架）在其 Twig 模板语言中也使用双大括号，因此你可能在那里看到过类似的用法。
- en: 'To render a variable in a template, simply wrap it with braces: `{{ book_name
    }}`. Django will automatically escape HTML in output so that you can include special
    characters (such as `<` or `>`) in your variable without worrying about it garbling
    your output. If a variable is not passed to a template, Django will simply render
    nothing at that location, instead of throwing an exception.'
  id: totrans-452
  prefs: []
  type: TYPE_NORMAL
  zh: 在模板中渲染变量，只需用大括号包裹它：`{{ book_name }}`。Django 会自动转义输出中的 HTML，这样你就可以在变量中包含特殊字符（如
    `<` 或 `>`），而不用担心它会破坏你的输出。如果一个变量没有传递到模板中，Django 将在该位置简单地渲染空内容，而不是抛出异常。
- en: There are many more ways to render a variable differently using filters, but
    these will be covered in *Chapter 3, URL Routers, Views, and Templates*.
  id: totrans-453
  prefs: []
  type: TYPE_NORMAL
  zh: 使用过滤器渲染变量有更多不同的方式，但这些将在 *第 3 章，URL 路由器、视图和模板* 中介绍。
- en: 'Exercise 1.07: Using Variables in Templates'
  id: totrans-454
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 练习 1.07：在模板中使用变量
- en: 'We''ll put a simple variable inside the `base.html` file to demonstrate how
    Django''s variable interpolation works:'
  id: totrans-455
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将在 `base.html` 文件中放置一个简单的变量来演示 Django 的变量插值是如何工作的：
- en: In PyCharm, open `base.html`.
  id: totrans-456
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 PyCharm 中打开 `base.html`。
- en: 'Update the `<body>` element so it contains a place to render the `name` variable:'
  id: totrans-457
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 更新 `<body>` 元素，使其包含一个用于渲染 `name` 变量的位置：
- en: '[PRE47]'
  id: totrans-458
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE47]'
- en: 'Go back to your web browser and refresh (you should still be at `http://127.0.0.1:8000`).
    You will see that the page now displays `Hello, !`. This is because we have not
    set the `name` variable in the rendering context:![Figure 1.38: No value rendered
    in the template because no context was set'
  id: totrans-459
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 返回您的网页浏览器并刷新（您应该仍然在 `http://127.0.0.1:8000`）。您会看到页面现在显示 `Hello, !`。这是因为我们没有在渲染上下文中设置
    `name` 变量：![图 1.38：由于没有设置上下文，模板中没有渲染任何值
- en: '](img/B15509_01_38.jpg)'
  id: totrans-460
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '![图片 B15509_01_38.jpg](img/B15509_01_38.jpg)'
- en: 'Figure 1.38: No value rendered in the template because no context was set'
  id: totrans-461
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 图 1.38：由于没有设置上下文，模板中没有渲染任何值
- en: 'Open `views.py` and add a variable called `name`, set to the value `"world"`,
    inside the `index` function:'
  id: totrans-462
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 打开 `views.py` 并在 `index` 函数内添加一个名为 `name` 的变量，将其值设置为 `"world"`：
- en: '[PRE48]'
  id: totrans-463
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE48]'
- en: 'Refresh your browser again. You should notice that nothing has changed: anything
    we want to render must be explicitly passed to the `render` function as `context`.
    This is the dictionary of variables that are made available when rendering.'
  id: totrans-464
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 再次刷新您的浏览器。您应该注意到没有任何变化：我们想要渲染的任何内容都必须明确传递给 `render` 函数作为 `context`。这是在渲染时提供的变量字典。
- en: 'Add the `context` dictionary as the third argument to the `render` function.
    Change your `render` line to this:'
  id: totrans-465
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将 `context` 字典作为 `render` 函数的第三个参数添加。将您的 `render` 行更改为以下内容：
- en: '[PRE49]'
  id: totrans-466
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE49]'
- en: 'In PyCharm, this should appear as follows:'
  id: totrans-467
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 在 PyCharm 中，它应该如下所示：
- en: '![Figure 1.39: views.py with the name variable sent in the render context'
  id: totrans-468
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '![图 1.39：在渲染上下文中发送了 `name` 变量的 `views.py`'
- en: '](img/B15509_01_39.jpg)'
  id: totrans-469
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '![图片 B15509_01_39.jpg](img/B15509_01_39.jpg)'
- en: 'Figure 1.39: views.py with the name variable sent in the render context'
  id: totrans-470
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 图 1.39：在渲染上下文中发送了 `name` 变量的 `views.py`
- en: 'Refresh your browser again and you''ll see it now says `Hello, world!`:![Figure
    1.40: A template rendered with a variable'
  id: totrans-471
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 再次刷新您的浏览器，您会看到它现在显示 `Hello, world!`：![图 1.40：使用变量渲染的模板
- en: '](img/B15509_01_40.jpg)'
  id: totrans-472
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '![图片 B15509_01_40.jpg](img/B15509_01_40.jpg)'
- en: 'Figure 1.40: A template rendered with a variable'
  id: totrans-473
  prefs: []
  type: TYPE_NORMAL
  zh: 图 1.40：使用变量渲染的模板
- en: In this exercise, we combined the template we created in the previous exercise
    with the `render` function, to render an HTML page with the `name` variable that
    was passed to it inside a `context` dictionary.
  id: totrans-474
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个练习中，我们将之前练习中创建的模板与 `render` 函数结合起来，以渲染一个包含传递到其中的 `name` 变量的 `context` 字典的
    HTML 页面。
- en: Debugging and Dealing with Errors
  id: totrans-475
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 调试和错误处理
- en: 'When programming, unless you''re the perfect programmer who never makes mistakes,
    you''ll probably have to deal with errors or debug your code at some point. When
    there is an error in your program, there are usually two ways to tell: either
    your code will raise an exception, or you will get an unexpected output or results
    when viewing the page. Exceptions you will probably see more often, as there are
    many accidental ways to cause them. If your code is generating unexpected output,
    but not raising any exceptions, you will probably want to use the PyCharm debugger
    to find out why.'
  id: totrans-476
  prefs: []
  type: TYPE_NORMAL
  zh: 在编程时，除非您是那种从不犯错的完美程序员，否则您可能需要在某个时候处理错误或调试您的代码。当您的程序中发生错误时，通常有两种方式可以告知：要么您的代码会引发异常，要么在查看页面时您会得到意外的输出或结果。您可能会更频繁地遇到异常，因为有许多意外的方式可以引发它们。如果您的代码正在生成意外的输出，但没有引发任何异常，您可能想使用
    PyCharm 调试器来找出原因。
- en: Exceptions
  id: totrans-477
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 异常
- en: 'If you have worked with Python or other programming languages before, you have
    probably come across exceptions. If not, here''s a quick introduction. Exceptions
    are raised (or thrown in other languages) when an error occurs. The execution
    of the program stops at that point in the code, and the exception travels back
    up the function call chain until it is caught. If it is not caught, then the program
    will crash, sometimes with an error message describing the exception and where
    it occurred. There are exceptions that are raised by Python itself, and your code
    can raise exceptions to quickly stop execution at any point. Some common exceptions
    that you might see when programming Python are listed here:'
  id: totrans-478
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您之前使用过 Python 或其他编程语言，您可能已经遇到过异常。如果没有，这里有一个快速介绍。当发生错误时，会引发（或在其他语言中抛出）异常。程序在代码的该点停止执行，异常沿着函数调用链向上传播，直到被捕获。如果没有被捕获，则程序将崩溃，有时会显示一个描述异常及其发生位置的错误消息。Python
    本身会引发异常，您的代码可以在任何位置快速停止执行。这里列出了您在编写 Python 代码时可能会遇到的常见异常：
- en: '`IndentationError`'
  id: totrans-479
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`IndentationError`'
- en: Python will raise this if your code is not correctly indented or has mixed tabs
    and spaces.
  id: totrans-480
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: Python 如果你的代码没有正确缩进或者混合了制表符和空格，将会引发这个错误。
- en: '`SyntaxError`'
  id: totrans-481
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`SyntaxError`'
- en: 'Python raises this error if your code has invalid syntax:'
  id: totrans-482
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 如果你的代码有无效的语法，Python 会引发这个错误：
- en: '[PRE50]'
  id: totrans-483
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE50]'
- en: '`ImportError`'
  id: totrans-484
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`ImportError`'
- en: 'This is raised when an import fails, for example, if trying to import from
    a file that does not exist or trying to import a name that is not set in a file:'
  id: totrans-485
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 当导入失败时（例如，尝试从一个不存在的文件导入，或者尝试导入一个文件中未设置的名字）会引发这个错误：
- en: '[PRE51]'
  id: totrans-486
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE51]'
- en: '`NameError`'
  id: totrans-487
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`NameError`'
- en: 'This is raised when trying to access a variable that has not yet been set:'
  id: totrans-488
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 当尝试访问尚未设置变量的值时会引发这个错误：
- en: '[PRE52]'
  id: totrans-489
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE52]'
- en: '`KeyError`'
  id: totrans-490
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`KeyError`'
- en: 'This is raised when accessing a key that is not set in a dictionary (or dictionary-like
    object):'
  id: totrans-491
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 当访问字典（或类似字典的对象）中未设置的关键字时会引发这个错误：
- en: '[PRE53]'
  id: totrans-492
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE53]'
- en: '`IndexError`'
  id: totrans-493
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`IndexError`'
- en: 'This is raised when accessing an index outside the length of a list:'
  id: totrans-494
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 当尝试访问列表长度之外的索引时会引发这个错误：
- en: '[PRE54]'
  id: totrans-495
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE54]'
- en: '`TypeError`'
  id: totrans-496
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`TypeError`'
- en: 'This is raised when trying to perform an operation on an object that does not
    support it, or when using two objects of the wrong type—for example, trying to
    add a string to an integer:'
  id: totrans-497
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 当尝试对一个不支持该操作的对象执行操作，或者使用错误类型的两个对象时（例如，尝试将一个字符串添加到一个整数上）会引发这个错误：
- en: '[PRE55]'
  id: totrans-498
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE55]'
- en: Django also raises its own custom exceptions, and you will be introduced to
    them throughout the book.
  id: totrans-499
  prefs: []
  type: TYPE_NORMAL
  zh: Django 还会引发它自己的自定义异常，你将在整本书中了解到它们。
- en: When running the Django development server with `DEBUG = True` in your `settings.py`
    file, Django will automatically capture exceptions that occur in your code (instead
    of crashing). It will then generate an HTTP response showing you a stack trace
    and other information to help you debug the problem. When running in production,
    `DEBUG` should be set to `False`. Django will then return a standard internal
    server error page, without any sensitive information. You also have the option
    to display a custom error page.
  id: totrans-500
  prefs: []
  type: TYPE_NORMAL
  zh: 当你在 `settings.py` 文件中将 `DEBUG` 设置为 `True` 并运行 Django 开发服务器时，Django 会自动捕获代码中发生的异常（而不是崩溃）。然后它会生成一个
    HTTP 响应，显示堆栈跟踪和其他信息，以帮助你调试问题。在生产环境中，`DEBUG` 应该设置为 `False`。此时 Django 将返回一个标准的内部服务器错误页面，不包含任何敏感信息。你也可以选择显示自定义错误页面。
- en: 'Exercise 1.08: Generating and Viewing Exceptions'
  id: totrans-501
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 练习 1.08：生成和查看异常
- en: 'Let''s create a simple exception in our view so you are familiar with how Django
    displays them. In this case, we''ll try to use a variable that doesn''t exist,
    which will raise `NameError`:'
  id: totrans-502
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们在视图中创建一个简单的异常，这样你就可以熟悉 Django 如何显示它们。在这种情况下，我们将尝试使用一个不存在的变量，这将引发 `NameError`：
- en: 'In PyCharm, open `views.py`. In the `index` view function, change the context
    being sent to the `render` function so that it''s using a variable that doesn''t
    exist. We''ll try to send `invalid_name` in the context dictionary, instead of
    `name`. Don''t change the context dictionary key, just its value:'
  id: totrans-503
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 PyCharm 中打开 `views.py`。在 `index` 视图函数中，更改发送给 `render` 函数的上下文，使其使用一个不存在的变量。我们将尝试在上下文字典中使用
    `invalid_name` 而不是 `name`。不要更改上下文字典的键，只需更改其值：
- en: '[PRE56]'
  id: totrans-504
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE56]'
- en: 'Go back to your browser and refresh the page. You should see a screen like
    *Figure 1.41*:![Figure 1.41: A Django exception screen'
  id: totrans-505
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '返回你的浏览器并刷新页面。你应该会看到一个像 *图 1.41* 的屏幕：![图 1.41: Django 异常屏幕'
- en: '](img/B15509_01_41.jpg)'
  id: totrans-506
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '![图片 B15509_01_41.jpg](img/B15509_01_41.jpg)'
- en: 'Figure 1.41: A Django exception screen'
  id: totrans-507
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '图 1.41: Django 异常屏幕'
- en: 'The first couple of header lines on the page tell you the error that occurred:'
  id: totrans-508
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 页面上方的前几行标题告诉你发生了什么错误：
- en: '[PRE57]'
  id: totrans-509
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE57]'
- en: 'Below the header is a traceback to where the exception occurred. You can click
    on the various lines of code to expand them and see the surrounding code or click
    `Local vars` for each frame to expand them and see what the values of the variables
    are:![Figure 1.42: The line that causes the exception'
  id: totrans-510
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '在标题下方是异常发生的跟踪信息。你可以点击代码的各个行来展开它们，查看周围的代码，或者点击每个帧的 `Local vars` 来展开它们，查看变量的值：![图
    1.42: 引发异常的行'
- en: '](img/B15509_01_42.jpg)'
  id: totrans-511
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '![图片 B15509_01_42.jpg](img/B15509_01_42.jpg)'
- en: 'Figure 1.42: The line that causes the exception'
  id: totrans-512
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '图 1.42: 引发异常的行'
- en: In our case, we can see the exception was raised on *line 6* of our `views.py`
    file and, expanding `Local vars`, we see `name` has the value `world` and the
    only other variable is the incoming `request` (*Figure 1.42*).
  id: totrans-513
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在我们的例子中，我们可以看到异常是在 `views.py` 文件的第 *6* 行引发的，展开 `Local vars`，我们看到 `name` 的值是
    `world`，唯一的另一个变量是传入的 `request`（*图 1.42*）。
- en: Go back to `views.py` and fix your `NameError` by renaming `invalid_name` back
    to `name`.
  id: totrans-514
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 返回 `views.py` 并通过将 `invalid_name` 重命名为 `name` 来修复你的 `NameError`。
- en: Save the file and refresh your browser and `Hello World` should be displayed
    again (as in *Figure 1.40*).
  id: totrans-515
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 保存文件并刷新浏览器，`Hello World` 应该再次显示（如 *图 1.40* 所示）。
- en: In this exercise, we made our Django code raise an exception (`NameError`) by
    trying to use a variable that had not been set. We saw that Django automatically
    sent details of this exception and a stack trace to the browser to help us find
    the cause of the error. We then reverted our code change to make sure our view
    worked properly.
  id: totrans-516
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个练习中，我们通过尝试使用一个尚未设置的变量来使我们的 Django 代码引发异常（`NameError`）。我们看到了 Django 自动将此异常的详细信息以及堆栈跟踪发送到浏览器，以帮助我们找到错误的原因。然后我们撤销了代码更改，以确保我们的视图能够正常工作。
- en: Debugging
  id: totrans-517
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 调试
- en: When you're trying to find problems in your code, it can help to use a debugger.
    This is a tool that lets you go through your code line by line, rather than executing
    it all at once. Each time the debugger is paused on a particular line of code,
    you can see the values of all the current variables. This is very useful for finding
    out errors in your code that don't raise exceptions.
  id: totrans-518
  prefs: []
  type: TYPE_NORMAL
  zh: 当您试图查找代码中的问题时，使用调试器可能会有所帮助。这是一个工具，它允许您逐行执行代码，而不是一次性执行所有代码。每次调试器在特定的代码行上暂停时，您都可以看到所有当前变量的值。这对于找出不会引发异常的代码错误非常有用。
- en: For example, in Bookr, we have talked about having a view that fetches a list
    of books from the database and renders them in an HTML template. If you view the
    page in the browser, you might see only one book when you expect several. You
    could have the execution pause inside your view function and see what values were
    fetched from the database. If your view is only receiving one book from the database,
    you know there is a problem with your database querying somewhere. If your view
    is successfully fetching multiple books but only one is being rendered, then it's
    probably a problem with the template. Debugging helps you narrow down faults like
    this.
  id: totrans-519
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，在 Bookr 中，我们讨论了有一个视图从数据库中获取书籍列表并在 HTML 模板中渲染它们的场景。如果你在浏览器中查看页面，当你期望看到多本书时，你可能会只看到一本书。你可以在你的视图函数内部暂停执行，查看从数据库中获取了哪些值。如果你的视图只从数据库接收一本书，那么你知道你的数据库查询某处存在问题。如果你的视图成功获取了多本书但只渲染了一本，那么可能是一个模板的问题。调试可以帮助你缩小这类错误的范围。
- en: PyCharm has a built-in debugger to make it easy to step through your code and
    see what is happening on each line. To tell the debugger where to stop the execution
    of the code, you need to set a *breakpoint* on one or more lines of code. They
    are named as such because the execution of the code will *break* (stop) at that
    *point*.
  id: totrans-520
  prefs: []
  type: TYPE_NORMAL
  zh: PyCharm 内置了调试器，这使得您可以轻松地逐行执行代码并查看每行的执行情况。为了告诉调试器在代码的哪个位置停止执行，您需要在代码的一行或多行上设置一个
    *断点*。它们之所以被这样命名，是因为代码的执行将在那个 *点* 上 *中断*（停止）。
- en: For breakpoints to be activated, PyCharm needs to be set to run your project
    in its debugger. There is a small performance penalty but it usually is not noticeable,
    so you might choose to always run your code inside the debugger so that you can
    quickly set a breakpoint without having to stop and restart the Django dev server.
  id: totrans-521
  prefs: []
  type: TYPE_NORMAL
  zh: 为了激活断点，PyCharm 需要设置为在调试器中运行您的项目。这会有轻微的性能损失，但通常不明显，因此您可能选择始终在调试器中运行代码，这样您就可以快速设置断点而无需停止和重新启动
    Django 开发服务器。
- en: Running the Django dev server inside the debugger is as simple as clicking the
    debug icon instead of the play icon (see *Figure 1.19*) to start it.
  id: totrans-522
  prefs: []
  type: TYPE_NORMAL
  zh: 在调试器内运行 Django 开发服务器就像点击调试图标而不是播放图标（见 *图 1.19*）来启动它。
- en: 'Exercise 1.09: Debugging Your Code'
  id: totrans-523
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 练习 1.09：调试您的代码
- en: 'In this exercise, you will learn the basics of the PyCharm debugger. You will
    run the Django dev server in the debugger and then set a breakpoint in your view
    function to pause execution so you can examine the variables:'
  id: totrans-524
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个练习中，您将学习 PyCharm 调试器的基础知识。您将在调试器中运行 Django 开发服务器，然后在您的视图函数中设置一个断点以暂停执行，这样您就可以检查变量：
- en: 'If the Django dev server is running, stop it by clicking the *stop* button
    in the top-right corner of the PyCharm window:![Figure 1.43: Stop button in the
    top-right corner of the PyCharm window'
  id: totrans-525
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果 Django 开发服务器正在运行，可以通过点击 PyCharm 窗口右上角的 *停止* 按钮来停止它：![图 1.43：PyCharm 窗口右上角的停止按钮
- en: '](img/B15509_01_43.jpg)'
  id: totrans-526
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '](img/B15509_01_43.jpg)'
- en: 'Figure 1.43: Stop button in the top-right corner of the PyCharm window'
  id: totrans-527
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 图 1.43：PyCharm 窗口右上角的停止按钮
- en: Start the Django dev server again inside the debugger by clicking the debug
    icon just to the left of the stop button (*Figure 1.43*).
  id: totrans-528
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 通过点击停止按钮左侧的调试图标（*图 1.43*）再次在调试器内启动 Django 开发服务器。
- en: The server will take a few seconds to start, then you should be able to refresh
    the page in your browser to make sure it's still loading—you shouldn't notice
    any changes; all the code is executed the same as before.
  id: totrans-529
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 服务器将花费几秒钟时间启动，然后你应该能够刷新浏览器中的页面以确保它仍在加载——你不应该注意到任何变化；所有代码的执行与之前相同。
- en: 'Now we can set a breakpoint that will cause execution to stop so we can see
    the state of the program. In PyCharm, click just to the right of the line numbers,
    on line 5, in the gutter on the left of the editor pane. A red circle will appear
    to indicate the breakpoint is now active:![Figure 1.44: A breakpoint on line 5'
  id: totrans-530
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在我们可以设置一个断点，这将导致执行停止，以便我们可以看到程序的状态。在 PyCharm 中，点击行号右侧的第 5 行，在编辑器面板左侧的空白处。一个红色圆圈将出现以指示断点现在处于活动状态：![图
    1.44：第 5 行的断点
- en: '](img/B15509_01_44.jpg)'
  id: totrans-531
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '](img/B15509_01_44.jpg)'
- en: 'Figure 1.44: A breakpoint on line 5'
  id: totrans-532
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 图 1.44：第 5 行的断点
- en: 'Go back to your browser and refresh the page. Your browser will not display
    any content; instead, it will just continue to try to load the page. Depending
    on your operating system, PyCharm should become active again; if not, bring it
    to the foreground. You should see that line 5 is highlighted and at the bottom
    of the window, the debugger is shown. The stack frames (the chain of functions
    that were called to get to the current line) are on the left and current variables
    of the function are on the right:![Figure 1.45: The debugger paused with the current
    line (5) highlighted'
  id: totrans-533
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 返回到你的浏览器并刷新页面。你的浏览器将不会显示任何内容；相反，它将继续尝试加载页面。根据你的操作系统，PyCharm 应该再次变得活跃；如果不是，将其带到前台。你应该看到第
    5 行被高亮显示，在窗口底部，调试器被显示。堆栈帧（调用当前行的函数链）在左侧，函数的当前变量在右侧：![图 1.45：调试器暂停，当前行（5）高亮显示
- en: '](img/B15509_01_45.jpg)'
  id: totrans-534
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '](img/B15509_01_45.jpg)'
- en: 'Figure 1.45: The debugger paused with the current line (5) highlighted'
  id: totrans-535
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 图 1.45：调试器暂停，当前行（5）被高亮显示
- en: 'There is currently one variable in scope, `request`. If you click the toggle
    triangle to the left of its name, you can show or hide the attributes it has set:![Figure
    1.46: The attributes of the request variable'
  id: totrans-536
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 当前作用域中有一个变量，`request`。如果你点击其名称左侧的切换三角形，你可以显示或隐藏它设置的属性：![图 1.46：request 变量的属性
- en: '](img/B15509_01_46.jpg)'
  id: totrans-537
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '](img/B15509_01_46.jpg)'
- en: 'Figure 1.46: The attributes of the request variable'
  id: totrans-538
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 图 1.46：request 变量的属性
- en: For example, if you scroll down through the list of attributes, you can see
    that the method is `GET` and the path is `/`.
  id: totrans-539
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 例如，如果你滚动通过属性列表，你可以看到方法是 `GET` 而路径是 `/`。
- en: 'The actions bar, shown in *Figure 1.47*, is above the stack frames and variables.
    Its buttons (from left to right) are as follows:![Figure 1.47: The actions bar'
  id: totrans-540
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '*图 1.47* 中显示的操作栏位于堆栈帧和变量之上。其按钮（从左到右）如下所示：![图 1.47：操作栏'
- en: '](img/B15509_01_47.jpg)'
  id: totrans-541
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '](img/B15509_01_47.jpg)'
- en: 'Figure 1.47: The actions bar'
  id: totrans-542
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 图 1.47：操作栏
- en: '*Step Over*'
  id: totrans-543
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*Step Over*'
- en: Execute the current line of code and continue to the next line.
  id: totrans-544
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: 执行当前行代码并继续到下一行。
- en: '*Step Into*'
  id: totrans-545
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*Step Into*'
- en: Step into the current line. For example, if the line contained a function, it
    would continue with the debugger inside this function.
  id: totrans-546
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: 进入当前行。例如，如果该行包含一个函数，它将在这个函数内部继续使用调试器。
- en: '*Step Into My Code*'
  id: totrans-547
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*Step Into My Code*'
- en: Step into the line being executed but continue until it finds code you have
    written. For example, if you're stepping into a third-party library code that
    later calls your code, it will not show you the third-party code, instead of continuing
    through until it returns to the code that you have written.
  id: totrans-548
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: 进入正在执行的行，但继续执行直到找到你编写的代码。例如，如果你进入第三方库代码，稍后调用你的代码，它将不会显示第三方代码，而是继续执行直到返回到你编写的代码。
- en: '*Force Step Into*'
  id: totrans-549
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*Force Step Into*'
- en: Step into code that would normally not be stepped into, such as Python standard
    library code. This is only available in some rare cases and is normally not used.
  id: totrans-550
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: 进入通常不会进入的代码，例如 Python 标准库代码。这仅在少数情况下可用，并且通常不使用。
- en: '*Step Out*'
  id: totrans-551
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*Step Out*'
- en: Return back out of the current code to the function or method that called it.
    The opposite of the *Step In* action.
  id: totrans-552
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: 从当前代码返回到调用它的函数或方法。与 *Step In* 动作相反。
- en: '*Run To Cursor*'
  id: totrans-553
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*Run To Cursor*'
- en: If you have a line of code further along from where currently are that you want
    to execute without having to click *Step Over* for all the lines in between, click
    to put your cursor on that line. Then, click *Run To Cursor*, and execution will
    continue until that line.
  id: totrans-554
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: 如果你有一行代码在你当前所在位置之后，你想执行而不必点击 *Step Over* 之间的所有行，请将光标移到该行。然后，点击 *Run To Cursor*，执行将继续到该行。
- en: Note that not all buttons are useful all the time. For example, it can be easy
    to step out of your view and end up confusing Django library code.
  id: totrans-555
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: 注意，并非所有按钮在所有时候都很有用。例如，很容易从你的视图中退出，并最终混淆 Django 库代码。
- en: Click the *Step Over* button once to execute line 5\.
  id: totrans-556
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 点击一次 *Step Over* 按钮来执行第 5 行\.
- en: 'You can see the `name` variable has been added to the list of variables in
    the debugger view, and its value is `world`:![Figure 1.48: The new name variable
    is now in scope, with the value world'
  id: totrans-557
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 你可以看到 `name` 变量已经被添加到调试器视图中的变量列表中，其值为 `world`：![图 1.48：新的名称变量现在在作用域内，其值为 world
- en: '](img/B15509_01_48.jpg)'
  id: totrans-558
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '](img/B15509_01_48.jpg)'
- en: 'Figure 1.48: The new name variable is now in scope, with the value world'
  id: totrans-559
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 图 1.48：新的名称变量现在在作用域内，其值为 world
- en: 'We are now at the end of our `index` view function, and if we were to step
    over this line of code, it would jump to Django library code, which we don''t
    want to see. To continue executing and send the response back to your browser,
    click the `Resume Program` button on the left of the window (*Figure 1.49*). You
    should see that your browser has now loaded the page again:![Figure 1.49: Actions
    to control execution—the green play icon'
  id: totrans-560
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们现在到达了 `index` 视图函数的末尾，如果我们继续执行此行代码，它将跳转到 Django 库代码，而我们不想看到这些代码。要继续执行并将响应发送回浏览器，请点击窗口左侧的
    `Resume Program` 按钮(*图 1.49*)。你应该看到浏览器已经重新加载了页面：![图 1.49：控制执行的动作——绿色播放图标
- en: is the Resume Program button
  id: totrans-561
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 是 Resume Program 按钮
- en: '](img/B15509_01_49.jpg)'
  id: totrans-562
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '](img/B15509_01_49.jpg)'
- en: 'Figure 1.49: Actions to control execution—the green play icon is the Resume
    Program button'
  id: totrans-563
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 图 1.49：控制执行的动作——绿色播放图标是 Resume Program 按钮
- en: There are more buttons in *Figure 1.49*; from the top, they are `Rerun` (stops
    the program and restarts it), `Resume Program` (continues running until the next
    breakpoint), `Pause Program` (breaks the program at its current execution point),
    `Stop` (stops the debugger), `View Breakpoints` (opens a window to see all breakpoints
    you have set), and `Mute Breakpoints` (which will toggle all breakpoints on or
    off, but not remove them).
  id: totrans-564
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 在 *图 1.49* 中还有更多按钮；从上到下，它们是 `Rerun`（停止程序并重新启动），`Resume Program`（继续运行直到下一个断点），`Pause
    Program`（在当前执行点中断程序），`Stop`（停止调试器），`View Breakpoints`（打开一个窗口以查看你设置的断点），和 `Mute
    Breakpoints`（将切换所有断点的开或关，但不会删除它们）。
- en: 'For now, turn off the breakpoint in PyCharm by clicking it (the red circle
    next to line 5):![Figure 1.50: Clicking the breakpoint that was on line 5 disables
    it'
  id: totrans-565
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，通过点击它（第 5 行旁边的红色圆圈）在 PyCharm 中关闭断点：![图 1.50：点击位于第 5 行的断点可以禁用它
- en: '](img/B15509_01_50.jpg)'
  id: totrans-566
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '](img/B15509_01_50.jpg)'
- en: 'Figure 1.50: Clicking the breakpoint that was on line 5 disables it'
  id: totrans-567
  prefs: []
  type: TYPE_NORMAL
  zh: 图 1.50：点击位于第 5 行的断点可以禁用它
- en: This is just a quick introduction to how to set breakpoints in PyCharm. If you
    have used debugging features in other IDEs, then you should be familiar with the
    concepts—you can step through code, step in and out of functions, or evaluate
    expressions. Once you have set a breakpoint, you can right-click on it to change
    options. For example, you can make the breakpoint conditional so that execution
    stops only under certain circumstances. All this is beyond the scope of this book
    but it's useful to know about when trying to solve problems in your code.
  id: totrans-568
  prefs: []
  type: TYPE_NORMAL
  zh: 这只是对如何在 PyCharm 中设置断点的快速介绍。如果你在其他 IDE 中使用过调试功能，那么你应该熟悉这些概念——你可以逐行执行代码，进入和退出函数，或者评估表达式。一旦设置了断点，你可以右键单击它来更改选项。例如，你可以使断点条件化，以便仅在特定情况下停止执行。所有这些内容都超出了本书的范围，但在尝试解决代码中的问题时了解这些是有用的。
- en: 'Activity 1.01: Creating a Site Welcome Screen'
  id: totrans-569
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 活动 1.01：创建站点欢迎屏幕
- en: The Bookr website that we are building needs to have a splash page that welcomes
    users and lets them know what site they are on. It will also contain links to
    other parts of the site, but these will be added in later chapters. For now, you
    will create a page with a welcome message.
  id: totrans-570
  prefs: []
  type: TYPE_NORMAL
  zh: 我们正在构建的 Bookr 网站需要一个欢迎页面，欢迎用户并告知他们所在的网站。它还将包含到网站其他部分的链接，但这些将在后面的章节中添加。现在，你将创建一个带有欢迎信息的页面。
- en: 'These steps will help you complete the activity:'
  id: totrans-571
  prefs: []
  type: TYPE_NORMAL
  zh: 这些步骤将帮助你完成活动：
- en: In your `index` view, render the `base.html` template.
  id: totrans-572
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在你的`index`视图中，渲染`base.html`模板。
- en: Update the `base.html` template to contain the welcome message. It should be
    in both the `<title>` tag in `<head>` and in a new `<h1>` tag in the body.
  id: totrans-573
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 更新`base.html`模板以包含欢迎信息。它应位于`<head>`中的`<title>`标签和正文中新的`<h1>`标签中。
- en: 'After completing the activity, you should be able to see something like this:'
  id: totrans-574
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 完成活动后，你应该能看到类似这样的内容：
- en: '![Figure 1.51: Bookr welcome page'
  id: totrans-575
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '![图 1.51：Bookr 欢迎页面'
- en: '](img/B15509_01_51.jpg)'
  id: totrans-576
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '![图片 B15509_01_51.jpg]'
- en: 'Figure 1.51: Bookr welcome page'
  id: totrans-577
  prefs: []
  type: TYPE_NORMAL
  zh: 图 1.51：Bookr 欢迎页面
- en: Note
  id: totrans-578
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: The solution to this activity can be found at [http://packt.live/2Nh1NTJ](http://packt.live/2Nh1NTJ).
  id: totrans-579
  prefs: []
  type: TYPE_NORMAL
  zh: 本活动的解决方案可以在[http://packt.live/2Nh1NTJ](http://packt.live/2Nh1NTJ)找到。
- en: 'Activity 1.02: Book Search Scaffold'
  id: totrans-580
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 活动一.02：图书搜索框架
- en: A useful feature for a site like Bookr is the ability to search through the
    data to find something on the site quickly. Bookr will implement book searching,
    to allow users to find a particular book by part of its title. While we don't
    have any books to find yet, we can still implement a page that shows the text
    the user searched for. The user enters the search string as part of the URL parameters.
    We will implement the searching and a form for easy text entry in *Chapter 6*,
    *Forms*.
  id: totrans-581
  prefs: []
  type: TYPE_NORMAL
  zh: 对于像Bookr这样的网站来说，一个有用的功能是能够搜索数据以快速找到网站上的内容。Bookr将实现图书搜索功能，允许用户通过书籍标题的一部分来查找特定的书籍。虽然我们目前还没有任何书籍可以查找，但我们仍然可以实施一个显示用户搜索文本的页面。用户将搜索字符串作为URL参数的一部分输入。我们将在*第6章*，*表单*中实现搜索和一个易于文本输入的表单。
- en: 'These steps will help you complete the activity:'
  id: totrans-582
  prefs: []
  type: TYPE_NORMAL
  zh: 这些步骤将帮助你完成活动：
- en: Create a search result HTML template. It should include a variable placeholder
    to show the search word(s) that were passed in through the render context. Show
    the passed-in variable in the `<title>` and `<h1>` tags. Use an `<em>` tag around
    the search text in the body to make it italic.
  id: totrans-583
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个搜索结果HTML模板。它应该包含一个变量占位符，以显示通过渲染上下文传递的搜索词。在`<title>`和`<h1>`标签中显示传递的变量。在正文中使用`<em>`标签包围搜索文本，使其变为斜体。
- en: Add a search view function in `views.py`. The view should read a search string
    from the URL parameters (in the request's `GET` attribute). It should then render
    the template you created in the previous step, passing in the search value to
    be substituted, using the context dictionary.
  id: totrans-584
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`views.py`中添加一个搜索视图函数。该视图应从URL参数（请求的`GET`属性）中读取搜索字符串。然后，它应该渲染你在上一步创建的模板，传递要替换的搜索值，使用上下文字典。
- en: Add a URL mapping to your new view to `urls.py`. The URL can be something like
    `/book-search`.
  id: totrans-585
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将新视图的URL映射添加到`urls.py`文件中。URL可以是类似`/book-search`的内容。
- en: 'After completing this activity, you should be able to pass in a search value
    through the URL''s parameters and see it rendered on the resulting page. It should
    look like this:'
  id: totrans-586
  prefs: []
  type: TYPE_NORMAL
  zh: 完成此活动后，你应该能够通过URL的参数传递一个搜索值，并在结果页面上看到它被渲染。它应该看起来像这样：
- en: '![Figure 1.52: Searching for Web Development with Django'
  id: totrans-587
  prefs: []
  type: TYPE_NORMAL
  zh: '![图 1.52：搜索使用Django进行Web开发'
- en: '](img/B15509_01_52.jpg)'
  id: totrans-588
  prefs: []
  type: TYPE_NORMAL
  zh: '![图片 B15509_01_52.jpg]'
- en: 'Figure 1.52: Searching for Web Development with Django'
  id: totrans-589
  prefs: []
  type: TYPE_NORMAL
  zh: 图 1.52：搜索使用Django进行Web开发
- en: 'You should also be able to pass in special HTML characters such as `<` and
    `>` to see how Django automatically escapes them in the template:'
  id: totrans-590
  prefs: []
  type: TYPE_NORMAL
  zh: 你还应该能够传递特殊HTML字符，如`<`和`>`，以查看Django如何在模板中自动转义它们：
- en: '![Figure 1.53: Notice how HTML characters are escaped so we are protected from
    tag injection'
  id: totrans-591
  prefs: []
  type: TYPE_NORMAL
  zh: '![图 1.53：注意HTML字符是如何被转义的，这样我们就可以防止标签注入'
- en: '](img/B15509_01_53.jpg)'
  id: totrans-592
  prefs: []
  type: TYPE_NORMAL
  zh: '![图片 B15509_01_53.jpg]'
- en: 'Figure 1.53: Notice how HTML characters are escaped so we are protected from
    tag injection'
  id: totrans-593
  prefs: []
  type: TYPE_NORMAL
  zh: 图 1.53：注意HTML字符是如何被转义的，这样我们就可以防止标签注入
- en: Note
  id: totrans-594
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: The solution to this activity can be found at [http://packt.live/2Nh1NTJ](http://packt.live/2Nh1NTJ).
  id: totrans-595
  prefs: []
  type: TYPE_NORMAL
  zh: 本活动的解决方案可以在[http://packt.live/2Nh1NTJ](http://packt.live/2Nh1NTJ)找到。
- en: You have scaffolded the book search view and can demonstrate how variables are
    read from the `GET` parameters. You can also use this view to test how Django
    escapes special HTML characters automatically in a template. The search view does
    not actually search or show results yet, as there are no books in the database,
    but this will be added in *Chapter 6*, *Forms*.
  id: totrans-596
  prefs: []
  type: TYPE_NORMAL
  zh: 你已经构建了图书搜索视图，可以展示如何从`GET`参数中读取变量。你还可以使用此视图来测试Django如何在模板中自动转义特殊HTML字符。搜索视图实际上还没有搜索或显示结果，因为数据库中没有书籍，但这一点将在*第6章*，*表单*中添加。
- en: Summary
  id: totrans-597
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: This chapter was a quick introduction to Django. You first got up to speed on
    the HTTP protocol and the structure of HTTP requests and responses. We then saw
    how Django uses the MVT paradigm, and then how it parses a URL, generates an HTTP
    request, and sends it to a view to get an HTTP response. We scaffolded the Bookr
    project and then created the `reviews` app for it. We then built two example views
    to illustrate how to get data from a request and use it when rendering templates.
    You should have experimented to see how Django escapes output in HTML when rendering
    a template.
  id: totrans-598
  prefs: []
  type: TYPE_NORMAL
  zh: 本章简要介绍了Django。你首先了解了HTTP协议以及HTTP请求和响应的结构。然后我们看到了Django如何使用MVT范式，以及它是如何解析URL、生成HTTP请求并将其发送到视图以获取HTTP响应的。我们为Bookr项目搭建了框架，并为它创建了`reviews`应用。接着，我们构建了两个示例视图来展示如何从请求中获取数据并在渲染模板时使用它。你应该已经尝试过，看看Django在渲染模板时如何在HTML中转义输出。
- en: You did all this with the PyCharm IDE, and you learned how to set it up to debug
    your application. The debugger will help you find out why things aren't working
    as they should. In the next chapter, you will start to learn about Django's database
    integration and its model system, so you can start storing and retrieving real
    data for your application.
  id: totrans-599
  prefs: []
  type: TYPE_NORMAL
  zh: 你使用PyCharm IDE完成了所有这些，并学习了如何设置它以调试你的应用程序。调试器将帮助你找出为什么事情没有按预期工作。在下一章中，你将开始学习Django的数据库集成及其模型系统，这样你就可以开始为你的应用程序存储和检索真实数据了。
