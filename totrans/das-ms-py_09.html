<html><head></head><body>
        

                            
                    <h1 class="header-title">Unit Testing</h1>
                
            
            
                
<p>In the previous chapter, we saw various approaches to metaprogramming and programmable syntax in Python. In this chapter, we're going to take a look at the ideas behind unit testing, then move on to several test automation tools we can use to make our testing easier and more useful. We'll focus on what unit testing is, and the ideas that motivate it. We'll also discuss Python's standard <kbd>unittest</kbd> package and how it works.</p>
<p>Finally, you'll learn how to use <kbd>unittest.mock</kbd> to control the environment that your test code will run in so that the test will remain focused on making sure one thing works properly.</p>
<p>In this chapter, we'll cover the following topics:</p>
<ul>
<li>Understanding the principle of unit testing</li>
<li>Using the unittest package</li>
<li>Using unittest.mock</li>
<li>Using unittest's test discovery</li>
<li>Using nose for unified test discovery and reporting</li>
</ul>


            

            
        
    

        

                            
                    <h1 class="header-title">Understanding the principle of unit testing</h1>
                
            
            
                
<p>Testing is often something of an afterthought for programmers because it tends to be laborious and annoying. Also, we usually have a high degree of confidence in our work and testing it seems unnecessary. It's also a fact, though, that the confidence is often misplaced. Source code is a complex and subtle language, and it's easy to make mistakes while writing it and not even notice them. We all know this from experience, but that doesn't make it any easier to make time for something that is laborious, annoying, and feels unnecessary. The following flow diagram illustrates a simple example of testing:</p>
<div><img height="382" width="284" class="aligncenter size-full wp-image-909 image-border" src="img/946c5ebf-b5e3-4b24-83a8-1151da7c5ade.png"/></div>
<p>So, the first question about testing is, <em>How can we do it in a way that doesn't feel like a painful waste of time?</em> Finding a way to overcome this psychological barrier is the first step toward creating a testing method that will actually work for a lot of programmers. Unit testing does this by reducing the effort needed to run tests, integrating testing with the development process, and making the tests themselves visibly useful.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">What is a unit test?</h1>
                
            
            
                
<p>First of all, let's find out what is a unit test. A <strong>unit test</strong> is a single small chunk of test code that tests correct behavior or a single specific flaw within an isolated small chunk of program code.</p>
<p>There are reasons for each part of this definition. A unit test is source code because one of the secrets of unit testing is that we put the maximum amount of the effort of testing on the computer, which is where it should belong.</p>
<p>The test code tells the computer how to perform the test, which allows us to perform the test often and easily. A unit test is small because a large test is almost inevitably testing for more than one thing.</p>
<p>This can be summarized as:</p>
<ul>
<li>Small, simple code</li>
<li>Checks a small piece of the program</li>
<li>Answers a single yes-or-no question about program functionality</li>
</ul>
<p>If we want to test for more than one thing, we should write more than one test.</p>
<p>There are two rules for a unit test. These are:</p>
<ul>
<li>A unit test only checks a single aspect of the program code because when a test fails, we want it to tell us exactly what the problem is</li>
<li>A unit test only involves a narrow region of the program code because when a test fails, we want it to tell us exactly where the problem is</li>
</ul>
<p>If we write a collection of tests that follow these rules, they are called a <strong>unit test suite</strong>.</p>
<p>With proper tools, we can run our whole test suite with a single command, and the output of this command will immediately tell us the status of our code with respect to the test. If the test fails, it tells us what we need to work on next. If it succeeds, it gives us a reason to build our confidence in the code it tested.</p>
<p>The availability of automated unit testing leads to a programming paradigm called <strong>test-driven development</strong> (<strong>TDD</strong>), as illustrated in the following diagram:</p>
<div><img height="409" width="700" class="aligncenter size-full wp-image-910 image-border" src="img/fe2f8b4b-45c7-4c35-8aa2-069f0cc3fd2b.png"/></div>
<p>The basic idea of TDD is that since a failing test tells us what to do next, we should never write program code except when we want to make a failing test pass. If all the presently available tests pass and the program isn't finished, we first add another test to the test suite, and then write program code to make it pass.</p>
<p>Doing things this way ensures that there are tests that cover most or all of the source code and that the tests are run often, which makes it very difficult for bugs and regressions to sneak into the code without being noticed. It also lets us break the development process down into a series of short-term goals, which produce a visible result when we achieve them.</p>
<p>This is psychologically useful because it makes the programming process feel more productive, and it's much easier to perform a task that feels rewarding. Further, debugging tends to dominate the time needed for a project, and TDD reduces the time needed to deal with bugs.</p>
<p>So, when applied properly, unit testing principles and tools help us produce better code, perform the test faster, and enjoy the process more. It's an all-round win.</p>
<p>So far, we've had a high-level discussion of the reasons for and the benefits of automated unit testing and TDD. Python includes a framework for automated unit testing, and we'll take a look at it in the next section.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">Using the unittest package</h1>
                
            
            
                
<p>In this section, we're going to look at Python's standard <kbd>unittest</kbd> package. We'll talk about how to structure a test file and how to write tests and draw a comparison between what happens and what should happen in these tests. Let's jump straight into it!</p>


            

            
        
    

        

                            
                    <h1 class="header-title">Structuring a test file</h1>
                
            
            
                
<p>The unittest module contains a framework for performing automated unit testing. Most of this functionality is based around the <kbd>unittest.TestCase</kbd> class, which we will inherit from to create our own tests.</p>
<p>In the following example, we see the basic features of <kbd>TestCase</kbd> in action and also test and assert methods:</p>
<div><img height="77" width="253" class="aligncenter size-full wp-image-911 image-border" src="img/dc0b2b97-8c1c-4d63-94ed-c0b2d50ef1dc.jpg"/></div>
<p>Any method that we define using a class inherited from <kbd>TestCase</kbd>, and that has a name that starts with the word <strong>test</strong>, is assumed to be a unit test. In the preceding example, this means that the <kbd>test_addition</kbd> method is a unit test; however, if we had added another method to the class, called <kbd>connect</kbd>, the unittest module would not have treated it as a unit test.</p>
<p>A <kbd>TestCase</kbd> class can contain more than one unit test and should run when those tests are logically related and require the same operating environment.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">assert methods</h1>
                
            
            
                
<p>Inside our <kbd>test_addition</kbd> method, which is a unit test, we used a method called <kbd>assertEqual</kbd> to actually check that the result of the code was as expected. <kbd>TestCase</kbd> provides a wide range of these assert methods that test for various relationships between our results and what we expected. This is shown in the following code example:</p>
<div><img height="316" width="400" class="aligncenter size-full wp-image-504 image-border" src="img/becea722-e559-4054-8783-07e2beede181.png"/></div>
<p>Let's take a closer look at what these assert methods actually do:</p>
<ul>
<li>We've already seen the <kbd>assertEqual</kbd> method in the previous code example; it checks whether two values are equal and makes the test fail if they are not. The <kbd>assertNotEqual</kbd> method performs the inverse operation, checking whether two values are equal and failing the test if they are.</li>
<li>The <kbd>assertAlmostEqual</kbd> and <kbd>assertNotAlmostEqual</kbd> methods are for use with floating point numbers.</li>
</ul>
<p style="padding-left: 60px">The way computers handle floating point numbers indicates that numbers that should be exactly equal actually differ in their least significant bits. For example, if we square the square root of seven, the result is not exactly seven, so <kbd>assertEqual</kbd> will treat it as <em>not equal</em>. However, <kbd>assertAlmostEqual</kbd> will recognize that the two numbers are the same for practical purposes.</p>
<ul>
<li>The <kbd>assertGreaterEqual</kbd>, <kbd>assertLess</kbd>, and <kbd>assertLessEqual</kbd> methods check for ordering relationships between their arguments.</li>
<li>The <kbd>assertIs</kbd> and <kbd>assertIsNot</kbd> methods check whether their arguments are references to the exact same object.</li>
<li>The <kbd>assertIsNone</kbd> and <kbd>assertIsNotNone</kbd> methods are a special case of <kbd>assertIs</kbd> and <kbd>assertIsNot</kbd> methods and check whether their single argument is in fact <kbd>None</kbd>.</li>
<li>The <kbd>assertIsInstance</kbd> and <kbd>assertIsNotInstant</kbd> methods check whether the object in the first argument is an instance of the type in their second argument.</li>
<li>The <kbd>assertIn</kbd> and <kbd>assertNotIn</kbd> check whether the object in the first argument is a member of the container in their second argument.</li>
<li>The <kbd>assertCountEqual</kbd> method is interesting. If we want to check whether two sequences are the same, we could just use <kbd>assertEqual</kbd>, but <kbd>assertCountEqual</kbd> is for when we want to check whether two sequences contain the same values but don't care about the order.</li>
</ul>
<p style="padding-left: 90px">The method will cause a test to fail if any of the members of either sequence appears in the other sequence a different number of times. So, if <kbd>a</kbd> is in the first sequence twice, it has to be in the second sequence twice as well, but we don't care where.</p>
<ul>
<li>Finally, we have <kbd>assertRaises</kbd>, which functions a little differently because it needs to catch the exception raised by running some code. This is a situation tailor-made for a context manager, and that's what <kbd>assertRaises</kbd> is.</li>
</ul>
<p style="padding-left: 60px">Used in a <kbd>with</kbd> statement, <kbd>assertRaises</kbd> makes the test fail if the code inside the with block does not raise the expected exception. This could seem a little backward, but it's correct. The test fails if the expected exception is not raised. Sometimes, raising an exception is the correct behavior. For example, passing <kbd>None</kbd> to the end constructor should raise a type error, and if it doesn't, that's a bug.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">Comparing what happens to what should happen in unit tests</h1>
                
            
            
                
<p>I mentioned in passing that all the unit tests in a <kbd>TestCase</kbd> class should share the same operating environment. What does that mean?</p>
<p>It means that each of them expects any external data that they access to be in the same state. For example, each of the tests accesses a particular file and each of them expects to find the same information inside that file.</p>
<p>Let's have a look at a code example:</p>
<div><img height="337" width="266" class="aligncenter size-full wp-image-912 image-border" src="img/98fa707d-ae87-44d6-9552-ee7c54299fb3.jpg"/></div>
<p>In the preceding example, we have two tests that both read and write in the same text file. Both of them expected to come in to contain the same specific information when they started running. In other words, both of them have the same expectations about their operating environment.</p>
<p>When we have multiple tests that share the same expectations and they're logically related, we should group them into a single <kbd>TestCase</kbd> class. Then, we should give that class a <kbd>setUp</kbd> method, which would be responsible for making sure those shared expectations are met, and possibly a <kbd>tearDown</kbd> method, which would clean up any changes that <kbd>setup</kbd> may have made or the tests left lying around.</p>
<p>The name of the class itself doesn't matter; simply inheriting from <kbd>TestCase</kbd> is sufficient to identify them.</p>
<p>The <kbd>setUp</kbd> method is run before each unit test in <kbd>TestCase</kbd>. So, in our code example, which has two unit tests, <kbd>setUp</kbd> is run twice. Similarly, <kbd>tearDown</kbd> runs after each unit test. That way, the changes that one test might make to the operating environment are removed before the next test is run.</p>
<p>The starting environment is the same for each unit test in <kbd>TestCase</kbd>. So, that's the basic mechanics of Python's unit test framework, as far as writing tests goes.</p>
<p>To run the tests, we just need to invoke the <kbd>unittest</kbd> package from the command line. We tell it the name of the module we want to run the tests from and it finds the <kbd>TestCase</kbd> classes in that module, creates instances of them, runs all their tests, and gives us a report on which test has passed and which failed.</p>
<p>In this section, we've seen how to write basic unit tests and run them. There are even easier ways to run a test, but we'll look at them after we examine unit test mock objects.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">Using unittest.mock</h1>
                
            
            
                
<p>In this section, we'll take a look at a subpackage of unit tests, called <strong>mock</strong>. The tools in the <kbd>mock</kbd> package help us keep our test isolated, so they aren't made to succeed or fail based on the behavior of the code, which isn't supposed to be covered by the test.</p>
<p>We talked about how important it is that unit tests only interact with a small section of code, but how can we arrange for this when so many pieces of code interact with objects and functions originating from all over the source tree? One answer is that we can replace those objects and functions with mock objects.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">What is a mock object?</h1>
                
            
            
                
<p>A mock object is a clever piece of code; it could pretend to be almost any kind of object or function, but instead of doing whatever the original did, it just records what is done with it so we can check it later. Let's play with a mock object for a moment to get a feel for them:</p>
<div><img height="123" width="399" class="aligncenter size-full wp-image-506 image-border" src="img/7f6f5d9c-a63d-47f0-a209-5acfeae4291d.png"/></div>
<p>Refer to the preceding screenshot. We can access pretty much any attribute of the mock object without defining it ahead of time. The result is another mock object. Similarly, we can call almost any method we want without defining it ahead of time and the result is yet another mock object, as shown here:</p>
<div><img height="48" width="417" class="aligncenter size-full wp-image-507 image-border" src="img/5b47ead3-58d4-4b53-ad62-45733cb5c96c.png"/></div>
<p>This by itself is enough to let a mock object replace a large range of functions and objects that our tested code might interact with. But, we can go further if we take time to preconfigure our mock objects.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">Preconfiguring mock objects</h1>
                
            
            
                
<p>We can assign non-mock objects to a mock object's attributes, so that when we access the attribute, we'd get a specific value instead of a generic mock object. This is illustrated by the following simple code example:</p>
<div><img height="58" width="152" class="aligncenter size-full wp-image-508 image-border" src="img/19118bc9-a4f4-4b04-9ac5-99a35565a323.png"/></div>
<p>We can also assign a customized mock object in place of a method so that we can make the mocked method act more like the original, but in a way, this is controlled by the test. We do this by passing a return value parameter to the <kbd>mock</kbd> constructor, which tells the mock object that every time it's called, it should return this value, as shown in the following code example:</p>
<div><img height="91" width="373" class="aligncenter size-full wp-image-509 image-border" src="img/d3f02ce0-f6fc-4068-9296-62b6c58f5af9.png"/></div>
<p>If we want the mock to return different values each time it's called, we use a different parameter of the constructor, called <kbd>side_effect</kbd>, as shown next:</p>
<div><img height="133" width="293" class="aligncenter size-full wp-image-510 image-border" src="img/569e85fd-7bb3-440d-97c1-c9417abb0980.png"/></div>
<p>We have to know how many times the test will call the mock as a function so we can provide a return value for each call; otherwise, this doesn't present a difficulty.</p>
<p>We can also make the mock object raise an exception by passing that exception as <kbd>side_effect</kbd> or a member of the <kbd>side_effect</kbd> sequence, as shown in the following code example:</p>
<div><img height="244" width="451" class="aligncenter size-full wp-image-511 image-border" src="img/ccc3c1a1-9c8a-4d86-a112-76fbd4cda1a4.png"/></div>
<p>That pretty well covers how to make a mock that can, in a controlled way, stand in for real objects and code while we run our test. However, to really support testing, we also need to be able to check the mock and confirm whether it was used as expected.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">assert methods of mock objects</h1>
                
            
            
                
<p>We've already seen the <kbd>method_calls</kbd> attribute that mock objects use to track their interactions, but mock objects also have their own assert methods that are usually easier to use than accessing the method calls' list directly.</p>
<p>The most useful mock object assertion method is <kbd>assert_called_with</kbd> (refer to the following code example):</p>
<div><img height="127" width="368" class="aligncenter size-full wp-image-512 image-border" src="img/6df0132d-256c-402b-b856-50ada446cdb3.png"/></div>
<p>It checks whether the most recent call to the mock object was done with a specified argument and <kbd>assert_any_call</kbd>, which checks whether the mock has ever been called with specified arguments.</p>
<p>So, we know what mock objects are for, how to create them, and how to check the record of what has been done with them. That's enough for replacing the parameters of a tested function with mock objects.</p>
<p>We can even replace the <kbd>self</kbd> parameter of methods if we call the method via the class instead of a real instance:</p>
<div><img height="155" width="302" class="aligncenter size-full wp-image-513 image-border" src="img/69345cc7-00c3-45e4-954c-c75ebfb17d07.png"/></div>


            

            
        
    

        

                            
                    <h1 class="header-title">The unittest.mock patch function</h1>
                
            
            
                
<p>What do we do, though, when the code we're testing reaches out to the system automatically and accesses something we want to replace with a mock object? For example, what if the code we're testing calls <kbd>time.time</kbd>? This is where the <kbd>unittest.mock</kbd><kbd>patch</kbd> function comes into play.</p>
<p>The <kbd>patch</kbd> function is a context manager and it could temporarily replace nearly any object in any package or module with a mock object. Once the with block exits, the real object is restored to its position, as shown in the following code example:</p>
<div><img height="107" width="367" class="aligncenter size-full wp-image-514 image-border" src="img/a79484dd-4f79-4a7b-af0c-66fe2b7650ac.png"/></div>
<p>Something to be aware of is that patch doesn't replace every reference to the target object with a mock; it only replaces the single reference that we specified in the first argument.</p>
<p>In the preceding example, any code that accesses the time function by looking up the reference in the <kbd>time</kbd> module will get our mock object; however, if there were any code that had used <kbd>from time</kbd><kbd>import time</kbd> to create a local reference to the <kbd>time</kbd> function, then that reference would still refer to the real-time function. If we want to patch the time function for code that has a local reference to it, we need to pass the path to that local reference into the patch.</p>
<p>OK, we're pretty much good to go with mock objects now. This means we know everything we need to write powerful tests easily. All we are left to do is find out how to run our test suites, which is our next topic.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">Using unittest's test discovery</h1>
                
            
            
                
<p>In this section, we'll take a look at the <kbd>unittest</kbd> package's ability to run many tests at once with a single command.</p>
<p>We've seen how to easily run all the tests in a particular file, but for a large project, putting all the tests into a single file would be troublesome. They need to be separated into different files according to logical groupings, or the test suite will become unmanageable. On the other hand, it would be a pain to have to manually tell unittests to run the test and a whole bunch of files if we were to test or list out each file.</p>
<p>Fortunately, there's a way to split our test suites into many files and still run them with a simple command, as shown in the following code:</p>
<div><img height="173" width="485" class="aligncenter size-full wp-image-515 image-border" src="img/6033f8db-20e3-48e9-9200-4678b4313bbd.png"/></div>
<p>We use a unit testing tool that supports test discovery. This basically just means it looks at the available files and decides for itself which ones seems like a test file; then it loads the test from those files and runs them.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">Unittest's discovery tool</h1>
                
            
            
                
<p>The <kbd>unittest</kbd> package has a basic but useful built-in test discovery tool. When we run <kbd>python -m unittest discover</kbd>, it searches the current directory for Python S, whose names start with the word <kbd>test</kbd>. In addition, it recursively performs the same scan on any subdirectories that contain an <kbd>init.py</kbd> file. Once it collects the names of all the matching modules, it runs the test just as if we'd specified the modules on the command line ourselves. This can be illustrated using the following code example:</p>
<div><img height="122" width="511" class="aligncenter size-full wp-image-516 image-border" src="img/c5e2ebaf-4813-499b-b5ab-b4d73113f842.png"/></div>


            

            
        
    

        

                            
                    <h1 class="header-title">Command-line options in unit test discovery</h1>
                
            
            
                
<p>There are a few command-line options we can use to adjust the behavior of unit test discovery. The first, which we saw in the previous code example, is the <kbd>-v</kbd> switch. This switch makes test reports somewhat more verbose. We used it in the previous code so we could see that the discovery had worked properly.</p>
<p>We can also use the <kbd>-p</kbd> command-line option (as shown in the following code example) to change the pattern that is used to recognize test files:</p>
<p><img height="145" width="699" class="aligncenter size-full wp-image-517 image-border" src="img/ef21fcda-2637-4042-be24-205bf43016f7.png"/></p>
<p>Here, we've changed it so that the filenames ending in the word <kbd>one.py</kbd> are recognized as test files.</p>
<p>The unittest discover code also recognizes <kbd>-s</kbd> to specify the directory where the test search should start. This is shown in the following code example:</p>
<div><img height="178" width="689" class="aligncenter size-full wp-image-518 image-border" src="img/8642c979-0002-47b1-bee8-224ba8ca01ca.png"/></div>
<p>Notice that by making a suite act as the starting directory for the search, we've stopped it from being recognized as a package containing the test. If that's a problem, we could supplement the <kbd>-s</kbd> option with <kbd>-t</kbd> (refer to the following code example), which tells you to test where to find the top-level directory for this run:</p>
<div><img height="177" width="744" class="aligncenter size-full wp-image-519 image-border" src="img/6dfdadf5-033f-4820-ad29-364dbc8bff55.png"/></div>
<p>Using both <kbd>-s</kbd> and <kbd>-t</kbd>, we're able to narrow the test search to a particular subdirectory while still running the tests in the context of a parent directory.</p>
<p>There's a bit of a pitfall to be aware of when using unit test discovery code or any other test discovery that works by importing modules to check whether they contain tests. This pitfall is that the modules are imported.</p>
<p>Most of the time, that's not a problem, but if a piece of test discovery code imports the module that was meant to be a program's entry point, it might result in actually running the program, which is not the desired behavior. It's easy to avoid this problem when we're writing an entry point by wrapping the entry point code in the <kbd>if '__name__' = = '__main__'</kbd> statement.</p>
<p>However, if we, or somebody else, skips this check and unittest thinks the file looks like a test file, running unit test discovery code will have surprising results. That's all there is in regard to unittest's test discovery tool. It doesn't have many features, but it does have the features that everybody needs, and there's a good chance that it's all we'll need for the majority of our projects.</p>
<p>For cases where we need more from our test discovery tool, we can use <kbd>nose</kbd>, which we'll look at in the next section.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">Using nose for unified test discovery and reporting</h1>
                
            
            
                
<p>Note that <kbd>nose</kbd> is a third-party tool available via <kbd>pip</kbd> and Python Package Index. It does basically the same job as a unittest <kbd>discover</kbd> command, but it supports more control and customization as well as recognizing a wider range of tests. It can be installed using the following command line:</p>
<pre>
<strong>python3 -m pip install nose</strong>
</pre>
<div><strong><strong><img height="120" width="495" class="aligncenter size-full wp-image-522 image-border" src="img/10500722-c392-45b0-a574-59846bb4432a.jpg"/></strong></strong></div>


            

            
        
    

        

                            
                    <h1 class="header-title">Running our tests with nose</h1>
                
            
            
                
<p>We're going to look at two specific features among the many that nose provides. These are:</p>
<ul>
<li>It can generate a code coverage report that tells us how much of the code our test actually tested</li>
<li>It can run tests across multiple processes, allowing them to be executed in parallel on multiple CPUs</li>
</ul>
<p>In order to get a coverage report, we first need to make sure that the coverage module is installed. We could do this with a simple <kbd>pip</kbd> command, as follows:</p>
<pre>
<strong>python3 -m pip install coverage</strong>
</pre>
<div><strong><strong><img height="114" width="468" class="aligncenter size-full wp-image-521 image-border" src="img/e2995c59-4230-46cc-a2bd-aebd4a404923.jpg"/></strong></strong></div>
<p>Once we have the <kbd>coverage</kbd> module in place, we can enable a coverage report for our test with nothing more than a couple of nose's command-line options.</p>
<p>Strictly speaking, only the <kbd>--with-coverage</kbd> option is required to enable the coverage report, as shown in the following code example:</p>
<div><img height="212" width="603" class="aligncenter size-full wp-image-995 image-border" src="img/d070144f-452a-4ba8-9b6c-c0605a196ba0.png"/></div>
<p>However, if we don't include <kbd>--cover-erase</kbd> as well, coverage data from previous test runs will get mixed with our current run, which will make the results harder to interpret.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">The cover-package option</h1>
                
            
            
                
<p>There's a third coverage-related command-line option that is sometimes useful. It is the <kbd>cover-package</kbd> option; it narrows down the code coverage report to only a specific package, as shown in the following code example:</p>
<div><img height="194" width="767" class="aligncenter size-full wp-image-996 image-border" src="img/630e8538-4e98-408f-8698-4a3ddf272273.png"/></div>
<p>Focusing the report this way can make it easier to read and extract useful information.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">Testing multiple worker processes</h1>
                
            
            
                
<p>The other nose feature we're going to look at is the ability to farm out tests to multiple worker processes and thus spread them across the available CPU cores. To test multiple worker processes, we just have to provide the <kbd>--processes=</kbd> command-line option and tell it how many processes to use. If we pass <kbd>-1</kbd> to indicate the number of processes, it uses the detected number of CPU cores, which is probably what we want anyway (refer to the following code example):</p>
<div><img height="121" width="597" class="aligncenter size-full wp-image-997 image-border" src="img/69feb791-f01e-40d2-9bc9-84b05d60e7a2.jpg"/></div>
<p>So, unless we have a specific reason to do otherwise, we should always just use <kbd>-1</kbd>.</p>
<p>If we look carefully at the preceding code example, we can see that it actually took longer to run our test suite on multiple processes. That's because conducting the tests themselves involves low effort, but it's not the same when it comes to launching a worker process. Fortunately, that's a fixed cost, so when we start running larger test suites that contain more expensive tests, we start seeing the benefits of parallel execution.</p>
<p>This was just a taste of the sort of features that nose supports and that's without writing our own nose plugins to customize it further. It's a very capable system, so if we find ourselves needing a particular feature from our test runner, a good first step is to see whether nose already has that feature.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">Summary</h1>
                
            
            
                
<p>In this chapter, we learned how to use the <kbd>unittest</kbd> and <kbd>unittest.mock</kbd> packages to write an automated test; we also learned the process of test-driven development. Next, we saw how to use <kbd>unittest.mock</kbd> to control the environment that our test code runs in so that the test can remain focused on making sure one thing works properly. Post this, we learned how to run a test using Python's built-in unit test tools, and finally, we discussed how to take advantage of a couple of features of the nose test runner.</p>
<p>In the next chapter, we're going to take a look at the reactive programming paradigm and RxPY.</p>


            

            
        
    </body></html>