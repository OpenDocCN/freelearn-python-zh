["```py\n#!/usr/bin/env python3 \n#rover_drivefwd.py \n#HARDWARE SETUP \n# GPIO \n# 2[==X====LR====]26[=======]40 \n# 1[=============]25[=======]39 \nimport time \nimport wiringpi2 \nON=1;OFF=0 \nIN=0;OUT=1 \nSTEP=0.5 \nPINS=[16,18] # PINS=[L-motor,R-motor] \nFWD=[ON,ON] \nRIGHT=[ON,OFF] \nLEFT=[OFF,ON] \nDEBUG=True \n\nclass motor: \n  # Constructor \n  def __init__(self,pins=PINS,steptime=STEP): \n    self.pins = pins \n    self.steptime=steptime \n    self.GPIOsetup() \n\n  def GPIOsetup(self): \n    wiringpi2.wiringPiSetupPhys() \n    for gpio in self.pins: \n      wiringpi2.pinMode(gpio,OUT) \n\n  def off(self): \n    for gpio in self.pins: \n      wiringpi2.digitalWrite(gpio,OFF) \n\n  def drive(self,drive,step=STEP): \n    for idx,gpio in enumerate(self.pins): \n      wiringpi2.digitalWrite(gpio,drive[idx]) \n      if(DEBUG):print(\"%s:%s\"%(gpio,drive[idx])) \n    time.sleep(step) \n    self.off() \n\n  def cmd(self,char,step=STEP): \n    if char == 'f': \n      self.drive(FWD,step) \n    elif char == 'r': \n      self.drive(RIGHT,step) \n    elif char == 'l': \n      self.drive(LEFT,step) \n    elif char == '#': \n      time.sleep(step) \n\ndef main(): \n  import os \n  if \"CMD\" in os.environ: \n    CMD=os.environ[\"CMD\"] \n    INPUT=False \n    print(\"CMD=\"+CMD) \n  else: \n    INPUT=True \n  roverPi=motor() \n  if INPUT: \n    print(\"Enter CMDs [f,r,l,#]:\") \n    CMD=input() \n  for idx,char in enumerate(CMD.lower()): \n    if(DEBUG):print(\"Step %s of %s: %s\"%(idx+1,len(CMD),char)) \n    roverPi.cmd(char) \n\nif __name__=='__main__': \n  try: \n    main() \n  finally: \n    print (\"Finish\") \n#End \n```", "```py\nsudo python3 rover_drivefwd.py \n```", "```py\nEnter CMDs [f,r,l,#]:  \n```", "```py\nffrr#ff#llff  \n```", "```py\nsudo CMD=f#lrr##fff python3 rover_drivefwd.py\n\n```", "```py\nPINS=[15,16,18,22]   # PINS=[L_FWD,L_BWD,R_FWD,R_BWD] \n```", "```py\nFWD=[ON,OFF,ON,OFF] \nBWD=[OFF,ON,OFF,ON] \nRIGHT=[OFF,ON,ON,OFF] \nLEFT=[ON,OFF,OFF,ON] \n```", "```py\n  def cmd(self,char,step=STEP): \n    if char == 'f': \n      self.drive(FWD,step) \n    elif char == 'b': \n      self.drive(BWD,step) \n    elif char == 'r': \n      self.drive(RIGHT,step) \n    elif char == 'l': \n      self.drive(LEFT,step) \n    elif char == '#': \n      time.sleep(step) \n```", "```py\nprint(\"Enter CMDs [f,b,r,l,#]:\") \n```", "```py\nPWM_PIN=12; PWM=2; ON_TIME=512  #0-1024 Off-On \n\n  def GPIOsetup(self): \n    wiringpi2.wiringPiSetupPhys() \n    wiringpi2.pinMode(PWM_PIN,PWM) \n    wiringpi2.pwmWrite(PWM_PIN,ON_TIME) \n    for gpio in self.pins: \n      wiringpi2.pinMode(gpio,OUT) \n```", "```py\nPWM_PIN_ENA=7;PWM_PIN_ENA=11;RANGE=100 #0-100 (100Hz Max) \nON_TIME1=20; ON_TIME2=75 #0-100 \nON_TIME1=20  #0-100 \n  def GPIOsetup(self): \n    wiringpi2.wiringPiSetupPhys() \n    wiringpi2.softPwmCreate(PWM_PIN_ENA,ON_TIME1,RANGE) \n    wiringpi2.softPwmCreate(PWM_PIN_ENB,ON_TIME2,RANGE) \n    for gpio in self.pins: \n      wiringpi2.pinMode(gpio,OUT) \n```", "```py\nIO_ADDR=0x20 \nAF_BASE=100 \n```", "```py\nwiringpi2.mcp23017Setup(AF_BASE,IO_ADDR) \n```", "```py\n#!/usr/bin/env python3 \n#servoAdafruit.py \nimport wiringpi2 \nimport time \n\n#PWM Registers \nMODE1=0x00 \nPRESCALE=0xFE \nLED0_ON_L=0x06 \nLED0_ON_H=0x07 \nLED0_OFF_L=0x08 \nLED0_OFF_H=0x09 \n\nPWMHZ=50 \nPWMADR=0x40 \n\nclass servo: \n  # Constructor \n  def __init__(self,pwmFreq=PWMHZ,addr=PWMADR): \n    self.i2c = wiringpi2.I2C() \n    self.devPWM=self.i2c.setup(addr) \n    self.GPIOsetup(pwmFreq,addr) \n\n  def GPIOsetup(self,pwmFreq,addr): \n    self.i2c.read(self.devPWM) \n    self.pwmInit(pwmFreq) \n\n  def pwmInit(self,pwmFreq): \n    prescale = 25000000.0 / 4096.0   # 25MHz / 12-bit \n    prescale /= float(pwmFreq) \n    prescale = prescale - 0.5 #-1 then +0.5 to round to \n                              # nearest value \n    prescale = int(prescale) \n    self.i2c.writeReg8(self.devPWM,MODE1,0x00) #RESET \n    mode=self.i2c.read(self.devPWM) \n    self.i2c.writeReg8(self.devPWM,MODE1, \n                       (mode & 0x7F)|0x10) #SLEEP \n    self.i2c.writeReg8(self.devPWM,PRESCALE,prescale) \n    self.i2c.writeReg8(self.devPWM,MODE1,mode) #restore mode \n    time.sleep(0.005) \n    self.i2c.writeReg8(self.devPWM,MODE1,mode|0x80) #restart \n\n  def setPWM(self,channel, on, off): \n    on=int(on) \n    off=int(off) \n    self.i2c.writeReg8(self.devPWM, \n                       LED0_ON_L+4*channel,on & 0xFF) \n    self.i2c.writeReg8(self.devPWM,LED0_ON_H+4*channel,on>>8) \n    self.i2c.writeReg8(self.devPWM, \n                       LED0_OFF_L+4*channel,off & 0xFF) \n    self.i2c.writeReg8(self.devPWM,LED0_OFF_H+4*channel,off>>8) \n\ndef main(): \n  servoMin = 205  # Min pulse 1ms 204.8 (50Hz) \n  servoMax = 410  # Max pulse 2ms 409.6 (50Hz) \n  myServo=servo() \n  myServo.setPWM(0,0,servoMin) \n  time.sleep(2) \n  myServo.setPWM(0,0,servoMax) \n\nif __name__=='__main__': \n  try: \n    main() \n  finally: \n    print (\"Finish\") \n#End \n```", "```py\n#!/usr/bin/env python3 \n#bug_drive.py \nimport time \nimport servoAdafruit as servoCon \n\nservoMin = 205  # Min pulse 1000us 204.8 (50Hz) \nservoMax = 410  # Max pulse 2000us 409.6 (50Hz) \n\nservoL=0; servoM=1; servoR=2 \nTILT=10 \nMOVE=30 \nMID=((servoMax-servoMin)/2)+servoMin \nCW=MID+MOVE; ACW=MID-MOVE \nTR=MID+TILT; TL=MID-TILT \nFWD=[TL,ACW,ACW,TR,CW,CW]#[midL,fwd,fwd,midR,bwd,bwd] \nBWD=[TR,ACW,ACW,TL,CW,CW]#[midR,fwd,fwd,midL,bwd,bwd] \nLEFT=[TR,ACW,CW,TL,CW,ACW]#[midR,fwd,bwd,midL,bwd,fwd] \nRIGHT=[TL,ACW,CW,TR,CW,ACW]#[midL,fwd,bwd,midR,bwd,fwd] \nHOME=[MID,MID,MID,MID,MID,MID] \nPINS=[servoM,servoL,servoR,servoM,servoL,servoR]     \nSTEP=0.2 \nglobal DEBUG \nDEBUG=False \n\nclass motor: \n  # Constructor \n  def __init__(self,pins=PINS,steptime=STEP): \n    self.pins = pins \n    self.steptime=steptime \n    self.theServo=servoCon.servo() \n\n  def off(self): \n    #Home position \n    self.drive(HOME,step) \n\n  def drive(self,drive,step=STEP): \n    for idx,servo in enumerate(self.pins): \n      if(drive[idx]==servoM): \n        time.sleep(step) \n      self.theServo.setPWM(servo,0,drive[idx]) \n      if(drive[idx]==servoM): \n        time.sleep(step) \n      if(DEBUG):print(\"%s:%s\"%(gpio,drive[idx])) \n\n  def cmd(self,char,step=STEP): \n    if char == 'f': \n      self.drive(FWD,step) \n    elif char == 'b': \n      self.drive(BWD,step) \n    elif char == 'r': \n      self.drive(RIGHT,step) \n    elif char == 'l': \n      self.drive(LEFT,step) \n    elif char == 'h': \n      self.drive(HOME,step) \n    elif char == '#': \n      time.sleep(step) \n\ndef main(): \n  import os \n  DEBUG=True \n  if \"CMD\" in os.environ: \n    CMD=os.environ[\"CMD\"] \n    INPUT=False \n    print(\"CMD=\"+CMD) \n  else: \n    INPUT=True \n  bugPi=motor() \n  if INPUT: \n    print(\"Enter CMDs [f,b,r,l,h,#]:\") \n    CMD=input() \n  for idx,char in enumerate(CMD.lower()): \n    if(DEBUG):print(\"Step %s of %s: %s\"%(idx+1,len(CMD),char)) \n    bugPi.cmd(char) \n\nif __name__ == '__main__': \n  try: \n    main() \n  except KeyboardInterrupt: \n    print (\"Finish\") \n#End \n```", "```py\nsudo CMD=fffll##rr##bb##h python3 bug_drive.py  \n```", "```py\ncd ~\nwget https://github.com/richardghirst/PiBits/archive/master.zip  \n```", "```py\nunzip master.zip\nrm master.zip\ncd PiBits-master/ServoBlaster/user  \n```", "```py\nmake servod  \n```", "```py\ngcc -Wall -g -O2 -o servod servod.c mailbox.c -lm  \n```", "```py\n./servod --help  \n```", "```py\nsudo servod --idle-timeout=2000  \n```", "```py\necho 0=0% > /dev/servoblaster  \n```", "```py\necho 0=50% > /dev/servoblaster  \n```", "```py\n#!/usr/bin/env python3 \n#servo_control.py \nimport curses \nimport os \n#HARDWARE SETUP \n# GPIO    \n# 2[=VX==2=======]26[=======]40 \n# 1[===013=======]25[=======]39 \n# V=5V X=Gnd \n# Servo 0=Turn 1=Shoulder 2=Elbow 3=Claw \nname=[\"Turn\",\"Shoulder\",\"Elbow\",\"Claw\"] \nCAL=[90,90,90,90] \nMIN=[0,60,40,60]; MAX=[180,165,180,180] \nPOS=list(CAL) \nKEY_CMD=[ord('c'),ord('x')] \n#Keys to rotate counter-clockwise \nKEY_LESS={ord('d'):0,ord('s'):1,ord('j'):2,ord('k'):3} \n#Keys to rotate clockwise \nKEY_MORE={ord('a'):0,ord('w'):1,ord('l'):2,ord('i'):3} \n\nSTEP=5; LESS=-STEP; MORE=STEP #Define control steps \nDEG2MS=1.5/180.0; OFFSET=1 #mseconds \nIDLE=2000 #Timeout servo after command \nSERVOD=\"/home/pi/PiBits-mater/ServoBlaster/user/servod\" #Location of servod \nDEBUG=True \ntext=\"Use a-d, w-s, j-l and i-k to control the MeArm. c=Cal x=eXit\" \n\ndef initialize(): \n  cmd=(\"sudo %s --idle-timeout=%s\"%(SERVOD, IDLE)) \n  os.system(cmd) \n\ndef limitServo(servo,value): \n  global text \n  if value > MAX[servo]: \n    text=(\"Max %s position %s:%s\"%(name[servo],servo,POS[servo])) \n    return MAX[servo] \n  elif value < MIN[servo]: \n    text=(\"Min %s position %s:%s\"%(name[servo],servo,POS[servo])) \n    return MIN[servo] \n  else: \n    return value \n\ndef updateServo(servo,change): \n  global text \n  POS[servo]=limitServo(servo,POS[servo]+change) \n  setServo(servo,POS[servo]) \n  text=str(POS) \n\ndef setServo(servo,position): \n  ms=OFFSET+(position*DEG2MS) \n  os.system(\"echo %d=%dus > /dev/servoblaster\" %(servo, ms/1000)) \n\ndef calibrate(): \n  global text \n  text=\"Calibrate 90deg\" \n  for i,value in enumerate(CAL): \n    POS[i]=value \n    setServo(i,value) \n\ndef main(term): \n  term.nodelay(1) \n  term.addstr(text) \n  term.refresh() \n  while True: \n    term.move(1,0) \n    c = term.getch() \n    if c != -1: \n      if c in KEY_MORE: \n        updateServo(KEY_MORE[c],MORE) \n      elif c in KEY_LESS: \n        updateServo(KEY_LESS[c],LESS) \n      elif c in KEY_CMD: \n        if c == ord('c'): \n          calibrate() \n        elif c == ord('x'): \n          exit() \n      if DEBUG:term.addstr(text+\"   \") \n\nif __name__=='__main__': \n  initialize() \n  curses.wrapper(main) \n#End \n```", "```py\npython3 servo_control.py\n\n```", "```py\nUse a-d, w-s, j-l and i-k to control the MeArm. c=Cal x=eXit \n```", "```py\nsudo apt-get install lirc lirc-x  \n```", "```py\ndtoverlay=lirc-rpi,gpio_in_pin=23  \n```", "```py\nsudo reboot  \n```", "```py\nmode2 -d /dev/lirco0    \n```", "```py\nspace 16300\npulse 95\nspace 28794\npulse 80\nspace 19395\npulse 83\n...etc... \n```", "```py\nLIRCD_ARGS=\"--uinput\" \nDRIVER=\"default\" \nDEVICE=\"/dev/lirc0\" \nMODULES=\"lirc_rpi\" \n```", "```py\nirrecord --list-namespace  \n```", "```py\nsudo /etc/init.d/lirc stop  \n```", "```py\nirrecord -d /dev/lirc0 ~/lircd.conf  \n```", "```py\nnano ~/lircd.conf  \n```", "```py\n...\nbegin remote\n  name  Goodmans\n  bits           16 \n...  \n```", "```py\nsudo cp ~/lircd.conf /etc/lirc/lirc.conf  \n```", "```py\n0000000000fe7a85 00 KEY_UP Goodmans \n0000000000fe7a85 01 KEY_UP Goodmans \n0000000000fe6a95 00 KEY_DOWN Goodmans \n0000000000fe6a95 01 KEY_DOWN Goodmans \n... \n```", "```py\nsudo nano /etc/lirc/lircrc  \n```", "```py\nbegin \n  prog=irxevent \n  button=KEY_UP \n  config=Key w CurrentWindow \nend \nbegin \n  prog=irxevent \n  button=KEY_DOWN \n  config=Key s CurrentWindow \nend \nbegin \n  prog=irxevent \n  button=KEY_LEFT \n  config=Key a CurrentWindow \nend \nbegin \n  prog=irxevent \n  button=KEY_RIGHT \n  config=Key d CurrentWindow \nend \nbegin \n  prog=irxevent \n  button=KEY_VOLUMEUP \n  config=Key i CurrentWindow \nend \nbegin \n  prog=irxevent \n  button=KEY_VOLUMEDOWN \n  config=Key k CurrentWindow \nend \nbegin \n  prog=irxevent \n  button=KEY_CHANNELUP \n  config=Key l CurrentWindow \nend \nbegin \n  prog=irxevent \n  button=KEY_CHANNELDOWN \n  config=Key j CurrentWindow \nend \n```", "```py\nsudo /etc/init.d/lirc restart  \n```", "```py\nircat irxevent  \n```", "```py\nKey k CurrentWindow\nKey i CurrentWindow  \n```", "```py\nirsend SEND_ONCE Goodmans KEY_PROGRAMUP \n```", "```py\ndtoverlay=lirc-rpi,gpio_in_pin=24,gpio_out_pin=19  \n```", "```py\n#!/usr/bin/env python3 \n#avoidance.py \nimport rover_drive as drive \nimport wiringpi2 \nimport time \n\nopCmds={'f':'bl','b':'fr','r':'ll','l':'rr','#':'#'} \nPINS=[7,11,12,13]   # PINS=[L_FWD,L_BWD,R_FWD,R_BWD] \nON=1;OFF=0 \nIN=0;OUT=1 \nPULL_UP=2;PULL_DOWN=1 \n\nclass sensor: \n  # Constructor \n  def __init__(self,pins=PINS): \n    self.pins = pins \n    self.GPIOsetup() \n\n  def GPIOsetup(self): \n    wiringpi2.wiringPiSetupPhys() \n    for gpio in self.pins: \n      wiringpi2.pinMode(gpio,IN) \n      wiringpi2.pullUpDnControl(gpio,PULL_UP)     \n\n  def checkSensor(self): \n    hit = False \n    for gpio in self.pins: \n      if wiringpi2.digitalRead(gpio)==False: \n        hit = True \n    return hit \n\ndef main(): \n  myBot=drive.motor() \n  mySensors=sensor() \n  while(True): \n    print(\"Enter CMDs [f,b,r,l,#]:\") \n    CMD=input() \n    for idx,char in enumerate(CMD.lower()): \n      print(\"Step %s of %s: %s\"%(idx+1,len(CMD),char)) \n      myBot.cmd(char,step=0.01)#small steps \n      hit = mySensors.checkSensor() \n      if hit: \n        print(\"We hit something on move: %s Go: %s\"%(char, \n                                              opCmds[char])) \n        for charcmd in opCmds[char]: \n          myBot.cmd(charcmd,step=0.02)#larger step \n\nif __name__ == '__main__': \n  try: \n    main() \n  except KeyboardInterrupt: \n    print (\"Finish\") \n#End \n```", "```py\n#!/usr/bin/python3 \n#sonic.py \nimport wiringpi2 \nimport time \nimport datetime \n\nON=1;OFF=0; IN=0;OUT=1 \nTRIGGER=15; ECHO=7 \nPULSE=0.00001 #10us pulse \n\nSPEEDOFSOUND=34029 #34029 cm/s \n\ndef gpiosetup(): \n  wiringpi2.wiringPiSetupPhys() \n  wiringpi2.pinMode(TRIGGER,OUT) \n  wiringpi2.pinMode(ECHO,IN) \n  wiringpi2.digitalWrite(TRIGGER,OFF) \n  time.sleep(0.5) \n\ndef pulse(): \n  wiringpi2.digitalWrite(TRIGGER,ON) \n  time.sleep(PULSE) \n  wiringpi2.digitalWrite(TRIGGER,OFF) \n  starttime=time.time() \n  stop=starttime \n  start=starttime \n  while wiringpi2.digitalRead(ECHO)==0 and start<starttime+2: \n    start=time.time() \n  while wiringpi2.digitalRead(ECHO)==1 and stop<starttime+2: \n    stop=time.time() \n  delta=stop-start \n  print(\"Start:%f Stop:%f Delta:%f\"%(start,stop,delta)) \n  distance=delta*SPEEDOFSOUND \n  return distance/2.0 \n\ndef main(): \n  global run \n  gpiosetup() \n  while(True): \n    print(\"Sample\") \n    print(\"Distance:%.1f\"%pulse()) \n    time.sleep(2) \n\nif __name__ == '__main__': \n  try: \n    main() \n  except KeyboardInterrupt: \n    print (\"Finish\") \n#End \n```", "```py\n#!/usr/bin/env python3 \n#XLoBorg3.py \nimport wiringpi2 \nimport struct \nimport time \n\ndef readBlockData(bus,device,register,words): \n  magData=[] \n  for i in range(words): \n    magData.append(bus.readReg16(device,register+i)) \n  return magData \n\nclass compass: \n  def __init__(self): \n    addr = 0x0E #compass \n    self.i2c = wiringpi2.I2C() \n    self.devMAG=self.i2c.setup(addr) \n    self.initCompass() \n\n  def initCompass(self): \n    # Acquisition mode \n    register = 0x11   # CTRL_REG2 \n    data  = (1 << 7)  # Reset before each acquisition \n    data |= (1 << 5)  # Raw mode, do not apply user offsets \n    data |= (0 << 5)  # Disable reset cycle \n    self.i2c.writeReg8(self.devMAG,register,data) \n    # System operation \n    register = 0x10   # CTRL_REG1 \n    data  = (0 << 5)  # Output data rate \n                      # (10 Hz when paired with 128 oversample) \n    data |= (3 << 3)  # Oversample of 128 \n    data |= (0 << 2)  # Disable fast read \n    data |= (0 << 1)  # Continuous measurement \n    data |= (1 << 0)  # Active mode \n    self.i2c.writeReg8(self.devMAG,register,data) \n\n  def readCompassRaw(self): \n    #x, y, z = readCompassRaw() \n    self.i2c.write(self.devMAG,0x00) \n    [status, xh, xl, yh, yl, \n      zh, zl, who, sm, oxh, oxl, \n      oyh, oyl, ozh, ozl, \n      temp, c1, c2] = readBlockData(self.i2c,self.devMAG, 0, 18) \n    # Convert from unsigned to correctly signed values \n    bytes = struct.pack('BBBBBB', xl, xh, yl, yh, zl, zh) \n    x, y, z = struct.unpack('hhh', bytes) \n    return x, y, z \n\nif __name__ == '__main__': \n  myCompass=compass() \n  try: \n    while True: \n      # Read the MAG Data \n      mx, my, mz = myCompass.readCompassRaw() \n      print (\"mX = %+06d, mY = %+06d, mZ = %+06d\" % (mx, my, mz)) \n      time.sleep(0.1) \n  except KeyboardInterrupt: \n    print(\"Finished\") \n#End \n```", "```py\nCAL=100 #take CAL samples \n```", "```py\n    self.offset,self.scaling=self.calibrateCompass() \n    if DEBUG:print(\"offset:%s scaling:%s\"%(str(self.offset), \n                                           str(self.scaling))) \n```", "```py\n  def calibrateCompass(self,samples=CAL): \n    MAXS16=32768 \n    SCALE=1000.0 \n    avg=[0,0,0] \n    min=[MAXS16,MAXS16,MAXS16];max=[-MAXS16,-MAXS16,-MAXS16] \n    print(\"Rotate sensor around axis (start in 5 sec)\") \n    time.sleep(5) \n    for calibrate in range(samples): \n      for idx,value in enumerate(self.readCompassRaw()): \n        avg[idx]+=value \n        avg[idx]/=2 \n        if(value>max[idx]): \n          max[idx]=value \n        if(value<min[idx]): \n          min[idx]=value \n      time.sleep(0.1) \n      if DEBUG:print(\"#%d min=[%+06d,%+06d,%+06d]\" \n                     %(calibrate,min[0],min[1],min[2]) \n                     +\" avg[%+06d,%+06d,%+06d]\" \n                     %(avg[0],avg[1],avg[2]) \n                     +\" max=[%+06d,%+06d,%+06d]\" \n                     %(max[0],max[1],max[2])) \n    offset=[] \n    scaling=[] \n    for idx, value in enumerate(min): \n      magRange=max[idx]-min[idx] \n      offset.append((magRange/2)+min[idx]) \n      scaling.append(SCALE/magRange) \n    return offset,scaling \n```", "```py\n  def readCompass(self): \n    raw = self.readCompassRaw() \n    if DEBUG:print(\"mX = %+06d, mY = %+06d, mZ = %+06d\" \n                   % (raw[0],raw[1],raw[2])) \n    read=[] \n    for idx,value in enumerate(raw): \n      adj=value-self.offset[idx] \n      read.append(adj*self.scaling[idx]) \n    return read \n```", "```py\n  def readCompassAngle(self,cal=True): \n    if cal==True: \n      read = self.readCompass() \n    else: \n      read = self.readCompassRaw() \n    angle = math.atan2 (read[1],read[0]) # cal angle in radians \n    if (angle < 0): \n      angle += (2 * math.pi) # ensure positive \n    angle = (angle * 360)/(2*math.pi); #report in degrees \n    return angle \n```", "```py\nimport math \n```", "```py\nFILENAME=\"mag.cal\" \n```", "```py\nself.offset,self.scaling=self.calibrateCompass() \n```", "```py\nself.offset,self.scaling=self.readCal(newCal) \n```", "```py\n  def readCal(self,newCal=False,filename=FILENAME): \n    if newCal==False: \n      try: \n        with open(FILENAME,'r') as magCalFile: \n          line=magCalFile.readline() \n          offset=line.split() \n          line=magCalFile.readline() \n          scaling=line.split() \n          if len(offset)==0 or len(scaling)==0: \n            raise ValueError() \n          else: \n            offset=list(map(float, offset)) \n            scaling=list(map(float, scaling)) \n      except (OSError,IOError,TypeError,ValueError) as e: \n        print(\"No Cal Data\") \n        newCal=True \n        pass \n    if newCal==True: \n      print(\"Perform New Calibration\") \n      offset,scaling=self.calibrateCompass() \n      self.writeCal(offset,scaling) \n    return offset,scaling \n```", "```py\n  def writeCal(self,offset,scaling): \n      if DEBUG:print(\"Write Calibration\") \n      if DEBUG:print(\"offset:\"+str(offset)) \n      if DEBUG:print(\"scaling:\"+str(scaling)) \n      with open(FILENAME,'w') as magCalFile: \n        for value in offset: \n          magCalFile.write(str(value)+\" \") \n        magCalFile.write(\"n\") \n        for value in scaling: \n          magCalFile.write(str(value)+\" \") \n        magCalFile.write(\"n\") \n```", "```py\n#!/usr/bin/env python3 \n#compassDrive.py \nimport XLoBorg3 as XLoBorg \nimport rover_drive as drive \nimport time \n\nMARGIN=10 #turn until within 10degs \nLEFT=\"l\"; RIGHT=\"r\"; DONE=\"#\" \n\ndef calDir(target, current, margin=MARGIN): \n  target=target%360 \n  current=current%360 \n  delta=(target-current)%360 \n  print(\"Target=%f Current=%f Delta=%f\"%(target,current,delta)) \n\n  if delta <= margin: \n    CMD=DONE \n  else: \n    if delta>180: \n      CMD=LEFT \n    else: \n      CMD=RIGHT \n  return CMD \n\ndef main(): \n  myCompass=XLoBorg.compass() \n  myBot=drive.motor() \n  while(True): \n    print(\"Enter target angle:\") \n    ANGLE=input() \n    try: \n      angleTarget=float(ANGLE) \n      CMD=LEFT \n      while (CMD!=DONE): \n        angleCompass=myCompass.readCompassAngle() \n        CMD=calDir(angleTarget,angleCompass) \n        print(\"CMD: %s\"%CMD) \n        time.sleep(1) \n        myBot.cmd(CMD) \n      print(\"Angle Reached!\") \n    except ValueError: \n      print(\"Enter valid angle!\") \n      pass \n\nif __name__ == '__main__': \n  try: \n    main() \n  except KeyboardInterrupt: \n    print (\"Finish\") \n#End \n```"]