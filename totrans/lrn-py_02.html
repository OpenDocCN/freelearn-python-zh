<html><head></head><body><div class="chapter" title="Chapter&#xA0;2.&#xA0;Built-in Data Types"><div class="titlepage"><div><div><h1 class="title"><a id="ch02"/>Chapter 2. Built-in Data Types</h1></div></div></div><div class="blockquote"><table border="0" width="100%" cellspacing="0" cellpadding="0" class="blockquote" summary="Block quote"><tr><td valign="top"> </td><td valign="top"><p><span class="emphasis"><em>"Data! Data! Data!" he cried impatiently. "I can't make bricks without clay."</em></span></p></td><td valign="top"> </td></tr><tr><td valign="top"> </td><td colspan="2" align="right" valign="top" style="text-align: center">--<span class="attribution"><span class="emphasis"><em>Sherlock Holmes - The Adventure of the Copper Beeches</em></span></span></td></tr></table></div><p>Everything you do with a computer is managing data. Data comes in many different shapes and flavors. It's the music you listen, the movie you stream, the PDFs you open. Even the chapter you're reading at this very moment is just a file, which is data.</p><p>Data can be simple, an integer number to represent an age, or complex, like an order placed on a website. It can be about a single object or about a collection of them.</p><p>Data can even be about data, that is, metadata. Data that describes the design of other data structures or data that describes application data or its context.</p><p>In Python, <span class="emphasis"><em>objects are abstraction for data</em></span>, and Python has an amazing variety of data structures that you can use to represent data, or combine them to create your own custom data. Before we delve into the specifics, I want you to be very clear about objects in Python, so let's talk a little bit more about them.</p><div class="section" title="Everything is an object"><div class="titlepage"><div><div><h1 class="title"><a id="ch02lvl1sec22"/>Everything is an object</h1></div></div></div><p>As we <a id="id110" class="indexterm"/>already said, everything in Python is an object. But what really happens when you type an instruction like <code class="literal">age = 42</code> in a Python module?</p><div class="note" title="Note" style=""><div class="inner"><h3 class="title"><a id="tip08"/>Tip</h3><p>If you go to <a class="ulink" href="http://pythontutor.com/">http://pythontutor.com/</a>, you can type that instruction into a text box <a id="id111" class="indexterm"/>and get its visual representation. Keep this website in mind, it's very useful to consolidate your understanding of what goes on behind the scenes.</p></div></div><p>So, what happens is that an object is created. It gets an <code class="literal">id</code>, the <code class="literal">type</code> is set to <code class="literal">int</code> (integer number), and the <code class="literal">value</code> to <code class="literal">42</code>. A name <code class="literal">age</code> is placed in the global namespace, pointing to that object. Therefore, whenever we are in the global namespace, after the execution of that line, we can retrieve that object by simply accessing it through its name: <code class="literal">age</code>.</p><p>If you were to move house, you would put all the knives, forks, and spoons in a box and label it cutlery. Can you see it's exactly the same concept? Here's a screenshot of how it may look <a id="id112" class="indexterm"/>like (you may have to tweak the settings to get to the same view):</p><div class="mediaobject"><img src="graphics/4715_02_01.jpg" alt="Everything is an object"/></div><p>So, for the rest of this chapter, whenever you read something such as <code class="literal">name = some_value</code>, think of a name placed in the namespace that is tied to the scope in which the instruction was written, with a nice arrow pointing to an object that has an <code class="literal">id</code>, a <code class="literal">type</code>, and a <code class="literal">value</code>. There is a little bit more to say about this mechanism, but it's much easier to talk about it over an example, so we'll get back to this later.</p></div></div>
<div class="section" title="Mutable or immutable? That is the question"><div class="titlepage"><div><div><h1 class="title"><a id="ch02lvl1sec23"/>Mutable or immutable? That is the question</h1></div></div></div><p>A first<a id="id113" class="indexterm"/> fundamental distinction that Python makes on data is about whether <a id="id114" class="indexterm"/>or not the value of an object changes. If the value can <a id="id115" class="indexterm"/>change, the object is called <span class="strong"><strong>mutable</strong></span>, while if the value cannot<a id="id116" class="indexterm"/> change, the object is called <span class="strong"><strong>immutable</strong></span>.</p><p>It is very important that you understand the distinction between mutable and immutable because it affects the code you write, so here's a question:</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong>&gt;&gt;&gt; age = 42</strong></span>
<span class="strong"><strong>&gt;&gt;&gt; age</strong></span>
<span class="strong"><strong>42</strong></span>
<span class="strong"><strong>&gt;&gt;&gt; age = 43  #A</strong></span>
<span class="strong"><strong>&gt;&gt;&gt; age</strong></span>
<span class="strong"><strong>43</strong></span>
</pre></div><p>In the preceding code, on the line <code class="literal">#A</code>, have I changed the value of age? Well, no. But now it's 43 (I hear you say...). Yes, it's 43, but 42 was an integer number, of the type <code class="literal">int</code>, which is immutable. So, what happened is really that on the first line, <code class="literal">age</code> is a name that is set to point to an <code class="literal">int</code> object, whose value is 42. When we type <code class="literal">age = 43</code>, what happens is that another object is created, of the type <code class="literal">int</code> and value 43 (also, the <code class="literal">id</code> will be different), and the name <code class="literal">age</code> is set to point to it. So, we didn't change that 42 to 43. We actually just pointed <code class="literal">age</code> to a different location: the new <code class="literal">int</code> object whose value is 43. Let's see the same code also printing the IDs:</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong>&gt;&gt;&gt; age = 42</strong></span>
<span class="strong"><strong>&gt;&gt;&gt; id(age)</strong></span>
<span class="strong"><strong>10456352</strong></span>
<span class="strong"><strong>&gt;&gt;&gt; age = 43</strong></span>
<span class="strong"><strong>&gt;&gt;&gt; id(age)</strong></span>
<span class="strong"><strong>10456384</strong></span>
</pre></div><p>Notice<a id="id117" class="indexterm"/> that we print the IDs by calling the built-in <code class="literal">id</code> function. As you can <a id="id118" class="indexterm"/>see, they are different, as expected. Bear in mind that <code class="literal">age</code> points to one object at a time: 42 first, then 43. Never together.</p><p>Now, let's see the same example using a mutable object. For this example, let's just use a <code class="literal">Person</code> object, that has a property <code class="literal">age</code>:</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong>&gt;&gt;&gt; fab = Person(age=39)</strong></span>
<span class="strong"><strong>&gt;&gt;&gt; fab.age</strong></span>
<span class="strong"><strong>39</strong></span>
<span class="strong"><strong>&gt;&gt;&gt; id(fab)</strong></span>
<span class="strong"><strong>139632387887456</strong></span>
<span class="strong"><strong>&gt;&gt;&gt; fab.age = 29  # I wish!</strong></span>
<span class="strong"><strong>&gt;&gt;&gt; id(fab)</strong></span>
<span class="strong"><strong>139632387887456  # still the same id</strong></span>
</pre></div><p>In this case, I set up an object <code class="literal">fab</code> whose <code class="literal">type</code> is <code class="literal">Person</code> (a custom class). On creation, the object is given the <code class="literal">age</code> of 39. I'm printing it, along with the object <code class="literal">id</code>, right afterwards. Notice that, even after I change <code class="literal">age</code> to be 29, the ID of <code class="literal">fab</code> stays the same (while the ID of <code class="literal">age</code> has changed, of course). Custom objects in Python are mutable (unless you code them not to be). Keep this concept in mind, it's very important. I'll remind you about it through the rest of the chapter.</p></div>
<div class="section" title="Numbers"><div class="titlepage"><div><div><h1 class="title"><a id="ch02lvl1sec24"/>Numbers</h1></div></div></div><p>Let's start by <a id="id119" class="indexterm"/>exploring Python's built-in data types for numbers. Python was designed by a man with a master's degree in mathematics and computer science, so it's only logical that it has amazing support for numbers.</p><p>Numbers are immutable objects.</p><div class="section" title="Integers"><div class="titlepage"><div><div><h2 class="title"><a id="ch02lvl2sec27"/>Integers</h2></div></div></div><p>Python integers have <a id="id120" class="indexterm"/>unlimited range, subject only to the available virtual memory. This means that it doesn't really matter how big a number you want to store: as long as it can fit in your computer's memory, Python will take care of it. Integer numbers can be positive, negative, and 0 (zero). They support all the basic mathematical operations, as shown in the following example:</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong>&gt;&gt;&gt; a = 12</strong></span>
<span class="strong"><strong>&gt;&gt;&gt; b = 3</strong></span>
<span class="strong"><strong>&gt;&gt;&gt; a + b  # addition</strong></span>
<span class="strong"><strong>15</strong></span>
<span class="strong"><strong>&gt;&gt;&gt; b - a  # subtraction</strong></span>
<span class="strong"><strong>-9</strong></span>
<span class="strong"><strong>&gt;&gt;&gt; a // b  # integer division</strong></span>
<span class="strong"><strong>4</strong></span>
<span class="strong"><strong>&gt;&gt;&gt; a / b  # true division</strong></span>
<span class="strong"><strong>4.0</strong></span>
<span class="strong"><strong>&gt;&gt;&gt; a * b  # multiplication</strong></span>
<span class="strong"><strong>36</strong></span>
<span class="strong"><strong>&gt;&gt;&gt; b ** a  # power operator</strong></span>
<span class="strong"><strong>531441</strong></span>
<span class="strong"><strong>&gt;&gt;&gt; 2 ** 1024  # a very big number, Python handles it gracefully</strong></span>
<span class="strong"><strong>17976931348623159077293051907890247336179769789423065727343008115</strong></span>
<span class="strong"><strong>77326758055009631327084773224075360211201138798713933576587897688</strong></span>
<span class="strong"><strong>14416622492847430639474124377767893424865485276302219601246094119</strong></span>
<span class="strong"><strong>45308295208500576883815068234246288147391311054082723716335051068</strong></span>
<span class="strong"><strong>4586298239947245938479716304835356329624224137216</strong></span>
</pre></div><p>The preceding code should be easy to understand. Just notice one important thing: Python has two <a id="id121" class="indexterm"/>division operators, one performs the so-called <span class="strong"><strong>true division</strong></span> (<code class="literal">/</code>), which<a id="id122" class="indexterm"/> returns the quotient of the operands, and the other one, the so-called <span class="strong"><strong>integer division</strong></span> (<code class="literal">//</code>), which returns the <span class="emphasis"><em>floored</em></span> quotient of the operands. See how that is different for positive and negative numbers:</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong>&gt;&gt;&gt; 7 / 4  # true division</strong></span>
<span class="strong"><strong>1.75</strong></span>
<span class="strong"><strong>&gt;&gt;&gt; 7 // 4  # integer division, flooring returns 1</strong></span>
<span class="strong"><strong>1</strong></span>
<span class="strong"><strong>&gt;&gt;&gt; -7 / 4  # true division again, result is opposite of previous</strong></span>
<span class="strong"><strong>-1.75</strong></span>
<span class="strong"><strong>&gt;&gt;&gt; -7 // 4  # integer div., result not the opposite of previous</strong></span>
<span class="strong"><strong>-2</strong></span>
</pre></div><p>This is an interesting example. If you were expecting a <code class="literal">-1</code> on the last line, don't feel bad, it's just the way Python works. The result of an integer division in Python is always rounded towards minus infinity. If instead of flooring you want to truncate a number to an integer, you can use the built-in <code class="literal">int</code> function, like shown in the following example:</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong>&gt;&gt;&gt; int(1.75)</strong></span>
<span class="strong"><strong>1</strong></span>
<span class="strong"><strong>&gt;&gt;&gt; int(-1.75)</strong></span>
<span class="strong"><strong>-1</strong></span>
</pre></div><p>Notice <a id="id123" class="indexterm"/>that truncation is done towards 0.</p><p>There is also an operator to calculate the remainder of a division. It's called modulo operator, and it's represented by a percent (<code class="literal">%</code>):</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong>&gt;&gt;&gt; 10 % 3  # remainder of the division 10 // 3</strong></span>
<span class="strong"><strong>1</strong></span>
<span class="strong"><strong>&gt;&gt;&gt; 10 % 4  # remainder of the division 10 // 4</strong></span>
<span class="strong"><strong>2</strong></span>
</pre></div></div><div class="section" title="Booleans"><div class="titlepage"><div><div><h2 class="title"><a id="ch02lvl2sec28"/>Booleans</h2></div></div></div><p>Boolean<a id="id124" class="indexterm"/> algebra is that subset of algebra in which the values of the variables are the truth values: true and false. In Python, <code class="literal">True</code> and <code class="literal">False</code> are two keywords that are used to represent truth values. Booleans are a subclass of integers, and behave respectively like 1 and 0. The equivalent of the <code class="literal">int</code> class for Booleans is the <code class="literal">bool</code> class, which returns either <code class="literal">True</code> or <code class="literal">False</code>. Every built-in Python object has a value in the Boolean context, which means they basically evaluate to either <code class="literal">True</code> or <code class="literal">False</code> when fed to the <code class="literal">bool</code> function. We'll see all about this in <a class="link" href="ch03.html" title="Chapter 3. Iterating and Making Decisions">Chapter 3</a>, <span class="emphasis"><em>Iterating and Making Decisions</em></span>.</p><p>Boolean values can be combined in Boolean expressions using the logical operators <code class="literal">and</code>, <code class="literal">or</code>, and <code class="literal">not</code>. Again, we'll see them in full in the next chapter, so for now let's just see a simple example:</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong>&gt;&gt;&gt; int(True)  # True behaves like 1</strong></span>
<span class="strong"><strong>1</strong></span>
<span class="strong"><strong>&gt;&gt;&gt; int(False)  # False behaves like 0</strong></span>
<span class="strong"><strong>0</strong></span>
<span class="strong"><strong>&gt;&gt;&gt; bool(1)  # 1 evaluates to True in a boolean context</strong></span>
<span class="strong"><strong>True</strong></span>
<span class="strong"><strong>&gt;&gt;&gt; bool(-42)  # and so does every non-zero number</strong></span>
<span class="strong"><strong>True</strong></span>
<span class="strong"><strong>&gt;&gt;&gt; bool(0)  # 0 evaluates to False</strong></span>
<span class="strong"><strong>False</strong></span>
<span class="strong"><strong>&gt;&gt;&gt; # quick peak at the operators (and, or, not)</strong></span>
<span class="strong"><strong>&gt;&gt;&gt; not True</strong></span>
<span class="strong"><strong>False</strong></span>
<span class="strong"><strong>&gt;&gt;&gt; not False</strong></span>
<span class="strong"><strong>True</strong></span>
<span class="strong"><strong>&gt;&gt;&gt; True and True</strong></span>
<span class="strong"><strong>True</strong></span>
<span class="strong"><strong>&gt;&gt;&gt; False or True</strong></span>
<span class="strong"><strong>True</strong></span>
</pre></div><p>You can <a id="id125" class="indexterm"/>see that <code class="literal">True</code> and <code class="literal">False</code> are subclasses of integers when you try to add them. Python upcasts them to integers and performs addition:</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong>&gt;&gt;&gt; 1 + True</strong></span>
<span class="strong"><strong>2</strong></span>
<span class="strong"><strong>&gt;&gt;&gt; False + 42</strong></span>
<span class="strong"><strong>42</strong></span>
<span class="strong"><strong>&gt;&gt;&gt; 7 - True</strong></span>
<span class="strong"><strong>6</strong></span>
</pre></div><div class="note" title="Note" style=""><div class="inner"><h3 class="title"><a id="note14"/>Note</h3><p>
<span class="strong"><strong>Upcasting</strong></span> is a type conversion operation that goes from a subclass to its parent. In the<a id="id126" class="indexterm"/> example presented here, <code class="literal">True</code> and <code class="literal">False</code>, which belong to a class derived from the integer class, are converted back to integers when needed. This topic is about inheritance and will be explained in detail in <a class="link" href="ch06.html" title="Chapter 6. Advanced Concepts – OOP, Decorators, and Iterators">Chapter 6</a>, <span class="emphasis"><em>Advanced Concepts – OOP, Decorators, and Iterators</em></span>.</p></div></div></div><div class="section" title="Reals"><div class="titlepage"><div><div><h2 class="title"><a id="ch02lvl2sec29"/>Reals</h2></div></div></div><p>Real numbers, or<a id="id127" class="indexterm"/> floating point numbers, are represented in Python according to the IEEE 754 double-precision binary floating-point format, which is stored in 64 bits of information divided into three sections: sign, exponent, and mantissa.</p><div class="note" title="Note" style=""><div class="inner"><h3 class="title"><a id="note15"/>Note</h3><p>Quench<a id="id128" class="indexterm"/> your thirst for knowledge about this format on Wikipedia: <a class="ulink" href="http://en.wikipedia.org/wiki/Double-precision_floating-point_format">http://en.wikipedia.org/wiki/Double-precision_floating-point_format</a>
</p></div></div><p>Usually programming languages give coders two different formats: single and double precision. The former taking up 32 bits of memory, and the latter 64. Python supports only the double format. Let's see a simple example:</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong>&gt;&gt;&gt; pi = 3.1415926536  # how many digits of PI can you remember?</strong></span>
<span class="strong"><strong>&gt;&gt;&gt; radius = 4.5</strong></span>
<span class="strong"><strong>&gt;&gt;&gt; area = pi * (radius ** 2)</strong></span>
<span class="strong"><strong>&gt;&gt;&gt; area</strong></span>
<span class="strong"><strong>63.61725123519331</strong></span>
</pre></div><div class="note" title="Note" style=""><div class="inner"><h3 class="title"><a id="note16"/>Note</h3><p>In the calculation of the area, I wrapped the <code class="literal">radius ** 2</code> within braces. Even though that wasn't necessary because the power operator has higher precedence than the multiplication one, I think the formula reads more easily like that.</p></div></div><p>The <code class="literal">sys.float_info</code> struct sequence holds information about how floating point numbers<a id="id129" class="indexterm"/> will behave on your system. This is what I see on my box:</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong>&gt;&gt;&gt; import sys</strong></span>
<span class="strong"><strong>&gt;&gt;&gt; sys.float_info</strong></span>
<span class="strong"><strong>sys.float_info(max=1.7976931348623157e+308, max_exp=1024, max_10_exp=308, min=2.2250738585072014e-308, min_exp=-1021, min_10_exp=-307, dig=15, mant_dig=53, epsilon=2.220446049250313e-16, radix=2, rounds=1)</strong></span>
</pre></div><p>Let's make a few considerations here: we have 64 bits to represent float numbers. This means we can represent at most <code class="literal">2 ** 64 == 18,446,744,073,709,551,616</code> numbers with that amount of bits. Take a look at the <code class="literal">max</code> and <code class="literal">epsilon</code> value for the float numbers, and you'll realize it's impossible to represent them all. There is just not enough space so they are approximated to the closest representable number. You probably think that only extremely big or extremely small numbers suffer from this issue. Well, think again:</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong>&gt;&gt;&gt; 3 * 0.1 – 0.3  # this should be 0!!!</strong></span>
<span class="strong"><strong>5.551115123125783e-17</strong></span>
</pre></div><p>What does this tell you? It tells you that double precision numbers suffer from approximation issues even when it comes to simple numbers like 0.1 or 0.3. Why is this important? It can be a big problem if you're handling prices, or financial calculations, or any kind of data that needs not to be approximated. Don't worry, Python gives you the <span class="strong"><strong>Decimal</strong></span> type, which doesn't suffer from these issues, we'll see them in a bit.</p></div><div class="section" title="Complex numbers"><div class="titlepage"><div><div><h2 class="title"><a id="ch02lvl2sec30"/>Complex numbers</h2></div></div></div><p>Python <a id="id130" class="indexterm"/>gives you complex numbers support out of the box. If you don't know what complex numbers are, you can look them up on the Web. They are numbers that can be expressed in the form <span class="emphasis"><em>a + ib</em></span> where <span class="emphasis"><em>a</em></span> and <span class="emphasis"><em>b</em></span> are real numbers, and <span class="emphasis"><em>i</em></span> (or <span class="emphasis"><em>j</em></span> if you're an engineer) is the imaginary unit, that is, the square root of -1. <span class="emphasis"><em>a</em></span> and <span class="emphasis"><em>b</em></span> are called respectively the <span class="emphasis"><em>real</em></span> and <span class="emphasis"><em>imaginary</em></span> part of the number.</p><p>It's actually unlikely you'll be using them, unless you're coding something scientific. Let's see a small example:</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong>&gt;&gt;&gt; c = 3.14 + 2.73j</strong></span>
<span class="strong"><strong>&gt;&gt;&gt; c.real  # real part</strong></span>
<span class="strong"><strong>3.14</strong></span>
<span class="strong"><strong>&gt;&gt;&gt; c.imag  # imaginary part</strong></span>
<span class="strong"><strong>2.73</strong></span>
<span class="strong"><strong>&gt;&gt;&gt; c.conjugate()  # conjugate of A + Bj is A - Bj</strong></span>
<span class="strong"><strong>(3.14-2.73j)</strong></span>
<span class="strong"><strong>&gt;&gt;&gt; c * 2  # multiplication is allowed</strong></span>
<span class="strong"><strong>(6.28+5.46j)</strong></span>
<span class="strong"><strong>&gt;&gt;&gt; c ** 2  # power operation as well</strong></span>
<span class="strong"><strong>(2.4067000000000007+17.1444j)</strong></span>
<span class="strong"><strong>&gt;&gt;&gt; d = 1 + 1j  # addition and subtraction as well</strong></span>
<span class="strong"><strong>&gt;&gt;&gt; c - d</strong></span>
<span class="strong"><strong>(2.14+1.73j)</strong></span>
</pre></div></div><div class="section" title="Fractions and decimals"><div class="titlepage"><div><div><h2 class="title"><a id="ch02lvl2sec31"/>Fractions and decimals</h2></div></div></div><p>Let's finish<a id="id131" class="indexterm"/> the tour of the number department with a look at fractions and decimals. Fractions hold a rational numerator and denominator in their lowest forms. Let's see a quick example:</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong>&gt;&gt;&gt; from fractions import Fraction</strong></span>
<span class="strong"><strong>&gt;&gt;&gt; Fraction(10, 6)  # mad hatter?</strong></span>
<span class="strong"><strong>Fraction(5, 3)  # notice it's been reduced to lowest terms</strong></span>
<span class="strong"><strong>&gt;&gt;&gt; Fraction(1, 3) + Fraction(2, 3)  # 1/3 + 2/3 = 3/3 = 1/1</strong></span>
<span class="strong"><strong>Fraction(1, 1)</strong></span>
<span class="strong"><strong>&gt;&gt;&gt; f = Fraction(10, 6)</strong></span>
<span class="strong"><strong>&gt;&gt;&gt; f.numerator</strong></span>
<span class="strong"><strong>5</strong></span>
<span class="strong"><strong>&gt;&gt;&gt; f.denominator</strong></span>
<span class="strong"><strong>3</strong></span>
</pre></div><p>Although they can be very useful at times, it's not that common to spot them in commercial software. Much easier instead, is to see decimal numbers being used in all those contexts where precision is everything, for example, scientific and financial calculations.</p><div class="note" title="Note" style=""><div class="inner"><h3 class="title"><a id="note17"/>Note</h3><p>It's important to remember that arbitrary precision decimal numbers come at a price in performance, of course. The amount of data to be stored for each number is far greater than it is for fractions or floats as well as the way they are handled, which requires the Python interpreter much more work behind the scenes. Another interesting thing to know is that you can get and set the precision by accessing <code class="literal">decimal.getcontext().prec</code>.</p></div></div><p>Let's see a quick example with <code class="literal">Decimal</code> numbers:</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong>&gt;&gt;&gt; from decimal import Decimal as D  # rename for brevity</strong></span>
<span class="strong"><strong>&gt;&gt;&gt; D(3.14)  # pi, from float, so approximation issues</strong></span>
<span class="strong"><strong>Decimal('3.140000000000000124344978758017532527446746826171875')</strong></span>
<span class="strong"><strong>&gt;&gt;&gt; D('3.14')  # pi, from a string, so no approximation issues</strong></span>
<span class="strong"><strong>Decimal('3.14')</strong></span>
<span class="strong"><strong>&gt;&gt;&gt; D(0.1) * D(3) - D(0.3)  # from float, we still have the issue</strong></span>
<span class="strong"><strong>Decimal('2.775557561565156540423631668E-17')</strong></span>
<span class="strong"><strong>&gt;&gt;&gt; D('0.1') * D(3) - D('0.3')  # from string, all perfect</strong></span>
<span class="strong"><strong>Decimal('0.0')</strong></span>
</pre></div><p>Notice <a id="id132" class="indexterm"/>that when we construct a <code class="literal">Decimal</code> number from a <code class="literal">float</code>, it takes on all the approximation issues the <code class="literal">float</code> may come from. On the other hand, when the <code class="literal">Decimal</code> has no approximation issues, for example, when we feed an <code class="literal">int</code> or a <code class="literal">string</code> representation to the constructor, then the calculation has no quirky behavior. When it comes to money, use decimals.</p><p>This concludes our introduction to built-in numeric types, let's now see sequences.</p></div></div>
<div class="section" title="Immutable sequences"><div class="titlepage"><div><div><h1 class="title"><a id="ch02lvl1sec25"/>Immutable sequences</h1></div></div></div><p>Let's<a id="id133" class="indexterm"/> start with immutable sequences: strings, tuples, and bytes.</p><div class="section" title="Strings and bytes"><div class="titlepage"><div><div><h2 class="title"><a id="ch02lvl2sec32"/>Strings and bytes</h2></div></div></div><p>Textual data in Python is handled with <span class="strong"><strong>str</strong></span> objects, more commonly known as strings. They<a id="id134" class="indexterm"/> are immutable sequences of <span class="strong"><strong>unicode code points</strong></span>. Unicode<a id="id135" class="indexterm"/> code points can represent a character, but<a id="id136" class="indexterm"/> can also have other meanings, such as formatting data for example. Python, unlike other languages, doesn't have a <code class="literal">char</code> type, so a single character is rendered simply by a string of length 1. Unicode is an excellent way to handle data, and should be used for the internals of any application. When it comes to store textual data though, or send it on the network, you may want to encode it, using an appropriate encoding for the medium you're using. String literals are written in Python using single, double or triple quotes (both single or double). If built with triple quotes, a string can span on multiple lines. An example will clarify the picture:</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong>&gt;&gt;&gt; # 4 ways to make a string</strong></span>
<span class="strong"><strong>&gt;&gt;&gt; str1 = 'This is a string. We built it with single quotes.'</strong></span>
<span class="strong"><strong>&gt;&gt;&gt; str2 = "This is also a string, but built with double quotes."</strong></span>
<span class="strong"><strong>&gt;&gt;&gt; str3 = '''This is built using triple quotes,</strong></span>
<span class="strong"><strong>... so it can span multiple lines.'''</strong></span>
<span class="strong"><strong>&gt;&gt;&gt; str4 = """This too</strong></span>
<span class="strong"><strong>... is a multiline one</strong></span>
<span class="strong"><strong>... built with triple double-quotes."""</strong></span>
<span class="strong"><strong>&gt;&gt;&gt; str4  #A</strong></span>
<span class="strong"><strong>'This too\nis a multiline one\nbuilt with triple double-quotes.'</strong></span>
<span class="strong"><strong>&gt;&gt;&gt; print(str4)  #B</strong></span>
<span class="strong"><strong>This too</strong></span>
<span class="strong"><strong>is a multiline one</strong></span>
<span class="strong"><strong>built with triple double-quotes.</strong></span>
</pre></div><p>In <code class="literal">#A</code> and <code class="literal">#B</code>, we print <code class="literal">str4</code>, first implicitly, then explicitly using the <code class="literal">print</code> function. A nice <a id="id137" class="indexterm"/>exercise would be to find out why they are different. Are you up to the challenge? (hint, look up the <code class="literal">str</code> function)</p><p>Strings, like any sequence, have a length. You can get this by calling the <code class="literal">len</code> function:</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong>&gt;&gt;&gt; len(str1)</strong></span>
<span class="strong"><strong>49</strong></span>
</pre></div><div class="section" title="Encoding and decoding strings"><div class="titlepage"><div><div><h3 class="title"><a id="ch02lvl3sec01"/>Encoding and decoding strings</h3></div></div></div><p>Using<a id="id138" class="indexterm"/> the <code class="literal">encode</code>/<code class="literal">decode</code> methods, we can encode unicode strings and <a id="id139" class="indexterm"/>decode bytes objects. <span class="strong"><strong>Utf-8</strong></span> is a variable length character<a id="id140" class="indexterm"/> encoding, capable of encoding all possible unicode code points. It is the dominant encoding for the Web (and not only). Notice also that by adding a literal <code class="literal">b</code> in front of a string declaration, we're creating a <span class="emphasis"><em>bytes</em></span> object.</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong>&gt;&gt;&gt; s = "This is üŋíc0de"  # unicode string: code points</strong></span>
<span class="strong"><strong>&gt;&gt;&gt; type(s)</strong></span>
<span class="strong"><strong>&lt;class 'str'&gt;</strong></span>
<span class="strong"><strong>&gt;&gt;&gt; encoded_s = s.encode('utf-8')  # utf-8 encoded version of s</strong></span>
<span class="strong"><strong>&gt;&gt;&gt; encoded_s</strong></span>
<span class="strong"><strong>b'This is \xc3\xbc\xc5\x8b\xc3\xadc0de'  # result: bytes object</strong></span>
<span class="strong"><strong>&gt;&gt;&gt; type(encoded_s)  # another way to verify it</strong></span>
<span class="strong"><strong>&lt;class 'bytes'&gt;</strong></span>
<span class="strong"><strong>&gt;&gt;&gt; encoded_s.decode('utf-8')  # let's revert to the original</strong></span>
<span class="strong"><strong>'This is üŋíc0de'</strong></span>
<span class="strong"><strong>&gt;&gt;&gt; bytes_obj = b"A bytes object"  # a bytes object</strong></span>
<span class="strong"><strong>&gt;&gt;&gt; type(bytes_obj)</strong></span>
<span class="strong"><strong>&lt;class 'bytes'&gt;</strong></span>
</pre></div></div><div class="section" title="Indexing and slicing strings"><div class="titlepage"><div><div><h3 class="title"><a id="ch02lvl3sec02"/>Indexing and slicing strings</h3></div></div></div><p>When <a id="id141" class="indexterm"/>manipulating sequences, it's very common to have to access them<a id="id142" class="indexterm"/> at one precise position (indexing), or to get a subsequence out of them (slicing). When dealing with immutable sequences, both operations are read-only.</p><p>While indexing comes in one form, a zero-based access to any position within the sequence, slicing comes in different forms. When you get a slice of a sequence, you can specify the <code class="literal">start</code> and <code class="literal">stop</code> positions, and the <code class="literal">step</code>. They are separated with a colon (<code class="literal">:</code>) like this: <code class="literal">my_sequence[start:stop:step]</code>. All the arguments are optional, <code class="literal">start</code> is inclusive, <code class="literal">stop</code> is exclusive. It's much easier to show an example, rather than explain them further in words:</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong>&gt;&gt;&gt; s = "The trouble is you think you have time."</strong></span>
<span class="strong"><strong>&gt;&gt;&gt; s[0]  # indexing at position 0, which is the first char</strong></span>
<span class="strong"><strong>'T'</strong></span>
<span class="strong"><strong>&gt;&gt;&gt; s[5]  # indexing at position 5, which is the sixth char</strong></span>
<span class="strong"><strong>'r'</strong></span>
<span class="strong"><strong>&gt;&gt;&gt; s[:4]  # slicing, we specify only the stop position</strong></span>
<span class="strong"><strong>'The '</strong></span>
<span class="strong"><strong>&gt;&gt;&gt; s[4:]  # slicing, we specify only the start position</strong></span>
<span class="strong"><strong>'trouble is you think you have time.'</strong></span>
<span class="strong"><strong>&gt;&gt;&gt; s[2:14]  # slicing, both start and stop positions</strong></span>
<span class="strong"><strong>'e trouble is'</strong></span>
<span class="strong"><strong>&gt;&gt;&gt; s[2:14:3]  # slicing, start, stop and step (every 3 chars)</strong></span>
<span class="strong"><strong>'erb '</strong></span>
<span class="strong"><strong>&gt;&gt;&gt; s[:]  # quick way of making a copy</strong></span>
<span class="strong"><strong>'The trouble is you think you have time.'</strong></span>
</pre></div><p>Of all<a id="id143" class="indexterm"/> the lines, the last one is probably the most interesting. If you don't specify<a id="id144" class="indexterm"/> a parameter, Python will fill in the default for you. In this case, <code class="literal">start</code> will be the start of the string, <code class="literal">stop</code> will be the end of the sting, and <code class="literal">step</code> will be the default 1. This is an easy and quick way of obtaining a copy of the string <code class="literal">s</code> (same value, but different object). Can you find a way to get the reversed copy of a string using slicing? (don't look it up, find it for yourself)</p></div></div><div class="section" title="Tuples"><div class="titlepage"><div><div><h2 class="title"><a id="ch02lvl2sec33"/>Tuples</h2></div></div></div><p>The last <a id="id145" class="indexterm"/>immutable sequence type we're going to see is the tuple. A <span class="strong"><strong>tuple</strong></span> is a sequence of arbitrary Python objects. In a tuple, items are separated by <a id="id146" class="indexterm"/>commas. They are used everywhere in Python, because they allow for patterns that are hard to reproduce in other languages. Sometimes tuples are used implicitly, for example to set up multiple variables on one line, or to allow a function to return multiple different objects (usually a function returns one object only, in many other languages), and even in the Python console, you can use tuples implicitly to print multiple elements with one single instruction. We'll see examples for all these cases:</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong>&gt;&gt;&gt; t = ()  # empty tuple</strong></span>
<span class="strong"><strong>&gt;&gt;&gt; type(t)</strong></span>
<span class="strong"><strong>&lt;class 'tuple'&gt;</strong></span>
<span class="strong"><strong>&gt;&gt;&gt; one_element_tuple = (42, )  # you need the comma!</strong></span>
<span class="strong"><strong>&gt;&gt;&gt; three_elements_tuple = (1, 3, 5)</strong></span>
<span class="strong"><strong>&gt;&gt;&gt; a, b, c = 1, 2, 3  # tuple for multiple assignment</strong></span>
<span class="strong"><strong>&gt;&gt;&gt; a, b, c  # implicit tuple to print with one instruction</strong></span>
<span class="strong"><strong>(1, 2, 3)</strong></span>
<span class="strong"><strong>&gt;&gt;&gt; 3 in three_elements_tuple  # membership test</strong></span>
<span class="strong"><strong>True</strong></span>
</pre></div><p>Notice that the membership operator <code class="literal">in</code> can also be used with lists, strings, dictionaries, and in general with collection and sequence objects.</p><div class="note" title="Note" style=""><div class="inner"><h3 class="title"><a id="note18"/>Note</h3><p>Notice that to create a tuple with one item, we need to put that comma after the item. The reason is that without the comma that item is just itself wrapped in braces, kind of in a redundant mathematical expression. Notice also that on assignment, braces are optional so <code class="literal">my_tuple = 1, 2, 3</code> is the same as <code class="literal">my_tuple = (1, 2, 3)</code>.</p></div></div><p>One<a id="id147" class="indexterm"/> thing that tuple assignment allows us to do, is <span class="emphasis"><em>one-line swaps</em></span>, with no need for a third temporary variable. Let's see first a more traditional way of doing it:</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong>&gt;&gt;&gt; a, b = 1, 2</strong></span>
<span class="strong"><strong>&gt;&gt;&gt; c = a  # we need three lines and a temporary var c</strong></span>
<span class="strong"><strong>&gt;&gt;&gt; a = b</strong></span>
<span class="strong"><strong>&gt;&gt;&gt; b = c</strong></span>
<span class="strong"><strong>&gt;&gt;&gt; a, b  # a and b have been swapped</strong></span>
<span class="strong"><strong>(2, 1)</strong></span>
</pre></div><p>And now let's see how we would do it in Python:</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong>&gt;&gt;&gt; a, b = b, a  # this is the Pythonic way to do it</strong></span>
<span class="strong"><strong>&gt;&gt;&gt; a, b</strong></span>
<span class="strong"><strong>(1, 2)</strong></span>
</pre></div><p>Take a look at the line that shows you the Pythonic way of swapping two values: do you remember what I wrote in <a class="link" href="ch01.html" title="Chapter 1. Introduction and First Steps – Take a Deep Breath">Chapter 1</a>, <span class="emphasis"><em>Introduction and First Steps – Take a Deep Breath</em></span>. A Python program is typically one-fifth to one-third the size of equivalent Java or C++ code, and features like one-line swaps contribute to this. Python is elegant, where elegance in this context means also economy.</p><p>Because they are immutable, tuples can be used as keys for dictionaries (we'll see this shortly). The <code class="literal">dict</code> objects need keys to be immutable because if they could change, then the value they reference wouldn't be found any more (because the path to it depends on the key). If you are into data structures, you know how nice a feature this one is to have. To me, tuples are Python's built-in data that most closely represent a mathematical vector. This doesn't mean that this was the reason for which they were created though. Tuples usually contain an heterogeneous sequence of elements, while on the other hand lists are most of the times homogeneous. Moreover, tuples are normally accessed via unpacking or indexing, while lists are usually iterated over.</p></div></div>
<div class="section" title="Mutable sequences"><div class="titlepage"><div><div><h1 class="title"><a id="ch02lvl1sec26"/>Mutable sequences</h1></div></div></div><p>Mutable sequences differ from their immutable sisters in that they can be changed after creation. There are<a id="id148" class="indexterm"/> two mutable sequence types in Python: lists and byte arrays. I said before that the dictionary is the king of data structures in Python. I guess this makes the list its rightful queen.</p><div class="section" title="Lists"><div class="titlepage"><div><div><h2 class="title"><a id="ch02lvl2sec34"/>Lists</h2></div></div></div><p>Python lists<a id="id149" class="indexterm"/> are mutable sequences. They are very similar to tuples, but they don't have the restrictions due to immutability. Lists are commonly used to store collections of homogeneous objects, but there is nothing preventing you to store heterogeneous collections as well. Lists can be created in many different ways, let's see an example:</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong>&gt;&gt;&gt; []  # empty list</strong></span>
<span class="strong"><strong>[]</strong></span>
<span class="strong"><strong>&gt;&gt;&gt; list()  # same as []</strong></span>
<span class="strong"><strong>[]</strong></span>
<span class="strong"><strong>&gt;&gt;&gt; [1, 2, 3]  # as with tuples, items are comma separated</strong></span>
<span class="strong"><strong>[1, 2, 3]</strong></span>
<span class="strong"><strong>&gt;&gt;&gt; [x + 5 for x in [2, 3, 4]]  # Python is magic</strong></span>
<span class="strong"><strong>[7, 8, 9]</strong></span>
<span class="strong"><strong>&gt;&gt;&gt; list((1, 3, 5, 7, 9))  # list from a tuple</strong></span>
<span class="strong"><strong>[1, 3, 5, 7, 9]</strong></span>
<span class="strong"><strong>&gt;&gt;&gt; list('hello')  # list from a string</strong></span>
<span class="strong"><strong>['h', 'e', 'l', 'l', 'o']</strong></span>
</pre></div><p>In the previous example, I showed you how to create a list using different techniques. I would like you to take a good look at the line that says <code class="literal">Python is magic</code>, which I am not expecting you to fully understand at this point (unless you cheated and you're not a novice!). That is called a <span class="strong"><strong>list</strong></span> <span class="strong"><strong>comprehension</strong></span>, a very powerful functional feature of Python, which <a id="id150" class="indexterm"/>we'll see in detail in <a class="link" href="ch05.html" title="Chapter 5. Saving Time and Memory">Chapter 5</a>, <span class="emphasis"><em>Saving Time and Memory</em></span>. I just wanted to make your mouth water at this point.</p><p>Creating lists is good, but the real fun comes when we use them, so let's see the main methods they gift us with:</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong>&gt;&gt;&gt; a = [1, 2, 1, 3]</strong></span>
<span class="strong"><strong>&gt;&gt;&gt; a.append(13)  # we can append anything at the end</strong></span>
<span class="strong"><strong>&gt;&gt;&gt; a</strong></span>
<span class="strong"><strong>[1, 2, 1, 3, 13]</strong></span>
<span class="strong"><strong>&gt;&gt;&gt; a.count(1)  # how many `1` are there in the list?</strong></span>
<span class="strong"><strong>2</strong></span>
<span class="strong"><strong>&gt;&gt;&gt; a.extend([5, 7])  # extend the list by another (or sequence)</strong></span>
<span class="strong"><strong>&gt;&gt;&gt; a</strong></span>
<span class="strong"><strong>[1, 2, 1, 3, 13, 5, 7]</strong></span>
<span class="strong"><strong>&gt;&gt;&gt; a.index(13)  # position of `13` in the list (0-based indexing)</strong></span>
<span class="strong"><strong>4</strong></span>
<span class="strong"><strong>&gt;&gt;&gt; a.insert(0, 17)  # insert `17` at position 0</strong></span>
<span class="strong"><strong>&gt;&gt;&gt; a</strong></span>
<span class="strong"><strong>[17, 1, 2, 1, 3, 13, 5, 7]</strong></span>
<span class="strong"><strong>&gt;&gt;&gt; a.pop()  # pop (remove and return) last element</strong></span>
<span class="strong"><strong>7</strong></span>
<span class="strong"><strong>&gt;&gt;&gt; a.pop(3)  # pop element at position 3</strong></span>
<span class="strong"><strong>1</strong></span>
<span class="strong"><strong>&gt;&gt;&gt; a</strong></span>
<span class="strong"><strong>[17, 1, 2, 3, 13, 5]</strong></span>
<span class="strong"><strong>&gt;&gt;&gt; a.remove(17)  # remove `17` from the list</strong></span>
<span class="strong"><strong>&gt;&gt;&gt; a</strong></span>
<span class="strong"><strong>[1, 2, 3, 13, 5]</strong></span>
<span class="strong"><strong>&gt;&gt;&gt; a.reverse()  # reverse the order of the elements in the list</strong></span>
<span class="strong"><strong>&gt;&gt;&gt; a</strong></span>
<span class="strong"><strong>[5, 13, 3, 2, 1]</strong></span>
<span class="strong"><strong>&gt;&gt;&gt; a.sort()  # sort the list</strong></span>
<span class="strong"><strong>&gt;&gt;&gt; a</strong></span>
<span class="strong"><strong>[1, 2, 3, 5, 13]</strong></span>
<span class="strong"><strong>&gt;&gt;&gt; a.clear()  # remove all elements from the list</strong></span>
<span class="strong"><strong>&gt;&gt;&gt; a</strong></span>
<span class="strong"><strong>[]</strong></span>
</pre></div><p>The preceding <a id="id151" class="indexterm"/>code gives you a roundup of list's main methods. I want to show you how powerful they are, using <code class="literal">extend</code> as an example. You can extend lists using any sequence type:</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong>&gt;&gt;&gt; a = list('hello')  # makes a list from a string</strong></span>
<span class="strong"><strong>&gt;&gt;&gt; a</strong></span>
<span class="strong"><strong>['h', 'e', 'l', 'l', 'o']</strong></span>
<span class="strong"><strong>&gt;&gt;&gt; a.append(100)  # append 100, heterogeneous type</strong></span>
<span class="strong"><strong>&gt;&gt;&gt; a</strong></span>
<span class="strong"><strong>['h', 'e', 'l', 'l', 'o', 100]</strong></span>
<span class="strong"><strong>&gt;&gt;&gt; a.extend((1, 2, 3))  # extend using tuple</strong></span>
<span class="strong"><strong>&gt;&gt;&gt; a</strong></span>
<span class="strong"><strong>['h', 'e', 'l', 'l', 'o', 100, 1, 2, 3]</strong></span>
<span class="strong"><strong>&gt;&gt;&gt; a.extend('...')  # extend using string</strong></span>
<span class="strong"><strong>&gt;&gt;&gt; a</strong></span>
<span class="strong"><strong>['h', 'e', 'l', 'l', 'o', 100, 1, 2, 3, '.', '.', '.']</strong></span>
</pre></div><p>Now, let's see what are the most common operations you can do with lists:</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong>&gt;&gt;&gt; a = [1, 3, 5, 7]</strong></span>
<span class="strong"><strong>&gt;&gt;&gt; min(a)  # minimum value in the list</strong></span>
<span class="strong"><strong>1</strong></span>
<span class="strong"><strong>&gt;&gt;&gt; max(a)  # maximum value in the list</strong></span>
<span class="strong"><strong>7</strong></span>
<span class="strong"><strong>&gt;&gt;&gt; sum(a)  # sum of all values in the list</strong></span>
<span class="strong"><strong>16</strong></span>
<span class="strong"><strong>&gt;&gt;&gt; len(a)  # number of elements in the list</strong></span>
<span class="strong"><strong>4</strong></span>
<span class="strong"><strong>&gt;&gt;&gt; b = [6, 7, 8]</strong></span>
<span class="strong"><strong>&gt;&gt;&gt; a + b  # `+` with list means concatenation</strong></span>
<span class="strong"><strong>[1, 3, 5, 7, 6, 7, 8]</strong></span>
<span class="strong"><strong>&gt;&gt;&gt; a * 2  # `*` has also a special meaning</strong></span>
<span class="strong"><strong>[1, 3, 5, 7, 1, 3, 5, 7]</strong></span>
</pre></div><p>The last two lines in the preceding code are quite interesting because they introduce us to a concept called <span class="strong"><strong>operator</strong></span> <span class="strong"><strong>overloading</strong></span>. In short, it means that operators such as <code class="literal">+</code>, <code class="literal">-</code>. <code class="literal">*</code>, <code class="literal">%</code>, and so <a id="id152" class="indexterm"/>on, may represent different operations according to<a id="id153" class="indexterm"/> the context they are used in. It doesn't make any sense to sum two lists, right? Therefore, the <code class="literal">+</code> sign is used to concatenate them. Hence, the <code class="literal">*</code> sign is used to concatenate the list to itself according to the right operand. Now, let's take a step further down the rabbit hole and see something a little more interesting. I want to show you how powerful the sort method can be and how easy it is in Python to achieve results that require a great deal of effort in other languages:</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong>&gt;&gt;&gt; from operator import itemgetter</strong></span>
<span class="strong"><strong>&gt;&gt;&gt; a = [(5, 3), (1, 3), (1, 2), (2, -1), (4, 9)]</strong></span>
<span class="strong"><strong>&gt;&gt;&gt; sorted(a)</strong></span>
<span class="strong"><strong>[(1, 2), (1, 3), (2, -1), (4, 9), (5, 3)]</strong></span>
<span class="strong"><strong>&gt;&gt;&gt; sorted(a, key=itemgetter(0))</strong></span>
<span class="strong"><strong>[(1, 3), (1, 2), (2, -1), (4, 9), (5, 3)]</strong></span>
<span class="strong"><strong>&gt;&gt;&gt; sorted(a, key=itemgetter(0, 1))</strong></span>
<span class="strong"><strong>[(1, 2), (1, 3), (2, -1), (4, 9), (5, 3)]</strong></span>
<span class="strong"><strong>&gt;&gt;&gt; sorted(a, key=itemgetter(1))</strong></span>
<span class="strong"><strong>[(2, -1), (1, 2), (5, 3), (1, 3), (4, 9)]</strong></span>
<span class="strong"><strong>&gt;&gt;&gt; sorted(a, key=itemgetter(1), reverse=True)</strong></span>
<span class="strong"><strong>[(4, 9), (5, 3), (1, 3), (1, 2), (2, -1)]</strong></span>
</pre></div><p>The preceding code deserves a little explanation. First of all, <code class="literal">a</code> is a list of tuples. This means each element in <code class="literal">a</code> is a tuple (a <span class="emphasis"><em>2-tuple</em></span>, to be picky). When we call <code class="literal">sorted(some_list)</code>, we get a sorted version of <code class="literal">some_list</code>. In this case, the sorting on a 2-tuple works by sorting them on the first item in the tuple, and on the second when the first one is the same. You can see this behavior in the result of <code class="literal">sorted(a)</code>, which yields <code class="literal">[(1, 2), (1, 3), ...]</code>. Python also gives us the ability to control on which element(s) of the tuple the sorting must be run against. Notice that when we instruct the <code class="literal">sorted</code> function to work on the first element of each tuple (by <code class="literal">key=itemgetter(0)</code>), the result is different: <code class="literal">[(1, 3), (1, 2), ...]</code>. The sorting is done only on the first element of each tuple (which is the one at position 0). If we want to replicate the default behavior of a simple <code class="literal">sorted(a)</code> call, we need to use <code class="literal">key=itemgetter(0, 1)</code>, which tells Python to sort first on the elements at position 0 within the tuples, and then on those at position 1. Compare the results and you'll see they match.</p><p>For completeness, I included an example of sorting only on the elements at position 1, and the same but in reverse order. If you have ever seen sorting in Java, I expect you to be on your knees crying with joy at this very moment.</p><p>The Python sorting <a id="id154" class="indexterm"/>algorithm is very powerful, and it was written by Tim Peters (we've already seen this name, can you recall when?). It is aptly named <span class="strong"><strong>Timsort</strong></span>, and it is<a id="id155" class="indexterm"/> a blend between <span class="strong"><strong>merge</strong></span> and <span class="strong"><strong>insertion</strong></span> <span class="strong"><strong>sort</strong></span> and <a id="id156" class="indexterm"/>has better time performances than most other algorithms used for mainstream programming languages. Timsort is a stable sorting algorithm, which means that when multiple records have the same key, their original order is preserved. We've seen this in the result of <code class="literal">sorted(a, key=itemgetter(0))</code> which has yielded <code class="literal">[(1, 3), (1, 2), ...]</code> in which the order of those two tuples has been preserved because they have the same value at position 0.</p></div><div class="section" title="Byte arrays"><div class="titlepage"><div><div><h2 class="title"><a id="ch02lvl2sec35"/>Byte arrays</h2></div></div></div><p>To<a id="id157" class="indexterm"/> conclude our overview of mutable sequence types, let's spend a couple of minutes on the <code class="literal">bytearray</code> type. Basically, they represent the mutable version of <code class="literal">bytes</code> objects. They expose most of the usual methods of mutable sequences as well as most of the methods of the <code class="literal">bytes</code> type. Items are integers in the range [0, 256).</p><div class="note" title="Note" style=""><div class="inner"><h3 class="title"><a id="note19"/>Note</h3><p>When it comes to intervals, I'm going to use the standard notation for open/closed ranges. A square bracket on one end means that the value is included, while a round brace means it's excluded. The granularity is usually inferred by the type of the edge elements so, for example, the interval [3, 7] means all integers between 3 and 7, inclusive. On the other hand, (3, 7) means all integers between 3 and 7 exclusive (hence 4, 5, and 6). Items in a <code class="literal">bytearray</code> type are integers between 0 and 256, 0 is included, 256 is not. One reason intervals are often expressed like this is to ease coding. If we break a range [a, b) into <span class="emphasis"><em>N</em></span> consecutive ranges, we can easily represent the original one as a concatenation like this:</p><div class="mediaobject"><img src="graphics/4715_02_04.jpg" alt="Byte arrays"/></div><p>The middle points (<span class="emphasis"><em>k</em></span>
<span class="emphasis"><em><sub>i</sub></em></span>) being excluded on one end, and included on the other end, allow for easy concatenation and splitting when intervals are handled in the code.</p></div></div><p>Let's see<a id="id158" class="indexterm"/> a quick example with the type <code class="literal">bytearray</code>:</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong>&gt;&gt;&gt; bytearray()  # empty bytearray object</strong></span>
<span class="strong"><strong>bytearray(b'')</strong></span>
<span class="strong"><strong>&gt;&gt;&gt; bytearray(10)  # zero-filled instance with given length</strong></span>
<span class="strong"><strong>bytearray(b'\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00')</strong></span>
<span class="strong"><strong>&gt;&gt;&gt; bytearray(range(5))  # bytearray from iterable of integers</strong></span>
<span class="strong"><strong>bytearray(b'\x00\x01\x02\x03\x04')</strong></span>
<span class="strong"><strong>&gt;&gt;&gt; name = bytearray(b'Lina')  # A - bytearray from bytes</strong></span>
<span class="strong"><strong>&gt;&gt;&gt; name.replace(b'L', b'l')</strong></span>
<span class="strong"><strong>bytearray(b'lina')</strong></span>
<span class="strong"><strong>&gt;&gt;&gt; name.endswith(b'na')</strong></span>
<span class="strong"><strong>True</strong></span>
<span class="strong"><strong>&gt;&gt;&gt; name.upper()</strong></span>
<span class="strong"><strong>bytearray(b'LINA')</strong></span>
<span class="strong"><strong>&gt;&gt;&gt; name.count(b'L')</strong></span>
<span class="strong"><strong>1</strong></span>
</pre></div><p>As you can see in the preceding code, there are a few ways to create a <code class="literal">bytearray</code> object. They can be useful in many situations, for example, when receiving data through a <span class="strong"><strong>socket</strong></span>, they eliminate the need to concatenate data while polling, hence they prove very handy. On the line <code class="literal">#A</code>, I created the <code class="literal">name</code> <code class="literal">bytearray</code> from the string <code class="literal">b'Lina'</code> to show you how the <code class="literal">bytearray</code> object exposes methods from both sequences and strings, which is extremely handy. If you think about it, they can be considered as mutable strings.</p></div></div>
<div class="section" title="Set types"><div class="titlepage"><div><div><h1 class="title"><a id="ch02lvl1sec27"/>Set types</h1></div></div></div><p>Python also <a id="id159" class="indexterm"/>provides two set types, <code class="literal">set</code> and <code class="literal">frozenset</code>. The <code class="literal">set</code> type is mutable, while <code class="literal">frozenset</code> is immutable. They are unordered collections of immutable objects.</p><p>
<span class="strong"><strong>Hashability</strong></span> is a <a id="id160" class="indexterm"/>characteristic that allows an object to be used as a set member as well as a key for a dictionary, as we'll see very soon.</p><div class="note" title="Note" style=""><div class="inner"><h3 class="title"><a id="note21"/>Note</h3><p>An object is hashable if it has a hash value which never changes during its lifetime.</p></div></div><p>Objects that compare equally must have the same hash value. Sets are very commonly used to test for membership, so let's introduce the <code class="literal">in</code> operator in the following example:</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong>&gt;&gt;&gt; small_primes = set()  # empty set</strong></span>
<span class="strong"><strong>&gt;&gt;&gt; small_primes.add(2)  # adding one element at a time</strong></span>
<span class="strong"><strong>&gt;&gt;&gt; small_primes.add(3)</strong></span>
<span class="strong"><strong>&gt;&gt;&gt; small_primes.add(5)</strong></span>
<span class="strong"><strong>&gt;&gt;&gt; small_primes</strong></span>
<span class="strong"><strong>{2, 3, 5}</strong></span>
<span class="strong"><strong>&gt;&gt;&gt; small_primes.add(1)  # Look what I've done, 1 is not a prime!</strong></span>
<span class="strong"><strong>&gt;&gt;&gt; small_primes</strong></span>
<span class="strong"><strong>{1, 2, 3, 5}</strong></span>
<span class="strong"><strong>&gt;&gt;&gt; small_primes.remove(1)  # so let's remove it</strong></span>
<span class="strong"><strong>&gt;&gt;&gt; 3 in small_primes  # membership test</strong></span>
<span class="strong"><strong>True</strong></span>
<span class="strong"><strong>&gt;&gt;&gt; 4 in small_primes</strong></span>
<span class="strong"><strong>False</strong></span>
<span class="strong"><strong>&gt;&gt;&gt; 4 not in small_primes  # negated membership test</strong></span>
<span class="strong"><strong>True</strong></span>
<span class="strong"><strong>&gt;&gt;&gt; small_primes.add(3)  # trying to add 3 again</strong></span>
<span class="strong"><strong>&gt;&gt;&gt; small_primes</strong></span>
<span class="strong"><strong>{2, 3, 5}  # no change, duplication is not allowed</strong></span>
<span class="strong"><strong>&gt;&gt;&gt; bigger_primes = set([5, 7, 11, 13])  # faster creation</strong></span>
<span class="strong"><strong>&gt;&gt;&gt; small_primes | bigger_primes  # union operator `|`</strong></span>
<span class="strong"><strong>{2, 3, 5, 7, 11, 13}</strong></span>
<span class="strong"><strong>&gt;&gt;&gt; small_primes &amp; bigger_primes  # intersection operator `&amp;`</strong></span>
<span class="strong"><strong>{5}</strong></span>
<span class="strong"><strong>&gt;&gt;&gt; small_primes - bigger_primes  # difference operator `-`</strong></span>
<span class="strong"><strong>{2, 3}</strong></span>
</pre></div><p>In the<a id="id161" class="indexterm"/> preceding code, you can see two different ways to create a set. One creates an empty set and then adds elements one at a time. The other creates the set using a list of numbers as argument to the constructor, which does all the work for us. Of course, you can create a set from a list or tuple (or any iterable) and then you can add and remove members from the set as you please.</p><p>Another way of creating a set is by simply using the curly braces notation, like this:</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong>&gt;&gt;&gt; small_primes = {2, 3, 5, 5, 3}</strong></span>
<span class="strong"><strong>&gt;&gt;&gt; small_primes</strong></span>
<span class="strong"><strong>{2, 3, 5}</strong></span>
</pre></div><p>Notice I added some duplication to emphasize that the result set won't have any.</p><div class="note" title="Note" style=""><div class="inner"><h3 class="title"><a id="note22"/>Note</h3><p>We'll see iterable objects and iteration in the next chapter. For now, just know that iterable objects are objects you can iterate on in a direction.</p></div></div><p>Let's see<a id="id162" class="indexterm"/> an example about the immutable counterpart of the set type: <code class="literal">frozenset</code>.</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong>&gt;&gt;&gt; small_primes = frozenset([2, 3, 5, 7])</strong></span>
<span class="strong"><strong>&gt;&gt;&gt; bigger_primes = frozenset([5, 7, 11])</strong></span>
<span class="strong"><strong>&gt;&gt;&gt; small_primes.add(11)  # we cannot add to a frozenset</strong></span>
<span class="strong"><strong>Traceback (most recent call last):</strong></span>
<span class="strong"><strong>  File "&lt;stdin&gt;", line 1, in &lt;module&gt;</strong></span>
<span class="strong"><strong>AttributeError: 'frozenset' object has no attribute 'add'</strong></span>
<span class="strong"><strong>&gt;&gt;&gt; small_primes.remove(2)  # neither we can remove</strong></span>
<span class="strong"><strong>Traceback (most recent call last):</strong></span>
<span class="strong"><strong>  File "&lt;stdin&gt;", line 1, in &lt;module&gt;</strong></span>
<span class="strong"><strong>AttributeError: 'frozenset' object has no attribute 'remove'</strong></span>
<span class="strong"><strong>&gt;&gt;&gt; small_primes &amp; bigger_primes  # intersect, union, etc. allowed</strong></span>
<span class="strong"><strong>frozenset({5, 7})</strong></span>
</pre></div><p>As you can see, <code class="literal">frozenset</code> objects are quite limited in respect of their mutable counterpart. They still prove very effective for membership test, union, intersection and difference operations, and for performance reasons.</p></div>
<div class="section" title="Mapping types &#x2013; dictionaries"><div class="titlepage"><div><div><h1 class="title"><a id="ch02lvl1sec28"/>Mapping types – dictionaries</h1></div></div></div><p>Of all<a id="id163" class="indexterm"/> the built-in Python data types, the dictionary is probably the most interesting one. It's the only standard mapping type, and it is the backbone of every Python object.</p><p>A dictionary maps keys to values. Keys need to be hashable objects, while values can be of any arbitrary type. Dictionaries are mutable objects.</p><p>There are quite a few different ways to create a dictionary, so let me give you a simple example of how to create a dictionary equal to <code class="literal">{'A': 1, 'Z': -1}</code> in five different ways:</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong>&gt;&gt;&gt; a = dict(A=1, Z=-1)</strong></span>
<span class="strong"><strong>&gt;&gt;&gt; b = {'A': 1, 'Z': -1}</strong></span>
<span class="strong"><strong>&gt;&gt;&gt; c = dict(zip(['A', 'Z'], [1, -1]))</strong></span>
<span class="strong"><strong>&gt;&gt;&gt; d = dict([('A', 1), ('Z', -1)])</strong></span>
<span class="strong"><strong>&gt;&gt;&gt; e = dict({'Z': -1, 'A': 1})</strong></span>
<span class="strong"><strong>&gt;&gt;&gt; a == b == c == d == e  # are they all the same?</strong></span>
<span class="strong"><strong>True  # indeed!</strong></span>
</pre></div><p>Have you noticed those double equals? Assignment is done with one equal, while to check whether an object is the same as another one (or 5 in one go, in this case), we use double equals. There is also another way to compare objects, which involves the <span class="strong"><strong>is</strong></span> operator, and checks whether the two objects are the same (if they have the same ID, not just the value), but <a id="id164" class="indexterm"/>unless you have a good reason to use it, you should use the double equal instead. In the preceding code, I also used one nice function: <code class="literal">zip</code>. It is named after the real-life zip, which glues together two things taking one element from each at a time. Let me show you an example:</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong>&gt;&gt;&gt; list(zip(['h', 'e', 'l', 'l', 'o'], [1, 2, 3, 4, 5]))</strong></span>
<span class="strong"><strong>[('h', 1), ('e', 2), ('l', 3), ('l', 4), ('o', 5)]</strong></span>
<span class="strong"><strong>&gt;&gt;&gt; list(zip('hello', range(1, 6)))  # equivalent, more Pythonic</strong></span>
<span class="strong"><strong>[('h', 1), ('e', 2), ('l', 3), ('l', 4), ('o', 5)]</strong></span>
</pre></div><p>In the preceding example, I have created the same list in two different ways, one more explicit, and the other a little bit more Pythonic. Forget for a moment that I had to wrap the <code class="literal">list</code> constructor around the <code class="literal">zip</code> call (the reason is because <code class="literal">zip</code> returns an iterator, not a <code class="literal">list</code>), and concentrate on the result. See how <code class="literal">zip</code> has coupled the first elements of its two arguments together, then the second ones, then the third ones, and so on and so forth? Take a look at your pants (or at your purse if you're a lady) and you'll see the same behavior in your actual zip. But let's go back to dictionaries and see how many wonderful methods they expose for allowing us to manipulate them as we want. Let's start with the basic operations:</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong>&gt;&gt;&gt; d = {}</strong></span>
<span class="strong"><strong>&gt;&gt;&gt; d['a'] = 1  # let's set a couple of (key, value) pairs</strong></span>
<span class="strong"><strong>&gt;&gt;&gt; d['b'] = 2</strong></span>
<span class="strong"><strong>&gt;&gt;&gt; len(d)  # how many pairs?</strong></span>
<span class="strong"><strong>2</strong></span>
<span class="strong"><strong>&gt;&gt;&gt; d['a']  # what is the value of 'a'?</strong></span>
<span class="strong"><strong>1</strong></span>
<span class="strong"><strong>&gt;&gt;&gt; d  # how does `d` look now?</strong></span>
<span class="strong"><strong>{'a': 1, 'b': 2}</strong></span>
<span class="strong"><strong>&gt;&gt;&gt; del d['a']  # let's remove `a`</strong></span>
<span class="strong"><strong>&gt;&gt;&gt; d</strong></span>
<span class="strong"><strong>{'b': 2}</strong></span>
<span class="strong"><strong>&gt;&gt;&gt; d['c'] = 3  # let's add 'c': 3</strong></span>
<span class="strong"><strong>&gt;&gt;&gt; 'c' in d  # membership is checked against the keys</strong></span>
<span class="strong"><strong>True</strong></span>
<span class="strong"><strong>&gt;&gt;&gt; 3 in d  # not the values</strong></span>
<span class="strong"><strong>False</strong></span>
<span class="strong"><strong>&gt;&gt;&gt; 'e' in d</strong></span>
<span class="strong"><strong>False</strong></span>
<span class="strong"><strong>&gt;&gt;&gt; d.clear()  # let's clean everything from this dictionary</strong></span>
<span class="strong"><strong>&gt;&gt;&gt; d</strong></span>
<span class="strong"><strong>{}</strong></span>
</pre></div><p>Notice how accessing keys of a dictionary, regardless of the type of operation we're performing, is done through square brackets. Do you remember strings, list, and tuples? We were accessing elements at some position through square brackets as well. Yet another example of Python's consistency.</p><p>Let's see<a id="id165" class="indexterm"/> now three special objects called dictionary views: <code class="literal">keys</code>, <code class="literal">values</code>, and <code class="literal">items</code>. These objects provide a dynamic view of the dictionary entries and they change when the dictionary changes. <code class="literal">keys()</code> returns all the keys in the dictionary, <code class="literal">values()</code> returns all the values in the dictionary, and <code class="literal">items()</code> returns all the <span class="emphasis"><em>(key, value)</em></span> pairs in the dictionary.</p><div class="note" title="Note" style=""><div class="inner"><h3 class="title"><a id="note23"/>Note</h3><p>It's very important to know that, even if a dictionary is not intrinsically ordered, according to the Python documentation: "<span class="emphasis"><em>Keys and values are iterated over in an arbitrary order which is non-random, varies across Python implementations, and depends on the dictionary's history of insertions and deletions. If keys, values and items views are iterated over with no intervening modifications to the dictionary, the order of items will directly correspond.</em></span>"</p></div></div><p>Enough with this chatter, let's put all this down into code:</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong>&gt;&gt;&gt; d = dict(zip('hello', range(5)))</strong></span>
<span class="strong"><strong>&gt;&gt;&gt; d</strong></span>
<span class="strong"><strong>{'e': 1, 'h': 0, 'o': 4, 'l': 3}</strong></span>
<span class="strong"><strong>&gt;&gt;&gt; d.keys()</strong></span>
<span class="strong"><strong>dict_keys(['e', 'h', 'o', 'l'])</strong></span>
<span class="strong"><strong>&gt;&gt;&gt; d.values()</strong></span>
<span class="strong"><strong>dict_values([1, 0, 4, 3])</strong></span>
<span class="strong"><strong>&gt;&gt;&gt; d.items()</strong></span>
<span class="strong"><strong>dict_items([('e', 1), ('h', 0), ('o', 4), ('l', 3)])</strong></span>
<span class="strong"><strong>&gt;&gt;&gt; 3 in d.values()</strong></span>
<span class="strong"><strong>True</strong></span>
<span class="strong"><strong>&gt;&gt;&gt; ('o', 4) in d.items()</strong></span>
<span class="strong"><strong>True</strong></span>
</pre></div><p>A few things to notice in the preceding code. First, notice how we're creating a dictionary by iterating over the zipped version of the string <code class="literal">'hello'</code> and the list <code class="literal">[0, 1, 2, 3, 4]</code>. The string <code class="literal">'hello'</code> has two <code class="literal">'l'</code> characters inside, and they are paired up with the values 2 and 3 by the zip function. Notice how in the dictionary, the second occurrence of the <code class="literal">'l'</code> key (the one with value 3), overwrites the first one (the one with value 2). Another thing to notice is that when asking for any view, the original order is lost, but is consistent within the views, as expected. Notice also that you may have different results when you try this code on your machine. Python doesn't guarantee that, it only guarantees the consistency of the order in which the views are presented.</p><p>We'll see how<a id="id166" class="indexterm"/> these views are fundamental tools when we talk about iterating over collections. Let's take a look now at some other methods exposed by Python's dictionaries, there's plenty of them and they are very useful:</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong>&gt;&gt;&gt; d</strong></span>
<span class="strong"><strong>{'e': 1, 'h': 0, 'o': 4, 'l': 3}</strong></span>
<span class="strong"><strong>&gt;&gt;&gt; d.popitem()  # removes a random item</strong></span>
<span class="strong"><strong>('e', 1)</strong></span>
<span class="strong"><strong>&gt;&gt;&gt; d</strong></span>
<span class="strong"><strong>{'h': 0, 'o': 4, 'l': 3}</strong></span>
<span class="strong"><strong>&gt;&gt;&gt; d.pop('l')  # remove item with key `l`</strong></span>
<span class="strong"><strong>3</strong></span>
<span class="strong"><strong>&gt;&gt;&gt; d.pop('not-a-key')  # remove a key not in dictionary: KeyError</strong></span>
<span class="strong"><strong>Traceback (most recent call last):</strong></span>
<span class="strong"><strong>  File "&lt;stdin&gt;", line 1, in &lt;module&gt;</strong></span>
<span class="strong"><strong>KeyError: 'not-a-key'</strong></span>
<span class="strong"><strong>&gt;&gt;&gt; d.pop('not-a-key', 'default-value')  # with a default value?</strong></span>
<span class="strong"><strong>'default-value'  # we get the default value</strong></span>
<span class="strong"><strong>&gt;&gt;&gt; d.update({'another': 'value'})  # we can update dict this way</strong></span>
<span class="strong"><strong>&gt;&gt;&gt; d.update(a=13)  # or this way (like a function call)</strong></span>
<span class="strong"><strong>&gt;&gt;&gt; d</strong></span>
<span class="strong"><strong>{'a': 13, 'another': 'value', 'h': 0, 'o': 4}</strong></span>
<span class="strong"><strong>&gt;&gt;&gt; d.get('a')  # same as d['a'] but if key is missing no KeyError</strong></span>
<span class="strong"><strong>13</strong></span>
<span class="strong"><strong>&gt;&gt;&gt; d.get('a', 177)  # default value used if key is missing</strong></span>
<span class="strong"><strong>13</strong></span>
<span class="strong"><strong>&gt;&gt;&gt; d.get('b', 177)  # like in this case</strong></span>
<span class="strong"><strong>177</strong></span>
<span class="strong"><strong>&gt;&gt;&gt; d.get('b')  # key is not there, so None is returned</strong></span>
</pre></div><p>All these methods are quite simple to understand, but it's worth talking about that <code class="literal">None</code>, for a moment. Every function in Python returns <code class="literal">None</code>, unless the <code class="literal">return</code> statement is explicitly used, but we'll see this when we explore functions. <code class="literal">None</code> is frequently used to represent the absence of a value, as when default arguments are not passed to a function. Some inexperienced coders sometimes write code that returns either <code class="literal">False</code> or <code class="literal">None</code>. Both <code class="literal">False</code> and <code class="literal">None</code> evaluate to <code class="literal">False</code> so it may seem there is not much difference between them. But actually, I would argue there is quite an important difference: <code class="literal">False</code> means that we have information, and the information we have is <code class="literal">False</code>. <code class="literal">None</code> means <span class="emphasis"><em>no information</em></span>. And no information is very different from an information, which is <code class="literal">False</code>. In layman's terms, if you ask your mechanic "is my car ready?" there is a big difference between the answer "No, it's not" (<span class="emphasis"><em>False</em></span>) and "I have no idea" (<span class="emphasis"><em>None</em></span>).</p><p>One last <a id="id167" class="indexterm"/>method I really like of dictionaries is <code class="literal">setdefault</code>. It behaves like <code class="literal">get</code>, but also sets the key with the given value if it is not there. Let's see and example:</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong>&gt;&gt;&gt; d = {}</strong></span>
<span class="strong"><strong>&gt;&gt;&gt; d.setdefault('a', 1)  # 'a' is missing, we get default value</strong></span>
<span class="strong"><strong>1</strong></span>
<span class="strong"><strong>&gt;&gt;&gt; d</strong></span>
<span class="strong"><strong>{'a': 1}  # also, the key/value pair ('a', 1) has now been added</strong></span>
<span class="strong"><strong>&gt;&gt;&gt; d.setdefault('a', 5)  # let's try to override the value</strong></span>
<span class="strong"><strong>1</strong></span>
<span class="strong"><strong>&gt;&gt;&gt; d</strong></span>
<span class="strong"><strong>{'a': 1}  # didn't work, as expected</strong></span>
</pre></div><p>So, we're now at the end of this tour. Test your knowledge about dictionaries trying to foresee how <code class="literal">d</code> looks like after this line.</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong>&gt;&gt;&gt; d = {}</strong></span>
<span class="strong"><strong>&gt;&gt;&gt; d.setdefault('a', {}).setdefault('b', []).append(1)</strong></span>
</pre></div><p>It's not that complicated, but don't worry if you don't get it immediately. I just wanted to spur you to experiment with dictionaries.</p><p>This concludes our tour of built-in data types. Before I make some considerations about what we've seen in this chapter, I want to briefly take a peek at the <code class="literal">collections</code> module.</p></div>
<div class="section" title="The collections module"><div class="titlepage"><div><div><h1 class="title"><a id="ch02lvl1sec29"/>The collections module</h1></div></div></div><p>When <a id="id168" class="indexterm"/>Python general purpose built-in containers (<code class="literal">tuple</code>, <code class="literal">list</code>, <code class="literal">set</code>, and <code class="literal">dict</code>) aren't enough, we can find specialized container data types in<a id="id169" class="indexterm"/> the <code class="literal">collections</code> module. They are:</p><div class="informaltable"><table border="1"><colgroup><col style="text-align: left"/><col style="text-align: left"/></colgroup><thead><tr><th style="text-align: left" valign="bottom">
<p>Data type</p>
</th><th style="text-align: left" valign="bottom">
<p>Description</p>
</th></tr></thead><tbody><tr><td style="text-align: left" valign="top">
<p>
<code class="literal">namedtuple()</code>
</p>
</td><td style="text-align: left" valign="top">
<p>A factory function for creating tuple subclasses with named fields</p>
</td></tr><tr><td style="text-align: left" valign="top">
<p>
<code class="literal">deque</code>
</p>
</td><td style="text-align: left" valign="top">
<p>A <code class="literal">list</code>-like container with fast appends and pops on either end</p>
</td></tr><tr><td style="text-align: left" valign="top">
<p>
<code class="literal">ChainMap</code>
</p>
</td><td style="text-align: left" valign="top">
<p>A <code class="literal">dict</code>-like class for creating a single view of multiple mappings</p>
</td></tr><tr><td style="text-align: left" valign="top">
<p>
<code class="literal">Counter</code>
</p>
</td><td style="text-align: left" valign="top">
<p>A <code class="literal">dict</code> subclass for counting hashable objects</p>
</td></tr><tr><td style="text-align: left" valign="top">
<p>
<code class="literal">OrderedDict</code>
</p>
</td><td style="text-align: left" valign="top">
<p>A <code class="literal">dict</code> subclass that remembers the order entries were added</p>
</td></tr><tr><td style="text-align: left" valign="top">
<p>
<code class="literal">defaultdict</code>
</p>
</td><td style="text-align: left" valign="top">
<p>A <code class="literal">dict</code> subclass that calls a factory function to supply missing values</p>
</td></tr><tr><td style="text-align: left" valign="top">
<p>
<code class="literal">UserDict</code>
</p>
</td><td style="text-align: left" valign="top">
<p>A <a id="id170" class="indexterm"/>wrapper around dictionary objects for easier dict subclassing</p>
</td></tr><tr><td style="text-align: left" valign="top">
<p>
<code class="literal">UserList</code>
</p>
</td><td style="text-align: left" valign="top">
<p>A wrapper around list objects for easier list subclassing</p>
</td></tr><tr><td style="text-align: left" valign="top">
<p>
<code class="literal">UserString</code>
</p>
</td><td style="text-align: left" valign="top">
<p>A wrapper around string objects for easier string subclassing</p>
</td></tr></tbody></table></div><p>We don't have<a id="id171" class="indexterm"/> the room to cover all of them, but you can find plenty of examples in the official documentation, so here I'll just give a small example to show you <code class="literal">namedtuple</code>, <code class="literal">defaultdict</code>, and <code class="literal">ChainMap</code>.</p><div class="section" title="Named tuples"><div class="titlepage"><div><div><h2 class="title"><a id="ch02lvl2sec36"/>Named tuples</h2></div></div></div><p>A <code class="literal">namedtuple</code> is a <code class="literal">tuple</code>-like object that has fields accessible by attribute lookup as well as <a id="id172" class="indexterm"/>being indexable and iterable (it's actually a subclass of <code class="literal">tuple</code>). This is sort of a compromise between a full-fledged object and a tuple, and it can be useful in those cases where you don't need the full power of a custom object, but you want your code to be more readable by avoiding weird indexing. Another use case is when there is a chance that items in the tuple need to change their position after refactoring, forcing the coder to refactor also all the logic involved, which can be very tricky. As usual, an example is better than a thousand words (or was it a picture?). Say we are handling data about the left and right eye of a patient. We save one value for the left eye (position 0) and one for the right eye (position 1) in a regular tuple. Here's how that might be:</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong>&gt;&gt;&gt; vision = (9.5, 8.8)</strong></span>
<span class="strong"><strong>&gt;&gt;&gt; vision</strong></span>
<span class="strong"><strong>(9.5, 8.8)</strong></span>
<span class="strong"><strong>&gt;&gt;&gt; vision[0]  # left eye (implicit positional reference)</strong></span>
<span class="strong"><strong>9.5</strong></span>
<span class="strong"><strong>&gt;&gt;&gt; vision[1]  # right eye (implicit positional reference)</strong></span>
<span class="strong"><strong>8.8</strong></span>
</pre></div><p>Now let's pretend we handle <code class="literal">vision</code> object all the time, and at some point the designer decides to enhance them by adding information for the combined vision, so that a <code class="literal">vision</code> object stores data in this format: <span class="emphasis"><em>(left eye, combined, right eye)</em></span>.</p><p>Do you see the trouble we're in now? We may have a lot of code that depends on <code class="literal">vision[0]</code> being the left eye information (which still is) and <code class="literal">vision[1]</code> being the right eye information (which is no longer the case). We have to refactor our code wherever we handle these objects, changing <code class="literal">vision[1]</code> to <code class="literal">vision[2]</code>, and it can be painful. We could have probably approached this a bit better from the beginning, by using a <code class="literal">namedtuple</code>. Let me show you what I mean:</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong>&gt;&gt;&gt; from collections import namedtuple</strong></span>
<span class="strong"><strong>&gt;&gt;&gt; Vision = namedtuple('Vision', ['left', 'right'])</strong></span>
<span class="strong"><strong>&gt;&gt;&gt; vision = Vision(9.5, 8.8)</strong></span>
<span class="strong"><strong>&gt;&gt;&gt; vision[0]</strong></span>
<span class="strong"><strong>9.5</strong></span>
<span class="strong"><strong>&gt;&gt;&gt; vision.left  # same as vision[0], but explicit</strong></span>
<span class="strong"><strong>9.5</strong></span>
<span class="strong"><strong>&gt;&gt;&gt; vision.right  # same as vision[1], but explicit</strong></span>
<span class="strong"><strong>8.8</strong></span>
</pre></div><p>If within <a id="id173" class="indexterm"/>our code we refer to left and right eye using <code class="literal">vision.left</code> and <code class="literal">vision.right</code>, all we need to do to fix the new design issue is to change our factory and the way we create instances. The rest of the code won't need to change.</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong>&gt;&gt;&gt; Vision = namedtuple('Vision', ['left', 'combined', 'right'])</strong></span>
<span class="strong"><strong>&gt;&gt;&gt; vision = Vision(9.5, 9.2, 8.8)</strong></span>
<span class="strong"><strong>&gt;&gt;&gt; vision.left  # still perfect</strong></span>
<span class="strong"><strong>9.5</strong></span>
<span class="strong"><strong>&gt;&gt;&gt; vision.right  # still perfect (though now is vision[2])</strong></span>
<span class="strong"><strong>8.8</strong></span>
<span class="strong"><strong>&gt;&gt;&gt; vision.combined  # the new vision[1]</strong></span>
<span class="strong"><strong>9.2</strong></span>
</pre></div><p>You can see how convenient it is to refer to those values by name rather than by position. After all, a wise man once wrote "<span class="emphasis"><em>Explicit is better than implicit</em></span>" (can you recall where? Think <span class="emphasis"><em>zen</em></span> if you don't...). This example may be a little extreme, of course it's not likely that our code designer will go for a change like this, but you'd be amazed to see how frequently issues similar to this one happen in a professional environment, and how painful it is to refactor them.</p></div><div class="section" title="Defaultdict"><div class="titlepage"><div><div><h2 class="title"><a id="ch02lvl2sec37"/>Defaultdict</h2></div></div></div><p>The <code class="literal">defaultdict</code> data type is one of my favorites. It allows you to avoid checking if a key is in<a id="id174" class="indexterm"/> a dictionary by simply inserting it for you on your first access attempt, with a default value whose type you pass on creation. In some cases, this tool can be very handy and shorten your code a little. Let's see a quick example: say we are updating the value of <code class="literal">age</code>, by adding one year. If <code class="literal">age</code> is not there, we assume it was <code class="literal">0</code> and we update it to <code class="literal">1</code>.</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong>&gt;&gt;&gt; d = {}</strong></span>
<span class="strong"><strong>&gt;&gt;&gt; d['age'] = d.get('age', 0) + 1  # age not there, we get 0 + 1</strong></span>
<span class="strong"><strong>&gt;&gt;&gt; d</strong></span>
<span class="strong"><strong>{'age': 1}</strong></span>
<span class="strong"><strong>&gt;&gt;&gt; d = {'age': 39}</strong></span>
<span class="strong"><strong>&gt;&gt;&gt; d['age'] = d.get('age', 0) + 1  # d is there, we get 40</strong></span>
<span class="strong"><strong>&gt;&gt;&gt; d</strong></span>
<span class="strong"><strong>{'age': 40}</strong></span>
</pre></div><p>Now let's <a id="id175" class="indexterm"/>see how it would work with a <code class="literal">defaultdict</code> data type. The second line is actually the short version of a 4-lines long <code class="literal">if</code> clause that we would have to write if dictionaries didn't have the <code class="literal">get</code> method. We'll see all about <code class="literal">if</code> clauses in <a class="link" href="ch03.html" title="Chapter 3. Iterating and Making Decisions">Chapter 3</a>, <span class="emphasis"><em>Iterating and Making Decisions</em></span>.</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong>&gt;&gt;&gt; from collections import defaultdict</strong></span>
<span class="strong"><strong>&gt;&gt;&gt; dd = defaultdict(int)  # int is the default type (0 the value)</strong></span>
<span class="strong"><strong>&gt;&gt;&gt; dd['age'] += 1  # short for dd['age'] = dd['age'] + 1</strong></span>
<span class="strong"><strong>&gt;&gt;&gt; dd</strong></span>
<span class="strong"><strong>defaultdict(&lt;class 'int'&gt;, {'age': 1})  # 1, as expected</strong></span>
<span class="strong"><strong>&gt;&gt;&gt; dd['age'] = 39</strong></span>
<span class="strong"><strong>&gt;&gt;&gt; dd['age'] += 1</strong></span>
<span class="strong"><strong>&gt;&gt;&gt; dd</strong></span>
<span class="strong"><strong>defaultdict(&lt;class 'int'&gt;, {'age': 40})  # 40, as expected</strong></span>
</pre></div><p>Notice how we just need to instruct the <code class="literal">defaultdict</code> factory that we want an <code class="literal">int</code> number to be used in case the key is missing (we'll get <code class="literal">0</code>, which is the default for the <code class="literal">int</code> type). Also, notice that even though in this example there is no gain on the number of lines, there is definitely a gain in readability, which is very important. You can also use a different technique to instantiate a <code class="literal">defaultdict</code> data type, which involves creating a factory object. For digging deeper, please refer to the official documentation.</p></div><div class="section" title="ChainMap"><div class="titlepage"><div><div><h2 class="title"><a id="ch02lvl2sec38"/>ChainMap</h2></div></div></div><p>The <code class="literal">ChainMap</code> is <a id="id176" class="indexterm"/>an extremely nice data type which was introduced in Python 3.3. It behaves like a normal dictionary but according to the Python documentation: <span class="emphasis"><em>is provided for quickly linking a number of mappings so they can be treated as a single unit.</em></span> This is usually much faster than creating one dictionary and running multiple update calls on it. <code class="literal">ChainMap</code> can be used to simulate nested scopes and is useful in templating. The underlying mappings are stored in a list. That list is public and can be accessed or updated using the maps attribute. Lookups search the underlying mappings successively until a key is found. In contrast, writes, updates, and deletions only operate on the first mapping.</p><p>A very common use case is providing defaults, so let's see an example:</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong>&gt;&gt;&gt; from collections import ChainMap</strong></span>
<span class="strong"><strong>&gt;&gt;&gt; default_connection = {'host': 'localhost', 'port': 4567}</strong></span>
<span class="strong"><strong>&gt;&gt;&gt; connection = {'port': 5678}</strong></span>
<span class="strong"><strong>&gt;&gt;&gt; conn = ChainMap(connection, default_connection) # map creation</strong></span>
<span class="strong"><strong>&gt;&gt;&gt; conn['port']  # port is found in the first dictionary</strong></span>
<span class="strong"><strong>5678</strong></span>
<span class="strong"><strong>&gt;&gt;&gt; conn['host']  # host is fetched from the second dictionary</strong></span>
<span class="strong"><strong>'localhost'</strong></span>
<span class="strong"><strong>&gt;&gt;&gt; conn.maps  # we can see the mapping objects</strong></span>
<span class="strong"><strong>[{'port': 5678}, {'host': 'localhost', 'port': 4567}]</strong></span>
<span class="strong"><strong>&gt;&gt;&gt; conn['host'] = 'packtpub.com'  # let's add host</strong></span>
<span class="strong"><strong>&gt;&gt;&gt; conn.maps</strong></span>
<span class="strong"><strong>[{'host': 'packtpub.com', 'port': 5678},</strong></span>
<span class="strong"><strong> {'host': 'localhost', 'port': 4567}]</strong></span>
<span class="strong"><strong>&gt;&gt;&gt; del conn['port']  # let's remove the port information</strong></span>
<span class="strong"><strong>&gt;&gt;&gt; conn.maps</strong></span>
<span class="strong"><strong>[{'host': 'packtpub.com'},</strong></span>
<span class="strong"><strong> {'host': 'localhost', 'port': 4567}]</strong></span>
<span class="strong"><strong>&gt;&gt;&gt; conn['port']  # now port is fetched from the second dictionary</strong></span>
<span class="strong"><strong>4567</strong></span>
<span class="strong"><strong>&gt;&gt;&gt; dict(conn)  # easy to merge and convert to regular dictionary</strong></span>
<span class="strong"><strong>{'host': 'packtpub.com', 'port': 4567}</strong></span>
</pre></div><p>I just love<a id="id177" class="indexterm"/> how Python makes your life easy. You work on a <code class="literal">ChainMap</code> object, configure the first mapping as you want, and when you need a complete dictionary with all the defaults as well as the customized items, you just feed the <code class="literal">ChainMap</code> object to a <code class="literal">dict</code> constructor. If you have never coded in other languages, such as Java or C++, you probably won't be able to fully appreciate how precious this is, how Python makes your life so much easier. I do, I feel claustrophobic every time I have to code in some other language.</p></div></div>
<div class="section" title="Final considerations"><div class="titlepage"><div><div><h1 class="title"><a id="ch02lvl1sec30"/>Final considerations</h1></div></div></div><p>That's it. Now you have seen a very good portion of the data structures that you will use in Python. I encourage you to take a dive into the Python documentation and experiment further with each and every data type we've seen in this chapter. It's worth it, believe me. Everything you'll write will be about handling data, so make sure your knowledge about it is rock solid.</p><p>Before we leap into the next chapter, I'd like to make some final considerations about different aspects that to my mind are important and not to be neglected.</p><div class="section" title="Small values caching"><div class="titlepage"><div><div><h2 class="title"><a id="ch02lvl2sec39"/>Small values caching</h2></div></div></div><p>When we <a id="id178" class="indexterm"/>discussed objects at the beginning of this chapter, we saw that when we assigned a name to an object, Python creates the object, sets its value, and then points the name to it. We can assign different names to the same value and we expect different objects to be created, like this:</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong>&gt;&gt;&gt; a = 1000000</strong></span>
<span class="strong"><strong>&gt;&gt;&gt; b = 1000000</strong></span>
<span class="strong"><strong>&gt;&gt;&gt; id(a) == id(b)</strong></span>
<span class="strong"><strong>False</strong></span>
</pre></div><p>In the preceding example, <code class="literal">a</code> and <code class="literal">b</code> are assigned to two <code class="literal">int</code> objects, which have the same value but they are not the same object, as you can see, their <code class="literal">id</code> is not the same. So let's do it again:</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong>&gt;&gt;&gt; a = 5</strong></span>
<span class="strong"><strong>&gt;&gt;&gt; b = 5</strong></span>
<span class="strong"><strong>&gt;&gt;&gt; id(a) == id(b)</strong></span>
<span class="strong"><strong>True</strong></span>
</pre></div><p>Oh oh! Is<a id="id179" class="indexterm"/> Python broken? Why are the two objects the same now? We didn't do <code class="literal">a = b = 5</code>, we set them up separately. Well, the answer is performances. Python caches short strings and small numbers, to avoid having many copies of them clogging up the system memory. Everything is handled properly under the hood so you don't need to worry a bit, but make sure that you remember this behavior should your code ever need to fiddle with IDs.</p></div><div class="section" title="How to choose data structures"><div class="titlepage"><div><div><h2 class="title"><a id="ch02lvl2sec40"/>How to choose data structures</h2></div></div></div><p>As we've<a id="id180" class="indexterm"/> seen, Python provides you with several built-in data types and sometimes, if you're not that experienced, choosing the one that serves you best can be tricky, especially when it comes to collections. For example, say you have many dictionaries to store, each of which represents a customer. Within each customer dictionary there's an <code class="literal">'id': 'code'</code> unique identification code. In what kind of collection would you place them? Well, unless I know more about these customers, it's very hard to answer. What kind of access will I need? What sort of operations will I have to perform on each of them, and how many times? Will the collection change over time? Will I need to modify the customer dictionaries in any way? What is going to be the most frequent operation I will have to perform on the collection?</p><p>If you can answer the preceding questions, then you will know what to choose. If the collection never shrinks or grows (in other words, it won't need to add/delete any customer object after creation) or shuffles, then tuples are a possible choice. Otherwise lists are a good candidate. Every customer dictionary has a unique identifier though, so even a dictionary could work. Let me draft these options for you:</p><div class="informalexample"><pre class="programlisting"># example customer objects
customer1 = {'id': 'abc123', 'full_name': 'Master Yoda'}
customer2 = {'id': 'def456', 'full_name': 'Obi-Wan Kenobi'}
customer3 = {'id': 'ghi789', 'full_name': 'Anakin Skywalker'}
# collect them in a <span class="strong"><strong>tuple</strong></span>
customers = (customer1, customer2, customer3)
# or collect them in a <span class="strong"><strong>list</strong></span>
customers = [customer1, customer2, customer3]
# or maybe within a <span class="strong"><strong>dictionary</strong></span>, they have a unique id after all
customers = {
    'abc123': customer1,
    'def456': customer2,
    'ghi789': customer3,
}</pre></div><p>Some <a id="id181" class="indexterm"/>customers we have there, right? I probably wouldn't go with the tuple option, unless I wanted to highlight that the collection is not going to change. I'd say usually a list is better, it allows for more flexibility.</p><p>Another factor to keep in mind is that tuples and lists are ordered collections, while if you use a dictionary or a set you lose the ordering, so you need to know if ordering is important in your application.</p><p>What about performances? For example in a list, operations such as insertion and membership can take <span class="emphasis"><em>O(n)</em></span>, while they are <span class="emphasis"><em>O(1)</em></span> for a dictionary. It's not always possible to use dictionaries though, if we don't have the guarantee that we can uniquely identify each item of the collection by means of one of its properties, and that the property in question is hashable (so it can be a key in <code class="literal">dict</code>).</p><div class="note" title="Note" style=""><div class="inner"><h3 class="title"><a id="note24"/>Note</h3><p>If you're wondering what <span class="emphasis"><em>O(n)</em></span> and <span class="emphasis"><em>O(1)</em></span> mean, please Google "<span class="emphasis"><em>big O notation</em></span>" and get a gist of it from anywhere. In this context, let's just say that if performing an operation <span class="emphasis"><em>Op</em></span> on a data structure takes <span class="emphasis"><em>O(f(n))</em></span>, it would mean that <span class="emphasis"><em>Op</em></span> takes at most a time <span class="inlinemediaobject"><img src="graphics/4715_02_03.jpg" alt="How to choose data structures"/></span> to complete, where <span class="emphasis"><em>c</em></span> is some positive constant, <span class="emphasis"><em>n</em></span> is the size of the input, and <span class="emphasis"><em>f</em></span> is some function. So, think of <span class="emphasis"><em>O(...)</em></span> as an upper bound for the running time of an operation (it can be used also to size other measurable quantities, of course).</p></div></div><p>Another way of understanding if you have chosen the right data structure is by looking at the code you have to write in order to manipulate it. If everything comes easily and flows naturally, then you probably have chosen correctly, but if you find yourself thinking your code is getting unnecessarily complicated, then you probably should try and decide whether you need to reconsider your choices. It's quite hard to give advice without a practical case though, so when you choose a data structure for your data, try to keep ease of use and performance in mind and give precedence to what matters most in the context you are.</p></div><div class="section" title="About indexing and slicing"><div class="titlepage"><div><div><h2 class="title"><a id="ch02lvl2sec41"/>About indexing and slicing</h2></div></div></div><p>At the <a id="id182" class="indexterm"/>beginning<a id="id183" class="indexterm"/> of this chapter, we saw slicing applied on strings. Slicing in general applies to a sequence, so tuples, lists, strings, etc. With lists, slicing can also be used for assignment. I've almost never seen this used in professional code, but still, you know you can. Could you slice dictionaries or sets? I hear you scream "<span class="emphasis"><em>Of course not! They are not ordered!</em></span>". Excellent, I see we're on the same page here, so let's talk about indexing.</p><p>There is one characteristic about Python indexing I haven't mentioned before. I'll show you by example. How do you address the last element of a collection? Let's see:</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong>&gt;&gt;&gt; a = list(range(10))  # `a` has 10 elements. Last one is 9.</strong></span>
<span class="strong"><strong>&gt;&gt;&gt; a</strong></span>
<span class="strong"><strong>[0, 1, 2, 3, 4, 5, 6, 7, 8, 9]</strong></span>
<span class="strong"><strong>&gt;&gt;&gt; len(a)  # its length is 10 elements</strong></span>
<span class="strong"><strong>10</strong></span>
<span class="strong"><strong>&gt;&gt;&gt; a[len(a) - 1]  # position of last one is len(a) - 1</strong></span>
<span class="strong"><strong>9</strong></span>
<span class="strong"><strong>&gt;&gt;&gt; a[-1]  # but we don't need len(a)! Python rocks!</strong></span>
<span class="strong"><strong>9</strong></span>
<span class="strong"><strong>&gt;&gt;&gt; a[-2]  # equivalent to len(a) - 2</strong></span>
<span class="strong"><strong>8</strong></span>
<span class="strong"><strong>&gt;&gt;&gt; a[-3]  # equivalent to len(a) - 3</strong></span>
<span class="strong"><strong>7</strong></span>
</pre></div><p>If the list <code class="literal">a</code> has 10 elements, because of the <span class="emphasis"><em>0-index</em></span> positioning system of Python, the first one is at position 0 and the last one is at position 9. In the preceding example, the elements are conveniently placed in a position equal to their value: 0 is at position 0, 1 at position 1, and so on.</p><p>So, in order to fetch the last element, we need to know the length of the whole list (or tuple, or string, and so on) and then subtract 1. Hence: <code class="literal">len(a) – 1</code>. This is so common an operation that Python provides you with a way to retrieve elements using <span class="strong"><strong>negative</strong></span> <span class="strong"><strong>indexing</strong></span>. This proves<a id="id184" class="indexterm"/> very useful when you do some serious data manipulation. Here's a nice diagram about how indexing works on the string <code class="literal">"HelloThere"</code>:</p><div class="mediaobject"><img src="graphics/4715_02_02.jpg" alt="About indexing and slicing"/></div><p>Trying to <a id="id185" class="indexterm"/>address <a id="id186" class="indexterm"/>indexes greater than 9 or smaller than -10 will raise an <code class="literal">IndexError</code>, as expected.</p></div><div class="section" title="About the names"><div class="titlepage"><div><div><h2 class="title"><a id="ch02lvl2sec42"/>About the names</h2></div></div></div><p>You may <a id="id187" class="indexterm"/>have noticed that, in order to keep the example as short as possible, I have called many objects using simple letters, like <code class="literal">a</code>, <code class="literal">b</code>, <code class="literal">c</code>, <code class="literal">d</code>, and so on. This is perfectly ok when you debug on the console or when you show that <code class="literal">a + b == 7</code>, but it's bad practice when it comes to professional coding (or any type of coding, for all that matter). I hope you will indulge me if I sometimes do it, the reason is to present the code in a more compact way.</p><p>In a real environment though, when you choose names for your data, you should choose them carefully and they should reflect what the data is about. So, if you have a collection of <code class="literal">Customer</code> objects, <code class="literal">customers</code> is a perfectly good name for it. Would <code class="literal">customers_list</code>, <code class="literal">customers_tuple</code>, or <code class="literal">customers_collection</code> work as well? Think about it for a second. Is it good to tie the name of the collection to the data type? I don't think so, at least in most cases. So I'd say if you have an excellent reason to do so go ahead, otherwise don't. The reason is, once that <code class="literal">customers_tuple</code> starts being used in different places of your code, and you realize you actually want to use a list instead of a tuple, you're up for<a id="id188" class="indexterm"/> some fun refactoring (also known as <span class="strong"><strong>wasted time</strong></span>). Names for data should be nouns, and names for functions should be verbs. Names should be as expressive as possible. Python is actually a very good example when it comes to names. Most of the time you can just guess what a function is called if you know what it does. Crazy, huh?</p><p>
<a class="link" href="ch02.html" title="Chapter 2. Built-in Data Types">Chapter 2</a>, <span class="emphasis"><em>Meaningful Names</em></span> of <span class="emphasis"><em>Clean Code</em></span>, <span class="emphasis"><em>Robert C. Martin</em></span>, <span class="emphasis"><em>Prentice Hall</em></span> is entirely dedicated to names. It's an amazing book that helped me improve my coding style in many different ways, a must read if you want to take your coding to the next level.</p></div></div>
<div class="section" title="Summary"><div class="titlepage"><div><div><h1 class="title"><a id="ch02lvl1sec31"/>Summary</h1></div></div></div><p>In this chapter, we've explored the built-in data types of Python. We've seen how many they are and how much can be achieved by just using them in different combinations.</p><p>We've seen number types, sequences, sets, mappings, collections, we've seen that everything is an object, we've learned the difference between mutable and immutable, and we've also learned about slicing and indexing (and, proudly, negative indexing as well).</p><p>We've presented simple examples, but there's much more that you can learn about this subject, so stick your nose into the official documentation and explore.</p><p>Most of all, I encourage you to try out all the exercises by yourself, get your fingers using that code, build some muscle memory, and experiment, experiment, experiment. Learn what happens when you divide by zero, when you combine different number types into a single expression, when you manage strings. Play with all data types. Exercise them, break them, discover all their methods, enjoy them and learn them well, damn well.</p><p>If your foundation is not rock solid, how good can your code be? And data is the foundation for everything. Data shapes what dances around it.</p><p>The more you progress with the book, the more it's likely that you will find some discrepancies or maybe a small typo here and there in my code (or yours). You will get an error message, something will break. That's wonderful! When you code, things break all the time, you debug and fix all the time, so consider errors as useful exercises to learn something new about the language you're using, and not as failures or problems. Errors will keep coming up until your very last line of code, that's for sure, so you may as well start making your peace with them now.</p><p>The next chapter is about iterating and making decisions. We'll see how to actually put those collections in use, and take decisions based on the data we're presented with. We'll start to go a little faster now that your knowledge is building up, so make sure you're comfortable with the contents of this chapter before you move to the next one. Once more, have fun, explore, break things. It's a very good way to learn.</p></div></body></html>