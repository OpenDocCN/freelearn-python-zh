- en: Chapter 11. Extending the Master
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Even though some of the modules that we've written so far can be used on the
    Master, the focus has still been entirely on managing Minion-based operations.
    Even runners, which only run on the Master, were originally designed to script
    tasks between Minions.
  prefs: []
  type: TYPE_NORMAL
- en: 'There are two types of modules that are designed entirely for Master-side work:
    external authentication modules and wheel modules. In this chapter, we''ll go
    over:'
  prefs: []
  type: TYPE_NORMAL
- en: Adding external authentication to the Master
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Troubleshooting external authentication modules
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Managing Master configuration with wheel modules
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Troubleshooting wheel modules
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Using external authentication
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In its default setup, users only communicate with Salt with one user: usually
    either `root` or `salt`. Any user who has access to log in as that user will be
    able to issue Salt commands. This may be OK with smaller setups, but it does not
    scale well at all. Larger organizations will want each user to manage Salt with
    their own login, and be able to set access controls on a per-user basis. There
    are also other programs, including Salt API, which require the use of external
    authentication modules.'
  prefs: []
  type: TYPE_NORMAL
- en: '**External authentication** (or **auth or eauth**) modules allow individual
    users to have their own permissions to the various components of Salt. The simplest
    is probably the `pam` module, in part because other existing access control mechanisms
    can be configured inside PAM itself. Unfortunately, PAM is rarely used outside
    of Linux, so other modules are needed on other platforms.'
  prefs: []
  type: TYPE_NORMAL
- en: Authenticating credentials
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: On the surface, an auth module doesn't need to do much. It only needs to accept
    a username and password, and check with the appropriate service to ensure that
    it is valid. If it is, then it returns `True`. Otherwise, it will return `False`.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s go ahead and set up an auth module for a fictional web service that
    accepts a username and password, and returns a status of `200` (`OK`) if they
    are correct and `403` (`FORBIDDEN`) if they are not. As with some of the other
    module types, there is a required function in auth modules. This one is called
    `auth()`. Let''s go ahead and look at our entire auth module at once:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'Our function declaration has two required arguments: username and password.
    These will be sent to the authentication service to check their validity. Our
    service doesn''t just accept arbitrary credentials; it requires an account to
    be set up first, with its own authentication, which stores the username and password.
    So, our first job is to grab the credentials for that service (`apiid` and `apikey`)
    from the master configuration. Then add in the URL to be used for the authentication
    check:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: 'We want to be able to accept special characters in either the username or password,
    but since they won''t translate properly over the wire, we use Python''s `urllib`
    library to add quoting to them. Then we format the credentials in the way that
    the external web service expects:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: 'Now that we have all of the data set up to pass to the web service, we use
    the `http.query()` function to make the call. `apiid` and `apikey` are used as
    the username and password to the service itself, and the user''s username and
    password are set along as a JSON string. We also make sure to tell `http.query()`
    to return a status code, since that is the only part of the result that we care
    about:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: 'Once we have an authentication code, we check to see if it''s `200`. If something
    goes wrong and there is no code, then we default the value to `403`, but when
    it comes down to it, anything other than `200` means that the credentials will
    be considered invalid:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: Troubleshooting external authentication
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Troubleshooting `auth` modules is a little different from other types of module,
    because what you're testing is the ability to access a command, not the functionality
    of the resulting command. This means that the command that you choose to execute
    should be one that is already known to work, such as `test.ping`.
  prefs: []
  type: TYPE_NORMAL
- en: Setting auth parameters
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Before you can use an `auth` module, you need to enable it in the master configuration
    file. Multiple auth modules can be configured, using the `external_auth` directive:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: In this example, we have three users set, between two different `auth` modules.
    The `moe` and `larry` users are set to use the `pam` module, and the `shemp` user
    is set to use the `webauth` module that we just created. The `moe` user has access
    to all execution modules, plus the runner and wheel systems, while `larry`'s execution
    module access is limited to the `test`, `disk`, and `network` modules. The `shemp`
    user is the same as `larry`, minus access to the `disk` module.
  prefs: []
  type: TYPE_NORMAL
- en: Keep in mind that Salt API requires `@runner` and `@wheel` to be set. If you
    are not planning on giving users access to resources using Salt API, then you
    can skip those two lines.
  prefs: []
  type: TYPE_NORMAL
- en: 'Once you have `external_auth` configured, there are two means of testing `auth`
    modules: using the `salt` command on the Master, and using Salt API.'
  prefs: []
  type: TYPE_NORMAL
- en: Testing with the salt command
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'The fastest way to test an `auth` module is to log in to the Master with the
    account that the `salt-master` service is running as and issue a `salt` command,
    with the appropriate arguments to set which `auth` module is to be used, and which
    credentials to use:'
  prefs: []
  type: TYPE_NORMAL
- en: '`--auth` or `-a`: This argument sets which auth module to use. The default
    argument for this is `pam`.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`--username`: The username to authenticate with.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`--password`: The password to authenticate with.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Assuming that you''re testing with the `webauth` module that we just created,
    a basic `salt` command will look like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: Testing with Salt API
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: You can also test `auth` modules using Salt API. This can be easily accomplished
    using the `curl` command that is commonly available in Linux. Before you can test
    using this method, you need to configure Salt API inside the `master` configuration
    file.
  prefs: []
  type: TYPE_NORMAL
- en: 'Please note that the following configuration block is insecure, as it does
    not use SSL. Never set `disable_ssl` to `True` in production! As a safety measure,
    this configuration block also sets Salt API to only listen to requests from the
    local host:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: 'Once you have Salt API configured, go ahead and start the `salt-master` and
    `salt-api` services in the foreground (in two different windows):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: 'Use the following `curl` command to run the `test.ping` function:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: The most important arguments here are `eauth`, which is equivalent to the `--auth`
    parameter from the `salt` command, and `client`, which specifies which type of
    module to access. Here, we use `local`, which refers to execution modules. Some
    of the other available arguments are `runner` and `wheel`, for runner and wheel
    modules.
  prefs: []
  type: TYPE_NORMAL
- en: 'When you issue the preceding command with the correct credentials, you will
    receive a JSON string back with the result:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: 'If you issue it with bad credentials, you will receive an error page that includes
    the following text:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: 'If you look at the window with `salt-master` running in the foreground, you
    will see an error message like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: 'And if you look in the window running `salt-api`, you will see a message like
    this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: Managing the Master with the wheel modules
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The wheel system is designed to provide an API to the Master, which is accessible
    via programs that give external access to the Master, such as Salt API.
  prefs: []
  type: TYPE_NORMAL
- en: One of the first things that you'll find when writing wheel modules is that
    there is no command-line program available for testing wheel modules directly.
    Wheel modules generally include functionality that would be available via some
    other means, were you logged directly in to the Master, but are still useful when
    manual access is not an option.
  prefs: []
  type: TYPE_NORMAL
- en: For instance, possibly the most commonly used wheel module is key, which allows
    a programmatic way to manage Minion keys without using the key command. Because
    wheel modules are available to the reactor system, you can write reactor modules
    that can automatically accept or delete keys for Minions based on predefined conditions.
  prefs: []
  type: TYPE_NORMAL
- en: Wrapping a wheel around runners
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: For our example module, we'll put together a wheel module that returns a small
    amount of data concerning runner modules. This module is a simplified version
    of the runner functions inside the `sys` execution module. The reason these functions
    might be useful as a wheel module is that runners are designed to run on the Master,
    not Minions. If you do not run the `salt-minion` service on the Master, then you
    have no way to programmatically list available runner modules on the Master.
  prefs: []
  type: TYPE_NORMAL
- en: 'To start things off, we''ll create a function that does nothing more than list
    all of the functions available in the runner system:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: This function doesn't do a whole lot. It sets up a connection to the Runner
    system and assigns it to a `run_ object`. Then it returns a sorted list of all
    of the runner functions available on the Master.
  prefs: []
  type: TYPE_NORMAL
- en: 'To test this, we''ll need Salt API configured, just like we did in the *Troubleshooting
    external authentication* section. Then we issue a command that sets `client` to
    use the `wheel` system:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: 'On a Master that only has the manage module available, we would get a JSON
    string back that looks like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: 'Let''s go ahead and build on that a little bit and add a runner-specific version
    of the `sys.doc` function in the execution modules:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: Once again, this function sets up a connection to the Runner system, and assigns
    it to the `run_` object. It then iterates through the functions inside the `run_`
    object, extracting the docstrings that live inside the `__doc__` attribute. Each
    docstring is added to a `docs` dictionary, which is passed through a function
    in Salt called `_strip_rst()`, which cleans things up a little bit.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s finish things up with a function that lists just the runner modules
    available, but no other information about them such as docstrings or even function
    names:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: This function expands upon the `list_runners()` function by stripping out function
    names and adding the resulting module names to a set called `runners`. As before,
    a sorted copy of that set is returned.
  prefs: []
  type: TYPE_NORMAL
- en: The final wheel module
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'With all of our functions put together, we will end up with a cohesive module
    that looks like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: Troubleshooting wheel modules
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Once again, wheel modules are a little special when it comes to troubleshooting,
    because there is no specific command-line program in Salt that executes them directly.
    Unlike `auth` modules, they can't even be tested using the `salt` command.
  prefs: []
  type: TYPE_NORMAL
- en: 'However, as you have just seen, they can be tested using Salt API and `curl`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: You can also test wheel modules using the event system in Salt. It is good to
    get used to testing this way, since wheel modules are so useful inside reactor
    modules.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s go ahead and set up a reactor that deletes a Minion''s key from the
    Master:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: 'Then add that reactor to the `master` configuration file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: 'Go ahead and create a bad Minion key on the Master:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: 'After restarting the Master, go ahead and issue a command to trigger the reactor:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: 'Once you issue this command, you can use the `salt-key` command to make sure
    that the Minion''s bad key is no longer there:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: 'Or for bonus points, why not use Salt API to make sure that Minion''s key is
    gone?:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: Don't be fooled by the fact that `success` is set to `true`; the important value
    here is `return`, which is an empty dictionary.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: External authentication (or auth) modules allow an external authentication system
    to validate user credentials on the Master. This can be used for authenticating
    a user locally, but it is required for using external systems that connect to
    Salt.
  prefs: []
  type: TYPE_NORMAL
- en: Wheel modules allow API access to Master-side functionality. The functions contained
    in a wheel module generally allow the management of features that are normally
    available via some other means on the Master locally, but not other means from
    an external endpoint outside the Master. However, wheel modules can contain any
    Master-side management that you deem necessary.
  prefs: []
  type: TYPE_NORMAL
- en: Congratulations! You made it all the way through Extending SaltStack! We've
    included a couple of appendices to give you some general development guidelines
    and some information about contributing to the community.
  prefs: []
  type: TYPE_NORMAL
- en: As you can see, there is a world of Salt development to explore. More modules
    are added regularly, and occasionally new types of modules will appear as well.
    While we haven't covered everything there is or will be, you now have a solid
    foundation that you can use to tackle new Salt code as you come across it. Good
    luck out there; I hope you win!
  prefs: []
  type: TYPE_NORMAL
- en: Appendix A. Connecting Different Modules
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: When building an infrastructure, it is helpful to understand how each of the
    module types fits together. This includes both how they fit together inside of
    Salt and how you are able to use those connections to build your own solutions.
  prefs: []
  type: TYPE_NORMAL
- en: Separating Master and Minion functionality
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'It''s easy to think of Salt in terms of the following: the Master sends commands
    to the Minions, the Minions do the work, and then the Minions send the results
    back to the Master. However, the Master and the Minion are two distinct components
    that work together in harmony to complete their respective tasks.'
  prefs: []
  type: TYPE_NORMAL
- en: It is important to keep in mind that when the Minion is running in a Masterless
    mode (using `salt-call --local`), it behaves as its own Master, and outside of
    a few specific features (such as `salt-key` and runners that make use of `local_client`),
    any feature that is available on the Master is also available on the Minion, using
    the same configuration options that would appear in the `master` file, but in
    the `minion` file instead.
  prefs: []
  type: TYPE_NORMAL
- en: But when running with a Master and one or more Minions, they are two distinct
    entities. Some module types are available to either the Master or the Minion;
    there are many more that are only available for that specific service.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let us have a look at a diagrammatic representation of the Salt Master topology:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Separating Master and Minion functionality](img/00002.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: 'And now follows the diagrammatic representation of the Salt Minion topology:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Separating Master and Minion functionality](img/00003.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: Like the Master and the Minion, each module type is specific and distinct. However,
    like the Master and the Minion, modules connect to each other and work in concert
    to accomplish larger workflows. Regardless of module type, the Master and the
    Minion will always communicate directly (using transport modules, which are beyond
    the scope of this book). Beyond that, different modules are able to communicate
    with each other to varying degrees.
  prefs: []
  type: TYPE_NORMAL
- en: The Master generally uses its own modules directly. Some of those modules may
    be used to provide Minions with resources (such as file server modules), but a
    number of them are used entirely for providing resources to the Master itself.
    Master returners are functionally identical to returners that execute on the Minion,
    with the exception of how they get their data.
  prefs: []
  type: TYPE_NORMAL
- en: Minion modules communicate with each other extensively. Execution modules can
    pull data from grain and SDB modules (and from pillars, through the Master) and
    cross-call each other. State modules are themselves called from an execution module,
    but also have access to cross-callback to execution modules. Renderers are used
    by a number of different module types, and when all is said and done, returners
    transport return data to the correct destination.
  prefs: []
  type: TYPE_NORMAL
- en: Salt Cloud is the odd man out, because while it can be accessed via either a
    runner or an execution module, it can also be accessed directly, and even used
    independently of the rest of Salt. In fact, it can be used to manage nodes without
    even installing Salt on them.
  prefs: []
  type: TYPE_NORMAL
- en: Working with dunders
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'For those of you not in the know, *dunder* refers to a variable that is preceded
    and succeeded by two underscores. For instance, one of the most common dunders
    in Salt is `__opts__`, which contains the configuration for either the Master
    or the Minion, depending on the context. There are a number of dunders that work
    together to form the glue that ties all of Salt together. Let''s take a look at
    them in turn:'
  prefs: []
  type: TYPE_NORMAL
- en: '`__opts__`: On a Master, the `__opts__` dictionary contains a composite of
    the information located in the Master''s configuration files (normally `/etc/salt/master`
    plus files located in the `/etc/salt/master.d/` directory), along with the default
    values for configuration parameters not specified, plus any internal configuration
    that Salt generates for its own use at runtime.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: On a Minion, `__opts__` contains the same sort of information (but from the
    `/etc/salt/minion` file and the `/etc/salt/minion.d/` directory), when it is connected
    to the Master. However, when the Minion is used in a Masterless mode (such as
    when called from `salt-call --local`), any defaults are filled in as if it were
    a Master, rather than a Minion. This is because lookups such as pillars and files
    need to be provided from a Master of some sort, and in this capacity the Minion
    needs to play that role.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '`__salt__`: In modules that run on the Minions (most notably execution and
    state modules), `__salt__` contains a list of function calls to all of the available
    execution modules on the system. These items can be called directly, as if they
    were functions inside the calling module itself. For example:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Using a function in this way is referred to as *cross-calling*. Because it calls
    out to execution modules, which are only available as a Minion, the Master does
    not make use of cross-calling.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '`__grains__`: Another Minion-only dunder is the `__grains__` dictionary, which
    contains a copy of all of the grains computed for the Minion. This is used extensively
    throughout Salt to help Minions auto-detect what kinds of resources are available.
    It is possible to start `salt-call` without detecting grains by passing the `--skip-grains`
    flag, like this:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: You will notice that if you try this, the Minion responds much more quickly.
    But if you try to use any modules much more advanced than `test`, you will quickly
    find out how important grains are to the functionality of the Minion.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '`__pillar__`: Pillars have their own dunder dictionary as well, whose name
    is strangely singular (`__pillar__` instead of `__pillars__`). Unlike grains,
    which are generated by the Minion, pillars are generated by the Master. However,
    if you run `salt-call` in `--local` mode like this, you will discover that as
    `__opts__` now contains Master-side configuration, pillar configuration that would
    normally live on the Master will now be accepted by the Minion:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: This is incredibly useful for writing and debugging pillar modules, since you
    don't run the risk of contaminating other Minions with bad pillar data.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`__context__`: This dictionary is available both to state and execution modules.
    When Salt fires up the first execution module (which will be the `state` module
    on a state run), it creates the `__context__` dictionary. All of the information
    entered into this dictionary will persist across each subsequent module, so that
    different modules have a means of storing information for later use by another
    module. Once the final module has finished, the `__context__` dictionary will
    be destroyed.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Make sure that if you decide to use `__context__`, you check for the existence
    of keys in it before trying to set or use them. This is because you really have
    no way of knowing beforehand which order somebody will use modules in, so you
    shouldn't assume that things have or have not been populated.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'For more information about Salt dunders, check out:'
  prefs: []
  type: TYPE_NORMAL
- en: '[https://docs.saltstack.com/en/latest/topics/development/dunder_dictionaries.html](https://docs.saltstack.com/en/latest/topics/development/dunder_dictionaries.html)'
  prefs: []
  type: TYPE_NORMAL
- en: Using the event bus
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The event bus does not appear in the topology drawings because it is available
    anywhere inside of Salt, just by importing the `salt.event` library. It also has
    the ability to call out to other module types, using the reactor system. Reactors
    have access to execution, state, and runner modules.
  prefs: []
  type: TYPE_NORMAL
- en: Tip
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: You may be wondering why we didn't cover reactor modules in this book. In truth,
    there is no such thing as a reactor module. Reactors are written using standard
    SLS files, which can include extra functionality using the renderer system. For
    more thorough discussions on writing and using reactors, be sure to check out
    *Mastering SaltStack*, *Joseph Hall*, *Packt Publishing*.
  prefs: []
  type: TYPE_NORMAL
- en: Because the event bus is so ubiquitous, it can be a very powerful tool for tying
    together the other module types into a cohesive workflow.
  prefs: []
  type: TYPE_NORMAL
- en: For example, let's take a look at Salt Cloud. It can be operated independently
    from the rest of Salt, but when using a Master + Minions setup, it will fire events
    to the Master during the creation and deletion process that can be picked up by
    reactors.
  prefs: []
  type: TYPE_NORMAL
- en: 'Salt Cloud events use tags that are namespaced in a way that can be easily
    determined by reactors:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: 'Available events vary depending on the cloud provider, and the work that provider
    has been configured to do, but a properly written cloud driver will always fire
    at least these two events when creating a node:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: 'It will also fire these two events when deleting a node:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: 'Operations that perform maintenance on Minions and their resources can be kicked
    off using these events. For instance, if you want to sync a Minion''s resources
    as soon as it''s created, you can use a reactor that looks like:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: Because a Minion will be available by the time Salt Cloud sends the `salt/cloud/<minion_id>/created`
    tag, you can set a reactor to ensure that the Minion is synced as soon as it comes
    online, without having to configure any `startup_states`.
  prefs: []
  type: TYPE_NORMAL
- en: Firing events
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'You can fire events both from the Minion-side modules (such as execution and
    state modules) and Master-side modules (such as runners). From a Minion-side module,
    you need nothing more than to call out to the event execution module as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs: []
  type: TYPE_PRE
- en: 'But in Master-side modules, you need to do a little more work, since `__salt__`
    isn''t available. You need to import `salt.utils.event`, then use it to fire the
    event. This isn''t much more work, but you do have to do some setup. It looks
    like:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs: []
  type: TYPE_PRE
- en: Let's go over what happened here. First, we set up our imports. The `salt.syspaths`
    library contains information about where standard files and directories will be
    located on this system. In our case, we need to connect to a socket called `master`.
    We use this information to set up a variable called `sock_dir`, which tells Salt
    where to find the event bus to connect to.
  prefs: []
  type: TYPE_NORMAL
- en: We also find out which transport mechanism is configured for this system. This
    will usually be `zeromq`, but it can also be another protocol such as `raet` or
    `tcp`. Then we set up an object using the `get_event()` function. The first argument
    says which bus we're dealing with, then the `sock_dir`, transport, and finally
    we say that we're not going to be listening for events' we'll be sending them.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: What do we mean by *which bus we're dealing with*? Both the Master and the Minion
    have their own event bus. A Minion can either fire a message to itself using the
    `minion` bus, or to the Master using the `master` bus. The Minion event bus is
    rarely used except by the internal Salt code, but the Master bus is used extensively.
  prefs: []
  type: TYPE_NORMAL
- en: 'Once we have the event object set up, we can fire the event. The data (which
    can be a list or a dictionary) is specified first, and then the event tag. If
    you like, you can set up a listener on the Master to see those events come in:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs: []
  type: TYPE_PRE
- en: One of the most useful things that events are used in is reactors. As mentioned
    earlier, for more information on writing reactors, check out *Mastering SaltStack*,
    *Joseph Hal* *l*, *Packt Publishing*.
  prefs: []
  type: TYPE_NORMAL
- en: Appendix B. Contributing Code Upstream
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: A number of users have commented over the years that Salt has a low barrier
    to entry for new developers. This can be attributed in part both to the friendly
    and professional community, and the tools that are used to manage the Salt code
    base.
  prefs: []
  type: TYPE_NORMAL
- en: How the community works
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The Salt community comprises users and developers from all over the globe. The
    vast majority of these people are professionals who use Salt in a business environment,
    though some hobbyists have found their place among the ranks too.
  prefs: []
  type: TYPE_NORMAL
- en: When most people make their way to the community, they are looking for help
    and information about a particular situation that they are working with. This
    may be as minor as looking for examples or documentation, or it could be more
    serious, such as reporting what appears to be a bug in the software.
  prefs: []
  type: TYPE_NORMAL
- en: Once people have spent some time in the community, they often stick around to
    help out other users. Remember that while some of them may be experts with Salt
    and the various pieces of technology that it manages, they are still just users
    like you, who are contributing their own time to help out people like you.
  prefs: []
  type: TYPE_NORMAL
- en: Asking questions and reporting issues
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'There are three primary places where the Salt community gets together to discuss
    the software and help each other out: the mailing list, the IRC chat room, and
    the issue tracker on GitHub.'
  prefs: []
  type: TYPE_NORMAL
- en: 'There are three types of messages that you will generally find in these places:
    questions about the software, bug reports, and feature requests. In general, questions
    about the software should be asked either on the mailing list or in IRC. Bug reports
    and feature requests are better suited to the issue tracker.'
  prefs: []
  type: TYPE_NORMAL
- en: Using the mailing list
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The salt-users mailing list is a very active discussion environment, hosted
    on Google Groups. The mailing list can be found at:'
  prefs: []
  type: TYPE_NORMAL
- en: '[https://groups.google.com/d/forum/salt-users](https://groups.google.com/d/forum/salt-users)'
  prefs: []
  type: TYPE_NORMAL
- en: You can browse the mailing list at the preceding link, or you can set up an
    e-mail subscription and get messages sent to your inbox, where you can reply to
    them. There are, typically, a good dozen or so e-mails a day, so if that sounds
    like too many, then maybe just looking online is the way to go.
  prefs: []
  type: TYPE_NORMAL
- en: 'If you''re going to post a question, there are a few guidelines that will help
    you out:'
  prefs: []
  type: TYPE_NORMAL
- en: When you ask a question, try to post enough information about your problem so
    that people will be able help you out. In the past, people have asked how to fix
    a particular problem without stating what the problem actually is, or in some
    cases, even the part of Salt that the question pertains to. As you can imagine,
    this isn't helpful to anybody.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Describe what you're trying to do, and what you expect to happen. If something
    isn't working the way that you expect, make sure to state what is actually happening.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: You may need to post the output from a command in order to explain what is happening.
    If this is the case, make sure to post the actual command that you're running,
    and the relevant part of the output. If you issue a command that results in dozens
    of lines of logging output, but the actual error only takes up five lines, then
    just post those five lines to start with. If somebody asks for more, then go ahead
    and post more.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Tip
  prefs:
  - PREF_IND
  - PREF_H3
  type: TYPE_NORMAL
- en: Be careful when posting logs and configuration files! All too often, people
    will accidentally post an API key, password, or private network information without
    meaning to. Before pasting any information at a place online, where somebody can
    see it, make sure to remove any sensitive information. Making sure not to post
    long log messages will make this a lot easier.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'It is also helpful to know which version of Salt you are running. It is likely
    that your particular experience is unique to a specific version of Salt. Rather
    than just saying which version of Salt, it is often more helpful to give the output
    of the following command:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE37]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'If you are working with Salt Cloud, then make sure to get that report instead,
    using:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE38]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Because Salt Cloud uses a different set of libraries, using its `versions` report
    will give more information that may be useful, in addition to all of the version
    information for Salt itself.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: If you happen to find the resolution for your situation from outside the mailing
    list, it is also a good idea to reply to your own thread with a copy of the solution.
    The mailing list is archived on Google's servers, and if somebody else with your
    issue searches for it, they will appreciate seeing the solution. Believe me, few
    things are more frustrating than finding a dozen different people asking the same
    question on a dozen different mailing lists, with either no solution or a message
    from the original person saying, "Hey, I figured it out," and leaving it at that.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Using IRC
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'IRC, or Internet relay chat, is a type of chat room that''s been around for
    a very long time. If you already have an IRC client, you can connect to the Freenode
    server at:'
  prefs: []
  type: TYPE_NORMAL
- en: '[irc.freenode.com](http://irc.freenode.com)'
  prefs: []
  type: TYPE_NORMAL
- en: 'And then join the Salt chat room at:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE39]'
  prefs: []
  type: TYPE_PRE
- en: 'If you don''t have an IRC client yet, you might want to consider Pidgin, which
    is a chat client that supports a number of chat protocols. It''s not the most
    popular IRC client by any means, but it''s easy to use and available for Windows,
    Mac, and Linux. You can download it at:'
  prefs: []
  type: TYPE_NORMAL
- en: '[https://www.pidgin.im/](https://www.pidgin.im/)'
  prefs: []
  type: TYPE_NORMAL
- en: 'If you don''t want to commit to an IRC client, Freenode does have a web-based
    IRC client that you can use to connect to Salt''s chat room. You can find this
    client at:'
  prefs: []
  type: TYPE_NORMAL
- en: '[https://webchat.freenode.net/](https://webchat.freenode.net/)'
  prefs: []
  type: TYPE_NORMAL
- en: 'When you connect to Salt''s chat room, there are a few things that will be
    useful to know:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Be patient.** There are hundreds of people logged in to the Salt chat room
    at any given time, but not all of them are actively participating. It is very
    common for people to log in to an IRC room while at work, and check it periodically
    throughout the day. When you ask a question, don''t expect an immediate answer.
    Somebody may be watching at that moment and try to help you, but it may take an
    hour for the right person to see your question and jump in to try to answer it.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Be ready to provide information as necessary.** The kind person who offers
    to help you may ask for log messages or code snippets, or may ask you to try a
    few different commands, and post the response.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'You may want to look into getting an account on a text-sharing service. One
    such popular service is PasteBin:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[http://pastebin.com/](http://pastebin.com/)'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'However, you might also want to look into using GitHub''s gist service:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[https://gist.github.com/](https://gist.github.com/)'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: This has become an increasingly popular way to share logs and code snippets
    as with PasteBin, but with the kind of revision management that Git is known for.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '**Post solutions.** As with the mailing list, conversations in the Salt chat
    room are archived. You can find them at:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[https://irclog.perlgeek.de/salt/](https://irclog.perlgeek.de/salt/)'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: If you find the solution as you are working on the problem, and it's not obvious
    by looking at the conversation what it is, make sure to post it in the chat room
    so that others can find it later.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Using the issue tracker
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'When you come across a situation that you know is a bug, or you have a feature
    request, the Salt issue tracker on GitHub is the way to go. You can find it at:'
  prefs: []
  type: TYPE_NORMAL
- en: '[https://github.com/saltstack/salt/issues](https://github.com/saltstack/salt/issues)'
  prefs: []
  type: TYPE_NORMAL
- en: You may come across a situation where you don't know whether your problem is
    the result of inexperience, or an actual bug. If you're not sure, go ahead and
    post it on the mailing list. If it is a bug, then you will probably be asked to
    file an issue in the issue tracker, assuming somebody else hasn't already filed
    the same issue.
  prefs: []
  type: TYPE_NORMAL
- en: 'One of the advantages of filing an issue in the issue tracker is that you are
    automatically subscribed to updates for that issue. That means that when others
    post questions and comments on the issue, you will receive an e-mail with a copy
    of their response. If somebody else posted the issue, then you can still subscribe
    to it. Just look for the **Subscribe** button on the right-hand side of the issue
    page:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Using the issue tracker](img/00004.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: Once you hit that button, it will change to say **Unsubscribe**. If you ever
    get tired of receiving updates for that issue (even if you created it), then you
    can unsubscribe from it. But if you've left comments, I would encourage you to
    remain subscribed, in case anybody wants to ask you further questions down the
    road.
  prefs: []
  type: TYPE_NORMAL
- en: Once again, make sure to post any relevant information, exactly as you would
    on the mailing list. Detailed information about the issue, version reports, and
    code snippets are all helpful. A very recent addition to the Salt issue tracker
    is the use of templates, which provide reminders as to which information to give.
  prefs: []
  type: TYPE_NORMAL
- en: Using GitHub markdown
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'One incredibly helpful feature in GitHub is the ability to use markdown. You
    can find a helpful guide to markdown at:'
  prefs: []
  type: TYPE_NORMAL
- en: '[https://guides.github.com/features/mastering-markdown/](https://guides.github.com/features/mastering-markdown/)'
  prefs: []
  type: TYPE_NORMAL
- en: 'By far the most useful markdown syntax to know is how to mark out code blocks.
    The character used to mark out code is commonly known as the backtick, also known
    as the grave accent. On an American QWERTY keyboard, this key is located in the
    top-left position:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Using GitHub markdown](img/00005.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: When you place a single backtick in front of a piece of text and another at
    the end, then the text will be formatted as a piece of code. If you need to format
    multiple lines, then start with three backticks together on the first line, and
    three more together on the last line. Blocking out code this way helps immensely
    with readability.
  prefs: []
  type: TYPE_NORMAL
- en: '![Using GitHub markdown](img/00006.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: Understanding the Salt Style Guide
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'If you''ve spent enough time in Python, then you''re already familiar with
    the Style Guide for Python Code, also known as PEP 8\. For those who have not
    seen it, or if you need a refresher, you can take a look at it here:'
  prefs: []
  type: TYPE_NORMAL
- en: '[https://www.python.org/dev/peps/pep-0008/](https://www.python.org/dev/peps/pep-0008/)'
  prefs: []
  type: TYPE_NORMAL
- en: 'There is also a guide to the Salt Coding Style, available at:'
  prefs: []
  type: TYPE_NORMAL
- en: '[https://docs.saltstack.com/en/latest/topics/development/conventions/style.html](https://docs.saltstack.com/en/latest/topics/development/conventions/style.html)'
  prefs: []
  type: TYPE_NORMAL
- en: 'In general, Salt coding conventions follow PEP 8, but there are some key differences:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Quoting:** One of the first conventions that new developers come across is
    that Salt uses single quotes ('') instead of double quotes ("). This applies to
    everything from string formatting to docstrings.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Line length:** It is very common for code to restrict lines to no longer
    than 80 characters. This seems to be especially adhered to in Python, but it is
    based on an older convention where computer screens were exactly 80 characters
    wide. Because this is no longer the case, it is considered acceptable in Salt
    to expand to 120 characters, particularly if it helps with readability.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Tabs versus spaces:** Salt uses four spaces for indentation. No tabs. No
    exceptions.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Using Pylint
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Salt makes extensive use of a program called **Pylint** to ensure that its
    code adheres to its style guide. You can find information about installing Pylint
    at:'
  prefs: []
  type: TYPE_NORMAL
- en: '[http://www.pylint.org/](http://www.pylint.org/)'
  prefs: []
  type: TYPE_NORMAL
- en: Keep in mind that Salt currently uses Python 2 (the minimum version being 2.6),
    so if you're working in a distribution where both Python 2 and 3 versions of Pylint
    are available, make sure you use the Python 2 version.
  prefs: []
  type: TYPE_NORMAL
- en: 'The Salt code base ships with a `.pylintrc` file to be used with Pylint. It
    doesn''t get used by default, so you need to make sure to point it out to Pylint:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE40]'
  prefs: []
  type: TYPE_PRE
- en: Not only will this file allow you to check your code against Salt style guidelines
    but also to check the entire code base at once. This is important, because the
    loader inserts variables into modules that wouldn't be picked up otherwise by
    Pylint.
  prefs: []
  type: TYPE_NORMAL
- en: Creating pull requests on GitHub
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Whereas many project communities accept code only through mailing lists or
    complex websites, Salt has opted to stick with pull requests for accepting code
    contributions. A list of active pull requests can be found at:'
  prefs: []
  type: TYPE_NORMAL
- en: '[https://github.com/saltstack/salt/pulls](https://github.com/saltstack/salt/pulls)'
  prefs: []
  type: TYPE_NORMAL
- en: The complete details of using Git are way beyond the scope of this book, but
    it is worth going over the steps to clone the Salt repository and put in a new
    pull request.
  prefs: []
  type: TYPE_NORMAL
- en: 'First, you will need your own fork of Salt on GitHub. If you don''t have one
    yet, then use the **Fork** button at Salt''s own GitHub page:'
  prefs: []
  type: TYPE_NORMAL
- en: '[https://github.com/saltstack/salt](https://github.com/saltstack/salt)'
  prefs: []
  type: TYPE_NORMAL
- en: 'Assuming that your GitHub username is *mygithubuser*, your new fork will appear
    at:'
  prefs: []
  type: TYPE_NORMAL
- en: '`https://github.com/mygithubuser/salt`'
  prefs: []
  type: TYPE_NORMAL
- en: 'Once you have a fork set up, you''ll need to clone a copy to your computer.
    The following steps assume that you work in a command-line environment, such as
    Linux:'
  prefs: []
  type: TYPE_NORMAL
- en: 'If you have an SSH key set up, you can clone using SSH:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE41]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Otherwise, you''ll need to clone over HTTPS:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE42]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'You will also need to add the original SaltStack repository to your local clone,
    to be able to create pull requests:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE43]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'The default Git branch is `develop`. If you''re adding a new feature to Salt,
    the work should be performed on a branch based on `develop`. To create a new branch
    called `newfeature` and switch to it, use:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE44]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'When you are ready to put in a pull request, it is best to rebase your branch
    to make sure it doesn''t conflict with any other pull requests that have been
    merged since your last update:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE45]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Note
  prefs:
  - PREF_IND
  - PREF_H3
  type: TYPE_NORMAL
- en: 'For more information on using rebase, check out:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[https://help.github.com/articles/using-git-rebase/](https://help.github.com/articles/using-git-rebase/)'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Once you have rebased, go ahead and push your branch up to GitHub:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE46]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: When you visit your fork on GitHub again, you will see a link that says **New
    Pull Request**. From there, you can look at the diff readout between your branch
    and the current version of the `develop` branch on GitHub, and create your pull
    request when you're satisfied with it.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: As with issue submission, pull requests now also have a template to use as a
    guide to provide useful information about describing the changes that your pull
    request includes.
  prefs: []
  type: TYPE_NORMAL
- en: Using other branches
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'If you''re submitting bug fixes, then it may be more appropriate to submit
    them against a branch that matches a specific version of Salt. If you know which
    version of Salt the bug was first found in, then use that branch. The exception
    would be if the branch in question is so old that it is no longer being maintained.
    If that is the case, then choose the oldest branch that is being maintained. For
    instance, if the oldest maintained version is `2015.8.x`, then check out the `2015.8`
    branch:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE47]'
  prefs: []
  type: TYPE_PRE
- en: Understanding test errors in pull requests
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'When you submit a new pull request, GitHub will trigger the test suite to run
    against it. This will take several minutes, as it needs to create a new virtual
    machine, and start a lint test using Pylint, as well as tests on popular platforms
    such as CentOS and Ubuntu:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Understanding test errors in pull requests](img/00007.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: 'As the tests are running, you can check progress by clicking the **Details**
    button on the right:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Understanding test errors in pull requests](img/00008.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: Click on one of the tests to see more information. You will see output such
    as error messages, stacktraces, and standard output and standard error output.
  prefs: []
  type: TYPE_NORMAL
- en: There is a chance that one or more of the test failures that show up in your
    pull request are not actually your fault. It could be that another pull request
    was merged, which caused unforeseen issues on the build server. If the errors
    that show up don't look to be related to your code, leave a comment to ask about
    it. One of the core developers at SaltStack will see it and help you out.
  prefs: []
  type: TYPE_NORMAL
- en: 'Lint errors look a little different. When you look at the details for a lint
    test, you will see a list of files that are affected. Click on one, and you will
    see each error marked out. Hover over it to find out what went wrong:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Understanding test errors in pull requests](img/00009.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: If you would like more information about the lint test, you can click on **Console
    Output** on the left, to see a full log of the lint test.
  prefs: []
  type: TYPE_NORMAL
- en: 'Once you have made corrections to the code in your local Git clone, commit
    them as you normally would, and push them back up to GitHub:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE48]'
  prefs: []
  type: TYPE_PRE
- en: A new test run will be scheduled, and any remaining errors will show up as before.
    Once all of the errors have been resolved, a core developer will be able to merge
    your code.
  prefs: []
  type: TYPE_NORMAL
