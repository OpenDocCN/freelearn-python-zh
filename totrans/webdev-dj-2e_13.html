<html><head></head><body>
		<div><div></div>
		</div>
		<div><h1 id="_idParaDest-358"><a id="_idTextAnchor375"/>13. Generating CSV, PDF, and Other Binary Files</h1>
		</div>
		<div><p class="callout-heading">Overview</p>
			<p class="callout">This chapter teaches you how to generate files in different data formats, such as <strong class="bold">CSV</strong>, <strong class="bold">PDF</strong>, and other binary file formats (for example, Excel-compatible files) using some of the common libraries that are available inside Python. This knowledge will help you build web projects that let your users export and download records from your site into familiar CSV or Excel-based formats. You will also learn how to generate graph plots inside Python and render them as HTML and display them inside your web applications. Moreover, you will be able to build features that let users export your data in PDF format.</p>
			<h1 id="_idParaDest-359"><a id="_idTextAnchor376"/>Introduction</h1>
			<p>So far, we have learned the various aspects of the Django framework and explored how we can build web applications using Django with all the features and customizations we want.</p>
			<p>Let's say that while building a web application, we need to do some analysis and prepare some reports. We may need to analyze user demographics about how the platform is being used or generate data that can be fed into machine learning systems to find patterns. We want our website to display some of the results of our analysis in a tabular format and other results as detailed graphs and charts. Furthermore, we also want to allow our users to export the reports and peruse them further in applications such as Jupyter Notebook and Excel.</p>
			<p>As we work our way through this chapter, we will learn how to bring these ideas to fruition and implement functionality in our web application that allows us to export records into structured formats such as tables through the use of <strong class="bold">Comma-Separated Value</strong> (<strong class="bold">CSV</strong>) files or Excel files. We will also learn how to allow our users to generate visual representations of the data we have stored inside our web application and export it as PDF so it can be distributed easily for quick reference.</p>
			<p>Let's start our journey by learning how to work with CSV files in Python. Learning this skill will help us create functionality that allows our readers to export our data for further analysis.</p>
			<h2 id="_idParaDest-360"><a id="_idTextAnchor377"/>Working with CSV Files inside Python</h2>
			<p>There are several reasons we may need to export the data in our application. One of the reasons may involve performing analysis of that data – for example, we may need to understand the demographics of users registered on the application or extract patterns of application usage. We may also need to find out how our application is working for users to design future improvements. Such use cases require data to be in a format that can be easily consumed and analyzed. Here, the CSV file format comes to the rescue. </p>
			<p>CSV is a handy file format that can be used to quickly export data from an application in a row-and-column format. CSV files usually have data separated by simple delimiters, which are used to differentiate one column from another, and newlines, which are used to indicate the start of a new record (or row) inside the table.</p>
			<p>Python has great support for working with CSV files in its standard library thanks to the <code>csv</code> module. This support enables the reading, parsing, and writing of CSV files. Let's take a look at how we can leverage the CSV module provided by Python to work on CSV files and read and write data from them.</p>
			<h1 id="_idParaDest-361"><a id="_idTextAnchor378"/>Working with Python's CSV Module</h1>
			<p>The <code>csv</code> module from Python provides us with the ability to interact with files that are in CSV format, which is nothing but a text file format. That is, the data stored inside the CSV files is human-readable.</p>
			<p>The <code>csv</code> module requires that the file is opened before the methods supplied by the <code>csv</code> module can be applied. Let's take a look at how we can start with the very basic operation of reading data from CSV files.</p>
			<h2 id="_idParaDest-362"><a id="_idTextAnchor379"/>Reading Data from a CSV File</h2>
			<p>Reading data from CSV files is quite easy and consists of the following steps:</p>
			<ol>
				<li>First, we open the file:<pre>csv_file = open('path to csv file')</pre><p>Here, we are reading the file using the Python <code>open()</code> method and then passing it the name of the file from which the data is to be read.</p></li>
				<li>Then, we read the data from the <code>file</code> object using the <code>csv</code> module's <code>reader</code> method:<pre>import csv
csv_data = csv.reader(csv_file)</pre><p>In the first line, we imported the <code>csv</code> module, which contains the set of methods required to work on CSV files:</p><pre>import csv</pre><p>With the file opened, the next step is to create a CSV <code>reader</code> object by using the <code>csv</code> module's <code>reader</code> method. This method takes in the <code>file</code> object as returned by the <code>open()</code> call and uses the <code>file</code> object to read the data from the CSV file:</p><pre>csv_reader = csv.reader(csv_file)</pre><p>The data read by the <code>reader()</code> method is returned as a list of a list, where every sub-list is a new record and every value inside the list is a value for the specified column. Generally, the first record in the list is referred to as a header, which denotes the different columns that are present inside the CSV file, but it is not necessary to have a <code>header</code> field inside a CSV file.</p></li>
				<li>Once the data is read by the <code>csv</code> module, we can iterate over this data to perform any kind of operation we may desire. This can be done as follows:<pre>for csv_record in csv_data:
    # do something</pre></li>
				<li>Once the processing is done, we close the CSV file simply by using the <code>close()</code> method in Python's file handler object:<pre>csv_file.close()</pre></li>
			</ol>
			<p>Now let's look at our first exercise, where we will implement a simple module that helps us read a CSV file and output its contents on our screen.</p>
			<h2 id="_idParaDest-363"><a id="_idTextAnchor380"/>Exercise 13.01: Reading a CSV File with Python</h2>
			<p>In this exercise, you will read and process a CSV file inside Python using Python's built-in <code>csv</code> module. The CSV file contains fictitious market data of several NASDAQ-listed companies:</p>
			<ol>
				<li value="1">First, download the <code>market_cap.csv</code> file from the GitHub repository for this book by clicking the following link: <a href="http://packt.live/2MNWzOV">http://packt.live/2MNWzOV</a>.<p class="callout-heading">Note</p><p class="callout">The CSV file consists of randomly generated data and does not correspond to any historical market trends. </p></li>
				<li>Once the file is downloaded, open it and take a look at its contents. You will realize that the file contains a set of comma-separated values with each different record on its own line:<div><img src="img/B15509_13_01.jpg" alt="Figure 13.1: Contents of the market cap CSV file&#13;&#10;"/></div><p class="figure-caption">Figure 13.1: Contents of the market cap CSV file</p></li>
				<li>Once the file is downloaded, you can proceed to write the first piece of code. For this, create a new file named <code>csv_reader.py</code> in the same directory where the CSV file was downloaded and add the following code inside it:<pre>import csv
def read_csv(filename):
    """Read and output the details of CSV file."""
    try:
       with open(filename, newline='') as csv_file:
           csv_reader = csv.reader(csv_file)
           for record in csv_reader:
               print(record)
    except (IOError, OSError) as file_read_error:
       print("Unable to open the csv file. Exception: {}".format(file_read_error))
if __name__ == '__main__':
    read_csv('market_cap.csv')</pre><p>Let's try to understand what you just implemented in the preceding snippet of code.</p><p>After importing the <code>csv</code> module, to keep the code modular, you created a new method named <code>read_csv()</code> that takes in a single parameter, the filename to read the data from:</p><pre>try:
       with open(filename, newline='') as csv_file:</pre><p>Now, if you are not familiar with the approach of opening the file shown in the preceding snippet, this is also known as the <code>with</code> block will have access to the <code>file</code> object, and once the code exits the scope of the <code>with</code> block, the file will be closed automatically.</p><pre>for record in csv_reader:
    print(record)</pre><p>Once this is done, you write the entry point method, from which your code will begin executing, by calling the <code>read_csv()</code> method and passing the name of the CSV file to read:</p><pre>if __name__ == '__main__':
    read_csv(market_cap.csv')</pre></li>
				<li>With this, you are done and ready to parse your CSV file now. You can do this by running your Python file in the Terminal or Command Prompt as shown here:<pre>python3 csv_reader.py</pre><p class="callout-heading">Note</p><p class="callout">Or, on Windows, use <strong class="bold">python csv_reader.py</strong> as shown in <em class="italic">Figure 13.2</em>.</p><p>Once the code executes, you should expect to see the following output:</p><div><img src="img/B15509_13_02.jpg" alt="Figure 13.2: Output from the CSV reader program&#13;&#10;"/></div></li>
			</ol>
			<p class="figure-caption">Figure 13.2: Output from the CSV reader program</p>
			<p>With this, now you know how to read CSV file contents. Also, as you can see from the output of <em class="italic">Exercise 13.01</em>, <em class="italic">Reading a CSV File with Python</em>, the output for individual rows is represented in the form of a list.</p>
			<p>Now, let's look at how we can use the Python <code>csv</code> module to create new CSV files.</p>
			<h2 id="_idParaDest-364"><a id="_idTextAnchor381"/>Writing to CSV Files Using Python</h2>
			<p>In the previous section, we explored how we can use the <code>csv</code> module in Python to read the contents of the CSV-formatted files. Now, let us learn how we can write CSV data to files.</p>
			<p>Writing CSV data follows a similar approach as reading from a CSV file, with some minor differences. The following steps outline the process of writing data to CSV files:</p>
			<ol>
				<li value="1">Open the file in writing mode:<pre>csv_file = open('path to csv file', 'w')</pre></li>
				<li>Obtain a CSV writer object, which can help us write data that is correctly formatted in the CSV format. This is done by calling the <code>writer()</code> method of the <code>csv</code> module, which returns a <code>writer</code> object, which can be used to write CSV format-compatible data to a CSV file:<pre>csv_writer = csv.writer(csv_file)</pre></li>
				<li>Once the <code>writer</code> object is available, we can start writing the data. This is facilitated by the <code>write_row()</code> method of the <code>writer</code> object. The <code>write_row()</code> method takes in a list of values that it writes to the CSV file. The list itself indicates a single row and the values inside the list indicate the values of columns:<pre>record = ['value1', 'value2', 'value3']
csv_writer.writerow(record)</pre><p>If you want to write multiple records in a single call, you can also use the <code>writerows()</code> method of the CSV writer. The <code>writerows()</code> method behaves similarly to the <code>writerow()</code> method but takes a list of lists and can write multiple rows in one go:</p><pre>records = [['value11', 'value12', 'value13'],\
           ['value21', 'value22', 'value23']]
csv_writer.writerows(records)</pre></li>
				<li>Once the records are written, we can then close the CSV file:<pre>csv_file.close()</pre></li>
			</ol>
			<p>Now, let's apply what we've learned in the next exercise and implement a program that will help us in writing values to CSV files.</p>
			<h2 id="_idParaDest-365"><a id="_idTextAnchor382"/>Exercise 13.02: Generating a CSV File Using Python's csv Module</h2>
			<p>In this exercise, you will use the Python <code>csv</code> module to create new CSV files:</p>
			<ol>
				<li value="1">Create a new file named <code>csv_writer.py</code>, inside which you will write the code for the CSV writer. Inside this file, add the following code:<pre>import csv
def write_csv(filename, header, data):
    """Write the provided data to the CSV file.
    :param str filename: The name of the file \
        to which the data should be written
    :param list header: The header for the \
        columns in csv file
    :param list data: The list of list mapping \
        the values to the columns
    """
    try:
        with open(filename, 'w') as csv_file:
            csv_writer = csv.writer(csv_file)
            csv_writer.writerow(header)
            csv_writer.writerows(data)
    except (IOError, OSError) as csv_file_error:
        print\
        ("Unable to write the contents to csv file. Exception: {}"\
         .format(csv_file_error))</pre><p>With this code, you should now be able to create new CSV files easily. Now, going step by step, let's understand what you are trying to do in this code:</p><p>You define a new method called <code>write_csv()</code>, which takes three parameters: the name of the file to which the data should be written (<code>filename</code>), the list of column names that should be used as headers (<code>header</code>), and lastly a list of a list that contains the data that needs to be mapped to individual columns (<code>data</code>):</p><pre> def write_csv(filename, header, data):</pre><p>Now, with the parameters in place, the next step is to open the file to which the data needs to be written and map it to an object:</p><pre>with open(filename, 'w') as csv_file:</pre><p>Once the file is opened, you perform three main steps: first, obtain a new CSV writer object by using the <code>writer()</code> method from the <code>csv</code> module and passing it to the file handler that holds a reference to your opened file:</p><pre>csv_writer = csv.writer(csv_file)</pre><p>The next step involves using the CSV writer's <code>writerow()</code> method to write your dataset's header fields into the file:</p><pre>csv_writer.writerow(header)</pre><p>Once you have written the header, the last step is to write the data to the CSV file for the individual columns that are present. For this, use the <code>csv</code> module's <code>writerows()</code> method to write multiple rows at once:</p><pre>csv_writer.writerows(data)</pre><p class="callout-heading">Note</p><p class="callout">We could also have merged the step of writing the header and data into a single line of code by having the header list as the first element of the data list and calling the <code>writerows()</code> method with the data list as a parameter.</p></li>
				<li>When you have created the methods that can write the provided data to a CSV file, you write the code for the entry point call, and inside it, set up the values for the header, data, and filename fields, and finally call the <code>write_csv()</code> method that you defined earlier:<pre>if __name__ == '__main__':
    header = ['name', 'age', 'gender']
    data = [['Richard', 32, 'M'], \
            ['Mumzil', 21, 'F'], \
            ['Melinda', 25, 'F']]
    filename = 'sample_output.csv'
    write_csv(filename, header, data)</pre></li>
				<li>Now with the code in place, execute the file you just created and see whether it creates the CSV file. To execute, run the following command:<pre>python3 csv_writer.py</pre><p>Once the execution finishes, you will see that a new file has been created in the same directory as the one in which you executed the command. When you open the file, the contents should resemble what you see in the following figure:</p><div><img src="img/B15509_13_03.jpg" alt="Figure 13.3: Output from the CSV writer sample_output.csv&#13;&#10;"/></div></li>
			</ol>
			<p class="figure-caption">Figure 13.3: Output from the CSV writer sample_output.csv</p>
			<p>With this, now you are well equipped to read and write the contents of CSV files.</p>
			<p>With this exercise, we have learned how to write data to a CSV file. Now, it is time to look at some enhancements that can make reading and writing data to CSV files as a developer more convenient.</p>
			<h2 id="_idParaDest-366"><a id="_idTextAnchor383"/>A Better Way to Read and Write CSV Files</h2>
			<p>Now, there is one important thing that needs to be taken care of. If you remember, the data read by the CSV reader usually maps values to a list. Now, if you want to access the values of individual columns, you need to use list indexes to access them. This way is not natural and causes a higher degree of coupling between the program responsible for writing the file and the one responsible for reading the file. For example, what if the writer program shuffled the order of the rows? In this case, you now have to update the reader program to make sure it identifies correct rows. So, the question arises, do we have a better way to read and write values that, instead of using list indexes, uses column names while preserving the context?</p>
			<p>The answer to this is yes, and the solution is provided by another set of CSV modules known as <code>DictReader</code> and <code>DictWriter</code>, which provide the functionality of mapping objects in a CSV file to <code>dict</code>, rather than to a list.</p>
			<p>This interface is easy to implement. Let's revisit the code you wrote in <em class="italic">Exercise 13.01</em>, <em class="italic">Reading a CSV File with Python</em>. If you wanted to parse the code as dict, the implementation of the <code>read_csv()</code> method would need to be changed as shown here:</p>
			<pre>def read_csv(filename):
    """Read and output the details of CSV file."""
    try:
       with open(filename, newline='') as csv_file:
           csv_reader = <strong class="bold">csv.DictReader</strong>(csv_file)
           for record in csv_reader:
               print(record)
    except (IOError, OSError) as file_read_error:
        print\
        ("Unable to open the csv file. Exception: {}"\
        .format(file_read_error))</pre>
			<p>As you will notice, the only change we did was to change <code>csv.reader()</code> to <code>csv.DictReader()</code>, which should represent individual rows in the CSV file as <code>OrderedDict</code>. You can also verify this by making this change and executing the following command:</p>
			<pre>python3 csv_reader.py</pre>
			<p>This should result in the following output:</p>
			<div><div><img src="img/B15509_13_04.jpg" alt="Figure 13.4: Output with DictReader&#13;&#10;"/>
				</div>
			</div>
			<p class="figure-caption">Figure 13.4: Output with DictReader</p>
			<p>As you can see in the preceding figure, the individual rows are mapped as key-value pairs in the dictionary. To access these individual fields in rows, we can use this:</p>
			<pre>print(record.get('stock_symbol'))</pre>
			<p>That should give us the value of the <code>stock_symbol</code> field from our individual records.</p>
			<p>Similarly, you can also use the <code>DictWriter()</code> interface to operate on CSV files as dictionaries. To see this, let's take a look at the <code>write_csv()</code> method in <em class="italic">Exercise 13.02</em>, <em class="italic">Generating a CSV File Using Python's csv Module</em>, and modify it as follows:</p>
			<pre>def write_csv(filename, header, data):
    """Write the provided data to the CSV file.
    :param str filename: The name of the file \
        to which the data should be written
    :param list header: The header for the \
        columns in csv file
    :param list data: The list of dicts mapping \
        the values to the columns
    """
    try:
        with open(filename, 'w') as csv_file:
            csv_writer = <strong class="bold">csv</strong>.<strong class="bold">DictWriter</strong>(csv_file, <strong class="bold">fieldnames=header</strong>)
            csv_writer.writeheader()
            csv_writer.writerows(data)
    except (IOError, OSError) as csv_file_error:
        print\
        ("Unable to write the contents to csv file. Exception: {}"\
        .format(csv_file_error))</pre>
			<p>In the preceding code, we replaced <code>csv.writer()</code> with <code>csv.DictWriter()</code>, which provides a dictionary-like interface to interact with CSV files. <code>DictWriter()</code> also takes in a <code>fieldnames</code> parameter, which is used to map the individual columns in a CSV file before writing.</p>
			<p>Next, to write this header, call the <code>writeheader()</code> method, which writes the <code>fieldname</code> header to the CSV file.</p>
			<p>The final call involves the <code>writerows()</code> method, which takes in a list of dictionaries and writes them to the CSV file. For the code to work correctly, you also need to modify the data list to resemble the one shown here:</p>
			<pre>data = [{'name': Richard, 'age': 32, 'gender': 'M'}, \
        {'name': Mumzil', 'age': 21, 'gender':'F'}, \
        {'name': 'Melinda', 'age': 25, 'gender': 'F'}]</pre>
			<p>With this, you will have enough knowledge to work with CSV files inside Python.</p>
			<p>Since we are talking about how to deal with tabular data, specifically reading and writing it to files, let's take a look at one of the more well-known file formats used by one of the most popular tabular data editors – Microsoft Excel.</p>
			<h1 id="_idParaDest-367"><a id="_idTextAnchor384"/>Working with Excel Files in Python</h1>
			<p>Microsoft Excel is a world-renowned software in the field of book-keeping and tabular record management. Similarly, the XLSX file format that was introduced with Excel has seen rapid and widespread adoption and is now supported by all the major product vendors.</p>
			<p>You will find that Microsoft Excel and its XLSX format are used quite a lot in the marketing and sales departments of many companies. Let's say, for one such company's marketing department, you are building a web portal in Django that keeps track of the products purchased by users. It also displays data about the purchases, such as the time of purchase and the location where the purchase was made. The marketing and sales teams are planning to use this data to generate leads or to create relevant advertisements.</p>
			<p>Since the marketing and sales teams use Excel quite a lot, we might want to export the data available inside our web application in XLSX format, which is native to Excel. Soon, we will look at how we can make our website work with this XLSX format. But before that, let's quickly take a look at the usage of binary file formats.</p>
			<h2 id="_idParaDest-368"><a id="_idTextAnchor385"/>Binary File Formats for Data Exports</h2>
			<p>Until now, we have worked mainly with textual data and how we can read and write it from text files. But often, text-based formats are not enough. For example, imagine you want to export an image or a graph. How will you represent an image or a graph as text, and how will you read and write to these images?</p>
			<p>In these situations, binary file formats can come to our rescue. They can help us read and write to and from a rich and diverse set of data. All commercial operating systems provide native support for working with both text and binary file formats, and it comes as no surprise that Python provides one of the most versatile implementations to work on binary data files. A simple example of this is the <code>open</code> command, which you use to state the format you would like to open a file in:</p>
			<pre>file_handler = open('path to file', 'r<strong class="bold">b</strong>')</pre>
			<p>Here, <code>b</code> indicates binary.</p>
			<p>Starting from this section, we will now be dealing with how we can work on binary files and use them to represent and export data from our Django web application. The first of the formats we are going to look at is the XLSX file format made popular by Microsoft Excel.</p>
			<p>So, let's dive into the handling of XLSX files with Python.</p>
			<h2 id="_idParaDest-369"><a id="_idTextAnchor386"/>Working with XLSX Files Using the XlsxWriter Package</h2>
			<p>In this section, we will learn more about the XLSX file format and understand how we can work with it using the <strong class="bold">XlsxWriter</strong> package.</p>
			<h3 id="_idParaDest-370"><a id="_idTextAnchor387"/>XLSX Files</h3>
			<p>XLSX files are binary files that are used to store tabular data. These files can be read by any software that implements support for this format. The XLSX format arranges data into two logical partitions:</p>
			<ul>
				<li><code>Example_file.xlsx</code> is a workbook <strong class="bold">(1)</strong>:<div><img src="img/B15509_13_05.jpg" alt="Figure 13.5: Workbooks and Worksheets in Excel&#13;&#10;"/></div></li>
			</ul>
			<p class="figure-caption">Figure 13.5: Workbooks and Worksheets in Excel</p>
			<ul>
				<li><code>Sheet1</code> and <code>Sheet2</code> are two worksheets <strong class="bold">(2)</strong>. </li>
			</ul>
			<p>When working with XLSX format, these are the two units that we generally work on. If you know about relational databases, you can think of workbooks as databases and worksheets as tables.</p>
			<p>With that, let's try to understand how we can start working on XLSX files inside Python.</p>
			<h3 id="_idParaDest-371"><a id="_idTextAnchor388"/>The XlsxWriter Python Package</h3>
			<p>Python does not provide native support for working with XLSX files through its standard library. But thanks to the vast community of developers within the Python ecosystem, it is easy to find a number of packages that can help us manage our interaction with XLSX files. One popular package in this category is <strong class="bold">XlsxWriter</strong>.</p>
			<p><code>XlsxWriter</code> is an actively maintained package by the developer community, providing support for interacting with XLSX files. The package provides a lot of useful functionalities and supports the creation and management of workbooks as well as worksheets in individual workbooks. You can install it by running the following command in Terminal or Command Prompt:</p>
			<pre>pip install XlsxWriter</pre>
			<p>Once installed, you can import the <code>xlsxwriter</code> module as follows:</p>
			<pre>import xlsxwriter</pre>
			<p>So, let's look at how we can start creating XLSX files with the support of the <code>XlsxWriter</code> package.</p>
			<h3 id="_idParaDest-372"><a id="_idTextAnchor389"/>Creating a Workbook</h3>
			<p>To start working on XLSX files, we first need to create them. An XLSX file is also known as a workbook and can be created by calling the <code>Workbook</code> class from the <code>xlsxwriter</code> module as follows:</p>
			<pre>workbook = xlsxwriter.Workbook(filename)</pre>
			<p>The call to the <code>Workbook</code> class opens a binary file, specified with the <code>filename</code> argument, and returns an instance of <code>workbook</code> that can be used to further create worksheets and write data.</p>
			<h3 id="_idParaDest-373"><a id="_idTextAnchor390"/>Creating a Worksheet</h3>
			<p>Before we can start writing data to an XLSX file, we first need to create a worksheet. This can be done easily by calling the <code>add_worksheet()</code> method of the <code>workbook</code> object we obtained in the previous step:</p>
			<pre>worksheet = workbook.add_worksheet()</pre>
			<p>The <code>add_worksheet()</code> method creates a new worksheet, adds it to the workbook, and returns an object mapping the worksheet to a Python object, through which we can write data to the worksheet.</p>
			<h3 id="_idParaDest-374"><a id="_idTextAnchor391"/>Writing Data to the Worksheet</h3>
			<p>Once a reference to the worksheet is available, we can start writing data to it by calling the <code>write</code> method of the <code>worksheet</code> object as shown:</p>
			<pre>worksheet.write(row_num, col_num, col_value)</pre>
			<p>As you can see, the <code>write()</code> method takes three parameters: a row number (<code>row_num</code>), a column number (<code>col_num</code>), and the data that belongs to the [<code>row_num, col_num</code>] pair as represented by <code>col_value</code>. This call can be repeated to insert multiple data items into the worksheet.</p>
			<h3 id="_idParaDest-375"><a id="_idTextAnchor392"/>Writing the Data to the Workbook</h3>
			<p>Once all the data is written, to finalize the written datasets and cleanly close the XLSX file, you call the <code>close()</code> method on the workbook:</p>
			<pre>workbook.close()</pre>
			<p>This method writes any data that may be in the file buffer and finally closes the workbook. Now, let's use this knowledge to implement our own code, which will help us write data to an XLSX file.</p>
			<p class="callout-heading">Further Reading</p>
			<p class="callout">It's not possible to cover all the methods and features the <code>XlsxWriter</code> package provides in this chapter. For more information, you can read the official documentation: <a href="https://xlsxwriter.readthedocs.io/contents.html">https://xlsxwriter.readthedocs.io/contents.html</a>.</p>
			<h2 id="_idParaDest-376"><a id="_idTextAnchor393"/>Exercise 13.03: Creating XLSX Files in Python</h2>
			<p>In this exercise, you will use the <code>XlsxWriter</code> package to create a new Excel (XLSX) file and add data to it from Python:</p>
			<ol>
				<li value="1">For this exercise, you will need the <code>XlsxWriter</code> package installed on your system. You can install it by running the following command in your Terminal app or Command Prompt:<pre>pip install XlsxWriter</pre><p>Once the command finishes, you will have the package installed on your system.</p></li>
				<li>With the package installed, you can start writing the code that will create the Excel file. Create a new file named <code>xlsx_demo.py</code> and add the following code inside it:<pre>import xlsxwriter
def create_workbook(filename):
    """Create a new workbook on which we can work."""
    workbook = xlsxwriter.Workbook(filename)
    return workbook</pre><p>In the preceding code snippet, you have created a new function that will assist you in creating a new workbook in which you can store your data. Once you have created a new workbook, the next step is to create a worksheet that provides you with the tabular format needed for you to organize the data to be stored inside the XLSX workbook.</p></li>
				<li>With the workbook created, create a new worksheet by adding the following code snippet to your <code>xlsx_demo.py</code> file:<pre>def create_worksheet(workbook):
    """Add a new worksheet in the workbook."""
    worksheet = workbook.add_worksheet()
    return worksheet</pre><p>In the preceding code snippet, you have created a new worksheet using the <code>add_worksheet()</code> method of the <code>workbook</code> object provided by the <code>XlsxWriter</code> package. This worksheet will then be used to write the data for the objects.</p></li>
				<li>The next step is to create a helper function that can assist in writing the data to the worksheet in a tabular format defined by the row and column numbering. For this, add the following snippet of code to your <code>xlsx_writer.py</code> file:<pre>def write_data(worksheet, data):
    """Write data to the worksheet."""
    for row in range(len(data)):
        for col in range(len(data[row])):
            worksheet.write(row, col, data[row][col])</pre><p>In the preceding code snippet, you have created a new function named <code>write_data()</code> that takes two parameters: the <code>worksheet</code> object to which the data needs to be written and the <code>data</code> object represented by a list of lists that needs to be written to the worksheet. The function iterates over the data passed to it and then writes the data to the row and column it belongs to.</p></li>
				<li>With all the core methods now implemented, you can now add the method that can help close the <code>workbook</code> object cleanly, such that the data is written to the file without any file corruption happening. For this, implement the following code snippet in the <code>xlsx_demo.py</code> file:<pre>def close_workbook(workbook):
    """Close an opened workbook."""
    workbook.close()</pre></li>
				<li>The last step in the exercise is to integrate all the methods you have implemented in the previous steps. For this, create a new entry point method as shown in the following code snippet in your <code>xlsx_demo.py</code> file:<pre>if __name__ == '__main__':
    data = [['John Doe', 38], \
            ['Adam Cuvver', 22], \
            ['Stacy Martin', 28], \
            ['Tom Harris', 42]]
    workbook = create_workbook('sample_workbook.xlsx')
    worksheet = create_worksheet(workbook)
    write_data(worksheet, data)
    close_workbook(workbook)</pre><p>In the preceding code snippet, you first created a dataset that you want to write to the XLSX file in the form of a list of lists. Once that was done, you obtained a new <code>workbook</code> object, which will be used to create an XLSX file. Inside this <code>workbook</code> object, you then created a worksheet to organize your data in a row-and-column format and then wrote the data to the worksheet and closed the workbook to persist the data to the disk.</p></li>
				<li>Now, let's see whether the code you wrote works the way it is expected to work. For this, run the following command:<pre>python3 xlsx_demo.py</pre><p>Once the command is finished executing, you will see a new file with the name <code>sample_workbook.xlsx</code> being created in the directory where the command was executed. To verify whether it contains the correct results, open this file with either Microsoft Excel or Google Sheets and view the contents. It should resemble what you see here:</p><div><img src="img/B15509_13_06.jpg" alt="Figure 13.6: Excel sheet generated using xlsxwriter&#13;&#10;"/></div></li>
			</ol>
			<p class="figure-caption">Figure 13.6: Excel sheet generated using xlsxwriter</p>
			<p>With the help of the <code>xlsxwriter</code> module, you can also apply formulas to your columns. For example, if you wanted to add another row that shows the average age of the people in the spreadsheet, you can do that simply by modifying the <code>write_data()</code> method as shown here:</p>
			<pre>def write_data(worksheet, data):
    """Write data to the worksheet."""
    for row in range(len(data)):
        for col in range(len(data[row])):
            worksheet.write(row, col, data[row][col])
    worksheet.write(len(data), 0, "Avg. Age") 
    # len(data) will give the next index to write to
    avg_formula = "=AVERAGE(B{}:B{})".format(1, len(data))
    worksheet.write(len(data), 1, avg_formula)</pre>
			<p>In the preceding code snippet, you added an additional <code>write</code> call to the worksheet and used the <code>AVERAGE</code> function provided by Excel to calculate the average age of the people in the worksheet.</p>
			<p>With this, you now know how we can generate Microsoft Excel-compatible XLSX files using Python and how to export tabular content that's easily consumable by the different teams in your organization. </p>
			<p>Now, let's cover another interesting file format that is widely used across the world.</p>
			<h1 id="_idParaDest-377"><a id="_idTextAnchor394"/>Working with PDF Files in Python</h1>
			<p><strong class="bold">Portable Document Format</strong> or <strong class="bold">PDF</strong> is one of the most common file formats in the world. You must have encountered PDF documents at some point. These documents can include business reports, digital books, and more.</p>
			<p>Also, do you remember ever having encountered websites that have a button that reads <code>Print</code> <code>page</code> <code>as</code> <code>PDF</code>? A lot of websites for government agencies readily provide this option, which allows you to print the web page directly as a PDF. So, the question arises, how can we do this for our web app? How should we add the option to export certain content as a PDF?</p>
			<p>Over the years, a huge community of developers has contributed a lot of useful packages to the Python ecosystem. One of those packages can help us achieve PDF file generation.</p>
			<h2 id="_idParaDest-378"><a id="_idTextAnchor395"/>Converting Web Pages to PDFs</h2>
			<p>Sometimes, we may run into situations where we want to convert a web page into a PDF. For example, we may want to print a web page to store it as a local copy. This also comes in handy when trying to print a certificate that is natively displayed as a web page.</p>
			<p>To help us in such efforts, we can leverage a simple library known as <code>weasyprint</code>, which is maintained by a community of Python developers and allows the quick and easy conversion of web pages to PDFs. So, let's take a look at how we can generate a PDF version of a web page.</p>
			<h2 id="_idParaDest-379"><a id="_idTextAnchor396"/>Exercise 13.04: Generating a PDF Version of a Web Page in Python</h2>
			<p>In this exercise, you will generate a PDF version of a website using Python. You will use a community-contributed Python module known as <code>weasyprint</code> that will help you generate the PDF:</p>
			<ol>
				<li value="1">To make the code in the upcoming steps work correctly, install the <code>weasyprint</code> module on your system. To do this, run the following command:<pre>pip install weasyprint</pre><p class="callout-heading">Note</p><p class="callout"><code>weasyprint</code> depends on the <code>cairo</code> library. In case you haven't installed <code>cairo</code> libraries, usage of <code>weasyprint</code> might raise an error with the message: <code>libcairo-2.dll</code> <code>file</code> <code>not</code> <code>found</code>. If you're facing this issue or any other issue installing the module, use the <code>requirements.txt</code> file we've provided on our GitHub repository at <a href="http://packt.live/3btLoVV">http://packt.live/3btLoVV</a>. Download the file to your disk and open your Terminal, shell or Command Prompt and type the following command (you will need to <code>cd</code> to the path where you saved this file locally): <code>pip install -r requirements.txt</code>. If that doesn't work, follow the steps as mentioned in the <code>weasyprint</code> documentation: <a href="https://weasyprint.readthedocs.io/en/stable/install.html">https://weasyprint.readthedocs.io/en/stable/install.html</a>.</p></li>
				<li>With the package now installed, create a new file named <code>pdf_demo.py</code> that will contain the PDF generation logic. Inside this file, write the following code:<pre>from weasyprint import HTML
def generate_pdf(url, pdf_file):
    """Generate PDF version of the provided URL."""
    print("Generating PDF...")
    HTML(url).write_pdf(pdf_file)</pre><p>Now, let's try to understand what this code does. In the first line, you imported the <code>HTML</code> class from the <code>weasyprint</code> package, which you installed in <em class="italic">step 1</em>:</p><pre>from weasyprint import HTML</pre><p>This HTML class provides us with a mechanism through which we can read the HTML content of a website if we have its URL.</p><p>In the next step, you created a new method named <code>generate_pdf()</code> that takes in two parameters, namely, the URL that should be used as the source URL for the generation of the PDF and the <code>pdf_file</code> parameter, which takes in the name of the file to which the document should be written:</p><pre>def generate_pdf(url, pdf_file):</pre><p>Next, you passed the URL to the <code>HTML</code> class object you imported earlier. This caused the URL to be parsed by the <code>weasyprint</code> library and caused its HTML content to be read. Once this was done, you called the <code>write_pdf()</code> method of the <code>HTML</code> class object and provided to it the name of the file to which the content should be written:</p><pre>HTML(url).write_pdf(pdf_file)</pre></li>
				<li>After this, write the entry point code that sets up the URL (for this exercise, we will use the text version of the <code>generate_pdf()</code> method to generate the content:<pre>if __name__ == '__main__':
    url = 'http://text.npr.org'
    pdf_file = 'demo_page.pdf'
    generate_pdf(url, pdf_file)</pre></li>
				<li>Now, to see the code in action, run the following command:<pre>python3 pdf_demo.py</pre><p>Once the command finishes executing, you will have a new PDF file named <code>demo_page.pdf</code> that is saved in the same directory where the command was executed. When you open the file, it should resemble what you see here:</p><div><img src="img/B15509_13_07.jpg" alt="Figure 13.7: Web page converted to a PDF using weasyprint&#13;&#10;"/></div></li>
			</ol>
			<p class="figure-caption">Figure 13.7: Web page converted to a PDF using weasyprint</p>
			<p>In the PDF file generated, we can see that the content seems to lack the formatting that the actual website has. This happens because the <code>weasyprint</code> package reads the HTML content but does not parse the attached CSS stylesheets for the page, so the page formatting is lost.</p>
			<p><code>weasyprint</code> also makes it quite easy to change the formatting of a page. This can be done simply by introducing the stylesheet parameter to the <code>write_pdf()</code> method. A simple modification to our <code>generate_pdf()</code> method is described next:</p>
			<pre>from weasyprint import CSS, HTML
def generate_pdf(url, pdf_file):
    """Generate PDF version of the provided URL."""
    print("Generating PDF...")
    css = CSS(string='body{ font-size: 8px; }')
    HTML(url).write_pdf(pdf_file, stylesheets=[css])</pre>
			<p>Now, when the preceding code is executed, we will see that the font size for all the text inside the HTML body content of the page has a size of <code>8px</code> in the printed PDF version.</p>
			<p class="callout-heading">Note</p>
			<p class="callout">The <code>HTML</code> class in <code>weasyprint</code> is also capable of taking any local files as well as raw HTML string content and can use those files to generate PDFs. For further information, please visit the <code>weasyprint</code> documentation at <a href="https://weasyprint.readthedocs.io">https://weasyprint.readthedocs.io</a>.</p>
			<p>So far, we have learned about how we can generate different types of binary files with Python, which can help us export our data in a structured manner or help us print PDF versions of our pages. Next, we will see how we can generate graph representations of our data using Python.</p>
			<h1 id="_idParaDest-380"><a id="_idTextAnchor397"/>Playing with Graphs in Python</h1>
			<p>Graphs are a great way to visually represent data that changes within a specific dimension. We come across graphs quite frequently in our day-to-day lives, be it weather charts for a week, stock market movements, or student performance report cards.</p>
			<p>Similarly, graphs can come in quite handy when we are working with our web applications. For Bookr, we can use graphs as a visual medium to show the user information about the number of books they read each week. Alternatively, we can show them the popularity of a book over time based on how many readers were reading the given book at a specific time. Now, let's look at how we can generate plots with Python and have them show up on our web pages.</p>
			<h2 id="_idParaDest-381"><a id="_idTextAnchor398"/>Generating Graphs with plotly</h2>
			<p>Graphs can come in quite handy when trying to visualize patterns in the data maintained by our applications. There are a lot of Python libraries that help developers in generating static or interactive graphs.</p>
			<p>For this book, we will use <code>plotly</code>, a community-supported Python library that generates graphs and renders them on web pages. <code>plotly</code> is particularly interesting to us due to its ease of integration with Django.</p>
			<p>To install it on your system, you can type in the following command in the command line:</p>
			<pre>pip install plotly</pre>
			<p>Now that's done, let's take a look at how we can generate a graph visualization using <code>plotly</code>.</p>
			<h3 id="_idParaDest-382"><a id="_idTextAnchor399"/>Setting Up a Figure</h3>
			<p>Before we can get started with generating a graph, we first need to initialize a <code>plotly</code> <code>Figure</code> object, which essentially acts as a container for our graph. A <code>plotly</code> <code>Figure</code> object is quite easy to initialize; it can be done by using the following code snippet:</p>
			<pre>from plotly.graph_objs import graphs
figure = graphs.Figure()</pre>
			<p>The <code>Figure()</code> constructor from the <code>graph_objs</code> module of <code>plotly</code> library returns an instance of the <code>Figure</code> graph container, inside which a graph can be generated. Once the <code>Figure</code> object is in place, the next thing that needs to be done is to generate a plot.</p>
			<h3 id="_idParaDest-383"><a id="_idTextAnchor400"/>Generating a Plot</h3>
			<p>A plot is a visual representation of a dataset. This plot could be a scatter plot, a line graph, a chart, and so on. For example, to generate a scatter plot, the following code snippet is used:</p>
			<pre>scatter_plot = graphs.Scatter(x_axis_values, y_axis_values)</pre>
			<p>The <code>Scatter</code> constructor takes in the values for the <em class="italic">X</em>-axis and <em class="italic">Y</em>-axis and returns an object that can be used to build a scatter plot. Once the <code>scatter_plot</code> object is generated, the next step is to add this plot to our <code>Figure</code>. This can be done as follows:</p>
			<pre>figure.add_trace(scatter_plot)</pre>
			<p>The <code>add_trace()</code> method is responsible for adding a plotting object to the figure and generating its visualization inside the figure.</p>
			<h3 id="_idParaDest-384"><a id="_idTextAnchor401"/>Rendering a Plot on a Web Page</h3>
			<p>Once the plot is added to the figure, it can be rendered on a web page by calling the <code>plot</code> method from the <code>offline</code> plotting module of <code>plotly</code> library. This is shown in the following code snippet:</p>
			<pre>from plotly.offline import plot
visualization_html = plot(figure, output_type='div')</pre>
			<p>The <code>plot</code> method takes two primary parameters: the first is the figure that needs to be rendered and the second one is the HTML tag of the container inside which the figure HTML will be generated. The <code>plot</code> method returns fully integrated HTML that can be embedded in any web page or made a part of the template to render a graph.</p>
			<p>Now, with this understanding of how graph plotting works, let's try a hands-on exercise to generate a graph for our sample dataset.</p>
			<h2 id="_idParaDest-385"><a id="_idTextAnchor402"/>Exercise 13.05: Generating Graphs in Python</h2>
			<p>In this exercise, you will generate a Graph plot using Python. It will be a scatter plot that will represent two-dimensional data:</p>
			<ol>
				<li value="1">For this exercise, you will be using the <code>plotly</code> library. To use this library, you first need to install it on the system. To do this, run the following command:<pre>pip install plotly</pre><p class="callout-heading">Note</p><p class="callout">You can install <code>plotly</code> and other dependencies for this exercise using the <code>requirements.txt</code> file we've provided on our GitHub repository: <a href="http://packt.live/38y5OLR">http://packt.live/38y5OLR</a>.</p></li>
				<li>With the library now installed, create a new file named <code>scatter_plot_demo.py</code> and add the following <code>import</code> statements inside it:<pre>from plotly.offline import plot
import plotly.graph_objs as graphs</pre></li>
				<li>Once the imports are sorted, create a method named <code>generate_scatter_plot()</code> that takes in two parameters, the values for the <em class="italic">X</em>-axis and the values for the <em class="italic">Y</em>-axis:<pre>def generate_scatter_plot(x_axis, y_axis):</pre></li>
				<li>Inside this method, first, create an object to act as a container for the graph:<pre>    figure = graphs.Figure()</pre></li>
				<li>Once the container for the graph is set up, create a new <code>Scatter</code> object with the values for the <em class="italic">X</em>-axis and <em class="italic">Y</em>-axis and add it to the graph <code>Figure</code> container:<pre>    scatter = graphs.Scatter(x=x_axis, y=y_axis)
    figure.add_trace(scatter)</pre></li>
				<li>Once the scatter plot is ready and added to the figure, the last step is to generate the HTML, which can be used to render this plot inside a web page. To do this, call the <code>plot</code> method and pass the graph container object to it, and render the HTML inside an HTML <code>div</code> tag:<pre>    return plot(figure, output_type='div')</pre><p>The complete <code>generate_scatter_plot()</code> method should look like this now:</p><pre>def generate_scatter_plot(x_axis, y_axis):
    figure = graphs.Figure()
    scatter = graphs.Scatter(x=x_axis, y=y_axis)
    figure.add_trace(scatter)
    return plot(figure, output_type='div')</pre></li>
				<li>Once the HTML for the plot is generated, it needs to be rendered somewhere. For this, create a new method named <code>generate_html()</code>, which will take in the plot HTML as its parameter and render an HTML file consisting of the plot:<pre>def generate_html(plot_html):
    """Generate an HTML page for the provided plot."""
    html_content = "&lt;html&gt;&lt;head&gt;&lt;title&gt;Plot       Demo&lt;/title&gt;&lt;/head&gt;&lt;body&gt;{}&lt;/body&gt;&lt;/html&gt;".format(plot_html)
    try:
        with open('plot_demo.html', 'w') as plot_file:
            plot_file.write(html_content)
    except (IOError, OSError) as file_io_error:
        print\
        ("Unable to generate plot file. Exception: {}"\
        .format(file_io_error))</pre></li>
				<li>Once the method is set up, the last step is to call it. For this, create a script entry point that will set up the values for the <em class="italic">X</em>-axis list and the <em class="italic">Y</em>-axis list and then call the <code>generate_scatter_plot()</code> method. With the value returned by the method, make a call to the <code>generate_html()</code> method, which will create an HTML page consisting of the scatter plot:<pre>if __name__ == '__main__':
    x = [1,2,3,4,5]
    y = [3,8,7,9,2]
    plot_html = generate_scatter_plot(x, y)
    generate_html(plot_html)</pre></li>
				<li>With the code in place, run the file and see what output is generated. To run the code, execute the following command:<pre>python3 scatter_plot_demo.py</pre><p>Once the execution completes, there will be a new <code>plot_demo.html</code> file created in the same directory in which the script was executed. Upon opening the file, you should see the following:</p><div><img src="img/B15509_13_08.jpg" alt="Figure 13.8: Graph generated in the browser using plotly&#13;&#10;"/></div></li>
			</ol>
			<p class="figure-caption">Figure 13.8: Graph generated in the browser using plotly</p>
			<p>With this, we have generated our first scatter plot, where different points are connected by a line.</p>
			<p>In this exercise, you used the <code>plotly</code> library to generate a graph that can be rendered inside a browser for your readers to visualize data.</p>
			<p>Now, you know how you can work with graphs in Python and how to generate HTML pages from them. </p>
			<p>But as a web developer, how you can use these graphs in Django? Let's find out. </p>
			<h2 id="_idParaDest-386"><a id="_idTextAnchor403"/>Integrating plotly with Django</h2>
			<p>The graphs generated by <code>plotly</code> are quite easy to embed in Django templates. Since the <code>plot</code> method returns a fully contained HTML that can be used to render a graph, we can use the HTML returned as a template variable in Django and pass it as it is. The Django templating engine will then take care of adding this generated HTML to the final template before it is shown in the browser.</p>
			<p>Some sample code for doing this is shown next:</p>
			<pre>def user_profile(request):
    username = request.user.get_username()
    scatter_plot_html = scatter_plot_books_read(username)
    return render(request, 'user_profile.html'),\
                 (context={'plt_div': scatter_plot_html})</pre>
			<p>The preceding code will cause the <code>{{ plt_div }}</code> content used inside the template to be replaced by the HTML stored inside the <code>scatter_plot_demo</code> variable, and the final template to render the scatter plot of the number of books read per week.</p>
			<h1 id="_idParaDest-387"><a id="_idTextAnchor404"/>Integrating Visualizations with Django</h1>
			<p>In the preceding sections, you have learned how data can be read and written in different formats that cater to the different needs of users. But how can we use what we've learned to integrate with Django?</p>
			<p>For example, in Bookr, we might want to allow the user to export a list of books that they have read or visualize their book reading activity over a year. How can that be done? The next exercise in this chapter focuses on that aspect, where you will learn how the components we have seen so far can be integrated into Django web applications.</p>
			<h2 id="_idParaDest-388"><a id="_idTextAnchor405"/>Exercise 13.06: Visualizing a User's Reading History on the User Profile Page</h2>
			<p>In this exercise, you will aim to modify the user's profile page such that the user can visualize their book reading history when they visit their profile page on Bookr.</p>
			<p>Let's look at how this can be done:</p>
			<ol>
				<li value="1">To get started with integrating the ability to visualize the reading history of the user, you first need to install the <code>plotly</code> library. To do this, run the following command in your terminal:<pre>pip install plotly</pre><p class="callout-heading">Note</p><p class="callout">You can install <code>plotly</code> and other dependencies for this exercise using the <code>requirements.txt</code> file we've provided on our GitHub repository: <a href="http://packt.live/3scIvPp">http://packt.live/3scIvPp</a>.</p></li>
				<li>Once the library is installed, the next step is to write the code that will fetch the total books read by the user as well as the books read by the user on a per-month basis. For this, create a new file named <code>utils.py</code> under the <code>bookr</code> application directory and add the required imports, which will be used to fetch the book reading history of the user from the <code>Review</code> model of the <code>reviews</code> application:<pre>import datetime
from django.db.models import Count
from reviews.models import Review</pre></li>
				<li>Next, create a new utility method named <code>get_books_read_by_month()</code>, which takes in the username of the user for whom the reading history needs to be fetched.</li>
				<li>Inside the method, we query the <code>Review</code> model and return a dictionary of books read by the user on a per-month basis:<pre>def get_books_read_by_month(username):
    """Get the books read by the user on per month basis.
    :param: str The username for which the books needs to be returned
    :return: dict of month wise books read
    """
    current_year = datetime.datetime.now().year
    books = Review.objects.filter\
            (creator__username__contains=username),\
            (date_created__year=current_year)\
            .values('date_created__month')\
            .annotate(book_count=Count('book__title'))
    return books</pre><p>Now, let's examine the following query, which is responsible for fetching the results of books read this year on a monthly basis:</p><pre>Review.objects.filter(creator__username__contains=username,date_created__year=current_year).values('date_created__month').annotate(book_count=Count('book__title'))</pre><p>This query can be broken down into the following components:</p><p><code>year</code> field can be easily accessed from our <code>date_created</code> field by appending <code>__year</code>.</p><p><code>values()</code> call to select only the <code>month</code> field from the <code>date_created</code> attribute of the <code>Review</code> model on which you are going to run the group by operation.</p><p><code>annotate</code> method to the <code>QuerySet</code> instance returned by the <code>values()</code> call.</p></li>
				<li>Once you have the utilities file in place, the next thing is to write the view function, which is going to help in showing the books-read-per-month plot on the user's profile page. For this, open the <code>views.py</code> file under the <code>bookr</code> directory and start by adding the following imports to it:<pre>from plotly.offline import plot
import plotly.graph_objects as graphs
from .utils import get_books_read_by_month</pre></li>
				<li>Once these imports are done, the next thing to do is to modify the view function that renders the profile page. Currently, the profile page is being handled by the <code>profile()</code> method inside the <code>views.py</code> file. Modify the method to resemble the one shown here:<pre>@login_required
def profile(request):
    user = request.user
    permissions = user.get_all_permissions()
    # Get the books read in different months this year
    books_read_by_month = get_books_read_by_month(user.username)
    """
    Initialize the Axis for graphs, X-Axis is months, 
    Y-axis is books read
    """
    months = [i+1 for i in range(12)]
    books_read = [0 for _ in range(12)]
    # Set the value for books read per month on Y-Axis
    for num_books_read in books_read_by_month:
        list_index = num_books_read['date_created__month'] - 1
        books_read[list_index] = num_books_read['book_count']
    # Generate a scatter plot HTML
    figure = graphs.Figure()
    scatter = graphs.Scatter(x=months, y=books_read)
    figure.add_trace(scatter)
    figure.update_layout(xaxis_title="Month"),\
                        (yaxis_title="No. of books read")
    plot_html = plot(figure, output_type='div')
    # Add to template
      return render(request, 'profile.html'),\
                   ({'user': user, 'permissions': permissions,\
                   'books_read_plot': plot_html})</pre><p>In this method, you did a couple of things. The first thing was that you called the <code>get_books_read_by_month()</code> method and provided it with the username of the currently logged-in user. This method returns the list of books read by a given user on a per-month basis in the current year:</p><pre>books_read_by_month = get_books_read_by_month(user.username)</pre><p>The next thing you did was pre-initialize the <em class="italic">X</em>-axis and <em class="italic">Y</em>-axis for the graph with some default values. For this visualization, use the <em class="italic">X</em>-axis to display months and the <em class="italic">Y</em>-axis to display the number of books read.</p><p>Now, since you already know that a year is going to have only 12 months, pre-initialize the <em class="italic">X</em>-axis with a value between <code>1</code> and <code>12</code>:</p><pre>months = [i+1 for i in range(12)]</pre><p>For the books read, initialize the <em class="italic">Y</em>-axis with all the <code>12</code> indexes set to <code>0</code> as follows:</p><pre>books_read = [0 for _ in range(12)]</pre><p>Now, with the pre-initialization done, fill in some actual values for the books read per month. For this, iterate upon the list you got as a result of the call made to <code>get_books_read_by_month(user.username)</code> and extract the month and the book count for the month from it.</p><p>Once the book count and month are extracted, the next step is to assign the <code>book_count</code> value to the <code>books_read</code> list at the month index:</p><pre>    for num_books_read in books_read_by_month:
        list_index = num_books_read['date_created__month'] - 1
        books_read[list_index] = num_books_read['book_count']</pre><p>Now, with the values for the axes set, generate a scatter plot using the <code>plotly</code> library:</p><pre>figure = graphs.Figure()
scatter = graphs.Scatter(x=months, y=books_read)
figure.add_trace(scatter)
figure.update_layout(xaxis_title="Month", \
                     yaxis_title="No. of books read")
plot_html = plot(figure, output_type='div')</pre><p>Once the HTML for the plot is generated, pass it to the template using the <code>render()</code> method such that it can be visualized on the profile page:</p><pre>return render(request, 'profile.html',
       {'user': user, 'permissions': permissions,\
        'books_read_plot': plot_html}</pre></li>
				<li>With the view function done, the next step is to modify the template to render this graph. For this, open the <code>profile.html</code> file under the <code>templates</code> directory and add the following highlighted code to the file, just before the last <code>{% endblock %}</code> statement:<pre>{% extends "base.html" %}
{% block title %}Bookr{% endblock %}
{% block heading %}Profile{% endblock %}
{% block content %}
  &lt;ul&gt;
      &lt;li&gt;Username: {{ user.username }} &lt;/li&gt;
      &lt;li&gt;Name: {{ user.first_name }} {{ user.last_name }}&lt;/li&gt;
      &lt;li&gt;Date Joined: {{ user.date_joined }} &lt;/li&gt;
      &lt;li&gt;Email: {{ user.email }}&lt;/li&gt;
      &lt;li&gt;Last Login: {{ user.last_login }}&lt;/li&gt;
      &lt;li&gt;Groups: {{ groups }}{% if not groups %}None{% endif %} &lt;/li&gt;
  &lt;/ul&gt;
<code>books_read_plot</code> variable passed in the view function to be used inside our HTML template. Also note that <code>autoescape</code> is set to off for this variable. This is required because this variable contains HTML generated by the <code>plotly</code> library and if you allow Django to escape the HTML, you will only see raw HTML in the profile page and not a graph visualization.</p><p>With this, you have successfully integrated the plot into the application.</p></li>
				<li>To try the visualization, run the following command and then navigate to your user profile by visiting <code>http://localhost:8080</code>:<pre>python manage.py runserver localhost:8080</pre><p>You should see a page that resembles the one shown next:</p><div><img src="img/B15509_13_09.jpg" alt="Figure 13.9: User book reading history scatter plot&#13;&#10;"/></div></li>
			</ol>
			<p class="figure-caption">Figure 13.9: User book reading history scatter plot</p>
			<p>In the preceding exercise, you saw how you can integrate a plotting library with Django to visualize the reading history of a user. Similarly, Django allows you to integrate any generic Python code into a web application, with the only constraint being that the data generated as a result of the integration should be transformed into a valid HTTP response that can be handled by any standard HTTP-compatible tool, such as a web browser or command-line tools such as CURL.</p>
			<h2 id="_idParaDest-389"><a id="_idTextAnchor406"/>Activity 13.01: Exporting the Books Read by a User as an XLSLX File</h2>
			<p>In this activity, you will implement a new API endpoint inside Bookr that will allow your users to export and download a list of books they have read as an XLSX file:</p>
			<ol>
				<li value="1">Install the <code>XlsxWriter</code> library.</li>
				<li>Inside the <code>utils.py</code> file created under the <code>bookr</code> application, create a new function that will help in fetching the list of books that have been read by the user.</li>
				<li>Inside the <code>views.py</code> file under the <code>bookr</code> directory, create a new view function that will allow the user to download their reading history in the XLSX file format.</li>
				<li>To create an XLSX file inside the view function, first create a <code>BytesIO</code>-based in-memory file that can be used to store the data from the <code>XlsxWriter</code> library.</li>
				<li>Read the data stored inside the in-memory file using the <code>getvalue()</code> method of the temporary file object.</li>
				<li>Finally, create a new <code>HttpResponse</code> instance with the <code>'application/vnd.ms-excel'</code> content type header, and then write the data obtained in step 5 to the response object.</li>
				<li>With the response object prepared, return the response object from the view function.</li>
				<li>With the view function ready, map it to a URL endpoint that can be visited by a user to download their book reading history.</li>
			</ol>
			<p>Once you have the URL endpoint mapped, start the application and log in to it with your user account. Once done, visit the URL endpoint you just created, and if upon visiting the URL endpoint your browser starts to download an Excel file, you have successfully completed the activity.</p>
			<p class="callout-heading">Note</p>
			<p class="callout">The solution to this activity can be found at <a href="http://packt.live/2Nh1NTJ">http://packt.live/2Nh1NTJ</a>.</p>
			<h1 id="_idParaDest-390"><a id="_idTextAnchor407"/>Summary</h1>
			<p>In this chapter, we looked at how we can deal with binary files and how Python's standard library, which comes pre-loaded with the necessary tools, can allow us to handle commonly used file formats such as CSV. We then moved on to learning how to read and write CSV files in Python using Python's CSV module. Later, we worked with the <code>XlsxWriter</code> package, which provides us with the ability to generate Microsoft Excel-compatible files right from our Python environment without worrying about the internal formatting of the file.</p>
			<p>The second half of the chapter was dedicated to learning how to use the <code>weasyprint</code> library to generate PDF versions of HTML pages. This skill can come in handy when we want to provide our users with an easy option to print the HTML version of our page with any added CSS styling of our choosing. The last section of the chapter discussed how we can generate interactive graphs in Python and render them as HTML pages that can be viewed inside the browser using the <code>plotly</code> library.</p>
			<p>In the next chapter, we will look at how we can test the different components we have been implementing in the previous chapters to make sure that code changes do not break our website's functionality.</p>
		</div>
		<div><div></div>
		</div>
	</body></html>