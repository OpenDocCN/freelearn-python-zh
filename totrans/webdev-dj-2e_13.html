<html><head></head><body>
		<div>
			<div id="_idContainer387" class="Content">
			</div>
		</div>
		<div id="_idContainer388" class="Content">
			<h1 id="_idParaDest-358"><a id="_idTextAnchor375"/>13. Generating CSV, PDF, and Other Binary Files</h1>
		</div>
		<div id="_idContainer398" class="Content">
			<p class="callout-heading">Overview</p>
			<p class="callout">This chapter teaches you how to generate files in different data formats, such as <strong class="bold">CSV</strong>, <strong class="bold">PDF</strong>, and other binary file formats (for example, Excel-compatible files) using some of the common libraries that are available inside Python. This knowledge will help you build web projects that let your users export and download records from your site into familiar CSV or Excel-based formats. You will also learn how to generate graph plots inside Python and render them as HTML and display them inside your web applications. Moreover, you will be able to build features that let users export your data in PDF format.</p>
			<h1 id="_idParaDest-359"><a id="_idTextAnchor376"/>Introduction</h1>
			<p>So far, we have learned the various aspects of the Django framework and explored how we can build web applications using Django with all the features and customizations we want.</p>
			<p>Let's say that while building a web application, we need to do some analysis and prepare some reports. We may need to analyze user demographics about how the platform is being used or generate data that can be fed into machine learning systems to find patterns. We want our website to display some of the results of our analysis in a tabular format and other results as detailed graphs and charts. Furthermore, we also want to allow our users to export the reports and peruse them further in applications such as Jupyter Notebook and Excel.</p>
			<p>As we work our way through this chapter, we will learn how to bring these ideas to fruition and implement functionality in our web application that allows us to export records into structured formats such as tables through the use of <strong class="bold">Comma-Separated Value</strong> (<strong class="bold">CSV</strong>) files or Excel files. We will also learn how to allow our users to generate visual representations of the data we have stored inside our web application and export it as PDF so it can be distributed easily for quick reference.</p>
			<p>Let's start our journey by learning how to work with CSV files in Python. Learning this skill will help us create functionality that allows our readers to export our data for further analysis.</p>
			<h2 id="_idParaDest-360"><a id="_idTextAnchor377"/>Working with CSV Files inside Python</h2>
			<p>There are several reasons we may need to export the data in our application. One of the reasons may involve performing analysis of that data – for example, we may need to understand the demographics of users registered on the application or extract patterns of application usage. We may also need to find out how our application is working for users to design future improvements. Such use cases require data to be in a format that can be easily consumed and analyzed. Here, the CSV file format comes to the rescue. </p>
			<p>CSV is a handy file format that can be used to quickly export data from an application in a row-and-column format. CSV files usually have data separated by simple delimiters, which are used to differentiate one column from another, and newlines, which are used to indicate the start of a new record (or row) inside the table.</p>
			<p>Python has great support for working with CSV files in its standard library thanks to the <strong class="source-inline">csv</strong> module. This support enables the reading, parsing, and writing of CSV files. Let's take a look at how we can leverage the CSV module provided by Python to work on CSV files and read and write data from them.</p>
			<h1 id="_idParaDest-361"><a id="_idTextAnchor378"/>Working with Python's CSV Module</h1>
			<p>The <strong class="source-inline">csv</strong> module from Python provides us with the ability to interact with files that are in CSV format, which is nothing but a text file format. That is, the data stored inside the CSV files is human-readable.</p>
			<p>The <strong class="source-inline">csv</strong> module requires that the file is opened before the methods supplied by the <strong class="source-inline">csv</strong> module can be applied. Let's take a look at how we can start with the very basic operation of reading data from CSV files.</p>
			<h2 id="_idParaDest-362"><a id="_idTextAnchor379"/>Reading Data from a CSV File</h2>
			<p>Reading data from CSV files is quite easy and consists of the following steps:</p>
			<ol>
				<li>First, we open the file:<p class="source-code">csv_file = open('path to csv file')</p><p>Here, we are reading the file using the Python <strong class="source-inline">open()</strong> method and then passing it the name of the file from which the data is to be read.</p></li>
				<li>Then, we read the data from the <strong class="source-inline">file</strong> object using the <strong class="source-inline">csv</strong> module's <strong class="source-inline">reader</strong> method:<p class="source-code">import csv</p><p class="source-code">csv_data = csv.reader(csv_file)</p><p>In the first line, we imported the <strong class="source-inline">csv</strong> module, which contains the set of methods required to work on CSV files:</p><p class="source-code">import csv</p><p>With the file opened, the next step is to create a CSV <strong class="source-inline">reader</strong> object by using the <strong class="source-inline">csv</strong> module's <strong class="source-inline">reader</strong> method. This method takes in the <strong class="source-inline">file</strong> object as returned by the <strong class="source-inline">open()</strong> call and uses the <strong class="source-inline">file</strong> object to read the data from the CSV file:</p><p class="source-code">csv_reader = csv.reader(csv_file)</p><p>The data read by the <strong class="source-inline">reader()</strong> method is returned as a list of a list, where every sub-list is a new record and every value inside the list is a value for the specified column. Generally, the first record in the list is referred to as a header, which denotes the different columns that are present inside the CSV file, but it is not necessary to have a <strong class="source-inline">header</strong> field inside a CSV file.</p></li>
				<li>Once the data is read by the <strong class="source-inline">csv</strong> module, we can iterate over this data to perform any kind of operation we may desire. This can be done as follows:<p class="source-code">for csv_record in csv_data:</p><p class="source-code">    # do something</p></li>
				<li>Once the processing is done, we close the CSV file simply by using the <strong class="source-inline">close()</strong> method in Python's file handler object:<p class="source-code">csv_file.close()</p></li>
			</ol>
			<p>Now let's look at our first exercise, where we will implement a simple module that helps us read a CSV file and output its contents on our screen.</p>
			<h2 id="_idParaDest-363"><a id="_idTextAnchor380"/>Exercise 13.01: Reading a CSV File with Python</h2>
			<p>In this exercise, you will read and process a CSV file inside Python using Python's built-in <strong class="source-inline">csv</strong> module. The CSV file contains fictitious market data of several NASDAQ-listed companies:</p>
			<ol>
				<li value="1">First, download the <strong class="source-inline">market_cap.csv</strong> file from the GitHub repository for this book by clicking the following link: <a href="http://packt.live/2MNWzOV">http://packt.live/2MNWzOV</a>.<p class="callout-heading">Note</p><p class="callout">The CSV file consists of randomly generated data and does not correspond to any historical market trends. </p></li>
				<li>Once the file is downloaded, open it and take a look at its contents. You will realize that the file contains a set of comma-separated values with each different record on its own line:<div id="_idContainer389" class="IMG---Figure"><img src="image/B15509_13_01.jpg" alt="Figure 13.1: Contents of the market cap CSV file&#13;&#10;"/></div><p class="figure-caption">Figure 13.1: Contents of the market cap CSV file</p></li>
				<li>Once the file is downloaded, you can proceed to write the first piece of code. For this, create a new file named <strong class="source-inline">csv_reader.py</strong> in the same directory where the CSV file was downloaded and add the following code inside it:<p class="source-code">import csv</p><p class="source-code">def read_csv(filename):</p><p class="source-code">    """Read and output the details of CSV file."""</p><p class="source-code">    try:</p><p class="source-code">       with open(filename, newline='') as csv_file:</p><p class="source-code">           csv_reader = csv.reader(csv_file)</p><p class="source-code">           for record in csv_reader:</p><p class="source-code">               print(record)</p><p class="source-code">    except (IOError, OSError) as file_read_error:</p><p class="source-code">       print("Unable to open the csv file. Exception: {}".format(file_read_error))</p><p class="source-code">if __name__ == '__main__':</p><p class="source-code">    read_csv('market_cap.csv')</p><p>Let's try to understand what you just implemented in the preceding snippet of code.</p><p>After importing the <strong class="source-inline">csv</strong> module, to keep the code modular, you created a new method named <strong class="source-inline">read_csv()</strong> that takes in a single parameter, the filename to read the data from:</p><p class="source-code">try:</p><p class="source-code">       with open(filename, newline='') as csv_file:</p><p>Now, if you are not familiar with the approach of opening the file shown in the preceding snippet, this is also known as the <strong class="bold">try-with-resources</strong> approach. In this case, any block of code that is encapsulated in the scope of the <strong class="source-inline">with</strong> block will have access to the <strong class="source-inline">file</strong> object, and once the code exits the scope of the <strong class="source-inline">with</strong> block, the file will be closed automatically.</p><p class="callout-heading">Note</p><p class="callout">It is a good habit to encapsulate file I/O operations within a <strong class="source-inline">try-except</strong> block, since file I/O can fail for several reasons and showing stack traces to the users is not a good option.</p><p>The <strong class="source-inline">reader()</strong> method returns a <strong class="source-inline">reader</strong> object over which we can iterate to access the values just like we saw in the <em class="italic">Reading Data from a CSV File</em> section:</p><p class="source-code">for record in csv_reader:</p><p class="source-code">    print(record)</p><p>Once this is done, you write the entry point method, from which your code will begin executing, by calling the <strong class="source-inline">read_csv()</strong> method and passing the name of the CSV file to read:</p><p class="source-code">if __name__ == '__main__':</p><p class="source-code">    read_csv(market_cap.csv')</p></li>
				<li>With this, you are done and ready to parse your CSV file now. You can do this by running your Python file in the Terminal or Command Prompt as shown here:<p class="source-code">python3 csv_reader.py</p><p class="callout-heading">Note</p><p class="callout">Or, on Windows, use <strong class="bold">python csv_reader.py</strong> as shown in <em class="italic">Figure 13.2</em>.</p><p>Once the code executes, you should expect to see the following output:</p><div id="_idContainer390" class="IMG---Figure"><img src="image/B15509_13_02.jpg" alt="Figure 13.2: Output from the CSV reader program&#13;&#10;"/></div></li>
			</ol>
			<p class="figure-caption">Figure 13.2: Output from the CSV reader program</p>
			<p>With this, now you know how to read CSV file contents. Also, as you can see from the output of <em class="italic">Exercise 13.01</em>, <em class="italic">Reading a CSV File with Python</em>, the output for individual rows is represented in the form of a list.</p>
			<p>Now, let's look at how we can use the Python <strong class="source-inline">csv</strong> module to create new CSV files.</p>
			<h2 id="_idParaDest-364"><a id="_idTextAnchor381"/>Writing to CSV Files Using Python</h2>
			<p>In the previous section, we explored how we can use the <strong class="source-inline">csv</strong> module in Python to read the contents of the CSV-formatted files. Now, let us learn how we can write CSV data to files.</p>
			<p>Writing CSV data follows a similar approach as reading from a CSV file, with some minor differences. The following steps outline the process of writing data to CSV files:</p>
			<ol>
				<li value="1">Open the file in writing mode:<p class="source-code">csv_file = open('path to csv file', 'w')</p></li>
				<li>Obtain a CSV writer object, which can help us write data that is correctly formatted in the CSV format. This is done by calling the <strong class="source-inline">writer()</strong> method of the <strong class="source-inline">csv</strong> module, which returns a <strong class="source-inline">writer</strong> object, which can be used to write CSV format-compatible data to a CSV file:<p class="source-code">csv_writer = csv.writer(csv_file)</p></li>
				<li>Once the <strong class="source-inline">writer</strong> object is available, we can start writing the data. This is facilitated by the <strong class="source-inline">write_row()</strong> method of the <strong class="source-inline">writer</strong> object. The <strong class="source-inline">write_row()</strong> method takes in a list of values that it writes to the CSV file. The list itself indicates a single row and the values inside the list indicate the values of columns:<p class="source-code">record = ['value1', 'value2', 'value3']</p><p class="source-code">csv_writer.writerow(record)</p><p>If you want to write multiple records in a single call, you can also use the <strong class="source-inline">writerows()</strong> method of the CSV writer. The <strong class="source-inline">writerows()</strong> method behaves similarly to the <strong class="source-inline">writerow()</strong> method but takes a list of lists and can write multiple rows in one go:</p><p class="source-code">records = [['value11', 'value12', 'value13'],\</p><p class="source-code">           ['value21', 'value22', 'value23']]</p><p class="source-code">csv_writer.writerows(records)</p></li>
				<li>Once the records are written, we can then close the CSV file:<p class="source-code">csv_file.close()</p></li>
			</ol>
			<p>Now, let's apply what we've learned in the next exercise and implement a program that will help us in writing values to CSV files.</p>
			<h2 id="_idParaDest-365"><a id="_idTextAnchor382"/>Exercise 13.02: Generating a CSV File Using Python's csv Module</h2>
			<p>In this exercise, you will use the Python <strong class="source-inline">csv</strong> module to create new CSV files:</p>
			<ol>
				<li value="1">Create a new file named <strong class="source-inline">csv_writer.py</strong>, inside which you will write the code for the CSV writer. Inside this file, add the following code:<p class="source-code">import csv</p><p class="source-code">def write_csv(filename, header, data):</p><p class="source-code">    """Write the provided data to the CSV file.</p><p class="source-code">    :param str filename: The name of the file \</p><p class="source-code">        to which the data should be written</p><p class="source-code">    :param list header: The header for the \</p><p class="source-code">        columns in csv file</p><p class="source-code">    :param list data: The list of list mapping \</p><p class="source-code">        the values to the columns</p><p class="source-code">    """</p><p class="source-code">    try:</p><p class="source-code">        with open(filename, 'w') as csv_file:</p><p class="source-code">            csv_writer = csv.writer(csv_file)</p><p class="source-code">            csv_writer.writerow(header)</p><p class="source-code">            csv_writer.writerows(data)</p><p class="source-code">    except (IOError, OSError) as csv_file_error:</p><p class="source-code">        print\</p><p class="source-code">        ("Unable to write the contents to csv file. Exception: {}"\</p><p class="source-code">         .format(csv_file_error))</p><p>With this code, you should now be able to create new CSV files easily. Now, going step by step, let's understand what you are trying to do in this code:</p><p>You define a new method called <strong class="source-inline">write_csv()</strong>, which takes three parameters: the name of the file to which the data should be written (<strong class="source-inline">filename</strong>), the list of column names that should be used as headers (<strong class="source-inline">header</strong>), and lastly a list of a list that contains the data that needs to be mapped to individual columns (<strong class="source-inline">data</strong>):</p><p class="source-code"> def write_csv(filename, header, data):</p><p>Now, with the parameters in place, the next step is to open the file to which the data needs to be written and map it to an object:</p><p class="source-code">with open(filename, 'w') as csv_file:</p><p>Once the file is opened, you perform three main steps: first, obtain a new CSV writer object by using the <strong class="source-inline">writer()</strong> method from the <strong class="source-inline">csv</strong> module and passing it to the file handler that holds a reference to your opened file:</p><p class="source-code">csv_writer = csv.writer(csv_file)</p><p>The next step involves using the CSV writer's <strong class="source-inline">writerow()</strong> method to write your dataset's header fields into the file:</p><p class="source-code">csv_writer.writerow(header)</p><p>Once you have written the header, the last step is to write the data to the CSV file for the individual columns that are present. For this, use the <strong class="source-inline">csv</strong> module's <strong class="source-inline">writerows()</strong> method to write multiple rows at once:</p><p class="source-code">csv_writer.writerows(data)</p><p class="callout-heading">Note</p><p class="callout">We could also have merged the step of writing the header and data into a single line of code by having the header list as the first element of the data list and calling the <strong class="source-inline">writerows()</strong> method with the data list as a parameter.</p></li>
				<li>When you have created the methods that can write the provided data to a CSV file, you write the code for the entry point call, and inside it, set up the values for the header, data, and filename fields, and finally call the <strong class="source-inline">write_csv()</strong> method that you defined earlier:<p class="source-code">if __name__ == '__main__':</p><p class="source-code">    header = ['name', 'age', 'gender']</p><p class="source-code">    data = [['Richard', 32, 'M'], \</p><p class="source-code">            ['Mumzil', 21, 'F'], \</p><p class="source-code">            ['Melinda', 25, 'F']]</p><p class="source-code">    filename = 'sample_output.csv'</p><p class="source-code">    write_csv(filename, header, data)</p></li>
				<li>Now with the code in place, execute the file you just created and see whether it creates the CSV file. To execute, run the following command:<p class="source-code">python3 csv_writer.py</p><p>Once the execution finishes, you will see that a new file has been created in the same directory as the one in which you executed the command. When you open the file, the contents should resemble what you see in the following figure:</p><div id="_idContainer391" class="IMG---Figure"><img src="image/B15509_13_03.jpg" alt="Figure 13.3: Output from the CSV writer sample_output.csv&#13;&#10;"/></div></li>
			</ol>
			<p class="figure-caption">Figure 13.3: Output from the CSV writer sample_output.csv</p>
			<p>With this, now you are well equipped to read and write the contents of CSV files.</p>
			<p>With this exercise, we have learned how to write data to a CSV file. Now, it is time to look at some enhancements that can make reading and writing data to CSV files as a developer more convenient.</p>
			<h2 id="_idParaDest-366"><a id="_idTextAnchor383"/>A Better Way to Read and Write CSV Files</h2>
			<p>Now, there is one important thing that needs to be taken care of. If you remember, the data read by the CSV reader usually maps values to a list. Now, if you want to access the values of individual columns, you need to use list indexes to access them. This way is not natural and causes a higher degree of coupling between the program responsible for writing the file and the one responsible for reading the file. For example, what if the writer program shuffled the order of the rows? In this case, you now have to update the reader program to make sure it identifies correct rows. So, the question arises, do we have a better way to read and write values that, instead of using list indexes, uses column names while preserving the context?</p>
			<p>The answer to this is yes, and the solution is provided by another set of CSV modules known as <strong class="source-inline">DictReader</strong> and <strong class="source-inline">DictWriter</strong>, which provide the functionality of mapping objects in a CSV file to <strong class="source-inline">dict</strong>, rather than to a list.</p>
			<p>This interface is easy to implement. Let's revisit the code you wrote in <em class="italic">Exercise 13.01</em>, <em class="italic">Reading a CSV File with Python</em>. If you wanted to parse the code as dict, the implementation of the <strong class="source-inline">read_csv()</strong> method would need to be changed as shown here:</p>
			<p class="source-code">def read_csv(filename):</p>
			<p class="source-code">    """Read and output the details of CSV file."""</p>
			<p class="source-code">    try:</p>
			<p class="source-code">       with open(filename, newline='') as csv_file:</p>
			<p class="source-code">           csv_reader = <strong class="bold">csv.DictReader</strong>(csv_file)</p>
			<p class="source-code">           for record in csv_reader:</p>
			<p class="source-code">               print(record)</p>
			<p class="source-code">    except (IOError, OSError) as file_read_error:</p>
			<p class="source-code">        print\</p>
			<p class="source-code">        ("Unable to open the csv file. Exception: {}"\</p>
			<p class="source-code">        .format(file_read_error))</p>
			<p>As you will notice, the only change we did was to change <strong class="source-inline">csv.reader()</strong> to <strong class="source-inline">csv.DictReader()</strong>, which should represent individual rows in the CSV file as <strong class="source-inline">OrderedDict</strong>. You can also verify this by making this change and executing the following command:</p>
			<p class="source-code">python3 csv_reader.py</p>
			<p>This should result in the following output:</p>
			<div>
				<div id="_idContainer392" class="IMG---Figure">
					<img src="image/B15509_13_04.jpg" alt="Figure 13.4: Output with DictReader&#13;&#10;"/>
				</div>
			</div>
			<p class="figure-caption">Figure 13.4: Output with DictReader</p>
			<p>As you can see in the preceding figure, the individual rows are mapped as key-value pairs in the dictionary. To access these individual fields in rows, we can use this:</p>
			<p class="source-code">print(record.get('stock_symbol'))</p>
			<p>That should give us the value of the <strong class="source-inline">stock_symbol</strong> field from our individual records.</p>
			<p>Similarly, you can also use the <strong class="source-inline">DictWriter()</strong> interface to operate on CSV files as dictionaries. To see this, let's take a look at the <strong class="source-inline">write_csv()</strong> method in <em class="italic">Exercise 13.02</em>, <em class="italic">Generating a CSV File Using Python's csv Module</em>, and modify it as follows:</p>
			<p class="source-code">def write_csv(filename, header, data):</p>
			<p class="source-code">    """Write the provided data to the CSV file.</p>
			<p class="source-code">    :param str filename: The name of the file \</p>
			<p class="source-code">        to which the data should be written</p>
			<p class="source-code">    :param list header: The header for the \</p>
			<p class="source-code">        columns in csv file</p>
			<p class="source-code">    :param list data: The list of dicts mapping \</p>
			<p class="source-code">        the values to the columns</p>
			<p class="source-code">    """</p>
			<p class="source-code">    try:</p>
			<p class="source-code">        with open(filename, 'w') as csv_file:</p>
			<p class="source-code">            csv_writer = <strong class="bold">csv</strong>.<strong class="bold">DictWriter</strong>(csv_file, <strong class="bold">fieldnames=header</strong>)</p>
			<p class="source-code">            csv_writer.writeheader()</p>
			<p class="source-code">            csv_writer.writerows(data)</p>
			<p class="source-code">    except (IOError, OSError) as csv_file_error:</p>
			<p class="source-code">        print\</p>
			<p class="source-code">        ("Unable to write the contents to csv file. Exception: {}"\</p>
			<p class="source-code">        .format(csv_file_error))</p>
			<p>In the preceding code, we replaced <strong class="source-inline">csv.writer()</strong> with <strong class="source-inline">csv.DictWriter()</strong>, which provides a dictionary-like interface to interact with CSV files. <strong class="source-inline">DictWriter()</strong> also takes in a <strong class="source-inline">fieldnames</strong> parameter, which is used to map the individual columns in a CSV file before writing.</p>
			<p>Next, to write this header, call the <strong class="source-inline">writeheader()</strong> method, which writes the <strong class="source-inline">fieldname</strong> header to the CSV file.</p>
			<p>The final call involves the <strong class="source-inline">writerows()</strong> method, which takes in a list of dictionaries and writes them to the CSV file. For the code to work correctly, you also need to modify the data list to resemble the one shown here:</p>
			<p class="source-code">data = [{'name': Richard, 'age': 32, 'gender': 'M'}, \</p>
			<p class="source-code">        {'name': Mumzil', 'age': 21, 'gender':'F'}, \</p>
			<p class="source-code">        {'name': 'Melinda', 'age': 25, 'gender': 'F'}]</p>
			<p>With this, you will have enough knowledge to work with CSV files inside Python.</p>
			<p>Since we are talking about how to deal with tabular data, specifically reading and writing it to files, let's take a look at one of the more well-known file formats used by one of the most popular tabular data editors – Microsoft Excel.</p>
			<h1 id="_idParaDest-367"><a id="_idTextAnchor384"/>Working with Excel Files in Python</h1>
			<p>Microsoft Excel is a world-renowned software in the field of book-keeping and tabular record management. Similarly, the XLSX file format that was introduced with Excel has seen rapid and widespread adoption and is now supported by all the major product vendors.</p>
			<p>You will find that Microsoft Excel and its XLSX format are used quite a lot in the marketing and sales departments of many companies. Let's say, for one such company's marketing department, you are building a web portal in Django that keeps track of the products purchased by users. It also displays data about the purchases, such as the time of purchase and the location where the purchase was made. The marketing and sales teams are planning to use this data to generate leads or to create relevant advertisements.</p>
			<p>Since the marketing and sales teams use Excel quite a lot, we might want to export the data available inside our web application in XLSX format, which is native to Excel. Soon, we will look at how we can make our website work with this XLSX format. But before that, let's quickly take a look at the usage of binary file formats.</p>
			<h2 id="_idParaDest-368"><a id="_idTextAnchor385"/>Binary File Formats for Data Exports</h2>
			<p>Until now, we have worked mainly with textual data and how we can read and write it from text files. But often, text-based formats are not enough. For example, imagine you want to export an image or a graph. How will you represent an image or a graph as text, and how will you read and write to these images?</p>
			<p>In these situations, binary file formats can come to our rescue. They can help us read and write to and from a rich and diverse set of data. All commercial operating systems provide native support for working with both text and binary file formats, and it comes as no surprise that Python provides one of the most versatile implementations to work on binary data files. A simple example of this is the <strong class="source-inline">open</strong> command, which you use to state the format you would like to open a file in:</p>
			<p class="source-code">file_handler = open('path to file', 'r<strong class="bold">b</strong>')</p>
			<p>Here, <strong class="source-inline">b</strong> indicates binary.</p>
			<p>Starting from this section, we will now be dealing with how we can work on binary files and use them to represent and export data from our Django web application. The first of the formats we are going to look at is the XLSX file format made popular by Microsoft Excel.</p>
			<p>So, let's dive into the handling of XLSX files with Python.</p>
			<h2 id="_idParaDest-369"><a id="_idTextAnchor386"/>Working with XLSX Files Using the XlsxWriter Package</h2>
			<p>In this section, we will learn more about the XLSX file format and understand how we can work with it using the <strong class="bold">XlsxWriter</strong> package.</p>
			<h3 id="_idParaDest-370"><a id="_idTextAnchor387"/>XLSX Files</h3>
			<p>XLSX files are binary files that are used to store tabular data. These files can be read by any software that implements support for this format. The XLSX format arranges data into two logical partitions:</p>
			<ul>
				<li><strong class="bold">Workbooks</strong>: Each XLSX file is called a workbook and is supposed to contain datasets related to a particular domain. In <em class="italic">Figure 13.5</em>, <strong class="source-inline">Example_file.xlsx</strong> is a workbook <strong class="bold">(1)</strong>:<div id="_idContainer393" class="IMG---Figure"><img src="image/B15509_13_05.jpg" alt="Figure 13.5: Workbooks and Worksheets in Excel&#13;&#10;"/></div></li>
			</ul>
			<p class="figure-caption">Figure 13.5: Workbooks and Worksheets in Excel</p>
			<ul>
				<li><strong class="bold">Worksheets</strong>: Inside each workbook, there can be one or more worksheets, which are used to store data about different but logically related datasets in a tabular format. In <em class="italic">Figure 13.5</em>, <strong class="source-inline">Sheet1</strong> and <strong class="source-inline">Sheet2</strong> are two worksheets <strong class="bold">(2)</strong>. </li>
			</ul>
			<p>When working with XLSX format, these are the two units that we generally work on. If you know about relational databases, you can think of workbooks as databases and worksheets as tables.</p>
			<p>With that, let's try to understand how we can start working on XLSX files inside Python.</p>
			<h3 id="_idParaDest-371"><a id="_idTextAnchor388"/>The XlsxWriter Python Package</h3>
			<p>Python does not provide native support for working with XLSX files through its standard library. But thanks to the vast community of developers within the Python ecosystem, it is easy to find a number of packages that can help us manage our interaction with XLSX files. One popular package in this category is <strong class="bold">XlsxWriter</strong>.</p>
			<p><strong class="source-inline">XlsxWriter</strong> is an actively maintained package by the developer community, providing support for interacting with XLSX files. The package provides a lot of useful functionalities and supports the creation and management of workbooks as well as worksheets in individual workbooks. You can install it by running the following command in Terminal or Command Prompt:</p>
			<p class="source-code">pip install XlsxWriter</p>
			<p>Once installed, you can import the <strong class="source-inline">xlsxwriter</strong> module as follows:</p>
			<p class="source-code">import xlsxwriter</p>
			<p>So, let's look at how we can start creating XLSX files with the support of the <strong class="source-inline">XlsxWriter</strong> package.</p>
			<h3 id="_idParaDest-372"><a id="_idTextAnchor389"/>Creating a Workbook</h3>
			<p>To start working on XLSX files, we first need to create them. An XLSX file is also known as a workbook and can be created by calling the <strong class="source-inline">Workbook</strong> class from the <strong class="source-inline">xlsxwriter</strong> module as follows:</p>
			<p class="source-code">workbook = xlsxwriter.Workbook(filename)</p>
			<p>The call to the <strong class="source-inline">Workbook</strong> class opens a binary file, specified with the <strong class="source-inline">filename</strong> argument, and returns an instance of <strong class="source-inline">workbook</strong> that can be used to further create worksheets and write data.</p>
			<h3 id="_idParaDest-373"><a id="_idTextAnchor390"/>Creating a Worksheet</h3>
			<p>Before we can start writing data to an XLSX file, we first need to create a worksheet. This can be done easily by calling the <strong class="source-inline">add_worksheet()</strong> method of the <strong class="source-inline">workbook</strong> object we obtained in the previous step:</p>
			<p class="source-code">worksheet = workbook.add_worksheet()</p>
			<p>The <strong class="source-inline">add_worksheet()</strong> method creates a new worksheet, adds it to the workbook, and returns an object mapping the worksheet to a Python object, through which we can write data to the worksheet.</p>
			<h3 id="_idParaDest-374"><a id="_idTextAnchor391"/>Writing Data to the Worksheet</h3>
			<p>Once a reference to the worksheet is available, we can start writing data to it by calling the <strong class="source-inline">write</strong> method of the <strong class="source-inline">worksheet</strong> object as shown:</p>
			<p class="source-code">worksheet.write(row_num, col_num, col_value)</p>
			<p>As you can see, the <strong class="source-inline">write()</strong> method takes three parameters: a row number (<strong class="source-inline">row_num</strong>), a column number (<strong class="source-inline">col_num</strong>), and the data that belongs to the [<strong class="source-inline">row_num, col_num</strong>] pair as represented by <strong class="source-inline">col_value</strong>. This call can be repeated to insert multiple data items into the worksheet.</p>
			<h3 id="_idParaDest-375"><a id="_idTextAnchor392"/>Writing the Data to the Workbook</h3>
			<p>Once all the data is written, to finalize the written datasets and cleanly close the XLSX file, you call the <strong class="source-inline">close()</strong> method on the workbook:</p>
			<p class="source-code">workbook.close()</p>
			<p>This method writes any data that may be in the file buffer and finally closes the workbook. Now, let's use this knowledge to implement our own code, which will help us write data to an XLSX file.</p>
			<p class="callout-heading">Further Reading</p>
			<p class="callout">It's not possible to cover all the methods and features the <strong class="source-inline">XlsxWriter</strong> package provides in this chapter. For more information, you can read the official documentation: <a href="https://xlsxwriter.readthedocs.io/contents.html">https://xlsxwriter.readthedocs.io/contents.html</a>.</p>
			<h2 id="_idParaDest-376"><a id="_idTextAnchor393"/>Exercise 13.03: Creating XLSX Files in Python</h2>
			<p>In this exercise, you will use the <strong class="source-inline">XlsxWriter</strong> package to create a new Excel (XLSX) file and add data to it from Python:</p>
			<ol>
				<li value="1">For this exercise, you will need the <strong class="source-inline">XlsxWriter</strong> package installed on your system. You can install it by running the following command in your Terminal app or Command Prompt:<p class="source-code">pip install XlsxWriter</p><p>Once the command finishes, you will have the package installed on your system.</p></li>
				<li>With the package installed, you can start writing the code that will create the Excel file. Create a new file named <strong class="source-inline">xlsx_demo.py</strong> and add the following code inside it:<p class="source-code">import xlsxwriter</p><p class="source-code">def create_workbook(filename):</p><p class="source-code">    """Create a new workbook on which we can work."""</p><p class="source-code">    workbook = xlsxwriter.Workbook(filename)</p><p class="source-code">    return workbook</p><p>In the preceding code snippet, you have created a new function that will assist you in creating a new workbook in which you can store your data. Once you have created a new workbook, the next step is to create a worksheet that provides you with the tabular format needed for you to organize the data to be stored inside the XLSX workbook.</p></li>
				<li>With the workbook created, create a new worksheet by adding the following code snippet to your <strong class="source-inline">xlsx_demo.py</strong> file:<p class="source-code">def create_worksheet(workbook):</p><p class="source-code">    """Add a new worksheet in the workbook."""</p><p class="source-code">    worksheet = workbook.add_worksheet()</p><p class="source-code">    return worksheet</p><p>In the preceding code snippet, you have created a new worksheet using the <strong class="source-inline">add_worksheet()</strong> method of the <strong class="source-inline">workbook</strong> object provided by the <strong class="source-inline">XlsxWriter</strong> package. This worksheet will then be used to write the data for the objects.</p></li>
				<li>The next step is to create a helper function that can assist in writing the data to the worksheet in a tabular format defined by the row and column numbering. For this, add the following snippet of code to your <strong class="source-inline">xlsx_writer.py</strong> file:<p class="source-code">def write_data(worksheet, data):</p><p class="source-code">    """Write data to the worksheet."""</p><p class="source-code">    for row in range(len(data)):</p><p class="source-code">        for col in range(len(data[row])):</p><p class="source-code">            worksheet.write(row, col, data[row][col])</p><p>In the preceding code snippet, you have created a new function named <strong class="source-inline">write_data()</strong> that takes two parameters: the <strong class="source-inline">worksheet</strong> object to which the data needs to be written and the <strong class="source-inline">data</strong> object represented by a list of lists that needs to be written to the worksheet. The function iterates over the data passed to it and then writes the data to the row and column it belongs to.</p></li>
				<li>With all the core methods now implemented, you can now add the method that can help close the <strong class="source-inline">workbook</strong> object cleanly, such that the data is written to the file without any file corruption happening. For this, implement the following code snippet in the <strong class="source-inline">xlsx_demo.py</strong> file:<p class="source-code">def close_workbook(workbook):</p><p class="source-code">    """Close an opened workbook."""</p><p class="source-code">    workbook.close()</p></li>
				<li>The last step in the exercise is to integrate all the methods you have implemented in the previous steps. For this, create a new entry point method as shown in the following code snippet in your <strong class="source-inline">xlsx_demo.py</strong> file:<p class="source-code">if __name__ == '__main__':</p><p class="source-code">    data = [['John Doe', 38], \</p><p class="source-code">            ['Adam Cuvver', 22], \</p><p class="source-code">            ['Stacy Martin', 28], \</p><p class="source-code">            ['Tom Harris', 42]]</p><p class="source-code">    workbook = create_workbook('sample_workbook.xlsx')</p><p class="source-code">    worksheet = create_worksheet(workbook)</p><p class="source-code">    write_data(worksheet, data)</p><p class="source-code">    close_workbook(workbook)</p><p>In the preceding code snippet, you first created a dataset that you want to write to the XLSX file in the form of a list of lists. Once that was done, you obtained a new <strong class="source-inline">workbook</strong> object, which will be used to create an XLSX file. Inside this <strong class="source-inline">workbook</strong> object, you then created a worksheet to organize your data in a row-and-column format and then wrote the data to the worksheet and closed the workbook to persist the data to the disk.</p></li>
				<li>Now, let's see whether the code you wrote works the way it is expected to work. For this, run the following command:<p class="source-code">python3 xlsx_demo.py</p><p>Once the command is finished executing, you will see a new file with the name <strong class="source-inline">sample_workbook.xlsx</strong> being created in the directory where the command was executed. To verify whether it contains the correct results, open this file with either Microsoft Excel or Google Sheets and view the contents. It should resemble what you see here:</p><div id="_idContainer394" class="IMG---Figure"><img src="image/B15509_13_06.jpg" alt="Figure 13.6: Excel sheet generated using xlsxwriter&#13;&#10;"/></div></li>
			</ol>
			<p class="figure-caption">Figure 13.6: Excel sheet generated using xlsxwriter</p>
			<p>With the help of the <strong class="source-inline">xlsxwriter</strong> module, you can also apply formulas to your columns. For example, if you wanted to add another row that shows the average age of the people in the spreadsheet, you can do that simply by modifying the <strong class="source-inline">write_data()</strong> method as shown here:</p>
			<p class="source-code">def write_data(worksheet, data):</p>
			<p class="source-code">    """Write data to the worksheet."""</p>
			<p class="source-code">    for row in range(len(data)):</p>
			<p class="source-code">        for col in range(len(data[row])):</p>
			<p class="source-code">            worksheet.write(row, col, data[row][col])</p>
			<p class="source-code">    worksheet.write(len(data), 0, "Avg. Age") </p>
			<p class="source-code">    # len(data) will give the next index to write to</p>
			<p class="source-code">    avg_formula = "=AVERAGE(B{}:B{})".format(1, len(data))</p>
			<p class="source-code">    worksheet.write(len(data), 1, avg_formula)</p>
			<p>In the preceding code snippet, you added an additional <strong class="source-inline">write</strong> call to the worksheet and used the <strong class="source-inline">AVERAGE</strong> function provided by Excel to calculate the average age of the people in the worksheet.</p>
			<p>With this, you now know how we can generate Microsoft Excel-compatible XLSX files using Python and how to export tabular content that's easily consumable by the different teams in your organization. </p>
			<p>Now, let's cover another interesting file format that is widely used across the world.</p>
			<h1 id="_idParaDest-377"><a id="_idTextAnchor394"/>Working with PDF Files in Python</h1>
			<p><strong class="bold">Portable Document Format</strong> or <strong class="bold">PDF</strong> is one of the most common file formats in the world. You must have encountered PDF documents at some point. These documents can include business reports, digital books, and more.</p>
			<p>Also, do you remember ever having encountered websites that have a button that reads <strong class="source-inline">Print</strong> <strong class="source-inline">page</strong> <strong class="source-inline">as</strong> <strong class="source-inline">PDF</strong>? A lot of websites for government agencies readily provide this option, which allows you to print the web page directly as a PDF. So, the question arises, how can we do this for our web app? How should we add the option to export certain content as a PDF?</p>
			<p>Over the years, a huge community of developers has contributed a lot of useful packages to the Python ecosystem. One of those packages can help us achieve PDF file generation.</p>
			<h2 id="_idParaDest-378"><a id="_idTextAnchor395"/>Converting Web Pages to PDFs</h2>
			<p>Sometimes, we may run into situations where we want to convert a web page into a PDF. For example, we may want to print a web page to store it as a local copy. This also comes in handy when trying to print a certificate that is natively displayed as a web page.</p>
			<p>To help us in such efforts, we can leverage a simple library known as <strong class="source-inline">weasyprint</strong>, which is maintained by a community of Python developers and allows the quick and easy conversion of web pages to PDFs. So, let's take a look at how we can generate a PDF version of a web page.</p>
			<h2 id="_idParaDest-379"><a id="_idTextAnchor396"/>Exercise 13.04: Generating a PDF Version of a Web Page in Python</h2>
			<p>In this exercise, you will generate a PDF version of a website using Python. You will use a community-contributed Python module known as <strong class="source-inline">weasyprint</strong> that will help you generate the PDF:</p>
			<ol>
				<li value="1">To make the code in the upcoming steps work correctly, install the <strong class="source-inline">weasyprint</strong> module on your system. To do this, run the following command:<p class="source-code">pip install weasyprint</p><p class="callout-heading">Note</p><p class="callout"><strong class="source-inline">weasyprint</strong> depends on the <strong class="source-inline">cairo</strong> library. In case you haven't installed <strong class="source-inline">cairo</strong> libraries, usage of <strong class="source-inline">weasyprint</strong> might raise an error with the message: <strong class="source-inline">libcairo-2.dll</strong> <strong class="source-inline">file</strong> <strong class="source-inline">not</strong> <strong class="source-inline">found</strong>. If you're facing this issue or any other issue installing the module, use the <strong class="source-inline">requirements.txt</strong> file we've provided on our GitHub repository at <a href="http://packt.live/3btLoVV">http://packt.live/3btLoVV</a>. Download the file to your disk and open your Terminal, shell or Command Prompt and type the following command (you will need to <strong class="source-inline">cd</strong> to the path where you saved this file locally): <strong class="source-inline">pip install -r requirements.txt</strong>. If that doesn't work, follow the steps as mentioned in the <strong class="source-inline">weasyprint</strong> documentation: <a href="https://weasyprint.readthedocs.io/en/stable/install.html">https://weasyprint.readthedocs.io/en/stable/install.html</a>.</p></li>
				<li>With the package now installed, create a new file named <strong class="source-inline">pdf_demo.py</strong> that will contain the PDF generation logic. Inside this file, write the following code:<p class="source-code">from weasyprint import HTML</p><p class="source-code">def generate_pdf(url, pdf_file):</p><p class="source-code">    """Generate PDF version of the provided URL."""</p><p class="source-code">    print("Generating PDF...")</p><p class="source-code">    HTML(url).write_pdf(pdf_file)</p><p>Now, let's try to understand what this code does. In the first line, you imported the <strong class="source-inline">HTML</strong> class from the <strong class="source-inline">weasyprint</strong> package, which you installed in <em class="italic">step 1</em>:</p><p class="source-code">from weasyprint import HTML</p><p>This HTML class provides us with a mechanism through which we can read the HTML content of a website if we have its URL.</p><p>In the next step, you created a new method named <strong class="source-inline">generate_pdf()</strong> that takes in two parameters, namely, the URL that should be used as the source URL for the generation of the PDF and the <strong class="source-inline">pdf_file</strong> parameter, which takes in the name of the file to which the document should be written:</p><p class="source-code">def generate_pdf(url, pdf_file):</p><p>Next, you passed the URL to the <strong class="source-inline">HTML</strong> class object you imported earlier. This caused the URL to be parsed by the <strong class="source-inline">weasyprint</strong> library and caused its HTML content to be read. Once this was done, you called the <strong class="source-inline">write_pdf()</strong> method of the <strong class="source-inline">HTML</strong> class object and provided to it the name of the file to which the content should be written:</p><p class="source-code">HTML(url).write_pdf(pdf_file)</p></li>
				<li>After this, write the entry point code that sets up the URL (for this exercise, we will use the text version of the <strong class="bold">National Public Radio</strong> (<strong class="bold">NPR</strong>) website) that should be used for your demo and the filename that should be used to write the PDF content to. Once that is set, the code calls the <strong class="source-inline">generate_pdf()</strong> method to generate the content:<p class="source-code">if __name__ == '__main__':</p><p class="source-code">    url = 'http://text.npr.org'</p><p class="source-code">    pdf_file = 'demo_page.pdf'</p><p class="source-code">    generate_pdf(url, pdf_file)</p></li>
				<li>Now, to see the code in action, run the following command:<p class="source-code">python3 pdf_demo.py</p><p>Once the command finishes executing, you will have a new PDF file named <strong class="source-inline">demo_page.pdf</strong> that is saved in the same directory where the command was executed. When you open the file, it should resemble what you see here:</p><div id="_idContainer395" class="IMG---Figure"><img src="image/B15509_13_07.jpg" alt="Figure 13.7: Web page converted to a PDF using weasyprint&#13;&#10;"/></div></li>
			</ol>
			<p class="figure-caption">Figure 13.7: Web page converted to a PDF using weasyprint</p>
			<p>In the PDF file generated, we can see that the content seems to lack the formatting that the actual website has. This happens because the <strong class="source-inline">weasyprint</strong> package reads the HTML content but does not parse the attached CSS stylesheets for the page, so the page formatting is lost.</p>
			<p><strong class="source-inline">weasyprint</strong> also makes it quite easy to change the formatting of a page. This can be done simply by introducing the stylesheet parameter to the <strong class="source-inline">write_pdf()</strong> method. A simple modification to our <strong class="source-inline">generate_pdf()</strong> method is described next:</p>
			<p class="source-code">from weasyprint import CSS, HTML</p>
			<p class="source-code">def generate_pdf(url, pdf_file):</p>
			<p class="source-code">    """Generate PDF version of the provided URL."""</p>
			<p class="source-code">    print("Generating PDF...")</p>
			<p class="source-code">    css = CSS(string='body{ font-size: 8px; }')</p>
			<p class="source-code">    HTML(url).write_pdf(pdf_file, stylesheets=[css])</p>
			<p>Now, when the preceding code is executed, we will see that the font size for all the text inside the HTML body content of the page has a size of <strong class="source-inline">8px</strong> in the printed PDF version.</p>
			<p class="callout-heading">Note</p>
			<p class="callout">The <strong class="source-inline">HTML</strong> class in <strong class="source-inline">weasyprint</strong> is also capable of taking any local files as well as raw HTML string content and can use those files to generate PDFs. For further information, please visit the <strong class="source-inline">weasyprint</strong> documentation at <a href="https://weasyprint.readthedocs.io">https://weasyprint.readthedocs.io</a>.</p>
			<p>So far, we have learned about how we can generate different types of binary files with Python, which can help us export our data in a structured manner or help us print PDF versions of our pages. Next, we will see how we can generate graph representations of our data using Python.</p>
			<h1 id="_idParaDest-380"><a id="_idTextAnchor397"/>Playing with Graphs in Python</h1>
			<p>Graphs are a great way to visually represent data that changes within a specific dimension. We come across graphs quite frequently in our day-to-day lives, be it weather charts for a week, stock market movements, or student performance report cards.</p>
			<p>Similarly, graphs can come in quite handy when we are working with our web applications. For Bookr, we can use graphs as a visual medium to show the user information about the number of books they read each week. Alternatively, we can show them the popularity of a book over time based on how many readers were reading the given book at a specific time. Now, let's look at how we can generate plots with Python and have them show up on our web pages.</p>
			<h2 id="_idParaDest-381"><a id="_idTextAnchor398"/>Generating Graphs with plotly</h2>
			<p>Graphs can come in quite handy when trying to visualize patterns in the data maintained by our applications. There are a lot of Python libraries that help developers in generating static or interactive graphs.</p>
			<p>For this book, we will use <strong class="source-inline">plotly</strong>, a community-supported Python library that generates graphs and renders them on web pages. <strong class="source-inline">plotly</strong> is particularly interesting to us due to its ease of integration with Django.</p>
			<p>To install it on your system, you can type in the following command in the command line:</p>
			<p class="source-code">pip install plotly</p>
			<p>Now that's done, let's take a look at how we can generate a graph visualization using <strong class="source-inline">plotly</strong>.</p>
			<h3 id="_idParaDest-382"><a id="_idTextAnchor399"/>Setting Up a Figure</h3>
			<p>Before we can get started with generating a graph, we first need to initialize a <strong class="source-inline">plotly</strong> <strong class="source-inline">Figure</strong> object, which essentially acts as a container for our graph. A <strong class="source-inline">plotly</strong> <strong class="source-inline">Figure</strong> object is quite easy to initialize; it can be done by using the following code snippet:</p>
			<p class="source-code">from plotly.graph_objs import graphs</p>
			<p class="source-code">figure = graphs.Figure()</p>
			<p>The <strong class="source-inline">Figure()</strong> constructor from the <strong class="source-inline">graph_objs</strong> module of <strong class="source-inline">plotly</strong> library returns an instance of the <strong class="source-inline">Figure</strong> graph container, inside which a graph can be generated. Once the <strong class="source-inline">Figure</strong> object is in place, the next thing that needs to be done is to generate a plot.</p>
			<h3 id="_idParaDest-383"><a id="_idTextAnchor400"/>Generating a Plot</h3>
			<p>A plot is a visual representation of a dataset. This plot could be a scatter plot, a line graph, a chart, and so on. For example, to generate a scatter plot, the following code snippet is used:</p>
			<p class="source-code">scatter_plot = graphs.Scatter(x_axis_values, y_axis_values)</p>
			<p>The <strong class="source-inline">Scatter</strong> constructor takes in the values for the <em class="italic">X</em>-axis and <em class="italic">Y</em>-axis and returns an object that can be used to build a scatter plot. Once the <strong class="source-inline">scatter_plot</strong> object is generated, the next step is to add this plot to our <strong class="source-inline">Figure</strong>. This can be done as follows:</p>
			<p class="source-code">figure.add_trace(scatter_plot)</p>
			<p>The <strong class="source-inline">add_trace()</strong> method is responsible for adding a plotting object to the figure and generating its visualization inside the figure.</p>
			<h3 id="_idParaDest-384"><a id="_idTextAnchor401"/>Rendering a Plot on a Web Page</h3>
			<p>Once the plot is added to the figure, it can be rendered on a web page by calling the <strong class="source-inline">plot</strong> method from the <strong class="source-inline">offline</strong> plotting module of <strong class="source-inline">plotly</strong> library. This is shown in the following code snippet:</p>
			<p class="source-code">from plotly.offline import plot</p>
			<p class="source-code">visualization_html = plot(figure, output_type='div')</p>
			<p>The <strong class="source-inline">plot</strong> method takes two primary parameters: the first is the figure that needs to be rendered and the second one is the HTML tag of the container inside which the figure HTML will be generated. The <strong class="source-inline">plot</strong> method returns fully integrated HTML that can be embedded in any web page or made a part of the template to render a graph.</p>
			<p>Now, with this understanding of how graph plotting works, let's try a hands-on exercise to generate a graph for our sample dataset.</p>
			<h2 id="_idParaDest-385"><a id="_idTextAnchor402"/>Exercise 13.05: Generating Graphs in Python</h2>
			<p>In this exercise, you will generate a Graph plot using Python. It will be a scatter plot that will represent two-dimensional data:</p>
			<ol>
				<li value="1">For this exercise, you will be using the <strong class="source-inline">plotly</strong> library. To use this library, you first need to install it on the system. To do this, run the following command:<p class="source-code">pip install plotly</p><p class="callout-heading">Note</p><p class="callout">You can install <strong class="source-inline">plotly</strong> and other dependencies for this exercise using the <strong class="source-inline">requirements.txt</strong> file we've provided on our GitHub repository: <a href="http://packt.live/38y5OLR">http://packt.live/38y5OLR</a>.</p></li>
				<li>With the library now installed, create a new file named <strong class="source-inline">scatter_plot_demo.py</strong> and add the following <strong class="source-inline">import</strong> statements inside it:<p class="source-code">from plotly.offline import plot</p><p class="source-code">import plotly.graph_objs as graphs</p></li>
				<li>Once the imports are sorted, create a method named <strong class="source-inline">generate_scatter_plot()</strong> that takes in two parameters, the values for the <em class="italic">X</em>-axis and the values for the <em class="italic">Y</em>-axis:<p class="source-code">def generate_scatter_plot(x_axis, y_axis):</p></li>
				<li>Inside this method, first, create an object to act as a container for the graph:<p class="source-code">    figure = graphs.Figure()</p></li>
				<li>Once the container for the graph is set up, create a new <strong class="source-inline">Scatter</strong> object with the values for the <em class="italic">X</em>-axis and <em class="italic">Y</em>-axis and add it to the graph <strong class="source-inline">Figure</strong> container:<p class="source-code">    scatter = graphs.Scatter(x=x_axis, y=y_axis)</p><p class="source-code">    figure.add_trace(scatter)</p></li>
				<li>Once the scatter plot is ready and added to the figure, the last step is to generate the HTML, which can be used to render this plot inside a web page. To do this, call the <strong class="source-inline">plot</strong> method and pass the graph container object to it, and render the HTML inside an HTML <strong class="source-inline">div</strong> tag:<p class="source-code">    return plot(figure, output_type='div')</p><p>The complete <strong class="source-inline">generate_scatter_plot()</strong> method should look like this now:</p><p class="source-code">def generate_scatter_plot(x_axis, y_axis):</p><p class="source-code">    figure = graphs.Figure()</p><p class="source-code">    scatter = graphs.Scatter(x=x_axis, y=y_axis)</p><p class="source-code">    figure.add_trace(scatter)</p><p class="source-code">    return plot(figure, output_type='div')</p></li>
				<li>Once the HTML for the plot is generated, it needs to be rendered somewhere. For this, create a new method named <strong class="source-inline">generate_html()</strong>, which will take in the plot HTML as its parameter and render an HTML file consisting of the plot:<p class="source-code">def generate_html(plot_html):</p><p class="source-code">    """Generate an HTML page for the provided plot."""</p><p class="source-code">    html_content = "&lt;html&gt;&lt;head&gt;&lt;title&gt;Plot       Demo&lt;/title&gt;&lt;/head&gt;&lt;body&gt;{}&lt;/body&gt;&lt;/html&gt;".format(plot_html)</p><p class="source-code">    try:</p><p class="source-code">        with open('plot_demo.html', 'w') as plot_file:</p><p class="source-code">            plot_file.write(html_content)</p><p class="source-code">    except (IOError, OSError) as file_io_error:</p><p class="source-code">        print\</p><p class="source-code">        ("Unable to generate plot file. Exception: {}"\</p><p class="source-code">        .format(file_io_error))</p></li>
				<li>Once the method is set up, the last step is to call it. For this, create a script entry point that will set up the values for the <em class="italic">X</em>-axis list and the <em class="italic">Y</em>-axis list and then call the <strong class="source-inline">generate_scatter_plot()</strong> method. With the value returned by the method, make a call to the <strong class="source-inline">generate_html()</strong> method, which will create an HTML page consisting of the scatter plot:<p class="source-code">if __name__ == '__main__':</p><p class="source-code">    x = [1,2,3,4,5]</p><p class="source-code">    y = [3,8,7,9,2]</p><p class="source-code">    plot_html = generate_scatter_plot(x, y)</p><p class="source-code">    generate_html(plot_html)</p></li>
				<li>With the code in place, run the file and see what output is generated. To run the code, execute the following command:<p class="source-code">python3 scatter_plot_demo.py</p><p>Once the execution completes, there will be a new <strong class="source-inline">plot_demo.html</strong> file created in the same directory in which the script was executed. Upon opening the file, you should see the following:</p><div id="_idContainer396" class="IMG---Figure"><img src="image/B15509_13_08.jpg" alt="Figure 13.8: Graph generated in the browser using plotly&#13;&#10;"/></div></li>
			</ol>
			<p class="figure-caption">Figure 13.8: Graph generated in the browser using plotly</p>
			<p>With this, we have generated our first scatter plot, where different points are connected by a line.</p>
			<p>In this exercise, you used the <strong class="source-inline">plotly</strong> library to generate a graph that can be rendered inside a browser for your readers to visualize data.</p>
			<p>Now, you know how you can work with graphs in Python and how to generate HTML pages from them. </p>
			<p>But as a web developer, how you can use these graphs in Django? Let's find out. </p>
			<h2 id="_idParaDest-386"><a id="_idTextAnchor403"/>Integrating plotly with Django</h2>
			<p>The graphs generated by <strong class="source-inline">plotly</strong> are quite easy to embed in Django templates. Since the <strong class="source-inline">plot</strong> method returns a fully contained HTML that can be used to render a graph, we can use the HTML returned as a template variable in Django and pass it as it is. The Django templating engine will then take care of adding this generated HTML to the final template before it is shown in the browser.</p>
			<p>Some sample code for doing this is shown next:</p>
			<p class="source-code">def user_profile(request):</p>
			<p class="source-code">    username = request.user.get_username()</p>
			<p class="source-code">    scatter_plot_html = scatter_plot_books_read(username)</p>
			<p class="source-code">    return render(request, 'user_profile.html'),\</p>
			<p class="source-code">                 (context={'plt_div': scatter_plot_html})</p>
			<p>The preceding code will cause the <strong class="source-inline">{{ plt_div }}</strong> content used inside the template to be replaced by the HTML stored inside the <strong class="source-inline">scatter_plot_demo</strong> variable, and the final template to render the scatter plot of the number of books read per week.</p>
			<h1 id="_idParaDest-387"><a id="_idTextAnchor404"/>Integrating Visualizations with Django</h1>
			<p>In the preceding sections, you have learned how data can be read and written in different formats that cater to the different needs of users. But how can we use what we've learned to integrate with Django?</p>
			<p>For example, in Bookr, we might want to allow the user to export a list of books that they have read or visualize their book reading activity over a year. How can that be done? The next exercise in this chapter focuses on that aspect, where you will learn how the components we have seen so far can be integrated into Django web applications.</p>
			<h2 id="_idParaDest-388"><a id="_idTextAnchor405"/>Exercise 13.06: Visualizing a User's Reading History on the User Profile Page</h2>
			<p>In this exercise, you will aim to modify the user's profile page such that the user can visualize their book reading history when they visit their profile page on Bookr.</p>
			<p>Let's look at how this can be done:</p>
			<ol>
				<li value="1">To get started with integrating the ability to visualize the reading history of the user, you first need to install the <strong class="source-inline">plotly</strong> library. To do this, run the following command in your terminal:<p class="source-code">pip install plotly</p><p class="callout-heading">Note</p><p class="callout">You can install <strong class="source-inline">plotly</strong> and other dependencies for this exercise using the <strong class="source-inline">requirements.txt</strong> file we've provided on our GitHub repository: <a href="http://packt.live/3scIvPp">http://packt.live/3scIvPp</a>.</p></li>
				<li>Once the library is installed, the next step is to write the code that will fetch the total books read by the user as well as the books read by the user on a per-month basis. For this, create a new file named <strong class="source-inline">utils.py</strong> under the <strong class="source-inline">bookr</strong> application directory and add the required imports, which will be used to fetch the book reading history of the user from the <strong class="source-inline">Review</strong> model of the <strong class="source-inline">reviews</strong> application:<p class="source-code">import datetime</p><p class="source-code">from django.db.models import Count</p><p class="source-code">from reviews.models import Review</p></li>
				<li>Next, create a new utility method named <strong class="source-inline">get_books_read_by_month()</strong>, which takes in the username of the user for whom the reading history needs to be fetched.</li>
				<li>Inside the method, we query the <strong class="source-inline">Review</strong> model and return a dictionary of books read by the user on a per-month basis:<p class="source-code">def get_books_read_by_month(username):</p><p class="source-code">    """Get the books read by the user on per month basis.</p><p class="source-code">    :param: str The username for which the books needs to be returned</p><p class="source-code">    :return: dict of month wise books read</p><p class="source-code">    """</p><p class="source-code">    current_year = datetime.datetime.now().year</p><p class="source-code">    books = Review.objects.filter\</p><p class="source-code">            (creator__username__contains=username),\</p><p class="source-code">            (date_created__year=current_year)\</p><p class="source-code">            .values('date_created__month')\</p><p class="source-code">            .annotate(book_count=Count('book__title'))</p><p class="source-code">    return books</p><p>Now, let's examine the following query, which is responsible for fetching the results of books read this year on a monthly basis:</p><p class="source-code">Review.objects.filter(creator__username__contains=username,date_created__year=current_year).values('date_created__month').annotate(book_count=Count('book__title'))</p><p>This query can be broken down into the following components:</p><p><strong class="bold">Filtration</strong></p><p class="source-code">Review.objects.filter(creator__username__contains=username,date_created__year=current_year)</p><p>Here you filter the review records to choose all the records that belong to the current user as well as the current year. The <strong class="source-inline">year</strong> field can be easily accessed from our <strong class="source-inline">date_created</strong> field by appending <strong class="source-inline">__year</strong>.</p><p><strong class="bold">Projection</strong></p><p>Once the review records are filtered, you are not interested in all the fields that might be there. What you are mainly interested in is the month and the number of books read each month. For this, use the <strong class="source-inline">values()</strong> call to select only the <strong class="source-inline">month</strong> field from the <strong class="source-inline">date_created</strong> attribute of the <strong class="source-inline">Review</strong> model on which you are going to run the group by operation.</p><p><strong class="bold">Group By</strong></p><p>Here, you select the total number of books read in a given month. This is done by applying the <strong class="source-inline">annotate</strong> method to the <strong class="source-inline">QuerySet</strong> instance returned by the <strong class="source-inline">values()</strong> call.</p></li>
				<li>Once you have the utilities file in place, the next thing is to write the view function, which is going to help in showing the books-read-per-month plot on the user's profile page. For this, open the <strong class="source-inline">views.py</strong> file under the <strong class="source-inline">bookr</strong> directory and start by adding the following imports to it:<p class="source-code">from plotly.offline import plot</p><p class="source-code">import plotly.graph_objects as graphs</p><p class="source-code">from .utils import get_books_read_by_month</p></li>
				<li>Once these imports are done, the next thing to do is to modify the view function that renders the profile page. Currently, the profile page is being handled by the <strong class="source-inline">profile()</strong> method inside the <strong class="source-inline">views.py</strong> file. Modify the method to resemble the one shown here:<p class="source-code">@login_required</p><p class="source-code">def profile(request):</p><p class="source-code">    user = request.user</p><p class="source-code">    permissions = user.get_all_permissions()</p><p class="source-code">    # Get the books read in different months this year</p><p class="source-code">    books_read_by_month = get_books_read_by_month(user.username)</p><p class="source-code">    """</p><p class="source-code">    Initialize the Axis for graphs, X-Axis is months, </p><p class="source-code">    Y-axis is books read</p><p class="source-code">    """</p><p class="source-code">    months = [i+1 for i in range(12)]</p><p class="source-code">    books_read = [0 for _ in range(12)]</p><p class="source-code">    # Set the value for books read per month on Y-Axis</p><p class="source-code">    for num_books_read in books_read_by_month:</p><p class="source-code">        list_index = num_books_read['date_created__month'] - 1</p><p class="source-code">        books_read[list_index] = num_books_read['book_count']</p><p class="source-code">    # Generate a scatter plot HTML</p><p class="source-code">    figure = graphs.Figure()</p><p class="source-code">    scatter = graphs.Scatter(x=months, y=books_read)</p><p class="source-code">    figure.add_trace(scatter)</p><p class="source-code">    figure.update_layout(xaxis_title="Month"),\</p><p class="source-code">                        (yaxis_title="No. of books read")</p><p class="source-code">    plot_html = plot(figure, output_type='div')</p><p class="source-code">    # Add to template</p><p class="source-code">      return render(request, 'profile.html'),\</p><p class="source-code">                   ({'user': user, 'permissions': permissions,\</p><p class="source-code">                   'books_read_plot': plot_html})</p><p>In this method, you did a couple of things. The first thing was that you called the <strong class="source-inline">get_books_read_by_month()</strong> method and provided it with the username of the currently logged-in user. This method returns the list of books read by a given user on a per-month basis in the current year:</p><p class="source-code">books_read_by_month = get_books_read_by_month(user.username)</p><p>The next thing you did was pre-initialize the <em class="italic">X</em>-axis and <em class="italic">Y</em>-axis for the graph with some default values. For this visualization, use the <em class="italic">X</em>-axis to display months and the <em class="italic">Y</em>-axis to display the number of books read.</p><p>Now, since you already know that a year is going to have only 12 months, pre-initialize the <em class="italic">X</em>-axis with a value between <strong class="source-inline">1</strong> and <strong class="source-inline">12</strong>:</p><p class="source-code">months = [i+1 for i in range(12)]</p><p>For the books read, initialize the <em class="italic">Y</em>-axis with all the <strong class="source-inline">12</strong> indexes set to <strong class="source-inline">0</strong> as follows:</p><p class="source-code">books_read = [0 for _ in range(12)]</p><p>Now, with the pre-initialization done, fill in some actual values for the books read per month. For this, iterate upon the list you got as a result of the call made to <strong class="source-inline">get_books_read_by_month(user.username)</strong> and extract the month and the book count for the month from it.</p><p>Once the book count and month are extracted, the next step is to assign the <strong class="source-inline">book_count</strong> value to the <strong class="source-inline">books_read</strong> list at the month index:</p><p class="source-code">    for num_books_read in books_read_by_month:</p><p class="source-code">        list_index = num_books_read['date_created__month'] - 1</p><p class="source-code">        books_read[list_index] = num_books_read['book_count']</p><p>Now, with the values for the axes set, generate a scatter plot using the <strong class="source-inline">plotly</strong> library:</p><p class="source-code">figure = graphs.Figure()</p><p class="source-code">scatter = graphs.Scatter(x=months, y=books_read)</p><p class="source-code">figure.add_trace(scatter)</p><p class="source-code">figure.update_layout(xaxis_title="Month", \</p><p class="source-code">                     yaxis_title="No. of books read")</p><p class="source-code">plot_html = plot(figure, output_type='div')</p><p>Once the HTML for the plot is generated, pass it to the template using the <strong class="source-inline">render()</strong> method such that it can be visualized on the profile page:</p><p class="source-code">return render(request, 'profile.html',</p><p class="source-code">       {'user': user, 'permissions': permissions,\</p><p class="source-code">        'books_read_plot': plot_html}</p></li>
				<li>With the view function done, the next step is to modify the template to render this graph. For this, open the <strong class="source-inline">profile.html</strong> file under the <strong class="source-inline">templates</strong> directory and add the following highlighted code to the file, just before the last <strong class="source-inline">{% endblock %}</strong> statement:<p class="source-code">{% extends "base.html" %}</p><p class="source-code">{% block title %}Bookr{% endblock %}</p><p class="source-code">{% block heading %}Profile{% endblock %}</p><p class="source-code">{% block content %}</p><p class="source-code">  &lt;ul&gt;</p><p class="source-code">      &lt;li&gt;Username: {{ user.username }} &lt;/li&gt;</p><p class="source-code">      &lt;li&gt;Name: {{ user.first_name }} {{ user.last_name }}&lt;/li&gt;</p><p class="source-code">      &lt;li&gt;Date Joined: {{ user.date_joined }} &lt;/li&gt;</p><p class="source-code">      &lt;li&gt;Email: {{ user.email }}&lt;/li&gt;</p><p class="source-code">      &lt;li&gt;Last Login: {{ user.last_login }}&lt;/li&gt;</p><p class="source-code">      &lt;li&gt;Groups: {{ groups }}{% if not groups %}None{% endif %} &lt;/li&gt;</p><p class="source-code">  &lt;/ul&gt;</p><p class="source-code"><strong class="bold">  {% autoescape off %}</strong></p><p class="source-code"><strong class="bold">      {{ books_read_plot }}</strong></p><p class="source-code"><strong class="bold">  {% endautoescape %}</strong></p><p class="source-code">{% endblock %}</p><p>This code snippet adds the <strong class="source-inline">books_read_plot</strong> variable passed in the view function to be used inside our HTML template. Also note that <strong class="source-inline">autoescape</strong> is set to off for this variable. This is required because this variable contains HTML generated by the <strong class="source-inline">plotly</strong> library and if you allow Django to escape the HTML, you will only see raw HTML in the profile page and not a graph visualization.</p><p>With this, you have successfully integrated the plot into the application.</p></li>
				<li>To try the visualization, run the following command and then navigate to your user profile by visiting <strong class="source-inline">http://localhost:8080</strong>:<p class="source-code">python manage.py runserver localhost:8080</p><p>You should see a page that resembles the one shown next:</p><div id="_idContainer397" class="IMG---Figure"><img src="image/B15509_13_09.jpg" alt="Figure 13.9: User book reading history scatter plot&#13;&#10;"/></div></li>
			</ol>
			<p class="figure-caption">Figure 13.9: User book reading history scatter plot</p>
			<p>In the preceding exercise, you saw how you can integrate a plotting library with Django to visualize the reading history of a user. Similarly, Django allows you to integrate any generic Python code into a web application, with the only constraint being that the data generated as a result of the integration should be transformed into a valid HTTP response that can be handled by any standard HTTP-compatible tool, such as a web browser or command-line tools such as CURL.</p>
			<h2 id="_idParaDest-389"><a id="_idTextAnchor406"/>Activity 13.01: Exporting the Books Read by a User as an XLSLX File</h2>
			<p>In this activity, you will implement a new API endpoint inside Bookr that will allow your users to export and download a list of books they have read as an XLSX file:</p>
			<ol>
				<li value="1">Install the <strong class="source-inline">XlsxWriter</strong> library.</li>
				<li>Inside the <strong class="source-inline">utils.py</strong> file created under the <strong class="source-inline">bookr</strong> application, create a new function that will help in fetching the list of books that have been read by the user.</li>
				<li>Inside the <strong class="source-inline">views.py</strong> file under the <strong class="source-inline">bookr</strong> directory, create a new view function that will allow the user to download their reading history in the XLSX file format.</li>
				<li>To create an XLSX file inside the view function, first create a <strong class="source-inline">BytesIO</strong>-based in-memory file that can be used to store the data from the <strong class="source-inline">XlsxWriter</strong> library.</li>
				<li>Read the data stored inside the in-memory file using the <strong class="source-inline">getvalue()</strong> method of the temporary file object.</li>
				<li>Finally, create a new <strong class="source-inline">HttpResponse</strong> instance with the <strong class="source-inline">'application/vnd.ms-excel'</strong> content type header, and then write the data obtained in step 5 to the response object.</li>
				<li>With the response object prepared, return the response object from the view function.</li>
				<li>With the view function ready, map it to a URL endpoint that can be visited by a user to download their book reading history.</li>
			</ol>
			<p>Once you have the URL endpoint mapped, start the application and log in to it with your user account. Once done, visit the URL endpoint you just created, and if upon visiting the URL endpoint your browser starts to download an Excel file, you have successfully completed the activity.</p>
			<p class="callout-heading">Note</p>
			<p class="callout">The solution to this activity can be found at <a href="http://packt.live/2Nh1NTJ">http://packt.live/2Nh1NTJ</a>.</p>
			<h1 id="_idParaDest-390"><a id="_idTextAnchor407"/>Summary</h1>
			<p>In this chapter, we looked at how we can deal with binary files and how Python's standard library, which comes pre-loaded with the necessary tools, can allow us to handle commonly used file formats such as CSV. We then moved on to learning how to read and write CSV files in Python using Python's CSV module. Later, we worked with the <strong class="source-inline">XlsxWriter</strong> package, which provides us with the ability to generate Microsoft Excel-compatible files right from our Python environment without worrying about the internal formatting of the file.</p>
			<p>The second half of the chapter was dedicated to learning how to use the <strong class="source-inline">weasyprint</strong> library to generate PDF versions of HTML pages. This skill can come in handy when we want to provide our users with an easy option to print the HTML version of our page with any added CSS styling of our choosing. The last section of the chapter discussed how we can generate interactive graphs in Python and render them as HTML pages that can be viewed inside the browser using the <strong class="source-inline">plotly</strong> library.</p>
			<p>In the next chapter, we will look at how we can test the different components we have been implementing in the previous chapters to make sure that code changes do not break our website's functionality.</p>
		</div>
		<div>
			<div id="_idContainer399" class="Content">
			</div>
		</div>
	</body></html>