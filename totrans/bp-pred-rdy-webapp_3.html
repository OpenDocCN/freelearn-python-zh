<html><head></head><body>
<div id="sbo-rt-content"><div id="_idContainer016">
<h1 class="chapter-number" id="_idParaDest-72"><a id="_idTextAnchor076"/>3</h1>
<h1 id="_idParaDest-73"><a id="_idTextAnchor077"/>Building the API</h1>
<p>In the previous chapter, we built a backend that connects to the database, manages user sessions, and sends emails. Now, we will add a specific API to the backend that tracks the member’s to-do’s. This will require an API that allows members, sessions, and to-dos to be managed.</p>
<p>In this chapter, you’ll learn how to build a <strong class="bold">RESTful API</strong>, which is a very popular style of API and one you’ll likely use and come across in your career. You’ll also build an API to manage members and authenticate their actions, which could be used in any other app with minimal changes. Finally, we will also build an API to track the to-dos, which, again, could be adapted for other uses.</p>
<p>We’ll build the API using a RESTful style as it works very well with web apps and can be expressed very easily with Quart. A RESTful API is where the functionality is grouped by resource with each function being an action acting on the resource. For example, the functionality to log in is described as creating a session and log out as deleting a session. For a RESTful web app, the action is represented by the HTTP verb and the resource by the HTTP path. In addition, the response status code is used to indicate the effect of the functionality, with 2XX codes indicating success and 4XX codes indicating different types of errors.</p>
<p class="callout-heading">Alternatives to RESTful APIs</p>
<p class="callout">While RESTful APIs utilize many HTTP verbs and paths to describe the functionality, a more basic style is to have a singular <strong class="source-inline">POST</strong> route. This route is then used for all the functionality with the request body describing the function and data. A good example is GraphQL, which typically uses only <strong class="source-inline">POST /graphql</strong> with a defined message structure. If you’d prefer to use GraphQL take a look at <a href="https://strawberry.rocks">https://strawberry.rocks</a>.</p>
<p>So, in this chapter, we will cover the following topics:</p>
<ul>
<li>Creating the database schema and models</li>
<li>Building the session API</li>
<li>Building the member API</li>
<li>Building the to-do API</li>
</ul>
<h1 id="_idParaDest-74"><a id="_idTextAnchor078"/>Technical requirements</h1>
<p>The following additional folders are required in this chapter and should be created:</p>
<pre class="source-code">
tozo
└── backend
    ├── src
    │   └── backend
    │       ├── migrations
    │       └── models
    └── tests
        └── models</pre>
<p>Empty <em class="italic">backend/src/backend/models/__init__.py</em> and <em class="italic">backend/tests/models/__init__.py</em> files should also be created.</p>
<p>To follow the development in this chapter, use the companion repository, <a href="https://github.com/pgjones/tozo">https://github.com/pgjones/tozo</a>, and see the commits between the tags <strong class="source-inline">r1-ch3-start</strong> and <strong class="source-inline">r1-ch3-end</strong>.</p>
<h1 id="_idParaDest-75"><a id="_idTextAnchor079"/>Creating the database schema and models</h1>
<p>In this book, we are building a to-do tracking app, which means we need to store data about the <a id="_idIndexMarker162"/>member and their to-dos. We will do so by placing the data into the database, which means we need to define the structure of the data. This structure is called the schema and describes the tables in the database. </p>
<p>While the <strong class="bold">schema</strong> describes the structure of the data in the database, we will use models in the backend <a id="_idIndexMarker163"/>and frontend. Each model is a class that represents a row in the database. For example, a table with only an ID could be represented by a class with a single <strong class="source-inline">id</strong> attribute.</p>
<p class="callout-heading">ORMs</p>
<p class="callout">Schemas and models are often conflated as the same thing, especially when an <strong class="bold">Object Relational Model</strong> (<strong class="bold">ORM</strong>) is used. While using an ORM is simpler to begin with, I find it hides important <a id="_idIndexMarker164"/>details and makes development harder after a short while. This is why, in this book, the model and schema are related but different. This also means that we’ll write SQL queries for all interactions with the database.</p>
<p>We’ll start by defining the <a id="_idIndexMarker165"/>member data and to-do data as both models and schemas in a migration, before adding some initial test and development data.</p>
<h2 id="_idParaDest-76"><a id="_idTextAnchor080"/>Creating the member schema and model</h2>
<p>We need <a id="_idIndexMarker166"/>to store information for each member so that we can associate their to-dos with them, via a foreign key reference. In addition, we need to store enough information so that the member can log in and prove who they are (authenticate themselves), which means we need to store their email and password hash. Finally, we’ll also store when their account was created and when they verified their email – the latter being important if we want to send them emails.</p>
<p>The schema for this data is given by the following SQL, which is given for reference and will be used in the <em class="italic">Running the first migration</em> section:</p>
<pre class="source-code">
CREATE TABLE members (
    id INT PRIMARY KEY GENERATED ALWAYS AS IDENTITY,
    created TIMESTAMP NOT NULL DEFAULT now(),
    email TEXT NOT NULL,
    email_verified TIMESTAMP,
    password_hash TEXT NOT NULL
);
 
<strong class="bold">CREATE UNIQUE INDEX members_unique_email_idx on members (LOWER(email));</strong></pre>
<p>The unique index highlighted ensures that there is only one member account per email, with email casing being ignored.</p>
<p class="callout-heading">SQL formatting</p>
<p class="callout">In <a href="B18727_01.xhtml#_idTextAnchor015"><em class="italic">Chapter 1</em></a><em class="italic"> Setting Up Our System for Development</em>, I mentioned the importance of code formatting and autoformatters. Sadly, I haven’t found an autoformatter that works for SQL <a id="_idIndexMarker167"/>embedded in Python code. However, I recommend you follow the style guide given at <a href="http://sqlstyle.guide/">http://sqlstyle.guide/</a> as I will in this book.</p>
<p>We can <a id="_idIndexMarker168"/>represent the database table with a Python <strong class="source-inline">dataclass</strong>, which includes each column as an attribute with the relevant Python type. This is the model shown in the following code, which should be added to <em class="italic">backend/src/backend/models/member.py</em>:</p>
<pre class="source-code">
from dataclasses import dataclass
from datetime import datetime
 
@dataclass
class Member:
    id: int
    email: str
    password_hash: str
    created: datetime
    email_verified: datetime | None</pre>
<p>In addition to the model, we can add the following functions to <em class="italic">backend/src/backend/models/member.py</em> in order to convert between the backend model and the SQL that reads from the database:</p>
<pre class="source-code">
from quart_db import Connection
 
async def select_member_by_email(
    db: Connection, email: str
) -&gt; Member | None:
    result = await db.fetch_one(
        """SELECT id, email, password_hash, created,                  email_verified
             FROM members
<strong class="bold">            WHERE LOWER(email) = LOWER(:email)""",</strong>
        {"email": email},
    )
    return None if result is None else Member(**result)
 
async def select_member_by_id(
    db: Connection, id: int
) -&gt; Member | None:
    result = await db.fetch_one(
        """SELECT id, email, password_hash, created,                  email_verified
             FROM members
            WHERE id = :id""",
        {"id": id},
    )
    return None if result is None else Member(**result)</pre>
<p>These functions allow member information to be read from the database. The highlighted line <a id="_idIndexMarker169"/>ensures that emails are considered a match if the lowercased email matches. </p>
<p class="callout-heading">Email case sensitivity</p>
<p class="callout">In our app, we store the email in the case given by the user, while comparing lowercased emails. This is the most user-friendly and secure solution, as emails can have a case-sensitive local part (before the <strong class="source-inline">@</strong>) but rarely do and must be case insensitive for the domain part (after the <strong class="source-inline">@</strong>). Therefore, by storing the given casing we ensure the email is delivered while ensuring there is one account per email address. More information is available at <a href="https://stackoverflow.com/questions/9807909/are-email-addresses-case-sensitive">https://stackoverflow.com/questions/9807909/are-email-addresses-case-sensitive</a>.</p>
<p>Next, we need to add functions that can alter the data in the database by adding the following to <em class="italic">backend/src/models/member.py</em>: </p>
<pre class="source-code">
async def insert_member(
    db: Connection, email: str, password_hash: str
) -&gt; Member:
    result = await db.fetch_one(
        """INSERT INTO members (email, password_hash)
                VALUES (:email, :password_hash)
             RETURNING id, email, password_hash, created,
                       email_verified""",
        {"email": email, "password_hash": password_hash},
    )
    return Member(**result)
 
async def update_member_password(
    db: Connection, id: int, password_hash: str
) -&gt; None:
    await db.execute(
        """UPDATE members 
              SET password_hash = :password_hash 
            WHERE id = :id""",
        {"id": id, "password_hash": password_hash},
    )
 
async def update_member_email_verified(
    db: Connection, id: int
) -&gt; None:
    await db.execute(
        "UPDATE members SET email_verified = now() WHERE id = :id",
        {"id": id},
    )</pre>
<p>These functions match the functionality we’ll shortly add to the API.</p>
<p>The case <a id="_idIndexMarker170"/>sensitivity is something we should test, by adding the following to <em class="italic">backend/tests/models/test_member.py</em>:</p>
<pre class="source-code">
import pytest
from asyncpg.exceptions import UniqueViolationError  # type: ignore
from quart_db import Connection
from backend.models.member import insert_member
async def test_insert_member(connection: Connection) -&gt; None:
    await insert_member(connection, "casing@tozo.dev", "")
<strong class="bold">    with pytest.raises(UniqueViolationError):</strong>
        await insert_member(connection, "Casing@tozo.dev", "")</pre>
<p>Firstly, we want a test to ensure that <strong class="source-inline">insert_member</strong> correctly rejects a second member <a id="_idIndexMarker171"/>with an email that differs only by casing. The highlighted line ensures that the lines within, when executed, raise a <strong class="source-inline">UniqueViolationError</strong> and hence prevents the member from being inserted again.</p>
<p>We also need to test that the <strong class="source-inline">select_member_by_email</strong> function compares case insensitively by adding the following to <em class="italic">backend/tests/models/test_member.py</em>:</p>
<pre class="source-code">
from backend.models.member import select_member_by_email
async def test_select_member_by_email (connection: Connection) -&gt; None:
    await insert_member(connection, "casing@tozo.dev", "")
    member = await select_member_by_email(
        connection, "Casing@tozo.dev"
    )
    assert member is not None</pre>
<p>With the model code set up this way, we’ll be able to use these functions and the class instance directly wherever required in the backend code. </p>
<h2 id="_idParaDest-77"><a id="_idTextAnchor081"/>Creating the to-do schema and model</h2>
<p>We also <a id="_idIndexMarker172"/>want to store information for each to-do, specifically the to-do task as text, when the to-do is due to be completed (although this should be optional), and if the to-do is complete. In addition, every to-do should be linked to the member that owns it.</p>
<p>The schema for this data is given by the following SQL, which is given for reference and will be used in the <em class="italic">Running the first migration</em> section:</p>
<pre class="source-code">
CREATE TABLE todos (
    id BIGINT PRIMARY KEY GENERATED ALWAYS AS IDENTITY,
    complete BOOLEAN NOT NULL DEFAULT FALSE,
    due TIMESTAMPTZ,
    member_id INT NOT NULL REFERENCES members(id),
    task TEXT NOT NULL
);</pre>
<p>The <a id="_idIndexMarker173"/>corresponding backend model for this table is given by the following code, which should be added to <em class="italic">backend/src/backend/models/todo.py</em>:</p>
<pre class="source-code">
from dataclasses import dataclass
from datetime import datetime
from pydantic import constr
 
@dataclass
class Todo:
    complete: bool
    due: datetime | None
    id: int
    task: constr(strip_whitespace=True, min_length=1)  # type: ignore</pre>
<p>Here, <strong class="source-inline">constr</strong> is used in place of <strong class="source-inline">str</strong> in order to ensure that empty strings are not considered valid. In addition to the model, we can add the following functions to <em class="italic">backend/src/backend/models/todo.py</em> in order to convert between the backend model <a id="_idIndexMarker174"/>and the SQL that reads from the database: </p>
<pre class="source-code">
from quart_db import Connection
async def select_todos(
    connection: Connection, 
    member_id: int, 
    complete: bool | None = None,
) -&gt; list[Todo]:
    if complete is None:
        query = """SELECT id, complete, due, task
                     FROM todos
                    WHERE member_id = :member_id"""
        values = {"member_id": member_id}
    else:
        query = """SELECT id, complete, due, task
                     FROM todos
                    WHERE member_id = :member_id 
                          AND complete = :complete"""
        values = {"member_id": member_id, "complete": complete}
    return [
        Todo(**row) 
        async for row in connection.iterate(query, values)
    ]
async def select_todo(
    connection: Connection, id: int, member_id: int,
) -&gt; Todo | None:
    result = await connection.fetch_one(
        """SELECT id, complete, due, task
             FROM todos
            WHERE id = :id AND member_id = :member_id""",
        {"id": id, "member_id": member_id},
    )
    return None if result is None else Todo(**result)</pre>
<p>These functions allow to-dos to be read from the database, but will only return to-dos that are owned by the given <strong class="source-inline">member_id</strong>. Using these functions should ensure that we don’t return to-dos to the wrong members. </p>
<p>Next, we <a id="_idIndexMarker175"/>need to add functions that can alter the data in the database by adding the following to <em class="italic">backend/src/models/todo.py</em>:</p>
<pre class="source-code">
async def insert_todo(
    connection: Connection, 
    member_id: int,
    task: str,
    complete: bool,
    due: datetime | None, 
) -&gt; Todo:
    result = await connection.fetch_one(
        """INSERT INTO todos (complete, due, member_id, task)
                VALUES (:complete, :due, :member_id, :task)
             RETURNING id, complete, due, task""",
        {
            "member_id": member_id, 
            "task": task, 
            "complete": complete, 
            "due": due,
        },
    )
    return Todo(**result)
async def update_todo(
    connection: Connection, 
    id: int, 
    member_id: int,
    task: str,
    complete: bool,
    due: datetime | None,
) -&gt; Todo | None:
    result = await connection.fetch_one(
        """UPDATE todos
              SET complete = :complete, due = :due, 
                  task = :task
            WHERE id = :id AND member_id = :member_id
        RETURNING id, complete, due, task""",
        {
            "id": id,
            "member_id": member_id, 
            "task": task, 
            "complete": complete, 
            "due": due,
        },
    )
    return None if result is None else Todo(**result)
 
async def delete_todo(
    connection: Connection, id: int, member_id: int,
) -&gt; None:
    await connection.execute(
        "DELETE FROM todos WHERE id = :id AND member_id = :member_id",
        {"id": id, "member_id": member_id},
    )</pre>
<p>Note that all these functions also take a <strong class="source-inline">member_id</strong> argument and only affect the to-dos <a id="_idIndexMarker176"/>that belong to the given <strong class="source-inline">member_id</strong>. This will help us avoid authorization errors whereby we write code that mistakenly allows a member to access or modify another member’s to-do. </p>
<p>This is something we should test, by adding the following to <em class="italic">backend/tests/models/test_todo.py</em>. Firstly, we want a test to ensure that <strong class="source-inline">delete_todo</strong> correctly deletes the to-do:</p>
<pre class="source-code">
import pytest
from quart_db import Connection
from backend.models.todo import (
    delete_todo, insert_todo, select_todo, update_todo
)
<strong class="bold">@pytest.mark.parametrize(</strong>
<strong class="bold">    "member_id, deleted",</strong>
<strong class="bold">    [(1, True), (2, False)],</strong>
<strong class="bold">)</strong>
async def test_delete_todo(
    connection: Connection, member_id: int, deleted: bool
) -&gt; None:
    todo = await insert_todo(        connection, 1, "Task", False, None     )
    await delete_todo(connection, todo.id, member_id)
    new_todo = await select_todo(connection, todo.id, 1)
    assert (new_todo is None) is deleted</pre>
<p>The <a id="_idIndexMarker177"/>highlighted parametrization provides two tests. The first test ensures that <strong class="source-inline">member_id 1</strong> can delete their to-do, and the second test ensures that <strong class="source-inline">member_id 2</strong> cannot delete another user’s to-do.</p>
<p>We should also add a similar test to ensure that the update works as expected:</p>
<pre class="source-code">
@pytest.mark.parametrize(
    "member_id, complete",
    [(1, True), (2, False)],
)
async def test_update_todo(
    connection: Connection, member_id: int, complete: bool
) -&gt; None:
    todo = await insert_todo(        connection, 1, "Task", False, None     )
    await update_todo(
        connection, todo.id, member_id, "Task", True, None
    )
    new_todo = await select_todo(connection, todo.id, 1)
    assert new_todo is not None
    assert new_todo.complete is complete</pre>
<p>The <a id="_idIndexMarker178"/>parametrization provides two tests. The first test ensures that the member with <strong class="source-inline">member_id 1</strong> can update their to-do, and the second test ensures that the member with <strong class="source-inline">member_id 2</strong> cannot update another user’s to-do.</p>
<p>While we have these important tests in place, we can’t run them until we create the database tables via a migration.</p>
<h2 id="_idParaDest-78"><a id="_idTextAnchor082"/>Running the first migration</h2>
<p>While we’ve written the SQL queries required to create the database schema, they haven’t run <a id="_idIndexMarker179"/>against the database. To run these, Quart-DB provides a migration system, whereby we can run queries as the backend starts, but only if they haven’t already run. To make use of this, we can add the following code to <em class="italic">backend/src/backend/migrations/0.py</em>:</p>
<pre class="source-code">
from quart_db import Connection
 
async def migrate(connection: Connection) -&gt; None:
    await connection.execute(
        """CREATE TABLE members (
               id INT PRIMARY KEY GENERATED ALWAYS AS IDENTITY,
               created TIMESTAMP NOT NULL DEFAULT now(),
               email TEXT NOT NULL,
               email_verified TIMESTAMP,
               password_hash TEXT NOT NULL
           )""",
    )
    await connection.execute(
        """CREATE UNIQUE INDEX members_unique_email_idx 
                            ON members (LOWER(email)
        )"""
    )
    await connection.execute(
        """CREATE TABLE todos (
               id BIGINT PRIMARY KEY GENERATED ALWAYS AS                  IDENTITY,
               complete BOOLEAN NOT NULL DEFAULT FALSE,
               due TIMESTAMPTZ,
               member_id INT NOT NULL REFERENCES members(id),
               task TEXT NOT NULL
           )""",
    )
async def valid_migration(connection: Connection) -&gt; bool:
    return True</pre>
<p>To see this migration take effect, you can run <strong class="source-inline">pdm run recreate-db</strong> and then start the backend (as the migration will run as the backend starts up). You can then use <strong class="source-inline">psql –U tozo</strong> to <a id="_idIndexMarker180"/>inspect the database and see the two new tables as shown in <em class="italic">Figure 3.1</em>:</p>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US"> </p>
<div>
<div class="IMG---Figure" id="_idContainer015">
<img alt="Figure 3.1: The database schema after the migration.  " height="315" src="image/B18727_03_01.jpg" width="724"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 3.1: The database schema after the migration. </p>
<p>There is a one-to-many relationship between the <strong class="source-inline">members</strong> and <strong class="source-inline">todos</strong> tables such that one member has many to-dos. Also note the <strong class="source-inline">schema_migration</strong> table is created and managed by Quart-DB to track migrations.</p>
<h2 id="_idParaDest-79"><a id="_idTextAnchor083"/>Adding test and development data</h2>
<p>It is helpful to <a id="_idIndexMarker181"/>have some standardized initial data in <a id="_idIndexMarker182"/>the database when developing and running tests; for example, we can add a standard member with known credentials to log in, rather than have to create a new member every time the database is recreated. To do this, we can utilize the data path feature in Quart-DB.</p>
<p>For ease of use, we’ll add a single member to the database by adding the following to <em class="italic">backend/src/backend/migrations/data.py</em>:</p>
<pre class="source-code">
from quart_db import Connection 
 
async def execute(connection: Connection) -&gt; None:
    await connection.execute(
        """INSERT INTO members (email, password_hash)
                VALUES ('member@tozo.dev', '$2b$14$6yXjNza30kPCg3LhzZJfqeCWOLM.zyTiQFD4rdWlFHBTfYzzKJMJe'
           )"""
    )
    await connection.execute(
        """INSERT INTO todos (member_id, task)
                VALUES (1, 'Test Task')"""
    )</pre>
<p>The password <a id="_idIndexMarker183"/>hash value corresponds to a value <a id="_idIndexMarker184"/>of <strong class="source-inline">password</strong>, which means the login will be with the email, password combination of <strong class="source-inline">member@tozo.dev</strong>, <strong class="source-inline">password</strong>. </p>
<p>To instruct Quart-DB to load and run this file, we need to add the following configuration variable to <em class="italic">backend/development.env</em> and <em class="italic">backend/testing.env</em>:</p>
<p class="source-code">TOZO_QUART_DB_DATA_PATH="migrations/data.py"</p>
<p>We can now run the tests and check that they pass by running the following in the <em class="italic">backend</em> directory:</p>
<p class="source-code">pdm run test</p>
<p>Now we’ve defined the data stored by the backend, we can focus on the API, starting with session management.</p>
<h1 id="_idParaDest-80"><a id="_idTextAnchor084"/>Building the session API</h1>
<p>To manage user sessions, we need a <strong class="bold">session</strong> (authentication) API that provides routes to log in and log <a id="_idIndexMarker185"/>out (i.e., to create and delete sessions). Login should result in a cookie being set, and logout results in the cookie being deleted. As per the authentication setup, login should require an email and matching password. We’ll add this API via a sessions blueprint containing login, logout, and status functionality.</p>
<h2 id="_idParaDest-81"><a id="_idTextAnchor085"/>Creating the blueprint</h2>
<p>A blueprint is a <a id="_idIndexMarker186"/>collection of route handlers and is useful to associate <a id="_idIndexMarker187"/>the related session functionality. It can be created with <a id="_idIndexMarker188"/>the following code in <em class="italic">backend/src/backend/blueprints/sessions.py</em>:</p>
<pre class="source-code">
from quart import Blueprint
blueprint = Blueprint("sessions", __name__)</pre>
<p>The blueprint then needs to be registered with the app, by adding the following to <em class="italic">backend/src/backend/run.py</em>:</p>
<pre class="source-code">
from backend.blueprints.sessions import blueprint as sessions_blueprint
app.register_blueprint(sessions_blueprint)</pre>
<p>With the blueprint created, we can now add specific functionality as routes.</p>
<h2 id="_idParaDest-82"><a id="_idTextAnchor086"/>Adding login functionality</h2>
<p>The login functionality is <a id="_idIndexMarker189"/>described in a RESTful style as <a id="_idIndexMarker190"/>creating a session, and hence the route should be <strong class="source-inline">POST,</strong> expecting <a id="_idIndexMarker191"/>an email, a password, and a remember flag returning <strong class="source-inline">200</strong> on success and <strong class="source-inline">401</strong> on invalid credentials. This is done via the <a id="_idIndexMarker192"/>following, which should be added to <em class="italic">backend/src/backend/blueprints/sessions.py</em>:</p>
<pre class="source-code">
from dataclasses import dataclass
from datetime import timedelta
 
import bcrypt
from pydantic import EmailStr
from quart import g, ResponseReturnValue
from quart_auth import AuthUser, login_user
from quart_rate_limiter import rate_limit
from quart_schema import validate_request
 
from backend.lib.api_error import APIError
from backend.models.member import select_member_by_email
 
@dataclass
class LoginData:
    email: EmailStr
    password: str
    remember: bool = False
 
@blueprint.post("/sessions/")
@rate_limit(5, timedelta(minutes=1))
@validate_request(LoginData)
async def login(data: LoginData) -&gt; ResponseReturnValue:
    """Login to the app.
 
    By providing credentials and then saving the     returned cookie.
    """
    result = await select_member_by_email(        g.connection, data.email     )
    if result is None:
        raise APIError(401, "INVALID_CREDENTIALS")
    passwords_match = bcrypt.checkpw(
        data.password.encode("utf-8"),
        result.password_hash.encode("utf-8"),
    )
    if passwords_match:
        login_user(AuthUser(str(result.id)), data.remember)
        return {}, 200
    else:
        raise APIError(401, "INVALID_CREDENTIALS")</pre>
<p>This route is rate limited to a lower limit than others (five requests a minute) to prevent malicious actors from <a id="_idIndexMarker193"/>brute forcing the login. This is where the <a id="_idIndexMarker194"/>malicious actor keeps trying different passwords in the hope that one will eventually be correct and allow login. </p>
<p>The route also validates the request data has the correct <strong class="source-inline">LoginData</strong> structure, which ensures that users correctly use this route, and prevents invalid data from causing errors in the route handler code. </p>
<p>The route itself tries to fetch the member’s details from the database given the email provided in the request data. If there is no data, a <strong class="source-inline">401</strong> response is returned. The password provided in the request data is then checked against the password hash in the database, with a match resulting in the member being logged in with a <strong class="source-inline">200</strong> response. If the passwords don’t match, a <strong class="source-inline">401</strong> response is returned.</p>
<p class="callout-heading">Trailing slashes</p>
<p class="callout">For this route, and for all others in the app, I’ve added a trailing slash so that the path is <strong class="source-inline">/sessions/</strong> rather than <strong class="source-inline">/sessions</strong>. This is a useful convention to follow as requests to <strong class="source-inline">/sessions</strong> will be automatically redirected to <strong class="source-inline">/sessions/</strong> and hence work despite the missing slash, whereas requests to <strong class="source-inline">/sessions/</strong> would not be redirected to <strong class="source-inline">/session</strong> if the route was defined without the trailing slash.</p>
<p>Logging in results in a <a id="_idIndexMarker195"/>cookie being stored in the member’s <a id="_idIndexMarker196"/>browser, which is then sent in every subsequent request. The presence and value of this cookie are used to determine whether the member is logged in, and which member made the request.</p>
<p class="callout-heading">Account enumeration</p>
<p class="callout">This implementation will allow an attacker to enumerate emails present in the database, which can be considered a security issue. See <a href="B18727_07.xhtml#_idTextAnchor180"><em class="italic">Chapter 7</em></a><em class="italic">, Securing and Packaging the App</em>, for how to mitigate against this.</p>
<h2 id="_idParaDest-83"><a id="_idTextAnchor087"/>Adding logout functionality</h2>
<p>A logout route is described <a id="_idIndexMarker197"/>as a session deletion in a RESTful style, therefore the <a id="_idIndexMarker198"/>route should be  <strong class="source-inline">DELETE</strong>, returning <a id="_idIndexMarker199"/><strong class="source-inline">200</strong>. The following should be added to <em class="italic">backend/src/backend/blueprints/sessions.py</em>:</p>
<pre class="source-code">
from quart_auth import logout_user
from quart_rate_limiter import rate_exempt
 
@blueprint.delete("/sessions/")
@rate_exempt
async def logout() -&gt; ResponseReturnValue:
    """Logout from the app.
 
    Deletes the session cookie.
    """
    logout_user()
    return {}</pre>
<p>This route is rate exempt as nothing should prevent a member from logging out – it is important that the <a id="_idIndexMarker200"/>logout function works so that members are logged <a id="_idIndexMarker201"/>out when they want to be. The route then only needs to call <strong class="source-inline">logout_user</strong>, which results in the cookie being deleted.</p>
<p class="callout-heading">Idempotent routes</p>
<p class="callout">Idempotence is a property of a route where the final state is achieved no matter how many times the route is <a id="_idIndexMarker202"/>called, that is, calling the route once or 10 times has the same effect. This is a useful property as it means the route can be safely retried if the request fails. For RESTful and HTTP APIs, the routes using <strong class="source-inline">GET</strong>, <strong class="source-inline">PUT</strong>, and <strong class="source-inline">DELETE</strong> verbs are expected to be idempotent. In this book, the routes using the <strong class="source-inline">GET</strong>, <strong class="source-inline">PUT</strong>, and <strong class="source-inline">DELETE</strong> verbs are idempotent.</p>
<h2 id="_idParaDest-84"><a id="_idTextAnchor088"/>Adding status functionality</h2>
<p>It is useful to have <a id="_idIndexMarker203"/>a route that returns the current <a id="_idIndexMarker204"/>session (status) as we’ll use it for debugging and testing. For a RESTful API, this should be a <strong class="source-inline">GET</strong> route, and the following should be added to <em class="italic">backend/src/backend/blueprints/sessions.py</em>:</p>
<pre class="source-code">
from quart_auth import current_user, login_required
from quart_schema import validate_response
 
@dataclass
class Status:
    member_id: int
 
@blueprint.get("/sessions/")
@rate_limit(10, timedelta(minutes=1))
@login_required
@validate_response(Status)
async def status() -&gt; ResponseReturnValue:
<strong class="bold">    assert current_user.auth_id is not None  # nosec</strong>
    return Status(member_id=int(current_user.auth_id))</pre>
<p>The highlighted assertion is used to inform the type checker that <strong class="source-inline">current_user.auth_id</strong> cannot be <strong class="source-inline">None</strong> in this function, and hence prevents the type checker from <a id="_idIndexMarker205"/>considering the subsequent line <a id="_idIndexMarker206"/>as an error. The <strong class="source-inline"># nosec</strong> comment informs the bandit security checker that this use of <strong class="source-inline">assert</strong> is not a security risk.</p>
<p>The route is rate limited for protection and will only run if the request has the correct cookie present from login. The route returns the member’s ID based on the value in the cookie as this is also very useful.</p>
<h2 id="_idParaDest-85"><a id="_idTextAnchor089"/>Testing the routes</h2>
<p>We should test <a id="_idIndexMarker207"/>that these routes work as a user would expect, starting by testing that a user can log in, get their status, and then log out as a complete flow. This is tested by adding the following to <em class="italic">backend/tests/blueprints/test_sessions.py</em>:</p>
<pre class="source-code">
from quart import Quart
 
async def test_session_flow(app: Quart) -&gt; None:
    test_client = app.test_client()
    await test_client.post(
        "/sessions/",
        json={
            "email": "member@tozo.dev", "password": "password"
        },
    )
    response = await test_client.get("/sessions/")
    assert (await response.get_json())["memberId"] == 1
    await test_client.delete("/sessions/")
    response = await test_client.get("/sessions/")
    assert response.status_code == 401</pre>
<p>This test ensures that a member can log in and then access routes that require them to be logged in. It then logs the member out and checks that they can no longer access the route. </p>
<p>We should <a id="_idIndexMarker208"/>also test that the login route returns the correct response if the wrong credentials are provided by adding the following test to <em class="italic">backend/tests/blueprints/test_sessions.py</em>:</p>
<pre class="source-code">
async def test_login_invalid_password(app: Quart) -&gt; None:
    test_client = app.test_client()
    await test_client.post(
        "/sessions/",
        json={
            "email": "member@tozo.dev", "password": "incorrect"
        },
    )
    response = await test_client.get("/sessions/")
    assert response.status_code == 401</pre>
<p>This is all we <a id="_idIndexMarker209"/>need to allow members to log in and log out. Next, we can focus on managing members.</p>
<h1 id="_idParaDest-86"><a id="_idTextAnchor090"/>Building the member API</h1>
<p>To manage <a id="_idIndexMarker210"/>members, we need an API that provides routes to create a member (register), confirm the email address, change the password, request a password reset, and reset a password. </p>
<p>We’ll add this API via a blueprint for the member, containing registration, email confirmation, changing password, and password reset functionality.</p>
<h2 id="_idParaDest-87"><a id="_idTextAnchor091"/>Creating the members blueprint</h2>
<p>To begin, we <a id="_idIndexMarker211"/>should create a blueprint for all the member routes, it is created with the following code in <em class="italic">backend/src/backend/blueprints/members.py</em>:</p>
<pre class="source-code">
from quart import Blueprint
blueprint = Blueprint("members", __name__)</pre>
<p>The blueprint then needs to be registered with the app, by adding the following to <em class="italic">backend/src/backend/run.py</em>:</p>
<pre class="source-code">
from backend.blueprints.members import blueprint as members_blueprint
app.register_blueprint(members_blueprint)</pre>
<p>With the blueprint created, we can now add the specific functionality as routes.</p>
<h2 id="_idParaDest-88"><a id="_idTextAnchor092"/>Creating a member</h2>
<p>In our app, we want users to be able to register as members. This requires a route that accepts an email <a id="_idIndexMarker212"/>and a password. The route should then check the password is sufficiently complex, create a new member, and send a welcome email. As the route creates a member, it should use the <strong class="source-inline">POST</strong> method to be in the RESTful style.</p>
<p>We’ll add a link to the welcome email that the recipient of the email can visit to prove they registered with our app. This way, we have verified that the email address owner is the same user that registered. The link will work by including an authentication token in the path, with the token working as explained in <a href="B18727_02.xhtml#_idTextAnchor053"><em class="italic">Chapter 2</em></a>, <em class="italic">Creating a Reusable Backend with Quart</em>. </p>
<p>We can do this by first creating an email template by adding the following to <em class="italic">backend/src/backend/templates/welcome.xhtml</em>:</p>
<pre class="source-code">
{% extends "email.xhtml" %}
{% block welcome %}
  Hello and welcome to tozo!
{% endblock %}
{% block content %}
  Please confirm you signed up by following this 
  &lt;a href="{{ config['BASE_URL'] }}/confirm-email/{{ token }}/"&gt;
    link
  &lt;/a&gt;.
{% endblock %}</pre>
<p>The route itself should return <strong class="source-inline">201</strong> on success, as this status code indicates a successful creation. This is all achieved by adding the following to <em class="italic">backend/src/backend/blueprints/members.py</em>:</p>
<pre class="source-code">
from dataclasses import dataclass
from datetime import timedelta
 
import asyncpg  # type: ignore
import bcrypt
from itsdangerous import URLSafeTimedSerializer
from quart import current_app, g, ResponseReturnValue
from quart_schema import validate_request
from quart_rate_limiter import rate_limit
from zxcvbn import zxcvbn  # type: ignore
 
from backend.lib.api_error import APIError
from backend.lib.email import send_email
from backend.models.member import insert_member
 
MINIMUM_STRENGTH = 3
EMAIL_VERIFICATION_SALT = "email verify"
 
@dataclass
class MemberData:
    email: str
    password: str
 
@blueprint.post("/members/")
@rate_limit(10, timedelta(seconds=10))
@validate_request(MemberData)
async def register(data: MemberData) -&gt; ResponseReturnValue:
    """Create a new Member.
 
    This allows a Member to be created.
    """
    strength = zxcvbn(data.password)
    if strength["score"] &lt; MINIMUM_STRENGTH:
        raise APIError(400, "WEAK_PASSWORD")
 
    hashed_password = bcrypt.hashpw(
        data.password.encode("utf-8"), 
        bcrypt.gensalt(14),
    )
    try:
        member = await insert_member(
            g.connection, 
            data.email, 
            hashed_password.decode(),
        )
    except asyncpg.exceptions.UniqueViolationError:
        pass
    else:
        serializer = URLSafeTimedSerializer(
            current_app.secret_key,             salt=EMAIL_VERIFICATION_SALT,
        )
        token = serializer.dumps(member.id)
        await send_email(
            member.email, 
            "Welcome", 
            "welcome.xhtml", 
            {"token": token},
        )
    return {}, 201</pre>
<p>As can be seen, the password strength is first checked, using <strong class="source-inline">zxcvbn</strong>, with weak passwords resulting in a <strong class="source-inline">400</strong> response. The password is then hashed and used with the email to insert a <a id="_idIndexMarker213"/>member. The new member’s ID is then used to create an email verification token, which is rendered into the email body before being sent to the given email address. </p>
<p>When the user follows the link, they will return to our app with the token for the email confirmation route to check.</p>
<h2 id="_idParaDest-89"><a id="_idTextAnchor093"/>Confirming the email address</h2>
<p>When a user registers as a member, they are sent a link back to our app that includes an email <a id="_idIndexMarker214"/>verification token. The token identifies the member and hence confirms that the email address is correct. Therefore, we need a route that accepts the token and, if valid, confirms the email address. This updates the member’s email property in a RESTful sense and hence is achieved by adding the following to <em class="italic">backend/src/backend/blueprints/members.py</em>:</p>
<pre class="source-code">
from itsdangerous import BadSignature, SignatureExpired 
from backend.models.member import update_member_email_verified
ONE_MONTH = int(timedelta(days=30).total_seconds()) 
 
@dataclass
class TokenData:
    token: str
 
@blueprint.put("/members/email/")
@rate_limit(5, timedelta(minutes=1))
@validate_request(TokenData)
async def verify_email(data: TokenData) -&gt; ResponseReturnValue:
    """Call to verify an email.
 
    This requires the user to supply a valid token.
    """
    serializer = URLSafeTimedSerializer(
        current_app.secret_key, salt=EMAIL_VERIFICATION_SALT
    )
    try:
        member_id = serializer.loads(            data.token, max_age=ONE_MONTH         )
    except SignatureExpired:
        raise APIError(403, "TOKEN_EXPIRED")
    except BadSignature:
        raise APIError(400, "TOKEN_INVALID")
    else:
        await update_member_email_verified(g.connection,          member_id)
    return {} </pre>
<p>The token is checked via the <strong class="source-inline">loads</strong> method, and if it is expired a <strong class="source-inline">403</strong> response is returned, whereas <a id="_idIndexMarker215"/>if it is invalid a <strong class="source-inline">400</strong> response is returned. If the token is good, the member’s email is marked as verified in the database and a <strong class="source-inline">200</strong> response is returned.</p>
<p>Once a user has registered, and hopefully verified their email, they will want to be able to change their password.</p>
<h2 id="_idParaDest-90"><a id="_idTextAnchor094"/>Changing passwords</h2>
<p>A user will want to <a id="_idIndexMarker216"/>change their password, which requires a route that accepts their new password and their old password. The old password is checked to make the member’s account more secure, as a malicious user gaining access via an unattended computer cannot change the member’s password (without also knowing the member’s password). The route will also need to check that the new password has sufficient complexity as with the registration route.</p>
<p>The route should also inform the user that the password has been changed by email. Doing so makes the member’s account more secure as the member can take corrective action if they are informed about a password change that they didn’t authorize. This email is defined by adding the following to <em class="italic">backend/src/backend/templates/password_changed.xhtml</em>:</p>
<pre class="source-code">
{% extends "email.xhtml" %}
 
{% block content %}
  Your Tozo password has been successfully changed.
{% endblock %}</pre>
<p>This route will update the password, which in a RESTful style means a <strong class="source-inline">PUT</strong> route on the member’s <a id="_idIndexMarker217"/>password resource that returns <strong class="source-inline">200</strong> on success. It should return a <strong class="source-inline">400</strong> response if the password is not complex enough and a <strong class="source-inline">401</strong> response if the old password is incorrect. The following should be added to <em class="italic">backend/src/backend/blueprints/members.py</em>:</p>
<pre class="source-code">
from typing import cast
from quart_auth import current_user, login_required
from backend.models.member import select_member_by_id, update_member_password
 
@dataclass
class PasswordData:
    current_password: str
    new_password: str
 
@blueprint.put("/members/password/")
@rate_limit(5, timedelta(minutes=1))
@login_required
@validate_request(PasswordData)
async def change_password(data: PasswordData) -&gt; ResponseReturnValue:
    """Update the members password.
 
    This allows the user to update their password.
    """
    strength = zxcvbn(data.new_password)
    if strength["score"] &lt; MINIMUM_STRENGTH:
        raise APIError(400, "WEAK_PASSWORD")
 
    member_id = int(cast(str, current_user.auth_id))
    member = await select_member_by_id(
        g.connection, member_id
    )
    assert member is not None  # nosec
    passwords_match = bcrypt.checkpw(
        data.current_password.encode("utf-8"),
        member.password_hash.encode("utf-8"),
    )
    if not passwords_match:
        raise APIError(401, "INVALID_PASSWORD")
 
    hashed_password = bcrypt.hashpw(
        data.new_password.encode("utf-8"),
        bcrypt.gensalt(14),
    )
    await update_member_password(
        g.connection, member_id, hashed_password.decode()
    )
    await send_email(
        member.email, 
        "Password changed", 
        "password_changed.xhtml", 
        {},
    )
    return {}</pre>
<p>As with the login route, this route has a lower rate limit to mitigate against brute force attacks. The code then checks the password strength before checking that the old password matches <a id="_idIndexMarker218"/>the hash stored in the database. If these checks pass, the password hash in the database is updated and an email is sent to the member.</p>
<p>This functionality is intentionally not useful for member’s that have forgotten their password. In that case, they first need to request a password reset.</p>
<h2 id="_idParaDest-91"><a id="_idTextAnchor095"/>Requesting a password reset</h2>
<p>If a member forgets their password, they’ll want a way to reset it. This is typically provided by <a id="_idIndexMarker219"/>emailing the member a link that they can follow to a<a id="_idTextAnchor096"/> password reset page with the link containing a token to authorize the reset – as with the email verification. For this to work, we first need a route that accepts the user’s email address and sends out the link. To start, let’s add the following email content to <em class="italic">backend/src/backend/templates/forgotten_password.xhtml</em>:</p>
<pre class="source-code">
{% extends "email.xhtml" %}
{% block content %}
  You can use this 
  &lt;a href="{{ config['BASE_URL'] }}/reset-password/{{ token     }}/"&gt;
    link
  &lt;/a&gt; 
  to reset your password.
{% endblock %}</pre>
<p>The route itself should accept an email address, and in the RESTful style should be a <strong class="source-inline">PUT</strong> to the <a id="_idIndexMarker220"/>member email resource. The following should be added to <em class="italic">backend/src/backend/blueprints/members.py</em>:</p>
<pre class="source-code">
from pydantic import EmailStr
from backend.models.member import select_member_by_email
 
FORGOTTEN_PASSWORD_SALT = "forgotten password"  # nosec
 
@dataclass
class ForgottenPasswordData:
    email: EmailStr
 
@blueprint.put("/members/forgotten-password/")
@rate_limit(5, timedelta(minutes=1))
@validate_request(ForgottenPasswordData)
async def forgotten_password(data: ForgottenPasswordData) -&gt; ResponseReturnValue:
    """Call to trigger a forgotten password email.
 
    This requires a valid member email.
    """
    member = await select_member_by_email(        g.connection, data.email     )
    if member is not None:
        serializer = URLSafeTimedSerializer(
            current_app.secret_key,             salt=FORGOTTEN_PASSWORD_SALT,
        )
        token = serializer.dumps(member.id)
        await send_email(
            member.email, 
            "Forgotten password", 
            "forgotten_password.xhtml", 
            {"token": token},
        )
    return {}</pre>
<p>This route creates a token using the forgotten-password salt. It is important that the salt differs to <a id="_idIndexMarker221"/>ensure that these tokens cannot be used in place of the email verification token and vice versa. The token is then rendered into the email and sent to the member. </p>
<h2 id="_idParaDest-92"><a id="_idTextAnchor097"/>Resetting the password</h2>
<p>If the member follows the link emailed out by the previous route, they will visit a page that allows <a id="_idIndexMarker222"/>them to enter a new password. Therefore, we need a route that accepts the new password and the token. This is achieved by adding the following to <em class="italic">backend/src/backend/blueprints/members.py</em>:</p>
<pre class="source-code">
ONE_DAY = int(timedelta(hours=24).total_seconds())
@dataclass
class ResetPasswordData:
    password: str
    token: str
 
@blueprint.put("/members/reset-password/")
@rate_limit(5, timedelta(minutes=1))
@validate_request(ResetPasswordData)
async def reset_password(data: ResetPasswordData) -&gt; ResponseReturnValue:
    """Call to reset a password using a token.
 
    This requires the user to supply a valid token and a
    new password.
    """
    serializer = URLSafeTimedSerializer(
        current_app.secret_key, salt=FORGOTTEN_PASSWORD_SALT
    )
    try:
        member_id = serializer.loads(data.token, max_age=ONE_          DAY)
    except SignatureExpired:
        raise APIError(403, "TOKEN_EXPIRED")
    except BadSignature:
        raise APIError(400, "TOKEN_INVALID")
    else:
        strength = zxcvbn(data.password)
        if strength["score"] &lt; MINIMUM_STRENGTH:
            raise APIError(400, "WEAK_PASSWORD")
 
        hashed_password = bcrypt.hashpw(
            data.password.encode("utf-8"), 
            bcrypt.gensalt(14),
        )
        await update_member_password(
            g.connection, member_id, hashed_password.decode()
        )
        member = await select_member_by_id(
            g.connection, int(cast(str, current_user.auth_id))
        )
        assert member is not None  # nosec
        await send_email(
            member.email, 
            "Password changed", 
            "password_changed.xhtml", 
            {},
        )
    return {}</pre>
<p>This route checks whether the token is valid, returning either a <strong class="source-inline">400</strong> if it is not or a <strong class="source-inline">403</strong> if it has <a id="_idIndexMarker223"/>expired. The expiry is important as it protects against a member’s email being exposed in the future (as the token will have expired and hence is useless). Then, if the password is strong enough, the new hash is placed into the database.</p>
<p class="callout-heading">Managing members</p>
<p class="callout">We’ve added functionality to create members and manage members’ passwords. However, we haven’t added functionality to manage a member’s account itself, for example, to close and delete it. This functionality will be dependent on the regulatory rules of your app as, for example, you may be required to keep data for a certain length of time. </p>
<p>With this route, we have all <a id="_idIndexMarker224"/>the functionality we require for member accounts and can now focus on testing the functionality.</p>
<h2 id="_idParaDest-93"><a id="_idTextAnchor098"/>Testing the routes</h2>
<p>We should <a id="_idIndexMarker225"/>test that these routes work as a user would expect. Firstly, let’s test that new members can register and then log in by adding the following to <em class="italic">backend/tests/blueprints/test_members.py</em>:</p>
<pre class="source-code">
import pytest
from quart import Quart
 
async def test_register(
    app: Quart, caplog: pytest.LogCaptureFixture 
) -&gt; None:
    test_client = app.test_client()
    data = {
        "email": "new@tozo.dev", 
        "password": "testPassword2$",
    }
    await test_client.post("/members/", json=data)
    response = await test_client.post("/sessions/", json=data)
    assert response.status_code == 200
    assert "Sending welcome.xhtml to new@tozo.dev" in caplog.text</pre>
<p>This test registers a new member with the email <strong class="source-inline">new@tozo.dev</strong> and then checks that the welcome <a id="_idIndexMarker226"/>email was sent to this address. Next, we need to check that the user can confirm their email address by adding the following to <em class="italic">backend/tests/blueprints/test_members.py</em>:</p>
<pre class="source-code">
from itsdangerous import URLSafeTimedSerializer
from freezegun import freeze_time
from backend.blueprints.members import EMAIL_VERIFICATION_SALT
@pytest.mark.parametrize(
    "time, expected",
    [("2022-01-01", 403), (None, 200)],
)
async def test_verify_email(
    app: Quart, time: str | None, expected: int
) -&gt; None:
    with freeze_time(time):
        signer = URLSafeTimedSerializer(
            app.secret_key, salt= EMAIL_VERIFICATION_SALT
        )
        token = signer.dumps(1)
    test_client = app.test_client()
    response = await test_client.put(
        "/members/email/", json={"token": token}
    )
    assert response.status_code == expected
async def test_verify_email_invalid_token(app: Quart) -&gt; None:
    test_client = app.test_client()
    response = await test_client.put( 
        "/members/email/", json={"token": "invalid"} 
    ) 
    assert response.status_code == 400</pre>
<p>The highlighted line allows us to ensure that expired tokens result in a <strong class="source-inline">403</strong> response while current tokens succeed. The second test ensures that invalid tokens result in a <strong class="source-inline">400</strong> response.</p>
<p>Next, we will <a id="_idIndexMarker227"/>test that members can change their password by adding the following to <em class="italic">backend/tests/blueprints/test_members.py</em>:</p>
<pre class="source-code">
async def test_change_password(
    app: Quart, caplog: pytest.LogCaptureFixture 
) -&gt; None:
    test_client = app.test_client()
    data = {
        "email": "new_password@tozo.dev", 
        "password": "testPassword2$",
    }
    response = await test_client.post("/members/", json=data)
    async with test_client.authenticated("2"):  # type: ignore
        response = await test_client.put(
            "/members/password/", 
            json={
                "currentPassword": data["password"], 
                "newPassword": "testPassword3$",
            }
        )
        assert response.status_code == 200
    assert "Sending password_changed.xhtml to new@tozo.dev" in caplog.text</pre>
<p>This test registers a new member and then, while authenticated as that member, changes the password.</p>
<p>Then we can <a id="_idIndexMarker228"/>test that a user that has forgotten their password can request a reset link by adding the following to <em class="italic">backend/tests/blueprints/test_members.py</em>:</p>
<pre class="source-code">
async def test_forgotten_password(
    app: Quart, caplog: pytest.LogCaptureFixture 
) -&gt; None:
    test_client = app.test_client()
    data = {"email": "member@tozo.dev"}
    response = await test_client.put(
        "/members/forgotten-password/", json=data
    )
    assert response.status_code == 200
    assert "Sending forgotten_password.xhtml to member@tozo.dev" in caplog.text</pre>
<p>Now we have these simple tests in place, we can focus on the To-Do API.</p>
<h1 id="_idParaDest-94"><a id="_idTextAnchor099"/>Building the To-Do API</h1>
<p>To manage to-dos, we <a id="_idIndexMarker229"/>need an API that provides functionality to create a new to-do, retrieve a to-do or to-dos, update a to-do, and delete a to-do (i.e., an API that has CRUD functionality). We’ll do this by creating a to-do blueprint with a route per CRUD function.</p>
<p class="callout-heading">CRUD functionality</p>
<p class="callout"><strong class="bold">CRUD</strong> stands for <strong class="source-inline">Create</strong>, <strong class="source-inline">Read</strong>, <strong class="source-inline">Update</strong>, and <strong class="source-inline">Delete</strong>, and is used to describe a set of <a id="_idTextAnchor100"/>funct<a id="_idTextAnchor101"/>ionalities. It is <a id="_idIndexMarker230"/>often used to describe the functionality of RESTful APIs. Typically, for a RESTFul API, the Create route uses the <strong class="source-inline">POST</strong> HTTP method, Read uses <strong class="source-inline">GET,</strong> Update uses <strong class="source-inline">PUT</strong>, and Delete uses <strong class="source-inline">DELETE</strong>.</p>
<h2 id="_idParaDest-95"><a id="_idTextAnchor102"/>Creating the blueprint</h2>
<p>The blueprint <a id="_idIndexMarker231"/>itself can be created with the following code in <em class="italic">backend/src/backend/blueprints/todos.py</em>:</p>
<pre class="source-code">
from quart import Blueprint
blueprint = Blueprint("todos", __name__)</pre>
<p>The blueprint then needs to be registered with the app, by adding the following to <em class="italic">backend/src/backend/run.py</em>:</p>
<pre class="source-code">
from backend.blueprints.todos import blueprint as todos_blueprint
app.register_blueprint(todos_blueprint)</pre>
<p>With the blueprint created, we can now add specific functionality as routes.</p>
<h2 id="_idParaDest-96"><a id="_idTextAnchor103"/>Creating a to-do</h2>
<p>The first functionality we <a id="_idIndexMarker232"/>need is to create a to-do. The route should expect the to-do data and return the complete to-do with a <strong class="source-inline">201</strong> status code on success. Returning the complete to-do is useful as it contains the to-do’s ID and confirms that the data is added. A RESTful to-do creation route should use the POST verb <a id="_idIndexMarker233"/>and have a <strong class="source-inline">/todos/</strong> path. The following should be added to <em class="italic">backend/src/backend/blueprints/todos.py</em>:</p>
<pre class="source-code">
from dataclasses import dataclass 
from datetime import datetime, timedelta
from typing import cast
 
from quart import g
from quart_auth import current_user, login_required
from quart_schema import validate_request, validate_response
from quart_rate_limiter import rate_limit
 
from backend.models.todo import insert_todo, Todo
@dataclass
class TodoData:
    complete: bool
    due: datetime | None
    task: str
 
@blueprint.post("/todos/")
@rate_limit(10, timedelta(seconds=10))
@login_required
@validate_request(TodoData)
@validate_response(Todo, 201)
async def post_todo(data: TodoData) -&gt; tuple[Todo, int]:
    """Create a new Todo.
 
    This allows todos to be created and stored.
    """
    todo = await insert_todo(
        g.connection, 
        int(cast(str, current_user.auth_id)),
        data.task,
        data.complete,
        data.due,
    )
    return todo, 201</pre>
<p>The route is rate limited to prevent malicious usage, with the assumption that normal users are unlikely to create more than 10 to-dos in 10 seconds (1 a second on average). It is also a route that <a id="_idIndexMarker234"/>requires the user to be logged in. The final two decorators ensure that the request and response data represent the to-do data and a complete to-do.</p>
<p>The route function simply inserts the data into the database and returns the complete to-do. Next, users will need to read a to-do from the backend.</p>
<h2 id="_idParaDest-97"><a id="_idTextAnchor104"/>Reading a to-do</h2>
<p>Users will need to read a to-do based on its ID. This will be implemented as a <strong class="source-inline">GET</strong> route with the ID <a id="_idIndexMarker235"/>specified in the path. The route should then either return the to-do or a <strong class="source-inline">404</strong> response if the to-do does not exist. The following should be added to <em class="italic">backend/src/backend/blueprints/todos.py</em>:</p>
<pre class="source-code">
from backend.lib.api_error import APIError
from backend.models.todo import select_todo
 
@blueprint.get("/todos/&lt;int:id&gt;/")
@rate_limit(10, timedelta(seconds=10))
@login_required
@validate_response(Todo)
async def get_todo(id: int) -&gt; Todo:
    """Get a todo.
 
    Fetch a Todo by its ID.
    """
    todo = await select_todo(
        g.connection, id, int(cast(str, current_user.auth_id))
    )
    if todo is None:
        raise APIError(404, "NOT_FOUND")
    else:
        return todo</pre>
<p>As with the creation route, this route includes rate limiting protection, requires the user to be logged in, and <a id="_idIndexMarker236"/>validates the response data. It then selects the to-do from the database based on the ID given in the path and returns it or a <strong class="source-inline">404</strong> response if no to-do exists. Note that the <strong class="source-inline">select_todo</strong> function requires the member’s ID, ensuring that members cannot read other members’ to-dos.</p>
<p>While reading a single to-do is useful, a user will also need to read all their to-dos in one call, which we’ll add next.</p>
<h2 id="_idParaDest-98"><a id="_idTextAnchor105"/>Reading the to-dos</h2>
<p>A user will need to read all their to-dos, which for a RESTFul API should use the <strong class="source-inline">GET</strong> verb and return a list <a id="_idIndexMarker237"/>of to-dos on success. We’ll also allow the user to filter the to-dos based on the <strong class="source-inline">complete</strong> attribute, which should be optional and hence, in a RESTful API, is provided via a <strong class="source-inline">querystring</strong>. The <strong class="source-inline">querystring</strong> works via the request path, for example, <strong class="source-inline">/todos/?complete=true</strong> or <strong class="source-inline">/todos/?complete=false</strong>. The following should be added to <em class="italic">backend/src/backend/blueprints/todos.py</em>:</p>
<pre class="source-code">
from quart_schema import validate_querystring
 
from backend.models.todo import select_todos
 
@dataclass
class Todos:
    todos: list[Todo]
 
@dataclass
class TodoFilter:
    complete: bool | None = None
 
@blueprint.get("/todos/")
@rate_limit(10, timedelta(seconds=10))
@login_required
@validate_response(Todos)
@validate_querystring(TodoFilter)
async def get_todos(query_args: TodoFilter) -&gt; Todos:
    """Get the todos.
 
    Fetch all the Todos optionally based on the     complete status.
    """
    todos = await select_todos(
        g.connection, 
        int(cast(str, current_user.auth_id)), 
        query_args.complete,
    )
    return Todos(todos=todos)</pre>
<p>This route includes rate limit protection, requires logged-in usage, validates the response data, and <a id="_idIndexMarker238"/>includes validation of the <strong class="source-inline">querystring</strong> parameters. We can now move on to allowing updates to a to-do.</p>
<h2 id="_idParaDest-99"><a id="_idTextAnchor106"/>Updating a to-do</h2>
<p>We need to provide functionality for members to update the data that makes up a to-do. For a RESTFul API, this <a id="_idIndexMarker239"/>route should use the <strong class="source-inline">PUT</strong> verb, expect the to-do data, and return the complete to-do on success or a <strong class="source-inline">404</strong> if the to-do does not exist. The following should be added to <em class="italic">backend/src/backend/blueprints/todos.py</em>:</p>
<pre class="source-code">
from backend.models.todo import update_todo
 
@blueprint.put("/todos/&lt;int:id&gt;/")
@rate_limit(10, timedelta(seconds=10))
@login_required
@validate_request(TodoData)
@validate_response(Todo)
async def put_todo(id: int, data: TodoData) -&gt; Todo:
    """Update the identified todo
 
    This allows the todo to be replaced with the request data.
    """
    todo = await update_todo(
        g.connection, 
        id,  
        int(cast(str, current_user.auth_id)),
        data.task,
        data.complete,
        data.due,
    )
    if todo is None:
        raise APIError(404, "NOT_FOUND")
    else:
        return todo</pre>
<p>This route includes rate limit protection, requires logged-in usage, and validates the request and response <a id="_idIndexMarker240"/>data. It then updates the to-do and returns the updated to-do or a <strong class="source-inline">404</strong> response if there is no to-do for the provided ID. Next, we’ll allow users to delete to-dos. </p>
<h2 id="_idParaDest-100"><a id="_idTextAnchor107"/>Deleting a to-do</h2>
<p>For a RESTFul API, the <a id="_idIndexMarker241"/>to-do deletion route should use the <strong class="source-inline">DELETE</strong> verb, and return <strong class="source-inline">202</strong> whether the to-do exists or not. The following should be added to <em class="italic">backend/src/backend/blueprints/todos.py</em>:</p>
<pre class="source-code">
from quart import ResponseReturnValue
 
from backend.models.todo import delete_todo
 
@blueprint.delete("/todos/&lt;int:id&gt;/")
@rate_limit(10, timedelta(seconds=10))
@login_required
async def todo_delete(id: int) -&gt; ResponseReturnValue:
    """Delete the identified todo
 
    This will delete the todo.
    """
    await delete_todo(
        g.connection, id, int(cast(str, current_user.auth_id))
    )
    return "", 202</pre>
<p>This route includes rate limit protection, requires logged-in usage, and deletes the to-do with the <a id="_idIndexMarker242"/>given ID as long as it belongs to the logged-in member.</p>
<p>With all the functionality for to-dos in place, we can now focus on testing that it works correctly.</p>
<h2 id="_idParaDest-101"><a id="_idTextAnchor108"/>Testing the routes</h2>
<p>We should test <a id="_idIndexMarker243"/>that these routes work as a user would expect. Firstly, we need to ensure we can create new to-dos by adding the following to <em class="italic">backend/tests/blueprints/test_todos.py</em>:</p>
<pre class="source-code">
from quart import Quart
 
async def test_post_todo(app: Quart) -&gt; None:
    test_client = app.test_client()
    async with test_client.authenticated("1"):  # type: ignore
        response = await test_client.post(
            "/todos/", 
            json={
                "complete": False, "due": None, "task": "Test                    task"
            },
        )
        assert response.status_code == 201
        assert (await response.get_json())["id"] &gt; 0</pre>
<p>Next, we can ensure <a id="_idIndexMarker244"/>we can read to-dos by adding the following to <em class="italic">backend/tests/blueprints/test_todos.py</em>:</p>
<pre class="source-code">
async def test_get_todo(app: Quart) -&gt; None:
    test_client = app.test_client()
    async with test_client.authenticated("1"):  # type: ignore
        response = await test_client.get("/todos/1/")
        assert response.status_code == 200
        assert (await response.get_json())["task"] == "Test           Task"</pre>
<p>Continuing along the CRUD functionality, we can ensure that to-dos can be updated by adding the following to <em class="italic">backend/tests/blueprints/test_todos.py</em>:</p>
<pre class="source-code">
async def test_put_todo(app: Quart) -&gt; None: 
    test_client = app.test_client() 
    async with test_client.authenticated("1"):  # type: ignore    
        response = await test_client.post( 
            "/todos/",  
            json={ 
                "complete": False, "due": None, "task": "Test                    task"
            }, 
        )
        todo_id = (await response.get_json())["id"]
        response = await test_client.put(
            f"/todos/{todo_id}/",
            json={
                "complete": False, "due": None, "task":                   "Updated"
            },  
        )
        assert (await response.get_json())["task"] == "Updated"
        response = await test_client.get(f"/todos/{todo_id}/")
        assert (await response.get_json())["task"] == "Updated"</pre>
<p>Finally, we can <a id="_idIndexMarker245"/>ensure that to-dos can be deleted by adding the following to <em class="italic">backend/tests/blueprints/test_todos.py</em>:</p>
<pre class="source-code">
async def test_delete_todo(app: Quart) -&gt; None:  
    test_client = app.test_client()  
    async with test_client.authenticated("1"):  # type: ignore     
        response = await test_client.post(  
            "/todos/",   
            json={  
                "complete": False, "due": None, "task": "Test                   task"
            },  
        ) 
        todo_id = (await response.get_json())["id"]
        await test_client.delete(f"/todos/{todo_id}/")
        response = await test_client.get(f"/todos/{todo_id}/")
        assert response.status_code == 404</pre>
<p>With these tests, we have <a id="_idIndexMarker246"/>all the functionality we need to manage to-dos.</p>
<h1 id="_idParaDest-102"><a id="_idTextAnchor109"/>Summary</h1>
<p>In this chapter, we’ve defined how we are storing the data in the database and then built an API to manage sessions, members, and to-dos. This includes all the functionality our app will need via an easy-to-understand RESTful API.</p>
<p>While the to-do functionality is unlikely to be directly useful to your app, the CRUD functionality is a pattern you should use. In addition, the member and session APIs could be used directly in your app. Finally, you’ve hopefully gained an understanding of what makes a good RESTful API that you can apply and use elsewhere.</p>
<p>In the next chapter, we’ll create a styled frontend, including validated data entry in React, that we can use with this API or any other.</p>
<h1 id="_idParaDest-103"><a id="_idTextAnchor110"/>Further reading</h1>
<p>We’ve built a fairly simple RESTful API in this chapter. As your API’s complexity increases, I’d recommend following the best practices at <a href="https://www.vinaysahni.com/best-practices-for-a-pragmatic-restful-api">https://www.vinaysahni.com/best-practices-for-a-pragmatic-restful-api</a>.</p>
</div>
</div></body></html>