<html><head></head><body><div><div><div><div><h1 class="title"><a id="ch02"/>Chapter 2. Creating and Editing Objects</h1></div></div></div><a class="indexterm" id="id76"/><p>In a way, meshes are the most essential type of objects in a 3D application. They form the basis of most visible objects and are the raw material that might get rigged and animated further down the line. This chapter deals with the creation of meshes and with ways to manipulate a mesh object, both as a whole and as the individual entities it consists of—the vertices, edges, and faces.</p><div><img alt="Creating and Editing Objects" src="img/0400-02-01.jpg"/></div><p>In this chapter, you will learn:</p><div><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">How to create configurable mesh objects</li><li class="listitem" style="list-style-type: disc">How to design a graphical user interface </li><li class="listitem" style="list-style-type: disc">How to make your script store user choices for later reuse</li><li class="listitem" style="list-style-type: disc">How to select vertices and faces in a mesh</li><li class="listitem" style="list-style-type: disc">How to parent an object to another</li><li class="listitem" style="list-style-type: disc">How to create groups</li><li class="listitem" style="list-style-type: disc">How to modify meshes</li><li class="listitem" style="list-style-type: disc">How to run Blender from the command line and render in the background</li><li class="listitem" style="list-style-type: disc">How to process command-line parameters</li></ul></div><div><div><div><div><h1 class="title"><a id="ch02lvl1sec14"/>Creepy crawlies—a GUI to configure objects</h1></div></div></div><p>Instantiating a single copy of a one-off Blender object (like we did in the "hello world" example in <a class="link" href="ch01.html" title="Chapter 1. Extending Blender with Python">Chapter 1</a>, 
<em>Extending Blender with Python</em>) might be a good programming exercise, but an object creation script really comes into its own when built-in methods such as copying objects, or modifiers such as the array modifier, are not sufficient.<a class="indexterm" id="id77"/>
</p><p>A good example is where we want to create one or many object variants and these variants need to be easy to configure for the end user. For example, nuts and bolts come in many shapes and sizes so Blender comes included with a script to create them. Many more scripts are available on the Web to create anything from mechanical gears to stairs, from trees to church domes.</p><p>In this section, we show how to build a small application that can create all sorts of bug-like creatures and comes with a simple but effective GUI to set the many configurable parameters. This application also stores the user preferences for later reuse.</p><div><div><div><div><h2 class="title"><a id="ch02lvl2sec21"/>Building the user interface</h2></div></div></div><a class="indexterm" id="id78"/><p>Designing, building, and testing a graphical user interface can be a formidable task, but the Blender API provides us with tools to make this task a lot easier.<a class="indexterm" id="id79"/> The <code class="literal">Blender.Draw</code> module provides simple, but often used and easy to configure components to quickly put a user interface together. The <code class="literal">Blender.BGL</code> module gives access to all the nuts and bolts to design a graphical user interface from scratch. We will mostly use the former because it is almost everything we need but we give an example of the latter as well to design a simple error pop up. Our main user interface will look like this:</p><div><img alt="Building the user interface" src="img/0400-02-02.jpg"/></div><a class="indexterm" id="id80"/><p>When we invoke our script from the <strong>Add</strong> Menu (normally accessible from the menu bar at the top of the screen or by pressing the spacebar in the 3D view), the previous menu will pop up and the user can tweak the parameters to his or her liking. When the <strong>OK</strong> button is pressed the script generates an insect-like mesh. The pop up can also be exited by pressing <em>Esc,</em> in which case the script terminates without generating a mesh.</p></div><div><div><div><div><h2 class="title"><a id="ch02lvl2sec22"/>Creating bugs—some assembly required</h2></div></div></div><p>Our mission is to create simple creatures from a small sample of building blocks that may be chained together. The outline for our script is this:</p><div><ol class="orderedlist arabic"><li class="listitem">Import the building blocks for our creatures.</li><li class="listitem">Draw a user interface.</li><li class="listitem">Assemble the creature mesh from building blocks as defined by the user.</li><li class="listitem">Insert the mesh as an object into the scene.</li></ol></div><a class="indexterm" id="id81"/><p>We go through the script step-by-step showing the relevant parts in detail. (The full script is available as <code class="literal">creepycrawlies.py</code>.) The first step involves creating body parts that are suitable for assembling together. This means we have to model these parts in Blender, defining suitable joints and marking those joints as vertex groups. Then we export these meshes as Python code by using a script that we encounter again in the next chapter as it deals with vertex groups.</p><p>For now, we use this generated Python code simply as a module containing several lists of vertices defining each body part. We have to make sure that this module is somewhere in the Python path, for example, <code class="literal">.blender\scripts\bpymodules</code> would be a logical choice or alternatively the user <code class="literal">scriptdir</code>. The Python file with the mesh building blocks is called <code class="literal">mymesh.py</code> so the first part of our code contains the following <code class="literal">import</code> statement:</p><div><pre class="programlisting">import mymesh</pre></div></div><div><div><div><div><h2 class="title"><a id="ch02lvl2sec23"/>Creating a user interface</h2></div></div></div><a class="indexterm" id="id82"/><p>Drawing a simple user interface is a matter of using <code class="literal">Draw.Create()</code> to create the required buttons and assembling and initializing these buttons with <code class="literal">Draw.PupBlock()</code>
</p><p>This is somewhat limited compared to full-fledged libraries available for some programming languages, but very easy to use. The basic idea is to create interactive objects, such as buttons, and then assemble them in a dialog box to display to the user. At the same time, the dialog box states some of the limitations on the values the button may produce. The dialog or pop up will be shown at the position of the cursor. Blender is capable of producing a more sophisticated user interface, but for now we stick to the basics.</p><a class="indexterm" id="id83"/><p>Although <code class="literal">Draw.Create()</code> can produce toggle buttons and input buttons for strings as well, for our application we need input buttons only for integer values and floating point values. The type of the variable (for example a floating point value or an integer) is determined by the type of the default value given to <code class="literal">Draw.Create()</code>. The <strong>OK</strong> button is automatically displayed by <code class="literal">Draw.PupBlock()</code>. This function takes a list of tuples as an argument with each tuple defining a button to display. Each tuple consists of a text to display on the button, a button object created with <code class="literal">Draw.Create()</code>, minimum and maximum allowable values, and a tooltip text to show when hovering above the button.</p><div><pre class="programlisting">Draw = Blender.Draw
THORAXSEGMENTS = Draw.Create(3)
TAILSEGMENTS = Draw.Create(5)
LEGSEGMENTS = Draw.Create(2)
WINGSEGMENTS = Draw.Create(2)
EYESIZE = Draw.Create(1.0)
TAILTAPER = Draw.Create(0.9)

if not Draw.PupBlock('Add CreepyCrawly', [
('Thorax segments:' , THORAXSEGMENTS, 2, 50,'Number of thorax segments'),
('Tail segments:' , TAILSEGMENTS, 0, 50, 'Number of tail segments'),
('Leg segments:' , LEGSEGMENTS, 2, 10, 'Number of thorax segments with legs'),
('Wing segments:' , WINGSEGMENTS, 0, 10, 'Number of thorax segments with wings'),
('Eye size:' , EYESIZE, 0.1,10, 'Size of the eyes'),
('Tail taper:' , TAILTAPER, 0.1,10, 'Taper fraction of each tail segment'),]):
   return</pre></div><a class="indexterm" id="id84"/><p>As you can see, we limit the possible values of our input buttons to a reasonable range (up to 50 for the thorax and tail segments) to prevent unwanted results (huge values might cripple your system if memory or processing power is scarce).</p></div><div><div><div><div><h2 class="title"><a id="ch02lvl2sec24"/>Remembering choices</h2></div></div></div><a class="indexterm" id="id85"/><p>It would be very convenient if we could remember the user's choices so that we could present the last settings when the script is run again, but in Blender each script is run in isolation and all information within the script is lost once the script ends. Therefore, we need some mechanism to store information in a persistent way. For this purpose, the Blender API has the <code class="literal">Registry</code> module that allows us to keep values in memory (and on disk as well) indexed by an arbitrary key.</p><p>Our GUI initialization code changes little in itself if we want to add this functionality, but is prepended by code retrieving remembered values (if they are present) and followed by code saving the user's choices:</p><div><pre class="programlisting">
<strong>reg = Blender.Registry.GetKey('CreepyCrawlies',True)</strong>
try:
   nthorax=reg['ThoraxSegments']
except:
   nthorax=3
try:
   ntail=reg['TailSegments']
except:
   ntail=5
... &lt;similar code for other parameters&gt; ...

Draw = Blender.Draw
THORAXSEGMENTS = Draw.Create(nthorax)
TAILSEGMENTS = Draw.Create(ntail)
LEGSEGMENTS = Draw.Create(nleg)
WINGSEGMENTS = Draw.Create(nwing)
EYESIZE = Draw.Create(eye)
TAILTAPER = Draw.Create(taper)

if not Draw.PupBlock('Add CreepyCrawly', [\
... &lt;identical code as in previous example&gt; ...
return
reg={'ThoraxSegments':THORAXSEGMENTS.val,
	 'TailSegments' :TAILSEGMENTS.val,
	 'LegSegments' :LEGSEGMENTS.val,
	 'WingSegments' :WINGSEGMENTS.val,
	 'EyeSize' :EYESIZE.val,
	 'TailTaper':TAILTAPER.val}
<strong>Blender.Registry.SetKey('CreepyCrawlies',reg,True)</strong>
</pre></div><a class="indexterm" id="id86"/><p>The actual reading and writing of our registry entry is highlighted. The <code class="literal">True</code> argument indicates that we want to retrieve our data from disk if it is not available in memory, or write it to disk as well when saving so that our script can access this saved information even if we stop Blender and restart it  later. The actual registry entry received or written is a dictionary that can hold whatever data we want. Of course, there might not yet be a registry entry present, in which case we get a <code class="literal">None</code> value—a situation taken care of by the <code class="literal">try</code> <code class="literal">…</code> <code class="literal">except</code> <code class="literal">…</code> statements.</p></div><div><div><div><div><h2 class="title"><a id="ch02lvl2sec25"/>The full power of Blender graphics</h2></div></div></div><p>A pop-up dialog is sufficient for many applications but if it does not fit your requirements, <a class="indexterm" id="id87"/>Blender's <code class="literal">Draw</code> module has many more building blocks to create a user interface but these building blocks require a little bit more effort to glue them together in a working application.</p><a class="indexterm" id="id88"/><p>We will use these building blocks to create an error pop up. This pop up merely shows a message on an alarmingly colored background but illustrates nicely how user actions (such as key presses or button clicks) are linked to the graphical elements.</p><div><pre class="programlisting">from Blender import Window,Draw,BGL

def event(evt, val):
    if evt == Draw.ESCKEY:
       Draw.Exit() # exit when user presses ESC
    return

def button_event(evt):
    if evt == 1:
       Draw.Exit() 
    return

def msg(text):
    w = Draw.GetStringWidth(text)+20
    wb= Draw.GetStringWidth('Ok')+8
    BGL.glClearColor(0.6, 0.6, 0.6, 1.0)
    BGL.glClear(BGL.GL_COLOR_BUFFER_BIT)
    BGL.glColor3f(0.75, 0.75, 0.75)
    BGL.glRecti(3,30,w+wb,3)
    Draw.Button("Ok",1,4,4,wb,28)
    Draw.Label(text,4+wb,4,w,28)

<strong>def error(text):</strong>
   Draw.Register(lambda:msg(text), event, button_event)</pre></div><a class="indexterm" id="id89"/><a class="indexterm" id="id90"/><p>The <code class="literal">error()</code> function is where it all starts and ends for the user; it tells Blender what to draw, where to send events such as button clicks, where to send  key presses, and starts the interaction. <a class="indexterm" id="id91"/>The <code class="literal">lambda</code> function is necessary as the function that we pass to <code class="literal">Draw.Register()</code> to draw things cannot take an argument, yet we want to pass a different text argument every time we call <code class="literal">error()</code>. The <code class="literal">lambda</code> function basically defines a new function without arguments but with the text enclosed.</p><a class="indexterm" id="id92"/><p>The <code class="literal">msg()</code> function is responsible for drawing all of the elements on the screen. It draws a colored backdrop with the <a class="indexterm" id="id93"/>
<code class="literal">BGL.glRecti()</code> function, a label with the text to display (with <code class="literal">Draw.Label()</code>), and an OK button that is assigned an event number of <code class="literal">1</code> (with <code class="literal">Draw.Button()</code>). When the user clicks the OK button, this event number is sent to the event handler—<a class="indexterm" id="id94"/>the <code class="literal">button_event()</code> function that we passed to <code class="literal">Draw.Register()</code>. All that the event handler does when it is called with this event number of <code class="literal">1</code> is to terminate the <code class="literal">Draw.Register()</code> function<a class="indexterm" id="id95"/> by calling <code class="literal">Draw.Exit()</code>, so our <code class="literal">error()</code> function may return.</p></div><div><div><div><div><h2 class="title"><a id="ch02lvl2sec26"/>Creating a new Mesh object</h2></div></div></div><a class="indexterm" id="id96"/><p>Once we have retrieved our lists of vertex co-ordinates and face indices from the <code class="literal">mymesh</code> module, we need some manner to create a new <code class="literal">Mesh</code> object in our scene and add <code class="literal">MVert</code> and <code class="literal">MFace</code> objects to this mesh. This might be implemented like this:</p><div><pre class="programlisting">me=Blender.Mesh.New('Bug')
me.verts.extend(verts)
me.faces.extend(faces)
<strong>scn=Blender.Scene.GetCurrent()</strong>
ob=scn.objects.new(me,'Bug')
scn.objects.active=ob

me.remDoubles(0.001)
me.recalcNormals()</pre></div><p>The first line creates a new <code class="literal">Mesh</code> object with the name <code class="literal">Bug</code>. It will contain no vertices, edges, or faces and will not be embedded in a Blender object nor connected to any <code class="literal">Scene</code> yet. If the name of the mesh already exists, it is appended with a unique numerical suffix (for example, <code class="literal">Bug.001</code>).<a class="indexterm" id="id97"/>
</p><p>The next two lines actually create geometry inside the mesh. The <code class="literal">verts</code> attribute is where our list of <code class="literal">MVert</code> objects is referenced. It has a method <code class="literal">extend()</code> that will take a list of tuples, each containing the x, y, and z coordinates of the vertices to create. Likewise, the <code class="literal">extend()</code> method of the <code class="literal">faces</code> attribute will take a list of tuples, each containing three or more indices into the vertex list that together define a face. Order is important here: we need to add new vertices first; otherwise newly-created faces cannot refer to them. It is not necessary to define any edges, as adding faces will also create implied edges that are not already present.</p><p>A mesh in itself is not yet an object that can be manipulated by the user, so in the next few lines (highlighted) we retrieve the current scene and add a new object to the scene. The arguments to <code class="literal">new()</code> are the <code class="literal">Mesh</code> object that we created earlier and the name we want to give to the object. The name given to the object might be the same as the one given to the mesh, as mesh names and object names live in different namespaces. As with meshes, an existing name will be made unique by adding a suffix. If the name is left out, the new object will have the type of its argument as a default name (<code class="literal">Mesh</code> in this case).</p><p>A newly-created object will be selected but not active so we correct that by assigning our object to <code class="literal">scene.objects.active</code> .</p><p>As we add together our mesh from various collections of vertices the result might not be as clean as we would like and therefore, the final two actions make sure we do not have any vertices that occupy almost the same location in space and that all face normals consistently point outward.</p></div></div></div>
<div><div><div><div><h1 class="title"><a id="ch02lvl1sec15"/>Transforming mesh topology</h1></div></div></div><a class="indexterm" id="id98"/><p>Creating the creature from building blocks requires that we duplicate, scale, and mirror those building blocks before we stick them together. In Blender 2.49, this means we have to define some utility functions to perform those actions as they are not present in the API. We define these utility functions in the <strong>Tools</strong> module, but we highlight some of them here as they show some interesting methods.</p><p>Some actions such as scaling around a median point or translation of vertices are straightforward but connecting a group of vertices to another one is tricky, as we would like to prevent edges from crossing each other and keep faces flat and undistorted. We cannot simply connect two sets of vertices (or edge loops) together. But by trying different starting points on an edge loop and checking if such a choice minimizes the distance between all vertex pairs we insure that no edges cross and distortion is minimal (although we can't prevent faces to distort if the edge loops are very dissimilar in shape).</p><div><div><div><div><h2 class="title"><a id="ch02lvl2sec27"/>Code outline bridging edge loops</h2></div></div></div><a class="indexterm" id="id99"/><p>In the function that creates the new faces we have to perform the following steps:</p><div><ol class="orderedlist arabic"><li class="listitem">Check that both edge loops are equally long and nonzero.</li><li class="listitem">For every edge in loop 1:<div><ol class="orderedlist arabic"><li class="listitem">Find the edge in loop 2 that is closest.</li><li class="listitem">Create a face connecting these two edges.</li></ol></div></li></ol></div><p>The function that implements this outline looks fairly complicated:</p><div><pre class="programlisting">def bridge_edgeloops(e1,e2,verts):

    e1 = e1[:]
    e2 = e2[:]
    faces=[]

if len(e1) == len(e2) and len(e1) &gt; 0 :</pre></div><p>The function takes two lists of edges as an argument and a list of vertices. The edges are represented as tuples of two integers (indices into the <code class="literal">verts</code> list) and the vertices are tuples of x, y, and z co-ordinates.</p><p>The first thing we do is make copies of the two edge lists because we do not want to mangle the lists in their original context. The list of faces that we will be constructing is initialized to an empty list and we do a sanity check on the length of both edge lists. If that checks out we proceed to the next bit:</p><div><pre class="programlisting">for a in e1:
    distance = None
    best = None
    enot = []</pre></div><p>We iterate over every edge in the first list, referring to this edge as <code class="literal">a</code>. The <code class="literal">distance</code> parameter will hold the distance to the closest edge in the second edge list and <code class="literal">best</code> will be a reference to that edge. <code class="literal">enot</code> is a list that will accumulate all edges from the second list that are at a greater distance than <code class="literal">best</code>.</p><p>At the end of each iteration, <code class="literal">enot</code> will hold all edges from the second list minus one—the one we consider the closest. We then reassign <code class="literal">enot</code> to the second list so the second list will shrink by one edge over each iteration. We are done once the second list of edges is exhausted:</p><div><pre class="programlisting">while len(e2):
    b = e2.pop(0)</pre></div><a class="indexterm" id="id100"/><p>The current edge from the second list that we are considering is referred to as <code class="literal">b</code>. For our purposes, we define the distance between <code class="literal">a</code> and <code class="literal">b</code> as the sum of the distance between corresponding vertices in <code class="literal">a</code> and <code class="literal">b.</code>If that one is shorter, we define it as the sum of the distance to the flipped vertices of <code class="literal">b</code>. If the last situation applies, we swap the vertices in edge <code class="literal">b</code>. This may seem a complicated way to do things, but by summing the two distances we assure that edges which are relatively co-linear are favored thereby diminishing the number of non-flat faces that will be constructed. By checking whether flipping the second edge will result in a shorter distance, we prevent the formation of warped or bow-tie quads as illustrated in the following figure:</p><div><img alt="Code outline bridging edge loops" src="img/0400-02-03.jpg"/></div><p>The implementation will look like the previous figure where the highlighted vec are aliases to <code class="literal">Mathutil.Vector</code>, converting our tuples of x, y, and z co-ordinates to proper vectors that we can subtract, add, and take the length of. <a class="indexterm" id="id101"/>
</p><p>First we calculate the distance:</p><div><pre class="programlisting">d1 = (vec(verts[a[0]]) - vec(verts[b[0]])).length + \
(vec(verts[a[1]]) – vec(verts[b[1]])).length</pre></div><p>Then we check whether flipping the b edge results in a shorter distance:</p><div><pre class="programlisting">d2 = (vec(verts[a[0]]) - vec(verts[b[1]])).length + \
(vec(verts[a[1]]) - vec(verts[b[0]])).length
if d2&lt;d1 :
    b =(b[1],b[0])
    d1 = d2</pre></div><p>If the calculated distance is not the shortest, we set aside the edge for the next iteration, unless it is the first we encounter:</p><div><pre class="programlisting">if distance == None or d1&lt;distance :
    if best != None:
       enot.append(best)
       best = b
       distance = d1
    else:
       enot.append(b)
       e2 = enot
       faces.append((a,best))</pre></div><p>Finally, we convert our list of faces, consisting of tuples of two edges, to a list of tuples of four indices:</p><div><pre class="programlisting">return [(a[0],b[0],b[1],a[1]) for a,b in faces]</pre></div><p>There is much more to this script and we will revisit <code class="literal">creepycrawlies.py</code> in the following chapter as we add modifiers and vertex groups and rig our model. The illustration shows a sample of the bestiary that can be created by the script.</p><div><img alt="Code outline bridging edge loops" src="img/0400-02-04.jpg"/></div></div></div>
<div><div><div><div><h1 class="title"><a id="ch02lvl1sec16"/>Dazzle your boss—bar charts in Blender style</h1></div></div></div><a class="indexterm" id="id102"/><p>To prove that Blender is adaptable to many tasks besides the interactive creation of 3D graphics, we will show you how to import external data (a spreadsheet in CSV format) and automate the task of creating and rendering the 3D representation of a bar chart.</p><div><img alt="Dazzle your boss—bar charts in Blender style" src="img/0400-02-05.jpg"/></div><a class="indexterm" id="id103"/><p>The idea is to run Blender with arguments directing it to run a script that reads a <code class="literal">.csv</code> file, renders an image, and saves that image when finished. For this to be possible we need a way to call Blender with the correct parameters. We get to that script shortly, but first let's see how to pass parameters to Blender to make it run a Python script:</p><div><pre class="programlisting">
<strong>blender -P /full/path/to/barchart.py</strong></pre></div><p>It is also possible to run a script from a text buffer inside a <code class="literal">.blend</code> file by naming that text buffer instead. Notice the order of the parameters in this case—the <code class="literal">.blend</code> file comes first:</p><div><pre class="programlisting"><strong>blender barchart.blend -P barchart.py</strong>
</pre></div><p>We also need a way to specify arguments to pass to our script. In contrast to what is described in the API docs, we can just access the command-line arguments from Python like this:</p><div><pre class="programlisting">import sys
print sys.argv</pre></div><p>This last snippet will print all arguments, including the name of the Blender executable as the first. Our script will have to skip any arguments intended for Blender itself when using this list. Any arguments intended only for our script that shouldn't be interpreted by Blender itself should come after an <strong>end-of-options</strong> <strong>argument</strong>, the double minus (<code class="literal">--</code>).</p><a class="indexterm" id="id104"/><p>Finally, we don't want Blender to pop up and show an interactive GUI. Instead, we will instruct it to run in the background and exit when done. This is done by passing the <code class="literal">-b</code> option. Putting all this together, the command line will look like this:</p><div><pre class="programlisting">
<strong>blender -b barchart.blend -P barchart.py –- data.csv</strong>
</pre></div><p>If Blender is run in background mode you <em>must</em> specify a <code class="literal">.blend</code> file, otherwise Blender will crash. If we have to specify a <code class="literal">.blend</code> file we can use an internal text as our Python script just as well, otherwise we'd have to keep two files together instead of one.</p><div><div><div><div><h2 class="title"><a id="ch02lvl2sec28"/>The bar chart script</h2></div></div></div><a class="indexterm" id="id105"/><p>Here, we show the relevant parts of the code in chunks (the complete file is available as <code class="literal">barchart.blend</code> that has <code class="literal">barchart.py</code> as an embedded text). We start by creating a new <code class="literal">World</code> object and set its zenith and horizon colors to a neutral all white (highlighted part of the following code):</p><div><pre class="programlisting">if __name__ == '__main__':
    w=World.New('BarWorld')
 <strong>   w.setHor([1,1,1])</strong>
 <strong>   w.setZen([1,1,1])</strong>
</pre></div><p>Next, we retrieve the last argument passed to Blender and check whether the extension is that of a <code class="literal">.csv</code> file. Real world production code would have more sophisticated error checking of course:</p><div><pre class="programlisting">csv = sys.argv[-1]
if csv.endswith('.csv'):</pre></div><p>If it has the correct extension we create a new <code class="literal">Scene</code> named <code class="literal">BarScene</code> and set its <code class="literal">world</code> attribute to our newly created world (This was inspired by a much more elaborate script by <em>jessethemid</em> on Blender Artists <a class="ulink" href="http://blenderartists.org/forum/showthread.php?t=79285">http://blenderartists.org/forum/showthread.php?t=79285</a>). The background mode does not load any default <code class="literal">.blend</code> file so the default scene will not contain any objects. However, just to make sure, we create a new empty scene with a meaningful name that will hold our objects:</p><div><pre class="programlisting">sc=Scene.New('BarScene')
sc.world=w
sc.makeCurrent()</pre></div><p>Then, we pass the filename to a function that adds the <code class="literal">barchart</code> objects to the current scene and returns the center of the chart so that our <code class="literal">addcamera()</code> function<a class="indexterm" id="id106"/> can use it to aim the camera. We also add a lamp to make rendering possible (otherwise our render would be all black).</p><div><pre class="programlisting">center = barchart(sys.argv[-1])
addcamera(center)
addlamp()</pre></div><a class="indexterm" id="id107"/><p>The rendering itself is straightforward (we will encounter more elaborate examples in <a class="link" href="ch08.html" title="Chapter 8. Rendering and Image Manipulation">Chapter 8</a>, <em>Rendering and Image Manipulation</em>). We retrieve the rendering context that holds all information about how to render, for example which frame, what output type, the size of the render, and so on. And, because most attributes have sensible defaults, we just set the format to PNG and render.</p><div><pre class="programlisting">context=sc.getRenderingContext()
context.setImageType(Scene.Render.PNG)
context.render()</pre></div><p>Finally, we set the output directory to an empty string to make our output go to the current working directory (the directory we were in when we called Blender) and save our rendered image. The image will have the same basename as the <code class="literal">.csv</code> file that we passed as the first argument but will have a <code class="literal">.png</code> extension. We checked that the filename ends in <code class="literal">.csv</code> so it's safe to bluntly strip the last four characters from the filename and add <code class="literal">.png</code>
</p><div><pre class="programlisting">context.setRenderPath('')
context.saveRenderedImage(csv[:-4]+'.png')</pre></div><p>Adding a lamp is not much different from adding any other object and is very similar to the "hello world" example. We create a new <code class="literal">Lamp</code> object, add it to the current scene, and set its location. A <code class="literal">Lamp</code> object has of course many configurable options but we settle for a default non-directional lamp in this example. The highlighted code shows some typical Python idiom: <code class="literal">loc</code> is a tuple of three values but <code class="literal">setLocation()</code> takes three separate arguments so we indicate we want to unpack the tuple as separate values with the <code class="literal">*</code> notation:</p><div><pre class="programlisting">def addlamp(loc=(0.0,0.0,10.0)):
    sc = Scene.GetCurrent()
    la = Lamp.New('Lamp')
    ob = sc.objects.new(la)
 <strong>   ob.setLocation(*loc)</strong>
</pre></div><p>Adding a camera is a little more intricate as we have to point it to our bar chart and make sure that the view angle is wide enough to see everything. We define a perspective camera here and set a fairly wide angle. Because the default camera is already oriented along the z-axis we do not have to set any rotation, just set the location 12 units removed from the center along the z-axis as highlighted in the second last line of the following code:</p><div><pre class="programlisting">def addcamera(center):
    sc = Scene.GetCurrent()
    ca = Camera.New('persp','Camera')
    ca.angle=75.0
    ob = sc.objects.new(ca)
 <strong>   ob.setLocation(center[0],center[1],center[2]+12.0)</strong>
    sc.objects.camera=ob</pre></div><a class="indexterm" id="id108"/><a class="indexterm" id="id109"/><p>The <code class="literal">barchart</code> function itself is not much of a surprise. We open the passed-in filename and use the standard <code class="literal">csv</code> module from Python to read the data from the file. We store all column headers in <code class="literal">xlabel</code> and other data in <code class="literal">rows</code>.</p><div><pre class="programlisting">from csv import DictReader

def barchart(filename): 
    csv = open(filename)
    data = DictReader(csv)
    xlabel = data.fieldnames[0]
    rows = [d for d in data]</pre></div><p>In order to scale our bar chart to reasonable values we have to determine the extremes of the data. The first column of each record holds the x-value (or label) so we exclude that from our calculation. As each value is stored as a string we have to convert it to a floating point value for comparisons.</p><div><pre class="programlisting">maximum = max([float(r[n]) for n in data.fieldnames[1:] for r in rows])
minimum = min([float(r[n]) for n in data.fieldnames[1:] for r in rows])</pre></div><p>To create the actual bars we iterate over all rows. Because the x-value might be a textual label (such as the name of a month for example), we keep a separate numerical x-value in order to position the bars. The x-value itself is added to the scene as a <code class="literal">Text3d</code> object by the <code class="literal">label()</code> function,<a class="indexterm" id="id110"/> whereas the y-values are visualized by appropriately scaled <code class="literal">Cube</code> objects added by the <code class="literal">bar()</code> function. Neither the <code class="literal">label()</code> nor the <code class="literal">bar()</code> function are shown here.</p><div><pre class="programlisting">for x,row in enumerate(rows):
    lastx=x
    label(row[xlabel],(x,10,0))
for y,ylabel in enumerate(data.fieldnames[1:]):
    bar(10.0*(float(row[ylabel])-minimum)/maximum,(x,0,y+1))
    x = lastx+1</pre></div><a class="indexterm" id="id111"/><p>Finally, we label each column (that is, each set of data) with its own column header as a label. We stored the number of x-values so we can return the center of our bar chart by dividing it by two (the y component is set to 5.0 as we scaled all y-values to lie within the range 0-10).</p><div><pre class="programlisting">for y,ylabel in enumerate(data.fieldnames[1:]):
    label(ylabel,(x,0,y+0.5),'x')
    return (lastx/2.0,5.0,0.0)</pre></div><div><div><h3 class="title"><a id="tip03"/>Tip</h3><p>
<strong>A Windows trick: SendTo</strong>
</p><p>Once you have your <code class="literal">.blend</code> file containing a correct Python script and you have figured out the correct way to invoke it from the command line, you can integrate this more closely with Windows XP by creating a <code class="literal">SendTo</code> program. <a class="indexterm" id="id112"/>A <code class="literal">SendTo</code> program (a <code class="literal">.BAT</code> file in this case) is any program that will take a single filename as an argument and acts upon it. It has to reside in the <code class="literal">SendTo</code> directory—which may be located in different places depending on your system configuration. It is simple to find by clicking on the <strong>Start</strong> button, selecting <strong>Run</strong>, and typing <strong>sendto</strong> instead of a command. This will open the correct directory. In this directory you can place the <code class="literal">.BAT</code> file, in our case we call it <code class="literal">BarChart.BAT</code>, and it will contain a single command: <code class="literal">/full/path/to/blender.exe</code> <code class="literal">/path/to/barchart.blend</code> <code class="literal">-P</code> <code class="literal">barchart.py</code> <code class="literal">--</code> <code class="literal">%1</code> (note the percent sign). Now we can simply right-click any <code class="literal">.csv</code> file we encounter and we can then select <code class="literal">BarChart.BAT</code> from the <code class="literal">SendTo</code> menu and hey presto, a <code class="literal">.png</code> file will appear alongside our <code class="literal">.csv</code>.</p></div></div></div></div>
<div><div><div><div><h1 class="title"><a id="ch02lvl1sec17"/>Weird faces—selecting and editing faces in meshes</h1></div></div></div><p>Blender already provides a host of options to select and manipulate the faces, edges, and vertices of a mesh, either via built-in methods or via Python extension scripts. But if you want to select some elements based on your unique requirements, this section shows how to implement that. We build a few small scripts that illustrate how to access faces, edges, and vertices and how to work with the various properties of these objects.</p></div>
<div><div><div><div><h1 class="title"><a id="ch02lvl1sec18"/>Selecting warped (non-planar) quads</h1></div></div></div><p>
<strong>Warped</strong> <strong>quads</strong>, also known as <strong>bow-tie</strong> <strong>quads,</strong> are sometimes formed when accidentally mixing up the vertex order during face creation. In a less extreme case they might be formed when moving a single vertex <a class="indexterm" id="id113"/>of a planar quad. This small illustration shows how these may look in the 3D-view:</p><div><img alt="Selecting warped (non-planar) quads" src="img/0400-02-06.jpg"/></div><p>In the 3D view, the warped face on the right didn't seem out of the ordinary but when rendered it does not show uniform shading:</p><div><img alt="Selecting warped (non-planar) quads" src="img/0400-02-07.jpg"/></div><a class="indexterm" id="id114"/><p>Both objects are planes and consist of a single face with four vertices. The one on the left is a bow-tie quad. Its right edge is rotated a full 180 degrees resulting in an ugly, black triangle where we see the back of the warped face. The plane on the right shows no noticeable distortion in the 3D view even though its upper-right vertex is moved a considerable distance along the z-axis (our line of sight). When rendered however, the distortion of the right plane is clearly visible. The visible distortion of slightly warped quads may be overcome by setting the <code class="literal">smooth</code> attribute of a face that will interpolate the vertex normals along the face resulting in a smooth appearance. Slightly warped quads are almost inevitable when modeling or deforming a mesh by an armature and whether they result in visible problems depends on the situation. Often it is helpful if you can identify and select them to make your own judgment.</p><a class="indexterm" id="id115"/><a class="indexterm" id="id116"/><p>Warped quads can be identified by checking whether the normals of the triangles that form the quad are pointing in the same direction. A flat quad will have its triangle normals pointing in the same direction as shown in the following figure:<a class="indexterm" id="id117"/>
</p><div><img alt="Selecting warped (non-planar) quads" src="img/0400-02-08.jpg"/></div><p>Whereas in a warped quad these normals are not parallel:</p><div><img alt="Selecting warped (non-planar) quads" src="img/0400-02-09.jpg"/></div><a class="indexterm" id="id118"/><p>These triangle normals are not the same as vertex normals: those are defined as the average of all face normals of the faces sharing a vertex so we will have to calculate these triangle normals ourselves. This can be done by taking the cross product of the edge vectors, that is, the vectors defined by the two vertices at the end of each edge. In the examples shown we have the left triangle normal formed by taking the cross product of the edge vectors 1 → 0 and 1 → 2 and the right triangle by taking the cross product of the edge vectors 2 → 1 and 2 → 3.</p><p>It does not matter whether we traverse our edges clockwise or counterclockwise but we have to be careful to be consistent in ordering edges when calculating the cross products because the sign will be reversed. Once we have our triangle normals we can check whether they point in exactly the same direction by verifying that all components (x, y, and z) of one vector are scaled by the same factor when compared to the corresponding components of the second vector. To give us somewhat more flexibility however, we would like to calculate the angle between the triangle normals and select a face only if that angle exceeds some minimum. We do not have to devise such a function ourselves because the <code class="literal">Blender.Mathutils</code> module provides the <code class="literal">AngleBetweenVecs()</code> function.<a class="indexterm" id="id119"/>
</p><p>It is possible to construct four different triangles within a quad but is not necessary to compare all triangle normals—any two normals will suffice because moving a single vertex of a quad will alter three of the possible four triangle normals.</p><div><div><div><div><h2 class="title"><a id="ch02lvl2sec29"/>Code outline warp select</h2></div></div></div><a class="indexterm" id="id120"/><p>Armed with all this information, the outline for our tool will look like this:</p><div><ol class="orderedlist arabic"><li class="listitem">Show pop up for minimum angle.</li><li class="listitem">Verify that the active object is a mesh and in <em>edit</em> mode.</li><li class="listitem">Enable <em>face select</em> mode.</li><li class="listitem">For all faces, check if the face is a quad and if so:<div><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">Calculate the triangle normal defined by vertex 0, 1, and 2</li><li class="listitem" style="list-style-type: disc">Calculate the triangle normal defined by vertex 1, 2, and 3</li><li class="listitem" style="list-style-type: disc">Calculate the angle between normals</li><li class="listitem" style="list-style-type: disc">If angle &gt; minimum angle, select the face</li></ul></div></li></ol></div><p>This translates in the following code for the actual detection and selection (the full script is provided as <code class="literal">warpselect.py</code>):</p><div><pre class="programlisting">
def warpselect(me,maxangle=5.0):
	for face in me.faces:
		if len(face.verts) == 4:
			n1 = ( face.verts[0].co - face.verts[1].co ).cross(
			face.verts[2].co - face.verts[1].co )
			n2 = ( face.verts[1].co - face.verts[2].co ).cross(
			face.verts[3].co - face.verts[2].co )
			a = AngleBetweenVecs(n1,n2)
			if a &gt; maxangle :
				face.sel = 1</pre></div><p>As you can see, our outline corresponds almost one-to-one to the code. Note that <code class="literal">AngleBetweenVecs()</code> returns the angle in degrees so we can directly compare it to <code class="literal">maxangle</code> which is also in degrees. Also, there is no need to implement the cross product of two vectors ourselves as Blender's <code class="literal">Vector</code> class is well stocked with all sorts of operators. Before we can call this function we have to take care of an important detail: in order to select faces, <em>face selection</em> mode should be enabled. This can be done as follows:</p><div><pre class="programlisting">selectmode = Blender.Mesh.Mode()
Blender.Mesh.Mode(selectmode | Blender.Mesh.SelectModes.FACE)</pre></div><p>To illustrate the less well-known fact that select modes are <em>not</em> mutually exclusive we set the <em>face</em> <em>select</em> mode in addition to any mode already selected by combining values with a binary or operator (<code class="literal">|</code>). At the end of the script we restore the mode that was active.</p></div></div>
<div><div><div><div><h1 class="title"><a id="ch02lvl1sec19"/>Selecting ultra sharp faces</h1></div></div></div><a class="indexterm" id="id121"/><p>Many tools exist to select faces that are in some sense unwieldy to work with. Blender has built-in tools to select faces that have an area that is too small or that have a perimeter that is too short. However, it lacks a tool to select faces with edges that form angles that are sharper than some limit. In some modeling tasks it would be very convenient if we could select such faces, as they are generally difficult to manipulate and may give rise to ugly artifacts when applying a subsurface modifier or deforming a mesh.</p><div><div><h3 class="title"><a id="note04"/>Note</h3><p>Note that Blender's <em>select</em> <em>sharp</em> <em>edges</em> tool (<em>Ctrl + Alt + Shift + S</em>) does something different despite its name; it selects those edges that are shared by exactly two faces whose angle of contact is less than some minimum value or, to put it in another way, selects edges between faces that are relatively flat.</p></div></div><p>We already have seen that Blender's <code class="literal">Mathutils</code> module has a function to calculate the angle so our code is very brief as the real work is done by a single function shown below. (The full script is provided as <code class="literal">sharpfaces.py</code>.)</p><div><pre class="programlisting">def sharpfaces(me,minimum_angle):
   for face in me.faces:
      n = len(face.verts)
      edges = [face.verts[(i+1)%n].co - face.verts[i].co for i in range(n)]
      for i in range(n):
         <strong>a = AngleBetweenVecs(-edges[i],edges[(i+1)%n])</strong>
         if a &lt; minimum_angle :
            face.sel = 1
            break</pre></div><p>Note that we do not distinguish between tris or quads as both may have edges that are joined by a sharp angle. The highlighted part in the preceding code shows one subtle detail; each time we calculate the angle between our two edge vectors, we invert one of them because to calculate the correct angle, each of the vectors should originate in the same vertex whereas we calculated them all as pointing from one vertex to the next. </p><p>The distinction is illustrated in the following figure:<a class="indexterm" id="id122"/>
</p><div><img alt="Selecting ultra sharp faces" src="img/0400_02_10.jpg"/></div></div>
<div><div><div><div><h1 class="title"><a id="ch02lvl1sec20"/>Selecting vertices with many edges</h1></div></div></div><a class="indexterm" id="id123"/><p>Ideally, a mesh will contain faces that consist of only four vertices (these faces are generally referred to as <strong>quads</strong><a class="indexterm" id="id124"/>) and are fairly even sized. Such a configuration is optimal when deforming the mesh, as is often necessary with animations. Of course, there is nothing intrinsically wrong with three-sided faces (<strong>tris</strong>) <a class="indexterm" id="id125"/>but in general it is better to avoid them because small triangular faces wreck havoc with subsurface modifiers, causing them to show unsightly ripples.</p><div><img alt="Selecting vertices with many edges" src="img/0400-02-11.jpg"/></div><a class="indexterm" id="id126"/><p>Now even when you have a mesh that consists only of quads, some vertices are the center of more than four edges. These vertices are sometimes called <strong>poles</strong>,<a class="indexterm" id="id127"/> hence the name of the scripts in the following sections. If the number of edges is excessive, say six or more (as shown in the previous screenshot), such an area might become difficult to deform and difficult to manipulate for the modeler. In a large and complex mesh these vertices might be difficult to pinpoint and therefore we need a selection tool that selects those vertices.</p></div>
<div><div><div><div><h1 class="title"><a id="ch02lvl1sec21"/>Selecting poles </h1></div></div></div><a class="indexterm" id="id128"/><p>In order to select vertices with a certain number of steps we may perform the following steps:</p><div><ol class="orderedlist arabic"><li class="listitem">Check whether the active object is a <code class="literal">Mesh.</code></li><li class="listitem">Check whether we are in <em>object</em> mode.</li><li class="listitem">Show a pop-up menu to input the minimum number of edges.</li><li class="listitem">For every vertex:<div><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">Iterate over all edges, counting occurrences of the vertex</li><li class="listitem" style="list-style-type: disc">If count is larger or equal to the minimum, select the vertex</li></ul></div></li></ol></div><a class="indexterm" id="id129"/><p>This approach is straightforward and simple. The function that is responsible for the actual work is shown below (the full script is called <code class="literal">poleselect1.py</code>). It follows our outline closely. The actual selection of a vertex is effected by assigning to the <code class="literal">sel</code> attribute of the vertex. Note also that the <code class="literal">v1</code> and <code class="literal">v2</code> attributes of an <code class="literal">edge</code> object are not indices into the <code class="literal">verts</code> attribute of our mesh but refer to <code class="literal">MVert</code> objects. That is why we need to retrieve the <code class="literal">index</code> attributes to compare.</p><div><pre class="programlisting">def poleselect1(me,n=5):
   <strong>for v in me.verts:</strong>
      n_edges=0
      for e in me.edges:
         if e.v1.index == v.index or e.v2.index == v.index:
            n_edges+=1
            if n_edges &gt;= n:
               v.sel = 1
               break</pre></div><div><div><div><div><h2 class="title"><a id="ch02lvl2sec30"/>Selecting poles, again</h2></div></div></div><a class="indexterm" id="id130"/><p>You probably noticed that we iterated over the list of edges for each and every vertex (highlighted in the previous code). This might be costly in terms of performance and this cost is even compounded by the need to compare indices which have to be retrieved again and again. Is it possible to write more efficient code that stays readable nonetheless? It is if we follow this strategy:</p><div><ol class="orderedlist arabic"><li class="listitem">Check whether the active object is a <code class="literal">Mesh</code>.</li><li class="listitem">Check whether we are in <em>object</em> mode.</li><li class="listitem">Show a pop-up menu to input the minimum number of edges.</li><li class="listitem">Initialize a dictionary, indexed by vertex index that will contain edge counts.</li><li class="listitem">Iterate over all edges (update the count for both referred vertices).</li><li class="listitem">Iterate over the items in the dictionary (if count is larger or equal to the minimum, select the vertex).</li></ol></div><p>By using this strategy we perform just two possibly lengthy iterations at the cost of needing the memory to store the dictionary (nothing is free). The speed increase is negligible for small meshes but might be considerable (I clocked a 1,000-fold speed boost on a smallish mesh of 3,000 vertices) for large meshes, and those are just the kind of meshes where someone might need a tool like this.</p><p>Our revised selection function is shown below (the full script is called <code class="literal">poleselect.py</code>). First note the <code class="literal">import</code> statement. The dictionary that we will be using is called a default dictionary and is provided by Python's collections module.<a class="indexterm" id="id131"/> A <strong>default</strong> <strong>dictionary</strong> is a dictionary that initializes missing items the first time they are referred to. As we want to increment the count for every vertex that is referred to by an edge, we should either initialize our dictionary with a zero value for every vertex in the mesh beforehand or check if a vertex is already indexed every time we want to increment the count and, if not, initialize it. A default dictionary does away with the need to initialize everything in advance and allows for a very readable idiom.<a class="indexterm" id="id132"/>
</p><a class="indexterm" id="id133"/><p>We create our dictionary by calling the <code class="literal">defaultdictionary()</code> function (a function returning a new object whose behavior is configured by some argument to the function is called a factory in object-oriented circles) with an <code class="literal">int</code> argument. The argument should be a function taking no arguments. The built-in function <code class="literal">int()</code> that we use here will return an integer value of zero when called without arguments. Every time we access our dictionary with a non-existing key, a new item is created and its value will be the return value of our <code class="literal">int()</code> function, <a class="indexterm" id="id134"/>that is, zero. The essential lines are the two where we increment the <code class="literal">edgecount</code> (highlighted part of the following code). We could have written that expression in a slightly different way to illustrate why we need a default dictionary:</p><div><pre class="programlisting">edgecount[edge.v1.index] = edgecount[edge.v1.index] + 1</pre></div><p>The dictionary item we refer to on the right-hand side of the expression might not yet exist every time we refer to a vertex index that we encounter for the first time. Of course, we could check beforehand but that would render the code a whole lot less readable.</p><div><pre class="programlisting">from collections import defaultdict

def poleselect(me,n=5):
   n_edges = defaultdict(int)
   for e in me.edges:
      <strong>n_edges[e.v1.index]+=1</strong>
 <strong>     n_edges[e.v2.index]+=1</strong>
   for v in (v for v,c in n_edges.items() if c&gt;=n ):
      me.verts[v].sel=1</pre></div></div></div>
<div><div><div><div><h1 class="title"><a id="ch02lvl1sec22"/>Determining the volume of a mesh</h1></div></div></div><a class="indexterm" id="id135"/><p>Although Blender is not really a CAD program, many people use it for CAD-like issues such as architectural visualization. Blender is capable of importing many types of files including those of major CAD programs, so including technical models drawn to precise measurements is never a problem.</p><a class="indexterm" id="id136"/><p>These CAD programs often offer all kinds of tools to measure the dimensions of (parts of) your model, yet Blender, by its nature, provides very few of those tools. It is possible to inspect the size and location of an object by pressing the <em>N</em> key in the 3D view window. In <em>edit</em> mode you may enable the display of edge lengths, edge angles, and face areas (see the panel <strong>Mesh tools more</strong> in the editing context (<em>F9</em>) of the Buttons window) but that is about as far as it gets.</p><p>Python may overcome those limitations in situations where we need some specific measurement and exporting our model to a CAD tool is not an option. A practical example is the calculation of the volume of a mesh. Nowadays, a number of companies offer possibilities to re-create your digital model as real world objects by way of 3D printing techniques. I have to say it is a rather special feeling to hold a plastic or even metal replica of your Blender model in your hands, it really adds a whole new dimension to 3D.</p><p>Now a major component of the price of 3D-printing a model is the amount of material that will be used. Often, it will be possible to design your model as a hollow object that takes less material to produce, but it is quite inconvenient to upload intermediate versions of your model again and again to let the manufacturer's software calculate the volume and give you a price quote. So what we would like to have is a script that can calculate the volume of a mesh in a fairly accurate manner.</p><p>A common method to calculate the volume of a mesh is sometimes referred to as the <strong>Surveyor's Formula</strong> as it is related to the way surveyors may calculate the volume of a hill or mountain by triangulating its surface.<a class="indexterm" id="id137"/>
</p><p>The central idea is to split a triangulated mesh into many columns that have their base on the xy-plane.</p><p>The surface area of the triangle projected onto the xy-plane times the average z-position of the three vertices then gives the volume of such a column. Summing these volumes finally gives the volume of the complete mesh (see the next figure).</p><div><img alt="Determining the volume of a mesh" src="img/0400-02-12.jpg"/></div><a class="indexterm" id="id138"/><p>There are a couple of things that have to be taken into account. First, a mesh may extend below the xy-plane. If we construct a column from a face that lies below the xy-plane, the product of the projected area and the average of the z-coordinates will be a negative number, so we have to negate its value to get a volume.</p><div><img alt="Determining the volume of a mesh" src="img/0400-02-13.jpg"/></div><a class="indexterm" id="id139"/><p>Second, a mesh may lie completely or partially above the xy-plane. If we take a look at the example in the previous diagram we see that the object has two triangles that contribute to the volume of the object, the top and bottom ones (the vertical triangles have a projected area of zero, so will contribute nothing). As the top and bottom faces both lie above the xy-plane, we have to subtract the volume of the column constructed from the bottom face from the one constructed from the top face. If the object was completely below the xy-plane it would be the other way around, and we would have to subtract the volume of the top column from the volume of the bottom column.</p><p>How we can tell what to do is determined by the direction of the face normal of our triangles. If, for example, a triangle is above the xy-plane but its face normal is pointing downward (it has a negative z-component), then we have to subtract the calculated volume. It is therefore vital that all face normals point consistently outward (in <em>edit</em> mode, select all faces and press <em>Ctrl + N</em>).</p><p>If we take into account all four possibilities (face normal up or down, face above or below the xy-plane) we can write the following outline for our function:</p><div><ol class="orderedlist arabic"><li class="listitem">Make sure all face normals consistently point outward.</li><li class="listitem">For all faces:<div><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">Calculate the z-component of face normal vector <strong>Nz</strong></li><li class="listitem" style="list-style-type: disc">Calculate the product <strong>P</strong> of the average z-coordinates and the projected surface area.</li><li class="listitem" style="list-style-type: disc">If Nz is positive: add P</li><li class="listitem" style="list-style-type: disc">If Nz is negative: subtract P</li></ul></div></li></ol></div><a class="indexterm" id="id140"/><p>This nifty algorithm works for simple objects without holes and just as well for objects containing holes (such as a torus), or even hollow ones (that is, containing an object completely enclosed in another object) like the examples shown in the following screenshot:</p><div><img alt="Determining the volume of a mesh" src="img/0400-02-14.jpg"/></div><p>Because we allow the product of area and z-coordinates to be negative, we have to check only for the direction of the face normal to cover all situations.</p><div><div><h3 class="title"><a id="note05"/>Note</h3><p>Note that it is necessary for the mesh to be closed and manifold: There shouldn't be any missing faces nor should there be any edges that do not share exactly two faces, such as interior faces.</p></div></div><div><img alt="Determining the volume of a mesh" src="img/0400-02-15.jpg"/></div><a class="indexterm" id="id141"/><p>The important part of the code is shown here (the complete script is called <code class="literal">volume.py</code>):</p><div><pre class="programlisting">def meshvolume(me):
   volume = 0.0
   for f in me.faces:
      <strong>xy_area = Mathutils.TriangleArea(vec(f.v[0].co[:2]),vec(f.v[1].co[:2]),vec(f.v[2].co[:2]))</strong>
      Nz = f.no[2]
      avg_z = sum([f.v[i].co[2] for i in range(3)])/3.0
      partial_volume = avg_z * xy_area 
      if Nz &lt; 0: volume -= partial_volume
      if Nz &gt; 0: volume += partial_volume
   return volume</pre></div><p>The highlighted code shows how we calculate the area of the triangle projected on the xy-plane. <code class="literal">TriangleArea()</code> will calculate the area of a two-dimensional triangle when given two dimensional points (points in the xy-plane). So we pass not the full coordinate vectors of the vertices, but truncate them (that is, we drop the z-coordinate) into two component vectors.</p><a class="indexterm" id="id142"/><p>After running the script from the text editor, or from the <strong>Scripts</strong> menu when in <em>object</em> mode, a pop up is displayed showing the volume in Blender units. Before running the script make sure that all modifiers are applied, scale and rotation are applied (<em>Ctrl + A</em> in <em>object</em> mode), the mesh is fully triangulated (<em>Ctrl + T</em> in <em>edit</em> mode), and that the mesh is manifold (closed or water-tight) by checking for non-manifold edges (<em>Ctrl + Alt + Shift +M </em>in <em>edge selection</em> mode). <a class="indexterm" id="id143"/>
<strong>Manifold</strong> <strong>edges</strong> are edges that are shared by exactly two faces. Also make sure that all normals are pointing in the right direction. The application of modifiers is necessary to make the mesh closed (if it is a mirror modifier) and to make the calculation of the volume accurate (if it is a subsurface modifier).</p></div>
<div><div><div><div><h1 class="title"><a id="ch02lvl1sec23"/>Determining the centre of mass of a mesh</h1></div></div></div><a class="indexterm" id="id144"/><p>When printing a three-dimensional object in plastic or metal, a seemingly innocent question might pop up once we create our first toy based on a mesh we created; what is its center of mass? If our model has legs but we don't want it to keel over, its center of mass better be somewhere over its feet and, preferably, as low as possible to keep it stable. This figure shows this schematically:</p><div><img alt="Determining the centre of mass of a mesh" src="img/0400-02-16.jpg"/></div><p>Once we know how to determine the volume of a mesh we can reuse many of the concepts to devise a script to determine the center of mass. Two additional bits of knowledge are needed to compute the position of the center of mass:<a class="indexterm" id="id145"/>
</p><div><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">The centers of mass of the projected volumes we construct when calculating the volume of the mesh</li><li class="listitem" style="list-style-type: disc">How to add up the calculated centers of mass of all these individual volumes</li></ul></div><a class="indexterm" id="id146"/><p>All of this assumes that solid sections of our mesh have a uniform density. A mesh may have any form or even be hollow but the solid parts are assumed to be of a uniform density. This is valid assumption for the materials deposited by 3D printers.</p><p>The first issue is a bit of geometry: the projected volume is essentially a triangular column (or triangular prism) capped by a possibly slanted triangular face. Calculating the center of mass might be done as follows: the x and y coordinates of the center of mass are the x and y coordinates of the center of the projected triangle on the xy-plane—those are simply the averages of the x and y coordinates respectively of the three points defining the triangular face. The z-coordinate of the center of mass is halfway along the average height of our projected column. This is the average of the z-coordinates of the three points of the triangular face divided by two.</p><p>The second issue is mainly common sense: given two masses m1 and m2 with their centers of mass at v1 and v2 respectively, their combined center of mass is the weighted average. That is to say, the center of mass is proportionally closer to the center of the mass of the heaviest component. <a class="indexterm" id="id147"/>
</p><div><div><h3 class="title"><a id="note06"/>Note</h3><p>Of course it is common sense to us now, but it took someone like Archimedes to see that it actually was common sense. After finding out about this 'law of levers' (as he called it), he didn't shout 'eureka' or went running around naked, so it took somewhat longer to attract attention.</p></div></div><p>Let's put all this information into a recipe that we can follow:</p><div><ol class="orderedlist arabic"><li class="listitem">Make sure all face normals consistently point outward.</li><li class="listitem">For all faces:<div><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">Calculate the z-component of face normal vector Nz</li><li class="listitem" style="list-style-type: disc">Calculate the product P of the average z-coordinates and the projected surface area</li><li class="listitem" style="list-style-type: disc">Calculate CM(x, y, z) with x, y the average of the projected x, y coordinates of the face and z (the average of the z-coordinates of the face)/2</li><li class="listitem" style="list-style-type: disc">If Nz is positive: add P times CM</li><li class="listitem" style="list-style-type: disc">If Nz is negative: subtract P times CM</li></ul></div></li></ol></div><p>From the outline above, it is clear that calculating the center of mass goes hand in hand with the calculation of the partial volumes, so it makes sense to redefine the <code class="literal">meshvolume()</code> function to the following:<a class="indexterm" id="id148"/>
</p><div><pre class="programlisting">def meshvolume(me):
   volume = 0.0
   <strong>cm = vec((0,0,0))</strong>
   for f in me.faces:
      xy_area = Mathutils.TriangleArea(vec(f.v[0].co[:2]),vec(f.v[1].co[:2]),vec(f.v[2].co[:2]))
      Nz = f.no[2]
      avg_z = sum([f.v[i].co[2] for i in range(3)])/3.0
      partial_volume = avg_z * xy_area 
      if Nz &lt; 0: volume -= partial_volume
      if Nz &gt; 0: volume += partial_volume
      <strong>avg_x = sum([f.v[i].co[0] for i in range(3)])/3.0</strong>
 <strong>     avg_y = sum([f.v[i].co[1] for i in range(3)])/3.0</strong>
 <strong>     centroid = vec((avg_x,avg_y,avg_z/2))</strong>
      <strong>if Nz &lt; 0: cm -= partial_volume * centroid</strong>
 <strong>     if Nz &gt; 0: cm += partial_volume * centroid</strong>
   return volume,cm/volume</pre></div><p>The added or changed lines of code are highlighted.</p><div><div><div><div><h2 class="title"><a id="ch02lvl2sec31"/>Some remarks about accuracy</h2></div></div></div><a class="indexterm" id="id149"/><p>Although most of us are artists and not engineers, we still may ask how accurate the number is that we calculate for our mesh volume or center of mass. There are two things to consider—intrinsic accuracy and computational accuracy of our algorithm.</p><a class="indexterm" id="id150"/><a class="indexterm" id="id151"/><p>
<strong>Intrinsic</strong> <strong>accuracy</strong> is what we refer to when we consider the fact that our model is made out of small polygons that approximate some imagined shape. When doing organic modeling this hardly matters; if our model looks good, it is good. However, if we try to approximate some ideal form, for example a sphere, by a polygonal model (a uv-sphere say, or an icosphere) there will be a difference between the calculated volume and the known volume of the ideal sphere. We can improve this approximation by increasing the number of subdivisions (or equivalent the size of the polygons) but we will never be able to completely eliminate this difference and the algorithm used to calculate the volume cannot change that.</p><a class="indexterm" id="id152"/><a class="indexterm" id="id153"/><p>
<strong>Computational</strong> <strong>accuracy</strong> has several aspects. First, there is the precision of the numbers we calculate with. On most platforms that Blender runs on, calculations are performed using double precision floating point numbers. This amounts to about 17 digits of precision and there is nothing we can do to improve that. Luckily, that is ample precision to work with.</p><p>Then there is the accuracy of our algorithm. When you look at the code you will see that we are adding and multiplying a potentially huge amount of values, as a typical high-resolution model may well contain over a hundred thousand faces or even a million. For each face we calculate the volume of the projected column and all of these volumes are added (or subtracted) together. The problem is that these volumes may differ considerably in size, not only because the areas of the faces may differ but especially because the projected area of a near vertical face is very small compared to a near horizontal one.</p><p>Now if we add a very large and a very small number with limited precision calculations we will <em>lose</em> the small number. For example, if our precision would be limited to three significant digits, adding 0.001 and 0.0001 would end up as 0.001, losing the effect of the small number. Now our precision is a lot better (about 17 digits) but we add a lot more than two numbers. If we implement the <code class="literal">volume()</code> function<a class="indexterm" id="id154"/> by using one of the cited algorithms however, the difference never adds up to more than one in million, so as long as we don't aim to do nuclear science with Blender there is no need to bother. (For those who do, an alternative is provided in the script as the function <code class="literal">volume2()</code>. Still, be careful that you know what you are doing).<a class="indexterm" id="id155"/>
</p><div><div><h3 class="title"><a id="note07"/>Note</h3><p>Python is able to work with numbers of potentially infinite size and precision but this is much slower than doing normal floating point calculations. The functions and classes provided in <code class="literal">Mathutils</code> are primarily coded in C for speed and limited to double precision floats. See <a class="ulink" href="http://code.activestate.com/recipes/393090/">http://code.activestate.com/recipes/393090/</a> <a class="ulink" href="http://code.activestate.com/recipes/298339/">http://code.activestate.com/recipes/298339/</a> or Section 18.5 of Python Cookbook, 2nd edition, by O'Reilly for some other techniques and mathematical background.</p></div></div></div></div>
<div><div><div><div><h1 class="title"><a id="ch02lvl1sec24"/>Growing sunflowers—parenting and grouping objects</h1></div></div></div><p>Creating elaborate assemblies of objects is automated easily enough, but we would like to provide the end user with ways to select all of these related objects and to move them together. This section shows how we can achieve that by creating groups and by parenting objects to each other. You will end up with a bunch of nice sunflowers as a result.</p><div><img alt="Growing sunflowers—parenting and grouping objects" src="img/0400-02-17.jpg"/></div><div><div><div><div><h2 class="title"><a id="ch02lvl2sec32"/>Groups</h2></div></div></div><a class="indexterm" id="id156"/><p>Groups are devised to make it easier to select, or manipulate, more than one object at the same time. Sometimes this behavior is part of a larger scheme. An armature for example, is a collection of bones, but then these collections have very specific relations (bones in an armature have precisely defined relations to each other).</p><a class="indexterm" id="id157"/><p>There are many situations where we would like to identify a bunch of objects as belonging together without there being a specific relationship. Blender provides two kinds of groups to help us define their loose relations: <strong>object</strong> <strong>groups</strong> <a class="indexterm" id="id158"/>(or simply groups) for named collections of objects, and <strong>vertex groups</strong><a class="indexterm" id="id159"/> for named collections of vertices within mesh objects.<a class="indexterm" id="id160"/>
</p><p>Object groups allow us to select an otherwise unrelated set of objects we added to a group (we could group a mesh, an armature, and a bunch of empties together for example). A group relationship is different from a parent-child relationship. Groups merely allow us to select objects but parented objects move along when their parent is moved. The functionality to define and manipulate groups is provided in the <code class="literal">Group</code> module and its identically named class (a group is just like another Blender object, but one containing a list of references to other objects, but not to other groups unfortunately). You might, for example, append a group from an external <code class="literal">.blend</code> file just like you would a <code class="literal">Lamp</code> or a <code class="literal">Mesh</code>. The following table lists some often used group operations (see the <code class="literal">Blender.Group</code> module in the Blender API documentation for additional functionality):</p><div><table border="1"><colgroup><col style="text-align: left"/><col style="text-align: left"/></colgroup><thead><tr><th style="text-align: left" valign="bottom">
<p>Operation</p>
</th><th style="text-align: left" valign="bottom">
<p>Action</p>
</th></tr></thead><tbody><tr><td style="text-align: left" valign="top">
<p>
<code class="literal">group=Group.New(name='aGroupName')</code>
</p>
</td><td style="text-align: left" valign="top">
<p>Creates a new group</p>
</td></tr><tr><td style="text-align: left" valign="top">
<p>
<code class="literal">group=Group.Get(name='aGroupName')</code>
</p>
</td><td style="text-align: left" valign="top">
<p>Gets a reference to a group by name</p>
</td></tr></tbody></table></div><p>Vertex groups are a convenient way to identify groups of related vertices (such as an ear or a leg in a model of a toy for example) but they have their uses beyond mere selecting. They can be used to determine the influence of bone deformations or to identify emitter regions of particle systems to name a few. Vertex groups will be our focus in the next chapter.</p></div><div><div><div><div><h2 class="title"><a id="ch02lvl2sec33"/>Parenting</h2></div></div></div><a class="indexterm" id="id161"/><a class="indexterm" id="id162"/><p>
<strong>Parenting</strong> in real life might be difficult at times, but in Blender it is rather easy although there is a sometimes bewildering array of options to choose from. It is possible to parent an object to another object, to a single bone in an armature, or to one or three vertices in a <code class="literal">Mesh</code> object. The following table shows the relevant methods (Refer to <code class="literal">Blender.Object</code> in the Blender API for additional functionality):</p><div><table border="1"><colgroup><col style="text-align: left"/><col style="text-align: left"/></colgroup><thead><tr><th style="text-align: left" valign="bottom">
<p>Operator</p>
</th><th style="text-align: left" valign="bottom">
<p>Action</p>
</th></tr></thead><tbody><tr><td style="text-align: left" valign="top">
<p>parent.makeParent([child1, child2, child3])</p>
</td><td style="text-align: left" valign="top">
<p>parent-children to a parent object</p>
</td></tr><tr><td style="text-align: left" valign="top">
<p>parentmesh.makeParentVertex([child1,child2,child3],vertexindex1) </p>
</td><td style="text-align: left" valign="top">
<p>parent-children to a vertex</p>
</td></tr><tr><td style="text-align: left" valign="top">
<p>parentmesh.makeParentVertex([child1,child2,child3],vertexindex1,vertexindex2,vertexindex3) </p>
</td><td style="text-align: left" valign="top">
<p>parent-children to three vertices</p>
</td></tr></tbody></table></div></div><div><div><div><div><h2 class="title"><a id="ch02lvl2sec34"/>Growing a sunflower from a seed</h2></div></div></div><a class="indexterm" id="id163"/><p>We can put all this information to good use when we write a script that will create a model of a sunflower (Van Gogh would probably have cut off his other ear as well if he saw this "sunflower" but then again, his was another way of looking altogether). The single sunflower that we will be creating consists of a stalk and a flower head. The head of a sunflower consists of tiny flowers that will become the seeds once fertilized and a rim of large petals. (I know, any botanist will cringe at my language. The tiny flowers are called "disc florets"—but floret is just a "little flower" right? And the ones on the edge are "ray florets".) Our head will have seeds and each seed is a separate <code class="literal">Mesh</code> object that will be vertex-parented to our head mesh.</p><p>We would like our seeds to not just move along with our seed head, but to follow any local curvature and orient themselves perpendicular to the head surface so we can, for example, distort the head mesh with proportional editing and all attached seeds will follow. To accomplish that we use the three vertex variant of vertex parenting.</p><p>By parenting an object to three different vertices of a mesh, that object will follow the position of those vertices and orient itself relative to the normal (see the following illustrations):</p><div><img alt="Growing a sunflower from a seed" src="img/0400-02-18.jpg"/></div><p>We do not need to connect all those triplets of vertices as the head mesh itself will not be rendered (it will be fully covered by seeds). We do define a face between each triplet of vertices though; otherwise it would be difficult for a modeler to see the head mesh in <em>edit</em> mode.</p><div><img alt="Growing a sunflower from a seed" src="img/0400-02-19.jpg"/></div><a class="indexterm" id="id164"/><p>The petals are separate objects parented in the normal way to the head mesh as they need not follow any curvature of the head mesh, just its location and rotation. The head in turn is parented to the stalk so we can move the whole assembly around by moving the stalk.</p><p>Finally, we assign all individual objects to a single group. That way it will be easy to select everything in one go and it enables us to link or append one or more sunflowers from an external file as a single entity.</p></div><div><div><div><div><h2 class="title"><a id="ch02lvl2sec35"/>Duplication versus instantiation</h2></div></div></div><p>We said that all our seeds and petals are separate objects but it might make more sense to instantiate them instead (called <strong>making a linked copy</strong> in Blender). As all seeds and all petals as we have modeled them are identical, we can refer to the same mesh data and just change the location, rotation, or scale of the object as needed—saving possibly a fair amount of memory. When using Blender interactively we can instantiate an object by pressing <em>Alt + D</em> (instead of <em>Shift + D</em> for a regular copy). In our script, we simply define a new object and point it to the same <code class="literal">Mesh</code> object by passing a reference to the same mesh when calling <code class="literal">Object.New()</code>.</p></div><div><div><div><div><h2 class="title"><a id="ch02lvl2sec36"/>Growing a sunflower</h2></div></div></div><p>Let's look at the main part of the script that will create the sunflower (the full script is available as <code class="literal">sunflower.py</code>). The first step is to calculate the position of the seeds:<a class="indexterm" id="id165"/>
</p><div><pre class="programlisting">def sunflower(scene,nseeds=100,npetals=50):
   pos = kernelpositions(nseeds)</pre></div><p>From these positions we create the head, vertices, and faces that we can parent the kernels to and assemble these into the head mesh (highlighted part of the following code):</p><div><pre class="programlisting">   headverts=pos2verts(pos)
   faces=[(v,v+1,v+2) for v in range(0,len(headverts),3)]
 <strong>  head=Tools.addmeshobject(scene,headverts,faces,name='head')</strong>
</pre></div><p>The next step is to create the base mesh for the kernel and create objects that reference this mesh (highlighted part of the following code):</p><div><pre class="programlisting">   kernelverts,kernelfaces=kernel(radius=1.5,scale=(1.0,1.0,0.3))
   kernelmesh = Tools.newmesh(kernelverts,kernelfaces,name='kernel')
   <strong>kernels = [Tools.addmeshduplicate(scene,kernelmesh,name='kernel')for i in range(nseeds)]</strong>
</pre></div><p>Each kernel is then assigned a suitable location and parented to the appropriate vertices in the flower head mesh (highlighted part of the following code):</p><div><pre class="programlisting">   for i in range(nseeds):
      loc = Tools.center(head.data.verts[i*3:(i+1)*3])
      kernels[i].setLocation(loc)
      head.<strong>makeParentVertex</strong>([kernels[i]],tuple([v.index for v in head.data.verts[i*3:(i+1)*3]]))</pre></div><p>Next, we create a petal mesh and arrange duplicates of this mesh along the rim of the flower head (highlighted part of the following code):</p><div><pre class="programlisting">   petalverts,petalfaces=petal((2.0,1.0,1.0))
   petalmesh = Tools.newmesh(petalverts,petalfaces,name='petal')
   r = sqrt(nseeds)
   petals = <strong>[Tools.addmeshduplicate</strong>(scene,petalmesh,name='petal') for i in range(npetals)]</pre></div><p>Each petal is positioned and rotated along the rim and parented to the head (highlighted part of the following code):</p><div><pre class="programlisting">   for i,p in enumerate(petals):
      a=float(i)*2*pi/npetals
      p.setLocation(r*cos(a),r*sin(a),0)
      e=p.getEuler('localspace')
      e.z=a
      p.setEuler(e)
      head.<strong>makeParent</strong>(petals)</pre></div><p>Finally, we create a stalk mesh and object and parent the head to the stalk. This way the entire flower may be moved by moving the stalk:</p><div><pre class="programlisting">   # add stalk (parent head to stalk)
   stalkverts,stalkfaces=stalk()
   stalkob = Tools.addmeshobject(scene,stalkverts,stalkfaces,name='stalk')
   stalkob.makeParent([head])</pre></div><a class="indexterm" id="id166"/><p>All that is left to do is to group the kernels and petals in separate groups (highlighted) and then all parts in an overall sunflower group for easy reference:</p><div><pre class="programlisting">   kernelgroup = <strong>Blender.Group.New</strong>('kernels')
   kernelgroup.objects=kernels
   petalgroup = <strong>Blender.Group.New</strong>('petals')
   petalgroup.objects=petals
   all = Blender.Group.New('sunflower')
   all.objects=sum([kernels,petals],[head,stalkob])</pre></div><p>The <code class="literal">addmeshduplicate()</code> function used in the code is implemented in the <code class="literal">Tools</code> module in the following manner:<a class="indexterm" id="id167"/>
</p><div><pre class="programlisting">def addmeshduplicate(scn,me,name=None): 
   ob=scn.objects.new(me)
   if name : ob.setName(name)
   <strong>scn.objects.active=ob</strong>
   me.remDoubles(0.001)
   me.recalcNormals()
   for f in me.faces: f.smooth = 1
      me.update()
   Blender.Window.RedrawAll()
   return ob</pre></div><p>Given a scene, a mesh, and a name (optional) for the object, it adds a new object to the scene. The <code class="literal">Mesh</code> object passed as an argument might be used again and again to create new objects that refer to the same mesh.</p><p>Newly created objects will be selected automatically but not be made active, so the next step is to make the newly-created object active (highlighted in the preceding code). This is not necessary but might be convenient to the user as are the next two actions: ensuring that all face normals point consistently outward and removing any vertices that are very close together. These last two actions can only be performed on a mesh that is embedded in an object.</p><a class="indexterm" id="id168"/><p>Also, as a convenience, we set the <code class="literal">smooth</code> attribute for all faces, to get smoother images when rendering. Finally, we update the display list for this mesh and notify all Blender windows that there has been a change.</p><div><div><h3 class="title"><a id="tip04"/>Tip</h3><p>
<strong>A slight digression, or why rabbits are related to sunflowers.</strong>
</p><p>One of the things you may notice is that we have arranged the seeds in a peculiar spiral. This type of spiral, where subsequent positions along the spiral are spaced by following the so-called <em>Golden</em> <em>ratio</em> is called <strong>Fermat's</strong> <strong>spiral</strong>. Such a spiral results naturally in many seed heads when the florets or seeds are formed in the middle and pushed outward, resulting in a highly efficient packing.<a class="indexterm" id="id169"/>
</p><p>When seen from above, the arrangement of seeds also seem to follow both left and right turning curves. The numbers of these curves usually are a pair from the <em>Fibonacci</em> <em>sequence</em> <em>[ 1 1 2 3 5 8 13 21 …]</em> and the ratio of such a pair of numbers tends to converge on the <em>Golden</em> <em>ratio</em> when they get bigger. (In the two illustrations of our seed head below we can discern 13 counterclockwise spirals and 21 clockwise spirals.) Fibonacci invented this series in an attempt to model the population growth of rabbits. More about sunflowers (and possibly rabbits) may be found here: <a class="ulink" href="http://en.wikipedia.org/wiki/Sunflower">http://en.wikipedia.org/wiki/Sunflower</a>.</p></div></div><div><img alt="Growing a sunflower" src="img/0400-02-20_NEW.jpg"/></div><a class="indexterm" id="id170"/></div></div>
<div><div><div><div><h1 class="title"><a id="ch02lvl1sec25"/>Summary </h1></div></div></div><p>In this chapter, we have seen how to create complex objects and how to make the task of configuring those objects on easy one for the end user by providing a graphical user interface that remembers previous choices. We saw that it was also possible to recruit Blender as a command-line tool to automate common tasks.</p><p>We also learned how to create a parent relation between objects and made a first step in editing meshes. Specifically, we saw how to:</p><div><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">Create configurable mesh objects</li><li class="listitem" style="list-style-type: disc">Design a graphical user interface </li><li class="listitem" style="list-style-type: disc">Make your script store user choices for later reuse</li><li class="listitem" style="list-style-type: disc">Select vertices and faces in a mesh</li><li class="listitem" style="list-style-type: disc">Parent an object to another</li><li class="listitem" style="list-style-type: disc">Create groups</li><li class="listitem" style="list-style-type: disc">Modify meshes</li><li class="listitem" style="list-style-type: disc">Run Blender from the command line and render in the background</li><li class="listitem" style="list-style-type: disc">Process command-line parameters</li></ul></div><p>In the next chapter, we will see how we can assign vertex groups and materials to our meshes.</p></div></body></html>