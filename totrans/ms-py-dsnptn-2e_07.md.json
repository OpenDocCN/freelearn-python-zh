["```py\nfrom concurrent.futures import ThreadPoolExecutor\nimport time\n```", "```py\ndef task(n):\n    print(f\"Executing task {n}\")\n    time.sleep(1)\n    print(f\"Task {n} completed\")\n```", "```py\nwith ThreadPoolExecutor(max_workers=5) as executor:\n    for i in range(10):\n        executor.submit(task, i)\n```", "```py\nExecuting task 0\nExecuting task 1\nExecuting task 2\nExecuting task 3\nExecuting task 4\nTask 0 completed\nTask 4 completed\nTask 3 completed\nTask 1 completed\nExecuting task 6\nExecuting task 7\nExecuting task 8\nTask 2 completed\nExecuting task 5\nExecuting task 9\nTask 8 completed\nTask 6 completed\nTask 9 completed\nTask 5 completed\nTask 7 completed\n```", "```py\nfrom multiprocessing import Process, Queue\nimport time\n```", "```py\ndef worker(task_queue):\n    while not task_queue.empty():\n        task = task_queue.get()\n        print(f\"Worker {task} is processing\")\n        time.sleep(1)\n        print(f\"Worker {task} completed\")\n```", "```py\ndef main():\n    task_queue = Queue()\n    for i in range(10):\n        task_queue.put(i)\n```", "```py\n    processes = [\n        Process(target=worker, args=(task_queue,))\n        for _ in range(5)\n    ]\n    # Start the worker processes\n    for p in processes:\n        p.start()\n    # Wait for all worker processes to finish\n    for p in processes:\n        p.join()\n    print(\"All tasks completed.\")\n```", "```py\nWorker 0 is processing\nWorker 1 is processing\nWorker 2 is processing\nWorker 3 is processing\nWorker 4 is processing\nWorker 0 completed\nWorker 5 is processing\nWorker 1 completed\nWorker 6 is processing\nWorker 2 completed\nWorker 7 is processing\nWorker 3 completed\nWorker 8 is processing\nWorker 4 completed\nWorker 9 is processing\nWorker 5 completed\nWorker 6 completed\nWorker 7 completed\nWorker 8 completed\nWorker 9 completed\nAll tasks completed.\n```", "```py\nfrom concurrent.futures import ThreadPoolExecutor, as_completed\n```", "```py\ndef square(x):\n    return x * x\n```", "```py\nwith ThreadPoolExecutor() as executor:\n    future1 = executor.submit(square, 2)\n    future2 = executor.submit(square, 3)\n    future3 = executor.submit(square, 4)\n    futures = [future1, future2, future3]\n    for future in as_completed(futures):\n        print(f\"Result: {future.result()}\")\n```", "```py\nResult: 16\nResult: 4\nResult: 9\n```", "```py\nimport asyncio\n```", "```py\nasync def square(x):\n    # Simulate some IO-bound operation\n    await asyncio.sleep(1)\n    return x * x\n```", "```py\nasync def main():\n    fut1 = asyncio.ensure_future(square(2))\n    fut2 = asyncio.ensure_future(square(3))\n    fut3 = asyncio.ensure_future(square(4))\n    results = await asyncio.gather(fut1, fut2, fut3)\n    for result in results:\n        print(f\"Result: {result}\")\n```", "```py\nif __name__ == \"__main__\":\n    asyncio.run(main())\n```", "```py\nResult: 4\nResult: 9\nResult: 16\n```", "```py\nPeter Brown, Gabriel Hunt, Gary Martinez, Heather Fernandez, Juan White, Alan George, Travis Davidson, David Adams, Christopher Morris, Brittany Thomas, Brian Allen, Stefanie Lutz, Craig West, William Phillips, Kirsten Michael, Daniel Brennan, Derrick West, Amy Vazquez, Carol Howard, Taylor Abbott,\n```", "```py\nfrom pathlib import Path\nimport reactivex as rx\nfrom reactivex import operators as ops\n```", "```py\ndef firstnames_from_db(path: Path):\n    file = path.open()\n    # collect and push stored people firstnames\n    return rx.from_iterable(file).pipe(\n        ops.flat_map(\n            lambda content: rx.from_iterable(\n                content.split(\", \")\n            )\n        ),\n        ops.filter(lambda name: name != \"\"),\n        ops.map(lambda name: name.split()[0]),\n        ops.group_by(lambda firstname: firstname),\n        ops.flat_map(\n            lambda grp: grp.pipe(\n                ops.count(),\n                ops.map(lambda ct: (grp.key, ct)),\n            )\n        ),\n    )\n```", "```py\ndef main():\n    db_path = Path(__file__).parent / Path(\"people.txt\")\n    # Emit data every 5 seconds\n    rx.interval(5.0).pipe(\n        ops.flat_map(lambda i: firstnames_from_db(db_path))\n    ).subscribe(lambda val: print(str(val)))\n    # Keep alive until user presses any key\n    input(\"Starting... Press any key and ENTER, to quit\\n\")\n```", "```py\nStarting... Press any key and ENTER, to quit\n('Peter', 1)\n('Gabriel', 1)\n('Gary', 1)\n('Heather', 1)\n('Juan', 1)\n('Alan', 1)\n('Travis', 1)\n('David', 1)\n('Christopher', 1)\n('Brittany', 1)\n('Brian', 1)\n('Stefanie', 1)\n('Craig', 1)\n('William', 1)\n('Kirsten', 1)\n('Daniel', 1)\n('Derrick', 1)\n```", "```py\nfrom faker import Faker\nimport sys\nfake = Faker()\nargs = sys.argv[1:]\nif len(args) == 1:\n    output_filename = args[0]\n    persons = []\n    for _ in range(0, 20):\n        p = {\"firstname\": fake.first_name(), \"lastname\": fake.last_name()}\n        persons.append(p)\n    persons = iter(persons)\n    data = [f\"{p['firstname']} {p['lastname']}\" for p in persons]\n    data = \", \".join(data) + \", \"\n    with open(output_filename, \"a\") as f:\n        f.write(data)\nelse:\n    print(\"You need to pass the output filepath!\")\n```"]