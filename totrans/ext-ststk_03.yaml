- en: Chapter 3. Extending Salt Configuration
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第3章：扩展Salt配置
- en: 'By now you know how to access configuration variables from the various parts
    of Salt, except for SDB modules, which will be covered in this chapter. But while
    setting static configuration is all fine and well, it can be very useful to be
    able to supply that data from an external source. In this chapter, you''ll learn
    about:'
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 到现在为止，您已经知道如何从Salt的各个部分访问配置变量，除了SDB模块，这将在本章中介绍。但在设置静态配置的同时，能够从外部源提供这些数据非常有用。在本章中，您将学习以下内容：
- en: Writing dynamic grains and external pillars
  id: totrans-2
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 编写动态grains和外部的pillars
- en: Troubleshooting grains and pillars
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 故障排除grains和pillars
- en: Writing and using SDB modules
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 编写和使用SDB模块
- en: Troubleshooting SDB modules
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 故障排除SDB模块
- en: Setting grains dynamically
  id: totrans-6
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 动态设置grains
- en: As you already know, grains hold variables that describe certain aspects of
    a Minion. This could be information about the operating system, the hardware,
    the network, and so on. It can also contain statically defined user data, which
    is configured either in `/etc/salt/minion` or `/etc/salt/grains`. It is also possible
    to define grains dynamically using grains modules.
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: 正如您已经知道的，grains包含描述Minion某些方面的变量。这可能包括有关操作系统、硬件、网络等信息。它还可以包含静态定义的用户数据，这些数据配置在`/etc/salt/minion`或`/etc/salt/grains`中。还可以使用grains模块动态定义grains。
- en: Setting some basic grains
  id: totrans-8
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 设置一些基本的grains
- en: Grains modules are interesting in that so long as the module is loaded, all
    public functions will be executed. As each function is executed, it will return
    a dictionary, which contains items to be merged into the Minion's grains.
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: Grains模块很有趣，只要模块被加载，所有公共函数都会被执行。随着每个函数的执行，它将返回一个字典，其中包含要合并到Minion的grains中的项。
- en: Let's go ahead and set up a new grains module to demonstrate. We'll prepend
    the names of the return data with a `z` so that it is easy to find.
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们继续设置一个新的grains模块来演示。我们将返回数据的名称前面加上一个`z`，以便于查找。
- en: '[PRE0]'
  id: totrans-11
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'Go ahead and save this file as `salt/grains/testdata.py`, and then use `salt-call`
    to display all of the grains, including this one:'
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 继续将此文件保存为`salt/grains/testdata.py`，然后使用`salt-call`显示所有grains，包括这个：
- en: '[PRE1]'
  id: totrans-13
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'Keep in mind that you can also use `grains.item` to display only a single grain:'
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 请记住，您也可以使用 `grains.item` 来仅显示单个grain：
- en: '[PRE2]'
  id: totrans-15
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'It may not look like this module is much good, since this is still just static
    data that could be defined in the `minion` or `grains` files. But keep in mind
    that, as with other modules, grains modules can be gated using a `__virtual__()`
    function. Let''s go ahead and set that up, along with a flag of sorts that will
    determine whether or not this module will load in the first place:'
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 这个模块可能看起来并不怎么有用，因为这只是静态数据，这些数据可以在`minion`或`grains`文件中定义。但请记住，与其他模块一样，grains模块可以使用`__virtual__()`函数进行控制。让我们继续设置它，以及一个决定此模块是否首先加载的某种类型的标志：
- en: '[PRE3]'
  id: totrans-17
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'Go ahead and run the following commands to see this in action:'
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 继续运行以下命令以查看此功能的作用：
- en: '[PRE4]'
  id: totrans-19
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: This is very useful for gating the return data from an entire module, whether
    dynamic or, as this module currently is, static.
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 这对于控制整个模块的返回数据非常有用，无论是动态的还是，如这个模块目前所是，静态的。
- en: 'You may be wondering why that example checked for the existence of a file,
    rather than checking the existing Minion configuration. This is to illustrate
    that the detection of certain system properties is likely to dictate how grains
    are set. If you want to just set a flag inside the `minion` file, you can pull
    it out of `__opts__`. Let''s go ahead and add that to the `__virtual__()` function:'
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 您可能想知道为什么那个例子检查了文件的存在，而不是检查现有的Minion配置。这是为了说明检测某些系统属性可能会决定如何设置grains。如果您只想在`minion`文件中设置一个标志，您可以从`__opts__`中提取它。让我们继续将其添加到`__virtual__()`函数中：
- en: '[PRE5]'
  id: totrans-22
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'Go ahead and remove the old flag, and set the new one:'
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 继续删除旧的标志，并设置新的标志：
- en: '[PRE6]'
  id: totrans-24
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'Let''s go ahead and set up this module to return dynamic data as well. Because
    YAML is so prevalent in Salt, let''s go ahead and set up a function that returns
    the contents of a YAML file:'
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们继续设置这个模块，使其也能返回动态数据。由于YAML在Salt中非常普遍，让我们设置一个函数，返回YAML文件的内容：
- en: '[PRE7]'
  id: totrans-26
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: You may notice that we've used `salt.utils.fopen()` instead of a standard Python
    `open()`. Salt's `fopen()` function wraps Python's `open()` with some extra handling,
    so that files are closed properly on Minions.
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 您可能会注意到，我们使用了`salt.utils.fopen()`而不是标准的Python `open()`。Salt的`fopen()`函数用一些额外的处理包装了Python的`open()`，以确保在Minions上正确关闭文件。
- en: 'Save your module, and then issue the following commands to see the result:'
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 保存你的模块，然后输入以下命令以查看结果：
- en: '[PRE8]'
  id: totrans-29
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: (Not) cross-calling execution modules
  id: totrans-30
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: （不）跨调用执行模块
- en: You may be tempted to try to cross-call an execution module from inside a grains
    module. Unfortunately, that won't work. The `__virtual__()` function in many execution
    modules relies heavily on grains. Allowing grains to cross-call to execution modules,
    before Salt has decided whether or not to even the execution module in the first
    place, would cause circular dependencies.
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 你可能会尝试从谷物模块内部跨调用执行模块。不幸的是，这是不可能的。许多执行模块中的`__virtual__()`函数严重依赖于谷物。如果允许谷物在Salt决定是否首先启用执行模块之前就跨调用执行模块，将会导致循环依赖。
- en: Just remember, grains are loaded first, then pillars, then execution modules.
    If you have code that you plan to use two or more of these types of modules, consider
    setting up a library for it in the `salt/utils/` directory.
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 只需记住，谷物首先加载，然后是柱子，然后是执行模块。如果你打算使用两种或更多这类模块的代码，考虑在`salt/utils/`目录下为它设置一个库。
- en: The final grains module
  id: totrans-33
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 最终的谷物模块
- en: 'With all of the code we''ve put together, the resulting module should look
    like the following:'
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经编写了所有这些代码，生成的模块应该看起来如下：
- en: '[PRE9]'
  id: totrans-35
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: Creating external pillars
  id: totrans-36
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 创建外部柱子
- en: 'As you know, pillars are like grains, with a key difference: grains are defined
    on the Minion, whereas pillars are defined for individual Minions, from the Master.'
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 正如你所知，柱子就像谷物，有一个关键的区别：谷物是在Minion上定义的，而柱子是为单个Minion定义的，从Master那里定义。
- en: 'As far as users are concerned, there''s not a whole lot of difference here,
    except that pillars must be mapped to targets on the Master, using the `top.sls`
    file in `pillar_roots`. One such mapping might look like this:'
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 对于用户来说，这里没有太多区别，除了柱子必须映射到Master上的目标，使用`pillar_roots`中的`top.sls`文件。这样的映射可能看起来像这样：
- en: '[PRE10]'
  id: totrans-39
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'In this example, we would have a pillar called test defined, which might look
    like this:'
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个例子中，我们会定义一个名为test的柱子，它可能看起来像这样：
- en: '[PRE11]'
  id: totrans-41
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: Dynamic pillars are still mapped in the `top.sls` file, but that's where the
    similarities end, so far as configuration is concerned.
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 动态柱子在`top.sls`文件中仍然被映射，但在配置方面，相似之处到此为止。
- en: Configuring external pillars
  id: totrans-43
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 配置外部柱子
- en: 'Unlike dynamic grains, which will run so long as their `__virtual__()` function
    allows them to do so, pillars must be explicitly enabled in the `master` configuration
    file. Or, if running in local mode as we will be, in the `minion` configuration
    file. Let''s go ahead and add the following lines to the end of `/etc/salt/minion`:'
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 与动态谷物不同，只要它们的`__virtual__()`函数允许它们这样做，就会一直运行，柱子必须在`master`配置文件中显式启用。或者，如果我们像我们这样在本地模式下运行，在`minion`配置文件中。让我们继续在`/etc/salt/minion`的末尾添加以下行：
- en: '[PRE12]'
  id: totrans-45
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: If we were testing this on the Master, we would need to restart the `salt-master`
    service. However, since we're testing in local mode on the Minion, this will not
    be required.
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们在Master上测试这个，我们需要重新启动`salt-master`服务。然而，由于我们在Minion上以本地模式测试，这不会是必需的。
- en: Adding an external pillar
  id: totrans-47
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 添加外部柱子
- en: 'We''ll also need to create a simple external pillar to get started with. Go
    ahead and create `salt/pillar/test_pillar.py` with the following content:'
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还需要创建一个简单的外部柱子来开始。创建`salt/pillar/test_pillar.py`并包含以下内容：
- en: '[PRE13]'
  id: totrans-49
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'Go ahead and save your work, and then test it to make sure it works:'
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 保存你的工作，然后测试以确保它工作正常：
- en: '[PRE14]'
  id: totrans-51
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: Let's go over what's happened here. First off, we have a function called `ext_pillar()`.
    This function is required in all external pillars. It is also the only function
    that is required. Any others, whether or not named with a preceding underscore,
    will be private to this module.
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们回顾一下这里发生了什么。首先，我们有一个名为`ext_pillar()`的函数。这个函数在所有外部柱子中都是必需的。它也是唯一必需的函数。任何其他函数，无论是否以前置下划线命名，都将仅限于这个模块。
- en: 'This function will always be passed three pieces of data. The first is the
    ID of the Minion that is requesting this pillar. You can see this in our example
    already: the `minion_id` where the earlier example was run was `dufresne`. The
    second is a copy of the static pillars defined for this Minion. The third is an
    extra piece of data that was passed to this external pillar in the `master` (or
    in this case, `minion`) configuration file.'
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 这个函数将始终传递三份数据。第一份是请求此柱子的Minion的ID。你可以在我们的例子中看到这一点：之前示例中运行的`minion_id`是`dufresne`。第二份是为这个Minion定义的静态柱子的副本。第三份是在`master`（或在这种情况下，`minion`）配置文件中传递给这个外部柱子的额外数据。
- en: 'Let''s go ahead and update our pillar to show us what each component looks
    like. Change your `ext_pillar()` function to look like:'
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  id: totrans-55
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'Save it, and then modify the `ext_pillar` configuration in your `minion` (or
    `master`) file:'
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  id: totrans-57
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'Take a look at your pillar data again:'
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  id: totrans-59
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: You can see the `test_pillar` that we referenced a couple of pages ago. And
    of course, you can see `minion_id`, just like before. The important part here
    is `config`.
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
- en: This example was chosen to make it clear where the `config` argument came from.
    When an external pillar is added to the `ext_pillar` list, it is entered as a
    dictionary, with a single item as its value. The item that is specified can be
    a string, boolean, integer, or float. It cannot be a dictionary or a list.
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
- en: 'This argument is normally used to pass arguments into the pillar from the configuration
    file. For instance, the `cmd_yaml` pillar that ships with Salt uses it to define
    a command that is expected to return data in YAML format:'
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  id: totrans-63
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'If the only thing that your pillar requires is to be enabled, then you can
    just set this to True, and then ignore it. However, you must still set it! Salt
    will expect that data to be there, and you will receive an error like this if
    it is not:'
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  id: totrans-65
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: Tip
  id: totrans-66
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Although `minion_id`, `pillar`, and `config` are all passed into the `ext_pillar()`
    function (in that order), Salt doesn't actually care what you call the variables
    in your function definition. You could call them Emeril, Mario, and Alton if you
    wanted (not that you would). But whatever you call them, they must still all be
    there.
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
- en: Another external pillar
  id: totrans-68
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Let''s put together another external pillar, so that it doesn''t get confused
    with our first one. This one''s job is to check the status of a web service. First,
    let''s write our pillar code:'
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  id: totrans-70
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: You've probably noticed that our `docstring` states that This file should be
    saved as `salt/pillar/http_status.py`. When you check out the Salt codebase, there
    is a directory called `salt/` that contains the actual code. This is the directory
    that is referred to in the `docstring`. You will continue to see these comments
    in the code examples throughout this book.
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
- en: 'Save this file as `salt/pillar/http_status.py`. Then go ahead and update your
    `ext_pillar` configuration to point to it. For now, we''ll use GitHub''s status
    URL:'
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  id: totrans-73
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'Go ahead and save the configuration, and then test the pillar:'
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  id: totrans-75
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'If you need to be able to check the status on multiple services, you can use
    the same external pillar multiple times, but with different configurations. Try
    updating your `ext_pillar` definition to contain two entries:'
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  id: totrans-77
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: Now, this can quickly become a problem. GitHub won't be happy with you if you're
    constantly hitting their status API. So, as nice as it is to get real-time status
    updates, you may want to do something to throttle your queries. Let's save the
    status in a file, and return it from there. We will check the file's timestamp
    to make sure it doesn't get updated more than once a minute.
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s go ahead and update the entire external pillar:'
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们继续更新整个外部 pillar：
- en: '[PRE24]'
  id: totrans-80
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'Now we''ve set a flag called `refresh`, and the URL will only be hit when that
    flag is `True`. We''ve also defined a file that will cache the content obtained
    from that URL. The file will contain the name given to the pillar, so it will
    end up having a name like `/tmp/status-github.json`. The following two lines will
    retrieve the last modified time of the file, and the current time in seconds:'
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们设置了一个名为 `refresh` 的标志，并且只有当该标志为 `True` 时才会访问 URL。我们还定义了一个将缓存从该 URL 获取的内容的文件。该文件将包含
    pillar 的名称，因此最终会有一个像 `/tmp/status-github.json` 这样的名称。以下两行将检索文件的最后修改时间和当前时间（以秒为单位）：
- en: '[PRE25]'
  id: totrans-82
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: And comparing the two, we can determine whether the file is more than 60 seconds
    old. If we wanted to make the pillar even more configurable, we could even move
    that `60` to the `config` parameter, and pull it from `comps[2]`.
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 通过比较这两个，我们可以确定文件是否超过 60 秒。如果我们想使 pillar 更具可配置性，甚至可以将那个 `60` 移动到 `config` 参数，并从
    `comps[2]` 中获取它。
- en: Troubleshooting grains and pillars
  id: totrans-84
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 故障排除 grains 和 pillars
- en: While writing grains and pillars, you may encounter some difficulties. Let's
    take a look at the most common problems you might have.
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 在编写 grains 和 pillars 时，你可能会遇到一些困难。让我们看看你可能会遇到的最常见问题。
- en: Dynamic grains not showing up
  id: totrans-86
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 动态 grains 未显示
- en: You may find that when you issue a `grains.items` command from the Master, your
    dynamic grains aren't showing up. This can be difficult to track down, because
    grains are evaluated on the Minion, and any errors aren't likely to make it back
    over the wire to you.
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 你可能会发现，当你从 Master 发出 `grains.items` 命令时，你的动态 grains 没有显示。这可能很难追踪，因为 grains 在
    Minion 上评估，任何错误都不太可能通过线路返回给你。
- en: When you find that dynamic grains aren't showing up as you expect, it's usually
    easiest to log in to the Minion directly to troubleshoot. Open up a shell and
    try issuing a `salt-call` command to see if any errors manifest themselves. If
    they don't immediately, try adding `--log-level=debug` to your command to see
    if any errors have been hiding at that level. Using a `trace` log level might
    also be necessary.
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 当你发现动态 grains 没有按照预期显示时，通常最简单的方法是直接登录到 Minion 进行故障排除。打开一个 shell 并尝试执行一个 `salt-call`
    命令，看看是否有错误出现。如果它们没有立即出现，尝试在命令中添加 `--log-level=debug` 来查看是否有错误隐藏在那个级别。使用 `trace`
    日志级别可能也是必要的。
- en: External pillars not showing up
  id: totrans-89
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 外部 pillars 未显示
- en: These can be a little more difficult to pick out. Using `salt-call` is effective
    in finding errors in grains, because all of the code can be executed without starting
    up or contacting a service. But pillars come from the Master, unless you're running
    `salt-call` in `local` mode.
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 这些可能有点难以找出。使用 `salt-call` 在 grains 中查找错误是有效的，因为所有代码都可以在不启动或联系服务的情况下执行。但是，pillars
    来自 Master，除非你在 `local` 模式下运行 `salt-call`。
- en: If you are able to install your external pillar code on a Minion for testing,
    then the steps are the same as for checking for grains errors. But if you find
    yourself in a situation where the Master's environment cannot be duplicated on
    a Minion, you will need to use a different tactic.
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你能够在一个 Minion 上安装你的外部 pillar 代码进行测试，那么步骤与检查 grains 错误相同。但是，如果你发现自己处于 Master
    的环境无法在 Minion 上复制的情形，你需要使用不同的策略。
- en: 'Stop the `salt-master` service on the Master, and then start it back up in
    the foreground, with a debug log level:'
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 在 Master 上停止 `salt-master` 服务，然后以调试日志级别重新启动它：
- en: '[PRE26]'
  id: totrans-93
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: 'Then open up another shell and check the pillars for an affected Minion:'
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 然后打开另一个 shell 并检查受影响的 Minion 的 pillars：
- en: '[PRE27]'
  id: totrans-95
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: Any errors in the pillar code should manifest themselves in the window with
    `salt-master` running in the foreground.
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: pillar 代码中的任何错误都应该在 `salt-master` 以前台运行时在窗口中显示出来。
- en: Writing SDB modules
  id: totrans-97
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 编写 SDB 模块
- en: SDB is a relatively new type of module, and ripe for development. It stands
    for Simple Database, and it is designed to allow data to be simple to query, using
    a very short URI. Underlying configuration can be as complex as necessary, so
    long as the URI that is used to query it is as simple as possible.
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: SDB 是一种相对较新的模块类型，非常适合开发。它代表 Simple Database，它旨在允许数据以非常简短的 URI 查询。底层配置可以像必要的那么复杂，只要用于查询它的
    URI 尽可能简单。
- en: Another design goal of SDB is that URIs can mask sensitive pieces of information
    from being stored directly inside a configuration file. For instance, passwords
    are often required for other types of modules, such as the `mysql` modules. But
    it is a poor practice to store passwords in files that are then stored inside
    a revision control system such as Git.
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: SDB的另一个设计目标是URI可以隐藏敏感信息，使其不会直接存储在配置文件中。例如，密码通常用于其他类型的模块，如`mysql`模块。但是，将密码存储在随后存储在版本控制系统（如Git）中的文件中是一种不良做法。
- en: Using SDB to look up passwords on the fly allows references to the passwords
    to be stored, but not the passwords themselves. This makes it much safer to store
    files that reference sensitive data, inside revision control systems.
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 使用SDB即时查找密码允许存储密码的引用，但不是密码本身。这使得在版本控制系统中存储引用敏感数据的文件变得更加安全。
- en: 'There is one supposed function that may be tempting to use SDB for: storing
    encrypted data on the Minion, which cannot be read by the Master. It is possible
    to run agents on a Minion that require local authentication, such as typing in
    a password from the Minion''s keyboard, or using a hardware encryption device.
    SDB modules can be made that make use of these agents, and due to their very nature,
    the authentication credentials themselves cannot be retrieved by the Master.'
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 有一种假设的功能可能会让人想要使用SDB：在Minion上存储加密数据，这些数据不能被Master读取。可以在Minion上运行需要本地认证的代理，例如从Minion的键盘输入密码，或者使用硬件加密设备。可以创建利用这些代理的SDB模块，由于它们的本质，认证凭证本身不能被Master获取。
- en: The problem is that the Master can access anything that a Minion that subscribes
    to it can. Although the data may be stored in an encrypted database on the Minion,
    and although its transfer to the Master is certainly encrypted, once it gets to
    the Master it can still be read in plaintext.
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 问题在于Master可以访问任何订阅它的Minion可以访问的内容。尽管数据可能存储在Minion上的加密数据库中，并且尽管其传输到Master时肯定被加密，但一旦到达Master，它仍然可以以明文形式读取。
- en: Getting SDB data
  id: totrans-103
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 获取SDB数据
- en: 'There are only two public functions that are used for SDB: `get` and `set`.
    And in truth, the only important one of these is `get`, since `set` can usually
    be done outside of Salt entirely. Let''s go ahead and take a look at `get`.'
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: SDB只使用了两个公共函数：`get`和`set`。实际上，其中最重要的一个是`get`，因为`set`通常可以在Salt之外完成。让我们先看看`get`函数。
- en: 'For our example, we''ll create a module that reads in a JSON file and then
    returns the requested key from it. First, let''s set up our JSON file:'
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 对于我们的示例，我们将创建一个模块，它读取JSON文件，然后从中返回请求的键。首先，让我们设置我们的JSON文件：
- en: '[PRE28]'
  id: totrans-106
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: 'Go ahead and save that file as `/root/mydata.json`. Then edit the `minion`
    configuration file and add a configuration profile:'
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 将该文件保存为`/root/mydata.json`。然后编辑`minion`配置文件并添加一个配置配置文件：
- en: '[PRE29]'
  id: totrans-108
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: 'With those two things in place, we''re ready to start writing our module. JSON
    has a very simple interface, so there won''t be much here:'
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 准备好这两样东西后，我们就可以开始编写我们的模块了。JSON有一个非常简单的接口，所以这里不会有太多内容：
- en: '[PRE30]'
  id: totrans-110
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: You've probably noticed that we've added a couple of extra things outside of
    the necessary JSON code. First, we imported something called `absolute_import`.
    This is because this file is called `json.py`, and it's importing another library
    called `json`. Without `absolute_import`, the file would try to import itself,
    and be unable to find the necessary functions from the actual `json` library.
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 你可能已经注意到，我们在必要的JSON代码之外添加了一些额外的东西。首先，我们导入了一个名为`absolute_import`的东西。这是因为这个文件叫做`json.py`，它正在导入另一个名为`json`的库。如果没有`absolute_import`，该文件将尝试导入自己，并且无法从实际的`json`库中找到必要的函数。
- en: 'The `get()` function takes two arguments: `key` and `profile`. `key` refers
    to the key that will be used to access the data that we need. `profile` is a copy
    of the profile data that we save in the `minion` configuration file as `myjson`.'
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: '`get()`函数接受两个参数：`key`和`profile`。`key`指的是将用于访问所需数据的键。`profile`是我们保存到`minion`配置文件中的`myjson`配置文件数据的副本。'
- en: 'The SDB URI makes use of these two items. When we build that URI, it will be
    formatted as:'
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: SDB URI使用了这两个项目。当我们构建该URI时，它将被格式化为：
- en: '[PRE31]'
  id: totrans-114
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: 'For instance, if we were to use the `sdb` execution module to retrieve the
    value of `key1`, our command would look like:'
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，如果我们使用`sdb`执行模块来检索`key1`的值，我们的命令将如下所示：
- en: '[PRE32]'
  id: totrans-116
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: 'With this module and profile in place, we can now add lines to the minion configuration
    (or to grains or pillars, or even the `master` configuration) that look like:'
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 在此模块和配置文件就绪的情况下，我们现在可以向 minion 配置文件（或 grains 或 pillars，甚至 `master` 配置文件）中添加类似以下内容的行：
- en: '[PRE33]'
  id: totrans-118
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: When a module that uses `config.get` comes across an SDB URI, it will automatically
    translate it on the fly to the appropriate data.
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 当一个使用 `config.get` 的模块遇到 SDB URI 时，它将自动即时将其转换为适当的数据。
- en: 'Before we move on, let''s update this function a little bit to do some error
    handling. If the user makes a typo in the profile (such as `json_fle` instead
    of `json_file`), or the file being referenced doesn''t exist, or the JSON isn''t
    formatted correctly, then this module will start spitting out trace back messages.
    Let''s go ahead and handle all of those, using Salt''s own `CommandExecutionError`:'
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们继续之前，让我们稍微更新一下这个函数，以便进行一些错误处理。如果用户在配置文件中输入了错误（例如 `json_fle` 而不是 `json_file`），或者引用的文件不存在，或者
    JSON 格式不正确，那么这个模块将开始输出跟踪回执消息。让我们继续处理所有这些问题，使用 Salt 的 `CommandExecutionError`：
- en: '[PRE34]'
  id: totrans-121
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: '`IOError` will catch problems with a path that doesn''t point to a real file.
    `KeyError` will catch errors with missing profile configuration (which would happen
    if one of the items was misspelled). `ValueError` will catch problems with an
    improperly formatted JSON file. This will turn errors like:'
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: '`IOError` 会捕获指向非实际文件的路径的问题。`KeyError` 会捕获缺少配置文件（如果其中一个项拼写错误）的错误。`ValueError`
    会捕获格式不正确的 JSON 文件的问题。这将使错误变成：'
- en: '[PRE35]'
  id: totrans-123
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: '...into errors like this:'
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: '...变成这样的错误：'
- en: '[PRE36]'
  id: totrans-125
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: Setting SDB data
  id: totrans-126
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 设置 SDB 数据
- en: 'The function that is used for `set` may look strange, because `set` is a Python
    built-in. That means that the function may not be called `set()`; it must be called
    something else, and then given an alias using the `__func_alias__` dictionary.
    Let''s go ahead and create a function that does nothing except return the `value`
    to be set:'
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 用于 `set` 的函数可能看起来很奇怪，因为 `set` 是 Python 的内置函数。这意味着该函数可能不被称为 `set()`；它必须被命名为其他名称，然后使用
    `__func_alias__` 字典给出别名。让我们继续创建一个除了返回要设置的 `value` 之外什么都不做的函数：
- en: '[PRE37]'
  id: totrans-128
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: This will be enough for your purposes with read-only data, but in our case,
    we're going to modify the JSON file. First, let's look at the arguments that are
    passed into our function.
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 对于只读数据，这对你来说已经足够了，但在这个案例中，我们将修改 JSON 文件。首先，让我们看看传递给我们的函数的参数。
- en: You already know that the key points to the data are to be referenced, and that
    profile contains a copy of the profile data from the Minion configuration file.
    And you can probably guess that value contains a copy of the data to be applied.
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 你已经知道，数据的关键点是要引用的，并且配置文件包含 Minion 配置文件中的配置数据副本。你可能也能猜到，值包含要应用的数据副本。
- en: 'The value doesn''t change the actual URI; that will always be the same, no
    matter whether you''re getting or setting data. The execution module itself is
    what accepts the data to be set, and then sets it. You can see that with:'
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 值不会改变实际的 URI；无论你是获取还是设置数据，它始终相同。执行模块本身接受要设置的数据，然后设置它。你可以通过以下方式看到这一点：
- en: '[PRE38]'
  id: totrans-132
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: 'With that in mind, let''s go ahead and make our module read in the JSON file,
    apply the new value, and then write it back out again. For now, we''ll skip error
    handling, to make it easier to read:'
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 考虑到这一点，让我们继续让我们的模块读取 JSON 文件，应用新值，然后再将其写回。目前，我们将跳过错误处理，以便更容易阅读：
- en: '[PRE39]'
  id: totrans-134
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: This function reads in the JSON file as before, then updates the specific value
    (creating it if necessary), then writes the file back out. When it's finished,
    it returns the data using the `get()` function, so that the user knows whether
    it was set properly. If it returns the wrong data, then the user will know that
    something went wrong. It won't necessarily tell them what went wrong, but it will
    raise a red flag.
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 这个函数与之前一样读取 JSON 文件，然后更新特定的值（如果需要则创建它），然后写回文件。完成时，它使用 `get()` 函数返回数据，这样用户就知道是否设置正确。如果返回错误的数据，那么用户就会知道出了问题。它不一定能告诉他们出了什么问题，但会拉响一个红旗。
- en: 'Let''s go ahead and add some error handling to help the user know what went
    wrong. We''ll go ahead and add in the error handling from the `get()` function
    too:'
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们继续添加一些错误处理来帮助用户了解出了什么问题。我们将继续添加来自 `get()` 函数的错误处理：
- en: '[PRE40]'
  id: totrans-137
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: 'Because we did all of that error handling when reading the file, by the time
    we get to writing it back again, we already know that the path is value, the JSON
    is valid, and there are no profile errors. However, there could still be errors
    in saving the file. Try the following:'
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 由于我们在读取文件时进行了所有错误处理，当我们再次写入时，我们已经知道路径是有效的，JSON是有效的，并且没有配置错误。然而，保存文件时仍然可能出错。尝试以下操作：
- en: '[PRE41]'
  id: totrans-139
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: 'We''ve changed the attribute of the file to make it immutable (read-only),
    and we can no longer write to the file. Without `IOError`, we would get an ugly
    trace back message just like before. Removing the immutable attribute will allow
    our function to run properly:'
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已将文件的属性更改为不可变（只读），因此我们不能再写入文件。如果没有`IOError`，我们就会得到一个像以前一样的难看的跟踪回信息。移除不可变属性将允许我们的函数正常运行：
- en: '[PRE42]'
  id: totrans-141
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: Using a descriptive docstring
  id: totrans-142
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用描述性的`docstring`
- en: With SDB modules, it is more important than ever to add a `docstring` that demonstrates
    how to configure and use the module. Without it, using the module is all but impossible
    for the user to figure out, and trying to modify a module is even worse.
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 使用SDB模块时，添加一个演示如何配置和使用模块的`docstring`比以往任何时候都更重要。没有它，用户几乎不可能弄清楚如何使用模块，尝试修改模块的情况甚至更糟。
- en: 'The `docstring` doesn''t need to be a novel. It should contain enough information
    to use the module, but not so much that figuring things out becomes confusing
    and frustrating. You should include not only an example of the profile data but
    also of an SDB URI to be used with this module:'
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: '`docstring`不需要是新颖的。它应该包含足够的信息来使用模块，但不要太多，以免弄清楚事情变得令人困惑和沮丧。你应该包括配置数据的示例，以及与该模块一起使用的SDB
    URI：'
- en: '[PRE43]'
  id: totrans-145
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: Using more complex configuration
  id: totrans-146
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用更复杂的配置
- en: 'It may be tempting to create SDB modules that make use of more complicated
    URIs. For instance, it is entirely possible to create a module that supports a
    URI such as:'
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 可能会诱使人们创建使用更复杂URI的SDB模块。例如，完全有可能创建一个支持如下URI的模块：
- en: '[PRE44]'
  id: totrans-148
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: 'With the preceding URI, the `key` that is passed in would be:'
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 使用前面的URI，传入的`key`将是：
- en: '[PRE45]'
  id: totrans-150
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: At that point, it would be up to you to parse out the key and translate it into
    something usable by your code. However, I strongly discourage it!
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 到那时，将取决于你解析出密钥并将其转换为代码可用的东西。然而，我强烈反对这样做！
- en: 'The more complex you make an SDB URI, the less it becomes a simple database
    lookup. You also risk exposing data in an unintended way. Look at the preceding
    `key` again. It reveals the following information about the database that holds
    the information that is supposed to be sensitive:'
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 你使SDB URI越复杂，它就越不像简单的数据库查找。你还可能以意想不到的方式暴露数据。再次看看前面的`key`。它揭示了以下关于存储敏感信息的数据库的信息：
- en: There is a field (abstracted or real) that is referred to as user. Since users
    tend to be lazier than they think, this is likely to point to a real database
    field called user. If that's true, then this exposes a portion of the database
    schema.
  id: totrans-153
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 存在一个被称为用户的字段（抽象的或真实的）。由于用户往往比他们想象的要懒惰，这很可能是指向一个名为user的真实数据库字段。如果是这样，那么这暴露了数据库模式的一部分。
- en: There is a group called ops. This means that there are other groups as well.
    Since *ops* typically refers to a team that performs server operations tasks,
    does that mean that there's a group called *dev* too? And if the dev group is
    compromised, what juicy pieces of data do they have for an attacker to steal?
  id: totrans-154
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 有一个名为ops的组。这意味着还有其他组。由于*ops*通常指的是执行服务器操作任务的团队，那么这意味着还有一个名为*dev*的组吗？如果dev组被攻破，攻击者能窃取到哪些有价值的资料？
- en: 'A day was specified. Does this company rotate passwords on a daily basis? The
    fact that *monday* was specified implies that there are no more than seven passwords:
    one for each day of the week.'
  id: totrans-155
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 指定了一天。这家公司是否每天轮换密码？指定*monday*的事实意味着最多只有七个密码：一周中每一天一个。
- en: 'Rather than putting all of this information into the URL, it is generally better
    to hide it inside the profile. It''s probably safe to assume that `mydb` refers
    to a database connection (if we called the profile `mysql`, we would be exposing
    what kind of database connection). Skipping over any database credentials that
    would be present, we could use a profile that looks like:'
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 与其将所有这些信息放入URL中，通常更好的做法是将它们隐藏在配置文件中。可以假设`mydb`指的是一个数据库连接（如果我们把配置文件命名为`mysql`，我们就会暴露数据库连接的类型）。跳过任何可能存在的数据库凭证，我们可以使用如下配置文件：
- en: '[PRE46]'
  id: totrans-157
  prefs: []
  type: TYPE_PRE
  zh: '[PRE46]'
- en: 'Assuming that the module in question is able to translate those `field`s into
    a query, and internally change `sdbkey` to whatever actual `key` was passed in,
    we could use a URI that looks like:'
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 假设相关的模块能够将这些`field`s转换成查询，并在内部将`sdbkey`更改为实际传入的任何`key`，我们可以使用如下看起来像的URI：
- en: '[PRE47]'
  id: totrans-159
  prefs: []
  type: TYPE_PRE
  zh: '[PRE47]'
- en: 'You can still guess that `curly` refers to a username, which is probably even
    more obvious when the URI is used with a configuration argument like:'
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 你仍然可以猜测`curly`指的是用户名，当URI与配置参数如一起使用时，这可能是更加明显的：
- en: '[PRE48]'
  id: totrans-161
  prefs: []
  type: TYPE_PRE
  zh: '[PRE48]'
- en: However, it doesn't expose the name of the field in the database.
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，它并没有暴露数据库中的字段名称。
- en: The final SDB module
  id: totrans-163
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 最终的SDB模块
- en: 'With all of the code we''ve put together, the resulting module should look
    like the following:'
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们编写的所有代码中，生成的模块应该看起来像以下这样：
- en: '[PRE49]'
  id: totrans-165
  prefs: []
  type: TYPE_PRE
  zh: '[PRE49]'
- en: Using SDB modules
  id: totrans-166
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用SDB模块
- en: 'There are a number of places where SDB modules can be used. Because SDB retrieval
    is built into the `config.get` function in the `config` execution module, the
    following locations can be used to set a value for a Minion:'
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 有许多地方可以使用SDB模块。因为SDB检索被集成在`config`执行模块中的`config.get`函数中，以下位置可以用来为Minion设置一个值：
- en: Minion configuration file
  id: totrans-168
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Minion配置文件
- en: Grains
  id: totrans-169
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 粒子
- en: Pillars
  id: totrans-170
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 柱子
- en: Master configuration file
  id: totrans-171
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 主配置文件
- en: 'SDB is also supported by Salt Cloud, so you can also set SDB URIs in:'
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: SDB也由Salt Cloud支持，因此你还可以在以下位置设置SDB URI：
- en: The main cloud configuration file
  id: totrans-173
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 主要云配置文件
- en: Cloud profiles
  id: totrans-174
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 云配置文件
- en: Cloud providers
  id: totrans-175
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 云提供商
- en: Cloud maps
  id: totrans-176
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 云映射
- en: 'Regardless of where you set an SDB URI, the format is the same:'
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 无论你在哪里设置SDB URI，格式都是相同的：
- en: '[PRE50]'
  id: totrans-178
  prefs: []
  type: TYPE_PRE
  zh: '[PRE50]'
- en: This can be particularly useful with cloud providers, all of which require credentials,
    but many of which also use more complex configuration blocks that should be checked
    into revision control.
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: 这对于云提供商特别有用，所有这些都需要凭证，但其中许多也使用更复杂的配置块，这些配置块应该被纳入版本控制。
- en: 'Take, for example, the `openstack` Cloud provider:'
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: 以`openstack`云提供商为例：
- en: '[PRE51]'
  id: totrans-181
  prefs: []
  type: TYPE_PRE
  zh: '[PRE51]'
- en: In this organization, `compute_region` and `compute_name` are probably public.
    And `identity_url` certainly is (else, how would you authenticate?). But the other
    information should probably be kept hidden.
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个组织中，`compute_region`和`compute_name`可能是公开的。而`identity_url`肯定也是（否则，你怎么进行认证呢？）。但其他信息可能应该保持隐藏。
- en: If you've ever set up OpenStack in Salt Cloud, you've probably used a number
    of other arguments as well, many of which are probably not sensitive. However,
    a complex configuration file should probably be kept in a revision control system.
    With SDB URIs, you can do so without having to worry about exposing the data that
    is sensitive.
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你曾经在使用Salt Cloud设置OpenStack，你可能已经使用了许多其他参数，其中许多可能不是敏感的。然而，一个复杂的配置文件可能应该保存在版本控制系统。使用SDB
    URI，你可以这样做而不必担心暴露敏感数据。
- en: Troubleshooting SDB modules
  id: totrans-184
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: SDB模块故障排除
- en: We've already covered some error handling that can be added to our SDB modules,
    but you may still encounter problems. Like grains and pillars, the most common
    involve data not showing up when expected.
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经介绍了一些可以添加到我们的SDB模块中的错误处理，但你可能仍然会遇到问题。像粒子和柱子一样，最常见的问题是在预期中数据没有显示出来。
- en: SDB data not showing up
  id: totrans-186
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: SDB数据未显示
- en: You may find that when you include an SDB URI in your configuration, it doesn't
    resolve as you think it might. If you've made typos in the earlier SDB code, you
    have probably already figured out that `sdb.get` is more than happy to raise trace
    backs when there are syntactical errors. But if using `salt-call` on `sdb.get`
    doesn't raise any errors that you can see, then it may not be a problem in your
    code.
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: 你可能会发现，当你将SDB URI包含在配置中时，它并没有像你想象的那样解析。如果你在早期的SDB代码中犯了拼写错误，你可能已经发现`sdb.get`在存在语法错误时会非常乐意抛出跟踪回溯。但如果使用`salt-call`在`sdb.get`上没有引发你可以看到的任何错误，那么可能不是你的代码中的问题。
- en: 'Before you start to blame other services, it''s best to make sure that you''re
    not to blame. Start logging key pieces of information, to make sure it''s showing
    up as you expect. Make sure to add the following lines toward the top of your
    module:'
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: 在开始责怪其他服务之前，最好确保你不是问题所在。开始记录关键信息，以确保它以你期望的方式显示。确保在模块顶部添加以下行：
- en: '[PRE52]'
  id: totrans-189
  prefs: []
  type: TYPE_PRE
  zh: '[PRE52]'
- en: Then you can use `log.debug()` to log those pieces of information. If you're
    logging sensitive pieces of information, you may want to use `log.trace()` instead,
    just in case you forget to take the log messages out.
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，你可以使用`log.debug()`来记录这些信息。如果你正在记录敏感信息，你可能想使用`log.trace()`代替，以防你忘记取出日志消息。
- en: 'You may want to start with logging the information coming into each function,
    to make sure it looks like you expect. Let''s go ahead and take a look at our
    `get()` example from earlier, with some logging added in:'
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE53]'
  id: totrans-192
  prefs: []
  type: TYPE_PRE
  zh: '[PRE53]'
- en: We've only added a couple of log lines here, but we used Python's `pprint` library
    to format one of them. The `pprint.pformat()` function formats text that is meant
    to be stored in a string or passed to a function, instead of just dumping it to
    `STDOUT` like `pprint.pprint()` does.
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
- en: If your SDB module connects to a service, you may discover that the service
    itself is unavailable. This may be due to unknown or unintended firewall rules,
    a network error, or actual downtime on the service itself. Scattering log messages
    throughout your code will help you discover where it is falling down, so that
    you can address it there.
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  id: totrans-195
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The three areas of Salt configuration that can be hooked into using the loader
    system are dynamic grains, external pillars, and SDB. Grains are generated on
    the Minion, pillars are generated on the Master, and SDB URIs can be configured
    in either place.
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
- en: SDB modules allow configuration to be stored outside, but referenced from, the
    various parts of the Salt configuration. When accessed from execution modules,
    they are resolved on the Minion. When accessed from Salt-Cloud, they are resolved
    on whichever system is running Salt Cloud.
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
- en: Now that we have configuration out of the way, it's time to dive into configuration
    management, by wrapping state modules around execution modules.
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
