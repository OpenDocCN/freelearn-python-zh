["```py\nk = 10 \ndef foo():\n    print(k)\n```", "```py\n>>> import importlib\n>>> import new\n>>> from new import foo\n>>> import sys\n>>> foo()\n10\n>>> new.foo()\n10\n>>> foo.__globals__ is sys.modules['new'].__dict__ # dictionary used by namespace and function attribute __globals__ is indeed same\nTrue\n>>> foo.__globals__['k'] = 20  # changing global namespace dictionary\n>>> new.do   #attribute is not defined in the module\nTraceback (most recent call last):\n  File \"<stdin>\", line 1, in <module>\nAttributeError: module 'new' has no attribute 'do'\n>>> foo.__globals__['do'] = 22 #we are attaching attribute to module from outside the module\n>>> new.do\n22\n>>> foo()  # we get updated value for global variable\n20\n>>> new.foo()\n20\n>>> importlib.reload(new) #reload repopulates old modules dictionary\n<module 'new' from '/tmp/new.py'>\n>>> new.do #it didn't got updated as it was populated from outside.\n22\n>>> new.foo() #variables updated by execution of code in module are updated\n10\n>>>\n```", "```py\n>>> #variable in enclosing scope can be referenced any level deep\n... \n>>> def f1():\n...     v1 = \"ohm\"\n...     def f2():\n...         print(\"f2\",v1)\n...         def f3():\n...             print(\"f3\",v1)\n...         f3()\n...     f2()\n... \n>>> f1()\nf2 ohm\nf3 ohm\n>>> \n>>> #variable can be made non-local (variable in outer scopes) skipping one level of enclosing scope\n... \n>>> def f1():\n...     v1 = \"ohm\"\n...     def f2():\n...         print(\"f2\",v1)\n...         def f3():\n...             nonlocal v1\n...             v1 = \"mho\"\n...             print(\"f3\",v1)\n...         f3()\n...         print(\"f2\",v1)\n...     f2()\n...     print(\"f1\",v1)\n... \n>>> f1()\nf2 ohm\nf3 mho\nf2 mho\nf1 mho\n>>> \n>>> \n>>> #global can be specified at any level of enclosed function\n... \n>>> v2 = \"joule\"\n>>> \n>>> def f1():\n...     def f2():\n...         def f3():\n...             global v2\n...             v2 = \"mho\"\n...             print(\"f3\",v2)\n...         f3()\n...         print(\"f2\",v2)\n...     f2()\n...     print(\"f1\",v2)\n... \n>>> f1()\nf3 mho\nf2 mho\nf1 mho\n```", "```py\nIn [6]: def fun():\n   ...:     localsum = sum\n   ...:     return localsum(localsum((a,a+1)) for a in range(1000))\n   ...: \n\nIn [8]: def fun2():\n   ...:     return sum(sum((a,a+1)) for a in range(1000))\n   ...: \n\nIn [9]: %timeit fun2()\n1000 loops, best of 3: 1.07 ms per loop\n\nIn [11]: %timeit fun()\n1000 loops, best of 3: 983 Âµs per loop\n```", "```py\n>>> def getformatter(start,end):\n...     def formatter(istr):\n...         print(\"%s%s%s\"%(start,istr,end))\n...     return formatter\n... \n>>> formatter1 = getformatter(\"<\",\">\")\n>>> formatter2 = getformatter(\"[\",\"]\")\n>>> \n>>> formatter1(\"hello\")\n<hello>\n>>> formatter2(\"hello\")\n[hello]\n>>> formatter1.__closure__[0].cell_contents\n'>'\n>>> formatter1.__closure__[1].cell_contents\n'<'\n```", "```py\n>>> def formatter(st,en):\n...     def fmt(inp):\n...             return \"%s%s%s\"%(st,inp,en)\n...     return fmt\n... \n>>> fmt1 = formatter(\"<\",\">\")\n>>> fmt1(\"hello\")\n'<hello>'\n>>> timeit.timeit(stmt=\"fmt1('hello')\",\n... number=1000000,globals={'fmt1':fmt1})\n0.3326794120075647\n>>> class Formatter:\n...     def __init__(self,st,en):\n...             self.st = st\n...             self.en = en\n...     def __call__(self, inp):\n...             return \"%s%s%s\"%(self.st,inp,self.en)\n... \n>>> fmt2 = Formatter(\"<\",\">\")\n>>> fmt2(\"hello\")\n'<hello>'\n>>> timeit.timeit(stmt=\"fmt2('hello')\",\n... number=1000000,globals={'fmt2':fmt2})\n0.5502702980011236\n```", "```py\n>>> import functools\n>>> \n>>> def foo(*args,**kwargs):\n...     print(\"foo with\",args,kwargs)    \n... \n>>> pfoo = functools.partial(foo,10,20,v1=23)\n>>> \n>>> foo(1,2,3,array=1)\nfoo with (1, 2, 3) {'array': 1}\n>>> pfoo()\nfoo with (10, 20) {'v1': 23}\n>>> pfoo(30,40,array=12)\nfoo with (10, 20, 30, 40) {'v1': 23, 'array': 12}\n```", "```py\nimport os\nimport sys\n\nclass Spec:\n    def __init__(self,name,loader,file='None',path=None,\n                 cached=None,parent=None,has_location=False):\n        self.name = name\n        self.loader = loader\n        self.origin = file\n        self.submodule_search_locations = path\n        self.cached = cached\n        self.has_location = has_location\n\nclass Finder:\n    def __init__(self, path):\n        self.path = path\n\n    def find_spec(self,name,path,target):\n        print(\"find spec name:%s path:%s target:%s\"%(name,path,target))\n        return Spec(name,self,path)\n\n    def load_module(self, fullname):\n        print(\"loading module\",fullname)\n        if fullname+'.py' in os.listdir(self.path):\n            import builtins\n            mod = type(os)\n            modobject = mod(fullname)\n            modobject.__builtins__ = builtins\n            def foo():\n                print(\"hii i am foo\")\n            modobject.__dict__['too'] = foo\n            sys.modules[fullname] = modobject\n            modobject.__spec__ = 'asdfasfsadfsd'\n            modobject.__name__ = fullname\n            modobject.__file__ = 'aruns file'\n            return modobject\n\nsys.meta_path.append(Finder(r'/tmp'))\nimport notes\nnotes.too()\n\nOutput:\nfind spec name:notes path:None target:None\nloading module notes\nhii i am foo\n```", "```py\n__all__ = ('hulk','k')\n\nk = 10\ndef hulk():\n    print(\"i am hulk\")\n\ndef spidey():\n    print(\"i am spidey\")\n```", "```py\n>>> from mymod import *\n>>> \n>>> hulk()\ni am hulk\n>>> k\n10\n>>> spidey()\nTraceback (most recent call last):\n  File \"<stdin>\", line 1, in <module>\nNameError: name 'spidey' is not defined\n```", "```py\n>>> class GrandParent:\n...     def do(self,):\n...         print(\"Grandparent do called\")\n...\n>>> class Father(GrandParent):\n...     def do(self,):\n...         print(\"Father do called\")\n...\n>>> class Mother(GrandParent):\n...     def do(self,):\n...         print(\"Mother do called\")\n...\n>>> class Child(Father, Mother):\n...     def do(self,):\n...         print(\"Child do called\")\n...\n>>> c = Child() # calls method in Class\n>>> c.do()\nChild do called\n>>> del Child.do # if method is not defined it is searched in bases\n>>> c.do()  #Father's method\nFather do called\n>>> c.__class__.__bases__ =  (c.__class__.__bases__[1],c.__class__.__bases__[0]) #we swap bases order\n>>> c.do() #Mothers's method\nMother do called\n>>> del Mother.do\n>>> c.do() #Fathers' method\nFather do called\n>>> del Father.do\n>>> c.do()\nGrandparent do called\n```", "```py\n>>> class GrandParent:\n...     def do(self,):\n...         print(\"Grandparent do called\")\n...\n>>> class Father(GrandParent):\n...     def do(self,):\n...         print(\"Father do called\")\n...\n>>> class Mother(GrandParent):\n...     def do(self,):\n...         print(\"Mother do called\")\n...\n>>> class Child(Father, Mother):\n...     def do(self,):\n...         print(\"Child do called\")\n...\n>>> c = Child()\n>>> c.do()\nChild do called\n>>> class Child(Father, Mother):\n...     def do(self,):\n...         print(\"Child do called\")\n...         super().do()\n...\n>>> c = Child()\n>>> c.do()\nChild do called\nFather do called\n>>> print(\"Father and child super calling\")\nFather and child super calling\n>>> class Father(GrandParent):\n...     def do(self,):\n...         print(\"Father do called\")\n...         super().do()\n...\n>>> class Child(Father, Mother):\n...     def do(self,):\n...         print(\"Child do called\")\n...         super().do()\n...\n>>> c = Child()\n>>> c.do()\nChild do called\nFather do called\nMother do called\n>>> print(\"Father and Mother super calling\")\nFather and Mother super calling\n>>> class Mother(GrandParent):\n...     def do(self,):\n...         print(\"Mother do called\")\n...         super().do()\n...\n>>> class Father(GrandParent):\n...     def do(self,):\n...         print(\"Father do called\")\n...         super().do()\n...\n>>> class Child(Father, Mother):\n...     def do(self,):\n...         print(\"Child do called\")\n...         super().do()\n...\n>>> c = Child()\n>>> c.do()\nChild do called\nFather do called\nMother do called\nGrandparent do called\n>>> print(Child.__mro__)\n(<class '__main__.Child'>, <class '__main__.Father'>, <class '__main__.Mother'>, <class '__main__.GrandParent'>, <class 'object'>)\n```", "```py\n>>> class BooksIterState:\n...     def __init__(self, books):\n...             self.books = books\n...             self.index = 0\n...     def __next__(self,):\n...             if self.index >= len(self.books._data):\n...                     raise StopIteration\n...             else:\n...                     tmp = self.books._data[self.index]\n...                     self.index += 1\n...                     return tmp\n... \n>>> class Books:\n...     def __init__(self, data):\n...             self._data = data\n...     def __iter__(self,):\n...             return BooksIterState(self)\n... \n>>> ii = iter(Books([\"don quixote\",\"lord of the flies\",\"great expectations\"]))\n>>> next(ii)\n'don quixote'\n>>> for i in Books([\"don quixote\",\"lord of the flies\",\"great expectations\"]):\n...     print(i)\n... \ndon quixote\nlord of the flies\ngreat expectations\n>>> next(ii)\n'lord of the flies'\n>>> next(ii)\n'great expectations'\n>>> next(ii)\nTraceback (most recent call last):\n  File \"<stdin>\", line 1, in <module>\n  File \"<stdin>\", line 7, in __next__\nStopIteration\n>>> \n```", "```py\n>>> class Ctx:\n...     def __enter__(*args):\n...         print(\"entering\")\n...         return \"do some work\"\n...     def __exit__(self, exception_type,\n...                  exception_value,\n...                  exception_traceback):\n...         print(\"exit\")\n...         if exception_type is not None:\n...             print(\"error\",exception_type)\n...         return True\n... \n>>> with Ctx() as k:\n...     print(k)\n...     raise KeyError\n... \nentering\ndo some work\nexit\nerror <class 'KeyError'>\n```", "```py\n>>> import contextlib\n>>> @contextlib.contextmanager\n... def ctx():\n...     try:\n...         print(\"start\")\n...         yield \"so some work\"\n...     except KeyError:\n...         print(\"error\")\n...     print(\"done\")\n... \n>>> with ctx() as k:\n...     print(k)\n...     raise KeyError\n... \nstart\nso some work\nerror\ndone\n```", "```py\n>>> from abc import ABCMeta, abstractmethod\n>>> class Worker(metaclass=ABCMeta):\n...     @abstractmethod\n...     def do(self, func, args, kwargs):\n...         \"\"\" work on function \"\"\"\n...     @abstractmethod\n...     def is_busy(self,):\n...         \"\"\" tell if busy \"\"\"\n...\n>>> class ApiWorker(Worker):\n...     def __init__(self,):\n...         self._busy = False\n...     def do(self, func, args=[], kwargs={}):\n...         self._busy = True\n...         res = func(*args, **kwargs)\n...         self._busy = False\n...         return res\n...     def is_busy(self,):\n...         return self._busy\n...\n>>> apiworker = ApiWorker()\n>>> print(apiworker.do(lambda x: x + 1, (1,)))\n2\n>>> print(apiworker.is_busy())\nFalse\n```"]