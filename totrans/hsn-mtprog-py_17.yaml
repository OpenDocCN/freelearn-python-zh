- en: '*Chapter 14*: Generating Code from AST'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we will learn how to use ASTs in Python to generate code for
    various applications. We will apply these abstract syntax trees to metaprogramming
    to implement automatic code generated in this chapter.
  prefs: []
  type: TYPE_NORMAL
- en: Automatic code generation is one way of making the life of a programmer easier.
    An abstract syntax tree is an excellent functionality that can help us generate
    code in a much simpler way.
  prefs: []
  type: TYPE_NORMAL
- en: The concept of AST is discussed with examples in [*Chapter 9*](B13426_09_Final_PG_epub.xhtml#_idTextAnchor124)
    of this book. In this chapter, we will be tapping the advantages of ASTs to generate
    code automatically. Code generation can be implemented to enable no-code or limited
    coding while developing applications. In this chapter, we will continue to use
    the example of *ABC Megamart* to generate code from ASTs.
  prefs: []
  type: TYPE_NORMAL
- en: 'In this chapter, we will be looking at the following main topics:'
  prefs: []
  type: TYPE_NORMAL
- en: Generating a simple class with a template
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Generating multiple classes from a list
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Generating a class with attributes
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Generating a class with methods
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Defining a custom class factory
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Developing a code generator to generate a simple library
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: By the end of this chapter, you should be able to understand how to use the
    existing methods of the `ast` library in Python to enable your application to
    generate its own code, how to avoid repeating yourself, and how to generate code
    dynamically.
  prefs: []
  type: TYPE_NORMAL
- en: Technical requirements
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The code examples shared in this chapter are available on GitHub under the
    code for this chapter here: [https://github.com/PacktPublishing/Metaprogramming-with-Python/tree/main/Chapter14](https://github.com/PacktPublishing/Metaprogramming-with-Python/tree/main/Chapter14).'
  prefs: []
  type: TYPE_NORMAL
- en: Generating a simple class with a template
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this section, we will be looking at how to generate code for a class without
    actually defining the class itself. We will be creating a string-based template
    with the structure of a class we want to develop but not the actual code that
    can be executed. To explain this further, let us look at an example where we will
    generate a class named `VegCounter` by parsing a series of strings using the `ast`
    module.
  prefs: []
  type: TYPE_NORMAL
- en: 'The sequence of steps to be followed to generate code for a class is represented
    in the following flow diagram:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 14.1 – A code generation sequence for a simple class ](img/Figure_14.1_B13426.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 14.1 – A code generation sequence for a simple class
  prefs: []
  type: TYPE_NORMAL
- en: 'Let us look at the implementation of this example:'
  prefs: []
  type: TYPE_NORMAL
- en: 'We will start by importing the `ast` library:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Let us now create a variable to pass the class name with which the code needs
    to be generated:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'We will next define a variable that becomes the template for the class generated
    in this example:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'In the next step, we will parse the class template with the parse method in
    the `ast` module:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'The output of the preceding code displays the abstract syntax tree of the class
    template:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'The preceding tree can be compiled and executed as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Thus, this leads to the following output:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: 'In the next step, we will unparse the tree to generate the actual code for
    the class:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Executing the preceding code leads to the following output:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: 'In the next step, let us write the preceding class code to a file named `classtemplate.py`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'The `classtemplate` file looks as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![Figure 14.2 – The classtemplate.py file ](img/Figure_14.2_B13426.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 14.2 – The classtemplate.py file
  prefs: []
  type: TYPE_NORMAL
- en: 'Let us now import the `classtemplate` and create an object:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'The output is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: In this section, we have generated a simple class code using the `ast` module.
    This example helps us in understanding the steps to be followed to generate code
    for a custom class since it is easier to start understanding code generation by
    starting simple. With this understanding, let us generate code for multiple classes.
  prefs: []
  type: TYPE_NORMAL
- en: Generating multiple classes from a list
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this section, we will look at generating code for multiple classes dynamically
    using the `ast` module and its `unparse` method.
  prefs: []
  type: TYPE_NORMAL
- en: Generating the code for more than one class dynamically gives us a direction
    for implementing code generation for multiple functionalities of an application.
    The classes need not be for the same functionality and the class code thus generated
    can later be modified to include additional methods or attributes as required
    by the application. The skeletal class code will be generated through this example.
  prefs: []
  type: TYPE_NORMAL
- en: To understand this further, we will follow the sequence described in the following
    flow diagram.
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 14.3 – A code generation sequence for multiple classes ](img/Figure_14.3_B13426.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 14.3 – A code generation sequence for multiple classes
  prefs: []
  type: TYPE_NORMAL
- en: 'Let us now look at how to implement this scenario:'
  prefs: []
  type: TYPE_NORMAL
- en: 'We will first define a variable that can be assigned a list of class names
    as values:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'In the next step, let us look at generating class templates for each of the
    class names from the preceding list:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'The class templates are added to another list named `classgenerator`, and the
    list is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: 'To parse the string templates from the preceding output and generate their
    abstract syntax trees, let us create another list named `classtrees` and store
    the trees:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'The parsed class trees that are assigned to the `classtrees` list variable
    are displayed as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: 'In this step, we will review one of the trees to ensure that the abstract syntax
    tree is generated for the class as expected:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'The output is generated as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: 'We can further unparse the `classtrees` variable to generate the code for each
    class:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'An example output looks as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: 'Let us further write all the generated classes into a file:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'The generated `classtemplates.py` file looks as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 14.4 – The classtemplates.py file ](img/Figure_14.4_B13426.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 14.4 – The classtemplates.py file
  prefs: []
  type: TYPE_NORMAL
- en: 'Let us import the file and call an instance of each class to check if it works:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'The output of the preceding code is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: In this section, we have generated code for multiple classes using the `ast`
    module. This example is the next step toward working on automatic code generation
    for multiple functionalities or modules of an application.
  prefs: []
  type: TYPE_NORMAL
- en: Generating a class with attributes
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In this section, we will generate code for a class, along with a list of attributes,
    that will also be included dynamically in the class. Generating code for a class
    alone can give the initial skeletal structure for a module, whereas we need to
    add attributes if we want to make the class more specific. The following flow
    diagram represents the sequence of steps to be followed for this example:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 14.5 – A code generation sequence for a class with multiple attributes
    ](img/Figure_14.5_B13426.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 14.5 – A code generation sequence for a class with multiple attributes
  prefs: []
  type: TYPE_NORMAL
- en: 'Let us look at the code for this example:'
  prefs: []
  type: TYPE_NORMAL
- en: 'We will first define a variable to provide `classname` as input, followed by
    a `classtemplate` to create the template of the class declaration:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'In the next step, let us define another variable to provide attribute names
    as input:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Let us further update `classtemplate` by providing each of the preceding attributes
    that are required to generate the class code:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Let us now parse the `classtemplate` and review the abstract syntax tree:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'The syntax tree for the preceding class template looks as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: All three variables – `items`, `countername`, and `billamount` added into the
    class template – are now part of the syntax tree. If we review the tree in detail,
    we can look at these variables under `body` | `assign` | `targets` | `name` |
    `id`.
  prefs: []
  type: TYPE_NORMAL
- en: 'We can further unparse the tree and look at the code of the class:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'The output looks as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: 'Let us write the code to a file and import it:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: 'The generated code looks as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 14.6 –The classtemplateattr.py file ](img/Figure_14.6_B13426.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 14.6 –The classtemplateattr.py file
  prefs: []
  type: TYPE_NORMAL
- en: 'We can import the `classtemplateattr.py` file and the class can be accessed
    as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: 'The output is displayed as follows, with all the attributes and their corresponding
    values assigned:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: In this section, we have generated a class with multiple attributes without
    writing the code for the class. Instead, we have defined a template that takes
    in a class name and a list of attributes as input. With this understanding, we
    can look at generating a class with methods.
  prefs: []
  type: TYPE_NORMAL
- en: Generating a class with methods
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In this section, let us generate code for a class and its methods. Throughout
    this chapter, our goal is to generate code dynamically for building applications
    that can solve a specific purpose. Adding methods along with attributes makes
    the code generation for a class even more application-specific. We can look at
    two variations of this example:'
  prefs: []
  type: TYPE_NORMAL
- en: Generating a class with an `init` method
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Generating a class with a user-defined method
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Let’s discuss each in detail.
  prefs: []
  type: TYPE_NORMAL
- en: Generating a class with an init method
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'In this example, let us generate code for a class and add an `init` method
    to the class and also initialize attributes. In this example, we will define a
    class for the vegetable counter of *ABC Megamart*. In the `init` method, let us
    initialize cart items from the vegetable counter of *ABC Megamart* in this class:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE35]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE36]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE37]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE38]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE39]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE40]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE41]'
  prefs: []
  type: TYPE_PRE
- en: 'The parsed class template generates the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE42]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE43]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE44]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE45]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE46]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE47]'
  prefs: []
  type: TYPE_PRE
- en: 'The abstract syntax tree for this class is generated with the function definition,
    as represented in the following figure:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 14.7 – The function definition of the init method ](img/Figure_14.7_B13426.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 14.7 – The function definition of the init method
  prefs: []
  type: TYPE_NORMAL
- en: With this understanding, let us look at one more example of this same class
    by generating code for a user-defined method.
  prefs: []
  type: TYPE_NORMAL
- en: Generating a class with a user-defined method
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'In this section, let us look at a variation of the class by creating a template
    that generates a user-defined method for the class:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE48]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE49]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE50]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE51]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE52]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE53]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE54]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE55]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE56]'
  prefs: []
  type: TYPE_PRE
- en: 'The parsed `classtemplate` generates the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE57]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE58]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE59]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE60]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE61]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE62]'
  prefs: []
  type: TYPE_PRE
- en: 'The abstract syntax tree for this class is generated with the function definition,
    as represented in the following figure:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 14.8 – The function definition of the user-defined method ](img/Figure_14.8_B13426.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 14.8 – The function definition of the user-defined method
  prefs: []
  type: TYPE_NORMAL
- en: We can either use the `init` method when we want to initialize the cart items
    at the class level or use the attributes later. By contrast, the user-defined
    method can be used if we want to keep the attributes specific to the method and
    perform actions based on the attributes within the method.
  prefs: []
  type: TYPE_NORMAL
- en: With this understanding, let us look at defining a custom class factory.
  prefs: []
  type: TYPE_NORMAL
- en: Defining a custom class factory
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In this section, let us define a function named `classgenerator` that generates
    a custom class, attribute, and method using a class template as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE63]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE64]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE65]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE66]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE67]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE68]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE69]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE70]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE71]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE72]'
  prefs: []
  type: TYPE_PRE
- en: In this section, we are making the code generation more dynamic by creating
    a function that can generate code with custom values for the class name, attribute
    name, and method name, respectively. This helps in creating custom code for multiple
    functionalities in an application.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let us provide a custom class name, attribute name, and method name as input
    to the preceding function:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE73]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE74]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE75]'
  prefs: []
  type: TYPE_PRE
- en: 'The generated class code is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE76]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE77]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE78]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE79]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE80]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE81]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE82]'
  prefs: []
  type: TYPE_PRE
- en: We can expand this example further by developing a code generator library in
    the following section.
  prefs: []
  type: TYPE_NORMAL
- en: Developing a code generator to generate a simple library
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In this section, let us develop a simple code generator that generates code
    for a class with `get`, `set`, and `delete` properties for its custom attributes.
    The purpose of this section is to generate a complete library through automatic
    code generation. To fulfill this, let us write the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Let us define the code generator as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE83]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Let us further define the method to define the class template in the code generator
    as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE84]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'We will now save the preceding code into a file named `codegenerator.py` and
    import the file as a library:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE85]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Let us define a dictionary object and assign multiple class names and their
    corresponding attribute names as input:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE86]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Let us further define a function named `generatelib` and add `classes` as input
    parameters. This function takes in the class names and their attribute names as
    input and generates the code from the class templates of the `codegenerator` library:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE87]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'In this step, let us write the generated code into a file to generate a custom
    library that can be used further:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE88]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'The generated code is in the following format for each input class:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE89]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'We can further import the generated library and define objects as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE90]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'The preceding code returns the following output:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE91]'
  prefs: []
  type: TYPE_PRE
- en: These are various examples of code generation that can be implemented using
    Python’s metaprogramming `ast` module.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we have looked at various examples to generate code for a custom
    class and a class with custom attributes. We have also covered examples of generating
    code for a custom class with methods and attributes. Finally, we have developed
    a code generator that can be used to develop a custom library using the concept
    of abstract syntax trees in Python.
  prefs: []
  type: TYPE_NORMAL
- en: Overall, we have seen various scenarios that can help us utilize the abstract
    syntax tree within Python’s `ast` module and generate dynamic code using Python
    metaprogramming.
  prefs: []
  type: TYPE_NORMAL
- en: In the next chapter, we will be discussing a case study to which we can apply
    all the concepts of metaprogramming that we have covered so far in the book.
  prefs: []
  type: TYPE_NORMAL
