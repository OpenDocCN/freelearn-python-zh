<html><head></head><body>
  <div id="_idContainer045">
    <h1 class="chapterNumber">3</h1>
    <h1 id="_idParaDest-56" class="chapterTitle">General Traits of Good Code</h1>
    <p class="normal">This is a book about software construction with Python. Good software is built from a good design. By saying things such as clean code, you may be thinking that we will explore good practices that relate only to the implementation details of the software, instead of its design. However, this assumption would be wrong since the code is not something different from the design—the code <em class="italic">is</em> the design.</p>
    <p class="normal">The code is probably the most detailed representation of the design. In the first two chapters, we discussed why structuring the code in a consistent way was important, and we have seen idioms for writing more compact and idiomatic code. Now it's time to understand that clean code is that, and much more—the ultimate goal is to make the code as robust as possible, and to write it in a way that minimizes defects or makes them utterly evident, should they occur.</p>
    <p class="normal">This chapter, and the one following, is focused on design principles at a higher level of abstraction. I will present the general principles of software engineering that are applied in Python.</p>
    <p class="normal">In particular, for this chapter, we will review different principles that make for good software design. Good quality software should be built around these ideas, and they will serve as design tools. That does not mean that all of them should always be applied; in fact, some of them represent different points of view (such is the case with the <strong class="keyword">Design by Contract</strong> (<strong class="keyword">DbC</strong>) approach, as opposed to defensive programming). Some of them depend on the context and are not always applicable.</p>
    <p class="normal">High-quality code is a concept that has multiple dimensions. We can think of this similarly to how we think about the quality attributes of a software architecture. For example, we want our software to be secure and to have good performance, reliability, and maintainability, to name just a few attributes.</p>
    <p class="normal">The goals of this chapter are as follows:</p>
    <ul>
      <li class="bullet">To understand the concepts behind robust software</li>
      <li class="bullet">To learn how to deal with erroneous data during the workflow of the application</li>
      <li class="bullet">To design maintainable software that can easily be extended and adapted to new requirements</li>
      <li class="bullet">To design reusable software</li>
      <li class="bullet">To write effective code that will keep the productivity of the development team high</li>
    </ul>
    <h1 id="_idParaDest-57" class="title">Design by contract</h1>
    <p class="normal">Some parts of the software we are working on are not meant to be called directly by users, but instead by other parts of the code. Such is the case when we divide the responsibilities of the application into different components or layers, and we have to think about the interaction between them.</p>
    <p class="normal">We have to encapsulate some functionality behind each component and expose an interface to clients who are going to use that <a id="_idIndexMarker131"/>functionality, namely, an <strong class="keyword">Application Programming Interface</strong> (<strong class="keyword">API</strong>). The functions, classes, or methods we write for that component have a particular way of working under certain considerations that, if they are not met, will make our code crash. Conversely, clients calling that code expect a particular response, and any failure of our function to provide this would represent a defect.</p>
    <p class="normal">That is to say that if, for example, we have a function that is expected to work with a series of parameters of type integers, and some other function invokes ours by passing strings, it is clear that it should not work as expected, but in reality, the function should not run at all because it was called incorrectly (the client made a mistake). This error should not pass silently.</p>
    <p class="normal">Of course, when designing an API, the expected input, output, and side effects should be documented. But documentation cannot enforce the behavior of the software at runtime. These rules, what every part of the code expects in order to work properly and what the caller is expecting from them, should be part of the design, and here is where the concept of a <strong class="keyword">contract</strong> comes<a id="_idIndexMarker132"/> into place.</p>
    <p class="normal">The idea behind the DbC approach is that, instead of implicitly placing in the code what every party is expecting, both parties agree on a contract that, if violated, will raise an exception, clearly stating why it cannot continue.</p>
    <p class="normal">In our context, a contract is a construction that enforces some rules that must be honored during the communication of software components. A contract entails mainly preconditions and postconditions, but in some cases, invariants, and side effects are also described:</p>
    <ul>
      <li class="bullet"><strong class="keyword">Preconditions</strong>: We can say that <a id="_idIndexMarker133"/>these are all the checks the code will perform before running. It will check for all the conditions that have to be made before the function can proceed. In general, it's implemented by validating the dataset provided in the parameters passed, but nothing should stop us from running all sorts of validations (for example, validating a set in a database, a file, or another method that was called before) if we consider that their side effects are overshadowed by the importance of such validations. Note that this imposes a constraint on the caller.</li>
      <li class="bullet"><strong class="keyword">Postconditions</strong>: The opposite of<a id="_idIndexMarker134"/> preconditions, here, the validations are done after the function call is returned. Postcondition validations are run to validate what the caller is expecting from this component.</li>
      <li class="bullet"><strong class="keyword">Invariants</strong>: Optionally, it would <a id="_idIndexMarker135"/>be a good idea to document, in the docstring of a function, the invariants, the things that are kept constant while the code of the function is running, as an expression of the logic of the function to be correct.</li>
      <li class="bullet"><strong class="keyword">Side effects</strong>: Optionally, we <a id="_idIndexMarker136"/>can mention any side effects of our code in the docstring.</li>
    </ul>
    <p class="normal">While conceptually, all of these items form part of the contract for a software component, and this is what should go to the documentation of such a piece, only the first two (preconditions and postconditions) are to be enforced at a low level (code).</p>
    <p class="normal">The reason why we would design by contract is that if errors occur, they must be easy to spot (and by noticing whether it was either the precondition or postcondition that failed, we will find the culprit much more easily) so that they can be quickly corrected. More importantly, we want critical parts of the code to avoid being executed under the wrong assumptions. This should help to clearly mark the limits for the responsibilities and errors if they occur, as opposed to something saying that this part of the application is failing. But the caller code provided the wrong arguments, so where should we apply the fix?</p>
    <p class="normal">The idea is that preconditions bind the client (they have an obligation to meet them if they want to run some part of the code), whereas postconditions bind the component in relation to some guarantees that the client can verify and enforce.</p>
    <p class="normal">This way, we can quickly identify responsibilities. If the precondition fails, we know it is due to a defect on the client. On the other hand, if the postcondition check fails, we know the problem is in the routine or class (supplier) itself.</p>
    <p class="normal">Specifically, regarding preconditions, it is important to highlight that they can be checked at runtime, and if they occur, the code that is being called should not be run at all (it does not make sense to run it because its conditions do not hold, and doing so might end up making things worse).</p>
    <h2 id="_idParaDest-58" class="title">Preconditions</h2>
    <p class="normal">Preconditions are all of the<a id="_idIndexMarker137"/> guarantees a function or method expects to receive in order to work correctly. In general programming terms, this usually means providing data that is properly formed, for example, objects that are initialized, non-null values, and many more. For Python, in particular, being dynamically typed, this also means that sometimes we need to check for the exact type of data that is provided. This is not exactly the same as type checking, the <code class="Code-In-Text--PACKT-">mypy</code> kind would do this, but rather verify the exact values that are needed.</p>
    <p class="normal">Part of these checks can be detected early on by using static analysis tools, such as <code class="Code-In-Text--PACKT-">mypy</code>, which we already introduced in <em class="chapterRef">Chapter 1</em>, <em class="italic">Introduction, Code Formatting, and Tools</em>, but these checks are not enough. A function should have proper validation for the information that it is going to handle.</p>
    <p class="normal">Now, this poses the question of where to place the validation logic, depending on whether we let the clients validate all the data before calling the function, or allow this one to validate everything that it received prior to running its own logic. The former equates to a tolerant approach (because the function itself is still allowing any data, potentially malformed data as well), whereas the latter equates to a demanding approach.</p>
    <p class="normal">For the purposes of this analysis, we prefer a demanding approach when it comes to DbC because it is usually the safest choice in terms of robustness, and usually the most common practice in the industry.</p>
    <p class="normal">Regardless of the approach we decide to take, we should always keep in mind the non-redundancy principle, which states that the enforcement of each precondition for a function should be done by only one of the two parts of the contract, but not both. This means that we put the validation logic on the client, or we leave it to the function itself, but in no case should we duplicate it (which also relates to the DRY principle, which we will discuss later on in this chapter).</p>
    <h2 id="_idParaDest-59" class="title">Postconditions</h2>
    <p class="normal">Postconditions are the part of<a id="_idIndexMarker138"/> the contract that is responsible for enforcing the state after the method or function has returned.</p>
    <p class="normal">Assuming that the function or method has been called with the correct properties (that is, with its preconditions met), then the postconditions will guarantee that certain properties are preserved.</p>
    <p class="normal">The idea is to use postconditions to <a id="_idIndexMarker139"/>check and validate everything that a client might need. If the method executed properly, and the postcondition validations pass, then any client calling that code should be able to work with the returned object without problems, as the contract has been fulfilled.</p>
    <h2 id="_idParaDest-60" class="title">Pythonic contracts</h2>
    <p class="normal">At the <a id="_idIndexMarker140"/>time of writing this book, a PEP-316, named <em class="italic">Programming by Contract for Python</em>, is deferred. That doesn't mean that we cannot implement it in Python because, as introduced at the beginning of the chapter, this is a general design principle.</p>
    <p class="normal">Probably the best way to enforce this is by adding control mechanisms to our methods, functions, and classes, and if they fail, raise a <code class="Code-In-Text--PACKT-">RuntimeError</code> exception or <code class="Code-In-Text--PACKT-">ValueError</code>. It's hard to devise a general rule for the correct type of exception, as that would pretty much depend on the application in particular. These previously mentioned exceptions are the most common types of exception, but if they don't fit accurately with the problem, creating a custom exception would be the best choice.</p>
    <p class="normal">We would also like to keep the code as isolated as possible. That is, the code for the preconditions in one part, the one for the postconditions in another, and the core of the function separated. We could achieve this separation by creating smaller functions, but in some cases implementing a decorator would be an interesting alternative.</p>
    <h2 id="_idParaDest-61" class="title">Design by contract – conclusions</h2>
    <p class="normal">The main value of this design principle is to effectively identify where the problem is. By defining a contract, when something fails at runtime, it will be clear what part of the code is broken, and what broke the contract.</p>
    <p class="normal">As a result of following this principle, the code will be more robust. Each component is enforcing its own constraints and maintaining some invariants, and the program can be proven correct as long as these invariants are preserved.</p>
    <p class="normal">It also serves the purpose of clarifying the structure of the program better. Instead of trying to run ad hoc validations, or trying to surmount all possible failure scenarios, the contracts explicitly specify what each function or method expects to work properly, and what is expected from them.</p>
    <p class="normal">Of course, following these principles also adds extra work, because we are not just programming the core logic of our main application, but also the contracts. In addition, we might want to consider adding unit tests for these contracts as well. However, the quality gained by this approach pays off in the long run; hence, it is a good idea to implement this principle for critical components of the application.</p>
    <p class="normal">Nonetheless, for this method to be effective, we should carefully think about what we are willing to validate, and this has to be a meaningful value. For example, it would not make much sense to define contracts that only check for the correct data types of the parameters provided to a function. Many programmers would argue that this would be like trying to make Python a statically typed language. Regardless of this, tools such as <code class="Code-In-Text--PACKT-">mypy</code>, in combination with the use of annotations, would serve this purpose much better and with less effort. With that in mind, design contracts so that there is actually value in them, checking, for example, the properties of the objects being passed and returned, the conditions they have to abide by, and so on.</p>
    <h1 id="_idParaDest-62" class="title">Defensive programming</h1>
    <p class="normal">Defensive programming<a id="_idIndexMarker141"/> follows a somewhat different approach to DbC. Instead of stating all conditions that must be held in a contract, which, if unmet, will raise an exception and make the program fail, this is more about making all parts of the code (objects, functions, or methods) able to protect themselves against invalid inputs.</p>
    <p class="normal">Defensive programming is a technique that has several aspects, and it is particularly useful if it is combined with other design principles (this means that the fact that it follows a different philosophy to DbC does not mean that it is a case of either one or the other—it could mean that they might complement one another).</p>
    <p class="normal">The main ideas on the subject of defensive programming are how to handle errors for scenarios that we might expect to occur, and how to deal with errors that should never occur (when impossible conditions happen). The former will fall into error handling procedures, while the latter will be the case for assertions. Both topics are explored in the following sections.</p>
    <h2 id="_idParaDest-63" class="title">Error handling</h2>
    <p class="normal">In our programs, we resort to <a id="_idIndexMarker142"/>error handling procedures for situations that we anticipate as prone to cause errors. This is usually the case for data input.</p>
    <p class="normal">The idea behind error handling is to gracefully respond to these expected errors in an attempt to either continue our program execution or decide to fail if the error turns out to be insurmountable.</p>
    <p class="normal">There are different approaches by which <a id="_idIndexMarker143"/>we can handle errors on our programs, but not all of them are always applicable. Some of these approaches are as follows:</p>
    <ul>
      <li class="bullet">Value substitution</li>
      <li class="bullet">Error logging</li>
      <li class="bullet">Exception handling</li>
    </ul>
    <p class="normal">In the next two sections, we'll focus on value substitution and exception handling, because these forms of error handling provide more interesting analysis. Error logging is a complementary practice (and a good one; we should always log errors), but most of the time we only log when there's nothing else to be done, so the other methods provide more interesting alternatives.</p>
    <h3 id="_idParaDest-64" class="title">Value substitution</h3>
    <p class="normal">In some scenarios, when <a id="_idIndexMarker144"/>there is an error and there is a risk of the software producing an incorrect value or failing entirely, we might be able to replace the result with another, safer value. We call this value substitution, since we are, in fact, replacing the actual erroneous result for a value that is to be considered non-disruptive (it could be a default, a well-known constant, a sentinel value, or simply something that does not affect the result at all, such as returning zero in a case where the result is intended to be applied to a sum).</p>
    <p class="normal">Value substitution is not always possible, however. This strategy has to be carefully chosen for cases where the substituted value is a safe option. Making this decision is a trade-off between robustness and correctness. A software program is robust when it does not fail, even in the presence of an erroneous scenario. But this is not correct either.</p>
    <p class="normal">This might not be acceptable for some kinds of software. If the application is critical, or the data being handled is too sensitive, this is not an option, since we cannot afford to provide users (or other parts of the application) with erroneous results. In these cases, we opt for correctness, rather than let the program explode when yielding the wrong results.</p>
    <p class="normal">A slightly different, and safer, version of this decision is to use default values for data that is not provided. This can be the case for parts of the code that can work with a default behavior, for example, default values for environment variables that are not set, for missing entries in configuration files, or for parameters of functions. </p>
    <p class="normal">We can find examples of Python supporting this throughout different methods of its API, for example, dictionaries have a <code class="Code-In-Text--PACKT-">get</code> method, whose (optional) second parameter allows you to indicate a default value:</p>
    <pre class="programlisting con"><code class="hljs-con"><span class="hljs-con-meta">&gt;</span><span class="bash">&gt;&gt; configuration = {"dbport": 5432}</span>
<span class="hljs-con-meta">&gt;</span><span class="bash">&gt;&gt; configuration.get("dbhost", "localhost")</span>
'localhost'
<span class="hljs-con-meta">&gt;</span><span class="bash">&gt;&gt; configuration.get("dbport")</span>
5432
</code></pre>
    <p class="normal">Environment variables have a similar API:</p>
    <pre class="programlisting con"><code class="hljs-con"><span class="hljs-con-meta">&gt;</span><span class="bash">&gt;&gt; import os</span>
<span class="hljs-con-meta">&gt;</span><span class="bash">&gt;&gt; os.getenv("DBHOST")</span>
'localhost'
<span class="hljs-con-meta">&gt;</span><span class="bash">&gt;&gt; os.getenv("DPORT", 5432)</span>
5432
</code></pre>
    <p class="normal">In both previous examples, if the <a id="_idIndexMarker145"/>second parameter is not provided, <code class="Code-In-Text--PACKT-">None</code> will be returned because it's the default value those functions are defined with. We can also define default values for the parameters of our own functions:</p>
    <pre class="programlisting con"><code class="hljs-con"><span class="hljs-con-meta">&gt;</span><span class="bash">&gt;&gt; def connect_database(host="localhost", port=5432):</span>
...     logger.info("connecting to database server at %s:%i", host, port)
</code></pre>
    <p class="normal">In general, replacing missing parameters with default values is acceptable, but substituting erroneous data with legal close values is more dangerous and can mask some errors. Take this criterion into consideration when deciding on this approach.</p>
    <h3 id="_idParaDest-65" class="title">Exception handling</h3>
    <p class="normal">In the presence of incorrect or<a id="_idIndexMarker146"/> missing input data, sometimes it is possible to correct the situation with some examples, such as the ones mentioned in the previous section. In other cases, however, it is better to stop the program from continuing to run with the wrong data than to leave it computing under erroneous assumptions. In those cases, failing and notifying the caller that something is wrong is a good approach, and this is the case for a precondition that was violated, as we saw in DbC.</p>
    <p class="normal">Nonetheless, erroneous input data is not the only possible way in which a function can go wrong. After all, functions are not just about passing data around; they also have side effects and connect to external components.</p>
    <p class="normal">It could be possible that a fault in a function call is due to a problem on one of these external components, and not in our function itself. If that is the case, our function should communicate this properly. This will make it easier to debug. The function should clearly, and unambiguously, notify the rest of the application regarding errors that cannot be ignored so that they can be addressed accordingly.</p>
    <p class="normal">The mechanism for accomplishing this is an exception. It is important to emphasize that this is what exceptions should be used for—clearly announcing an exceptional situation, and not altering the flow of the program according to business logic.</p>
    <p class="normal">If the code tries to use exceptions to handle expected scenarios or business logic, the flow of the program will become harder to read. This will lead to a situation where exceptions are used as a sort of <code class="Code-In-Text--PACKT-">go-to</code> statement, which (to make things worse) could span multiple levels on the call stack (up to caller functions), violating the encapsulation of the logic into its correct level of abstraction. The case could get even worse if these <code class="Code-In-Text--PACKT-">except</code> blocks are mixing business logic with truly exceptional cases that the code is trying to defend against; in that case, it will be harder to distinguish between the core logic we have to maintain and the errors to be handled.</p>
    <div class="packt_tip">
      <p class="Tip--PACKT-">Do not use exceptions as a <code class="Code-In-Text--PACKT-">go-to</code> mechanism for business logic. Raise exceptions when there is something wrong with the code that callers need to be aware of.</p>
    </div>
    <p class="normal">This last concept is an important one; exceptions<a id="_idIndexMarker147"/> are usually about notifying the caller about something amiss. This means that exceptions should be used carefully because they weaken encapsulation. The more exceptions a function has, the more the caller function will have to anticipate, therefore knowing about the function it is calling. And if a function raises too many exceptions, this means that it is not so context-free, because every time we want to invoke it, we will have to keep all of its possible side effects in mind.</p>
    <p class="normal">This can be used as a heuristic to tell when a function is not sufficiently cohesive and has too many responsibilities. If it raises too many exceptions, it could be a sign that it has to be broken down into multiple, smaller ones.</p>
    <p class="normal">Here are some recommendations that relate to exceptions in Python.</p>
    <h4 class="title">Handling exceptions at the right level of abstraction</h4>
    <p class="normal">Exceptions are<a id="_idIndexMarker148"/> also part of the principal functions that do one thing, and one thing only. The exception the function is handling (or raising) has to be consistent with the logic encapsulated on it.</p>
    <p class="normal">In the following example, we can see what we mean by mixing different levels of abstractions. Imagine an object that acts as a transport for some data in our application. It connects to an external component where the data is going to be sent upon decoding. In the following listing, we will focus on the <code class="Code-In-Text--PACKT-">deliver_event</code> method:</p>
    <pre class="programlisting code"><code class="hljs-code"><span class="hljs-keyword">class</span><span class="hljs-class"> </span><span class="hljs-title">DataTransport</span><span class="hljs-class">:</span>
    """An example of an <span class="hljs-built_in">object</span> handling exceptions of different levels."""
    _RETRY_BACKOFF: <span class="hljs-built_in">int</span> = <span class="hljs-number">5</span>
    _RETRY_TIMES: <span class="hljs-built_in">int</span> = <span class="hljs-number">3</span>
    <span class="hljs-keyword">def</span><span class="hljs-function"> </span><span class="hljs-title">__init__</span><span class="hljs-function">(</span><span class="hljs-params">self, connector: Connector</span><span class="hljs-function">) -&gt; </span><span class="hljs-keyword">None</span><span class="hljs-function">:</span>
        self._connector = connector
        self.connection = <span class="hljs-literal">None</span>
    <span class="hljs-keyword">def</span><span class="hljs-function"> </span><span class="hljs-title">deliver_event</span><span class="hljs-function">(</span><span class="hljs-params">self, event: Event</span><span class="hljs-function">):</span>
        <span class="hljs-keyword">try</span>:
            self.connect()
            data = event.decode()
            self.send(data)
        <span class="hljs-keyword">except</span> ConnectionError <span class="hljs-keyword">as</span> e:
            logger.info("connection error detected: %s", e)
            <span class="hljs-keyword">raise</span>
        <span class="hljs-keyword">except</span> ValueError <span class="hljs-keyword">as</span> e:
            logger.error("%r contains incorrect data: %s", event, e)
            <span class="hljs-keyword">raise</span>
    <span class="hljs-keyword">def</span><span class="hljs-function"> </span><span class="hljs-title">connect</span><span class="hljs-function">(</span><span class="hljs-params">self</span><span class="hljs-function">):</span>
        <span class="hljs-keyword">for</span> _ <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(self._RETRY_TIMES):
            <span class="hljs-keyword">try</span>:
                self.connection = self._connector.connect()
            <span class="hljs-keyword">except</span> ConnectionError <span class="hljs-keyword">as</span> e:
                logger.info(
                    "%s: attempting new connection <span class="hljs-keyword">in</span> %<span class="hljs-keyword">is</span>", e, self._RETRY_BACKOFF,
                )
                time.sleep(self._RETRY_BACKOFF)
            <span class="hljs-keyword">else</span>:
                <span class="hljs-keyword">return</span> self.connection
        <span class="hljs-keyword">raise</span> ConnectionError(f"Couldn't connect after {self._RETRY_TIMES} times")
    <span class="hljs-keyword">def</span><span class="hljs-function"> </span><span class="hljs-title">send</span><span class="hljs-function">(</span><span class="hljs-params">self, data: </span><span class="hljs-built_in">bytes</span><span class="hljs-function">):</span>
        <span class="hljs-keyword">return</span> self.connection.send(data)
</code></pre>
    <p class="normal">For our analysis, let's zoom in and focus on how the <code class="Code-In-Text--PACKT-">deliver_event()</code> method handles exceptions.</p>
    <p class="normal">What <a id="_idIndexMarker149"/>does <code class="Code-In-Text--PACKT-">ValueError</code> have to do with <code class="Code-In-Text--PACKT-">ConnectionError</code>? Not much. By looking at these two highly different types of error, we can get an idea of how responsibilities should be divided.</p>
    <p class="normal"><code class="Code-In-Text--PACKT-">ConnectionError</code> should be handled inside the <code class="Code-In-Text--PACKT-">connect</code> method. This allows a clear separation of behavior. For example, if this method needs to support retries, then handling said exception would be a way of doing it.</p>
    <p class="normal">Conversely, <code class="Code-In-Text--PACKT-">ValueError</code> belongs to the <code class="Code-In-Text--PACKT-">decode</code> method of the event. With this new implementation (shown in the next example), this method does not need to catch any exception—the exceptions we were worrying about before are either handled by internal methods or deliberately left to be raised.</p>
    <p class="normal">We should separate these fragments into different methods or functions. For the connection management, a small function should be enough. This function will be in charge of trying to establish the connection, catching exceptions (should they occur), and logging them accordingly:</p>
    <pre class="programlisting code"><code class="hljs-code"><span class="hljs-keyword">def</span><span class="hljs-function"> </span><span class="hljs-title">connect_with_retry</span><span class="hljs-function">(</span><span class="hljs-params">connector: Connector, retry_n_times: </span><span class="hljs-built_in">int</span><span class="hljs-params">, retry_backoff: </span><span class="hljs-built_in">int</span><span class="hljs-params"> = </span><span class="hljs-number">5</span><span class="hljs-function">):</span>
    """Tries to establish the connection of &lt;connector&gt; retrying
    &lt;retry_n_times&gt;, <span class="hljs-keyword">and</span> waiting &lt;retry_backoff&gt; seconds between attempts.
    If it can connect, returns the connection <span class="hljs-built_in">object</span>.
    If it's <span class="hljs-keyword">not</span> possible to connect after the retries have been exhausted, raises ``ConnectionError``.
    :param connector:         An <span class="hljs-built_in">object</span> <span class="hljs-keyword">with</span> a ``.connect()`` method.
    :param retry_n_times <span class="hljs-built_in">int</span>: The number of times to <span class="hljs-keyword">try</span> to call
                              ``connector.connect()``.
    :param retry_backoff <span class="hljs-built_in">int</span>: The time lapse between retry calls.
    """
    <span class="hljs-keyword">for</span> _ <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(retry_n_times):
        <span class="hljs-keyword">try</span>:
            <span class="hljs-keyword">return</span> connector.connect()
        <span class="hljs-keyword">except</span> ConnectionError <span class="hljs-keyword">as</span> e:
            logger.info("%s: attempting new connection <span class="hljs-keyword">in</span> %<span class="hljs-keyword">is</span>", e, retry_backoff)
            time.sleep(retry_backoff)
    exc = ConnectionError(f"Couldn't connect after {retry_n_times} times")
    logger.exception(exc)
    <span class="hljs-keyword">raise</span> exc
</code></pre>
    <p class="normal">Then, we<a id="_idIndexMarker150"/> will call this function in our method. As for the <code class="Code-In-Text--PACKT-">ValueError</code> exception on the event, we could separate it with a new object and do composition, but for this limited case it would be overkill, so just moving the logic to a separate method would be enough. With these two considerations in place, the new version of the method looks much more compact and easier to read:</p>
    <pre class="programlisting code"><code class="hljs-code"><span class="hljs-keyword">class</span><span class="hljs-class"> </span><span class="hljs-title">DataTransport</span><span class="hljs-class">:</span>
    """An example of an <span class="hljs-built_in">object</span> that separates the exception handling by
    abstraction levels.
    """
    _RETRY_BACKOFF: <span class="hljs-built_in">int</span> = <span class="hljs-number">5</span>
    _RETRY_TIMES: <span class="hljs-built_in">int</span> = <span class="hljs-number">3</span>
    <span class="hljs-keyword">def</span><span class="hljs-function"> </span><span class="hljs-title">__init__</span><span class="hljs-function">(</span><span class="hljs-params">self, connector: Connector</span><span class="hljs-function">) -&gt; </span><span class="hljs-keyword">None</span><span class="hljs-function">:</span>
        self._connector = connector
        self.connection = <span class="hljs-literal">None</span>
    <span class="hljs-keyword">def</span><span class="hljs-function"> </span><span class="hljs-title">deliver_event</span><span class="hljs-function">(</span><span class="hljs-params">self, event: Event</span><span class="hljs-function">):</span>
        self.connection = connect_with_retry(self._connector, self._RETRY_TIMES, self._RETRY_BACKOFF)
        self.send(event)
    <span class="hljs-keyword">def</span><span class="hljs-function"> </span><span class="hljs-title">send</span><span class="hljs-function">(</span><span class="hljs-params">self, event: Event</span><span class="hljs-function">):</span>
        <span class="hljs-keyword">try</span>:
            <span class="hljs-keyword">return</span> self.connection.send(event.decode())
        <span class="hljs-keyword">except</span> ValueError <span class="hljs-keyword">as</span> e:
            logger.error("%r contains incorrect data: %s", event, e)
            <span class="hljs-keyword">raise</span>
</code></pre>
    <p class="normal">See now how the separation of the exception classes also delimits a separation in responsibilities. In the first example shown, everything was mixed, and there wasn't a clear separation of concerns. Then we decided the connection as a concern on itself, so in the next example, the <code class="Code-In-Text--PACKT-">connect_with_retry</code> function was created, and <code class="Code-In-Text--PACKT-">ConnectionError</code> was being handled as part of this function, if we needed to modify that function (as we had). On the other hand, the <code class="Code-In-Text--PACKT-">ValueError</code> wasn't part of that same logic, so it was left in the <code class="Code-In-Text--PACKT-">send</code> method where it belongs.</p>
    <p class="normal">Exceptions<a id="_idIndexMarker151"/> carry a meaning. For that reason, it's important to handle each type of exception at its right level of abstraction (that means, depending on the layer of our application they belong to). But they can also carry important information sometimes. And since this information might be sensitive, we don't want it to fall into the wrong hands, so in the next section we'll discuss the security implications of exceptions.</p>
    <h4 class="title">Do not expose tracebacks to end users</h4>
    <p class="normal">This is a security consideration. When dealing with exceptions, it might be acceptable to let them propagate if the error is too important, and maybe even let the program fail if this is the decision for that particular scenario and correctness was favored over robustness.</p>
    <p class="normal">When there is an exception that denotes a problem, it's important to log in with as much detail as possible (including the traceback information, message, and all we can gather) so that the issue can be corrected efficiently. At the same time, we want to include as much detail as possible for ourselves—we don't want any of this becoming visible to users.</p>
    <p class="normal">In Python, tracebacks of exceptions <a id="_idIndexMarker152"/>contain very rich and useful debugging information. Unfortunately, this information is also very useful for attackers or malicious users who want to try and harm the application, not to mention that the leak would represent an important information disclosure, jeopardizing the intellectual property of your organization (as parts of the code will be exposed).</p>
    <p class="normal">If you choose to let exceptions propagate, make sure not to disclose any sensitive information. Also, if you have to notify users about a problem, choose generic messages (such as <code class="Code-In-Text--PACKT-">Something went wrong</code>, or <code class="Code-In-Text--PACKT-">Page not found</code>). This is a common technique used in web applications that display generic informative messages when an HTTP error occurs.</p>
    <h4 class="title">Avoid empty except blocks</h4>
    <p class="normal">This was even referred to as the<a id="_idIndexMarker153"/> most diabolical Python anti-pattern (REAL 01). While it is good to anticipate and defend our programs against some errors, being too defensive might lead to even worse problems. In particular, the only problem with being too defensive is that there is an empty <code class="Code-In-Text--PACKT-">except</code> block that silently passes without doing anything.</p>
    <p class="normal">Python is so flexible that it allows us to write code that can be faulty and yet, will not raise an error, like this:</p>
    <pre class="programlisting code"><code class="hljs-code"><span class="hljs-keyword">try</span>:
    process_data()
<span class="hljs-keyword">except</span>:
    <span class="hljs-keyword">pass</span>
</code></pre>
    <p class="normal">The problem with this is that it will not fail, ever, even when it should. It is also non-Pythonic if you remember from the Zen of Python that errors should never pass silently.</p>
    <div class="packt_tip">
      <p class="Tip--PACKT-">Configure your continuous integration environment (by using tools such as those explored in <em class="chapterRef">Chapter 1</em>, <em class="italic">Introduction, Code Formatting, and Tools</em>) to automatically report on empty exception blocks.</p>
    </div>
    <p class="normal">In the event of an exception, this block of code will not fail, which might be what we wanted in the first place. But what if there is a defect? There might occur an actual failure when the <code class="Code-In-Text--PACKT-">process_data()</code> function runs, and we would like to know if there is an error in our logic in order to be able to correct it. Writing blocks such as this one will mask problems, making things harder to maintain.</p>
    <p class="normal">There are two alternatives:</p>
    <ul>
      <li class="bullet">Catch a more specific exception (not too broad, such as an <code class="Code-In-Text--PACKT-">Exception</code>). In fact, some linting tools and IDEs will warn you in some cases when the code is handling too broad an exception.</li>
      <li class="bullet">Perform some actual error handling on the <code class="Code-In-Text--PACKT-">except</code> block.</li>
    </ul>
    <p class="normal">The best thing to do would be to apply both recommendations. Handling a more specific exception (for example, <code class="Code-In-Text--PACKT-">AttributeError</code> or <code class="Code-In-Text--PACKT-">KeyError</code>) will make the program more maintainable because the reader will know what to expect and can get an idea of the <em class="italic">why</em> of it. It will also leave other exceptions free to be raised, and if that happens, this probably means a bug, only this time it can be discovered.</p>
    <p class="normal">Handling the exception itself can mean multiple things. In its simplest form, it could be just about logging the exception (make sure to use <code class="Code-In-Text--PACKT-">logger.exception</code> or <code class="Code-In-Text--PACKT-">logger.error</code> to provide the full context of what happened). Other alternatives could be to return a default value (substitution, only that in this case after detecting an error, not prior to causing it), or raising a different exception.</p>
    <div class="packt_tip">
      <p class="Tip--PACKT-">If you choose to raise a different exception, include the original exception that caused the problem (see the next section).</p>
    </div>
    <p class="normal">Another reason to avoid <a id="_idIndexMarker154"/>having an empty <code class="Code-In-Text--PACKT-">except</code> block (using <code class="Code-In-Text--PACKT-">pass</code>) is the implicitness of it: it doesn't tell readers of the code that we actually expect that exception to be ignored. A more explicit way of doing so would be to use the <code class="Code-In-Text--PACKT-">contextlib.suppress</code> function, which can accept all exceptions as arguments that are to be ignored, and it can be used as a context manager.</p>
    <p class="normal">In our example, it might look like this:</p>
    <pre class="programlisting code"><code class="hljs-code"><span class="hljs-keyword">import</span> contextlib
<span class="hljs-keyword">with</span> contextlib.suppress(KeyError):
    process_data()
</code></pre>
    <p class="normal">Again, as with the previous case, try to avoid passing the general <code class="Code-In-Text--PACKT-">Exception</code> to this context manager, because the effect will be the same.</p>
    <h4 class="title">Include the original exception</h4>
    <p class="normal">As part of our <a id="_idIndexMarker155"/>error handling logic, we might decide to raise a different one, and maybe even change its message. If that is the case, it is recommended to include the original exception that led to that.</p>
    <p class="normal">We can use the <code class="Code-In-Text--PACKT-">raise &lt;e&gt; from &lt;original_exception&gt;</code> syntax (PEP-3134). When using this construction, the original traceback will be embedded into the new exception, and the original exception will be set in the <code class="Code-In-Text--PACKT-">__cause__</code> attribute of the resulting one.</p>
    <p class="normal">For example, if we desire to wrap default exceptions with custom ones internally to our project, we could still do that while including information about the root exception:</p>
    <pre class="programlisting code"><code class="hljs-code"><span class="hljs-keyword">class</span><span class="hljs-class"> </span><span class="hljs-title">InternalDataError</span><span class="hljs-class">(</span><span class="hljs-params">Exception</span><span class="hljs-class">):</span>
    """An exception <span class="hljs-keyword">with</span> the data of our domain problem."""
<span class="hljs-keyword">def</span><span class="hljs-function"> </span><span class="hljs-title">process</span><span class="hljs-function">(</span><span class="hljs-params">data_dictionary, record_id</span><span class="hljs-function">):</span>
    <span class="hljs-keyword">try</span>:
        <span class="hljs-keyword">return</span> data_dictionary[record_id]
    <span class="hljs-keyword">except</span> KeyError <span class="hljs-keyword">as</span> e:
        <span class="hljs-keyword">raise</span> InternalDataError("Record <span class="hljs-keyword">not</span> present") <span class="hljs-keyword">from</span> e
</code></pre>
    <div class="packt_tip">
      <p class="Tip--PACKT-">Always use the <code class="Code-In-Text--PACKT-">raise &lt;e&gt; from &lt;o&gt;</code> syntax when changing the type of the exception.</p>
    </div>
    <p class="normal">Using this <a id="_idIndexMarker156"/>syntax will make the tracebacks contain more information about the exception or the error that has just occurred, which will help significantly when debugging.</p>
    <h2 id="_idParaDest-66" class="title">Using assertions in Python</h2>
    <p class="normal">Assertions <a id="_idIndexMarker157"/>are to be used for situations that should never happen, so the <a id="_idIndexMarker158"/>expression on the <code class="Code-In-Text--PACKT-">assert</code> statement has to mean an impossible condition. Should this condition happen, it means there is a defect in the software.</p>
    <p class="normal">In contrast to the error handling approach, there are situations in which we don't want our program to continue its execution if a particular error occurred. This is because, in some cases, the error cannot be surmounted, and our program cannot correct its course of execution (or self-heal), so it's better to fail fast, and let the error be noticed, so it can be corrected with the next version upgrade.</p>
    <p class="normal">The idea of using assertions is to prevent the program from causing further damage if such an invalid scenario is presented. Sometimes, it is better to stop and let the program crash rather than let it continue processing under the wrong assumptions.</p>
    <p class="normal">By definition, an assertion is a Boolean condition in the code that must hold true for the program to be correct. If the program fails because of an <code class="Code-In-Text--PACKT-">AssertionError</code>, it means a defect has just been uncovered.</p>
    <p class="normal">For this reason, assertions should not be mixed with the business logic, or used as control flow mechanisms for the software. The following example is a bad idea:</p>
    <pre class="programlisting code"><code class="hljs-code"><span class="hljs-keyword">try</span>:
    <span class="hljs-keyword">assert</span> condition.holds(), "Condition <span class="hljs-keyword">is</span> <span class="hljs-keyword">not</span> satisfied"
<span class="hljs-keyword">except</span> AssertionError:
    alternative_procedure()
</code></pre>
    <div class="packt_tip">
      <p class="Tip--PACKT-">Do not catch the <code class="Code-In-Text--PACKT-">AssertionError</code> exception because it might be confusing for readers of the code. If you're expecting some part of your code to raise an exception, try to use a more specific one.</p>
    </div>
    <p class="normal">The previous advice of catching the <code class="Code-In-Text--PACKT-">AssertionError</code> goes along the lines of not letting your program fail silently. But it could fail gracefully. So, instead of letting the application have a hard crash, you can catch the <code class="Code-In-Text--PACKT-">AssertionError</code> and show a generic error message, while still logging all the internal error details to the logging platform of your company. The point is not exactly about whether or not to catch this exception, but that assertion errors are a valuable source of information that will help you improve the quality of your software.</p>
    <p class="normal">Make sure that the <a id="_idIndexMarker159"/>program terminates when an assertion fails. This means<a id="_idIndexMarker160"/> that assertions are usually put in the code to identify erroneous parts of the program. There's a tendency in many programming languages to think that assertions can be suppressed when the program is running in production, but that defeats its purpose, because the point of them is to precisely let us know about those parts of the program that need to be fixed.</p>
    <p class="normal">In Python, in particular, running with the <code class="Code-In-Text--PACKT-">–O</code> flag will suppress the <code class="Code-In-Text--PACKT-">assert</code> statements, but this is discouraged for the aforementioned reasons.</p>
    <div class="packt_tip">
      <p class="Tip--PACKT-">Do not run your production programs with <code class="Code-In-Text--PACKT-">python –O </code>… as you'd like to take advantage of the assertions in the code to correct defects.</p>
    </div>
    <p class="normal">Include a descriptive error message in the assertion statement and log the errors to make sure that you can properly debug and correct the problem later on.</p>
    <p class="normal">Another important reason why the previous code is a bad idea is that besides catching <code class="Code-In-Text--PACKT-">AssertionError</code>, the statement in the assertion is a function call. Function calls can have side effects, and they aren't always repeatable (we don't know if calling <code class="Code-In-Text--PACKT-">condition.holds()</code> again will yield the same result). Moreover, if we stop the debugger at that line, we might not be able to conveniently see the result that causes the error, and, again, even if we call that function again, we don't know if that was the offending value.</p>
    <p class="normal">A better alternative requires a few more lines of code, but provides more useful information:</p>
    <pre class="programlisting code"><code class="hljs-code">result = condition.holds()
<span class="hljs-keyword">assert</span> result &gt; <span class="hljs-number">0</span>, f"Error <span class="hljs-keyword">with</span> {result}"
</code></pre>
    <div class="packt_tip">
      <p class="Tip--PACKT-">When using assertions, try to avoid using function calls directly, and write the expression in terms of local variables.</p>
    </div>
    <p class="normal">What's the relationship between assertions and exception handling? Some might ask if assertions are moot, in the light of exception handling. Why would you want to assert for a condition if we can check that with an <code class="Code-In-Text--PACKT-">if</code> statement and raise an exception? There's a subtle difference, though. In general, exceptions are for handling unexpected situations in relation to the business logic that our program will want to consider, whereas assertions are like self-checking mechanisms put in the code, to validate (assert) its correctness.</p>
    <p class="normal">For this reason, exception<a id="_idIndexMarker161"/> raising will be much more common than having <code class="Code-In-Text--PACKT-">assert</code> statements. Typical uses of <code class="Code-In-Text--PACKT-">assert</code> are situations where an algorithm maintains an <a id="_idIndexMarker162"/>invariant logic that must be kept at all times: in that case, you might want to assert for the invariant. If this is broken at some point, it means either the algorithm is wrong or poorly implemented.</p>
    <p class="normal">We have explored defensive programming in Python, and some related topics regarding exception handling. Now, we move on to the next big topic, as the next section discusses the separation of concerns.</p>
    <h1 id="_idParaDest-67" class="title">Separation of concerns</h1>
    <p class="normal">This is a design <a id="_idIndexMarker163"/>principle that is applied at multiple levels. It is not just about the low-level design (code), but it is also relevant at a higher level of abstraction, so it will come up later when we talk about architecture.</p>
    <p class="normal">Different responsibilities should go into different components, layers, or modules of the application. Each part of the program should only be responsible for a part of the functionality (what we call its concerns) and should know nothing about the rest.</p>
    <p class="normal">The goal of separating concerns in software is to enhance maintainability by minimizing ripple effects. A <strong class="keyword">ripple</strong> effect<a id="_idIndexMarker164"/> means the propagation of a change in the software from a starting point. This could be the case of an error or exception triggering a chain of other exceptions, causing failures that will result in a defect on a remote part of the application. It can also be that we have to change a lot of code scattered through multiple parts of the code base, as a result of a simple change in a function definition.</p>
    <p class="normal">Clearly, we do not want these scenarios to happen. The software has to be easy to change. If we have to modify or refactor some part of the code, this has to have a minimal impact on the rest of the application, and the way to achieve this is through proper encapsulation.</p>
    <p class="normal">In a similar way, we want any potential errors to be contained so that they don't cause major damage.</p>
    <p class="normal">This concept is related to the DbC principle in the sense that each concern can be enforced by a <a id="_idIndexMarker165"/>contract. When a contract is violated, and an exception is raised as a result of such a violation, we know what part of the program has the failure, and what responsibilities failed to be met.</p>
    <p class="normal">Despite this similarity, separation of concerns goes further. We normally think of contracts between functions, methods, or classes, and while this also applies to responsibilities that have to be separated, the idea of the separation of concerns also applies to Python modules, packages, and basically any software component.</p>
    <h2 id="_idParaDest-68" class="title">Cohesion and coupling</h2>
    <p class="normal">These are important concepts for good software design.</p>
    <p class="normal">On the one hand, <code class="Code-In-Text--PACKT-">cohesion</code> means <a id="_idIndexMarker166"/>that objects should have a small and well-defined purpose, and they should do as little as possible. It follows a similar philosophy as Unix commands that do only one thing and do it well. The more cohesive our objects are, the more useful and reusable they become, making our design better.</p>
    <p class="normal">On the other hand, <code class="Code-In-Text--PACKT-">coupling</code> refers to <a id="_idIndexMarker167"/>the idea of how two or more objects depend on each other. This dependency poses a limitation. If two parts of the code (objects or methods) are too dependent on each other, they bring with them some undesired consequences:</p>
    <ul>
      <li class="bullet"><strong class="keyword">No code reuse</strong>: If one function depends too much on a particular object, or takes too many parameters, it's coupled with this object, which means that it will be really difficult to use that function in a different context (to do so, we will have to find a suitable parameter that complies with a very restrictive interface).</li>
      <li class="bullet"><strong class="keyword">Ripple effects</strong>: Changes in one of the two parts will certainly impact the other, as they are too close.</li>
      <li class="bullet"><strong class="keyword">Low level of abstraction</strong>: When two functions are so closely related, it is hard to see them as different concerns resolving problems at different levels of abstraction.</li>
    </ul>
    <div class="packt_tip">
      <p class="Tip--PACKT-">Rule of thumb: Well-defined software will achieve high cohesion and low coupling.</p>
    </div>
    <h1 id="_idParaDest-69" class="title">Acronyms to live by</h1>
    <p class="normal">In this section, we will review some principles that yield some good design ideas. The point is to quickly relate to good software practices by acronyms that are easy to remember, working as a sort of mnemonic rule. If you keep these words in mind, you will be able to associate them with good practices more easily and finding the right idea behind a particular line of code that you are looking at will be faster.</p>
    <p class="normal">These are by no means formal or academic definitions, but more like empirical ideas that emerged from years of working in the software industry. Some of them do appear in books, as they were coined by important authors (see the references to investigate them in more detail), and others have their roots probably in blog posts, papers, or conference talks.</p>
    <h2 id="_idParaDest-70" class="title">DRY/OAOO</h2>
    <p class="normal">The ideas of <strong class="keyword">Don't Repeat Yourself</strong> (<strong class="keyword">DRY</strong>) and <strong class="keyword">Once and Only Once</strong> (<strong class="keyword">OAOO</strong>) are closely related, so they <a id="_idIndexMarker168"/>were included together here. They are self-explanatory, and you should avoid <a id="_idIndexMarker169"/>duplication at all costs.</p>
    <p class="normal">Things in the code, knowledge, have to be defined only once and in a single place. When you have to make a change to the code, there should be only one rightful location to modify. Failure to do so is a sign of a poorly designed system.</p>
    <p class="normal">Code duplication is a<a id="_idIndexMarker170"/> problem that directly impacts maintainability. It is very undesirable to have code duplication because of its many negative consequences:</p>
    <ul>
      <li class="bullet"><strong class="keyword">It's error prone</strong>: When some logic is repeated multiple times throughout the code, and this needs to change, it means we depend on efficiently correcting all the instances with this logic, without forgetting any of them, because in that case there will be a bug.</li>
      <li class="bullet"><strong class="keyword">It's expensive</strong>: Linked to the previous point, making a change in multiple places takes much more time (development and testing effort) than if it was defined only once. This will slow the team down.</li>
      <li class="bullet"><strong class="keyword">It's unreliable</strong>: Also linked to the first point, when multiple places need to be changed for a single change in the context, you rely on the person who wrote the code to remember all the instances where the modification has to be made. There is no single source of truth.</li>
    </ul>
    <p class="normal">Duplication is <a id="_idIndexMarker171"/>often caused by ignoring (or forgetting) that code represents knowledge. By giving meaning to certain parts of the code, we are identifying and labeling that knowledge.</p>
    <p class="normal">Let's see what this means with an example. Imagine that, in a study center, students are ranked by the following criteria: 11 points per exam passed, minus five points per exam failed, and minus two per year in the institution. The following is not actual code, but just a representation of how this might be scattered in a real code base:</p>
    <pre class="programlisting code"><code class="hljs-code"><span class="hljs-keyword">def</span><span class="hljs-function"> </span><span class="hljs-title">process_students_list</span><span class="hljs-function">(</span><span class="hljs-params">students</span><span class="hljs-function">):</span>
    <span class="hljs-comment"># do some processing...</span>
    students_ranking = <span class="hljs-built_in">sorted</span>(
        students, key=<span class="hljs-keyword">lambda</span> s: s.passed * <span class="hljs-number">11</span> - s.failed * <span class="hljs-number">5</span> - s.years * <span class="hljs-number">2</span>
    )
    <span class="hljs-comment"># more processing</span>
    <span class="hljs-keyword">for</span> student <span class="hljs-keyword">in</span> students_ranking:
        print(
            "Name: {<span class="hljs-number">0</span>}, Score: {<span class="hljs-number">1</span>}".<span class="hljs-built_in">format</span>(
                student.name,
                (student.passed * <span class="hljs-number">11</span> - student.failed * <span class="hljs-number">5</span> - student.years * <span class="hljs-number">2</span>),
            )
        )
</code></pre>
    <p class="normal">Notice how the lambda, which is in the key of the sorted function, represents some valid knowledge from the domain problem, yet it doesn't reflect it (it doesn't have a name, a proper and rightful location, there is no meaning assigned to that code, nothing). This lack of meaning in the code leads to the duplication we find when the score is printed out while listing the raking.</p>
    <p class="normal">We should reflect our knowledge of our domain problem in our code, and our code will then be less likely to suffer from duplication and will be easier to understand:</p>
    <pre class="programlisting code"><code class="hljs-code"><span class="hljs-keyword">def</span><span class="hljs-function"> </span><span class="hljs-title">score_for_student</span><span class="hljs-function">(</span><span class="hljs-params">student</span><span class="hljs-function">):</span>
    <span class="hljs-keyword">return</span> student.passed * <span class="hljs-number">11</span> - student.failed * <span class="hljs-number">5</span> - student.years * <span class="hljs-number">2</span>
<span class="hljs-keyword">def</span><span class="hljs-function"> </span><span class="hljs-title">process_students_list</span><span class="hljs-function">(</span><span class="hljs-params">students</span><span class="hljs-function">):</span>
    <span class="hljs-comment"># do some processing...</span>
    students_ranking = <span class="hljs-built_in">sorted</span>(students, key=score_for_student)
    <span class="hljs-comment"># more processing</span>
    <span class="hljs-keyword">for</span> student <span class="hljs-keyword">in</span> students_ranking:
        print(
            "Name: {<span class="hljs-number">0</span>}, Score: {<span class="hljs-number">1</span>}".<span class="hljs-built_in">format</span>(
                student.name, score_for_student(student)
            )
        )
</code></pre>
    <p class="normal">A fair disclaimer: This is just an analysis of one of the traits of code duplication. In reality, there are more cases, types, and taxonomies of code duplication. Entire chapters could be dedicated to this topic, but here we focus on one particular aspect to make the idea behind the acronym clear.</p>
    <p class="normal">In this example, we have taken what is probably the simplest approach to eliminating duplication: creating a function. Depending on the case, the best solution would be different. In some cases, there might be an entirely new object that has to be created (maybe an entire abstraction was missing). In other cases, we can eliminate duplication with a context manager. Iterators or generators (described in <em class="chapterRef">Chapter 7</em>, <em class="italic">Generators, Iterators, and Asynchronous Programming</em>) could also help to avoid repetition in the code, and decorators (explained in <em class="chapterRef">Chapter 5</em>, <em class="italic">Using Decorators to Improve Our Code</em>) will also help.</p>
    <p class="normal">Unfortunately, there is no general rule or pattern to tell you which of the features of Python are the most suitable when it comes to addressing code duplication, but hopefully, after seeing the examples in this book, and how the elements of Python are used, the reader will be able to develop their own intuition.</p>
    <h2 id="_idParaDest-71" class="title">YAGNI</h2>
    <p class="normal"><strong class="keyword">YAGNI</strong> (short for <strong class="keyword">You Ain't Gonna Need It</strong>) is an idea you might want to keep in mind very often when writing a solution if you do not want to over-engineer it.</p>
    <p class="normal">We want to be able to<a id="_idIndexMarker172"/> easily modify our programs, so we want to make them future-proof. In line with that, many developers think that they have to anticipate all future requirements and create solutions that are very complex, and so create abstractions that are hard to read, maintain, and understand. Sometime later, it turns out that those anticipated requirements do not show up, or they do but in a different way (surprise!), and the original code that was supposed to handle precisely that does not work. </p>
    <p class="normal">The problem is that now it is even harder to refactor and extend our programs. What happened was that the original solution did not handle the original requirements correctly, and neither do the current ones, simply because it is the wrong abstraction.</p>
    <p class="normal">Having maintainable software is not about anticipating future requirements (do not do futurology!). It is about writing software that only addresses current requirements in such a way that it will be possible (and easy) to change later on. In other words, when designing, make sure that your decisions don't tie you down, and that you will be able to keep on building, but do not build more than what's necessary.</p>
    <p class="normal">It's usually tempting to not follow this idea in some cases in which we're aware of principles that we think might apply or save time for us. For example, later in the book, we'll review design patterns, which are common solutions for typical situations of object-oriented design. While it's important to study design patterns, we must refuse the temptation to apply them prematurely as it might fall into a violation of the YAGNI principle.</p>
    <p class="normal">For example, imagine you're <a id="_idIndexMarker173"/>creating a class to encapsulate the behavior of a component. You know it's needed, but then you think that more (and similar) requirements will come in the future, so it might be tempting to create a base class (as to define an interface with the methods that must be implemented), and then make the class you were just creating a subclass that implement that interface. This would be wrong for several reasons. First, all you need now is the class that was being created in the first place (investing more time in over-generalizing a solution that we don't know we'll need is not a good way of managing our resources). And then, that base class is being biased by the current requirements, so it'll likely not be the correct abstraction.</p>
    <p class="normal">The best approach would be to write only what's needed now in a way that doesn't hinder further improvements. If, later on, more requirements come in, we can think about creating a base class, abstract some methods, and perhaps we will discover a design pattern that emerged for our solution. This is also the way object-oriented design is supposed to work: bottom-up.</p>
    <p class="normal">Finally, I wanted to emphasize that YAGNI is an idea that also applies to software architecture (not just detailed code).</p>
    <h2 id="_idParaDest-72" class="title">KIS</h2>
    <p class="normal"><strong class="keyword">KIS</strong> (stands for <strong class="keyword">Keep It Simple</strong>) relates <a id="_idIndexMarker174"/>very much to the previous point. When you are designing a software component, avoid over-engineering it. Ask yourself if your solution is the minimal one that fits the problem.</p>
    <p class="normal">Implement minimal functionality that correctly solves the problem and does not complicate your solution more than is necessary. Remember, the simpler the design, the more maintainable it will be.</p>
    <p class="normal">This design principle is an idea we will want to keep in mind at all levels of abstraction, whether we are thinking of a high-level design, or addressing a particular line of code.</p>
    <p class="normal">At a high level, think about the components we are creating. Do we really need all of them? Does this module actually require being utterly extensible right now? Emphasize the last part—maybe we want to make that component extensible, but now is not the right time, or it is not appropriate to do so because we still do not have enough information to create the proper abstractions, and trying to come up with generic interfaces at this point will only lead to even worse problems.</p>
    <p class="normal">In terms of code, keeping <a id="_idIndexMarker175"/>it simple usually means using the smallest data structure that fits the problem. You will most likely find it in the standard library.</p>
    <p class="normal">Sometimes, we might over-complicate code, creating more functions or methods than are necessary. The following class creates a namespace from a set of keyword arguments that have been provided, but it has a rather complicated code interface:</p>
    <pre class="programlisting code"><code class="hljs-code"><span class="hljs-keyword">class</span><span class="hljs-class"> </span><span class="hljs-title">ComplicatedNamespace</span><span class="hljs-class">:</span>
    """A convoluted example of initializing an <span class="hljs-built_in">object</span> <span class="hljs-keyword">with</span> some properties."""
    ACCEPTED_VALUES = ("id_", "user", "location")
<span class="hljs-meta">    @classmethod</span>
    <span class="hljs-keyword">def</span><span class="hljs-function"> </span><span class="hljs-title">init_with_data</span><span class="hljs-function">(</span><span class="hljs-params">cls, **data</span><span class="hljs-function">):</span>
        instance = cls()
        <span class="hljs-keyword">for</span> key, value <span class="hljs-keyword">in</span> data.items():
            <span class="hljs-keyword">if</span> key <span class="hljs-keyword">in</span> cls.ACCEPTED_VALUES:
                <span class="hljs-built_in">setattr</span>(instance, key, value)
        <span class="hljs-keyword">return</span> instance
</code></pre>
    <p class="normal">Having an extra class method for initializing the object doesn't seem necessary. Then, the iteration and the call to <code class="Code-In-Text--PACKT-">setattr</code> inside it make things even more strange, and the interface that is presented to the user is not very clear:</p>
    <pre class="programlisting con"><code class="hljs-con"><span class="hljs-con-meta">&gt;</span><span class="bash">&gt;&gt; cn = ComplicatedNamespace.init_with_data(</span>
...     id_=42, user="root", location="127.0.0.1", extra="excluded"
... )
<span class="hljs-con-meta">&gt;</span><span class="bash">&gt;&gt; cn.id_, cn.user, cn.location</span>
(42, 'root', '127.0.0.1')
<span class="hljs-con-meta">&gt;</span><span class="bash">&gt;&gt; hasattr(cn, "extra")</span>
False
</code></pre>
    <p class="normal">The user has to know of the existence of this other method, which is not convenient. It would be better to keep it simple, and just initialize the object as we initialize any other object in Python (after all, there is a method for that) with the <code class="Code-In-Text--PACKT-">__init__</code> method:</p>
    <pre class="programlisting code"><code class="hljs-code"><span class="hljs-keyword">class</span><span class="hljs-class"> </span><span class="hljs-title">Namespace</span><span class="hljs-class">:</span>
    """Create an <span class="hljs-built_in">object</span> <span class="hljs-keyword">from</span> keyword arguments."""
 
    ACCEPTED_VALUES = ("id_", "user", "location")
 
    <span class="hljs-keyword">def</span><span class="hljs-function"> </span><span class="hljs-title">__init__</span><span class="hljs-function">(</span><span class="hljs-params">self, **data</span><span class="hljs-function">):</span>
        <span class="hljs-keyword">for</span> attr_name, attr_value <span class="hljs-keyword">in</span> data.items():
            <span class="hljs-keyword">if</span> attr_name <span class="hljs-keyword">in</span> self.ACCEPTED_VALUES:
                <span class="hljs-built_in">setattr</span>(self, attr_name, attr_value)
</code></pre>
    <p class="normal">Remember the Zen of Python: Simple is better than complex.</p>
    <p class="normal">There are many <a id="_idIndexMarker176"/>scenarios in Python in which we would like to keep our code simple. One of them relates to something we've explored before: code duplication. A common way to abstract code in Python is by using decorators (which we'll see later on, in <em class="chapterRef">Chapter 5</em>, <em class="italic">Using Decorators to Improve Our Code</em>). But what if we're trying to avoid duplication of a small section, let's say three lines of code? In that case, writing the decorator would probably take more lines and be more trouble for the simple duplicated lines we're trying to solve. In this case, apply common sense and be pragmatic. Accept that a small amount of duplication might be better than a complicated function (that is, of course, unless you find an even simpler way of removing the duplication and keeping the code simple!).</p>
    <p class="normal">As part of keeping the code simple, I would recommend avoiding advanced features of Python, like meta-classes (or anything related to meta-programming in general), because not only are these features hardly required (there are very special justifications for their use!), but also, they make the code much more complicated to read, and harder to maintain.</p>
    <h2 id="_idParaDest-73" class="title">EAFP/LBYL</h2>
    <p class="normal"><strong class="keyword">EAFP</strong> stands for <strong class="keyword">Easier to Ask Forgiveness than Permission</strong>, while <strong class="keyword">LBYL</strong> stands for <strong class="keyword">Look Before You Leap</strong>.</p>
    <p class="normal">The idea of <a id="_idIndexMarker177"/>EAFP is that we write our code so that it performs an action directly, and then we take care of the consequences later in case it doesn't work. Typically, this means try running some code, expecting it to work, but catching an exception if it doesn't, and then handling the corrective code on the <code class="Code-In-Text--PACKT-">except</code> block.</p>
    <p class="normal">This is the opposite of<a id="_idIndexMarker178"/> LBYL. As its name says, in the <em class="italic">look before you leap</em> approach, we first check what we are about to use. For example, we might want to check whether a file is available before trying to operate with it:</p>
    <pre class="programlisting code"><code class="hljs-code"><span class="hljs-keyword">if</span> os.path.exists(filename):
    <span class="hljs-keyword">with</span> <span class="hljs-built_in">open</span>(filename) <span class="hljs-keyword">as</span> f:
        ...
</code></pre>
    <p class="normal">The EAFP version of the previous code would look like this:</p>
    <pre class="programlisting code"><code class="hljs-code"><span class="hljs-keyword">try</span>:
    <span class="hljs-keyword">with</span> <span class="hljs-built_in">open</span>(filename) <span class="hljs-keyword">as</span> f:
        ...
<span class="hljs-keyword">except</span> FileNotFoundError <span class="hljs-keyword">as</span> e:
    logger.error(e)
</code></pre>
    <p class="normal">If you are coming from other languages, such as C, which doesn't have exceptions, then it's logical that will find the LBYL approach of more use. And in other languages such as C++, there is some discouragement towards the use of exceptions due to performance considerations, but this doesn't generally hold true in Python.</p>
    <p class="normal">Particular cases might of course apply, but most of the time, you'll find the EAFP version to be more intention-revealing. The code written this way would be easier to read, because it goes directly to the task needed instead of preventively checking conditions. Put another way, in the last example, you'll see a part of the code that tries to open a file and then process it. If the file doesn't exist, then we handle that case. In the first example, we'll see a function checking whether a file exists, and then trying to do something. You might argue that this is also clear, but we don't know for sure. Maybe the file being asked about is a different one or is a function that belongs to a different layer of the program, or a leftover, and such like. The second approach is less error-prone when you look at the code at first glance.</p>
    <p class="normal">You can apply both ideas as they make sense in your particular code, but in general, code written in an EAFP fashion would be easier to pick at first glance, so in case of doubt, I'd recommend you choose this variant.</p>
    <h1 id="_idParaDest-74" class="title">Inheritance in Python</h1>
    <p class="normal">In object-oriented software <a id="_idIndexMarker179"/>design, there are often discussions as to how to address some problems by using the main ideas of the paradigm (polymorphism, inheritance, and encapsulation).</p>
    <p class="normal">Probably the most commonly used of these ideas is inheritance—developers often start by creating a class hierarchy with the classes they are going to need and decide the methods each one should implement.</p>
    <p class="normal">While inheritance is a powerful concept, it does come with its perils. The main one is that every time we extend a base class, we are creating a new one that is tightly coupled with the parent. As we have already discussed, coupling is one of the things we want to reduce to a minimum when designing software.</p>
    <p class="normal">One of the main scenarios developers relate inheritance with is code reuse. While we should always embrace code reuse, it is not a good idea to force our design to use inheritance to reuse code just because we get the methods from the parent class for free. The proper way to reuse code is to have highly cohesive objects that can be easily composed and that could work on multiple contexts.</p>
    <h2 id="_idParaDest-75" class="title">When inheritance is a good decision</h2>
    <p class="normal">We have to be careful when<a id="_idIndexMarker180"/> creating a derived class because this is a double-edged sword—on the one hand, it has the advantage that we get all the code of the methods from the parent class for free, but on the other hand, we are carrying all of them to a new class, meaning that we might be placing too much functionality in a new definition.</p>
    <p class="normal">When creating a new subclass, we have to think if it is actually going to use all of the methods it has just inherited, as a heuristic to see whether the class is correctly defined. If instead, we find out that we do not need most of the methods, and have to override or replace them, this is a design mistake that could be caused by a number of reasons:</p>
    <ul>
      <li class="bullet">The superclass<a id="_idIndexMarker181"/> is vaguely defined and contains too much responsibility, instead of a well-defined interface</li>
      <li class="bullet">The subclass<a id="_idIndexMarker182"/> is not a proper specialization of the superclass it is trying to extend</li>
    </ul>
    <p class="normal">A good case for using inheritance is the type of situation when you have a class that defines certain components with its behavior that are defined by the interface of this class (its <code class="Code-In-Text--PACKT-">public</code> methods and attributes), and then you need to specialize this class in order to create objects that do the same but with something else added, or with some particular parts of its behavior changed.</p>
    <p class="normal">You can find examples of <a id="_idIndexMarker183"/>good uses of inheritance in the Python standard library itself. For example, in <a id="_idIndexMarker184"/>the <code class="Code-In-Text--PACKT-">http.server</code> package (<a href="https://docs.python.org/3/library/http.server.html#http.server.BaseHTTPRequestHandler"><span class="url">https://docs.python.org/3/library/http.server.html#http.server.BaseHTTPRequestHandler</span></a>), we can find a base class such as <code class="Code-In-Text--PACKT-">BaseHTTPRequestHandler</code>, and subclasses such as <code class="Code-In-Text--PACKT-">SimpleHTTPRequestHandler</code>, that extend this one by adding or changing part of its base interface.</p>
    <p class="normal">Speaking of interface definition, this is another good use of inheritance. When we want to enforce the interface of some objects, we can create an abstract base class that does not implement the behavior itself, but instead just defines the interface—every class that extends this one will have to implement these to be a proper subtype.</p>
    <p class="normal">Finally, another good case for inheritance is exceptions. We can see that the standard exception in Python derives from <code class="Code-In-Text--PACKT-">Exception</code>. This is what allows you to have a generic clause such as <code class="Code-In-Text--PACKT-">except Exception</code>, which will catch every possible error. The important point is the conceptual one; they are classes derived from <code class="Code-In-Text--PACKT-">Exception</code> because they are more specific exceptions. This also works in well-known libraries such as <code class="Code-In-Text--PACKT-">requests</code>, for instance, in which an <code class="Code-In-Text--PACKT-">HTTPError</code> is a <code class="Code-In-Text--PACKT-">RequestException</code>, which, in turn, is an <code class="Code-In-Text--PACKT-">IOError</code>.</p>
    <h2 id="_idParaDest-76" class="title">Anti-patterns for inheritance</h2>
    <p class="normal">If the previous section had<a id="_idIndexMarker185"/> to be summarized in a single word, it would be <em class="italic">specialization</em>. The <a id="_idIndexMarker186"/>correct use of inheritance is to <a id="_idIndexMarker187"/>specialize objects and create more detailed abstractions starting from base ones.</p>
    <p class="normal">The parent (or base) class is part of the <code class="Code-In-Text--PACKT-">public</code> definition of the new derived class. This is because the methods that are inherited will be part of the interface of this new class. For this reason, when we read the <code class="Code-In-Text--PACKT-">public</code> methods of a class, they have to be consistent with what the parent class defines.</p>
    <p class="normal">For example, if we see that a class derived from <code class="Code-In-Text--PACKT-">BaseHTTPRequestHandler</code> implements a method named <code class="Code-In-Text--PACKT-">handle()</code>, it would make sense because it is overriding one of the parents. If it had any other method whose name relates to an action that has to do with an HTTP request, then we could also think that is correctly placed (but we would not think that if we found something called <code class="Code-In-Text--PACKT-">process_purchase()</code> on that class).</p>
    <p class="normal">The previous illustration might seem obvious, but it is something that happens very often, especially when developers try to use inheritance with the sole goal of reusing code. In the next example, we will see a typical situation that represents a common anti-pattern in Python—there is a domain problem that has to be represented, and a suitable data structure is devised for that problem, but instead of creating an object that uses such a data structure, the object becomes the data structure itself.</p>
    <p class="normal">Let's see these problems more concretely through an example. Imagine we have a system for managing insurance, with a module in charge of applying policies to different clients. We need to keep in memory a set of customers that are being processed at the time in order to apply those changes before further processing or persistence. The basic operations we need are to store a new customer with its records as satellite data, apply a change to a policy, or edit some of the data, to name but a few. We also need to support a batch operation. That is, when something on the policy itself changes (the one this module is currently processing), we have to apply these changes overall to customers on the current<a id="_idIndexMarker188"/> transaction.</p>
    <p class="normal">Thinking in terms of the data <a id="_idIndexMarker189"/>structure we need, we realize that accessing the record for a particular customer in constant time is a nice trait. Therefore, something like <code class="Code-In-Text--PACKT-">policy_transaction[customer_id]</code> looks like a nice interface. From this, we might think that a <code class="Code-In-Text--PACKT-">subscriptable</code> object is a good idea, and further on, we might get carried away into thinking that the object we need is a dictionary:</p>
    <pre class="programlisting code"><code class="hljs-code"><span class="hljs-keyword">class</span><span class="hljs-class"> </span><span class="hljs-title">TransactionalPolicy</span><span class="hljs-class">(</span><span class="hljs-params">collections.UserDict</span><span class="hljs-class">):</span>
    """Example of an incorrect use of inheritance."""
    <span class="hljs-keyword">def</span><span class="hljs-function"> </span><span class="hljs-title">change_in_policy</span><span class="hljs-function">(</span><span class="hljs-params">self, customer_id, **new_policy_data</span><span class="hljs-function">):</span>
        self[customer_id].update(**new_policy_data)
</code></pre>
    <p class="normal">With this code, we can get information about a policy for a customer by its identifier:</p>
    <pre class="programlisting con"><code class="hljs-con"><span class="hljs-con-meta">&gt;</span><span class="bash">&gt;&gt; policy = TransactionalPolicy({</span>
...     "client001": { 
...         "fee": 1000.0, 
...         "expiration_date": datetime(2020, 1, 3), 
...     } 
... }) 
<span class="hljs-con-meta">&gt;</span><span class="bash">&gt;&gt; policy["client001"]</span>
{'fee': 1000.0, 'expiration_date': datetime.datetime(2020, 1, 3, 0, 0)}
<span class="hljs-con-meta">&gt;</span><span class="bash">&gt;&gt; policy.change_in_policy("client001", expiration_date=datetime(2020, 1, 4))</span>
<span class="hljs-con-meta">&gt;</span><span class="bash">&gt;&gt; policy["client001"]</span>
{'fee': 1000.0, 'expiration_date': datetime.datetime(2020, 1, 4, 0, 0)}
</code></pre>
    <p class="normal">Sure, we achieved the interface we wanted in the first place, but at what cost? Now, this class has a lot of extra behavior from carrying out methods that weren't necessary:</p>
    <pre class="programlisting con"><code class="hljs-con"><span class="hljs-con-meta">&gt;</span><span class="bash">&gt;&gt; dir(policy)</span>
[ # all magic and special method have been omitted for brevity...
 'change_in_policy', 'clear', 'copy', 'data', 'fromkeys', 'get', 'items', 'keys', 'pop', 'popitem', 'setdefault', 'update', 'values']
</code></pre>
    <p class="normal">There are (at least) two major problems with this design. On the one hand, the hierarchy is wrong. Creating a new class from a base one conceptually means that it's a more specific version of the class it's extending (hence the name). How is it that a <code class="Code-In-Text--PACKT-">TransactionalPolicy</code> is a <a id="_idIndexMarker190"/>dictionary? Does this make sense? Remember, this is part of <a id="_idIndexMarker191"/>the public interface of the object, so users will see this class and its hierarchy and will notice such an odd specialization as well as its public methods.</p>
    <p class="normal">This leads us to the second problem—coupling. The interface of the transactional policy now includes all methods from a dictionary. Does a transactional policy really need methods such as <code class="Code-In-Text--PACKT-">pop()</code> or <code class="Code-In-Text--PACKT-">items()</code>? However, there they are. They are also <code class="Code-In-Text--PACKT-">public</code>, so any user of this interface is entitled to call them, with whatever undesired side effect they may carry. More on this point—we don't really gain much by extending a dictionary. The only method it actually needs to update for all customers affected by a change in the current policy (<code class="Code-In-Text--PACKT-">change_in_policy()</code>) is not on the base class, so we will have to define it ourselves either way.</p>
    <p class="normal">This is a problem of mixing implementation objects with domain objects. A dictionary is an implementation object, a data structure, suitable for certain kinds of operation, and with a trade-off like all data structures. A transactional policy should represent something in the domain problem, an entity that is part of the problem we are trying to solve.</p>
    <div class="packt_tip">
      <p class="Tip--PACKT-">Don't mix implementation data structures with business domain classes in the same hierarchy.</p>
    </div>
    <p class="normal">Hierarchies like this one are incorrect, and just because we get a few magic methods from a base class (to make the object subscriptable by extending a dictionary) is not reason enough to create such an extension. Implementation classes should be extended solely when creating other, more specific, implementation classes. In other words, extend a dictionary if you want to create another (more specific, or slightly modified) dictionary. The same rule applies to classes of the domain problem.</p>
    <p class="normal">The correct solution here is to<a id="_idIndexMarker192"/> use composition. <code class="Code-In-Text--PACKT-">TransactionalPolicy</code> is not a<a id="_idIndexMarker193"/> dictionary—it uses a dictionary. It should store a dictionary in a <code class="Code-In-Text--PACKT-">private</code> attribute, and implement <code class="Code-In-Text--PACKT-">__getitem__()</code> by proxying from that dictionary and then only implementing the rest of the <code class="Code-In-Text--PACKT-">public</code> method it requires:</p>
    <pre class="programlisting code"><code class="hljs-code"><span class="hljs-keyword">class</span><span class="hljs-class"> </span><span class="hljs-title">TransactionalPolicy</span><span class="hljs-class">:</span>
    """Example refactored to use composition."""
    <span class="hljs-keyword">def</span><span class="hljs-function"> </span><span class="hljs-title">__init__</span><span class="hljs-function">(</span><span class="hljs-params">self, policy_data, **extra_data</span><span class="hljs-function">):</span>
        self._data = {**policy_data, **extra_data}
    <span class="hljs-keyword">def</span><span class="hljs-function"> </span><span class="hljs-title">change_in_policy</span><span class="hljs-function">(</span><span class="hljs-params">self, customer_id, **new_policy_data</span><span class="hljs-function">):</span>
        self._data[customer_id].update(**new_policy_data)
    <span class="hljs-keyword">def</span><span class="hljs-function"> </span><span class="hljs-title">__getitem__</span><span class="hljs-function">(</span><span class="hljs-params">self, customer_id</span><span class="hljs-function">):</span>
        <span class="hljs-keyword">return</span> self._data[customer_id]
    <span class="hljs-keyword">def</span><span class="hljs-function"> </span><span class="hljs-title">__len__</span><span class="hljs-function">(</span><span class="hljs-params">self</span><span class="hljs-function">):</span>
        <span class="hljs-keyword">return</span> <span class="hljs-built_in">len</span>(self._data)
</code></pre>
    <p class="normal">This way is not only conceptually correct, but also more extensible. If the underlying data structure (which, for now, is a dictionary) is changed in the future, callers of this object will not be affected, so long as the interface is maintained. This reduces coupling, minimizes ripple effects, allows for better refactoring (unit tests ought not to be changed), and makes the code more maintainable.</p>
    <h2 id="_idParaDest-77" class="title">Multiple inheritance in Python</h2>
    <p class="normal">Python supports<a id="_idIndexMarker194"/> multiple inheritance. As inheritance, when improperly used, leads to <a id="_idIndexMarker195"/>design problems, you could also expect that multiple inheritance will also yield even bigger problems when it's not correctly implemented.</p>
    <p class="normal">Multiple inheritance is, therefore, a double-edged sword. It can also be very beneficial in some cases. Just to be clear, there is nothing wrong with multiple inheritance—the only problem it has is that when it's not implemented correctly, it will multiply the problems.</p>
    <p class="normal">Multiple inheritance is a perfectly valid solution when used correctly, and this opens up new patterns (such as the adapter pattern we discussed in <em class="chapterRef">Chapter 9</em>, <em class="italic">Common Design Patterns</em>) and mixins.</p>
    <p class="normal">One of the <a id="_idIndexMarker196"/>most powerful applications of multiple inheritance is perhaps that <a id="_idIndexMarker197"/>which enables the creation of mixins. Before exploring mixins, we need to understand how multiple inheritance works, and how methods are resolved in a complex hierarchy.</p>
    <h3 id="_idParaDest-78" class="title">Method Resolution Order (MRO)</h3>
    <p class="normal">Some people <a id="_idIndexMarker198"/>don't like multiple inheritance because of the constraints it has in other programming languages, for instance, the so-called diamond problem. When a class extends from two or more classes, and all of those classes also extend from other base classes, the bottom ones will have multiple ways to resolve the methods coming from the top-level classes. The question is: Which of these implementations is used?</p>
    <p class="normal">Consider the following diagram, which has a structure with multiple inheritance. The top-level class has a class attribute and implements the <code class="Code-In-Text--PACKT-">__str__</code> method. Think of any of the concrete classes, for example, <code class="Code-In-Text--PACKT-">ConcreteModuleA12</code>—it extends from <code class="Code-In-Text--PACKT-">BaseModule1</code> and <code class="Code-In-Text--PACKT-">BaseModule2</code>, and each one of them will take the implementation of <code class="Code-In-Text--PACKT-">__str__</code> from <code class="Code-In-Text--PACKT-">BaseModule</code>. Which of these two methods is going to be the one for <code class="Code-In-Text--PACKT-">ConcreteModuleA12</code>?</p>
    <figure class="mediaobject"><img src="../Images/B16567_03_01.png" alt="Picture 1"/></figure>
    <p class="packt_figref">Figure 3.1: Method Resolution Order</p>
    <p class="normal">With the value of <a id="_idIndexMarker199"/>the class attribute, this will become evident:</p>
    <pre class="programlisting code"><code class="hljs-code"><span class="hljs-keyword">class</span><span class="hljs-class"> </span><span class="hljs-title">BaseModule</span><span class="hljs-class">:</span>
    module_name = "top"
    <span class="hljs-keyword">def</span><span class="hljs-function"> </span><span class="hljs-title">__init__</span><span class="hljs-function">(</span><span class="hljs-params">self, module_name</span><span class="hljs-function">):</span>
        self.name = module_name
    <span class="hljs-keyword">def</span><span class="hljs-function"> </span><span class="hljs-title">__str__</span><span class="hljs-function">(</span><span class="hljs-params">self</span><span class="hljs-function">):</span>
        <span class="hljs-keyword">return</span> f"{self.module_name}:{self.name}"
<span class="hljs-keyword">class</span><span class="hljs-class"> </span><span class="hljs-title">BaseModule1</span><span class="hljs-class">(</span><span class="hljs-params">BaseModule</span><span class="hljs-class">):</span>
    module_name = "module-<span class="hljs-number">1</span>"
<span class="hljs-keyword">class</span><span class="hljs-class"> </span><span class="hljs-title">BaseModule2</span><span class="hljs-class">(</span><span class="hljs-params">BaseModule</span><span class="hljs-class">):</span>
    module_name = "module-<span class="hljs-number">2</span>"
<span class="hljs-keyword">class</span><span class="hljs-class"> </span><span class="hljs-title">BaseModule3</span><span class="hljs-class">(</span><span class="hljs-params">BaseModule</span><span class="hljs-class">):</span>
    module_name = "module-<span class="hljs-number">3</span>"
<span class="hljs-keyword">class</span><span class="hljs-class"> </span><span class="hljs-title">ConcreteModuleA12</span><span class="hljs-class">(</span><span class="hljs-params">BaseModule1, BaseModule2</span><span class="hljs-class">):</span>
    """Extend <span class="hljs-number">1</span> &amp; <span class="hljs-number">2</span>"""
<span class="hljs-keyword">class</span><span class="hljs-class"> </span><span class="hljs-title">ConcreteModuleB23</span><span class="hljs-class">(</span><span class="hljs-params">BaseModule2, BaseModule3</span><span class="hljs-class">):</span>
    """Extend <span class="hljs-number">2</span> &amp; <span class="hljs-number">3</span>"""
</code></pre>
    <p class="normal">Now, let's test this to see what method is being called:</p>
    <pre class="programlisting con"><code class="hljs-con"><span class="hljs-con-meta">&gt;</span><span class="bash">&gt;&gt; str(ConcreteModuleA12("</span><span class="hljs-co -built_i">test</span><span class="bash">"))</span>
'module-1:test'
</code></pre>
    <p class="normal">There is no collision. Python resolves this by using an algorithm called C3 linearization or MRO, which <a id="_idIndexMarker200"/>defines a deterministic way in which methods are going to be called.</p>
    <p class="normal">In fact, we can specifically ask the class for its resolution order:</p>
    <pre class="programlisting con"><code class="hljs-con"><span class="hljs-con-meta">&gt;</span><span class="bash">&gt;&gt; [cls.__name__ </span><span class="hljs-con-keyword">for</span><span class="bash"> cls </span><span class="hljs-con-keyword">in</span><span class="bash"> ConcreteModuleA12.mro()]</span>
['ConcreteModuleA', 'BaseModule1', 'BaseModule2', 'BaseModule', 'object']
</code></pre>
    <p class="normal">Knowing about how the method is going to be resolved in a hierarchy can be used to our advantage when designing classes because we can make use of mixins.</p>
    <h3 id="_idParaDest-79" class="title">Mixins</h3>
    <p class="normal">A mixin <a id="_idIndexMarker201"/>is a base class that encapsulates some common behavior with the goal of reusing code. Typically, a mixin class is not useful on its own, and extending this class alone will certainly not work, because most of the time it depends on methods and properties that are defined in other classes. The idea is to use mixin classes along with other ones, through multiple inheritance, so that the methods or properties used on the mixin will be available.</p>
    <p class="normal">Imagine we have a simple parser that takes a <code class="Code-In-Text--PACKT-">string</code> and provides iteration over it by its values separated by hyphens (<code class="Code-In-Text--PACKT-">-</code>):</p>
    <pre class="programlisting code"><code class="hljs-code"><span class="hljs-keyword">class</span><span class="hljs-class"> </span><span class="hljs-title">BaseTokenizer</span><span class="hljs-class">:</span>
    <span class="hljs-keyword">def</span><span class="hljs-function"> </span><span class="hljs-title">__init__</span><span class="hljs-function">(</span><span class="hljs-params">self, str_token</span><span class="hljs-function">):</span>
        self.str_token = str_token
    <span class="hljs-keyword">def</span><span class="hljs-function"> </span><span class="hljs-title">__iter__</span><span class="hljs-function">(</span><span class="hljs-params">self</span><span class="hljs-function">):</span>
        <span class="hljs-keyword">yield</span> <span class="hljs-keyword">from</span> self.str_token.split("-")
</code></pre>
    <p class="normal">This is quite straightforward:</p>
    <pre class="programlisting con"><code class="hljs-con"><span class="hljs-con-meta">&gt;</span><span class="bash">&gt;&gt; tk = BaseTokenizer("28a2320b-fd3f-4627-9792-a2b38e3c46b0")</span>
<span class="hljs-con-meta">&gt;</span><span class="bash">&gt;&gt; list(tk)</span>
['28a2320b', 'fd3f', '4627', '9792', 'a2b38e3c46b0']
</code></pre>
    <p class="normal">But now we want the<a id="_idIndexMarker202"/> values to be sent in uppercase, without altering the base class. For this simple example, we could just create a new class, but imagine that a lot of classes are already extending from <code class="Code-In-Text--PACKT-">BaseTokenizer</code>, and we don't want to replace all of them. We can mix a new class into the hierarchy that handles this transformation:</p>
    <pre class="programlisting code"><code class="hljs-code"><span class="hljs-keyword">class</span><span class="hljs-class"> </span><span class="hljs-title">UpperIterableMixin</span><span class="hljs-class">:</span>
    <span class="hljs-keyword">def</span><span class="hljs-function"> </span><span class="hljs-title">__iter__</span><span class="hljs-function">(</span><span class="hljs-params">self</span><span class="hljs-function">):</span>
        <span class="hljs-keyword">return</span> <span class="hljs-built_in">map</span>(<span class="hljs-built_in">str</span>.upper, <span class="hljs-built_in">super</span>().__iter__())
<span class="hljs-keyword">class</span><span class="hljs-class"> </span><span class="hljs-title">Tokenizer</span><span class="hljs-class">(</span><span class="hljs-params">UpperIterableMixin, BaseTokenizer</span><span class="hljs-class">):</span>
    <span class="hljs-keyword">pass</span>
</code></pre>
    <p class="normal">The new <code class="Code-In-Text--PACKT-">Tokenizer</code> class is really simple. It doesn't need any code because it takes advantage of the mixin. This type of mixin acts as a sort of decorator. Based on what we just saw, <code class="Code-In-Text--PACKT-">Tokenizer</code> will take <code class="Code-In-Text--PACKT-">__iter__</code> from the mixin, and this one, in turn, delegates to the next class on the line (by calling <code class="Code-In-Text--PACKT-">super()</code>), which is <code class="Code-In-Text--PACKT-">BaseTokenizer</code>, but it converts its values to uppercase, thereby creating the desired effect.</p>
    <p class="normal">As we have discussed inheritance in Python, we've seen topics such as cohesion and coupling that are important to the design of our software. These concepts appear repeatedly in software design, and they can also be analyzed from the lens of functions and their arguments, which we explore in the next section.</p>
    <h1 id="_idParaDest-80" class="title">Arguments in functions and methods</h1>
    <p class="normal">In Python, functions can be <a id="_idIndexMarker203"/>defined to receive arguments in several different ways, and<a id="_idIndexMarker204"/> these arguments can also be provided by callers in multiple ways.</p>
    <p class="normal">There is also an industry-wide set of practices for defining interfaces in software engineering that closely relate to the definition of arguments in functions.</p>
    <p class="normal">In this section, we will first explore the mechanics of arguments in Python functions and then review the general principles of software engineering that relate to good practices regarding this subject to finally relate both concepts.</p>
    <h2 id="_idParaDest-81" class="title">How function arguments work in Python</h2>
    <p class="normal">First, let's review the<a id="_idIndexMarker205"/> particularities of how arguments are passed to functions in Python.</p>
    <p class="normal">By first understanding the possibilities that Python offers for handling parameters, we will be able to assimilate general rules more easily, and the idea is that after having done so, we can easily draw conclusions on what good patterns or idioms are when handling arguments. Then, we can identify in which scenarios the Pythonic approach is the correct one, and in which cases we might be abusing the features of the language.</p>
    <h3 id="_idParaDest-82" class="title">How arguments are copied to functions</h3>
    <p class="normal">The first rule in <a id="_idIndexMarker206"/>Python is that all arguments are passed by a value. Always. This <a id="_idIndexMarker207"/>means that when passing values to functions, they are assigned to the variables on the signature definition of the function to be later used on it.</p>
    <p class="normal">You will notice that a function may or may not mutate the parameters it receives, depending on their type. If we are passing <code class="Code-In-Text--PACKT-">mutable</code> objects, and the body of the function modifies this, then of course, we have the side effect that they will have been changed by the time the function returns.</p>
    <p class="normal">In the following, we can see the difference:</p>
    <pre class="programlisting con"><code class="hljs-con"><span class="hljs-con-meta">&gt;</span><span class="bash">&gt;&gt; def </span><span class="hljs-con-keyword">function</span><span class="bash">(argument):</span>
...     argument += " in function"
...     print(argument)
... 
<span class="hljs-con-meta">&gt;</span><span class="bash">&gt;&gt; immutable = "hello"</span>
<span class="hljs-con-meta">&gt;</span><span class="bash">&gt;&gt; </span><span class="hljs-con-keyword">function</span><span class="bash">(immutable)</span>
hello in function
<span class="hljs-con-meta">&gt;</span><span class="bash">&gt;&gt; mutable = list("hello")</span>
<span class="hljs-con-meta">&gt;</span><span class="bash">&gt;&gt; immutable</span>
'hello'
<span class="hljs-con-meta">&gt;</span><span class="bash">&gt;&gt; </span><span class="hljs-con-keyword">function</span><span class="bash">(mutable)</span>
['h', 'e', 'l', 'l', 'o', ' ', 'i', 'n', ' ', 'f', 'u', 'n', 'c', 't', 'i', 'o', 'n']
<span class="hljs-con-meta">&gt;</span><span class="bash">&gt;&gt; mutable</span>
['h', 'e', 'l', 'l', 'o', ' ', 'i', 'n', ' ', 'f', 'u', 'n', 'c', 't', 'i', 'o', 'n']
<span class="hljs-con-meta">&gt;</span><span class="bash">&gt;&gt;</span> 
</code></pre>
    <p class="normal">This might look like an inconsistency, but it's not. When we pass the first argument, a <code class="Code-In-Text--PACKT-">string</code>, this is assigned to the argument on the <code class="Code-In-Text--PACKT-">function</code>. Since <code class="Code-In-Text--PACKT-">string</code> objects are immutable, a statement such as <code class="Code-In-Text--PACKT-">argument += &lt;expression&gt;</code> will, in fact, create the new object, <code class="Code-In-Text--PACKT-">argument + &lt;expression&gt;</code>, and assign that back to the argument. At that point, an argument is just a local variable inside the scope of the function and has nothing to do with the original one in the caller.</p>
    <p class="normal">On the other hand, when<a id="_idIndexMarker208"/> we pass <code class="Code-In-Text--PACKT-">list</code>, which is a <code class="Code-In-Text--PACKT-">mutable</code> object, then that <a id="_idIndexMarker209"/>statement has a different meaning (it is equivalent to <code class="Code-In-Text--PACKT-">calling .extend()</code> on that <code class="Code-In-Text--PACKT-">list</code>). This operator acts by modifying the <code class="Code-In-Text--PACKT-">list</code> in place over a variable that holds a reference to the original <code class="Code-In-Text--PACKT-">list</code> object, hence modifying it. What happened in this second case is that the <code class="Code-In-Text--PACKT-">list</code>'s reference was passed by a value to the function. But since it's a reference, it is mutating the original <code class="Code-In-Text--PACKT-">list</code> object, so we see the mutation after the function has finished. It's roughly equivalent to this:</p>
    <pre class="programlisting con"><code class="hljs-con"><span class="hljs-con-meta">&gt;</span><span class="bash">&gt;&gt; a = list(range(5))</span>
<span class="hljs-con-meta">&gt;</span><span class="bash">&gt;&gt; b = a  </span><span class="hljs-con-comment"># the function call is doing something like this</span>
<span class="hljs-con-meta">&gt;</span><span class="bash">&gt;&gt; b.append(99)</span>
<span class="hljs-con-meta">&gt;</span><span class="bash">&gt;&gt; b</span>
[0, 1, 2, 3, 4, 99]
<span class="hljs-con-meta">&gt;</span><span class="bash">&gt;&gt; a</span>
[0, 1, 2, 3, 4, 99]
</code></pre>
    <p class="normal">We have to be careful when dealing with <code class="Code-In-Text--PACKT-">mutable</code> objects because it can lead to unexpected side effects. Unless you are absolutely sure that it is correct to manipulate <code class="Code-In-Text--PACKT-">mutable</code> arguments in this way, I would recommend avoiding it and going for alternatives without these problems.</p>
    <div class="packt_tip">
      <p class="Tip--PACKT-">Don't mutate function arguments. In general, try to avoid unnecessary side effects in functions as much as possible.</p>
    </div>
    <p class="normal">Arguments in Python can be passed by position, as in many other programming languages, but also by keyword. This means that we can explicitly tell the function which values we want for which of its parameters. The only caveat is that after a parameter is passed by a keyword, the rest that follow must also be passed this way, otherwise, <code class="Code-In-Text--PACKT-">SyntaxError</code> will be raised.</p>
    <h3 id="_idParaDest-83" class="title">Variable number of arguments</h3>
    <p class="normal">Python, as well as<a id="_idIndexMarker210"/> other languages, has built-in functions and constructions that can take a variable number of arguments. Consider, for example, <code class="Code-In-Text--PACKT-">string</code> interpolation functions (whether it be by using the <code class="Code-In-Text--PACKT-">%</code> operator or the <code class="Code-In-Text--PACKT-">format</code> method for strings), which follow a similar structure to the <code class="Code-In-Text--PACKT-">printf</code> function in C, a first positional parameter with the <code class="Code-In-Text--PACKT-">string</code> format, followed by any number of arguments that will be placed on the markers of that formatting string.</p>
    <p class="normal">Besides taking advantage of these functions that are available in Python, we can also create our own, which will work in a similar fashion. In this section, we will cover the basic principles of functions with a variable number of arguments, along with some recommendations, so that in the next section, we can explore how to use these features to our advantage when dealing with common problems, issues, and constraints that functions might have if they have too many arguments.</p>
    <p class="normal">For a variable number of <code class="Code-In-Text--PACKT-">positional</code> arguments, the star symbol (<code class="Code-In-Text--PACKT-">*</code>) is used, preceding the name of the variable that is packing those arguments. This works through the packing mechanism of Python.</p>
    <p class="normal">Let's say there is a function that takes three positional arguments. In one part of the code, we conveniently happen to have the arguments we want to pass to the function inside a <code class="Code-In-Text--PACKT-">list</code>, in the same order as they are expected by the function. </p>
    <p class="normal">Instead of passing them one by one by the position (that is, <code class="Code-In-Text--PACKT-">list[0]</code> to the first element, <code class="Code-In-Text--PACKT-">list[1]</code> to the second, and so on), which would be really un-Pythonic, we can use the packing mechanism and pass them all together in a single instruction:</p>
    <pre class="programlisting con"><code class="hljs-con"><span class="hljs-con-meta">&gt;</span><span class="bash">&gt;&gt; def f(first, second, third):</span>
...     print(first)
...     print(second)
...     print(third)
... 
<span class="hljs-con-meta">&gt;</span><span class="bash">&gt;&gt; l = [1, 2, 3]</span>
<span class="hljs-con-meta">&gt;</span><span class="bash">&gt;&gt; f(*l)</span>
1
2
3
</code></pre>
    <p class="normal">The nice thing about <a id="_idIndexMarker211"/>the packing mechanism is that it also works the other way around. If we want to extract the values of a <code class="Code-In-Text--PACKT-">list</code> to variables, by their respective position, we can assign them like this:</p>
    <pre class="programlisting con"><code class="hljs-con"><span class="hljs-con-meta">&gt;</span><span class="bash">&gt;&gt; a, b, c = [1, 2, 3]</span>
<span class="hljs-con-meta">&gt;</span><span class="bash">&gt;&gt; a</span>
1
<span class="hljs-con-meta">&gt;</span><span class="bash">&gt;&gt; b</span>
2
<span class="hljs-con-meta">&gt;</span><span class="bash">&gt;&gt; c</span>
3
</code></pre>
    <p class="normal">Partial unpacking is also possible. Let's say we are just interested in the first values of a sequence (this can be a <code class="Code-In-Text--PACKT-">list</code>, <code class="Code-In-Text--PACKT-">tuple</code>, or something else), and after some point we just want the rest to be kept together. We can assign the variables we need and leave the rest under a packaged <code class="Code-In-Text--PACKT-">list</code>. The order in which we unpack is not limited. If there is nothing to place in one of the unpacked subsections, the result will be an empty <code class="Code-In-Text--PACKT-">list</code>. Try the following examples on a Python terminal and also explore how unpacking works with generators as well:</p>
    <pre class="programlisting con"><code class="hljs-con"><span class="hljs-con-meta">&gt;</span><span class="bash">&gt;&gt; def show(e, rest):</span>
...     print("Element: {0} - Rest: {1}".format(e, rest))
... 
<span class="hljs-con-meta">&gt;</span><span class="bash">&gt;&gt; first, *rest = [1, 2, 3, 4, 5]</span>
<span class="hljs-con-meta">&gt;</span><span class="bash">&gt;&gt; show(first, rest)</span>
Element: 1 - Rest: [2, 3, 4, 5]
<span class="hljs-con-meta">&gt;</span><span class="bash">&gt;&gt; *rest, last = range(6)</span>
<span class="hljs-con-meta">&gt;</span><span class="bash">&gt;&gt; show(last, rest)</span>
Element: 5 - Rest: [0, 1, 2, 3, 4]
<span class="hljs-con-meta">&gt;</span><span class="bash">&gt;&gt; first, *middle, last = range(6)</span>
<span class="hljs-con-meta">&gt;</span><span class="bash">&gt;&gt; first</span>
0
<span class="hljs-con-meta">&gt;</span><span class="bash">&gt;&gt; middle</span>
[1, 2, 3, 4]
<span class="hljs-con-meta">&gt;</span><span class="bash">&gt;&gt; last</span>
5
<span class="hljs-con-meta">&gt;</span><span class="bash">&gt;&gt; first, last, *empty = 1, 2</span>
<span class="hljs-con-meta">&gt;</span><span class="bash">&gt;&gt; first</span>
1
<span class="hljs-con-meta">&gt;</span><span class="bash">&gt;&gt; last</span>
2
<span class="hljs-con-meta">&gt;</span><span class="bash">&gt;&gt; empty</span>
[]
</code></pre>
    <p class="normal">One of the best uses for <a id="_idIndexMarker212"/>unpacking variables can be found in iteration. When we have to iterate over a sequence of elements, and each element is, in turn, a sequence, it is a good idea to unpack at the same time each element is being iterated over. To see an example of this in action, we are going to pretend that we have a function that receives a <code class="Code-In-Text--PACKT-">list</code> of database rows, and that it is in charge of creating users out of that data. The first implementation takes the values to construct the user with from the position of each column in the row, which is not idiomatic at all. The second implementation uses unpacking while iterating:</p>
    <pre class="programlisting code"><code class="hljs-code"><span class="hljs-keyword">from</span> dataclasses <span class="hljs-keyword">import</span> dataclass
 
 
USERS = [
    (i, f"first_name_{i}", f"last_name_{i}")
    <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-number">1_000</span>)
]
 
<span class="hljs-meta">@dataclass</span>
<span class="hljs-keyword">class</span><span class="hljs-class"> </span><span class="hljs-title">User</span><span class="hljs-class">:</span>
    user_id: <span class="hljs-built_in">int</span>
    first_name: <span class="hljs-built_in">str</span>
    last_name: <span class="hljs-built_in">str</span>
<span class="hljs-keyword">def</span><span class="hljs-function"> </span><span class="hljs-title">bad_users_from_rows</span><span class="hljs-function">(</span><span class="hljs-params">dbrows</span><span class="hljs-function">) -&gt; list:</span>
    """A bad case (non-pythonic) of creating ``User``s <span class="hljs-keyword">from</span> DB rows."""
    <span class="hljs-keyword">return</span> [User(row[<span class="hljs-number">0</span>], row[<span class="hljs-number">1</span>], row[<span class="hljs-number">2</span>]) <span class="hljs-keyword">for</span> row <span class="hljs-keyword">in</span> dbrows]
<span class="hljs-keyword">def</span><span class="hljs-function"> </span><span class="hljs-title">users_from_rows</span><span class="hljs-function">(</span><span class="hljs-params">dbrows</span><span class="hljs-function">) -&gt; list:</span>
    """Create ``User``s <span class="hljs-keyword">from</span> DB rows."""
    <span class="hljs-keyword">return</span> [
        User(user_id, first_name, last_name)
        <span class="hljs-keyword">for</span> (user_id, first_name, last_name) <span class="hljs-keyword">in</span> dbrows
    ]
</code></pre>
    <p class="normal">Notice that the second version is much easier to read. In the first version of the function (<code class="Code-In-Text--PACKT-">bad_users_from_rows</code>), we have data expressed in the form <code class="Code-In-Text--PACKT-">row[0]</code>, <code class="Code-In-Text--PACKT-">row[1]</code>, and <code class="Code-In-Text--PACKT-">row[2]</code>, which doesn't tell us anything about what they are. On the other hand, variables such as <code class="Code-In-Text--PACKT-">user_id</code>, <code class="Code-In-Text--PACKT-">first_name</code>, and <code class="Code-In-Text--PACKT-">last_name</code> speak for themselves.</p>
    <p class="normal">We could also use the star operator to pass all the <code class="Code-In-Text--PACKT-">positional</code> parameters from the <code class="Code-In-Text--PACKT-">tuple</code> when constructing the <code class="Code-In-Text--PACKT-">User</code> object:</p>
    <pre class="programlisting code"><code class="hljs-code">[User(*row) <span class="hljs-keyword">for</span> row <span class="hljs-keyword">in</span> dbrows]
</code></pre>
    <p class="normal">We can leverage this kind<a id="_idIndexMarker213"/> of functionality to our advantage when designing our own functions.</p>
    <p class="normal">An example of this that we can find in the standard library lies in the <code class="Code-In-Text--PACKT-">max</code> function, which is defined as follows:</p>
    <pre class="programlisting code"><code class="hljs-code"><span class="hljs-built_in">max</span>(...)
    <span class="hljs-built_in">max</span>(iterable, *[, default=obj, key=func]) -&gt; value
    <span class="hljs-built_in">max</span>(arg1, arg2, *args, *[, key=func]) -&gt; value
    
    With a single iterable argument, <span class="hljs-keyword">return</span> its biggest item. The
    default keyword-only argument specifies an <span class="hljs-built_in">object</span> to <span class="hljs-keyword">return</span> <span class="hljs-keyword">if</span>
    the provided iterable <span class="hljs-keyword">is</span> empty.
    With two <span class="hljs-keyword">or</span> more arguments, <span class="hljs-keyword">return</span> the largest argument.
</code></pre>
    <p class="normal">There is a similar notation, with two stars (<code class="Code-In-Text--PACKT-">**</code>) for keyword arguments. If we have a dictionary and we pass it with a double star to a function, what it will do is pick the keys as the name for the parameter, and pass the <code class="Code-In-Text--PACKT-">value</code> for that <code class="Code-In-Text--PACKT-">key</code> as the <code class="Code-In-Text--PACKT-">value</code> for that <code class="Code-In-Text--PACKT-">parameter</code> in that function.</p>
    <p class="normal">For instance, check this out:</p>
    <pre class="programlisting code"><code class="hljs-code">function(**{"key": "value"})
</code></pre>
    <p class="normal">It is the same as the following:</p>
    <pre class="programlisting code"><code class="hljs-code">function(key="value")
</code></pre>
    <p class="normal">Conversely, if we define a function with a parameter starting with two star symbols, the opposite will happen—keyword-provided parameters will be packed into a dictionary:</p>
    <pre class="programlisting con"><code class="hljs-con"><span class="hljs-con-meta">&gt;</span><span class="bash">&gt;&gt; def </span><span class="hljs-con-keyword">function</span><span class="bash">(**kwargs):</span>
...     print(kwargs)
... 
<span class="hljs-con-meta">&gt;</span><span class="bash">&gt;&gt; </span><span class="hljs-con-keyword">function</span><span class="bash">(key="value")</span>
{'key': 'value'}
</code></pre>
    <p class="normal">This feature of Python is really powerful as it lets us choose dynamically the values we want to pass to a function. However, abusing this functionality, and making excessive use of it, will render the code harder to understand.</p>
    <p class="normal">When we define a<a id="_idIndexMarker214"/> function as in the previous example, on which one of its parameters has a double star, meaning that arbitrary keyword arguments are allowed, Python will place them in a dictionary that we can access at our discretion. From the previously defined function, the <code class="Code-In-Text--PACKT-">kwargs</code> argument is a dictionary. A good recommendation is to not use this dictionary to extract particular values from it.</p>
    <p class="normal">Namely, don't look for particular keys of the dictionary. Instead, extract these arguments directly on the function definition.</p>
    <p class="normal">For example, instead of doing something like this:</p>
    <pre class="programlisting code"><code class="hljs-code"><span class="hljs-keyword">def</span><span class="hljs-function"> </span><span class="hljs-title">function</span><span class="hljs-function">(</span><span class="hljs-params">**kwargs</span><span class="hljs-function">):</span>  <span class="hljs-comment"># wrong</span>
    timeout = kwargs.get("timeout", DEFAULT_TIMEOUT)
    ...
</code></pre>
    <p class="normal">Let Python do the unpacking and set the default argument at the signature:</p>
    <pre class="programlisting code"><code class="hljs-code"><span class="hljs-keyword">def</span><span class="hljs-function"> </span><span class="hljs-title">function</span><span class="hljs-function">(</span><span class="hljs-params">timeout=DEFAULT_TIMEOUT, **kwargs</span><span class="hljs-function">):</span>  <span class="hljs-comment"># better</span>
    ...
</code></pre>
    <p class="normal">In this example, timeout is not strictly keyword-only. We'll see how to make keyword-only arguments in a few sections, but the idea that should prevail is to not manipulate the <code class="Code-In-Text--PACKT-">kwargs</code> dictionary, and instead execute proper unpacking at the signature level.</p>
    <p class="normal">Before diving into keyword-only arguments, let's start with those that are positional-only first.</p>
    <h3 id="_idParaDest-84" class="title">Positional-only parameters</h3>
    <p class="normal">As we have <a id="_idIndexMarker215"/>seen already, positional arguments (variable or not) are those that are first provided to functions in Python. The values for these arguments are interpreted based on the position they're provided to the function, meaning they're assigned respectively to the parameters in the function's definition.</p>
    <p class="normal">If we don't make use any special syntax when defining the function arguments, by default, they can be passed by position or keyword. For example, in the following function, all calls to the function are equivalent:</p>
    <pre class="programlisting con"><code class="hljs-con"><span class="hljs-con-meta">&gt;</span><span class="bash">&gt;&gt; def my_function(x, y):</span>
...     print(f"{x=}, {y=}")
...
<span class="hljs-con-meta">&gt;</span>&gt;&gt; my_function(1, 2) 
x=1, y=2 
<span class="hljs-con-meta">&gt;</span>&gt;&gt; my_function(x=1, y=2) 
x=1, y=2
<span class="hljs-con-meta">&gt;</span>&gt;&gt; my_function(y=2, x=1) 
x=1, y=2
<span class="hljs-con-meta">&gt;</span><span class="bash">&gt;&gt; my_function(1, y=2)</span>
x=1, y=2
</code></pre>
    <p class="normal">This means, in the first case, we pass the values <code class="Code-In-Text--PACKT-">1</code> and <code class="Code-In-Text--PACKT-">2</code>, and by their position, they're assigned to the parameters <code class="Code-In-Text--PACKT-">x</code> and <code class="Code-In-Text--PACKT-">y</code>, respectively. With this syntax, nothing stops us from passing the same arguments with their keyword (even in reverse order), should that be needed (for example, to be more explicit). The only constraint here is that if we pass one argument as a keyword, all the following ones must be provided as a keyword as well (the last example wouldn't work with the parameters reversed).</p>
    <p class="normal">However, starting from<a id="_idIndexMarker216"/> Python 3.8 (PEP-570), new syntax was introduced that allows parameters to be defined that are strictly positional (meaning we can't provide their name when passing values by). To use this, a <code class="Code-In-Text--PACKT-">/</code> must be added to the end of the last positional-only argument). For example:</p>
    <pre class="programlisting con"><code class="hljs-con"><span class="hljs-con-meta">&gt;</span><span class="bash">&gt;&gt; def my_function(x, y, /):</span>
...     print(f"{x=}, {y=}")
...
<span class="hljs-con-meta">&gt;</span><span class="bash">&gt;&gt; my_function(1, 2)</span>
x=1, y=2
<span class="hljs-con-meta">&gt;</span><span class="bash">&gt;&gt; my_function(x=1, y=2)</span>
Traceback (most recent call last):
 File "&lt;stdin&gt;", line 1, in &lt;module&gt;
TypeError: my_function() got some positional-only arguments passed as keyword arguments: 'x, y'
</code></pre>
    <p class="normal">Note how the first invocation of the function worked (just as before), but from now on, any attempt to pass a keyword argument will fail. The exception that is raised will tell us in its message the positional-only parameters that attempted to be passed as keyword-only. In general, using keyword arguments makes the code more readable because you'll know at all times which values are provided for which arguments, but there could be situations in which this syntax is useful, for example, in cases where the names of the arguments aren't meaningful (because they can't be, not because we did a poor job on naming them!), and attempting to use their name would be counterproductive.</p>
    <p class="normal">To give a really<a id="_idIndexMarker217"/> simple example, imagine a function to check whether two words are anagrams. That function takes two strings and does some processing. It doesn't really matter how we name those two strings (and frankly their order doesn't matter, it would just be a first word and a second word). Trying to come up with good names for those arguments wouldn't make much sense, nor would assigning their keyword values when calling the function.</p>
    <p class="normal">For the rest of the cases, this should be avoided.</p>
    <div class="packt_tip">
      <p class="Tip--PACKT-">Don't force meaningful arguments to be positional-only.</p>
    </div>
    <p class="normal">In very particular cases, positional-only parameters might be a good idea, but most of the time this shouldn't be required. But in general, this isn't a feature you'd want to use many times because we can take advantage of passing arguments as keywords, because that will make it easier to understand which values are being passed to which parameters. For that reason, the opposite case is something you'd want to do more often, making the arguments keyword-only, as we'll discuss in the next section.</p>
    <h3 id="_idParaDest-85" class="title">Keyword-only arguments</h3>
    <p class="normal">Analogous to the previous<a id="_idIndexMarker218"/> feature is the possibility of making some arguments keyword-only. This probably makes more sense, because we can find meaning when assigning the keyword argument on a function call, and now we can enforce this explicitness.</p>
    <p class="normal">In this case (and contrary to the previous one), we use the <code class="Code-In-Text--PACKT-">*</code> symbol to signal when the keyword-only arguments start. In the function signature, everything that comes after the variable number of positional arguments (<code class="Code-In-Text--PACKT-">*args</code>) will be keyword-only.</p>
    <p class="normal">For example, the following definition takes two positional arguments, then any number of positional parameters, and then two final arguments, which are to be passed as keyword-only. The last one has a default value (although this is not mandatory, as in the third case):</p>
    <pre class="programlisting con"><code class="hljs-con"><span class="hljs-con-meta">&gt;</span><span class="bash">&gt;&gt; def my_function(x, y, *args, kw1, kw2=0):</span>
...     print(f"{x=}, {y=}, {kw1=}, {kw2=}")
...
<span class="hljs-con-meta">&gt;</span><span class="bash">&gt;&gt; my_function(1, 2, kw1=3, kw2=4)</span>
x=1, y=2, kw1=3, kw2=4
<span class="hljs-con-meta">&gt;</span><span class="bash">&gt;&gt; my_function(1, 2, kw1=3)</span>
x=1, y=2, kw1=3, kw2=0
</code></pre>
    <p class="normal">The function calls make it clear how this behaves. If we didn't want any number of positional arguments after the first two, we can simply put <code class="Code-In-Text--PACKT-">*</code> instead of <code class="Code-In-Text--PACKT-">*args</code>.</p>
    <p class="normal">This functionality is useful for extending functions or classes that are already defined (and being used) in a backward-compatible fashion. If, for example, you have a function that takes two arguments, and it's being called several times throughout the code (sometimes with the parameters by position, sometimes by keyword), and you'd want to add a third parameter, you'd<a id="_idIndexMarker219"/> have to set a default for it, if you want the current calls to keep working. But even better would be to make this last parameter keyword-only, so new calls have to make it explicit that they intend to use the new definition.</p>
    <p class="normal">Along the same lines, this functionality is also useful when refactoring and keeping compatibility. Imagine you have a function that you're replacing with a new implementation, but you keep the original function as a wrapper, in order to preserve compatibility. Let's analyze the difference between a function call such as the following:</p>
    <pre class="programlisting code"><code class="hljs-code">result = my_function(<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-literal">True</span>)
</code></pre>
    <p class="normal">And another call as follows:</p>
    <pre class="programlisting code"><code class="hljs-code">result = my_function(<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, use_new_implementation=<span class="hljs-literal">True</span>)
</code></pre>
    <p class="normal">It's clear that the second example is much more explicit, and you get a clear idea of what's going on as soon as you glance at the function call. For that reason, it makes sense to make the new parameter (which determines which implementation to use) keyword-only.</p>
    <p class="normal">In cases like this, where there's an argument that really needs context in order to be understood, making that parameter keyword-only is a good idea.</p>
    <p class="normal">These are the basics in terms of how arguments and parameters work in Python functions. Now we can use that knowledge to discuss this in terms of good design ideas.</p>
    <h2 id="_idParaDest-86" class="title">The number of arguments in functions</h2>
    <p class="normal">In this section, we agree <a id="_idIndexMarker220"/>on the idea that having functions or methods that take too many arguments is a sign of bad design (a code smell). Then, we propose ways of dealing with this issue.</p>
    <p class="normal">The first alternative is a more general principle of software design—reification (creating a new object for all of those arguments that we are passing, which is probably the abstraction we are missing). Compacting multiple arguments into a new object is not a solution specific to Python, but rather something that we can apply in any programming language.</p>
    <p class="normal">Another option would be to use the Python-specific features we saw in the previous section, making use of variable positional and keyword arguments to create functions that have a dynamic signature. While this might be a Pythonic way of proceeding, we have to be careful not to abuse the feature, because we might be creating something that is so dynamic that it is hard to maintain. In this case, we should take a look at the body of the function. Regardless<a id="_idIndexMarker221"/> of the signature, and whether the parameters seem to be correct, if the function is doing too many different things responding to the values of the parameters, then it is a sign that it has to be broken down into multiple smaller functions (remember, functions should do one thing, and one thing only!).</p>
    <h3 id="_idParaDest-87" class="title">Function arguments and coupling</h3>
    <p class="normal">The more arguments<a id="_idIndexMarker222"/> a function signature has, the more likely this one is going to be tightly coupled with the caller function.</p>
    <p class="normal">Let's say we have two functions, <code class="Code-In-Text--PACKT-">f1</code>, and <code class="Code-In-Text--PACKT-">f2</code>, and the latter takes five parameters. The more parameters <code class="Code-In-Text--PACKT-">f2</code> takes, the more difficult it would be for anyone trying to call that function to gather all that information and pass it along so that it can work properly.</p>
    <p class="normal">Now, <code class="Code-In-Text--PACKT-">f1</code> seems to have all of this information because it can call it correctly. From this, we can derive two conclusions. First, <code class="Code-In-Text--PACKT-">f2</code> is probably a leaky abstraction, which means that since <code class="Code-In-Text--PACKT-">f1</code> knows everything that <code class="Code-In-Text--PACKT-">f2</code> requires, it can pretty much figure out what it is doing internally and will be able to do it by itself. </p>
    <p class="normal">So, all in all, <code class="Code-In-Text--PACKT-">f2</code> is not abstracting that much. Second, it looks like <code class="Code-In-Text--PACKT-">f2</code> is only useful to <code class="Code-In-Text--PACKT-">f1</code>, and it is hard to imagine using this function in a different context, making it harder to reuse.</p>
    <p class="normal">When functions have a more general interface and are able to work with higher-level abstractions, they become more reusable.</p>
    <p class="normal">This applies to all sorts of functions and object methods, including the <code class="Code-In-Text--PACKT-">__init__</code> method for classes. The presence of a method like this could generally (but not always) mean that a new higher-level abstraction should be passed instead, or that there is a missing object.</p>
    <div class="packt_tip">
      <p class="Tip--PACKT-">If a function needs too many parameters to work properly, consider it a code smell.</p>
    </div>
    <p class="normal">In fact, this is such a design problem that static analysis tools such as <code class="Code-In-Text--PACKT-">pylint</code> (discussed in <em class="chapterRef">Chapter 1</em>, <em class="italic">Introduction, Code Formatting, and Tools</em>) will, by default, raise a warning when they encounter such a case. When this happens, don't suppress the warning—refactor it instead.</p>
    <h3 id="_idParaDest-88" class="title">Compact function signatures that take too many arguments</h3>
    <p class="normal">Suppose we find a<a id="_idIndexMarker223"/> function that requires too many parameters. We know that we cannot leave the code base like that, and a refactor process is imperative. But what are the options?</p>
    <p class="normal">Depending on the case, some of the following rules might apply. This is by no means extensive, but it does provide an idea of how to solve some scenarios that occur quite often.</p>
    <p class="normal">Sometimes, there is an easy way to change parameters if we can see that most of them belong to a common object. For example, consider a function call like this one:</p>
    <pre class="programlisting code"><code class="hljs-code">track_request(request.headers, request.ip_addr, request.request_id)
</code></pre>
    <p class="normal">Now, the function might or might not take additional arguments, but something is really obvious here: All of the parameters depend upon <code class="Code-In-Text--PACKT-">request</code>, so why not pass the <code class="Code-In-Text--PACKT-">request</code> object instead? This is a simple change, but it significantly improves the code. The correct function call should be <code class="Code-In-Text--PACKT-">track_request(request)</code>—not to mention that, semantically, it also makes much more sense.</p>
    <p class="normal">While passing around parameters like this is encouraged, in all cases where we pass <code class="Code-In-Text--PACKT-">mutable</code> objects to functions, we must be really careful about side effects. The function we are calling should not make any modifications to the object we are passing because that will mutate the object, creating an undesired side effect. Unless this is actually the desired effect (in which case, it must be made explicit), this kind of behavior is discouraged. Even when we actually want to change something on the object we are dealing with, a better alternative would be to copy it and return a (new) modified version of it.</p>
    <div class="packt_tip">
      <p class="Tip--PACKT-">Work with immutable objects and avoid side effects as much as possible.</p>
    </div>
    <p class="normal">This brings us to a similar topic—grouping parameters. In the previous example, the parameters were already grouped, but the group (in this case, the <code class="Code-In-Text--PACKT-">request</code> object) was not being used. But other cases are not as obvious as that one, and we might want to group all the data in the parameters in a single object that acts as a <code class="Code-In-Text--PACKT-">container</code>. Needless to say, this grouping has to make sense. The idea here is to <em class="italic">reify</em>: Create the abstraction that was missing from our design.</p>
    <p class="normal">If the previous strategies don't work, as a last resort we can change the signature of the function to accept a variable number of arguments. If the number of arguments is too big, using <code class="Code-In-Text--PACKT-">*args</code> or <code class="Code-In-Text--PACKT-">**kwargs</code> will make things harder to follow, so we have to make sure that the interface is properly documented and correctly used, but in some cases, this is worth doing.</p>
    <p class="normal">It's true that a function <a id="_idIndexMarker224"/>defined with <code class="Code-In-Text--PACKT-">*args</code> and <code class="Code-In-Text--PACKT-">**kwargs</code> is really flexible and adaptable, but the disadvantage is that it loses its signature, and with that, part of its meaning, and almost all of its legibility. We have seen examples of how names for variables (including function arguments) make the code much easier to read. If a function will take any number of arguments (positional or keyword), we might find out that when we want to take a look at that function in the future, we probably won't know exactly what it was supposed to do with its parameters, unless it has a very good docstring.</p>
    <div class="packt_tip">
      <p class="Tip--PACKT-">Try to only define functions with the most generic arguments (<code class="Code-In-Text--PACKT-">*args</code>, <code class="Code-In-Text--PACKT-">**kwargs</code>) when you want a perfect wrapper over another function (for example, a method that will call <code class="Code-In-Text--PACKT-">super()</code>, or a decorator).</p>
    </div>
    <h1 id="_idParaDest-89" class="title">Final remarks on good practices for software design</h1>
    <p class="normal">Good software design involves <a id="_idIndexMarker225"/>a combination of following good practices of software engineering and taking advantage of most of the features of the language. There is great value in using everything that Python has to offer, but there is also a great risk of abusing this and trying to fit complex features into simple designs.</p>
    <p class="normal">In addition to this general principle, it would be good to add some final recommendations.</p>
    <h2 id="_idParaDest-90" class="title">Orthogonality in software</h2>
    <p class="normal">This word is very<a id="_idIndexMarker226"/> general and can have multiple meanings or interpretations. In math, orthogonal means that two elements are independent. If two vectors are orthogonal, their scalar product is zero. It also means they are not related at all. A change in one of them doesn't affect the other one at all. That's the way we should think about our software.</p>
    <p class="normal">Changing a module, class, or function should have no impact on the outside world to that component that is being modified. This is, of course, highly desirable, but not always possible. But even for cases where it's not possible, a good design will try to minimize the impact as much as possible. We have seen ideas such as separation of concerns, cohesion, and isolation of components.</p>
    <p class="normal">In terms of the runtime structure of software, orthogonality can be interpreted as the process of making changes (or side effects) local. This means, for instance, that calling a method on an object should not alter the internal state of other (unrelated) objects. We have already (and will continue to do so) emphasized in this book the importance of minimizing side effects in our code.</p>
    <p class="normal">In the example with the mixin class, we created a tokenizer object that returned an <code class="Code-In-Text--PACKT-">iterable</code>. The fact that the <code class="Code-In-Text--PACKT-">__iter__</code> method returned a new generator increases the chances that all three classes (the base, the mixing, and the concrete class) are orthogonal. If this had returned something in concrete (a <code class="Code-In-Text--PACKT-">list</code>, let's say), this would have created a dependency on the rest of the classes, because when we changed the <code class="Code-In-Text--PACKT-">list</code> to something else, we might have needed to update other parts of the code, revealing that the classes were not as independent as they should be.</p>
    <p class="normal">Let's show you a quick example. Python allows passing functions by parameter because they are just regular objects. We can use this feature to achieve some orthogonality. We have a function that calculates a price, including taxes and discounts, but afterward we want to format the final price that's obtained:</p>
    <pre class="programlisting code"><code class="hljs-code"><span class="hljs-keyword">def</span><span class="hljs-function"> </span><span class="hljs-title">calculate_price</span><span class="hljs-function">(</span><span class="hljs-params">base_price: </span><span class="hljs-built_in">float</span><span class="hljs-params">, tax: </span><span class="hljs-built_in">float</span><span class="hljs-params">, discount: </span><span class="hljs-built_in">float</span><span class="hljs-function">) -&gt; </span><span class="hljs-built_in">float</span><span class="hljs-params">:</span>
<span class="hljs-function">    return (base_price * (1 + tax)) * (1 - discount)</span>
<span class="hljs-function">def show_price(price:</span> <span class="hljs-built_in">float</span>) -&gt; <span class="hljs-built_in">str</span>:
    <span class="hljs-keyword">return</span> "$ {<span class="hljs-number">0</span>:,<span class="hljs-number">.2</span>f}".<span class="hljs-built_in">format</span>(price)
<span class="hljs-keyword">def</span><span class="hljs-function"> </span><span class="hljs-title">str_final_price</span><span class="hljs-function">(</span>
<span class="hljs-params">    base_price: </span><span class="hljs-built_in">float</span><span class="hljs-params">, tax: </span><span class="hljs-built_in">float</span><span class="hljs-params">, discount: </span><span class="hljs-built_in">float</span><span class="hljs-params">, fmt_function=</span><span class="hljs-built_in">str</span>
<span class="hljs-function">) -&gt; str:</span>
    <span class="hljs-keyword">return</span> fmt_function(calculate_price(base_price, tax, discount))
</code></pre>
    <p class="normal">Notice that the top-level function is composing two orthogonal functions. One thing to notice is how we calculate <code class="Code-In-Text--PACKT-">price</code>, which is how the other one is going to be represented. Changing one does not change the other. If we don't pass anything in particular, it will <a id="_idIndexMarker227"/>use <code class="Code-In-Text--PACKT-">string</code> conversion as the default representation function, and if we choose to pass a custom function, the resulting <code class="Code-In-Text--PACKT-">string</code> will change. However, changes in <code class="Code-In-Text--PACKT-">show_price</code> do not affect <code class="Code-In-Text--PACKT-">calculate_price</code>. We can make changes to either function, knowing that the other one will remain as it was:</p>
    <pre class="programlisting con"><code class="hljs-con"><span class="hljs-con-meta">&gt;</span><span class="bash">&gt;&gt; str_final_price(10, 0.2, 0.5)</span>
'6.0'
<span class="hljs-con-meta">&gt;</span><span class="bash">&gt;&gt; str_final_price(1000, 0.2, 0)</span>
'1200.0'
<span class="hljs-con-meta">&gt;</span><span class="bash">&gt;&gt; str_final_price(1000, 0.2, 0.1, fmt_function=show_price)</span>
'$ 1,080.00'
</code></pre>
    <p class="normal">There is an interesting quality aspect that relates to orthogonality. If two parts of the code are orthogonal, it means one can change without affecting the other. This implies that the part that changed has unit tests that are also orthogonal to the unit tests of the rest of the application. Under this assumption, if those tests pass, we can assume (up to a certain degree) that the application is correct without needing full regression testing.</p>
    <p class="normal">More broadly, orthogonality can be thought of in terms of features. Two functionalities of the application can be totally independent so that they can be tested and released without having to worry that one might break the other (or the rest of the code, for that matter). Imagine that the project requires a new authentication mechanism (<code class="Code-In-Text--PACKT-">oauth2</code>, let's say, but just for the sake of the example), and at the same time another team is also working on a new report. </p>
    <p class="normal">Unless there is something fundamentally wrong in that system, neither of those features should impact the other. Regardless of which one of those gets merged first, the other one should not be affected at all.</p>
    <h2 id="_idParaDest-91" class="title">Structuring the code</h2>
    <p class="normal">The way code is<a id="_idIndexMarker228"/> organized also impacts the performance of the team and its maintainability.</p>
    <p class="normal">In particular, having large files with lots of definitions (classes, functions, constants, and so on) is a bad practice and should be discouraged. This doesn't mean going to the extreme of placing one definition per file, but a good code base will structure and arrange components by similarity.</p>
    <p class="normal">Luckily, most of the time, changing a large file into smaller ones is not a hard task in Python. Even if other multiple parts of the code depend on definitions made on that file, this can be broken down into a package, and will maintain total compatibility. The idea would be to <a id="_idIndexMarker229"/>create a new directory with a <code class="Code-In-Text--PACKT-">__init__.py</code> file on it (this will make it a Python package). Alongside this file, we will have multiple files with all the particular definitions each one requires (fewer functions and classes grouped by a certain criterion). Then, the <code class="Code-In-Text--PACKT-">__init__.py</code> file will import from all the other files the definitions it previously had (which is what guarantees its compatibility). Additionally, these definitions can be mentioned in the <code class="Code-In-Text--PACKT-">__all__</code> variable of the module to make them exportable.</p>
    <p class="normal">There are many advantages to this. Other than the fact that each file will be easier to navigate, and things will be easier to find, we could argue that it will be more efficient for the following reasons:</p>
    <ul>
      <li class="bullet">It contains fewer objects to parse and load into memory when the module is imported.</li>
      <li class="bullet">The module itself will probably be importing fewer modules because it needs fewer dependencies, like before.</li>
    </ul>
    <p class="normal">It also helps to have a convention for the project. For example, instead of placing <code class="Code-In-Text--PACKT-">constants</code> in all of the files, we can create a file specific to the constant values to be used in the project, and import it from there:</p>
    <pre class="programlisting gen"><code class="hljs">from myproject.constants import CONNECTION_TIMEOUT
</code></pre>
    <p class="normal">Centralizing information in this way makes it easier to reuse code and helps to avoid inadvertent duplication.</p>
    <p class="normal">More details about separating modules and creating Python packages will be discussed in <em class="chapterRef">Chapter 10</em>, <em class="italic">Clean Architecture</em>, when we explore this in the context of software architecture.</p>
    <h1 id="_idParaDest-92" class="title">Summary</h1>
    <p class="normal">In this chapter, we have explored several principles to achieve a clean design. Understanding that the code is part of the design is key to achieving high-quality software. This and the following chapter are focused precisely on that.</p>
    <p class="normal">With these ideas, we can now construct more robust code. For example, by applying DbC, we can create components that are guaranteed to work within their constraints. More importantly, if errors occur, this will not happen out of the blue, but instead, we will have a clear idea of who the offender is and which part of the code broke the contract. This compartmentalization is key to effective debugging.</p>
    <p class="normal">Along similar lines, each component can be made more robust if it defends itself from malicious intent or incorrect input. Although this idea goes in a different direction from DbC, it might complement it very well. Defensive programming is a good idea, especially for critical parts of the application.</p>
    <p class="normal">For both approaches (DbC and defensive programming), it's important to correctly handle assertions. Keep in mind how they should be used in Python, and don't use assertions as part of the control flow logic of the program. Don't catch this exception, either.</p>
    <p class="normal">Speaking of exceptions, it's important to know how and when to use them, and the most important concept here is to avoid using exception as a control flow (<code class="Code-In-Text--PACKT-">go-to</code>) kind of construction.</p>
    <p class="normal">We have explored a recurrent topic in object-oriented design—deciding between using inheritance or composition. The main lesson here is not to use one over the other, but to use whichever option is better; we should also avoid some common anti-patterns, which we might often see in Python (especially given its highly dynamic nature).</p>
    <p class="normal">Finally, we discussed the number of arguments in functions, along with heuristics for a clean design, always with the particularities of Python in mind.</p>
    <p class="normal">These concepts are fundamental design ideas that lay the foundations for what's coming in the next chapter. We need to first understand these ideas so that we can move on to more advanced topics, such as SOLID principles.</p>
    <h1 id="_idParaDest-93" class="title">References</h1>
    <p class="normal">Here is a list of information you can refer to:</p>
    <ul>
      <li class="bullet"><em class="italic">PEP-570</em>: <em class="italic">Python Positional-Only Parameters</em> (<a href="https://www.python.org/dev/peps/pep-0570/"><span class="url">https://www.python.org/dev/peps/pep-0570/</span></a>)</li>
      <li class="bullet"><em class="italic">PEP-3102</em>: <em class="italic">Keyword-Only Arguments</em> (<a href="https://www.python.org/dev/peps/pep-3102/"><span class="url">https://www.python.org/dev/peps/pep-3102/</span></a>)</li>
      <li class="bullet"><em class="italic">Object-Oriented Software Construction</em>, <em class="italic">Second Edition</em>, written by <em class="italic">Bertrand Meyer</em></li>
      <li class="bullet"><em class="italic">The Pragmatic Programmer: From Journeyman to Master</em>, by <em class="italic">Andrew Hunt</em> and <em class="italic">David Thomas</em>, published by <em class="italic">Addison-Wesley</em>, 2000.</li>
      <li class="bullet"><em class="italic">PEP-316</em>: <em class="italic">Programming by Contract for Python</em> (<a href="https://www.python.org/dev/peps/pep-0316/"><span class="url">https://www.python.org/dev/peps/pep-0316/</span></a>)</li>
      <li class="bullet"><em class="italic">REAL 01</em>: <em class="italic">The Most Diabolical Python Antipattern</em> (<a href="https://realpython.com/blog/python/the-most-diabolical-python-antipattern/"><span class="url">https://realpython.com/blog/python/the-most-diabolical-python-antipattern/</span></a>)</li>
      <li class="bullet"><em class="italic">PEP-3134</em>: <em class="italic">Exception Chaining and Embedded Tracebacks</em>: (<a href="https://www.python.org/dev/peps/pep-3134/"><span class="url">https://www.python.org/dev/peps/pep-3134/</span></a>)</li>
      <li class="bullet"><em class="italic">Idiomatic Python: EAFP versus LBYL</em>: <a href="https://blogs.msdn.microsoft.com/pythonengineering/2016/06/29/idiomatic-python-eafp-versus-lbyl/"><span class="url">https://blogs.msdn.microsoft.com/pythonengineering/2016/06/29/idiomatic-python-eafp-versus-lbyl/</span></a></li>
      <li class="bullet"><em class="italic">Composition vs. Inheritance: How to Choose?</em> <a href="https://www.thoughtworks.com/insights/blog/composition-vs-inheritance-how-choose"><span class="url">https://www.thoughtworks.com/insights/blog/composition-vs-inheritance-how-choose</span></a></li>
      <li class="bullet"><em class="italic">Python HTTP</em>: <a href="https://docs.python.org/3/library/http.server.html#http.server.BaseHTTPRequestHandler"><span class="url">https://docs.python.org/3/library/http.server.html#http.server.BaseHTTPRequestHandler</span></a></li>
      <li class="bullet">Source reference for exceptions in the requests library: <a href="http://docs.python-requests.org/en/master/_modules/requests/exceptions/"><span class="url">http://docs.python-requests.org/en/master/_modules/requests/exceptions/</span></a></li>
      <li class="bullet"><em class="italic">Code Complete: A Practical Handbook of Software Construction</em>, <em class="italic">Second Edition</em>, written by <em class="italic">Steve McConnell</em></li>
    </ul>
  </div>
</body></html>