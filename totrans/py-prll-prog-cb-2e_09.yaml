- en: Python Debugging and Testing
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: This last chapter will introduce two important software engineering topics—debugging
    and testing—that are important steps in the software development process.
  prefs: []
  type: TYPE_NORMAL
- en: The first part of the chapter is focused on code debugging. A bug is a mistake
    in a program and can cause different problems that may be more or less serious
    depending on the situation. To encourage programmers to search for bugs, special
    software tools are used, called **debuggers***;* using these software tools, we
    have the ability to find errors or malfunctions within a program by taking advantage
    of specific debugging functions, an activity that exists precisely for identifying
    the portion of software affected by a bug.
  prefs: []
  type: TYPE_NORMAL
- en: In the second part, the main topic is *software testing: * it is a process used
    to identify deficiencies of *correctness*, *completeness*, and *reliability* in
    a software product that is being developed.
  prefs: []
  type: TYPE_NORMAL
- en: In this context, we will, therefore, examine the three most important Python
    tools for debugging code in action. These are `winpdb-reborn`, which involves
    debugging with a visualization tool; `pdb`, the debugger from the Python standard
    library; and `rpdb`, where `r` stands for remote, meaning that it is code debugging
    from a remote machine*.*
  prefs: []
  type: TYPE_NORMAL
- en: 'Regarding software testing, we will examine the following tools: `unittest`
    and `nose`.'
  prefs: []
  type: TYPE_NORMAL
- en: These are frameworks for developing unit tests, whereby the unit is the minimum
    component of a program within an independent operation.
  prefs: []
  type: TYPE_NORMAL
- en: 'In this chapter, we will cover the following topics:'
  prefs: []
  type: TYPE_NORMAL
- en: What is debugging?
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: What is software testing?
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Debugging using Winpdb Reborn
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Interacting with `pdb`
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Implementing `rpdb` for debugging
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Dealing with `unittest`
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Application testing using `nose`
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: What is debugging?
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The term *debugging* indicates the activity of identifying the portion of code
    in which one or more errors (bugs) are detected in software following its use.
  prefs: []
  type: TYPE_NORMAL
- en: The error can be localized during the testing phase of the program; that is
    when it is still in the development phase and is not yet ready to be used by the
    end-user, or during the use of the program by the latter. After finding the error,
    the debugging phase ensues and identifies the software part in which the error
    lies, which is sometimes very complex.
  prefs: []
  type: TYPE_NORMAL
- en: Nowadays, this activity is supported by specific applications and debuggers,
    which show the execution to the programmer using step-by-step software instructions,
    allowing the viewing and analysis of the inputs and outputs of the program itself at
    the same time.
  prefs: []
  type: TYPE_NORMAL
- en: Before these tools were available for the activity of identifying and correcting
    errors (and even now, in the absence of them), the simplest (but also least effective)
    techniques for code inspection were printing a file or printing the instructions
    on the screen that the program was executing.
  prefs: []
  type: TYPE_NORMAL
- en: Debugging is one of the most important operations for the development of a program.
    It is often extremely difficult due to the complexity of the software that is
    being developed. It is even delicate due to the risk of introducing new errors
    or behaviors that are not in line with those desired in the attempt to correct
    those for which the activity was undertaken.
  prefs: []
  type: TYPE_NORMAL
- en: 'Although the task of perfecting software using debugging is unique every time
    and constitutes a story in itself, some general principles are always applicable.
    In particular, in the context of software applications, it is possible to recognize
    the following four *debugging phases*, summarized in the following diagram:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/16de8223-a2d3-4378-8677-70527c657df8.png)'
  prefs: []
  type: TYPE_IMG
- en: Debugging phases
  prefs: []
  type: TYPE_NORMAL
- en: Of course, Python offers the developer numerous debugging tools (see [https://wiki.python.org/moin/PythonDebuggingTools](https://wiki.python.org/moin/PythonDebuggingTools)
    for a list of Python debuggers). In this chapter, we will consider Winpdb Reborn, `rpdb`, and
    `pdb`.
  prefs: []
  type: TYPE_NORMAL
- en: What is software testing?
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: As mentioned in the introduction of this chapter, software testing is a process
    used to identify deficiencies of correctness, completeness, and reliability in
    a software product that is being developed.
  prefs: []
  type: TYPE_NORMAL
- en: With this activity, we, therefore, want to ensure the quality of the product
    by searching search for defects, or a sequence of instructions and procedures
    that, when executed with particular input data and in particular operating environments,
    generate malfunctions. A malfunction is a behavior of the software that is not
    expected by the user; therefore, it is different from the specifications and from
    the implicit or explicit requirements defined for such applications.
  prefs: []
  type: TYPE_NORMAL
- en: The purpose of testing is, therefore, to detect defects through malfunctions,
    so as to minimize the probability of such malfunctions occurring in the normal
    use of the software product. Testing cannot establish that a product functions
    correctly under all possible conditions of execution, but it can highlight defects
    under specific conditions.
  prefs: []
  type: TYPE_NORMAL
- en: In fact, given the impossibility of testing all the input combinations and the
    possible software and hardware environments in which the application may be operating,
    the probability of malfunctions cannot be reduced to zero, but it must be reduced
    to a minimum in order to be acceptable to the user.
  prefs: []
  type: TYPE_NORMAL
- en: A particular type of software testing is the unit test (which we will learn
    about in this chapter), the purpose of which is to isolate each part of a program
    and show its correctness and completeness in the implementation. It also promptly
    brings out any defects so that they can be corrected easily before integration.
  prefs: []
  type: TYPE_NORMAL
- en: Furthermore, the unit test lowers the costs—in terms of time and resources—of
    identifying and correcting defects, compared to achieving the same result by performing
    tests on the entire application.
  prefs: []
  type: TYPE_NORMAL
- en: Debugging using Winpdb Reborn
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '**Winpdb Reborn** is one of the most important and well-known Python debuggers.
    The major strength of this debugger is managing the debugging of thread-based
    code.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Winpdb Reborn is based on the RPDB2 debugger, while Winpdb is the GUI frontend
    to RPDB2 (see: [https://github.com/bluebird75/winpdb/blob/master/rpdb2.py](https://github.com/bluebird75/winpdb/blob/master/rpdb2.py)).'
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The most commonly used way to install Winpdb Reborn (*release 2.0.0 dev5*)
    is via `pip`, so from your console, you need to type the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: Also, if you have not already installed wxPython in your Python distribution,
    then you need to do so. wxPython is a cross-platform GUI toolkit for the Python
    language.
  prefs: []
  type: TYPE_NORMAL
- en: For Python Version 2.x, please refer to [https://sourceforge.net/projects/wxpython/files/wxPython/](https://sourceforge.net/projects/wxpython/files/wxPython/).
    For Python Version 3.x, wxPython is automatically installed as a dependency via
    `pip`.
  prefs: []
  type: TYPE_NORMAL
- en: In the next section, we will examine the main features and the graphical interface
    of Winpdb Reborn through a simple example of its use.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Suppose we want to analyze the following Python application, which uses the
    threading library. An example that is very similar to the following example is
    already described in the *How to define a thread subclass* section of [Chapter
    2](c95be391-9558-4d2d-867e-96f61fbc5bbf.xhtml), *Thread-Based Parallelism*. In
    the following example, we use the `MyThreadClass` class to create and manage the
    execution of three threads. Here is the entire code to debug:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: 'Let''s have a look at the following steps:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Open your console and type in the name of the folder containing the sample
    file, `winpdb_reborn_code_example.py`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: This works on macOS as well, but you have to use a framework build of Python.
    If you are using Winpdb Reborn with Anaconda, simply use `pythonw` instead of
    `python` to launch a Winpdb Reborn session.
  prefs: []
  type: TYPE_NORMAL
- en: 'If the installation was successful, then the Winpdb Reborn GUI should open:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/2fba89a5-4840-407f-8266-63aab36b85ba.png)'
  prefs: []
  type: TYPE_IMG
- en: Windpdb Reborn GUI
  prefs: []
  type: TYPE_NORMAL
- en: 'As you can see in the following screenshot, we have inserted two breakpoints
    (using the Breakpoints menu), in both line 12 and line 23 (highlighted in red):'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '***![](img/5a2ccb87-7020-4948-8b20-80a3f393b972.png)***'
  prefs: []
  type: TYPE_NORMAL
- en: Code breakpoints
  prefs: []
  type: TYPE_NORMAL
- en: To learn about what a breakpoint is, move on to the *There's more...* section
    of this recipe.
  prefs: []
  type: TYPE_NORMAL
- en: 'Remaining in the Source window, we place the mouse on line 23, where we have
    inserted the second breakpoint, and press the *F8* key, and then the *F5* key.
    The breakpoint allows the code to be executed up to the selected line. As you
    can see, Namespace indicates that we are considering the instance of the `MyThreadClass`
    class, with `thread#1` as an argument:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/1a27af00-4468-449f-88ee-ee0c6b9bb6a4.png)'
  prefs: []
  type: TYPE_IMG
- en: Namespace
  prefs: []
  type: TYPE_NORMAL
- en: Another fundamental feature of the debugger is the **Step Into** capability,
    which is the ability to inspect not only the code being debugged but also the
    library functions and the subroutines called for execution.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Before you start to delete the previous breakpoints (Menu | Breakpoints | Clear
    All), insert the new breakpoint on line 28:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/b27f1402-d9ab-4924-bfa2-df62a894b50c.png)'
  prefs: []
  type: TYPE_IMG
- en: Line 28 breakpoint
  prefs: []
  type: TYPE_NORMAL
- en: Finally, press the *F5* key and the application will be executed up to the breakpoint
    of line **28**.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Then, press *F7*. Here, the source window no longer shows our sample code, but
    rather, the `threading` library we are using (see the next screenshot).
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Therefore, the Breakpoints functionality, together with that of Step Into, not
    only allow the debugging of the code in question but also allow the inspection
    of all the library functions and any other subroutines used:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/70c4308b-78e8-4633-8a9c-7435c583eb9c.png)'
  prefs: []
  type: TYPE_IMG
- en: Line 28 Source window after executing Step Into
  prefs: []
  type: TYPE_NORMAL
- en: How it works...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this first example, we have become familiar with the Winpdb Reborn tool.
    This debugging environment (like every environment in general) allows you to stop
    program execution at precise points, inspect the execution stack, the contents
    of the variables, the status of the objects created, and much more.
  prefs: []
  type: TYPE_NORMAL
- en: 'To use Winpdb Reborn, just take a note of the following basic steps:'
  prefs: []
  type: TYPE_NORMAL
- en: Set some breakpoints in the source code (the Source window).
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Inspect the functions through the Step Into function.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: View the status of the variables (the Namespace window) and the execution stack
    (the Stack window).
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The breakpoints are set by simply double-clicking the desired line with the
    left mouse button (you will see the selected line underlined in red). As a general
    warning, it is inadvisable to have multiple commands on the same line; otherwise,
    it will not be possible to associate breakpoints with some of them.
  prefs: []
  type: TYPE_NORMAL
- en: When you use the right mouse button, you can selectively *disable breakpoints* without
    removing them (the red highlighting will disappear). To remove all the breakpoints
    instead, use the Clear All command, which is present in the Breakpoints menu, as
    mentioned previously.
  prefs: []
  type: TYPE_NORMAL
- en: 'When the first breakpoint is reached, it is good to keep an eye on the following
    views in the point of the program that is being analyzed:'
  prefs: []
  type: TYPE_NORMAL
- en: The Stack view shows the contents of the execution stack, where all the instances
    of various methods that are currently suspended appear. Typically, the one at
    the bottom of the stack is the main method and the one at the top of the stack
    is the method containing the breakpoint that has been reached.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The Namespace view shows the local variables of the method and allows you to
    inspect the values. If the variables refer to objects, then it is possible to
    find out the unique identifier of the object and inspect its status.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: In general, the execution of a program can be managed with different modes associated
    with the icon (or the *Fx* keys) present on the Winpdb Reborn command bar.
  prefs: []
  type: TYPE_NORMAL
- en: 'Finally, we''ll point out the following important execution methods:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Step Into (*F7* key): This resumes the execution of the program one line at
    a time, and invocations of library methods or subroutines.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Return (*F12* key): This allows you to resume execution at the exact point
    where the Step Into function was activated.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Next (*F6* key): This resumes the execution of the program one line at a time
    without stopping in any methods invoked.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Run to Line (*F8* key) This runs the program until it stops (waiting for new
    commands) at the indicated line.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: There's more...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'As you saw in the Winpdb Reborn GUI screenshot, the GUI is divided into five
    main windows:'
  prefs: []
  type: TYPE_NORMAL
- en: Namespace: In this window, the names of entities are displayed, which are various
    variables and identifiers that are defined by the program and used in the source
    file.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Threads: The current thread of the execution is shown, and it is characterized
    by the **TID**  (short for **T**hread **ID**entification) fields, the name of
    the thread, and the thread status.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Stack: This is where the execution stack of the program to be analyzed is shown.
    Stacks are also known as**Last In, First Out** (**LIFO**) data structures, as
    the last element inserted is the first to be removed. When a program calls a function,
    the called function must know how to return the calling control, so the return
    address of the calling function is entered into the program execution stack. The
    program execution stack also contains the memory for the local variables used
    at each invocation of the function.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Console: This is a command-line interface, thus allowing a textual interaction
    between the user and Winpdb Reborn.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Source:This window shows the source code to debug. By scrolling along the lines
    of code, it is also possible to insert the breakpoints by pressing *F9 *once you
    are on the line of code of interest.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The breakpoint is a very basic debugging tool. In fact, it allows you to run
    a program, but with the possibility of interrupting it at the desired point or
    when certain conditions occur, in order to acquire information on a running program***.***
  prefs: []
  type: TYPE_NORMAL
- en: 'There are multiple debugging strategies. Here, we list some of them:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Reproduce the error**: Identify the input data that caused it.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Simplify the error**: Identify the simplest possible data that caused it.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Divide and** **rule**: Perform the main proceeding in step-over mode until
    the anomaly occurs. The method that caused it is the last performed before it
    was possible to find the problem, so we can re-debug by doing step-in into that
    particular invocation, and proceeding again with step-over following the method''s
    instructions.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Proceed consciously**: During debugging, you constantly compare the current
    values of the variables with the ones you would expect.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Check all the details**: Don''t overlook the details while debugging. It
    is best to make a note if you notice any discrepancies in the source code.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Correct the errors**: Correct the error only if you are sure you have understood
    the problem well.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: See also
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: A good Winpdb Reborn tutorial can be found at [http://heather.cs.ucdavis.edu/~matloff/winpdb.html#usewin](http://heather.cs.ucdavis.edu/~matloff/winpdb.html#usewin).
  prefs: []
  type: TYPE_NORMAL
- en: Interacting with pdb
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '`pdb` is a Python module for performing interactive debugging.'
  prefs: []
  type: TYPE_NORMAL
- en: 'The main features of `pdb` are as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: The use of breakpoints
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Interactive processing of the source code line by line
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Stack frame analysis
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The debugger is implemented through the `pdb` class. For this reason, it can
    be easily extended with new features.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'No installation of `pdb` is required because it is part of the Python standard
    library. It can be launched with the following main use pattern:'
  prefs: []
  type: TYPE_NORMAL
- en: Interacting with the command line
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Using the Python interpreter
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Inserting a directive (that is, a `pdb` statement) in the code to debug
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Interacting with the command line
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The simplest method is simply passing the name of your program as input. For
    example, for the `pdb_test.py` program, this is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: 'By executing from the command line, `pdb` loads the source file to be analyzed
    and stops its execution at the first statement found. In this case, the debug
    stops at line `1` (that is, at the definition of the`Pdb_test` class):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: Using the Python interpreter
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The `pdb` module can be used in interactive mode by using the `run()` command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: In this case, the `run()` statement is from the debugger and will stop the execution
    before evaluating the first expression.
  prefs: []
  type: TYPE_NORMAL
- en: Inserting a directive in the code to debug
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'For a long-running process, where the problem occurs much later in the program
    execution, it would be much more convenient to start the debugger within the program
    using the `pdb set_trace()` directive:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: '`set_trace()` can be called at any point in the program to debug. For example,
    it can be called based on conditions, exception handlers, or a specific branch
    of control instructions.'
  prefs: []
  type: TYPE_NORMAL
- en: 'In this case, the output is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: The code run stops, exactly after the `pdb.set_trace()` statement completes.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'To interact with `pdb`, you need to use its language, which allows you to move
    around the code, examine and modify the values of the variables, insert breakpoints,
    or move through stack calls:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Use the `where` command (or alternatively, the compact form, `w`) to view which
    line of code is running and the call stack. In this case, this is on line 17 in
    the `go()` method of the `pdb_test.py` module:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: 'Inspect the lines of code near the current location (indicated by an arrow)
    by using `list`. In the default mode, `11` rows are listed around the current
    one (five before and five after):'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: 'If `list` receives two parameters, then they are interpreted as the first and
    last lines to be displayed:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: 'Use `up` (or `u`) to move to older frames on the stack and `down` (or `d`)
    to move to more recent stack frames:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: How it works...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The debugging activity is carried out following the flow of the running program
    (tracing). In each line of code, the coder displays the operations performed by
    the instructions in real time and the values recorded in the variables. In this
    way, the developer can check that everything is working properly or identify the
    cause of a malfunction.
  prefs: []
  type: TYPE_NORMAL
- en: Each programming language has its own debugger. However, there is no valid debugger
    for all programming languages because each language has its own syntax and grammar.
    The debugger executes the step-by-step source code. Therefore, the debugger must
    know the rules of the language, like the compiler.
  prefs: []
  type: TYPE_NORMAL
- en: There's more...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The most useful `pdb` commands, along with their short forms, to keep in mind
    while working with the Python debugger are as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '| **Command** | **Action** |'
  prefs: []
  type: TYPE_TB
- en: '| `args` | Prints the argument list of the current function |'
  prefs: []
  type: TYPE_TB
- en: '| `break` | Creates a breakpoint (requires parameters)  |'
  prefs: []
  type: TYPE_TB
- en: '| `continue` | Continues program execution |'
  prefs: []
  type: TYPE_TB
- en: '| `help` | Lists the commands (or help) for a command (as a parameter) |'
  prefs: []
  type: TYPE_TB
- en: '| `jump` | Sets the next line to be executed |'
  prefs: []
  type: TYPE_TB
- en: '| `list` | Prints the source code around the current line |'
  prefs: []
  type: TYPE_TB
- en: '| `next` | Continues execution until the next line in the current function
    is reached or returns |'
  prefs: []
  type: TYPE_TB
- en: '| `step` | Executes the current line, stopping at the first possible occasion
    |'
  prefs: []
  type: TYPE_TB
- en: '| `pp` | Pretty-prints the value of the expression |'
  prefs: []
  type: TYPE_TB
- en: '| **`quit` **or** `exit`** | Aborts from `pdb` |'
  prefs: []
  type: TYPE_TB
- en: '| `return` | Continues execution until the current function returns |'
  prefs: []
  type: TYPE_TB
- en: See also
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: You can find out more about `pdb` by watching this interesting video tutorial: [https://www.youtube.com/watch?v=bZZTeKPRSLQ](https://www.youtube.com/watch?v=bZZTeKPRSLQ).
  prefs: []
  type: TYPE_NORMAL
- en: Implementing rpdb for debugging
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In some cases, it is appropriate to debug code in a remote location; that is,
    a location that doesn't reside on the same machine in which we run the debugger.
    For this purpose, `rpdb` was developed. This is a wrapper on `pdb` that uses a
    TCP socket to communicate with the world outside.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The installation of `rpdb` first requires the main step of using `pip`. For
    Windows OS, just type the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: Then, you need to be sure that you have a working **telnet** client enabled
    on your machine. In Windows 10, if you open Command Prompt and type `telnet`,
    then the OS will respond with an error as it is not present by default in the
    installation.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s see how to install it with a few simple steps:'
  prefs: []
  type: TYPE_NORMAL
- en: Open Command Prompt in administrator mode.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Click on the Cortana button and type `cmd`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: In the list that appears, right-click on the Command Prompt item and select
    Run as Administrator.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Then, when running Command Prompt as an administrator, type the following command:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: 'Wait a few minutes until the installation finishes. If the process is successful,
    then you will see this:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/92df2ec3-4eb3-43be-a8a0-f6351d39f5de.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Now, you can use telnet directly from the prompt. By typing `telnet`, the following
    window should appear:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/1e25886f-dca3-41a6-8e2a-efaf80ff5b05.png)'
  prefs: []
  type: TYPE_IMG
- en: In the following example, let's see how to run a remote debug with `rpdb`.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Let''s perform the following steps:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Consider the following sample code:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: 'To use `rpdb`, you need to insert the following lines of code (just after the
    `import threading` statement). In fact, these three lines of code enable the use
    of `rpdb` via a remote client on port `4444` with an IP address of `127.0.0.1`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: 'If you run the sample code after inserting these three lines of code that enable
    the use of `rpdb`, then you should see the following message on Python Command
    Prompt:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: 'Then, you can switch to debug the sample code remotely by making the following
    telnet connection:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: 'The following window should open:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/9f1b0949-3689-4ca7-9cd9-502cdaf6a028.png)'
  prefs: []
  type: TYPE_IMG
- en: 'In the sample code, note the arrow in line 7\. The code is not running, it
    is just waiting for an instruction to execute:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/1aa03050-e016-4563-94a9-b3418cef7ef4.png)'
  prefs: []
  type: TYPE_IMG
- en: 'For example, here, we execute the code and type the `next` statement repeatedly:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: Once the program is finished, you can still run a new debug section. Now, let's
    see how `rpdp` works in the next section.
  prefs: []
  type: TYPE_NORMAL
- en: How it works...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this section, we'll see how to simply move through the code by using the
    `next` statement, which continues execution until the next line in the current
    function is reached or returned.
  prefs: []
  type: TYPE_NORMAL
- en: 'To use `rpdb`, follow these steps:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Import the relevant `rpdb` library:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: 'Set the `debugger` parameter, which specifies the telnet port to connect to
    in order to run the debugger:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: 'Call the  `set_trace()`  directive, which makes it possible to enter into debugging
    mode:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: In our case, we placed the `set_trace()` directive immediately after the `debugger`
    instance. In reality, we can place it anywhere in the code; for example, if conditions
    are satisfied, or within a section managed by an exception.
  prefs: []
  type: TYPE_NORMAL
- en: 'The second step, instead, consists of opening Command Prompt and launching
    `telnet` by setting the same port value specified in the `debugger` parameter
    definition within the sample code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: It is possible to interact with the `rpdb` debugger by using a small command
    language that allows movement between calls to the stack, to examine and to modify
    the values of the variables and control the way in which the debugger executes
    its own program.
  prefs: []
  type: TYPE_NORMAL
- en: There's more...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The list of commands with which you can interact with in `rpdb` can be displayed
    by typing the `help` command from the `Pdb` prompt:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: 'Among the most useful commands, this is how we insert the breakpoints in the
    code:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Type `b` and the line numberto set a breakpoint. Here, a breakpoint is set
    in lines `5` and `10`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: 'It is sufficient to type the `b` command to display the list of breakpoints
    implemented:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: At each new breakpoint added, a numeric identifier is assigned. These identifiers
    are used to enable, disable, and interactively remove breakpoints. To disable
    a breakpoint, use the `disable` command, which tells the debugger not to stop
    when that line is reached. The breakpoint is not forgotten but is ignored.
  prefs: []
  type: TYPE_NORMAL
- en: See also
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'You can find a lot of information on `pdb`, and then on `rpdb`, on this site:
    [https://github.com/spiside/pdb-tutorial](https://github.com/spiside/pdb-tutorial).'
  prefs: []
  type: TYPE_NORMAL
- en: 'In the next two sections, we will look at some Python tools that are used for
    the implementation of unit tests:'
  prefs: []
  type: TYPE_NORMAL
- en: '`unittest`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`nose`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Dealing with unittest
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The `unittest` module is provided with the standard Python library. It has an
    extensive set of tools and procedures for performing unit tests. In this section,
    we'll briefly see how the `unittest` module works.
  prefs: []
  type: TYPE_NORMAL
- en: 'A unit test consists of two parts:'
  prefs: []
  type: TYPE_NORMAL
- en: The code to manage the so-called *test system*
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The test itself
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The simplest `unittest` module can be obtained via the `TestCase` subclass,
    to which the appropriate methods must be rewritten or added.
  prefs: []
  type: TYPE_NORMAL
- en: 'A simple `unittest` module can be composed as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: To run the `unittest` module, you need to include `unittest.main ()`, while
    we have a single method, `test()`, which fails if `True` is ever `False`.
  prefs: []
  type: TYPE_NORMAL
- en: 'By executing the preceding example, you get the following result:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: The test was successful, thus giving the result, `OK`.
  prefs: []
  type: TYPE_NORMAL
- en: In the following section, we go into more detail about how the `unittest` module
    works. In particular, we want to study what the possible outcomes of a unit test are.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Let''s see how we can characterize the results of a test with this example:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Import the relevant module:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: 'Define the `outcomesTest` class, which has the `TestCase` subclass as its argument:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: 'The first method we define is `testPass`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: 'Here is the `TestFail` method:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: 'Next, we have the `TestError` method:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: 'Finally, we have the `main` function, with which we recall our procedure:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: How it works...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this example, the possible outcomes of a unit test by `unittest` are shown.
  prefs: []
  type: TYPE_NORMAL
- en: 'The possible outcomes are as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '`ERROR`: The test raises an exception other than `AssertionError`. There is
    no explicit way to pass a test, so the test status depends on the presence (or
    absence) of an exception.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`FAILED`: The test is not passed and an `AssertionError` exception is raised.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`OK`: The test is passed.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The output is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs: []
  type: TYPE_PRE
- en: 'Most tests affirm the truth of a condition. There are different ways of writing
    tests that verify a truth, depending on the perspective of the author of the test
    and whether the desired result of the code is verified. If the code produces a
    value that can be evaluated as true, then the `failUnless ()` and `assertTrue ()`
    methods should be used. If the code produces a false value, then it makes more
    sense to use the `failIf ()` and `assertFalse ()` methods:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs: []
  type: TYPE_PRE
- en: 'The result is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs: []
  type: TYPE_PRE
- en: There's more...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: As mentioned previously, if a test raises an exception other than `AssertionError`,
    then it is treated as an error. This is very useful for discovering errors that
    occur while you are editing code for which a matched test already exists.
  prefs: []
  type: TYPE_NORMAL
- en: 'There are circumstances, however, in which you would want to run a test to
    verify that certain code actually produces an exception. For example, in cases
    when an invalid value is passed as an attribute of an object. In such cases, `failUnlessRaises()`
    makes the code clearer than capturing the exception in your code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE37]'
  prefs: []
  type: TYPE_PRE
- en: 'The results for both are the same. However, the result for the second test,
    which uses `failUnlessRaises()`, is shorter:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE38]'
  prefs: []
  type: TYPE_PRE
- en: See also
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: More information on Python testing can be found at [https://realpython.com/python-testing/](https://realpython.com/python-testing/).
  prefs: []
  type: TYPE_NORMAL
- en: Application testing using nose
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '`nose` is an important Python module for defining unit tests. It allows us
    to write simple test functions using subclasses of `unittest.TestCase` but also,
    classes of tests that are *not subclasse*s of `unittest.TestCase`.'
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Install `nose` by using `pip`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE39]'
  prefs: []
  type: TYPE_PRE
- en: 'The source package can be downloaded and installed at [https://pypi.org/project/nose/](https://pypi.org/project/nose/)
    by following these steps:'
  prefs: []
  type: TYPE_NORMAL
- en: Unzip the source package.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '`cd` to the new directory.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Then, enter the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE40]'
  prefs: []
  type: TYPE_PRE
- en: 'One of the strengths of `nose` is automatically collecting tests from the following:'
  prefs: []
  type: TYPE_NORMAL
- en: Python source files
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Directories and packages found in the working directory
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'To specify which tests to run, pass the relevant test names on the command
    line:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE41]'
  prefs: []
  type: TYPE_PRE
- en: The test names specified may be file or module names, and may optionally indicate
    the test case to run by separating the module or filename from the test case name
    with a colon. Filenames may be relative or absolute.
  prefs: []
  type: TYPE_NORMAL
- en: 'Some examples are as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE42]'
  prefs: []
  type: TYPE_PRE
- en: 'You may also change the working directory, where `nose` looks for tests, by
    using the `-w` switch:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE43]'
  prefs: []
  type: TYPE_PRE
- en: 'Note, however, that support for multiple `-w` arguments is now deprecated and
    will be removed in a future release. However, it is possible to get the same behavior
    by specifying the target directories without the `-w` switch:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE44]'
  prefs: []
  type: TYPE_PRE
- en: Further customization of test selection and loading is possible through the
    use of plugins.
  prefs: []
  type: TYPE_NORMAL
- en: The test result output is identical to that of `unittest`, except for the additional
    features, such as error classes, and plugin-supplied features such as output capture
    and assert introspection.
  prefs: []
  type: TYPE_NORMAL
- en: In the next section, we look at testing a class using `nose`*.*
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Let''s perform the steps that follow:'
  prefs: []
  type: TYPE_NORMAL
- en: Import the relevant `nose.tools`*:*
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE45]'
  prefs: []
  type: TYPE_PRE
- en: 'Then, set the `TestSuite` class. Here,the methods of the class are tested by
    the `eq_` function:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE46]'
  prefs: []
  type: TYPE_PRE
- en: How it works...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: A unit test can be developed independently by the developer, but it is good
    practice to have a standard product such as `unittest` and adhere to a common
    test practice.
  prefs: []
  type: TYPE_NORMAL
- en: 'As you can see from the following example, the test method was set by using
    the `eq_` function. This is similar to `assertEquals` by `unittest`, which verifies
    that the two parameters are equal:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE47]'
  prefs: []
  type: TYPE_PRE
- en: This testing practice, despite good in intentions, has obvious limitations,
    such as not being able to be repeated over time (for example, when a software
    module changes) for so-called **regression tests**.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here is the output:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE48]'
  prefs: []
  type: TYPE_PRE
- en: In general, testing is not able to identify all the errors in a program and
    the same is true for unit testing, which, by analyzing individual units by definition,
    cannot identify integration errors, performance problems, and other system-related
    problems. In general, unit testing is more effective when used in conjunction
    with other software testing techniques.
  prefs: []
  type: TYPE_NORMAL
- en: Like any form of testing, even unit testing cannot certify the absence of errors,
    but can only *highlight* their presence.
  prefs: []
  type: TYPE_NORMAL
- en: There's more...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Software testing is a combinatorial mathematics problem. For example, each Boolean
    test requires at least two tests, one for the true condition and one for the false
    condition. It can be shown that, for each functional code line, three to five
    lines of code are required for a test. It is therefore unrealistic to test all
    possible input combinations of any non-trivial code without a dedicated test case
    generation tool.
  prefs: []
  type: TYPE_NORMAL
- en: To achieve the desired benefits from a unit test, a strict sense of discipline
    is required throughout the development process. It is essential to keep track
    not only of the tests that have been developed and performed but also of all the
    changes made to the functional code of the unit in question and all the other
    units. The use of a version control system is essential. If a later version of
    a unit fails a test that it previously passed, then a version control system allow
    you to highlight the code changes that have occurred in the meantime.
  prefs: []
  type: TYPE_NORMAL
- en: See also
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: A valid tutorial on `nose` is available at [https://nose.readthedocs.io/en/latest/index.html](https://nose.readthedocs.io/en/latest/index.html).
  prefs: []
  type: TYPE_NORMAL
