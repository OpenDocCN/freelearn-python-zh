- en: '9'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Cryptography and Tokens
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: ”Three may keep a secret, if two of them are dead.”
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: ''
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: – Benjamin Franklin, Poor Richard’s Almanack
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: In this short chapter, we are going to give you a brief overview of the cryptographic
    services offered by the Python standard library. We are also going to touch upon
    JSON Web Tokens, an interesting standard for representing claims securely between
    two parties.
  prefs: []
  type: TYPE_NORMAL
- en: 'We are going to explore the following:'
  prefs: []
  type: TYPE_NORMAL
- en: Hashlib
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: HMAC
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Secrets
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: JSON Web Tokens with PyJWT, which seems to be the most popular Python library
    for dealing with JWTs
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Let us start by taking a moment to talk about cryptography and why it is so
    important.
  prefs: []
  type: TYPE_NORMAL
- en: The need for cryptography
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: It is estimated that, as of 2024, there are approximately 5.35 to 5.44 billion
    people using the internet worldwide. Every year, more people are using online
    banking services, shopping online, or just talking to friends and family on social
    media. All these people expect that their money will be safe, their transactions
    secure, and their conversations private.
  prefs: []
  type: TYPE_NORMAL
- en: 'Therefore, if you are an application developer, you must take security very
    seriously. It doesn’t matter how small or insignificant your application is: security
    should always be a concern for you.'
  prefs: []
  type: TYPE_NORMAL
- en: Security in information technology is achieved by employing several different
    means, but by far the most important one is cryptography. Almost everything you
    do with your computer or phone should include a layer where cryptography takes
    place. For example, cryptography is used to secure online payments, to transfer
    messages over a network in such a way that even if someone intercepts them, they
    will not be able to read them, and to encrypt your files when you back them up
    in the cloud.
  prefs: []
  type: TYPE_NORMAL
- en: The purpose of this chapter is not to teach you all the intricacies of cryptography—there
    are entire books dedicated to the subject. Instead, we will show you how you can
    use the tools that Python offers you to create digests, tokens, and, in general,
    to be on the safe(r) side when you need to implement something cryptography-related.
    As you read this chapter, it is worth bearing in mind that there is much more
    to cryptography than just encrypting and decrypting data; in fact, you will not
    find any examples of encryption or decryption in the entire chapter!
  prefs: []
  type: TYPE_NORMAL
- en: Useful guidelines
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Always remember the following rule: do not attempt to create your own hash
    or encryption functions. Simply don’t. Use tools and functions that are there
    already. It is incredibly tough to invent a good, solid, robust algorithm to do
    hashing or encryption, so it is best to leave it to professional cryptographers.'
  prefs: []
  type: TYPE_NORMAL
- en: It is important to understand cryptography, so try and learn as much as you
    can about this subject. There is plenty of information on the web, but for your
    convenience, we will put some useful references at the end of this chapter.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, let us dig into the first of the standard library modules we want to show
    you: `hashlib` .'
  prefs: []
  type: TYPE_NORMAL
- en: Hashlib
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: This module provides access to a variety of cryptographic hash algorithms. These
    are mathematical functions that take a message of any size and produce a fixed-size
    result, which is referred to as a **hash** or **digest** . Cryptographic hashes
    have many uses, from verifying data integrity to securely storing and verifying
    passwords.
  prefs: []
  type: TYPE_NORMAL
- en: 'Ideally, cryptographic hash algorithms should be:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Deterministic** : The same message should always produce the same hash.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Irreversible** : It should not be feasible to determine the original message
    from the hash.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Collision resistant** : It should be difficult to find two different messages
    that produce the same hash.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: These properties are crucial for the secure application of hashes. For example,
    it is considered imperative that passwords are only stored in hashed form.
  prefs: []
  type: TYPE_NORMAL
- en: The irreversibility property ensures that even if a data breach occurs and an
    attacker gets hold of a password database, it would not be feasible for them to
    obtain the original passwords. Having the passwords stored only as hashes means
    that the only way to verify a user’s password when they log in is to compute the
    hash of the password they provided and compare it against the stored hash. Of
    course, this will not work if the hash algorithm is not deterministic.
  prefs: []
  type: TYPE_NORMAL
- en: Collision resistance is also important. It ensures data integrity in that if
    a hash is used to provide a fingerprint for data, it is crucial that when the
    data changes, the fingerprint changes too. Collision resistance prevents an attacker
    from replacing a document with a different one that has the same hash. Moreover,
    many security protocols rely on the uniqueness guaranteed by collision-resistant
    hash functions.
  prefs: []
  type: TYPE_NORMAL
- en: 'The exact set of algorithms that are available through `hashlib` vary depending
    on the underlying libraries used on your platform. Some algorithms, however, are
    guaranteed to be present in all systems. Let us see how to find out what is available
    (note that your results might be different from ours):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: By opening a Python shell, we can get the set of available algorithms for our
    system. If our application talks to third-party applications, it is always best
    to pick an algorithm out of the guaranteed set, as that means every platform supports
    them. Notice that a lot of them start with *sha* , which stands for *secure hash
    algorithm* .
  prefs: []
  type: TYPE_NORMAL
- en: 'Let us keep going in the same shell; we are going to create a hash for the
    byte string `b"Hash me now!"` :'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: Here, we have used the `blake2b()` cryptographic function, which is quite sophisticated
    and was added in Python 3.6. After creating the hash object, `h` , we update its
    message in two steps. Not that we needed to, but sometimes we need to hash data
    that is not available all at once, so it is good to know we can do it in steps.
  prefs: []
  type: TYPE_NORMAL
- en: 'Once we have added the entire message, we get the hexadecimal representation
    of the digest. This will use two characters per byte (as each character represents
    four bits, which is half a byte). We also get the byte representation of the digest,
    and then we inspect its details: it has a block size (the internal block size
    of the hash algorithm in bytes) of 128 bytes, a digest size (the size of the resulting
    hash in bytes) of 64 bytes, and a name.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Let us see what we get if, instead of the `blake2b()` function, we use `sha512()`
    :'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: The resulting hash is as long as the `blake2b` one. Notice that we can construct
    the hash object with the message and compute the digest in one line.
  prefs: []
  type: TYPE_NORMAL
- en: Hashing is an interesting topic, and of course, the simple examples we have
    seen so far are just the start. The `blake2b()` function allows us a great deal
    of flexibility thanks to a number of parameters that can be adjusted. This means
    that it can be adapted for different applications or adjusted to protect against
    particular types of attacks.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here, we will just briefly discuss one of these parameters; for the full details,
    please refer to the official documentation at [https://docs.python.org/3/library/hashlib.html](https://docs.python.org/3/library/hashlib.html)
    . The `person` parameter is quite interesting. It is used to *personalize* the
    hash, forcing it to produce different digests for the same message. This can help
    to improve security when the same hash function is used for different purposes
    within the same application:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: Here, we have also used the `digest_size` parameter to get hashes that are only
    16 bytes long.
  prefs: []
  type: TYPE_NORMAL
- en: General-purpose hash functions, like `blake2b()` or `sha512()` , are not suitable
    for securely storing passwords. General-purpose hash functions are quite fast
    to compute on modern computers, which makes it feasible for an attacker to reverse
    the hash by **brute force** (trying millions of possibilities per second until
    they find a match). Key derivation algorithms like `pbkdf2_hmac()` are designed
    to be slow enough to make such brute-force attacks infeasible. The `pbkdf2_hmac()`
    key derivation algorithm achieves this by using many repeated applications of
    a general-purpose hash function (the number of iterations can be specified as
    a parameter). As computers get more powerful, it is important to increase the
    number of iterations we do over time; otherwise, the likelihood of a successful
    brute-force attack on our data increases as time passes.
  prefs: []
  type: TYPE_NORMAL
- en: Good password hash functions should also use **salt** . Salt is a random piece
    of data used to initialize the hash function; this randomizes the output of the
    algorithm and protects against attacks where hashes are compared to tables of
    known hashes. The `pbkdf2_hmac()` function supports salting via a required `salt`
    parameter.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here’s how you can use `pbkdf2_hmac()` to hash a password:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: Notice that we have used `os.urandom()` to provide a 16-byte random salt, as
    recommended by the documentation.
  prefs: []
  type: TYPE_NORMAL
- en: Normally, the value of the salt is stored alongside the hash. When a user attempts
    to log in, your program uses the stored salt to create the hash of the given password,
    which is then compared to the stored hash. Using the same value for the salt ensures
    that the hash will be the same when the password is correct.
  prefs: []
  type: TYPE_NORMAL
- en: We encourage you to explore and experiment with this module, as eventually,
    you will have to use it. Now, let us move on to the `hmac` module.
  prefs: []
  type: TYPE_NORMAL
- en: HMAC
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: This module implements the **HMAC** algorithm, as described by RFC 2104 ( [https://datatracker.ietf.org/doc/html/rfc2104.html](https://datatracker.ietf.org/doc/html/rfc2104.html)
    ). HMAC (which stands for **hash-based message authentication code** or **keyed-hash
    message authentication code** , depending on who you ask) is a widely used mechanism
    for authenticating messages and verifying that they have not been tampered with.
  prefs: []
  type: TYPE_NORMAL
- en: The algorithm combines a message with a secret key and generates a hash of the
    combination. This hash is referred to as a **message authentication code** ( **MAC**
    ) or **signature** . The signature is stored or transmitted along with the message.
    You can verify that the message has not been tampered with by re-computing the
    signature using the same secret key and comparing it to the previously computed
    signature. The secret key must be carefully protected; otherwise, an attacker
    with access to the key would be able to modify the message and replace the signature,
    thereby defeating the authentication mechanism.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let us see a small example of how to compute a MAC:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: The `hmac.new()` function takes a secret key, a message, and the hash algorithm
    to use. It returns an `hmac` object, which has a similar interface to the hash
    objects from `hashlib` . The key must be a `bytes` or `bytearray` object and the
    message can be any `bytes` -like object. Therefore, we convert our `key` and the
    `message` into bytes before creating an `hmac` instance ( `dig` ), which we use
    to get a hexadecimal representation of the hash.
  prefs: []
  type: TYPE_NORMAL
- en: We will see a bit more of how HMAC signatures can be used later in this chapter
    when we talk about JWTs. Before that, however, we will take a quick look at the
    `secrets` module.
  prefs: []
  type: TYPE_NORMAL
- en: Secrets
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'This small module was added in Python 3.6 and deals with three things: random
    numbers, tokens, and digest comparison. It uses the most secure random number
    generators provided by the underlying operating system to generate tokens and
    random numbers suitable for use in cryptographic applications. Let us have a quick
    look at what it provides.'
  prefs: []
  type: TYPE_NORMAL
- en: Random objects
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'We can use three functions to produce random objects:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: 'The first one, `choice()` , returns an element at random from a non-empty sequence.
    The second, `randbelow()` , generates a random integer between 0 and the argument
    you call it with, and the third, `randbits()` , generates an integer with the
    given number of random bits in it. Running that code produces the following output
    (which will, of course, be different every time it is run):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: You should use these functions instead of those from the `random` module whenever
    you need randomness in the context of cryptography, as these are specially designed
    for this task. Let us see what the module provides for tokens.
  prefs: []
  type: TYPE_NORMAL
- en: Token generation
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Again, we have three functions for generating tokens, each in a different format.
    Let us see the example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: 'The `token_bytes()` function simply returns a random byte string containing
    the specified number of bytes (16, in this example). The other two do the same,
    but `token_hex()` returns a token in hexadecimal format, and `token_urlsafe()`
    returns a token that only contains characters suitable for being included in a
    URL. Here is the output (which is a continuation of the previous run):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: 'Let us see how we can use these tools to write our own random password generator:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: The `generate_pwd()` function simply generates a random string of a given length
    by joining together `length` characters, picked at random from a string that contains
    all the letters of the alphabet (lowercase and uppercase), and the 10 decimal
    digits.
  prefs: []
  type: TYPE_NORMAL
- en: Then, we define another function, `generate_secure_pwd()` , that simply keeps
    calling `generate_pwd()` until the random string we get matches some basic requirements.
    The password must be `length` characters long, have at least one lowercase character,
    `upper` uppercase characters, and `digits` digits.
  prefs: []
  type: TYPE_NORMAL
- en: If the total number of uppercase characters, lowercase characters, and digits
    specified by the parameters is greater than the length of the password we are
    generating, we can never satisfy the conditions. We check for this before starting
    the loop and raise a `ValueError` if the given parameters would result in an infinite
    loop.
  prefs: []
  type: TYPE_NORMAL
- en: 'The body of the `while` loop is straightforward: first, we generate the random
    password, and then we verify the conditions by using `any()` and `sum()` . The
    `any()` function returns `True` if any of the items in the iterable it is called
    with evaluate to `True` . The use of `sum()` is actually slightly trickier here,
    in that it exploits **polymorphism** . As you may recall from *Chapter 2* , *Built-In
    Data Types* , the `bool` type is a subclass of `int` , therefore when summing
    on an iterable of `True` and `False` values, they will automatically be interpreted
    as integers (with the values 1 and 0) by the `sum()` function. This is an example
    of polymorphism, which we briefly discussed in *Chapter 6* , *OOP, Decorators,
    and Iterators* .'
  prefs: []
  type: TYPE_NORMAL
- en: 'Running the example produces the following result:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: Of course, you wouldn’t want to use a password of length 3.
  prefs: []
  type: TYPE_NORMAL
- en: 'One common use of random tokens is in password reset URLs for websites. Here
    is an example of how we can generate such a URL:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: 'Running the above produced this output:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: Digest comparison
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: This is probably quite surprising, but the `secrets` module also provides a
    `compare_digest(a, b)` function, which is the equivalent of comparing two digests
    by simply doing `a == b` . So, why would we need that function? It is because
    it has been designed to prevent timing attacks. These kinds of attacks can infer
    information about where the two digests start being different, according to the
    time it takes for the comparison to fail. So, `compare_digest()` prevents this
    attack by removing the correlation between time and failures. We think this is
    a brilliant example of how sophisticated attacking methods can be. If you raised
    your eyebrows in astonishment, maybe now it is clearer why we said never to implement
    cryptography functions by yourself.
  prefs: []
  type: TYPE_NORMAL
- en: 'This brings us to the end of our tour of the cryptographic services in the
    Python standard library. Now, let us move on to a different type of token: JWTs.'
  prefs: []
  type: TYPE_NORMAL
- en: JSON Web Tokens
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '**JSON Web Token** , or **JWT** , is a JSON-based open standard for creating
    tokens that assert a number of **claims** . JWTs are frequently used as authentication
    tokens. In this context, the claims typically are statements about the identity
    and permissions of an authenticated user. The tokens are cryptographically signed,
    which makes it possible to verify that the content of the token has not been modified
    since it was issued. You can learn all about this technology on the website (
    [https://jwt.io](https://jwt.io) ).'
  prefs: []
  type: TYPE_NORMAL
- en: This type of token consists of three sections, joined together by dots, in the
    format *A.B.C* . *B* is the payload, which is where we put the claims. *C* is
    the signature, which is used to verify the validity of the token, and *A* is a
    header, which identifies the token as a JWT, and indicates the algorithm used
    to compute the signature. *A* , *B* , and *C* are all encoded with a URL-safe
    Base64 encoding (which we will refer to as Base64URL). The Base64URL encoding
    makes it possible to use JWTs as part of URLs (typically as query parameters);
    however, JWTs do also appear in other places, including HTTP headers.
  prefs: []
  type: TYPE_NORMAL
- en: '`Base64` is a popular binary-to-text encoding scheme that represents binary
    data in an ASCII string format by translating it into a Radix-64 representation.
    The Radix-64 representation uses the letters A-Z, a-z, and the digits 0-9, plus
    the two symbols + and /, giving a total of 64 symbols. `Base64` is used, for example,
    to encode images attached to an email. It happens seamlessly, so the vast majority
    of users are completely oblivious to this fact. `Base64URL` is a variant of `Base64`
    encoding where the + and / characters (which have specific meanings in the context
    of a URL) are replaced with - and _. The = character (which is used for padding
    in `Base64` ) also has a special meaning within URLs and is omitted in `Base64URL`
    .'
  prefs: []
  type: TYPE_NORMAL
- en: The way this type of token works is slightly different from what we have seen
    so far in this chapter. In fact, the information that the token carries is always
    visible. You just need to decode *A* and *B* from Base64URL to get the algorithm
    and the payload. The security lies in part *C* , which is an HMAC signature of
    the header and payload. If you try to modify either the *A* or *B* part by editing
    the header or the payload, encoding it back to Base64URL, and replacing it in
    the token, the signature will not match, and therefore the token will be invalid.
  prefs: []
  type: TYPE_NORMAL
- en: This means that we can build a payload with claims such as *logged in as admin*
    , or something along those lines, and as long as the token is valid, we know we
    can trust that that user is logged in as an admin.
  prefs: []
  type: TYPE_NORMAL
- en: When dealing with JWTs, you want to make sure you have researched how to handle
    them safely. Things like not accepting unsigned tokens or restricting the list
    of algorithms you use to encode and decode, as well as other security measures,
    are very important and you should take the time to investigate and learn them.
  prefs: []
  type: TYPE_NORMAL
- en: For this part of the code, you will have to have the `PyJWT` and `cryptography`
    Python packages installed. As always, you will find them in the requirements of
    the source code for this chapter.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let us start with a simple example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: 'We define the `data` payload, which contains an ID and some payload data. We
    create a token using the `jwt.encode()` function, which takes the payload and
    a secret key. The secret key is used to generate the HMAC signature of the token
    header and payload. Next, we decode the token again, specifying the signature
    algorithms that we are willing to accept. The default algorithm used to calculate
    the token is `HS256` ; in this example, we accept either `HS256` or `HS512` when
    decoding (if the token had been generated using a different algorithm, it would
    be rejected with an exception). Here is the output:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: As you can see, the token is a binary string of Base64URL-encoded pieces of
    data (abridged to fit on one line). We called `jwt.decode()` , providing the correct
    secret key. If we had supplied the wrong key, we would have gotten an error, since
    the signature can only be verified with the same secret that was used to generate
    it.
  prefs: []
  type: TYPE_NORMAL
- en: JWTs are often used to transmit information between two parties. For example,
    authentication protocols that allow websites to rely on third-party identity providers
    to authenticate users often use JWTs. In such cases, the secret key used to sign
    tokens needs to be shared between the two parties. Therefore, it is often referred
    to as a **shared secret** .
  prefs: []
  type: TYPE_NORMAL
- en: Care must be taken to protect the shared secret since anyone with access to
    it can generate valid tokens.
  prefs: []
  type: TYPE_NORMAL
- en: 'Sometimes, you might want to be able to inspect the content of the token without
    verifying the signature first. You can do so by simply calling `decode()` this
    way:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: 'This is useful, for example, when values in the token payload are needed to
    recover the secret key, but that technique is quite advanced so we will not be
    spending time on it in this context. Instead, let us see how we can specify a
    different algorithm for computing the signature:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: Here, we have used the `HS512` algorithm to generate the token and, on decoding,
    specified that we would only accept tokens generated using the `HS512` algorithm.
    The output is the original payload dictionary.
  prefs: []
  type: TYPE_NORMAL
- en: Now, while you are free to put whatever you want in the token payload, there
    are some claims that have been standardized; they are essential for ensuring security,
    consistency, and interoperability across different systems and applications.
  prefs: []
  type: TYPE_NORMAL
- en: Registered claims
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The JWT standard defines the following official **registered claims** :'
  prefs: []
  type: TYPE_NORMAL
- en: '`iss` : The issuer of the token'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`sub` : The subject information about the party this token is carrying information
    about'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`aud` : The audience for the token'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`exp` : The expiration time, after which the token is invalid'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`nbf` : The not before (time), or the time before which the token is not considered
    to be valid yet'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`iat` : The time at which the token was issued'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`jti` : The token ID'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Claims that are not defined in the standard can be categorized as public or
    private:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Public** : Claims that are publicly allocated for a particular purpose. Public
    claim names can be reserved by registering them with the IANA JSON Web Token Claims
    Registry. Alternatively, the claims should be named in a way that ensures that
    they do not clash with any other public or official claim names (one way of achieving
    this could be to prepend a registered domain name to the claim name).'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Private** : Any other claims that do not fall under the above category are
    referred to as private claims. The meaning of such claims is typically defined
    within the context of a particular application, and they are meaningless outside
    that context. To prevent ambiguity and confusion, care must be taken to avoid
    name clashes.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: To learn about claims, please refer to the official website. Now, let us see
    a couple of code examples involving a subset of these claims.
  prefs: []
  type: TYPE_NORMAL
- en: Time-related claims
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'This is how we might use the claims related to time:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: In this example, we set the issued at ( `iat` ) claim to the current UTC time
    ( **UTC** stands for **Coordinated Universal Time** ). We then set the “not before”
    ( `nbf` ) and “expire time” ( `exp` ) claims to 1 and 3 seconds from now, respectively.
    We define a `decode()` helper function that reacts to a token not being valid
    yet, or being expired, by trapping the appropriate exceptions, and then we call
    it three times, interspersed by two calls to `sleep()` .
  prefs: []
  type: TYPE_NORMAL
- en: 'This way, we will try to decode the token before it is valid, then when it
    is valid, and finally, after it has expired. This function also prints a useful
    timestamp before attempting to decode the token. Let us see how it goes (blank
    lines have been added for readability):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: As you can see, it executed as expected. We get descriptive messages from the
    exceptions and get the original payload back when the token is valid.
  prefs: []
  type: TYPE_NORMAL
- en: Authentication-related claims
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Here we have another quick example, this time, involving the issuer ( `iss`
    ) and audience ( `aud` ) claims. The code is conceptually very similar to the
    previous example, and we are going to exercise it in the same way:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: As you can see, this time, we specified both issuer ( `iss` ) and audience (
    `aud` ) when creating the token. Decoding this token succeeds even if we omit
    the `issuer` argument to `jwt.decode()` . However, if the `issuer` is provided
    but does not match the iss field in the token, decoding fails. On the other hand,
    if the `audience` argument is omitted or does not match the `aud` field in the
    token, `jwt.decode()` will fail.
  prefs: []
  type: TYPE_NORMAL
- en: 'As in the previous example, we have written a custom `decode()` function that
    reacts to the appropriate exceptions. See if you can follow along with the calls
    and the relative output that follows (we will help with some blank lines):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: Note that, in this example, we varied the arguments to `jwt.decode()` to show
    you the behavior in various scenarios. In real-world usage, however, you would
    typically use fixed values for both `audience` and `issuer` and reject any tokens
    that cannot be decoded successfully. Omitting the `issuer` when decoding means
    you will accept tokens from any issuer. Omitting the `audience` means you will
    only accept tokens that do not specify an audience.
  prefs: []
  type: TYPE_NORMAL
- en: Now, let us see one final example for a more complex use case.
  prefs: []
  type: TYPE_NORMAL
- en: Using asymmetric (public key) algorithms
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Sometimes, using a shared secret is not the best option. In such cases, it is
    possible to use an asymmetric key pair instead of HMAC to generate the JWT signature.
    In this example, we are going to create a token (and decode it) using an **RSA**
    key pair.
  prefs: []
  type: TYPE_NORMAL
- en: 'Public key cryptography, or asymmetrical cryptography, is any cryptographic
    system that uses pairs of keys: public keys, which may be disseminated widely,
    and private keys, which are known only to the owner. If you are interested in
    learning more about this topic, please see the end of this chapter for recommendations.
    A signature can be generated using the private key, and the public key can be
    used to verify the signature. Thus, two parties can exchange JWTs and the signatures
    can be verified without any need for a shared secret.'
  prefs: []
  type: TYPE_NORMAL
- en: 'First, let us create an RSA key pair. We are going to use the `ssh-keygen`
    utility from OpenSSH ( [https://www.ssh.com/academy/ssh/keygen](https://www.ssh.com/academy/ssh/keygen)
    ) to do this. In the folder where our scripts for this chapter are, we created
    a `jwt/rsa` subfolder. Within it, run the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: Give the name `key` when asked for a filename (it will be saved in the current
    folder), and simply hit the *Enter* key when asked for a passphrase.
  prefs: []
  type: TYPE_NORMAL
- en: 'Having generated our keys, we can now change back to the `ch09` folder and
    run this code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: In this example, we defined a couple of custom functions to encode and decode
    tokens using private/public keys. As you can see in the `encode()` function, we
    are using the `RS256` algorithm this time. Notice that when we encode, we provide
    the private key, which is used to generate the JWT signature. When we decode the
    JWT, we instead supply the public key, which is used to verify the signature.
  prefs: []
  type: TYPE_NORMAL
- en: The logic is straightforward, and we would encourage you to think about at least
    one use case where this technique might be more suitable than using a shared key.
  prefs: []
  type: TYPE_NORMAL
- en: Useful references
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Here, you can find a list of useful references if you want to dig deeper into
    the fascinating world of cryptography:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Cryptography: [https://en.wikipedia.org/wiki/Cryptography](https://en.wikipedia.org/wiki/Cryptography)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'JSON Web Tokens: [https://jwt.io](https://jwt.io)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'RFC standard for JSON Web Tokens: [https://datatracker.ietf.org/doc/html/rfc7519](https://datatracker.ietf.org/doc/html/rfc7519)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Hash functions: [https://en.wikipedia.org/wiki/Cryptographic_hash_function](https://en.wikipedia.org/wiki/Cryptographic_hash_function)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'HMAC: [https://en.wikipedia.org/wiki/HMAC](https://en.wikipedia.org/wiki/HMAC)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Cryptography services (Python STD library): [https://docs.python.org/3/library/crypto.html](https://docs.python.org/3/library/crypto.html)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'IANA JSON Web Token Claims Registry: [https://www.iana.org/assignments/jwt/jwt.xhtml](https://www.iana.org/assignments/jwt/jwt.xhtml)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'PyJWT library: [https://pyjwt.readthedocs.io/](https://pyjwt.readthedocs.io/)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Cryptography library: [https://cryptography.io/](https://cryptography.io/)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: There is a lot of information on the web and plenty of books you can study,
    but we would recommend that you start with the main concepts and then gradually
    dive into the specifics you want to understand more thoroughly.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this short chapter, we explored the world of cryptography in the Python standard
    library. We learned how to create a hash (or digest) for a message using different
    cryptographic functions. We also learned how to create tokens and deal with random
    data in the context of cryptography.
  prefs: []
  type: TYPE_NORMAL
- en: We then took a small tour outside the standard library to learn about JSON Web
    Tokens, which are commonly used in authentication and claims-related functionalities
    by modern systems and applications.
  prefs: []
  type: TYPE_NORMAL
- en: The most important thing is to understand that doing things manually can be
    very risky when it comes to cryptography, so it is always best to leave it to
    the professionals and simply use the tools we have available.
  prefs: []
  type: TYPE_NORMAL
- en: The next chapter will be about testing our code so that we can be confident
    that it works the way it is supposed to.
  prefs: []
  type: TYPE_NORMAL
- en: Join our community on Discord
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Join our community’s Discord space for discussions with the authors and other
    readers:'
  prefs: []
  type: TYPE_NORMAL
- en: '[https://discord.com/invite/uaKmaz7FEC](Chapter_9.xhtml)'
  prefs: []
  type: TYPE_NORMAL
- en: '![img](img/QR_Code119001106417026468.png)'
  prefs: []
  type: TYPE_IMG
