- en: '6'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Using a Non-Relational Database
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: So far, we have learned that relational databases store data using table columns
    and rows. All these table records are structurally optimized and designed using
    different keys, such as primary, unique, and composite keys. The tables are connected
    using foreign/reference keys. Foreign key integrity plays a significant role in
    the table relationship of a database schema because it gives consistency and integrity
    to the data that’s persisted in the tables. [*Chapter 5*](B17975_05.xhtml#_idTextAnchor107),
    *Connecting to a Relational Database*, provided considerable proof that FastAPI
    can connect to relational databases using any of the present ORMs smoothly without
    lots of complexities. This time, we will focus on using non-relational databases
    as data storage for our FastAPI microservice application.
  prefs: []
  type: TYPE_NORMAL
- en: If FastAPI uses ORM for relational databases, it uses **Object Document Mapping**
    (**ODM**) to manage data using non-relational data stores or **NoSQL** databases.
    There are no tables, keys, and foreign key constraints involved in ODM, but a
    JSON document is needed to hold the various pieces of information. Different NoSQL
    databases vary in the storage model type that’s used to store data. The simplest
    among these databases manages data as key-value pairs, such as **Redis**, while
    complicated databases utilize schema-free document structures easily mapped to
    objects. This is usually done in **MongoDB**. Some use columnar data stores such
    as **Cassandra**, while some have graph-oriented data storage such as **Neo4j**.
    However, this chapter will focus on the FastAPI-MongoDB connectivity and the different
    ODM we can apply to pursue data management with a document-based database.
  prefs: []
  type: TYPE_NORMAL
- en: The main objective of this chapter is to study, formalize, and scrutinize different
    ways to use MongoDB as a database for our FastAPI application. Building the repository
    layer and showcasing the CRUD implementation will be the main highlight.
  prefs: []
  type: TYPE_NORMAL
- en: 'In this chapter, we will cover the following topics:'
  prefs: []
  type: TYPE_NORMAL
- en: Setting up the database environment
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Applying the PyMongo driver for synchronous connections
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Creating asynchronous CRUD transactions using Motor
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Implementing CRUD transactions using MongoEngine
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Implementing asynchronous CRUD transactions using Beanie
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Building an asynchronous repository for FastAPI using ODMantic
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Creating CRUD transactions using MongoFrames
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Technical requirements
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: This chapter focuses on an eBookstore web portal, *online book reselling system*,
    where users can sell and buy books from home through the internet. The virtual
    store allows users to view the *sellers' profiles*, *book catalogs*, *list of
    orders*, and *archive of purchases*. When it comes to the e-commerce side, the
    user can select their preferred books and add them to a cart. Then, they can check
    out the items as orders and pursue the payment transaction afterward. All the
    data is stored in a MongoDB database. The code for this chapter can be found at
    [https://github.com/PacktPublishing/Building-Python-Microservices-with-FastAPI](https://github.com/PacktPublishing/Building-Python-Microservices-with-FastAPI)
    in the `ch06` project.
  prefs: []
  type: TYPE_NORMAL
- en: Setting up the database environment
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Before we start discussing the application’s database connectivity, we need
    to download the appropriate MongoDB database server from [https://www.mongodb.com/try/download/community](https://www.mongodb.com/try/download/community).
    *online book reselling system* uses MongoDB 5.0.5 for a Windows platform. The
    installation will provide default service configuration details for the service
    name, data directory, and log directory. However, it is advised that you use different
    directory paths instead of the default ones.
  prefs: []
  type: TYPE_NORMAL
- en: After the installation, we can start the MongoDB server by running `/bin/mongod.exe`.
    This will automatically create a database directory called `/data/db` in the `C:/`
    drive (Windows). We can place the `/data/db` directory in some other location,
    but be sure to run the `mongod` command with the `--dbpath` option while specifying
    `<new path>/data/db`.
  prefs: []
  type: TYPE_NORMAL
- en: 'The MongoDB platform has utilities that can aid in managing database collections,
    and one of them is **MongoDB Compass**. It can provide a GUI experience that allows
    you to browse, explore, and easily manipulate the database and its collections.
    Also, it has built-in performance metrics, query views, and schema visualization
    features that can help with scrutinizing the correctness of the database structure.
    The following screenshot shows the dashboard for MongoDB Compass version 1.29.6:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 6.1 – The MongoDB Compass dashboard'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/Figure_6.01_B17975.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 6.1 – The MongoDB Compass dashboard
  prefs: []
  type: TYPE_NORMAL
- en: The preceding dashboard shows the document structure of the `profile` and list
    of books for sale.
  prefs: []
  type: TYPE_NORMAL
- en: 'Once the server and utility have been installed, we need to design the data
    collections for our database using the `obrs`:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 6.2 – The class diagram for the obrs database'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/Figure_6.02_B17975.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 6.2 – The class diagram for the obrs database
  prefs: []
  type: TYPE_NORMAL
- en: Our application uses all the collections depicted in the preceding diagram to
    store all the information it captures from the client. Each context box represents
    one collection, with all the attributes and expected underlying transactions indicated
    inside the box. It also shows the associations that bind these collections, such
    as the one-to-one association between `login` and `profile` and the many-to-one
    association between `BookForSale` and `UserProfile`.
  prefs: []
  type: TYPE_NORMAL
- en: Now that the database server has been installed and designed, let us look at
    the different ways of establishing a connection from our FastAPI microservice
    application to its MongoDB database.
  prefs: []
  type: TYPE_NORMAL
- en: Applying the PyMongo driver for synchronous connections
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'We will start by learning how the FastAPI application connects to MongoDB using
    the PyMongo database driver. This driver is equivalent to `psycopg2`, which allows
    us to access PostgreSQL without using any ORM. Some popular ODMs, such as MongoEngine
    and Motor, use PyMongo as their core driver, which gives us the reason to explore
    PyMongo first before we touch on issues regarding popular ODMs. Studying the driver’s
    behavior can provide baseline transactions that will show how an ODM builds the
    database connectivity, models, and CRUD transactions. But before we proceed with
    the details, we need to install the `pymongo` extension using `pip`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: Setting up the database connectivity
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: PyMongo uses its `MongoClient` module class to connect to any MongoDB database.
    We instantiate it with the specified host and port to extract the client object,
    such as `MongoClient("localhost", "27017")`, or a database URI, such as `MongoClient('mongodb://localhost:27017/')`.
    Our application uses the latter to connect to its database. But if we instantiate
    without providing the parameters, it will use the default `localhost` and `27017`
    details.
  prefs: []
  type: TYPE_NORMAL
- en: 'After extracting the client object, we can use it to access the database through
    a dot (`.`) operator or `attribute-style access` if the database name follows
    the Python naming convention; for example, `client.obrs`. Otherwise, we can use
    the bracket symbols (`[]`) or dictionary-style access; for example, `client["obrs_db"]`.
    Once the database object has been retrieved, we can access the collections using
    the access rules. Note that a collection is equivalent to a table in a relational
    database, where the collated records, known as documents, are stored. The following
    code shows a generator function that’s used by the application to open database
    connectivity and access the necessary collections in preparation for the CRUD
    implementation:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: A generator function such as `create_db_collections()` is preferred because
    the `yield` statement works perfectly when it comes to managing the database connection
    over the `return` statement. The `yield` statement suspends the function’s execution
    when it sends a value back to the caller but retains the state where the function
    can resume at the point where it left off. This feature is applied by the generator
    to close the database connection when it resumes the execution at the `finally`
    clause. The `return` statement, on the other hand, will not be applicable for
    this purpose because `return` will finish the whole transaction before it sends
    a value to the caller.
  prefs: []
  type: TYPE_NORMAL
- en: However, before we invoke the generator, let us scrutinize how PyMongo builds
    its model layer to pursue the necessary CRUD transactions.
  prefs: []
  type: TYPE_NORMAL
- en: Building the model layer
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Documents in MongoDB are represented and collated as JSON-style structures,
    specifically BSON documents. A BSON document offers more data types than the JSON
    structure. We can use dictionaries to represent and persist these BSON documents
    in PyMongo. Once a dictionary has been persisted, the BSON-type document will
    look like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: 'Common Python data types such as `str`, `int`, and `float` are supported by
    the BSON specification, but there are types such as `ObjectId`, `Decimal128`,
    `RegEx`, and `Binary` that are intrinsic only to the `bson` module. The specification
    only supports the `timestamp` and `datetime` temporal types. To install `bson`,
    use the following `pip` command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: Important note
  prefs: []
  type: TYPE_NORMAL
- en: '**BSON** is short for **Binary JSON**, a serialized and binary encoding for
    JSON-like documents. The specification behind this is lightweight and flexible.
    The efficient encoding format is explained in more detail at [https://bsonspec.org/spec.html](https://bsonspec.org/spec.html).'
  prefs: []
  type: TYPE_NORMAL
- en: '`ObjectId` is an essential data type in a MongoDB document because it serves
    as a *unique identifier* for the main document structure. It is a *12-byte* field
    that consists of a 4-byte UNIX *embedded timestamp*, the 3-byte *machine ID* of
    the MongoDB server, a 2-byte *process ID*, and a 3-byte *arbitrary value* for
    the ID’s increments. Conventionally, the declared field of the document, `_id`,
    always refers to the `ObjectId` value of the document structure. We can allow
    the MongoDB server to generate the _`id` object for the document or create an
    instance of the object type during persistence. When retrieved, `ObjectId` can
    be in *24 hexadecimal digit* or *string* format. Note that the `_id` field is
    the key indicator that a dictionary is ready to be persisted as a valid BSON document.
    Now, BSON documents can also be linked with one another using some associations.'
  prefs: []
  type: TYPE_NORMAL
- en: Establishing document associations
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'MongoDB has no concept of referential integrity constraints, but a relationship
    among documents is possible based on structures. There are two types of documents:
    *main* and *embedded* documents. A document has a *one-to-one association* with
    another if it is an embedded document of the other. Likewise, a document has a
    *many-to-one association* if a list in that document is linked to the main document
    structure.'
  prefs: []
  type: TYPE_NORMAL
- en: The previous purchase BSON document shows a sample of the principal `buyer`
    document with a one-to-one association with the `customer_status` embedded document
    and a many-to-one association with the `purchase_history` documents. As depicted
    from this sample document, embedded documents have no separate collection because
    they have no respective `_id` field to make them stand as primary documents.
  prefs: []
  type: TYPE_NORMAL
- en: Using the BaseModel classes for transactions
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Since PyMongo has no predefined model classes, the Pydantic models of FastAPI
    can be used to represent MongoDB documents with all the necessary validation rules
    and encoders. We can use the `BaseModel` classes to contain document details and
    pursue *insert*, *update*, and *delete* transactions since the Pydantic models
    are compatible with MongoDB documents. The following models are being used by
    our online book reselling application to store and retrieve the `buyer`, `purchase_history`,
    and `customer_status` document details:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: For these request models to recognize the BSON data types, we should make some
    modifications to the default behavior of these models. Just like earlier in this
    chapter, where we added the `orm_mode` option, there is also a need to add a nested
    `Config` class to the `BaseModel` blueprint with the `arbitrary_types_allowed`
    option set to `True`. This additional configuration will recognize the BSON data
    types used in the attribute declaration, including compliance with the necessary
    underlying validation rules for the corresponding BSON data types used. Moreover,
    the `json_encoders` option should also be part of the configuration to convert
    the `ObjectId` property of the document into a string during a query transaction.
  prefs: []
  type: TYPE_NORMAL
- en: Using Pydantic validation
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: However, some other types are too complex for `json_encoders` to process, such
    as the BSON `datettime` field being converted into a Python `datetime.date`. Since
    the ODM cannot automatically convert a MongoDB datetime into a Python `date` type,
    we need to create a custom validation and parse this BSON `datetime` through Pydantic’s
    `@validation` decorator. We must also use custom validators and parsers in the
    FastAPI services to convert all incoming Python date parameters into BSON datetime.
    This will be covered later.
  prefs: []
  type: TYPE_NORMAL
- en: '`@validator` creates a `class` method that accepts `class name` as the first
    parameter, not the instance, of the field(s) to be validated and parsed. Its second
    parameter is an option that specifies the field name or class attribute that needs
    to be converted into another data type, such as `date_purchased`, `date_shipped`,
    or `date_payment` of the `PurchaseRequestReq` model. The `pre` attribute of `@validator`
    tells FastAPI to process the class methods before any built-in validation can
    be done in the API service implementation. These methods are executed right after
    `APIRouter` runs its custom and built-in FastAPI validation rules for the request
    models, if there are any.'
  prefs: []
  type: TYPE_NORMAL
- en: Note that these request models have been placed in the `/models/request/buyer.py`
    module of the application.
  prefs: []
  type: TYPE_NORMAL
- en: Using the Pydantic @dataclass to query documents
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Wrapping the queried BSON documents using the `BaseModel` model classes is
    still the best approach to implementing the query transaction. But since BSON
    has issues with the Python `datetime.date` fields, we cannot always utilize the
    request model classes that are used for the CRUD transaction by wrapping retrieved
    BSON documents. Sometimes, using the model yields an `"invalid date format (type=value_error.date)"`
    error because all the models have the Python `datetime.date` fields, whereas the
    incoming data has a BSON `datetime` or `timestamp`. Instead of adding more complexities
    to the request models, we should resort to another approach to extracting the
    documents – that is, utilizing the Pydantic `@dataclass`. The following data classes
    are defined for wrapping the extracted `buyer` documents:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: '`@dataclass` is a decorator function that adds an `__init__()` to a Python
    class to initialize its attributes and other special functions, such as `__repr__()`.
    The `PurchasedHistory`, `PurchaseStatus`, and `Buyer` custom classes shown in
    the preceding code are typical classes that can be converted into request model
    classes. FastAPI supports both `BaseModel` and data classes when creating model
    classes. Apart from being under the `Pydantic` module, using `@dataclass` is not
    a replacement for using `BaseModel` when creating model classes. This is because
    the two components are different in terms of their flexibility, features, and
    hooks. `BaseModel` is configuration-friendly and can be adapted to many validation
    rules and type hints, while `@dataclass` has problems recognizing some `Config`
    attributes such as `extra`, `allow_population_by_field_name`, and `json_encoders`.
    If a data class requires some additional details, a custom class is needed to
    define these configurations and set the `config` parameter of the decorator. For
    instance, the `Config` class in the preceding code, which sets `arbitrary_types_allowed`
    to `True`, has been added to the three model classes.'
  prefs: []
  type: TYPE_NORMAL
- en: Besides `config`, the decorator has other parameters such as `init`, `eq`, and
    `repr` that accept `bool` values to generate their respective hook methods. The
    `frozen` parameter enables exception handling concerning field type mismatches
    when set to `True`.
  prefs: []
  type: TYPE_NORMAL
- en: When it comes to data parsing, transition, and conversion, `@dataclass` is always
    dependent on augmented validations, unlike `BaseModel`, which can process data
    type conversion simply by adding `json_encoders`. In the data classes shown previously,
    all the validators focus on BSON `datetime` to Python `datetime.date` conversion
    during the document retrieval process. These validations will occur before any
    custom or built-in validation in `APIRouter` because the `pre` parameter of the
    `@validator` decorator is set to `True`.
  prefs: []
  type: TYPE_NORMAL
- en: When dealing with default values, `BaseModel` classes can use typical type hints
    such as `Optional` or object instantiation such as `dict()` or `list()` to define
    the preconditional state of its complex attributes. With `@dataclass`, a `ValueError`
    exception is always thrown at compile time when type hints are applied to set
    default values of complex field types such as `list`, `dict`, and `ObjectId`.
    It requires the `field()` specifier from Python’s `dataclasses` module to set
    the default values of these fields, either by assigning an actual value through
    the specifier’s `default` parameter or invoking a function or lambda that returns
    a valid value through the `default_factory` parameter. The use of `field()` indicates
    that Pydantic’s `@dataclass` is an exact replacement of Python’s core data classes
    but with some additional features, such as the `config` parameter and the inclusion
    of the `@validator` components.
  prefs: []
  type: TYPE_NORMAL
- en: Note that it is advised that all `@dataclass` models have default values when
    using type hints or `field()`, especially for embedded documents and for models
    with the `date` or `datetime` types, to avoid some missing constructor parameter(s)
    errors. On the other hand, an `@dataclass` can also create embedded structures
    in the `BaseModel` classes, for example, by defining attributes with the class
    types. This is highlighted in the `Buyer` model.
  prefs: []
  type: TYPE_NORMAL
- en: All these model classes have been placed in the `/models/data/pymongo.py` script.
    Let us now apply these data models to create the repository layer.
  prefs: []
  type: TYPE_NORMAL
- en: Implementing the repository layer
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: PyMongo needs `collection` to build the repository layer of the application.
    Besides the `collection` object, the *insert*, *delete*, and *update* transactions
    will also need the `BaseModel` classes to contain all the details from the client
    and convert them into BSON documents after the transaction. Meanwhile, our query
    transactions will require the data classes to convert all BSON documents into
    JSON-able resources during the document retrieval process. Now, let us look at
    how a repository can be implemented using a PyMongo driver.
  prefs: []
  type: TYPE_NORMAL
- en: Building the CRUD transactions
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'The repository class in the following code block implements the CRUD transactions
    that aim to manage the `buyer`, `purchase_history`, and `customer_status` information
    based on basic specifications of the *online book reselling* system:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: Let us examine `insert_buyer()`, which inserts details about a registered book
    buyer who had some previous transactions in the system as a `login` user. The
    PyMongo collection offers helper methods for processing CRUD transactions, such
    as `insert_one()`, which adds a single main document from its `Dict` parameter.
    It also has `insert_many()`, which accepts a valid list of dictionaries that can
    be persisted as multiple documents. These two methods can generate an `ObjectId`
    for the `_id` field of the BSON document during the insertion process. The buyer’s
    details are extracted from the `BuyerReq` Pydantic model.
  prefs: []
  type: TYPE_NORMAL
- en: 'Next, `update_buyer()` shows how to update a specific document in the `buyer`
    collection:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: 'The collection has an `update_one()` method that requires two parameters: a
    unique and valid field/value dictionary pair that will serve as the *search key*
    of the record search, and another dictionary pair with the predefined `$set` key
    with the dictionary of updated *details for replacement*. It also has `update_many()`,
    which can update multiple documents, given that the primary dictionary field/value
    parameter is not unique.'
  prefs: []
  type: TYPE_NORMAL
- en: '`delete_buyer()` is the transaction that deletes a `buyer` document using a
    unique and valid field/value pair such as `{"buyer_id": id}`. If this parameter
    or search key is a common/non-unique data, the collection offers `delete_many()`,
    which can delete multiple documents. Now, the following script shows how to implement
    query transactions in PyMongo'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: 'When querying documents, PyMongo has a `find()` method, which retrieves all
    the documents in the collection, and `find_one()`, which can get a unique and
    single document. Both methods need two parameters: the conditional or logical
    query parameter in the form of a dictionary field/value pair and the set of fields
    that needs to appear in the record. `get_buyer()` in the previous code block shows
    how to retrieve a buyer document through the unique `buyer_id` field. The absence
    of its second parameter means the presence of all the fields in the result. Meanwhile,
    `get_all_buyer()` retrieves all the buyer documents without constraints. Constraints
    or filter expressions are formulated using BSON comparison operators, as shown
    in the following table:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/Table_011.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'For instance, retrieving buyer documents with *user_id greater than 5* requires
    the `buyers.find({"user_id": {"$gte": 5}})` query operation. If we need to build
    compound filters, we must apply the following logical operators:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/Table_021.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Retrieving buyer documents with *buyer_id less than 50* and *buyer_id greater
    than 10* will require the `find({''and'': [{''buyer_id'': {''$lt'': 50}}, {''user_id'':{''$gt'':10}}]})`
    query.'
  prefs: []
  type: TYPE_NORMAL
- en: Both methods return BSON documents that are not JSON-able components of the
    FastAPI framework. To convert the documents into JSON, the `bson.json_util` extension
    has a `dumps()` method that can convert a single document or list of documents
    into a JSON string. Both `get_all_buyer()` and `get_buyer()`convert every single
    document retrieved into JSON so that each can be mapped to the `Buyer` data class.
    The main objective of the mapping is to convert the `datetime` fields into Python
    `datetime.date` while utilizing the validators of the `Buyer` data class. The
    mapping will only be successful if the `loads()` method of the `json` extension
    is used to convert `str` into a `dict` data structure. After generating the list
    of `Buyer` data classes, the `asdict()` method of Python’s `dataclasses` module
    is needed to transform the list of `Buyer` data classes into a list of dictionaries
    to be consumed by `APIRouter`.
  prefs: []
  type: TYPE_NORMAL
- en: Managing document association
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Technically, there are two ways to construct a document association in PyMongo.
    The first one is to use the `DBRef` class of the `bison.dbref` module to link
    the parent and child documents. The only prerequisite is for both documents to
    have an `_id` value of the `ObjectId` type and have their respective collection
    exist. For instance, if `PurchaseHistoryReq` is a core document, we can insert
    one purchase record into the list through the following query:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: 'Here, the first parameter of the `DBRef` constructor pertains to the name of
    the collection where the child document is placed, while the second one is the
    `ObjectId` property of the child document in string format. However, some people
    use an `ObjectId` instance instead of the string version. On the other hand, to
    find a specific `purchase_history` document from the `buyer` collection using
    `DBRef`, we can write our query like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: 'The second way is to add the whole BSON document structure to the `list` field
    of `buyer` through the `BuyerReq` model. This solution applies to embedded documents
    that do not have `_id` and `collection` but are essential to the core document.
    `add_purchase_history()` in the following code shows how this approach is applied
    to create a many-to-one association between the `purchase_history` and `buyer`
    documents:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: The `add_customer_status()` method shows how to implement the second approach
    in building a one-to-one association between the `buyer` and `purchase_status`
    documents. The first approach, which involves using `DBRef`, can also be applied
    if `PurchaseStatusReq` is an independent core document.
  prefs: []
  type: TYPE_NORMAL
- en: The complete repository class can be found in the `/repository/pymongo/buyer.py`
    script file. Now, let us apply these CRUD transactions to our API services.
  prefs: []
  type: TYPE_NORMAL
- en: Running the transactions
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Before executing the `BuyerRepository` transactions, the `create_db_collections()`
    generator should be injected into the API services using `Depends`. Since PyMongo
    has difficulty processing Python types that are not BSON-supported, such as `datettime.date`,
    custom validations and serializers are sometimes required to pursue some transactions.
  prefs: []
  type: TYPE_NORMAL
- en: Important note
  prefs: []
  type: TYPE_NORMAL
- en: The implementation of `@validator` inside `@dataclass` and `BaseModel` converts
    outgoing BSON `datetime` parameters into Python `date` during query retrieval.
    Meanwhile, the JSON encoder validation in this API layer converts incoming Python
    `date` values into BSON `datetime` values during the transition from the application
    to MongoDB.
  prefs: []
  type: TYPE_NORMAL
- en: 'For instance, the `add_buyer()`, `update_buyer()`, and `add_purchase_history()`
    transaction methods in the following code require a custom serializer such as
    `json_serialize_date()` to transform the Python `datetime.date` value into the
    `datettime.datetime` type so that it complies with PyMongo’s BSON specification:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: The `json_serialize_date()` function becomes part of the JSON serialization
    process of the `dumps()` method but only handles the temporal type conversion
    while transforming the `buyer` details into JSON objects. It is applied in the
    *INSERT* and *UPDATE* transactions of the repository class to extract the serialized
    JSON string equivalent of the `BuyerReq`, `PurchaseHistoryReq`, and `PurchaseStatusReq`
    models.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, another custom converter is applied in the data retrievals of the `list_all_buyer()`
    and `get_buyer()` methods:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: The data models involved in our query transactions are data classes, so the
    results of the two preceding query methods have already been mapped and transformed
    into JSON format. However, unfortunately, they’re not JSON-able enough for the
    FastAPI framework. Aside from BSON `datetime` types, the PyMongo ODM cannot automatically
    convert `ObjectId` into a default type in Python, thus throwing `ValueError` during
    data retrieval from MongoDB. To fix this problem, `dumps()`needs a custom serializer,
    such as `json_serialize_oid()`, to convert all `ObjectId` parameters in MongoDB
    into FastAPI transitions. It also converts BSON `datetime` values into Python
    `date` values following the *ISO-8601* format. The valid JSON string from `dumps()`
    will enable the `loads()` method to produce a JSON-able result for the FastAPI
    services. The complete API services can be found in the `/api/buyer.py` script
    file.
  prefs: []
  type: TYPE_NORMAL
- en: After complying with all the requirements, PyMongo can help store and manage
    all the information using the MongoDB server. However, the driver only works for
    synchronous CRUD transactions. If we opt for an asynchronous way of implementing
    CRUD, we must always resort to the Motor driver.
  prefs: []
  type: TYPE_NORMAL
- en: Creating async CRUD transactions using Motor
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Motor is an asynchronous driver that relies on the AsyncIO environment of the
    FastAPI. It wraps PyMongo to produce non-blocking and coroutine-based classes
    and methods needed to create asynchronous repository layers. It is almost like
    PyMongo when it comes to most of the requirements except for the database connectivity
    and repository implementation.
  prefs: []
  type: TYPE_NORMAL
- en: 'But before we proceed, we need to install the `motor` extension using the following
    `pip` command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: Setting up the database connectivity
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Using the `AsyncIO` platform of the FastAPI, the Motor driver opens a connection
    to the MongoDB database through its `AsyncIOMotorClient` class. When instantiated,
    the default connection credential is always `localhost` at port `27017`. Alternatively,
    we can specify the new details in `str` format through its constructor. The following
    script shows how to create a global `AsyncIOMotorClient` reference with the specified
    database credentials:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: 'The format of the database URI is a string with a colon (`:`) in between the
    details. Now, the application needs the following Motor methods to start the database
    transactions:'
  prefs: []
  type: TYPE_NORMAL
- en: '`create_async_db()`: A method for establishing the database connection and
    loading schema definitions'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`close_async_db()`: A method for closing the connection'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`APIRouter` will require event handlers to manage these two core methods as
    application-level events. Later, we will register `create_async_db()` as a startup
    event and `close_async_db()` as a shutdown event. On the other hand, the `create_db_collections()`
    method creates some references to the `login` and `buyer` collections, which will
    be needed by the repository transactions later.'
  prefs: []
  type: TYPE_NORMAL
- en: In general, creating the database connection and getting the reference to the
    document collections do not require the `async/await` expression since no I/O
    is involved in the process. These methods can be found in the `/db_config/motor_config.py`
    script file. It is time now to create Motor's repository layer.
  prefs: []
  type: TYPE_NORMAL
- en: Creating the model layer
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: PyMongo and Motor share the same approaches in creating both the request and
    data models. All base models, data classes, validators, and serializers used by
    PyMongo also apply to Motor connectivity.
  prefs: []
  type: TYPE_NORMAL
- en: Building the asynchronous repository layer
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'When it comes to the CRUD implementation, both PyMongo and Motor have some
    slight differences in the syntax but a considerable difference in the performance
    of each transaction. Their helper methods for inserting, updating, and deleting
    documents, including the necessary method parameters, are all the same, except
    that Motor has the non-blocking versions. Invoking the non-blocking Motor methods
    inside the repository requires an async/await expression. Here is an asynchronous
    version of PyMongo’s `BuyerRepository`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: '`insert_buyer()` in the preceding code block is defined as `async` because
    `insert_one()` is a non-blocking operation that requires an `await` invocation.
    The same goes for `add_purchase_history()`, which updates the `purchase_history`
    embedded documents using the non-blocking `update_one()`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: The `delete_many()` and `find_one()` operations are also invoked through an
    `await` expression. However, `find()` in Motor is not asynchronous and behaves
    differently than it does with PyMongo. The reason is that `find()` is not an I/O
    operation in Motor, and it returns an `AsyncIOMotorCursor` or asynchronous cursor,
    an iterable type that contains all the BSON documents. We apply `async` to the
    cursor when retrieving all its stored documents. The `get_all_buyer()` transaction
    in the preceding code shows how we call the `find()` operation and invoke the
    cursor to extract the necessary documents for JSON transformation. This repository
    class can be found in the `/repository/motor/buyer.py` script file. Let us now
    apply these CRUD transactions to our API services.
  prefs: []
  type: TYPE_NORMAL
- en: Running the CRUD transactions
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'For the repository to work with `APIRouter`, we need to create two event handlers
    to manage the database connection and document collection retrieval. The first
    event, which is the startup event that the Uvicorn server executes before the
    application runs, should trigger the `create_async_db()` method’s execution to
    instantiate `AsyncIOMotorClient` and make references to the collections. The second
    event, which is the shutdown event, runs when the Uvicorn server is shutting down
    and should trigger the `close_async_db()` execution to close the connection. `APIRouter`
    has an `add_event_handler()` method to create these two event handlers. The following
    is a portion of the `APIRouter` script that shows how to prepare the database
    connection for the `BuyerRepository` transactions:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: The `"startup"` and `"shutdown"` values are pre-built configuration values and
    not just any arbitrary string values used to indicate the type of event handlers.
    We will discuss these event handlers in more detail in [*Chapter 8*](B17975_08.xhtml#_idTextAnchor229),
    *Creating Coroutines, Events, and Message-Driven Transactions*.
  prefs: []
  type: TYPE_NORMAL
- en: 'After setting these events handlers, the API services can now invoke the repository
    transactions asynchronously using an await/async expression. The validations and
    serialization utilities that are applied in PyMongo can also be utilized here
    in this version of `BuyerRepository`. The collections will be available to the
    API services upon injecting `create_db_collections()` into the API services. The
    `add_buyer()` API service showcases the implementation of an asynchronous REST
    transaction using the Motor driver:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: Using PyMongo and Mongo drivers provides a minimal and exhaustive implementation
    of the MongoDB transactions. The core implementation of every CRUD transaction
    varies from one developer to another, and the approaches that are used to scrutinize
    and analyze the processes involved are managed in different ways. Also, there
    are no established standards for defining the document fields, such as *data uniqueness*,
    *the length of the field value*, *the value range*, and even the idea of adding
    a *unique ID*. To address these issues surrounding PyMongo and Motor, let us explore
    other ways of opening a connection to MongoDB to create CRUD transactions, such
    as using an **ODM**.
  prefs: []
  type: TYPE_NORMAL
- en: Implementing CRUD transactions using MongoEngine
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: MongoEngine is an ODM that uses PyMongo to create an easy-to-use framework that
    can assist in managing MongoDB documents. It offers API classes that can help
    generate model classes using its field types and attribute metadata. It provides
    a declarative way of creating and structuring the embedded documents.
  prefs: []
  type: TYPE_NORMAL
- en: 'Before we explore this ODM, we need to install it using the following `pip`
    command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: Establishing database connection
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'MongoEngine has one of the most straightforward ways to establish a connection.
    Its `mongoengine` module has a `connect()` helper method that connects to the
    MongoDB database when it’s given the appropriate database connections. Our application
    must have a generator method to create a reference to the database connection
    and close this created connection after the transactions expire. The following
    script showcases the MongoEngine database connectivity:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: The `connect()` method has a mandatory first parameter, named `db`, which indicates
    the name of the database. The remaining parameters refer to the other remaining
    details of the database connection, such as `host`, `port`, `username`, and `password`.
    This configuration can be found in the `/db_config/mongoengine_config.py` script
    file. Let us now create data models for our MongoEngine repository.
  prefs: []
  type: TYPE_NORMAL
- en: Building the model layer
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'MongoEngine provides a convenient and declarative way of mapping BSON documents
    to the model classes through its `Document` API class. A model class must subclass
    `Document` to inherit the structure and properties of a qualified and valid MongoDB
    document. The following is a `Login` definition that’s been created using the
    `Document` API class:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: Unlike PyMongo and the Motor drivers, MongoEngine can define class attributes
    using its `Field` classes and their properties. Some of its `Field` classes include
    `StringField`, `IntField`, `FloatField`, `BooleanField`, and `DateField`. These
    can declare the `str`, `int`, `float`, `bool`, and `datetime.date` class attributes,
    respectively.
  prefs: []
  type: TYPE_NORMAL
- en: Another convenient feature that this ODM has is that it can create `SequenceField`,
    which behaves the same as the `auto_increment` column field in a relational database
    or `Sequence` in an object-relational database. The `id` field of a model class
    should be declared as `SequenceField` so that it serves as the primary key of
    the document. Like in a typical sequence, this field has utilities to increment
    its value or reset it to zero, depending on what document record must be accessed.
  prefs: []
  type: TYPE_NORMAL
- en: 'Other than the field types, field classes can also provide field arguments
    to attributes such as `choices`, `required`, `unique`, `min_value`, `max_value`,
    `max_length`, and `min_length` to give constraints to the field values. The `choices`
    parameter, for instance, accepts an iterable of string values that will serve
    as an enumeration. The `required` parameter indicates whether the field always
    needs a field value, while the `unique` parameter means the field value has no
    duplicates in the collection. Violating the `unique` parameter will lead to the
    following error message:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: '`min_value` and `max_value`, on the other hand, indicate the minimum and maximum
    values for the numeric fields, respectively. `min_length` specifies the minimum
    length of a string value, while `max_length` sets the maximum string length. The
    `db_field` parameter, on the other hand, can also be applied when specifying another
    document field name instead of the class attribute name. The given `Login` class
    also has `username` and `password` fields defined to hold string values, an id
    primary key defined as `SequenceField`, and an embedded document field to establish
    document association.'
  prefs: []
  type: TYPE_NORMAL
- en: Creating document association
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'The `profile` field of `Login` creates a one-to-one association between the
    `Login` document and `UserProfile`. But before the association can work, we need
    to define the `profile` field as being of the `EmbeddedDocumentField` type and
    `UserProfile` as being of the `EmbeddedDocument` type. The following is the complete
    blueprint of `UserProfile`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: The `EmbeddedDocument` API is a `Document` without an `id` and has no collection
    of its own. Subclasses of this API are model classes that have been created to
    be part of a core document structure, such as `UserProfile` being part of the
    `Login` details. Now, the field that refers to this document has a `required`
    property set to `False` since an embedded document can’t be present at all times.
  prefs: []
  type: TYPE_NORMAL
- en: On the other hand, a field declared as `EmbeddedDocumentList` is used to create
    a many-to-one association between documents. The preceding `UserProfile` class
    is strongly connected to a list of `BookForSale` embedded documents because of
    its declared `booksale` field. Again, the field type should always set its `required`
    property to `False` to avoid problems when dealing with empty values.
  prefs: []
  type: TYPE_NORMAL
- en: Applying custom serialization and deserialization
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: There are no built-in hooks for validation and serialization in this ODM. Every
    model class in the *online book reselling* application has implemented a `from_json()`
    class method that converts JSON details into a valid `Document` instance. When
    converting the BSON document into a JSON object, model classes must have the custom
    `to_json()` instance method, which builds the JSON structure and automatically
    transforms the BSON `datetime` into JSON-able `date` objects through formatting.
    Let us now create the repository layer using the model classes.
  prefs: []
  type: TYPE_NORMAL
- en: Implementing the CRUD transactions
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'MongoEngine provides the most convenient and straightforward approach to building
    the repository layer for the application. All its operations come from the `Document`
    model class and they are easy to use. `LoginRepository` uses the ODM to implement
    its CRUD transactions:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: It only takes two lines for the `insert_login()` method to save the `Login`
    document. After creating the `Login` instance with the necessary document details,
    we simply call the `save()` method of the `Document` instance to pursue the insert
    transaction. When it comes to modifying some document values, the `Document` API
    class has an `update()` method that manages changes in state for every class attribute.
    But first, we need to find the document using the `objects()` utility method,
    which retrieves document structures from the collection. This `objects()` method
    can fetch a document by providing its parameter with an `id` field value or extracting
    a list of document records by supplying the method with a generic search expression.
    The instance of the retrieved document must invoke its `update()` method to pursue
    the modification of some, if not all, of its field values. The given `update_password()`
    method updates the password field of `Login`, which gives us a good template regarding
    how to pursue update operations on other field attributes.
  prefs: []
  type: TYPE_NORMAL
- en: 'On the other hand, `delete_login()` shows how to delete a `Login` document
    from its collection after it searches for the object using a simple call to the
    instance’s `delete()` method. The following script shows how to perform query
    transactions in MongoEngine:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: The only way to perform single- or multiple-document retrieval is to utilize
    the `objects()` method. There is no need to implement JSON converters for the
    query results because every `Document` model class has a `to_json()` method to
    provide the JSON-able equivalent of the instance. The given `get_all_login()`
    transaction uses list comprehension to create a list of JSON documents from the
    result of `objects()`, while the `get_login()` method invokes `to_json()` after
    extracting a single document.
  prefs: []
  type: TYPE_NORMAL
- en: Managing the embedded documents
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'It is easier to implement document associations with an ODM than the core PyMongo
    and Motor database drivers. Since the operations of MongoEngine are comfortable
    to use, it takes only a few lines to manage the embedded documents. In the following
    `UserProfileRepository` script, `insert_profile()` shows how adding a `UserProfile`
    detail to the `Login` document can be done by performing a simple object search
    and an `update()` call:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: Likewise, the given `add_book_sale()` transaction creates a many-to-one association
    between `BookForSale` and `UserProfile` using the same approach applied in `insert_profile()`
    with an additional List's `append()` operation.
  prefs: []
  type: TYPE_NORMAL
- en: 'Querying the embedded documents is also feasible in MongoEngine. The ODM has
    a `filter()` method that uses *field lookup syntax* to refer to a specific document
    structure or list of embedded documents. This field lookup syntax consists of
    the *field name of the embedded document*, followed by a *double underscore* in
    place of the dot in the usual object attribute access syntax. Then, it has *another
    double underscore* to cater to some *operators*, such as `lt`, `gt`, `eq`, and
    `exists`. In the following code, `get_all_profile()`uses the `profile__login_id__exists=True`
    field lookup to filter all `user_profile` embedded documents that have valid `login`
    structures. However, the `get_profile()` transaction does not need to use `filter()`
    and field lookups because it can simply access the specific login document to
    fetch its profile details:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: The preceding query transactions are just simple implementations compared to
    some other complex MongoEngine queries, which involve complicated embedded document
    structures that require complex field lookup syntax. Let us now apply the CRUD
    transactions to our API services.
  prefs: []
  type: TYPE_NORMAL
- en: Running the CRUD transactions
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: CRUD will not work without passing our `create_db()` method to the *startup*
    event and `disconnect_db()` to the *shutdown* event. The former will open the
    MongoDB connection during the Uvicorn startup, while the latter will close it
    during server shutdown.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following script shows the application’s `profile` router with a `create_profile()`
    REST service that asks clients for a profile detail, given a specific login record,
    and pursues the insert transaction using `UserProfileRepository`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: '`create_profile()` is a standard API service that deals with MongoEngine’s
    synchronous `insert_profile()` transaction. When it comes to asynchronous REST
    services, it is not advisable to use MongoEngine because its platform only works
    with synchronous ones. In the next section, we will discuss an ODM that’s popular
    in building an asynchronous repository layer.'
  prefs: []
  type: TYPE_NORMAL
- en: Implementing async transactions using Beanie
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '**Beanie** is a non-boilerplate mapper that utilizes the core features of Motor
    and Pydantic. This ODM offers a more straightforward approach to implementing
    asynchronous CRUD transactions than its precursor, the Motor driver.'
  prefs: []
  type: TYPE_NORMAL
- en: 'To use Beanie, we need to install it using the following `pip` command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: Important note
  prefs: []
  type: TYPE_NORMAL
- en: Installing Beanie may uninstall the current version of your Motor module because
    it sometimes requires lower version of Motor module. Pursuing this will produce
    errors in your existing Motor transactions.
  prefs: []
  type: TYPE_NORMAL
- en: Creating the database connection
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Beanie uses the Motor driver to open a database connection to MongoDB. Instantiating
    the Motor’s `AsyncIOMotorClient` class with the database URL is the first step
    of configuring it. But what makes Beanie unique compared to other ODMs is how
    it pre-initializes and pre-recognizes the model classes that will be involved
    in a CRUD transaction. The ODM has an asynchronous `init_beanie()` helper method
    that initiates the model class initialization using the database name. Calling
    this method will also set up the collection-domain mapping, where all the model
    classes are registered in the `document_models` parameter of `init_beanie()`.
    The following script shows the database configuration that’s required to access
    our MongoDB database, `obrs`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: Here, `db_connect()` uses an async/await expression because its method invocation
    to `init_beanie()` is asynchronous. `db_disconnect()` will close the database
    connection by calling the `close()` method of the `AsyncIOMotorClient` instance.
    Both of these methods are executed as events, just like in MongoEngine. Their
    implementation can be found in the `/db_config/beanie_config.py` script file.
    Let us now create the model classes.
  prefs: []
  type: TYPE_NORMAL
- en: Defining the model classes
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The Beanie ODM has a `Document` API class that’s responsible for defining its
    model classes, mapping them to MongoDB collections, and handling repository transactions,
    just like in MongoEngine. Although there is no `Field` directive for defining
    class attributes, the ODM supports Pydantic’s validation and parsing rules and
    `typing` extension for declaring models and their attributes. But it also has
    built-in validation and encoding features, which can be used together with Pydantic.
    The following script shows how to define Beanie model classes while it’s being
    configured:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: The `id` attribute of the given `Document` classes automatically translates
    into an `_id` value. This serves as the primary key of the document. Beanie allows
    you to replace the default `ObjectId` type of `_id` with another type, such as
    `int`, which is not possible in other ODMs. And with Motor, this ODM needs custom
    JSON serializers because it has difficulty converting BSON `datetime` types into
    Python `datetime.date` types during CRUD transactions.
  prefs: []
  type: TYPE_NORMAL
- en: A document in Beanie can be configured by adding the `Collection` and `Settings`
    nested classes. The `Collection` class can replace the default name of the collection
    where the model is supposed to be mapped. It can also provide indexes to document
    fields if needed. The `Settings` inner class, on the other hand, can override
    existing BSON encoders, apply caching, manage concurrent updates, and add validation
    when the document is being saved. These three model classes include the collection
    configuration in their definitions to replace the names of their respective collections
    with their class names.
  prefs: []
  type: TYPE_NORMAL
- en: Creating the document associations
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Python syntax, Pydantic rules, and API classes are used to establish links between
    documents in this mapper. To create a one-to-one association between `Order` and
    `Receipt`, for instance, we only need to set an `Order` field attribute that will
    link to a single `Receipt` instance. For many-to-one associations, such as the
    relationship between `Order` and `Cart`, the `Cart` document should only need
    a list field that will contain all the `Order` embedded documents.
  prefs: []
  type: TYPE_NORMAL
- en: However, the ODM has a `Link` type, which can be used to define class fields
    to generate these associations. Its CRUD operations, such as `save()`, `insert()`,
    and `update()`, strongly support these `Link` types, so long as the `link_rule`
    parameter is provided in their parameters. For query transactions, the `find()`
    method can include the `Link` documents during document fetching, given that its
    `fetch_links` parameter is set to `True`. Now, let us implement the repository
    layer using the model classes.
  prefs: []
  type: TYPE_NORMAL
- en: Implementing the CRUD transactions
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Implementing repositories with Beanie is similar to how it’s done with MongoEngine
    – that is, it uses short and direct CRUD syntax due to the convenient helper methods
    like create(), update(), and delete(), provided by the `Document` API class. However,
    the Beanie mapper creates an asynchronous repository layer because all the API
    methods that are inherited by the model classes are non-blocking. The following
    code for the `CartRepository` class shows a sample implementation of an asynchronous
    repository class using this Beanie ODM:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: The `add_item()` method showcases the use of the asynchronous `insert()`method
    to persist a newly created `Cart` instance. The `Document` API also has a `create()`
    method that works like `insert()`. Another option is to use the `insert_one()`
    class method instead of the instance methods. Moreover, adding multiple documents
    is allowed in this ODM because an `insert_many()` operation exists to pursue that
    kind of insert.
  prefs: []
  type: TYPE_NORMAL
- en: Updating a document can be initiated using two methods, namely `set()` and `replace()`.`update_qty()`
    in the preceding script chooses the `set()` operation to update the current `qty`
    value of the items placed in a cart.
  prefs: []
  type: TYPE_NORMAL
- en: When it comes to document removal, the ODM only has the `delete()` method to
    pursue the transactions. This is present in the `delete_item()` transaction in
    the preceding code.
  prefs: []
  type: TYPE_NORMAL
- en: 'Retrieving a single document or a list of documents using this ODM is easy.
    No further serialization and cursor wrapping is needed during its query operations.
    When fetching a single document structure, the mapper provides the `get()` method
    if the fetching process only requires the `_id` field; it provides `find_one()`
    when the fetching process requires a conditional expression. Moreover, Beanie
    has a `find_all()` method that fetches all the documents without constraints and
    the `find()` method for retrieving data with conditions. The following code shows
    the query transaction for retrieving cart items from the database:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs: []
  type: TYPE_PRE
- en: Both the `find()` and `find_all()` operations are used in the methods to return
    a `FindMany` object that has a `to_list()` utility that returns a list of JSON-able
    documents. Let us now apply our CRUD transactions to the API services.
  prefs: []
  type: TYPE_NORMAL
- en: Running the repository transactions
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The `CartRepository` methods will only run successfully if `db_connect()` from
    the configuration file is injected into the router. Although injecting it into
    each API service is acceptable, our solution prefers injecting the component into
    `APIRouter` using `Depends`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs: []
  type: TYPE_PRE
- en: The asynchronous `add_cart_item()` service asynchronously inserts the cart account
    into the database using `CartRepository`.
  prefs: []
  type: TYPE_NORMAL
- en: Another asynchronous mapper that can integrate perfectly with FastAPI is *ODMantic*.
  prefs: []
  type: TYPE_NORMAL
- en: Building async repository for FastAPI using ODMantic
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The dependencies of Beanie and ODMantic come from Motor and Pydantic. ODMantic
    also utilizes Motor’s `AsyncIOMotorClient` class to open a database connection.
    It also uses Pydantic features for class attribute validation, Python’s typing
    extension for type hinting, and other Python components for management. But its
    edge over Beanie is that it complies with ASGI frameworks such as FastAPI.
  prefs: []
  type: TYPE_NORMAL
- en: 'To pursue ODMantic, we need to install the extension using the following `pip`
    command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs: []
  type: TYPE_PRE
- en: Creating the database connection
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Setting up the database connectivity in ODMantic is the same as what we do
    with the Beanie mapper, except that the setup includes creating an engine that
    will handle all its CRUD operations. This engine is `AIOEngine` from the `odmantic`
    module, which requires both the motor client object and the database name to be
    created successfully. The following is a complete implementation of the database
    connectivity needed by the ODMantic mapper:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE37]'
  prefs: []
  type: TYPE_PRE
- en: We need to create event handlers in `APIRouter` to run `create_db_connection()`
    and `close_db_connection()` for our repository transactions to work. Let us now
    implement the model layer of the ODM.
  prefs: []
  type: TYPE_NORMAL
- en: Creating the model layer
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'ODMantic has a `Model` API class that provides properties to model classes
    when subclassed. It relies on Python types and BSON specifications to define the
    class attributes. When transforming field types, such as converting a BSON `datetime`
    value into a Python `datetime.date` value, the mapper allows you to add custom
    `@validator` methods into the model classes to implement the appropriate object
    serializer. Generally, ODMantic relies on the `pydantic` module when it comes
    to data validation, unlike in the Beanie mapper. The following is a standard ODMantic
    model class definition:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE38]'
  prefs: []
  type: TYPE_PRE
- en: For advanced configurations, we can add a nested `Config` class to the model
    class to set these additional options, such as the `collection` option, which
    replaces the default name of the collection with a custom one. We can also configure
    some familiar options, such as `json_encoders`, to convert one field type into
    another supported one.
  prefs: []
  type: TYPE_NORMAL
- en: Establishing document association
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: When creating associations, the typical Python approach of declaring fields
    so that they refer to an embedded document(s) is still applicable in this ODM.
    However, this ODM mapper has an `EmbeddedModel` API class to create a model with
    no `_id` field; this can be linked to another document. The `Model` classes, on
    the other hand, can define a field attribute that will refer to an `EmbeddedModel`
    class to establish a one-to-one association or a list of `EmbeddedModel` instances
    for a many-to-one association.
  prefs: []
  type: TYPE_NORMAL
- en: Implementing the CRUD transactions
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Creating the repository layer using ODMantic always requires the engine object
    that was created in the startup event. This is because all the CRUD operations
    that are needed will come from this engine. The following `PurchaseRepository`
    shows the operations from the `AIOEngine` object that we need to create CRUD transactions:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE39]'
  prefs: []
  type: TYPE_PRE
- en: This `insert_purchase()` method shows the standard way to insert a record into
    the database using ODMantic. Through the engine’s `save()` method, we can persist
    one document at a time using the model class. `AIOEngine` also provides the `save_all()`
    method for inserting a list of multiple documents into the associated MongoDB
    collection.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, there is no specific way to update transactions, but ODMantic allows you
    to fetch the record that needs to be updated. The following code can be used to
    update a record using ODMantic:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE40]'
  prefs: []
  type: TYPE_PRE
- en: 'After accessing and changing the field values, the fetched document object
    will be re-saved using the `save()` method to reflect the changes in physical
    storage. The complete process is implemented in the preceding `update_purchase()`
    transaction:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE41]'
  prefs: []
  type: TYPE_PRE
- en: When it comes to document removal, you must fetch the document to be deleted.
    We pass the fetched document object to the `delete()` method of the engine to
    pursue the removal process. This implementation is shown in the `delete_purchase()`
    method.
  prefs: []
  type: TYPE_NORMAL
- en: 'When fetching a single document so that it can be updated or deleted, `AIOEngine`
    has a `find_one()` method that requires two arguments: the model class name and
    the conditional expression, which involves either the `id` primary key or some
    non-unique fields. All the fields can be accessed like class variables. The following
    `get_purchase()` method retrieves a `Purchase` document with the specified `id`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE42]'
  prefs: []
  type: TYPE_PRE
- en: The engine has a `find()` operation to retrieve all `Purchase` documents, for
    instance, from the database. It only needs an argument – the name of the model
    class. Let now apply our repository layer to the API services.
  prefs: []
  type: TYPE_NORMAL
- en: Running the CRUD transaction
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'For the repository classes to run, all the router services must be asynchronous.
    Then, we need to create the startup and shutdown event handlers for `create_db_connection()`
    and `close_db_connection()`, respectively, to open the connection for repository
    transactions. Lastly, for the repository class to work, `create_db_engine()` must
    be injected into each API service to derive the engine object:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE43]'
  prefs: []
  type: TYPE_PRE
- en: At this point, we should know how to compare these mappers and drivers when
    it comes to the setup and procedures needed to manage MongoDB documents. Each
    has its strengths and weaknesses based on the code they produce and the performance,
    popularity, support, and complexity of its solution. Some may work on other requirements,
    while others may not. The final ODM we will cover focuses on being the lightest
    and least obtrusive mapper. It aims to fit into an existing application without
    generating syntax and performance problems.
  prefs: []
  type: TYPE_NORMAL
- en: Creating CRUD transactions using MongoFrames
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: If you are tired of using complicated and heavy-loaded ODMs, then MongoFrames
    is ideal for your requirements. MongoFrames is one of the newest ODMs and is very
    convenient to use, especially when building a new repository layer for an already
    existing complex and legacy FastAPI microservice application. But this mapper
    can only create synchronous and standard types of CRUD transactions.
  prefs: []
  type: TYPE_NORMAL
- en: 'But before we proceed, let us install the extension module using `pip`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE44]'
  prefs: []
  type: TYPE_PRE
- en: Creating the database connection
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The MongoFrames platform runs on top of PyMongo, which is why it cannot build
    an asynchronous repository layer. To create the database connection, it uses the
    `MongoClient` API class from the `pymongo` module, with the database URL in string
    format. Unlike in the other ODMs, where we create a client variable, in this mapper,
    we access the `variable _client` class from the `Frame` API class to refer to
    the client connection object. The following code shows `create_db_client()`, which
    will open the database connection for our app, and `disconnect_db_client()`, which
    will close this connection:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE45]'
  prefs: []
  type: TYPE_PRE
- en: Just like in the previous ODMs, we need event handlers to execute these core
    methods to start building the model and repository layers.
  prefs: []
  type: TYPE_NORMAL
- en: Building the model layer
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The process of creating model classes in MongoFrames is called `Frame` API
    class to define the model classes. Once inherited, `Frame` does not require a
    model class to define its attributes. It uses the `_fields` property to contain
    all the necessary fields of the document without indicating any metadata. The
    following model classes are defined by the `Frame` API class:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE46]'
  prefs: []
  type: TYPE_PRE
- en: A `Frame` model class can wrap a document in dictionary form or in a `kwargs`
    that contains the key-value details of the document’s structure. It can also provide
    attributes and helper methods that can help pursue CRUD transactions. All the
    fields of the model class can be accessed through dot (`.`) notation, just like
    typical class variables.
  prefs: []
  type: TYPE_NORMAL
- en: Creating the document association
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: We need to define the `SubFrame` model before creating associations among these
    documents. A `SubFrame` model class is mapped to an embedded document structure
    and has no collection table of its own. The MongoFrames mapper provides operations
    that allow you to append, update, remove, and query the `SubFrame` class of the
    `Frame` instance. These operations will determine the type of association among
    documents since the field references of `Frame` do not have specific field types.
    The `Reference` document, for instance, will have a list of categories linked
    to its `categories` field because our transaction will build that association
    as designed. A `Book` document, on the other hand, will refer to a `Category`
    child document through its `category` field because a transaction will build that
    association at runtime. So, MongoFrames is both restrained and non-strict when
    it comes to defining the type of association among these documents.
  prefs: []
  type: TYPE_NORMAL
- en: Creating the repository layer
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The `Frame` API class provides the model classes and the necessary helper methods
    to implement the asynchronous repository transactions. The following code shows
    an implementation of a repository class that uses MongoFrames to create its CRUD
    transactions:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE47]'
  prefs: []
  type: TYPE_PRE
- en: 'The given `insert_book()` transaction inserts a book instance into its mapped
    collection. The `Frame` API provides an `insert()` method that saves the given
    model object into the database. It also has `insert_many()`, which inserts a list
    of multiple BSON documents or a list of model instances. The following script
    shows how to create an *UPDATE* transaction in MongoFrames:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE48]'
  prefs: []
  type: TYPE_PRE
- en: 'The given `update_book()` transaction shows that the `Frame` model class also
    has an `update()` method, which recognizes and saves the changes reflected in
    the field values of a document object right after fetching them from the collection.
    A similar process is applied to the `delete_book()` process, which calls the `delete()`
    operation of the document object right after fetching it from the collection:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE49]'
  prefs: []
  type: TYPE_PRE
- en: 'When creating query transactions, the `Frame` API provides two class methods
    – the `many()` method, which extracts all BSON documents, and the `one()` method,
    which returns a single document object. Both operations can accept a query expression
    as an argument if there are any constraints. Moreover, MongoFrames has a `Q` query
    maker class that’s used to build conditionals in a query expression. The expression
    starts with `Q`, followed by dot (`.`) notation to define the field name or path
    – for example, `Q.categories.fiction` – followed by an operator (for example,
    `==`, `!=`, `>`, `>=`, `<`, or `<=`) and finally a value. The following code shows
    examples of the query transactions being translated using the MongoFrames ODM
    syntax:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE50]'
  prefs: []
  type: TYPE_PRE
- en: The `get_book()` method shows how to extract a single `Book` document with a
    `Q` expression that filters the correct `id`, while `get_all_book()` retrieves
    all `Book` documents without any constraints.
  prefs: []
  type: TYPE_NORMAL
- en: The `many()` operator returns a list of `Frame` objects, while the `one()` operator
    returns a single `Frame` instance. To convert the result into JSON-able components,
    we need to invoke the `to_json_type()` method in each `Frame` instance.
  prefs: []
  type: TYPE_NORMAL
- en: 'As explained earlier, adding embedded documents is determined by the operation
    and not by the model attributes. In the following `add_category()` transaction,
    it is clear that a `Category` object has been assigned to a `category` field of
    a `Book` instance, even if the field is not defined to refer to an embedded document
    of the `Category` type. Instead of throwing an exception, MongoFrame will update
    the `Book` document right after the `update()` call:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE51]'
  prefs: []
  type: TYPE_PRE
- en: Now, it is time to apply these CRUD transactions to our API services.
  prefs: []
  type: TYPE_NORMAL
- en: Applying the repository layer
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Our repository classes will not work if we do not inject the `create_db_client()`
    injectable into the router. The following solution injects the component into
    `APIRouter`, even if it is acceptable to inject it into each API service implementation:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE52]'
  prefs: []
  type: TYPE_PRE
- en: The `create_book()` service uses `BookRepository` to insert book details into
    the MongoDB database. In general, MongoFrames has an easy setup because it requires
    fewer configuration details for creating the database connection, building the
    model layer, and implementing the repository transactions. Its platform can be
    adapted to the existing requirements of the application and can easily reflect
    changes if modifications need to be made to its mapping mechanisms.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we looked at various ways to manage data using MongoDB. We
    utilized MongoDB to store non-relational data for our *online book reselling system*
    since we expect the data to become large when information is exchanged between
    the book buyers and resellers. Additionally, the details involved in the transactions
    are mainly strings, floats, and integers, which are all order and purchase values
    that will be easier to mine and analyze if they’re stored in schema-less storage.
  prefs: []
  type: TYPE_NORMAL
- en: This chapter took the non-relational data management roadmap for utilizing the
    data in sales forecasting, regression analysis of book readers’ demands, and other
    descriptive data analysis forms.
  prefs: []
  type: TYPE_NORMAL
- en: First, you learned how the PyMongo and Motor drivers connect the FastAPI application
    to the MongoDB database. After understanding the nuts and bolts of creating CRUD
    transactions using these drivers, you learned that ODM is the better option for
    pursuing MongoDB connectivity. We explored the features of MongoEngine, Beanie,
    ODMantic, and MongoFrames and studied their strengths and weaknesses as ODM mappers.
    All these ODMs can be integrated well with the FastAPI platform and provide the
    application with a standardized way to back up data.
  prefs: []
  type: TYPE_NORMAL
- en: Now that we’ve spent two chapters covering data management, in the next chapter,
    we will learn how to secure our FastAPI microservice applications.
  prefs: []
  type: TYPE_NORMAL
