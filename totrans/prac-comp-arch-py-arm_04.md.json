["```py\n[MBR] ← [[MAR]]   @ A read operation (example of indirect addressing)\n```", "```py\n\nFETCH [MAR] ← [PC]        @ Copy contents of the PC to the MAR\n      [PC]  ← [PC] + 1    @ Increment the contents of the PC to point to next instruction\n      [MBR] ← [[MAR]]     @ Read the instruction from memory\n      [IR]  ← [MBR]       @ Move the instruction to the instruction register for processing\n```", "```py\n      CU    ← [IRopcode]  @ Transmit the opcode to the control unit\n```", "```py\n\n                                # Testing the fetch cycle\nmem = [0] * 16                  # Set up 16 locations in memory\npc = 0                          # Initialize pc to 0\nmem[0] = 0b011000001010         # Dummy first instruction (opcode in bold) 0b indicates binary value\nmem[1] = 0b100011111111         # Dummy second instruction\ndef fetch(memory):              # Fetch cycle implemented using a function\n    global pc                   # Make pc global because we change it\n    mar = pc                    # Copy pc to mar\n    pc = pc + 1                 # Increment the pc ready for next instruction\n    mbr = memory[mar]           # Read instruction from memory\n    ir = mbr                    # Copy instruction to instruction register\n    cu = ir >> 8                # Shift instruction 8 places right to get the operation code\n    address = ir & 0xFF         # Mask opcode to 8-bit address\n    return(cu, address)         # Return instruction and address\nopCode,address = fetch(mem)     # Do a fetch cycle\nprint('pc =', pc - 1, 'opcode =', opCode, ' Operand =', address)\nopCode,address = fetch(mem)     # Do a fetch cycle\nprint('pc =', pc - 1, 'opcode =', opCode, ' Operand =', address)\n```", "```py\n\n    ir  = mem[pc]               # Read current instruction into ir\n    pc = pc + 1                 # Increment program counter ready for next cycle\n    cu = ir >> 8                # Extract the opcode\n    address = ir & 0xFF         # Extract the operand address\n```", "```py\n\n[r0] ← [r0] + [X]       @ Add the contents of the memory\n                         location X to register r0\n```", "```py\n\nFETCH [MAR] ← [PC]        Move the contents of the PC to the MAR\n      [PC]  ← [PC] + 1    Increment the contents of the PC\n      [MBR] ← [[MAR]]      Read the current instruction from the memory\n      [IR]  ← [MBR]       Move the contents of the MBR to the IR\n      CU    ← [IRopcode]      Move the opcode from the IR to the CU\nADD   [MAR] ← [IRaddress]             Move the operand address to the MAR\n[MBR] ← [[MAR]]Read the data from memory\n      ALU← [MBR], ALU ← [r2] Perform the addition\n      [r2]  ← ALUMove the output of ALU to the data register\n```", "```py\n\n# Implement fetch cycle and execute cycle: include three test instructions\nmem = [0] * 12                     # Set up 12-location memory\npc = 0                             # Initialize pc to 0\nmem[0] = 0b000100001100            # First instruction load r0 with 12\nmem[1] = 0b001000000111            # Second instruction add mem[7] to r0\nmem[2] = 0b111100000000            # Third instruction is stop\nmem[7] = 8                         # Initial data inlocation 7 is 8\ndef fetch(memory):                 # Function for fetch phase\n    global pc                      # Make pc a global variable\n    ir = memory[pc]                # Read instruction and move to IR\n    pc = pc + 1                    # Increment program counter for next cycle\n    return(ir >> 8, ir & 0xFF)     # Returns opCode and operand\nrun = 1                            # run = 1 to continue\nwhile run == 1:                    # REPEAT: The program execution loop\n    opCode, address = fetch(mem)   # Call fetch to perform fetch phase\n    if   opCode == 0b1111: run = 0 # Execute phase for  stop (set run to 0 on stop)\n    elif opCode == 0b0001:         # Execute phase for load number\n         r0 = address              # Load r0 with contents of address field\n    elif opCode == 0b0010:         # Execute phase for add\n         mar = address             # Copy address in opCode to MAR\n         mbr = mem[mar]            # Read the number to be dded\n         r0 = mbr + r0             # Do the addition\n    print('pc = ',pc - 1, 'opCode =', opCode, 'Register r0 =',r0)\n                                   # We print pc – 1 because the pc is incremented\n```", "```py\n\npc =  0 opCode = 1  Register r0 = 12\npc =  1 opCode = 2  Register r0 = 20\n```", "```py\npc =  2 opCode = 15 Register r0 = 20\n```", "```py\nIF condition THEN action\n```", "```py\n\n     SUB  r0,x    @ Subtract the contents of memory location x from register r0\n     BEQ  Last    @ If the result was zero, then branch to Last; otherwise, continue\n     .            @ Execute here if branch not taken\n     .\nLast              @ Target address of branch (if taken)\n```", "```py\n\nMOV   [MAR] ← [r0]        Move the source operand address to the MAR\n      [MBR] ← [[MAR]]     Read the actual operand from memory\n      [MAR] ← [MBR]       Copy the address back to the MAR\n      [r1]  ← [[MAR]]     Copy the data from memory to r1\n```", "```py\n\n                             # Simple program to test a branch instruction\nmem = [0] * 12               # Set up a 12-location memory\npc = 0                       # Initialize program counter to 0\nmem[0] = 0b000100001001      # First instruction loads r0 with 9 (i.e., 1001)\nmem[1] = 0b001100000111      # Second instruction subtracts mem[7] from r0\nmem[2] = 0b010000000110      # Third instruction is BEQ 6 (branch on zero to 6)\nmem[3] = 0b111100000000      # Fourth instruction is stop\nmem[6] = 0b111100000000      # Seventh instruction is stop\nmem[7] = 9                   # Initial data in location 7 is 9\n                             # Fetch returns opcode and address\ndef fetch(memory):           # This function, fetch, gets the instruction from memory\n    global pc                # Declare pc as global because we modify it in the function\n    ir = memory[pc]          # Read the instruction from memory\n    pc = pc + 1              # Now point to the next instruction\n    return(ir>>8, ir&0xFF)   # Return the opcode and address\nz = 0                                             # Clear z bit initially\nrun = 1                                           # run = 1 to continue\nwhile run == 1:                                   # Main loop REPEAT until stop found\n    pcOld = pc                                    # Save current pc for display\n    opCode, address = fetch(mem)                  # Perform fetch to get opcode\n    if   opCode == 0b1111: run = 0                # Test for stop\n    elif opCode == 0b0001: r0 = address           # Test for load literal\n    elif opCode == 0b0010: r0 = r0 + mem[address] # Test for add\n    elif opCode == 0b0011:                        # Test for subtract\n        r0 = r0 - mem[address]                    # Do subtraction\n        if r0 == 0: z = 1                         # Update z flag on subtract\n        else:       z = 0\n    elif opCode == 0b0100:                        # Test for branch on zero\n        if z == 1: pc = address                   # If BEQ, load PC on zero flag\n    print('pc = ',pcOld,'opCode =',opCode,'\\tRegister r0 =',r0,'z = ',z)\n                                                  # The '\\t' performs a tab operation\n```", "```py\n\npc =  0 opCode = 1  Register r0 = 9 z =  0\npc =  1 opCode = 3  Register r0 = 0 z =  1\npc =  2 opCode = 4  Register r0 = 0 z =  1        z = 1 so branch taken\npc =  6 opCode = 15 Register r0 = 0 z =  1\n```", "```py\n\n[c] ← [b] – [a]\nif [c] != 0: [pc] ← d\nelse: [pc] ← [pc] + 1\n```", "```py\n\n        LDRL r0,0          @ Load register r0 with 0 (the sum)\n        LDRL r1,0          @ Load register r1 with 0 (the counter)\nLoop    ADDL r1,r1,1       @ Increment the counter in r1\n        ADD  r0,r0,r1      @ Add the count to the sum in r0\n        CMPL r1,10         @ Compare the count with 10\n```", "```py\n        BNE  Loop          @ Branch back to Loop until all numbers added\n```", "```py\n\nLDA A            @ Load accumulator with A\nADD B            @ Add B to the accumulator\nSTA C            @ Store the accumulator in C\n```", "```py\n\nLDR r0,[r1]      @ Load r0 with data pointed at by r1\nLDR r2,[r3]      @ Load r2 with data pointed at by r3\nADD r4,r0,r2     @ Add r0 and r2, result in r4\nSTR r4,[r5]      @ Store r4 in memory pointed at by r5\n```"]