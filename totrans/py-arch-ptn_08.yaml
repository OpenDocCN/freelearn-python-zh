- en: '6'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '6'
- en: Web Server Structures
  id: totrans-1
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 网络服务器结构
- en: Web servers are the most common servers for remote access at the moment. Web
    services based on HTTP are flexible and powerful.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 目前，网络服务器是远程访问中最常见的服务器。基于HTTP的Web服务灵活且强大。
- en: 'In this chapter, we will see how web servers are structured, starting by describing
    how the basic request-response architecture works, and then diving into a LAMP-style
    architecture in three layers: the web server itself, the workers executing the
    code, and an intermediate layer that controls those workers and presents a standardized
    connection to the web server.'
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将了解网络服务器的结构，首先描述基本请求-响应架构是如何工作的，然后深入探讨三层LAMP风格的架构：服务器本身、执行代码的工作者以及控制这些工作者并向服务器提供标准化连接的中间层。
- en: We will describe each layer in detail, presenting a specific tool, such as nginx
    for the web server, uWSGI for the intermediate layer, and the Python Django framework
    for the specific code inside the worker. We will describe each of them in detail.
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将详细描述每一层，展示特定的工具，例如用于网络服务器的nginx，用于中间层的uWSGI，以及用于工作者内部特定代码的Python Django框架。我们将详细描述每一个。
- en: We will also include the Django REST framework, as it's a tool that builds on
    top of Django to generate RESTful API interfaces.
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还将包括Django REST框架，因为它是一个构建在Django之上的工具，用于生成RESTful API接口。
- en: Finally, we will describe how extra layers can be added on top for greater flexibility,
    scalability, and performance.
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们将描述如何添加额外的层以实现更大的灵活性、可扩展性和性能。
- en: 'In this chapter, we''ll cover the following topics:'
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: 本章我们将涵盖以下主题：
- en: Request-response
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 请求-响应
- en: Web architecture
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 网络架构
- en: Web servers
  id: totrans-10
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 网络服务器
- en: uWSGI
  id: totrans-11
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: uWSGI
- en: Python workers
  id: totrans-12
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Python工作者
- en: External layers
  id: totrans-13
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 外部层
- en: Let's start by describing the basis of the request-response architecture.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们先描述请求-响应架构的基础。
- en: Request-response
  id: totrans-15
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 请求-响应
- en: The classical server architecture is heavily based on request-response to communicate.
    A client sends a request to a remote server and the server processes it and returns
    a response.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 经典的服务器架构在通信上严重依赖于请求-响应。客户端向远程服务器发送请求，服务器处理它并返回响应。
- en: This communication pattern has been prevalent since the era of mainframes and
    works in an analog manner as software communicates internally with a library,
    but over a network. The software calls a library and receives a response from
    it.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 这种通信模式自主机时代以来一直很流行，它以类似的方式工作，即软件通过库与内部通信，但通过网络。软件调用一个库并从它那里接收响应。
- en: An important element is the time delay between the sending of the request and
    the reception of the response. Internally, it is rare that a call takes more than
    a couple of milliseconds, but for a network, it may be measured in hundreds of
    milliseconds and seconds, very commonly.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 一个重要元素是请求发送和响应接收之间的时间延迟。内部，调用通常不会超过几毫秒，但对于网络来说，它可能以百毫秒和秒来衡量，非常常见。
- en: Network calls are very dependent on where the server is located. A call within
    the same data center will be fast, perhaps taking less than 100 milliseconds,
    while a connection to an external API will likely take close to a second or more.
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 网络调用非常依赖于服务器所在的位置。在同一数据中心内的调用将会很快，可能不到100毫秒，而连接到外部API的调用可能接近一秒或更长。
- en: Times will also be highly variable, as the network conditions may affect them
    greatly. This time difference makes it important to handle it properly.
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 时间也会有很大的变化，因为网络条件可能会极大地影响它们。这种时间差异使得正确处理它变得很重要。
- en: The usual strategy when making requests is to make them synchronously. That
    means that the code stops and waits until the response is ready. This is convenient,
    as the code will be simple, but it's also inefficient, as the computer will be
    not doing anything while the server is calculating the response and it's being
    transferred through the network.
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 在发出请求时，通常的策略是同步进行。这意味着代码会停止并等待直到响应准备好。这很方便，因为代码将会很简单，但这也低效，因为当服务器正在计算响应并通过网络传输时，计算机将不会做任何事情。
- en: The client can be improved to perform multiple requests at the same time. This
    can be done when the requests are independent of each other, allowing it to make
    them in parallel. An easy way to achieve this is to use a multithreaded system
    to perform them, so they can speed up the process.
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 客户端可以被改进以同时执行多个请求。这可以在请求彼此独立时进行，允许它并行执行。实现这一点的简单方法是使用多线程系统来执行它们，这样它们可以加快处理过程。
- en: Typically, a flow will be required, with some requests that can be performed
    in parallel and others that require waiting until information is received. For
    example, a common request to retrieve a web page will make one request to retrieve
    the page and later will download multiple files referenced (e.g. header files,
    images) in parallel.
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 通常，需要一个流程，其中一些请求可以并行执行，而其他请求则需要等待收到信息。例如，一个常见的请求是检索网页，它将发送一个请求来检索页面，稍后将以并行方式下载多个引用的文件（例如，头文件、图像）。
- en: We will see later in the chapter how this effect can be designed to increase
    the responsiveness of web pages.
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将在本章后面看到，如何设计这种效果来提高网页的响应性。
- en: The fact that the network is more unreliable than a local call, requires better
    error handling that understands this fact. Any request-response system should
    take extra care about capturing different errors, and retry, as network problems
    typically are transient, and can be recovered if retried after waiting.
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 事实上，网络比本地调用更不可靠，需要更好的错误处理来理解这一事实。任何请求-响应系统都应该特别注意捕获不同的错误，并重试，因为网络问题通常是短暂的，如果在等待后重试，可以恢复。
- en: As we saw in *Chapter 2*, *API Design* the multiple status codes from HTTP can
    give detailed information.
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我们在*第二章*，*API设计*中看到的，HTTP的多个状态码可以提供详细的信息。
- en: Another characteristic of the request-response pattern is that a server cannot
    call the client proactively, only return information. This simplifies the communication,
    as it's not entirely bidirectional. The client is required to initiate the request,
    and the server only needs to listen for new requests coming. This also makes both
    roles asymmetrical and requires the client to know where the server is, usually
    by its DNS address and the port to access (by default, port 80 for HTTP and 443
    for HTTPS).
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 请求-响应模式的另一个特点是服务器不能主动调用客户端，只能返回信息。这简化了通信，因为它不是完全的双向的。客户端需要发起请求，而服务器只需要监听新的请求。这也使得两个角色不对称，并要求客户端知道服务器的位置，通常是通过DNS地址和访问端口（默认情况下，HTTP为80端口，HTTPS为443端口）。
- en: This characteristic makes some communication patterns difficult to achieve.
    For example, full bidirectional communication, where two parts want to initiate
    the sending of messages, is difficult to achieve with request-response.
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 这种特性使得某些通信模式难以实现。例如，完全双向通信，其中两部分都希望发起消息的发送，在请求-响应中很难实现。
- en: A crude example of this is a message server implemented only in request-response.
    Two clients require the usage of an intermediate server.
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 这种方法的粗略例子是仅通过请求-响应实现的邮件服务器。两个客户端需要使用一个中间服务器。
- en: This basic structure is common in applications like forums or social networks
    that allow the users to have some sort of direct messaging between users.
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 这种基本结构在允许用户之间进行某种直接消息传递的应用程序中很常见，如论坛或社交网络。
- en: 'Each user can perform two actions:'
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 每个用户可以执行两个操作：
- en: Request any new message addressed to them
  id: totrans-32
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 请求任何发送给他们的新消息
- en: Send a new message to another user
  id: totrans-33
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 向另一个用户发送新消息
- en: A user needs to check periodically whether there are new messages available
    through polling. This is inefficient, as it's likely that for any new message
    there'll be a significant number of checks that return "no new messages available."
    Even worse, there could be a significant delay before noticing that a new message
    is available if the checks are not performed often enough.
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 用户需要定期检查是否有新消息可用，这通过轮询来实现。这是低效的，因为对于任何新消息，都可能存在大量的检查返回“没有新消息可用”。更糟糕的是，如果检查不够频繁，可能会出现显著的延迟，才会注意到有新消息可用。
- en: In real applications, normally this polling is avoided by sending a notification
    in a way that's proactive towards the client. For example, mobile OSes have a
    system to deliver notifications, enabling the server to send a notification through
    an external API provided by the OS to notify the user of a new message. An older
    alternative is to send an email with the same goal.
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 在实际应用中，通常通过向客户端发送通知来避免这种轮询。例如，移动操作系统有一个系统来传递通知，允许服务器通过操作系统提供的API发送通知，通知用户有新消息。一个较老的替代方案是发送一封电子邮件达到相同的目的。
- en: There are other alternatives, of course. There are P2P alternatives, where two
    clients can connect to each other, and there are connections with a server through
    websockets that can remain open, allowing the server to notify the user of new
    information. They both deviate from the request-response architecture.
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 当然，还有其他替代方案。有P2P替代方案，其中两个客户端可以相互连接，还有通过websockets与服务器建立连接，这些连接可以保持打开状态，允许服务器通知用户新的信息。它们都偏离了请求-响应架构。
- en: Even with these limitations, request-response architecture is the basis of web
    services and has been proven to be very reliable over the decades. The possibility
    of having a central server that controls communication and can take a passive
    role in accepting new requests makes the architecture simple to implement and
    quick to evolve, and simplifies the client's work. The centralized aspect allows
    a lot of control.
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 即使有这些限制，请求-响应架构仍然是Web服务的基础，并且在几十年中被证明是非常可靠的。存在一个中央服务器来控制通信并可以被动地接受新请求的可能性，使得架构易于实现和快速演进，并简化了客户端的工作。集中的方面允许进行大量控制。
- en: Web architecture
  id: totrans-38
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 网络架构
- en: 'We introduced in the introduction of the chapter the LAMP architecture, which
    is the base for the web server architecture:'
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章的引言中，我们介绍了LAMP架构，它是网络服务器架构的基础：
- en: '![Diagram'
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: '![图'
- en: Description automatically generated](img/B17580_06_01.png)
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 自动生成的描述](img/B17580_06_01.png)
- en: 'Figure 6.1: The LAMP architecture'
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 图6.1：LAMP架构
- en: The LAMP architecture is more general, but we will take a closer look at the
    web server and web worker. We will use specific tools, based on the Python ecosystem,
    but we will discuss possible alternatives.
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: LAMP架构更为通用，但我们将更详细地研究网络服务器和网络工作进程。我们将使用基于Python生态系统的特定工具，但我们将讨论可能的替代方案。
- en: '![Diagram'
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: '![图'
- en: Description automatically generated](img/B17580_06_02.png)
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 自动生成的描述](img/B17580_06_02.png)
- en: 'Figure 6.2: More detailed architecture in a Python environment'
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 图6.2：Python环境中的更详细架构
- en: From the point of view of an incoming request, a web request accesses the different
    elements.
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 从传入请求的角度来看，Web请求访问不同的元素。
- en: Web servers
  id: totrans-48
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 网络服务器
- en: The **web server** exposes the HTTP port, accepts incoming connections, and
    redirects them towards the backend. One common option is nginx ([https://www.nginx.com/](https://www.nginx.com/)).
    Another common option is Apache ([https://httpd.apache.org/](https://httpd.apache.org/)).
    The web server can directly serve a request, for example, by directly returning
    static files, permanent redirects, or similar simple requests. If the request
    requires more computation, it will be directed towards the backend, acting as
    a reverse proxy.
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: '**网络服务器**公开HTTP端口，接受传入的连接，并将它们重定向到后端。一个常见的选项是nginx ([https://www.nginx.com/](https://www.nginx.com/))。另一个常见的选项是Apache
    ([https://httpd.apache.org/](https://httpd.apache.org/))。网络服务器可以直接服务请求，例如，通过直接返回静态文件、永久重定向或类似的简单请求。如果请求需要更多的计算，它将被重定向到后端，充当反向代理。'
- en: The primary objective of the web server in the presented architecture is to
    work as a reverse proxy, accepting HTTP requests, stabilizing the input of data,
    and queuing the incoming requests.
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 在所展示的架构中，网络服务器的主要目标是充当反向代理，接受HTTP请求，稳定数据输入，并排队处理传入的请求。
- en: A basic configuration for nginx could look like this. The code is available
    on GitHub at [https://github.com/PacktPublishing/Python-Architecture-Patterns/blob/main/chapter_06_web_server/nginx_example.conf](https://github.com/PacktPublishing/Python-Architecture-Patterns/blob/main/chapter_06_web_server/nginx_example.conf).
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: nginx的基本配置可能看起来像这样。代码可在GitHub上找到：[https://github.com/PacktPublishing/Python-Architecture-Patterns/blob/main/chapter_06_web_server/nginx_example.conf](https://github.com/PacktPublishing/Python-Architecture-Patterns/blob/main/chapter_06_web_server/nginx_example.conf)。
- en: '[PRE0]'
  id: totrans-52
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: The directive `server` opens and closes the basic block to define how to serve
    the data. Note each line ends with a semicolon.
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 指令`server`用于打开和关闭基本块，以定义如何服务数据。注意每行都以分号结尾。
- en: In nginx parlance, each server directive defines a virtual server. Normally
    there will be only one, but multiple can be configured, for example, to define
    different behaviors based on the DNS addressed.
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 在nginx术语中，每个服务器指令定义了一个虚拟服务器。通常只有一个，但也可以配置多个，例如，根据DNS地址定义不同的行为。
- en: 'Inside, we have a basic configuration on what port to serve – in our case,
    port 80 and both IPv4 and IPv6 addresses. The `default_server` clause means this
    is the server to be used by default:'
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 在内部，我们有一个基本配置，说明在哪个端口提供服务——在我们的例子中，端口80和IPv4和IPv6地址。`default_server`子句表示这是默认要使用的服务器：
- en: '[PRE1]'
  id: totrans-56
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: IPv4 is the common address with four numbers, like `127.0.0.1`. IPv6 is longer,
    and it's intended as a replacement for IPv4\. For example, an IPv6 address can
    be expressed as `2001:0db8:0000:0000:0000:ff00:0042:7879`. IPv4 addresses have
    already been exhausted, meaning that there are no new addresses available. IPv6
    will in the long run provide enough to avoid this problem, though IPv4 is still
    widely used, and probably will remain in use for a long time yet.
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: IPv4是常见的四数字地址，如`127.0.0.1`。IPv6更长，它被设计为IPv4的替代品。例如，一个IPv6地址可以表示为`2001:0db8:0000:0000:0000:ff00:0042:7879`。IPv4地址已经耗尽，这意味着没有新的地址可用。从长远来看，IPv6将提供足够的地址以避免这个问题，尽管IPv4仍然被广泛使用，并且可能还会继续使用很长时间。
- en: Next, we define where the static files are, both in terms of the external URL,
    and what is the mapping with some section of the hard drive.
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们定义静态文件的位置，包括外部URL以及与硬盘某个部分的映射。
- en: 'Note the static location needs to be defined before the reverse proxy:'
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 注意静态位置需要在反向代理之前定义：
- en: '[PRE2]'
  id: totrans-60
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: '`root` defines the starting point, while `location` starts a section that will
    serve the URL `/static/file1.txt` from the file located in the hard drive at `/opt/static/file1.txt`.'
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: '`root`定义了起点，而`location`开始一个将URL `/static/file1.txt`从硬盘上的`/opt/static/file1.txt`文件中提供的服务部分。'
- en: '`try_files` will scan for files in the URI and raise a 404 error if it''s not
    there.'
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: '`try_files`将扫描URI中的文件，如果不存在则引发404错误。'
- en: '`autoindex` automatically generates an index page to check the contents of
    a directory.'
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: '`autoindex`自动生成索引页面以检查目录的内容。'
- en: This option is typically disabled in production servers, but it's very handy
    to detect problems with static files while running in test mode.
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 这个选项通常在生产服务器上被禁用，但在测试模式下运行时检测静态文件问题非常有用。
- en: It's important in production environments to serve static files directly from
    the web server, instead of doing them further along the line with the Python worker.
    While this is possible, and a common case when working in a development environment,
    it's very inefficient. The speed and memory usage will be much bigger, while a
    web server is optimized to serve static files. Please always remember to serve
    static files in production through a web server.
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 在生产环境中，直接从Web服务器提供静态文件，而不是在Python工作流中进一步处理，这是很重要的。虽然这是可能的，并且在开发环境中是一个常见情况，但它非常低效。速度和内存使用将大大增加，而Web服务器已经优化了提供静态文件。请始终记住，在生产环境中通过Web服务器提供静态文件。
- en: Serving static content externally
  id: totrans-66
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 外部提供静态内容
- en: 'An alternative is to use an external service to handle files, like AWS S3,
    that allows you to serve static files. The files then will be under a different
    URL than the service, for example:'
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 另一个选择是使用外部服务来处理文件，例如AWS S3，它允许你提供静态文件。文件将位于与服务的不同URL下，例如：
- en: The service URL is `https://example.com/index`
  id: totrans-68
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 服务的URL是`https://example.com/index`
- en: The static files are in `https://mybucket.external-service/static/`
  id: totrans-69
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 静态文件在`https://mybucket.external-service/static/`
- en: All the references inside the service web pages, then, should point to the external
    service endpoint.
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，服务网页内的所有引用都应指向外部服务端点。
- en: This way of operating requires you to push the code to the external service
    as part of the deployment. To allow for uninterrupted deployments, remember that
    the static content needs to be available before. Another important detail is to
    upload them with a different path, so static files between deployments are not
    confused.
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 这种操作方式要求你将代码作为部署的一部分推送到外部服务。为了允许不间断的部署，请记住，静态内容需要在之前可用。另一个重要细节是使用不同的路径上传它们，以便部署之间的静态文件不会混淆。
- en: 'This is easy to do using different root paths. For example:'
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 使用不同的根路径来做这件事很容易。例如：
- en: Version `v1` of the service is deployed. This is the starting point. The static
    content is served from `https://mybucket.external-service/static/v1/`.
  id: totrans-73
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 服务的`v1`版本已部署。这是起点。静态内容从`https://mybucket.external-service/static/v1/`提供。
- en: The calls to the service, like `https://example.com/index`, return all their
    static content pointing at version `v1`.
  id: totrans-74
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 对服务的调用，如`https://example.com/index`，返回所有指向版本`v1`的静态内容。
- en: Once `v2` of the service is ready, the first thing to do is to push it to the
    external service, so it's available in `https://mybucket.external-service/static/v2/`.
    Note that, at this point, no user is accessing `/static/v2`; the service is still
    returning `/static/v1`.
  id: totrans-75
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 一旦服务的`v2`版本准备就绪，首先要做的就是将其推送到外部服务，以便在`https://mybucket.external-service/static/v2/`中可用。注意，在这个时候，没有用户访问`/static/v2`；服务仍然返回`/static/v1`。
- en: Deploy the new service. Once it is deployed, the users will start accessing
    `/static/v2` when they call `https://example.com/index`.
  id: totrans-76
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 部署新服务。一旦部署完成，用户在调用 `https://example.com/index` 时将开始访问 `/static/v2`。
- en: As we've seen in previous chapters, the key for a seamless deployment is to
    perform actions in small increments, and each step must perform actions that are
    reversible and prepare the terrain so there's no moment when something that's
    required is not ready.
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我们在前面的章节中看到的，无缝部署的关键是分小步骤执行操作，并且每一步都必须执行可逆的操作，并准备好地形，以便没有某个必需的元素尚未准备好的时刻。
- en: This approach can be used for big operations. In a JavaScript-heavy interface,
    like a single-page application, changing the static files effectively can be a
    new deployment. The underlying service API can remain the same but changing the
    downloaded version for all JavaScript code and other static content, which in
    effect will deploy a new version.
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 这种方法可以用于大型操作。在一个 JavaScript 为主的界面，如单页应用程序中，更改静态文件实际上可以视为一个新的部署。底层服务 API 可以保持不变，但更改所有
    JavaScript 代码和其他静态内容的下载版本，这实际上将部署一个新版本。
- en: We talked about single-page apps in *Chapter 2*.
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在 *第二章* 中讨论了单页应用程序。
- en: This structure makes both versions of the static content available at the same
    time. This can also be used to make tests or release beta versions. As the service
    is returning whether to use version A or B, this can be set dynamically.
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 这种结构使得静态内容的两个版本可以同时可用。这也可以用来进行测试或发布测试版。由于服务返回是否使用版本 A 或 B，这可以动态设置。
- en: 'For example, adding an optional parameter in any call to overwrite the returned
    version:'
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，在任意调用中添加一个可选参数来覆盖返回的版本：
- en: Calling `https://example.com/index` returns the default version, for example,
    `v2`.
  id: totrans-82
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 调用 `https://example.com/index` 返回默认版本，例如，`v2`。
- en: Calling `https://example.com/index?overwrite_static=v3` returns the specified
    version instead, like `v3`.
  id: totrans-83
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 调用 `https://example.com/index?overwrite_static=v3` 将返回指定的版本，例如 `v3`。
- en: Other options are returning `v3` for specific users, like beta testers or internal
    staff. Once `v3` is deemed correct, it can be changed to be the new default with
    a small change in the service.
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 其他选项是为特定用户返回 `v3`，例如测试人员或内部员工。一旦 `v3` 被认为正确，可以通过对服务进行微小更改将其更改为新的默认版本。
- en: This approach can be taken to the extreme to push any single commit to the source
    control to the public S3 bucket, and then test in any environment, including production.
    This can help to generate a very fast feedback loop where QA or product owners
    can quickly see changes in their own browser, without requiring any deployment
    or special environment.
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 这种方法可以极端到将任何单个提交推送到源控制到公共 S3 存储桶，然后在任何环境中进行测试，包括生产环境。这可以帮助生成一个非常快速的反馈循环，其中 QA
    或产品所有者可以快速在自己的浏览器中看到更改，而无需进行任何部署或特殊环境。
- en: Don't feel limited to a unique integer as the version number; it can work as
    well with a random UUID or SHA of the content generated automatically. Web storage
    is quite cheap, so it would require a lot of versions with very big files to really
    start to worry about cost. And old versions can be deleted periodically.
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 不要将版本号限制为唯一的整数；它也可以与自动生成的随机 UUID 或内容的 SHA 一起工作。Web 存储相当便宜，所以只有当版本非常多且文件非常大时，才会真正开始担心成本。并且可以定期删除旧版本。
- en: While this approach can be very aggressive and not viable for all applications,
    for an application that requires many changes in a rich JavaScript interface or
    to make drastic changes to the look and feel, it can be highly productive.
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然这种方法可能非常激进，并不适用于所有应用程序，但对于需要在大型的 JavaScript 界面中进行许多更改或对外观和感觉进行重大更改的应用程序，它可以非常高效。
- en: This external serving can be combined with **CDN** (**content delivery network**)
    support for a multiregional proxy. This will distribute the files around the world
    to provide a copy of it closer to the user.
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 这种外部服务可以与 **CDN**（**内容分发网络**）支持的多区域代理结合使用。这将把文件分布到世界各地，为用户提供更接近的副本。
- en: Think of a CDN as an internal cache by the company providing the service. For
    example, we have a service where their servers are located in Europe, but a user
    is accessing it from Japan. This company has servers in Japan that store a copy
    of the static content. That means that the user can access the files with much
    lower latency than if the request had to reach a server in Europe, more than 8,000
    kilometers away.
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 将CDN视为提供服务公司的内部缓存。例如，我们有一个服务，他们的服务器位于欧洲，但用户从日本访问它。这家公司在日本有服务器，存储了静态内容的副本。这意味着用户可以以比请求必须到达欧洲的服务器（超过8000公里）低得多的延迟访问文件。
- en: Using a CDN is very powerful for truly global audiences. They are especially
    useful for serving data that requires low latency around the world. For example,
    broadcasting near real-time video.
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 使用CDN对于真正全球的受众来说非常强大。它们特别适用于需要全球低延迟的数据服务。例如，广播接近实时视频。
- en: Video broadcast online is typically transferred as small video chunks of a few
    seconds in duration. An index file keeps track of what is the latest chunk generated,
    so clients can be kept up to date. This is the basis of the format **HTTP Live
    Streaming**, or **HLS**, very common as the transfer of data is done directly
    through HTTP.
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 在线视频广播通常以持续几秒的小视频块形式传输。一个索引文件会记录最新生成的块是什么，这样客户端就可以保持最新状态。这是**HTTP实时流**（**HLS**）格式的基础，这种格式非常常见，因为数据传输是通过HTTP直接进行的。
- en: The data can be distributed internally between the different servers from the
    company providing the CDN service quite quickly, as they'll use dedicated networks
    between them instead of using an external network.
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 由于它们之间将使用专用网络而不是外部网络，因此CDN服务提供商的不同服务器之间可以非常快速地内部分发数据。
- en: In any case, using an external service to store the static files will, obviously,
    remove the need to configure the web server for them.
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 在任何情况下，使用外部服务来存储静态文件将显然消除为它们配置Web服务器的需要。
- en: Reverse proxy
  id: totrans-94
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 反向代理
- en: Let's continue describing the web server configuration. After describing the
    static files, we need to define a connection to the backend, acting as a reverse
    proxy.
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们继续描述Web服务器配置。在描述静态文件之后，我们需要定义一个连接到后端，充当反向代理的连接。
- en: A reverse proxy is a proxy server that can redirect a received request towards
    one or more defined backends. In our example, the backend is the uWSGI process.
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 反向代理是一种代理服务器，可以将接收到的请求重定向到一个或多个定义的后端。在我们的例子中，后端是uWSGI进程。
- en: A reverse proxy works in a similar way as a load balancer, though load balancers
    can work with more protocols, while a reverse proxy is only capable of working
    with web requests. On top of distributing requests across different servers, it
    can also add some features like caching, security, SSL termination (receiving
    a request in HTTPS and connecting to other servers using HTTP), or, in this particular
    case, receive a web request and transfer it to through a WSGI connection.
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 反向代理的工作方式与负载均衡器类似，尽管负载均衡器可以与更多协议一起工作，而反向代理只能处理Web请求。除了在不同服务器之间分配请求之外，它还可以添加一些功能，如缓存、安全性、SSL终止（接收HTTPS请求并使用HTTP连接到其他服务器），或者在这种情况下，接收Web请求并通过WSGI连接将其传输。
- en: The web server will be able to communicate with the backend in multiple ways,
    allowing flexibility. This can use different protocols, like FastCGI, SCGI, straight
    HTTP for pure proxying, or, in our case, connecting directly to the uWSGI protocol.
    We need to define it to connect through either a TCP socket or a UNIX socket.
    We will use a UNIX socket.
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: Web服务器将以多种方式与后端进行通信，从而提供灵活性。这可以使用不同的协议，如FastCGI、SCGI、直接HTTP进行纯代理，或者在我们的情况下，直接连接到uWSGI协议。我们需要定义它，以便通过TCP套接字或UNIX套接字连接。我们将使用UNIX套接字。
- en: TCP sockets are designed to allow communication between different servers, while
    UNIX sockets are designed to communicate processes locally. UNIX sockets are a
    little bit lighter for communication inside the same host and they work like a
    file, allowing you to assign them permissions to control what process can access
    what socket.
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: TCP套接字旨在允许不同服务器之间的通信，而UNIX套接字旨在本地通信进程。UNIX套接字在相同主机内部通信时稍微轻量一些，并且它们的工作方式类似于文件，允许你分配权限以控制哪些进程可以访问哪些套接字。
- en: 'The socket needs to be coordinated with the way uWSGI is configured. As we
    will see later, the uWSGI process will create it:'
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 套接字需要与uWSGI的配置方式相协调。正如我们稍后将会看到的，uWSGI进程将创建它：
- en: '[PRE3]'
  id: totrans-101
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: First of all, the root of the server is at the `/` URL. It's important to make
    the static content before the reverse proxy, as the locations are checked in order.
    So any request for a `/static` request gets detected before checking for `/` and
    it's properly treated.
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，服务器的根目录位于 `/` URL。在反向代理之前制作静态内容非常重要，因为检查的顺序是按照位置进行的。所以任何对 `/static` 的请求都会在检查
    `/` 之前被检测到，并且会得到适当的处理。
- en: The core of the reverse proxy configuration is the `uwsgi_pass` clause. This
    specified where to redirect the requests. `include uwgi_params` will add a bunch
    of standard configurations to be passed to the next stage.
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 反向代理配置的核心是 `uwsgi_pass` 子句。它指定了请求重定向的位置。`include uwgi_params` 将添加一些标准配置传递到下一阶段。
- en: '`uwsgi_params` is actually a defined file included by default in nginx config
    that adds a lot of `uwsgi_param` statements with elements like `SERVER_NAME`,
    `REMOTE_ADDRESS`, etc.'
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: '`uwsgi_params` 实际上是一个在 nginx 配置中默认包含的已定义文件，它添加了许多带有 `SERVER_NAME`、`REMOTE_ADDRESS`
    等元素的 `uwsgi_param` 语句。'
- en: More `uwsgi_param` can be added if necessary, in a similar way to the headers.
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 如果需要，可以添加更多的 `uwsgi_param`，方法与头部类似。
- en: Extra elements can be added as HTTP headers. They'll be added to the request,
    so they are available further down the request.
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 可以添加额外的元素作为 HTTP 头部。它们将被添加到请求中，因此它们在请求的后续部分是可用的。
- en: '[PRE4]'
  id: totrans-107
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: In this case, we are adding the `Host` header, with information about the requested
    host. Note that the `$host` is an indication to nginx to fill the value with the
    host the request is addressed to. In the same way, the header `X-Real-IP` is added
    with the IP address from the remote address.
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 在这种情况下，我们添加了 `Host` 头部，其中包含有关请求的主机信息。请注意，`$host` 是 nginx 填充请求所指向的主机值的指示。同样，添加了
    `X-Real-IP` 头部，其中包含远程地址的 IP 地址。
- en: Setting headers correctly to pass on is unappreciated work, but can be critical
    to properly monitor problems. Setting headers may require doing so at different
    stages. As we will discuss later, a single request can pass through multiple proxies,
    and each of them needs to adequately forward the headers.
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 正确设置头部信息以传递是一个不受重视的工作，但这对正确监控问题至关重要。设置头部可能需要在不同的阶段进行。正如我们稍后将要讨论的，单个请求可以穿过多个代理，并且每个代理都需要充分转发头部信息。
- en: In our configuration, we only use a single backend, as uWSGI will balance between
    different workers. But, if necessary, multiple backends can be defined, even mixing
    UNIX and TCP sockets, defining a cluster.
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的配置中，我们只使用单个后端，因为 uWSGI 会在不同的工作者之间进行平衡。但是，如果需要，可以定义多个后端，甚至可以混合 UNIX 和 TCP
    套接字，定义一个集群。
- en: '[PRE5]'
  id: totrans-111
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: Later, define the `uwsgi_pass` to use the cluster. The requests will be equally
    spread over the different backends.
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，定义 `uwsgi_pass` 以使用集群。请求将在不同的后端之间均匀分配。
- en: '[PRE6]'
  id: totrans-113
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: Logging
  id: totrans-114
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 日志记录
- en: 'We also need to track any possible error or access. There are two different
    logs that `nginx` (and other web servers) produces:'
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还需要跟踪任何可能的错误或访问。`nginx`（以及其他网络服务器）产生两个不同的日志：
- en: '**Error log**: The error log tracks possible problems from the web server itself,
    like not being able to start, configuration problems, etc.'
  id: totrans-116
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**错误日志**：错误日志跟踪来自网络服务器本身的可能问题，如无法启动、配置问题等。'
- en: '**Access log**: The access log reports any request accessing the system. This
    is the basic information about the system flowing. It can be used to find specific
    problems like 502 errors when the backend cannot be connected, or, when treated
    as aggregated, it can detect problems like an abnormal number of error status
    codes (`4xx` or `5xx`).'
  id: totrans-117
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**访问日志**：访问日志报告任何访问系统的请求。这是系统流动的基本信息。它可以用来查找特定问题，如后端无法连接时的502错误，或者，当作为聚合处理时，可以检测到异常数量的错误状态代码（`4xx`
    或 `5xx`）。'
- en: We will talk in further detail about logs in *Chapter 11*.
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将在第11章中更详细地讨论日志。
- en: Both logs are critical information that needs to be adequately detected. Following
    the Twelve-Factor App, we should treat them as streams of data. The easiest is
    to redirect them both to standard output.
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 这两个日志都是需要充分检测的关键信息。遵循十二要素应用原则，我们应该将它们视为数据流。最简单的方法是将它们都重定向到标准输出。
- en: '[PRE7]'
  id: totrans-120
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: This requires nginx to not start as a daemon process, or if it is, capture the
    standard output properly.
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 这要求 nginx 不要以守护进程的方式启动，或者如果它是以守护进程方式启动的，则正确捕获标准输出。
- en: Another option is to redirect the log into a centralized log facility, using
    the proper protocol. This directs all the logs into a centralized server that
    captures the information. In this example, we send it to a syslog host in `syslog_host`.
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 另一个选项是将日志重定向到集中日志设施，使用适当的协议。这将所有日志重定向到集中服务器，以捕获信息。在这个例子中，我们将其发送到 `syslog_host`
    上的 syslog 主机。
- en: '[PRE8]'
  id: totrans-123
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: This protocol allows you to include tags and extra information that can help
    separate the origin of each log later.
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 此协议允许您包含标签和额外信息，这些信息可以帮助在以后区分每个日志的来源。
- en: Being able to distinguish the source of each log is critical and always requires
    a bit of tweaking. Be sure to spend some time making the logs easy to search.
    It will greatly simplify the work when an error in production requires gathering
    information.
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 能够区分每个日志的来源至关重要，并且始终需要一些调整。请确保花些时间使日志易于搜索。当生产中出现错误需要收集信息时，这将极大地简化工作。
- en: Advanced usages
  id: totrans-126
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 高级用法
- en: A web server is very powerful, and shouldn't be underestimated. Other than acting
    purely as a proxy, there are a lot of other features that can be enabled like
    returning custom redirects, overwriting the proxy with a static page for maintenance
    windows, rewriting URLs to adjust changes, providing SSL termination (decrypt
    receiving HTTPS requests to pass them decrypted through regular HTTP, and encrypt
    the result back), caching requests, splitting the requests based on percentages
    for A/B testing, choosing a backend server based on geolocalization of the requester,
    etc.
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: Web 服务器非常强大，不应被低估。除了纯粹作为代理外，还有很多其他功能可以启用，如返回自定义重定向、在维护窗口期间用静态页面覆盖代理、重写 URL 以调整更改、提供
    SSL 终止（解密接收到的 HTTPS 请求，以便通过常规 HTTP 传递解密后的请求，并将结果加密回），缓存请求、根据百分比分割请求进行 A/B 测试、根据请求者的地理位置选择后端服务器等。
- en: Be sure to read the documentation of `nginx` at [http://nginx.org/en/docs/](http://nginx.org/en/docs/)
    to read all the possibilities.
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 请务必阅读 `nginx` 的文档，地址为 [http://nginx.org/en/docs/](http://nginx.org/en/docs/)，以了解所有可能性。
- en: uWSGI
  id: totrans-129
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: uWSGI
- en: The next element of the chain is the uWSGI application. This application receives
    the requests from `nginx` and redirects them into independent Python workers,
    in WSGI format.
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 链接的下一个元素是 uWSGI 应用程序。该应用程序接收来自 `nginx` 的请求并将它们重定向到独立的 Python 工作进程，以 WSGI 格式。
- en: '**Web Server Gateway Interface** (**WSGI**) is a Python standard to deal with
    web requests. It''s very popular and supported by a lot of software, both from
    the sending end (like `nginx`, but also other web servers like Apache and GUnicorn)
    and from the receiving end (virtually every Python web framework, like Django,
    Flask, or Pyramid).'
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: '**Web 服务器网关接口**（**WSGI**）是处理 Web 请求的 Python 标准。它非常流行，并且得到了许多软件的支持，包括发送端（如 `nginx`，以及其他
    Web 服务器，如 Apache 和 GUnicorn）和接收端（几乎每个 Python Web 框架，如 Django、Flask 或 Pyramid）。'
- en: uWSGI will also start and coordinate the different processes, handling the lifecycle
    for each of them. The application works as an intermediary, starting a group of
    workers receiving the requests.
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: uWSGI 还将启动和协调不同的进程，处理每个进程的生命周期。应用程序作为一个中介，启动一组接收请求的工作进程。
- en: uWSGI is configured through a `uwsgi.ini` file. Let's see an example, available
    on GitHub at [https://github.com/PacktPublishing/Python-Architecture-Patterns/blob/main/chapter_06_web_server/uwsgi_example.uni](https://github.com/PacktPublishing/Python-Architecture-Patterns/blob/main/chapter_06_web_server/uwsgi_example.uni).
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: uWSGI 通过 `uwsgi.ini` 文件进行配置。让我们看看一个例子，可在 GitHub 上找到，地址为 [https://github.com/PacktPublishing/Python-Architecture-Patterns/blob/main/chapter_06_web_server/uwsgi_example.uni](https://github.com/PacktPublishing/Python-Architecture-Patterns/blob/main/chapter_06_web_server/uwsgi_example.uni)。
- en: '[PRE9]'
  id: totrans-134
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'The first element defines what the working directory is. The application will
    be launched here, and other file references will work from here:'
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 第一个元素定义了工作目录是什么。应用程序将在这里启动，其他文件引用也将从这里开始：
- en: '[PRE10]'
  id: totrans-136
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: Then, we describe where the `wsgi.py` file is, which describes our application.
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们描述 `wsgi.py` 文件的位置，该文件描述了我们的应用程序。
- en: The WSGI application
  id: totrans-138
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: WSGI 应用程序
- en: Inside this file is the definition of the `application` function, which uWSGI
    can use to address the internal Python code, in a controlled way.
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 在此文件中是 `application` 函数的定义，uWSGI 可以以受控的方式使用它来访问内部 Python 代码。
- en: 'For example:'
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 例如：
- en: '[PRE11]'
  id: totrans-141
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: The first parameter is a dictionary with predefined variables that detail the
    request (like `METHOD`, `PATH_INFO`, `CONTENT_TYPE`, and so on) and parameters
    related to the protocol or environment (for example, `wsgi.version`).
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 第一个参数是一个包含预定义变量的字典，这些变量详细说明了请求（如 `METHOD`、`PATH_INFO`、`CONTENT_TYPE` 等）以及与协议或环境相关的参数（例如，`wsgi.version`）。
- en: The second parameter, `start_response`, is a callable that allows you to set
    up the return status and any headers.
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 第二个参数 `start_response` 是一个可调用对象，允许您设置返回状态和任何头信息。
- en: The function should return the body. Note how it's returned in byte stream format.
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 函数应该返回体。注意它是以字节流格式返回的。
- en: The difference between text streams (or strings) and byte streams was one of
    the big differences introduced in Python 3\. To summarize it, byte streams are
    raw binary data, while text streams contain meaning by interpreting that data
    through a particular encoding.
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 文本流（或字符串）与字节流之间的区别是 Python 3 引入的很大区别之一。为了总结，字节流是原始的二进制数据，而文本流通过特定的编码解释这些数据来包含意义。
- en: The differentiation between both can be a bit baffling sometimes, in particular
    since Python 3 makes the difference explicit, and that clashes with some previous
    lax practices, especially when dealing with ASCII content that can be represented
    in the same way.
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 这两种之间的区别有时可能有些令人困惑，尤其是在 Python 3 使这种区别变得明确的情况下，这与其他一些先前宽松的做法相冲突，尤其是在处理可以用相同方式表示的
    ASCII 内容时。
- en: Keep in mind that text streams need to be encoded to be transformed into byte
    streams, and byte streams need to be decoded into text streams. Encoding is moving
    from the abstract representation of text to the precise representation of binary.
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 请记住，文本流需要被编码才能转换为字节流，字节流需要被解码为文本流。编码是将文本的抽象表示转换为精确的二进制表示。
- en: 'For example, the Spanish word "cañón" contains two characters not present in
    ASCII, `ñ` and `ó`. You can see how encoding them through UTF8 replaces them with
    specific binary elements described in UTF8:'
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，西班牙语单词 "cañón" 包含两个在 ASCII 中不存在的字符，`ñ` 和 `ó`。您可以看到通过 UTF8 编码它们是如何被替换为 UTF8
    中描述的特定二进制元素的：
- en: '[PRE12]'
  id: totrans-149
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: The function can also work as a generator and use the keyword `yield` instead
    of `return` when the returning body needs to be streamed.
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 该函数还可以作为生成器工作，并在返回体需要流式传输时使用关键字 `yield` 而不是 `return`。
- en: Any function that uses `yield` is a generator in Python. This means that when
    called, it returns an iterator object that returns elements one by one, normally
    to be used in loops.
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 任何使用 `yield` 的函数在 Python 中都是生成器。这意味着当被调用时，它返回一个迭代器对象，逐个返回元素，通常用于循环中。
- en: This is very useful for situations where each element of the loop takes some
    time to process but can be returned without being required to calculate every
    single item, reducing latency and memory usage, as not all elements need to be
    maintained in memory.
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 这对于每种循环元素需要一些时间来处理但可以返回而不必计算每个单独的项目的情况非常有用，从而减少延迟和内存使用，因为不需要在内存中维护所有元素。
- en: '[PRE13]'
  id: totrans-153
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: In any case, the WSGI file is normally created by default by whatever framework
    is used. For example, a `wsgi.py` file created by Django will look like this.
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 在任何情况下，WSGI 文件通常由使用的框架默认创建。例如，Django 创建的 `wsgi.py` 文件看起来像这样。
- en: '[PRE14]'
  id: totrans-155
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: Note how the function `get_wsgi_application` will automatically set up the proper
    application function, and connect it with the rest of the defined code – a great
    advantage of using an existing framework!
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 注意函数 `get_wsgi_application` 将如何自动设置正确的应用程序函数，并将其与定义的其余代码连接起来——这是使用现有框架的一个巨大优势！
- en: Interacting with the web server
  id: totrans-157
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 与网络服务器交互
- en: 'Let''s continue with the `uwsgi.ini` configuration with the socket configuration:'
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们继续使用 `uwsgi.ini` 配置文件中的套接字配置：
- en: '[PRE15]'
  id: totrans-159
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: The `socket` parameter creates the UNIX socket for the web server to connect
    to. It was discussed before in this chapter, when talking about the web server.
    This needs to be coordinated on both sides, to ensure they connect properly.
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: '`socket` 参数为网络服务器创建用于连接的 UNIX 套接字。这在本章之前讨论网络服务器时已经讨论过。这需要在双方进行协调，以确保它们能够正确连接。'
- en: uWSGI also allows you to use a native HTTP socket, using the option `http-socket`.
    For example, `http-socket = 0.0.0.0:8000` to serve all addresses on port 8000\.
    You may use this option if the web server is not on the same server and needs
    to communicate through the network.
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: uWSGI 还允许您使用本机 HTTP 套接字，使用选项 `http-socket`。例如，`http-socket = 0.0.0.0:8000` 用于在端口
    8000 上服务所有地址。如果您使用的网络服务器不在同一服务器上并且需要通过网络进行通信，则可以使用此选项。
- en: When possible, avoid exposing uWSGI directly publicly over the internet. A web
    server will be safer and more efficient. It will also serve static content much
    more efficiently. If you really must skip the web server, use the option `http`
    instead of `http-socket`, which includes a certain level of protection.
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 当可能时，避免直接将 uWSGI 公开暴露在互联网上。使用一个网络服务器会更安全、更高效。它还能更高效地服务静态内容。如果你确实必须跳过网络服务器，请使用选项
    `http` 而不是 `http-socket`，后者包含一定程度的保护。
- en: The `vacuum` option cleans up the socket when the server is closed.
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: '`vacuum` 选项在服务器关闭时清理套接字。'
- en: Processes
  id: totrans-164
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 进程
- en: 'The next parameters control the number of processes and how to control them:'
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 下一个参数控制进程的数量以及如何控制它们：
- en: '[PRE16]'
  id: totrans-166
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: The `master` parameter creates a master process that ensures that the number
    of workers is correct, restarting if not, and deals with the process lifecycle,
    among other tasks. It should always be enabled in production for smooth operation.
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: '`master` 参数创建一个主进程，确保工作进程的数量正确，如果不正确则重启，并处理进程生命周期等任务。在生产环境中，为了平稳运行，应始终启用此参数。'
- en: The `processes` parameter is very straightforward and describes how many Python
    workers should be started. Received requests will be load balanced across them.
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: '`processes` 参数非常直接，描述了应该启动多少个 Python 工作进程。接收到的请求将在它们之间进行负载均衡。'
- en: The way uWSGI generates new processes is through pre-forking. This means that
    a single process gets started, and after the application is loaded (which may
    take a while), it's cloned through a fork process. This sensibly speeds up the
    startup time for new processes, but at the same time, relays that the setup of
    the application can be duplicated.
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: uWSGI 生成新进程的方式是通过预分叉。这意味着启动一个进程，在应用程序加载（可能需要一段时间）之后，通过分叉进程进行克隆。这合理地加快了新进程的启动时间，但同时也意味着应用程序的设置可以被复制。
- en: This assumption, on rare occasions, may cause problems with certain libraries
    that, for example, open file descriptors during initializations that cannot be
    shared safely. If that's the case, the parameter `lazy-apps` will make each worker
    start from scratch, independently. This is slower, but it creates more consistent
    results.
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 这种假设在罕见情况下可能会导致某些库出现问题，例如，在初始化期间打开文件描述符，而这些文件描述符无法安全共享。如果是这种情况，参数 `lazy-apps`
    将使每个工作进程从头开始独立启动。这会慢一些，但会创建更一致的结果。
- en: Choosing the right number of processes is highly dependent on the application
    itself and the hardware that supports it. The hardware is important as a CPU with
    multiple cores will be able to run more processes efficiently. The amount of IO
    vs CPU usage in the application will determine how many processes can be run by
    the CPU core.
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 选择正确的进程数量高度依赖于应用程序本身及其支持的硬件。硬件很重要，因为具有多个核心的 CPU 将能够更高效地运行更多进程。应用程序中的 IO 与 CPU
    使用量将决定 CPU 核心可以运行多少个进程。
- en: Theoretically, a process not using IO and purely crunching numbers will use
    the whole core without wait periods, not allowing the core to switch to another
    process meanwhile. A process with high IO, with the core idle while waiting for
    results from the database and external services, will increase its efficiency
    by performing more context switches. This number should be tested to ensure the
    best results. A common starting point will be two times the number of cores, but
    remember to monitor the system to tweak it and obtain the best results.
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 理论上，不使用 IO 且纯粹进行数值计算的进程将使用整个核心而无需等待时间，不允许核心在此期间切换到另一个进程。具有高 IO 的进程，在等待数据库和外部服务的结果时核心空闲，将通过执行更多上下文切换来提高其效率。这个数字应该经过测试以确保最佳结果。一个常见的起点是核心数的两倍，但请记住监控系统以调整它并获得最佳结果。
- en: An important detail about the created processes is that they deactivate the
    creation of new threads by default. This is an optimization choice. In the majority
    of web applications, there's no need to create independent threads inside each
    of the workers, and that allows you to deactivate the Python GIL, speeding up
    the code.
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 关于创建的进程的一个重要细节是，它们默认禁用新线程的创建。这是一个优化选择。在大多数网络应用程序中，不需要在每个工作进程内部创建独立的线程，这允许你禁用
    Python GIL，从而加快代码执行。
- en: The **Global Interpreter Lock** or **GIL** is a mutex lock that only allows
    a single thread to have control of the Python process. This means that, inside
    a single process, no two threads can run at the same time, something that multi-core
    CPU architecture makes possible. Note that multiple threads may be waiting for
    IO results while another runs, which is a usual situation in real-life applications.
    The GIL is typically held and released constantly, as each operation first holds
    the GIL and then releases it at the end.
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: '**全局解释器锁**（Global Interpreter Lock）或**GIL**是一种互斥锁，它只允许单个线程控制Python进程。这意味着在单个进程中，不会有两个线程同时运行，这是多核CPU架构使得成为可能的事情。请注意，当另一个线程运行时，多个线程可能正在等待IO结果，这在实际应用中是一种常见情况。GIL通常会被频繁地获取和释放，因为每个操作首先获取GIL，然后在结束时释放它。'
- en: The GIL is commonly blamed for inefficiencies in Python, though the effect is
    only perceived in high-CPU multi-threaded operations in native Python (as opposed
    to using optimized libraries like NumPy), which are not as usual and are already
    slow to start with.
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: GIL通常被指责是Python效率低下的原因，尽管这种影响只有在原生Python中的高CPU多线程操作（与使用优化库如NumPy相比）中才会感觉到，而这些操作并不常见，而且它们本身就启动缓慢。
- en: These interactions with the GIL are only wasteful if no threads will be run,
    so that's why uWSGI deactivates it by default.
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 与GIL的这些交互只有在没有线程将运行的情况下才是浪费的，这就是为什么uWSGI默认禁用它的原因。
- en: If threads need to be used, the option `enable-threads` will enable them.
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 如果需要使用线程，`enable-threads`选项将启用它们。
- en: Process lifecycle
  id: totrans-178
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 进程生命周期
- en: During the time of operation, processes won't stay static. Any working web application
    will need to reload with new code changes regularly. The next parameters are related
    to how processes are created and destroyed.
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: 在操作期间，进程不会保持静态。任何正在运行的网络应用都需要定期重新加载以应用新的代码更改。接下来的参数与进程的创建和销毁有关。
- en: '[PRE17]'
  id: totrans-180
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: '`max-requests` specifies the number of requests to be processed by a single
    worker before being restarted. Once the worker gets to this number, uWSGI will
    destroy it and create another worker from scratch, following the usual process
    (fork by default, or using `lazy-apps` if configured).'
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: '`max-requests`指定了单个工作进程在重启之前需要处理的请求数量。一旦工作进程达到这个数量，uWSGI将销毁它，并从头开始创建另一个工作进程，遵循常规流程（默认为fork，或者如果配置了`lazy-apps`，则使用`lazy-apps`）。'
- en: This is useful to avoid problems with memory leaks or other sorts of stale problems,
    where the performance of a worker gets degraded over time. Recycling the workers
    is a protective measure that can be taken pre-emptively, so even if a problem
    is present, it will be corrected before it causes any issues.
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: 这对于避免内存泄漏或其他类型的陈旧问题很有用，这些问题会导致工作进程的性能随时间下降。回收工作进程是一种可以预先采取的保护措施，因此即使存在问题，它也会在造成任何问题之前得到纠正。
- en: Remember that, based on the Twelve-Factor App, web workers need to be able to
    be stopped and started at any time, so this recycling is painless.
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: 记住，根据十二要素应用，网络工作进程需要能够在任何时候停止和启动，因此这种回收是无痛的。
- en: uWSGI will also recycle the worker when it's idle, after serving its 5,000^(th)
    request, so it will be a controlled operation.
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: 当工作进程空闲时，uWSGI也会回收工作进程，在服务了5,000次请求之后，这将是一个受控的操作。
- en: Keep in mind this recycling may interfere with other operations. Depending on
    the startup time, it may take a few seconds or worse (especially if `lazy-apps`
    is used) to start the worker, potentially creating a backlog of requests. uWSGI
    will queue the incoming requests. In our example configuration, there's only a
    single worker defined in `processes`. With multiple workers this can be mitigated,
    as the rest of the workers will be able to handle the extra load.
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: 请记住，这种回收可能会干扰其他操作。根据启动时间，启动工作进程可能需要几秒钟，或者更糟（特别是如果使用了`lazy-apps`），这可能会创建请求数据的积压。uWSGI将排队等待的请求数据。在我们的示例配置中，`processes`中只定义了一个工作进程。如果有多个工作进程，这可以通过其他工作进程处理额外的负载来减轻。
- en: When multiple workers are involved, if each of them will restart after their
    5,000^(th) request, a stampede problem can be created where one after another
    all the workers are recycled. Keep in mind that the load is distributed through
    the workers equally, so this count will be in sync across the multiple workers.
    While the expectation is that, for example, with 16 workers, at least 15 of them
    will be available, in practice we might find that all are being recycled at the
    same time.
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
- en: 'To avoid this problem, use the `max-requests-delta` parameter. This parameter
    adds a variable number for each worker. It will multiply the delta for the worker
    ID (a unique consecutive number for each worker starting from 1). So, configuring
    a delta of 200, each worker will have the following:'
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
- en: '| Worker | Base max-request | Delta | Total requests to recycle |'
  id: totrans-188
  prefs: []
  type: TYPE_TB
- en: '| Worker 1 | 5,000 | 1 * 200 | 5,200 |'
  id: totrans-189
  prefs: []
  type: TYPE_TB
- en: '| Worker 2 | 5,000 | 2 * 200 | 5,400 |'
  id: totrans-190
  prefs: []
  type: TYPE_TB
- en: '| Worker 3 | 5,000 | 3 * 200 | 5,600 |'
  id: totrans-191
  prefs: []
  type: TYPE_TB
- en: '| … |  |  |  |'
  id: totrans-192
  prefs: []
  type: TYPE_TB
- en: '| Worker 16 | 5,000 | 16 * 200 | 8,200 |'
  id: totrans-193
  prefs: []
  type: TYPE_TB
- en: This makes the recycling happen at different times, increasing the number of
    workers available at the same time, as they won't restart simultaneously.
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
- en: This problem is of the same kind as what's called a cache stampede. This is
    produced where multiple cache values are invalidated at the same time, producing
    the regeneration of values at the same time. Because the system expects to be
    running under some cache acceleration, suddenly having to recreate a significant
    portion section of the cache may produce a serious performance problem, to the
    point of the complete collapse of the system.
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
- en: To avoid this, avoid setting fixed times for the cache to expire, such as a
    certain hour of the clock. This can happen, for example, if a backend gets updated
    with news for the day at midnight, making it tempting to expire the cache at this
    time. Instead, add an element to make the different keys expire at slightly different
    times to avoid this problem. This can be achieved by adding a small random amount
    of time to the expiry time for each of the keys, so they can reliably be refreshed
    at different times.
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
- en: 'The `master-fifo` parameter creates a way to communicate with uWSGI and send
    commands:'
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  id: totrans-198
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'This creates a UNIX socket in `/tmp/uwsgi-fifo` that can receive commands in
    the form of characters redirected to it. For example:'
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  id: totrans-200
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: This method allows for better handling of situations than sending signals, as
    there are more commands available and it allows for quite granular control of
    the processes and the whole uWSGI.
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
- en: For example, sending `Q` will produce a direct shutdown of uWSGI, while `q`
    will produce a graceful one. A graceful shutdown will start by stopping accepting
    new requests in uWSGI, then waiting until any request in the internal uWSGI queue
    is being processed, and when a worker has finished its request, stopping it in
    an orderly fashion. Finally, when all workers are done, stop the uWSGI master
    process.
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
- en: The graceful reload with `r` takes a similar approach, keeping the requests
    in the internal queue and waiting until the workers are done to stop them and
    restart them. It will also load any new configuration related to uWSGI itself.
    Note that, during the time of the operation, the internal uWSGI listen queue may
    be filled up, causing problems.
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
- en: The size of the listen queue can be tweaked with the `listen` parameter, but
    keep in mind that there's a limit set up by Linux that you may need to change
    as well. Defaults are 100 for listen and 128 for the Linux configuration.
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
- en: Do tests before changing those to big values, as churning through a big backlog
    of tasks has its own problems.
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
- en: If the loading of processes is done through the fork process, after starting
    up the first one, the rest will be copies, so they will be loaded quite quickly.
    By comparison, using `lazy-apps` may delay achieving full capacity as each individual
    worker will need to be individually started from scratch. This can produce an
    extra load on the server, depending on the number of workers and the startup procedure.
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
- en: A possible alternative for `lazy-apps` is to use the `c` option, reloading the
    workers with chain reloading. This reloads each worker independently, waiting
    until a single worker is totally reloaded before moving to the next one. This
    procedure doesn't reload the uWSGI configuration but will do with code changes
    in the workers. It will take longer, but it will work at a controller pace.
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
- en: Reloading a single server under load may be complicated. Using multiple uWSGI
    servers simplifies the process. In this situation, reloads should happen at different
    times to allow you to distribute the load.
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
- en: A cluster-style approach can be taken in using multiple servers to perform this
    dance, creating copies of the uWSGI configuration in multiple servers and then
    recycling them one at a time. While one is reloading, the others will be able
    to handle the extra load. In extreme situations, an extra server can be used to
    produce extra capacity during the reload.
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
- en: This is common in cloud environments where an extra server can be used and then
    destroyed. In Docker situations, new containers can be added to provide this extra
    capacity.
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
- en: For more information about the `master-fifo` and accepted commands, including
    how to pause and resume the instance, and other exotic operations, check the uWSGI
    documentation at [https://uwsgi-docs.readthedocs.io/en/latest/MasterFIFO.html](https://uwsgi-docs.readthedocs.io/en/latest/MasterFIFO.html).
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
- en: uWSGI is a very powerful application that has almost endless possibilities for
    configuration. Its documentation is overwhelming in the amount of detail it contains,
    but it's incredibly comprehensive and insightful. You can learn a lot, not only
    about uWSGI but also about how the whole web stack works. I highly recommend going
    through slowly, but surely, to learn a lot. You can access the documentation at
    [https://uwsgi-docs.readthedocs.io/](https://uwsgi-docs.readthedocs.io/).
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
- en: Python worker
  id: totrans-213
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The core of the system is the Python WSGI worker. This worker receives the HTTP
    requests from uWSGI after they're routed by the external web server, etc.
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
- en: This is where the magic happens, and it is specific to the application. This
    is the element that will see faster iteration than the rest of the links of the
    chain.
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
- en: Each framework will interact in a slightly different way with the requests,
    but in general, they will follow similar patterns. We will use Django as an example.
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
- en: We won't discuss all aspects of Django or go into a deep dive of its features
    but will use a selection to look at some lessons that are useful for other frameworks.
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
- en: 'The Django project is really well documented. Seriously, it has always been
    distinguished by its world-class documentation, since the project started. You
    can read it here: [http://www.djangoproject.com](http://www.djangoproject.com).'
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
- en: Django MVT architecture
  id: totrans-219
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Django borrows heavily from the MVC structure but tweaks it a bit into what''s
    called **MVT** (**Model-View-Template**):'
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
- en: The Model remains the same, the representation of the data and interacting with
    the storage.
  id: totrans-221
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The View receives the HTTP request and processes it, interacting with the different
    Models that may be required.
  id: totrans-222
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The Template is a system to generate HTML files, from values passed on.
  id: totrans-223
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: This changes Model-View-Controller a bit, though the result is similar.
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
- en: '![Shape, arrow'
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
- en: Description automatically generated](img/B17580_06_03.png)
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
- en: 'Figure 6.3: The Model-View-Controller'
  id: totrans-227
  prefs: []
  type: TYPE_NORMAL
- en: The Model works the same in both systems. The Django View acts as a combination
    of the View and the Controller, and the Template is a helping system for the View
    component of the Django View.
  id: totrans-228
  prefs: []
  type: TYPE_NORMAL
- en: The templating system is not strictly required to be used, as not every Django
    interface requires an HTML page as a result.
  id: totrans-229
  prefs: []
  type: TYPE_NORMAL
- en: While Django was designed to create HTML interfaces, there are ways of creating
    other types of interfaces. In particular, for RESTful interfaces, the Django REST
    framework ([https://www.django-rest-framework.org](https://www.django-rest-framework.org))
    allows you to expand the functionality and generate self-documented RESTful interfaces
    easily.
  id: totrans-230
  prefs: []
  type: TYPE_NORMAL
- en: We will look at the Django REST framework later in the chapter.
  id: totrans-231
  prefs: []
  type: TYPE_NORMAL
- en: Django is a powerful and comprehensive framework and has some assumptions on
    how things are supposed to run, such as using the Django ORM or using its templating
    system. While doing so is "swimming with the current," it's definitely possible
    to take other approaches and tailor any part of the system. This can involve elements
    like not using templates, using a different templating system, using a different
    ORM library like SQLAlchemy, and adding extra libraries to connect to different
    databases, including ones not supported natively by Django (like NoSQL databases).
    Do not let the constraints of the system limit you from achieving your goals.
  id: totrans-232
  prefs: []
  type: TYPE_NORMAL
- en: Django is opinionated in the way that it presents a lot of elements working
    together with certain assumptions. They are tightly related to each other. If
    that's an impediment, for example, because you need to use wildly different tools,
    a good alternative can be Pyramid ([https://trypyramid.com](https://trypyramid.com)),
    a Python web framework designed to build your own combination of tools to ensure
    flexibility.
  id: totrans-233
  prefs: []
  type: TYPE_NORMAL
- en: Routing a request towards a View
  id: totrans-234
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Django provides the tools to perform the proper routing from a particular URL
    to a specific View.
  id: totrans-235
  prefs: []
  type: TYPE_NORMAL
- en: This is done in the `urls.py` file. Let's see an example.
  id: totrans-236
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  id: totrans-237
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: The required Views (that are typically declared as functions) are imported from
    whatever module they are currently in into the file.
  id: totrans-238
  prefs: []
  type: TYPE_NORMAL
- en: The `urlpatterns` list defines an ordered list of URL patterns that will be
    tested against an input URL.
  id: totrans-239
  prefs: []
  type: TYPE_NORMAL
- en: The first `path` definition is very straightforward. If the URL is `example/`,
    it will call the View `first_view`.
  id: totrans-240
  prefs: []
  type: TYPE_NORMAL
- en: 'The second `path` definition contains definitions to capture parameters. It
    will transform the defined parameters properly and pass them over to the view.
    For example, the URL `example/15/example-slug` will create these parameters:'
  id: totrans-241
  prefs: []
  type: TYPE_NORMAL
- en: '`parameter=int(15)`'
  id: totrans-242
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`other_parameter=str("example-slug")`'
  id: totrans-243
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: There are different types of parameters that can be configured. `int` is self-explanatory,
    but `slug` is a limited string that will include only alphanumeric, `_` (underscore),
    and `–` (dash) symbols, excluding characters like `.` or other symbols.
  id: totrans-244
  prefs: []
  type: TYPE_NORMAL
- en: There are more types available. There's also a `str` type that can be too broad.
    The character `/` is understood as special in URLs and it's always excluded. This
    allows for easy separation of parameters. The type `slug` should cover more typical
    use cases for parameters inside a URL.
  id: totrans-245
  prefs: []
  type: TYPE_NORMAL
- en: Another option is to generate the paths directly as regex. If you are familiar
    with the regex format, this can be very powerful and allow a great deal of control.
    At the same time, regexes can grow really complex and difficult to read and use.
  id: totrans-246
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  id: totrans-247
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: This was the only option available previously in Django. As you can see for
    the example, equivalent to `example/<int:parameter>/`, the new path-defined URL
    patterns are easier to read and to deal with.
  id: totrans-248
  prefs: []
  type: TYPE_NORMAL
- en: An intermediate option is to define types to be sure that they match specific
    values, for example, creating a type to match only months like `Apr` or `Jun`.
    If the type is defined in this way, an incorrect pattern like `Jen` will return
    a 404 automatically. Internally, this will require writing a regex to match the
    proper string anyway, but afterwards, it can transform the value. For example,
    to transform the month `Jun` to either the number 1, normalize it as `JUNE`, or
    any other value that makes sense later. The complexity of the regex will be abstracted
    by the type.
  id: totrans-249
  prefs: []
  type: TYPE_NORMAL
- en: Keep in mind that the patterns are checked in order. That means that, if a pattern
    may fulfil two paths, it will select the first one. This may have unintended effects
    when a previous path "hides" the next one, so the least restrictive patterns should
    be positioned later.
  id: totrans-250
  prefs: []
  type: TYPE_NORMAL
- en: 'For example:'
  id: totrans-251
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  id: totrans-252
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: No URL will ever get passed to `second_view`, as any parameter that is an integer
    will be captured first.
  id: totrans-253
  prefs: []
  type: TYPE_NORMAL
- en: This kind of error is usually possible in most URL routers in web frameworks,
    as most of them are pattern-based. Keep an eye in case it affects your code.
  id: totrans-254
  prefs: []
  type: TYPE_NORMAL
- en: The interesting stuff happens inside of the View.
  id: totrans-255
  prefs: []
  type: TYPE_NORMAL
- en: The View
  id: totrans-256
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The View is the central element of Django. It receives the request information,
    plus any parameters from the URL, and processes it. The View normally will use
    the different Models to compose the information, and finally returns a response.
  id: totrans-257
  prefs: []
  type: TYPE_NORMAL
- en: The View is in charge of deciding if there's any change in behavior based on
    the request. Note that the routing towards the View only distinguishes between
    different paths, but other distinctions like HTTP method or parameters will need
    to be differentiated here.
  id: totrans-258
  prefs: []
  type: TYPE_NORMAL
- en: 'This makes it a very common pattern to differentiate between POST and GET requests
    to the same URL. A common usage in web pages is to make a form page to display
    the empty form, and then POST to the same URL. For example, in a form with a single
    parameter, the structure will be similar to the following example:'
  id: totrans-259
  prefs: []
  type: TYPE_NORMAL
- en: This is intended as pseudocode to not complicate it.
  id: totrans-260
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  id: totrans-261
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: While it's true that Django includes a form system that simplifies the validation
    and reporting of forms, this structure can grow legs and become tiresome. In particular,
    the multiple nested `if` blocks are confusing.
  id: totrans-262
  prefs: []
  type: TYPE_NORMAL
- en: We won't go into details with the form system in Django. It is quite complete
    and allows you to render rich HTML forms that will validate and show possible
    errors to the user. Read the Django documentation to know more.
  id: totrans-263
  prefs: []
  type: TYPE_NORMAL
- en: Instead of that, dividing the View with two different subfunctions may be clearer.
  id: totrans-264
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  id: totrans-265
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: The challenge here is to preserve the fact that, when the parameters are incorrect,
    the form needs to be rendered again. By the principle of **DRY** (**Don't Repeat
    Yourself**), we should try to locate that code in a single place. Here, in the
    `display_form` function. We allow some customization of the message to add some
    extra content, in case the data is incorrect.
  id: totrans-266
  prefs: []
  type: TYPE_NORMAL
- en: In a more complete example, the form will be tweaked to show the specific errors.
    Django forms are able to do this automatically. The process will be to create
    a form with the parameters from the request, validate it, and print it. It automatically
    will produce the proper error messages, based on the type of each of the fields,
    including custom types. Again, refer to Django's documentation for more information.
  id: totrans-267
  prefs: []
  type: TYPE_NORMAL
- en: Note that the `display_form` function gets called both from `example_view` and
    also inside `process_data`.
  id: totrans-268
  prefs: []
  type: TYPE_NORMAL
- en: HttpRequest
  id: totrans-269
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The key element for passing information is the `request` parameter. This object's
    type is `HttpRequest`, and contains all the information that the user is sending
    in the request.
  id: totrans-270
  prefs: []
  type: TYPE_NORMAL
- en: 'Its most important attributes are:'
  id: totrans-271
  prefs: []
  type: TYPE_NORMAL
- en: '`method`, which contains the used HTTP method.'
  id: totrans-272
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'If the method is `GET`, it will contain a `GET` attribute with a `QueryDict`
    (a dictionary subclass) containing all the query parameters in the request. For
    example, a request such as:'
  id: totrans-273
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE25]'
  id: totrans-274
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'Will produce a `request.GET` value like this:'
  id: totrans-275
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE26]'
  id: totrans-276
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE26]'
- en: 'Note that the parameters are stored internally as a list of values, because
    query parameters accept multiple parameters with the same key, though that''s
    not usually the case. They''ll return a unique value when queried anyway:'
  id: totrans-277
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE27]'
  id: totrans-278
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE27]'
- en: 'They''ll be all reported in order, with the latest value being returned. If
    you need to access all values, use the method `getlist`:'
  id: totrans-279
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  id: totrans-280
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: All the parameters are defined as strings, needing to be converted to other
    types if necessary.
  id: totrans-281
  prefs: []
  type: TYPE_NORMAL
- en: If the method is `POST`, an analogous `POST` attribute will be created. In this
    case, it will be filled first by the body of the request, to allow encoding form
    posts. If the body is empty, it will fill the values with query parameters like
    the `GET` case.
  id: totrans-282
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: POST multiple values will commonly be used in multiple selection forms.
  id: totrans-283
  prefs: []
  type: TYPE_NORMAL
- en: '`content_type` with the MIME type of the request.'
  id: totrans-284
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`FILES`, including data for any uploaded files in the request, for certain
    `POST` requests.'
  id: totrans-285
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`headers`, a dictionary containing all the HTTP headers of the request and
    headers. Another dictionary, `META`, contains extra information from headers that
    may be introduced and are not necessarily HTTP-based, like `SERVER_NAME`. In general,
    it is better to obtain information from the `headers` attribute.'
  id: totrans-286
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'There are also some useful methods to retrieve information from the request,
    for example:'
  id: totrans-287
  prefs: []
  type: TYPE_NORMAL
- en: '`.get_host()` to obtain the name of the host. It will interpret the different
    headers to determine the proper host, so it''s more reliable than directly reading
    the `HTTP_HOST` header.'
  id: totrans-288
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`.build_absolute_uri(location)` to generate a full URI, including the host,
    port, etc. This method is useful to create full references to return them.'
  id: totrans-289
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: These attributes and methods, combined with the parameters described in the
    request, allow you to retrieve all the relevant information necessary for processing
    the request and call the required Models.
  id: totrans-290
  prefs: []
  type: TYPE_NORMAL
- en: HttpResponse
  id: totrans-291
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The `HttpResponse` class handles the information being returned by the View
    to the web server. The return from a View function needs to be an `HttpResponse`
    object.
  id: totrans-292
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  id: totrans-293
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: The response has a default `status_code` of 200 if it's not specified.
  id: totrans-294
  prefs: []
  type: TYPE_NORMAL
- en: If the response needs to be written in several steps, it can be added through
    the `.write()` method.
  id: totrans-295
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  id: totrans-296
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: The body can also be composed as an iterable.
  id: totrans-297
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  id: totrans-298
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: All responses from `HttpResponse` will be composed completely before being returned.
    It is possible to return responses in a streaming way, meaning that the status
    code will be returned first and chunks of the body will be sent over time. To
    do that, there's another class called `StreamingHttpResponse` that will work in
    that way, and can be useful for sending big responses over time.
  id: totrans-299
  prefs: []
  type: TYPE_NORMAL
- en: 'Instead of using integers to define the status code, it''s better to use the
    defined constants available in Python, for example:'
  id: totrans-300
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  id: totrans-301
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: This makes the usage of each status code more explicit and helps increase the
    readability of the code, making them explicitly `HTTPStatus` objects.
  id: totrans-302
  prefs: []
  type: TYPE_NORMAL
- en: 'You can see all the status codes defined in Python here: [https://docs.python.org/3/library/http.html](https://docs.python.org/3/library/http.html).
    Note the name is their standard HTTP status code name, as defined in several RFC
    documents, for example, `201 CREATED`, `404 NOT FOUND`, `502 BAD GATEWAY`, etc.'
  id: totrans-303
  prefs: []
  type: TYPE_NORMAL
- en: The `content` parameter defines the body of the request. It can be described
    as a Python string, but it also accepts binary data, if the response is not plain
    text. If that's the case, a `content_type` parameter should be added to adequately
    label the data with the proper MIME type.
  id: totrans-304
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  id: totrans-305
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: It is very important that the returned `Content-Type` matches the format of
    the body. This will make any other tool, like a browser, properly interpret the
    content adequately.
  id: totrans-306
  prefs: []
  type: TYPE_NORMAL
- en: Headers can also be added to the response using the `headers` parameter.
  id: totrans-307
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE34]'
  id: totrans-308
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: '`Content-Disposition` can be used to label the response as an attachment that
    should be downloaded to the hard drive.'
  id: totrans-309
  prefs: []
  type: TYPE_NORMAL
- en: Also, we can set up the `Content-Type` header either manually through the `headers`
    parameter or through the `content_type` parameter directly.
  id: totrans-310
  prefs: []
  type: TYPE_NORMAL
- en: 'Headers are also stored in the response when it is accessed as a dictionary:'
  id: totrans-311
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE35]'
  id: totrans-312
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: 'There are specialized subclasses for common cases. Instead of using a generic
    `HttpResponse`, for JSON encoded requests, it''s better to use `JsonResponse`,
    which will correctly fill the Content-Type and encode it:'
  id: totrans-313
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE36]'
  id: totrans-314
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: In the same style, the `FileResponse` allows you to download a file directly,
    providing a file-like object and directly filling the headers and content type,
    including if it needs to be an attachment
  id: totrans-315
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE37]'
  id: totrans-316
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: The response can also be created by rendering a template. This is the usual
    way of doing so for HTML interfaces, which was what Django was originally designed
    for. The `render` function will automatically return an `HttpResponse` object.
  id: totrans-317
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE38]'
  id: totrans-318
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: Middleware
  id: totrans-319
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: A key concept in WSGI requests is that they can be chained. This means that
    a request can go through different stages, wrapping a new request around the orinal
    at each stage, which allows you to add functionality.
  id: totrans-320
  prefs: []
  type: TYPE_NORMAL
- en: This leads to the concept of middleware. Middleware improves the handling between
    systems by simplifying handling several aspects of the request, adding functionality,
    or simplifying their usage.
  id: totrans-321
  prefs: []
  type: TYPE_NORMAL
- en: Middleware is a word that can refer to different concepts depending on the context
    of its usage. When used in an HTTP server environment, it typically refers to
    plugins that enhance or simplify the handling of requests.
  id: totrans-322
  prefs: []
  type: TYPE_NORMAL
- en: A typical example of middleware is logging each received request in a standard
    manner. The middleware will receive the request, produce a log, and hand the request
    to the next level.
  id: totrans-323
  prefs: []
  type: TYPE_NORMAL
- en: Another example is managing whether the user is logged or not. There's a standard
    Django middleware that will detect any session stored in cookies and will search
    in the database for the associated user. It will then fill the `request.user`
    object with the proper user.
  id: totrans-324
  prefs: []
  type: TYPE_NORMAL
- en: Another example, enabled by default in Django, checks the CSRF token on `POST`
    requests. If the CSRF token is not present or it's incorrect, the request will
    be immediately intercepted and it will return `403 FORBIDDEN`, before accessing
    the View code.
  id: totrans-325
  prefs: []
  type: TYPE_NORMAL
- en: We introduced the idea of CSRF and tokens in *Chapter 2*.
  id: totrans-326
  prefs: []
  type: TYPE_NORMAL
- en: 'Middleware can access the request both when it''s received and the response
    when it''s ready, so they can work on either side or both sides in coordination:'
  id: totrans-327
  prefs: []
  type: TYPE_NORMAL
- en: Logging middleware that generates a log with the path and method of the received
    request can generate it before the request is sent to the View.
  id: totrans-328
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Logging middleware that also logs the status code needs to have the information
    of the status code, so it will need to do it once the View is finished and the
    response is ready.
  id: totrans-329
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Logging middleware that logs the time it took to generate the request will need
    to first register the time when the request was received, and what time it is
    when the response is ready, to log the difference. This requires code both before
    and after the View.
  id: totrans-330
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Middleware is defined in this way:'
  id: totrans-331
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE39]'
  id: totrans-332
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: 'The structure to return a function allows the initialization of chained elements.
    The input `get_reponse` can be another middleware function or could be the final
    view. This allows this kind of structure:'
  id: totrans-333
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE40]'
  id: totrans-334
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: The order of the middleware is also important. For example, logging should happen
    before any middleware that can stop the request, as if done in reverse order,
    any rejected request (for example, not adding a proper CSRF) won't be logged.
  id: totrans-335
  prefs: []
  type: TYPE_NORMAL
- en: Generally, middleware functions have some recommendations on where they should
    be located. Some are more sensitive to their position than others. Check the documentation
    for each one.
  id: totrans-336
  prefs: []
  type: TYPE_NORMAL
- en: Middleware can be easily added, either custom-made or by using third-party options.
    There are a lot of packages that create their own middleware functions for useful
    features in Django. When considering adding a new feature, spend some time searching
    to see if there's something already available.
  id: totrans-337
  prefs: []
  type: TYPE_NORMAL
- en: Django REST framework
  id: totrans-338
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: While Django was designed originally to support HTML interfaces, its functionality
    has been expanded, both as new features inside the Django project itself, as well
    as other external projects that enhance Django.
  id: totrans-339
  prefs: []
  type: TYPE_NORMAL
- en: One of particular interest is Django REST framework. We will use it as an example
    of the available possibilities.
  id: totrans-340
  prefs: []
  type: TYPE_NORMAL
- en: Django REST framework is not only a popular and powerful module. It also uses
    a lot of conventions that are common across REST frameworks in multiple programming
    languages.
  id: totrans-341
  prefs: []
  type: TYPE_NORMAL
- en: For our example, we will implement some of the endpoints that we defined in
    *Chapter 2*. We will use the following endpoints, to follow the whole lifecycle
    of a micropost.
  id: totrans-342
  prefs: []
  type: TYPE_NORMAL
- en: '| Endpoint | Method | Action |'
  id: totrans-343
  prefs: []
  type: TYPE_TB
- en: '| `/api/users/<username>/collection` | `GET` | Retrieve all the microposts
    from a user |'
  id: totrans-344
  prefs: []
  type: TYPE_TB
- en: '| `/api/users/<username>/collection` | `POST` | Create a new micropost for
    the user |'
  id: totrans-345
  prefs: []
  type: TYPE_TB
- en: '| `/api/users/<username>/collection/<micropost_id>` | `GET` | Retrieve a single
    micropost |'
  id: totrans-346
  prefs: []
  type: TYPE_TB
- en: '| `/api/users/<username>/collection/<micropost_id>` | `PUT, PATCH` | Update
    a micropost |'
  id: totrans-347
  prefs: []
  type: TYPE_TB
- en: '| `/api/users/<username>/collection/<micropost_id>` | `DELETE` | Delete a micropost
    |'
  id: totrans-348
  prefs: []
  type: TYPE_TB
- en: The basic principle behind Django REST framework is to create different classes
    that encapsulate the exposed resources as URLs.
  id: totrans-349
  prefs: []
  type: TYPE_NORMAL
- en: The extra concept is that objects will be transformed from an internal Model
    into an external JSON object and vice versa through a *serializer*. The serializer
    will handle the creation and validate that the external data is correct.
  id: totrans-350
  prefs: []
  type: TYPE_NORMAL
- en: A serializer can't only transform a Model object, but any kind of internal Python
    class. You can use them to create "virtual objects" that can pull information
    from multiple Models.
  id: totrans-351
  prefs: []
  type: TYPE_NORMAL
- en: A peculiarity of Django REST framework is that the serializer is the same for
    input and output. In other frameworks, there are different modules for the way
    in and out.
  id: totrans-352
  prefs: []
  type: TYPE_NORMAL
- en: Models
  id: totrans-353
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: We first need to introduce the models to store the information. We will use
    a `Usr` Model for the users and a `Micropost` Model.
  id: totrans-354
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE41]'
  id: totrans-355
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: The `Usr` model is very straightforward, only storing the username. The `Micropost`
    Model stores a string of text and the user that created the micropost. Optionally,
    it can store a referenced user.
  id: totrans-356
  prefs: []
  type: TYPE_NORMAL
- en: Note that the relations have their own named back reference, `reference` and
    `owner`. They are created by default by Django so you can search where a `Usr`
    is referenced, for example.
  id: totrans-357
  prefs: []
  type: TYPE_NORMAL
- en: Note also that the `text` allows for 300 characters, instead of the 255 that
    we said in the API. This is to allow a bit of extra space in the database. We
    will still protect against more characters later.
  id: totrans-358
  prefs: []
  type: TYPE_NORMAL
- en: URL routing
  id: totrans-359
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'With this information, we create two different views, one for each URL that
    we need to create. They''ll be called `MicropostsListView` and `MicropostView`.
    Let''s take a look first at how the URLs are defined in the `urls.py` file:'
  id: totrans-360
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE42]'
  id: totrans-361
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: 'Note that there are two URLs, that correspond to this definition:'
  id: totrans-362
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE43]'
  id: totrans-363
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: And each is mapped to the corresponding view.
  id: totrans-364
  prefs: []
  type: TYPE_NORMAL
- en: Views
  id: totrans-365
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Each view inherits from the proper API endpoint, the collection one from `ListCreateAPIView`,
    which defines the actions for `LIST` (`GET`) and `CREATE` (`POST`):'
  id: totrans-366
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE44]'
  id: totrans-367
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: 'We will check the serializer later. The class requires defining the queryset
    that it will use to retrieve the information when the `LIST` part of the class
    is called. Because our URL includes the username, we need to identify it:'
  id: totrans-368
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE45]'
  id: totrans-369
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: '`self.kwargs[''username'']` will retrieve the username defined in the URL.'
  id: totrans-370
  prefs: []
  type: TYPE_NORMAL
- en: For the `CREATE` part, we need to overwrite the `perform_create` method. This
    method receives a serializer parameter that already contains the validated parameters.
  id: totrans-371
  prefs: []
  type: TYPE_NORMAL
- en: We need to obtain the username and user from the same `self.kwargs` to be sure
    to add it to the creation of the `Micropost` object.
  id: totrans-372
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE46]'
  id: totrans-373
  prefs: []
  type: TYPE_PRE
  zh: '[PRE46]'
- en: The new object is created combining both the user and the rest of the data,
    added as part of the `save` method for the serializer.
  id: totrans-374
  prefs: []
  type: TYPE_NORMAL
- en: 'The individual View follows a similar pattern, but there''s no need to overwrite
    the creation:'
  id: totrans-375
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE47]'
  id: totrans-376
  prefs: []
  type: TYPE_PRE
  zh: '[PRE47]'
- en: 'In this case, we allow more operations: `RETRIEVE` (`GET`), `UPDATE` (`PUT`
    and `PATCH`), and `DESTROY` (`DELETE`).'
  id: totrans-377
  prefs: []
  type: TYPE_NORMAL
- en: Serializer
  id: totrans-378
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'The serializer transforms from the Python object of the Model to the JSON result
    and the other way around. The serializer is defined like this:'
  id: totrans-379
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE48]'
  id: totrans-380
  prefs: []
  type: TYPE_PRE
  zh: '[PRE48]'
- en: '`ModelSerializer` will automatically detect the fields in the model defined
    in the `Meta` subclass. We specified the fields to be included in the `fields`
    section. Note that, apart from the ones that are directly translated, `id` and
    `timestamp`, we include others that will change (`user`, `text`, `referenced`)
    and an extra one (`href`). The directly translated ones are straightforward; we
    don''t need to do anything there.'
  id: totrans-381
  prefs: []
  type: TYPE_NORMAL
- en: The `text` field is described again as a `CharField`, but this time, we limit
    the maximum number of characters.
  id: totrans-382
  prefs: []
  type: TYPE_NORMAL
- en: The `user` field is also redescribed as a `CharField`, but using the source
    parameter we define it as the username of the referenced user. The field is defined
    as `read_only`.
  id: totrans-383
  prefs: []
  type: TYPE_NORMAL
- en: '`referenced` is similar to it, but we need to define it as `SlugRelatedField`,
    so it understands that''s a reference. A slug is a string that references the
    value. We define that the `slug_field` is the username of the reference, and add
    the queryset to allow searching for it.'
  id: totrans-384
  prefs: []
  type: TYPE_NORMAL
- en: 'The `href` field requires an extra defined class to create a proper URL reference.
    Let''s take a detailed look:'
  id: totrans-385
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE49]'
  id: totrans-386
  prefs: []
  type: TYPE_PRE
  zh: '[PRE49]'
- en: '`view_name` describes the URL that will be used. The `reverse` call transforms
    the parameters into the proper full URL. This is wrapped in the `get_url` method.
    This method receives mainly the `obj` parameter with the full object. This full
    object is defined in the `source=''*''` call to the `MicropostHyperlink` class
    in the serializer.'
  id: totrans-387
  prefs: []
  type: TYPE_NORMAL
- en: The combination of all these factors makes the interface work correctly. Django
    REST framework can also create an interface to help you visualize the whole interface
    and use it.
  id: totrans-388
  prefs: []
  type: TYPE_NORMAL
- en: 'For example, a list will look like this:'
  id: totrans-389
  prefs: []
  type: TYPE_NORMAL
- en: '![Graphical user interface, application, Teams'
  id: totrans-390
  prefs: []
  type: TYPE_NORMAL
- en: Description automatically generated](img/B17580_06_04.png)
  id: totrans-391
  prefs: []
  type: TYPE_NORMAL
- en: 'Figure 6.4: Microposts List'
  id: totrans-392
  prefs: []
  type: TYPE_NORMAL
- en: And a micropost page will look like this, which allows you to test different
    actions like `PUT`, `PATCH`, `DELETE`, and `GET`.
  id: totrans-393
  prefs: []
  type: TYPE_NORMAL
- en: '![Graphical user interface, application, Teams'
  id: totrans-394
  prefs: []
  type: TYPE_NORMAL
- en: Description automatically generated](img/B17580_06_05.png)
  id: totrans-395
  prefs: []
  type: TYPE_NORMAL
- en: 'Figure 6.5: Microposts page'
  id: totrans-396
  prefs: []
  type: TYPE_NORMAL
- en: Django REST framework is very powerful and can be used in different ways to
    be sure that it behaves exactly as you expect. It has its own quirks, and it tends
    to be a little temperamental with the parameters until everything is configured
    just right. At the same time, it allows you to customize the interface in every
    aspect. Be sure to read the documentation carefully.
  id: totrans-397
  prefs: []
  type: TYPE_NORMAL
- en: 'You can find the whole documentation here: [https://www.django-rest-framework.org/](https://www.django-rest-framework.org/).'
  id: totrans-398
  prefs: []
  type: TYPE_NORMAL
- en: External layers
  id: totrans-399
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: On top of the web server, there is the possibility to continue the link by adding
    extra levels that work on the HTTP layer. This allows you to load balance between
    multiple servers and increase the total throughput of the system. This can be
    chained into multiple layers, if necessary.
  id: totrans-400
  prefs: []
  type: TYPE_NORMAL
- en: '![Diagram'
  id: totrans-401
  prefs: []
  type: TYPE_NORMAL
- en: Description automatically generated](img/B17580_06_06.png)
  id: totrans-402
  prefs: []
  type: TYPE_NORMAL
- en: 'Figure 6.6: Chained load balancers'
  id: totrans-403
  prefs: []
  type: TYPE_NORMAL
- en: The route from the user to the edge of our system is handled by the internet,
    but once it reaches the edge load balancer, it directs the requests inside the
    system. The edge load balancer works as a gateway between the external networks
    and the controlled environment of our network.
  id: totrans-404
  prefs: []
  type: TYPE_NORMAL
- en: The edge load balancer is normally the only one that handles HTTPS connection,
    allowing the rest of the system to use only HTTP. This is convenient as HTTP requests
    are easier to cache and handle. HTTPS requests are encoded end to end and cannot
    be properly cached or analyzed. The internal traffic is protected from external
    access and should have robust policies to be sure that only approved engineers
    are able to access it and access logs to audit accesses. But at the same time,
    it can be easily debugged, and any traffic problems can be solved much more easily.
  id: totrans-405
  prefs: []
  type: TYPE_NORMAL
- en: The configuration of the network can greatly vary, and in lots of cases multiple
    load balancers are not required, and the edge load balancer can handle multiple
    web servers directly. The capacity in this case is key, as a load balancer has
    a limit on the number of requests that it can take.
  id: totrans-406
  prefs: []
  type: TYPE_NORMAL
- en: Some key load balancers can be set up as specialized hardware to ensure that
    they have the capacity to handle the required number of requests.
  id: totrans-407
  prefs: []
  type: TYPE_NORMAL
- en: This multi-layered structure allows you to introduce caching at any point of
    the system. This can improve the performance of the system, though it needs to
    be treated with care to be sure that it's adequate. After all, one of the most
    difficult problems in software development is the proper handling of the cache
    and its invalidation.
  id: totrans-408
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  id: totrans-409
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we went into the details about how web servers work, and the
    different layers that are involved.
  id: totrans-410
  prefs: []
  type: TYPE_NORMAL
- en: We started by describing the fundamental details of the request-response and
    web server architecture. Then, we moved on to describe a system with three layers,
    using nginx as the front web server and uWSGI to handle multiple Python workers
    that run Django code.
  id: totrans-411
  prefs: []
  type: TYPE_NORMAL
- en: We started with the web server itself, which allows you to serve HTTP, directly
    return the static content stored in files, and route it towards the next layer.
    We analyzed the different configuration elements, including enabling header forwarding
    and logging.
  id: totrans-412
  prefs: []
  type: TYPE_NORMAL
- en: We continued by describing how uWSGI works and how it's able to create and set
    up different processes that interact through the WSGI protocol in Python. We described
    how to set up the interaction with the previous level (the nginx web server) and
    the next level (the Python code). We also described how the workers can be restarted
    in an orderly way, and how they can be automatically recycled periodically to
    mitigate certain kinds of problems.
  id: totrans-413
  prefs: []
  type: TYPE_NORMAL
- en: We described how Django works to define a web application, and how the requests
    and responses flow through the code, including how the middleware can be used
    to chain elements in the flow. We also introduced Django REST framework as a way
    to create RESTful APIs and show how our example introduced in *Chapter 2* can
    be implemented through the views and serializers provided by Django REST framework.
  id: totrans-414
  prefs: []
  type: TYPE_NORMAL
- en: Finally, we described how the structure can be extended by layers on top to
    be sure to distribute the load across multiple servers and scale the system.
  id: totrans-415
  prefs: []
  type: TYPE_NORMAL
- en: We will next describe event-driven systems.
  id: totrans-416
  prefs: []
  type: TYPE_NORMAL
