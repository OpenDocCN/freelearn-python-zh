- en: '6'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '6'
- en: Web Server Structures
  id: totrans-1
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 网络服务器结构
- en: Web servers are the most common servers for remote access at the moment. Web
    services based on HTTP are flexible and powerful.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 目前，网络服务器是远程访问中最常见的服务器。基于HTTP的Web服务灵活且强大。
- en: 'In this chapter, we will see how web servers are structured, starting by describing
    how the basic request-response architecture works, and then diving into a LAMP-style
    architecture in three layers: the web server itself, the workers executing the
    code, and an intermediate layer that controls those workers and presents a standardized
    connection to the web server.'
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将了解网络服务器的结构，首先描述基本请求-响应架构是如何工作的，然后深入探讨三层LAMP风格的架构：服务器本身、执行代码的工作者以及控制这些工作者并向服务器提供标准化连接的中间层。
- en: We will describe each layer in detail, presenting a specific tool, such as nginx
    for the web server, uWSGI for the intermediate layer, and the Python Django framework
    for the specific code inside the worker. We will describe each of them in detail.
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将详细描述每一层，展示特定的工具，例如用于网络服务器的nginx，用于中间层的uWSGI，以及用于工作者内部特定代码的Python Django框架。我们将详细描述每一个。
- en: We will also include the Django REST framework, as it's a tool that builds on
    top of Django to generate RESTful API interfaces.
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还将包括Django REST框架，因为它是一个构建在Django之上的工具，用于生成RESTful API接口。
- en: Finally, we will describe how extra layers can be added on top for greater flexibility,
    scalability, and performance.
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们将描述如何添加额外的层以实现更大的灵活性、可扩展性和性能。
- en: 'In this chapter, we''ll cover the following topics:'
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: 本章我们将涵盖以下主题：
- en: Request-response
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 请求-响应
- en: Web architecture
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 网络架构
- en: Web servers
  id: totrans-10
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 网络服务器
- en: uWSGI
  id: totrans-11
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: uWSGI
- en: Python workers
  id: totrans-12
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Python工作者
- en: External layers
  id: totrans-13
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 外部层
- en: Let's start by describing the basis of the request-response architecture.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们先描述请求-响应架构的基础。
- en: Request-response
  id: totrans-15
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 请求-响应
- en: The classical server architecture is heavily based on request-response to communicate.
    A client sends a request to a remote server and the server processes it and returns
    a response.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 经典的服务器架构在通信上严重依赖于请求-响应。客户端向远程服务器发送请求，服务器处理它并返回响应。
- en: This communication pattern has been prevalent since the era of mainframes and
    works in an analog manner as software communicates internally with a library,
    but over a network. The software calls a library and receives a response from
    it.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 这种通信模式自主机时代以来一直很流行，它以类似的方式工作，即软件通过库与内部通信，但通过网络。软件调用一个库并从它那里接收响应。
- en: An important element is the time delay between the sending of the request and
    the reception of the response. Internally, it is rare that a call takes more than
    a couple of milliseconds, but for a network, it may be measured in hundreds of
    milliseconds and seconds, very commonly.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 一个重要元素是请求发送和响应接收之间的时间延迟。内部，调用通常不会超过几毫秒，但对于网络来说，它可能以百毫秒和秒来衡量，非常常见。
- en: Network calls are very dependent on where the server is located. A call within
    the same data center will be fast, perhaps taking less than 100 milliseconds,
    while a connection to an external API will likely take close to a second or more.
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 网络调用非常依赖于服务器所在的位置。在同一数据中心内的调用将会很快，可能不到100毫秒，而连接到外部API的调用可能接近一秒或更长。
- en: Times will also be highly variable, as the network conditions may affect them
    greatly. This time difference makes it important to handle it properly.
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 时间也会有很大的变化，因为网络条件可能会极大地影响它们。这种时间差异使得正确处理它变得很重要。
- en: The usual strategy when making requests is to make them synchronously. That
    means that the code stops and waits until the response is ready. This is convenient,
    as the code will be simple, but it's also inefficient, as the computer will be
    not doing anything while the server is calculating the response and it's being
    transferred through the network.
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 在发出请求时，通常的策略是同步进行。这意味着代码会停止并等待直到响应准备好。这很方便，因为代码将会很简单，但这也低效，因为当服务器正在计算响应并通过网络传输时，计算机将不会做任何事情。
- en: The client can be improved to perform multiple requests at the same time. This
    can be done when the requests are independent of each other, allowing it to make
    them in parallel. An easy way to achieve this is to use a multithreaded system
    to perform them, so they can speed up the process.
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 客户端可以被改进以同时执行多个请求。这可以在请求彼此独立时进行，允许它并行执行。实现这一点的简单方法是使用多线程系统来执行它们，这样它们可以加快处理过程。
- en: Typically, a flow will be required, with some requests that can be performed
    in parallel and others that require waiting until information is received. For
    example, a common request to retrieve a web page will make one request to retrieve
    the page and later will download multiple files referenced (e.g. header files,
    images) in parallel.
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 通常，需要一个流程，其中一些请求可以并行执行，而其他请求则需要等待收到信息。例如，一个常见的请求是检索网页，它将发送一个请求来检索页面，稍后将以并行方式下载多个引用的文件（例如，头文件、图像）。
- en: We will see later in the chapter how this effect can be designed to increase
    the responsiveness of web pages.
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将在本章后面看到，如何设计这种效果来提高网页的响应性。
- en: The fact that the network is more unreliable than a local call, requires better
    error handling that understands this fact. Any request-response system should
    take extra care about capturing different errors, and retry, as network problems
    typically are transient, and can be recovered if retried after waiting.
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 事实上，网络比本地调用更不可靠，需要更好的错误处理来理解这一事实。任何请求-响应系统都应该特别注意捕获不同的错误，并重试，因为网络问题通常是短暂的，如果在等待后重试，可以恢复。
- en: As we saw in *Chapter 2*, *API Design* the multiple status codes from HTTP can
    give detailed information.
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我们在*第二章*，*API设计*中看到的，HTTP的多个状态码可以提供详细的信息。
- en: Another characteristic of the request-response pattern is that a server cannot
    call the client proactively, only return information. This simplifies the communication,
    as it's not entirely bidirectional. The client is required to initiate the request,
    and the server only needs to listen for new requests coming. This also makes both
    roles asymmetrical and requires the client to know where the server is, usually
    by its DNS address and the port to access (by default, port 80 for HTTP and 443
    for HTTPS).
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 请求-响应模式的另一个特点是服务器不能主动调用客户端，只能返回信息。这简化了通信，因为它不是完全的双向的。客户端需要发起请求，而服务器只需要监听新的请求。这也使得两个角色不对称，并要求客户端知道服务器的位置，通常是通过DNS地址和访问端口（默认情况下，HTTP为80端口，HTTPS为443端口）。
- en: This characteristic makes some communication patterns difficult to achieve.
    For example, full bidirectional communication, where two parts want to initiate
    the sending of messages, is difficult to achieve with request-response.
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 这种特性使得某些通信模式难以实现。例如，完全双向通信，其中两部分都希望发起消息的发送，在请求-响应中很难实现。
- en: A crude example of this is a message server implemented only in request-response.
    Two clients require the usage of an intermediate server.
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 这种方法的粗略例子是仅通过请求-响应实现的邮件服务器。两个客户端需要使用一个中间服务器。
- en: This basic structure is common in applications like forums or social networks
    that allow the users to have some sort of direct messaging between users.
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 这种基本结构在允许用户之间进行某种直接消息传递的应用程序中很常见，如论坛或社交网络。
- en: 'Each user can perform two actions:'
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 每个用户可以执行两个操作：
- en: Request any new message addressed to them
  id: totrans-32
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 请求任何发送给他们的新消息
- en: Send a new message to another user
  id: totrans-33
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 向另一个用户发送新消息
- en: A user needs to check periodically whether there are new messages available
    through polling. This is inefficient, as it's likely that for any new message
    there'll be a significant number of checks that return "no new messages available."
    Even worse, there could be a significant delay before noticing that a new message
    is available if the checks are not performed often enough.
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 用户需要定期检查是否有新消息可用，这通过轮询来实现。这是低效的，因为对于任何新消息，都可能存在大量的检查返回“没有新消息可用”。更糟糕的是，如果检查不够频繁，可能会出现显著的延迟，才会注意到有新消息可用。
- en: In real applications, normally this polling is avoided by sending a notification
    in a way that's proactive towards the client. For example, mobile OSes have a
    system to deliver notifications, enabling the server to send a notification through
    an external API provided by the OS to notify the user of a new message. An older
    alternative is to send an email with the same goal.
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 在实际应用中，通常通过向客户端发送通知来避免这种轮询。例如，移动操作系统有一个系统来传递通知，允许服务器通过操作系统提供的API发送通知，通知用户有新消息。一个较老的替代方案是发送一封电子邮件达到相同的目的。
- en: There are other alternatives, of course. There are P2P alternatives, where two
    clients can connect to each other, and there are connections with a server through
    websockets that can remain open, allowing the server to notify the user of new
    information. They both deviate from the request-response architecture.
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 当然，还有其他替代方案。有P2P替代方案，其中两个客户端可以相互连接，还有通过websockets与服务器建立连接，这些连接可以保持打开状态，允许服务器通知用户新的信息。它们都偏离了请求-响应架构。
- en: Even with these limitations, request-response architecture is the basis of web
    services and has been proven to be very reliable over the decades. The possibility
    of having a central server that controls communication and can take a passive
    role in accepting new requests makes the architecture simple to implement and
    quick to evolve, and simplifies the client's work. The centralized aspect allows
    a lot of control.
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 即使有这些限制，请求-响应架构仍然是Web服务的基础，并且在几十年中被证明是非常可靠的。存在一个中央服务器来控制通信并可以被动地接受新请求的可能性，使得架构易于实现和快速演进，并简化了客户端的工作。集中的方面允许进行大量控制。
- en: Web architecture
  id: totrans-38
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 网络架构
- en: 'We introduced in the introduction of the chapter the LAMP architecture, which
    is the base for the web server architecture:'
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章的引言中，我们介绍了LAMP架构，它是网络服务器架构的基础：
- en: '![Diagram'
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: '![图'
- en: Description automatically generated](img/B17580_06_01.png)
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 自动生成的描述](img/B17580_06_01.png)
- en: 'Figure 6.1: The LAMP architecture'
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 图6.1：LAMP架构
- en: The LAMP architecture is more general, but we will take a closer look at the
    web server and web worker. We will use specific tools, based on the Python ecosystem,
    but we will discuss possible alternatives.
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: LAMP架构更为通用，但我们将更详细地研究网络服务器和网络工作进程。我们将使用基于Python生态系统的特定工具，但我们将讨论可能的替代方案。
- en: '![Diagram'
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: '![图'
- en: Description automatically generated](img/B17580_06_02.png)
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 自动生成的描述](img/B17580_06_02.png)
- en: 'Figure 6.2: More detailed architecture in a Python environment'
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 图6.2：Python环境中的更详细架构
- en: From the point of view of an incoming request, a web request accesses the different
    elements.
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 从传入请求的角度来看，Web请求访问不同的元素。
- en: Web servers
  id: totrans-48
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 网络服务器
- en: The **web server** exposes the HTTP port, accepts incoming connections, and
    redirects them towards the backend. One common option is nginx ([https://www.nginx.com/](https://www.nginx.com/)).
    Another common option is Apache ([https://httpd.apache.org/](https://httpd.apache.org/)).
    The web server can directly serve a request, for example, by directly returning
    static files, permanent redirects, or similar simple requests. If the request
    requires more computation, it will be directed towards the backend, acting as
    a reverse proxy.
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: '**网络服务器**公开HTTP端口，接受传入的连接，并将它们重定向到后端。一个常见的选项是nginx ([https://www.nginx.com/](https://www.nginx.com/))。另一个常见的选项是Apache
    ([https://httpd.apache.org/](https://httpd.apache.org/))。网络服务器可以直接服务请求，例如，通过直接返回静态文件、永久重定向或类似的简单请求。如果请求需要更多的计算，它将被重定向到后端，充当反向代理。'
- en: The primary objective of the web server in the presented architecture is to
    work as a reverse proxy, accepting HTTP requests, stabilizing the input of data,
    and queuing the incoming requests.
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 在所展示的架构中，网络服务器的主要目标是充当反向代理，接受HTTP请求，稳定数据输入，并排队处理传入的请求。
- en: A basic configuration for nginx could look like this. The code is available
    on GitHub at [https://github.com/PacktPublishing/Python-Architecture-Patterns/blob/main/chapter_06_web_server/nginx_example.conf](https://github.com/PacktPublishing/Python-Architecture-Patterns/blob/main/chapter_06_web_server/nginx_example.conf).
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: nginx的基本配置可能看起来像这样。代码可在GitHub上找到：[https://github.com/PacktPublishing/Python-Architecture-Patterns/blob/main/chapter_06_web_server/nginx_example.conf](https://github.com/PacktPublishing/Python-Architecture-Patterns/blob/main/chapter_06_web_server/nginx_example.conf)。
- en: '[PRE0]'
  id: totrans-52
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: The directive `server` opens and closes the basic block to define how to serve
    the data. Note each line ends with a semicolon.
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 指令`server`用于打开和关闭基本块，以定义如何服务数据。注意每行都以分号结尾。
- en: In nginx parlance, each server directive defines a virtual server. Normally
    there will be only one, but multiple can be configured, for example, to define
    different behaviors based on the DNS addressed.
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 在nginx术语中，每个服务器指令定义了一个虚拟服务器。通常只有一个，但也可以配置多个，例如，根据DNS地址定义不同的行为。
- en: 'Inside, we have a basic configuration on what port to serve – in our case,
    port 80 and both IPv4 and IPv6 addresses. The `default_server` clause means this
    is the server to be used by default:'
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 在内部，我们有一个基本配置，说明在哪个端口提供服务——在我们的例子中，端口80和IPv4和IPv6地址。`default_server`子句表示这是默认要使用的服务器：
- en: '[PRE1]'
  id: totrans-56
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: IPv4 is the common address with four numbers, like `127.0.0.1`. IPv6 is longer,
    and it's intended as a replacement for IPv4\. For example, an IPv6 address can
    be expressed as `2001:0db8:0000:0000:0000:ff00:0042:7879`. IPv4 addresses have
    already been exhausted, meaning that there are no new addresses available. IPv6
    will in the long run provide enough to avoid this problem, though IPv4 is still
    widely used, and probably will remain in use for a long time yet.
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: IPv4是常见的四数字地址，如`127.0.0.1`。IPv6更长，它被设计为IPv4的替代品。例如，一个IPv6地址可以表示为`2001:0db8:0000:0000:0000:ff00:0042:7879`。IPv4地址已经耗尽，这意味着没有新的地址可用。从长远来看，IPv6将提供足够的地址以避免这个问题，尽管IPv4仍然被广泛使用，并且可能还会继续使用很长时间。
- en: Next, we define where the static files are, both in terms of the external URL,
    and what is the mapping with some section of the hard drive.
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们定义静态文件的位置，包括外部URL以及与硬盘某个部分的映射。
- en: 'Note the static location needs to be defined before the reverse proxy:'
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 注意静态位置需要在反向代理之前定义：
- en: '[PRE2]'
  id: totrans-60
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: '`root` defines the starting point, while `location` starts a section that will
    serve the URL `/static/file1.txt` from the file located in the hard drive at `/opt/static/file1.txt`.'
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: '`root`定义了起点，而`location`开始一个将URL `/static/file1.txt`从硬盘上的`/opt/static/file1.txt`文件中提供的服务部分。'
- en: '`try_files` will scan for files in the URI and raise a 404 error if it''s not
    there.'
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: '`try_files`将扫描URI中的文件，如果不存在则引发404错误。'
- en: '`autoindex` automatically generates an index page to check the contents of
    a directory.'
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: '`autoindex`自动生成索引页面以检查目录的内容。'
- en: This option is typically disabled in production servers, but it's very handy
    to detect problems with static files while running in test mode.
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 这个选项通常在生产服务器上被禁用，但在测试模式下运行时检测静态文件问题非常有用。
- en: It's important in production environments to serve static files directly from
    the web server, instead of doing them further along the line with the Python worker.
    While this is possible, and a common case when working in a development environment,
    it's very inefficient. The speed and memory usage will be much bigger, while a
    web server is optimized to serve static files. Please always remember to serve
    static files in production through a web server.
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 在生产环境中，直接从Web服务器提供静态文件，而不是在Python工作流中进一步处理，这是很重要的。虽然这是可能的，并且在开发环境中是一个常见情况，但它非常低效。速度和内存使用将大大增加，而Web服务器已经优化了提供静态文件。请始终记住，在生产环境中通过Web服务器提供静态文件。
- en: Serving static content externally
  id: totrans-66
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 外部提供静态内容
- en: 'An alternative is to use an external service to handle files, like AWS S3,
    that allows you to serve static files. The files then will be under a different
    URL than the service, for example:'
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 另一个选择是使用外部服务来处理文件，例如AWS S3，它允许你提供静态文件。文件将位于与服务的不同URL下，例如：
- en: The service URL is `https://example.com/index`
  id: totrans-68
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 服务的URL是`https://example.com/index`
- en: The static files are in `https://mybucket.external-service/static/`
  id: totrans-69
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 静态文件在`https://mybucket.external-service/static/`
- en: All the references inside the service web pages, then, should point to the external
    service endpoint.
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，服务网页内的所有引用都应指向外部服务端点。
- en: This way of operating requires you to push the code to the external service
    as part of the deployment. To allow for uninterrupted deployments, remember that
    the static content needs to be available before. Another important detail is to
    upload them with a different path, so static files between deployments are not
    confused.
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 这种操作方式要求你将代码作为部署的一部分推送到外部服务。为了允许不间断的部署，请记住，静态内容需要在之前可用。另一个重要细节是使用不同的路径上传它们，以便部署之间的静态文件不会混淆。
- en: 'This is easy to do using different root paths. For example:'
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 使用不同的根路径来做这件事很容易。例如：
- en: Version `v1` of the service is deployed. This is the starting point. The static
    content is served from `https://mybucket.external-service/static/v1/`.
  id: totrans-73
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 服务的`v1`版本已部署。这是起点。静态内容从`https://mybucket.external-service/static/v1/`提供。
- en: The calls to the service, like `https://example.com/index`, return all their
    static content pointing at version `v1`.
  id: totrans-74
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 对服务的调用，如`https://example.com/index`，返回所有指向版本`v1`的静态内容。
- en: Once `v2` of the service is ready, the first thing to do is to push it to the
    external service, so it's available in `https://mybucket.external-service/static/v2/`.
    Note that, at this point, no user is accessing `/static/v2`; the service is still
    returning `/static/v1`.
  id: totrans-75
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 一旦服务的`v2`版本准备就绪，首先要做的就是将其推送到外部服务，以便在`https://mybucket.external-service/static/v2/`中可用。注意，在这个时候，没有用户访问`/static/v2`；服务仍然返回`/static/v1`。
- en: Deploy the new service. Once it is deployed, the users will start accessing
    `/static/v2` when they call `https://example.com/index`.
  id: totrans-76
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 部署新服务。一旦部署完成，用户在调用 `https://example.com/index` 时将开始访问 `/static/v2`。
- en: As we've seen in previous chapters, the key for a seamless deployment is to
    perform actions in small increments, and each step must perform actions that are
    reversible and prepare the terrain so there's no moment when something that's
    required is not ready.
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我们在前面的章节中看到的，无缝部署的关键是分小步骤执行操作，并且每一步都必须执行可逆的操作，并准备好地形，以便没有某个必需的元素尚未准备好的时刻。
- en: This approach can be used for big operations. In a JavaScript-heavy interface,
    like a single-page application, changing the static files effectively can be a
    new deployment. The underlying service API can remain the same but changing the
    downloaded version for all JavaScript code and other static content, which in
    effect will deploy a new version.
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 这种方法可以用于大型操作。在一个 JavaScript 为主的界面，如单页应用程序中，更改静态文件实际上可以视为一个新的部署。底层服务 API 可以保持不变，但更改所有
    JavaScript 代码和其他静态内容的下载版本，这实际上将部署一个新版本。
- en: We talked about single-page apps in *Chapter 2*.
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在 *第二章* 中讨论了单页应用程序。
- en: This structure makes both versions of the static content available at the same
    time. This can also be used to make tests or release beta versions. As the service
    is returning whether to use version A or B, this can be set dynamically.
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 这种结构使得静态内容的两个版本可以同时可用。这也可以用来进行测试或发布测试版。由于服务返回是否使用版本 A 或 B，这可以动态设置。
- en: 'For example, adding an optional parameter in any call to overwrite the returned
    version:'
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，在任意调用中添加一个可选参数来覆盖返回的版本：
- en: Calling `https://example.com/index` returns the default version, for example,
    `v2`.
  id: totrans-82
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 调用 `https://example.com/index` 返回默认版本，例如，`v2`。
- en: Calling `https://example.com/index?overwrite_static=v3` returns the specified
    version instead, like `v3`.
  id: totrans-83
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 调用 `https://example.com/index?overwrite_static=v3` 将返回指定的版本，例如 `v3`。
- en: Other options are returning `v3` for specific users, like beta testers or internal
    staff. Once `v3` is deemed correct, it can be changed to be the new default with
    a small change in the service.
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 其他选项是为特定用户返回 `v3`，例如测试人员或内部员工。一旦 `v3` 被认为正确，可以通过对服务进行微小更改将其更改为新的默认版本。
- en: This approach can be taken to the extreme to push any single commit to the source
    control to the public S3 bucket, and then test in any environment, including production.
    This can help to generate a very fast feedback loop where QA or product owners
    can quickly see changes in their own browser, without requiring any deployment
    or special environment.
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 这种方法可以极端到将任何单个提交推送到源控制到公共 S3 存储桶，然后在任何环境中进行测试，包括生产环境。这可以帮助生成一个非常快速的反馈循环，其中 QA
    或产品所有者可以快速在自己的浏览器中看到更改，而无需进行任何部署或特殊环境。
- en: Don't feel limited to a unique integer as the version number; it can work as
    well with a random UUID or SHA of the content generated automatically. Web storage
    is quite cheap, so it would require a lot of versions with very big files to really
    start to worry about cost. And old versions can be deleted periodically.
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 不要将版本号限制为唯一的整数；它也可以与自动生成的随机 UUID 或内容的 SHA 一起工作。Web 存储相当便宜，所以只有当版本非常多且文件非常大时，才会真正开始担心成本。并且可以定期删除旧版本。
- en: While this approach can be very aggressive and not viable for all applications,
    for an application that requires many changes in a rich JavaScript interface or
    to make drastic changes to the look and feel, it can be highly productive.
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然这种方法可能非常激进，并不适用于所有应用程序，但对于需要在大型的 JavaScript 界面中进行许多更改或对外观和感觉进行重大更改的应用程序，它可以非常高效。
- en: This external serving can be combined with **CDN** (**content delivery network**)
    support for a multiregional proxy. This will distribute the files around the world
    to provide a copy of it closer to the user.
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 这种外部服务可以与 **CDN**（**内容分发网络**）支持的多区域代理结合使用。这将把文件分布到世界各地，为用户提供更接近的副本。
- en: Think of a CDN as an internal cache by the company providing the service. For
    example, we have a service where their servers are located in Europe, but a user
    is accessing it from Japan. This company has servers in Japan that store a copy
    of the static content. That means that the user can access the files with much
    lower latency than if the request had to reach a server in Europe, more than 8,000
    kilometers away.
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 将CDN视为提供服务公司的内部缓存。例如，我们有一个服务，他们的服务器位于欧洲，但用户从日本访问它。这家公司在日本有服务器，存储了静态内容的副本。这意味着用户可以以比请求必须到达欧洲的服务器（超过8000公里）低得多的延迟访问文件。
- en: Using a CDN is very powerful for truly global audiences. They are especially
    useful for serving data that requires low latency around the world. For example,
    broadcasting near real-time video.
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 使用CDN对于真正全球的受众来说非常强大。它们特别适用于需要全球低延迟的数据服务。例如，广播接近实时视频。
- en: Video broadcast online is typically transferred as small video chunks of a few
    seconds in duration. An index file keeps track of what is the latest chunk generated,
    so clients can be kept up to date. This is the basis of the format **HTTP Live
    Streaming**, or **HLS**, very common as the transfer of data is done directly
    through HTTP.
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 在线视频广播通常以持续几秒的小视频块形式传输。一个索引文件会记录最新生成的块是什么，这样客户端就可以保持最新状态。这是**HTTP实时流**（**HLS**）格式的基础，这种格式非常常见，因为数据传输是通过HTTP直接进行的。
- en: The data can be distributed internally between the different servers from the
    company providing the CDN service quite quickly, as they'll use dedicated networks
    between them instead of using an external network.
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 由于它们之间将使用专用网络而不是外部网络，因此CDN服务提供商的不同服务器之间可以非常快速地内部分发数据。
- en: In any case, using an external service to store the static files will, obviously,
    remove the need to configure the web server for them.
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 在任何情况下，使用外部服务来存储静态文件将显然消除为它们配置Web服务器的需要。
- en: Reverse proxy
  id: totrans-94
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 反向代理
- en: Let's continue describing the web server configuration. After describing the
    static files, we need to define a connection to the backend, acting as a reverse
    proxy.
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们继续描述Web服务器配置。在描述静态文件之后，我们需要定义一个连接到后端，充当反向代理的连接。
- en: A reverse proxy is a proxy server that can redirect a received request towards
    one or more defined backends. In our example, the backend is the uWSGI process.
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 反向代理是一种代理服务器，可以将接收到的请求重定向到一个或多个定义的后端。在我们的例子中，后端是uWSGI进程。
- en: A reverse proxy works in a similar way as a load balancer, though load balancers
    can work with more protocols, while a reverse proxy is only capable of working
    with web requests. On top of distributing requests across different servers, it
    can also add some features like caching, security, SSL termination (receiving
    a request in HTTPS and connecting to other servers using HTTP), or, in this particular
    case, receive a web request and transfer it to through a WSGI connection.
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 反向代理的工作方式与负载均衡器类似，尽管负载均衡器可以与更多协议一起工作，而反向代理只能处理Web请求。除了在不同服务器之间分配请求之外，它还可以添加一些功能，如缓存、安全性、SSL终止（接收HTTPS请求并使用HTTP连接到其他服务器），或者在这种情况下，接收Web请求并通过WSGI连接将其传输。
- en: The web server will be able to communicate with the backend in multiple ways,
    allowing flexibility. This can use different protocols, like FastCGI, SCGI, straight
    HTTP for pure proxying, or, in our case, connecting directly to the uWSGI protocol.
    We need to define it to connect through either a TCP socket or a UNIX socket.
    We will use a UNIX socket.
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: Web服务器将以多种方式与后端进行通信，从而提供灵活性。这可以使用不同的协议，如FastCGI、SCGI、直接HTTP进行纯代理，或者在我们的情况下，直接连接到uWSGI协议。我们需要定义它，以便通过TCP套接字或UNIX套接字连接。我们将使用UNIX套接字。
- en: TCP sockets are designed to allow communication between different servers, while
    UNIX sockets are designed to communicate processes locally. UNIX sockets are a
    little bit lighter for communication inside the same host and they work like a
    file, allowing you to assign them permissions to control what process can access
    what socket.
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: TCP套接字旨在允许不同服务器之间的通信，而UNIX套接字旨在本地通信进程。UNIX套接字在相同主机内部通信时稍微轻量一些，并且它们的工作方式类似于文件，允许你分配权限以控制哪些进程可以访问哪些套接字。
- en: 'The socket needs to be coordinated with the way uWSGI is configured. As we
    will see later, the uWSGI process will create it:'
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 套接字需要与uWSGI的配置方式相协调。正如我们稍后将会看到的，uWSGI进程将创建它：
- en: '[PRE3]'
  id: totrans-101
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: First of all, the root of the server is at the `/` URL. It's important to make
    the static content before the reverse proxy, as the locations are checked in order.
    So any request for a `/static` request gets detected before checking for `/` and
    it's properly treated.
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，服务器的根目录位于 `/` URL。在反向代理之前制作静态内容非常重要，因为检查的顺序是按照位置进行的。所以任何对 `/static` 的请求都会在检查
    `/` 之前被检测到，并且会得到适当的处理。
- en: The core of the reverse proxy configuration is the `uwsgi_pass` clause. This
    specified where to redirect the requests. `include uwgi_params` will add a bunch
    of standard configurations to be passed to the next stage.
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 反向代理配置的核心是 `uwsgi_pass` 子句。它指定了请求重定向的位置。`include uwgi_params` 将添加一些标准配置传递到下一阶段。
- en: '`uwsgi_params` is actually a defined file included by default in nginx config
    that adds a lot of `uwsgi_param` statements with elements like `SERVER_NAME`,
    `REMOTE_ADDRESS`, etc.'
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: '`uwsgi_params` 实际上是一个在 nginx 配置中默认包含的已定义文件，它添加了许多带有 `SERVER_NAME`、`REMOTE_ADDRESS`
    等元素的 `uwsgi_param` 语句。'
- en: More `uwsgi_param` can be added if necessary, in a similar way to the headers.
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 如果需要，可以添加更多的 `uwsgi_param`，方法与头部类似。
- en: Extra elements can be added as HTTP headers. They'll be added to the request,
    so they are available further down the request.
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 可以添加额外的元素作为 HTTP 头部。它们将被添加到请求中，因此它们在请求的后续部分是可用的。
- en: '[PRE4]'
  id: totrans-107
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: In this case, we are adding the `Host` header, with information about the requested
    host. Note that the `$host` is an indication to nginx to fill the value with the
    host the request is addressed to. In the same way, the header `X-Real-IP` is added
    with the IP address from the remote address.
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 在这种情况下，我们添加了 `Host` 头部，其中包含有关请求的主机信息。请注意，`$host` 是 nginx 填充请求所指向的主机值的指示。同样，添加了
    `X-Real-IP` 头部，其中包含远程地址的 IP 地址。
- en: Setting headers correctly to pass on is unappreciated work, but can be critical
    to properly monitor problems. Setting headers may require doing so at different
    stages. As we will discuss later, a single request can pass through multiple proxies,
    and each of them needs to adequately forward the headers.
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 正确设置头部信息以传递是一个不受重视的工作，但这对正确监控问题至关重要。设置头部可能需要在不同的阶段进行。正如我们稍后将要讨论的，单个请求可以穿过多个代理，并且每个代理都需要充分转发头部信息。
- en: In our configuration, we only use a single backend, as uWSGI will balance between
    different workers. But, if necessary, multiple backends can be defined, even mixing
    UNIX and TCP sockets, defining a cluster.
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的配置中，我们只使用单个后端，因为 uWSGI 会在不同的工作者之间进行平衡。但是，如果需要，可以定义多个后端，甚至可以混合 UNIX 和 TCP
    套接字，定义一个集群。
- en: '[PRE5]'
  id: totrans-111
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: Later, define the `uwsgi_pass` to use the cluster. The requests will be equally
    spread over the different backends.
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，定义 `uwsgi_pass` 以使用集群。请求将在不同的后端之间均匀分配。
- en: '[PRE6]'
  id: totrans-113
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: Logging
  id: totrans-114
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 日志记录
- en: 'We also need to track any possible error or access. There are two different
    logs that `nginx` (and other web servers) produces:'
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还需要跟踪任何可能的错误或访问。`nginx`（以及其他网络服务器）产生两个不同的日志：
- en: '**Error log**: The error log tracks possible problems from the web server itself,
    like not being able to start, configuration problems, etc.'
  id: totrans-116
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**错误日志**：错误日志跟踪来自网络服务器本身的可能问题，如无法启动、配置问题等。'
- en: '**Access log**: The access log reports any request accessing the system. This
    is the basic information about the system flowing. It can be used to find specific
    problems like 502 errors when the backend cannot be connected, or, when treated
    as aggregated, it can detect problems like an abnormal number of error status
    codes (`4xx` or `5xx`).'
  id: totrans-117
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**访问日志**：访问日志报告任何访问系统的请求。这是系统流动的基本信息。它可以用来查找特定问题，如后端无法连接时的502错误，或者，当作为聚合处理时，可以检测到异常数量的错误状态代码（`4xx`
    或 `5xx`）。'
- en: We will talk in further detail about logs in *Chapter 11*.
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将在第11章中更详细地讨论日志。
- en: Both logs are critical information that needs to be adequately detected. Following
    the Twelve-Factor App, we should treat them as streams of data. The easiest is
    to redirect them both to standard output.
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 这两个日志都是需要充分检测的关键信息。遵循十二要素应用原则，我们应该将它们视为数据流。最简单的方法是将它们都重定向到标准输出。
- en: '[PRE7]'
  id: totrans-120
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: This requires nginx to not start as a daemon process, or if it is, capture the
    standard output properly.
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 这要求 nginx 不要以守护进程的方式启动，或者如果它是以守护进程方式启动的，则正确捕获标准输出。
- en: Another option is to redirect the log into a centralized log facility, using
    the proper protocol. This directs all the logs into a centralized server that
    captures the information. In this example, we send it to a syslog host in `syslog_host`.
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 另一个选项是将日志重定向到集中日志设施，使用适当的协议。这将所有日志重定向到集中服务器，以捕获信息。在这个例子中，我们将其发送到 `syslog_host`
    上的 syslog 主机。
- en: '[PRE8]'
  id: totrans-123
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: This protocol allows you to include tags and extra information that can help
    separate the origin of each log later.
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 此协议允许您包含标签和额外信息，这些信息可以帮助在以后区分每个日志的来源。
- en: Being able to distinguish the source of each log is critical and always requires
    a bit of tweaking. Be sure to spend some time making the logs easy to search.
    It will greatly simplify the work when an error in production requires gathering
    information.
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 能够区分每个日志的来源至关重要，并且始终需要一些调整。请确保花些时间使日志易于搜索。当生产中出现错误需要收集信息时，这将极大地简化工作。
- en: Advanced usages
  id: totrans-126
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 高级用法
- en: A web server is very powerful, and shouldn't be underestimated. Other than acting
    purely as a proxy, there are a lot of other features that can be enabled like
    returning custom redirects, overwriting the proxy with a static page for maintenance
    windows, rewriting URLs to adjust changes, providing SSL termination (decrypt
    receiving HTTPS requests to pass them decrypted through regular HTTP, and encrypt
    the result back), caching requests, splitting the requests based on percentages
    for A/B testing, choosing a backend server based on geolocalization of the requester,
    etc.
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: Web 服务器非常强大，不应被低估。除了纯粹作为代理外，还有很多其他功能可以启用，如返回自定义重定向、在维护窗口期间用静态页面覆盖代理、重写 URL 以调整更改、提供
    SSL 终止（解密接收到的 HTTPS 请求，以便通过常规 HTTP 传递解密后的请求，并将结果加密回），缓存请求、根据百分比分割请求进行 A/B 测试、根据请求者的地理位置选择后端服务器等。
- en: Be sure to read the documentation of `nginx` at [http://nginx.org/en/docs/](http://nginx.org/en/docs/)
    to read all the possibilities.
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 请务必阅读 `nginx` 的文档，地址为 [http://nginx.org/en/docs/](http://nginx.org/en/docs/)，以了解所有可能性。
- en: uWSGI
  id: totrans-129
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: uWSGI
- en: The next element of the chain is the uWSGI application. This application receives
    the requests from `nginx` and redirects them into independent Python workers,
    in WSGI format.
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 链接的下一个元素是 uWSGI 应用程序。该应用程序接收来自 `nginx` 的请求并将它们重定向到独立的 Python 工作进程，以 WSGI 格式。
- en: '**Web Server Gateway Interface** (**WSGI**) is a Python standard to deal with
    web requests. It''s very popular and supported by a lot of software, both from
    the sending end (like `nginx`, but also other web servers like Apache and GUnicorn)
    and from the receiving end (virtually every Python web framework, like Django,
    Flask, or Pyramid).'
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: '**Web 服务器网关接口**（**WSGI**）是处理 Web 请求的 Python 标准。它非常流行，并且得到了许多软件的支持，包括发送端（如 `nginx`，以及其他
    Web 服务器，如 Apache 和 GUnicorn）和接收端（几乎每个 Python Web 框架，如 Django、Flask 或 Pyramid）。'
- en: uWSGI will also start and coordinate the different processes, handling the lifecycle
    for each of them. The application works as an intermediary, starting a group of
    workers receiving the requests.
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: uWSGI 还将启动和协调不同的进程，处理每个进程的生命周期。应用程序作为一个中介，启动一组接收请求的工作进程。
- en: uWSGI is configured through a `uwsgi.ini` file. Let's see an example, available
    on GitHub at [https://github.com/PacktPublishing/Python-Architecture-Patterns/blob/main/chapter_06_web_server/uwsgi_example.uni](https://github.com/PacktPublishing/Python-Architecture-Patterns/blob/main/chapter_06_web_server/uwsgi_example.uni).
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: uWSGI 通过 `uwsgi.ini` 文件进行配置。让我们看看一个例子，可在 GitHub 上找到，地址为 [https://github.com/PacktPublishing/Python-Architecture-Patterns/blob/main/chapter_06_web_server/uwsgi_example.uni](https://github.com/PacktPublishing/Python-Architecture-Patterns/blob/main/chapter_06_web_server/uwsgi_example.uni)。
- en: '[PRE9]'
  id: totrans-134
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'The first element defines what the working directory is. The application will
    be launched here, and other file references will work from here:'
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 第一个元素定义了工作目录是什么。应用程序将在这里启动，其他文件引用也将从这里开始：
- en: '[PRE10]'
  id: totrans-136
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: Then, we describe where the `wsgi.py` file is, which describes our application.
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们描述 `wsgi.py` 文件的位置，该文件描述了我们的应用程序。
- en: The WSGI application
  id: totrans-138
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: WSGI 应用程序
- en: Inside this file is the definition of the `application` function, which uWSGI
    can use to address the internal Python code, in a controlled way.
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 在此文件中是 `application` 函数的定义，uWSGI 可以以受控的方式使用它来访问内部 Python 代码。
- en: 'For example:'
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 例如：
- en: '[PRE11]'
  id: totrans-141
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: The first parameter is a dictionary with predefined variables that detail the
    request (like `METHOD`, `PATH_INFO`, `CONTENT_TYPE`, and so on) and parameters
    related to the protocol or environment (for example, `wsgi.version`).
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 第一个参数是一个包含预定义变量的字典，这些变量详细说明了请求（如 `METHOD`、`PATH_INFO`、`CONTENT_TYPE` 等）以及与协议或环境相关的参数（例如，`wsgi.version`）。
- en: The second parameter, `start_response`, is a callable that allows you to set
    up the return status and any headers.
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 第二个参数 `start_response` 是一个可调用对象，允许您设置返回状态和任何头信息。
- en: The function should return the body. Note how it's returned in byte stream format.
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 函数应该返回体。注意它是以字节流格式返回的。
- en: The difference between text streams (or strings) and byte streams was one of
    the big differences introduced in Python 3\. To summarize it, byte streams are
    raw binary data, while text streams contain meaning by interpreting that data
    through a particular encoding.
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 文本流（或字符串）与字节流之间的区别是 Python 3 引入的很大区别之一。为了总结，字节流是原始的二进制数据，而文本流通过特定的编码解释这些数据来包含意义。
- en: The differentiation between both can be a bit baffling sometimes, in particular
    since Python 3 makes the difference explicit, and that clashes with some previous
    lax practices, especially when dealing with ASCII content that can be represented
    in the same way.
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 这两种之间的区别有时可能有些令人困惑，尤其是在 Python 3 使这种区别变得明确的情况下，这与其他一些先前宽松的做法相冲突，尤其是在处理可以用相同方式表示的
    ASCII 内容时。
- en: Keep in mind that text streams need to be encoded to be transformed into byte
    streams, and byte streams need to be decoded into text streams. Encoding is moving
    from the abstract representation of text to the precise representation of binary.
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 请记住，文本流需要被编码才能转换为字节流，字节流需要被解码为文本流。编码是将文本的抽象表示转换为精确的二进制表示。
- en: 'For example, the Spanish word "cañón" contains two characters not present in
    ASCII, `ñ` and `ó`. You can see how encoding them through UTF8 replaces them with
    specific binary elements described in UTF8:'
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，西班牙语单词 "cañón" 包含两个在 ASCII 中不存在的字符，`ñ` 和 `ó`。您可以看到通过 UTF8 编码它们是如何被替换为 UTF8
    中描述的特定二进制元素的：
- en: '[PRE12]'
  id: totrans-149
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: The function can also work as a generator and use the keyword `yield` instead
    of `return` when the returning body needs to be streamed.
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 该函数还可以作为生成器工作，并在返回体需要流式传输时使用关键字 `yield` 而不是 `return`。
- en: Any function that uses `yield` is a generator in Python. This means that when
    called, it returns an iterator object that returns elements one by one, normally
    to be used in loops.
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 任何使用 `yield` 的函数在 Python 中都是生成器。这意味着当被调用时，它返回一个迭代器对象，逐个返回元素，通常用于循环中。
- en: This is very useful for situations where each element of the loop takes some
    time to process but can be returned without being required to calculate every
    single item, reducing latency and memory usage, as not all elements need to be
    maintained in memory.
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 这对于每种循环元素需要一些时间来处理但可以返回而不必计算每个单独的项目的情况非常有用，从而减少延迟和内存使用，因为不需要在内存中维护所有元素。
- en: '[PRE13]'
  id: totrans-153
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: In any case, the WSGI file is normally created by default by whatever framework
    is used. For example, a `wsgi.py` file created by Django will look like this.
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 在任何情况下，WSGI 文件通常由使用的框架默认创建。例如，Django 创建的 `wsgi.py` 文件看起来像这样。
- en: '[PRE14]'
  id: totrans-155
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: Note how the function `get_wsgi_application` will automatically set up the proper
    application function, and connect it with the rest of the defined code – a great
    advantage of using an existing framework!
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 注意函数 `get_wsgi_application` 将如何自动设置正确的应用程序函数，并将其与定义的其余代码连接起来——这是使用现有框架的一个巨大优势！
- en: Interacting with the web server
  id: totrans-157
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 与网络服务器交互
- en: 'Let''s continue with the `uwsgi.ini` configuration with the socket configuration:'
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们继续使用 `uwsgi.ini` 配置文件中的套接字配置：
- en: '[PRE15]'
  id: totrans-159
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: The `socket` parameter creates the UNIX socket for the web server to connect
    to. It was discussed before in this chapter, when talking about the web server.
    This needs to be coordinated on both sides, to ensure they connect properly.
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: '`socket` 参数为网络服务器创建用于连接的 UNIX 套接字。这在本章之前讨论网络服务器时已经讨论过。这需要在双方进行协调，以确保它们能够正确连接。'
- en: uWSGI also allows you to use a native HTTP socket, using the option `http-socket`.
    For example, `http-socket = 0.0.0.0:8000` to serve all addresses on port 8000\.
    You may use this option if the web server is not on the same server and needs
    to communicate through the network.
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: uWSGI 还允许您使用本机 HTTP 套接字，使用选项 `http-socket`。例如，`http-socket = 0.0.0.0:8000` 用于在端口
    8000 上服务所有地址。如果您使用的网络服务器不在同一服务器上并且需要通过网络进行通信，则可以使用此选项。
- en: When possible, avoid exposing uWSGI directly publicly over the internet. A web
    server will be safer and more efficient. It will also serve static content much
    more efficiently. If you really must skip the web server, use the option `http`
    instead of `http-socket`, which includes a certain level of protection.
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 当可能时，避免直接将 uWSGI 公开暴露在互联网上。使用一个网络服务器会更安全、更高效。它还能更高效地服务静态内容。如果你确实必须跳过网络服务器，请使用选项
    `http` 而不是 `http-socket`，后者包含一定程度的保护。
- en: The `vacuum` option cleans up the socket when the server is closed.
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: '`vacuum` 选项在服务器关闭时清理套接字。'
- en: Processes
  id: totrans-164
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 进程
- en: 'The next parameters control the number of processes and how to control them:'
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 下一个参数控制进程的数量以及如何控制它们：
- en: '[PRE16]'
  id: totrans-166
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: The `master` parameter creates a master process that ensures that the number
    of workers is correct, restarting if not, and deals with the process lifecycle,
    among other tasks. It should always be enabled in production for smooth operation.
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: '`master` 参数创建一个主进程，确保工作进程的数量正确，如果不正确则重启，并处理进程生命周期等任务。在生产环境中，为了平稳运行，应始终启用此参数。'
- en: The `processes` parameter is very straightforward and describes how many Python
    workers should be started. Received requests will be load balanced across them.
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: '`processes` 参数非常直接，描述了应该启动多少个 Python 工作进程。接收到的请求将在它们之间进行负载均衡。'
- en: The way uWSGI generates new processes is through pre-forking. This means that
    a single process gets started, and after the application is loaded (which may
    take a while), it's cloned through a fork process. This sensibly speeds up the
    startup time for new processes, but at the same time, relays that the setup of
    the application can be duplicated.
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: uWSGI 生成新进程的方式是通过预分叉。这意味着启动一个进程，在应用程序加载（可能需要一段时间）之后，通过分叉进程进行克隆。这合理地加快了新进程的启动时间，但同时也意味着应用程序的设置可以被复制。
- en: This assumption, on rare occasions, may cause problems with certain libraries
    that, for example, open file descriptors during initializations that cannot be
    shared safely. If that's the case, the parameter `lazy-apps` will make each worker
    start from scratch, independently. This is slower, but it creates more consistent
    results.
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 这种假设在罕见情况下可能会导致某些库出现问题，例如，在初始化期间打开文件描述符，而这些文件描述符无法安全共享。如果是这种情况，参数 `lazy-apps`
    将使每个工作进程从头开始独立启动。这会慢一些，但会创建更一致的结果。
- en: Choosing the right number of processes is highly dependent on the application
    itself and the hardware that supports it. The hardware is important as a CPU with
    multiple cores will be able to run more processes efficiently. The amount of IO
    vs CPU usage in the application will determine how many processes can be run by
    the CPU core.
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 选择正确的进程数量高度依赖于应用程序本身及其支持的硬件。硬件很重要，因为具有多个核心的 CPU 将能够更高效地运行更多进程。应用程序中的 IO 与 CPU
    使用量将决定 CPU 核心可以运行多少个进程。
- en: Theoretically, a process not using IO and purely crunching numbers will use
    the whole core without wait periods, not allowing the core to switch to another
    process meanwhile. A process with high IO, with the core idle while waiting for
    results from the database and external services, will increase its efficiency
    by performing more context switches. This number should be tested to ensure the
    best results. A common starting point will be two times the number of cores, but
    remember to monitor the system to tweak it and obtain the best results.
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 理论上，不使用 IO 且纯粹进行数值计算的进程将使用整个核心而无需等待时间，不允许核心在此期间切换到另一个进程。具有高 IO 的进程，在等待数据库和外部服务的结果时核心空闲，将通过执行更多上下文切换来提高其效率。这个数字应该经过测试以确保最佳结果。一个常见的起点是核心数的两倍，但请记住监控系统以调整它并获得最佳结果。
- en: An important detail about the created processes is that they deactivate the
    creation of new threads by default. This is an optimization choice. In the majority
    of web applications, there's no need to create independent threads inside each
    of the workers, and that allows you to deactivate the Python GIL, speeding up
    the code.
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 关于创建的进程的一个重要细节是，它们默认禁用新线程的创建。这是一个优化选择。在大多数网络应用程序中，不需要在每个工作进程内部创建独立的线程，这允许你禁用
    Python GIL，从而加快代码执行。
- en: The **Global Interpreter Lock** or **GIL** is a mutex lock that only allows
    a single thread to have control of the Python process. This means that, inside
    a single process, no two threads can run at the same time, something that multi-core
    CPU architecture makes possible. Note that multiple threads may be waiting for
    IO results while another runs, which is a usual situation in real-life applications.
    The GIL is typically held and released constantly, as each operation first holds
    the GIL and then releases it at the end.
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: '**全局解释器锁**（Global Interpreter Lock）或**GIL**是一种互斥锁，它只允许单个线程控制Python进程。这意味着在单个进程中，不会有两个线程同时运行，这是多核CPU架构使得成为可能的事情。请注意，当另一个线程运行时，多个线程可能正在等待IO结果，这在实际应用中是一种常见情况。GIL通常会被频繁地获取和释放，因为每个操作首先获取GIL，然后在结束时释放它。'
- en: The GIL is commonly blamed for inefficiencies in Python, though the effect is
    only perceived in high-CPU multi-threaded operations in native Python (as opposed
    to using optimized libraries like NumPy), which are not as usual and are already
    slow to start with.
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: GIL通常被指责是Python效率低下的原因，尽管这种影响只有在原生Python中的高CPU多线程操作（与使用优化库如NumPy相比）中才会感觉到，而这些操作并不常见，而且它们本身就启动缓慢。
- en: These interactions with the GIL are only wasteful if no threads will be run,
    so that's why uWSGI deactivates it by default.
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 与GIL的这些交互只有在没有线程将运行的情况下才是浪费的，这就是为什么uWSGI默认禁用它的原因。
- en: If threads need to be used, the option `enable-threads` will enable them.
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 如果需要使用线程，`enable-threads`选项将启用它们。
- en: Process lifecycle
  id: totrans-178
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 进程生命周期
- en: During the time of operation, processes won't stay static. Any working web application
    will need to reload with new code changes regularly. The next parameters are related
    to how processes are created and destroyed.
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: 在操作期间，进程不会保持静态。任何正在运行的网络应用都需要定期重新加载以应用新的代码更改。接下来的参数与进程的创建和销毁有关。
- en: '[PRE17]'
  id: totrans-180
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: '`max-requests` specifies the number of requests to be processed by a single
    worker before being restarted. Once the worker gets to this number, uWSGI will
    destroy it and create another worker from scratch, following the usual process
    (fork by default, or using `lazy-apps` if configured).'
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: '`max-requests`指定了单个工作进程在重启之前需要处理的请求数量。一旦工作进程达到这个数量，uWSGI将销毁它，并从头开始创建另一个工作进程，遵循常规流程（默认为fork，或者如果配置了`lazy-apps`，则使用`lazy-apps`）。'
- en: This is useful to avoid problems with memory leaks or other sorts of stale problems,
    where the performance of a worker gets degraded over time. Recycling the workers
    is a protective measure that can be taken pre-emptively, so even if a problem
    is present, it will be corrected before it causes any issues.
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: 这对于避免内存泄漏或其他类型的陈旧问题很有用，这些问题会导致工作进程的性能随时间下降。回收工作进程是一种可以预先采取的保护措施，因此即使存在问题，它也会在造成任何问题之前得到纠正。
- en: Remember that, based on the Twelve-Factor App, web workers need to be able to
    be stopped and started at any time, so this recycling is painless.
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: 记住，根据十二要素应用，网络工作进程需要能够在任何时候停止和启动，因此这种回收是无痛的。
- en: uWSGI will also recycle the worker when it's idle, after serving its 5,000^(th)
    request, so it will be a controlled operation.
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: 当工作进程空闲时，uWSGI也会回收工作进程，在服务了5,000次请求之后，这将是一个受控的操作。
- en: Keep in mind this recycling may interfere with other operations. Depending on
    the startup time, it may take a few seconds or worse (especially if `lazy-apps`
    is used) to start the worker, potentially creating a backlog of requests. uWSGI
    will queue the incoming requests. In our example configuration, there's only a
    single worker defined in `processes`. With multiple workers this can be mitigated,
    as the rest of the workers will be able to handle the extra load.
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: 请记住，这种回收可能会干扰其他操作。根据启动时间，启动工作进程可能需要几秒钟，或者更糟（特别是如果使用了`lazy-apps`），这可能会创建请求数据的积压。uWSGI将排队等待的请求数据。在我们的示例配置中，`processes`中只定义了一个工作进程。如果有多个工作进程，这可以通过其他工作进程处理额外的负载来减轻。
- en: When multiple workers are involved, if each of them will restart after their
    5,000^(th) request, a stampede problem can be created where one after another
    all the workers are recycled. Keep in mind that the load is distributed through
    the workers equally, so this count will be in sync across the multiple workers.
    While the expectation is that, for example, with 16 workers, at least 15 of them
    will be available, in practice we might find that all are being recycled at the
    same time.
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: 当涉及多个工作者时，如果他们中的每一个在完成5,000次请求后都会重启，可能会产生一种群羊效应，其中所有工作者一个接一个地被回收。请记住，负载在工作者之间是平均分配的，因此这个计数将在多个工作者之间同步。虽然预期例如在16个工作者的系统中，至少有15个是可用的，但在实践中我们可能会发现所有工作者同时被回收。
- en: 'To avoid this problem, use the `max-requests-delta` parameter. This parameter
    adds a variable number for each worker. It will multiply the delta for the worker
    ID (a unique consecutive number for each worker starting from 1). So, configuring
    a delta of 200, each worker will have the following:'
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: 为了避免这个问题，使用`max-requests-delta`参数。此参数为每个工作者添加一个可变数字。它将乘以工作者ID的Delta（每个工作者从1开始的唯一连续数字）。因此，配置Delta为200，每个工作者将具有以下配置：
- en: '| Worker | Base max-request | Delta | Total requests to recycle |'
  id: totrans-188
  prefs: []
  type: TYPE_TB
  zh: '| 工作者 | 基础最大请求 | Delta | 总回收请求 |'
- en: '| Worker 1 | 5,000 | 1 * 200 | 5,200 |'
  id: totrans-189
  prefs: []
  type: TYPE_TB
  zh: '| 工作者 1 | 5,000 | 1 * 200 | 5,200 |'
- en: '| Worker 2 | 5,000 | 2 * 200 | 5,400 |'
  id: totrans-190
  prefs: []
  type: TYPE_TB
  zh: '| 工作者 2 | 5,000 | 2 * 200 | 5,400 |'
- en: '| Worker 3 | 5,000 | 3 * 200 | 5,600 |'
  id: totrans-191
  prefs: []
  type: TYPE_TB
  zh: '| 工作者 3 | 5,000 | 3 * 200 | 5,600 |'
- en: '| … |  |  |  |'
  id: totrans-192
  prefs: []
  type: TYPE_TB
  zh: '| … |  |  |  |'
- en: '| Worker 16 | 5,000 | 16 * 200 | 8,200 |'
  id: totrans-193
  prefs: []
  type: TYPE_TB
  zh: '| 工作者 16 | 5,000 | 16 * 200 | 8,200 |'
- en: This makes the recycling happen at different times, increasing the number of
    workers available at the same time, as they won't restart simultaneously.
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: 这使得回收在不同的时间发生，增加了同时可用的工人数量，因为它们不会同时重启。
- en: This problem is of the same kind as what's called a cache stampede. This is
    produced where multiple cache values are invalidated at the same time, producing
    the regeneration of values at the same time. Because the system expects to be
    running under some cache acceleration, suddenly having to recreate a significant
    portion section of the cache may produce a serious performance problem, to the
    point of the complete collapse of the system.
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: 这个问题与所谓的缓存群羊效应是同一类型的。这是在多个缓存值同时失效时产生的，同时产生值的再生。因为系统期望在某种缓存加速下运行，突然需要重新创建缓存的重要部分可能会产生严重的性能问题，甚至可能导致系统完全崩溃。
- en: To avoid this, avoid setting fixed times for the cache to expire, such as a
    certain hour of the clock. This can happen, for example, if a backend gets updated
    with news for the day at midnight, making it tempting to expire the cache at this
    time. Instead, add an element to make the different keys expire at slightly different
    times to avoid this problem. This can be achieved by adding a small random amount
    of time to the expiry time for each of the keys, so they can reliably be refreshed
    at different times.
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: 为了避免这种情况，避免为缓存设置固定的过期时间，例如时钟的某个小时。例如，如果后端在午夜更新了当天的新闻，这可能会诱使你在此时过期缓存。相反，添加一个元素使不同的键在略微不同的时间过期以避免这个问题。这可以通过为每个键添加一小段时间的随机量来实现，这样它们就可以在不同的时间可靠地刷新。
- en: 'The `master-fifo` parameter creates a way to communicate with uWSGI and send
    commands:'
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: '`master-fifo`参数创建了一种与uWSGI通信并发送命令的方式：'
- en: '[PRE18]'
  id: totrans-198
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'This creates a UNIX socket in `/tmp/uwsgi-fifo` that can receive commands in
    the form of characters redirected to it. For example:'
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: 这在`/tmp/uwsgi-fifo`中创建了一个UNIX套接字，可以接收以字符形式重定向到它的命令。例如：
- en: '[PRE19]'
  id: totrans-200
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: This method allows for better handling of situations than sending signals, as
    there are more commands available and it allows for quite granular control of
    the processes and the whole uWSGI.
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: 与发送信号相比，这种方法可以更好地处理情况，因为提供了更多的命令，并且允许对进程和整个uWSGI进行相当细粒度的控制。
- en: For example, sending `Q` will produce a direct shutdown of uWSGI, while `q`
    will produce a graceful one. A graceful shutdown will start by stopping accepting
    new requests in uWSGI, then waiting until any request in the internal uWSGI queue
    is being processed, and when a worker has finished its request, stopping it in
    an orderly fashion. Finally, when all workers are done, stop the uWSGI master
    process.
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，发送`Q`将直接关闭uWSGI，而`q`将产生一个优雅的关闭。优雅的关闭将首先停止uWSGI接受新的请求，然后等待直到内部uWSGI队列中的任何请求正在处理，当一个工作者完成其请求后，有序地停止它。最后，当所有工作者都完成后，停止uWSGI主进程。
- en: The graceful reload with `r` takes a similar approach, keeping the requests
    in the internal queue and waiting until the workers are done to stop them and
    restart them. It will also load any new configuration related to uWSGI itself.
    Note that, during the time of the operation, the internal uWSGI listen queue may
    be filled up, causing problems.
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: 使用 `r` 键优雅地重新加载与保持请求在内部队列中并等待工作者完成以停止和重新启动它们的方法类似。它还会加载与 uWSGI 本身相关的任何新配置。请注意，在操作期间，内部
    uWSGI 监听队列可能会填满，导致问题。
- en: The size of the listen queue can be tweaked with the `listen` parameter, but
    keep in mind that there's a limit set up by Linux that you may need to change
    as well. Defaults are 100 for listen and 128 for the Linux configuration.
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: 监听队列的大小可以通过 `listen` 参数进行调整，但请记住，Linux 设置了一个限制，您可能需要更改它。默认值为监听 100，Linux 配置为
    128。
- en: Do tests before changing those to big values, as churning through a big backlog
    of tasks has its own problems.
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: 在更改这些值之前进行测试，因为处理大量任务队列有其自身的问题。
- en: If the loading of processes is done through the fork process, after starting
    up the first one, the rest will be copies, so they will be loaded quite quickly.
    By comparison, using `lazy-apps` may delay achieving full capacity as each individual
    worker will need to be individually started from scratch. This can produce an
    extra load on the server, depending on the number of workers and the startup procedure.
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: 如果进程的加载是通过 fork 进程完成的，则在启动第一个进程后，其余的将是副本，因此它们将很快被加载。相比之下，使用 `lazy-apps` 可能会延迟达到满负荷，因为每个单独的工作者都需要从头开始单独启动。这可能会根据工作者的数量和启动程序产生额外的服务器负载。
- en: A possible alternative for `lazy-apps` is to use the `c` option, reloading the
    workers with chain reloading. This reloads each worker independently, waiting
    until a single worker is totally reloaded before moving to the next one. This
    procedure doesn't reload the uWSGI configuration but will do with code changes
    in the workers. It will take longer, but it will work at a controller pace.
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: 对于 `lazy-apps` 的一个可能替代方案是使用 `c` 选项，通过链式重新加载来重新加载工作者。这将独立地重新加载每个工作者，等待单个工作者完全重新加载后再进行下一个。此过程不会重新加载
    uWSGI 配置，但会处理工作者中的代码更改。这将花费更长的时间，但将以控制器速度工作。
- en: Reloading a single server under load may be complicated. Using multiple uWSGI
    servers simplifies the process. In this situation, reloads should happen at different
    times to allow you to distribute the load.
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: 在负载下重新加载单个服务器可能很复杂。使用多个 uWSGI 服务器可以简化这个过程。在这种情况下，重新加载应在不同的时间进行，以便您可以分配负载。
- en: A cluster-style approach can be taken in using multiple servers to perform this
    dance, creating copies of the uWSGI configuration in multiple servers and then
    recycling them one at a time. While one is reloading, the others will be able
    to handle the extra load. In extreme situations, an extra server can be used to
    produce extra capacity during the reload.
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
  zh: 可以采用集群式方法使用多个服务器来执行此操作，在多个服务器中创建 uWSGI 配置的副本，然后逐个回收它们。当其中一个正在重新加载时，其他服务器将能够处理额外的负载。在极端情况下，可以使用额外的服务器在重新加载期间产生额外的容量。
- en: This is common in cloud environments where an extra server can be used and then
    destroyed. In Docker situations, new containers can be added to provide this extra
    capacity.
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: 这在云环境中很常见，其中可以使用额外的服务器，然后将其销毁。在 Docker 情况下，可以添加新的容器以提供额外的容量。
- en: For more information about the `master-fifo` and accepted commands, including
    how to pause and resume the instance, and other exotic operations, check the uWSGI
    documentation at [https://uwsgi-docs.readthedocs.io/en/latest/MasterFIFO.html](https://uwsgi-docs.readthedocs.io/en/latest/MasterFIFO.html).
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
  zh: 有关 `master-fifo` 和接受命令的更多信息，包括如何暂停和恢复实例，以及其他异构操作，请参阅 uWSGI 文档[https://uwsgi-docs.readthedocs.io/en/latest/MasterFIFO.html](https://uwsgi-docs.readthedocs.io/en/latest/MasterFIFO.html)。
- en: uWSGI is a very powerful application that has almost endless possibilities for
    configuration. Its documentation is overwhelming in the amount of detail it contains,
    but it's incredibly comprehensive and insightful. You can learn a lot, not only
    about uWSGI but also about how the whole web stack works. I highly recommend going
    through slowly, but surely, to learn a lot. You can access the documentation at
    [https://uwsgi-docs.readthedocs.io/](https://uwsgi-docs.readthedocs.io/).
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
  zh: uWSGI是一个非常强大的应用程序，具有几乎无限多的配置可能性。其文档包含大量细节，令人印象深刻，但内容全面且富有洞察力。你可以学到很多，不仅关于uWSGI，还关于整个Web栈是如何工作的。我强烈建议您慢慢地、坚定地学习，以获得很多知识。您可以在[https://uwsgi-docs.readthedocs.io/](https://uwsgi-docs.readthedocs.io/)访问文档。
- en: Python worker
  id: totrans-213
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Python工作进程
- en: The core of the system is the Python WSGI worker. This worker receives the HTTP
    requests from uWSGI after they're routed by the external web server, etc.
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
  zh: 系统的核心是Python WSGI工作进程。该工作进程在经过外部Web服务器等路由后，从uWSGI接收HTTP请求。
- en: This is where the magic happens, and it is specific to the application. This
    is the element that will see faster iteration than the rest of the links of the
    chain.
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
  zh: 这就是魔法发生的地方，并且它对应用程序来说是特定的。这是将比链中的其他链接更快迭代元素。
- en: Each framework will interact in a slightly different way with the requests,
    but in general, they will follow similar patterns. We will use Django as an example.
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
  zh: 每个框架与请求的交互方式略有不同，但总体上，它们将遵循类似的模式。我们将以Django为例。
- en: We won't discuss all aspects of Django or go into a deep dive of its features
    but will use a selection to look at some lessons that are useful for other frameworks.
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
  zh: 我们不会讨论Django的所有方面，也不会深入探讨其功能，但会选取一些对其他框架有用的课程。
- en: 'The Django project is really well documented. Seriously, it has always been
    distinguished by its world-class documentation, since the project started. You
    can read it here: [http://www.djangoproject.com](http://www.djangoproject.com).'
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
  zh: Django项目有非常好的文档。说真的，自从项目开始以来，它一直以其世界级的文档而闻名。您可以在这里阅读：[http://www.djangoproject.com](http://www.djangoproject.com)。
- en: Django MVT architecture
  id: totrans-219
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: Django MVT架构
- en: 'Django borrows heavily from the MVC structure but tweaks it a bit into what''s
    called **MVT** (**Model-View-Template**):'
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
  zh: Django大量借鉴了MVC结构，但稍作调整，形成了所谓的**MVT**（模型-视图-模板）：
- en: The Model remains the same, the representation of the data and interacting with
    the storage.
  id: totrans-221
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 模型保持不变，数据的表示和与存储的交互。
- en: The View receives the HTTP request and processes it, interacting with the different
    Models that may be required.
  id: totrans-222
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 视图接收HTTP请求并处理它，与可能需要的不同模型进行交互。
- en: The Template is a system to generate HTML files, from values passed on.
  id: totrans-223
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 模板是一个生成HTML文件的系统，从传递的值中生成。
- en: This changes Model-View-Controller a bit, though the result is similar.
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然这稍微改变了模型-视图-控制器，但结果相似。
- en: '![Shape, arrow'
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
  zh: '![形状、箭头'
- en: Description automatically generated](img/B17580_06_03.png)
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
  zh: 自动生成的描述](img/B17580_06_03.png)
- en: 'Figure 6.3: The Model-View-Controller'
  id: totrans-227
  prefs: []
  type: TYPE_NORMAL
  zh: 图6.3：模型-视图-控制器
- en: The Model works the same in both systems. The Django View acts as a combination
    of the View and the Controller, and the Template is a helping system for the View
    component of the Django View.
  id: totrans-228
  prefs: []
  type: TYPE_NORMAL
  zh: 在两个系统中，模型的工作方式相同。Django视图充当视图和控制器组合的角色，模板是Django视图视图组件的辅助系统。
- en: The templating system is not strictly required to be used, as not every Django
    interface requires an HTML page as a result.
  id: totrans-229
  prefs: []
  type: TYPE_NORMAL
  zh: 模板系统并非必须使用，因为并非每个Django接口都需要作为结果的HTML页面。
- en: While Django was designed to create HTML interfaces, there are ways of creating
    other types of interfaces. In particular, for RESTful interfaces, the Django REST
    framework ([https://www.django-rest-framework.org](https://www.django-rest-framework.org))
    allows you to expand the functionality and generate self-documented RESTful interfaces
    easily.
  id: totrans-230
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然Django被设计用来创建HTML界面，但有一些方法可以创建其他类型的界面。特别是，对于RESTful界面，Django REST框架([https://www.django-rest-framework.org](https://www.django-rest-framework.org))允许您轻松扩展功能并生成自文档化的RESTful界面。
- en: We will look at the Django REST framework later in the chapter.
  id: totrans-231
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将在本章后面讨论Django REST框架。
- en: Django is a powerful and comprehensive framework and has some assumptions on
    how things are supposed to run, such as using the Django ORM or using its templating
    system. While doing so is "swimming with the current," it's definitely possible
    to take other approaches and tailor any part of the system. This can involve elements
    like not using templates, using a different templating system, using a different
    ORM library like SQLAlchemy, and adding extra libraries to connect to different
    databases, including ones not supported natively by Django (like NoSQL databases).
    Do not let the constraints of the system limit you from achieving your goals.
  id: totrans-232
  prefs: []
  type: TYPE_NORMAL
  zh: Django 是一个强大且全面的框架，并对事物应该如何运行有一些假设，例如使用 Django ORM 或使用其模板系统。虽然这样做是“顺流而行”，但肯定可以采取其他方法并定制系统的任何部分。这可能包括不使用模板、使用不同的模板系统、使用不同的
    ORM 库如 SQLAlchemy，以及添加额外的库以连接到不同的数据库，包括 Django 本身不支持的原生数据库（如 NoSQL 数据库）。不要让系统的限制限制您实现目标。
- en: Django is opinionated in the way that it presents a lot of elements working
    together with certain assumptions. They are tightly related to each other. If
    that's an impediment, for example, because you need to use wildly different tools,
    a good alternative can be Pyramid ([https://trypyramid.com](https://trypyramid.com)),
    a Python web framework designed to build your own combination of tools to ensure
    flexibility.
  id: totrans-233
  prefs: []
  type: TYPE_NORMAL
  zh: Django 在展示元素的方式上持有一定的观点，这些元素以一定的假设协同工作。它们彼此紧密相关。如果这成为障碍，例如，因为您需要使用完全不同的工具，一个好的替代方案可以是
    Pyramid ([https://trypyramid.com](https://trypyramid.com))，这是一个旨在构建您自己的工具组合的 Python
    网络框架，以确保灵活性。
- en: Routing a request towards a View
  id: totrans-234
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 将请求路由到视图
- en: Django provides the tools to perform the proper routing from a particular URL
    to a specific View.
  id: totrans-235
  prefs: []
  type: TYPE_NORMAL
  zh: Django 提供了从特定 URL 到特定视图的正确路由的工具。
- en: This is done in the `urls.py` file. Let's see an example.
  id: totrans-236
  prefs: []
  type: TYPE_NORMAL
  zh: 这是在 `urls.py` 文件中完成的。让我们看看一个例子。
- en: '[PRE20]'
  id: totrans-237
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: The required Views (that are typically declared as functions) are imported from
    whatever module they are currently in into the file.
  id: totrans-238
  prefs: []
  type: TYPE_NORMAL
  zh: 所需的视图（通常声明为函数）从它们当前所在的模块导入到文件中。
- en: The `urlpatterns` list defines an ordered list of URL patterns that will be
    tested against an input URL.
  id: totrans-239
  prefs: []
  type: TYPE_NORMAL
  zh: '`urlpatterns` 列表定义了一个按顺序排列的 URL 模式列表，这些模式将针对输入 URL 进行测试。'
- en: The first `path` definition is very straightforward. If the URL is `example/`,
    it will call the View `first_view`.
  id: totrans-240
  prefs: []
  type: TYPE_NORMAL
  zh: 第一个 `path` 定义非常直接。如果 URL 是 `example/`，它将调用视图 `first_view`。
- en: 'The second `path` definition contains definitions to capture parameters. It
    will transform the defined parameters properly and pass them over to the view.
    For example, the URL `example/15/example-slug` will create these parameters:'
  id: totrans-241
  prefs: []
  type: TYPE_NORMAL
  zh: 第二个 `path` 定义包含捕获参数的定义。它将正确转换定义的参数并将它们传递给视图。例如，URL `example/15/example-slug`
    将创建以下参数：
- en: '`parameter=int(15)`'
  id: totrans-242
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`parameter=int(15)`'
- en: '`other_parameter=str("example-slug")`'
  id: totrans-243
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`other_parameter=str("example-slug")`'
- en: There are different types of parameters that can be configured. `int` is self-explanatory,
    but `slug` is a limited string that will include only alphanumeric, `_` (underscore),
    and `–` (dash) symbols, excluding characters like `.` or other symbols.
  id: totrans-244
  prefs: []
  type: TYPE_NORMAL
  zh: 可以配置不同类型的参数。`int` 是不言自明的，但 `slug` 是一个有限的字符串，它将只包含字母数字、`_`（下划线）和 `–`（破折号）符号，不包括像
    `.` 或其他符号的字符。
- en: There are more types available. There's also a `str` type that can be too broad.
    The character `/` is understood as special in URLs and it's always excluded. This
    allows for easy separation of parameters. The type `slug` should cover more typical
    use cases for parameters inside a URL.
  id: totrans-245
  prefs: []
  type: TYPE_NORMAL
  zh: 还有更多类型可用。还有一个 `str` 类型可能过于宽泛。字符 `/` 在 URL 中被视为特殊字符，并且始终被排除。这允许轻松分离参数。`slug`
    类型应该覆盖 URL 内参数的更多典型用例。
- en: Another option is to generate the paths directly as regex. If you are familiar
    with the regex format, this can be very powerful and allow a great deal of control.
    At the same time, regexes can grow really complex and difficult to read and use.
  id: totrans-246
  prefs: []
  type: TYPE_NORMAL
  zh: 另一个选项是直接作为正则表达式生成路径。如果您熟悉正则表达式格式，这将非常强大，并允许有大量的控制。同时，正则表达式可能会变得非常复杂，难以阅读和使用。
- en: '[PRE21]'
  id: totrans-247
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: This was the only option available previously in Django. As you can see for
    the example, equivalent to `example/<int:parameter>/`, the new path-defined URL
    patterns are easier to read and to deal with.
  id: totrans-248
  prefs: []
  type: TYPE_NORMAL
  zh: 这是在之前的 Django 中可用的唯一选项。正如您在示例中看到的，新的路径定义的 URL 模式更容易阅读和处理，相当于 `example/<int:parameter>/`。
- en: An intermediate option is to define types to be sure that they match specific
    values, for example, creating a type to match only months like `Apr` or `Jun`.
    If the type is defined in this way, an incorrect pattern like `Jen` will return
    a 404 automatically. Internally, this will require writing a regex to match the
    proper string anyway, but afterwards, it can transform the value. For example,
    to transform the month `Jun` to either the number 1, normalize it as `JUNE`, or
    any other value that makes sense later. The complexity of the regex will be abstracted
    by the type.
  id: totrans-249
  prefs: []
  type: TYPE_NORMAL
  zh: 一个中间方案是定义类型以确保它们匹配特定的值，例如，创建一个只匹配像`Apr`或`Jun`这样的月份的类型。如果以这种方式定义类型，像`Jen`这样的错误模式将自动返回404。内部来说，这仍然需要编写一个正则表达式来匹配正确的字符串，但之后它可以转换值。例如，将月份`Jun`转换为数字1，将其规范化为`JUNE`，或任何其他后续有意义的值。正则表达式的复杂性将由类型抽象化。
- en: Keep in mind that the patterns are checked in order. That means that, if a pattern
    may fulfil two paths, it will select the first one. This may have unintended effects
    when a previous path "hides" the next one, so the least restrictive patterns should
    be positioned later.
  id: totrans-250
  prefs: []
  type: TYPE_NORMAL
  zh: 请记住，模式是按顺序检查的。这意味着，如果一个模式可能满足两个路径，它将选择第一个。当先前的路径“隐藏”下一个路径时，这可能会产生意想不到的影响，因此最不限制的模式应该放在后面。
- en: 'For example:'
  id: totrans-251
  prefs: []
  type: TYPE_NORMAL
  zh: 例如：
- en: '[PRE22]'
  id: totrans-252
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: No URL will ever get passed to `second_view`, as any parameter that is an integer
    will be captured first.
  id: totrans-253
  prefs: []
  type: TYPE_NORMAL
  zh: 没有任何URL会被传递到`second_view`，因为任何整数参数都会首先被捕获。
- en: This kind of error is usually possible in most URL routers in web frameworks,
    as most of them are pattern-based. Keep an eye in case it affects your code.
  id: totrans-254
  prefs: []
  type: TYPE_NORMAL
  zh: 这种错误通常在大多数Web框架的URL路由器中是可能的，因为它们大多数都是基于模式的。请注意，它是否会影响你的代码。
- en: The interesting stuff happens inside of the View.
  id: totrans-255
  prefs: []
  type: TYPE_NORMAL
  zh: 有趣的事情发生在视图内部。
- en: The View
  id: totrans-256
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 视图
- en: The View is the central element of Django. It receives the request information,
    plus any parameters from the URL, and processes it. The View normally will use
    the different Models to compose the information, and finally returns a response.
  id: totrans-257
  prefs: []
  type: TYPE_NORMAL
  zh: 视图是Django的核心元素。它接收请求信息，以及来自URL的任何参数，并对其进行处理。视图通常将使用不同的模型来组合信息，并最终返回一个响应。
- en: The View is in charge of deciding if there's any change in behavior based on
    the request. Note that the routing towards the View only distinguishes between
    different paths, but other distinctions like HTTP method or parameters will need
    to be differentiated here.
  id: totrans-258
  prefs: []
  type: TYPE_NORMAL
  zh: 视图负责根据请求决定是否有任何行为上的变化。请注意，路由到视图的路径仅区分不同的路径，但其他区分，如HTTP方法或参数，需要在这里进行区分。
- en: 'This makes it a very common pattern to differentiate between POST and GET requests
    to the same URL. A common usage in web pages is to make a form page to display
    the empty form, and then POST to the same URL. For example, in a form with a single
    parameter, the structure will be similar to the following example:'
  id: totrans-259
  prefs: []
  type: TYPE_NORMAL
  zh: 这使得区分对同一URL的POST和GET请求成为一种非常常见的模式。在网页中的一种常见用法是创建一个表单页面来显示空表单，然后对同一URL进行POST。例如，在一个只有一个参数的表单中，结构将类似于以下示例：
- en: This is intended as pseudocode to not complicate it.
  id: totrans-260
  prefs: []
  type: TYPE_NORMAL
  zh: 这是为了不使伪代码变得复杂。
- en: '[PRE23]'
  id: totrans-261
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: While it's true that Django includes a form system that simplifies the validation
    and reporting of forms, this structure can grow legs and become tiresome. In particular,
    the multiple nested `if` blocks are confusing.
  id: totrans-262
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然Django确实包含一个简化表单验证和报告的表单系统，但这种结构可能会变得复杂且令人疲惫。特别是，多个嵌套的`if`块让人困惑。
- en: We won't go into details with the form system in Django. It is quite complete
    and allows you to render rich HTML forms that will validate and show possible
    errors to the user. Read the Django documentation to know more.
  id: totrans-263
  prefs: []
  type: TYPE_NORMAL
  zh: 我们不会深入探讨Django中的表单系统。它相当完整，允许你渲染丰富的HTML表单，这些表单将验证并显示可能的错误给用户。阅读Django文档以了解更多信息。
- en: Instead of that, dividing the View with two different subfunctions may be clearer.
  id: totrans-264
  prefs: []
  type: TYPE_NORMAL
  zh: 相反，通过两个不同的子函数来划分视图可能更清晰。
- en: '[PRE24]'
  id: totrans-265
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: The challenge here is to preserve the fact that, when the parameters are incorrect,
    the form needs to be rendered again. By the principle of **DRY** (**Don't Repeat
    Yourself**), we should try to locate that code in a single place. Here, in the
    `display_form` function. We allow some customization of the message to add some
    extra content, in case the data is incorrect.
  id: totrans-266
  prefs: []
  type: TYPE_NORMAL
  zh: 这里的挑战是保留这样一个事实，即当参数不正确时，表单需要重新渲染。根据**DRY**（**不要重复自己**）的原则，我们应该尝试将这段代码定位在单一位置。在这里，在`display_form`函数中。我们允许对消息进行一些定制，以添加一些额外内容，以防数据不正确。
- en: In a more complete example, the form will be tweaked to show the specific errors.
    Django forms are able to do this automatically. The process will be to create
    a form with the parameters from the request, validate it, and print it. It automatically
    will produce the proper error messages, based on the type of each of the fields,
    including custom types. Again, refer to Django's documentation for more information.
  id: totrans-267
  prefs: []
  type: TYPE_NORMAL
  zh: 在一个更完整的示例中，表单将被调整以显示特定的错误。Django 表单能够自动完成这项工作。这个过程是创建一个带有请求参数的表单，验证它，并打印它。它将自动生成适当的错误消息，基于每个字段的类型，包括自定义类型。再次，请参阅
    Django 的文档以获取更多信息。
- en: Note that the `display_form` function gets called both from `example_view` and
    also inside `process_data`.
  id: totrans-268
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，`display_form` 函数既从 `example_view` 调用，也来自 `process_data` 内部。
- en: HttpRequest
  id: totrans-269
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: HttpRequest
- en: The key element for passing information is the `request` parameter. This object's
    type is `HttpRequest`, and contains all the information that the user is sending
    in the request.
  id: totrans-270
  prefs: []
  type: TYPE_NORMAL
  zh: 传递信息的关键元素是 `request` 参数。此对象类型为 `HttpRequest`，包含用户在请求中发送的所有信息。
- en: 'Its most important attributes are:'
  id: totrans-271
  prefs: []
  type: TYPE_NORMAL
  zh: 它最重要的属性包括：
- en: '`method`, which contains the used HTTP method.'
  id: totrans-272
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`method`，它包含使用的 HTTP 方法。'
- en: 'If the method is `GET`, it will contain a `GET` attribute with a `QueryDict`
    (a dictionary subclass) containing all the query parameters in the request. For
    example, a request such as:'
  id: totrans-273
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果方法是 `GET`，它将包含一个 `GET` 属性，其中包含请求中所有查询参数的 `QueryDict`（字典子类）。例如，一个请求如下：
- en: '[PRE25]'
  id: totrans-274
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'Will produce a `request.GET` value like this:'
  id: totrans-275
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 将生成一个类似 `request.GET` 的值：
- en: '[PRE26]'
  id: totrans-276
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE26]'
- en: 'Note that the parameters are stored internally as a list of values, because
    query parameters accept multiple parameters with the same key, though that''s
    not usually the case. They''ll return a unique value when queried anyway:'
  id: totrans-277
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 注意，参数在内部作为值的列表存储，因为查询参数接受具有相同键的多个参数，尽管通常不是这种情况。查询时它们仍将返回一个唯一值：
- en: '[PRE27]'
  id: totrans-278
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE27]'
- en: 'They''ll be all reported in order, with the latest value being returned. If
    you need to access all values, use the method `getlist`:'
  id: totrans-279
  prefs: []
  type: TYPE_NORMAL
  zh: 它们将按顺序报告，返回最新的值。如果您需要访问所有值，请使用 `getlist` 方法：
- en: '[PRE28]'
  id: totrans-280
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: All the parameters are defined as strings, needing to be converted to other
    types if necessary.
  id: totrans-281
  prefs: []
  type: TYPE_NORMAL
  zh: 所有参数都定义为字符串，如果需要，需要转换为其他类型。
- en: If the method is `POST`, an analogous `POST` attribute will be created. In this
    case, it will be filled first by the body of the request, to allow encoding form
    posts. If the body is empty, it will fill the values with query parameters like
    the `GET` case.
  id: totrans-282
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果方法是 `POST`，将创建一个类似的 `POST` 属性。在这种情况下，它将首先由请求体填充，以便允许编码表单提交。如果请求体为空，它将使用查询参数填充值，就像
    `GET` 的情况一样。
- en: POST multiple values will commonly be used in multiple selection forms.
  id: totrans-283
  prefs: []
  type: TYPE_NORMAL
  zh: 在多选表单中，通常会用 `POST` 多个值。
- en: '`content_type` with the MIME type of the request.'
  id: totrans-284
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`content_type`，包含请求的 MIME 类型。'
- en: '`FILES`, including data for any uploaded files in the request, for certain
    `POST` requests.'
  id: totrans-285
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`FILES`，包括请求中任何上传文件的请求，对于某些 `POST` 请求。'
- en: '`headers`, a dictionary containing all the HTTP headers of the request and
    headers. Another dictionary, `META`, contains extra information from headers that
    may be introduced and are not necessarily HTTP-based, like `SERVER_NAME`. In general,
    it is better to obtain information from the `headers` attribute.'
  id: totrans-286
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`headers`，一个包含请求和头信息的字典。另一个字典 `META` 包含可能引入的额外信息，这些信息不一定是基于 HTTP 的，如 `SERVER_NAME`。通常，从
    `headers` 属性获取信息更好。'
- en: 'There are also some useful methods to retrieve information from the request,
    for example:'
  id: totrans-287
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，还有一些有用的方法可以检索请求中的信息，例如：
- en: '`.get_host()` to obtain the name of the host. It will interpret the different
    headers to determine the proper host, so it''s more reliable than directly reading
    the `HTTP_HOST` header.'
  id: totrans-288
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用 `.get_host()` 获取主机名。它将解释不同的头信息以确定正确的宿主，因此比直接读取 `HTTP_HOST` 头更可靠。
- en: '`.build_absolute_uri(location)` to generate a full URI, including the host,
    port, etc. This method is useful to create full references to return them.'
  id: totrans-289
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用 `.build_absolute_uri(location)` 生成完整的 URI，包括主机、端口等。此方法对于创建完整的引用以返回它们非常有用。
- en: These attributes and methods, combined with the parameters described in the
    request, allow you to retrieve all the relevant information necessary for processing
    the request and call the required Models.
  id: totrans-290
  prefs: []
  type: TYPE_NORMAL
  zh: 这些属性和方法，结合请求中描述的参数，允许您检索处理请求和调用所需模型的所有相关信息。
- en: HttpResponse
  id: totrans-291
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: HttpResponse
- en: The `HttpResponse` class handles the information being returned by the View
    to the web server. The return from a View function needs to be an `HttpResponse`
    object.
  id: totrans-292
  prefs: []
  type: TYPE_NORMAL
  zh: '`HttpResponse`类处理视图返回给Web服务器的信息。视图函数的返回值需要是一个`HttpResponse`对象。'
- en: '[PRE29]'
  id: totrans-293
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: The response has a default `status_code` of 200 if it's not specified.
  id: totrans-294
  prefs: []
  type: TYPE_NORMAL
  zh: 如果未指定，响应的默认`status_code`为200。
- en: If the response needs to be written in several steps, it can be added through
    the `.write()` method.
  id: totrans-295
  prefs: []
  type: TYPE_NORMAL
  zh: 如果响应需要分几个步骤写入，可以通过`.write()`方法添加。
- en: '[PRE30]'
  id: totrans-296
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: The body can also be composed as an iterable.
  id: totrans-297
  prefs: []
  type: TYPE_NORMAL
  zh: 主体也可以由可迭代对象组成。
- en: '[PRE31]'
  id: totrans-298
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: All responses from `HttpResponse` will be composed completely before being returned.
    It is possible to return responses in a streaming way, meaning that the status
    code will be returned first and chunks of the body will be sent over time. To
    do that, there's another class called `StreamingHttpResponse` that will work in
    that way, and can be useful for sending big responses over time.
  id: totrans-299
  prefs: []
  type: TYPE_NORMAL
  zh: 所有来自`HttpResponse`的响应在返回之前都将完全组合。可以以流式方式返回响应，这意味着首先返回状态码，然后随着时间的推移发送主体块。为此，还有一个名为`StreamingHttpResponse`的类，它将以这种方式工作，并且对于在一段时间内发送大响应可能很有用。
- en: 'Instead of using integers to define the status code, it''s better to use the
    defined constants available in Python, for example:'
  id: totrans-300
  prefs: []
  type: TYPE_NORMAL
  zh: 使用整数定义状态码不如使用Python中定义的常量好，例如：
- en: '[PRE32]'
  id: totrans-301
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: This makes the usage of each status code more explicit and helps increase the
    readability of the code, making them explicitly `HTTPStatus` objects.
  id: totrans-302
  prefs: []
  type: TYPE_NORMAL
  zh: 这样可以使每个状态码的使用更加明确，并有助于提高代码的可读性，使它们明确地成为`HTTPStatus`对象。
- en: 'You can see all the status codes defined in Python here: [https://docs.python.org/3/library/http.html](https://docs.python.org/3/library/http.html).
    Note the name is their standard HTTP status code name, as defined in several RFC
    documents, for example, `201 CREATED`, `404 NOT FOUND`, `502 BAD GATEWAY`, etc.'
  id: totrans-303
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以在Python中看到所有定义的状态码：[https://docs.python.org/3/library/http.html](https://docs.python.org/3/library/http.html)。注意名称是它们的标准HTTP状态码名称，如定义在多个RFC文档中，例如，`201
    CREATED`，`404 NOT FOUND`，`502 BAD GATEWAY`等。
- en: The `content` parameter defines the body of the request. It can be described
    as a Python string, but it also accepts binary data, if the response is not plain
    text. If that's the case, a `content_type` parameter should be added to adequately
    label the data with the proper MIME type.
  id: totrans-304
  prefs: []
  type: TYPE_NORMAL
  zh: '`content`参数定义了请求的主体。它可以描述为一个Python字符串，但如果响应不是纯文本，它也接受二进制数据。如果是这种情况，应该添加一个`content_type`参数，以便适当地用正确的MIME类型标记数据。'
- en: '[PRE33]'
  id: totrans-305
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: It is very important that the returned `Content-Type` matches the format of
    the body. This will make any other tool, like a browser, properly interpret the
    content adequately.
  id: totrans-306
  prefs: []
  type: TYPE_NORMAL
  zh: 返回的`Content-Type`与主体的格式相匹配非常重要。这将使任何其他工具，如浏览器，正确地适当地解释内容。
- en: Headers can also be added to the response using the `headers` parameter.
  id: totrans-307
  prefs: []
  type: TYPE_NORMAL
  zh: 可以使用`headers`参数向响应添加头。
- en: '[PRE34]'
  id: totrans-308
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: '`Content-Disposition` can be used to label the response as an attachment that
    should be downloaded to the hard drive.'
  id: totrans-309
  prefs: []
  type: TYPE_NORMAL
  zh: 可以使用`Content-Disposition`将响应标记为附件，以便下载到硬盘。
- en: Also, we can set up the `Content-Type` header either manually through the `headers`
    parameter or through the `content_type` parameter directly.
  id: totrans-310
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，我们还可以通过`headers`参数或直接通过`content_type`参数手动设置`Content-Type`头。
- en: 'Headers are also stored in the response when it is accessed as a dictionary:'
  id: totrans-311
  prefs: []
  type: TYPE_NORMAL
  zh: 当响应作为字典访问时，头也会存储在响应中。
- en: '[PRE35]'
  id: totrans-312
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: 'There are specialized subclasses for common cases. Instead of using a generic
    `HttpResponse`, for JSON encoded requests, it''s better to use `JsonResponse`,
    which will correctly fill the Content-Type and encode it:'
  id: totrans-313
  prefs: []
  type: TYPE_NORMAL
  zh: 对于常见情况，有专门的子类。对于JSON编码的请求，与其使用通用的`HttpResponse`，不如使用`JsonResponse`，这将正确填充`Content-Type`并对其进行编码：
- en: '[PRE36]'
  id: totrans-314
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: In the same style, the `FileResponse` allows you to download a file directly,
    providing a file-like object and directly filling the headers and content type,
    including if it needs to be an attachment
  id: totrans-315
  prefs: []
  type: TYPE_NORMAL
  zh: 以同样的方式，`FileResponse`允许你直接下载文件，提供一个类似文件的对象，并直接填充头和内容类型，包括如果它需要作为附件。
- en: '[PRE37]'
  id: totrans-316
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: The response can also be created by rendering a template. This is the usual
    way of doing so for HTML interfaces, which was what Django was originally designed
    for. The `render` function will automatically return an `HttpResponse` object.
  id: totrans-317
  prefs: []
  type: TYPE_NORMAL
  zh: 响应也可以通过渲染模板来创建。这是HTML界面的常用方法，这正是Django最初被设计的目的。`render`函数将自动返回一个`HttpResponse`对象。
- en: '[PRE38]'
  id: totrans-318
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: Middleware
  id: totrans-319
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 中间件
- en: A key concept in WSGI requests is that they can be chained. This means that
    a request can go through different stages, wrapping a new request around the orinal
    at each stage, which allows you to add functionality.
  id: totrans-320
  prefs: []
  type: TYPE_NORMAL
  zh: WSGI请求中的一个关键概念是它们可以被链式处理。这意味着请求可以经过不同的阶段，在每个阶段围绕原始请求包装一个新的请求，这允许你添加功能。
- en: This leads to the concept of middleware. Middleware improves the handling between
    systems by simplifying handling several aspects of the request, adding functionality,
    or simplifying their usage.
  id: totrans-321
  prefs: []
  type: TYPE_NORMAL
  zh: 这导致了中间件的概念。中间件通过简化请求的多个方面、添加功能或简化其使用来改进系统之间的处理。
- en: Middleware is a word that can refer to different concepts depending on the context
    of its usage. When used in an HTTP server environment, it typically refers to
    plugins that enhance or simplify the handling of requests.
  id: totrans-322
  prefs: []
  type: TYPE_NORMAL
  zh: 中间件这个词可以根据其使用的上下文指代不同的概念。在HTTP服务器环境中使用时，通常指的是增强或简化请求处理的插件。
- en: A typical example of middleware is logging each received request in a standard
    manner. The middleware will receive the request, produce a log, and hand the request
    to the next level.
  id: totrans-323
  prefs: []
  type: TYPE_NORMAL
  zh: 中间件的典型例子是以标准方式记录每个接收到的请求。中间件将接收请求，生成日志，并将请求交给下一级。
- en: Another example is managing whether the user is logged or not. There's a standard
    Django middleware that will detect any session stored in cookies and will search
    in the database for the associated user. It will then fill the `request.user`
    object with the proper user.
  id: totrans-324
  prefs: []
  type: TYPE_NORMAL
  zh: 另一个例子是管理用户是否已登录。有一个标准的Django中间件可以检测存储在cookie中的任何会话，并在数据库中搜索关联的用户。然后，它将填充`request.user`对象以包含正确的用户。
- en: Another example, enabled by default in Django, checks the CSRF token on `POST`
    requests. If the CSRF token is not present or it's incorrect, the request will
    be immediately intercepted and it will return `403 FORBIDDEN`, before accessing
    the View code.
  id: totrans-325
  prefs: []
  type: TYPE_NORMAL
  zh: 另一个例子是Django默认启用的，它检查`POST`请求上的CSRF令牌。如果CSRF令牌不存在或是不正确的，请求将被立即拦截，并返回`403 FORBIDDEN`，在访问视图代码之前。
- en: We introduced the idea of CSRF and tokens in *Chapter 2*.
  id: totrans-326
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在*第二章*中介绍了CSRF和令牌的概念。
- en: 'Middleware can access the request both when it''s received and the response
    when it''s ready, so they can work on either side or both sides in coordination:'
  id: totrans-327
  prefs: []
  type: TYPE_NORMAL
  zh: 中间件可以在请求接收时以及响应准备时访问请求，因此它们可以在协调中在任一侧或两侧工作：
- en: Logging middleware that generates a log with the path and method of the received
    request can generate it before the request is sent to the View.
  id: totrans-328
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 生成包含接收到的请求路径和方法的日志的日志中间件可以在请求发送到视图之前生成。
- en: Logging middleware that also logs the status code needs to have the information
    of the status code, so it will need to do it once the View is finished and the
    response is ready.
  id: totrans-329
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 同时记录状态码的日志中间件需要具有状态码的信息，因此它需要在视图完成并且响应准备就绪后执行。
- en: Logging middleware that logs the time it took to generate the request will need
    to first register the time when the request was received, and what time it is
    when the response is ready, to log the difference. This requires code both before
    and after the View.
  id: totrans-330
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 记录生成请求所需时间的日志中间件需要首先注册请求接收的时间以及响应准备的时间，以便记录差异。这需要在视图前后编写代码。
- en: 'Middleware is defined in this way:'
  id: totrans-331
  prefs: []
  type: TYPE_NORMAL
  zh: 中间件是这样定义的：
- en: '[PRE39]'
  id: totrans-332
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: 'The structure to return a function allows the initialization of chained elements.
    The input `get_reponse` can be another middleware function or could be the final
    view. This allows this kind of structure:'
  id: totrans-333
  prefs: []
  type: TYPE_NORMAL
  zh: 返回函数的结构允许初始化链式元素。输入`get_reponse`可以是另一个中间件函数，或者可以是最终的视图。这允许这种结构：
- en: '[PRE40]'
  id: totrans-334
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: The order of the middleware is also important. For example, logging should happen
    before any middleware that can stop the request, as if done in reverse order,
    any rejected request (for example, not adding a proper CSRF) won't be logged.
  id: totrans-335
  prefs: []
  type: TYPE_NORMAL
  zh: 中间件的顺序也很重要。例如，日志应该在任何可能停止请求的中间件之前发生，如果顺序相反，任何被拒绝的请求（例如，没有添加适当的CSRF）将不会被记录。
- en: Generally, middleware functions have some recommendations on where they should
    be located. Some are more sensitive to their position than others. Check the documentation
    for each one.
  id: totrans-336
  prefs: []
  type: TYPE_NORMAL
  zh: 通常，中间件函数有一些关于它们应该位于何处的地方建议。有些比其他更敏感于它们的位置。请检查每个的文档。
- en: Middleware can be easily added, either custom-made or by using third-party options.
    There are a lot of packages that create their own middleware functions for useful
    features in Django. When considering adding a new feature, spend some time searching
    to see if there's something already available.
  id: totrans-337
  prefs: []
  type: TYPE_NORMAL
  zh: 中间件可以轻松添加，无论是自定义的还是使用第三方选项。有许多包为Django创建了具有有用功能的自定义中间件函数。在考虑添加新功能时，花点时间搜索看看是否已有现成的功能。
- en: Django REST framework
  id: totrans-338
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: Django REST框架
- en: While Django was designed originally to support HTML interfaces, its functionality
    has been expanded, both as new features inside the Django project itself, as well
    as other external projects that enhance Django.
  id: totrans-339
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然Django最初是为了支持HTML界面而设计的，但其功能已经得到了扩展，包括Django项目本身的新功能，以及其他增强Django的外部项目。
- en: One of particular interest is Django REST framework. We will use it as an example
    of the available possibilities.
  id: totrans-340
  prefs: []
  type: TYPE_NORMAL
  zh: 其中一个特别有趣的是Django REST框架。我们将用它作为可用可能性的示例。
- en: Django REST framework is not only a popular and powerful module. It also uses
    a lot of conventions that are common across REST frameworks in multiple programming
    languages.
  id: totrans-341
  prefs: []
  type: TYPE_NORMAL
  zh: Django REST框架不仅是一个流行且强大的模块。它还使用了许多在多种编程语言的REST框架中常见的约定。
- en: For our example, we will implement some of the endpoints that we defined in
    *Chapter 2*. We will use the following endpoints, to follow the whole lifecycle
    of a micropost.
  id: totrans-342
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的示例中，我们将实现我们在*第二章*中定义的一些端点。我们将使用以下端点，以跟踪微帖的整个生命周期。
- en: '| Endpoint | Method | Action |'
  id: totrans-343
  prefs: []
  type: TYPE_TB
  zh: '| 端点 | 方法 | 操作 |'
- en: '| `/api/users/<username>/collection` | `GET` | Retrieve all the microposts
    from a user |'
  id: totrans-344
  prefs: []
  type: TYPE_TB
  zh: '| `/api/users/<username>/collection` | `GET` | 从用户检索所有微帖 |'
- en: '| `/api/users/<username>/collection` | `POST` | Create a new micropost for
    the user |'
  id: totrans-345
  prefs: []
  type: TYPE_TB
  zh: '| `/api/users/<username>/collection` | `POST` | 为用户创建一个新的微帖 |'
- en: '| `/api/users/<username>/collection/<micropost_id>` | `GET` | Retrieve a single
    micropost |'
  id: totrans-346
  prefs: []
  type: TYPE_TB
  zh: '| `/api/users/<username>/collection/<micropost_id>` | `GET` | 检索单个微帖 |'
- en: '| `/api/users/<username>/collection/<micropost_id>` | `PUT, PATCH` | Update
    a micropost |'
  id: totrans-347
  prefs: []
  type: TYPE_TB
  zh: '| `/api/users/<username>/collection/<micropost_id>` | `PUT, PATCH` | 更新一个微帖
    |'
- en: '| `/api/users/<username>/collection/<micropost_id>` | `DELETE` | Delete a micropost
    |'
  id: totrans-348
  prefs: []
  type: TYPE_TB
  zh: '| `/api/users/<username>/collection/<micropost_id>` | `DELETE` | 删除一个微帖 |'
- en: The basic principle behind Django REST framework is to create different classes
    that encapsulate the exposed resources as URLs.
  id: totrans-349
  prefs: []
  type: TYPE_NORMAL
  zh: Django REST框架背后的基本原理是创建不同的类，这些类封装了作为URL公开的资源。
- en: The extra concept is that objects will be transformed from an internal Model
    into an external JSON object and vice versa through a *serializer*. The serializer
    will handle the creation and validate that the external data is correct.
  id: totrans-350
  prefs: []
  type: TYPE_NORMAL
  zh: 另一个概念是，对象将通过序列化器从内部模型转换为外部JSON对象，反之亦然。序列化器将处理创建并验证外部数据是否正确。
- en: A serializer can't only transform a Model object, but any kind of internal Python
    class. You can use them to create "virtual objects" that can pull information
    from multiple Models.
  id: totrans-351
  prefs: []
  type: TYPE_NORMAL
  zh: 序列化器不仅可以转换模型对象，还可以转换任何内部Python类。你可以使用它们创建“虚拟对象”，这些对象可以从多个模型中提取信息。
- en: A peculiarity of Django REST framework is that the serializer is the same for
    input and output. In other frameworks, there are different modules for the way
    in and out.
  id: totrans-352
  prefs: []
  type: TYPE_NORMAL
  zh: Django REST框架的一个特点是序列化器对于输入和输出是相同的。在其他框架中，有不同的模块用于输入和输出方式。
- en: Models
  id: totrans-353
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 模型
- en: We first need to introduce the models to store the information. We will use
    a `Usr` Model for the users and a `Micropost` Model.
  id: totrans-354
  prefs: []
  type: TYPE_NORMAL
  zh: 我们首先需要介绍用于存储信息的模型。我们将使用`Usr`模型来存储用户，以及`Micropost`模型。
- en: '[PRE41]'
  id: totrans-355
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: The `Usr` model is very straightforward, only storing the username. The `Micropost`
    Model stores a string of text and the user that created the micropost. Optionally,
    it can store a referenced user.
  id: totrans-356
  prefs: []
  type: TYPE_NORMAL
  zh: '`Usr`模型非常简单，只存储用户名。`Micropost`模型存储一段文本和创建该微帖的用户。可选地，它可以存储一个引用用户。'
- en: Note that the relations have their own named back reference, `reference` and
    `owner`. They are created by default by Django so you can search where a `Usr`
    is referenced, for example.
  id: totrans-357
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，关系有自己的命名反向引用，`reference`和`owner`。这些默认由Django创建，因此你可以搜索`Usr`被引用的地方，例如。
- en: Note also that the `text` allows for 300 characters, instead of the 255 that
    we said in the API. This is to allow a bit of extra space in the database. We
    will still protect against more characters later.
  id: totrans-358
  prefs: []
  type: TYPE_NORMAL
  zh: 还要注意，`text`允许300个字符，而不是我们之前在API中说的255个字符。这是为了在数据库中留出更多空间。我们稍后会保护更多字符。
- en: URL routing
  id: totrans-359
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: URL路由
- en: 'With this information, we create two different views, one for each URL that
    we need to create. They''ll be called `MicropostsListView` and `MicropostView`.
    Let''s take a look first at how the URLs are defined in the `urls.py` file:'
  id: totrans-360
  prefs: []
  type: TYPE_NORMAL
  zh: 基于这些信息，我们创建了两个不同的视图，一个对应于我们需要创建的每个 URL。它们将被命名为 `MicropostsListView` 和 `MicropostView`。让我们首先看看
    `urls.py` 文件中如何定义这些 URL：
- en: '[PRE42]'
  id: totrans-361
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: 'Note that there are two URLs, that correspond to this definition:'
  id: totrans-362
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，有两个 URL，对应于这个定义：
- en: '[PRE43]'
  id: totrans-363
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: And each is mapped to the corresponding view.
  id: totrans-364
  prefs: []
  type: TYPE_NORMAL
  zh: 每个都映射到相应的视图。
- en: Views
  id: totrans-365
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 视图
- en: 'Each view inherits from the proper API endpoint, the collection one from `ListCreateAPIView`,
    which defines the actions for `LIST` (`GET`) and `CREATE` (`POST`):'
  id: totrans-366
  prefs: []
  type: TYPE_NORMAL
  zh: 每个视图都继承自适当的 API 端点，集合视图从 `ListCreateAPIView` 继承，它定义了 `LIST`（`GET`）和 `CREATE`（`POST`）的操作：
- en: '[PRE44]'
  id: totrans-367
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: 'We will check the serializer later. The class requires defining the queryset
    that it will use to retrieve the information when the `LIST` part of the class
    is called. Because our URL includes the username, we need to identify it:'
  id: totrans-368
  prefs: []
  type: TYPE_NORMAL
  zh: 我们稍后会检查序列化器。该类需要定义当类中的 `LIST` 部分被调用时它将使用的查询集。由于我们的 URL 包含用户名，我们需要识别它：
- en: '[PRE45]'
  id: totrans-369
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: '`self.kwargs[''username'']` will retrieve the username defined in the URL.'
  id: totrans-370
  prefs: []
  type: TYPE_NORMAL
  zh: '`self.kwargs[''username'']` 将检索在 URL 中定义的用户名。'
- en: For the `CREATE` part, we need to overwrite the `perform_create` method. This
    method receives a serializer parameter that already contains the validated parameters.
  id: totrans-371
  prefs: []
  type: TYPE_NORMAL
  zh: 对于 `CREATE` 部分，我们需要重写 `perform_create` 方法。该方法接收一个序列化器参数，该参数已经包含验证过的参数。
- en: We need to obtain the username and user from the same `self.kwargs` to be sure
    to add it to the creation of the `Micropost` object.
  id: totrans-372
  prefs: []
  type: TYPE_NORMAL
  zh: 我们需要从相同的 `self.kwargs` 中获取用户名和用户，以确保将其添加到 `Micropost` 对象的创建中。
- en: '[PRE46]'
  id: totrans-373
  prefs: []
  type: TYPE_PRE
  zh: '[PRE46]'
- en: The new object is created combining both the user and the rest of the data,
    added as part of the `save` method for the serializer.
  id: totrans-374
  prefs: []
  type: TYPE_NORMAL
  zh: 新的对象是通过结合用户和其他数据创建的，这些数据作为序列化器的 `save` 方法的一部分添加。
- en: 'The individual View follows a similar pattern, but there''s no need to overwrite
    the creation:'
  id: totrans-375
  prefs: []
  type: TYPE_NORMAL
  zh: 单个视图遵循类似的模式，但不需要重写创建：
- en: '[PRE47]'
  id: totrans-376
  prefs: []
  type: TYPE_PRE
  zh: '[PRE47]'
- en: 'In this case, we allow more operations: `RETRIEVE` (`GET`), `UPDATE` (`PUT`
    and `PATCH`), and `DESTROY` (`DELETE`).'
  id: totrans-377
  prefs: []
  type: TYPE_NORMAL
  zh: 在这种情况下，我们允许更多的操作：`RETRIEVE`（`GET`）、`UPDATE`（`PUT` 和 `PATCH`）以及 `DESTROY`（`DELETE`）。
- en: Serializer
  id: totrans-378
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 序列化器
- en: 'The serializer transforms from the Python object of the Model to the JSON result
    and the other way around. The serializer is defined like this:'
  id: totrans-379
  prefs: []
  type: TYPE_NORMAL
  zh: 序列化器将模型对象的 Python 对象转换为 JSON 结果，反之亦然。序列化器定义如下：
- en: '[PRE48]'
  id: totrans-380
  prefs: []
  type: TYPE_PRE
  zh: '[PRE48]'
- en: '`ModelSerializer` will automatically detect the fields in the model defined
    in the `Meta` subclass. We specified the fields to be included in the `fields`
    section. Note that, apart from the ones that are directly translated, `id` and
    `timestamp`, we include others that will change (`user`, `text`, `referenced`)
    and an extra one (`href`). The directly translated ones are straightforward; we
    don''t need to do anything there.'
  id: totrans-381
  prefs: []
  type: TYPE_NORMAL
  zh: '`ModelSerializer` 将自动检测在 `Meta` 子类中定义的模型中的字段。我们在 `fields` 部分指定了要包含的字段。注意，除了直接翻译的字段
    `id` 和 `timestamp` 之外，我们还包含了其他会变化的字段（`user`、`text`、`referenced`）以及一个额外的字段（`href`）。直接翻译的字段很简单；我们那里不需要做任何事情。'
- en: The `text` field is described again as a `CharField`, but this time, we limit
    the maximum number of characters.
  id: totrans-382
  prefs: []
  type: TYPE_NORMAL
  zh: '`text` 字段再次被描述为 `CharField`，但这次我们限制了字符的最大数量。'
- en: The `user` field is also redescribed as a `CharField`, but using the source
    parameter we define it as the username of the referenced user. The field is defined
    as `read_only`.
  id: totrans-383
  prefs: []
  type: TYPE_NORMAL
  zh: '`user` 字段也被重新描述为 `CharField`，但使用源参数我们将其定义为引用用户的用户名。该字段被定义为 `read_only`。'
- en: '`referenced` is similar to it, but we need to define it as `SlugRelatedField`,
    so it understands that''s a reference. A slug is a string that references the
    value. We define that the `slug_field` is the username of the reference, and add
    the queryset to allow searching for it.'
  id: totrans-384
  prefs: []
  type: TYPE_NORMAL
  zh: '`referenced` 与之类似，但我们需要将其定义为 `SlugRelatedField`，以便它理解这是一个引用。一个 slug 是一个引用值的字符串。我们定义
    `slug_field` 是引用的用户名，并添加查询集以允许搜索它。'
- en: 'The `href` field requires an extra defined class to create a proper URL reference.
    Let''s take a detailed look:'
  id: totrans-385
  prefs: []
  type: TYPE_NORMAL
  zh: '`href` 字段需要一个额外定义的类来创建正确的 URL 引用。让我们详细看看：'
- en: '[PRE49]'
  id: totrans-386
  prefs: []
  type: TYPE_PRE
  zh: '[PRE49]'
- en: '`view_name` describes the URL that will be used. The `reverse` call transforms
    the parameters into the proper full URL. This is wrapped in the `get_url` method.
    This method receives mainly the `obj` parameter with the full object. This full
    object is defined in the `source=''*''` call to the `MicropostHyperlink` class
    in the serializer.'
  id: totrans-387
  prefs: []
  type: TYPE_NORMAL
  zh: '`view_name`描述了将要使用的URL。`reverse`调用将参数转换成正确的完整URL。这被封装在`get_url`方法中。此方法主要接收带有完整对象的`obj`参数。这个完整对象是在序列化器中对`MicropostHyperlink`类进行`source=''*''`调用时定义的。'
- en: The combination of all these factors makes the interface work correctly. Django
    REST framework can also create an interface to help you visualize the whole interface
    and use it.
  id: totrans-388
  prefs: []
  type: TYPE_NORMAL
  zh: 所有这些因素的组合使得界面能够正确工作。Django REST框架也可以创建一个界面来帮助你可视化整个界面并使用它。
- en: 'For example, a list will look like this:'
  id: totrans-389
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，列表将看起来像这样：
- en: '![Graphical user interface, application, Teams'
  id: totrans-390
  prefs: []
  type: TYPE_NORMAL
  zh: '![图形用户界面，应用程序，团队'
- en: Description automatically generated](img/B17580_06_04.png)
  id: totrans-391
  prefs: []
  type: TYPE_NORMAL
  zh: 自动生成的描述](img/B17580_06_04.png)
- en: 'Figure 6.4: Microposts List'
  id: totrans-392
  prefs: []
  type: TYPE_NORMAL
  zh: 图6.4：微帖子列表
- en: And a micropost page will look like this, which allows you to test different
    actions like `PUT`, `PATCH`, `DELETE`, and `GET`.
  id: totrans-393
  prefs: []
  type: TYPE_NORMAL
  zh: 微帖子页面将看起来像这样，它允许你测试不同的操作，如`PUT`、`PATCH`、`DELETE`和`GET`。
- en: '![Graphical user interface, application, Teams'
  id: totrans-394
  prefs: []
  type: TYPE_NORMAL
  zh: '![图形用户界面，应用程序，团队'
- en: Description automatically generated](img/B17580_06_05.png)
  id: totrans-395
  prefs: []
  type: TYPE_NORMAL
  zh: 自动生成的描述](img/B17580_06_05.png)
- en: 'Figure 6.5: Microposts page'
  id: totrans-396
  prefs: []
  type: TYPE_NORMAL
  zh: 图6.5：微帖子页面
- en: Django REST framework is very powerful and can be used in different ways to
    be sure that it behaves exactly as you expect. It has its own quirks, and it tends
    to be a little temperamental with the parameters until everything is configured
    just right. At the same time, it allows you to customize the interface in every
    aspect. Be sure to read the documentation carefully.
  id: totrans-397
  prefs: []
  type: TYPE_NORMAL
  zh: Django REST框架非常强大，可以以不同的方式使用，以确保它表现得完全符合你的预期。它有自己的特性，并且它对参数的敏感性直到一切配置正确才会减弱。同时，它允许你在每个方面自定义界面。务必仔细阅读文档。
- en: 'You can find the whole documentation here: [https://www.django-rest-framework.org/](https://www.django-rest-framework.org/).'
  id: totrans-398
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以在这里找到完整的文档：[https://www.django-rest-framework.org/](https://www.django-rest-framework.org/)。
- en: External layers
  id: totrans-399
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 外部层级
- en: On top of the web server, there is the possibility to continue the link by adding
    extra levels that work on the HTTP layer. This allows you to load balance between
    multiple servers and increase the total throughput of the system. This can be
    chained into multiple layers, if necessary.
  id: totrans-400
  prefs: []
  type: TYPE_NORMAL
  zh: 在网络服务器之上，可以通过添加额外的层级来继续链接，这些层级在HTTP层上工作。这允许你在多个服务器之间进行负载均衡，并增加系统的总吞吐量。如果需要，这些层级可以链式连接成多层。
- en: '![Diagram'
  id: totrans-401
  prefs: []
  type: TYPE_NORMAL
  zh: '![图表'
- en: Description automatically generated](img/B17580_06_06.png)
  id: totrans-402
  prefs: []
  type: TYPE_NORMAL
  zh: 自动生成的描述](img/B17580_06_06.png)
- en: 'Figure 6.6: Chained load balancers'
  id: totrans-403
  prefs: []
  type: TYPE_NORMAL
  zh: 图6.6：链式负载均衡器
- en: The route from the user to the edge of our system is handled by the internet,
    but once it reaches the edge load balancer, it directs the requests inside the
    system. The edge load balancer works as a gateway between the external networks
    and the controlled environment of our network.
  id: totrans-404
  prefs: []
  type: TYPE_NORMAL
  zh: 用户到我们系统边缘的路径由互联网处理，但一旦到达边缘负载均衡器，它就会将请求内部化。边缘负载均衡器作为外部网络和我们的网络受控环境之间的网关工作。
- en: The edge load balancer is normally the only one that handles HTTPS connection,
    allowing the rest of the system to use only HTTP. This is convenient as HTTP requests
    are easier to cache and handle. HTTPS requests are encoded end to end and cannot
    be properly cached or analyzed. The internal traffic is protected from external
    access and should have robust policies to be sure that only approved engineers
    are able to access it and access logs to audit accesses. But at the same time,
    it can be easily debugged, and any traffic problems can be solved much more easily.
  id: totrans-405
  prefs: []
  type: TYPE_NORMAL
  zh: 边缘负载均衡器通常是唯一处理HTTPS连接的，允许系统其余部分仅使用HTTP。这很方便，因为HTTP请求更容易缓存和处理。HTTPS请求是端到端编码的，不能被正确缓存或分析。内部流量受到外部访问的保护，应该有强大的策略来确保只有批准的工程师能够访问它，并且应该有访问日志来审计访问。但与此同时，它也易于调试，任何流量问题都可以更容易地解决。
- en: The configuration of the network can greatly vary, and in lots of cases multiple
    load balancers are not required, and the edge load balancer can handle multiple
    web servers directly. The capacity in this case is key, as a load balancer has
    a limit on the number of requests that it can take.
  id: totrans-406
  prefs: []
  type: TYPE_NORMAL
  zh: 网络配置可能有很大的不同，在许多情况下不需要多个负载均衡器，边缘负载均衡器可以直接处理多个Web服务器。在这种情况下，容量是关键，因为负载均衡器对它能够处理的请求数量有限制。
- en: Some key load balancers can be set up as specialized hardware to ensure that
    they have the capacity to handle the required number of requests.
  id: totrans-407
  prefs: []
  type: TYPE_NORMAL
  zh: 一些关键的负载均衡器可以设置为专用硬件，以确保它们有处理所需请求数量的能力。
- en: This multi-layered structure allows you to introduce caching at any point of
    the system. This can improve the performance of the system, though it needs to
    be treated with care to be sure that it's adequate. After all, one of the most
    difficult problems in software development is the proper handling of the cache
    and its invalidation.
  id: totrans-408
  prefs: []
  type: TYPE_NORMAL
  zh: 这种多层结构允许你在系统的任何位置引入缓存。这可以提高系统的性能，尽管需要小心处理以确保其足够。毕竟，软件开发中最困难的问题之一就是正确处理缓存及其失效。
- en: Summary
  id: totrans-409
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: In this chapter, we went into the details about how web servers work, and the
    different layers that are involved.
  id: totrans-410
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们详细介绍了Web服务器的工作原理以及涉及的各个层。
- en: We started by describing the fundamental details of the request-response and
    web server architecture. Then, we moved on to describe a system with three layers,
    using nginx as the front web server and uWSGI to handle multiple Python workers
    that run Django code.
  id: totrans-411
  prefs: []
  type: TYPE_NORMAL
  zh: 我们首先描述了请求-响应和Web服务器架构的基本细节。然后，我们继续描述了一个具有三层结构的系统，使用nginx作为前端Web服务器，并使用uWSGI来处理运行Django代码的多个Python工作进程。
- en: We started with the web server itself, which allows you to serve HTTP, directly
    return the static content stored in files, and route it towards the next layer.
    We analyzed the different configuration elements, including enabling header forwarding
    and logging.
  id: totrans-412
  prefs: []
  type: TYPE_NORMAL
  zh: 我们从Web服务器本身开始，它允许你直接服务HTTP，直接返回存储在文件中的静态内容，并将其路由到下一层。我们分析了不同的配置元素，包括启用头部转发和日志记录。
- en: We continued by describing how uWSGI works and how it's able to create and set
    up different processes that interact through the WSGI protocol in Python. We described
    how to set up the interaction with the previous level (the nginx web server) and
    the next level (the Python code). We also described how the workers can be restarted
    in an orderly way, and how they can be automatically recycled periodically to
    mitigate certain kinds of problems.
  id: totrans-413
  prefs: []
  type: TYPE_NORMAL
  zh: 我们继续描述了uWSGI的工作原理以及它如何能够创建和设置不同的进程，这些进程通过Python中的WSGI协议进行交互。我们描述了如何设置与上一级（nginx
    Web服务器）和下一级（Python代码）的交互，还描述了如何有序地重启工作进程，以及如何定期自动回收它们以减轻某些类型的问题。
- en: We described how Django works to define a web application, and how the requests
    and responses flow through the code, including how the middleware can be used
    to chain elements in the flow. We also introduced Django REST framework as a way
    to create RESTful APIs and show how our example introduced in *Chapter 2* can
    be implemented through the views and serializers provided by Django REST framework.
  id: totrans-414
  prefs: []
  type: TYPE_NORMAL
  zh: 我们描述了Django如何定义Web应用程序，以及请求和响应如何通过代码流动，包括如何使用中间件在流程中串联元素。我们还介绍了Django REST框架作为创建RESTful
    API的方法，并展示了如何在*第二章*中引入的示例通过Django REST框架提供的视图和序列化器来实现。
- en: Finally, we described how the structure can be extended by layers on top to
    be sure to distribute the load across multiple servers and scale the system.
  id: totrans-415
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们描述了如何通过在顶部添加层来扩展结构，以确保将负载分布到多个服务器并扩展系统。
- en: We will next describe event-driven systems.
  id: totrans-416
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们将描述事件驱动系统。
