["```py\n    $ pip install fastapi[all]\n    ```", "```py\n$ pip install –r requirements.txt\n```", "```py\n$ pip install fastapi[all] \"sqlalchemy>=2.0.0\" aiosqlite\n```", "```py\nfrom sqlalchemy import Column, Float, ForeignKey, Table\nfrom sqlalchemy.orm import (\n    DeclarativeBase,\n    Mapped,\n    mapped_column,\n)\nclass Base(DeclarativeBase):\n    pass\nclass Ticket(Base):\n    __tablename__ = \"tickets\"\n    id: Mapped[int] = mapped_column(primary_key=True)\n    price: Mapped[float] = mapped_column(nullable=True)\n    show: Mapped[str | None]\n    user: Mapped[str | None]\n```", "```py\nfrom sqlalchemy.ext.asyncio import (\n    create_async_engine,\n)\nfrom sqlalchemy.orm import sessionmaker\nSQLALCHEMY_DATABASE_URL = (\n    \"sqlite+aiosqlite:///.database.db\"\n)\ndef get_engine():\n    return create_async_engine(\n        SQLALCHEMY_DATABASE_URL, echo=True\n    )\n```", "```py\nfrom sqlalchemy.ext.asyncio import (\n    AsyncSession,\n)\nAsyncSessionLocal = sessionmaker(\n    autocommit=False,\n    autoflush=False,\n    bind=get_engine(),\n    class_=AsyncSession,\n)\nasync def get_db_session():\n    async with AsyncSessionLocal() as session:\n        yield session\n```", "```py\nfrom contextlib import asynccontextmanager\nfrom fastapi import FastAPI\nfrom app.database import Base\nfrom app.db_connection import (\n    AsynSessionLocal,\n    get_db_session\n)\n@asynccontextmanager\nasync def lifespan(app: FastAPI):\n    engine = get_engine()\n    async with engine.begin() as conn:\n        await conn.run_sync(Base.metadata.create_all)\n        yield\n    await engine.dispose()ispose()\napp = FastAPI(lifespan=lifespan)\n```", "```py\n$ uvicorn app.main:app\n```", "```py\nSQLALCHEMY_DATABASE_URL = \"sqlite+aiosqlite:///.database.db\"\n```", "```py\nmysql+aiomysql://user:password@host:port/dbname[?key=value&key=value...]\n```", "```py\n    from sqlalchemy.ext.asyncio import AsyncSession\n    from sqlalchemy.future import select\n    from app.database import Ticket\n    async def create_ticket(\n        db_session: AsyncSession,\n        show_name: str,\n        user: str = None,\n        price: float = None,\n    ) -> int:\n        ticket = Ticket(\n            show=show_name,\n            user=user,\n            price=price,\n        )\n        async with db_session.begin():\n            db_session.add(ticket)\n            await db_session.flush()\n            ticket_id = ticket.id\n            await db_session.commit()\n        return ticket_id\n    ```", "```py\n    async def get_ticket(\n        db_session: AsyncSession, ticket_id: int\n    ) -> Ticket | None:\n        query = (\n            select(Ticket)\n            .where(Ticket.id == ticket_id)\n        )\n        async with db_session as session:\n            tickets = await session.execute(query)\n            return tickets.scalars().first()\n    ```", "```py\n    async def update_ticket_price(\n        db_session: AsyncSession,\n        ticket_id: int,\n        new_price: float,\n    ) -> bool:\n        query = (\n            update(Ticket)\n            .where(Ticket.id == ticket_id)\n            .values(price=new_price)\n        )\n        async with db_session as session:\n            ticket_updated = await session.execute(query)\n            await session.commit()\n            if ticket_updated.rowcount == 0:\n                return False\n            return True\n    ```", "```py\n    async def delete_ticket(\n        db_session: AsyncSession, ticket_id\n    ) -> bool:\n        async with db_session as session:\n            tickets_removed = await session.execute(\n                delete(\n                    Ticket\n                ).where(Ticket.id == ticket_id)\n            )\n            await session.commit()\n            if tickets_removed.rowcount == 0:\n                return False\n            return True\n    ```", "```py\n    from typing import Annotated\n    from sqlalchemy.ext.asyncio import AsyncSession\n    from app.db_connection import (\n        AsyncSessionLocal,\n        get_engine,\n        get_session\n    )\n    from app.operations import create_ticket\n    # rest of the code \n    class TicketRequest(BaseModel):\n        price: float | None\n        show: str | None\n        user: str | None = None\n    @app.post(\"/ticket\", response_model=dict[str, int])\n    async def create_ticket_route(\n        ticket: TicketRequest,\n        db_session: Annotated[\n            AsyncSession,\n            Depends(get_db_session)\n        ]\n    ):\n        ticket_id = await create_ticket(\n            db_session,\n            ticket.show,\n            ticket.user,\n            ticket.price,\n        )\n        return {\"ticket_id\": ticket_id}\n    ```", "```py\n$ uvicorn app.main:app\n```", "```py\n$ pip install alembic\n```", "```py\n    alembic.ini file and an alembic folder with some files inside it. The alembic.ini file is a configuration file for alembic.If you copy the project from the GitHub repository make sure to delete the existing `alembic` folder before running the `alembic` `init` command.\n    ```", "```py\n    sqlalchemy.url = sqlite:///.database.db\n    ```", "```py\n    from app.database import Base\n    target_metadata = Base.metadata\n    ```", "```py\n    alembic/versions folder.\n    ```", "```py\n    .database.db file with the tickets table in it.\n    ```", "```py\nclass Ticket(Base):\n    __tablename__ = \"tickets\"\n    id: Mapped[int] = mapped_column(primary_key=True)\n    price: Mapped[float] = mapped_column(nullable=True)\n    show: Mapped[str | None]\n    user: Mapped[str | None]\n    sold: Mapped[bool] = mapped_column(default=False)\n```", "```py\n$ alembic revision –-autogenerate -m \"Add sold field\"\n```", "```py\n$ alembic upgrade head\n```", "```py\n    class Ticket(Base):\n        __tablename__ = \"tickets\"\n        id: Mapped[int] = mapped_column(primary_key=True)\n        price: Mapped[float] = mapped_column(\n            nullable=True\n        )\n        show: Mapped[str | None]\n        user: Mapped[str | None]\n        sold: Mapped[bool] = mapped_column(default=False)\n        details: Mapped[\"TicketDetails\"] = relationship(\n            back_populates=\"ticket\"\n        )\n    ```", "```py\n    from sqlalchemy import ForeignKey\n    class TicketDetails(Base):\n        __tablename__ = \"ticket_details\"\n        id: Mapped[int] = mapped_column(primary_key=True)\n        ticket_id: Mapped[int] = mapped_column(\n            ForeignKey(\"tickets.id\")\n    )\n        ticket: Mapped[\"Ticket\"] = relationship(\n            back_populates=\"details\"\n        )\n        seat: Mapped[str | None]\n        ticket_type: Mapped[str | None]\n    ```", "```py\n    async def update_ticket_details(\n        db_session: AsyncSession,\n        ticket_id: int,\n        updating_ticket_details: dict,\n    ) -> bool:\n        ticket_query = update(TicketDetails).where(\n            TicketDetails.ticket_id == ticket_id\n        )\n        if updating_ticket_details != {}:\n            ticket_query = ticket_query.values(\n                 *updating_ticket_details\n            )\n            result = await db_session.execute(\n                    ticket_query\n                )\n            await db_session.commit()\n            if result.rowcount == 0:\n                    return False\n        return True\n    ```", "```py\n    async def create_ticket(\n        db_session: AsyncSession,\n        show_name: str,\n        user: str = None,\n        price: float = None,\n    ) -> int:\n        ticket = Ticket(\n            show=show_name,\n            user=user,\n            price=price,\n            details=TicketDetails(),\n        )\n        async with db_session.begin():\n            db_session.add(ticket)\n            await db_session.flush()\n            ticket_id = ticket.id\n            await db_session.commit()\n        return ticket_id\n    ```", "```py\nclass Ticket(Base):\n    __tablename__ = \"tickets\"\n    # skip existing columns\n    event_id: Mapped[int | None] = mapped_column(\n        ForeignKey(\"events.id\")\n    )\n    event: Mapped[\"Event | None\"] = relationship(\n        back_populates=\"tickets\"\nEvent class to map the events table into the database:\n\n```", "```py\n\n `ForeignKey`, in this case, is defined only in the `Ticket` class since the event associated can be only one.\nThis is all you need to create a many-to-one relationship.\nExercise\nYou can add to the application the operations to create an event and specify the number of tickets to create with it. Once you’ve done this, expose the operation with the corresponding endpoint.\nMany to many\nLet’s imagine that we have a list of sponsors that can sponsor our events. Since we can have multiple sponsors that can sponsor multiple events, this situation is best representative of a many-to-many relationship.\nTo work with many-to-many relationships, we need to define a class for the concerned tables and another class to track the so-called *association table*.\nLet’s start by defining a column to accommodate relationships in the `Event` class:\n\n```", "```py\nclass Sponsor(Base):\n    __tablename__ = \"sponsors\"\n    id: Mapped[int] = mapped_column(primary_key=True)\n    name: Mapped[str] = mapped_column(unique=True)\n    events: Mapped[list[\"Event\"]] = relationship(\n        secondary=\"sponsorships\",\n        back_populates=\"sponsors\",\n    )\n```", "```py\nclass Sponsorship(Base):\n    __tablename__ = \"sponsorships\"\n    event_id: Mapped[int] = mapped_column(\n        ForeignKey(\"events.id\"), primary_key=True\n    )\n    sponsor_id: Mapped[int] = mapped_column(\n        ForeignKey(\"sponsors.id\"), primary_key=True\n    )\n    amount: Mapped[float] = mapped_column(\n        nullable=False, default=10\n    )\n```", "```py\nasync def get_events_with_sponsors(\n    db_session: AsyncSession\n) -> list[Event]:\n    query = (\n        select(Event)\n        .options(\njoinedload(Event.sponsors)\n        )\n    )\n    async with db_session as session:\n        result = await session.execute(query)\n        events = result.scalars().all()\n    return events\n```", "```py\nasync def get_event_sponsorships_with_amount(\n    db_session: AsyncSession, event_id: int\n):\n    query = (\n        select(Sponsor.name, Sponsorship.amount)\n        .join(\n            Sponsorship,\n            Sponsorship.sponsor_id == Sponsor.id,\n        )\n        .join(\n            Event,\n            Sponsorship.event_id == Event.id\n)\n        .order_by(Sponsorship.amount.desc())\n    )\n    async with db_session as session:\n        result = await session.execute(query)\n        sponsor_contributions = result.fetchall()\n    return sponsor_contributions\n```", "```py\nasync def get_event_sponsorships_with_amount(\n    db_session: AsyncSession, event_id: int\n):\n    query = (\nselect(Sponsor.name, Sponsorship.amount)\n        .join(\n            Sponsorship,\n            Sponsorship.sponsor_id == Sponsor.id,\n        )\n        .where(Sponsorship.event_id == event_id)\n        .order_by(Sponsorship.amount.desc())\n    )\n    async with db_session as session:\n        result = await session.execute(query)\n        sponsor_contributions = result.fetchall()\n    return sponsor_contributions\n```", "```py\nasync def get_events_tickets_with_user_price(\n    db_session: AsyncSession, event_id: int\n) -> list[Ticket]:\n    query = (\n        select(Ticket)\n        .where(Ticket.event_id == event_id)\n        .options(\n            load_only(\n                Ticket.id, Ticket.user, Ticket.price\n            )\n        )\n    )\n    async with db_session as session:\n        result = await session.execute(query)\n        tickets = result.scalars().all()\n    return tickets\n```", "```py\ntickets = await get_events_tickets_with_user_price(\n    session, event_id\n)\n```", "```py\n$ pip install cryptography\n```", "```py\n    class CreditCard(Base):\n        __tablename__ = \"credit_cards\"\n        id: Mapped[int] = mapped_column(primary_key=True)\n        number: Mapped[str]\n        expiration_date: Mapped[str]\n        cvv: Mapped[str]\n        card_holder_name: Mapped[str]\n    ```", "```py\n    from cryptography.fernet import Fernet\n    cypher_key = Fernet.generate_key()\n    cypher_suite = Fernet(cypher_key)\n    ```", "```py\n    def encrypt_credit_card_info(card_info: str) -> str:\n        return cypher_suite.encrypt(\n            card_info.encode()\n        ).decode()\n    def decrypt_credit_card_info(\n        encrypted_card_info: str,\n    ) -> str:\n        return cypher_suite.decrypt(\n            encrypted_card_info.encode()\n        ).decode()\n    ```", "```py\n    from sqlalchemy import select\n    from sqlalchemy.ext.asyncio import AsyncSession\n    from app.database import CreditCard\n    async def store_credit_card_info(\n        db_session: AsyncSession,\n        card_number: str,\n        card_holder_name: str,\n        expiration_date: str,\n        cvv: str,\n    ):\n        encrypted_card_number = encrypt_credit_card_info(\n            card_number\n        )\n        encrypted_cvv = encrypt_credit_card_info(cvv)\n        # Store encrypted credit card information\n        # in the database\n        credit_card = CreditCard(\n            number=encrypted_card_number,\n            card_holder_name=card_holder_name,\n            expiration_date=expiration_date,\n            cvv=encrypted_cvv,\n        )\n        async with db_session.begin():\n            db_session.add(credit_card)\n            await db_session.flush()\n            credit_card_id = credit_card.id\n            await db_session.commit()\n        return credit_card_id\n    ```", "```py\n    async def retrieve_credit_card_info(\n        db_session: AsyncSession, credit_card_id: int\n    ):\n        query = select(CreditCard).where(\n            CreditCard.id == credit_card_id\n        )\n        async with db_session as session:\n            result = await session.execute(query)\n            credit_card = result.scalars().first()\n        credit_card_number = decrypt_credit_card_info(\n                credit_card.number\n            ),\n        cvv = decrypt_credit_card_info(credit_card.cvv)\n        card_holder = credit_card.card_holder_name\n        expiry = credit_card.expiration_date\n        return {\n            \"card_number\": credit_card_number,\n            \"card_holder_name\": card_holder,\n            \"expiration_date\": expiry,\n            \"cvv\": cvv\n        }\n    ```", "```py\n    async def sell_ticket_to_user(\n        db_session: AsyncSession, ticket_id: int, user: str\n    ) -> bool:\n        ticket_query = (\n            update(Ticket)\n            .where(\n                and_(\n                    Ticket.id == ticket_id,\n                    Ticket.sold == False,\n                )\n            )\n            .values(user=user, sold=True)\n        )\n        async with db_session as session:\n            result = (\n               await db_session.execute(ticket_query)\n            )\n            await db_session.commit()\n            if result.rowcount == 0:\n                return False\n        return True\n    ```", "```py\n    @pytest.fixture\n    async def add_special_ticket(db_session_test):\n        ticket = Ticket(\n            id=1234,\n            show=\"Special Show\",\n            details=TicketDetails(),\n        )\n        async with db_session_test.begin():\n            db_session_test.add(ticket)\n            await db_session_test.commit()\n    ```", "```py\n    import asyncio\n    async def test_concurrent_ticket_sales(\n        add_special_ticket,\n        db_session_test,\n        second_session_test,\n    ):\n        result = await asyncio.gather(\n            sell_ticket_to_user(\n                db_session_test, 1234, \"Jake Fake\"\n            ),\n            sell_ticket_to_user(\n                second_session_test, 1234, \"John Doe\"\n            ),\n        )\n        assert result in (\n            [True, False],\n            [False, True],\n        )  # only one of the sales should be successful\n        ticket = await get_ticket(db_session_test, 1234)\n        # assert that the user who bought the ticket\n        # correspond to the successful sale\n        if result[0]:\n            assert ticket.user == \"Jake Fake\"\n        else:\n            assert ticket.user == \"John Doe\"\n    ```", "```py\n    $ pytest tests/test_operations.py::test_concurrent_ticket_sales\n    ```", "```py\nfrom sqlalchemy import create_engine\nfrom sqlalchemy.orm import sessionmaker\neng = create_engine(\n    \"postgresql+psycopg2://scott:tiger@localhost/test\",\n    isolation_level=\"REPEATABLE READ\",\n)\nSession = sessionmaker(eng)\n```", "```py\n\n```"]