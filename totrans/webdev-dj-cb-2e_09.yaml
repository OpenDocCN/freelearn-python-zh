- en: Chapter 9. Data Import and Export
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In this chapter, we will cover the following recipes:'
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
- en: Importing data from a local CSV file
  id: totrans-2
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Importing data from a local Excel file
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Importing data from an external JSON file
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Importing data from an external XML file
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Creating filterable RSS feeds
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Using Tastypie to create API
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Using Django REST framework to create API
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Introduction
  id: totrans-9
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: There are times when your data needs to be transported from a local format to
    the database, imported from external resources, or provided to third parties.
    In this chapter, we will take a look at some practical examples of how to write
    management commands and APIs to do this.
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
- en: Importing data from a local CSV file
  id: totrans-11
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The **comma-separated values** (**CSV**) format is probably the simplest way
    to store tabular data in a text file. In this recipe, we will create a management
    command that imports data from CSV to a Django database. We will need a CSV list
    of movies with a title, URL, and release year. You can easily create such files
    with Excel, Calc, or another spreadsheet application.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  id: totrans-13
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Create a `movies` app with the `Movie` model containing the following fields:
    `title`, `url`, and `release_year`. Place the app under `INSTALLED_APPS` in the
    settings.'
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  id: totrans-15
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Follow these steps to create and use a management command that imports movies
    from a local CSV file:'
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
- en: In the `movies` app, create a `management` directory and then a `commands` directory
    in the new `management` directory. Put the empty `__init__.py` files in both new
    directories to make them Python packages.
  id: totrans-17
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Add an `import_movies_from_csv.py` file there with the following content:'
  id: totrans-18
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE0]'
  id: totrans-19
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'To run the import, call the following in the command line:'
  id: totrans-20
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE1]'
  id: totrans-21
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE1]'
- en: How it works...
  id: totrans-22
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'For a management command, we need to create a `Command` class deriving from
    `BaseCommand` and overwriting the `add_arguments()` and `handle()` method. The
    `help` attribute defines the help text for the management command. It can be seen
    when you type the following in the command line:'
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  id: totrans-24
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: Django management commands use the built-in argparse module to parse the passed
    arguments. The `add_arguments()` method defines what positional or named arguments
    should be passed to the management command. In our case, we will add a positional
    `file_path` argument of Unicode type. By `nargs` set to the `1` attribute, we
    allow only one value. To learn about the other arguments that you can define and
    how to do this, refer to the official argparse documentation at [https://docs.python.org/2/library/argparse.html#the-add-argument-method](https://docs.python.org/2/library/argparse.html#the-add-argument-method).
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
- en: 'At the beginning of the `handle()` method, the `verbosity` argument is checked.
    Verbosity defines how verbose the command is, from `0` not giving any output to
    the command-line tool to `3` being very verbose. You can pass this argument to
    the command as follows:'
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  id: totrans-27
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: Then, we also expect the filename as the first positional argument. The `options["file_path"]`
    returns a list of the values defined in the nargs, therefore, it is one value
    in this case.
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
- en: We open the given file and pass its pointer to `csv.reader`. Then, for each
    line in the file, we will create a new `Movie` object if a matching movie doesn't
    exist yet. The management command will print out the imported movie titles to
    the console, unless you set the verbosity to `0`.
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
- en: Tip
  id: totrans-30
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: If you want to debug the errors of a management command while developing it,
    pass the `--traceback` parameter for it. If an error occurs, you will see the
    full stack trace of the problem.
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
- en: There's more...
  id: totrans-32
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: You can learn more about the CSV library from the official documentation at
    [https://docs.python.org/2/library/csv.html](https://docs.python.org/2/library/csv.html).
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
- en: See also
  id: totrans-34
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The *Importing data from a local Excel file* recipe
  id: totrans-35
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Importing data from a local Excel file
  id: totrans-36
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Another popular format to store tabular data is an Excel spread sheet. In this
    recipe, we will import movies from a file of this format.
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  id: totrans-38
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Let''s start with the `movies` app that we created in the previous recipe.
    Install the `xlrd` package to read Excel files, as follows:'
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  id: totrans-40
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: How to do it...
  id: totrans-41
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Follow these steps to create and use a management command that imports movies
    from a local XLS file:'
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
- en: If you haven't done that, in the `movies` app, create a `management` directory
    and then a `commands` directory in the new `management` directory. Put the empty
    `__init__.py` files in both the new directories to make them Python packages.
  id: totrans-43
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Add the `import_movies_from_xls.py` file with the following content:'
  id: totrans-44
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE5]'
  id: totrans-45
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'To run the import, call the following in the command line:'
  id: totrans-46
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE6]'
  id: totrans-47
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE6]'
- en: How it works...
  id: totrans-48
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The principle of importing from an XLS file is the same as with CSV. We open
    the file, read it row by row, and create the `Movie` objects from the provided
    data. A detailed explanation is as follows.
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
- en: Excel files are workbooks containing sheets as different tabs.
  id: totrans-50
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: We are using the `xlrd` library to open a file passed as a positional argument
    to the command. Then, we will read the first sheet from the workbook.
  id: totrans-51
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Afterwards, we will read the rows one by one (except the first row with the
    column titles) and create the `Movie` objects from them. Once again, the management
    command will print out the imported movie titles to the console, unless you set
    the verbosity to `0`.
  id: totrans-52
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: There's more...
  id: totrans-53
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: You can learn more about how to work with Excel files at [http://www.python-excel.org/](http://www.python-excel.org/).
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
- en: See also
  id: totrans-55
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The *Importing data from a local CSV file* recipe
  id: totrans-56
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Importing data from an external JSON file
  id: totrans-57
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The `Last.fm` music website has an API under the [http://ws.audioscrobbler.com/](http://ws.audioscrobbler.com/)
    domain that you can use to read the albums, artists, tracks, events, and more.
    The API allows you to either use the JSON or XML format. In this recipe, we will
    import the top tracks tagged disco using the JSON format.
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  id: totrans-59
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Follow these steps in order to import data in the JSON format from `Last.fm`:'
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
- en: To use `Last.fm`, you need to register and get an API key. The API key can be
    created at [http://www.last.fm/api/account/create](http://www.last.fm/api/account/create).
  id: totrans-61
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The API key has to be set in the settings as `LAST_FM_API_KEY`.
  id: totrans-62
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Also, install the `requests` library in your virtual environment using the
    following command:'
  id: totrans-63
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE7]'
  id: totrans-64
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'Let''s check the structure of the JSON endpoint ([http://ws.audioscrobbler.com/2.0/?method=tag.gettoptracks&tag=disco&api_key=xxx&format=json](http://ws.audioscrobbler.com/2.0/?method=tag.gettoptracks&tag=disco&api_key=xxx&format=json)):'
  id: totrans-65
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE8]'
  id: totrans-66
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE8]'
- en: We want to read the track name, artist, URL, and medium-sized images.
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  id: totrans-68
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Follow these steps to create a `Track` model and management command, which
    imports top tracks from `Last.fm` to the database:'
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s create a `music` app with a simple `Track` model, as follows:'
  id: totrans-70
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE9]'
  id: totrans-71
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'Then, create the management command as shown in the following:'
  id: totrans-72
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE10]'
  id: totrans-73
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'As the list is paginated, we will add the `save_page()` method to the `Command`
    class to save a single page of tracks. This method takes the dictionary with the
    top tracks from a single page as a parameter, as follows:'
  id: totrans-74
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE11]'
  id: totrans-75
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'To run the import, call the following in the command line:'
  id: totrans-76
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE12]'
  id: totrans-77
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE12]'
- en: How it works...
  id: totrans-78
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The optional named `max_pages` argument limits the imported data to three pages.
    Just skip it if you want to download all the available top tracks; however, beware
    that there are above 26,000 pages as detailed in the `totalPages` value and this
    will take a while.
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
- en: Using the `requests.get()` method, we read the data from `Last.fm`, passing
    the `params` query parameters. The response object has a built-in method called
    `json()`, which converts a JSON string and returns a parsed dictionary.
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
- en: We read the total pages value from this dictionary and then save the first page
    of results. Then, we get the second and later pages one by one and save them.
    One interesting part in the import is downloading and saving the image. Here,
    we also use `request.get()` to retrieve the image data and then we pass it to
    `File` through `StringIO`, which is accordingly used in the `image.save()` method.
    The first parameter of `image.save()` is a filename that will be overwritten anyway
    by the value from the `upload_to` function and is necessary only for the file
    extension.
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
- en: See also
  id: totrans-82
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The *Importing data from an external XML file* recipe
  id: totrans-83
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Importing data from an external XML file
  id: totrans-84
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The `Last.fm` file also allows you to take data from their services in XML format.
    In this recipe, I will show you how to do this.
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  id: totrans-86
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'To prepare importing top tracks from `Last.fm` in the XML format, follow these
    steps:'
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
- en: Start with the first three steps from the *Getting ready* section in the *Importing
    data from an external JSON file* recipe.
  id: totrans-88
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Then, let''s check the structure of the XML endpoint ([http://ws.audioscrobbler.com/2.0/?method=tag.gettoptracks&tag=disco&api_key=xxx&format=xml](http://ws.audioscrobbler.com/2.0/?method=tag.gettoptracks&tag=disco&api_key=xxx&format=xml)),
    as follows:'
  id: totrans-89
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后，让我们检查XML端点的结构（[http://ws.audioscrobbler.com/2.0/?method=tag.gettoptracks&tag=disco&api_key=xxx&format=xml](http://ws.audioscrobbler.com/2.0/?method=tag.gettoptracks&tag=disco&api_key=xxx&format=xml)），如下所示：
- en: '[PRE13]'
  id: totrans-90
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE13]'
- en: How to do it...
  id: totrans-91
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何做到这一点...
- en: 'Execute the following steps one by one to import the top tracks from `Last.fm`
    in the XML format:'
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 按顺序执行以下步骤以导入`Last.fm`的XML格式的顶级曲目：
- en: Create a `music` app with a `Track` model similar to the previous recipe, if
    you've not already done this.
  id: totrans-93
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果您还没有这样做，创建一个具有类似之前食谱的`Track`模型的`music`应用。
- en: 'Then, create an `import_music_from_lastfm_as_xml.py` management command. We
    will be using the `ElementTree` XML API that comes with Python to parse the XML
    nodes, as follows:'
  id: totrans-94
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后，创建一个`import_music_from_lastfm_as_xml.py`管理命令。我们将使用Python附带的`ElementTree`
    XML API来解析XML节点，如下所示：
- en: '[PRE14]'
  id: totrans-95
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'As the list is paginated, we will add a `save_page()` method to the `Command`
    class to save a single page of tracks. This method takes the root node of the
    XML as a parameter, as shown in the following:'
  id: totrans-96
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 由于列表是分页的，我们将在`Command`类中添加一个`save_page()`方法来保存单个页面的曲目。此方法以XML的根节点作为参数，如下所示：
- en: '[PRE15]'
  id: totrans-97
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'To run the import, call the following in the command line:'
  id: totrans-98
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 要运行导入，请在命令行中调用以下命令：
- en: '[PRE16]'
  id: totrans-99
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE16]'
- en: How it works...
  id: totrans-100
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: The process is analogous to the JSON approach. Using the `requests.get()` method,
    we read the data from `Last.fm`, passing the query parameters as `params`. The
    XML content of the response is passed to the `ElementTree` parser and the root
    node is returned.
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 该过程类似于JSON方法。使用`requests.get()`方法，我们从`Last.fm`读取数据，将查询参数作为`params`传递。响应的XML内容传递给`ElementTree`解析器，并返回根节点。
- en: The `ElementTree` nodes have the `find()` and `findall()` methods, where you
    can pass XPath queries to filter out specific subnodes.
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: '`ElementTree`节点有`find()`和`findall()`方法，您可以通过传递XPath查询来过滤出特定的子节点。'
- en: 'The following is a table of the available XPath syntax supported by `ElementTree`:'
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是一个表格，列出了`ElementTree`支持的可用XPath语法：
- en: '| XPath Syntax Component | Meaning |'
  id: totrans-104
  prefs: []
  type: TYPE_TB
  zh: '| XPath语法组件 | 含义 |'
- en: '| --- | --- |'
  id: totrans-105
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- |'
- en: '| `tag` | This selects all the child elements with the given tag. |'
  id: totrans-106
  prefs: []
  type: TYPE_TB
  zh: '| `tag` | 这选择具有给定标签的所有子元素。|'
- en: '| `*` | This selects all the child elements. |'
  id: totrans-107
  prefs: []
  type: TYPE_TB
  zh: '| `*` | 这选择所有子元素。|'
- en: '| `.` | This selects the current node. |'
  id: totrans-108
  prefs: []
  type: TYPE_TB
  zh: '| `.` | 这选择当前节点。|'
- en: '| `//` | This selects all the subelements on all the levels beneath the current
    element. |'
  id: totrans-109
  prefs: []
  type: TYPE_TB
  zh: '| `//` | 这选择当前元素所有级别下的所有子元素。|'
- en: '| `..` | This selects the parent element. |'
  id: totrans-110
  prefs: []
  type: TYPE_TB
  zh: '| `..` | 这选择父元素。|'
- en: '| `[@attrib]` | This selects all the elements that have the given attribute.
    |'
  id: totrans-111
  prefs: []
  type: TYPE_TB
  zh: '| `[@attrib]` | 这选择具有给定属性的所有元素。|'
- en: '| `[@attrib=''value'']` | This selects all the elements for which the given
    attribute has the given value. |'
  id: totrans-112
  prefs: []
  type: TYPE_TB
  zh: '| `[@attrib=''value'']` | 这选择具有给定属性值的所有元素。|'
- en: '| `[tag]` | This selects all the elements that have a child named tag. Only
    immediate children are supported. |'
  id: totrans-113
  prefs: []
  type: TYPE_TB
  zh: '| `[tag]` | 这选择所有具有名为tag的子元素的元素。仅支持直接子元素。|'
- en: '| `[position]` | This selects all the elements that are located at the given
    position. The position can either be an integer (`1` is the first position), the
    `last()`expression (for the last position), or a position relative to the last
    position (for example, `last()-1`). |'
  id: totrans-114
  prefs: []
  type: TYPE_TB
  zh: '| `[position]` | 这选择位于给定位置的元素。位置可以是整数（`1`是第一个位置），`last()`表达式（对于最后一个位置），或者相对于最后一个位置的位置（例如，`last()-1`）。|'
- en: Therefore, using `root.find("tracks").attrib["totalPages"]`, we read the total
    amount of pages. We will save the first page and then go through the other pages
    one by one and save them too.
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，使用`root.find("tracks").attrib["totalPages"]`，我们读取总页数。我们将保存第一页，然后逐页保存其他页面。
- en: In the `save_page()` method, `root.findall("tracks/track")` returns an iterator
    through the `<track>` nodes under the `<tracks>` node. With `track_node.find("image[@size='medium']")`,
    we get the medium-sized image.
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 在`save_page()`方法中，`root.findall("tracks/track")`返回一个通过`<tracks>`节点下的`<track>`节点进行迭代的迭代器。使用`track_node.find("image[@size='medium']")`，我们获取中等大小的图像。
- en: There's more...
  id: totrans-117
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 还有更多...
- en: You can learn more about XPath at [https://en.wikipedia.org/wiki/XPath](https://en.wikipedia.org/wiki/XPath).
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以在[https://en.wikipedia.org/wiki/XPath](https://en.wikipedia.org/wiki/XPath)上了解更多关于XPath的信息。
- en: The full documentation of `ElementTree` can be found at [https://docs.python.org/2/library/xml.etree.elementtree.html](https://docs.python.org/2/library/xml.etree.elementtree.html).
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
- en: See also
  id: totrans-120
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The *Importing data from an external JSON file* recipe
  id: totrans-121
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Creating filterable RSS feeds
  id: totrans-122
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Django comes with a syndication feed framework that allows you to create RSS
    and Atom feeds easily. RSS and Atom feeds are XML documents with specific semantics.
    They can be subscribed in an RSS reader such as Feedly or they can be aggregated
    in other websites, mobile applications, or desktop applications. In this recipe,
    we will create `BulletinFeed`, which provides a bulletin board with images. Moreover,
    the results will be filterable by URL query parameters.
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  id: totrans-124
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Create a new `bulletin_board` app and put it under `INSTALLED_APPS` in the settings.
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  id: totrans-126
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'We will create a `Bulletin` model and an RSS feed for it. We will be able to
    filter the RSS feed by type or category so that it is possible to only subscribe
    to the bulletins that are, for example, offering used books:'
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
- en: 'In the `models.py` file of this app, add the `Category` and `Bulletin` models
    with a foreign key relationship between them, as follows:'
  id: totrans-128
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE17]'
  id: totrans-129
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'Then, create `BulletinFilterForm` that allows the visitor to filter the bulletins
    by type and category, as follows:'
  id: totrans-130
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE18]'
  id: totrans-131
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'Add a `feeds.py` file with the `BulletinFeed` class, as shown in the following:'
  id: totrans-132
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE19]'
  id: totrans-133
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'Create a template for the bulletin description that will be provided in the
    feed, as shown in the following:'
  id: totrans-134
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE20]'
  id: totrans-135
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'Create a URL configuration for the bulletin board app and include it in the
    root URL configuration, as follows:'
  id: totrans-136
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE21]'
  id: totrans-137
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'You will also need the views and templates for the filterable list and details
    of the bulletins. In the `Bulletin` list page template, add the following link:'
  id: totrans-138
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE22]'
  id: totrans-139
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE22]'
- en: How it works...
  id: totrans-140
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Therefore, if you have some data in the database and you open `http://127.0.0.1:8000/bulletin-board/rss/?bulletin_type=offering&category=4`
    in your browser, you will get an RSS feed of bulletins with the `Offering` type
    and the `4` category ID.
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
- en: The `BulletinFeed` class has the `get_objects()` method that takes the current
    `HttpRequest` and defines the `obj` dictionary used in other methods of the same
    class. The `obj` dictionary contains the bulletin type, category, and current
    query string.
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
- en: The `title()` method returns the title of the feed. It can either be generic
    or related to the selected bulletin type or category. The `link()` method returns
    the link to the original bulletin list with the filtering done. The `feed_url()`
    method returns the URL of the current feed. The `items()` method does the filtering
    itself and returns a filtered `QuerySet` of bulletins. Finally, the `item_pubdate()`
    method returns the creation date of the bulletin.
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
- en: To see all the available methods and properties of the `Feed` class that we
    are extending, refer to the following documentation at [https://docs.djangoproject.com/en/1.8/ref/contrib/syndication/#feed-class-reference](https://docs.djangoproject.com/en/1.8/ref/contrib/syndication/#feed-class-reference).
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
- en: The other parts of the code are self-explanatory.
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
- en: See also
  id: totrans-146
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The *Creating a model mixin with URL-related methods* recipe in [Chapter 2](ch02.html
    "Chapter 2. Database Structure"), *Database Structure*
  id: totrans-147
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The *Creating a model mixin to handle creation and modification dates* recipe
    in [Chapter 2](ch02.html "Chapter 2. Database Structure"), *Database Structure*
  id: totrans-148
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The *Using Tastypie to create API* recipe
  id: totrans-149
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Using Tastypie to create API
  id: totrans-150
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '**Tastypie** is a framework for Django to create web service **Application
    Program Interface** (**API**). It supports full `GET`/`POST`/`PUT`/`DELETE`/`PATCH
    HTTP` methods to deal with online resources. It also supports different types
    of authentication and authorization, serialization, caching, throttling, and so
    on. In this recipe, you will learn how to provide bulletins to third parties for
    reading, that is, we will implement only the `GET HTTP` method.'
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  id: totrans-152
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'First of all, install `Tastypie` in your virtual environment using the following
    command:'
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  id: totrans-154
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: Add Tastypie to `INSTALLED_APPS` in the settings. Then, enhance the `bulletin_board`
    app that we defined in the *Creating filterable RSS feeds* recipe.
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  id: totrans-156
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'We will create an API for bulletins and inject it in the URL configuration
    as follows:'
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
- en: 'In the `bulletin_board` app, create an `api.py` file with two resources, `CategoryResource`
    and `BulletinResource`, as follows:'
  id: totrans-158
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE24]'
  id: totrans-159
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'In the main URL configuration, include the API URLs, as follows:'
  id: totrans-160
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE25]'
  id: totrans-161
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE25]'
- en: Create a Tastypie API key for the admin user in the model administration. To
    do this, navigate to **Tastypie** | **Api key** | **Add Api key**, select the
    admin user, and save the entry. This will generate a random API key, as shown
    in the following screenshot:![How to do it...](img/B04912_09_01.jpg)
  id: totrans-162
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Then, you can open this URL to see the JSON response in action (simply replace
    xxx with your API key): `http://127.0.0.1:8000/api/v1/bulletins/?format=json&username=admin&api_key=xxx`.'
  id: totrans-163
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: How it works...
  id: totrans-164
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Each endpoint of `Tastypie` should have a class extending `ModelResource` defined.
    Similar to the Django models, the configuration of the resource is set in the
    `Meta` class:'
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
- en: The `queryset` parameter defines the `QuerySet` of objects to list.
  id: totrans-166
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The `resource_name` parameter defines the name of the URL endpoint.
  id: totrans-167
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The `fields` parameter lists out the fields of the model that should be shown
    in the API.
  id: totrans-168
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The `allowed_methods` parameter lists out the request methods, such as `get`,
    `post`, `put`, `delete`, and `patch`.
  id: totrans-169
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The `authentication` parameter defines how third parties can authenticate themselves
    when connecting to the API. The available options are `Authentication`, `BasicAuthentication`,
    `ApiKeyAuthentication`, `SessionAuthentication`, `DigestAuthentication`, `OAuthAuthentication`,
    `MultiAuthentication`, or your own custom authentication. In our case, we are
    using `ApiKeyAuthentication` as we want each user to use `username` and `api_key`.
  id: totrans-170
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The `authorization` parameter answers the authorization question: is permission
    granted to this user to take the stated action? The possible choices are `Authorization`,
    `ReadOnlyAuthorization`, `DjangoAuthorization`, or your own custom authorization.
    In our case, we are using `ReadOnlyAuthorization` as we only want to allow read
    access to the users.'
  id: totrans-171
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The `filtering` parameter defines by which fields one can filter the lists
    in the URL query parameters. For example, with the current configuration, you
    can filter the items by titles that contain the word "`movie`": `http://127.0.0.1:8000/api/v1/bulletins/?format=json&username=admin&api_key=xxx&title__contains=movie`.'
  id: totrans-172
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Also, there is a `category` foreign key that is defined in `BulletinResource`
    with the `full=True` argument, meaning that the full list of category fields will
    be shown in the bulletin resource instead of an endpoint link.
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
- en: Besides JSON, `Tastypie` allows you to use other formats such as XML, YAML,
    and bplist.
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
- en: There is a lot more that you can do with APIs using Tastypie. To find out more
    details, check the official documentation at [http://django-tastypie.readthedocs.org/en/latest/](http://django-tastypie.readthedocs.org/en/latest/).
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
- en: See also
  id: totrans-176
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The *Creating filterable RSS feeds* recipe
  id: totrans-177
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The *Using Django REST framework to create API* recipe
  id: totrans-178
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Using Django REST framework to create API
  id: totrans-179
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Besides Tastypie, there is a newer and fresher framework to create API for your
    data transfers to and from third parties. That's Django REST Framework. This framework
    has more extensive documentation and Django-ish implementation, it is also more
    maintainable. Therefore, if you have to choose between Tastypie or Django REST
    Framework, I would recommend the latter one. In this recipe, you will learn how
    to use Django REST Framework in order to allow your project partners, mobile clients,
    or Ajax-based website to access data on your site to create, read, update, and
    delete.
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  id: totrans-181
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'First of all, install Django REST Framework and its optional dependencies in
    your virtual environment using the following commands:'
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  id: totrans-183
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: Add `rest_framework` to `INSTALLED_APPS` in the settings. Then, enhance the
    `bulletin_board` app that we defined in the *Creating filterable RSS feeds* recipe.
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  id: totrans-185
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'To integrate a new REST API in our `bulletin_board` app, execute the following
    steps:'
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
- en: 'Add the specific configurations to the settings:'
  id: totrans-187
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE27]'
  id: totrans-188
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE27]'
- en: 'In the `bulletin_board` app, create the `serializers.py` file with the following
    content:'
  id: totrans-189
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE28]'
  id: totrans-190
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE28]'
- en: 'Add two new class-based views to the `views.py` file in the `bulletin_board`
    app:'
  id: totrans-191
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE29]'
  id: totrans-192
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE29]'
- en: 'Finally, plug in the new views to the URL configuration:'
  id: totrans-193
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE30]'
  id: totrans-194
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE30]'
- en: How it works...
  id: totrans-195
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: What we created here is an API for the bulletin board, where one can read a
    paginated bulletin list; create a new bulletin; and read, change, or delete a
    single bulletin by ID. Reading is allowed without authentication; whereas, one
    has to have a user account with appropriate permissions to add, change, or delete
    a bulletin.
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
- en: 'Here''s how you can approach the created API:'
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
- en: '| URL | HTTP Method | Description |'
  id: totrans-198
  prefs: []
  type: TYPE_TB
- en: '| --- | --- | --- |'
  id: totrans-199
  prefs: []
  type: TYPE_TB
- en: '| `http://127.0.0.1:8000/rest-api/bulletin-board/` | `GET` | List bulletins
    paginated by 100 |'
  id: totrans-200
  prefs: []
  type: TYPE_TB
- en: '| `http://127.0.0.1:8000/rest-api/bulletin-board/` | `POST` | Create a new
    bulletin if the requesting user is authenticated and authorized to create bulletins
    |'
  id: totrans-201
  prefs: []
  type: TYPE_TB
- en: '| `http://127.0.0.1:8000/rest-api/bulletin-board/1/` | `GET` | Get a bulletin
    with the `1` ID |'
  id: totrans-202
  prefs: []
  type: TYPE_TB
- en: '| `http://127.0.0.1:8000/rest-api/bulletin-board/1/` | `PUT` | Update a bulletin
    with the `1` ID, if the user is authenticated and authorized to change bulletins
    |'
  id: totrans-203
  prefs: []
  type: TYPE_TB
- en: '| `http://127.0.0.1:8000/rest-api/bulletin-board/1/` | `DELETE` | Delete the
    bulletin with the `1` ID, if the user is authenticated and authorized to delete
    bulletins |'
  id: totrans-204
  prefs: []
  type: TYPE_TB
- en: 'How to use the API practically? For example, if you have the `requests` library
    installed, you can create a new bulletin in the Django shell as follows:'
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  id: totrans-206
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: 'Additionally, Django REST Framework provides you with a web-based API documentation
    that is shown when you access the API endpoints in a browser. There you can also
    try out the APIs by integrated forms, as shown in the following screenshot:'
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
- en: '![How it works...](img/B04912_09_02.jpg)'
  id: totrans-208
  prefs: []
  type: TYPE_IMG
- en: Let's take a quick look at how the code that we wrote works. In the settings,
    we have set the access to be dependent on the permissions of the Django system.
    For anonymous requests, only reading is allowed. Other access options include
    allowing any permission to everyone, allowing any permission only to authenticated
    users, allowing any permission to staff users, and so on. The full list can be
    found at [http://www.django-rest-framework.org/api-guide/permissions/](http://www.django-rest-framework.org/api-guide/permissions/).
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
- en: Then, in the settings, pagination is set. The current option is to have the
    `limit` and `offset` parameters like in an SQL query. Other options are to have
    either pagination by page numbers for rather static content or cursor pagination
    for real-time data. We set the default pagination to 100 items per page.
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
- en: Later we define serializers for categories and bulletins. They handle the data
    that will be shown in the output or validated by the input. In order to handle
    category retrieval or saving, we had to overwrite the `create()` and `update()`
    methods of `BulletinSerializer`. There are various ways to serialize relations
    in Django REST Framework and we chose the most verbose one in our example. To
    read more about how to serialize relations, refer to the documentation at [http://www.django-rest-framework.org/api-guide/relations/](http://www.django-rest-framework.org/api-guide/relations/).
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
- en: After defining the serializers, we created two class-based views to handle the
    API endpoints and plugged them in the URL configuration. In the URL configuration,
    we have a rule (`/api-auth/`) for browsable API pages, login, and logout.
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
- en: See also
  id: totrans-213
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The *Creating filterable RSS feeds* recipe
  id: totrans-214
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The *Using Tastypie to create API* recipe
  id: totrans-215
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The *Testing API created using Django REST framework* recipe in [Chapter 11](ch11.html
    "Chapter 11. Testing and Deployment"), *Testing and Deployment*
  id: totrans-216
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
