- en: Chapter 9. Data Import and Export
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In this chapter, we will cover the following recipes:'
  prefs: []
  type: TYPE_NORMAL
- en: Importing data from a local CSV file
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Importing data from a local Excel file
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Importing data from an external JSON file
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Importing data from an external XML file
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Creating filterable RSS feeds
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Using Tastypie to create API
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Using Django REST framework to create API
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Introduction
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: There are times when your data needs to be transported from a local format to
    the database, imported from external resources, or provided to third parties.
    In this chapter, we will take a look at some practical examples of how to write
    management commands and APIs to do this.
  prefs: []
  type: TYPE_NORMAL
- en: Importing data from a local CSV file
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The **comma-separated values** (**CSV**) format is probably the simplest way
    to store tabular data in a text file. In this recipe, we will create a management
    command that imports data from CSV to a Django database. We will need a CSV list
    of movies with a title, URL, and release year. You can easily create such files
    with Excel, Calc, or another spreadsheet application.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Create a `movies` app with the `Movie` model containing the following fields:
    `title`, `url`, and `release_year`. Place the app under `INSTALLED_APPS` in the
    settings.'
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Follow these steps to create and use a management command that imports movies
    from a local CSV file:'
  prefs: []
  type: TYPE_NORMAL
- en: In the `movies` app, create a `management` directory and then a `commands` directory
    in the new `management` directory. Put the empty `__init__.py` files in both new
    directories to make them Python packages.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Add an `import_movies_from_csv.py` file there with the following content:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'To run the import, call the following in the command line:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: How it works...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'For a management command, we need to create a `Command` class deriving from
    `BaseCommand` and overwriting the `add_arguments()` and `handle()` method. The
    `help` attribute defines the help text for the management command. It can be seen
    when you type the following in the command line:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: Django management commands use the built-in argparse module to parse the passed
    arguments. The `add_arguments()` method defines what positional or named arguments
    should be passed to the management command. In our case, we will add a positional
    `file_path` argument of Unicode type. By `nargs` set to the `1` attribute, we
    allow only one value. To learn about the other arguments that you can define and
    how to do this, refer to the official argparse documentation at [https://docs.python.org/2/library/argparse.html#the-add-argument-method](https://docs.python.org/2/library/argparse.html#the-add-argument-method).
  prefs: []
  type: TYPE_NORMAL
- en: 'At the beginning of the `handle()` method, the `verbosity` argument is checked.
    Verbosity defines how verbose the command is, from `0` not giving any output to
    the command-line tool to `3` being very verbose. You can pass this argument to
    the command as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: Then, we also expect the filename as the first positional argument. The `options["file_path"]`
    returns a list of the values defined in the nargs, therefore, it is one value
    in this case.
  prefs: []
  type: TYPE_NORMAL
- en: We open the given file and pass its pointer to `csv.reader`. Then, for each
    line in the file, we will create a new `Movie` object if a matching movie doesn't
    exist yet. The management command will print out the imported movie titles to
    the console, unless you set the verbosity to `0`.
  prefs: []
  type: TYPE_NORMAL
- en: Tip
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: If you want to debug the errors of a management command while developing it,
    pass the `--traceback` parameter for it. If an error occurs, you will see the
    full stack trace of the problem.
  prefs: []
  type: TYPE_NORMAL
- en: There's more...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: You can learn more about the CSV library from the official documentation at
    [https://docs.python.org/2/library/csv.html](https://docs.python.org/2/library/csv.html).
  prefs: []
  type: TYPE_NORMAL
- en: See also
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The *Importing data from a local Excel file* recipe
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Importing data from a local Excel file
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Another popular format to store tabular data is an Excel spread sheet. In this
    recipe, we will import movies from a file of this format.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Let''s start with the `movies` app that we created in the previous recipe.
    Install the `xlrd` package to read Excel files, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: How to do it...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Follow these steps to create and use a management command that imports movies
    from a local XLS file:'
  prefs: []
  type: TYPE_NORMAL
- en: If you haven't done that, in the `movies` app, create a `management` directory
    and then a `commands` directory in the new `management` directory. Put the empty
    `__init__.py` files in both the new directories to make them Python packages.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Add the `import_movies_from_xls.py` file with the following content:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'To run the import, call the following in the command line:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: How it works...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The principle of importing from an XLS file is the same as with CSV. We open
    the file, read it row by row, and create the `Movie` objects from the provided
    data. A detailed explanation is as follows.
  prefs: []
  type: TYPE_NORMAL
- en: Excel files are workbooks containing sheets as different tabs.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: We are using the `xlrd` library to open a file passed as a positional argument
    to the command. Then, we will read the first sheet from the workbook.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Afterwards, we will read the rows one by one (except the first row with the
    column titles) and create the `Movie` objects from them. Once again, the management
    command will print out the imported movie titles to the console, unless you set
    the verbosity to `0`.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: There's more...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: You can learn more about how to work with Excel files at [http://www.python-excel.org/](http://www.python-excel.org/).
  prefs: []
  type: TYPE_NORMAL
- en: See also
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The *Importing data from a local CSV file* recipe
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Importing data from an external JSON file
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The `Last.fm` music website has an API under the [http://ws.audioscrobbler.com/](http://ws.audioscrobbler.com/)
    domain that you can use to read the albums, artists, tracks, events, and more.
    The API allows you to either use the JSON or XML format. In this recipe, we will
    import the top tracks tagged disco using the JSON format.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Follow these steps in order to import data in the JSON format from `Last.fm`:'
  prefs: []
  type: TYPE_NORMAL
- en: To use `Last.fm`, you need to register and get an API key. The API key can be
    created at [http://www.last.fm/api/account/create](http://www.last.fm/api/account/create).
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The API key has to be set in the settings as `LAST_FM_API_KEY`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Also, install the `requests` library in your virtual environment using the
    following command:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Let''s check the structure of the JSON endpoint ([http://ws.audioscrobbler.com/2.0/?method=tag.gettoptracks&tag=disco&api_key=xxx&format=json](http://ws.audioscrobbler.com/2.0/?method=tag.gettoptracks&tag=disco&api_key=xxx&format=json)):'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: We want to read the track name, artist, URL, and medium-sized images.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Follow these steps to create a `Track` model and management command, which
    imports top tracks from `Last.fm` to the database:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s create a `music` app with a simple `Track` model, as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Then, create the management command as shown in the following:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'As the list is paginated, we will add the `save_page()` method to the `Command`
    class to save a single page of tracks. This method takes the dictionary with the
    top tracks from a single page as a parameter, as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'To run the import, call the following in the command line:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: How it works...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The optional named `max_pages` argument limits the imported data to three pages.
    Just skip it if you want to download all the available top tracks; however, beware
    that there are above 26,000 pages as detailed in the `totalPages` value and this
    will take a while.
  prefs: []
  type: TYPE_NORMAL
- en: Using the `requests.get()` method, we read the data from `Last.fm`, passing
    the `params` query parameters. The response object has a built-in method called
    `json()`, which converts a JSON string and returns a parsed dictionary.
  prefs: []
  type: TYPE_NORMAL
- en: We read the total pages value from this dictionary and then save the first page
    of results. Then, we get the second and later pages one by one and save them.
    One interesting part in the import is downloading and saving the image. Here,
    we also use `request.get()` to retrieve the image data and then we pass it to
    `File` through `StringIO`, which is accordingly used in the `image.save()` method.
    The first parameter of `image.save()` is a filename that will be overwritten anyway
    by the value from the `upload_to` function and is necessary only for the file
    extension.
  prefs: []
  type: TYPE_NORMAL
- en: See also
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The *Importing data from an external XML file* recipe
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Importing data from an external XML file
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The `Last.fm` file also allows you to take data from their services in XML format.
    In this recipe, I will show you how to do this.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'To prepare importing top tracks from `Last.fm` in the XML format, follow these
    steps:'
  prefs: []
  type: TYPE_NORMAL
- en: Start with the first three steps from the *Getting ready* section in the *Importing
    data from an external JSON file* recipe.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Then, let''s check the structure of the XML endpoint ([http://ws.audioscrobbler.com/2.0/?method=tag.gettoptracks&tag=disco&api_key=xxx&format=xml](http://ws.audioscrobbler.com/2.0/?method=tag.gettoptracks&tag=disco&api_key=xxx&format=xml)),
    as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: How to do it...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Execute the following steps one by one to import the top tracks from `Last.fm`
    in the XML format:'
  prefs: []
  type: TYPE_NORMAL
- en: Create a `music` app with a `Track` model similar to the previous recipe, if
    you've not already done this.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Then, create an `import_music_from_lastfm_as_xml.py` management command. We
    will be using the `ElementTree` XML API that comes with Python to parse the XML
    nodes, as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'As the list is paginated, we will add a `save_page()` method to the `Command`
    class to save a single page of tracks. This method takes the root node of the
    XML as a parameter, as shown in the following:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'To run the import, call the following in the command line:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: How it works...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The process is analogous to the JSON approach. Using the `requests.get()` method,
    we read the data from `Last.fm`, passing the query parameters as `params`. The
    XML content of the response is passed to the `ElementTree` parser and the root
    node is returned.
  prefs: []
  type: TYPE_NORMAL
- en: The `ElementTree` nodes have the `find()` and `findall()` methods, where you
    can pass XPath queries to filter out specific subnodes.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following is a table of the available XPath syntax supported by `ElementTree`:'
  prefs: []
  type: TYPE_NORMAL
- en: '| XPath Syntax Component | Meaning |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| `tag` | This selects all the child elements with the given tag. |'
  prefs: []
  type: TYPE_TB
- en: '| `*` | This selects all the child elements. |'
  prefs: []
  type: TYPE_TB
- en: '| `.` | This selects the current node. |'
  prefs: []
  type: TYPE_TB
- en: '| `//` | This selects all the subelements on all the levels beneath the current
    element. |'
  prefs: []
  type: TYPE_TB
- en: '| `..` | This selects the parent element. |'
  prefs: []
  type: TYPE_TB
- en: '| `[@attrib]` | This selects all the elements that have the given attribute.
    |'
  prefs: []
  type: TYPE_TB
- en: '| `[@attrib=''value'']` | This selects all the elements for which the given
    attribute has the given value. |'
  prefs: []
  type: TYPE_TB
- en: '| `[tag]` | This selects all the elements that have a child named tag. Only
    immediate children are supported. |'
  prefs: []
  type: TYPE_TB
- en: '| `[position]` | This selects all the elements that are located at the given
    position. The position can either be an integer (`1` is the first position), the
    `last()`expression (for the last position), or a position relative to the last
    position (for example, `last()-1`). |'
  prefs: []
  type: TYPE_TB
- en: Therefore, using `root.find("tracks").attrib["totalPages"]`, we read the total
    amount of pages. We will save the first page and then go through the other pages
    one by one and save them too.
  prefs: []
  type: TYPE_NORMAL
- en: In the `save_page()` method, `root.findall("tracks/track")` returns an iterator
    through the `<track>` nodes under the `<tracks>` node. With `track_node.find("image[@size='medium']")`,
    we get the medium-sized image.
  prefs: []
  type: TYPE_NORMAL
- en: There's more...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: You can learn more about XPath at [https://en.wikipedia.org/wiki/XPath](https://en.wikipedia.org/wiki/XPath).
  prefs: []
  type: TYPE_NORMAL
- en: The full documentation of `ElementTree` can be found at [https://docs.python.org/2/library/xml.etree.elementtree.html](https://docs.python.org/2/library/xml.etree.elementtree.html).
  prefs: []
  type: TYPE_NORMAL
- en: See also
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The *Importing data from an external JSON file* recipe
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Creating filterable RSS feeds
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Django comes with a syndication feed framework that allows you to create RSS
    and Atom feeds easily. RSS and Atom feeds are XML documents with specific semantics.
    They can be subscribed in an RSS reader such as Feedly or they can be aggregated
    in other websites, mobile applications, or desktop applications. In this recipe,
    we will create `BulletinFeed`, which provides a bulletin board with images. Moreover,
    the results will be filterable by URL query parameters.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Create a new `bulletin_board` app and put it under `INSTALLED_APPS` in the settings.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'We will create a `Bulletin` model and an RSS feed for it. We will be able to
    filter the RSS feed by type or category so that it is possible to only subscribe
    to the bulletins that are, for example, offering used books:'
  prefs: []
  type: TYPE_NORMAL
- en: 'In the `models.py` file of this app, add the `Category` and `Bulletin` models
    with a foreign key relationship between them, as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Then, create `BulletinFilterForm` that allows the visitor to filter the bulletins
    by type and category, as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Add a `feeds.py` file with the `BulletinFeed` class, as shown in the following:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Create a template for the bulletin description that will be provided in the
    feed, as shown in the following:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Create a URL configuration for the bulletin board app and include it in the
    root URL configuration, as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'You will also need the views and templates for the filterable list and details
    of the bulletins. In the `Bulletin` list page template, add the following link:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: How it works...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Therefore, if you have some data in the database and you open `http://127.0.0.1:8000/bulletin-board/rss/?bulletin_type=offering&category=4`
    in your browser, you will get an RSS feed of bulletins with the `Offering` type
    and the `4` category ID.
  prefs: []
  type: TYPE_NORMAL
- en: The `BulletinFeed` class has the `get_objects()` method that takes the current
    `HttpRequest` and defines the `obj` dictionary used in other methods of the same
    class. The `obj` dictionary contains the bulletin type, category, and current
    query string.
  prefs: []
  type: TYPE_NORMAL
- en: The `title()` method returns the title of the feed. It can either be generic
    or related to the selected bulletin type or category. The `link()` method returns
    the link to the original bulletin list with the filtering done. The `feed_url()`
    method returns the URL of the current feed. The `items()` method does the filtering
    itself and returns a filtered `QuerySet` of bulletins. Finally, the `item_pubdate()`
    method returns the creation date of the bulletin.
  prefs: []
  type: TYPE_NORMAL
- en: To see all the available methods and properties of the `Feed` class that we
    are extending, refer to the following documentation at [https://docs.djangoproject.com/en/1.8/ref/contrib/syndication/#feed-class-reference](https://docs.djangoproject.com/en/1.8/ref/contrib/syndication/#feed-class-reference).
  prefs: []
  type: TYPE_NORMAL
- en: The other parts of the code are self-explanatory.
  prefs: []
  type: TYPE_NORMAL
- en: See also
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The *Creating a model mixin with URL-related methods* recipe in [Chapter 2](ch02.html
    "Chapter 2. Database Structure"), *Database Structure*
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The *Creating a model mixin to handle creation and modification dates* recipe
    in [Chapter 2](ch02.html "Chapter 2. Database Structure"), *Database Structure*
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The *Using Tastypie to create API* recipe
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Using Tastypie to create API
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '**Tastypie** is a framework for Django to create web service **Application
    Program Interface** (**API**). It supports full `GET`/`POST`/`PUT`/`DELETE`/`PATCH
    HTTP` methods to deal with online resources. It also supports different types
    of authentication and authorization, serialization, caching, throttling, and so
    on. In this recipe, you will learn how to provide bulletins to third parties for
    reading, that is, we will implement only the `GET HTTP` method.'
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'First of all, install `Tastypie` in your virtual environment using the following
    command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: Add Tastypie to `INSTALLED_APPS` in the settings. Then, enhance the `bulletin_board`
    app that we defined in the *Creating filterable RSS feeds* recipe.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'We will create an API for bulletins and inject it in the URL configuration
    as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: 'In the `bulletin_board` app, create an `api.py` file with two resources, `CategoryResource`
    and `BulletinResource`, as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'In the main URL configuration, include the API URLs, as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Create a Tastypie API key for the admin user in the model administration. To
    do this, navigate to **Tastypie** | **Api key** | **Add Api key**, select the
    admin user, and save the entry. This will generate a random API key, as shown
    in the following screenshot:![How to do it...](img/B04912_09_01.jpg)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Then, you can open this URL to see the JSON response in action (simply replace
    xxx with your API key): `http://127.0.0.1:8000/api/v1/bulletins/?format=json&username=admin&api_key=xxx`.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: How it works...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Each endpoint of `Tastypie` should have a class extending `ModelResource` defined.
    Similar to the Django models, the configuration of the resource is set in the
    `Meta` class:'
  prefs: []
  type: TYPE_NORMAL
- en: The `queryset` parameter defines the `QuerySet` of objects to list.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The `resource_name` parameter defines the name of the URL endpoint.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The `fields` parameter lists out the fields of the model that should be shown
    in the API.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The `allowed_methods` parameter lists out the request methods, such as `get`,
    `post`, `put`, `delete`, and `patch`.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The `authentication` parameter defines how third parties can authenticate themselves
    when connecting to the API. The available options are `Authentication`, `BasicAuthentication`,
    `ApiKeyAuthentication`, `SessionAuthentication`, `DigestAuthentication`, `OAuthAuthentication`,
    `MultiAuthentication`, or your own custom authentication. In our case, we are
    using `ApiKeyAuthentication` as we want each user to use `username` and `api_key`.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The `authorization` parameter answers the authorization question: is permission
    granted to this user to take the stated action? The possible choices are `Authorization`,
    `ReadOnlyAuthorization`, `DjangoAuthorization`, or your own custom authorization.
    In our case, we are using `ReadOnlyAuthorization` as we only want to allow read
    access to the users.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The `filtering` parameter defines by which fields one can filter the lists
    in the URL query parameters. For example, with the current configuration, you
    can filter the items by titles that contain the word "`movie`": `http://127.0.0.1:8000/api/v1/bulletins/?format=json&username=admin&api_key=xxx&title__contains=movie`.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Also, there is a `category` foreign key that is defined in `BulletinResource`
    with the `full=True` argument, meaning that the full list of category fields will
    be shown in the bulletin resource instead of an endpoint link.
  prefs: []
  type: TYPE_NORMAL
- en: Besides JSON, `Tastypie` allows you to use other formats such as XML, YAML,
    and bplist.
  prefs: []
  type: TYPE_NORMAL
- en: There is a lot more that you can do with APIs using Tastypie. To find out more
    details, check the official documentation at [http://django-tastypie.readthedocs.org/en/latest/](http://django-tastypie.readthedocs.org/en/latest/).
  prefs: []
  type: TYPE_NORMAL
- en: See also
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The *Creating filterable RSS feeds* recipe
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The *Using Django REST framework to create API* recipe
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Using Django REST framework to create API
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Besides Tastypie, there is a newer and fresher framework to create API for your
    data transfers to and from third parties. That's Django REST Framework. This framework
    has more extensive documentation and Django-ish implementation, it is also more
    maintainable. Therefore, if you have to choose between Tastypie or Django REST
    Framework, I would recommend the latter one. In this recipe, you will learn how
    to use Django REST Framework in order to allow your project partners, mobile clients,
    or Ajax-based website to access data on your site to create, read, update, and
    delete.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'First of all, install Django REST Framework and its optional dependencies in
    your virtual environment using the following commands:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: Add `rest_framework` to `INSTALLED_APPS` in the settings. Then, enhance the
    `bulletin_board` app that we defined in the *Creating filterable RSS feeds* recipe.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'To integrate a new REST API in our `bulletin_board` app, execute the following
    steps:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Add the specific configurations to the settings:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'In the `bulletin_board` app, create the `serializers.py` file with the following
    content:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Add two new class-based views to the `views.py` file in the `bulletin_board`
    app:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Finally, plug in the new views to the URL configuration:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: How it works...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: What we created here is an API for the bulletin board, where one can read a
    paginated bulletin list; create a new bulletin; and read, change, or delete a
    single bulletin by ID. Reading is allowed without authentication; whereas, one
    has to have a user account with appropriate permissions to add, change, or delete
    a bulletin.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here''s how you can approach the created API:'
  prefs: []
  type: TYPE_NORMAL
- en: '| URL | HTTP Method | Description |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| `http://127.0.0.1:8000/rest-api/bulletin-board/` | `GET` | List bulletins
    paginated by 100 |'
  prefs: []
  type: TYPE_TB
- en: '| `http://127.0.0.1:8000/rest-api/bulletin-board/` | `POST` | Create a new
    bulletin if the requesting user is authenticated and authorized to create bulletins
    |'
  prefs: []
  type: TYPE_TB
- en: '| `http://127.0.0.1:8000/rest-api/bulletin-board/1/` | `GET` | Get a bulletin
    with the `1` ID |'
  prefs: []
  type: TYPE_TB
- en: '| `http://127.0.0.1:8000/rest-api/bulletin-board/1/` | `PUT` | Update a bulletin
    with the `1` ID, if the user is authenticated and authorized to change bulletins
    |'
  prefs: []
  type: TYPE_TB
- en: '| `http://127.0.0.1:8000/rest-api/bulletin-board/1/` | `DELETE` | Delete the
    bulletin with the `1` ID, if the user is authenticated and authorized to delete
    bulletins |'
  prefs: []
  type: TYPE_TB
- en: 'How to use the API practically? For example, if you have the `requests` library
    installed, you can create a new bulletin in the Django shell as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: 'Additionally, Django REST Framework provides you with a web-based API documentation
    that is shown when you access the API endpoints in a browser. There you can also
    try out the APIs by integrated forms, as shown in the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![How it works...](img/B04912_09_02.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Let's take a quick look at how the code that we wrote works. In the settings,
    we have set the access to be dependent on the permissions of the Django system.
    For anonymous requests, only reading is allowed. Other access options include
    allowing any permission to everyone, allowing any permission only to authenticated
    users, allowing any permission to staff users, and so on. The full list can be
    found at [http://www.django-rest-framework.org/api-guide/permissions/](http://www.django-rest-framework.org/api-guide/permissions/).
  prefs: []
  type: TYPE_NORMAL
- en: Then, in the settings, pagination is set. The current option is to have the
    `limit` and `offset` parameters like in an SQL query. Other options are to have
    either pagination by page numbers for rather static content or cursor pagination
    for real-time data. We set the default pagination to 100 items per page.
  prefs: []
  type: TYPE_NORMAL
- en: Later we define serializers for categories and bulletins. They handle the data
    that will be shown in the output or validated by the input. In order to handle
    category retrieval or saving, we had to overwrite the `create()` and `update()`
    methods of `BulletinSerializer`. There are various ways to serialize relations
    in Django REST Framework and we chose the most verbose one in our example. To
    read more about how to serialize relations, refer to the documentation at [http://www.django-rest-framework.org/api-guide/relations/](http://www.django-rest-framework.org/api-guide/relations/).
  prefs: []
  type: TYPE_NORMAL
- en: After defining the serializers, we created two class-based views to handle the
    API endpoints and plugged them in the URL configuration. In the URL configuration,
    we have a rule (`/api-auth/`) for browsable API pages, login, and logout.
  prefs: []
  type: TYPE_NORMAL
- en: See also
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The *Creating filterable RSS feeds* recipe
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The *Using Tastypie to create API* recipe
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The *Testing API created using Django REST framework* recipe in [Chapter 11](ch11.html
    "Chapter 11. Testing and Deployment"), *Testing and Deployment*
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
