<html><head></head><body>
        <section>

                            <header>
                    <h1 class="header-title">The Iterator Pattern</h1>
                </header>
            
            <article>
                
<p>We've discussed how many of Python's built-ins and idioms seem, at first blush, to fly in the face of object-oriented principles, but are actually providing access to real objects under the hood. In this chapter, we'll discuss how the <kbd>for</kbd> loop, which seems so structured, is actually a lightweight wrapper around a set of object-oriented principles. We'll also see a variety of extensions to this syntax that automatically create even more types of object. We will cover the following topics:</p>
<ul>
<li>What design patterns are</li>
<li>The iterator protocol—one of the most powerful design patterns</li>
<li>List, set, and dictionary comprehensions</li>
<li>Generators and coroutines</li>
</ul>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Design patterns in brief</h1>
                </header>
            
            <article>
                
<p>When engineers and architects decide to build a bridge, or a tower, or a building, they follow certain principles to ensure structural integrity. There are various possible designs for bridges (suspension and cantilever, for example), but if the engineer doesn't use one of the standard designs, and doesn't have a brilliant new design, it is likely the bridge he/she designs will collapse.</p>
<p>Design patterns are an attempt to bring this same formal definition for correctly designed structures to software engineering. There are many different design patterns to solve different general problems. Design patterns typically solve a specific common problem faced by developers in some specific situation. The design pattern is then a suggestion as to the ideal solution for that problem, in terms of object-oriented design.</p>
<p>Knowing a design pattern and choosing to use it in our software does not, however, guarantee that we are creating a <em>correct</em> solution. In 1907, the Québec Bridge (to this day, the longest cantilever bridge in the world) collapsed before construction was completed, because the engineers who designed it grossly underestimated the weight of the steel used to construct it. Similarly, in software development, we may incorrectly choose or apply a design pattern, and create software that <em>collapses</em> under normal operating situations or when stressed beyond its original design limits.</p>
<p>Any one design pattern proposes a set of objects interacting in a specific way to solve a general problem. The job of the programmer is to recognize when they are facing a specific version of such a problem, then to choose and adapt the general design in their precise needs.</p>
<p>In this chapter, we'll be covering the iterator design pattern. This pattern is so powerful and pervasive that the Python developers have provided multiple syntaxes to access the object-oriented principles underlying the pattern. We will be covering other design patterns in the next two chapters. Some of them have language support and some don't, but none of them is so intrinsically a part of the Python coder's daily life as the iterator pattern.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Iterators</h1>
                </header>
            
            <article>
                
<p>In typical design pattern parlance, an iterator is an object with a <kbd>next()</kbd> method and a <kbd>done()</kbd> method; the latter returns <kbd>True</kbd> if there are no items left in the sequence. In a programming language without built-in support for iterators, the iterator would be looped over like this:</p>
<pre>while not iterator.done(): 
    item = iterator.next() 
    # do something with the item </pre>
<p>In Python, iteration is a special feature, so the method gets a special name, <kbd>__next__</kbd>. This method can be accessed using the <kbd>next(iterator)</kbd> built-in. Rather than a <kbd>done</kbd> method, Python's iterator protocol raises <kbd>StopIteration</kbd> to notify the loop that it has completed. Finally, we have the much more readable <kbd>foriteminiterator</kbd> syntax to actually access items in an iterator instead of messing around with a <kbd>while</kbd> loop. Let's look at these in more detail.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">The iterator protocol</h1>
                </header>
            
            <article>
                
<p>The <kbd>Iterator</kbd><span> abstract base class,</span> in the <kbd>collections.abc</kbd> module, defines the iterator protocol in Python. As mentioned, it must have a <kbd>__next__</kbd> method that the <kbd>for</kbd> loop (and other features that support iteration) can call to get a new element from the sequence. In addition, every iterator must also fulfill the <kbd>Iterable</kbd> interface. Any class that provides an <kbd>__iter__</kbd> method is iterable. That method must return an <kbd>Iterator</kbd> instance that will cover all the elements in that class.</p>
<p>This might sound a bit confusing, so have a look at the following example, but note that this is a very verbose way to solve this problem. It clearly explains iteration and the two protocols in question, but we'll be looking at several more readable ways to get this effect later in this chapter:</p>
<pre>class CapitalIterable: 
    def __init__(self, string): 
        self.string = string 
 
<strong>    def __iter__(self): 
        return CapitalIterator(self.string)</strong> 
 
 
class CapitalIterator: 
    def __init__(self, string): 
        self.words = [w.capitalize() for w in string.split()] 
        self.index = 0 
 
<strong>    def __next__(self):</strong> 
        if self.index == len(self.words): 
<strong>            raise StopIteration()</strong> 
 
        word = self.words[self.index] 
        self.index += 1 
        return word 
 
    def __iter__(self): 
        return self </pre>
<p>This example defines an <kbd>CapitalIterable</kbd> class whose job is to loop over each of the words in a string and output them with the first letter capitalized. Most of the work of that iterable is passed to the <kbd>CapitalIterator</kbd> implementation. The canonical way to interact with this iterator is as follows:</p>
<pre><strong>&gt;&gt;&gt; iterable = CapitalIterable('the quick brown fox jumps over the lazy dog')</strong>
<strong>&gt;&gt;&gt; iterator = iter(iterable)</strong>
<strong>&gt;&gt;&gt; while True:</strong>
<strong>...     try:</strong>
<strong>...         print(next(iterator))</strong>
<strong>...     except StopIteration:</strong>
<strong>...         break</strong>
<strong>...     </strong>
<strong>The</strong>
<strong>Quick</strong>
<strong>Brown</strong>
<strong>Fox</strong>
<strong>Jumps</strong>
<strong>Over</strong>
<strong>The</strong>
<strong>Lazy</strong>
<strong>Dog</strong>  </pre>
<p>This example first constructs an iterable and retrieves an iterator from it. The distinction may need explanation; the iterable is an object with elements that can be looped over. Normally, these elements can be looped over multiple times, maybe even at the same time or in overlapping code. The iterator, on the other hand, represents a specific location in that iterable; some of the items have been consumed and some have not. Two different iterators might be at different places in the list of words, but any one iterator can mark only one place.</p>
<p>Each time <kbd>next()</kbd> is called on the iterator, it returns another token from the iterable, in order. Eventually, the iterator will be exhausted (won't have any more elements to return), in which case <kbd>Stopiteration</kbd> is raised, and we break out of the loop.</p>
<p>Of course, we already know a much simpler syntax for constructing an iterator from an iterable:</p>
<pre><strong>&gt;&gt;&gt; for i in iterable:</strong>
<strong>...     print(i)</strong>
<strong>...     </strong>
<strong>The</strong>
<strong>Quick</strong>
<strong>Brown</strong>
<strong>Fox</strong>
<strong>Jumps</strong>
<strong>Over</strong>
<strong>The</strong>
<strong>Lazy</strong>
<strong>Dog</strong>  </pre>
<p>As you can see, the <kbd>for</kbd> statement, in spite of not looking remotely object-oriented, is actually a shortcut to some obviously object-oriented design principles. Keep this in mind as we discuss comprehensions, as they, too, appear to be the polar opposite of an object-oriented tool. Yet, they use the exact same iteration protocol as <kbd>for</kbd> loops and are just another kind of shortcut.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Comprehensions</h1>
                </header>
            
            <article>
                
<p>Comprehensions are simple, but powerful, syntaxes that allow us to transform or filter an iterable object in as little as one line of code. The resultant object can be a perfectly normal list, set, or dictionary, or it can be a generator expression that can be efficiently consumed while keeping just one element in memory at a time.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">List comprehensions</h1>
                </header>
            
            <article>
                
<p>List comprehensions are one of the most powerful tools in Python, so people tend to think of them as advanced. They're not. Indeed, I've taken the liberty of littering previous examples with comprehensions, assuming you would understand them. While it's true that advanced programmers use comprehensions a lot, it's not because they're advanced. It's because they're trivial, and handle some of the most common operations in software development.</p>
<p>Let's have a look at one of those common operations; namely, converting a list of items into a list of related items. Specifically, let's assume we just read a list of strings from a file, and now we want to convert it to a list of integers. We know every item in the list is an integer, and we want to do some activity (say, calculate an average) on those numbers. Here's one simple way to approach it:</p>
<pre>input_strings = ["1", "5", "28", "131", "3"]
 
output_integers = [] 
for num in input_strings: 
    output_integers.append(int(num)) </pre>
<p>This works fine and it's only three lines of code. If you aren't used to comprehensions, you may not even think it looks ugly! Now, look at the same code using a list comprehension:</p>
<pre>input_strings = ["1", "5", "28", "131", "3"]<br/><strong>output_integers = [int(num) for num in input_strings]</strong> </pre>
<p>We're down to one line and, importantly for performance, we've dropped an <kbd>append</kbd> method call for each item in the list. Overall, it's pretty easy to tell what's going on, even if you're not used to comprehension syntax.</p>
<p>The square brackets indicate, as always, that we're creating a list. Inside this list is a <kbd>for</kbd> loop that iterates over each item in the input sequence. The only thing that may be confusing is what's happening between the list's opening brace and the start of the <kbd>for</kbd> loop. Whatever happens here is applied to <em>each</em> of the items in the input list. The item in question is referenced by the <kbd>num</kbd> variable from the loop. So, it's calling the <kbd>int</kbd> function for each element and storing the resulting integer in the new list.</p>
<p>That's all there is to a basic list comprehension. Comprehensions are highly optimized C code; list comprehensions are far faster than <kbd>for</kbd> loops when looping over a large number of items. If readability alone isn't a convincing reason to use them as much as possible, speed should be.</p>
<p>Converting one list of items into a related list isn't the only thing we can do with a list comprehension. We can also choose to exclude certain values by adding an <kbd>if</kbd> statement inside the comprehension. Have a look:</p>
<pre><strong>output_integers = [int(num) for num in input_strings if len(num) &lt; 3]</strong></pre>
<p>All that's different between this example and the previous one is the <kbd>if len(num) &lt; 3</kbd> part. This extra code excludes any strings with more than two characters. The <kbd>if</kbd> statement is applied to each element <strong>before</strong> the <kbd>int</kbd> function, so it's testing the length of a string. Since our input strings are all integers at heart, it excludes any number over 99.</p>
<p>List comprehensions are used to map input values to output values, applying a filter along the way to include or exclude any values that meet a specific condition.</p>
<p>Any iterable can be the input to a list comprehension. In other words, anything we can wrap in a <kbd>for</kbd> loop can also be placed inside a comprehension. For example, text files are iterable; each call to <kbd>__next__</kbd> on the file's iterator will return one line of the file. We could load a tab-delimited file where the first line is a header row into a dictionary using the <kbd>zip</kbd> function:</p>
<pre>import sys<br/><br/>filename = sys.argv[1]<br/><br/>with open(filename) as file:<br/>    header = file.readline().strip().split("\t")<br/><strong> contacts = [</strong><br/><strong> dict(</strong><br/><strong> zip(header, line.strip().split("\t")))</strong><br/><strong> for line in file</strong><br/><strong> ]</strong><br/><br/>for contact in contacts:<br/>    print("email: {email} -- {last}, {first}".format(**contact))<br/><br/></pre>
<p>This time, I've added some whitespace to make it more readable (list comprehensions don't <em>have</em> to fit on one line). This example creates a list of dictionaries from the zipped header and split lines for each line in the file.</p>
<p>Er, what? Don't worry if that code or explanation doesn't make sense; it's confusing. One list comprehension is doing a pile of work here, and the code is hard to understand, read, and ultimately, maintain. This example shows that list comprehensions aren't always the best solution; most programmers would agree that a <kbd>for</kbd> loop would be more readable than this version.</p>
<div class="packt_tip">Remember: the tools we are provided with should not be abused! Always pick the right tool for the job, which is always to write maintainable code.</div>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Set and dictionary comprehensions</h1>
                </header>
            
            <article>
                
<p>Comprehensions aren't restricted to lists. We can use a similar syntax with braces to create sets and dictionaries as well. Let's start with sets. One way to create a set is to wrap a list comprehension in the <kbd>set()</kbd> constructor, which converts it to a set. But why waste memory on an intermediate list that gets discarded, when we can create a set directly?</p>
<p>Here's an example that uses a named tuple to model author/title/genre triads, and then retrieves a set of all the authors that write in a specific genre:</p>
<pre>from collections import namedtuple<br/><br/>Book = namedtuple("Book", "author title genre")<br/>books = [<br/>    Book("Pratchett", "Nightwatch", "fantasy"),<br/>    Book("Pratchett", "Thief Of Time", "fantasy"),<br/>    Book("Le Guin", "The Dispossessed", "scifi"),<br/>    Book("Le Guin", "A Wizard Of Earthsea", "fantasy"),<br/>    Book("Turner", "The Thief", "fantasy"),<br/>    Book("Phillips", "Preston Diamond", "western"),<br/>    Book("Phillips", "Twice Upon A Time", "scifi"),<br/>]<br/><br/><strong>fantasy_authors = {b.author for b in books if b.genre == "fantasy"}</strong><br/><br/></pre>
<p>The highlighted set comprehension sure is short in comparison to the demo-data setup! If we were to use a list comprehension, of course, Terry Pratchett would have been listed twice. As it is, the nature of sets removes the duplicates, and we end up with the following:</p>
<pre><strong>&gt;&gt;&gt; fantasy_authors</strong>
<strong>{'Turner', 'Pratchett', 'Le Guin'}</strong>  </pre>
<p>Still using braces, we can introduce a colon to create a dictionary comprehension. This converts a sequence into a dictionary using <em>key:value</em> pairs. For example, it may be useful to quickly look up the author or genre in a dictionary if we know the title. We can use a dictionary comprehension to map titles to <kbd>books</kbd> objects:</p>
<pre>fantasy_titles = {b.title: b for b in books if b.genre == "fantasy"}</pre>
<p>Now, we have a dictionary, and can look up books by title using the normal syntax.</p>
<p>In summary, comprehensions are not advanced Python, nor are they <em>non-object-oriented</em> tools that should be avoided. They are simply a more concise and optimized syntax for creating a list, set, or dictionary from an existing sequence.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Generator expressions</h1>
                </header>
            
            <article>
                
<p>Sometimes we want to process a new sequence without pulling a new list, set, or dictionary into system memory. If we're just looping over items one at a time, and don't actually care about having a complete container (such as a list or dictionary) created, creating that container is a waste of memory. When processing one item at a time, we only need the current object available in memory at any one moment. But when we create a container, all the objects have to be stored in that container before we start processing them.</p>
<p>For example, consider a program that processes log files. A very simple log might contain information in this format:</p>
<pre><strong>Jan 26, 2015 11:25:25 DEBUG This is a debugging message. Jan 26, 2015 11:25:36 INFO This is an information method. Jan 26, 2015 11:25:46 WARNING This is a warning. It could be serious. Jan 26, 2015 11:25:52 WARNING Another warning sent. Jan 26, 2015 11:25:59 INFO Here's some information. Jan 26, 2015 11:26:13 DEBUG Debug messages are only useful if you want to figure something out. Jan 26, 2015 11:26:32 INFO Information is usually harmless, but helpful. Jan 26, 2015 11:26:40 WARNING Warnings should be heeded. Jan 26, 2015 11:26:54 WARNING Watch for warnings.</strong> </pre>
<p>Log files for popular web servers, databases, or email servers can contain many gigabytes of data (I once had to clean nearly 2 terabytes of logs off a misbehaving system). If we want to process each line in the log, we can't use a list comprehension; it would create a list containing every line in the file. This probably wouldn't fit in RAM and could bring the computer to its knees, depending on the operating system.</p>
<p>If we used a <kbd>for</kbd> loop on the log file, we could process one line at a time before reading the next one into memory. Wouldn't be nice if we could use comprehension syntax to get the same effect?</p>
<p>This is where generator expressions come in. They use the same syntax as comprehensions, but they don't create a final container object. To create a generator expression, wrap the comprehension in <kbd>()</kbd> instead of <kbd>[]</kbd> or <kbd>{}</kbd>.</p>
<p>The following code parses a log file in the previously presented format and outputs a new log file that contains only the <kbd>WARNING</kbd> lines:</p>
<pre>import sys 
 
inname = sys.argv[1] 
outname = sys.argv[2] 
 
with open(inname) as infile: 
    with open(outname, "w") as outfile: 
<strong>        warnings = (l for l in infile if 'WARNING' in l)</strong> 
        for l in warnings: 
            outfile.write(l) </pre>
<p>This program takes the two filenames on the command line, uses a generator expression to filter out the warnings (in this case, it uses the <kbd>if</kbd> syntax and leaves the line unmodified), and then outputs the warnings to another file. If we run it on our sample file, the output looks like this:</p>
<pre><strong>Jan 26, 2015 11:25:46 WARNING This is a warning. It could be serious.<br/>Jan 26, 2015 11:25:52 WARNING Another warning sent.<br/>Jan 26, 2015 11:26:40 WARNING Warnings should be heeded.<br/>Jan 26, 2015 11:26:54 WARNING Watch for warnings.</strong> </pre>
<p>Of course, with such a short input file, we could have safely used a list comprehension, but if the file is millions of lines long, the generator expression will have a huge impact on both memory and speed.</p>
<div class="packt_tip">Wrapping a <kbd>for</kbd> expression in parenthesis creates a generator expression, not a tuple.</div>
<p>Generator expressions are frequently most useful inside function calls. For example, we can call <kbd>sum</kbd>, <kbd>min</kbd>, or <kbd>max</kbd> on a generator expression instead of a list, since these functions process one object at a time. We're only interested in the aggregate result, not any intermediate container.</p>
<p>In general, of the four options, a generator expression should be used whenever possible. If we don't actually need a list, set, or dictionary, but simply need to filter or convert items in a sequence, a generator expression will be most efficient. If we need to know the length of a list, or sort the result, remove duplicates, or create a dictionary, we'll have to use the comprehension syntax.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Generators</h1>
                </header>
            
            <article>
                
<p>Generator expressions are actually a sort of comprehension too; they compress the more advanced (this time it really is more advanced!) generator syntax into one line. The greater generator syntax looks even less object-oriented than anything we've seen, but we'll discover that once again, it is a simple syntax shortcut to create a kind of object.</p>
<p>Let's take the log file example a little further. If we want to delete the <kbd>WARNING</kbd> column from our output file (since it's redundant: this file contains only warnings), we have several options at various levels of readability. We can do it with a generator expression:</p>
<pre>import sys<br/><br/># generator expression<br/>inname, outname = sys.argv[1:3]<br/><br/>with open(inname) as infile:<br/>    with open(outname, "w") as outfile:<br/><strong>        warnings = (</strong><br/><strong>            l.replace("\tWARNING", "") for l in infile if "WARNING" in l</strong><br/><strong>        )</strong><br/>        for l in warnings:<br/>            outfile.write(l)</pre>
<p>That's perfectly readable, though I wouldn't want to make the expression much more complicated than that. We could also do it with a normal <kbd>for</kbd> loop:</p>
<pre>with open(inname) as infile:<br/>    with open(outname, "w") as outfile:<br/>        for l in infile:<br/>            if "WARNING" in l:<br/>                outfile.write(l.replace("\tWARNING", ""))</pre>
<p>That's clearly maintainable, but so many levels of indent in so few lines is kind of ugly. More alarmingly, if we wanted to do something other than printing the lines out, we'd have to duplicate the looping and conditional code, too.</p>
<p>Now let's consider a truly object-oriented solution, without any shortcuts:</p>
<pre>class WarningFilter:<br/>    def __init__(self, insequence):<br/>        self.insequence = insequence<br/><br/><strong>    def __iter__(self):</strong><br/>        return self<br/><br/><strong>    def __next__(self):</strong><br/>        l = self.insequence.readline()<br/>        while l and "WARNING" not in l:<br/>            l = self.insequence.readline()<br/>        if not l:<br/><strong> raise StopIteration</strong><br/>        return l.replace("\tWARNING", "")<br/><br/><br/>with open(inname) as infile:<br/>    with open(outname, "w") as outfile:<br/>        filter = WarningFilter(infile)<br/>        for l in filter:<br/>            outfile.write(l)</pre>
<p>No doubt about it: that is so ugly and difficult to read that you may not even be able to tell what's going on. We created an object that takes a file object as input, and provides a <kbd>__next__</kbd> method like any iterator.</p>
<p>This <kbd>__next__</kbd> method reads lines from the file, discarding them if they are not <kbd>WARNING</kbd> lines. When we encounter a <kbd>WARNING</kbd> line, we modify and return it. Then our <kbd>for</kbd> loop calls <kbd>__next__</kbd> again to process the subsequent <kbd>WARNING</kbd> line. When we run out of lines, we raise <kbd>StopIteration</kbd> to tell the loop we're finished iterating. It's pretty ugly compared to the other examples, but it's also powerful; now that we have a class in our hands, we can do whatever we want with it.</p>
<p>With that background behind us, we finally get to see true generators in action. This next example does <em>exactly</em> the same thing as the previous one: it creates an object with a <kbd>__next__</kbd> method that raises <kbd>StopIteration</kbd> when it's out of inputs:</p>
<pre>def warnings_filter(insequence):<br/>    for l in insequence:<br/>        if "WARNING" in l:<br/><strong>            yield l.replace("\tWARNING", "")</strong><br/><br/><br/>with open(inname) as infile:<br/>    with open(outname, "w") as outfile:<br/>        filter = warnings_filter(infile)<br/>        for l in filter:<br/>            outfile.write(l)</pre>
<p>OK, that's pretty readable, maybe... at least it's short. But what on earth is going on here? It makes no sense whatsoever. And what is <kbd>yield</kbd>, anyway?</p>
<p>In fact, <kbd>yield</kbd> is the key to generators. When Python sees <kbd>yield</kbd> in a function, it takes that function and wraps it up in an object not unlike the one in our previous example. Think of the <kbd>yield</kbd> statement as similar to the <kbd>return</kbd> statement; it exits the function and returns a line. Unlike <kbd>return</kbd>, however, when the function is called again (via <kbd>next()</kbd>), it will start where it left off<span>—</span>on the line after the <kbd>yield</kbd> statement<span>—</span>instead of at the beginning of the function. In this example, there is no line <em>after</em> the <kbd>yield</kbd> statement, so it jumps to the next iteration of the <kbd>for</kbd> loop. Since the <kbd>yield</kbd> statement is inside an <kbd>if</kbd> statement, it only yields lines that contain <kbd>WARNING</kbd>.</p>
<p>While it looks like this is just a function looping over the lines, it is actually creating a special type of object, a generator object:</p>
<pre><strong>&gt;&gt;&gt; print(warnings_filter([]))</strong>
<strong>&lt;generator object warnings_filter at 0xb728c6bc&gt;</strong>  </pre>
<p>I passed an empty list into the function to act as an iterator. All the function does is create and return a generator object. That object has <kbd>__iter__</kbd> and <kbd>__next__</kbd> methods on it, just like the one we created in the previous example. (You can call the <kbd>dir</kbd> built-in function on it to confirm.) Whenever <kbd>__next__</kbd> is called, the generator runs the function until it finds a <kbd>yield</kbd> statement. It then returns the value from <kbd>yield</kbd>, and the next time <kbd>__next__</kbd> is called, it picks up where it left off.</p>
<p>This use of generators isn't that advanced, but if you don't realize the function is creating an object, it can seem like magic. This example was quite simple, but you can get really powerful effects by making multiple calls to <kbd>yield</kbd> in a single function; on each loop, the generator will simply pick up at the most recent <kbd>yield</kbd> and continue to the next one.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Yield items from another iterable</h1>
                </header>
            
            <article>
                
<p>Often, when we build a generator function, we end up in a situation where we want to yield data from another iterable object, possibly a list comprehension or generator expression we constructed inside the generator, or perhaps some external items that were passed into the function. This has always been possible by looping over the iterable and individually yielding each item. However, in Python version 3.3, the Python developers introduced a new syntax to make it a little more elegant.</p>
<p>Let's adapt the generator example a bit so that instead of accepting a sequence of lines, it accepts a filename. This would normally be frowned upon as it ties the object to a particular paradigm. When possible we should operate on iterators as input; this way the same function could be used regardless of whether the log lines came from a file, memory, or the web.</p>
<p>This version of the code illustrates that your generator can do some basic setup before yielding information from another iterable (in this case, a generator expression):</p>
<pre>def warnings_filter(infilename):<br/>    with open(infilename) as infile:<br/><strong>        yield from (</strong><br/><strong>            l.replace("\tWARNING", "") for l in infile if "WARNING" in l</strong><br/><strong>        )</strong><br/><br/><br/>filter = warnings_filter(inname)<br/>with open(outname, "w") as outfile:<br/>    for l in filter:<br/>        outfile.write(l)</pre>
<p>This code combines the <kbd>for</kbd> loop from the previous example into a generator expression. Notice that this transformation didn't help anything; the previous example with a <kbd>for</kbd> loop was more readable.</p>
<p>So, let's consider an example that is more readable than its alternative. It can be useful to construct a generator that yields data from multiple other generators. The <kbd>itertools.chain</kbd> function, for example, yields data from iterables in sequence until they have all been exhausted. This can be implemented far too easily using the <kbd>yield from</kbd> syntax, so let's consider a classic computer science problem: walking a general tree.</p>
<p>A common implementation of the general tree data structure is a computer's filesystem. Let's model a few folders and files in a Unix filesystem so we can use <kbd>yield from</kbd> to walk them effectively:</p>
<pre>class File:<br/>    def __init__(self, name):<br/>        self.name = name<br/><br/><br/>class Folder(File):<br/>    def __init__(self, name):<br/>        super().__init__(name)<br/>        self.children = []<br/><br/><br/>root = Folder("")<br/>etc = Folder("etc")<br/>root.children.append(etc)<br/>etc.children.append(File("passwd"))<br/>etc.children.append(File("groups"))<br/>httpd = Folder("httpd")<br/>etc.children.append(httpd)<br/>httpd.children.append(File("http.conf"))<br/>var = Folder("var")<br/>root.children.append(var)<br/>log = Folder("log")<br/>var.children.append(log)<br/>log.children.append(File("messages"))<br/>log.children.append(File("kernel"))<br/><br/></pre>
<p>This setup code looks like a lot of work, but in a real filesystem, it would be even more involved. We'd have to read data from the hard drive and structure it into the tree. Once in memory, however, the code that outputs every file in the filesystem is quite elegant:</p>
<pre>def walk(file):<br/>    if isinstance(file, Folder):<br/>        yield file.name + "/"<br/>        for f in file.children:<br/><strong>            yield from walk(f)</strong><br/>    else:<br/>        yield file.name</pre>
<p>If this code encounters a directory, it recursively asks <kbd>walk()</kbd> to generate a list of all files subordinate to each of its children, and then yields all that data plus its own filename. In the simple case that it has encountered a normal file, it just yields that name.</p>
<p>As an aside, solving the preceding problem without using a generator is tricky enough that it is a common interview question. If you answer it as shown like this, be prepared for your interviewer to be both impressed and somewhat irritated that you answered it so easily. They will likely demand that you explain exactly what is going on. Of course, armed with the principles you've learned in this chapter, you won't have any problem. Good luck!</p>
<p>The <kbd>yield from</kbd> syntax is a useful shortcut when writing chained generators. It was added to the language for a different reason, to support coroutines. It is not used all that much anymore, however, because it's usage has been replaced with <kbd>async</kbd> and <kbd>await</kbd> syntax. We'll see examples of both in the next section.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Coroutines</h1>
                </header>
            
            <article>
                
<p>Coroutines are extremely powerful constructs that are often confused with generators. Many authors inappropriately describe coroutines as <em>generators with a bit of extra syntax</em>. This is an easy mistake to make, as, way back in Python 2.5, when coroutines were introduced, they were presented as <em>we added a</em> <kbd>send</kbd> <em>method to the generator syntax</em>. The difference is actually a lot more nuanced and will make more sense after you've seen a few examples.</p>
<p>Coroutines are pretty hard to understand. Outside the <kbd>asyncio</kbd> module, which we'll cover in the chapter on concurrency, they are not used all that often in the wild. You can definitely skip this section and happily develop in Python for years without ever encountering coroutines. There are a couple of libraries that use coroutines extensively (mostly for concurrent or asynchronous programming), but they are normally written such that you can use coroutines without actually understanding how they work! So, if you get lost in this section, don't despair.</p>
<p>If I haven't scared you off, let's get started! Here's one of the simplest possible coroutines; it allows us to keep a running tally that can be increased by arbitrary values:</p>
<pre>def tally(): 
    score = 0 
    while True: 
<strong>        increment = yield score</strong> 
        score += increment </pre>
<p>This code looks like black magic that couldn't possibly work, so let's prove it works before going into a line-by-line description. This simple object could be used by a scoring application for a baseball team. Separate tallies could be kept for each team, and their score could be incremented by the number of runs accumulated at the end of every half-innings. Look at this interactive session:</p>
<pre><strong>&gt;&gt;&gt; white_sox = tally()</strong>
<strong>&gt;&gt;&gt; blue_jays = tally()</strong>
<strong>&gt;&gt;&gt; next(white_sox)</strong>
<strong>0</strong>
<strong>&gt;&gt;&gt; next(blue_jays)</strong>
<strong>0</strong>
<strong>&gt;&gt;&gt; white_sox.send(3)</strong>
<strong>3</strong>
<strong>&gt;&gt;&gt; blue_jays.send(2)</strong>
<strong>2</strong>
<strong>&gt;&gt;&gt; white_sox.send(2)</strong>
<strong>5</strong>
<strong>&gt;&gt;&gt; blue_jays.send(4)</strong>
<strong>6</strong>  </pre>
<p>First, we construct two <kbd>tally</kbd> objects, one for each team. Yes, they look like functions, but as with the generator objects in the previous section, the fact that there is a <kbd>yield</kbd> statement inside the function tells Python to put a great deal of effort into turning the simple function into an object.</p>
<p>We then call <kbd>next()</kbd> on each of the coroutine objects. This does the same thing as calling next on any generator, which is to say, it executes each line of code until it encounters a <kbd>yield</kbd> statement, returns the value at that point, and then <em>pauses</em> until the next <kbd>next()</kbd> call.</p>
<p>So far, then, there's nothing new. But look back at the <kbd>yield</kbd> statement in our coroutine:</p>
<pre>increment = yield score </pre>
<p>Unlike with generators, this <kbd>yield</kbd> function looks like it's supposed to return a value and assign it to a variable. In fact, this is exactly what's happening. The coroutine is still paused at the <kbd>yield</kbd> statement and waiting to be activated again by another call to <kbd>next()</kbd>.</p>
<p>Except we don't call <kbd>next()</kbd>. As you see in the interactive session, we instead call to a method called <kbd>send()</kbd>. The <kbd>send()</kbd> method does <em>exactly</em> the same thing as <kbd>next()</kbd> except that in addition to advancing the generator to the next <kbd>yield</kbd> statement, it also allows you to pass in a value from outside the generator. This value is what gets assigned to the left side of the <kbd>yield</kbd> statement.</p>
<p>The thing that is really confusing for many people is the order in which this happens:</p>
<ol>
<li><kbd>yield</kbd> occurs and the generator pauses</li>
<li><kbd>send()</kbd> occurs from outside the function and the generator wakes up</li>
<li>The value sent in is assigned to the left side of the <kbd>yield</kbd> statement</li>
<li>The generator continues processing until it encounters another <kbd>yield</kbd> statement</li>
</ol>
<p>So, in this particular example, after we construct the coroutine and advance it to the <kbd>yield</kbd> statement with a single call to <kbd>next()</kbd>, each successive call to <kbd>send()</kbd> passes a value into the coroutine. We add this value to its score. Then we go back to the top of the <kbd>while</kbd> loop, and keep processing until we hit the <kbd>yield</kbd> statement. The <kbd>yield</kbd> statement returns a value, which becomes the return value of our most recent call to <kbd>send</kbd>. Don't miss that: like <kbd>next()</kbd>, the <kbd>send()</kbd> method does not just submit a value to the generator, it also returns the value from the upcoming <kbd>yield</kbd> statement. This is how we define the difference between a generator and a coroutine: a generator only produces values, while a coroutine can also consume them.</p>
<div class="packt_infobox">The behavior and syntax of <kbd>next(i)</kbd>, <kbd>i.__next__()</kbd>, and <kbd>i.send(value)</kbd> are rather unintuitive and frustrating. The first is a normal function, the second is a special method, and the last is a normal method. But all three do the same thing: advance the generator until it yields a value and pause. Further, the <kbd>next()</kbd> function and associated method can be replicated by calling <kbd>i.send(None)</kbd>. There is value to having two different method names here, since it helps the reader of our code easily see whether they are interacting with a coroutine or a generator. I just find the fact that in one case it's a function call and in the other it's a normal method somewhat irritating.</div>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Back to log parsing</h1>
                </header>
            
            <article>
                
<p>Of course, the previous example could easily have been coded using a couple of integer variables and calling <kbd>x += increment</kbd> on them. Let's look at a second example where coroutines actually save us some code. This example is a somewhat simplified (for pedagogical reasons) version of a problem I had to solve while working at Facebook.</p>
<p>The Linux kernel log contains lines that look almost, but not quite entirely, unlike this:</p>
<pre><strong>unrelated log messages 
sd 0:0:0:0 Attached Disk Drive 
unrelated log messages 
sd 0:0:0:0 (SERIAL=ZZ12345) 
unrelated log messages 
sd 0:0:0:0 [sda] Options 
unrelated log messages 
XFS ERROR [sda] 
unrelated log messages 
sd 2:0:0:1 Attached Disk Drive 
unrelated log messages 
sd 2:0:0:1 (SERIAL=ZZ67890) 
unrelated log messages 
sd 2:0:0:1 [sdb] Options 
unrelated log messages 
sd 3:0:1:8 Attached Disk Drive 
unrelated log messages 
sd 3:0:1:8 (SERIAL=WW11111) 
unrelated log messages 
sd 3:0:1:8 [sdc] Options 
unrelated log messages 
XFS ERROR [sdc] 
unrelated log messages</strong> </pre>
<p>There are a whole bunch of interspersed kernel log messages, some of which pertain to hard disks. The hard disk messages might be interspersed with other messages, but they occur in a predictable format and order. For each, a specific drive with a known serial number is associated with a bus identifier (such as <kbd>0:0:0:0</kbd>). A block device identifier (such as <kbd>sda</kbd>) is also associated with that bus. Finally, if the drive has a corrupt filesystem, it might fail with an XFS error.</p>
<p>Now, given the preceding log file, the problem we need to solve is how to obtain the serial number of any drives that have XFS errors on them. This serial number might later be used by a data center technician to identify and replace the drive.</p>
<p>We know we can identify the individual lines using regular expressions, but we'll have to change the regular expressions as we loop through the lines, since we'll be looking for different things depending on what we found previously. The other difficult bit is that if we find an error string, the information about which bus contains that string as well as the serial number have already been processed. This can easily be solved by iterating through the lines of the file in reverse order.</p>
<p>Before you look at this example, be warned<span>—</span>the amount of code required for a coroutine-based solution is scarily small:</p>
<pre>import re<br/><br/><br/>def match_regex(filename, regex):<br/>    with open(filename) as file:<br/>        lines = file.readlines()<br/>    for line in reversed(lines):<br/>        match = re.match(regex, line)<br/>        if match:<br/><strong>            regex = yield match.groups()[0]</strong><br/><br/><br/>def get_serials(filename):<br/>    ERROR_RE = "XFS ERROR (\[sd[a-z]\])"<br/>    matcher = match_regex(filename, ERROR_RE)<br/>    device = next(matcher)<br/>    while True:<br/>        try:<br/>            bus = matcher.send(<br/>                "(sd \S+) {}.*".format(re.escape(device))<br/>            )<br/>            serial = matcher.send("{} \(SERIAL=([^)]*)\)".format(bus))<br/><strong> yield serial</strong><br/>            device = matcher.send(ERROR_RE)<br/>        except StopIteration:<br/>            matcher.close()<br/>            return<br/><br/><br/>for serial_number in get_serials("EXAMPLE_LOG.log"):<br/>    print(serial_number)</pre>
<p>This code neatly divides the job into two separate tasks. The first task is to loop over all the lines and spit out any lines that match a given regular expression. The second task is to interact with the first task and give it guidance as to what regular expression it is supposed to be searching for at any given time.</p>
<p>Look at the <kbd>match_regex</kbd> coroutine first. Remember, it doesn't execute any code when it is constructed; rather, it just creates a coroutine object. Once constructed, someone outside the coroutine will eventually call <kbd>next()</kbd> to start the code running. Then it stores the state of two variables <kbd>filename</kbd> and <kbd>regex</kbd>. It then reads all the lines in the file and iterates over them in reverse. Each line is compared to the regular expression that was passed in until it finds a match. When the match is found, the coroutine yields the first group from the regular expression and waits.</p>
<p>At some point in the future, other code will send in a new regular expression to search for. Note that the coroutine never cares what regular expression it is trying to match; it's just looping over lines and comparing them to a regular expression. It's somebody else's responsibility to decide what regular expression to supply.</p>
<p>In this case, that somebody else is the <kbd>get_serials</kbd> generator. It doesn't care about the lines in the file; in fact, it isn't even aware of them. The first thing it does is create a <kbd>matcher</kbd> object from the <kbd>match_regex</kbd> coroutine constructor, giving it a default regular expression to search for. It advances the coroutine to its first <kbd>yield</kbd> and stores the value it returns. It then goes into a loop that instructs the <kbd>matcher</kbd> object to search for a bus ID based on the stored device ID, and then a serial number based on that bus ID.</p>
<p>It idly yields that serial number to the outside <kbd>for</kbd> loop before instructing the matcher to find another device ID and repeat the cycle.</p>
<p>Basically, the coroutine's job is to search for the next important line in the file, while the generator's (<kbd>get_serial</kbd>, which uses the <kbd>yield</kbd> syntax without assignment) job is to decide which line is important. The generator has information about this particular problem, such as what order lines will appear in the file. The coroutine, on the other hand, could be plugged into any problem that required searching a file for given regular expressions.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Closing coroutines and throwing exceptions</h1>
                </header>
            
            <article>
                
<p>Normal generators signal their exit from inside by raising <kbd>StopIteration</kbd>. If we chain multiple generators together (for example, by iterating over one generator from inside another), the <kbd>StopIteration</kbd> exception will be propagated outward. Eventually, it will hit a <kbd>for</kbd> loop that will see the exception and know that it's time to exit the loop.</p>
<p>Even though they use a similar syntax, coroutines don't normally follow the iteration mechanism. Instead of pulling data through one until an exception is encountered, data is usually pushed into it (using <kbd>send</kbd>). The entity doing the pushing is normally the one in charge of telling the coroutine when it's finished. It does this by calling the <kbd>close()</kbd> method on the coroutine in question.</p>
<p>When called, the <kbd>close()</kbd> method will raise a <kbd>GeneratorExit</kbd> exception at the point the coroutine was waiting for a value to be sent in. It is normally good policy for coroutines to wrap their <kbd>yield</kbd> statements in a <kbd>try</kbd>...<kbd>finally</kbd> block so that any cleanup tasks (such as closing associated files or sockets) can be performed.</p>
<p>If we need to raise an exception inside a coroutine, we can use the <kbd>throw()</kbd> method in a similar way. It accepts an exception type with optional <kbd>value</kbd> and <kbd>traceback</kbd> arguments. The latter is useful when we encounter an exception in one coroutine and want to cause an exception to occur in an adjacent coroutine while maintaining the traceback.</p>
<div class="packt_infobox">The previous example could be written without coroutines and would be about equally readable. The truth is, correctly managing all the state between coroutines is pretty difficult, especially when you take things like context managers and exceptions into account. Luckily, the Python standard library contains a package called <kbd>asyncio</kbd> that can manage all of this for you. We'll cover that in the chapter on concurrency. In general, I recommend you avoid using bare coroutines unless you are specifically coding for asyncio. The logging example could almost be considered an <em>anti-pattern</em>; a design pattern that should be avoided rather than embraced.</div>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">The relationship between coroutines, generators, and functions</h1>
                </header>
            
            <article>
                
<p>We've seen coroutines in action, so now let's go back to that discussion of how they are related to generators. In Python, as is so often the case, the distinction is quite blurry. In fact, all coroutines are generator objects, and authors often use the two terms interchangeably. Sometimes, they describe coroutines as a subset of generators (only generators that return values from yield are considered coroutines). This is technically true in Python, as we've seen in the previous sections.</p>
<p>However, in the greater sphere of theoretical computer science, coroutines are considered the more general principles, and generators are a specific type of coroutine. Further, normal functions are yet another distinct subset of coroutines.</p>
<p>A coroutine is a routine that can have data passed in at one or more points and get it out at one or more points. In Python, the point where data is passed in and out is the <kbd>yield</kbd> statement.</p>
<p>A function, or subroutine, is the simplest type of coroutine. You can pass data in at one point, and get data out at one other point when the function returns. While a function can have multiple <kbd>return</kbd> statements, only one of them can be called for any given invocation of the function.</p>
<p>Finally, a generator is a type of coroutine that can have data passed in at one point, but can pass data out at multiple points. In Python, the data would be passed out at a <kbd>yield</kbd> statement, but you can't pass data back in. If you called <kbd>send</kbd>, the data would be silently discarded.</p>
<p>So, in theory, generators are types of coroutines, functions are types of coroutines, and there are coroutines that are neither functions nor generators. That's simple enough, eh? So, why does it feel more complicated in Python?</p>
<p>In Python, generators and coroutines are both constructed using a syntax that <strong>looks</strong> like we are constructing a function. But the resulting object is not a function at all; it's a totally different kind of object. Functions are, of course, also objects. But they have a different interface; functions are callable and return values, generators have data pulled out using <kbd>next()</kbd>, and coroutines have data pushed in using <kbd>send</kbd>.</p>
<div class="packt_infobox">There is an alternate syntax for coroutines using the <kbd>async</kbd> and <kbd>await</kbd> <span>keywords.</span> The syntax makes it clearer that the code is a coroutine and further breaks the deceiving symmetry between coroutines and generators. The syntax doesn't work very well without building a full event loop, so we will skip it until we cover <kbd>asyncio</kbd> in the concurrency chapter.</div>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Case study</h1>
                </header>
            
            <article>
                
<p>One of the fields in which Python is the most popular these days is data science. In honor of that fact, let's implement a basic machine learning algorithm.</p>
<p>Machine learning is a huge topic, but the general idea is to make predictions or classifications about future data by using knowledge gained from past data. Uses of such algorithms abound, and data scientists are finding new ways to apply machine learning every day. Some important machine learning applications include computer vision (such as image classification or facial recognition), product recommendation, identifying spam, and self-driving cars.</p>
<p>So as not to digress into an entire book on machine learning, we'll look at a simpler problem: given an RGB color definition, what name would humans identify that color as?</p>
<p>There are more than 16 million colors in the standard RGB color space, and humans have come up with names for only a fraction of them. While there are thousands of names (some quite ridiculous; just go to any car dealership or paint store), let's build a classifier that attempts to divide the RGB space into the basic colors:</p>
<ul>
<li>Red</li>
<li>Purple</li>
<li>Blue</li>
<li>Green</li>
<li>Yellow</li>
<li>Orange</li>
<li>Gray</li>
<li>Pink</li>
</ul>
<p>(In my testing, I classified whitish and blackish colors as gray, and brownish colors as orange.)</p>
<p>The first thing we need is a dataset to train our algorithm on. In a production system, you might scrape a <em>list of colors</em> website or survey thousands of people. Instead, I created a simple application that renders a random color and asks the user to select one of the preceding eight options to classify it. I implemented it using <kbd>tkinter</kbd>, the user interface toolkit that ships with Python. I'm not going to go into the details of what this script does, but here it is in its entirety for completeness (it's a trifle long, so you may want to pull it from Packt's GitHub repository with the examples for this book instead of typing it in):</p>
<pre>import random<br/>import tkinter as tk<br/>import csv<br/><br/><br/>class Application(tk.Frame):<br/>    def __init__(self, master=None):<br/>        super().__init__(master)<br/>        self.grid(sticky="news")<br/>        master.columnconfigure(0, weight=1)<br/>        master.rowconfigure(0, weight=1)<br/>        self.create_widgets()<br/>        self.file = csv.writer(open("colors.csv", "a"))<br/><br/>    def create_color_button(self, label, column, row):<br/>        button = tk.Button(<br/>            self, command=lambda: self.click_color(label), text=label<br/>        )<br/>        button.grid(column=column, row=row, sticky="news")<br/><br/>    def random_color(self):<br/>        r = random.randint(0, 255)<br/>        g = random.randint(0, 255)<br/>        b = random.randint(0, 255)<br/><br/>        return f"#{r:02x}{g:02x}{b:02x}"<br/><br/>    def create_widgets(self):<br/>        self.color_box = tk.Label(<br/>            self, bg=self.random_color(), width="30", height="15"<br/>        )<br/>        self.color_box.grid(<br/>            column=0, columnspan=2, row=0, sticky="news"<br/>        )<br/>        self.create_color_button("Red", 0, 1)<br/>        self.create_color_button("Purple", 1, 1)<br/>        self.create_color_button("Blue", 0, 2)<br/>        self.create_color_button("Green", 1, 2)<br/>        self.create_color_button("Yellow", 0, 3)<br/>        self.create_color_button("Orange", 1, 3)<br/>        self.create_color_button("Pink", 0, 4)<br/>        self.create_color_button("Grey", 1, 4)<br/>        self.quit = tk.Button(<br/>            self, text="Quit", command=root.destroy, bg="#ffaabb"<br/>        )<br/>        self.quit.grid(column=0, row=5, columnspan=2, sticky="news")<br/><br/>    def click_color(self, label):<br/>        self.file.writerow([label, self.color_box["bg"]])<br/>        self.color_box["bg"] = self.random_color()<br/><br/><br/>root = tk.Tk()<br/>app = Application(master=root)<br/>app.mainloop()</pre>
<div class="packt_tip">You can easily add more buttons for other colors if you like. You may get tripped up on the layout; the second and third argument to <kbd>create_color_button</kbd> represent the row and column of a two column grid that the button goes in. Once you have all your colors in place, you will want to move the <strong>Quit</strong> button to the last row.</div>
<p>For the purposes of this case study, the important thing to know about this application is the output. It creates a <strong>C</strong><strong>omma-Separated Value</strong> (<strong>CSV</strong>) file named <kbd>colors.csv</kbd>. This file contains two CSVs: the label the user assigned to the color, and the hex RGB value for the color. Here's an example:</p>
<pre><strong>Green,#6edd13</strong><br/><strong>Purple,#814faf</strong><br/><strong>Yellow,#c7c26d</strong><br/><strong>Orange,#61442c</strong><br/><strong>Green,#67f496</strong><br/><strong>Purple,#c757d5</strong><br/><strong>Blue,#106a98</strong><br/><strong>Pink,#d40491</strong><br/><strong>.</strong><br/><strong>.</strong><br/><strong>.</strong><br/><strong>Blue,#a4bdfa</strong><br/><strong>Green,#30882f</strong><br/><strong>Pink,#f47aad</strong><br/><strong>Green,#83ddb2</strong><br/><strong>Grey,#baaec9</strong><br/><strong>Grey,#8aa28d</strong><br/><strong>Blue,#533eda</strong></pre>
<p>I made over 250 datapoints before I got bored and decided it was time to start machine learning on my dataset. My datapoints are shipped with the examples for this chapter if you would like to use it (nobody's ever told me I'm colorblind, so it should be somewhat reasonable).</p>
<p>We'll be implementing one of the simpler machine learning algorithms, referred to as <em>k-nearest neighbor</em>. This algorithm relies on some kind of <em>distance</em> calculation between points in the dataset (in our case, we can use a three-dimensional version of the Pythagorean theorem). Given a new datapoint, it finds a certain number (referred to as <em>k</em>, which is the <em>k</em> in <em>k-nearest</em>) of datapoints that are closest to it when measured by that distance calculation. Then it combines those datapoints in some way (an average might work for linear calculations; for our classification problem, we'll use the mode), and returns the result.</p>
<p>We won't go into too much detail about what the algorithm does; rather, we'll focus on some of the ways we can apply the iterator pattern or iterator protocol to this problem.</p>
<p>Let's now write a program that performs the following steps in order:</p>
<ol>
<li>Load the sample data from the file and construct a model from it.</li>
<li>Generate 100 random colors.</li>
<li>Classify each color and output it to a file in the same format as the input.</li>
</ol>
<p>The first step is a fairly simple generator that loads CSV data and converts it into a format that is amenable to our needs:</p>
<pre>import csv<br/><br/>dataset_filename = "colors.csv"<br/><br/><br/>def load_colors(filename):<br/>    with open(filename) as dataset_file:<br/>        lines = csv.reader(dataset_file)<br/><strong>        for line in lines:</strong><br/>            label, hex_color = line<br/><strong>            yield (hex_to_rgb(hex_color), label)</strong></pre>
<p>We haven't seen the <kbd>csv.reader</kbd> function before. It returns an iterator over the lines in the file. Each value returned by the iterator is a list of strings, as separated by commas. So, the line <kbd>Green,#6edd13</kbd> is returned as <kbd>["Green", "#6edd13"]</kbd>.</p>
<p>The <kbd>load_colors</kbd> generator then consumes that iterator, one line at a time, and yields a tuple of RGB values as well as the label. It is quite common for generators to be chained in this way, where one iterator calls another that calls another and so on. You may want to look at the <kbd>itertools</kbd> module in the Python Standard Library for a whole host of such ready-made generators waiting for you.</p>
<p>The RGB values in this case are tuples of integers between 0 and 255. The conversion from hex to RGB is a bit tricky, so we pulled it out into a separate function:</p>
<pre>def hex_to_rgb(hex_color):<br/>    return tuple(int(hex_color[i : i + 2], 16) for i in range(1, 6, 2))<br/><br/></pre>
<p>This generator expression is doing a lot of work. It takes a string such as <kbd>"#12abfe"</kbd> as input and returns a tuple such as <kbd>(18, 171, 254)</kbd>. Let's break it down from back to front.</p>
<p>The <kbd>range</kbd> call will return the numbers <kbd>[1, 3, 5]</kbd>. These represent the indexes of the three color channels in the hex string. The index, <kbd>0</kbd>, is skipped, since it represents the character <kbd>"#"</kbd>, which we don't care about. For each of the three numbers, it extracts the two character string between <kbd>i</kbd> and <kbd>i+2</kbd>. For the preceding example string , that would be <kbd>12</kbd>, <kbd>ab</kbd>, and <kbd>fe</kbd>. Then it converts this string value to an integer. The <kbd>16</kbd> passed as the second argument to the <kbd>int</kbd> function tells the function to use base-16 (hexadecimal) instead of the usual base-10 (decimal) for the conversion.</p>
<p>Given how difficult the generator expression is to read, do you think it should have been represented in a different format? It could be created as a sequence of multiple generator expressions, for example, or be unrolled into a normal generator function with <kbd>yield</kbd> statements. Which would you prefer?</p>
<p>In this case, I am comfortable trusting the function name to explain what the ugly line of code is doing.</p>
<p>Now that we've loaded the <em>training data</em> (manually classified colors, we need some new data to test how well the algorithm is working. We can do this by generating a hundred random colors, each composed of three random numbers between 0 and 255.</p>
<p>There are so many ways this can be done:</p>
<ul>
<li>A list comprehension with a nested generator expression: <kbd>[tuple(randint(0,255) for c in range(3)) for r in range(100)]</kbd></li>
<li>A basic generator function</li>
<li>A class that implements the <kbd>__iter__</kbd> and <kbd>__next__</kbd> protocols</li>
</ul>
<ul>
<li>Push the data through a pipeline of coroutines</li>
<li>Even just a basic <kbd>for</kbd> loop</li>
</ul>
<p>The generator version seems to be most readable, so let's add that function to our program:</p>
<pre>from random import randint<br/> 
def generate_colors(count=100):<br/>    for i in range(count):<br/>        yield (randint(0, 255), randint(0, 255), randint(0, 255))</pre>
<p>Notice how we parameterize the number of colors to generate. We can now reuse this function for other color-generating tasks in the future.</p>
<p>Now, before we do the classification step, we need a function to calculate the <em>distance</em> between two colors. Since it's possible to think of colors as being three dimensional (red, green, and blue could map to the <em>x</em>, <em>y</em>, and <em>z</em> axes, for example), let's use a little basic math:</p>
<pre>def color_distance(color1, color2):<br/>    channels = zip(color1, color2)<br/>    sum_distance_squared = 0<br/>    for c1, c2 in channels:<br/>        sum_distance_squared += (c1 - c2) ** 2<br/>    return sum_distance_squared</pre>
<p>This is a pretty basic-looking function; it doesn't look like it's even using the iterator protocol. There's no <kbd>yield</kbd> function, no comprehensions. However, there is a <kbd>for</kbd> loop, and that call to the <kbd>zip</kbd> function is doing some real iteration as well (if you aren't familiar with it, <kbd>zip</kbd> yields tuples, each containing one element from each input iterator).</p>
<p>This distance calculation is the three-dimensional version of the Pythagorean theorem you may remember from school: <em>a<sup>2</sup> + b<sup>2</sup> = c<sup>2</sup></em>. Since we are using three dimensions, I guess it would actually be <em>a<sup>2</sup> + b<sup>2</sup> + c<sup>2</sup> = d<sup>2</sup></em>. The distance is technically the square root of <em>a<sup>2</sup> + b<sup>2</sup> + c<sup>2</sup></em>, but there isn't any need to perform the somewhat expensive <kbd>sqrt</kbd> calculation since the squared distances are all the same relative size to each other.</p>
<p>Now that we have some plumbing in place, let's do the actual k-nearest neighbor implementation. This routine can be thought of as consuming and combining the two generators we've already seen (<kbd>load_colors</kbd> and <kbd>generate_colors</kbd>):</p>
<pre>def nearest_neighbors(model_colors, target_colors, num_neighbors=5):<br/>    model_colors = list(model_colors)<br/><br/>    for target in target_colors:<br/>        distances = sorted(<br/>            ((color_distance(c[0], target), c) for c in model_colors)<br/>        )<br/>        yield target, distances[:5]</pre>
<p>We first convert the <kbd>model_colors</kbd> generator to a list because it has to be consumed multiple times, once for each of the <kbd>target_colors</kbd>.  If we didn't do this, we would have to load the colors from the source file repeatedly, which would perform a lot of unnecessary disk reads.</p>
<p class="mce-root">The downside of this decision is that the entire list has to be stored in memory all at once. If we had a massive dataset that didn't fit in memory, it would actually be necessary to reload the generator from disk each time (though we'd actually be looking at different machine learning algorithms in that case).</p>
<p>The <kbd>nearest_neighbors</kbd> generator loops over each target color (a three-tuple, such as <kbd>(255, 14, 168)</kbd>) and calls the <kbd>color_distance</kbd> function on it inside a generator expression. The <kbd>sorted</kbd> call surrounding that generator expression then sorts the results by their first element, which is the distance. It is a complicated piece of code and isn't object-oriented at all. You may want to break it down into a normal <kbd>for</kbd> loop to ensure you understand what the generator expression is doing.</p>
<p>The <kbd>yield</kbd> statement is a bit less complicated. For each RGB three-tuple from the <kbd>target_colors</kbd> generator, it yields the target, and a list comprehension of the <kbd>num_neighbors</kbd> (that's the <em>k</em> in <em>k-nearest</em>, by the way. Many mathematicians and, by extension, data scientists, have a horrible tendency to use unintelligible one-letter variable names) closest colors.</p>
<p>The contents of each element in the list comprehension is an element from the <kbd>model_colors</kbd> generator; that is, a tuple of a tuple of three RGB values and the string name that was manually entered for that color. So, one element might look like this: <kbd>((104, 195, 77), 'Green')</kbd>. The first thing I think when I see nested tuples like that is, <em>that is not the right datastructure</em>. The RGB color should probably be represented as a named tuple, and the two attributes should maybe go on a dataclass.</p>
<p>We can now add <em>another</em> generator to the chain to figure out what name we should give this target color:</p>
<pre>from collections import Counter<br/><br/>def name_colors(model_colors, target_colors, num_neighbors=5):<br/>    for target, near in nearest_neighbors(<br/>        model_colors, target_colors, num_neighbors=5<br/>    ):<br/>        print(target, near)<br/>        name_guess = Counter(n[1] for n in near).most_common()[0][0]<br/>        yield target, name_guess</pre>
<p>This generator is unpacking the tuple returned by <kbd>nearest_neighbors</kbd> into the three-tuple target and the five nearest datapoints. It uses a <kbd>Counter</kbd> to find the name that appears most often among the colors that were returned. There is yet another generator expression in the <kbd>Counter</kbd> constructor; this one extracts the second element (the color name) from each datapoint. Then it yields a tuple RGB value and the guessed name. An example of the return value is <kbd>(91, 158, 250) Blue</kbd>.</p>
<p>We can write a function that accepts the output from the <kbd>name_colors</kbd> generator and writes it to a CSV file, with the RGB colors represented as hex values:</p>
<pre>def write_results(colors, filename="output.csv"):<br/>    with open(filename, "w") as file:<br/>        writer = csv.writer(file)<br/>        for (r, g, b), name in colors:<br/>            writer.writerow([name, f"#{r:02x}{g:02x}{b:02x}"])</pre>
<p>This is a function, not a generator. It's consuming the generator in a <kbd>for</kbd> loop, but it's not yielding anything. It constructs a CSV writer and outputs rows of name, hex value (for example, <kbd>Purple,#7f5f95</kbd>) pairs for each of the target colors. The only thing that might be confusing in here is the contents of the format string. The <kbd>:02x</kbd> modifier used with each of the <kbd>r</kbd>,<kbd>g</kbd>, and <kbd>b</kbd> channels outputs the number as a zero-padded two-digit hexadecimal number.</p>
<p>Now all we have to do is connect these various generators and pipelines together, and kick off the process with a single function call:</p>
<pre>def process_colors(dataset_filename="colors.csv"):<br/>    model_colors = load_colors(dataset_filename)<br/>    colors = name_colors(model_colors, generate_colors(), 5)<br/>    write_results(colors)<br/><br/><br/>if __name__ == "__main__":<br/>    process_colors()</pre>
<p>So, this function, unlike almost every other function we've defined, is a perfectly normal function without any <kbd>yield</kbd> statements or <kbd>for</kbd> loops. It doesn't do any iteration at all.</p>
<p>It does, however, construct three generators. Can you see all three?:</p>
<ul>
<li><kbd>load_colors</kbd> returns a generator</li>
<li><kbd>generate_colors</kbd> returns a generator</li>
<li><kbd>name_guess</kbd> returns a generator</li>
</ul>
<p>The <kbd>name_guess</kbd> generator consumes the first two generators. It, in turn, is then consumed by the <kbd>write_results</kbd> function.</p>
<p>I wrote a second Tkinter app to check the accuracy of the algorithm. It is similar to the first app, except it renders each color and the label associated with that color. Then you have to manually click <span class="packt_screen">Yes</span> or <span class="packt_screen">No</span> if the label matches the color. For my example data, I got around 95% accuracy. This could be improved by implementing the following:</p>
<ul>
<li>Adding more color names</li>
<li>Adding more training data by manually classifying more colors</li>
<li>Tweaking the value of <kbd>num_neighbors</kbd></li>
<li>Using a more advanced machine learning algorithm</li>
</ul>
<p>Here's the code for the output checking app, though I recommend downloading the example code instead. This would be tedious to type in:</p>
<pre>import tkinter as tk<br/>import csv<br/><br/><br/>class Application(tk.Frame):<br/>    def __init__(self, master=None):<br/>        super().__init__(master)<br/>        self.grid(sticky="news")<br/>        master.columnconfigure(0, weight=1)<br/>        master.rowconfigure(0, weight=1)<br/>        self.csv_reader = csv.reader(open("output.csv"))<br/>        self.create_widgets()<br/>        self.total_count = 0<br/>        self.right_count = 0<br/><br/>    def next_color(self):<br/>        return next(self.csv_reader)<br/><br/>    def mk_grid(self, widget, column, row, columnspan=1):<br/>        widget.grid(<br/>            column=column, row=row, columnspan=columnspan, sticky="news"<br/>        )<br/><br/>    def create_widgets(self):<br/>        color_text, color_bg = self.next_color()<br/>        self.color_box = tk.Label(<br/>            self, bg=color_bg, width="30", height="15"<br/>        )<br/>        self.mk_grid(self.color_box, 0, 0, 2)<br/><br/>        self.color_label = tk.Label(self, text=color_text, height="3")<br/>        self.mk_grid(self.color_label, 0, 1, 2)<br/><br/>        self.no_button = tk.Button(<br/>            self, command=self.count_next, text="No"<br/>        )<br/>        self.mk_grid(self.no_button, 0, 2)<br/><br/>        self.yes_button = tk.Button(<br/>            self, command=self.count_yes, text="Yes"<br/>        )<br/>        self.mk_grid(self.yes_button, 1, 2)<br/><br/>        self.percent_accurate = tk.Label(self, height="3", text="0%")<br/>        self.mk_grid(self.percent_accurate, 0, 3, 2)<br/><br/>        self.quit = tk.Button(<br/>            self, text="Quit", command=root.destroy, bg="#ffaabb"<br/>        )<br/>        self.mk_grid(self.quit, 0, 4, 2)<br/><br/>    def count_yes(self):<br/>        self.right_count += 1<br/>        self.count_next()<br/><br/>    def count_next(self):<br/>        self.total_count += 1<br/>        percentage = self.right_count / self.total_count<br/>        self.percent_accurate["text"] = f"{percentage:.0%}"<br/>        try:<br/>            color_text, color_bg = self.next_color()<br/>        except StopIteration:<br/>            color_text = "DONE"<br/>            color_bg = "#ffffff"<br/>            self.color_box["text"] = "DONE"<br/>            self.yes_button["state"] = tk.DISABLED<br/>            self.no_button["state"] = tk.DISABLED<br/>        self.color_label["text"] = color_text<br/>        self.color_box["bg"] = color_bg<br/><br/><br/>root = tk.Tk()<br/>app = Application(master=root)<br/>app.mainloop()</pre>
<p>You might be wondering, <em>what does any of this have to do with object-oriented programming? There isn't even one class in this code!</em>. In some ways, you'd be right; generators are not commonly considered object-oriented. However, the functions that create them return objects; in fact, you could think of those functions as constructors. The constructed object has an appropriate <kbd>__next__()</kbd> method. Basically, the generator syntax is a syntax shortcut for a particular kind of object that would be quite verbose to create without it.</p>
<p>As a sort of historical note, the second edition of this book used coroutines to solve this problem instead of basic generators. I decided to switch it to generators in the third edition for a few reasons:</p>
<ul>
<li>Nobody ever uses coroutines in real life outside of <kbd>asyncio</kbd>, which we'll cover in the chapter on concurrency. I felt I was wrongly encouraging people to use coroutines to solve problems when they are extremely rarely the right tool.</li>
<li>The coroutine version is longer and more convoluted with more boilerplate than the generator version.</li>
<li>The coroutine version didn't demonstrate enough of the other features discussed in this chapter, such as list comprehensions and generator expressions.</li>
</ul>
<p>In case you might find the coroutine-based implementation to be historically interesting, I included a copy of that code with the rest of the downloadable example code for this chapter.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Exercises</h1>
                </header>
            
            <article>
                
<p>If you don't use comprehensions in your daily coding very often, the first thing you should do is search through some existing code and find some <kbd>for</kbd> loops. See whether any of them can be trivially converted to a generator expression or a list, set, or dictionary comprehension.</p>
<p>Test the claim that list comprehensions are faster than <kbd>for</kbd> loops. This can be done with the built-in <kbd>timeit</kbd> module. Use the help documentation for the <kbd>timeit.timeit</kbd> function to find out how to use it. Basically, write two functions that do the same thing, one using a list comprehension, and one using a <kbd>for</kbd> loop to iterate over several thousand items. Pass each function into <kbd>timeit.timeit</kbd>, and compare the results. If you're feeling adventurous, compare generators and generator expressions as well. Testing code using <kbd>timeit</kbd> can become addictive, so bear in mind that code does not need to be hyperfast unless it's being executed an immense number of times, such as on a huge input list or file.</p>
<p>Play around with generator functions. Start with basic iterators that require multiple values (mathematical sequences are canonical examples; the Fibonacci sequence is overused if you can't think of anything better). Try some more advanced generators that do things such as take multiple input lists and somehow yield values that merge them. Generators can also be used on files; can you write a simple generator that shows lines that are identical in two files?</p>
<p>Coroutines abuse the iterator protocol but don't actually fulfill the iterator pattern. Can you build a non-coroutine version of the code that gets a serial number from a log file? Take an object-oriented approach so that you can store an additional state on a class. You'll learn a lot about coroutines if you can create an object that is a drop-in replacement for the existing coroutine.</p>
<p>The case study for this chapter has a lot of odd tuples of tuples being passed around that are hard to keep track of. See whether you can replace those return values with more object-oriented solutions. Also, experiment with moving some of the functions that share data (for example, <kbd>model_colors</kbd> and <kbd>target_colors</kbd>) into a class. That should reduce the number of arguments that have to be passed into most of the generators since they can look them up on <kbd>self</kbd>.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Summary</h1>
                </header>
            
            <article>
                
<p>In this chapter, we learned that design patterns are useful abstractions that provide best-practice solutions for common programming problems. We covered our first design pattern, the iterator, as well as numerous ways that Python uses and abuses this pattern for its own nefarious purposes. The original iterator pattern is extremely object-oriented, but it is also rather ugly and verbose to code around. However, Python's built-in syntax abstracts the ugliness away, leaving us with a clean interface to these object-oriented constructs.</p>
<p>Comprehensions and generator expressions can combine container construction with iteration in a single line. Generator objects can be constructed using the <kbd>yield</kbd> syntax. Coroutines look like generators on the outside but serve a much different purpose.</p>
<p>We'll cover several more design patterns in the next two chapters.</p>


            </article>

            
        </section>
    </body></html>