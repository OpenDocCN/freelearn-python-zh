<html><head></head><body>
<div><h1 class="chapter-number" id="_idParaDest-216"><a id="_idTextAnchor252"/>12</h1>
<h1 id="_idParaDest-217"><a id="_idTextAnchor253"/>Authentication and Authorization</h1>
<p>In building full-stack web applications, you will more than often want to implement a system that allows users to trust you with their sensitive information. As a full-stack web developer, it is crucial to understand how to implement robust authentication and authorization mechanisms. You need to know how to protect the security of user data and the integrity of your application. Imagine you are building an e-commerce website that allows users to make online purchases.</p>
<p>If you do not properly authenticate and authorize users, it would be possible for someone to gain unauthorized access to the website and place orders using someone else’s personal information. This could result in financial loss for the legitimate user as well as damage to the reputation of an online business or that of your clients.</p>
<p>Furthermore, if you fail to properly authenticate and authorize users, it could also open your web application up to attacks such as SQL injection, where an attacker can gain access to sensitive information stored in your database. This could lead to the loss of customer data and legal repercussions may be staring you in the face.</p>
<p>In this chapter, we will delve into the world of web security and explore the best practices and techniques for securing Flask web applications. As the famous computer scientist Bruce Schneier once said, <em class="italic">Security is a process, not a product</em> (<a href="https://www.schneier.com/essays/archives/2000/04/the_process_of_secur.html">https://www.schneier.com/essays/archives/2000/04/the_process_of_secur.html</a>). This chapter will equip you with the knowledge and skills needed to understand the importance of information security and how to implement it in a Flask application.</p>
<p>From understanding the fundamentals of authentication and authorization to managing user sessions and creating accounts with secure passwords, this chapter will cover the crucial elements of web application security. We will examine the process of securing your Flask application and show you how to implement these concepts in practice.</p>
<p>In this chapter, you will learn about the following topics:</p>
<ul>
<li>Understanding the fundamentals of information security</li>
<li>Defining authentication and the authentication role in web applications</li>
<li>Implementing password security and hashing passwords</li>
<li>Understanding access and authorization in web application development</li>
<li>Adding authentication to your Flask application</li>
<li>Identifying system users and managing their information</li>
<li>Session management</li>
<li>Creating a password-protected dashboard</li>
<li>Implementing flash messages in Flask</li>
</ul>
<h1 id="_idParaDest-218"><a id="_idTextAnchor254"/>Technical requirements</h1>
<p>The complete code for this chapter is available on GitHub at: <a href="https://github.com/PacktPublishing/Full-Stack-Flask-and-React/tree/main/Chapter12">https://github.com/PacktPublishing/Full-Stack-Flask-and-React/tree/main/Chapter12</a>.</p>
<h1 id="_idParaDest-219"><a id="_idTextAnchor255"/>Understanding the fundamentals of information security</h1>
<p>Information security is a critical aspect of web application development. In today’s digital age, personal and <a id="_idIndexMarker823"/>sensitive information is often stored <a id="_idIndexMarker824"/>and transmitted through web applications, making them vulnerable <a id="_idIndexMarker825"/>to various types of security threats. These threats can range <a id="_idIndexMarker826"/>from simple attacks such as <strong class="bold">SQL injection</strong> and <strong class="bold">cross-site scripting</strong> (<strong class="bold">XSS</strong>) to more <a id="_idIndexMarker827"/>complex attacks such as <strong class="bold">man-in-the-middle</strong> (<strong class="bold">MITM</strong>) and <strong class="bold">distributed denial of </strong><strong class="bold">service</strong> (<strong class="bold">DDoS</strong>).</p>
<p>Let’s delve deeper into some of the various types of threats that can compromise your web application security:</p>
<ul>
<li><code>username</code> and <code>password</code> details. If the application is vulnerable to SQL injection, an attacker could input something like <code>' OR '1'='1</code> in the password field.</p><p class="list-inset">The SQL query may <a id="_idIndexMarker829"/>then become <code>SELECT * FROM users WHERE username = 'username' AND password = '' OR '1'='1';</code>, which would potentially allow the attacker to log in without a valid password.</p></li>
<li><code>&lt;script&gt;malicious_scripts()&lt;/script&gt;</code>, other users viewing the comment section might execute the script unintentionally.</pre></li>
<li><strong class="bold">Cross-site request forgery</strong> (<strong class="bold">CSRF</strong>): This is an attack where an attacker tricks a user into unknowingly making a request to a web application on which the user is authenticated. This can lead to unauthorized actions <a id="_idIndexMarker831"/>being taken on behalf of the user without their consent.<p class="list-inset">CSRF attacks exploit the trust that a website has in a user’s browser. For instance, an unsuspecting user logs into an online banking website and gets a session cookie. The attacker creates a malicious web page that contains a hidden form that submits a request to transfer money from the user’s account to the attacker’s account.</p><p class="list-inset">The user visits the attacker’s web page, and the hidden form is submitted using the user’s session <a id="_idIndexMarker832"/>cookie, resulting in an unauthorized transfer. This type of attack exploits the trust that a website has in the user’s browser to perform unauthorized actions.</p></li>
<li><strong class="bold">Distributed Denial of Service</strong> (<strong class="bold">DDoS</strong>) <strong class="bold">attacks</strong>: This type of attack involves overwhelming <a id="_idIndexMarker833"/>a target server, service, or network with a flood of traffic from multiple sources, rendering it inaccessible to legitimate users. For instance, an attacker might use a botnet (a network of compromised computers) to send a massive amount of traffic to a web application. This can cause a web application to become slow or entirely unavailable to users.</li>
</ul>
<p>However, there are ways you can mitigate against these malicious threats, which are capable of undermining your web application. Now, we will highlight some of the best practices for securing your web application.</p>
<ul>
<li><strong class="bold">Input validation</strong>: You need to <a id="_idIndexMarker834"/>ensure that all input data is properly sanitized and validated to prevent SQL injection and XSS attacks.</li>
<li><code>SQLAlchemy</code> in Flask, handle the construction of SQL queries for you and provide a safe and efficient way to interact with databases.</li>
<li><strong class="bold">Password storage</strong>: Store passwords securely using a strong hashing algorithm and a unique salt for each user.</li>
<li><strong class="bold">Use of HTTPS</strong>: Use HTTPS to encrypt all communication between the client and the server to prevent eavesdropping and MITM attacks.</li>
<li><strong class="bold">Session management</strong>: Properly manage sessions to prevent session hijacking and fix session <a id="_idIndexMarker836"/>fixation vulnerabilities in your web application.</li>
<li><strong class="bold">Access control</strong>: Use role-based access control to restrict access to sensitive resources and functionality.</li>
<li><strong class="bold">Logging and monitoring</strong>: You need to consistently keep detailed logs of all application activity and monitor them for suspicious activity.</li>
<li><strong class="bold">Using up-to-date software</strong>: You need to regularly update the framework, libraries, and all dependencies that your web application is using to ensure that known vulnerabilities are patched.</li>
<li><code>X-XSS-Protection</code>, <code>X-Frame-Options</code>, and <code>Content-Security-Policy</code> to prevent certain types of attacks.</li>
<li><strong class="bold">Regularly testing for vulnerabilities</strong>: Regularly conduct penetration testing and <a id="_idIndexMarker837"/>vulnerability scanning to identify and fix any security issues.</li>
</ul>
<p>In the remaining parts of this chapter, we will discuss and implement authentication with authorization in a Flask web application to help you keep your application and its users’ data secure.</p>
<p>Next, we will discuss authentication and the authentication role in web applications. This will improve your understanding of how to verify users’ identities and the various types of authentications.</p>
<h1 id="_idParaDest-220"><a id="_idTextAnchor256"/>Defining authentication and the authentication role in web application</h1>
<p><strong class="bold">Authentication</strong> is the process of <a id="_idIndexMarker838"/>verifying the identity of a user and ensuring that only authorized users have access to the application’s resources and functionality. Authentication is an important aspect of any web application, including those built with Flask.</p>
<p>This is typically done by prompting the user to provide a set of credentials, such as a username and password, that the web application can use to confirm the user’s identity. The purpose of authentication in web application development is to ensure that only authorized users can access sensitive information and perform certain actions within a web application.</p>
<p>In web development, we <a id="_idIndexMarker839"/>have several types of authentication methods that can be used in any web application project. These are some of the most commonly used methods:</p>
<ul>
<li><strong class="bold">Password-based authentication</strong>: This is the most common form of authentication <a id="_idIndexMarker840"/>we encounter <a id="_idIndexMarker841"/>in everyday use and involves the user entering a username/email and password to gain access to the web application. This method is simple and easy to implement but comes with its weakness. Password-based authentication is vulnerable to attacks such as brute-force and dictionary attacks.</li>
<li><strong class="bold">Multi-factor authentication</strong> (<strong class="bold">MFA</strong>): This method adds an additional layer of security by <a id="_idIndexMarker842"/>requiring the <a id="_idIndexMarker843"/>user to provide multiple forms of identification. For instance, a user may be required to enter a password and also provide a one-time code that’s been sent to their phone or email. MFA is more secure than password-based authentication but can negatively impact the user experience.</li>
<li><strong class="bold">Token-based authentication</strong>: This method involves the user being issued a token that they <a id="_idIndexMarker844"/>must present <a id="_idIndexMarker845"/>to the web application to gain access. Tokens can be in the form of a JWT or OAuth token and are often stored in a browser’s cookies or local storage. Tokens can easily be revoked, making it easier to maintain security.</li>
<li><strong class="bold">Biometric authentication</strong>: This method involves the use of biological characteristics such <a id="_idIndexMarker846"/>as fingerprints, facial <a id="_idIndexMarker847"/>recognition, or voice recognition to verify a user’s identity. Biometric authentication is considered to be more secure <a id="_idIndexMarker848"/>than other methods but can be more <a id="_idIndexMarker849"/>expensive to implement.</li>
</ul>
<p>When you are deciding which authentication method to use, it’s crucial to consider the level of security required for the web application and the user experience. Each of these authentication methods has its pros and cons. It is essential to choose the right method for your application.</p>
<p>For instance, if you are building a web application that requires a high level of security, you may want to consider using MFA or biometric authentication. And of course, biometric authentication is rarely used in public or general-purpose web applications. If you are building a simple web application that does not require a high level of security, password-based authentication may be safe and sufficient.</p>
<p>Next, we will discuss the concept of implementing password security and hashing passwords in securing a Flask web application.</p>
<h1 id="_idParaDest-221"><a id="_idTextAnchor257"/>Implementing password security and hashing passwords</h1>
<p>In any web application <a id="_idIndexMarker850"/>that requires access, passwords are often the first line of defense against unauthorized access. As a developer, you will want to ensure that passwords are securely managed when building Flask applications. A critical component of password management in web applications is to never store passwords in plaintext.</p>
<p>Instead, passwords should <a id="_idIndexMarker851"/>be hashed, which is a one-way encryption process that produces a fixed-length output that cannot be reversed. When a user enters their password, it is hashed and compared with the stored hash. If the two hashes match, the password is correct. Hashing passwords can help protect against attacks such as brute-force and dictionary attacks.</p>
<p>Brute-force attacks involve trying every possible combination of characters to find a match, while dictionary attacks involve trying a pre-computed list of words. Hashing passwords makes it computationally infeasible for an attacker to reverse the hash and discover the original password.</p>
<p>In Flask, you can use a library such as <code>Flask-Bcrypt</code> to handle password hashing. <code>Flask-Bcrypt</code> is a Flask extension <a id="_idIndexMarker852"/>that provides <code>bcrypt</code> password hashing for Flask. <code>Flask-Bcrypt</code> provides a simple interface for hashing and checking passwords. You can also use <code>Flask-Bcrypt</code> to generate random salts for use in password hashing.</p>
<p>Let’s quickly <a id="_idIndexMarker853"/>run through an example of password <a id="_idIndexMarker854"/>hashing using <code>Flask-Bcrypt</code>:</p>
<pre class="source-code">from flask import Flask, render_template, requestfrom flask_bcrypt import Bcrypt
app = Flask(__name__)
bcrypt = Bcrypt()
@app.route("/", methods=["GET", "POST"])
def index():
    if request.method == "POST":
        password = request.form.get("password")
        password_hash =
            bcrypt.generate_password_hash(password)
                .decode('utf-8')
        return render_template("index.html",
            password_hash=password_hash)
    else:
        return render_template("index.html")
@app.route("/login", methods=["POST"])
def login():
    password = request.form.get("password")
    password_hash = request.form.get("password_hash")
//Check GitHub for the complete code
if __name__ == "__main__":
    app.run(debug=True)</pre>
<p>The preceding code <a id="_idIndexMarker855"/>uses the <code>Flask Bcrypt</code> library to hash and check a password. It imports the <code>Bcrypt</code> class and the <code>check_password_hash</code> function, creating an instance of <code>Bcrypt</code> with <a id="_idIndexMarker856"/>the Flask application. When the form is submitted, the <a id="_idIndexMarker857"/>password is hashed using the <code>flask_bcrypt</code> extension, and the hashed password is displayed back to the user on the same page. The <code>render_template</code> function is used to render the HTML templates, and the <code>Bcrypt</code> extension is used for secure password hashing.</p>
<p>Next, we will discuss access and authorization in web application development.</p>
<h1 id="_idParaDest-222"><a id="_idTextAnchor258"/>Understanding access and authorization in web application development</h1>
<p>Access and authorization in web application development is the process of controlling who has access to <a id="_idIndexMarker858"/>specific resources and actions within a web application. As a developer, you will want to design and ensure that users can only perform actions they are authorized to perform and access resources they are authorized to access in a web application.</p>
<p>As discussed earlier, authentication is the process of verifying the identity of a user. Authorization is the process of <a id="_idIndexMarker859"/>determining what a user is allowed to do within a web application. When you combine these two mechanisms, you have a system that<a id="_idIndexMarker860"/> ensures that only authorized users can access sensitive information and perform certain actions within a web application.</p>
<p>Several different types of access control methods can be used in web application development. We will discuss some of them and make specific reference to how Flask can handle access and authorization:</p>
<ul>
<li><code>Flask-Login</code> and <code>Flask-Security</code>.</li>
<li><code>Flask-OAuthlib</code>. This extension <a id="_idIndexMarker869"/>provides support for <code>OAuth 1.0a</code> and <code>OAuth 2.0</code>. <code>Flask-OAuthlib</code> makes it easy for developers to implement OAuth in their Flask applications.</p></li>
<li><code>Flask-JWT</code> and <code>Flask-JWT-Extended</code>.</p><p class="list-inset">These extensions provide features such as token generation, verification, and expiration, as <a id="_idIndexMarker874"/>well as the ability to restrict access to certain <a id="_idIndexMarker875"/>resources and actions based on the claims contained in the JWT to ensure that it was generated by a trusted source and has not been tampered with.</p></li>
<li><code>Flask-RBAC</code>.</p><p class="list-inset">The <code>Flask-RBAC</code> extension provides features such as role management, permission management, <a id="_idIndexMarker878"/>and the ability to restrict access to certain resources and actions based on the user’s role.</p></li>
<li><code>Flask-Policies</code>. <code>Flask-Policies</code> provides features such as policy management, enforcement, and the ability to restrict <a id="_idIndexMarker882"/>access to certain resources <a id="_idIndexMarker883"/>and actions based on the conditions specified in the policies.</p></li>
</ul>
<p>By using these libraries, you can easily handle user roles and permissions and restrict access to certain views and routes based on the user’s role. Next, we will take a look at how to implement authentication in a Flask web application.</p>
<h1 id="_idParaDest-223"><a id="_idTextAnchor259"/>Adding authentication to your Flask application</h1>
<p>JWT is a popular method for <a id="_idIndexMarker884"/>authentication in modern web applications. A JWT is a JSON object that is digitally signed and can be used to authenticate users by transmitting claims between parties, such as an authorization server and a resource server. In a Flask web application, you <a id="_idIndexMarker885"/>can use the <code>PyJWT</code> library to encode and decode JWTs for authentication.</p>
<p>When a user logs into a Flask application, the backend verifies the user’s credentials, such as their email and password, and if they are valid, a JWT is generated and sent back to the client. The client stores the JWT in the browser’s local storage or as a cookie. For subsequent requests to protected routes and resources, the client sends the JWT in the request header.</p>
<p>The backend decodes the JWT to verify the user’s identity, grants or denies access to the requested resources, and generates a new JWT for subsequent requests. JWT for authentication allows stateless authentication. This means that the authentication information is stored in the JWT, which can be passed around between different servers, instead of on the server’s memory. This makes it easier to scale the application and reduces the risk of data loss or corruption.</p>
<p>JWT authentication also enhances security by using digital signatures to prevent data tampering. The signature is generated using a secret key that’s shared between the server and the client. The signature ensures that the data in the JWT has not been altered in transit. JWT authentication is a secure and efficient method for authenticating users in a Flask application.</p>
<p>By implementing JWT <a id="_idIndexMarker886"/>authentication in a Flask application, <a id="_idIndexMarker887"/>developers can simplify the process of authenticating users and reduce the risk of security breaches. Let’s examine the backend and frontend implementation of JWT.</p>
<h2 id="_idParaDest-224"><a id="_idTextAnchor260"/>Flask backend</h2>
<p>The following code <a id="_idIndexMarker888"/>defines two <a id="_idIndexMarker889"/>Flask endpoints – <code>/api/v1/login</code> and <code>/api/v1/dashboard</code>:</p>
<pre class="source-code">@app.route('/api/v1/login', methods=['POST'])def login():
    email = request.json.get('email', None)
    password = request.json.get('password', None)
    if email is None or password is None:
        return jsonify({'message': 'Missing email or
            password'}), 400
    user = User.query.filter_by(email=email).first()
    if user is None or not bcrypt.check_password_hash
        (user.password, password):
        return jsonify({'message': 'Invalid email or
            password'}), 401
    access_token = create_access_token(identity=user.id)
    return jsonify({'access_token': access_token}), 200
@app.route('/api/v1/dashboard', methods=['GET'])
@jwt_required
def dashboard():
    current_user = get_jwt_identity()
    user = User.query.filter_by(id=current_user).first()
    return jsonify({'email': user.email}), 200</pre>
<p>The <code>/api/v1/login</code> endpoint is for handling user login requests. It takes in a JSON request with two properties: <code>email</code> and <code>password</code>. If either of these properties is missing, the function returns a JSON response with a message indicating <code>Missing email or password</code> and a status code of <code>400</code> (Bad Request).</p>
<p>Next, the function <a id="_idIndexMarker890"/>queries the database for a user with the given <a id="_idIndexMarker891"/>email. If no such user exists, or if the password provided does not match the hashed password stored in the database, the function returns a JSON response with a message indicating <code>Invalid email or password</code> and a status code of <code>401</code> (Unauthorized).</p>
<p>Otherwise, the function generates a JWT using the <code>create_access_token</code> function and returns it as a JSON response, along with a status code of <code>200</code> (OK). The JWT can be used to authenticate the user in subsequent requests to the backend. The <code>/api/v1/dashboard</code> endpoint is a protected endpoint that can only be accessed by users who have a valid JWT.</p>
<p>The <code>jwt_required</code> decorator is used to enforce this restriction. When this endpoint is accessed, the JWT is used to extract the user’s identity, which is then used to retrieve the user’s <code>email</code> from the database. This email is then returned as a JSON response, along with a status code of <code>200</code> (OK).</p>
<h2 id="_idParaDest-225"><a id="_idTextAnchor261"/>React frontend</h2>
<p>The following code <a id="_idIndexMarker892"/>shows a login form and a dashboard. The <code>LoginForm</code> component <a id="_idIndexMarker893"/>has three states –  <code>email</code>, <code>password</code>, and <code>accessToken</code>. When the form is submitted, it makes a <code>POST</code> request to the <code>/api/v1/login</code> endpoint with the email and password data, and the response of the request is stored in the <code>accessToken</code> state:</p>
<pre class="source-code">import React, { useState } from 'react';import axios from 'axios';
const LoginForm = () =&gt; {
  const [email, setEmail] = useState('');
  const [password, setPassword] = useState('');
  const [accessToken, setAccessToken] = useState('');
  const handleSubmit = async (event) =&gt; {
    event.preventDefault();
    try {
      const res = await axios.post('/api/v1/login', {
        email, password });
      setAccessToken(res.data.access_token);
    } catch (err) {
      console.error(err);
    }
  };
  return (
    &lt;&gt;
      {accessToken ? (
        &lt;Dashboard accessToken={accessToken} /&gt;
      ) : (
        &lt;form onSubmit={handleSubmit}&gt;
          ....
          /&gt;
          &lt;button type="submit"&gt;Login&lt;/button&gt;
        &lt;/form&gt;
      )}
    &lt;/&gt;
  );
};
};
 export default LoginForm;</pre>
<p>The <code>Dashboard</code> component takes an <code>accessToken</code> prop and has one state, <code>email</code>. It makes a <code>GET</code> request <a id="_idIndexMarker894"/>to the <code>/api/v1/dashboard</code> endpoint <a id="_idIndexMarker895"/>with an authorization header set to <code>accessToken</code>, and the response is stored in the <code>email</code> state. The component displays a message stating <code>"Welcome to </code><code>dashboard, [email]!"</code>.</p>
<p>The <code>LoginForm</code> component returns either the <code>Dashboard</code> component if <code>accessToken</code> is truthy, or the login form if <code>accessToken</code> is <code>falsy</code>.</p>
<p>Next, we will discuss how to identify web application users and manage their information.</p>
<h1 id="_idParaDest-226"><a id="_idTextAnchor262"/>Identifying system users and managing their information</h1>
<p>In most web applications, <a id="_idIndexMarker896"/>users are identified by a unique identifier <a id="_idIndexMarker897"/>such as a username or email address. Typically, in a Flask application, you can use a database to store user information, such as usernames, email addresses, and hashed passwords.</p>
<p>When a user attempts to log in, the entered credentials (username and password) are compared to the information stored in the database. If the entered credentials match, the user is authenticated, and a session is created for that user. In Flask, you can use the built-in session object to store and retrieve user information.</p>
<p>By using sessions, you can easily identify users in a Flask web application and retrieve information about <a id="_idIndexMarker898"/>them. However, it’s important to note that sessions <a id="_idIndexMarker899"/>are vulnerable to session hijacking attacks. So, it’s essential to use secure session management techniques such as regenerating session IDs after login and using secure cookies.</p>
<p>Let’s examine an implementation example:</p>
<pre class="source-code">from flask import Flask, request, redirect, session, jsonifyapp = Flask(__name__)
app.secret_key = 'secret_key'
@app.route('/login', methods=['POST'])
def login():
    data = request.get_json()
    email = data.get('email')
    password = data.get('password')
    session['email'] = email
    return jsonify({'message': 'Login successful'}), 201
@app.route('/dashboard', methods=['GET'])
def dashboard():
    email = session.get('email')
    user = User.query.filter_by(email=email).first()
    return jsonify({'email': email, 'user':
        user.to_dict()}), 200</pre>
<p>In the preceding code, the first line imports the required modules from the Flask library. The next line creates an instance of the <code>Flask</code> class and assigns it to the <code>app</code> variable. The <code>app.secret_key</code> attribute is set to <code>'secret_key'</code>, which is used to securely sign the session cookie.</p>
<p>The login function is defined as a POST endpoint at the <code>api/v1/login</code> route. This endpoint uses the <code>request.get_json()</code> method to get the JSON data from the request body and extract the values for <code>email</code> and <code>password</code>. <code>email</code> is then stored in the session using <code>session['email'] = email</code>. The function returns a JSON response with a message of <code>"Login successful"</code> and a <code>201</code> status code, indicating the successful creation of a resource.</p>
<p>Then, the dashboard function is defined as a GET endpoint at the <code>api/v1/dashboard</code> route. It retrieves <code>email</code> from the session using <code>session.get('email')</code>. The function then queries the database for a user with the specified email using <code>User.query.filter_by(email=email).first()</code>. The <code>email</code> and user data (converted into a dictionary using <code>to_dict()</code>) are returned in a JSON response with a 200 status code, indicating the successful retrieval of a resource.</p>
<p>You can also identify <a id="_idIndexMarker900"/>users in a Flask application with a token-based authentication <a id="_idIndexMarker901"/>method. In this method, a token is issued to the user when they log in, and the token is stored in the user’s browser as a cookie or placed in local storage. This token is then sent with each subsequent request made by the user, and the server uses this token to identify the user. JWT is a commonly used token format, and libraries such as <code>Flask-JWT</code> and <code>Flask-JWT-Extended</code> make it easy to implement JWT-based authentication in Flask.</p>
<p>Next, we will delve deeper into tracking a user’s session in a web application.</p>
<h1 id="_idParaDest-227"><a id="_idTextAnchor263"/>Session management</h1>
<p><code>Flask-Session</code>; on the frontend React side, you can use React’s <code>localStorage</code> or <code>sessionStorage</code>.</p>
<p>Flask thrives on its simplicity as a framework of choice for Python that makes it easy to build small to enterprise-sized web applications. Flask can manage user sessions using the built-in session object and some of the available Flask extensions contributed by the community members.</p>
<p>A session object is a dictionary-like <a id="_idIndexMarker903"/>object that is stored on the server and can be accessed by the <a id="_idIndexMarker904"/>client via a secure session cookie. To use a session object, a <em class="italic">secret key</em> must be set in the Flask application. This secret key is used to encrypt and <a id="_idIndexMarker905"/>sign the session data, which is stored in a secure cookie on the <a id="_idIndexMarker906"/>client’s browser. When a user visits a protected resource, the server verifies the session cookie and grants access if the cookie is valid.</p>
<p>Let’s implement session management in a Flask backend and React frontend. We will create a counter endpoint that keeps track of the number of times a user visited a dashboard page.</p>
<h2 id="_idParaDest-228"><a id="_idTextAnchor264"/>Flask backend</h2>
<p>We will use <code>Flask-Session</code> to store session data and securely manage sessions. To use <code>Flask-Session</code>, you <a id="_idIndexMarker907"/>need to install it first. You can do <a id="_idIndexMarker908"/>this by running the <code>pip install flask-session</code> command in the Terminal.</p>
<p>Once you’ve installed <code>Flask-Session</code>, you need to add the following code to your Flask application:</p>
<pre class="source-code">from flask import Flask, sessionfrom flask_session import Session
app = Flask(__name__)
app.config["SESSION_TYPE"] = "filesystem"
Session(app)
@app.route("/api/v1/couters")
def visit_couter():
    session["counter"] = session.get("counter", 0) + 1
    return "Hey , you have visited this page:
        {}".format(session["counter"])</pre>
<p>The preceding code shows a simple implementation of session management in a Flask backend:</p>
<ol>
<li>The first line imports the Flask module, while the second line imports the <code>Flask-Session</code> extension.</li>
<li>The next few lines <a id="_idIndexMarker909"/>create a Flask application object <a id="_idIndexMarker910"/>and configure the session type to be stored on the filesystem.</li>
<li>The <code>Session</code> object is then initialized with the Flask application object as its argument.</li>
<li>The <code>@app.route</code> decorator creates a route – in this case, <code>/api/v1/counters</code> – for the <code>visit_counter</code> function.</li>
<li>The <code>visit_counter</code> function retrieves the current value of the <code>counter</code> key in the session or sets it to <code>0</code> if it doesn’t exist, and then increments the value by <code>1</code>. The updated value is then returned to the user in the response.</li>
</ol>
<p>Let’s explore the React frontend part of this implementation.</p>
<h2 id="_idParaDest-229"><a id="_idTextAnchor265"/>React Frontend</h2>
<p>You can use the <a id="_idIndexMarker911"/>Axios library to send HTTP requests to <a id="_idIndexMarker912"/>the Flask server. If not installed yet, you can install Axios with the <code>npm install </code><code>axios</code> command.</p>
<p>Once you’ve installed Axios, you can use it to send an HTTP request to the Flask server to set or get the session data:</p>
<pre class="source-code">import React, { useState } from "react";import axios from "axios";
function VisitCouter() {
    const [counter, setCounter] = useState(0);
    const getCounter = async () =&gt; {
        const response = await axios.get(
            "http://localhost:5000/api/v1/counters");
        setCounter(response.data.counter);
        };
        return (
          &lt;div&gt;
            &lt;h1&gt;You have visited this page: {counter}
              times!&lt;/h1&gt;
            &lt;button onClick={getCounter}&gt;Get Counter
              &lt;/button&gt;
          &lt;/div&gt;
        );
}
export default VisitCounter;</pre>
<p>The preceding code demonstrates the frontend implementation of a React frontend that retrieves the visit counter from a Flask backend:</p>
<ol>
<li>The first line <a id="_idIndexMarker913"/>imports the required <a id="_idIndexMarker914"/>libraries – that is, <code>React</code> and <code>axios</code>.</li>
<li>The next section declares the <code>VisitCounter</code> function component, which returns a view for the user.</li>
<li>Within the component, the state variable counter is initialized using the <code>useState</code> hook.</li>
<li>The <code>getCounter</code> function uses the <code>axios</code> library to make a <code>GET</code> request to the <code>/api/v1/counters</code> endpoint on the Flask backend. The response from the backend, which contains the updated counter value, is then used to update the counter state variable.</li>
<li>The component <a id="_idIndexMarker915"/>returns a div that displays the <a id="_idIndexMarker916"/>value of the counter and a button that, when clicked, triggers the <code>getCounter</code> function to retrieve the updated counter value from the backend.</li>
</ol>
<p>Next, we will discuss how to create a password-protected dashboard in a Flask-React web application.</p>
<h1 id="_idParaDest-230"><a id="_idTextAnchor266"/>Creating a password-protected dashboard</h1>
<p>Protecting pages in a web application is essential for maintaining security and privacy. By extension, this can <a id="_idIndexMarker917"/>help prevent unauthorized access to sensitive information. In this section, you will be implementing a protected dashboard page in a Flask-React web application.</p>
<p>A dashboard is a user-friendly <a id="_idIndexMarker918"/>interface that provides an overview of data and information. The data that’s displayed on a dashboard can come from a variety of sources, such as databases, spreadsheets, and APIs.</p>
<h2 id="_idParaDest-231"><a id="_idTextAnchor267"/>Flask backend</h2>
<p>The following code <a id="_idIndexMarker919"/>demonstrates an <a id="_idIndexMarker920"/>implementation that allows an admin user to log in and see a protected dashboard page. We will implement minimalist login and logout endpoints that define login and logout functionality and protect the <code>dashboard</code> endpoint. The application uses the <code>Flask-Session</code> library to store session data in the filesystem:</p>
<pre class="source-code">from flask import Flask, request, jsonify, sessionfrom flask_session import Session
app = Flask(__name__)
app.config["SESSION_TYPE"] = "filesystem"
Session(app)
@app.route("/api/v1/login", methods=["POST"])
def login():
    username = request.json.get("username")
    password = request.json.get("password")
    if username == "admin" and password == "secret":
        session["logged_in"] = True
        return jsonify({"message": "Login successful"})
    else:
        return jsonify({"message": "Login failed"}), 401
@app.route("/api/v1/logout")
def logout():
    session.pop("logged_in", None)
    return jsonify({"message": "Logout successful"})
@app.route("/api/v1/dashboard")
def dashboard():
    if "logged_in" not in session:
        return jsonify({"message": "Unauthorized access"}),
            401
    else:
        return jsonify({"message": "Welcome to the
            dashboard"})</pre>
<p>In the <code>login</code> endpoint, the <a id="_idIndexMarker921"/>application <a id="_idIndexMarker922"/>receives a <code>POST</code> request with the <code>username</code> and <code>password</code> parameters in the request body in JSON format. The code checks if the <code>username</code> and <code>password</code> parameters match the predefined values – that is, <code>admin</code> and <code>secret</code>. If the values match, the code sets the <code>logged_in</code> key in the session data to <code>True</code>, indicating that the user is logged in.</p>
<p>It returns a JSON response with a message stating <code>Login successful</code>. If the values don’t match, the code returns a JSON response with a message stating <code>Login failed</code> and a <code>401</code> HTTP status code, indicating unauthorized access.</p>
<p>The <code>logout</code> endpoint <a id="_idIndexMarker923"/>removes the <code>logged_in</code> key <a id="_idIndexMarker924"/>from the session data, indicating that the user is logged out. It returns a JSON response with a message stating <code>Logout successful</code>.</p>
<p>The dashboard endpoint checks if the <code>logged_in</code> key exists in the session data. If it does not, the code returns a JSON response with a message stating <code>Unauthorized access</code> and a <code>401</code> HTTP status code. If the <code>logged_in</code> key exists, the code returns a JSON response with a message stating <code>"Welcome to </code><code>the dashboard"</code>.</p>
<h2 id="_idParaDest-232"><a id="_idTextAnchor268"/>React frontend</h2>
<p>The following code <a id="_idIndexMarker925"/>snippet is a React component <a id="_idIndexMarker926"/>that displays a dashboard for a user. It uses React hooks, specifically <code>useState</code> and <code>useEffect</code>, to manage its state and update the user interface:</p>
<pre class="source-code">import React, { useState, useEffect } from "react";import axios from "axios";
function Dashboard() {
  const [isLoggedIn, setIsLoggedIn] = useState(false);
  const [message, setMessage] = useState("");
  const checkLogin = async () =&gt; {
    const response = await axios.get(
      "http://localhost:5000/api/v1/dashboard");
    if (response.status === 200) {
      setIsLoggedIn(true);
      setMessage(response.data.message);
    }
  };
  useEffect(() =&gt; {
  checkLogin();
  }, []);
  if (!isLoggedIn) {
    return &lt;h1&gt;Unauthorized access&lt;/h1&gt;;
  }
  return &lt;h1&gt;{message}&lt;/h1&gt;;
}
export default Dashboard;</pre>
<p>When the component is rendered, it makes an HTTP <code>GET</code> request to <code>http://localhost:5000/api/v1/dashboard</code> using the <code>axios</code> library. This is done in the <code>checkLogin</code> function, which is called by the <code>useEffect</code> hook when the component is mounted.</p>
<p>If the response <a id="_idIndexMarker927"/>from the server is <code>200 OK</code>, this <a id="_idIndexMarker928"/>means that the user is authorized to access the dashboard. The component’s state is updated to reflect this by setting <code>isLoggedIn</code> to <code>true</code> and <code>message</code> to the message returned from the server. If the response is not <code>200 OK</code>, this means the user is unauthorized and <code>isLoggedIn</code> remains <code>false</code>.</p>
<p>Finally, the component returns a message that tells the user whether they have access to the dashboard. If <code>isLoggedIn</code> is <code>false</code>, it returns <code>Unauthorized access</code>. If <code>isLoggedIn</code> is <code>true</code>, it returns the message from the server.</p>
<p>In this way, you can create a password-protected dashboard that is only accessible to authenticated users using React and Flask with added security for your application.</p>
<p>Next, you will learn how to implement flash messages in Flask and React web applications.</p>
<h1 id="_idParaDest-233"><a id="_idTextAnchor269"/>Implementing flash messages in Flask</h1>
<p>Flash messages enhance the user experience in any web application, providing informative <a id="_idIndexMarker929"/>and timely feedback to users. Flash is used to display status or error messages on web pages after a redirect. For instance, after a successful form submission, a message can be stored in the flash to display a success message on the redirected page.</p>
<p>The flash message is stored in the user’s session, which is a dictionary-like object that can store information between requests. With flash messages, you can pass information between requests securely and efficiently. This is useful for displaying messages that don’t need to persist for a long time or that need to be shown only once, such as success or error messages. Since flash messages are stored in the user’s session, they are only accessible by the server and are not sent to the client in plain text, making them secure.</p>
<p>Let’s modify the login and logout endpoints to show flash messages.</p>
<h2 id="_idParaDest-234"><a id="_idTextAnchor270"/>Flask backend</h2>
<p>The following code <a id="_idIndexMarker930"/>demonstrates the implementation of a flash message system with login and logout endpoints. The code starts by importing the necessary modules and creating a Flask application. The <code>app.secret_key = "secret_key"</code> line sets the secret key, which is used to encrypt the flash messages stored in the session:</p>
<pre class="source-code">from flask import Flask, request, jsonify, session, flashfrom flask_session import Session
app = Flask(__name__)
app.config["SESSION_TYPE"] = "filesystem"
app.secret_key = "secret_key"
Session(app)
@app.route("/api/v1/login", methods=["POST"])
def login():
    username = request.json.get("username")
    password = request.json.get("password")
    if username == "admin" and password == "secret":
        session["logged_in"] = True
        flash("Login successful")
        return jsonify({"message": "Login successful"})
    else:
        flash("Login failed")
        return jsonify({"message": "Login failed"}), 401
@app.route("/api/v1/logout")
def logout():
    session.pop("logged_in", None)
    flash("Logout successful")
    return jsonify({"message": "Logout successful"})</pre>
<p>The <code>login</code> endpoint is defined by the <code>login</code> function, which is bound to the <code>/api/v1/login</code> URL. The <a id="_idIndexMarker931"/>function retrieves the <code>username</code> and <code>password</code> values from the JSON data in the request, and checks if they match the predefined values of <code>"admin"</code> and <code>"secret"</code>. If the values match, the user’s session is marked as logged in by setting the <code>logged_in</code> key in the session, and a flash message is set to indicate that the login was successful.</p>
<p>The function then returns a JSON response, indicating the login was successful. If the values do not match, a flash message is set, indicating the login failed, and a JSON response indicating the login failure is returned. The logout endpoint is defined by the <code>logout</code> function, which is bound to the <code>/</code><code>api/v1/logout</code> URL.</p>
<p>The function removes the <code>logged_in</code> key from the session, indicating that the user is no longer logged in, and <a id="_idIndexMarker932"/>sets a flash message indicating that the logout was successful. A JSON response indicating the logout was successful is then returned.</p>
<h2 id="_idParaDest-235"><a id="_idTextAnchor271"/>React frontend</h2>
<p>The following <a id="_idIndexMarker933"/>snippet demonstrates a React functional <a id="_idIndexMarker934"/>component that represents the dashboard of a web application handling flash messages from the backend. The <code>Dashboard</code> component makes use of <code>useState</code> and <code>useEffect</code> hooks:</p>
<pre class="source-code">import React, { useState, useEffect } from "react";import axios from "axios";
function Dashboard() {
    const [isLoggedIn, setIsLoggedIn] = useState(false);
    const [message, setMessage] = useState("");
    const [flashMessage, setFlashMessage] = useState("");
    const checkLogin = async () =&gt; {
        const response = await axios.get(
            "http://localhost:5000/api/v1/dashboard");
        if (response.status === 200) {
            setIsLoggedIn(true);
            setMessage(response.data.message);
        }
    };
                    .....
        if (!isLoggedIn) {
            return (
                &lt;div&gt;
                    &lt;h1&gt;Unauthorized access&lt;/h1&gt;
                    &lt;h2&gt;{flashMessage}&lt;/h2&gt;
                    &lt;button onClick={() =&gt;
                        handleLogin("admin", "secret")}&gt;
                        Login&lt;/button&gt;</pre>
<p>The <code>Dashboard</code> component keeps track of the following state variables:</p>
<ul>
<li><code>isLoggedIn</code>: A Boolean value <a id="_idIndexMarker935"/>indicating if the user is logged in or not. It is initially set to <code>false</code>.</li>
<li><code>message</code>: A string value that represents a message that is displayed on the dashboard.</li>
<li><code>flashMessage</code>: A string value that represents a flash message that is displayed on the page.</li>
</ul>
<p>The <code>Dashboard</code> component has three functions:</p>
<ul>
<li><code>checkLogin</code>: An asynchronous function that makes a <code>GET</code> request to the <code>/api/v1/dashboard</code> endpoint <a id="_idIndexMarker936"/>to check if the user is logged in or not. If the response status is <code>200</code>, it updates the <code>isLoggedIn</code> state variables to <code>true</code> and messages a value of <code>response.data.message</code>.</li>
<li><code>handleLogin</code>: An asynchronous function that makes a <code>POST</code> request to the <code>/api/v1/login</code> endpoint <a id="_idIndexMarker937"/>with the provided <code>username</code> and <code>password</code> values as the request body. If the response status is <code>200</code>, it <a id="_idIndexMarker938"/>updates the <code>isLoggedIn</code> state variables to <code>true</code> and <code>flashMessage</code> to the value of <code>response.data.message</code>. If the response status is not <code>200</code>, it updates <code>flashMessage</code> to the value of <code>response.data.message</code>.</li>
<li><code>handleLogout</code>: An asynchronous function that makes a <code>GET</code> request to the <code>/api/v1/logout</code> endpoint. If the <a id="_idIndexMarker939"/>response status is <code>200</code>, it updates the <code>isLoggedIn</code> state variables to <code>false</code> and <code>flashMessage</code> to the value of <code>response.data.message</code>.</li>
</ul>
<p>The <code>useEffect</code> hook is used to call the <code>checkLogin</code> function when the component is mounted.</p>
<p>Finally, the component <a id="_idIndexMarker940"/>returns a UI, depending on the value <a id="_idIndexMarker941"/>of <code>isLoggedIn:</code>. If the user is not logged in, it displays a message saying <code>"Unauthorized access"</code> and a <code>"</code><code>Login successful"</code>.</p>
<p>In this way, you can use flash messages to provide feedback to the user in a React application via the frontend, and then use the Flask backend to enhance the user’s experience. Overall, flash messages make web applications more interactive and user-friendly.</p>
<h1 id="_idParaDest-236"><a id="_idTextAnchor272"/>Summary</h1>
<p>This chapter has provided a comprehensive overview of the fundamentals of information security and how to secure a Flask web application using authentication and authorization. You learned about the best practices and were provided with use cases for implementing authentication and authorization in a Flask application. We also discussed different types of authentication methods and access control methods.</p>
<p>You explored how to manage user sessions and implement password-protected dashboards. Additionally, this chapter has shown you how to use flash messages to provide feedback to users of web applications. You are expected to have garnered a solid understanding of how to secure a Flask application and be able to implement authentication and authorization in your projects.</p>
<p>In the next chapter, we will discuss how to handle errors in Flask web applications with React handling the frontend part of it. We will delve into in-built Flask debugging capabilities and learn how to handle custom error messages in React-Flask applications.</p>
</div>
</body></html>