<html><head></head><body>
<div id="_idContainer098">
<h1 class="chapter-number" id="_idParaDest-216"><a id="_idTextAnchor252"/><span class="koboSpan" id="kobo.1.1">12</span></h1>
<h1 id="_idParaDest-217"><a id="_idTextAnchor253"/><span class="koboSpan" id="kobo.2.1">Authentication and Authorization</span></h1>
<p><span class="koboSpan" id="kobo.3.1">In building full-stack web applications, you will more than often want to implement a system that allows users to trust you with their sensitive information. </span><span class="koboSpan" id="kobo.3.2">As a full-stack web developer, it is crucial to understand how to implement robust authentication and authorization mechanisms. </span><span class="koboSpan" id="kobo.3.3">You need to know how to protect the security of user data and the integrity of your application. </span><span class="koboSpan" id="kobo.3.4">Imagine you are building an e-commerce website that allows users to make </span><span class="No-Break"><span class="koboSpan" id="kobo.4.1">online purchases.</span></span></p>
<p><span class="koboSpan" id="kobo.5.1">If you do not properly authenticate and authorize users, it would be possible for someone to gain unauthorized access to the website and place orders using someone else’s personal information. </span><span class="koboSpan" id="kobo.5.2">This could result in financial loss for the legitimate user as well as damage to the reputation of an online business or that of </span><span class="No-Break"><span class="koboSpan" id="kobo.6.1">your clients.</span></span></p>
<p><span class="koboSpan" id="kobo.7.1">Furthermore, if you fail to properly authenticate and authorize users, it could also open your web application up to attacks such as SQL injection, where an attacker can gain access to sensitive information stored in your database. </span><span class="koboSpan" id="kobo.7.2">This could lead to the loss of customer data and legal repercussions may be staring you in </span><span class="No-Break"><span class="koboSpan" id="kobo.8.1">the face.</span></span></p>
<p><span class="koboSpan" id="kobo.9.1">In this chapter, we will delve into the world of web security and explore the best practices and techniques for securing Flask web applications. </span><span class="koboSpan" id="kobo.9.2">As the famous computer scientist Bruce Schneier once said, </span><em class="italic"><span class="koboSpan" id="kobo.10.1">Security is a process, not a product</span></em><span class="koboSpan" id="kobo.11.1"> (</span><a href="https://www.schneier.com/essays/archives/2000/04/the_process_of_secur.html"><span class="koboSpan" id="kobo.12.1">https://www.schneier.com/essays/archives/2000/04/the_process_of_secur.html</span></a><span class="koboSpan" id="kobo.13.1">). </span><span class="koboSpan" id="kobo.13.2">This chapter will equip you with the knowledge and skills needed to understand the importance of information security and how to implement it in a </span><span class="No-Break"><span class="koboSpan" id="kobo.14.1">Flask application.</span></span></p>
<p><span class="koboSpan" id="kobo.15.1">From understanding the fundamentals of authentication and authorization to managing user sessions and creating accounts with secure passwords, this chapter will cover the crucial elements of web application security. </span><span class="koboSpan" id="kobo.15.2">We will examine the process of securing your Flask application and show you how to implement these concepts </span><span class="No-Break"><span class="koboSpan" id="kobo.16.1">in practice.</span></span></p>
<p><span class="koboSpan" id="kobo.17.1">In this chapter, you will learn about the </span><span class="No-Break"><span class="koboSpan" id="kobo.18.1">following topics:</span></span></p>
<ul>
<li><span class="koboSpan" id="kobo.19.1">Understanding the fundamentals of </span><span class="No-Break"><span class="koboSpan" id="kobo.20.1">information security</span></span></li>
<li><span class="koboSpan" id="kobo.21.1">Defining authentication and the authentication role in </span><span class="No-Break"><span class="koboSpan" id="kobo.22.1">web applications</span></span></li>
<li><span class="koboSpan" id="kobo.23.1">Implementing password security and </span><span class="No-Break"><span class="koboSpan" id="kobo.24.1">hashing passwords</span></span></li>
<li><span class="koboSpan" id="kobo.25.1">Understanding access and authorization in web </span><span class="No-Break"><span class="koboSpan" id="kobo.26.1">application development</span></span></li>
<li><span class="koboSpan" id="kobo.27.1">Adding authentication to your </span><span class="No-Break"><span class="koboSpan" id="kobo.28.1">Flask application</span></span></li>
<li><span class="koboSpan" id="kobo.29.1">Identifying system users and managing </span><span class="No-Break"><span class="koboSpan" id="kobo.30.1">their information</span></span></li>
<li><span class="No-Break"><span class="koboSpan" id="kobo.31.1">Session management</span></span></li>
<li><span class="koboSpan" id="kobo.32.1">Creating a </span><span class="No-Break"><span class="koboSpan" id="kobo.33.1">password-protected dashboard</span></span></li>
<li><span class="koboSpan" id="kobo.34.1">Implementing flash messages </span><span class="No-Break"><span class="koboSpan" id="kobo.35.1">in Flask</span></span></li>
</ul>
<h1 id="_idParaDest-218"><a id="_idTextAnchor254"/><span class="koboSpan" id="kobo.36.1">Technical requirements</span></h1>
<p><span class="koboSpan" id="kobo.37.1">The complete code for this chapter is available on GitHub </span><span class="No-Break"><span class="koboSpan" id="kobo.38.1">at: </span></span><a href="https://github.com/PacktPublishing/Full-Stack-Flask-and-React/tree/main/Chapter12"><span class="No-Break"><span class="koboSpan" id="kobo.39.1">https://github.com/PacktPublishing/Full-Stack-Flask-and-React/tree/main/Chapter12</span></span></a><span class="No-Break"><span class="koboSpan" id="kobo.40.1">.</span></span></p>
<h1 id="_idParaDest-219"><a id="_idTextAnchor255"/><span class="koboSpan" id="kobo.41.1">Understanding the fundamentals of information security</span></h1>
<p><span class="koboSpan" id="kobo.42.1">Information security is a critical aspect of web application development. </span><span class="koboSpan" id="kobo.42.2">In today’s digital age, personal and </span><a id="_idIndexMarker823"/><span class="koboSpan" id="kobo.43.1">sensitive information is often stored </span><a id="_idIndexMarker824"/><span class="koboSpan" id="kobo.44.1">and transmitted through web applications, making them vulnerable </span><a id="_idIndexMarker825"/><span class="koboSpan" id="kobo.45.1">to various types of security threats. </span><span class="koboSpan" id="kobo.45.2">These threats can range </span><a id="_idIndexMarker826"/><span class="koboSpan" id="kobo.46.1">from simple attacks such as </span><strong class="bold"><span class="koboSpan" id="kobo.47.1">SQL injection</span></strong><span class="koboSpan" id="kobo.48.1"> and </span><strong class="bold"><span class="koboSpan" id="kobo.49.1">cross-site scripting</span></strong><span class="koboSpan" id="kobo.50.1"> (</span><strong class="bold"><span class="koboSpan" id="kobo.51.1">XSS</span></strong><span class="koboSpan" id="kobo.52.1">) to more </span><a id="_idIndexMarker827"/><span class="koboSpan" id="kobo.53.1">complex attacks such as </span><strong class="bold"><span class="koboSpan" id="kobo.54.1">man-in-the-middle</span></strong><span class="koboSpan" id="kobo.55.1"> (</span><strong class="bold"><span class="koboSpan" id="kobo.56.1">MITM</span></strong><span class="koboSpan" id="kobo.57.1">) and </span><strong class="bold"><span class="koboSpan" id="kobo.58.1">distributed denial of </span></strong><span class="No-Break"><strong class="bold"><span class="koboSpan" id="kobo.59.1">service</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.60.1"> (</span></span><span class="No-Break"><strong class="bold"><span class="koboSpan" id="kobo.61.1">DDoS</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.62.1">).</span></span></p>
<p><span class="koboSpan" id="kobo.63.1">Let’s delve deeper into some of the various types of threats that can compromise your web </span><span class="No-Break"><span class="koboSpan" id="kobo.64.1">application security:</span></span></p>
<ul>
<li><strong class="bold"><span class="koboSpan" id="kobo.65.1">SQL injection</span></strong><span class="koboSpan" id="kobo.66.1">: This is a type of cyberattack in which an attacker injects malicious SQL code into </span><a id="_idIndexMarker828"/><span class="koboSpan" id="kobo.67.1">an application’s input fields to trick the application into executing unintended database actions. </span><span class="koboSpan" id="kobo.67.2">This can lead to unauthorized access, data manipulation, or even </span><span class="No-Break"><span class="koboSpan" id="kobo.68.1">data leakage.</span></span><p class="list-inset"><span class="koboSpan" id="kobo.69.1">For instance, consider a web application login form where a user enters their </span><strong class="source-inline"><span class="koboSpan" id="kobo.70.1">username</span></strong><span class="koboSpan" id="kobo.71.1"> and </span><strong class="source-inline"><span class="koboSpan" id="kobo.72.1">password</span></strong><span class="koboSpan" id="kobo.73.1"> details. </span><span class="koboSpan" id="kobo.73.2">If the application is vulnerable to SQL injection, an attacker could input something like </span><strong class="source-inline"><span class="koboSpan" id="kobo.74.1">' OR '1'='1</span></strong><span class="koboSpan" id="kobo.75.1"> in the </span><span class="No-Break"><span class="koboSpan" id="kobo.76.1">password field.</span></span></p><p class="list-inset"><span class="koboSpan" id="kobo.77.1">The SQL query may </span><a id="_idIndexMarker829"/><span class="koboSpan" id="kobo.78.1">then become </span><strong class="source-inline"><span class="koboSpan" id="kobo.79.1">SELECT * FROM users WHERE username = 'username' AND password = '' OR '1'='1';</span></strong><span class="koboSpan" id="kobo.80.1">, which would potentially allow the attacker to log in without a </span><span class="No-Break"><span class="koboSpan" id="kobo.81.1">valid password.</span></span></p></li>
<li><strong class="bold"><span class="koboSpan" id="kobo.82.1">Cross-site scripting</span></strong> <strong class="bold"><span class="koboSpan" id="kobo.83.1">(XSS</span></strong><span class="koboSpan" id="kobo.84.1">): This is a vulnerability that allows attackers to inject malicious scripts </span><a id="_idIndexMarker830"/><span class="koboSpan" id="kobo.85.1">into web pages viewed by other site users. </span><span class="koboSpan" id="kobo.85.2">These scripts can steal user information, manipulate page content, or perform other </span><span class="No-Break"><span class="koboSpan" id="kobo.86.1">malicious actions.</span></span><p class="list-inset"><span class="koboSpan" id="kobo.87.1">For instance, imagine your Flask application displays user comments on a web page without </span><span class="No-Break"><span class="koboSpan" id="kobo.88.1">proper sanitization:</span></span></p><pre class="source-code"><span class="koboSpan" id="kobo.89.1">comment = request.form['comment']html = f"&lt;p&gt;{comment}&lt;/p&gt;"</span></pre><p class="list-inset"><span class="koboSpan" id="kobo.90.1">If an attacker submits a comment such as </span><strong class="source-inline"><span class="koboSpan" id="kobo.91.1">&lt;script&gt;malicious_scripts()&lt;/script&gt;</span></strong><span class="koboSpan" id="kobo.92.1">, other users viewing the comment section might execute the </span><span class="No-Break"><span class="koboSpan" id="kobo.93.1">script unintentionally.</span></span></p></li>
<li><strong class="bold"><span class="koboSpan" id="kobo.94.1">Cross-site request forgery</span></strong><span class="koboSpan" id="kobo.95.1"> (</span><strong class="bold"><span class="koboSpan" id="kobo.96.1">CSRF</span></strong><span class="koboSpan" id="kobo.97.1">): This is an attack where an attacker tricks a user into unknowingly making a request to a web application on which the user is authenticated. </span><span class="koboSpan" id="kobo.97.2">This can lead to unauthorized actions </span><a id="_idIndexMarker831"/><span class="koboSpan" id="kobo.98.1">being taken on behalf of the user without </span><span class="No-Break"><span class="koboSpan" id="kobo.99.1">their consent.</span></span><p class="list-inset"><span class="koboSpan" id="kobo.100.1">CSRF attacks exploit the trust that a website has in a user’s browser. </span><span class="koboSpan" id="kobo.100.2">For instance, an unsuspecting user logs into an online banking website and gets a session cookie. </span><span class="koboSpan" id="kobo.100.3">The attacker creates a malicious web page that contains a hidden form that submits a request to transfer money from the user’s account to the </span><span class="No-Break"><span class="koboSpan" id="kobo.101.1">attacker’s account.</span></span></p><p class="list-inset"><span class="koboSpan" id="kobo.102.1">The user visits the attacker’s web page, and the hidden form is submitted using the user’s session </span><a id="_idIndexMarker832"/><span class="koboSpan" id="kobo.103.1">cookie, resulting in an unauthorized transfer. </span><span class="koboSpan" id="kobo.103.2">This type of attack exploits the trust that a website has in the user’s browser to perform </span><span class="No-Break"><span class="koboSpan" id="kobo.104.1">unauthorized actions.</span></span></p></li>
<li><strong class="bold"><span class="koboSpan" id="kobo.105.1">Distributed Denial of Service</span></strong><span class="koboSpan" id="kobo.106.1"> (</span><strong class="bold"><span class="koboSpan" id="kobo.107.1">DDoS</span></strong><span class="koboSpan" id="kobo.108.1">) </span><strong class="bold"><span class="koboSpan" id="kobo.109.1">attacks</span></strong><span class="koboSpan" id="kobo.110.1">: This type of attack involves overwhelming </span><a id="_idIndexMarker833"/><span class="koboSpan" id="kobo.111.1">a target server, service, or network with a flood of traffic from multiple sources, rendering it inaccessible to legitimate users. </span><span class="koboSpan" id="kobo.111.2">For instance, an attacker might use a botnet (a network of compromised computers) to send a massive amount of traffic to a web application. </span><span class="koboSpan" id="kobo.111.3">This can cause a web application to become slow or entirely unavailable </span><span class="No-Break"><span class="koboSpan" id="kobo.112.1">to users.</span></span></li>
</ul>
<p><span class="koboSpan" id="kobo.113.1">However, there are ways you can mitigate against these malicious threats, which are capable of undermining your web application. </span><span class="koboSpan" id="kobo.113.2">Now, we will highlight some of the best practices for securing your </span><span class="No-Break"><span class="koboSpan" id="kobo.114.1">web application.</span></span></p>
<ul>
<li><strong class="bold"><span class="koboSpan" id="kobo.115.1">Input validation</span></strong><span class="koboSpan" id="kobo.116.1">: You need to </span><a id="_idIndexMarker834"/><span class="koboSpan" id="kobo.117.1">ensure that all input data is properly sanitized and validated to prevent SQL injection and </span><span class="No-Break"><span class="koboSpan" id="kobo.118.1">XSS attacks.</span></span></li>
<li><strong class="bold"><span class="koboSpan" id="kobo.119.1">Use prepared statements</span></strong><span class="koboSpan" id="kobo.120.1">: Prepared statements allow you to create a database-independent API for executing SQL statements. </span><span class="koboSpan" id="kobo.120.2">Prepared statements can only be executed, not constructed, which makes it much harder for an attacker to inject malicious </span><a id="_idIndexMarker835"/><span class="koboSpan" id="kobo.121.1">code into the database. </span><span class="koboSpan" id="kobo.121.2">ORM libraries, such as </span><strong class="source-inline"><span class="koboSpan" id="kobo.122.1">SQLAlchemy</span></strong><span class="koboSpan" id="kobo.123.1"> in Flask, handle the construction of SQL queries for you and provide a safe and efficient way to interact </span><span class="No-Break"><span class="koboSpan" id="kobo.124.1">with databases.</span></span></li>
<li><strong class="bold"><span class="koboSpan" id="kobo.125.1">Password storage</span></strong><span class="koboSpan" id="kobo.126.1">: Store passwords securely using a strong hashing algorithm and a unique salt for </span><span class="No-Break"><span class="koboSpan" id="kobo.127.1">each user.</span></span></li>
<li><strong class="bold"><span class="koboSpan" id="kobo.128.1">Use of HTTPS</span></strong><span class="koboSpan" id="kobo.129.1">: Use HTTPS to encrypt all communication between the client and the server to prevent eavesdropping and </span><span class="No-Break"><span class="koboSpan" id="kobo.130.1">MITM attacks.</span></span></li>
<li><strong class="bold"><span class="koboSpan" id="kobo.131.1">Session management</span></strong><span class="koboSpan" id="kobo.132.1">: Properly manage sessions to prevent session hijacking and fix session </span><a id="_idIndexMarker836"/><span class="koboSpan" id="kobo.133.1">fixation vulnerabilities in your </span><span class="No-Break"><span class="koboSpan" id="kobo.134.1">web application.</span></span></li>
<li><strong class="bold"><span class="koboSpan" id="kobo.135.1">Access control</span></strong><span class="koboSpan" id="kobo.136.1">: Use role-based access control to restrict access to sensitive resources </span><span class="No-Break"><span class="koboSpan" id="kobo.137.1">and functionality.</span></span></li>
<li><strong class="bold"><span class="koboSpan" id="kobo.138.1">Logging and monitoring</span></strong><span class="koboSpan" id="kobo.139.1">: You need to consistently keep detailed logs of all application activity and monitor them for </span><span class="No-Break"><span class="koboSpan" id="kobo.140.1">suspicious activity.</span></span></li>
<li><strong class="bold"><span class="koboSpan" id="kobo.141.1">Using up-to-date software</span></strong><span class="koboSpan" id="kobo.142.1">: You need to regularly update the framework, libraries, and all dependencies that your web application is using to ensure that known vulnerabilities </span><span class="No-Break"><span class="koboSpan" id="kobo.143.1">are patched.</span></span></li>
<li><strong class="bold"><span class="koboSpan" id="kobo.144.1">Using security headers</span></strong><span class="koboSpan" id="kobo.145.1">: Use security headers such as </span><strong class="source-inline"><span class="koboSpan" id="kobo.146.1">X-XSS-Protection</span></strong><span class="koboSpan" id="kobo.147.1">, </span><strong class="source-inline"><span class="koboSpan" id="kobo.148.1">X-Frame-Options</span></strong><span class="koboSpan" id="kobo.149.1">, and </span><strong class="source-inline"><span class="koboSpan" id="kobo.150.1">Content-Security-Policy</span></strong><span class="koboSpan" id="kobo.151.1"> to prevent certain types </span><span class="No-Break"><span class="koboSpan" id="kobo.152.1">of attacks.</span></span></li>
<li><strong class="bold"><span class="koboSpan" id="kobo.153.1">Regularly testing for vulnerabilities</span></strong><span class="koboSpan" id="kobo.154.1">: Regularly conduct penetration testing and </span><a id="_idIndexMarker837"/><span class="koboSpan" id="kobo.155.1">vulnerability scanning to identify and fix any </span><span class="No-Break"><span class="koboSpan" id="kobo.156.1">security issues.</span></span></li>
</ul>
<p><span class="koboSpan" id="kobo.157.1">In the remaining parts of this chapter, we will discuss and implement authentication with authorization in a Flask web application to help you keep your application and its users’ </span><span class="No-Break"><span class="koboSpan" id="kobo.158.1">data secure.</span></span></p>
<p><span class="koboSpan" id="kobo.159.1">Next, we will discuss authentication and the authentication role in web applications. </span><span class="koboSpan" id="kobo.159.2">This will improve your understanding of how to verify users’ identities and the various types </span><span class="No-Break"><span class="koboSpan" id="kobo.160.1">of authentications.</span></span></p>
<h1 id="_idParaDest-220"><a id="_idTextAnchor256"/><span class="koboSpan" id="kobo.161.1">Defining authentication and the authentication role in web application</span></h1>
<p><strong class="bold"><span class="koboSpan" id="kobo.162.1">Authentication</span></strong><span class="koboSpan" id="kobo.163.1"> is the process of </span><a id="_idIndexMarker838"/><span class="koboSpan" id="kobo.164.1">verifying the identity of a user and ensuring that only authorized users have access to the application’s resources and functionality. </span><span class="koboSpan" id="kobo.164.2">Authentication is an important aspect of any web application, including those built </span><span class="No-Break"><span class="koboSpan" id="kobo.165.1">with Flask.</span></span></p>
<p><span class="koboSpan" id="kobo.166.1">This is typically done by prompting the user to provide a set of credentials, such as a username and password, that the web application can use to confirm the user’s identity. </span><span class="koboSpan" id="kobo.166.2">The purpose of authentication in web application development is to ensure that only authorized users can access sensitive information and perform certain actions within a </span><span class="No-Break"><span class="koboSpan" id="kobo.167.1">web application.</span></span></p>
<p><span class="koboSpan" id="kobo.168.1">In web development, we </span><a id="_idIndexMarker839"/><span class="koboSpan" id="kobo.169.1">have several types of authentication methods that can be used in any web application project. </span><span class="koboSpan" id="kobo.169.2">These are some of the most commonly </span><span class="No-Break"><span class="koboSpan" id="kobo.170.1">used methods:</span></span></p>
<ul>
<li><strong class="bold"><span class="koboSpan" id="kobo.171.1">Password-based authentication</span></strong><span class="koboSpan" id="kobo.172.1">: This is the most common form of authentication </span><a id="_idIndexMarker840"/><span class="koboSpan" id="kobo.173.1">we encounter </span><a id="_idIndexMarker841"/><span class="koboSpan" id="kobo.174.1">in everyday use and involves the user entering a username/email and password to gain access to the web application. </span><span class="koboSpan" id="kobo.174.2">This method is simple and easy to implement but comes with its weakness. </span><span class="koboSpan" id="kobo.174.3">Password-based authentication is vulnerable to attacks such as brute-force and </span><span class="No-Break"><span class="koboSpan" id="kobo.175.1">dictionary attacks.</span></span></li>
<li><strong class="bold"><span class="koboSpan" id="kobo.176.1">Multi-factor authentication</span></strong><span class="koboSpan" id="kobo.177.1"> (</span><strong class="bold"><span class="koboSpan" id="kobo.178.1">MFA</span></strong><span class="koboSpan" id="kobo.179.1">): This method adds an additional layer of security by </span><a id="_idIndexMarker842"/><span class="koboSpan" id="kobo.180.1">requiring the </span><a id="_idIndexMarker843"/><span class="koboSpan" id="kobo.181.1">user to provide multiple forms of identification. </span><span class="koboSpan" id="kobo.181.2">For instance, a user may be required to enter a password and also provide a one-time code that’s been sent to their phone or email. </span><span class="koboSpan" id="kobo.181.3">MFA is more secure than password-based authentication but can negatively impact the </span><span class="No-Break"><span class="koboSpan" id="kobo.182.1">user experience.</span></span></li>
<li><strong class="bold"><span class="koboSpan" id="kobo.183.1">Token-based authentication</span></strong><span class="koboSpan" id="kobo.184.1">: This method involves the user being issued a token that they </span><a id="_idIndexMarker844"/><span class="koboSpan" id="kobo.185.1">must present </span><a id="_idIndexMarker845"/><span class="koboSpan" id="kobo.186.1">to the web application to gain access. </span><span class="koboSpan" id="kobo.186.2">Tokens can be in the form of a JWT or OAuth token and are often stored in a browser’s cookies or local storage. </span><span class="koboSpan" id="kobo.186.3">Tokens can easily be revoked, making it easier to </span><span class="No-Break"><span class="koboSpan" id="kobo.187.1">maintain security.</span></span></li>
<li><strong class="bold"><span class="koboSpan" id="kobo.188.1">Biometric authentication</span></strong><span class="koboSpan" id="kobo.189.1">: This method involves the use of biological characteristics such </span><a id="_idIndexMarker846"/><span class="koboSpan" id="kobo.190.1">as fingerprints, facial </span><a id="_idIndexMarker847"/><span class="koboSpan" id="kobo.191.1">recognition, or voice recognition to verify a user’s identity. </span><span class="koboSpan" id="kobo.191.2">Biometric authentication is considered to be more secure </span><a id="_idIndexMarker848"/><span class="koboSpan" id="kobo.192.1">than other methods but can be more </span><a id="_idIndexMarker849"/><span class="koboSpan" id="kobo.193.1">expensive </span><span class="No-Break"><span class="koboSpan" id="kobo.194.1">to implement.</span></span></li>
</ul>
<p><span class="koboSpan" id="kobo.195.1">When you are deciding which authentication method to use, it’s crucial to consider the level of security required for the web application and the user experience. </span><span class="koboSpan" id="kobo.195.2">Each of these authentication methods has its pros and cons. </span><span class="koboSpan" id="kobo.195.3">It is essential to choose the right method for </span><span class="No-Break"><span class="koboSpan" id="kobo.196.1">your application.</span></span></p>
<p><span class="koboSpan" id="kobo.197.1">For instance, if you are building a web application that requires a high level of security, you may want to consider using MFA or biometric authentication. </span><span class="koboSpan" id="kobo.197.2">And of course, biometric authentication is rarely used in public or general-purpose web applications. </span><span class="koboSpan" id="kobo.197.3">If you are building a simple web application that does not require a high level of security, password-based authentication may be safe </span><span class="No-Break"><span class="koboSpan" id="kobo.198.1">and sufficient.</span></span></p>
<p><span class="koboSpan" id="kobo.199.1">Next, we will discuss the concept of implementing password security and hashing passwords in securing a Flask </span><span class="No-Break"><span class="koboSpan" id="kobo.200.1">web application.</span></span></p>
<h1 id="_idParaDest-221"><a id="_idTextAnchor257"/><span class="koboSpan" id="kobo.201.1">Implementing password security and hashing passwords</span></h1>
<p><span class="koboSpan" id="kobo.202.1">In any web application </span><a id="_idIndexMarker850"/><span class="koboSpan" id="kobo.203.1">that requires access, passwords are often the first line of defense against unauthorized access. </span><span class="koboSpan" id="kobo.203.2">As a developer, you will want to ensure that passwords are securely managed when building Flask applications. </span><span class="koboSpan" id="kobo.203.3">A critical component of password management in web applications is to never store passwords </span><span class="No-Break"><span class="koboSpan" id="kobo.204.1">in plaintext.</span></span></p>
<p><span class="koboSpan" id="kobo.205.1">Instead, passwords should </span><a id="_idIndexMarker851"/><span class="koboSpan" id="kobo.206.1">be hashed, which is a one-way encryption process that produces a fixed-length output that cannot be reversed. </span><span class="koboSpan" id="kobo.206.2">When a user enters their password, it is hashed and compared with the stored hash. </span><span class="koboSpan" id="kobo.206.3">If the two hashes match, the password is correct. </span><span class="koboSpan" id="kobo.206.4">Hashing passwords can help protect against attacks such as brute-force and </span><span class="No-Break"><span class="koboSpan" id="kobo.207.1">dictionary attacks.</span></span></p>
<p><span class="koboSpan" id="kobo.208.1">Brute-force attacks involve trying every possible combination of characters to find a match, while dictionary attacks involve trying a pre-computed list of words. </span><span class="koboSpan" id="kobo.208.2">Hashing passwords makes it computationally infeasible for an attacker to reverse the hash and discover the </span><span class="No-Break"><span class="koboSpan" id="kobo.209.1">original password.</span></span></p>
<p><span class="koboSpan" id="kobo.210.1">In Flask, you can use a library such as </span><strong class="source-inline"><span class="koboSpan" id="kobo.211.1">Flask-Bcrypt</span></strong><span class="koboSpan" id="kobo.212.1"> to handle password hashing. </span><strong class="source-inline"><span class="koboSpan" id="kobo.213.1">Flask-Bcrypt</span></strong><span class="koboSpan" id="kobo.214.1"> is a Flask extension </span><a id="_idIndexMarker852"/><span class="koboSpan" id="kobo.215.1">that provides </span><strong class="source-inline"><span class="koboSpan" id="kobo.216.1">bcrypt</span></strong><span class="koboSpan" id="kobo.217.1"> password hashing for Flask. </span><strong class="source-inline"><span class="koboSpan" id="kobo.218.1">Flask-Bcrypt</span></strong><span class="koboSpan" id="kobo.219.1"> provides a simple interface for hashing and checking passwords. </span><span class="koboSpan" id="kobo.219.2">You can also use </span><strong class="source-inline"><span class="koboSpan" id="kobo.220.1">Flask-Bcrypt</span></strong><span class="koboSpan" id="kobo.221.1"> to generate random salts for use in </span><span class="No-Break"><span class="koboSpan" id="kobo.222.1">password hashing.</span></span></p>
<p><span class="koboSpan" id="kobo.223.1">Let’s quickly </span><a id="_idIndexMarker853"/><span class="koboSpan" id="kobo.224.1">run through an example of password </span><a id="_idIndexMarker854"/><span class="koboSpan" id="kobo.225.1">hashing </span><span class="No-Break"><span class="koboSpan" id="kobo.226.1">using </span></span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.227.1">Flask-Bcrypt</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.228.1">:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.229.1">from flask import Flask, render_template, requestfrom flask_bcrypt import Bcrypt
app = Flask(__name__)
bcrypt = Bcrypt()
@app.route("/", methods=["GET", "POST"])
def index():
    if request.method == "POST":
        password = request.form.get("password")
        password_hash =
            bcrypt.generate_password_hash(password)
                .decode('utf-8')
        return render_template("index.html",
            password_hash=password_hash)
    else:
        return render_template("index.html")
@app.route("/login", methods=["POST"])
def login():
    password = request.form.get("password")
    password_hash = request.form.get("password_hash")
//Check GitHub for the complete code
if __name__ == "__main__":
    app.run(debug=True)</span></pre>
<p><span class="koboSpan" id="kobo.230.1">The preceding code </span><a id="_idIndexMarker855"/><span class="koboSpan" id="kobo.231.1">uses the </span><strong class="source-inline"><span class="koboSpan" id="kobo.232.1">Flask Bcrypt</span></strong><span class="koboSpan" id="kobo.233.1"> library to hash and check a password. </span><span class="koboSpan" id="kobo.233.2">It imports the </span><strong class="source-inline"><span class="koboSpan" id="kobo.234.1">Bcrypt</span></strong><span class="koboSpan" id="kobo.235.1"> class and the </span><strong class="source-inline"><span class="koboSpan" id="kobo.236.1">check_password_hash</span></strong><span class="koboSpan" id="kobo.237.1"> function, creating an instance of </span><strong class="source-inline"><span class="koboSpan" id="kobo.238.1">Bcrypt</span></strong><span class="koboSpan" id="kobo.239.1"> with </span><a id="_idIndexMarker856"/><span class="koboSpan" id="kobo.240.1">the Flask application. </span><span class="koboSpan" id="kobo.240.2">When the form is submitted, the </span><a id="_idIndexMarker857"/><span class="koboSpan" id="kobo.241.1">password is hashed using the </span><strong class="source-inline"><span class="koboSpan" id="kobo.242.1">flask_bcrypt</span></strong><span class="koboSpan" id="kobo.243.1"> extension, and the hashed password is displayed back to the user on the same page. </span><span class="koboSpan" id="kobo.243.2">The </span><strong class="source-inline"><span class="koboSpan" id="kobo.244.1">render_template</span></strong><span class="koboSpan" id="kobo.245.1"> function is used to render the HTML templates, and the </span><strong class="source-inline"><span class="koboSpan" id="kobo.246.1">Bcrypt</span></strong><span class="koboSpan" id="kobo.247.1"> extension is used for secure </span><span class="No-Break"><span class="koboSpan" id="kobo.248.1">password hashing.</span></span></p>
<p><span class="koboSpan" id="kobo.249.1">Next, we will discuss access and authorization in web </span><span class="No-Break"><span class="koboSpan" id="kobo.250.1">application development.</span></span></p>
<h1 id="_idParaDest-222"><a id="_idTextAnchor258"/><span class="koboSpan" id="kobo.251.1">Understanding access and authorization in web application development</span></h1>
<p><span class="koboSpan" id="kobo.252.1">Access and authorization in web application development is the process of controlling who has access to </span><a id="_idIndexMarker858"/><span class="koboSpan" id="kobo.253.1">specific resources and actions within a web application. </span><span class="koboSpan" id="kobo.253.2">As a developer, you will want to design and ensure that users can only perform actions they are authorized to perform and access resources they are authorized to access in a </span><span class="No-Break"><span class="koboSpan" id="kobo.254.1">web application.</span></span></p>
<p><span class="koboSpan" id="kobo.255.1">As discussed earlier, authentication is the process of verifying the identity of a user. </span><span class="koboSpan" id="kobo.255.2">Authorization is the process of </span><a id="_idIndexMarker859"/><span class="koboSpan" id="kobo.256.1">determining what a user is allowed to do within a web application. </span><span class="koboSpan" id="kobo.256.2">When you combine these two mechanisms, you have a system that</span><a id="_idIndexMarker860"/><span class="koboSpan" id="kobo.257.1"> ensures that only authorized users can access sensitive information and perform certain actions within a </span><span class="No-Break"><span class="koboSpan" id="kobo.258.1">web application.</span></span></p>
<p><span class="koboSpan" id="kobo.259.1">Several different types of access control methods can be used in web application development. </span><span class="koboSpan" id="kobo.259.2">We will discuss some of them and make specific reference to how Flask can handle access </span><span class="No-Break"><span class="koboSpan" id="kobo.260.1">and authorization:</span></span></p>
<ul>
<li><strong class="bold"><span class="koboSpan" id="kobo.261.1">Login and password systems</span></strong><span class="koboSpan" id="kobo.262.1">: Login and password systems can restrict access to certain </span><a id="_idIndexMarker861"/><span class="koboSpan" id="kobo.263.1">resources and </span><a id="_idIndexMarker862"/><span class="koboSpan" id="kobo.264.1">actions based on the user’s authentication status. </span><span class="koboSpan" id="kobo.264.2">For instance, only logged-in users may be allowed to access certain pages, while anonymous users may be redirected to the login page. </span><span class="koboSpan" id="kobo.264.3">In a Flask </span><a id="_idIndexMarker863"/><span class="koboSpan" id="kobo.265.1">application, a login and password </span><a id="_idIndexMarker864"/><span class="koboSpan" id="kobo.266.1">system can be </span><a id="_idIndexMarker865"/><span class="koboSpan" id="kobo.267.1">implemented using </span><a id="_idIndexMarker866"/><span class="koboSpan" id="kobo.268.1">extensions such as </span><strong class="source-inline"><span class="koboSpan" id="kobo.269.1">Flask-Login</span></strong> <span class="No-Break"><span class="koboSpan" id="kobo.270.1">and </span></span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.271.1">Flask-Security</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.272.1">.</span></span></li>
<li><strong class="bold"><span class="koboSpan" id="kobo.273.1">Open Authorization</span></strong><span class="koboSpan" id="kobo.274.1"> (</span><strong class="bold"><span class="koboSpan" id="kobo.275.1">OAuth</span></strong><span class="koboSpan" id="kobo.276.1">): OAuth is a standard for authorization that allows users to </span><a id="_idIndexMarker867"/><span class="koboSpan" id="kobo.277.1">grant third-party applications access </span><a id="_idIndexMarker868"/><span class="koboSpan" id="kobo.278.1">to their resources without them having to share their credentials, such as their username and password. </span><span class="koboSpan" id="kobo.278.2">Rather, the user grants permission to the third-party application. </span><span class="koboSpan" id="kobo.278.3">This third-party application can then access the user’s resources on the </span><span class="No-Break"><span class="koboSpan" id="kobo.279.1">user’s behalf.</span></span><p class="list-inset"><span class="koboSpan" id="kobo.280.1">An example of an OAuth implementation is social media logins when a user logs in with a Google or Facebook account. </span><span class="koboSpan" id="kobo.280.2">When a user clicks the </span><strong class="bold"><span class="koboSpan" id="kobo.281.1">Log in with Google</span></strong><span class="koboSpan" id="kobo.282.1"> or </span><strong class="bold"><span class="koboSpan" id="kobo.283.1">Log in with Facebook</span></strong><span class="koboSpan" id="kobo.284.1"> button, the user is redirected to the relevant provider’s website to grant permission. </span><span class="koboSpan" id="kobo.284.2">Once the user grants permission, the provider sends an authorization code back to the application, which can then exchange the code for an </span><span class="No-Break"><span class="koboSpan" id="kobo.285.1">access token.</span></span></p><p class="list-inset"><span class="koboSpan" id="kobo.286.1">This access token can then be used to make API calls and access the user’s resources. </span><span class="koboSpan" id="kobo.286.2">In a Flask application, OAuth can be implemented using extensions such as </span><strong class="source-inline"><span class="koboSpan" id="kobo.287.1">Flask-OAuthlib</span></strong><span class="koboSpan" id="kobo.288.1">. </span><span class="koboSpan" id="kobo.288.2">This extension </span><a id="_idIndexMarker869"/><span class="koboSpan" id="kobo.289.1">provides support for </span><strong class="source-inline"><span class="koboSpan" id="kobo.290.1">OAuth 1.0a</span></strong><span class="koboSpan" id="kobo.291.1"> and </span><strong class="source-inline"><span class="koboSpan" id="kobo.292.1">OAuth 2.0</span></strong><span class="koboSpan" id="kobo.293.1">. </span><strong class="source-inline"><span class="koboSpan" id="kobo.294.1">Flask-OAuthlib</span></strong><span class="koboSpan" id="kobo.295.1"> makes it easy for developers to implement OAuth in their </span><span class="No-Break"><span class="koboSpan" id="kobo.296.1">Flask applications.</span></span></p></li>
<li><strong class="bold"><span class="koboSpan" id="kobo.297.1">JSON Web Token</span></strong><span class="koboSpan" id="kobo.298.1"> (</span><strong class="bold"><span class="koboSpan" id="kobo.299.1">JWT</span></strong><span class="koboSpan" id="kobo.300.1">): JWT is a widely used standard for authentication and authorization </span><a id="_idIndexMarker870"/><span class="koboSpan" id="kobo.301.1">in web applications. </span><span class="koboSpan" id="kobo.301.2">JWT provides a secure </span><a id="_idIndexMarker871"/><span class="koboSpan" id="kobo.302.1">way to transmit information between parties as a JSON object that is signed by the server and can be verified by the client. </span><span class="koboSpan" id="kobo.302.2">In a JWT-based authentication system, the server generates a JWT when the user logs in and sends it to </span><span class="No-Break"><span class="koboSpan" id="kobo.303.1">the client.</span></span><p class="list-inset"><span class="koboSpan" id="kobo.304.1">The client then sends the JWT back to the server with each subsequent request to authenticate </span><a id="_idIndexMarker872"/><span class="koboSpan" id="kobo.305.1">the user. </span><span class="koboSpan" id="kobo.305.2">The server verifies the signature of the JWT. </span><span class="koboSpan" id="kobo.305.3">In a Flask application, JWT-based authentication </span><a id="_idIndexMarker873"/><span class="koboSpan" id="kobo.306.1">can be implemented using extensions such as </span><strong class="source-inline"><span class="koboSpan" id="kobo.307.1">Flask-JWT</span></strong> <span class="No-Break"><span class="koboSpan" id="kobo.308.1">and </span></span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.309.1">Flask-JWT-Extended</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.310.1">.</span></span></p><p class="list-inset"><span class="koboSpan" id="kobo.311.1">These extensions provide features such as token generation, verification, and expiration, as </span><a id="_idIndexMarker874"/><span class="koboSpan" id="kobo.312.1">well as the ability to restrict access to certain </span><a id="_idIndexMarker875"/><span class="koboSpan" id="kobo.313.1">resources and actions based on the claims contained in the JWT to ensure that it was generated by a trusted source and has not been </span><span class="No-Break"><span class="koboSpan" id="kobo.314.1">tampered with.</span></span></p></li>
<li><strong class="bold"><span class="koboSpan" id="kobo.315.1">Role-based access control</span></strong><span class="koboSpan" id="kobo.316.1"> (</span><strong class="bold"><span class="koboSpan" id="kobo.317.1">RBAC</span></strong><span class="koboSpan" id="kobo.318.1">): This is a method of regulating access to resources or </span><a id="_idIndexMarker876"/><span class="koboSpan" id="kobo.319.1">actions based on the roles that a user </span><a id="_idIndexMarker877"/><span class="koboSpan" id="kobo.320.1">holds. </span><span class="koboSpan" id="kobo.320.2">In an RBAC system, users are assigned roles, and each role is associated with a set of permissions that determine what actions the user is allowed </span><span class="No-Break"><span class="koboSpan" id="kobo.321.1">to perform.</span></span><p class="list-inset"><span class="koboSpan" id="kobo.322.1">For instance, in a web application, an administrator may have permission to create and edit user accounts, while a regular user may only have permission to view their own account information. </span><span class="koboSpan" id="kobo.322.2">In a Flask application, RBAC can be implemented using extensions such </span><span class="No-Break"><span class="koboSpan" id="kobo.323.1">as </span></span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.324.1">Flask-RBAC</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.325.1">.</span></span></p><p class="list-inset"><span class="koboSpan" id="kobo.326.1">The </span><strong class="source-inline"><span class="koboSpan" id="kobo.327.1">Flask-RBAC</span></strong><span class="koboSpan" id="kobo.328.1"> extension provides features such as role management, permission management, </span><a id="_idIndexMarker878"/><span class="koboSpan" id="kobo.329.1">and the ability to restrict access to certain resources and actions based on the </span><span class="No-Break"><span class="koboSpan" id="kobo.330.1">user’s role.</span></span></p></li>
<li><strong class="bold"><span class="koboSpan" id="kobo.331.1">Policy-based access control</span></strong><span class="koboSpan" id="kobo.332.1"> (</span><strong class="bold"><span class="koboSpan" id="kobo.333.1">PBAC</span></strong><span class="koboSpan" id="kobo.334.1">): This is a method of regulating access to resources </span><a id="_idIndexMarker879"/><span class="koboSpan" id="kobo.335.1">or actions based on predefined </span><a id="_idIndexMarker880"/><span class="koboSpan" id="kobo.336.1">policies. </span><span class="koboSpan" id="kobo.336.2">In the PBAC system, policies are defined to specify the conditions under which access is granted or denied. </span><span class="koboSpan" id="kobo.336.3">For instance, in a web application, a policy may be defined to grant access to a resource only if the user is authenticated and their account </span><span class="No-Break"><span class="koboSpan" id="kobo.337.1">is active.</span></span><p class="list-inset"><span class="koboSpan" id="kobo.338.1">The policy may also specify that access should be denied if the user has reached a certain number of failed login attempts. </span><span class="koboSpan" id="kobo.338.2">In a Flask application, PBAC can be implemented using </span><a id="_idIndexMarker881"/><span class="koboSpan" id="kobo.339.1">extensions such as </span><strong class="source-inline"><span class="koboSpan" id="kobo.340.1">Flask-Policies</span></strong><span class="koboSpan" id="kobo.341.1">. </span><strong class="source-inline"><span class="koboSpan" id="kobo.342.1">Flask-Policies</span></strong><span class="koboSpan" id="kobo.343.1"> provides features such as policy management, enforcement, and the ability to restrict </span><a id="_idIndexMarker882"/><span class="koboSpan" id="kobo.344.1">access to certain resources </span><a id="_idIndexMarker883"/><span class="koboSpan" id="kobo.345.1">and actions based on the conditions specified in </span><span class="No-Break"><span class="koboSpan" id="kobo.346.1">the policies.</span></span></p></li>
</ul>
<p><span class="koboSpan" id="kobo.347.1">By using these libraries, you can easily handle user roles and permissions and restrict access to certain views and routes based on the user’s role. </span><span class="koboSpan" id="kobo.347.2">Next, we will take a look at how to implement authentication in a Flask </span><span class="No-Break"><span class="koboSpan" id="kobo.348.1">web application.</span></span></p>
<h1 id="_idParaDest-223"><a id="_idTextAnchor259"/><span class="koboSpan" id="kobo.349.1">Adding authentication to your Flask application</span></h1>
<p><span class="koboSpan" id="kobo.350.1">JWT is a popular method for </span><a id="_idIndexMarker884"/><span class="koboSpan" id="kobo.351.1">authentication in modern web applications. </span><span class="koboSpan" id="kobo.351.2">A JWT is a JSON object that is digitally signed and can be used to authenticate users by transmitting claims between parties, such as an authorization server and a resource server. </span><span class="koboSpan" id="kobo.351.3">In a Flask web application, you </span><a id="_idIndexMarker885"/><span class="koboSpan" id="kobo.352.1">can use the </span><strong class="source-inline"><span class="koboSpan" id="kobo.353.1">PyJWT</span></strong><span class="koboSpan" id="kobo.354.1"> library to encode and decode JWTs </span><span class="No-Break"><span class="koboSpan" id="kobo.355.1">for authentication.</span></span></p>
<p><span class="koboSpan" id="kobo.356.1">When a user logs into a Flask application, the backend verifies the user’s credentials, such as their email and password, and if they are valid, a JWT is generated and sent back to the client. </span><span class="koboSpan" id="kobo.356.2">The client stores the JWT in the browser’s local storage or as a cookie. </span><span class="koboSpan" id="kobo.356.3">For subsequent requests to protected routes and resources, the client sends the JWT in the </span><span class="No-Break"><span class="koboSpan" id="kobo.357.1">request header.</span></span></p>
<p><span class="koboSpan" id="kobo.358.1">The backend decodes the JWT to verify the user’s identity, grants or denies access to the requested resources, and generates a new JWT for subsequent requests. </span><span class="koboSpan" id="kobo.358.2">JWT for authentication allows stateless authentication. </span><span class="koboSpan" id="kobo.358.3">This means that the authentication information is stored in the JWT, which can be passed around between different servers, instead of on the server’s memory. </span><span class="koboSpan" id="kobo.358.4">This makes it easier to scale the application and reduces the risk of data loss </span><span class="No-Break"><span class="koboSpan" id="kobo.359.1">or corruption.</span></span></p>
<p><span class="koboSpan" id="kobo.360.1">JWT authentication also enhances security by using digital signatures to prevent data tampering. </span><span class="koboSpan" id="kobo.360.2">The signature is generated using a secret key that’s shared between the server and the client. </span><span class="koboSpan" id="kobo.360.3">The signature ensures that the data in the JWT has not been altered in transit. </span><span class="koboSpan" id="kobo.360.4">JWT authentication is a secure and efficient method for authenticating users in a </span><span class="No-Break"><span class="koboSpan" id="kobo.361.1">Flask application.</span></span></p>
<p><span class="koboSpan" id="kobo.362.1">By implementing JWT </span><a id="_idIndexMarker886"/><span class="koboSpan" id="kobo.363.1">authentication in a Flask application, </span><a id="_idIndexMarker887"/><span class="koboSpan" id="kobo.364.1">developers can simplify the process of authenticating users and reduce the risk of security breaches. </span><span class="koboSpan" id="kobo.364.2">Let’s examine the backend and frontend implementation </span><span class="No-Break"><span class="koboSpan" id="kobo.365.1">of JWT.</span></span></p>
<h2 id="_idParaDest-224"><a id="_idTextAnchor260"/><span class="koboSpan" id="kobo.366.1">Flask backend</span></h2>
<p><span class="koboSpan" id="kobo.367.1">The following code </span><a id="_idIndexMarker888"/><span class="koboSpan" id="kobo.368.1">defines two </span><a id="_idIndexMarker889"/><span class="koboSpan" id="kobo.369.1">Flask endpoints – </span><strong class="source-inline"><span class="koboSpan" id="kobo.370.1">/api/v1/login</span></strong> <span class="No-Break"><span class="koboSpan" id="kobo.371.1">and </span></span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.372.1">/api/v1/dashboard</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.373.1">:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.374.1">@app.route('/api/v1/login', methods=['POST'])def login():
    email = request.json.get('email', None)
    password = request.json.get('password', None)
    if email is None or password is None:
        return jsonify({'message': 'Missing email or
            password'}), 400
    user = User.query.filter_by(email=email).first()
    if user is None or not bcrypt.check_password_hash
        (user.password, password):
        return jsonify({'message': 'Invalid email or
            password'}), 401
    access_token = create_access_token(identity=user.id)
    return jsonify({'access_token': access_token}), 200
@app.route('/api/v1/dashboard', methods=['GET'])
@jwt_required
def dashboard():
    current_user = get_jwt_identity()
    user = User.query.filter_by(id=current_user).first()
    return jsonify({'email': user.email}), 200</span></pre>
<p><span class="koboSpan" id="kobo.375.1">The </span><strong class="source-inline"><span class="koboSpan" id="kobo.376.1">/api/v1/login</span></strong><span class="koboSpan" id="kobo.377.1"> endpoint is for handling user login requests. </span><span class="koboSpan" id="kobo.377.2">It takes in a JSON request with two properties: </span><strong class="source-inline"><span class="koboSpan" id="kobo.378.1">email</span></strong><span class="koboSpan" id="kobo.379.1"> and </span><strong class="source-inline"><span class="koboSpan" id="kobo.380.1">password</span></strong><span class="koboSpan" id="kobo.381.1">. </span><span class="koboSpan" id="kobo.381.2">If either of these properties is missing, the function returns a JSON response with a message indicating </span><strong class="source-inline"><span class="koboSpan" id="kobo.382.1">Missing email or password</span></strong><span class="koboSpan" id="kobo.383.1"> and a status code of </span><strong class="source-inline"><span class="koboSpan" id="kobo.384.1">400</span></strong><span class="koboSpan" id="kobo.385.1"> (</span><span class="No-Break"><span class="koboSpan" id="kobo.386.1">Bad Request).</span></span></p>
<p><span class="koboSpan" id="kobo.387.1">Next, the function </span><a id="_idIndexMarker890"/><span class="koboSpan" id="kobo.388.1">queries the database for a user with the given </span><a id="_idIndexMarker891"/><span class="koboSpan" id="kobo.389.1">email. </span><span class="koboSpan" id="kobo.389.2">If no such user exists, or if the password provided does not match the hashed password stored in the database, the function returns a JSON response with a message indicating </span><strong class="source-inline"><span class="koboSpan" id="kobo.390.1">Invalid email or password</span></strong><span class="koboSpan" id="kobo.391.1"> and a status code of </span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.392.1">401</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.393.1"> (Unauthorized).</span></span></p>
<p><span class="koboSpan" id="kobo.394.1">Otherwise, the function generates a JWT using the </span><strong class="source-inline"><span class="koboSpan" id="kobo.395.1">create_access_token</span></strong><span class="koboSpan" id="kobo.396.1"> function and returns it as a JSON response, along with a status code of </span><strong class="source-inline"><span class="koboSpan" id="kobo.397.1">200</span></strong><span class="koboSpan" id="kobo.398.1"> (OK). </span><span class="koboSpan" id="kobo.398.2">The JWT can be used to authenticate the user in subsequent requests to the backend. </span><span class="koboSpan" id="kobo.398.3">The </span><strong class="source-inline"><span class="koboSpan" id="kobo.399.1">/api/v1/dashboard</span></strong><span class="koboSpan" id="kobo.400.1"> endpoint is a protected endpoint that can only be accessed by users who have a </span><span class="No-Break"><span class="koboSpan" id="kobo.401.1">valid JWT.</span></span></p>
<p><span class="koboSpan" id="kobo.402.1">The </span><strong class="source-inline"><span class="koboSpan" id="kobo.403.1">jwt_required</span></strong><span class="koboSpan" id="kobo.404.1"> decorator is used to enforce this restriction. </span><span class="koboSpan" id="kobo.404.2">When this endpoint is accessed, the JWT is used to extract the user’s identity, which is then used to retrieve the user’s </span><strong class="source-inline"><span class="koboSpan" id="kobo.405.1">email</span></strong><span class="koboSpan" id="kobo.406.1"> from the database. </span><span class="koboSpan" id="kobo.406.2">This email is then returned as a JSON response, along with a status code of </span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.407.1">200</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.408.1"> (OK).</span></span></p>
<h2 id="_idParaDest-225"><a id="_idTextAnchor261"/><span class="koboSpan" id="kobo.409.1">React frontend</span></h2>
<p><span class="koboSpan" id="kobo.410.1">The following code </span><a id="_idIndexMarker892"/><span class="koboSpan" id="kobo.411.1">shows a login form and a dashboard. </span><span class="koboSpan" id="kobo.411.2">The </span><strong class="source-inline"><span class="koboSpan" id="kobo.412.1">LoginForm</span></strong><span class="koboSpan" id="kobo.413.1"> component </span><a id="_idIndexMarker893"/><span class="koboSpan" id="kobo.414.1">has three states –  </span><strong class="source-inline"><span class="koboSpan" id="kobo.415.1">email</span></strong><span class="koboSpan" id="kobo.416.1">, </span><strong class="source-inline"><span class="koboSpan" id="kobo.417.1">password</span></strong><span class="koboSpan" id="kobo.418.1">, and </span><strong class="source-inline"><span class="koboSpan" id="kobo.419.1">accessToken</span></strong><span class="koboSpan" id="kobo.420.1">. </span><span class="koboSpan" id="kobo.420.2">When the form is submitted, it makes a </span><strong class="source-inline"><span class="koboSpan" id="kobo.421.1">POST</span></strong><span class="koboSpan" id="kobo.422.1"> request to the </span><strong class="source-inline"><span class="koboSpan" id="kobo.423.1">/api/v1/login</span></strong><span class="koboSpan" id="kobo.424.1"> endpoint with the email and password data, and the response of the request is stored in the </span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.425.1">accessToken</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.426.1"> state:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.427.1">import React, { useState } from 'react';import axios from 'axios';
const LoginForm = () =&gt; {
  const [email, setEmail] = useState('');
  const [password, setPassword] = useState('');
  const [accessToken, setAccessToken] = useState('');
  const handleSubmit = async (event) =&gt; {
    event.preventDefault();
    try {
      const res = await axios.post('/api/v1/login', {
        email, password });
      setAccessToken(res.data.access_token);
    } catch (err) {
      console.error(err);
    }
  };
  return (
    &lt;&gt;
      {accessToken ? </span><span class="koboSpan" id="kobo.427.2">(
        &lt;Dashboard accessToken={accessToken} /&gt;
      ) : (
        &lt;form onSubmit={handleSubmit}&gt;
          ....
</span><span class="koboSpan" id="kobo.427.3">          /&gt;
          &lt;button type="submit"&gt;Login&lt;/button&gt;
        &lt;/form&gt;
      )}
    &lt;/&gt;
  );
};
};
 export default LoginForm;</span></pre>
<p><span class="koboSpan" id="kobo.428.1">The </span><strong class="source-inline"><span class="koboSpan" id="kobo.429.1">Dashboard</span></strong><span class="koboSpan" id="kobo.430.1"> component takes an </span><strong class="source-inline"><span class="koboSpan" id="kobo.431.1">accessToken</span></strong><span class="koboSpan" id="kobo.432.1"> prop and has one state, </span><strong class="source-inline"><span class="koboSpan" id="kobo.433.1">email</span></strong><span class="koboSpan" id="kobo.434.1">. </span><span class="koboSpan" id="kobo.434.2">It makes a </span><strong class="source-inline"><span class="koboSpan" id="kobo.435.1">GET</span></strong><span class="koboSpan" id="kobo.436.1"> request </span><a id="_idIndexMarker894"/><span class="koboSpan" id="kobo.437.1">to the </span><strong class="source-inline"><span class="koboSpan" id="kobo.438.1">/api/v1/dashboard</span></strong><span class="koboSpan" id="kobo.439.1"> endpoint </span><a id="_idIndexMarker895"/><span class="koboSpan" id="kobo.440.1">with an authorization header set to </span><strong class="source-inline"><span class="koboSpan" id="kobo.441.1">accessToken</span></strong><span class="koboSpan" id="kobo.442.1">, and the response is stored in the </span><strong class="source-inline"><span class="koboSpan" id="kobo.443.1">email</span></strong><span class="koboSpan" id="kobo.444.1"> state. </span><span class="koboSpan" id="kobo.444.2">The component displays a message stating </span><strong class="source-inline"><span class="koboSpan" id="kobo.445.1">"Welcome to </span></strong><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.446.1">dashboard, [email]!"</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.447.1">.</span></span></p>
<p><span class="koboSpan" id="kobo.448.1">The </span><strong class="source-inline"><span class="koboSpan" id="kobo.449.1">LoginForm</span></strong><span class="koboSpan" id="kobo.450.1"> component returns either the </span><strong class="source-inline"><span class="koboSpan" id="kobo.451.1">Dashboard</span></strong><span class="koboSpan" id="kobo.452.1"> component if </span><strong class="source-inline"><span class="koboSpan" id="kobo.453.1">accessToken</span></strong><span class="koboSpan" id="kobo.454.1"> is truthy, or the login form if </span><strong class="source-inline"><span class="koboSpan" id="kobo.455.1">accessToken</span></strong> <span class="No-Break"><span class="koboSpan" id="kobo.456.1">is </span></span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.457.1">falsy</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.458.1">.</span></span></p>
<p><span class="koboSpan" id="kobo.459.1">Next, we will discuss how to identify web application users and manage </span><span class="No-Break"><span class="koboSpan" id="kobo.460.1">their information.</span></span></p>
<h1 id="_idParaDest-226"><a id="_idTextAnchor262"/><span class="koboSpan" id="kobo.461.1">Identifying system users and managing their information</span></h1>
<p><span class="koboSpan" id="kobo.462.1">In most web applications, </span><a id="_idIndexMarker896"/><span class="koboSpan" id="kobo.463.1">users are identified by a unique identifier </span><a id="_idIndexMarker897"/><span class="koboSpan" id="kobo.464.1">such as a username or email address. </span><span class="koboSpan" id="kobo.464.2">Typically, in a Flask application, you can use a database to store user information, such as usernames, email addresses, and </span><span class="No-Break"><span class="koboSpan" id="kobo.465.1">hashed passwords.</span></span></p>
<p><span class="koboSpan" id="kobo.466.1">When a user attempts to log in, the entered credentials (username and password) are compared to the information stored in the database. </span><span class="koboSpan" id="kobo.466.2">If the entered credentials match, the user is authenticated, and a session is created for that user. </span><span class="koboSpan" id="kobo.466.3">In Flask, you can use the built-in session object to store and retrieve </span><span class="No-Break"><span class="koboSpan" id="kobo.467.1">user information.</span></span></p>
<p><span class="koboSpan" id="kobo.468.1">By using sessions, you can easily identify users in a Flask web application and retrieve information about </span><a id="_idIndexMarker898"/><span class="koboSpan" id="kobo.469.1">them. </span><span class="koboSpan" id="kobo.469.2">However, it’s important to note that sessions </span><a id="_idIndexMarker899"/><span class="koboSpan" id="kobo.470.1">are vulnerable to session hijacking attacks. </span><span class="koboSpan" id="kobo.470.2">So, it’s essential to use secure session management techniques such as regenerating session IDs after login and using </span><span class="No-Break"><span class="koboSpan" id="kobo.471.1">secure cookies.</span></span></p>
<p><span class="koboSpan" id="kobo.472.1">Let’s examine an </span><span class="No-Break"><span class="koboSpan" id="kobo.473.1">implementation example:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.474.1">from flask import Flask, request, redirect, session, jsonifyapp = Flask(__name__)
app.secret_key = 'secret_key'
@app.route('/login', methods=['POST'])
def login():
    data = request.get_json()
    email = data.get('email')
    password = data.get('password')
    session['email'] = email
    return jsonify({'message': 'Login successful'}), 201
@app.route('/dashboard', methods=['GET'])
def dashboard():
    email = session.get('email')
    user = User.query.filter_by(email=email).first()
    return jsonify({'email': email, 'user':
        user.to_dict()}), 200</span></pre>
<p><span class="koboSpan" id="kobo.475.1">In the preceding code, the first line imports the required modules from the Flask library. </span><span class="koboSpan" id="kobo.475.2">The next line creates an instance of the </span><strong class="source-inline"><span class="koboSpan" id="kobo.476.1">Flask</span></strong><span class="koboSpan" id="kobo.477.1"> class and assigns it to the </span><strong class="source-inline"><span class="koboSpan" id="kobo.478.1">app</span></strong><span class="koboSpan" id="kobo.479.1"> variable. </span><span class="koboSpan" id="kobo.479.2">The </span><strong class="source-inline"><span class="koboSpan" id="kobo.480.1">app.secret_key</span></strong><span class="koboSpan" id="kobo.481.1"> attribute is set to </span><strong class="source-inline"><span class="koboSpan" id="kobo.482.1">'secret_key'</span></strong><span class="koboSpan" id="kobo.483.1">, which is used to securely sign the </span><span class="No-Break"><span class="koboSpan" id="kobo.484.1">session cookie.</span></span></p>
<p><span class="koboSpan" id="kobo.485.1">The login function is defined as a POST endpoint at the </span><strong class="source-inline"><span class="koboSpan" id="kobo.486.1">api/v1/login</span></strong><span class="koboSpan" id="kobo.487.1"> route. </span><span class="koboSpan" id="kobo.487.2">This endpoint uses the </span><strong class="source-inline"><span class="koboSpan" id="kobo.488.1">request.get_json()</span></strong><span class="koboSpan" id="kobo.489.1"> method to get the JSON data from the request body and extract the values for </span><strong class="source-inline"><span class="koboSpan" id="kobo.490.1">email</span></strong><span class="koboSpan" id="kobo.491.1"> and </span><strong class="source-inline"><span class="koboSpan" id="kobo.492.1">password</span></strong><span class="koboSpan" id="kobo.493.1">. </span><strong class="source-inline"><span class="koboSpan" id="kobo.494.1">email</span></strong><span class="koboSpan" id="kobo.495.1"> is then stored in the session using </span><strong class="source-inline"><span class="koboSpan" id="kobo.496.1">session['email'] = email</span></strong><span class="koboSpan" id="kobo.497.1">. </span><span class="koboSpan" id="kobo.497.2">The function returns a JSON response with a message of </span><strong class="source-inline"><span class="koboSpan" id="kobo.498.1">"Login successful"</span></strong><span class="koboSpan" id="kobo.499.1"> and a </span><strong class="source-inline"><span class="koboSpan" id="kobo.500.1">201</span></strong><span class="koboSpan" id="kobo.501.1"> status code, indicating the successful creation of </span><span class="No-Break"><span class="koboSpan" id="kobo.502.1">a resource.</span></span></p>
<p><span class="koboSpan" id="kobo.503.1">Then, the dashboard function is defined as a GET endpoint at the </span><strong class="source-inline"><span class="koboSpan" id="kobo.504.1">api/v1/dashboard</span></strong><span class="koboSpan" id="kobo.505.1"> route. </span><span class="koboSpan" id="kobo.505.2">It retrieves </span><strong class="source-inline"><span class="koboSpan" id="kobo.506.1">email</span></strong><span class="koboSpan" id="kobo.507.1"> from the session using </span><strong class="source-inline"><span class="koboSpan" id="kobo.508.1">session.get('email')</span></strong><span class="koboSpan" id="kobo.509.1">. </span><span class="koboSpan" id="kobo.509.2">The function then queries the database for a user with the specified email using </span><strong class="source-inline"><span class="koboSpan" id="kobo.510.1">User.query.filter_by(email=email).first()</span></strong><span class="koboSpan" id="kobo.511.1">. </span><span class="koboSpan" id="kobo.511.2">The </span><strong class="source-inline"><span class="koboSpan" id="kobo.512.1">email</span></strong><span class="koboSpan" id="kobo.513.1"> and user data (converted into a dictionary using </span><strong class="source-inline"><span class="koboSpan" id="kobo.514.1">to_dict()</span></strong><span class="koboSpan" id="kobo.515.1">) are returned in a JSON response with a 200 status code, indicating the successful retrieval of </span><span class="No-Break"><span class="koboSpan" id="kobo.516.1">a resource.</span></span></p>
<p><span class="koboSpan" id="kobo.517.1">You can also identify </span><a id="_idIndexMarker900"/><span class="koboSpan" id="kobo.518.1">users in a Flask application with a token-based authentication </span><a id="_idIndexMarker901"/><span class="koboSpan" id="kobo.519.1">method. </span><span class="koboSpan" id="kobo.519.2">In this method, a token is issued to the user when they log in, and the token is stored in the user’s browser as a cookie or placed in local storage. </span><span class="koboSpan" id="kobo.519.3">This token is then sent with each subsequent request made by the user, and the server uses this token to identify the user. </span><span class="koboSpan" id="kobo.519.4">JWT is a commonly used token format, and libraries such as </span><strong class="source-inline"><span class="koboSpan" id="kobo.520.1">Flask-JWT</span></strong><span class="koboSpan" id="kobo.521.1"> and </span><strong class="source-inline"><span class="koboSpan" id="kobo.522.1">Flask-JWT-Extended</span></strong><span class="koboSpan" id="kobo.523.1"> make it easy to implement JWT-based authentication </span><span class="No-Break"><span class="koboSpan" id="kobo.524.1">in Flask.</span></span></p>
<p><span class="koboSpan" id="kobo.525.1">Next, we will delve deeper into tracking a user’s session in a </span><span class="No-Break"><span class="koboSpan" id="kobo.526.1">web application.</span></span></p>
<h1 id="_idParaDest-227"><a id="_idTextAnchor263"/><span class="koboSpan" id="kobo.527.1">Session management</span></h1>
<p><strong class="bold"><span class="koboSpan" id="kobo.528.1">Session management</span></strong><span class="koboSpan" id="kobo.529.1"> is a critical aspect of web development as it enables a web application to identify </span><a id="_idIndexMarker902"/><span class="koboSpan" id="kobo.530.1">and track a user’s actions over a certain period. </span><span class="koboSpan" id="kobo.530.2">In Flask web applications, session management is typically implemented on the server side using Flask’s in-built session object or a Flask extension such as </span><strong class="source-inline"><span class="koboSpan" id="kobo.531.1">Flask-Session</span></strong><span class="koboSpan" id="kobo.532.1">; on the frontend React side, you can use React’s </span><strong class="source-inline"><span class="koboSpan" id="kobo.533.1">localStorage</span></strong> <span class="No-Break"><span class="koboSpan" id="kobo.534.1">or </span></span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.535.1">sessionStorage</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.536.1">.</span></span></p>
<p><span class="koboSpan" id="kobo.537.1">Flask thrives on its simplicity as a framework of choice for Python that makes it easy to build small to enterprise-sized web applications. </span><span class="koboSpan" id="kobo.537.2">Flask can manage user sessions using the built-in session object and some of the available Flask extensions contributed by the </span><span class="No-Break"><span class="koboSpan" id="kobo.538.1">community members.</span></span></p>
<p><span class="koboSpan" id="kobo.539.1">A session object is a dictionary-like </span><a id="_idIndexMarker903"/><span class="koboSpan" id="kobo.540.1">object that is stored on the server and can be accessed by the </span><a id="_idIndexMarker904"/><span class="koboSpan" id="kobo.541.1">client via a secure session cookie. </span><span class="koboSpan" id="kobo.541.2">To use a session object, a </span><em class="italic"><span class="koboSpan" id="kobo.542.1">secret key</span></em><span class="koboSpan" id="kobo.543.1"> must be set in the Flask application. </span><span class="koboSpan" id="kobo.543.2">This secret key is used to encrypt and </span><a id="_idIndexMarker905"/><span class="koboSpan" id="kobo.544.1">sign the session data, which is stored in a secure cookie on the </span><a id="_idIndexMarker906"/><span class="koboSpan" id="kobo.545.1">client’s browser. </span><span class="koboSpan" id="kobo.545.2">When a user visits a protected resource, the server verifies the session cookie and grants access if the cookie </span><span class="No-Break"><span class="koboSpan" id="kobo.546.1">is valid.</span></span></p>
<p><span class="koboSpan" id="kobo.547.1">Let’s implement session management in a Flask backend and React frontend. </span><span class="koboSpan" id="kobo.547.2">We will create a counter endpoint that keeps track of the number of times a user visited a </span><span class="No-Break"><span class="koboSpan" id="kobo.548.1">dashboard page.</span></span></p>
<h2 id="_idParaDest-228"><a id="_idTextAnchor264"/><span class="koboSpan" id="kobo.549.1">Flask backend</span></h2>
<p><span class="koboSpan" id="kobo.550.1">We will use </span><strong class="source-inline"><span class="koboSpan" id="kobo.551.1">Flask-Session</span></strong><span class="koboSpan" id="kobo.552.1"> to store session data and securely manage sessions. </span><span class="koboSpan" id="kobo.552.2">To use </span><strong class="source-inline"><span class="koboSpan" id="kobo.553.1">Flask-Session</span></strong><span class="koboSpan" id="kobo.554.1">, you </span><a id="_idIndexMarker907"/><span class="koboSpan" id="kobo.555.1">need to install it first. </span><span class="koboSpan" id="kobo.555.2">You can do </span><a id="_idIndexMarker908"/><span class="koboSpan" id="kobo.556.1">this by running the </span><strong class="source-inline"><span class="koboSpan" id="kobo.557.1">pip install flask-session</span></strong><span class="koboSpan" id="kobo.558.1"> command in </span><span class="No-Break"><span class="koboSpan" id="kobo.559.1">the Terminal.</span></span></p>
<p><span class="koboSpan" id="kobo.560.1">Once you’ve installed </span><strong class="source-inline"><span class="koboSpan" id="kobo.561.1">Flask-Session</span></strong><span class="koboSpan" id="kobo.562.1">, you need to add the following code to your </span><span class="No-Break"><span class="koboSpan" id="kobo.563.1">Flask application:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.564.1">from flask import Flask, sessionfrom flask_session import Session
app = Flask(__name__)
app.config["SESSION_TYPE"] = "filesystem"
Session(app)
@app.route("/api/v1/couters")
def visit_couter():
    session["counter"] = session.get("counter", 0) + 1
    return "Hey , you have visited this page:
        {}".format(session["counter"])</span></pre>
<p><span class="koboSpan" id="kobo.565.1">The preceding code shows a simple implementation of session management in a </span><span class="No-Break"><span class="koboSpan" id="kobo.566.1">Flask backend:</span></span></p>
<ol>
<li><span class="koboSpan" id="kobo.567.1">The first line imports the Flask module, while the second line imports the </span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.568.1">Flask-Session</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.569.1"> extension.</span></span></li>
<li><span class="koboSpan" id="kobo.570.1">The next few lines </span><a id="_idIndexMarker909"/><span class="koboSpan" id="kobo.571.1">create a Flask application object </span><a id="_idIndexMarker910"/><span class="koboSpan" id="kobo.572.1">and configure the session type to be stored on </span><span class="No-Break"><span class="koboSpan" id="kobo.573.1">the filesystem.</span></span></li>
<li><span class="koboSpan" id="kobo.574.1">The </span><strong class="source-inline"><span class="koboSpan" id="kobo.575.1">Session</span></strong><span class="koboSpan" id="kobo.576.1"> object is then initialized with the Flask application object as </span><span class="No-Break"><span class="koboSpan" id="kobo.577.1">its argument.</span></span></li>
<li><span class="koboSpan" id="kobo.578.1">The </span><strong class="source-inline"><span class="koboSpan" id="kobo.579.1">@app.route</span></strong><span class="koboSpan" id="kobo.580.1"> decorator creates a route – in this case, </span><strong class="source-inline"><span class="koboSpan" id="kobo.581.1">/api/v1/counters</span></strong><span class="koboSpan" id="kobo.582.1"> – for the </span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.583.1">visit_counter</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.584.1"> function.</span></span></li>
<li><span class="koboSpan" id="kobo.585.1">The </span><strong class="source-inline"><span class="koboSpan" id="kobo.586.1">visit_counter</span></strong><span class="koboSpan" id="kobo.587.1"> function retrieves the current value of the </span><strong class="source-inline"><span class="koboSpan" id="kobo.588.1">counter</span></strong><span class="koboSpan" id="kobo.589.1"> key in the session or sets it to </span><strong class="source-inline"><span class="koboSpan" id="kobo.590.1">0</span></strong><span class="koboSpan" id="kobo.591.1"> if it doesn’t exist, and then increments the value by </span><strong class="source-inline"><span class="koboSpan" id="kobo.592.1">1</span></strong><span class="koboSpan" id="kobo.593.1">. </span><span class="koboSpan" id="kobo.593.2">The updated value is then returned to the user in </span><span class="No-Break"><span class="koboSpan" id="kobo.594.1">the response.</span></span></li>
</ol>
<p><span class="koboSpan" id="kobo.595.1">Let’s explore the React frontend part of </span><span class="No-Break"><span class="koboSpan" id="kobo.596.1">this implementation.</span></span></p>
<h2 id="_idParaDest-229"><a id="_idTextAnchor265"/><span class="koboSpan" id="kobo.597.1">React Frontend</span></h2>
<p><span class="koboSpan" id="kobo.598.1">You can use the </span><a id="_idIndexMarker911"/><span class="koboSpan" id="kobo.599.1">Axios library to send HTTP requests to </span><a id="_idIndexMarker912"/><span class="koboSpan" id="kobo.600.1">the Flask server. </span><span class="koboSpan" id="kobo.600.2">If not installed yet, you can install Axios with the </span><strong class="source-inline"><span class="koboSpan" id="kobo.601.1">npm install </span></strong><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.602.1">axios</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.603.1"> command.</span></span></p>
<p><span class="koboSpan" id="kobo.604.1">Once you’ve installed Axios, you can use it to send an HTTP request to the Flask server to set or get the </span><span class="No-Break"><span class="koboSpan" id="kobo.605.1">session data:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.606.1">import React, { useState } from "react";import axios from "axios";
function VisitCouter() {
    const [counter, setCounter] = useState(0);
    const getCounter = async () =&gt; {
        const response = await axios.get(
            "http://localhost:5000/api/v1/counters");
        setCounter(response.data.counter);
        };
        return (
          &lt;div&gt;
            &lt;h1&gt;You have visited this page: {counter}
              times!&lt;/h1&gt;
            &lt;button onClick={getCounter}&gt;Get Counter
              &lt;/button&gt;
          &lt;/div&gt;
        );
}
export default VisitCounter;</span></pre>
<p><span class="koboSpan" id="kobo.607.1">The preceding code demonstrates the frontend implementation of a React frontend that retrieves the visit counter from a </span><span class="No-Break"><span class="koboSpan" id="kobo.608.1">Flask backend:</span></span></p>
<ol>
<li><span class="koboSpan" id="kobo.609.1">The first line </span><a id="_idIndexMarker913"/><span class="koboSpan" id="kobo.610.1">imports the required </span><a id="_idIndexMarker914"/><span class="koboSpan" id="kobo.611.1">libraries – that is, </span><strong class="source-inline"><span class="koboSpan" id="kobo.612.1">React</span></strong> <span class="No-Break"><span class="koboSpan" id="kobo.613.1">and </span></span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.614.1">axios</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.615.1">.</span></span></li>
<li><span class="koboSpan" id="kobo.616.1">The next section declares the </span><strong class="source-inline"><span class="koboSpan" id="kobo.617.1">VisitCounter</span></strong><span class="koboSpan" id="kobo.618.1"> function component, which returns a view for </span><span class="No-Break"><span class="koboSpan" id="kobo.619.1">the user.</span></span></li>
<li><span class="koboSpan" id="kobo.620.1">Within the component, the state variable counter is initialized using the </span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.621.1">useState</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.622.1"> hook.</span></span></li>
<li><span class="koboSpan" id="kobo.623.1">The </span><strong class="source-inline"><span class="koboSpan" id="kobo.624.1">getCounter</span></strong><span class="koboSpan" id="kobo.625.1"> function uses the </span><strong class="source-inline"><span class="koboSpan" id="kobo.626.1">axios</span></strong><span class="koboSpan" id="kobo.627.1"> library to make a </span><strong class="source-inline"><span class="koboSpan" id="kobo.628.1">GET</span></strong><span class="koboSpan" id="kobo.629.1"> request to the </span><strong class="source-inline"><span class="koboSpan" id="kobo.630.1">/api/v1/counters</span></strong><span class="koboSpan" id="kobo.631.1"> endpoint on the Flask backend. </span><span class="koboSpan" id="kobo.631.2">The response from the backend, which contains the updated counter value, is then used to update the counter </span><span class="No-Break"><span class="koboSpan" id="kobo.632.1">state variable.</span></span></li>
<li><span class="koboSpan" id="kobo.633.1">The component </span><a id="_idIndexMarker915"/><span class="koboSpan" id="kobo.634.1">returns a div that displays the </span><a id="_idIndexMarker916"/><span class="koboSpan" id="kobo.635.1">value of the counter and a button that, when clicked, triggers the </span><strong class="source-inline"><span class="koboSpan" id="kobo.636.1">getCounter</span></strong><span class="koboSpan" id="kobo.637.1"> function to retrieve the updated counter value from </span><span class="No-Break"><span class="koboSpan" id="kobo.638.1">the backend.</span></span></li>
</ol>
<p><span class="koboSpan" id="kobo.639.1">Next, we will discuss how to create a password-protected dashboard in a Flask-React </span><span class="No-Break"><span class="koboSpan" id="kobo.640.1">web application.</span></span></p>
<h1 id="_idParaDest-230"><a id="_idTextAnchor266"/><span class="koboSpan" id="kobo.641.1">Creating a password-protected dashboard</span></h1>
<p><span class="koboSpan" id="kobo.642.1">Protecting pages in a web application is essential for maintaining security and privacy. </span><span class="koboSpan" id="kobo.642.2">By extension, this can </span><a id="_idIndexMarker917"/><span class="koboSpan" id="kobo.643.1">help prevent unauthorized access to sensitive information. </span><span class="koboSpan" id="kobo.643.2">In this section, you will be implementing a protected dashboard page in a Flask-React </span><span class="No-Break"><span class="koboSpan" id="kobo.644.1">web application.</span></span></p>
<p><span class="koboSpan" id="kobo.645.1">A dashboard is a user-friendly </span><a id="_idIndexMarker918"/><span class="koboSpan" id="kobo.646.1">interface that provides an overview of data and information. </span><span class="koboSpan" id="kobo.646.2">The data that’s displayed on a dashboard can come from a variety of sources, such as databases, spreadsheets, </span><span class="No-Break"><span class="koboSpan" id="kobo.647.1">and APIs.</span></span></p>
<h2 id="_idParaDest-231"><a id="_idTextAnchor267"/><span class="koboSpan" id="kobo.648.1">Flask backend</span></h2>
<p><span class="koboSpan" id="kobo.649.1">The following code </span><a id="_idIndexMarker919"/><span class="koboSpan" id="kobo.650.1">demonstrates an </span><a id="_idIndexMarker920"/><span class="koboSpan" id="kobo.651.1">implementation that allows an admin user to log in and see a protected dashboard page. </span><span class="koboSpan" id="kobo.651.2">We will implement minimalist login and logout endpoints that define login and logout functionality and protect the </span><strong class="source-inline"><span class="koboSpan" id="kobo.652.1">dashboard</span></strong><span class="koboSpan" id="kobo.653.1"> endpoint. </span><span class="koboSpan" id="kobo.653.2">The application uses the </span><strong class="source-inline"><span class="koboSpan" id="kobo.654.1">Flask-Session</span></strong><span class="koboSpan" id="kobo.655.1"> library to store session data in </span><span class="No-Break"><span class="koboSpan" id="kobo.656.1">the filesystem:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.657.1">from flask import Flask, request, jsonify, sessionfrom flask_session import Session
app = Flask(__name__)
app.config["SESSION_TYPE"] = "filesystem"
Session(app)
@app.route("/api/v1/login", methods=["POST"])
def login():
    username = request.json.get("username")
    password = request.json.get("password")
    if username == "admin" and password == "secret":
        session["logged_in"] = True
        return jsonify({"message": "Login successful"})
    else:
        return jsonify({"message": "Login failed"}), 401
@app.route("/api/v1/logout")
def logout():
    session.pop("logged_in", None)
    return jsonify({"message": "Logout successful"})
@app.route("/api/v1/dashboard")
def dashboard():
    if "logged_in" not in session:
        return jsonify({"message": "Unauthorized access"}),
            401
    else:
        return jsonify({"message": "Welcome to the
            dashboard"})</span></pre>
<p><span class="koboSpan" id="kobo.658.1">In the </span><strong class="source-inline"><span class="koboSpan" id="kobo.659.1">login</span></strong><span class="koboSpan" id="kobo.660.1"> endpoint, the </span><a id="_idIndexMarker921"/><span class="koboSpan" id="kobo.661.1">application </span><a id="_idIndexMarker922"/><span class="koboSpan" id="kobo.662.1">receives a </span><strong class="source-inline"><span class="koboSpan" id="kobo.663.1">POST</span></strong><span class="koboSpan" id="kobo.664.1"> request with the </span><strong class="source-inline"><span class="koboSpan" id="kobo.665.1">username</span></strong><span class="koboSpan" id="kobo.666.1"> and </span><strong class="source-inline"><span class="koboSpan" id="kobo.667.1">password</span></strong><span class="koboSpan" id="kobo.668.1"> parameters in the request body in JSON format. </span><span class="koboSpan" id="kobo.668.2">The code checks if the </span><strong class="source-inline"><span class="koboSpan" id="kobo.669.1">username</span></strong><span class="koboSpan" id="kobo.670.1"> and </span><strong class="source-inline"><span class="koboSpan" id="kobo.671.1">password</span></strong><span class="koboSpan" id="kobo.672.1"> parameters match the predefined values – that is, </span><strong class="source-inline"><span class="koboSpan" id="kobo.673.1">admin</span></strong><span class="koboSpan" id="kobo.674.1"> and </span><strong class="source-inline"><span class="koboSpan" id="kobo.675.1">secret</span></strong><span class="koboSpan" id="kobo.676.1">. </span><span class="koboSpan" id="kobo.676.2">If the values match, the code sets the </span><strong class="source-inline"><span class="koboSpan" id="kobo.677.1">logged_in</span></strong><span class="koboSpan" id="kobo.678.1"> key in the session data to </span><strong class="source-inline"><span class="koboSpan" id="kobo.679.1">True</span></strong><span class="koboSpan" id="kobo.680.1">, indicating that the user is </span><span class="No-Break"><span class="koboSpan" id="kobo.681.1">logged in.</span></span></p>
<p><span class="koboSpan" id="kobo.682.1">It returns a JSON response with a message stating </span><strong class="source-inline"><span class="koboSpan" id="kobo.683.1">Login successful</span></strong><span class="koboSpan" id="kobo.684.1">. </span><span class="koboSpan" id="kobo.684.2">If the values don’t match, the code returns a JSON response with a message stating </span><strong class="source-inline"><span class="koboSpan" id="kobo.685.1">Login failed</span></strong><span class="koboSpan" id="kobo.686.1"> and a </span><strong class="source-inline"><span class="koboSpan" id="kobo.687.1">401</span></strong><span class="koboSpan" id="kobo.688.1"> HTTP status code, indicating </span><span class="No-Break"><span class="koboSpan" id="kobo.689.1">unauthorized access.</span></span></p>
<p><span class="koboSpan" id="kobo.690.1">The </span><strong class="source-inline"><span class="koboSpan" id="kobo.691.1">logout</span></strong><span class="koboSpan" id="kobo.692.1"> endpoint </span><a id="_idIndexMarker923"/><span class="koboSpan" id="kobo.693.1">removes the </span><strong class="source-inline"><span class="koboSpan" id="kobo.694.1">logged_in</span></strong><span class="koboSpan" id="kobo.695.1"> key </span><a id="_idIndexMarker924"/><span class="koboSpan" id="kobo.696.1">from the session data, indicating that the user is logged out. </span><span class="koboSpan" id="kobo.696.2">It returns a JSON response with a message stating </span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.697.1">Logout successful</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.698.1">.</span></span></p>
<p><span class="koboSpan" id="kobo.699.1">The dashboard endpoint checks if the </span><strong class="source-inline"><span class="koboSpan" id="kobo.700.1">logged_in</span></strong><span class="koboSpan" id="kobo.701.1"> key exists in the session data. </span><span class="koboSpan" id="kobo.701.2">If it does not, the code returns a JSON response with a message stating </span><strong class="source-inline"><span class="koboSpan" id="kobo.702.1">Unauthorized access</span></strong><span class="koboSpan" id="kobo.703.1"> and a </span><strong class="source-inline"><span class="koboSpan" id="kobo.704.1">401</span></strong><span class="koboSpan" id="kobo.705.1"> HTTP status code. </span><span class="koboSpan" id="kobo.705.2">If the </span><strong class="source-inline"><span class="koboSpan" id="kobo.706.1">logged_in</span></strong><span class="koboSpan" id="kobo.707.1"> key exists, the code returns a JSON response with a message stating </span><strong class="source-inline"><span class="koboSpan" id="kobo.708.1">"Welcome to </span></strong><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.709.1">the dashboard"</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.710.1">.</span></span></p>
<h2 id="_idParaDest-232"><a id="_idTextAnchor268"/><span class="koboSpan" id="kobo.711.1">React frontend</span></h2>
<p><span class="koboSpan" id="kobo.712.1">The following code </span><a id="_idIndexMarker925"/><span class="koboSpan" id="kobo.713.1">snippet is a React component </span><a id="_idIndexMarker926"/><span class="koboSpan" id="kobo.714.1">that displays a dashboard for a user. </span><span class="koboSpan" id="kobo.714.2">It uses React hooks, specifically </span><strong class="source-inline"><span class="koboSpan" id="kobo.715.1">useState</span></strong><span class="koboSpan" id="kobo.716.1"> and </span><strong class="source-inline"><span class="koboSpan" id="kobo.717.1">useEffect</span></strong><span class="koboSpan" id="kobo.718.1">, to manage its state and update the </span><span class="No-Break"><span class="koboSpan" id="kobo.719.1">user interface:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.720.1">import React, { useState, useEffect } from "react";import axios from "axios";
function Dashboard() {
  const [isLoggedIn, setIsLoggedIn] = useState(false);
  const [message, setMessage] = useState("");
  const checkLogin = async () =&gt; {
    const response = await axios.get(
      "http://localhost:5000/api/v1/dashboard");
    if (response.status === 200) {
      setIsLoggedIn(true);
      setMessage(response.data.message);
    }
  };
  useEffect(() =&gt; {
  checkLogin();
  }, []);
  if (!isLoggedIn) {
    return &lt;h1&gt;Unauthorized access&lt;/h1&gt;;
  }
  return &lt;h1&gt;{message}&lt;/h1&gt;;
}
export default Dashboard;</span></pre>
<p><span class="koboSpan" id="kobo.721.1">When the component is rendered, it makes an HTTP </span><strong class="source-inline"><span class="koboSpan" id="kobo.722.1">GET</span></strong><span class="koboSpan" id="kobo.723.1"> request to </span><strong class="source-inline"><span class="koboSpan" id="kobo.724.1">http://localhost:5000/api/v1/dashboard</span></strong><span class="koboSpan" id="kobo.725.1"> using the </span><strong class="source-inline"><span class="koboSpan" id="kobo.726.1">axios</span></strong><span class="koboSpan" id="kobo.727.1"> library. </span><span class="koboSpan" id="kobo.727.2">This is done in the </span><strong class="source-inline"><span class="koboSpan" id="kobo.728.1">checkLogin</span></strong><span class="koboSpan" id="kobo.729.1"> function, which is called by the </span><strong class="source-inline"><span class="koboSpan" id="kobo.730.1">useEffect</span></strong><span class="koboSpan" id="kobo.731.1"> hook when the component </span><span class="No-Break"><span class="koboSpan" id="kobo.732.1">is mounted.</span></span></p>
<p><span class="koboSpan" id="kobo.733.1">If the response </span><a id="_idIndexMarker927"/><span class="koboSpan" id="kobo.734.1">from the server is </span><strong class="source-inline"><span class="koboSpan" id="kobo.735.1">200 OK</span></strong><span class="koboSpan" id="kobo.736.1">, this </span><a id="_idIndexMarker928"/><span class="koboSpan" id="kobo.737.1">means that the user is authorized to access the dashboard. </span><span class="koboSpan" id="kobo.737.2">The component’s state is updated to reflect this by setting </span><strong class="source-inline"><span class="koboSpan" id="kobo.738.1">isLoggedIn</span></strong><span class="koboSpan" id="kobo.739.1"> to </span><strong class="source-inline"><span class="koboSpan" id="kobo.740.1">true</span></strong><span class="koboSpan" id="kobo.741.1"> and </span><strong class="source-inline"><span class="koboSpan" id="kobo.742.1">message</span></strong><span class="koboSpan" id="kobo.743.1"> to the message returned from the server. </span><span class="koboSpan" id="kobo.743.2">If the response is not </span><strong class="source-inline"><span class="koboSpan" id="kobo.744.1">200 OK</span></strong><span class="koboSpan" id="kobo.745.1">, this means the user is unauthorized and </span><strong class="source-inline"><span class="koboSpan" id="kobo.746.1">isLoggedIn</span></strong> <span class="No-Break"><span class="koboSpan" id="kobo.747.1">remains </span></span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.748.1">false</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.749.1">.</span></span></p>
<p><span class="koboSpan" id="kobo.750.1">Finally, the component returns a message that tells the user whether they have access to the dashboard. </span><span class="koboSpan" id="kobo.750.2">If </span><strong class="source-inline"><span class="koboSpan" id="kobo.751.1">isLoggedIn</span></strong><span class="koboSpan" id="kobo.752.1"> is </span><strong class="source-inline"><span class="koboSpan" id="kobo.753.1">false</span></strong><span class="koboSpan" id="kobo.754.1">, it returns </span><strong class="source-inline"><span class="koboSpan" id="kobo.755.1">Unauthorized access</span></strong><span class="koboSpan" id="kobo.756.1">. </span><span class="koboSpan" id="kobo.756.2">If </span><strong class="source-inline"><span class="koboSpan" id="kobo.757.1">isLoggedIn</span></strong><span class="koboSpan" id="kobo.758.1"> is </span><strong class="source-inline"><span class="koboSpan" id="kobo.759.1">true</span></strong><span class="koboSpan" id="kobo.760.1">, it returns the message from </span><span class="No-Break"><span class="koboSpan" id="kobo.761.1">the server.</span></span></p>
<p><span class="koboSpan" id="kobo.762.1">In this way, you can create a password-protected dashboard that is only accessible to authenticated users using React and Flask with added security for </span><span class="No-Break"><span class="koboSpan" id="kobo.763.1">your application.</span></span></p>
<p><span class="koboSpan" id="kobo.764.1">Next, you will learn how to implement flash messages in Flask and React </span><span class="No-Break"><span class="koboSpan" id="kobo.765.1">web applications.</span></span></p>
<h1 id="_idParaDest-233"><a id="_idTextAnchor269"/><span class="koboSpan" id="kobo.766.1">Implementing flash messages in Flask</span></h1>
<p><span class="koboSpan" id="kobo.767.1">Flash messages enhance the user experience in any web application, providing informative </span><a id="_idIndexMarker929"/><span class="koboSpan" id="kobo.768.1">and timely feedback to users. </span><span class="koboSpan" id="kobo.768.2">Flash is used to display status or error messages on web pages after a redirect. </span><span class="koboSpan" id="kobo.768.3">For instance, after a successful form submission, a message can be stored in the flash to display a success message on the </span><span class="No-Break"><span class="koboSpan" id="kobo.769.1">redirected page.</span></span></p>
<p><span class="koboSpan" id="kobo.770.1">The flash message is stored in the user’s session, which is a dictionary-like object that can store information between requests. </span><span class="koboSpan" id="kobo.770.2">With flash messages, you can pass information between requests securely and efficiently. </span><span class="koboSpan" id="kobo.770.3">This is useful for displaying messages that don’t need to persist for a long time or that need to be shown only once, such as success or error messages. </span><span class="koboSpan" id="kobo.770.4">Since flash messages are stored in the user’s session, they are only accessible by the server and are not sent to the client in plain text, making </span><span class="No-Break"><span class="koboSpan" id="kobo.771.1">them secure.</span></span></p>
<p><span class="koboSpan" id="kobo.772.1">Let’s modify the login and logout endpoints to show </span><span class="No-Break"><span class="koboSpan" id="kobo.773.1">flash messages.</span></span></p>
<h2 id="_idParaDest-234"><a id="_idTextAnchor270"/><span class="koboSpan" id="kobo.774.1">Flask backend</span></h2>
<p><span class="koboSpan" id="kobo.775.1">The following code </span><a id="_idIndexMarker930"/><span class="koboSpan" id="kobo.776.1">demonstrates the implementation of a flash message system with login and logout endpoints. </span><span class="koboSpan" id="kobo.776.2">The code starts by importing the necessary modules and creating a Flask application. </span><span class="koboSpan" id="kobo.776.3">The </span><strong class="source-inline"><span class="koboSpan" id="kobo.777.1">app.secret_key = "secret_key"</span></strong><span class="koboSpan" id="kobo.778.1"> line sets the secret key, which is used to encrypt the flash messages stored in </span><span class="No-Break"><span class="koboSpan" id="kobo.779.1">the session:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.780.1">from flask import Flask, request, jsonify, session, flashfrom flask_session import Session
app = Flask(__name__)
app.config["SESSION_TYPE"] = "filesystem"
app.secret_key = "secret_key"
Session(app)
@app.route("/api/v1/login", methods=["POST"])
def login():
    username = request.json.get("username")
    password = request.json.get("password")
    if username == "admin" and password == "secret":
        session["logged_in"] = True
        flash("Login successful")
        return jsonify({"message": "Login successful"})
    else:
        flash("Login failed")
        return jsonify({"message": "Login failed"}), 401
@app.route("/api/v1/logout")
def logout():
    session.pop("logged_in", None)
    flash("Logout successful")
    return jsonify({"message": "Logout successful"})</span></pre>
<p><span class="koboSpan" id="kobo.781.1">The </span><strong class="source-inline"><span class="koboSpan" id="kobo.782.1">login</span></strong><span class="koboSpan" id="kobo.783.1"> endpoint is defined by the </span><strong class="source-inline"><span class="koboSpan" id="kobo.784.1">login</span></strong><span class="koboSpan" id="kobo.785.1"> function, which is bound to the </span><strong class="source-inline"><span class="koboSpan" id="kobo.786.1">/api/v1/login</span></strong><span class="koboSpan" id="kobo.787.1"> URL. </span><span class="koboSpan" id="kobo.787.2">The </span><a id="_idIndexMarker931"/><span class="koboSpan" id="kobo.788.1">function retrieves the </span><strong class="source-inline"><span class="koboSpan" id="kobo.789.1">username</span></strong><span class="koboSpan" id="kobo.790.1"> and </span><strong class="source-inline"><span class="koboSpan" id="kobo.791.1">password</span></strong><span class="koboSpan" id="kobo.792.1"> values from the JSON data in the request, and checks if they match the predefined values of </span><strong class="source-inline"><span class="koboSpan" id="kobo.793.1">"admin"</span></strong><span class="koboSpan" id="kobo.794.1"> and </span><strong class="source-inline"><span class="koboSpan" id="kobo.795.1">"secret"</span></strong><span class="koboSpan" id="kobo.796.1">. </span><span class="koboSpan" id="kobo.796.2">If the values match, the user’s session is marked as logged in by setting the </span><strong class="source-inline"><span class="koboSpan" id="kobo.797.1">logged_in</span></strong><span class="koboSpan" id="kobo.798.1"> key in the session, and a flash message is set to indicate that the login </span><span class="No-Break"><span class="koboSpan" id="kobo.799.1">was successful.</span></span></p>
<p><span class="koboSpan" id="kobo.800.1">The function then returns a JSON response, indicating the login was successful. </span><span class="koboSpan" id="kobo.800.2">If the values do not match, a flash message is set, indicating the login failed, and a JSON response indicating the login failure is returned. </span><span class="koboSpan" id="kobo.800.3">The logout endpoint is defined by the </span><strong class="source-inline"><span class="koboSpan" id="kobo.801.1">logout</span></strong><span class="koboSpan" id="kobo.802.1"> function, which is bound to the </span><strong class="source-inline"><span class="koboSpan" id="kobo.803.1">/</span></strong><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.804.1">api/v1/logout</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.805.1"> URL.</span></span></p>
<p><span class="koboSpan" id="kobo.806.1">The function removes the </span><strong class="source-inline"><span class="koboSpan" id="kobo.807.1">logged_in</span></strong><span class="koboSpan" id="kobo.808.1"> key from the session, indicating that the user is no longer logged in, and </span><a id="_idIndexMarker932"/><span class="koboSpan" id="kobo.809.1">sets a flash message indicating that the logout was successful. </span><span class="koboSpan" id="kobo.809.2">A JSON response indicating the logout was successful is </span><span class="No-Break"><span class="koboSpan" id="kobo.810.1">then returned.</span></span></p>
<h2 id="_idParaDest-235"><a id="_idTextAnchor271"/><span class="koboSpan" id="kobo.811.1">React frontend</span></h2>
<p><span class="koboSpan" id="kobo.812.1">The following </span><a id="_idIndexMarker933"/><span class="koboSpan" id="kobo.813.1">snippet demonstrates a React functional </span><a id="_idIndexMarker934"/><span class="koboSpan" id="kobo.814.1">component that represents the dashboard of a web application handling flash messages from the backend. </span><span class="koboSpan" id="kobo.814.2">The </span><strong class="source-inline"><span class="koboSpan" id="kobo.815.1">Dashboard</span></strong><span class="koboSpan" id="kobo.816.1"> component makes use of </span><strong class="source-inline"><span class="koboSpan" id="kobo.817.1">useState</span></strong><span class="koboSpan" id="kobo.818.1"> and </span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.819.1">useEffect</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.820.1"> hooks:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.821.1">import React, { useState, useEffect } from "react";import axios from "axios";
function Dashboard() {
    const [isLoggedIn, setIsLoggedIn] = useState(false);
    const [message, setMessage] = useState("");
    const [flashMessage, setFlashMessage] = useState("");
    const checkLogin = async () =&gt; {
        const response = await axios.get(
            "http://localhost:5000/api/v1/dashboard");
        if (response.status === 200) {
            setIsLoggedIn(true);
            setMessage(response.data.message);
        }
    };
                    .....
</span><span class="koboSpan" id="kobo.821.2">        if (!isLoggedIn) {
            return (
                &lt;div&gt;
                    &lt;h1&gt;Unauthorized access&lt;/h1&gt;
                    &lt;h2&gt;{flashMessage}&lt;/h2&gt;
                    &lt;button onClick={() =&gt;
                        handleLogin("admin", "secret")}&gt;
                        Login&lt;/button&gt;</span></pre>
<p><span class="koboSpan" id="kobo.822.1">The </span><strong class="source-inline"><span class="koboSpan" id="kobo.823.1">Dashboard</span></strong><span class="koboSpan" id="kobo.824.1"> component keeps track of the following </span><span class="No-Break"><span class="koboSpan" id="kobo.825.1">state variables:</span></span></p>
<ul>
<li><strong class="source-inline"><span class="koboSpan" id="kobo.826.1">isLoggedIn</span></strong><span class="koboSpan" id="kobo.827.1">: A Boolean value </span><a id="_idIndexMarker935"/><span class="koboSpan" id="kobo.828.1">indicating if the user is logged in or not. </span><span class="koboSpan" id="kobo.828.2">It is initially set </span><span class="No-Break"><span class="koboSpan" id="kobo.829.1">to </span></span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.830.1">false</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.831.1">.</span></span></li>
<li><strong class="source-inline"><span class="koboSpan" id="kobo.832.1">message</span></strong><span class="koboSpan" id="kobo.833.1">: A string value that represents a message that is displayed on </span><span class="No-Break"><span class="koboSpan" id="kobo.834.1">the dashboard.</span></span></li>
<li><strong class="source-inline"><span class="koboSpan" id="kobo.835.1">flashMessage</span></strong><span class="koboSpan" id="kobo.836.1">: A string value that represents a flash message that is displayed on </span><span class="No-Break"><span class="koboSpan" id="kobo.837.1">the page.</span></span></li>
</ul>
<p><span class="koboSpan" id="kobo.838.1">The </span><strong class="source-inline"><span class="koboSpan" id="kobo.839.1">Dashboard</span></strong><span class="koboSpan" id="kobo.840.1"> component has </span><span class="No-Break"><span class="koboSpan" id="kobo.841.1">three functions:</span></span></p>
<ul>
<li><strong class="source-inline"><span class="koboSpan" id="kobo.842.1">checkLogin</span></strong><span class="koboSpan" id="kobo.843.1">: An asynchronous function that makes a </span><strong class="source-inline"><span class="koboSpan" id="kobo.844.1">GET</span></strong><span class="koboSpan" id="kobo.845.1"> request to the </span><strong class="source-inline"><span class="koboSpan" id="kobo.846.1">/api/v1/dashboard</span></strong><span class="koboSpan" id="kobo.847.1"> endpoint </span><a id="_idIndexMarker936"/><span class="koboSpan" id="kobo.848.1">to check if the user is logged in or not. </span><span class="koboSpan" id="kobo.848.2">If the response status is </span><strong class="source-inline"><span class="koboSpan" id="kobo.849.1">200</span></strong><span class="koboSpan" id="kobo.850.1">, it updates the </span><strong class="source-inline"><span class="koboSpan" id="kobo.851.1">isLoggedIn</span></strong><span class="koboSpan" id="kobo.852.1"> state variables to </span><strong class="source-inline"><span class="koboSpan" id="kobo.853.1">true</span></strong><span class="koboSpan" id="kobo.854.1"> and messages a value </span><span class="No-Break"><span class="koboSpan" id="kobo.855.1">of </span></span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.856.1">response.data.message</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.857.1">.</span></span></li>
<li><strong class="source-inline"><span class="koboSpan" id="kobo.858.1">handleLogin</span></strong><span class="koboSpan" id="kobo.859.1">: An asynchronous function that makes a </span><strong class="source-inline"><span class="koboSpan" id="kobo.860.1">POST</span></strong><span class="koboSpan" id="kobo.861.1"> request to the </span><strong class="source-inline"><span class="koboSpan" id="kobo.862.1">/api/v1/login</span></strong><span class="koboSpan" id="kobo.863.1"> endpoint </span><a id="_idIndexMarker937"/><span class="koboSpan" id="kobo.864.1">with the provided </span><strong class="source-inline"><span class="koboSpan" id="kobo.865.1">username</span></strong><span class="koboSpan" id="kobo.866.1"> and </span><strong class="source-inline"><span class="koboSpan" id="kobo.867.1">password</span></strong><span class="koboSpan" id="kobo.868.1"> values as the request body. </span><span class="koboSpan" id="kobo.868.2">If the response status is </span><strong class="source-inline"><span class="koboSpan" id="kobo.869.1">200</span></strong><span class="koboSpan" id="kobo.870.1">, it </span><a id="_idIndexMarker938"/><span class="koboSpan" id="kobo.871.1">updates the </span><strong class="source-inline"><span class="koboSpan" id="kobo.872.1">isLoggedIn</span></strong><span class="koboSpan" id="kobo.873.1"> state variables to </span><strong class="source-inline"><span class="koboSpan" id="kobo.874.1">true</span></strong><span class="koboSpan" id="kobo.875.1"> and </span><strong class="source-inline"><span class="koboSpan" id="kobo.876.1">flashMessage</span></strong><span class="koboSpan" id="kobo.877.1"> to the value of </span><strong class="source-inline"><span class="koboSpan" id="kobo.878.1">response.data.message</span></strong><span class="koboSpan" id="kobo.879.1">. </span><span class="koboSpan" id="kobo.879.2">If the response status is not </span><strong class="source-inline"><span class="koboSpan" id="kobo.880.1">200</span></strong><span class="koboSpan" id="kobo.881.1">, it updates </span><strong class="source-inline"><span class="koboSpan" id="kobo.882.1">flashMessage</span></strong><span class="koboSpan" id="kobo.883.1"> to the value </span><span class="No-Break"><span class="koboSpan" id="kobo.884.1">of </span></span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.885.1">response.data.message</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.886.1">.</span></span></li>
<li><strong class="source-inline"><span class="koboSpan" id="kobo.887.1">handleLogout</span></strong><span class="koboSpan" id="kobo.888.1">: An asynchronous function that makes a </span><strong class="source-inline"><span class="koboSpan" id="kobo.889.1">GET</span></strong><span class="koboSpan" id="kobo.890.1"> request to the </span><strong class="source-inline"><span class="koboSpan" id="kobo.891.1">/api/v1/logout</span></strong><span class="koboSpan" id="kobo.892.1"> endpoint. </span><span class="koboSpan" id="kobo.892.2">If the </span><a id="_idIndexMarker939"/><span class="koboSpan" id="kobo.893.1">response status is </span><strong class="source-inline"><span class="koboSpan" id="kobo.894.1">200</span></strong><span class="koboSpan" id="kobo.895.1">, it updates the </span><strong class="source-inline"><span class="koboSpan" id="kobo.896.1">isLoggedIn</span></strong><span class="koboSpan" id="kobo.897.1"> state variables to </span><strong class="source-inline"><span class="koboSpan" id="kobo.898.1">false</span></strong><span class="koboSpan" id="kobo.899.1"> and </span><strong class="source-inline"><span class="koboSpan" id="kobo.900.1">flashMessage</span></strong><span class="koboSpan" id="kobo.901.1"> to the value </span><span class="No-Break"><span class="koboSpan" id="kobo.902.1">of </span></span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.903.1">response.data.message</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.904.1">.</span></span></li>
</ul>
<p><span class="koboSpan" id="kobo.905.1">The </span><strong class="source-inline"><span class="koboSpan" id="kobo.906.1">useEffect</span></strong><span class="koboSpan" id="kobo.907.1"> hook is used to call the </span><strong class="source-inline"><span class="koboSpan" id="kobo.908.1">checkLogin</span></strong><span class="koboSpan" id="kobo.909.1"> function when the component </span><span class="No-Break"><span class="koboSpan" id="kobo.910.1">is mounted.</span></span></p>
<p><span class="koboSpan" id="kobo.911.1">Finally, the component </span><a id="_idIndexMarker940"/><span class="koboSpan" id="kobo.912.1">returns a UI, depending on the value </span><a id="_idIndexMarker941"/><span class="koboSpan" id="kobo.913.1">of </span><strong class="source-inline"><span class="koboSpan" id="kobo.914.1">isLoggedIn:</span></strong><span class="koboSpan" id="kobo.915.1">. </span><span class="koboSpan" id="kobo.915.2">If the user is not logged in, it displays a message saying </span><strong class="source-inline"><span class="koboSpan" id="kobo.916.1">"Unauthorized access"</span></strong><span class="koboSpan" id="kobo.917.1"> and a </span><strong class="bold"><span class="koboSpan" id="kobo.918.1">Login</span></strong><span class="koboSpan" id="kobo.919.1"> button. </span><span class="koboSpan" id="kobo.919.2">If the user is logged in, it displays a message value of </span><strong class="source-inline"><span class="koboSpan" id="kobo.920.1">"</span></strong><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.921.1">Login successful"</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.922.1">.</span></span></p>
<p><span class="koboSpan" id="kobo.923.1">In this way, you can use flash messages to provide feedback to the user in a React application via the frontend, and then use the Flask backend to enhance the user’s experience. </span><span class="koboSpan" id="kobo.923.2">Overall, flash messages make web applications more interactive </span><span class="No-Break"><span class="koboSpan" id="kobo.924.1">and user-friendly.</span></span></p>
<h1 id="_idParaDest-236"><a id="_idTextAnchor272"/><span class="koboSpan" id="kobo.925.1">Summary</span></h1>
<p><span class="koboSpan" id="kobo.926.1">This chapter has provided a comprehensive overview of the fundamentals of information security and how to secure a Flask web application using authentication and authorization. </span><span class="koboSpan" id="kobo.926.2">You learned about the best practices and were provided with use cases for implementing authentication and authorization in a Flask application. </span><span class="koboSpan" id="kobo.926.3">We also discussed different types of authentication methods and access </span><span class="No-Break"><span class="koboSpan" id="kobo.927.1">control methods.</span></span></p>
<p><span class="koboSpan" id="kobo.928.1">You explored how to manage user sessions and implement password-protected dashboards. </span><span class="koboSpan" id="kobo.928.2">Additionally, this chapter has shown you how to use flash messages to provide feedback to users of web applications. </span><span class="koboSpan" id="kobo.928.3">You are expected to have garnered a solid understanding of how to secure a Flask application and be able to implement authentication and authorization in </span><span class="No-Break"><span class="koboSpan" id="kobo.929.1">your projects.</span></span></p>
<p><span class="koboSpan" id="kobo.930.1">In the next chapter, we will discuss how to handle errors in Flask web applications with React handling the frontend part of it. </span><span class="koboSpan" id="kobo.930.2">We will delve into in-built Flask debugging capabilities and learn how to handle custom error messages in </span><span class="No-Break"><span class="koboSpan" id="kobo.931.1">React-Flask applications.</span></span></p>
</div>
</body></html>