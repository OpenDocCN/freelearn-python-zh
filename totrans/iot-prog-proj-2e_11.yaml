- en: '11'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '11'
- en: Introducing ROS
  id: totrans-1
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 介绍ROS
- en: In this chapter, we introduce the **Robot Operating System** (**ROS**), a powerful
    tool for developing robotics applications. We will explore the significance of
    ROS in the field of robotics and detail the process of setting up ROS on a Raspberry
    Pi 4\. This involves replacing the standard Raspberry Pi OS with Ubuntu, due to
    Ubuntu’s compatibility and optimization for specific versions of ROS.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们介绍了**机器人操作系统**（**ROS**），这是一个用于开发机器人应用的强大工具。我们将探讨ROS在机器人领域的意义，并详细说明在Raspberry
    Pi 4上设置ROS的过程。这涉及到用Ubuntu替换标准Raspberry Pi OS，因为Ubuntu与ROS特定版本的兼容性和优化。
- en: We will start our hands-on exercises setting up and running **TurtleSim**, a
    user-friendly ROS simulator. We will do this to gain knowledge of basic ROS concepts
    and operations. Starting with simple keyboard controls, we will learn how to command
    and maneuver a virtual robot within the simulator environment. We will follow
    this up by progressing to controlling the TurtleSim simulator with **Message Queuing
    Telemetry Transport** (**MQTT**) messages as we start to bridge the gap between
    simulation and real-world application.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将从设置和运行用户友好的ROS模拟器**TurtleSim**开始我们的动手练习。我们将这样做是为了了解基本的ROS概念和操作。从简单的键盘控制开始，我们将学习如何在模拟器环境中指挥和操纵虚拟机器人。随后，我们将通过使用**消息队列遥测传输**（**MQTT**）消息来控制TurtleSim模拟器，以此开始弥合模拟与现实应用之间的差距。
- en: Building on the skills developed through working with TurtleSim will prepare
    us for constructing our advanced IoT robot named A.R.E.S. (short for Advanced
    Robot Eyes for Security). A.R.E.S. is the final and most sophisticated project
    of the book and will comprise the remaining chapters.
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 通过与TurtleSim合作开发技能，我们将为构建名为A.R.E.S.（代表高级机器人眼睛用于安全）的高级物联网机器人做好准备。A.R.E.S.是本书的最终和最复杂的项目，并将包括剩余的章节。
- en: 'We will cover the following topics in this chapter:'
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 本章我们将涵盖以下主题：
- en: Exploring ROS
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 探索ROS
- en: Installing Ubuntu and ROS onto our Raspberry Pi
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在我们的Raspberry Pi上安装Ubuntu和ROS
- en: Running and controlling a simulated robot
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 运行和控制模拟机器人
- en: Let’s begin!
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们开始吧！
- en: Technical requirements
  id: totrans-10
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 技术要求
- en: 'The following are the requirements for completing this chapter:'
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 完成本章所需的以下要求：
- en: Intermediate knowledge of Python programming
  id: totrans-12
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Python编程的中级知识
- en: Basic knowledge of the Linux command line
  id: totrans-13
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 基本的Linux命令行知识
- en: A CloudAMQP account for the MQTT server instance
  id: totrans-14
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 用于MQTT服务器实例的CloudAMQP账户
- en: Late-model Raspberry Pi 4 or any computer capable of installing Ubuntu (Ubuntu
    installed on a Mac mini was used in this chapter)
  id: totrans-15
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 新款Raspberry Pi 4或任何能够安装Ubuntu的计算机（本章使用了安装了Ubuntu的Mac mini）
- en: microSD card and microSD – USB adapter
  id: totrans-16
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: microSD卡和microSD-USB适配器
- en: 'The code for this chapter may be found here:'
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 本章的代码可以在以下位置找到：
- en: '[https://github.com/PacktPublishing/-Internet-of-Things-Programming-Projects-2nd-Edition/tree/main/Chapter11](https://github.com/PacktPublishing/Internet-of-Things-Programming-Projects-2nd-Edition/tree/main/Chapter11)'
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: '[https://github.com/PacktPublishing/-Internet-of-Things-Programming-Projects-2nd-Edition/tree/main/Chapter11](https://github.com/PacktPublishing/Internet-of-Things-Programming-Projects-2nd-Edition/tree/main/Chapter11)'
- en: Exploring ROS
  id: totrans-19
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 探索ROS
- en: In this section, we will explore the basics of ROS. This section is by no means
    an in-depth replacement for the excellent documentation that may be found on the
    ROS website at [www.ros.org](https://www.ros.org/).
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们将探索ROS的基本知识。本节绝对不是对ROS网站上可能找到的优秀文档的深入替代。
- en: ROS is an **Open Source Software** (**OSS**) development kit for robotics applications,
    providing a standard platform that bridges the gap between research and production.
    Designed to speed up the robotics development process, ROS simplifies the creation
    of robotic systems. It is 100% open source and commercially friendly.
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: ROS是一个用于机器人应用的**开源软件**（**OSS**）开发套件，提供了一个连接研究和生产的标准平台。设计用于加速机器人开发过程，ROS简化了机器人系统的创建。它是100%开源且商业友好的。
- en: 'Our goal here is to establish a common knowledge base, equipping us with the
    essential concepts and tools of ROS needed for this chapter’s project and, eventually,
    our A.R.E.S. robot. We will start by outlining the main project of this chapter:
    the control of the ROS TurtleSim virtual robot using MQTT messaging.'
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的目标是建立一个共同的知识库，为我们提供完成本章项目以及最终A.R.E.S.机器人所需的ROS的基本概念和工具。我们将从概述本章的主要项目开始：使用MQTT消息控制ROS
    TurtleSim虚拟机器人。
- en: Reviewing our TurtleSim controller ROS application
  id: totrans-23
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 检查我们的TurtleSim控制器ROS应用
- en: TurtleSim is a lightweight robot simulator provided by ROS and is primarily
    used as an educational tool for learning ROS concepts. It offers a simple interface
    for teaching the basics of ROS, allowing users to experiment with commands and
    observe the behavior of a simulated robot in a safe and controlled environment.
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: TurtleSim 是 ROS 提供的一个轻量级机器人模拟器，主要用于学习 ROS 概念的教育工具。它提供了一个简单的界面，用于教授 ROS 的基础知识，使用户能够在安全和受控的环境中实验命令并观察模拟机器人的行为。
- en: For the main project in this chapter, we will control a TurtleSim instance with
    MQTT messages as we command the robot to draw a circle or stop moving based on
    the message we transmit to the `move` topic of our MQTT instance.
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章的主要项目中，我们将使用 MQTT 消息来控制 TurtleSim 实例，根据我们发送到 MQTT 实例的 `move` 主题的消息，命令机器人画圆或停止移动。
- en: 'In *Figure 11**.1*, we see our application illustrated. Messages created using
    the MQTT-Explorer in Windows are sent to the `circle` node we create in ROS. Based
    on the message, either `draw_circle` or `stop`, we send a `cmd_vel` topic ROS
    message to a TurtleSim instance. This internal messaging uses publishers and subscribers
    and is like the way MQTT communication is performed:'
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 在 *图 11*.1 中，我们看到我们的应用程序被展示出来。使用 Windows 中的 MQTT-Explorer 创建的消息被发送到我们在 ROS 中创建的
    `circle` 节点。根据消息，我们发送 `draw_circle` 或 `stop`，将 `cmd_vel` 主题的 ROS 消息发送到 TurtleSim
    实例。这种内部消息使用发布者和订阅者，类似于 MQTT 通信的执行方式：
- en: '![Figure 11.1 – Using MQTT messages to control a simulated robot](img/B21282_11_1.jpg)'
  id: totrans-27
  prefs: []
  type: TYPE_IMG
  zh: '![图 11.1 – 使用 MQTT 消息控制模拟机器人](img/B21282_11_1.jpg)'
- en: Figure 11.1 – Using MQTT messages to control a simulated robot
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 图 11.1 – 使用 MQTT 消息控制模拟机器人
- en: For the application in this chapter, we will be sending messages directly using
    the MQTT-Explorer app. In the next chapter, we will build an IoT joystick with
    a Raspberry Pi Pico W and use it to control the simulated robot.
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 对于本章的应用程序，我们将直接使用 MQTT-Explorer 应用程序发送消息。在下一章中，我们将使用 Raspberry Pi Pico W 构建一个物联网摇杆，并使用它来控制模拟机器人。
- en: Now that we’ve outlined our chapter’s goals, let’s step back to gain a basic
    understanding of ROS concepts. This overview will provide us with a fundamental
    insight into its architecture and role in robotics.
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经概述了本章的目标，让我们退后一步，对 ROS 概念有一个基本的了解。这个概述将为我们提供对其架构和在机器人技术中角色的基本洞察。
- en: Understanding ROS node communication
  id: totrans-31
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 理解 ROS 节点通信
- en: ROS supports a wide range of applications and platforms, including Linux, Windows,
    macOS, and embedded systems, making it highly versatile. Its modular framework
    is based on the concepts of nodes, topics, services, and actions. Nodes in ROS
    are individual processes that perform specific computations, and topics serve
    as communication channels where nodes exchange messages using a publisher-subscriber
    mechanism.
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: ROS 支持广泛的平台和应用，包括 Linux、Windows、macOS 和嵌入式系统，使其非常灵活。其模块化框架基于节点、主题、服务和动作的概念。ROS
    中的节点是执行特定计算的单个进程，而主题作为节点之间通过发布者-订阅者机制交换消息的通信渠道。
- en: 'For our application, we will be using a topic and publisher-subscriber model
    to send `vel_msg` messages of the `cmd_vel` topic from our custom `circle` node
    to an instance of a TurtleSim virtual robot. Although a publisher may have many
    subscribers, we will only be using one instance of TurtleSim to subscribe to the
    publisher we will build in our custom node. We see this illustrated in the following
    diagram:'
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 对于我们的应用程序，我们将使用主题和发布者-订阅者模型，将来自我们自定义 `circle` 节点的 `cmd_vel` 主题的 `vel_msg` 消息发送到
    TurtleSim 虚拟机器人的实例。尽管发布者可能有多个订阅者，但我们将只使用一个 TurtleSim 实例来订阅我们在自定义节点中构建的发布者。以下图示说明了这一点：
- en: '![Figure 11.2 – A view of the publisher-subscriber model inside ROS](img/B21282_11_2.jpg)'
  id: totrans-34
  prefs: []
  type: TYPE_IMG
  zh: '![图 11.2 – ROS 内部发布者-订阅者模型视图](img/B21282_11_2.jpg)'
- en: Figure 11.2 – A view of the publisher-subscriber model inside ROS
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 图 11.2 – ROS 内部发布者-订阅者模型视图
- en: Services in ROS offer a way for nodes to perform request-response interactions,
    useful for tasks that require immediate feedback. Actions provide a means for
    executing long-running tasks that require continuous feedback and the possibility
    of cancellation. We will not be using services or actions for our application.
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: ROS 中的服务为节点提供了执行请求-响应交互的方式，这对于需要即时反馈的任务非常有用。动作提供了一种执行需要持续反馈和取消可能性的长时间运行任务的方法。我们不会在我们的应用程序中使用服务或动作。
- en: Now that we have a little understanding of ROS node communication, let’s look
    at the project structure in ROS.
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们对 ROS 节点通信有了一定的了解，让我们来看看 ROS 中的项目结构。
- en: Investigating ROS project structure and organization
  id: totrans-38
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 调查ROS项目的结构和组织
- en: 'The structure of a ROS project is organized for the efficient development and
    management of robotics applications. At its core, a ROS project is built around
    the concept of packages and workspaces, which are essential for organizing the
    various components of a robotics project. The following list summarizes the key
    concepts for a ROS project:'
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: ROS项目的结构是为了高效地开发和管理工作机器人应用而组织的。在其核心，一个ROS项目是围绕软件包和工作空间的概念构建的，这对于组织机器人项目的各种组件至关重要。以下列表总结了ROS项目的关键概念：
- en: '**Packages and workspaces**: A ROS workspace is a directory (or a folder) where
    ROS packages are developed and compiled. Each package, typically a directory within
    the workspace, represents a specific functionality or component of the robot,
    such as sensors, actuators, algorithms, or even a collection of related nodes.
    Packages can contain ROS nodes, libraries, datasets, configuration files, or anything
    that constitutes an independent and reusable module.'
  id: totrans-40
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**软件包和工作空间**：一个ROS工作空间是一个目录（或文件夹），其中开发并编译ROS软件包。每个软件包，通常在工作空间内的一个目录，代表机器人特定的功能或组件，例如传感器、执行器、算法，甚至是一组相关的节点。软件包可以包含ROS节点、库、数据集、配置文件，或构成独立且可重用模块的任何内容。'
- en: '**ROS nodes and communication**: Within these packages, the primary executable
    units are the nodes. Each node is designed to perform a specific task, such as
    controlling a motor, processing sensor data, or performing computations. Nodes
    communicate with each other over topics, services, or actions. Topics allow for
    asynchronous, publish-subscribe communication, ideal for streaming data such as
    sensor readings or control commands. Services provide synchronous, request-response
    interaction, useful for tasks that need immediate feedback. Actions are suited
    for long-running tasks that require continuous feedback and the possibility of
    cancellation. As mentioned, we will be creating a custom node to communicate with
    the TurtleSim simulator using topics and the publish-subscribe method.'
  id: totrans-41
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**ROS节点和通信**：在这些软件包中，主要的可执行单元是节点。每个节点被设计来执行特定的任务，例如控制电机、处理传感器数据或执行计算。节点通过主题、服务或动作相互通信。主题允许异步的发布-订阅通信，非常适合流式传输数据，如传感器读数或控制命令。服务提供同步的请求-响应交互，适用于需要即时反馈的任务。动作适合长时间运行的任务，这些任务需要连续的反馈和取消的可能性。如前所述，我们将创建一个自定义节点，使用主题和发布-订阅方法与TurtleSim模拟器进行通信。'
- en: '`catkin` in ROS 1 or `colcon` in ROS 2) to compile and manage packages. The
    build system handles dependencies and integrates packages into the ROS ecosystem.
    We will be using `colcon` to compile our project.'
  id: totrans-42
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在ROS 1中使用`catkin`或在ROS 2中使用`colcon`来编译和管理软件包。构建系统处理依赖关系并将软件包集成到ROS生态系统中。我们将使用`colcon`来编译我们的项目。
- en: '`ros2` `run` command.'
  id: totrans-43
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`ros2` `run`命令。'
- en: We will construct our workspaces, build our packages, and execute our program
    directly from the command line. Before we do this, let’s explore how ROS distributions
    align with Ubuntu versions.
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将构建我们的工作空间，构建我们的软件包，并直接从命令行执行我们的程序。在我们这样做之前，让我们探索ROS发行版如何与Ubuntu版本相匹配。
- en: Aligning ROS distributions with Ubuntu LTS versions
  id: totrans-45
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 将ROS发行版与Ubuntu LTS版本相匹配
- en: Each ROS distribution is paired with a designated Ubuntu **Long-Term Support**
    (**LTS**) version, a strategy that guarantees stability and compatibility as it
    gives ROS developers a consistent code base to work with.
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 每个ROS发行版都与指定的Ubuntu **长期支持**（**LTS**）版本配对，这种策略保证了稳定性和兼容性，因为它为ROS开发者提供了一个一致的代码库来工作。
- en: 'The ROS release policy is clear: one Ubuntu LTS version per ROS release, with
    no new Ubuntu version support after the release. To take advantage of this pairing
    of Ubuntu with ROS, we will install Ubuntu 22.04 and the Humble Hawksbill version
    of ROS 2 onto our Raspberry Pi 4 (for those of us who wish to run Ubuntu on a
    computer other than a Raspberry Pi, we may skip the next section).'
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: ROS的发布策略是明确的：每个ROS发布版对应一个Ubuntu LTS版本，发布后不再支持新的Ubuntu版本。为了利用Ubuntu与ROS的这种配对，我们将安装Ubuntu
    22.04和ROS 2的Humble Hawksbill版本到我们的Raspberry Pi 4（对于那些希望在除Raspberry Pi以外的计算机上运行Ubuntu的人，我们可能可以跳过下一节）。
- en: We will start by flashing Ubuntu onto a microSD card using the Raspberry Pi
    Imager.
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将首先使用Raspberry Pi Imager将Ubuntu闪存到microSD卡上。
- en: Installing Ubuntu and ROS onto our Raspberry Pi
  id: totrans-49
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 在我们的Raspberry Pi上安装Ubuntu和ROS
- en: In this section, we will walk through the steps of installing Ubuntu 22.04 and
    ROS Humble Hawksbill on our Raspberry Pi 4\. This involves choosing the correct
    Ubuntu image, flashing it onto a microSD card using the Raspberry Pi Imager, and
    setting up the Raspberry Pi to boot with Ubuntu.
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们将逐步介绍如何在我们的 Raspberry Pi 4 上安装 Ubuntu 22.04 和 ROS Humble Hawksbill。这包括选择正确的
    Ubuntu 镜像，使用 Raspberry Pi 镜像工具将其烧录到 microSD 卡，并设置 Raspberry Pi 以 Ubuntu 启动。
- en: Why are we using a Raspberry Pi 4 and not a Raspberry Pi 5?
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 为什么我们使用 Raspberry Pi 4 而不是 Raspberry Pi 5？
- en: At the time of writing, the Raspberry Pi 5 does not support Ubuntu 22.04 and
    thus the latest version of ROS.
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 在撰写本文时，Raspberry Pi 5 不支持 Ubuntu 22.04 以及 ROS 的最新版本。
- en: We will start by launching the Raspberry Pi Imager on a computer of our choice.
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将首先在我们的选择电脑上启动 Raspberry Pi 镜像工具。
- en: Installing Ubuntu on our Raspberry Pi 4
  id: totrans-54
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 在我们的 Raspberry Pi 4 上安装 Ubuntu
- en: To install Ubuntu onto our Raspberry Pi 4, we will use the Raspberry Pi Imager
    to burn the operating system onto a microSD card, which we will install on our
    Pi. The Raspberry Pi Imager is a tool created by the Raspberry Pi Foundation and
    is used to simplify the process of imaging microSD cards with the Raspberry Pi
    operating system and other compatible systems.
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 要将 Ubuntu 安装到我们的 Raspberry Pi 4，我们将使用 Raspberry Pi 镜像工具将操作系统烧录到 microSD 卡，然后将其安装到我们的
    Pi 上。Raspberry Pi 镜像工具是由 Raspberry Pi 基金会创建的工具，用于简化使用 Raspberry Pi 操作系统和其他兼容系统镜像
    microSD 卡的过程。
- en: The Raspberry Pi Imager is available for Windows, macOS, and Linux and may even
    be installed on the Raspberry Pi itself.
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: Raspberry Pi 镜像工具适用于 Windows、macOS 和 Linux，甚至可以安装在 Raspberry Pi 本身上。
- en: Using the Raspberry Pi Imager on a Raspberry Pi
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 在 Raspberry Pi 上使用 Raspberry Pi 镜像工具
- en: We may use the Raspberry Pi Imager on our Raspberry Pi to burn an image onto
    a microSD card. The process involves using an SD card reader connected to the
    Raspberry Pi’s USB port. We may install the imager from a Terminal in the Raspberry
    Pi OS with the `sudo apt install` `rpi-imager` command.
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以使用 Raspberry Pi 镜像工具在我们的 Raspberry Pi 上将镜像烧录到 microSD 卡。这个过程涉及到使用连接到 Raspberry
    Pi USB 端口的 SD 卡读卡器。我们可以通过在 Raspberry Pi OS 的终端中使用 `sudo apt install rpi-imager`
    命令来安装镜像工具。
- en: 'To burn Ubuntu onto a microSD card for use with a Raspberry Pi, we do the following:'
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 将 Ubuntu 烧录到 microSD 卡以供 Raspberry Pi 使用，我们需要执行以下步骤：
- en: 'Using an internet browser, we navigate to the following website to download
    the Raspberry Pi Imager:'
  id: totrans-60
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用网络浏览器，我们导航到以下网站下载 Raspberry Pi 镜像工具：
- en: '[https://www.raspberrypi.com/software/](https://www.raspberrypi.com/software/)'
  id: totrans-61
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '[https://www.raspberrypi.com/software/](https://www.raspberrypi.com/software/)'
- en: 'To begin the imaging process, we insert a microSD card into a USB microSD adapter
    and then connect the adapter to a USB port on our computer:'
  id: totrans-62
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 要开始镜像过程，我们将 microSD 卡插入 USB microSD 适配器，然后将适配器连接到电脑的 USB 端口：
- en: '![Figure 11.3 – A USB microSD adapter with microSD card inserted](img/B21282_11_3.jpg)'
  id: totrans-63
  prefs: []
  type: TYPE_IMG
  zh: '![图 11.3 – 插入 microSD 卡的 USB microSD 适配器](img/B21282_11_3.jpg)'
- en: Figure 11.3 – A USB microSD adapter with microSD card inserted
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 图 11.3 – 插入 microSD 卡的 USB microSD 适配器
- en: 'Next, we install the Raspberry Pi Imager software on our computer. Once installed,
    launching the imager will bring up its main screen, ready for us to select an
    operating system image and the target microSD card for the installation:'
  id: totrans-65
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，我们在电脑上安装 Raspberry Pi 镜像工具软件。安装完成后，启动镜像工具将显示主界面，准备好让我们选择操作系统镜像和安装的目标 microSD
    卡：
- en: '![Figure 11.4 – Raspberry Pi Imager](img/B21282_11_4.jpg)'
  id: totrans-66
  prefs: []
  type: TYPE_IMG
  zh: '![图 11.4 – Raspberry Pi 镜像工具](img/B21282_11_4.jpg)'
- en: Figure 11.4 – Raspberry Pi Imager
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 图 11.4 – Raspberry Pi 镜像工具
- en: Under **Raspberry Pi Device**, we select **NO FILTERING**.
  id: totrans-68
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 **Raspberry Pi 设备** 下，我们选择 **不筛选**。
- en: For **Operating System**, we select **Other General Purpose OS**, then **Ubuntu**,
    then **Ubuntu Desktop 22.04.3** **LTS (64-BIT)**.
  id: totrans-69
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 对于 **操作系统**，我们选择 **其他通用操作系统**，然后选择 **Ubuntu**，然后选择 **Ubuntu Desktop 22.04.3
    LTS (64-BIT)**。
- en: We then click on the **CHOOSE STORAGE** button and select the microSD card we
    inserted into our computer.
  id: totrans-70
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后，我们点击 **选择存储** 按钮，并选择我们插入电脑的 microSD 卡。
- en: 'Our selections should look like the following:'
  id: totrans-71
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们的选择应该如下所示：
- en: '![Figure 11.5 – Raspberry Pi Imager after selections](img/B21282_11_5.jpg)'
  id: totrans-72
  prefs: []
  type: TYPE_IMG
  zh: '![图 11.5 – 选择后的 Raspberry Pi 镜像工具](img/B21282_11_5.jpg)'
- en: Figure 11.5 – Raspberry Pi Imager after selections
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 图 11.5 – 选择后的 Raspberry Pi 镜像工具
- en: Selecting the correct version of Ubuntu
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 选择正确的 Ubuntu 版本
- en: At the time of writing, the latest version of ROS 2 supports Ubuntu 22.04\.
    Therefore, in our example, we will use Ubuntu 22.04 LTS, even though the most
    recent version of Ubuntu is 23.10\. For future iterations of ROS 2, it’s important
    to select the version of Ubuntu that corresponds with the ROS 2 release in use.
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 在编写本文时，ROS 2的最新版本支持Ubuntu 22.04。因此，在我们的示例中，我们将使用Ubuntu 22.04 LTS，尽管最新的Ubuntu版本是23.10。对于ROS
    2的未来版本，选择与使用的ROS 2版本相对应的Ubuntu版本非常重要。
- en: To start the burning process, we click on the **NEXT** button and click on the
    **Yes** button on the **Warning** dialog to continue.
  id: totrans-76
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 要开始烧录过程，我们点击**下一步**按钮，并在**警告**对话框中点击**是**按钮以继续。
- en: Once the writing process is complete, the Raspberry Pi Imager will perform a
    verification to ensure the image has been correctly written to the microSD card.
    Upon successful verification, we should see a **Write Successful** screen, indicating
    that the microSD card is now ready to be used in our Raspberry Pi with the newly
    installed operating system.
  id: totrans-77
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 写作过程完成后，Raspberry Pi Imager将执行验证以确保图像已正确写入microSD卡。在验证成功后，我们应该看到一个**写入成功**屏幕，表明microSD卡现在可以用于我们的Raspberry
    Pi，并安装了新操作系统。
- en: With the image burned onto our microSD card, we then proceed to install the
    card onto our Raspberry Pi and follow the steps to complete the installation of
    Ubuntu onto the Raspberry Pi.
  id: totrans-78
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在将图像烧录到我们的microSD卡后，我们接着将卡安装到我们的Raspberry Pi上，并按照步骤完成Ubuntu在Raspberry Pi上的安装。
- en: With Ubuntu now running on our Raspberry Pi, the next step is to install the
    appropriate version of ROS. Despite its name, ROS isn’t an operating system. Instead,
    it functions as a middleware or software framework, providing tools and libraries
    for building and managing robotic applications.
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 现在Ubuntu已经在我们的Raspberry Pi上运行，下一步是安装适当的ROS版本。尽管名为ROS，但它不是一个操作系统。相反，它作为一个中间件或软件框架运行，提供构建和管理机器人应用程序的工具和库。
- en: Adding ROS to our Ubuntu installation
  id: totrans-80
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 将ROS添加到我们的Ubuntu安装中
- en: Recapping our *Exploring ROS* section, we emphasized the importance of matching
    each ROS distribution with a specific Ubuntu LTS version to ensure stability.
    Having installed Ubuntu 22.04 on our Raspberry Pi, we’re now ready to install
    ROS.
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 在总结我们的**探索ROS**部分时，我们强调了将每个ROS发行版与特定的Ubuntu LTS版本匹配的重要性，以确保稳定性。在Raspberry Pi上安装了Ubuntu
    22.04后，我们现在准备安装ROS。
- en: 'As of this writing, there are two ROS versions compatible with Ubuntu 22.04:
    Humble Hawksbill and Iron Irwini. Humble Hawksbill is an LTS version, meaning
    it’s designed for stability and extended support, ideal for longer-term projects
    and those seeking a stable development environment. Iron Irwini, on the other
    hand, is a non-LTS version, typically featuring more cutting-edge changes but
    with a shorter support life cycle.'
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 到本文编写时为止，有两个与Ubuntu 22.04兼容的ROS版本：Humble Hawksbill和Iron Irwini。Humble Hawksbill是一个LTS版本，这意味着它旨在提供稳定性和长期支持，非常适合长期项目和寻求稳定开发环境的人。另一方面，Iron
    Irwini是一个非LTS版本，通常具有更多前沿的变更，但支持生命周期较短。
- en: We will use Humble Hawksbill for our application as we desire stability over
    new features for what we are doing.
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 由于我们希望我们的应用稳定性高于新功能，我们将使用Humble Hawksbill。
- en: Important note
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 重要提示
- en: The ROS installation instructions provided here are current as of the time of
    writing. However, it’s recommended to consult the official web page for the most
    up-to-date guidance, as there may be updates or changes.
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 这里提供的ROS安装说明是在编写时最新的。然而，建议您咨询官方网页以获取最新的指导，因为可能会有更新或变化。
- en: 'To install Humble Hawksbill on our Raspberry Pi, we do the following:'
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 要在我们的Raspberry Pi上安装Humble Hawksbill，我们执行以下操作：
- en: 'To view the latest versions of ROS, we navigate to the following website:'
  id: totrans-87
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 要查看ROS的最新版本，我们导航到以下网站：
- en: '[https://www.ros.org/blog/getting-started/](https://www.ros.org/blog/getting-started/)'
  id: totrans-88
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '[https://www.ros.org/blog/getting-started/](https://www.ros.org/blog/getting-started/)'
- en: 'To view the current versions of ROS, we scroll down to the **Installation**
    section of the page where we see the following:'
  id: totrans-89
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 要查看ROS的当前版本，我们滚动到页面上的**安装**部分，我们看到以下内容：
- en: '![Figure 11.6 – Current versions of ROS](img/B21282_11_6.jpg)'
  id: totrans-90
  prefs: []
  type: TYPE_IMG
  zh: '![图11.6 – ROS的当前版本](img/B21282_11_6.jpg)'
- en: Figure 11.6 – Current versions of ROS
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 图11.6 – ROS的当前版本
- en: To proceed, we click on the **Install** link under the **Humble** **Hawksbill**
    section.
  id: totrans-92
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 要继续，我们在**Humble** **Hawksbill**部分下点击**安装**链接。
- en: This will bring us to the Humble Hawksbill installation page.
  id: totrans-93
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 这将带我们到Humble Hawksbill安装页面。
- en: 'To install Humble Hawksbill for Ubuntu, we click on the **Debian packages**
    link (highlighted with a red box in the following figure) under **Ubuntu Linux
    – Jammy** **Jellyfish (22.04)**:'
  id: totrans-94
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 要为Ubuntu安装Humble Hawksbill，我们点击**Debian软件包**链接（在以下图中用红色框突出显示），位于**Ubuntu Linux
    – Jammy** **Jellyfish (22.04)**下：
- en: '![Figure 11.7 – Binary packages for ROS](img/B21282_11_7.jpg)'
  id: totrans-95
  prefs: []
  type: TYPE_IMG
  zh: '![图11.7 – ROS的二进制软件包](img/B21282_11_7.jpg)'
- en: Figure 11.7 – Binary packages for ROS
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 图11.7 – ROS的二进制软件包
- en: 'To set the locale in Ubuntu, we simply copy the commands from the **Set locale**
    section of the web page. This can be done quickly by clicking the **Copy** icon
    on the top right of the code box, which appears when we hover over it. We then
    paste and execute these commands into the Ubuntu Terminal to complete the locale
    setting process:'
  id: totrans-97
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 要在Ubuntu中设置区域设置，我们只需从网页的**设置区域设置**部分复制命令。这可以通过点击代码框右上角的**复制**图标快速完成，该图标在我们悬停时出现。然后我们将这些命令粘贴并执行到Ubuntu终端中，以完成区域设置过程：
- en: '![Figure 11.8 – Setting the locale in Ubuntu](img/B21282_11_8.jpg)'
  id: totrans-98
  prefs: []
  type: TYPE_IMG
  zh: '![图11.8 – 在Ubuntu中设置区域设置](img/B21282_11_8.jpg)'
- en: Figure 11.8 – Setting the locale in Ubuntu
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 图11.8 – 在Ubuntu中设置区域设置
- en: 'To configure our system to access and authenticate the ROS software repository,
    we copy, paste, and execute the code from each section under the **Setup** **Sources**
    section:'
  id: totrans-100
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 要配置我们的系统以访问和验证ROS软件仓库，我们复制、粘贴并执行**设置** **源**部分下的每个部分的代码：
- en: '![Figure 11.9 – Configuring our Ubuntu installation for access to the ROS software
    repository](img/B21282_11_9.jpg)'
  id: totrans-101
  prefs: []
  type: TYPE_IMG
  zh: '![图11.9 – 配置我们的Ubuntu安装以访问ROS软件仓库](img/B21282_11_9.jpg)'
- en: Figure 11.9 – Configuring our Ubuntu installation for access to the ROS software
    repository
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 图11.9 – 配置我们的Ubuntu安装以访问ROS软件仓库
- en: 'To update our system’s packages, we type the following command into the Terminal:'
  id: totrans-103
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 要更新我们系统的软件包，我们在终端中输入以下命令：
- en: '[PRE0]'
  id: totrans-104
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'We then upgrade the packages on our system with the following command:'
  id: totrans-105
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后，我们使用以下命令升级系统上的软件包：
- en: '[PRE1]'
  id: totrans-106
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'We will be using the desktop version of ROS. We install it with the following
    command:'
  id: totrans-107
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们将使用ROS的桌面版本。我们使用以下命令安装它：
- en: '[PRE2]'
  id: totrans-108
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'As we will be creating our own nodes, we will need the ROS development tools.
    We install these tools with the following command:'
  id: totrans-109
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 由于我们将创建自己的节点，我们需要ROS开发工具。我们使用以下命令安装这些工具：
- en: '[PRE3]'
  id: totrans-110
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE3]'
- en: With ROS and the ROS development tools installed, we are now ready to explore.
    We will start off with a simple publish-subscribe example.
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 在安装了ROS和ROS开发工具后，我们现在可以开始探索了。我们将从一个简单的发布-订阅示例开始。
- en: Testing our ROS installation
  id: totrans-112
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 测试我们的ROS安装
- en: We may test our new ROS installation with different components, regardless of
    the programming languages used to write these components. A common approach to
    this, and the approach we will take, is to use a simple publisher-subscriber model
    where the publisher is written in C++ and the subscriber in Python.
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以使用不同的组件测试我们的新ROS安装，无论这些组件是用什么编程语言编写的。对此的一种常见方法，也是我们将采用的方法，是使用一个简单的发布-订阅模型，其中发布者是用C++编写的，而订阅者是用Python编写的。
- en: 'In Figure 11.10, the nodes shown are part of the ROS desktop installation.
    The figure highlights a **Publisher** node, written in C++, which sends a Hello
    World: message followed by a sequential number to the chatter topic. The **Subscriber**
    node is written in Python and subscribes to the chatter topic:'
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 在图11.10中，显示的节点是ROS桌面安装的一部分。该图突出显示了一个**发布者**节点，用C++编写，它向chatter主题发送一个Hello World:消息，后跟一个顺序号。**订阅者**节点是用Python编写的，并订阅chatter主题：
- en: '![Figure 11.10 – ROS publisher-subscriber using C++ publisher and Python subscriber](img/B21282_11_10.jpg)'
  id: totrans-115
  prefs: []
  type: TYPE_IMG
  zh: '![图11.10 – 使用C++发布者和Python订阅者的ROS发布-订阅](img/B21282_11_10.jpg)'
- en: Figure 11.10 – ROS publisher-subscriber using C++ publisher and Python subscriber
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 图11.10 – 使用C++发布者和Python订阅者的ROS发布-订阅
- en: 'To run the example, we do the following:'
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 要运行示例，我们执行以下操作：
- en: 'In Ubuntu, we open a new Terminal and type in the following command:'
  id: totrans-118
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在Ubuntu中，我们打开一个新的终端并输入以下命令：
- en: '[PRE4]'
  id: totrans-119
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE4]'
- en: We use this command to initialize the ROS environment for the current Terminal
    session, thereby enabling ROS commands and package usage.
  id: totrans-120
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 我们使用此命令初始化当前终端会话的ROS环境，从而启用ROS命令和包的使用。
- en: 'To launch the publisher, we type the following:'
  id: totrans-121
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 要启动发布者，我们输入以下内容：
- en: '[PRE5]'
  id: totrans-122
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE5]'
- en: '![Figure 11.11 – Output from running the talker node](img/B21282_11_11.jpg)'
  id: totrans-123
  prefs: []
  type: TYPE_IMG
  zh: '![图11.11 – 运行talker节点时的输出](img/B21282_11_11.jpg)'
- en: Figure 11.11 – Output from running the talker node
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 图11.11 – 运行talker节点时的输出
- en: We can see from the Terminal that an output of `Hello World:` followed by an
    incrementing number is published by the `talker` node. Although we can’t tell
    from the output, the topic our node is publishing to is the `chatter` topic.
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 从终端中我们可以看到，`talker` 节点发布了一个 `Hello World:` 后跟递增数字的输出。尽管我们无法从输出中得知，但我们节点发布的主题是
    `chatter` 主题。
- en: 'To receive the messages, we open a new Terminal in Ubuntu and launch the Python
    subscriber node with the following commands:'
  id: totrans-126
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 要接收消息，我们在 Ubuntu 中打开一个新的终端并启动以下命令的 Python 订阅节点：
- en: '[PRE6]'
  id: totrans-127
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'With every new Terminal we open, we must source the ROS installation to enable
    ROS commands. We should observe an acknowledgment of the published messages in
    our new Terminal:'
  id: totrans-128
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 每当我们打开一个新的终端时，我们必须源 ROS 安装以启用 ROS 命令。我们应该在我们的新终端中观察到已发布的消息的确认：
- en: '![Figure 11.12 – Receiving messages from the talker node](img/B21282_11_12.jpg)'
  id: totrans-129
  prefs: []
  type: TYPE_IMG
  zh: '![图 11.12 – 从 talker 节点接收消息](img/B21282_11_12.jpg)'
- en: Figure 11.12 – Receiving messages from the talker node
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 图 11.12 – 从 talker 节点接收消息
- en: With this, we have successfully installed and tested our ROS installation. In
    the next section, we will run a simulated robot and control it through MQTT messages.
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 通过这种方式，我们已经成功安装并测试了我们的 ROS 安装。在下一节中，我们将运行一个模拟机器人并通过 MQTT 消息来控制它。
- en: Running and controlling a simulated robot
  id: totrans-132
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 运行和控制模拟机器人
- en: In this section, we explore the use of TurtleSim, a lightweight and user-friendly
    tool within ROS for simulating a robot’s movements and behaviors. TurtleSim serves
    as an excellent educational resource, especially for beginners in ROS, to understand
    basic concepts such as node interactions, message passing, and simple robotic
    commands.
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们探讨使用 TurtleSim，这是一个轻量级且用户友好的工具，在 ROS 中用于模拟机器人的运动和行为。TurtleSim 是一个优秀的教育资源，特别是对于
    ROS 的初学者来说，可以帮助他们理解基本概念，如节点交互、消息传递和简单的机器人命令。
- en: By using TurtleSim, we will learn how to create a ROS node to control a virtual
    robot. We will control the TurtleSim robot with MQTT messages. In the upcoming
    chapters, we will use what we learn here to convert our robot into a physical
    robot we will call A.R.E.S.
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 通过使用 TurtleSim，我们将学习如何创建一个 ROS 节点来控制虚拟机器人。我们将使用 MQTT 消息来控制 TurtleSim 机器人。在接下来的章节中，我们将使用在这里学到的知识将我们的机器人转换为物理机器人，我们将其称为
    A.R.E.S。
- en: We’ll begin by launching a TurtleSim node within Ubuntu and then control it
    using a separate ROS node.
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将首先在 Ubuntu 中启动一个 TurtleSim 节点，然后使用一个单独的 ROS 节点来控制它。
- en: Launching and testing TurtleSim
  id: totrans-136
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 启动和测试 TurtleSim
- en: As mentioned, TurtleSim is designed to help new users familiarize themselves
    with ROS functionalities such as nodes, topics, and services through a simple
    interface. By running TurtleSim, we can simulate a robot’s movement and behavior
    in a controlled environment.
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 如前所述，TurtleSim 设计用于帮助新用户通过简单界面熟悉 ROS 的功能，如节点、主题和服务。通过运行 TurtleSim，我们可以在一个受控环境中模拟机器人的运动和行为。
- en: 'To launch TurtleSim, we do the following:'
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 要启动 TurtleSim，我们执行以下操作：
- en: 'In Ubuntu, we open a new Terminal and type in the following commands:'
  id: totrans-139
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 Ubuntu 中，我们打开一个新的终端并输入以下命令：
- en: '[PRE7]'
  id: totrans-140
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE7]'
- en: '![Figure 11.13 – TurtleSim robot](img/B21282_11_13.jpg)'
  id: totrans-141
  prefs: []
  type: TYPE_IMG
  zh: '![图 11.13 – TurtleSim 机器人](img/B21282_11_13.jpg)'
- en: Figure 11.13 – TurtleSim robot
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 图 11.13 – TurtleSim 机器人
- en: 'To control the turtle, we use another node. To do this, we open another Terminal
    in Ubuntu and execute the following commands:'
  id: totrans-143
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 要控制海龟，我们使用另一个节点。为此，我们在 Ubuntu 中打开另一个终端并执行以下命令：
- en: '[PRE8]'
  id: totrans-144
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE8]'
- en: '![Figure 11.14 – Running the turtle_teleop_key node](img/B21282_11_14.jpg)'
  id: totrans-145
  prefs: []
  type: TYPE_IMG
  zh: '![图 11.14 – 运行 turtle_teleop_key 节点](img/B21282_11_14.jpg)'
- en: Figure 11.14 – Running the turtle_teleop_key node
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 图 11.14 – 运行 turtle_teleop_key 节点
- en: 'We may move our TurtleSim robot simply by holding down the arrow keys on our
    keyboard. We may also rotate our robot using any of the keys listed in the Terminal:'
  id: totrans-147
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们可以通过按住键盘上的箭头键来移动我们的 TurtleSim 机器人。我们还可以使用终端中列出的任何键来旋转我们的机器人：
- en: '![Figure 11.15 – Results of moving the TurtleSim robot](img/B21282_11_15.jpg)'
  id: totrans-148
  prefs: []
  type: TYPE_IMG
  zh: '![图 11.15 – 移动 TurtleSim 机器人的结果](img/B21282_11_15.jpg)'
- en: Figure 11.15 – Results of moving the TurtleSim robot
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 图 11.15 – 移动 TurtleSim 机器人的结果
- en: 'To visualize node and topic connections in ROS, we can use `rqt_graph`, a graphical
    tool that displays how nodes interact. It’s especially helpful for debugging and
    deciphering the network within a ROS system. To launch `rqt_graph`, we enter the
    following commands in a new Ubuntu Terminal:'
  id: totrans-150
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 要在 ROS 中可视化节点和主题连接，我们可以使用 `rqt_graph`，这是一个图形工具，显示节点如何交互。它对于调试和解析 ROS 系统中的网络特别有帮助。要启动
    `rqt_graph`，我们在新的 Ubuntu 终端中输入以下命令：
- en: '[PRE9]'
  id: totrans-151
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE9]'
- en: '![Figure 11.16 – Using the rqt_graph tool in ROS](img/B21282_11_16.jpg)'
  id: totrans-152
  prefs: []
  type: TYPE_IMG
  zh: '![图 11.16 – 在 ROS 中使用 rqt_graph 工具](img/B21282_11_16.jpg)'
- en: Figure 11.16 – Using the rqt_graph tool in ROS
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 图11.16 – 在ROS中使用rqt_graph工具
- en: From our graph, the `cmd_vel` topic is a key communication channel in ROS that
    connects the `teleop_turtle` node, acting as a controller, to the `turtlesim`
    node, which simulates the robot. In our ROS graph, we refer to the TurtleSim instance
    as `turtle1`, and it’s this name we use to identify the specific turtle being
    controlled when interacting with the `cmd_vel` topic. The graph also shows `rotate_absolute`
    actions. For our basic robot control application, we are only interested in `cmd_vel`
    topic communications.
  id: totrans-154
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 从我们的图中，`cmd_vel`主题是ROS中的一个关键通信通道，它将作为控制器的`teleop_turtle`节点与模拟机器人的`turtlesim`节点连接起来。在我们的ROS图中，我们将TurtleSim实例称为`turtle1`，并且我们在与`cmd_vel`主题交互时使用这个名字来识别被控制的特定海龟。图还显示了`rotate_absolute`动作。对于我们的基本机器人控制应用，我们只对`cmd_vel`主题通信感兴趣。
- en: Why do we launch turtle_teleop_key but view teleop_turtle?
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 为什么我们启动turtle_teleop_key但查看teleop_turtle？
- en: The difference between the `teleop_turtle` node name in the `rqt_graph` tool
    and the `ros2 run turtlesim turtle_teleop_key` command stems from the framework’s
    naming conventions and structure. The `turtle_teleop_key` command refers to the
    executable file in ROS that, when run, initializes a ROS node. This node is internally
    named `teleop_turtle` within the ROS environment for communication and identification.
    This approach allows flexibility in ROS, where a single executable can launch
    different nodes, and node names can be dynamically changed for specific needs
    or configurations. The node name is essential for network communication, such
    as publishing to topics, while the executable name is just for starting the node.
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: '`rqt_graph`工具中`teleop_turtle`节点名称与`ros2 run turtlesim turtle_teleop_key`命令之间的区别源于框架的命名约定和结构。《turtle_teleop_key》命令指的是ROS中的可执行文件，当运行时，初始化一个ROS节点。这个节点在ROS环境中内部命名为`teleop_turtle`，用于通信和识别。这种方法允许ROS具有灵活性，其中单个可执行文件可以启动不同的节点，节点名称可以根据特定需求或配置动态更改。节点名称对于网络通信，如发布到主题，是至关重要的，而可执行文件名称只是用于启动节点。'
- en: Our exercise demonstrates how we may control a robot using a node – in this
    case, the `teleop_turtle` node, which allows us to control the TurtleSim robot
    with our keyboard. In the next section, we will create our own node, which will
    allow us to control the robot via MQTT messaging.
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的练习展示了我们如何使用一个节点来控制机器人——在这个例子中，是`teleop_turtle`节点，它允许我们通过键盘控制TurtleSim机器人。在下一节中，我们将创建自己的节点，这将使我们能够通过MQTT消息来控制机器人。
- en: Creating an ROS workspace and package
  id: totrans-158
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 创建ROS工作空间和包
- en: In ROS 2, the structure and creation of packages are critical for organizing,
    distributing, and compiling our code. The creation of a package in ROS 2 involves
    using `ament` as the build system and `colcon` as the build tool. We have the
    option to create packages in either C++ or Python.
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 在ROS 2中，包的结构和创建对于组织、分发和编译我们的代码至关重要。在ROS 2中创建一个包涉及使用`ament`作为构建系统和`colcon`作为构建工具。我们有选择以C++或Python创建包的选项。
- en: The contents of a ROS 2 package vary depending on whether it’s a CMake or Python
    package. Typically, a CMake package includes a `CMakeLists.txt` file and a `package.xml`
    file, along with directories for source code and package headers. A Python package,
    on the other hand, will include `package.xml` and `setup.py` files and a directory
    with the same name as the package containing an `__init__.py` file, among others.
    For our application, we will use Python.
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: ROS 2包的内容取决于它是一个CMake包还是Python包。通常，CMake包包括一个`CMakeLists.txt`文件和一个`package.xml`文件，以及源代码和包头文件的目录。另一方面，Python包将包括`package.xml`和`setup.py`文件，以及一个与包同名且包含`__init__.py`文件等文件的目录。对于我们的应用，我们将使用Python。
- en: We can have multiple packages in a ROS 2 workspace, each in its own folder,
    and these packages can be of different build types. It’s recommended to keep packages
    within the `src` folder of our workspace to maintain organization.
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 在ROS 2工作空间中，我们可以有多个包，每个包都有自己的文件夹，并且这些包可以是不同的构建类型。建议将包保存在我们工作空间的`src`文件夹中，以保持组织。
- en: 'In the following figure, we can see the structure of the ROS workspace we will
    build, with the dot (`.`) representing the root directory of the workspace. The
    workspace is simply a directory in our filesystem. Under the `src` folder, we
    have our single package called `mqtt_robot`:'
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 在以下图中，我们可以看到我们将要构建的ROS工作空间的结构，其中点（`.`）代表工作空间的根目录。工作空间只是我们的文件系统中的一个目录。在`src`文件夹下，我们有一个名为`mqtt_robot`的单个包：
- en: '![Figure 11.17 – ROS workspace structure](img/B21282_11_17.jpg)'
  id: totrans-163
  prefs: []
  type: TYPE_IMG
  zh: '![图11.17 – ROS工作空间结构](img/B21282_11_17.jpg)'
- en: Figure 11.17 – ROS workspace structure
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 图11.17 – ROS工作空间结构
- en: To build our ROS application, we will begin by creating a workspace, a Linux
    directory that includes a `src` subfolder for organizing our application’s ROS
    packages.
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 为了构建我们的ROS应用程序，我们将首先创建一个工作空间，这是一个包含用于组织我们应用程序ROS包的 `src` 子文件夹的Linux目录。
- en: 'To do so, we do the following:'
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 要做到这一点，我们执行以下操作：
- en: 'We open an Ubuntu Terminal and execute the following command in our home directory:'
  id: totrans-167
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们在Ubuntu终端中打开我们的家目录并执行以下命令：
- en: '[PRE10]'
  id: totrans-168
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE10]'
- en: Important note
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 重要提示
- en: Creating our workspace in the home directory simplifies future navigation, as
    we can use the `~` character as a shortcut in our commands.
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 在家目录中创建我们的工作空间简化了未来的导航，因为我们可以在命令中使用 `~` 字符作为快捷方式。
- en: With this command, we create a workspace. The `-p` flag in the `mkdir` command
    ensures that any necessary parent directories are created as part of the new directory
    path.
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 使用此命令，我们创建了一个工作空间。`mkdir` 命令中的 `-p` 标志确保任何必要的父目录作为新目录路径的一部分被创建。
- en: 'With the folder created, we navigate to the `src` folder with the following
    command:'
  id: totrans-172
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建文件夹后，我们使用以下命令导航到 `src` 文件夹：
- en: '[PRE11]'
  id: totrans-173
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'To initialize our ROS environment, we execute the following command:'
  id: totrans-174
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 为了初始化我们的ROS环境，我们执行以下命令：
- en: '[PRE12]'
  id: totrans-175
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'We then create our package by executing the following command:'
  id: totrans-176
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后，我们通过执行以下命令创建我们的包：
- en: '[PRE13]'
  id: totrans-177
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE13]'
- en: In the command we use to build our package, we specify the Apache 2.0 License.
  id: totrans-178
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 在我们构建包的命令中，我们指定了Apache 2.0许可证。
- en: What is the Apache 2.0 License?
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: 什么是Apache 2.0许可证？
- en: This license is an open source license that allows for commercial and non-commercial
    use and modification, with the requirement to disclose major changes in distributed
    versions and the explicit grant of patent rights to users. In our case, this disclosure
    requirement applies only if we were to modify the existing code of the build tools
    or other Apache 2.0 licensed software, not to the new code we write ourselves
    after the package creation.
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: 此许可证是一个开源许可证，允许商业和非商业用途以及修改，但要求在分发版本中披露重大更改，并明确授予用户专利权。在我们的情况下，此披露要求仅适用于我们修改构建工具或Apache
    2.0许可证软件的现有代码，而不是在包创建后我们自己编写的代码。
- en: 'With this line, we created a new package named `mqtt_robot` with the Python
    build type and generated a node named `draw_circle`. To view the new file structure,
    we execute the `tree` command:'
  id: totrans-181
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 通过这一行，我们创建了一个名为 `mqtt_robot` 的新包，具有Python构建类型，并生成了一个名为 `draw_circle` 的节点。要查看新的文件结构，我们执行
    `tree` 命令：
- en: '![Figure 11.18 – Workspace file structure under the src directory](img/B21282_11_18.jpg)'
  id: totrans-182
  prefs: []
  type: TYPE_IMG
  zh: '![图11.18 – src目录下的工作空间文件结构](img/B21282_11_18.jpg)'
- en: Figure 11.18 – Workspace file structure under the src directory
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: 图11.18 – src目录下的工作空间文件结构
- en: With our `ch11_ws` workspace and `mqtt_robot` package created; we are now ready
    to start modifying the generated code for our purposes. We will start with the
    `draw_circle.py` script.
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: 使用我们创建的 `ch11_ws` 工作空间和 `mqtt_robot` 包，我们现在可以开始修改生成的代码以适应我们的需求。我们将从 `draw_circle.py`
    脚本开始。
- en: Modifying the generated Python code
  id: totrans-185
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 修改生成的Python代码
- en: After the code generation of our package, we are presented with a folder called
    `mqtt_robot` under the `src` folder. This folder represents our package. Inside
    is another folder with the same name, `mqtt_robot`. It is in this second `mqtt_robot`
    folder where we find the main Python code for our application.
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的包代码生成后，我们在 `src` 文件夹下看到一个名为 `mqtt_robot` 的文件夹。这个文件夹代表我们的包。在这个文件夹内部还有一个同名的文件夹，`mqtt_robot`。正是在这个第二个
    `mqtt_robot` 文件夹中，我们找到了我们应用程序的主要Python代码。
- en: 'To create the logic for our application, we will modify the `draw_circle.py`
    script. To do so, we do the following:'
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: 为了创建我们应用程序的逻辑，我们将修改 `draw_circle.py` 脚本。为此，我们执行以下操作：
- en: 'For our application, we require the `paho-mqtt` library for MQTT communications.
    In an Ubuntu Terminal, we type the following command to install the library:'
  id: totrans-188
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 对于我们的应用程序，我们需要 `paho-mqtt` 库来进行MQTT通信。在Ubuntu终端中，我们输入以下命令来安装库：
- en: '[PRE14]'
  id: totrans-189
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'draw_circle.py file in a text editor, we execute the following command:'
  id: totrans-190
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 在文本编辑器中打开 `draw_circle.py` 文件，我们执行以下命令：
- en: '[PRE15]'
  id: totrans-191
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE15]'
- en: '[PRE16]'
  id: totrans-192
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'We start by deleting all the code. We then start our new code with imports:'
  id: totrans-193
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们首先删除所有代码。然后，我们以导入开始编写新的代码：
- en: '[PRE17]'
  id: totrans-194
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'In our code, we have the following:'
  id: totrans-195
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 在我们的代码中，我们有以下内容：
- en: '`import rclpy`: Imports the ROS 2 client library for Python, allowing the script
    to interact with ROS 2 functionalities and create ROS 2 nodes.'
  id: totrans-196
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`import rclpy`：导入ROS 2客户端库，允许脚本与ROS 2功能交互并创建ROS 2节点。'
- en: '`from rclpy.node import Node`: Imports the `Node` class from the `rclpy` module,
    enabling the script to define custom nodes for ROS 2 applications.'
  id: totrans-197
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`from rclpy.node import Node`: 从 `rclpy` 模块中导入 `Node` 类，使脚本能够为 ROS 2 应用程序定义自定义节点。'
- en: '`from geometry_msgs.msg import Twist`: Imports the `Twist` message type from
    the `geometry_msgs` package; we use this for sending commands to move the TurtleSim
    robot.'
  id: totrans-198
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`from geometry_msgs.msg import Twist`: 从 `geometry_msgs` 包中导入 `Twist` 消息类型；我们使用它来发送命令以移动
    TurtleSim 机器人。'
- en: '`import paho.mqtt.client as mqtt`: Imports the Paho MQTT client library we
    will use for MQTT protocol communication.'
  id: totrans-199
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`import paho.mqtt.client as mqtt`: 导入我们将用于 MQTT 协议通信的 Paho MQTT 客户端库。'
- en: 'We define an `MQTTMessage` class, which includes an initialization method and
    a method to set a flag. The `__init__()` method initializes the `should_draw_circle`
    attribute as `False`, and the `set_flag()` method updates this attribute to `True`
    when our class receives the `draw_circle` message. We set `should_draw_circle`
    to `False` when a `stop` message is received:'
  id: totrans-200
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们定义了一个 `MQTTMessage` 类，它包括一个初始化方法和一个设置标志的方法。`__init__()` 方法将 `should_draw_circle`
    属性初始化为 `False`，而 `set_flag()` 方法在类接收到 `draw_circle` 消息时将此属性更新为 `True`。当接收到 `stop`
    消息时，我们将 `should_draw_circle` 设置为 `False`：
- en: '[PRE18]'
  id: totrans-201
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'We derive the `CircleMover` class from ROS 2’s `Node` class. This class is
    designed for controlling the movement of a simulated turtle in TurtleSim based
    on MQTT messages. The class initializes with an MQTT message handler, sets up
    a publisher for the `turtle1/cmd_vel` topic to control movement, and configures
    an MQTT client for connecting to a broker and handling incoming messages:'
  id: totrans-202
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们从 ROS 2 的 `Node` 类派生出 `CircleMover` 类。这个类旨在根据 MQTT 消息控制 TurtleSim 中的模拟海龟的运动。该类使用
    MQTT 消息处理程序初始化，设置 `turtle1/cmd_vel` 主题的发布者以控制运动，并配置 MQTT 客户端以连接到代理并处理传入的消息：
- en: '[PRE19]'
  id: totrans-203
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'The `timer_callback()` function inside the class determines the turtle’s movement
    based on the `should_draw_circle` flag set by MQTT messages, enabling dynamic
    control of the turtle through MQTT:'
  id: totrans-204
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 类内部的 `timer_callback()` 函数根据由 MQTT 消息设置的 `should_draw_circle` 标志确定海龟的运动，从而通过
    MQTT 实现对海龟的动态控制：
- en: '[PRE20]'
  id: totrans-205
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'To complete our code, we define a `main()` function for our ROS 2 Python script,
    which initializes the ROS client library, creates an instance of the `MQTTMessage`
    class, and then an instance of the `CircleMover` class using the MQTT message
    handler. It runs the ROS node with the `rclpy.spin()` method, keeping the node
    active and responding to callbacks. Upon termination, it destroys the node and
    shuts down the ROS client library. We use the `main()` function as the entry point
    for our script, executing it when the script is run directly:'
  id: totrans-206
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 为了完成我们的代码，我们为我们的 ROS 2 Python 脚本定义了一个 `main()` 函数，该函数初始化 ROS 客户端库，创建 `MQTTMessage`
    类的一个实例，然后使用 MQTT 消息处理程序创建 `CircleMover` 类的一个实例。它使用 `rclpy.spin()` 方法运行 ROS 节点，保持节点活跃并响应回调。在终止时，它销毁节点并关闭
    ROS 客户端库。我们使用 `main()` 函数作为脚本的入口点，在直接运行脚本时执行它：
- en: '[PRE21]'
  id: totrans-207
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE21]'
- en: With our code completed, we save the file using the same name, `draw_circle.py`.
  id: totrans-208
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 完成我们的代码后，我们使用相同的名称，`draw_circle.py`，保存文件。
- en: Our next step is to update the `package.xml` file to include Python library
    dependencies for our code.
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的下一步是更新 `package.xml` 文件，以包含我们的代码所需的 Python 库依赖项。
- en: Updating package.xml
  id: totrans-210
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 更新 package.xml
- en: The `package.xml` file in ROS is a descriptor that includes essential information
    about a ROS package, such as its name, version, maintainers, licenses, and dependencies.
    Crucial for the build process, it informs the `colcon` build tool about the dependencies
    needed for compiling the package. It is created and maintained by the developer.
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
  zh: ROS 中的 `package.xml` 文件是一个描述符，它包含有关 ROS 包的基本信息，例如其名称、版本、维护者、许可证和依赖项。对于构建过程至关重要，它通知
    `colcon` 构建工具编译包所需的依赖项。它由开发者创建和维护。
- en: For our purposes, we will modify `package.xml` to inform it of the Python libraries
    our code needs to compile.
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
  zh: 对于我们的目的，我们将修改 `package.xml` 以通知它我们的代码需要编译的 Python 库。
- en: 'To do so, we do the following:'
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
  zh: 要做到这一点，我们执行以下操作：
- en: 'We open an Ubuntu Terminal and navigate to the folder containing the `package.xml`
    file:'
  id: totrans-214
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们打开一个 Ubuntu 终端并导航到包含 `package.xml` 文件的文件夹：
- en: '[PRE22]'
  id: totrans-215
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE22]'
- en: '</package>):'
  id: totrans-216
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '</package>):'
- en: '[PRE23]'
  id: totrans-217
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE23]'
- en: '[PRE24]'
  id: totrans-218
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE24]'
- en: These lines indicate to the compiler that `rclpy` (Python client library for
    ROS) and `paho-mqtt` (used for MQTT communications) are execution dependencies
    for the ROS package, meaning these packages are required for running the ROS nodes
    contained in the package. We save our changes and close the editor.
  id: totrans-219
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 这些行指示编译器，`rclpy`（ROS的Python客户端库）和`paho-mqtt`（用于MQTT通信）是ROS包的执行依赖项，这意味着这些包是运行包中包含的ROS节点所必需的。我们保存我们的更改并关闭编辑器。
- en: With updates to `package.xml`, we are now ready to compile our code and run
    our new node.
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
  zh: 通过更新`package.xml`，我们现在可以编译我们的代码并运行我们的新节点。
- en: Compiling and running our code
  id: totrans-221
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 编译和运行我们的代码
- en: To compile our code, we use the `colcon` ROS tool, a command-line tool used
    for compiling ROS packages, handling dependencies, and orchestrating builds across
    multiple packages in the workspace. For our application, we require it to compile
    only one package.
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
  zh: 要编译我们的代码，我们使用`colcon` ROS工具，这是一个用于编译ROS包、处理依赖项并在工作空间中跨多个包协调构建的命令行工具。对于我们的应用程序，我们需要它只编译一个包。
- en: 'To compile and execute our new code, we do the following:'
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
  zh: 要编译和执行我们的新代码，我们执行以下操作：
- en: 'In Ubuntu, we open a new Terminal and source our ROS 2 environment:'
  id: totrans-224
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在Ubuntu中，我们打开一个新的终端并源我们的ROS 2环境：
- en: '[PRE25]'
  id: totrans-225
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'We then navigate to the root of our workspace:'
  id: totrans-226
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后，我们导航到我们的工作空间根目录：
- en: '[PRE26]'
  id: totrans-227
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE26]'
- en: 'To compile our code, we execute the following command:'
  id: totrans-228
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 要编译我们的代码，我们执行以下命令：
- en: '[PRE27]'
  id: totrans-229
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE27]'
- en: Why do we create a package from the src folder but compile from the root?
  id: totrans-230
  prefs: []
  type: TYPE_NORMAL
  zh: 为什么我们从src文件夹创建一个包，但从根目录编译？
- en: 'It’s worth noting that package creation and compilation in a ROS workspace
    occur at different levels. While we create individual packages within the `src`
    folder of a workspace, compilation is done from the workspace’s root folder. This
    distinction is key: creating packages is a localized action within `src`, but
    compiling with `colcon` at the workspace root ensures all packages within `src`
    are built together.'
  id: totrans-231
  prefs: []
  type: TYPE_NORMAL
  zh: 值得注意的是，在ROS工作空间中，包的创建和编译发生在不同的级别。虽然我们在工作空间的`src`文件夹内创建单个包，但编译是在工作空间的根文件夹中进行的。这种区别是关键的：创建包是在`src`中的本地化操作，但使用`colcon`在工作空间根目录编译确保`src`中的所有包一起构建。
- en: Upon completion, a message confirming a successful build will appear in the
    Terminal.
  id: totrans-232
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 完成后，终端将出现一条确认成功构建的消息。
- en: 'With our code compiled, it is time to source our new ROS environment. We do
    this with the following command:'
  id: totrans-233
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们的代码编译完成后，现在是时候源我们的新ROS环境了。我们使用以下命令执行此操作：
- en: '[PRE28]'
  id: totrans-234
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE28]'
- en: 'This is like how we source the ROS environment. To run our node, we execute
    the following command:'
  id: totrans-235
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 这就像我们源ROS环境一样。要运行我们的节点，我们执行以下命令：
- en: '[PRE29]'
  id: totrans-236
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE29]'
- en: If not already running, we launch a TurtleSim instance.
  id: totrans-237
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果尚未运行，我们启动一个TurtleSim实例。
- en: We may notice that nothing is happening. The turtle in TurtleSim is not moving,
    and the Terminal where we launched our node is in a waiting state. To make the
    turtle move, we need to send an MQTT message to our new node.
  id: totrans-238
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可能会注意到没有任何动作发生。TurtleSim中的海龟没有移动，而我们启动节点所用的终端处于等待状态。要使海龟移动，我们需要向我们的新节点发送一个MQTT消息。
- en: Let’s do that now.
  id: totrans-239
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们来做这件事。
- en: Controlling our robot with an MQTT message
  id: totrans-240
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用MQTT消息控制我们的机器人
- en: We see a high-level overview of our application in *Figure 11**.1*, where an
    MQTT message using MQTT-Explorer directs our ROS-simulated robot. The `draw_circle`
    message prompts the turtle to draw a circle, while `stop` halts its movement.
    This forms the foundational basis for our project, which we’ll expand with additional
    features in the upcoming chapters.
  id: totrans-241
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在*图11.1*中看到了我们应用程序的高级概述，其中使用MQTT-Explorer的MQTT消息指导我们的ROS模拟机器人。`draw_circle`消息提示海龟画一个圆圈，而`stop`则停止其移动。这构成了我们项目的基础，我们将在接下来的章节中通过添加更多功能来扩展它。
- en: 'To control the TurtleSim robot from an MQTT message, we do the following:'
  id: totrans-242
  prefs: []
  type: TYPE_NORMAL
  zh: 要通过MQTT消息控制TurtleSim机器人，我们执行以下操作：
- en: Using the MQTT-Explorer app in Windows, we publish a `draw_circle` message to
    the `move` topic.
  id: totrans-243
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在Windows中使用MQTT-Explorer应用程序，我们向`move`主题发布一个`draw_circle`消息。
- en: 'Upon sending, we should observe that our TurtleSim robot starts to move in
    a circle:'
  id: totrans-244
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 发送后，我们应该观察到我们的TurtleSim机器人开始画圈移动：
- en: '![Figure 11.19 – TurtleSim robot moving from MQTT message](img/B21282_11_19.jpg)'
  id: totrans-245
  prefs: []
  type: TYPE_IMG
  zh: '![图11.19 – 从MQTT消息移动的TurtleSim机器人](img/B21282_11_19.jpg)'
- en: Figure 11.19 – TurtleSim robot moving from MQTT message
  id: totrans-246
  prefs: []
  type: TYPE_NORMAL
  zh: 图11.19 – 从MQTT消息移动的TurtleSim机器人
- en: To stop the robot, we send a `stop` message under the `move` topic using the
    MQTT-Explorer app.
  id: totrans-247
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 要停止机器人，我们使用MQTT-Explorer应用程序在`move`主题下发送一个`stop`消息。
- en: We should observe that the TurtleSim robot stops moving.
  id: totrans-248
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们应该观察到TurtleSim机器人停止移动。
- en: Our demonstration of controlling a virtual robot using MQTT messages lays the
    groundwork for applying these learned concepts to our upcoming real robot project,
    A.R.E.S.
  id: totrans-249
  prefs: []
  type: TYPE_NORMAL
  zh: 我们使用MQTT消息控制虚拟机器人的演示为将所学概念应用到即将到来的真实机器人项目A.R.E.S.奠定了基础。
- en: Summary
  id: totrans-250
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: In this chapter, we began our exploration into ROS. We started by setting up
    ROS on a Raspberry Pi 4, going for Ubuntu over the standard Raspberry Pi OS for
    better compatibility with ROS.
  id: totrans-251
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们开始了对ROS的探索。我们首先在Raspberry Pi 4上设置了ROS，选择Ubuntu而不是标准的Raspberry Pi OS，以获得与ROS更好的兼容性。
- en: Our hands-on journey started with TurtleSim, a user-friendly ROS simulator.
    We learned basic ROS operations and concepts, starting with keyboard controls
    to maneuver a virtual robot. We then advanced to using MQTT messages for control,
    bridging the gap between simulation and real-world application.
  id: totrans-252
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的动手之旅从用户友好的ROS模拟器TurtleSim开始。我们学习了基本的ROS操作和概念，从键盘控制来操控虚拟机器人开始。然后我们进阶到使用MQTT消息进行控制，架起了模拟与现实应用之间的桥梁。
- en: This experience with TurtleSim is foundational for our main project, A.R.E.S.,
    an advanced IoT robot that will be developed in the upcoming chapters.
  id: totrans-253
  prefs: []
  type: TYPE_NORMAL
  zh: 在TurtleSim上的这次体验为我们主要项目A.R.E.S.打下了基础，A.R.E.S.是一个将在接下来的章节中开发的先进物联网机器人。
- en: In the next chapter, we will return to building IoT devices as we build an MQTT
    joystick to control our TurtleSim robot.
  id: totrans-254
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章中，我们将回到构建物联网设备，因为我们正在构建一个MQTT游戏手柄来控制我们的TurtleSim机器人。
