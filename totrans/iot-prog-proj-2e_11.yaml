- en: '11'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Introducing ROS
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we introduce the **Robot Operating System** (**ROS**), a powerful
    tool for developing robotics applications. We will explore the significance of
    ROS in the field of robotics and detail the process of setting up ROS on a Raspberry
    Pi 4\. This involves replacing the standard Raspberry Pi OS with Ubuntu, due to
    Ubuntu’s compatibility and optimization for specific versions of ROS.
  prefs: []
  type: TYPE_NORMAL
- en: We will start our hands-on exercises setting up and running **TurtleSim**, a
    user-friendly ROS simulator. We will do this to gain knowledge of basic ROS concepts
    and operations. Starting with simple keyboard controls, we will learn how to command
    and maneuver a virtual robot within the simulator environment. We will follow
    this up by progressing to controlling the TurtleSim simulator with **Message Queuing
    Telemetry Transport** (**MQTT**) messages as we start to bridge the gap between
    simulation and real-world application.
  prefs: []
  type: TYPE_NORMAL
- en: Building on the skills developed through working with TurtleSim will prepare
    us for constructing our advanced IoT robot named A.R.E.S. (short for Advanced
    Robot Eyes for Security). A.R.E.S. is the final and most sophisticated project
    of the book and will comprise the remaining chapters.
  prefs: []
  type: TYPE_NORMAL
- en: 'We will cover the following topics in this chapter:'
  prefs: []
  type: TYPE_NORMAL
- en: Exploring ROS
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Installing Ubuntu and ROS onto our Raspberry Pi
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Running and controlling a simulated robot
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Let’s begin!
  prefs: []
  type: TYPE_NORMAL
- en: Technical requirements
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The following are the requirements for completing this chapter:'
  prefs: []
  type: TYPE_NORMAL
- en: Intermediate knowledge of Python programming
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Basic knowledge of the Linux command line
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A CloudAMQP account for the MQTT server instance
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Late-model Raspberry Pi 4 or any computer capable of installing Ubuntu (Ubuntu
    installed on a Mac mini was used in this chapter)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: microSD card and microSD – USB adapter
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The code for this chapter may be found here:'
  prefs: []
  type: TYPE_NORMAL
- en: '[https://github.com/PacktPublishing/-Internet-of-Things-Programming-Projects-2nd-Edition/tree/main/Chapter11](https://github.com/PacktPublishing/Internet-of-Things-Programming-Projects-2nd-Edition/tree/main/Chapter11)'
  prefs: []
  type: TYPE_NORMAL
- en: Exploring ROS
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this section, we will explore the basics of ROS. This section is by no means
    an in-depth replacement for the excellent documentation that may be found on the
    ROS website at [www.ros.org](https://www.ros.org/).
  prefs: []
  type: TYPE_NORMAL
- en: ROS is an **Open Source Software** (**OSS**) development kit for robotics applications,
    providing a standard platform that bridges the gap between research and production.
    Designed to speed up the robotics development process, ROS simplifies the creation
    of robotic systems. It is 100% open source and commercially friendly.
  prefs: []
  type: TYPE_NORMAL
- en: 'Our goal here is to establish a common knowledge base, equipping us with the
    essential concepts and tools of ROS needed for this chapter’s project and, eventually,
    our A.R.E.S. robot. We will start by outlining the main project of this chapter:
    the control of the ROS TurtleSim virtual robot using MQTT messaging.'
  prefs: []
  type: TYPE_NORMAL
- en: Reviewing our TurtleSim controller ROS application
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: TurtleSim is a lightweight robot simulator provided by ROS and is primarily
    used as an educational tool for learning ROS concepts. It offers a simple interface
    for teaching the basics of ROS, allowing users to experiment with commands and
    observe the behavior of a simulated robot in a safe and controlled environment.
  prefs: []
  type: TYPE_NORMAL
- en: For the main project in this chapter, we will control a TurtleSim instance with
    MQTT messages as we command the robot to draw a circle or stop moving based on
    the message we transmit to the `move` topic of our MQTT instance.
  prefs: []
  type: TYPE_NORMAL
- en: 'In *Figure 11**.1*, we see our application illustrated. Messages created using
    the MQTT-Explorer in Windows are sent to the `circle` node we create in ROS. Based
    on the message, either `draw_circle` or `stop`, we send a `cmd_vel` topic ROS
    message to a TurtleSim instance. This internal messaging uses publishers and subscribers
    and is like the way MQTT communication is performed:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 11.1 – Using MQTT messages to control a simulated robot](img/B21282_11_1.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 11.1 – Using MQTT messages to control a simulated robot
  prefs: []
  type: TYPE_NORMAL
- en: For the application in this chapter, we will be sending messages directly using
    the MQTT-Explorer app. In the next chapter, we will build an IoT joystick with
    a Raspberry Pi Pico W and use it to control the simulated robot.
  prefs: []
  type: TYPE_NORMAL
- en: Now that we’ve outlined our chapter’s goals, let’s step back to gain a basic
    understanding of ROS concepts. This overview will provide us with a fundamental
    insight into its architecture and role in robotics.
  prefs: []
  type: TYPE_NORMAL
- en: Understanding ROS node communication
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: ROS supports a wide range of applications and platforms, including Linux, Windows,
    macOS, and embedded systems, making it highly versatile. Its modular framework
    is based on the concepts of nodes, topics, services, and actions. Nodes in ROS
    are individual processes that perform specific computations, and topics serve
    as communication channels where nodes exchange messages using a publisher-subscriber
    mechanism.
  prefs: []
  type: TYPE_NORMAL
- en: 'For our application, we will be using a topic and publisher-subscriber model
    to send `vel_msg` messages of the `cmd_vel` topic from our custom `circle` node
    to an instance of a TurtleSim virtual robot. Although a publisher may have many
    subscribers, we will only be using one instance of TurtleSim to subscribe to the
    publisher we will build in our custom node. We see this illustrated in the following
    diagram:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 11.2 – A view of the publisher-subscriber model inside ROS](img/B21282_11_2.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 11.2 – A view of the publisher-subscriber model inside ROS
  prefs: []
  type: TYPE_NORMAL
- en: Services in ROS offer a way for nodes to perform request-response interactions,
    useful for tasks that require immediate feedback. Actions provide a means for
    executing long-running tasks that require continuous feedback and the possibility
    of cancellation. We will not be using services or actions for our application.
  prefs: []
  type: TYPE_NORMAL
- en: Now that we have a little understanding of ROS node communication, let’s look
    at the project structure in ROS.
  prefs: []
  type: TYPE_NORMAL
- en: Investigating ROS project structure and organization
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The structure of a ROS project is organized for the efficient development and
    management of robotics applications. At its core, a ROS project is built around
    the concept of packages and workspaces, which are essential for organizing the
    various components of a robotics project. The following list summarizes the key
    concepts for a ROS project:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Packages and workspaces**: A ROS workspace is a directory (or a folder) where
    ROS packages are developed and compiled. Each package, typically a directory within
    the workspace, represents a specific functionality or component of the robot,
    such as sensors, actuators, algorithms, or even a collection of related nodes.
    Packages can contain ROS nodes, libraries, datasets, configuration files, or anything
    that constitutes an independent and reusable module.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**ROS nodes and communication**: Within these packages, the primary executable
    units are the nodes. Each node is designed to perform a specific task, such as
    controlling a motor, processing sensor data, or performing computations. Nodes
    communicate with each other over topics, services, or actions. Topics allow for
    asynchronous, publish-subscribe communication, ideal for streaming data such as
    sensor readings or control commands. Services provide synchronous, request-response
    interaction, useful for tasks that need immediate feedback. Actions are suited
    for long-running tasks that require continuous feedback and the possibility of
    cancellation. As mentioned, we will be creating a custom node to communicate with
    the TurtleSim simulator using topics and the publish-subscribe method.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`catkin` in ROS 1 or `colcon` in ROS 2) to compile and manage packages. The
    build system handles dependencies and integrates packages into the ROS ecosystem.
    We will be using `colcon` to compile our project.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`ros2` `run` command.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: We will construct our workspaces, build our packages, and execute our program
    directly from the command line. Before we do this, let’s explore how ROS distributions
    align with Ubuntu versions.
  prefs: []
  type: TYPE_NORMAL
- en: Aligning ROS distributions with Ubuntu LTS versions
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Each ROS distribution is paired with a designated Ubuntu **Long-Term Support**
    (**LTS**) version, a strategy that guarantees stability and compatibility as it
    gives ROS developers a consistent code base to work with.
  prefs: []
  type: TYPE_NORMAL
- en: 'The ROS release policy is clear: one Ubuntu LTS version per ROS release, with
    no new Ubuntu version support after the release. To take advantage of this pairing
    of Ubuntu with ROS, we will install Ubuntu 22.04 and the Humble Hawksbill version
    of ROS 2 onto our Raspberry Pi 4 (for those of us who wish to run Ubuntu on a
    computer other than a Raspberry Pi, we may skip the next section).'
  prefs: []
  type: TYPE_NORMAL
- en: We will start by flashing Ubuntu onto a microSD card using the Raspberry Pi
    Imager.
  prefs: []
  type: TYPE_NORMAL
- en: Installing Ubuntu and ROS onto our Raspberry Pi
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this section, we will walk through the steps of installing Ubuntu 22.04 and
    ROS Humble Hawksbill on our Raspberry Pi 4\. This involves choosing the correct
    Ubuntu image, flashing it onto a microSD card using the Raspberry Pi Imager, and
    setting up the Raspberry Pi to boot with Ubuntu.
  prefs: []
  type: TYPE_NORMAL
- en: Why are we using a Raspberry Pi 4 and not a Raspberry Pi 5?
  prefs: []
  type: TYPE_NORMAL
- en: At the time of writing, the Raspberry Pi 5 does not support Ubuntu 22.04 and
    thus the latest version of ROS.
  prefs: []
  type: TYPE_NORMAL
- en: We will start by launching the Raspberry Pi Imager on a computer of our choice.
  prefs: []
  type: TYPE_NORMAL
- en: Installing Ubuntu on our Raspberry Pi 4
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: To install Ubuntu onto our Raspberry Pi 4, we will use the Raspberry Pi Imager
    to burn the operating system onto a microSD card, which we will install on our
    Pi. The Raspberry Pi Imager is a tool created by the Raspberry Pi Foundation and
    is used to simplify the process of imaging microSD cards with the Raspberry Pi
    operating system and other compatible systems.
  prefs: []
  type: TYPE_NORMAL
- en: The Raspberry Pi Imager is available for Windows, macOS, and Linux and may even
    be installed on the Raspberry Pi itself.
  prefs: []
  type: TYPE_NORMAL
- en: Using the Raspberry Pi Imager on a Raspberry Pi
  prefs: []
  type: TYPE_NORMAL
- en: We may use the Raspberry Pi Imager on our Raspberry Pi to burn an image onto
    a microSD card. The process involves using an SD card reader connected to the
    Raspberry Pi’s USB port. We may install the imager from a Terminal in the Raspberry
    Pi OS with the `sudo apt install` `rpi-imager` command.
  prefs: []
  type: TYPE_NORMAL
- en: 'To burn Ubuntu onto a microSD card for use with a Raspberry Pi, we do the following:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Using an internet browser, we navigate to the following website to download
    the Raspberry Pi Imager:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[https://www.raspberrypi.com/software/](https://www.raspberrypi.com/software/)'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'To begin the imaging process, we insert a microSD card into a USB microSD adapter
    and then connect the adapter to a USB port on our computer:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![Figure 11.3 – A USB microSD adapter with microSD card inserted](img/B21282_11_3.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 11.3 – A USB microSD adapter with microSD card inserted
  prefs: []
  type: TYPE_NORMAL
- en: 'Next, we install the Raspberry Pi Imager software on our computer. Once installed,
    launching the imager will bring up its main screen, ready for us to select an
    operating system image and the target microSD card for the installation:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![Figure 11.4 – Raspberry Pi Imager](img/B21282_11_4.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 11.4 – Raspberry Pi Imager
  prefs: []
  type: TYPE_NORMAL
- en: Under **Raspberry Pi Device**, we select **NO FILTERING**.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: For **Operating System**, we select **Other General Purpose OS**, then **Ubuntu**,
    then **Ubuntu Desktop 22.04.3** **LTS (64-BIT)**.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: We then click on the **CHOOSE STORAGE** button and select the microSD card we
    inserted into our computer.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Our selections should look like the following:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![Figure 11.5 – Raspberry Pi Imager after selections](img/B21282_11_5.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 11.5 – Raspberry Pi Imager after selections
  prefs: []
  type: TYPE_NORMAL
- en: Selecting the correct version of Ubuntu
  prefs: []
  type: TYPE_NORMAL
- en: At the time of writing, the latest version of ROS 2 supports Ubuntu 22.04\.
    Therefore, in our example, we will use Ubuntu 22.04 LTS, even though the most
    recent version of Ubuntu is 23.10\. For future iterations of ROS 2, it’s important
    to select the version of Ubuntu that corresponds with the ROS 2 release in use.
  prefs: []
  type: TYPE_NORMAL
- en: To start the burning process, we click on the **NEXT** button and click on the
    **Yes** button on the **Warning** dialog to continue.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Once the writing process is complete, the Raspberry Pi Imager will perform a
    verification to ensure the image has been correctly written to the microSD card.
    Upon successful verification, we should see a **Write Successful** screen, indicating
    that the microSD card is now ready to be used in our Raspberry Pi with the newly
    installed operating system.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: With the image burned onto our microSD card, we then proceed to install the
    card onto our Raspberry Pi and follow the steps to complete the installation of
    Ubuntu onto the Raspberry Pi.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: With Ubuntu now running on our Raspberry Pi, the next step is to install the
    appropriate version of ROS. Despite its name, ROS isn’t an operating system. Instead,
    it functions as a middleware or software framework, providing tools and libraries
    for building and managing robotic applications.
  prefs: []
  type: TYPE_NORMAL
- en: Adding ROS to our Ubuntu installation
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Recapping our *Exploring ROS* section, we emphasized the importance of matching
    each ROS distribution with a specific Ubuntu LTS version to ensure stability.
    Having installed Ubuntu 22.04 on our Raspberry Pi, we’re now ready to install
    ROS.
  prefs: []
  type: TYPE_NORMAL
- en: 'As of this writing, there are two ROS versions compatible with Ubuntu 22.04:
    Humble Hawksbill and Iron Irwini. Humble Hawksbill is an LTS version, meaning
    it’s designed for stability and extended support, ideal for longer-term projects
    and those seeking a stable development environment. Iron Irwini, on the other
    hand, is a non-LTS version, typically featuring more cutting-edge changes but
    with a shorter support life cycle.'
  prefs: []
  type: TYPE_NORMAL
- en: We will use Humble Hawksbill for our application as we desire stability over
    new features for what we are doing.
  prefs: []
  type: TYPE_NORMAL
- en: Important note
  prefs: []
  type: TYPE_NORMAL
- en: The ROS installation instructions provided here are current as of the time of
    writing. However, it’s recommended to consult the official web page for the most
    up-to-date guidance, as there may be updates or changes.
  prefs: []
  type: TYPE_NORMAL
- en: 'To install Humble Hawksbill on our Raspberry Pi, we do the following:'
  prefs: []
  type: TYPE_NORMAL
- en: 'To view the latest versions of ROS, we navigate to the following website:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[https://www.ros.org/blog/getting-started/](https://www.ros.org/blog/getting-started/)'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'To view the current versions of ROS, we scroll down to the **Installation**
    section of the page where we see the following:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![Figure 11.6 – Current versions of ROS](img/B21282_11_6.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 11.6 – Current versions of ROS
  prefs: []
  type: TYPE_NORMAL
- en: To proceed, we click on the **Install** link under the **Humble** **Hawksbill**
    section.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: This will bring us to the Humble Hawksbill installation page.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'To install Humble Hawksbill for Ubuntu, we click on the **Debian packages**
    link (highlighted with a red box in the following figure) under **Ubuntu Linux
    – Jammy** **Jellyfish (22.04)**:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![Figure 11.7 – Binary packages for ROS](img/B21282_11_7.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 11.7 – Binary packages for ROS
  prefs: []
  type: TYPE_NORMAL
- en: 'To set the locale in Ubuntu, we simply copy the commands from the **Set locale**
    section of the web page. This can be done quickly by clicking the **Copy** icon
    on the top right of the code box, which appears when we hover over it. We then
    paste and execute these commands into the Ubuntu Terminal to complete the locale
    setting process:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![Figure 11.8 – Setting the locale in Ubuntu](img/B21282_11_8.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 11.8 – Setting the locale in Ubuntu
  prefs: []
  type: TYPE_NORMAL
- en: 'To configure our system to access and authenticate the ROS software repository,
    we copy, paste, and execute the code from each section under the **Setup** **Sources**
    section:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![Figure 11.9 – Configuring our Ubuntu installation for access to the ROS software
    repository](img/B21282_11_9.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 11.9 – Configuring our Ubuntu installation for access to the ROS software
    repository
  prefs: []
  type: TYPE_NORMAL
- en: 'To update our system’s packages, we type the following command into the Terminal:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'We then upgrade the packages on our system with the following command:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'We will be using the desktop version of ROS. We install it with the following
    command:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'As we will be creating our own nodes, we will need the ROS development tools.
    We install these tools with the following command:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: With ROS and the ROS development tools installed, we are now ready to explore.
    We will start off with a simple publish-subscribe example.
  prefs: []
  type: TYPE_NORMAL
- en: Testing our ROS installation
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: We may test our new ROS installation with different components, regardless of
    the programming languages used to write these components. A common approach to
    this, and the approach we will take, is to use a simple publisher-subscriber model
    where the publisher is written in C++ and the subscriber in Python.
  prefs: []
  type: TYPE_NORMAL
- en: 'In Figure 11.10, the nodes shown are part of the ROS desktop installation.
    The figure highlights a **Publisher** node, written in C++, which sends a Hello
    World: message followed by a sequential number to the chatter topic. The **Subscriber**
    node is written in Python and subscribes to the chatter topic:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 11.10 – ROS publisher-subscriber using C++ publisher and Python subscriber](img/B21282_11_10.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 11.10 – ROS publisher-subscriber using C++ publisher and Python subscriber
  prefs: []
  type: TYPE_NORMAL
- en: 'To run the example, we do the following:'
  prefs: []
  type: TYPE_NORMAL
- en: 'In Ubuntu, we open a new Terminal and type in the following command:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: We use this command to initialize the ROS environment for the current Terminal
    session, thereby enabling ROS commands and package usage.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'To launch the publisher, we type the following:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '![Figure 11.11 – Output from running the talker node](img/B21282_11_11.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 11.11 – Output from running the talker node
  prefs: []
  type: TYPE_NORMAL
- en: We can see from the Terminal that an output of `Hello World:` followed by an
    incrementing number is published by the `talker` node. Although we can’t tell
    from the output, the topic our node is publishing to is the `chatter` topic.
  prefs: []
  type: TYPE_NORMAL
- en: 'To receive the messages, we open a new Terminal in Ubuntu and launch the Python
    subscriber node with the following commands:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'With every new Terminal we open, we must source the ROS installation to enable
    ROS commands. We should observe an acknowledgment of the published messages in
    our new Terminal:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '![Figure 11.12 – Receiving messages from the talker node](img/B21282_11_12.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 11.12 – Receiving messages from the talker node
  prefs: []
  type: TYPE_NORMAL
- en: With this, we have successfully installed and tested our ROS installation. In
    the next section, we will run a simulated robot and control it through MQTT messages.
  prefs: []
  type: TYPE_NORMAL
- en: Running and controlling a simulated robot
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this section, we explore the use of TurtleSim, a lightweight and user-friendly
    tool within ROS for simulating a robot’s movements and behaviors. TurtleSim serves
    as an excellent educational resource, especially for beginners in ROS, to understand
    basic concepts such as node interactions, message passing, and simple robotic
    commands.
  prefs: []
  type: TYPE_NORMAL
- en: By using TurtleSim, we will learn how to create a ROS node to control a virtual
    robot. We will control the TurtleSim robot with MQTT messages. In the upcoming
    chapters, we will use what we learn here to convert our robot into a physical
    robot we will call A.R.E.S.
  prefs: []
  type: TYPE_NORMAL
- en: We’ll begin by launching a TurtleSim node within Ubuntu and then control it
    using a separate ROS node.
  prefs: []
  type: TYPE_NORMAL
- en: Launching and testing TurtleSim
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: As mentioned, TurtleSim is designed to help new users familiarize themselves
    with ROS functionalities such as nodes, topics, and services through a simple
    interface. By running TurtleSim, we can simulate a robot’s movement and behavior
    in a controlled environment.
  prefs: []
  type: TYPE_NORMAL
- en: 'To launch TurtleSim, we do the following:'
  prefs: []
  type: TYPE_NORMAL
- en: 'In Ubuntu, we open a new Terminal and type in the following commands:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '![Figure 11.13 – TurtleSim robot](img/B21282_11_13.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 11.13 – TurtleSim robot
  prefs: []
  type: TYPE_NORMAL
- en: 'To control the turtle, we use another node. To do this, we open another Terminal
    in Ubuntu and execute the following commands:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '![Figure 11.14 – Running the turtle_teleop_key node](img/B21282_11_14.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 11.14 – Running the turtle_teleop_key node
  prefs: []
  type: TYPE_NORMAL
- en: 'We may move our TurtleSim robot simply by holding down the arrow keys on our
    keyboard. We may also rotate our robot using any of the keys listed in the Terminal:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![Figure 11.15 – Results of moving the TurtleSim robot](img/B21282_11_15.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 11.15 – Results of moving the TurtleSim robot
  prefs: []
  type: TYPE_NORMAL
- en: 'To visualize node and topic connections in ROS, we can use `rqt_graph`, a graphical
    tool that displays how nodes interact. It’s especially helpful for debugging and
    deciphering the network within a ROS system. To launch `rqt_graph`, we enter the
    following commands in a new Ubuntu Terminal:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '![Figure 11.16 – Using the rqt_graph tool in ROS](img/B21282_11_16.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 11.16 – Using the rqt_graph tool in ROS
  prefs: []
  type: TYPE_NORMAL
- en: From our graph, the `cmd_vel` topic is a key communication channel in ROS that
    connects the `teleop_turtle` node, acting as a controller, to the `turtlesim`
    node, which simulates the robot. In our ROS graph, we refer to the TurtleSim instance
    as `turtle1`, and it’s this name we use to identify the specific turtle being
    controlled when interacting with the `cmd_vel` topic. The graph also shows `rotate_absolute`
    actions. For our basic robot control application, we are only interested in `cmd_vel`
    topic communications.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Why do we launch turtle_teleop_key but view teleop_turtle?
  prefs: []
  type: TYPE_NORMAL
- en: The difference between the `teleop_turtle` node name in the `rqt_graph` tool
    and the `ros2 run turtlesim turtle_teleop_key` command stems from the framework’s
    naming conventions and structure. The `turtle_teleop_key` command refers to the
    executable file in ROS that, when run, initializes a ROS node. This node is internally
    named `teleop_turtle` within the ROS environment for communication and identification.
    This approach allows flexibility in ROS, where a single executable can launch
    different nodes, and node names can be dynamically changed for specific needs
    or configurations. The node name is essential for network communication, such
    as publishing to topics, while the executable name is just for starting the node.
  prefs: []
  type: TYPE_NORMAL
- en: Our exercise demonstrates how we may control a robot using a node – in this
    case, the `teleop_turtle` node, which allows us to control the TurtleSim robot
    with our keyboard. In the next section, we will create our own node, which will
    allow us to control the robot via MQTT messaging.
  prefs: []
  type: TYPE_NORMAL
- en: Creating an ROS workspace and package
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In ROS 2, the structure and creation of packages are critical for organizing,
    distributing, and compiling our code. The creation of a package in ROS 2 involves
    using `ament` as the build system and `colcon` as the build tool. We have the
    option to create packages in either C++ or Python.
  prefs: []
  type: TYPE_NORMAL
- en: The contents of a ROS 2 package vary depending on whether it’s a CMake or Python
    package. Typically, a CMake package includes a `CMakeLists.txt` file and a `package.xml`
    file, along with directories for source code and package headers. A Python package,
    on the other hand, will include `package.xml` and `setup.py` files and a directory
    with the same name as the package containing an `__init__.py` file, among others.
    For our application, we will use Python.
  prefs: []
  type: TYPE_NORMAL
- en: We can have multiple packages in a ROS 2 workspace, each in its own folder,
    and these packages can be of different build types. It’s recommended to keep packages
    within the `src` folder of our workspace to maintain organization.
  prefs: []
  type: TYPE_NORMAL
- en: 'In the following figure, we can see the structure of the ROS workspace we will
    build, with the dot (`.`) representing the root directory of the workspace. The
    workspace is simply a directory in our filesystem. Under the `src` folder, we
    have our single package called `mqtt_robot`:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 11.17 – ROS workspace structure](img/B21282_11_17.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 11.17 – ROS workspace structure
  prefs: []
  type: TYPE_NORMAL
- en: To build our ROS application, we will begin by creating a workspace, a Linux
    directory that includes a `src` subfolder for organizing our application’s ROS
    packages.
  prefs: []
  type: TYPE_NORMAL
- en: 'To do so, we do the following:'
  prefs: []
  type: TYPE_NORMAL
- en: 'We open an Ubuntu Terminal and execute the following command in our home directory:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Important note
  prefs: []
  type: TYPE_NORMAL
- en: Creating our workspace in the home directory simplifies future navigation, as
    we can use the `~` character as a shortcut in our commands.
  prefs: []
  type: TYPE_NORMAL
- en: With this command, we create a workspace. The `-p` flag in the `mkdir` command
    ensures that any necessary parent directories are created as part of the new directory
    path.
  prefs: []
  type: TYPE_NORMAL
- en: 'With the folder created, we navigate to the `src` folder with the following
    command:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'To initialize our ROS environment, we execute the following command:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'We then create our package by executing the following command:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: In the command we use to build our package, we specify the Apache 2.0 License.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: What is the Apache 2.0 License?
  prefs: []
  type: TYPE_NORMAL
- en: This license is an open source license that allows for commercial and non-commercial
    use and modification, with the requirement to disclose major changes in distributed
    versions and the explicit grant of patent rights to users. In our case, this disclosure
    requirement applies only if we were to modify the existing code of the build tools
    or other Apache 2.0 licensed software, not to the new code we write ourselves
    after the package creation.
  prefs: []
  type: TYPE_NORMAL
- en: 'With this line, we created a new package named `mqtt_robot` with the Python
    build type and generated a node named `draw_circle`. To view the new file structure,
    we execute the `tree` command:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![Figure 11.18 – Workspace file structure under the src directory](img/B21282_11_18.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 11.18 – Workspace file structure under the src directory
  prefs: []
  type: TYPE_NORMAL
- en: With our `ch11_ws` workspace and `mqtt_robot` package created; we are now ready
    to start modifying the generated code for our purposes. We will start with the
    `draw_circle.py` script.
  prefs: []
  type: TYPE_NORMAL
- en: Modifying the generated Python code
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: After the code generation of our package, we are presented with a folder called
    `mqtt_robot` under the `src` folder. This folder represents our package. Inside
    is another folder with the same name, `mqtt_robot`. It is in this second `mqtt_robot`
    folder where we find the main Python code for our application.
  prefs: []
  type: TYPE_NORMAL
- en: 'To create the logic for our application, we will modify the `draw_circle.py`
    script. To do so, we do the following:'
  prefs: []
  type: TYPE_NORMAL
- en: 'For our application, we require the `paho-mqtt` library for MQTT communications.
    In an Ubuntu Terminal, we type the following command to install the library:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'draw_circle.py file in a text editor, we execute the following command:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE16]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'We start by deleting all the code. We then start our new code with imports:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'In our code, we have the following:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '`import rclpy`: Imports the ROS 2 client library for Python, allowing the script
    to interact with ROS 2 functionalities and create ROS 2 nodes.'
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: '`from rclpy.node import Node`: Imports the `Node` class from the `rclpy` module,
    enabling the script to define custom nodes for ROS 2 applications.'
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: '`from geometry_msgs.msg import Twist`: Imports the `Twist` message type from
    the `geometry_msgs` package; we use this for sending commands to move the TurtleSim
    robot.'
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: '`import paho.mqtt.client as mqtt`: Imports the Paho MQTT client library we
    will use for MQTT protocol communication.'
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: 'We define an `MQTTMessage` class, which includes an initialization method and
    a method to set a flag. The `__init__()` method initializes the `should_draw_circle`
    attribute as `False`, and the `set_flag()` method updates this attribute to `True`
    when our class receives the `draw_circle` message. We set `should_draw_circle`
    to `False` when a `stop` message is received:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'We derive the `CircleMover` class from ROS 2’s `Node` class. This class is
    designed for controlling the movement of a simulated turtle in TurtleSim based
    on MQTT messages. The class initializes with an MQTT message handler, sets up
    a publisher for the `turtle1/cmd_vel` topic to control movement, and configures
    an MQTT client for connecting to a broker and handling incoming messages:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'The `timer_callback()` function inside the class determines the turtle’s movement
    based on the `should_draw_circle` flag set by MQTT messages, enabling dynamic
    control of the turtle through MQTT:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'To complete our code, we define a `main()` function for our ROS 2 Python script,
    which initializes the ROS client library, creates an instance of the `MQTTMessage`
    class, and then an instance of the `CircleMover` class using the MQTT message
    handler. It runs the ROS node with the `rclpy.spin()` method, keeping the node
    active and responding to callbacks. Upon termination, it destroys the node and
    shuts down the ROS client library. We use the `main()` function as the entry point
    for our script, executing it when the script is run directly:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: With our code completed, we save the file using the same name, `draw_circle.py`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Our next step is to update the `package.xml` file to include Python library
    dependencies for our code.
  prefs: []
  type: TYPE_NORMAL
- en: Updating package.xml
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The `package.xml` file in ROS is a descriptor that includes essential information
    about a ROS package, such as its name, version, maintainers, licenses, and dependencies.
    Crucial for the build process, it informs the `colcon` build tool about the dependencies
    needed for compiling the package. It is created and maintained by the developer.
  prefs: []
  type: TYPE_NORMAL
- en: For our purposes, we will modify `package.xml` to inform it of the Python libraries
    our code needs to compile.
  prefs: []
  type: TYPE_NORMAL
- en: 'To do so, we do the following:'
  prefs: []
  type: TYPE_NORMAL
- en: 'We open an Ubuntu Terminal and navigate to the folder containing the `package.xml`
    file:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '</package>):'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE24]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: These lines indicate to the compiler that `rclpy` (Python client library for
    ROS) and `paho-mqtt` (used for MQTT communications) are execution dependencies
    for the ROS package, meaning these packages are required for running the ROS nodes
    contained in the package. We save our changes and close the editor.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: With updates to `package.xml`, we are now ready to compile our code and run
    our new node.
  prefs: []
  type: TYPE_NORMAL
- en: Compiling and running our code
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: To compile our code, we use the `colcon` ROS tool, a command-line tool used
    for compiling ROS packages, handling dependencies, and orchestrating builds across
    multiple packages in the workspace. For our application, we require it to compile
    only one package.
  prefs: []
  type: TYPE_NORMAL
- en: 'To compile and execute our new code, we do the following:'
  prefs: []
  type: TYPE_NORMAL
- en: 'In Ubuntu, we open a new Terminal and source our ROS 2 environment:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'We then navigate to the root of our workspace:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'To compile our code, we execute the following command:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Why do we create a package from the src folder but compile from the root?
  prefs: []
  type: TYPE_NORMAL
- en: 'It’s worth noting that package creation and compilation in a ROS workspace
    occur at different levels. While we create individual packages within the `src`
    folder of a workspace, compilation is done from the workspace’s root folder. This
    distinction is key: creating packages is a localized action within `src`, but
    compiling with `colcon` at the workspace root ensures all packages within `src`
    are built together.'
  prefs: []
  type: TYPE_NORMAL
- en: Upon completion, a message confirming a successful build will appear in the
    Terminal.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'With our code compiled, it is time to source our new ROS environment. We do
    this with the following command:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'This is like how we source the ROS environment. To run our node, we execute
    the following command:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: If not already running, we launch a TurtleSim instance.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: We may notice that nothing is happening. The turtle in TurtleSim is not moving,
    and the Terminal where we launched our node is in a waiting state. To make the
    turtle move, we need to send an MQTT message to our new node.
  prefs: []
  type: TYPE_NORMAL
- en: Let’s do that now.
  prefs: []
  type: TYPE_NORMAL
- en: Controlling our robot with an MQTT message
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: We see a high-level overview of our application in *Figure 11**.1*, where an
    MQTT message using MQTT-Explorer directs our ROS-simulated robot. The `draw_circle`
    message prompts the turtle to draw a circle, while `stop` halts its movement.
    This forms the foundational basis for our project, which we’ll expand with additional
    features in the upcoming chapters.
  prefs: []
  type: TYPE_NORMAL
- en: 'To control the TurtleSim robot from an MQTT message, we do the following:'
  prefs: []
  type: TYPE_NORMAL
- en: Using the MQTT-Explorer app in Windows, we publish a `draw_circle` message to
    the `move` topic.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Upon sending, we should observe that our TurtleSim robot starts to move in
    a circle:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![Figure 11.19 – TurtleSim robot moving from MQTT message](img/B21282_11_19.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 11.19 – TurtleSim robot moving from MQTT message
  prefs: []
  type: TYPE_NORMAL
- en: To stop the robot, we send a `stop` message under the `move` topic using the
    MQTT-Explorer app.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: We should observe that the TurtleSim robot stops moving.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Our demonstration of controlling a virtual robot using MQTT messages lays the
    groundwork for applying these learned concepts to our upcoming real robot project,
    A.R.E.S.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we began our exploration into ROS. We started by setting up
    ROS on a Raspberry Pi 4, going for Ubuntu over the standard Raspberry Pi OS for
    better compatibility with ROS.
  prefs: []
  type: TYPE_NORMAL
- en: Our hands-on journey started with TurtleSim, a user-friendly ROS simulator.
    We learned basic ROS operations and concepts, starting with keyboard controls
    to maneuver a virtual robot. We then advanced to using MQTT messages for control,
    bridging the gap between simulation and real-world application.
  prefs: []
  type: TYPE_NORMAL
- en: This experience with TurtleSim is foundational for our main project, A.R.E.S.,
    an advanced IoT robot that will be developed in the upcoming chapters.
  prefs: []
  type: TYPE_NORMAL
- en: In the next chapter, we will return to building IoT devices as we build an MQTT
    joystick to control our TurtleSim robot.
  prefs: []
  type: TYPE_NORMAL
