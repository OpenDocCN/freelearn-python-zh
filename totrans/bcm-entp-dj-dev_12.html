<html><head></head><body>
		<div><h1 id="_idParaDest-244"><em class="italic"><a id="_idTextAnchor272"/>Chapter 9</em>: Django Testing</h1>
			<p>This chapter is dedicated to testing and debugging a Django project. Django has a wide range of test classes built into its framework that are used to write automated test scripts. As we build each app and/or component of a project, we can run one command at any time to ensure that every component still works as it should. This is great for <strong class="bold">regression testing</strong>, which<a id="_idIndexMarker1119"/> means testing a new or changed component, making sure that it does not affect the intended behavior of existing components or the entire system as a whole. For most of what we will cover in this chapter, we do not need to install any third-party packages. The last thing we will cover is the <strong class="bold">Django Debug Toolbar</strong> (<strong class="bold">DjDT</strong>), which<a id="_idIndexMarker1120"/> does require us to install a third-party package to use.</p>
			<p>In this chapter, we will cover the following topics:</p>
			<ul>
				<li>Writing automated test scripts</li>
				<li>Creating unit test cases</li>
				<li>Testing view classes and their get and post methods</li>
				<li>Testing view classes that require user authentication</li>
				<li>Testing Django REST API endpoints</li>
				<li>Installing the DjDT, a tool used for debugging</li>
			</ul>
			<h1 id="_idParaDest-245"><a id="_idTextAnchor273"/>Technical requirements</h1>
			<p>To work with the code in this chapter, the following tools will need to be installed on your local machine:</p>
			<ul>
				<li>Python version 3.9 – used as the underlying programming language for the project</li>
				<li>Django version 4.0 – used as the backend framework of the project</li>
				<li>pip package manager – used to manage third-party Python/Django packages</li>
			</ul>
			<p>We will continue to work with the solution created in <a href="B17243_02_ePub.xhtml#_idTextAnchor037"><em class="italic">Chapter 2</em></a>, <em class="italic">Project Configuration</em>. However, it is not necessary to use the Visual Studio IDE. The main project itself can be run using another IDE or run independently using a terminal or command-line window from within the project root folder, which is where the <code>manage.py</code> file resides. Whatever editor or IDE you are using, a virtual environment will also be needed to work with the Django project. Instructions for how to create a project and virtual environment can be found in <a href="B17243_02_ePub.xhtml#_idTextAnchor037"><em class="italic">Chapter 2</em></a>, <em class="italic">Project Configuration</em>. You will need a database to store the data contained in your project. PostgreSQL was chosen for the examples in the previous chapters; however, any database type that you choose for your project can be used to work with the examples in this chapter.</p>
			<p>We will also be using data that is in the form of a Django fixture, provided in <a href="B17243_03_ePub.xhtml#_idTextAnchor077"><em class="italic">Chapter 3</em></a>, <em class="italic">Models, Relations, and Inheritance</em>, in the subsection titled <em class="italic">Loading the chapter_3 data fixture</em>. Make sure the <code>chapter_3</code> fixture is loaded into your database. If this has already been done, then you may skip the next command. If you have already created the tables found in <a href="B17243_03_ePub.xhtml#_idTextAnchor077"><em class="italic">Chapter 3</em></a>, <em class="italic">Models, Relations, and Inheritance</em>, and have not loaded that fixture yet, then run the following command, after activating your virtual environment:</p>
			<pre>(virtual_env) PS &gt; python manage.py loaddata chapter_3</pre>
			<p>All of the code created in this chapter can be found in the GitHub repository for this book: <a href="https://github.com/PacktPublishing/Becoming-an-Enterprise-Django-Developer">https://github.com/PacktPublishing/Becoming-an-Enterprise-Django-Developer</a>. The bulk of the code depicted in this chapter can be found in the <code>/becoming_a_django_entdev/becoming_a_django_entdev/chapter_9/</code> directory.</p>
			<p>Check out the following video to see the <em class="italic">Code in Action</em>: <a href="https://bit.ly/3yh0tW6">https://bit.ly/3yh0tW6</a>.</p>
			<h1 id="_idParaDest-246"><a id="_idTextAnchor274"/>Preparing for this chapter</h1>
			<p>Start by creating a new app in your project called <code>chapter_9</code> by following the steps discussed in <a href="B17243_02_ePub.xhtml#_idTextAnchor037"><em class="italic">Chapter 2</em></a>, <em class="italic">Project Configuration</em>, in the subsection titled <em class="italic">Creating a Django app</em>. As discussed in that section, don't forget to change the value of the <code>name =</code> variable for your app class found in the <code>/becoming_a_django_entdev/becoming_a_django_entdev/chapter_9/apps.py</code> file to now point to the path where you installed your app. Be sure to also include this app in the <code>INSTALLED_APPS</code> variable found in the <code>settings.py</code> file as well.</p>
			<p>In the main <code>urls.py</code> file of the site, add the following two paths:</p>
			<pre class="source-code"><strong class="bold"># /becoming_a_django_entdev/urls.py</strong></pre>
			<pre class="source-code">...</pre>
			<pre class="source-code">urlpatterns = [</pre>
			<pre class="source-code">    <strong class="bold">path(</strong></pre>
			<pre class="source-code">        <strong class="bold">'',   </strong></pre>
			<pre class="source-code">        <strong class="bold">include(</strong></pre>
			<pre class="source-code">            <strong class="bold">'becoming_a_django_entdev.chapter_9.urls'</strong></pre>
			<pre class="source-code">        <strong class="bold">)</strong></pre>
			<pre class="source-code">    <strong class="bold">)</strong>,</pre>
			<pre class="source-code">    <strong class="bold">path(</strong></pre>
			<pre class="source-code">        <strong class="bold">'',   </strong></pre>
			<pre class="source-code">        <strong class="bold">include(</strong></pre>
			<pre class="source-code">            <strong class="bold">'becoming_a_django_entdev.chapter_8.urls'</strong></pre>
			<pre class="source-code">        <strong class="bold">)</strong></pre>
			<pre class="source-code">    <strong class="bold">)</strong>,</pre>
			<pre class="source-code">]</pre>
			<p>These point to the <a href="B17243_09_ePub.xhtml#_idTextAnchor272"><em class="italic">Chapter 9</em></a> URL patterns that we will be creating for this chapter and includes all of the URL patterns that we created for <a href="B17243_08_ePub.xhtml#_idTextAnchor239"><em class="italic">Chapter 8</em></a>, <em class="italic">Working with the Django REST Framework</em>. We will need the API endpoints that we created in the previous chapter for some of the REST API test exercises. Make sure the <a href="B17243_09_ePub.xhtml#_idTextAnchor272"><em class="italic">Chapter 9</em></a> URLs take precedence over the other by placing them first in this list.</p>
			<p>In your <code>/chapter_9/urls.py</code> file, you should add the following paths. These paths were used in the exercises in <a href="B17243_04_ePub.xhtml#_idTextAnchor116"><em class="italic">Chapter 4</em></a>, <em class="italic">URLs, Views, and Templates</em>: </p>
			<pre class="source-code"><strong class="bold"># /becoming_a_django_entdev/chapter_9/urls.py </strong></pre>
			<pre class="source-code">from django.urls import path, register_converter</pre>
			<pre class="source-code">from django.views.generic import TemplateView</pre>
			<pre class="source-code">from ..chapter_4.converters import <strong class="bold">YearConverter</strong> </pre>
			<pre class="source-code">from ..chapter_4.views import (</pre>
			<pre class="source-code">    <strong class="bold">practice_year_view</strong>,</pre>
			<pre class="source-code">    <strong class="bold">VehicleView</strong></pre>
			<pre class="source-code">)</pre>
			<pre class="source-code">register_converter(<strong class="bold">YearConverter</strong>, 'year') </pre>
			<pre class="source-code">urlpatterns = [</pre>
			<pre class="source-code">    path(</pre>
			<pre class="source-code">        '',  </pre>
			<pre class="source-code">        TemplateView.as_view(</pre>
			<pre class="source-code">            template_name = 'chapter_9/index.html'</pre>
			<pre class="source-code">        )</pre>
			<pre class="source-code">    ),</pre>
			<pre class="source-code">    path(</pre>
			<pre class="source-code">        <strong class="bold">'my_year_path/&lt;year:year&gt;/',</strong></pre>
			<pre class="source-code">        <strong class="bold">practice_year_view</strong>, </pre>
			<pre class="source-code">        name = 'year_url'</pre>
			<pre class="source-code">    ),</pre>
			<pre class="source-code">    path(</pre>
			<pre class="source-code">        <strong class="bold">'vehicle/&lt;int:id&gt;/',</strong></pre>
			<pre class="source-code">        <strong class="bold">VehicleView</strong>.as_view(), </pre>
			<pre class="source-code">        name = 'vehicle-detail'</pre>
			<pre class="source-code">    ),</pre>
			<pre class="source-code">]</pre>
			<p>Instead of including all of the URLs from <a href="B17243_04_ePub.xhtml#_idTextAnchor116"><em class="italic">Chapter 4</em></a>, <em class="italic">URLs, Views, and Templates</em>, we are only providing you with the ones that are needed. The reason behind this is that in <a href="B17243_04_ePub.xhtml#_idTextAnchor116"><em class="italic">Chapter 4</em></a>, <em class="italic">URLs, Views, and Templates</em>, we discussed several variations of writing the same paths for learning purposes. To prevent confusion, only the variation of the URL patterns that are needed to satisfy the type of tests that we are about to perform is included in the preceding code.</p>
			<p>Copy the <code>index.html</code> file from the code of the book found in the <code>/chapter_9/templates/chapter_9</code> directory into your project in the same directory. Also, copy the <code>chapter_9</code> CSS and JavaScript files from the code of the book into your project.</p>
			<p class="callout-heading">Note</p>
			<p class="callout">If you cloned the entire repository of code provided with this book and the DjDT is already turned on/enabled, please disable it before running any of the test cases that we will soon create. Look for the <strong class="bold">Turn Off/Comment Out For the First Half of Chapter 9</strong> comments throughout the settings and URL files. That tool will be discussed after working through some test cases.</p>
			<p>Next, let's discuss what automated testing is in Django and how it is used. </p>
			<h1 id="_idParaDest-247"><a id="_idTextAnchor275"/>Understanding automated testing in Django</h1>
			<p>Automated<a id="_idIndexMarker1121"/> testing <a id="_idIndexMarker1122"/>is helpful for a number of reasons. Developers use it when refactoring old components that need to be modified. Test scripts are used to regression test older components to see whether they were affected negatively by any new additions. Django offers several test classes that are an extension of the standard Python library called <code>unittest</code>. You can learn more about this package here: <a href="https://docs.python.org/3/library/unittest.html">https://docs.python.org/3/library/unittest.html</a>. The Django test classes are all found in the <code>django.test</code> library. The most commonly used class is <code>TestCase</code>.</p>
			<p>The following list depicts all of the test classes that are available in the <code>django.test</code> library:</p>
			<ul>
				<li><code>unittest</code> library. This class will not interact with a database.</li>
				<li><code>SimpleTestCase</code> class and allows for database transactions.</li>
				<li><code>TransactionTestCase</code> class and includes features that allow for better interactions with a database. It is the most commonly used test class.</li>
				<li><code>TransactionTestCase</code> class and allows the use of test clients other than the test client provided by Django, such as Appium, Cypress, Selenium, Serenity, or any of the dozens of other ones available. It will actually spin up a live Django server in the background to run the test and then destroy that server upon completion.</li>
				<li><code>LiveServerTestCase</code> class. This class is built specifically for using the Selenium test framework as the test client due to how popular it is.</li>
			</ul>
			<p>Writing test <a id="_idIndexMarker1124"/>classes is just like writing any other Python class. They <a id="_idIndexMarker1125"/>must consist of at least a test method, and they usually contain a <code>setUp()</code> method, but this method is not required. Test methods have the word <code>test_</code> prepended to their name, for example, <code>test_one()</code> and <code>test_two()</code>. The <code>setUp()</code> method is used to prepare your environment and/or database for any of the test methods in that class. If a class has more than one test method, an object created in one test method will not be accessible in the other test method. If you need an object in both test methods of a class, you need to place that logic in the <code>setUp()</code> method. </p>
			<p>Test classes may also have a <code>tearDown()</code> method, which will perform any cleanup tasks necessary after a test has been performed and before moving on to the next test. <code>tearDown()</code> is not used very often seeing as Django will automatically destroy any servers and databases created during the test after the test has completed. Other methods are available as well and you can learn more about them here: <a href="https://docs.djangoproject.com/en/4.0/topics/testing/tools/">https://docs.djangoproject.com/en/4.0/topics/testing/tools/</a>. </p>
			<p class="callout-heading">Tip</p>
			<p class="callout">Selenium is a third-party library of tools that simulates actual browsers, allowing you to run automated tests in many different browser types and versions. It is not necessary to perform basic/standard test cases and this is considered an advanced topic beyond the scope of this book. To learn more about Selenium, visit <a href="https://www.selenium.dev/">https://www.selenium.dev/</a>, <a href="https://pypi.org/project/selenium/">https://pypi.org/project/selenium/</a>, and <a href="https://django-selenium.readthedocs.io/en/latest/">https://django-selenium.readthedocs.io/en/latest/</a>.</p>
			<p>Every time a new app is created in Django, such as when all of the chapter apps were created prior to this chapter, you may have noticed that a <code>tests.py</code> file was automatically created for you in that app directory. This file is created whether you are using the IDE or command line to create the new app. We have just been disregarding this file as it served no purpose to us, until now. The code in this chapter will live almost entirely within the <code>tests.py</code> file. If you are using the Visual Studio IDE, you may have also noticed that it created a <code>SimpleTest(TestCase)</code> class in your <code>tests.py</code> file. Apps created through the command-line window or terminal will not have created this class for you. Go <a id="_idIndexMarker1126"/>ahead and comment this out or delete it before<a id="_idIndexMarker1127"/> proceeding so that we only see the results pertaining to the test(s) at hand.</p>
			<p>Now that we have a better understanding of how tests are performed, let's dive in and begin testing next.</p>
			<h1 id="_idParaDest-248"><a id="_idTextAnchor276"/>Getting started with unit testing</h1>
			<p><code>SimpleTest</code> class that the Visual Studio IDE created for us is actually testing for. These can be utility methods, conditional or comparison statements, Django models, forms, email messages, and so on. </p>
			<p>Let's practice writing a simple test script and then write another to include our models.</p>
			<h2 id="_idParaDest-249"><a id="_idTextAnchor277"/>Basic unit test script</h2>
			<p>In this exercise, we <a id="_idIndexMarker1129"/>will write a very basic test class that executes two different test methods. These tests will not interact with a database and are only used to compare <code>True</code> and <code>False</code> statements. The class as a whole can be used as a boilerplate when creating new test classes and modified as needed. </p>
			<p>Follow these steps:</p>
			<ol>
				<li>In your <code>/chapter_9/tests.py</code> file, add the structure of the class, as shown:<pre><strong class="bold"># /becoming_a_django_entdev/chapter_9/tests.py</strong>
from django.test import <strong class="bold">SimpleTestCase</strong>
class <strong class="bold">TestingCalibrator</strong>(<strong class="bold">SimpleTestCase</strong>):
    def <strong class="bold">setUp</strong>(self):
        pass
    def <strong class="bold">tearDown</strong>(self):
        pass
    def <strong class="bold">test_pass</strong>(self):
        '''Checks if True == True, Value set to 
            True'''
        self.assertTrue(True)
    def <strong class="bold">test_fail</strong>(self):
        '''Checks if False == False, Value set to 
            True'''
        self.assertFalse(True)</pre></li>
			</ol>
			<p>The <code>test_pass(self)</code> method is used to compare whether <code>True</code> actually equals <code>True</code> when <code>True</code> is passed into the function; it is intended to be a successful test. The <code>test_fail(self)</code> method is used to compare whether <code>False</code> equals <code>False</code> when <code>True</code> is passed into the function; it is intended to produce a failure. </p>
			<ol>
				<li value="2">Now, in your command-line window or terminal, navigate to your project's root directory and activate your virtual environment but do not run the project at this time. Instead, execute the Django test command depicted in the following code, which will only execute the tests found in your <code>chap<a id="_idTextAnchor278"/>ter_9</code> app:<pre><strong class="bold">(virtual_env) PS &gt; python manage.py test becoming_a_django_entdev.chapter_9</strong></pre></li>
			</ol>
			<p>If everything runs as intended in this exercise, it should tell you in your command-line<a id="_idIndexMarker1130"/> window that two tests were performed and which one failed, as shown:</p>
			<pre><strong class="bold">Found 2 test(s).</strong>
<strong class="bold">System check identified no issues (0 silenced).</strong>
<strong class="bold">F.</strong>
<strong class="bold">======================================================</strong>
<strong class="bold">FAIL: test_fail (becoming_a_django_entdev.chapter_9.tests.TestingCalibrator)</strong>
<strong class="bold">Checks if False == False, Value set to True</strong>
<strong class="bold">------------------------------------------------------</strong>
<strong class="bold">Traceback (most recent call last):</strong>
<strong class="bold">  File "C:\Projects\Packt\Repo\becoming_a_django_entdev\becoming_a_django_entdev\chapter_9\tests.py", line 49, in test_fail</strong>
<strong class="bold">    self.assertFalse(True)</strong>
<strong class="bold">AssertionError: True is not false</strong>
<strong class="bold">------------------------------------------------------</strong>
<strong class="bold">Ran 2 tests in 0.001s</strong>
<strong class="bold">FAILED (failures=1)</strong>
<strong class="bold">Destroying test database for alias 'default'...</strong></pre>
			<p>On the third line in the preceding output, it printed <code>F.</code>. The capital <code>F</code> represents one test was a failure and the period represents one test was a success. It then prints each of the tests that failed below that line. For each test that it prints out, Django includes the comment written for that test case, such as <code>'''Checks if False == False, Value set to True'''</code>. Make use of the triple double-quote or single-quote comment notation to include helpful information when your test does fail. It then provides traceback information, indicating the cause and location of the error or failure. You can also<a id="_idIndexMarker1131"/> include <code>print()</code> statements within these test methods if you want to provide additional information regarding a particular test.</p>
			<p class="callout-heading">Tip</p>
			<p class="callout">To run the tests for all of the apps included in your project, run the following command:<code>(virtual_env) PS &gt; python manage.py test</code></p>
			<p class="callout">Also, if you break your single-line double-quote or single-quote comment into a multiline comment, only the first line of that comment will appear in your command-line window.</p>
			<p>Now, comment out or delete the <code>TestingCalibrator</code> class before moving on to the next exercise.</p>
			<h2 id="_idParaDest-250"><a id="_idTextAnchor279"/>Testing Django models</h2>
			<p>In this exercise, we will<a id="_idIndexMarker1132"/> use the <code>TestCase</code> class because we will be connecting to a database. The database that the test client spins up for us will not affect any of the data found in all local or remote databases. Follow these steps:</p>
			<ol>
				<li value="1">In your <code>/chapter_3/models.py</code> file, make sure the (8, 'Jeep')  value exists in the <code>MAKE_CHOICES</code> list of choices:<pre><strong class="bold"># /becoming_a_django_entdev/chapter_3/models.py</strong>
...
<strong class="bold">MAKE_CHOICES</strong> = (
    ...
    <strong class="bold">(8, 'Jeep'),</strong>
    ...
)</pre></li>
				<li>In your <code>/chapter_9/tests.py</code> file, add the following <code>import</code> statements:<pre><strong class="bold"># /becoming_a_django_entdev/chapter_9/tests.py</strong>
from django.test import ..., <strong class="bold">TestCase</strong>
from djmoney.money import <strong class="bold">Money</strong>
from ..chapter_3.models import (
    <strong class="bold">Engine</strong>,
    <strong class="bold">Seller</strong>,
    <strong class="bold">Vehicle</strong>,
    <strong class="bold">VehicleModel</strong>
)</pre></li>
				<li>In that same file, add the following class and <code>setUp()</code> method:<pre><strong class="bold"># /becoming_a_django_entdev/chapter_9/tests.py</strong>
...
class <strong class="bold">ModelUnitTestCase</strong>(<strong class="bold">TestCase</strong>):
    def setUp(self):
        model = <strong class="bold">VehicleModel</strong>.objects.create(
            name = 'Grand Cherokee Laredo 4WD',
            make = 8
        )
        engine = <strong class="bold">Engine</strong>.objects.create(
            name = '3.6L FI FFV DO',
            vehicle_model = model
        )
        vehicle = <strong class="bold">Vehicle</strong>.objects.create(
            vin = 'aa890123456789012',
            sold = False,
            price = <strong class="bold">Money</strong>(39875, 'USD'),
            make = 8,
            vehicle_model = model,
            engine = engine
        )
        seller = <strong class="bold">Seller</strong>.objects.create_user(
            'test',
            'testing@example.com',
            'testpassword',
            is_staff = True,
            is_superuser = True,
            is_active = True,
            name = 'Chapter 9 Seller 1'
        )
        seller.vehicles.set([vehicle])</pre></li>
				<li>In that same <code>ModelUnitTestCase</code> class, add the following test method:<pre><strong class="bold"># /becoming_a_django_entdev/chapter_9/tests.py</strong>
...
class <strong class="bold">ModelUnitTestCase</strong>(<strong class="bold">TestCase</strong>):
    ...
    def <strong class="bold">test_full_vehicle_name</strong>(self):
        vehicle_1 = <strong class="bold">Vehicle</strong>.objects.get(
            vin = 'aa890123456789012'
        )
        <strong class="bold">self.assertEqual</strong>(
            vehicle_1.<strong class="bold">full_vehicle_name()</strong>,
            'Jeep Grand Cherokee Laredo 4WD - 3.6L FI 
                FFV DO'
        )</pre></li>
			</ol>
			<p>The <a id="_idIndexMarker1133"/>preceding <code>setUp(self)</code> method will create a <code>VehicleModel</code>, <code>Engine</code>, <code>Vehicle</code>, and <code>Seller</code> model object that we imported from the <code>chapter_3</code> app. The <code>setUp()</code> method creates these objects before any of the test cases in that class are executed. We create each related object as a variable and then use that variable to assign as the related object of the next object that we create. The <code>Seller</code> object uses the same <code>create_user()</code> method that was introduced in <a href="B17243_06_ePub.xhtml#_idTextAnchor190"><em class="italic">Chapter 6</em></a>, <em class="italic">Exploring the Django Admin Site</em>, to create a new <code>Seller</code> with the hashed password and date fields formatted for us. We created only one test, called <code>test_full_vehicle_name()</code>, which looks up the vehicle that was created upon setup by the vin field value specified. It uses the <code>full_vehicle_name()</code> method that we created in <a href="B17243_03_ePub.xhtml#_idTextAnchor077"><em class="italic">Chapter 3</em></a>, <em class="italic">Models, Relations, and Inheritance</em>, to return to us the custom-formatted name of that newly created vehicle. The expected value is <code>Jeep Grand Cherokee Laredo 4WD - 3.6L FI FFV DO</code>, which is in the format <code>{{ make }} {{ model }} – {{ engine }}</code>. If the resulting value does not match that value, the test will fail.</p>
			<ol>
				<li value="5">Now, execute the run test command shown here:<pre><strong class="bold">(virtual_env) PS &gt; python manage.py test becoming_a_django_entdev.chapter_9</strong></pre></li>
			</ol>
			<p>If you commented <a id="_idIndexMarker1134"/>out all the other tests prior to this one, you should see the results shown here:</p>
			<pre><strong class="bold">Found 1 test(s).</strong>
<strong class="bold">Creating test database for alias 'default'...</strong>
<strong class="bold">System check identified no issues (0 silenced).</strong>
<strong class="bold">.</strong>
<strong class="bold">------------------------------------------------------</strong>
<strong class="bold">Ran 1 test in 0.229s</strong>
<strong class="bold">OK</strong>
<strong class="bold">Destroying test database for alias 'default'...</strong></pre>
			<ol>
				<li value="6">Go ahead and change the expected value found in the <code>self.assertEqual()</code> function of <em class="italic">step 4</em> previously to something that doesn't exist, and then rerun your test command one more time. Now, you should see a failure message, as depicted here:<pre><strong class="bold">Found 1 test(s).</strong>
<strong class="bold">Creating test database for alias 'default'...</strong>
<strong class="bold">System check identified no issues (0 silenced).</strong>
<strong class="bold">F</strong>
<strong class="bold">======================================================</strong>
<strong class="bold">FAIL: test_full_vehicle_name </strong>
<strong class="bold">------------------------------------------------------</strong>
<strong class="bold">Traceback (most recent call last):</strong>
<strong class="bold">  File "C:\Projects\Packt\Repo\becoming_a_django_entdev\becoming_a_django_entdev\chapter_9\tests.py", line 88, in test_full_vehicle_name</strong>
<strong class="bold">    self.assertEqual(vehicle_1.full_vehicle_name(), 'Jeep Grand Cherokee Laredo 4WD - 3.6L FI FFV DO asdfasdfas') # Incorrect Value</strong>
<strong class="bold">AssertionError: 'Jeep Grand Cherokee Laredo 4WD - 3.6L FI FFV DO' != 'Jeep Grand Cherokee Laredo 4WD - 3.6L FI FFV DO asdfasdfas'</strong>
<strong class="bold">- Jeep Grand Cherokee Laredo 4WD - 3.6L FI FFV DO</strong>
<strong class="bold">+ Jeep Grand Cherokee Laredo 4WD - 3.6L FI FFV DO asdfasdfas</strong>
<strong class="bold">?                                                +++++++++++</strong>
<strong class="bold">------------------------------------------------------</strong>
<strong class="bold">Ran 1 test in 0.227s</strong>
<strong class="bold">FAILED (failures=1)</strong>
<strong class="bold">Destroying test database for alias 'default'...</strong></pre></li>
			</ol>
			<p>Go ahead and comment out the <code>ModelUnitTestCase</code> class before proceeding to the next exercise. Now that we have an understanding of how to write simple test cases and cases that test model CRUD actions, next, we will test a custom view class that was written<a id="_idIndexMarker1135"/> in <a href="B17243_04_ePub.xhtml#_idTextAnchor116"><em class="italic">Chapter 4</em></a>, <em class="italic">URLs, Views, and Templates</em>.</p>
			<h1 id="_idParaDest-251"><a id="_idTextAnchor280"/>Testing HTTP view requests</h1>
			<p>In this section, we will <a id="_idIndexMarker1136"/>expand on the basic test cases that we previously wrote to include HTTP view requests. When testing view classes, whether they are a method-based view or a class-based view, they will both use the same <code>TestCase</code> class that we have been using so far.</p>
			<p>In the following subsections, we will perform two tests, one for a method-based view and the other for a class-based view.</p>
			<h2 id="_idParaDest-252"><a id="_idTextAnchor281"/>Testing method-based views</h2>
			<p>In this<a id="_idIndexMarker1137"/> exercise, we <a id="_idIndexMarker1138"/>will test the <code>practice_year_view()</code> method, written in <a href="B17243_04_ePub.xhtml#_idTextAnchor116"><em class="italic">Chapter 4</em></a>, <em class="italic">URLs, Views, and Templates</em>. What we are comparing in this test is whether the response code that gets returned equals the value of <code>200</code>, which means a successful response. </p>
			<p>Follow these steps to create your test case:</p>
			<ol>
				<li value="1">In your <code>/chapter_9/tests.py</code> file, add the following <code>YearRequestTestCase</code> class and methods:<pre><strong class="bold"># /becoming_a_django_entdev/chapter_9/tests.py</strong>
...
from django.contrib.auth.models import <strong class="bold">AnonymousUser</strong>
from django.test import ..., <strong class="bold">RequestFactory</strong>, TestCase
from ..chapter_4.views import <strong class="bold">practice_year_view</strong>
class <strong class="bold">YearRequestTestCase</strong>(TestCase):
    def <strong class="bold">setUp</strong>(self):
        self.factory = <strong class="bold">RequestFactory</strong>()
    def <strong class="bold">test_methodbased</strong>(self):
        request = self.factory.get(
            '/my_year_path/<strong class="bold">2022</strong>/'
        )
        request.user = <strong class="bold">AnonymousUser()</strong>
        response = <strong class="bold">practice_year_view</strong>(request, <strong class="bold">2022</strong>)
        self.assertEqual(<strong class="bold">response.status_code</strong>, <strong class="bold">200</strong>)</pre></li>
			</ol>
			<p>This test uses a <code>RequestFactory()</code> object saved as the <code>self.factory</code> variable. It then uses that factory to construct an actual <code>request</code> object. The path that we want to test is passed into the <code>self.factory.get()</code> method as <code>/my_year_path/2022/</code>. Since we are not requiring authentication within <code>practice_year_view()</code>, we are setting the <code>request.user</code> object to an <code>AnonymousUser()</code> class object provided in the <code>django.contrib.auth.models</code> library. The response is constructed using the <code>practice_year_view(request, 2022)</code> method. Here, we pass in the <code>request</code> object and the value of the year keyword argument that we are attempting to<a id="_idIndexMarker1139"/> access. The last line<a id="_idIndexMarker1140"/> checks whether <code>response.status_code</code> actually equals a value of <code>200</code>.</p>
			<ol>
				<li value="2">Next, run the following test command for the <code>chapter_9</code> app test cases:<pre><strong class="bold">(virtual_env) PS &gt; python manage.py test becoming_a_django_entdev.chapter_9</strong></pre></li>
			</ol>
			<p>If successful, you should see the following message:</p>
			<pre><strong class="bold">Found 1 test(s).</strong>
<strong class="bold">Creating test database for alias 'default'...</strong>
<strong class="bold">System check identified no issues (0 silenced).</strong>
<strong class="bold">.</strong>
<strong class="bold">------------------------------------------------------</strong>
<strong class="bold">Ran 1 test in 0.003s</strong>
<strong class="bold">OK</strong>
<strong class="bold">Destroying test database for alias 'default'...</strong></pre>
			<p>Go back to <em class="italic">step 1</em> and change all instances of the year <code>2022</code> to <code>12</code> (found in two spots), and then rerun your test command. You should see the failure/error message <a id="_idIndexMarker1141"/>shown <a id="_idIndexMarker1142"/>here:</p>
			<pre><strong class="bold">Found 1 test(s).</strong>
<strong class="bold">Creating test database for alias 'default'...</strong>
<strong class="bold">System check identified no issues (0 silenced).</strong>
<strong class="bold">E</strong>
<strong class="bold">======================================================</strong>
<strong class="bold">ERROR: test_methodbased (becoming_a_django_entdev.chapter_9.tests.YearRequestTestCase)</strong>
<strong class="bold">Checks if the path http://localhost:8000/my_year_path/2022/ actually exists and returns a 200 response code (Valid)</strong>
<strong class="bold">------------------------------------------------------</strong>
<strong class="bold">Traceback (most recent call last):</strong>
<strong class="bold">  File "C:\Projects\Packt\Repo\becoming_a_django_entdev\becoming_a_django_entdev\chapter_9\tests.py", line 115, in test_methodbased</strong>
<strong class="bold">    response = practice_year_view(request, 12)</strong>
<strong class="bold">  File "C:\Projects\Packt\Repo\becoming_a_django_entdev\becoming_a_django_entdev\chapter_4\views.py", line 37, in practice_year_view</strong>
<strong class="bold">    raise Http404('Year Not Found: %s' % year)</strong>
<strong class="bold">django.http.response.Http404: Year Not Found: 12</strong>
<strong class="bold">------------------------------------------------------</strong>
<strong class="bold">Ran 1 test in 0.004s</strong>
<strong class="bold">FAILED (errors=1)</strong>
<strong class="bold">Destroying test database for alias 'default'...</strong></pre>
			<p>This test case failed because of the condition that we wrote in the <code>practice_year_view()</code> method in <a href="B17243_04_ePub.xhtml#_idTextAnchor116"><em class="italic">Chapter 4</em></a>, <em class="italic">URLs, Views, and Templates</em>, which checks to make sure the user enters a year greater than or equal to <code>1900</code>. You will also see that instead of printing an <code>F</code> or period for this test, it printed the capital letter <code>E</code>, which stands for error. The error versus a failure is a result of the custom parameters that we are checking for, meaning the URL pattern is correct but the view itself performs additional logic that triggers<a id="_idIndexMarker1143"/> the <a id="_idIndexMarker1144"/>page-not-found error.</p>
			<p>Go ahead and comment out the <code>YearRequestTestCase</code> class before proceeding to the next exercise.</p>
			<p>Let's test a class-based view in the next section. </p>
			<h2 id="_idParaDest-253"><a id="_idTextAnchor282"/>Testing class-based views</h2>
			<p>In this exercise, we <a id="_idIndexMarker1145"/>will test the <code>VehicleView</code> class, written<a id="_idIndexMarker1146"/> in <a href="B17243_04_ePub.xhtml#_idTextAnchor116"><em class="italic">Chapter 4</em></a>, <em class="italic">URLs, Views, and Templates</em>. We will be loading the <code>chapter_3</code> data fixture instead of creating objects in the <code>setUp()</code> method, as we have done in the <code>ModelUnitTestCase</code> class. We already performed a test to see whether creating objects was a success. We can save time and effort now by just loading a fixture for all other tests that we write. </p>
			<p>Follow these steps to create your test case:</p>
			<ol>
				<li value="1">In your <code>/chapter_9/tests.py</code> file, add the <code>VehicleRequestTestCase</code> class and methods, as shown:<pre><strong class="bold"># /becoming_a_django_entdev/chapter_9/tests.py</strong>
...
from django<a id="_idTextAnchor283"/>.contrib.auth.models import AnonymousUser
from django.test import ..., RequestFactory, TestCase
from ..chapter_4.views import ..., <strong class="bold">VehicleView</strong>
class <strong class="bold">VehicleRequestTestCase</strong>(TestCase):
    <strong class="bold">fixtures</strong> = <strong class="bold">['chapter_3']</strong>
    def <strong class="bold">setUp</strong>(self):
        self.factory = RequestFactory()
    def <strong class="bold">test_classbased</strong>(self):
        request = self.factory.get('/vehicle/<strong class="bold">1</strong>/')
        request.user = AnonymousUser()
        response = <strong class="bold">VehicleView.as_view()(request, 1)</strong>
        self.assertEqual(response.status_code, 200)</pre></li>
			</ol>
			<p>We still<a id="_idIndexMarker1147"/> need the <code>RequestFactory()</code> object and <code>AnonymousUser()</code> as we used before, because the <code>VehicleView</code> class does not require authentication as well. We created the response object for this test using <code>VehicleView.as_view()(request, 1)</code>. It looks similar to a URL pattern mapping to a view class, using the <code>.as_view()</code> method, found in any <code>urls.py</code> file. We again check to see whether <code>response.status_code</code> equals a value of <code>200</code>, indicating success.</p>
			<ol>
				<li value="2">Now, run the test command shown in the following code and you should once again see a successful test:<pre><strong class="bold">(virtual_env) PS &gt; python manage.py test becoming_a_django_entdev.chapter_9</strong></pre></li>
				<li>Now, change the number <code>1</code> found in <em class="italic">step 1</em> in <code>'/vehicle/1/'</code> and <code>(request, 1)</code> to <code>99</code>. This number represents the index of the vehicle that we are trying to access, an index that should not currently exist. Then, rerun your <code>test</code> <a id="_idIndexMarker1148"/>command and you should see<a id="_idIndexMarker1149"/> the following message:<pre><strong class="bold">Found 1 test(s).</strong>
<strong class="bold">Creating test database for alias 'default'...</strong>
<strong class="bold">System check identified no issues (0 silenced).</strong>
<strong class="bold">E</strong>
<strong class="bold">======================================================</strong>
<strong class="bold">ERROR: test_classbased (becoming_a_django_entdev.chapter_9.tests.VehicleRequestTestCase)</strong>
<strong class="bold">Checks if the path http://localhost:8000/vehicle/1/ actually exists and returns a 200 response code (Valid)</strong>
<strong class="bold">------------------------------------------------------</strong>
<strong class="bold">Traceback (most recent call last):</strong>
<strong class="bold">  File "C:\Projects\Packt\Repo\becoming_a_django_entdev\becoming_a_django_entdev\chapter_4\views.py", line 68, in get</strong>
<strong class="bold">    vehicle = Vehicle.objects.get(id=id)</strong>
<strong class="bold">  File "C:\Projects\Packt\Repo\becoming_a_django_entdev\virtual_env\lib\site-packages\django\db\models\manager.py", line 85, in manager_method</strong>
<strong class="bold">    return getattr(self.get_queryset(), name)(*args, **kwargs)</strong>
<strong class="bold">  File "C:\Projects\Packt\Repo\becoming_a_django_entdev\virtual_env\lib\site-packages\django\db\models\query.py", line 439, in get</strong>
<strong class="bold">    raise self.model.DoesNotExist(</strong>
<strong class="bold">becoming_a_django_entdev.chapter_3.models.Vehicle.DoesNotExist: Vehicle matching query does not exist.</strong>
<strong class="bold">During handling of the above exception, another exception occurred:</strong>
<strong class="bold">Traceback (most recent call last):</strong>
<strong class="bold">  File "C:\Projects\Packt\Repo\becoming_a_django_entdev\becoming_a_django_entdev\chapter_9\tests.py", line 143, in test_classbased</strong>
<strong class="bold">    response = VehicleView.as_view()(request, 99)</strong>
<strong class="bold">  File "C:\Projects\Packt\Repo\becoming_a_django_entdev\virtual_env\lib\site-packages\django\views\generic\base.py", line 69, in view</strong>
<strong class="bold">    return self.dispatch(request, *args, **kwargs)</strong>
<strong class="bold">  File "C:\Projects\Packt\Repo\becoming_a_django_entdev\virtual_env\lib\site-packages\django\views\generic\base.py", line 101, in dispatch</strong>
<strong class="bold">    return handler(request, *args, **kwargs)</strong>
<strong class="bold">  File "C:\Projects\Packt\Repo\becoming_a_django_entdev\becoming_a_django_entdev\chapter_4\views.py", line 70, in get</strong>
<strong class="bold">    raise Http404('Vehicle ID Not Found: %s' % id)</strong>
<strong class="bold">django.http.response.Http404: Vehicle ID Not Found: 99</strong>
<strong class="bold">------------------------------------------------------</strong>
<strong class="bold">Ran 1 test in 0.062s</strong>
<strong class="bold">FAILED (errors=1)</strong>
<strong class="bold">Destroying test database for alias 'default'...</strong></pre></li>
			</ol>
			<p>You'll <a id="_idIndexMarker1150"/>notice, inside<a id="_idIndexMarker1151"/> the preceding traceback message, that it indicates that an object with that ID was not found. The bottom of your traceback is where you will likely find your answer as to what caused the problem to occur, but that is not always the case. This is because we have less than 10 vehicle items found in the <code>chapter_3</code> fixture.</p>
			<p>Comment out the <code>VehicleRequestTestCase</code> class before proceeding to the next exercise.</p>
			<p>Now that we have<a id="_idIndexMarker1152"/> learned how to test request responses and load <a id="_idIndexMarker1153"/>data fixtures into a test case, let's build on that by adding authentication measures next.</p>
			<h1 id="_idParaDest-254"><a id="_idTextAnchor284"/>Testing authenticated view requests</h1>
			<p>In this section, we will <a id="_idIndexMarker1154"/>be building on the same request test cases that we just built to remove the <code>AnonymousUser</code> class and perform our own authentication, requiring only permitted users. We have a few view classes that we wrote in <a href="B17243_08_ePub.xhtml#_idTextAnchor239"><em class="italic">Chapter 8</em></a>, <em class="italic">Working with the Django REST Framework</em>, that require user authentication. Let's create test scripts that allow us to authenticate with an actual user when performing an automated test. This is where loading the <code>chapter_8/urls.py</code> file when preparing for this chapter comes into play. Django provides a class called <code>Client</code> found in the <code>django.test</code> library that lets us perform user authentication when testing a view class. </p>
			<p>In the following subsection, we will implement the <code>Client</code> class when performing authentication.</p>
			<h2 id="_idParaDest-255"><a id="_idTextAnchor285"/>Using the Client() class</h2>
			<p>In this exercise, we <a id="_idIndexMarker1155"/>will test the custom API<a id="_idIndexMarker1156"/> endpoint written in <a href="B17243_08_ePub.xhtml#_idTextAnchor239"><em class="italic">Chapter 8</em></a>, <em class="italic">Working with the Django REST Framework</em>, in the <code>GetSellerHTMLView</code> class. This is the class we wrote to query a seller by ID and return preformatted HTML instead of the expected JSON, from a traditional API endpoint. What we will be testing for is whether or not the <code>seller</code> context object has the business name that is expected for the ID that we are looking up. When using the <code>Client</code> class, the <code>RequestFactory</code> class is no longer needed, and neither is the <code>AnonymousUser</code> class.</p>
			<p>Follow these steps to implement your own authentication:</p>
			<ol>
				<li value="1">In your <code>/chapter_9/tests.py</code> file, add the <code>SellerClientTestCase</code> class and <code>setUp()</code> method shown here: <pre><strong class="bold"># /becoming_a_django_entdev/chapter_9/tests.py</strong>
...
from django.test import ..., <strong class="bold">Client</strong>, TestCase
from ..chapter_3.models import ..., <strong class="bold">Seller</strong>
class <strong class="bold">SellerClientTestCase</strong>(TestCase):
    fixtures = ['chapter_3']
    def <strong class="bold">setUp</strong>(self):
        self.user = <strong class="bold">Seller</strong>.objects.get(id=1)
        self.client = <strong class="bold">Client()</strong>
        self.client.login(
            username = self.user.username,
            password = <strong class="bold">'mynewpassword'</strong>
        )</pre></li>
			</ol>
			<p>We first <a id="_idIndexMarker1157"/>set <a id="_idIndexMarker1158"/>the <code>self.user</code> value to equal a single <code>Seller</code>. The ID provided is the number <code>1</code>, relating to the first superuser created with the username of <code>admin</code>. This is the only seller object that has been provided in the <code>chapter_3</code> fixture for you. Next, we set the <code>self.client</code> value to be a newly created <code>Client()</code> object. The last line of the <code>setUp(self)</code> method is where we simulate logging into the system. We use <code>self.user.username</code> to grab the username of the <code>Seller</code> that we queried. Do not use <code>self.user.password</code> as the password; instead, use the unhashed password as a string manually written into the code. This is because there is no way to retrieve the unhashed password of a user and that is by design for security reasons.</p>
			<p class="callout-heading">Note</p>
			<p class="callout">When writing your own test cases, it would be wise to keep test user credentials stored in a <code>.env</code> file and imported into your project as a <code>settings.py</code> variable, which can then be referenced instead of hardcoding the password, as was done previously.</p>
			<ol>
				<li value="2">In that same <code>SellerClientTestCase</code> class, add the following test method:<pre><strong class="bold"># /becoming_a_django_entdev/chapter_9/tests.py</strong>
...
class <strong class="bold">SellerClientTestCase</strong>(TestCase):
    ...
    def <strong class="bold">test_get</strong>(self):
        response = <strong class="bold">self.client.get(</strong>
            <strong class="bold">'/chapter-8/seller/1/'</strong>
        <strong class="bold">)</strong>
        self.assertEqual(<strong class="bold">response.status_code</strong>, <strong class="bold">200</strong>)
        seller = response.context['seller']</pre></li>
			</ol>
			<p>        self.assertEqual(<strong class="bold">seller.name</strong>, <strong class="bold">'Test Biz Name'</strong>)</p>
			<p>In <a id="_idIndexMarker1159"/>the <a id="_idIndexMarker1160"/>preceding <code>test_get(self)</code> method, we created the response object using <code>self.client.get()</code>. Inside that method, we are passing in the path that we are testing, of http://localhost:8000/chapter-8/seller/1/. We are performing two checks instead of one within this test case; the first checks whether <code>response.status_code</code> actually equals <code>200</code>, to indicate success. The other checks whether or not the seller's business name is what is expected for the object that we are looking up, that being <code>Test Biz Name</code>. </p>
			<p>This is why we are creating the lowercase <code>seller</code> variable, which grabs the <code>seller</code> from the context returned with the request. It is also important that we add the <code>self.assertEqual(response.status_code, 200)</code> statement before we create the lowercase <code>seller</code> variable. If we do not have a successful response for any reason, the <code>seller</code> object will obviously not exist and so the test will fail. When that happens, it could point you in the wrong direction as to what the real problem could be.</p>
			<ol>
				<li value="3">Now, run the following <code>test</code> command and you should once again see a successful test:<pre><strong class="bold">(virtual_env) PS &gt; python manage.py test becoming_a_django_entdev.chapter_9</strong></pre></li>
				<li>Next, change the <code>password</code> value found in <em class="italic">step 1</em> to an incorrect password, such as <code>mynewpassword1</code>, which will force a failed response. Rerun your <code>test</code> command and you should see<a id="_idIndexMarker1161"/> the <a id="_idIndexMarker1162"/>following message:<pre><strong class="bold">Found 1 test(s).</strong>
<strong class="bold">Creating test database for alias 'default'...</strong>
<strong class="bold">System check identified no issues (0 silenced).</strong>
<strong class="bold">F</strong>
<strong class="bold">======================================================</strong>
<strong class="bold">FAIL: test_get (becoming_a_django_entdev.chapter_9.tests.SellerClientTestCase) </strong>
<strong class="bold">Tests a custom-built REST-API Endpoint using the Client() class.</strong>
<strong class="bold">------------------------------------------------------</strong>
<strong class="bold">Traceback (most recent call last):</strong>
<strong class="bold">  File "C:\Projects\Packt\Repo\becoming_a_django_entdev\becoming_a_django_entdev\chapter_9\tests.py", line 171, in test_get</strong>
<strong class="bold">    self.assertEqual(response.status_code, 200)</strong>
<strong class="bold">AssertionError: 401 != 200</strong>
<strong class="bold">------------------------------------------------------</strong>
<strong class="bold">Ran 1 test in 0.356s</strong>
<strong class="bold">FAILED (failures=1)</strong>
<strong class="bold">Destroying test database for alias 'default'...</strong></pre></li>
			</ol>
			<p>We can see the reason why a failure occurred is due to <strong class="bold">AssertionError: 401 != 200</strong>. A <strong class="bold">401</strong> response means an unauthorized response, which means the requested resource does not have valid authentication credentials and access will not be granted.</p>
			<ol>
				<li value="5">Change your<a id="_idIndexMarker1163"/> password<a id="_idIndexMarker1164"/> back to the correct password of <code>mynewpassword</code> and then, returning to <em class="italic">step 2</em>, change the business name in the last line to something incorrect, such as <code>Test Biz Name1</code>.</li>
				<li>Rerun the <code>test</code> command one more time and now you should see the following failed message:<pre><strong class="bold">Found 1 test(s).</strong>
<strong class="bold">Creating test database for alias 'default'...</strong>
<strong class="bold">System check identified no issues (0 silenced).</strong>
<strong class="bold">F</strong>
<strong class="bold">======================================================</strong>
<strong class="bold">FAIL: test_get (becoming_a_django_entdev.chapter_9.tests.SellerClientTestCase)</strong>
<strong class="bold">Tests a custom-built REST-API Endpoint using the Client() class.</strong>
<strong class="bold">------------------------------------------------------</strong>
<strong class="bold">Traceback (most recent call last):</strong>
<strong class="bold">  File "C:\Projects\Packt\Repo\becoming_a_django_entdev\becoming_a_django_entdev\chapter_9\tests.py", line 175, in test_get</strong>
<strong class="bold">    self.assertEqual(seller.name, 'Test Biz Name1')</strong>
<strong class="bold">AssertionError: 'Test Biz Name' != 'Test Biz Name1'</strong>
<strong class="bold">- Test Biz Name</strong>
<strong class="bold">+ Test Biz Name1</strong>
<strong class="bold">?              +</strong>
<strong class="bold">------------------------------------------------------</strong>
<strong class="bold">Ran 1 test in 0.561s</strong>
<strong class="bold">FAILED (failures=1)</strong>
<strong class="bold">Destroying test database for alias 'default'...</strong></pre></li>
			</ol>
			<p>This also indicates that we achieved a <strong class="bold">200</strong> successful response code seeing that this is the second assertion that failed and not the first one.</p>
			<p>You may now comment out the <code>SellerClientTestCase</code> class before proceeding to the next exercise. Now <a id="_idIndexMarker1165"/>that we have a better understanding of how to add<a id="_idIndexMarker1166"/> authentication measures to our test cases, we will test Django REST API endpoints with authentication next.</p>
			<h1 id="_idParaDest-256"><a id="_idTextAnchor286"/>Testing Django REST API endpoints</h1>
			<p>This section will <a id="_idIndexMarker1167"/>introduce writing test cases that test Django REST framework endpoints. When testing any REST API endpoints created using the Django REST framework, we need to use the <code>APITestCase</code> class provided by the <code>rest_framework.test</code> library. We also should use the <code>APIClient()</code> class provided by that same library when requiring authentication, instead of using the <code>Client()</code> class as we did before. </p>
			<p>In the following exercises, we will create one test class that performs two tests: the first will create an <a id="_idIndexMarker1168"/>engine object and the other will update an object.</p>
			<h2 id="_idParaDest-257"><a id="_idTextAnchor287"/>Creating an object test case</h2>
			<p>This test will <a id="_idIndexMarker1169"/>use the <code>POST</code> request method to <a id="_idIndexMarker1170"/>send data to the <a href="http://localhost:8000/chapter-8/engines/">http://localhost:8000/chapter-8/engines/</a> endpoint and create an engine object in the database. Since we are loading a data fixture that contains only two engine objects with the IDs <code>1</code> and <code>2</code>, we should expect the new object to be created at index <code>3</code>, but your results may vary. We will refer back to this in the <em class="italic">Updating an object test case</em> subsection. </p>
			<p>Follow these steps to create your test case:</p>
			<ol>
				<li value="1">In your <code>/chapter_9/tests.py</code> file, add the following <code>EngineAPITestCase</code> class, the <code>setUp()</code> method, and the <code>import</code> statement:<pre><strong class="bold"># /becoming_a_django_entdev/chapter_9/tests.py</strong>
...
from rest_framework.test import <strong class="bold">APITestCase</strong>, <strong class="bold">APIClient</strong>
class <strong class="bold">EngineAPITestCase</strong>(<strong class="bold">APITestCase</strong>):
    fixtures = ['chapter_3']
    def <strong class="bold">setUp</strong>(self):
        self.user = Seller.objects.get(id=1)
        self.client = <strong class="bold">APIClient()</strong>
        self.client.login(
            username = self.user.username,
            password = 'mynewpassword'
        )</pre></li>
			</ol>
			<p>The structure of the preceding class follows a very similar pattern to what was done in the subsection titled <em class="italic">Using the Client() class</em>. Here, we set the value of <code>self.client</code> to use the <code>rest_framework.test</code> library-provided <code>APIClient</code> class. Login is done the same as before, in the <code>self.client.login()</code> declaration.</p>
			<ol>
				<li value="2">In that <a id="_idIndexMarker1171"/>same <code>EngineAPITestCase</code> class, add<a id="_idIndexMarker1172"/> the following <code>test_post()</code> method:<pre><strong class="bold"># /becoming_a_django_entdev/chapter_9/tests.py</strong>
...
class <strong class="bold">EngineAPITestCase</strong>(<strong class="bold">APITestCase</strong>):
    ...
    def <strong class="bold">test_post</strong>(self):
        response = <strong class="bold">self.client.post</strong>(
            '/chapter-8/engines/',
            <strong class="bold">{'name': 'New Engine'},</strong>
            <strong class="bold">format = 'json'</strong>
        )
        self.assertEqual(response.status_code, 201)
        self.assertEqual(<strong class="bold">response.data['name']</strong>, 'New 
            Engine')</pre></li>
			</ol>
			<p>For the response object, instead of using <code>self.client.get()</code>, we are using <code>self.client.post()</code> because we want to send information to the test client server. Inside is the data we are sending, noting that the last argument is the format of the data, which is set to JSON format in this example. We then check the <code>response.status_code</code> value, this time to see whether it equals <code>201</code> and not <code>200</code>. A <code>201</code> response code indicates that an object was created successfully. The last line checks whether the data that was returned to us, which is the object that was created, has the engine name that we expect. In this case, the new engine name we are expecting is <code>New Engine</code>.</p>
			<ol>
				<li value="3">Now, run the following <code>test</code> command and you should once again see a successful test:<pre><strong class="bold">virtual_env) PS &gt; python manage.py test becoming_a_django_entdev.chapter_9 </strong></pre></li>
				<li>Next, go back to <em class="italic">step 1</em> and add an incorrect password, such as <code>mynewpassword1</code>, and <a id="_idIndexMarker1173"/>then run your <code>test</code> command again. You should see the<a id="_idIndexMarker1174"/> following message:<pre><strong class="bold">Found 1 test(s).</strong>
<strong class="bold">Creating test database for alias 'default'...</strong>
<strong class="bold">System check identified no issues (0 silenced).</strong>
<strong class="bold">F</strong>
<strong class="bold">======================================================</strong>
<strong class="bold">FAIL: test_post (becoming_a_django_entdev.chapter_9.tests.EngineAPITestCase)</strong>
<strong class="bold">Checks if it returns a 201 response code (Created).</strong>
<strong class="bold">------------------------------------------------------</strong>
<strong class="bold">Traceback (most recent call last):</strong>
<strong class="bold">  File "C:\Projects\Packt\Repo\becoming_a_django_entdev\becoming_a_django_entdev\chapter_9\tests.py", line 203, in test_post</strong>
<strong class="bold">    self.assertEqual(response.status_code, 201)</strong>
<strong class="bold">AssertionError: 401 != 201</strong>
<strong class="bold">------------------------------------------------------</strong>
<strong class="bold">Ran 1 test in 0.363s</strong>
<strong class="bold">FAILED (failures=1)</strong>
<strong class="bold">Destroying test database for alias 'default'...</strong></pre></li>
			</ol>
			<p>We can see in this test that we are being warned of <code>AssertionError: 401 != 201</code> and not <code>200</code> this time. You can <code>achieve</code> the same by changing the expected value of the engine name and you will <a id="_idIndexMarker1175"/>see it warn you of that <a id="_idIndexMarker1176"/>assertion.</p>
			<p>Next, let's add to this class to allow us to test updating an object.</p>
			<h2 id="_idParaDest-258"><a id="_idTextAnchor288"/>Updating an object test case</h2>
			<p>This test <a id="_idIndexMarker1177"/>will<a id="_idIndexMarker1178"/> use the <code>PUT</code> request method to send data to the <a href="http://localhost:8000/chapter-8/engines/1/">http://localhost:8000/chapter-8/engines/1/</a> endpoint, a specific engine object to update within the database. </p>
			<p>Follow these steps to update your class for this test case:</p>
			<ol>
				<li value="1">Inside the same <code>EngineAPITestCase</code> class, add the following <code>test_put()</code> method:<pre><strong class="bold"># /becoming_a_django_entdev/chapter_9/tests.py</strong>
...
from rest_framework.test import APITestCase, APIClient
class <strong class="bold">EngineAPITestCase</strong>(APITestCase):
    ...
    def test_put(self):
        response = <strong class="bold">self.client.put</strong>(
            '/chapter-8/engines/1/',
            {'name': 'My Changed Engine Name'},
            format = 'json'
        )
        self.assertEqual(response.status_code, 200)
        self.assertEqual(
            response.data['name'],
            'My Changed Engine Name'
        )</pre></li>
			</ol>
			<p>Please leave the <code>setUp()</code> and <code>test_post()</code> methods as they are. In the preceding <code>test_put()</code> method, we are using the <code>self.client.put()</code> method to create the response object. The data that we are sending is in the same JSON format. Note that in the preceding example, we are specifying the path as <code>'/chapter-8/engines/1/'</code>, which refers to the first engine object with <a id="_idIndexMarker1179"/>an ID index of <code>1</code>. That <a id="_idIndexMarker1180"/>object is being inserted into the dummy database that gets created through the <code>chapter_3</code> fixture that is still being used in this class. We once again are checking that <code>response.status_code</code> equals <code>200</code>, success. We don't need to check for <code>201</code> because nothing is being created currently, only updated. We then check to make sure that the expected object's name equals <code>My Changed Engine Name</code>.</p>
			<ol>
				<li value="2">Now, run the following test command and you should see that both tests are a success:<pre><strong class="bold">(virtual_env) PS &gt; python3 manage.py test becoming_a_django_entdev.chapter_9</strong></pre></li>
				<li>To demonstrate how creating an item in one test cannot be retrieved from another test within the same class, change the ID of <code>1</code> to <code>3</code> within the <code>test_put()</code> method, as in <code>'/chapter-8/engines/3/'</code>. </li>
			</ol>
			<p>When we created an object in the <code>test_post(self)</code> method, you might expect the newly created object to have had an ID index of <code>3</code> since the <code>chapter_3</code> fixture only has two objects. The reason we won't find the new object to update that object is that when the <code>test_post(self)</code> method is complete, anything created during that operation gets destroyed upon completion.</p>
			<ol>
				<li value="4">Rerun your <code>test</code><a id="_idIndexMarker1181"/> command <a id="_idIndexMarker1182"/>and now you should see the failure message shown here:<pre><strong class="bold">Found 2 test(s).</strong>
<strong class="bold">Creating test database for alias 'default'...</strong>
<strong class="bold">System check identified no issues (0 silenced).</strong>
<strong class="bold">.F</strong>
<strong class="bold">======================================================</strong>
<strong class="bold">FAIL: test_put (becoming_a_django_entdev.chapter_9.tests.EngineAPITestCase)</strong>
<strong class="bold">Checks if it returns a 200 response code (Success).</strong>
<strong class="bold">------------------------------------------------------</strong>
<strong class="bold">Traceback (most recent call last):</strong>
<strong class="bold">  File "C:\Projects\Packt\Repo\becoming_a_django_entdev\becoming_a_django_entdev\chapter_9\tests.py", line 219, in test_put</strong>
<strong class="bold">    self.assertEqual(response.status_code, 200)</strong>
<strong class="bold">AssertionError: 404 != 200</strong>
<strong class="bold">------------------------------------------------------</strong>
<strong class="bold">Ran 2 tests in 1.037s</strong>
<strong class="bold">FAILED (failures=1)</strong>
<strong class="bold">Destroying test database for alias 'default'...</strong></pre></li>
			</ol>
			<p>The reason we are seeing a failure is that Django does not keep objects created between other test cases within the same test class. Django will keep a counter of the last object ID created, which means if or when a test case completes and an object gets destroyed, the counter will continue to count. This could make for a frustrating time testing and, as such, is the reason we are loading a fixture, so that we know for sure that the ID is what it should be for the object that we are testing.</p>
			<p>Now that we <a id="_idIndexMarker1183"/>have a better understanding of how<a id="_idIndexMarker1184"/> automated testing works in Django, let's introduce the DjDT next, a powerful set of tools that helps developers to debug during development.</p>
			<h1 id="_idParaDest-259"><a id="_idTextAnchor289"/>Using the DjDT</h1>
			<p>The DjDT is a <a id="_idIndexMarker1185"/>third-party package that integrates a set of configurable panels that display debug information in real time to the developer. Other third-party packages can be installed to add additional panels to this toolbar. With that in mind, you could also build your own panels too. We will only be installing the DjDT package by itself and then explaining each of its most common features, guiding you through using it, interpreting what it is showing you. To learn more about all of its capabilities, visit <a href="https://pypi.org/project/django-debug-toolbar/">https://pypi.org/project/django-debug-toolbar/</a> and <a href="https://django-debug-toolbar.readthedocs.io/en/latest/">https://django-debug-toolbar.readthedocs.io/en/latest/</a>. </p>
			<h2 id="_idParaDest-260"><a id="_idTextAnchor290"/>Installing the DjDT</h2>
			<p>To get started <a id="_idIndexMarker1186"/>with installing the DjDT, follow these steps:</p>
			<ol>
				<li value="1">Add the <code>django-debug-toolbar</code> package to your <code>requirements.txt</code> file and install it into your virtual environment via that file or run the following <code>pip</code> command, making sure your virtual environment is already active:<pre><strong class="bold">PS C:\Projects\Packt\Repo\becoming_a_django_entdev&gt; virtual_env/Scripts/activate</strong>
<strong class="bold">(virtual_env) PS &gt; pip install django-debug-toolbar</strong></pre></li>
				<li>In your <code>settings.py</code> file, add the following items to your <code>INSTALLED_APPS</code> list:<pre><strong class="bold"># /becoming_a_django_entdev/settings.py</strong>
...
INSTALLED_APPS = [
    ...
    <strong class="bold">'debug_toolbar'</strong>,
    ...
]</pre></li>
				<li>In the<a id="_idIndexMarker1187"/> same <code>settings.py</code> file, add the following middleware to the top of your <code>MIDDLEWARE</code> list:<pre><strong class="bold"># /becoming_a_django_entdev/settings.py</strong>
...
MIDDLEWARE = [
    <strong class="bold">'debug_toolbar.middleware.DebugToolbarMiddleware'</strong>,
    ...
]
...</pre></li>
			</ol>
			<p>The <code>debug_toolbar</code> app and the <code>MIDDLEWARE</code> item should be the only new items that you are adding to this file.</p>
			<ol>
				<li value="4">The <code>django.contrib.staticfiles</code> app, the <code>INTERNAL_IPS</code> list, and the <code>STATIC_URL</code> variable should have already been added in <a href="B17243_02_ePub.xhtml#_idTextAnchor037"><em class="italic">Chapter 2</em></a>, <em class="italic">Project Configuration</em>, when we created and configured the project for the first time. Note that they are required for this toolbar to work. Should you be working on a project of your own that does not follow the <code>settings.py</code> specifications of<a id="_idIndexMarker1188"/> this book, make sure that these items are included:<pre><strong class="bold"># /becoming_a_django_entdev/settings.py</strong>
...
<strong class="bold">INTERNAL_IPS</strong> = [
    <strong class="bold">'127.0.0.1',</strong>
]
INSTALLED_APPS = [
    ...
    <strong class="bold">'django.contrib.staticfiles',</strong>
    'debug_toolbar',
    ...
]
<strong class="bold">STATIC_URL = '/staticfiles/'</strong>
...</pre></li>
				<li>Next, you will need to import the URL patterns relative to this third-party app. To make sure this toolbar can be used in all chapters throughout this book, in your main <code>urls.py</code> file, add the following <code>include</code> pattern:<pre><strong class="bold"># /becoming_a_django_entdev/urls.py</strong>
...
from django.urls import ..., include, re_path
...
<strong class="bold">if settings.DEBUG:</strong>
    ...
    <strong class="bold">import debug_toolbar</strong>
    urlpatterns = [
        <strong class="bold">re_path(</strong>
            <strong class="bold">r'^__debug__/', </strong>
            <strong class="bold">include(debug_toolbar.urls)</strong>
        <strong class="bold">),</strong>
    ] + urlpatterns</pre></li>
			</ol>
			<p>Note that in the preceding example, we are placing the import under the <code>settings.DEBUG</code> conditional statement, checking whether our environment is the <code>DEBUG</code> environment. We don't ever want this toolbar to appear in a production or production-like test environment, such as staging. The development environment is usually acceptable. </p>
			<p>That's it; by <a id="_idIndexMarker1189"/>now, this toolbar should be installed and working properly. Next, let's discuss making an adjustment to work with our remote environments.</p>
			<h3>Adjusting DjDT settings</h3>
			<p>Any of the panels <a id="_idIndexMarker1190"/>that you are about to learn about have behavioral settings that can be defined in your <code>settings.py</code> file. A common example of this is how we need to use the <code>SHOW_TOOLBAR_CALLBACK</code> setting to allow us to see the DjDT in a Heroku environment. To learn more about all of the settings available, visit <a href="https://django-debug-toolbar.readthedocs.io/en/latest/configuration.html#23debug-toolbar-config">https://django-debug-toolbar.readthedocs.io/en/latest/configuration.html#debug-toolbar-config</a>.</p>
			<p>Follow these steps to activate this setting:</p>
			<ol>
				<li value="1">In the <code>settings.py</code> file, add the following code:<pre><strong class="bold"># /becoming_a_django_entdev/settings.py</strong>
...
def <strong class="bold">show_toolbar</strong>(request):
    <strong class="bold">return True</strong>
if <strong class="bold">os.getenv('SHOW_TOOLBAR_CALLBACK')</strong> == 'True':
    DEBUG_TOOLBAR_CONFIG = {
        'SHOW_TOOLBAR_CALLBACK': <strong class="bold">show_toolbar</strong>,
    }</pre></li>
			</ol>
			<p>We have to <a id="_idIndexMarker1191"/>use a callable and a variable in the <code>.env</code> file because using the <code>DEBUG_TOOLBAR_CONFIG</code> dictionary and running your automated Django test command locally will result in an error due to the DjDT package. Using either the toolbar or the Django testing commands separately will be fine without the preceding code, but when used together, this code is required.</p>
			<ol>
				<li value="2">To show this toolbar in your Heroku-hosted environments, set the following value to <code>True</code> in your <code>.env</code> file. Refer to the subsection titled <em class="italic">Remote variables</em> found in <a href="B17243_02_ePub.xhtml#_idTextAnchor037"><em class="italic">Chapter 2</em></a>, <em class="italic">Project Configuration</em>:<pre><strong class="bold"># .env</strong>
SHOW_TOOLBAR_CALLBACK=<strong class="bold">True</strong></pre></li>
				<li>Leave this value as <code>False</code> in your local environment.</li>
			</ol>
			<p>Now, let's use this toolbar.</p>
			<h2 id="_idParaDest-261"><a id="_idTextAnchor291"/>How to use the DjDT</h2>
			<p>Make sure<a id="_idIndexMarker1192"/> your virtual environment is activated and then take the following steps to use the DjDT:</p>
			<ol>
				<li value="1">Run your project using the following command, or you can use the IDE, as discussed in <a href="B17243_02_ePub.xhtml#_idTextAnchor037"><em class="italic">Chapter 2</em></a>, <em class="italic">Project Configuration</em>:<pre><strong class="bold">PS C:\Projects\Packt\Repo\becoming_a_django_entdev&gt; virtual_env/Scripts/activate</strong>
<strong class="bold">(virtual_env) PS &gt; python3 manage.py runserver</strong></pre></li>
				<li>In your browser, navigate to your home page at <a href="http://localhost:8000/">http://localhost:8000/</a> and you should see the classic home page image with the <strong class="bold">Chapter 9</strong> subtitle and now, a tab in the top right of the window, as shown in the following screenshot, with the arrow pointing to it:</li>
			</ol>
			<p class="figure-caption"> </p>
			<div><div><img src="img/Figure_9.01_B17243.jpg" alt="Figure 9.1 – DjDT – tab&#13;&#10;"/>
				</div>
			</div>
			<p class="figure-caption">Figure 9.1 – DjDT – tab</p>
			<ol>
				<li value="3">Click on this toolbar to open it and see what mysteries behold, as shown in the following screenshot:</li>
			</ol>
			<div><div><img src="img/Figure_9.02_B17243.jpg" alt="Figure 9.2 – DjDT – opened&#13;&#10;"/>
				</div>
			</div>
			<p class="figure-caption">Figure 9.2 – DjDT – opened</p>
			<p>Each item in this <a id="_idIndexMarker1193"/>toolbar can be clicked on to expand it even further. The following subsections give you a breakdown of what each panel actually shows you.</p>
			<h3>History</h3>
			<p>The <strong class="bold">History</strong> panel shows<a id="_idIndexMarker1194"/> us a list of every request that was made within this browser tab. Every time you refresh the page or navigate to a new path within your site, that information will be logged within this panel. For each item within this panel, there is a <strong class="bold">Switch</strong> button. When that button is clicked, debug information will update in the other tabs relative to that request, highlighted with arrows in the following screenshot:</p>
			<div><div><img src="img/Figure_9.03_B17243.jpg" alt="Figure 9.3 – DjDT – History tab&#13;&#10;"/>
				</div>
			</div>
			<p class="figure-caption">Figure 9.3 – DjDT – History tab</p>
			<p>When you click the <code>chapter_8</code> app URL patterns in preparation for this chapter. In this example, I am actually logged into my admin panel, showing in the <strong class="bold">SQL</strong> tab that there are three queries, then when I switch to one of the home page URLs, the <strong class="bold">SQL</strong> tab updates to tell me I now have two queries. I'll explain what these queries mean in the <em class="italic">SQL</em> subsection that follows. For now, you can at least see how this data is changing.</p>
			<h3>Versions</h3>
			<p>The <code>requirements.txt</code> file is shared with developers to automate the installation of the required packages and versions of your project. The following screenshot shows what this tab looks like, verifying that we are indeed using Django 4.0:</p>
			<div><div><img src="img/Figure_9.04_B17243.jpg" alt="Figure 9.4 – DjDT – Versions tab&#13;&#10;"/>
				</div>
			</div>
			<p class="figure-caption">Figure 9.4 – DjDT – Versions tab</p>
			<h3>Time</h3>
			<p>The <strong class="bold">Time</strong> tab only <a id="_idIndexMarker1196"/>displays the time it took to execute the current request. It doesn't actually open a new panel like the first two tabs. It's just a placeholder tab that displays useful information.</p>
			<h3>Settings</h3>
			<p>The <code>settings.py</code> variables and their computed values. This is handy if you have methods calculating values, or if you are linking many different <code>settings.py</code> files together from other packages that override or change the values in your parent file, they can all be viewed from here. The following screenshot shows you what that looks like:</p>
			<div><div><img src="img/Figure_9.05_B17243.jpg" alt="Figure 9.5 – DjDT – Settings tab&#13;&#10;"/>
				</div>
			</div>
			<p class="figure-caption">Figure 9.5 – DjDT – Settings tab</p>
			<h3>Headers</h3>
			<p>The <strong class="bold">Headers</strong> panel <a id="_idIndexMarker1198"/>displays all of the information pertaining to your HTTP request and response headers. It also displays your WSGI or ASGI environment variables at the bottom of this panel. This can be very helpful when you are working with API endpoints and you need to make sure the information in your request and response headers is as what you would expect it to be. The following screenshot shows you what this looks like:</p>
			<div><div><img src="img/Figure_9.06_B17243.jpg" alt="Figure 9.6 – DjDT – Headers tab&#13;&#10;"/>
				</div>
			</div>
			<p class="figure-caption">Figure 9.6 – DjDT – Headers tab</p>
			<h3>Request</h3>
			<p>The <strong class="bold">Request</strong> panel <a id="_idIndexMarker1199"/>shows you all of the data related to your request, such as keyword arguments and cookie and session data. This tab is very useful for checking to make sure this information is what it is expected to be. The following screenshot shows what this panel looks like:</p>
			<div><div><img src="img/Figure_9.07_B17243.jpg" alt="Figure 9.7 – DjDT – Request tab&#13;&#10;"/>
				</div>
			</div>
			<p class="figure-caption">Figure 9.7 – DjDT – Request tab</p>
			<h3>SQL</h3>
			<p>The <strong class="bold">SQL</strong> panel shows<a id="_idIndexMarker1200"/> you a very detailed and broken-down look of what each query is doing, as well as showing you all of the queries involved in a particular request. For example, if you are visiting the home page while not logged into the Django admin site, the <strong class="bold">SQL</strong> tab will tell you there are zero queries, as depicted in <em class="italic">Figure 9.2</em>. However, if you are logged into the Django admin site and are visiting the home page, you should see at least two queries under the <strong class="bold">SQL</strong> tab. When you click on this tab, you will see what those two queries are, as shown in the following screenshot:</p>
			<div><div><img src="img/Figure_9.08_B17243.jpg" alt="Figure 9.8 – DjDT – SQL tab&#13;&#10;"/>
				</div>
			</div>
			<p class="figure-caption">Figure 9.8 – DjDT – SQL tab</p>
			<p>Here, we can see the first query establishes a session for the current request and then queries the object of the user logged into the system. That user object is a <code>Seller</code> model object because of how we extended the <code>User</code> model in <a href="B17243_03_ePub.xhtml#_idTextAnchor077"><em class="italic">Chapter 3</em></a>, <em class="italic">Models, Relations, and Inheritance</em>. Each query also has a <strong class="bold">Sel</strong> and <strong class="bold">Expl</strong> button, which provide other details about that query. Clicking the plus sign, found to the left of any one of these queries expands even more, giving you information about that query, including traceback<a id="_idIndexMarker1201"/> information, as shown:</p>
			<div><div><img src="img/Figure_9.09_B17243.jpg" alt="Figure 9.9 – DjDT – SQL tab expanded&#13;&#10;"/>
				</div>
			</div>
			<p class="figure-caption">Figure 9.9 – DjDT – SQL tab expanded</p>
			<h3>Static files</h3>
			<p>The <strong class="bold">Static files</strong> panel <a id="_idIndexMarker1202"/>displays all of the apps installed that actually contain static files. The middle section lists all of the static files related to the current request. You can actually click on them to open and view them in the current or a new tab. The last section in this panel displays a list of all of the static files found in all of the apps that are installed. This can sometimes be helpful if you are comparing a static file that overrides the same static file of another app, you can see which one is used and which ones are ignored. The following screenshot shows you what this panel looks like:</p>
			<div><div><img src="img/Figure_9.10_B17243.jpg" alt="Figure 9.10 – DjDT – Static files tab&#13;&#10;"/>
				</div>
			</div>
			<p class="figure-caption">Figure 9.10 – DjDT – Static files tab</p>
			<p>Here, we can <a id="_idIndexMarker1203"/>see that the only static file being used on this page is the <code>home_page.jpg</code> file. Since the <code>index.html</code> file is not extending the <code>base_template_1.html</code> file, we don't have any CSS or JavaScript files used on this page; they do not get loaded. Should you activate the DjDT and go back to previous chapters, you will likely see those additional assets because we were using the <code>base_template_1.html</code> file. Any debug tools, such as CSS and JavaScript files related to the DjDT, will not be shown in the middle section. The idea is that those are debug-related assets and we don't need to know that on the page that we are debugging. Should you inspect a page using your browser tools, you will see assets related to the DjDT; they will not appear in production.</p>
			<h3>Templates</h3>
			<p>The <strong class="bold">Templates</strong> panel <a id="_idIndexMarker1204"/>displays information related to the templates used and the context that is available. The middle section displays all of the templates. If you had partial HTML files using includes or extends, each one of those templates would appear in this list in the order that they are used. When you click on the <strong class="bold">Toggle context</strong> arrow, shown in the following screenshot, it will display a list of all of the context variables and their values related to that file:</p>
			<div><div><img src="img/Figure_9.11_B17243.jpg" alt="Figure 9.11 – DjDT – Templates tab&#13;&#10;"/>
				</div>
			</div>
			<p class="figure-caption">Figure 9.11 – DjDT – Templates tab</p>
			<p>The following screenshot depicts what clicking the <strong class="bold">Toggle context</strong> button looks like, showing us the context available in that particular template or partial file:</p>
			<div><div><img src="img/Figure_9.12_B17243.jpg" alt="Figure 9.12 – DjDT – Templates tab showing context&#13;&#10;"/>
				</div>
			</div>
			<p class="figure-caption">Figure 9.12 – DjDT – Templates tab showing context</p>
			<p>At the bottom of this panel is where all of the context processors are located. You can view the <a id="_idIndexMarker1205"/>context available in each of the context processors available.</p>
			<h3>Cache</h3>
			<p>The <strong class="bold">Cache</strong> panel<a id="_idIndexMarker1206"/> displays all of the cached objects involved with this page. This is if you are using tools that help enhance the performance of your database. This is considered an advanced topic beyond the scope of this book.</p>
			<p class="callout-heading">Note</p>
			<p class="callout">The DjDT publisher also notes in their own documentation that this panel is incompatible with Django's per-site caching.</p>
			<h3>Signals</h3>
			<p>The <strong class="bold">Signals</strong> panel <a id="_idIndexMarker1207"/>displays the notifiers and receivers within an application that are communicating with each other. These can be closely compared to what <strong class="bold">WebSocket</strong> is. This is also considered an advanced topic beyond the scope of this book.</p>
			<h3>Logging</h3>
			<p>The <code>logging</code> library. Before showing how this panel looks, let's wire up an actual log to view. As with the Django messages framework, the logging system has different levels of messages. The default minimum log level is <code>WARNING</code> but you can show <code>DEBUG</code>- and <code>INFO</code>-level logs the same way, either by setting it in your <code>settings.py</code> file or by declaring it inline where your log is set, as we are going to do in the following steps. To learn more about all of the capabilities of using the logging system, visit <a href="https://docs.djangoproject.com/en/4.0/topics/logging/">https://docs.djangoproject.com/en/4.0/topics/logging/</a> and <a href="https://docs.python.org/3/library/logging.html">https://docs.python.org/3/library/logging.html</a>.</p>
			<p>Take the following steps to practice using the logging system:</p>
			<ol>
				<li value="1">In your <code>/chapter_4/views.py</code> file, add the following log statements at the beginning of the existing <code>practice_year_view()</code>:<pre><strong class="bold"># /becoming_a_django_entdev/chapter_4/views.py</strong>
...
import <strong class="bold">logging</strong>
def <strong class="bold">practice_year_view</strong>(request, year):
    <strong class="bold">logger = logging.getLogger(__name__)</strong>
    <strong class="bold">logger.setLevel(logging.INFO)</strong>
    <strong class="bold">logger.info('The Requested Year Is: %s' % year)</strong>
    ...</pre></li>
			</ol>
			<p>The first two<a id="_idIndexMarker1209"/> lines lower the logging level to show all <code>INFO</code>-level logs and higher, allowing us to use the <code>logger.info()</code> method to create the log message. Otherwise, the lowest level we could use by default would be the <code>logger.warning()</code> level method. The log message we are expecting to see should be <code>The Requested Year Is: 2022</code> when visiting the URL. </p>
			<ol>
				<li value="2">Now, navigate to <a href="http://localhost:8000/my_year_path/2022/">http://localhost:8000/my_year_path/2022/</a> in your browser and expand the debug toolbar. Open the <strong class="bold">Logging</strong> tab and now you should see the log that we created, as depicted in the following screenshot:</li>
			</ol>
			<div><div><img src="img/Figure_9.13_B17243.jpg" alt="Figure 9.13 – DjDT – Logging tab&#13;&#10;"/>
				</div>
			</div>
			<p class="figure-caption">Figure 9.13 – DjDT – Logging tab</p>
			<h3>Intercept redirects</h3>
			<p>The <strong class="bold">Intercept redirects</strong> checkbox <a id="_idIndexMarker1210"/>is used to display an intermediary page whenever a redirect is performed to display information about that redirect, before the browser is updated with the redirected page.</p>
			<h3>Profiling</h3>
			<p>The <strong class="bold">Profiling</strong> checkbox<a id="_idIndexMarker1211"/> enables the gathering of extra data on page load. It is a detailed analysis of memory and CPU processes taking place. Each process is broken down into the smallest measurements possible. By default, this checkbox is left unchecked. An example of what this looks like is shown in the following screenshot:</p>
			<div><div><img src="img/Figure_9.14_B17243.jpg" alt="Figure 9.14 – DjDT – Profiling tab&#13;&#10;"/>
				</div>
			</div>
			<p class="figure-caption">Figure 9.14 – DjDT – Profiling tab</p>
			<p>We now have a deeper understanding of all of the tabs available within the DjDT and what they are used for. This now adds a wealth of tools to our toolbox to help us make world-class applications with ease.</p>
			<h1 id="_idParaDest-262"><a id="_idTextAnchor292"/>Summary</h1>
			<p>By now, we have developed a solid understanding of how automated testing in Django is performed. We wrote several test cases that test many of the exercises done in previous chapters. We practiced writing test cases that simulate success and others that deliberately trigger a failure to better understand what is happening. We even discovered how to write test cases that work with the Django REST framework. After we worked with automated testing, we then installed what I would consider the most powerful tool of them all, the DjDT. The DjDT is used for real-time debugging of developers' code as they write that code and run their projects locally. </p>
			<p>In the next chapter, we will learn how to use the DjDT to monitor performance as we learn how to optimize database queries.</p>
		</div>
	</body></html>