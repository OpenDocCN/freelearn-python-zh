<html><head></head><body>
		<div id="_idContainer142">
			<h1 id="_idParaDest-244"><em class="italic"><a id="_idTextAnchor272"/>Chapter 9</em>: Django Testing</h1>
			<p>This chapter is dedicated to testing and debugging a Django project. Django has a wide range of test classes built into its framework that are used to write automated test scripts. As we build each app and/or component of a project, we can run one command at any time to ensure that every component still works as it should. This is great for <strong class="bold">regression testing</strong>, which<a id="_idIndexMarker1119"/> means testing a new or changed component, making sure that it does not affect the intended behavior of existing components or the entire system as a whole. For most of what we will cover in this chapter, we do not need to install any third-party packages. The last thing we will cover is the <strong class="bold">Django Debug Toolbar</strong> (<strong class="bold">DjDT</strong>), which<a id="_idIndexMarker1120"/> does require us to install a third-party package to use.</p>
			<p>In this chapter, we will cover the following topics:</p>
			<ul>
				<li>Writing automated test scripts</li>
				<li>Creating unit test cases</li>
				<li>Testing view classes and their get and post methods</li>
				<li>Testing view classes that require user authentication</li>
				<li>Testing Django REST API endpoints</li>
				<li>Installing the DjDT, a tool used for debugging</li>
			</ul>
			<h1 id="_idParaDest-245"><a id="_idTextAnchor273"/>Technical requirements</h1>
			<p>To work with the code in this chapter, the following tools will need to be installed on your local machine:</p>
			<ul>
				<li>Python version 3.9 – used as the underlying programming language for the project</li>
				<li>Django version 4.0 – used as the backend framework of the project</li>
				<li>pip package manager – used to manage third-party Python/Django packages</li>
			</ul>
			<p>We will continue to work with the solution created in <a href="B17243_02_ePub.xhtml#_idTextAnchor037"><em class="italic">Chapter 2</em></a>, <em class="italic">Project Configuration</em>. However, it is not necessary to use the Visual Studio IDE. The main project itself can be run using another IDE or run independently using a terminal or command-line window from within the project root folder, which is where the <strong class="source-inline">manage.py</strong> file resides. Whatever editor or IDE you are using, a virtual environment will also be needed to work with the Django project. Instructions for how to create a project and virtual environment can be found in <a href="B17243_02_ePub.xhtml#_idTextAnchor037"><em class="italic">Chapter 2</em></a>, <em class="italic">Project Configuration</em>. You will need a database to store the data contained in your project. PostgreSQL was chosen for the examples in the previous chapters; however, any database type that you choose for your project can be used to work with the examples in this chapter.</p>
			<p>We will also be using data that is in the form of a Django fixture, provided in <a href="B17243_03_ePub.xhtml#_idTextAnchor077"><em class="italic">Chapter 3</em></a>, <em class="italic">Models, Relations, and Inheritance</em>, in the subsection titled <em class="italic">Loading the chapter_3 data fixture</em>. Make sure the <strong class="source-inline">chapter_3</strong> fixture is loaded into your database. If this has already been done, then you may skip the next command. If you have already created the tables found in <a href="B17243_03_ePub.xhtml#_idTextAnchor077"><em class="italic">Chapter 3</em></a>, <em class="italic">Models, Relations, and Inheritance</em>, and have not loaded that fixture yet, then run the following command, after activating your virtual environment:</p>
			<p class="source-code">(virtual_env) PS &gt; python manage.py loaddata chapter_3</p>
			<p>All of the code created in this chapter can be found in the GitHub repository for this book: <a href="https://github.com/PacktPublishing/Becoming-an-Enterprise-Django-Developer">https://github.com/PacktPublishing/Becoming-an-Enterprise-Django-Developer</a>. The bulk of the code depicted in this chapter can be found in the <strong class="source-inline">/becoming_a_django_entdev/becoming_a_django_entdev/chapter_9/</strong> directory.</p>
			<p>Check out the following video to see the <em class="italic">Code in Action</em>: <a href="https://bit.ly/3yh0tW6">https://bit.ly/3yh0tW6</a>.</p>
			<h1 id="_idParaDest-246"><a id="_idTextAnchor274"/>Preparing for this chapter</h1>
			<p>Start by creating a new app in your project called <strong class="source-inline">chapter_9</strong> by following the steps discussed in <a href="B17243_02_ePub.xhtml#_idTextAnchor037"><em class="italic">Chapter 2</em></a>, <em class="italic">Project Configuration</em>, in the subsection titled <em class="italic">Creating a Django app</em>. As discussed in that section, don't forget to change the value of the <strong class="source-inline">name =</strong> variable for your app class found in the <strong class="source-inline">/becoming_a_django_entdev/becoming_a_django_entdev/chapter_9/apps.py</strong> file to now point to the path where you installed your app. Be sure to also include this app in the <strong class="source-inline">INSTALLED_APPS</strong> variable found in the <strong class="source-inline">settings.py</strong> file as well.</p>
			<p>In the main <strong class="source-inline">urls.py</strong> file of the site, add the following two paths:</p>
			<pre class="source-code"><strong class="bold"># /becoming_a_django_entdev/urls.py</strong></pre>
			<pre class="source-code">...</pre>
			<pre class="source-code">urlpatterns = [</pre>
			<pre class="source-code">    <strong class="bold">path(</strong></pre>
			<pre class="source-code">        <strong class="bold">'',   </strong></pre>
			<pre class="source-code">        <strong class="bold">include(</strong></pre>
			<pre class="source-code">            <strong class="bold">'becoming_a_django_entdev.chapter_9.urls'</strong></pre>
			<pre class="source-code">        <strong class="bold">)</strong></pre>
			<pre class="source-code">    <strong class="bold">)</strong>,</pre>
			<pre class="source-code">    <strong class="bold">path(</strong></pre>
			<pre class="source-code">        <strong class="bold">'',   </strong></pre>
			<pre class="source-code">        <strong class="bold">include(</strong></pre>
			<pre class="source-code">            <strong class="bold">'becoming_a_django_entdev.chapter_8.urls'</strong></pre>
			<pre class="source-code">        <strong class="bold">)</strong></pre>
			<pre class="source-code">    <strong class="bold">)</strong>,</pre>
			<pre class="source-code">]</pre>
			<p>These point to the <a href="B17243_09_ePub.xhtml#_idTextAnchor272"><em class="italic">Chapter 9</em></a> URL patterns that we will be creating for this chapter and includes all of the URL patterns that we created for <a href="B17243_08_ePub.xhtml#_idTextAnchor239"><em class="italic">Chapter 8</em></a>, <em class="italic">Working with the Django REST Framework</em>. We will need the API endpoints that we created in the previous chapter for some of the REST API test exercises. Make sure the <a href="B17243_09_ePub.xhtml#_idTextAnchor272"><em class="italic">Chapter 9</em></a> URLs take precedence over the other by placing them first in this list.</p>
			<p>In your <strong class="source-inline">/chapter_9/urls.py</strong> file, you should add the following paths. These paths were used in the exercises in <a href="B17243_04_ePub.xhtml#_idTextAnchor116"><em class="italic">Chapter 4</em></a>, <em class="italic">URLs, Views, and Templates</em>: </p>
			<pre class="source-code"><strong class="bold"># /becoming_a_django_entdev/chapter_9/urls.py </strong></pre>
			<pre class="source-code">from django.urls import path, register_converter</pre>
			<pre class="source-code">from django.views.generic import TemplateView</pre>
			<pre class="source-code">from ..chapter_4.converters import <strong class="bold">YearConverter</strong> </pre>
			<pre class="source-code">from ..chapter_4.views import (</pre>
			<pre class="source-code">    <strong class="bold">practice_year_view</strong>,</pre>
			<pre class="source-code">    <strong class="bold">VehicleView</strong></pre>
			<pre class="source-code">)</pre>
			<pre class="source-code">register_converter(<strong class="bold">YearConverter</strong>, 'year') </pre>
			<pre class="source-code">urlpatterns = [</pre>
			<pre class="source-code">    path(</pre>
			<pre class="source-code">        '',  </pre>
			<pre class="source-code">        TemplateView.as_view(</pre>
			<pre class="source-code">            template_name = 'chapter_9/index.html'</pre>
			<pre class="source-code">        )</pre>
			<pre class="source-code">    ),</pre>
			<pre class="source-code">    path(</pre>
			<pre class="source-code">        <strong class="bold">'my_year_path/&lt;year:year&gt;/',</strong></pre>
			<pre class="source-code">        <strong class="bold">practice_year_view</strong>, </pre>
			<pre class="source-code">        name = 'year_url'</pre>
			<pre class="source-code">    ),</pre>
			<pre class="source-code">    path(</pre>
			<pre class="source-code">        <strong class="bold">'vehicle/&lt;int:id&gt;/',</strong></pre>
			<pre class="source-code">        <strong class="bold">VehicleView</strong>.as_view(), </pre>
			<pre class="source-code">        name = 'vehicle-detail'</pre>
			<pre class="source-code">    ),</pre>
			<pre class="source-code">]</pre>
			<p>Instead of including all of the URLs from <a href="B17243_04_ePub.xhtml#_idTextAnchor116"><em class="italic">Chapter 4</em></a>, <em class="italic">URLs, Views, and Templates</em>, we are only providing you with the ones that are needed. The reason behind this is that in <a href="B17243_04_ePub.xhtml#_idTextAnchor116"><em class="italic">Chapter 4</em></a>, <em class="italic">URLs, Views, and Templates</em>, we discussed several variations of writing the same paths for learning purposes. To prevent confusion, only the variation of the URL patterns that are needed to satisfy the type of tests that we are about to perform is included in the preceding code.</p>
			<p>Copy the <strong class="source-inline">index.html</strong> file from the code of the book found in the <strong class="source-inline">/chapter_9/templates/chapter_9</strong> directory into your project in the same directory. Also, copy the <strong class="source-inline">chapter_9</strong> CSS and JavaScript files from the code of the book into your project.</p>
			<p class="callout-heading">Note</p>
			<p class="callout">If you cloned the entire repository of code provided with this book and the DjDT is already turned on/enabled, please disable it before running any of the test cases that we will soon create. Look for the <strong class="bold">Turn Off/Comment Out For the First Half of Chapter 9</strong> comments throughout the settings and URL files. That tool will be discussed after working through some test cases.</p>
			<p>Next, let's discuss what automated testing is in Django and how it is used. </p>
			<h1 id="_idParaDest-247"><a id="_idTextAnchor275"/>Understanding automated testing in Django</h1>
			<p>Automated<a id="_idIndexMarker1121"/> testing <a id="_idIndexMarker1122"/>is helpful for a number of reasons. Developers use it when refactoring old components that need to be modified. Test scripts are used to regression test older components to see whether they were affected negatively by any new additions. Django offers several test classes that are an extension of the standard Python library called <strong class="source-inline">unittest</strong>. You can learn more about this package here: <a href="https://docs.python.org/3/library/unittest.html">https://docs.python.org/3/library/unittest.html</a>. The Django test classes are all found in the <strong class="source-inline">django.test</strong> library. The most commonly used class is <strong class="source-inline">TestCase</strong>.</p>
			<p>The following list depicts all of the test classes that are available in the <strong class="source-inline">django.test</strong> library:</p>
			<ul>
				<li><strong class="bold">SimpleTestCase</strong> – this is<a id="_idIndexMarker1123"/> the smallest test possible, extending the Python <strong class="source-inline">unittest</strong> library. This class will not interact with a database.</li>
				<li><strong class="bold">TransactionTestCase</strong> – this test extends the <strong class="source-inline">SimpleTestCase</strong> class and allows for database transactions.</li>
				<li><strong class="bold">TestCase</strong> – this test extends the <strong class="source-inline">TransactionTestCase</strong> class and includes features that allow for better interactions with a database. It is the most commonly used test class.</li>
				<li><strong class="bold">LiveServerTestCase</strong> – this test extends the <strong class="source-inline">TransactionTestCase</strong> class and allows the use of test clients other than the test client provided by Django, such as Appium, Cypress, Selenium, Serenity, or any of the dozens of other ones available. It will actually spin up a live Django server in the background to run the test and then destroy that server upon completion.</li>
				<li><strong class="bold">SeleniumTestCase</strong> – this test extends the <strong class="source-inline">LiveServerTestCase</strong> class. This class is built specifically for using the Selenium test framework as the test client due to how popular it is.</li>
			</ul>
			<p>Writing test <a id="_idIndexMarker1124"/>classes is just like writing any other Python class. They <a id="_idIndexMarker1125"/>must consist of at least a test method, and they usually contain a <strong class="source-inline">setUp()</strong> method, but this method is not required. Test methods have the word <strong class="source-inline">test_</strong> prepended to their name, for example, <strong class="source-inline">test_one()</strong> and <strong class="source-inline">test_two()</strong>. The <strong class="source-inline">setUp()</strong> method is used to prepare your environment and/or database for any of the test methods in that class. If a class has more than one test method, an object created in one test method will not be accessible in the other test method. If you need an object in both test methods of a class, you need to place that logic in the <strong class="source-inline">setUp()</strong> method. </p>
			<p>Test classes may also have a <strong class="source-inline">tearDown()</strong> method, which will perform any cleanup tasks necessary after a test has been performed and before moving on to the next test. <strong class="source-inline">tearDown()</strong> is not used very often seeing as Django will automatically destroy any servers and databases created during the test after the test has completed. Other methods are available as well and you can learn more about them here: <a href="https://docs.djangoproject.com/en/4.0/topics/testing/tools/">https://docs.djangoproject.com/en/4.0/topics/testing/tools/</a>. </p>
			<p class="callout-heading">Tip</p>
			<p class="callout">Selenium is a third-party library of tools that simulates actual browsers, allowing you to run automated tests in many different browser types and versions. It is not necessary to perform basic/standard test cases and this is considered an advanced topic beyond the scope of this book. To learn more about Selenium, visit <a href="https://www.selenium.dev/">https://www.selenium.dev/</a>, <a href="https://pypi.org/project/selenium/">https://pypi.org/project/selenium/</a>, and <a href="https://django-selenium.readthedocs.io/en/latest/">https://django-selenium.readthedocs.io/en/latest/</a>.</p>
			<p>Every time a new app is created in Django, such as when all of the chapter apps were created prior to this chapter, you may have noticed that a <strong class="source-inline">tests.py</strong> file was automatically created for you in that app directory. This file is created whether you are using the IDE or command line to create the new app. We have just been disregarding this file as it served no purpose to us, until now. The code in this chapter will live almost entirely within the <strong class="source-inline">tests.py</strong> file. If you are using the Visual Studio IDE, you may have also noticed that it created a <strong class="source-inline">SimpleTest(TestCase)</strong> class in your <strong class="source-inline">tests.py</strong> file. Apps created through the command-line window or terminal will not have created this class for you. Go <a id="_idIndexMarker1126"/>ahead and comment this out or delete it before<a id="_idIndexMarker1127"/> proceeding so that we only see the results pertaining to the test(s) at hand.</p>
			<p>Now that we have a better understanding of how tests are performed, let's dive in and begin testing next.</p>
			<h1 id="_idParaDest-248"><a id="_idTextAnchor276"/>Getting started with unit testing</h1>
			<p><strong class="bold">Unit testing</strong> is the act<a id="_idIndexMarker1128"/> of testing the smallest components possible, such as logic statements, for example, 1 + 1 equals 2. That is what the <strong class="source-inline">SimpleTest</strong> class that the Visual Studio IDE created for us is actually testing for. These can be utility methods, conditional or comparison statements, Django models, forms, email messages, and so on. </p>
			<p>Let's practice writing a simple test script and then write another to include our models.</p>
			<h2 id="_idParaDest-249"><a id="_idTextAnchor277"/>Basic unit test script</h2>
			<p>In this exercise, we <a id="_idIndexMarker1129"/>will write a very basic test class that executes two different test methods. These tests will not interact with a database and are only used to compare <strong class="source-inline">True</strong> and <strong class="source-inline">False</strong> statements. The class as a whole can be used as a boilerplate when creating new test classes and modified as needed. </p>
			<p>Follow these steps:</p>
			<ol>
				<li>In your <strong class="source-inline">/chapter_9/tests.py</strong> file, add the structure of the class, as shown:<p class="source-code"><strong class="bold"># /becoming_a_django_entdev/chapter_9/tests.py</strong></p><p class="source-code">from django.test import <strong class="bold">SimpleTestCase</strong></p><p class="source-code">class <strong class="bold">TestingCalibrator</strong>(<strong class="bold">SimpleTestCase</strong>):</p><p class="source-code">    def <strong class="bold">setUp</strong>(self):</p><p class="source-code">        pass</p><p class="source-code">    def <strong class="bold">tearDown</strong>(self):</p><p class="source-code">        pass</p><p class="source-code">    def <strong class="bold">test_pass</strong>(self):</p><p class="source-code">        '''Checks if True == True, Value set to </p><p class="source-code">            True'''</p><p class="source-code">        self.assertTrue(True)</p><p class="source-code">    def <strong class="bold">test_fail</strong>(self):</p><p class="source-code">        '''Checks if False == False, Value set to </p><p class="source-code">            True'''</p><p class="source-code">        self.assertFalse(True)</p></li>
			</ol>
			<p>The <strong class="source-inline">test_pass(self)</strong> method is used to compare whether <strong class="source-inline">True</strong> actually equals <strong class="source-inline">True</strong> when <strong class="source-inline">True</strong> is passed into the function; it is intended to be a successful test. The <strong class="source-inline">test_fail(self)</strong> method is used to compare whether <strong class="source-inline">False</strong> equals <strong class="source-inline">False</strong> when <strong class="source-inline">True</strong> is passed into the function; it is intended to produce a failure. </p>
			<ol>
				<li value="2">Now, in your command-line window or terminal, navigate to your project's root directory and activate your virtual environment but do not run the project at this time. Instead, execute the Django test command depicted in the following code, which will only execute the tests found in your <strong class="source-inline">chap<a id="_idTextAnchor278"/>ter_9</strong> app:<p class="source-code"><strong class="bold">(virtual_env) PS &gt; python manage.py test becoming_a_django_entdev.chapter_9</strong></p></li>
			</ol>
			<p>If everything runs as intended in this exercise, it should tell you in your command-line<a id="_idIndexMarker1130"/> window that two tests were performed and which one failed, as shown:</p>
			<p class="source-code"><strong class="bold">Found 2 test(s).</strong></p>
			<p class="source-code"><strong class="bold">System check identified no issues (0 silenced).</strong></p>
			<p class="source-code"><strong class="bold">F.</strong></p>
			<p class="source-code"><strong class="bold">======================================================</strong></p>
			<p class="source-code"><strong class="bold">FAIL: test_fail (becoming_a_django_entdev.chapter_9.tests.TestingCalibrator)</strong></p>
			<p class="source-code"><strong class="bold">Checks if False == False, Value set to True</strong></p>
			<p class="source-code"><strong class="bold">------------------------------------------------------</strong></p>
			<p class="source-code"><strong class="bold">Traceback (most recent call last):</strong></p>
			<p class="source-code"><strong class="bold">  File "C:\Projects\Packt\Repo\becoming_a_django_entdev\becoming_a_django_entdev\chapter_9\tests.py", line 49, in test_fail</strong></p>
			<p class="source-code"><strong class="bold">    self.assertFalse(True)</strong></p>
			<p class="source-code"><strong class="bold">AssertionError: True is not false</strong></p>
			<p class="source-code"><strong class="bold">------------------------------------------------------</strong></p>
			<p class="source-code"><strong class="bold">Ran 2 tests in 0.001s</strong></p>
			<p class="source-code"><strong class="bold">FAILED (failures=1)</strong></p>
			<p class="source-code"><strong class="bold">Destroying test database for alias 'default'...</strong></p>
			<p>On the third line in the preceding output, it printed <strong class="source-inline">F.</strong>. The capital <strong class="source-inline">F</strong> represents one test was a failure and the period represents one test was a success. It then prints each of the tests that failed below that line. For each test that it prints out, Django includes the comment written for that test case, such as <strong class="source-inline">'''Checks if False == False, Value set to True'''</strong>. Make use of the triple double-quote or single-quote comment notation to include helpful information when your test does fail. It then provides traceback information, indicating the cause and location of the error or failure. You can also<a id="_idIndexMarker1131"/> include <strong class="source-inline">print()</strong> statements within these test methods if you want to provide additional information regarding a particular test.</p>
			<p class="callout-heading">Tip</p>
			<p class="callout">To run the tests for all of the apps included in your project, run the following command:<strong class="source-inline">(virtual_env) PS &gt; python manage.py test</strong></p>
			<p class="callout">Also, if you break your single-line double-quote or single-quote comment into a multiline comment, only the first line of that comment will appear in your command-line window.</p>
			<p>Now, comment out or delete the <strong class="source-inline">TestingCalibrator</strong> class before moving on to the next exercise.</p>
			<h2 id="_idParaDest-250"><a id="_idTextAnchor279"/>Testing Django models</h2>
			<p>In this exercise, we will<a id="_idIndexMarker1132"/> use the <strong class="source-inline">TestCase</strong> class because we will be connecting to a database. The database that the test client spins up for us will not affect any of the data found in all local or remote databases. Follow these steps:</p>
			<ol>
				<li value="1">In your <strong class="source-inline">/chapter_3/models.py</strong> file, make sure the (8, 'Jeep')  value exists in the <strong class="source-inline">MAKE_CHOICES</strong> list of choices:<p class="source-code"><strong class="bold"># /becoming_a_django_entdev/chapter_3/models.py</strong></p><p class="source-code">...</p><p class="source-code"><strong class="bold">MAKE_CHOICES</strong> = (</p><p class="source-code">    ...</p><p class="source-code">    <strong class="bold">(8, 'Jeep'),</strong></p><p class="source-code">    ...</p><p class="source-code">)</p></li>
				<li>In your <strong class="source-inline">/chapter_9/tests.py</strong> file, add the following <strong class="source-inline">import</strong> statements:<p class="source-code"><strong class="bold"># /becoming_a_django_entdev/chapter_9/tests.py</strong></p><p class="source-code">from django.test import ..., <strong class="bold">TestCase</strong></p><p class="source-code">from djmoney.money import <strong class="bold">Money</strong></p><p class="source-code">from ..chapter_3.models import (</p><p class="source-code">    <strong class="bold">Engine</strong>,</p><p class="source-code">    <strong class="bold">Seller</strong>,</p><p class="source-code">    <strong class="bold">Vehicle</strong>,</p><p class="source-code">    <strong class="bold">VehicleModel</strong></p><p class="source-code">)</p></li>
				<li>In that same file, add the following class and <strong class="source-inline">setUp()</strong> method:<p class="source-code"><strong class="bold"># /becoming_a_django_entdev/chapter_9/tests.py</strong></p><p class="source-code">...</p><p class="source-code">class <strong class="bold">ModelUnitTestCase</strong>(<strong class="bold">TestCase</strong>):</p><p class="source-code">    def setUp(self):</p><p class="source-code">        model = <strong class="bold">VehicleModel</strong>.objects.create(</p><p class="source-code">            name = 'Grand Cherokee Laredo 4WD',</p><p class="source-code">            make = 8</p><p class="source-code">        )</p><p class="source-code">        engine = <strong class="bold">Engine</strong>.objects.create(</p><p class="source-code">            name = '3.6L FI FFV DO',</p><p class="source-code">            vehicle_model = model</p><p class="source-code">        )</p><p class="source-code">        vehicle = <strong class="bold">Vehicle</strong>.objects.create(</p><p class="source-code">            vin = 'aa890123456789012',</p><p class="source-code">            sold = False,</p><p class="source-code">            price = <strong class="bold">Money</strong>(39875, 'USD'),</p><p class="source-code">            make = 8,</p><p class="source-code">            vehicle_model = model,</p><p class="source-code">            engine = engine</p><p class="source-code">        )</p><p class="source-code">        seller = <strong class="bold">Seller</strong>.objects.create_user(</p><p class="source-code">            'test',</p><p class="source-code">            'testing@example.com',</p><p class="source-code">            'testpassword',</p><p class="source-code">            is_staff = True,</p><p class="source-code">            is_superuser = True,</p><p class="source-code">            is_active = True,</p><p class="source-code">            name = 'Chapter 9 Seller 1'</p><p class="source-code">        )</p><p class="source-code">        seller.vehicles.set([vehicle])</p></li>
				<li>In that same <strong class="source-inline">ModelUnitTestCase</strong> class, add the following test method:<p class="source-code"><strong class="bold"># /becoming_a_django_entdev/chapter_9/tests.py</strong></p><p class="source-code">...</p><p class="source-code">class <strong class="bold">ModelUnitTestCase</strong>(<strong class="bold">TestCase</strong>):</p><p class="source-code">    ...</p><p class="source-code">    def <strong class="bold">test_full_vehicle_name</strong>(self):</p><p class="source-code">        vehicle_1 = <strong class="bold">Vehicle</strong>.objects.get(</p><p class="source-code">            vin = 'aa890123456789012'</p><p class="source-code">        )</p><p class="source-code">        <strong class="bold">self.assertEqual</strong>(</p><p class="source-code">            vehicle_1.<strong class="bold">full_vehicle_name()</strong>,</p><p class="source-code">            'Jeep Grand Cherokee Laredo 4WD - 3.6L FI </p><p class="source-code">                FFV DO'</p><p class="source-code">        )</p></li>
			</ol>
			<p>The <a id="_idIndexMarker1133"/>preceding <strong class="source-inline">setUp(self)</strong> method will create a <strong class="source-inline">VehicleModel</strong>, <strong class="source-inline">Engine</strong>, <strong class="source-inline">Vehicle</strong>, and <strong class="source-inline">Seller</strong> model object that we imported from the <strong class="source-inline">chapter_3</strong> app. The <strong class="source-inline">setUp()</strong> method creates these objects before any of the test cases in that class are executed. We create each related object as a variable and then use that variable to assign as the related object of the next object that we create. The <strong class="source-inline">Seller</strong> object uses the same <strong class="source-inline">create_user()</strong> method that was introduced in <a href="B17243_06_ePub.xhtml#_idTextAnchor190"><em class="italic">Chapter 6</em></a>, <em class="italic">Exploring the Django Admin Site</em>, to create a new <strong class="source-inline">Seller</strong> with the hashed password and date fields formatted for us. We created only one test, called <strong class="source-inline">test_full_vehicle_name()</strong>, which looks up the vehicle that was created upon setup by the vin field value specified. It uses the <strong class="source-inline">full_vehicle_name()</strong> method that we created in <a href="B17243_03_ePub.xhtml#_idTextAnchor077"><em class="italic">Chapter 3</em></a>, <em class="italic">Models, Relations, and Inheritance</em>, to return to us the custom-formatted name of that newly created vehicle. The expected value is <strong class="source-inline">Jeep Grand Cherokee Laredo 4WD - 3.6L FI FFV DO</strong>, which is in the format <strong class="source-inline">{{ make }} {{ model }} – {{ engine }}</strong>. If the resulting value does not match that value, the test will fail.</p>
			<ol>
				<li value="5">Now, execute the run test command shown here:<p class="source-code"><strong class="bold">(virtual_env) PS &gt; python manage.py test becoming_a_django_entdev.chapter_9</strong></p></li>
			</ol>
			<p>If you commented <a id="_idIndexMarker1134"/>out all the other tests prior to this one, you should see the results shown here:</p>
			<p class="source-code"><strong class="bold">Found 1 test(s).</strong></p>
			<p class="source-code"><strong class="bold">Creating test database for alias 'default'...</strong></p>
			<p class="source-code"><strong class="bold">System check identified no issues (0 silenced).</strong></p>
			<p class="source-code"><strong class="bold">.</strong></p>
			<p class="source-code"><strong class="bold">------------------------------------------------------</strong></p>
			<p class="source-code"><strong class="bold">Ran 1 test in 0.229s</strong></p>
			<p class="source-code"><strong class="bold">OK</strong></p>
			<p class="source-code"><strong class="bold">Destroying test database for alias 'default'...</strong></p>
			<ol>
				<li value="6">Go ahead and change the expected value found in the <strong class="source-inline">self.assertEqual()</strong> function of <em class="italic">step 4</em> previously to something that doesn't exist, and then rerun your test command one more time. Now, you should see a failure message, as depicted here:<p class="source-code"><strong class="bold">Found 1 test(s).</strong></p><p class="source-code"><strong class="bold">Creating test database for alias 'default'...</strong></p><p class="source-code"><strong class="bold">System check identified no issues (0 silenced).</strong></p><p class="source-code"><strong class="bold">F</strong></p><p class="source-code"><strong class="bold">======================================================</strong></p><p class="source-code"><strong class="bold">FAIL: test_full_vehicle_name </strong></p><p class="source-code"><strong class="bold">------------------------------------------------------</strong></p><p class="source-code"><strong class="bold">Traceback (most recent call last):</strong></p><p class="source-code"><strong class="bold">  File "C:\Projects\Packt\Repo\becoming_a_django_entdev\becoming_a_django_entdev\chapter_9\tests.py", line 88, in test_full_vehicle_name</strong></p><p class="source-code"><strong class="bold">    self.assertEqual(vehicle_1.full_vehicle_name(), 'Jeep Grand Cherokee Laredo 4WD - 3.6L FI FFV DO asdfasdfas') # Incorrect Value</strong></p><p class="source-code"><strong class="bold">AssertionError: 'Jeep Grand Cherokee Laredo 4WD - 3.6L FI FFV DO' != 'Jeep Grand Cherokee Laredo 4WD - 3.6L FI FFV DO asdfasdfas'</strong></p><p class="source-code"><strong class="bold">- Jeep Grand Cherokee Laredo 4WD - 3.6L FI FFV DO</strong></p><p class="source-code"><strong class="bold">+ Jeep Grand Cherokee Laredo 4WD - 3.6L FI FFV DO asdfasdfas</strong></p><p class="source-code"><strong class="bold">?                                                +++++++++++</strong></p><p class="source-code"><strong class="bold">------------------------------------------------------</strong></p><p class="source-code"><strong class="bold">Ran 1 test in 0.227s</strong></p><p class="source-code"><strong class="bold">FAILED (failures=1)</strong></p><p class="source-code"><strong class="bold">Destroying test database for alias 'default'...</strong></p></li>
			</ol>
			<p>Go ahead and comment out the <strong class="source-inline">ModelUnitTestCase</strong> class before proceeding to the next exercise. Now that we have an understanding of how to write simple test cases and cases that test model CRUD actions, next, we will test a custom view class that was written<a id="_idIndexMarker1135"/> in <a href="B17243_04_ePub.xhtml#_idTextAnchor116"><em class="italic">Chapter 4</em></a>, <em class="italic">URLs, Views, and Templates</em>.</p>
			<h1 id="_idParaDest-251"><a id="_idTextAnchor280"/>Testing HTTP view requests</h1>
			<p>In this section, we will <a id="_idIndexMarker1136"/>expand on the basic test cases that we previously wrote to include HTTP view requests. When testing view classes, whether they are a method-based view or a class-based view, they will both use the same <strong class="source-inline">TestCase</strong> class that we have been using so far.</p>
			<p>In the following subsections, we will perform two tests, one for a method-based view and the other for a class-based view.</p>
			<h2 id="_idParaDest-252"><a id="_idTextAnchor281"/>Testing method-based views</h2>
			<p>In this<a id="_idIndexMarker1137"/> exercise, we <a id="_idIndexMarker1138"/>will test the <strong class="source-inline">practice_year_view()</strong> method, written in <a href="B17243_04_ePub.xhtml#_idTextAnchor116"><em class="italic">Chapter 4</em></a>, <em class="italic">URLs, Views, and Templates</em>. What we are comparing in this test is whether the response code that gets returned equals the value of <strong class="source-inline">200</strong>, which means a successful response. </p>
			<p>Follow these steps to create your test case:</p>
			<ol>
				<li value="1">In your <strong class="source-inline">/chapter_9/tests.py</strong> file, add the following <strong class="source-inline">YearRequestTestCase</strong> class and methods:<p class="source-code"><strong class="bold"># /becoming_a_django_entdev/chapter_9/tests.py</strong></p><p class="source-code">...</p><p class="source-code">from django.contrib.auth.models import <strong class="bold">AnonymousUser</strong></p><p class="source-code">from django.test import ..., <strong class="bold">RequestFactory</strong>, TestCase</p><p class="source-code">from ..chapter_4.views import <strong class="bold">practice_year_view</strong></p><p class="source-code">class <strong class="bold">YearRequestTestCase</strong>(TestCase):</p><p class="source-code">    def <strong class="bold">setUp</strong>(self):</p><p class="source-code">        self.factory = <strong class="bold">RequestFactory</strong>()</p><p class="source-code">    def <strong class="bold">test_methodbased</strong>(self):</p><p class="source-code">        request = self.factory.get(</p><p class="source-code">            '/my_year_path/<strong class="bold">2022</strong>/'</p><p class="source-code">        )</p><p class="source-code">        request.user = <strong class="bold">AnonymousUser()</strong></p><p class="source-code">        response = <strong class="bold">practice_year_view</strong>(request, <strong class="bold">2022</strong>)</p><p class="source-code">        self.assertEqual(<strong class="bold">response.status_code</strong>, <strong class="bold">200</strong>)</p></li>
			</ol>
			<p>This test uses a <strong class="source-inline">RequestFactory()</strong> object saved as the <strong class="source-inline">self.factory</strong> variable. It then uses that factory to construct an actual <strong class="source-inline">request</strong> object. The path that we want to test is passed into the <strong class="source-inline">self.factory.get()</strong> method as <strong class="source-inline">/my_year_path/2022/</strong>. Since we are not requiring authentication within <strong class="source-inline">practice_year_view()</strong>, we are setting the <strong class="source-inline">request.user</strong> object to an <strong class="source-inline">AnonymousUser()</strong> class object provided in the <strong class="source-inline">django.contrib.auth.models</strong> library. The response is constructed using the <strong class="source-inline">practice_year_view(request, 2022)</strong> method. Here, we pass in the <strong class="source-inline">request</strong> object and the value of the year keyword argument that we are attempting to<a id="_idIndexMarker1139"/> access. The last line<a id="_idIndexMarker1140"/> checks whether <strong class="source-inline">response.status_code</strong> actually equals a value of <strong class="source-inline">200</strong>.</p>
			<ol>
				<li value="2">Next, run the following test command for the <strong class="source-inline">chapter_9</strong> app test cases:<p class="source-code"><strong class="bold">(virtual_env) PS &gt; python manage.py test becoming_a_django_entdev.chapter_9</strong></p></li>
			</ol>
			<p>If successful, you should see the following message:</p>
			<p class="source-code"><strong class="bold">Found 1 test(s).</strong></p>
			<p class="source-code"><strong class="bold">Creating test database for alias 'default'...</strong></p>
			<p class="source-code"><strong class="bold">System check identified no issues (0 silenced).</strong></p>
			<p class="source-code"><strong class="bold">.</strong></p>
			<p class="source-code"><strong class="bold">------------------------------------------------------</strong></p>
			<p class="source-code"><strong class="bold">Ran 1 test in 0.003s</strong></p>
			<p class="source-code"><strong class="bold">OK</strong></p>
			<p class="source-code"><strong class="bold">Destroying test database for alias 'default'...</strong></p>
			<p>Go back to <em class="italic">step 1</em> and change all instances of the year <strong class="source-inline">2022</strong> to <strong class="source-inline">12</strong> (found in two spots), and then rerun your test command. You should see the failure/error message <a id="_idIndexMarker1141"/>shown <a id="_idIndexMarker1142"/>here:</p>
			<p class="source-code"><strong class="bold">Found 1 test(s).</strong></p>
			<p class="source-code"><strong class="bold">Creating test database for alias 'default'...</strong></p>
			<p class="source-code"><strong class="bold">System check identified no issues (0 silenced).</strong></p>
			<p class="source-code"><strong class="bold">E</strong></p>
			<p class="source-code"><strong class="bold">======================================================</strong></p>
			<p class="source-code"><strong class="bold">ERROR: test_methodbased (becoming_a_django_entdev.chapter_9.tests.YearRequestTestCase)</strong></p>
			<p class="source-code"><strong class="bold">Checks if the path http://localhost:8000/my_year_path/2022/ actually exists and returns a 200 response code (Valid)</strong></p>
			<p class="source-code"><strong class="bold">------------------------------------------------------</strong></p>
			<p class="source-code"><strong class="bold">Traceback (most recent call last):</strong></p>
			<p class="source-code"><strong class="bold">  File "C:\Projects\Packt\Repo\becoming_a_django_entdev\becoming_a_django_entdev\chapter_9\tests.py", line 115, in test_methodbased</strong></p>
			<p class="source-code"><strong class="bold">    response = practice_year_view(request, 12)</strong></p>
			<p class="source-code"><strong class="bold">  File "C:\Projects\Packt\Repo\becoming_a_django_entdev\becoming_a_django_entdev\chapter_4\views.py", line 37, in practice_year_view</strong></p>
			<p class="source-code"><strong class="bold">    raise Http404('Year Not Found: %s' % year)</strong></p>
			<p class="source-code"><strong class="bold">django.http.response.Http404: Year Not Found: 12</strong></p>
			<p class="source-code"><strong class="bold">------------------------------------------------------</strong></p>
			<p class="source-code"><strong class="bold">Ran 1 test in 0.004s</strong></p>
			<p class="source-code"><strong class="bold">FAILED (errors=1)</strong></p>
			<p class="source-code"><strong class="bold">Destroying test database for alias 'default'...</strong></p>
			<p>This test case failed because of the condition that we wrote in the <strong class="source-inline">practice_year_view()</strong> method in <a href="B17243_04_ePub.xhtml#_idTextAnchor116"><em class="italic">Chapter 4</em></a>, <em class="italic">URLs, Views, and Templates</em>, which checks to make sure the user enters a year greater than or equal to <strong class="source-inline">1900</strong>. You will also see that instead of printing an <strong class="source-inline">F</strong> or period for this test, it printed the capital letter <strong class="source-inline">E</strong>, which stands for error. The error versus a failure is a result of the custom parameters that we are checking for, meaning the URL pattern is correct but the view itself performs additional logic that triggers<a id="_idIndexMarker1143"/> the <a id="_idIndexMarker1144"/>page-not-found error.</p>
			<p>Go ahead and comment out the <strong class="source-inline">YearRequestTestCase</strong> class before proceeding to the next exercise.</p>
			<p>Let's test a class-based view in the next section. </p>
			<h2 id="_idParaDest-253"><a id="_idTextAnchor282"/>Testing class-based views</h2>
			<p>In this exercise, we <a id="_idIndexMarker1145"/>will test the <strong class="source-inline">VehicleView</strong> class, written<a id="_idIndexMarker1146"/> in <a href="B17243_04_ePub.xhtml#_idTextAnchor116"><em class="italic">Chapter 4</em></a>, <em class="italic">URLs, Views, and Templates</em>. We will be loading the <strong class="source-inline">chapter_3</strong> data fixture instead of creating objects in the <strong class="source-inline">setUp()</strong> method, as we have done in the <strong class="source-inline">ModelUnitTestCase</strong> class. We already performed a test to see whether creating objects was a success. We can save time and effort now by just loading a fixture for all other tests that we write. </p>
			<p>Follow these steps to create your test case:</p>
			<ol>
				<li value="1">In your <strong class="source-inline">/chapter_9/tests.py</strong> file, add the <strong class="source-inline">VehicleRequestTestCase</strong> class and methods, as shown:<p class="source-code"><strong class="bold"># /becoming_a_django_entdev/chapter_9/tests.py</strong></p><p class="source-code">...</p><p class="source-code">from django<a id="_idTextAnchor283"/>.contrib.auth.models import AnonymousUser</p><p class="source-code">from django.test import ..., RequestFactory, TestCase</p><p class="source-code">from ..chapter_4.views import ..., <strong class="bold">VehicleView</strong></p><p class="source-code">class <strong class="bold">VehicleRequestTestCase</strong>(TestCase):</p><p class="source-code">    <strong class="bold">fixtures</strong> = <strong class="bold">['chapter_3']</strong></p><p class="source-code">    def <strong class="bold">setUp</strong>(self):</p><p class="source-code">        self.factory = RequestFactory()</p><p class="source-code">    def <strong class="bold">test_classbased</strong>(self):</p><p class="source-code">        request = self.factory.get('/vehicle/<strong class="bold">1</strong>/')</p><p class="source-code">        request.user = AnonymousUser()</p><p class="source-code">        response = <strong class="bold">VehicleView.as_view()(request, 1)</strong></p><p class="source-code">        self.assertEqual(response.status_code, 200)</p></li>
			</ol>
			<p>We still<a id="_idIndexMarker1147"/> need the <strong class="source-inline">RequestFactory()</strong> object and <strong class="source-inline">AnonymousUser()</strong> as we used before, because the <strong class="source-inline">VehicleView</strong> class does not require authentication as well. We created the response object for this test using <strong class="source-inline">VehicleView.as_view()(request, 1)</strong>. It looks similar to a URL pattern mapping to a view class, using the <strong class="source-inline">.as_view()</strong> method, found in any <strong class="source-inline">urls.py</strong> file. We again check to see whether <strong class="source-inline">response.status_code</strong> equals a value of <strong class="source-inline">200</strong>, indicating success.</p>
			<ol>
				<li value="2">Now, run the test command shown in the following code and you should once again see a successful test:<p class="source-code"><strong class="bold">(virtual_env) PS &gt; python manage.py test becoming_a_django_entdev.chapter_9</strong></p></li>
				<li>Now, change the number <strong class="source-inline">1</strong> found in <em class="italic">step 1</em> in <strong class="source-inline">'/vehicle/1/'</strong> and <strong class="source-inline">(request, 1)</strong> to <strong class="source-inline">99</strong>. This number represents the index of the vehicle that we are trying to access, an index that should not currently exist. Then, rerun your <strong class="source-inline">test</strong> <a id="_idIndexMarker1148"/>command and you should see<a id="_idIndexMarker1149"/> the following message:<p class="source-code"><strong class="bold">Found 1 test(s).</strong></p><p class="source-code"><strong class="bold">Creating test database for alias 'default'...</strong></p><p class="source-code"><strong class="bold">System check identified no issues (0 silenced).</strong></p><p class="source-code"><strong class="bold">E</strong></p><p class="source-code"><strong class="bold">======================================================</strong></p><p class="source-code"><strong class="bold">ERROR: test_classbased (becoming_a_django_entdev.chapter_9.tests.VehicleRequestTestCase)</strong></p><p class="source-code"><strong class="bold">Checks if the path http://localhost:8000/vehicle/1/ actually exists and returns a 200 response code (Valid)</strong></p><p class="source-code"><strong class="bold">------------------------------------------------------</strong></p><p class="source-code"><strong class="bold">Traceback (most recent call last):</strong></p><p class="source-code"><strong class="bold">  File "C:\Projects\Packt\Repo\becoming_a_django_entdev\becoming_a_django_entdev\chapter_4\views.py", line 68, in get</strong></p><p class="source-code"><strong class="bold">    vehicle = Vehicle.objects.get(id=id)</strong></p><p class="source-code"><strong class="bold">  File "C:\Projects\Packt\Repo\becoming_a_django_entdev\virtual_env\lib\site-packages\django\db\models\manager.py", line 85, in manager_method</strong></p><p class="source-code"><strong class="bold">    return getattr(self.get_queryset(), name)(*args, **kwargs)</strong></p><p class="source-code"><strong class="bold">  File "C:\Projects\Packt\Repo\becoming_a_django_entdev\virtual_env\lib\site-packages\django\db\models\query.py", line 439, in get</strong></p><p class="source-code"><strong class="bold">    raise self.model.DoesNotExist(</strong></p><p class="source-code"><strong class="bold">becoming_a_django_entdev.chapter_3.models.Vehicle.DoesNotExist: Vehicle matching query does not exist.</strong></p><p class="source-code"><strong class="bold">During handling of the above exception, another exception occurred:</strong></p><p class="source-code"><strong class="bold">Traceback (most recent call last):</strong></p><p class="source-code"><strong class="bold">  File "C:\Projects\Packt\Repo\becoming_a_django_entdev\becoming_a_django_entdev\chapter_9\tests.py", line 143, in test_classbased</strong></p><p class="source-code"><strong class="bold">    response = VehicleView.as_view()(request, 99)</strong></p><p class="source-code"><strong class="bold">  File "C:\Projects\Packt\Repo\becoming_a_django_entdev\virtual_env\lib\site-packages\django\views\generic\base.py", line 69, in view</strong></p><p class="source-code"><strong class="bold">    return self.dispatch(request, *args, **kwargs)</strong></p><p class="source-code"><strong class="bold">  File "C:\Projects\Packt\Repo\becoming_a_django_entdev\virtual_env\lib\site-packages\django\views\generic\base.py", line 101, in dispatch</strong></p><p class="source-code"><strong class="bold">    return handler(request, *args, **kwargs)</strong></p><p class="source-code"><strong class="bold">  File "C:\Projects\Packt\Repo\becoming_a_django_entdev\becoming_a_django_entdev\chapter_4\views.py", line 70, in get</strong></p><p class="source-code"><strong class="bold">    raise Http404('Vehicle ID Not Found: %s' % id)</strong></p><p class="source-code"><strong class="bold">django.http.response.Http404: Vehicle ID Not Found: 99</strong></p><p class="source-code"><strong class="bold">------------------------------------------------------</strong></p><p class="source-code"><strong class="bold">Ran 1 test in 0.062s</strong></p><p class="source-code"><strong class="bold">FAILED (errors=1)</strong></p><p class="source-code"><strong class="bold">Destroying test database for alias 'default'...</strong></p></li>
			</ol>
			<p>You'll <a id="_idIndexMarker1150"/>notice, inside<a id="_idIndexMarker1151"/> the preceding traceback message, that it indicates that an object with that ID was not found. The bottom of your traceback is where you will likely find your answer as to what caused the problem to occur, but that is not always the case. This is because we have less than 10 vehicle items found in the <strong class="source-inline">chapter_3</strong> fixture.</p>
			<p>Comment out the <strong class="source-inline">VehicleRequestTestCase</strong> class before proceeding to the next exercise.</p>
			<p>Now that we have<a id="_idIndexMarker1152"/> learned how to test request responses and load <a id="_idIndexMarker1153"/>data fixtures into a test case, let's build on that by adding authentication measures next.</p>
			<h1 id="_idParaDest-254"><a id="_idTextAnchor284"/>Testing authenticated view requests</h1>
			<p>In this section, we will <a id="_idIndexMarker1154"/>be building on the same request test cases that we just built to remove the <strong class="source-inline">AnonymousUser</strong> class and perform our own authentication, requiring only permitted users. We have a few view classes that we wrote in <a href="B17243_08_ePub.xhtml#_idTextAnchor239"><em class="italic">Chapter 8</em></a>, <em class="italic">Working with the Django REST Framework</em>, that require user authentication. Let's create test scripts that allow us to authenticate with an actual user when performing an automated test. This is where loading the <strong class="source-inline">chapter_8/urls.py</strong> file when preparing for this chapter comes into play. Django provides a class called <strong class="source-inline">Client</strong> found in the <strong class="source-inline">django.test</strong> library that lets us perform user authentication when testing a view class. </p>
			<p>In the following subsection, we will implement the <strong class="source-inline">Client</strong> class when performing authentication.</p>
			<h2 id="_idParaDest-255"><a id="_idTextAnchor285"/>Using the Client() class</h2>
			<p>In this exercise, we <a id="_idIndexMarker1155"/>will test the custom API<a id="_idIndexMarker1156"/> endpoint written in <a href="B17243_08_ePub.xhtml#_idTextAnchor239"><em class="italic">Chapter 8</em></a>, <em class="italic">Working with the Django REST Framework</em>, in the <strong class="source-inline">GetSellerHTMLView</strong> class. This is the class we wrote to query a seller by ID and return preformatted HTML instead of the expected JSON, from a traditional API endpoint. What we will be testing for is whether or not the <strong class="source-inline">seller</strong> context object has the business name that is expected for the ID that we are looking up. When using the <strong class="source-inline">Client</strong> class, the <strong class="source-inline">RequestFactory</strong> class is no longer needed, and neither is the <strong class="source-inline">AnonymousUser</strong> class.</p>
			<p>Follow these steps to implement your own authentication:</p>
			<ol>
				<li value="1">In your <strong class="source-inline">/chapter_9/tests.py</strong> file, add the <strong class="source-inline">SellerClientTestCase</strong> class and <strong class="source-inline">setUp()</strong> method shown here: <p class="source-code"><strong class="bold"># /becoming_a_django_entdev/chapter_9/tests.py</strong></p><p class="source-code">...</p><p class="source-code">from django.test import ..., <strong class="bold">Client</strong>, TestCase</p><p class="source-code">from ..chapter_3.models import ..., <strong class="bold">Seller</strong></p><p class="source-code">class <strong class="bold">SellerClientTestCase</strong>(TestCase):</p><p class="source-code">    fixtures = ['chapter_3']</p><p class="source-code">    def <strong class="bold">setUp</strong>(self):</p><p class="source-code">        self.user = <strong class="bold">Seller</strong>.objects.get(id=1)</p><p class="source-code">        self.client = <strong class="bold">Client()</strong></p><p class="source-code">        self.client.login(</p><p class="source-code">            username = self.user.username,</p><p class="source-code">            password = <strong class="bold">'mynewpassword'</strong></p><p class="source-code">        )</p></li>
			</ol>
			<p>We first <a id="_idIndexMarker1157"/>set <a id="_idIndexMarker1158"/>the <strong class="source-inline">self.user</strong> value to equal a single <strong class="source-inline">Seller</strong>. The ID provided is the number <strong class="source-inline">1</strong>, relating to the first superuser created with the username of <strong class="source-inline">admin</strong>. This is the only seller object that has been provided in the <strong class="source-inline">chapter_3</strong> fixture for you. Next, we set the <strong class="source-inline">self.client</strong> value to be a newly created <strong class="source-inline">Client()</strong> object. The last line of the <strong class="source-inline">setUp(self)</strong> method is where we simulate logging into the system. We use <strong class="source-inline">self.user.username</strong> to grab the username of the <strong class="source-inline">Seller</strong> that we queried. Do not use <strong class="source-inline">self.user.password</strong> as the password; instead, use the unhashed password as a string manually written into the code. This is because there is no way to retrieve the unhashed password of a user and that is by design for security reasons.</p>
			<p class="callout-heading">Note</p>
			<p class="callout">When writing your own test cases, it would be wise to keep test user credentials stored in a <strong class="source-inline">.env</strong> file and imported into your project as a <strong class="source-inline">settings.py</strong> variable, which can then be referenced instead of hardcoding the password, as was done previously.</p>
			<ol>
				<li value="2">In that same <strong class="source-inline">SellerClientTestCase</strong> class, add the following test method:<p class="source-code"><strong class="bold"># /becoming_a_django_entdev/chapter_9/tests.py</strong></p><p class="source-code">...</p><p class="source-code">class <strong class="bold">SellerClientTestCase</strong>(TestCase):</p><p class="source-code">    ...</p><p class="source-code">    def <strong class="bold">test_get</strong>(self):</p><p class="source-code">        response = <strong class="bold">self.client.get(</strong></p><p class="source-code">            <strong class="bold">'/chapter-8/seller/1/'</strong></p><p class="source-code">        <strong class="bold">)</strong></p><p class="source-code">        self.assertEqual(<strong class="bold">response.status_code</strong>, <strong class="bold">200</strong>)</p><p class="source-code">        seller = response.context['seller']</p></li>
			</ol>
			<p>        self.assertEqual(<strong class="bold">seller.name</strong>, <strong class="bold">'Test Biz Name'</strong>)</p>
			<p>In <a id="_idIndexMarker1159"/>the <a id="_idIndexMarker1160"/>preceding <strong class="source-inline">test_get(self)</strong> method, we created the response object using <strong class="source-inline">self.client.get()</strong>. Inside that method, we are passing in the path that we are testing, of http://localhost:8000/chapter-8/seller/1/. We are performing two checks instead of one within this test case; the first checks whether <strong class="source-inline">response.status_code</strong> actually equals <strong class="source-inline">200</strong>, to indicate success. The other checks whether or not the seller's business name is what is expected for the object that we are looking up, that being <strong class="source-inline">Test Biz Name</strong>. </p>
			<p>This is why we are creating the lowercase <strong class="source-inline">seller</strong> variable, which grabs the <strong class="source-inline">seller</strong> from the context returned with the request. It is also important that we add the <strong class="source-inline">self.assertEqual(response.status_code, 200)</strong> statement before we create the lowercase <strong class="source-inline">seller</strong> variable. If we do not have a successful response for any reason, the <strong class="source-inline">seller</strong> object will obviously not exist and so the test will fail. When that happens, it could point you in the wrong direction as to what the real problem could be.</p>
			<ol>
				<li value="3">Now, run the following <strong class="source-inline">test</strong> command and you should once again see a successful test:<p class="source-code"><strong class="bold">(virtual_env) PS &gt; python manage.py test becoming_a_django_entdev.chapter_9</strong></p></li>
				<li>Next, change the <strong class="source-inline">password</strong> value found in <em class="italic">step 1</em> to an incorrect password, such as <strong class="source-inline">mynewpassword1</strong>, which will force a failed response. Rerun your <strong class="source-inline">test</strong> command and you should see<a id="_idIndexMarker1161"/> the <a id="_idIndexMarker1162"/>following message:<p class="source-code"><strong class="bold">Found 1 test(s).</strong></p><p class="source-code"><strong class="bold">Creating test database for alias 'default'...</strong></p><p class="source-code"><strong class="bold">System check identified no issues (0 silenced).</strong></p><p class="source-code"><strong class="bold">F</strong></p><p class="source-code"><strong class="bold">======================================================</strong></p><p class="source-code"><strong class="bold">FAIL: test_get (becoming_a_django_entdev.chapter_9.tests.SellerClientTestCase) </strong></p><p class="source-code"><strong class="bold">Tests a custom-built REST-API Endpoint using the Client() class.</strong></p><p class="source-code"><strong class="bold">------------------------------------------------------</strong></p><p class="source-code"><strong class="bold">Traceback (most recent call last):</strong></p><p class="source-code"><strong class="bold">  File "C:\Projects\Packt\Repo\becoming_a_django_entdev\becoming_a_django_entdev\chapter_9\tests.py", line 171, in test_get</strong></p><p class="source-code"><strong class="bold">    self.assertEqual(response.status_code, 200)</strong></p><p class="source-code"><strong class="bold">AssertionError: 401 != 200</strong></p><p class="source-code"><strong class="bold">------------------------------------------------------</strong></p><p class="source-code"><strong class="bold">Ran 1 test in 0.356s</strong></p><p class="source-code"><strong class="bold">FAILED (failures=1)</strong></p><p class="source-code"><strong class="bold">Destroying test database for alias 'default'...</strong></p></li>
			</ol>
			<p>We can see the reason why a failure occurred is due to <strong class="bold">AssertionError: 401 != 200</strong>. A <strong class="bold">401</strong> response means an unauthorized response, which means the requested resource does not have valid authentication credentials and access will not be granted.</p>
			<ol>
				<li value="5">Change your<a id="_idIndexMarker1163"/> password<a id="_idIndexMarker1164"/> back to the correct password of <strong class="source-inline">mynewpassword</strong> and then, returning to <em class="italic">step 2</em>, change the business name in the last line to something incorrect, such as <strong class="source-inline">Test Biz Name1</strong>.</li>
				<li>Rerun the <strong class="source-inline">test</strong> command one more time and now you should see the following failed message:<p class="source-code"><strong class="bold">Found 1 test(s).</strong></p><p class="source-code"><strong class="bold">Creating test database for alias 'default'...</strong></p><p class="source-code"><strong class="bold">System check identified no issues (0 silenced).</strong></p><p class="source-code"><strong class="bold">F</strong></p><p class="source-code"><strong class="bold">======================================================</strong></p><p class="source-code"><strong class="bold">FAIL: test_get (becoming_a_django_entdev.chapter_9.tests.SellerClientTestCase)</strong></p><p class="source-code"><strong class="bold">Tests a custom-built REST-API Endpoint using the Client() class.</strong></p><p class="source-code"><strong class="bold">------------------------------------------------------</strong></p><p class="source-code"><strong class="bold">Traceback (most recent call last):</strong></p><p class="source-code"><strong class="bold">  File "C:\Projects\Packt\Repo\becoming_a_django_entdev\becoming_a_django_entdev\chapter_9\tests.py", line 175, in test_get</strong></p><p class="source-code"><strong class="bold">    self.assertEqual(seller.name, 'Test Biz Name1')</strong></p><p class="source-code"><strong class="bold">AssertionError: 'Test Biz Name' != 'Test Biz Name1'</strong></p><p class="source-code"><strong class="bold">- Test Biz Name</strong></p><p class="source-code"><strong class="bold">+ Test Biz Name1</strong></p><p class="source-code"><strong class="bold">?              +</strong></p><p class="source-code"><strong class="bold">------------------------------------------------------</strong></p><p class="source-code"><strong class="bold">Ran 1 test in 0.561s</strong></p><p class="source-code"><strong class="bold">FAILED (failures=1)</strong></p><p class="source-code"><strong class="bold">Destroying test database for alias 'default'...</strong></p></li>
			</ol>
			<p>This also indicates that we achieved a <strong class="bold">200</strong> successful response code seeing that this is the second assertion that failed and not the first one.</p>
			<p>You may now comment out the <strong class="source-inline">SellerClientTestCase</strong> class before proceeding to the next exercise. Now <a id="_idIndexMarker1165"/>that we have a better understanding of how to add<a id="_idIndexMarker1166"/> authentication measures to our test cases, we will test Django REST API endpoints with authentication next.</p>
			<h1 id="_idParaDest-256"><a id="_idTextAnchor286"/>Testing Django REST API endpoints</h1>
			<p>This section will <a id="_idIndexMarker1167"/>introduce writing test cases that test Django REST framework endpoints. When testing any REST API endpoints created using the Django REST framework, we need to use the <strong class="source-inline">APITestCase</strong> class provided by the <strong class="source-inline">rest_framework.test</strong> library. We also should use the <strong class="source-inline">APIClient()</strong> class provided by that same library when requiring authentication, instead of using the <strong class="source-inline">Client()</strong> class as we did before. </p>
			<p>In the following exercises, we will create one test class that performs two tests: the first will create an <a id="_idIndexMarker1168"/>engine object and the other will update an object.</p>
			<h2 id="_idParaDest-257"><a id="_idTextAnchor287"/>Creating an object test case</h2>
			<p>This test will <a id="_idIndexMarker1169"/>use the <strong class="source-inline">POST</strong> request method to <a id="_idIndexMarker1170"/>send data to the <a href="http://localhost:8000/chapter-8/engines/">http://localhost:8000/chapter-8/engines/</a> endpoint and create an engine object in the database. Since we are loading a data fixture that contains only two engine objects with the IDs <strong class="source-inline">1</strong> and <strong class="source-inline">2</strong>, we should expect the new object to be created at index <strong class="source-inline">3</strong>, but your results may vary. We will refer back to this in the <em class="italic">Updating an object test case</em> subsection. </p>
			<p>Follow these steps to create your test case:</p>
			<ol>
				<li value="1">In your <strong class="source-inline">/chapter_9/tests.py</strong> file, add the following <strong class="source-inline">EngineAPITestCase</strong> class, the <strong class="source-inline">setUp()</strong> method, and the <strong class="source-inline">import</strong> statement:<p class="source-code"><strong class="bold"># /becoming_a_django_entdev/chapter_9/tests.py</strong></p><p class="source-code">...</p><p class="source-code">from rest_framework.test import <strong class="bold">APITestCase</strong>, <strong class="bold">APIClient</strong></p><p class="source-code">class <strong class="bold">EngineAPITestCase</strong>(<strong class="bold">APITestCase</strong>):</p><p class="source-code">    fixtures = ['chapter_3']</p><p class="source-code">    def <strong class="bold">setUp</strong>(self):</p><p class="source-code">        self.user = Seller.objects.get(id=1)</p><p class="source-code">        self.client = <strong class="bold">APIClient()</strong></p><p class="source-code">        self.client.login(</p><p class="source-code">            username = self.user.username,</p><p class="source-code">            password = 'mynewpassword'</p><p class="source-code">        )</p></li>
			</ol>
			<p>The structure of the preceding class follows a very similar pattern to what was done in the subsection titled <em class="italic">Using the Client() class</em>. Here, we set the value of <strong class="source-inline">self.client</strong> to use the <strong class="source-inline">rest_framework.test</strong> library-provided <strong class="source-inline">APIClient</strong> class. Login is done the same as before, in the <strong class="source-inline">self.client.login()</strong> declaration.</p>
			<ol>
				<li value="2">In that <a id="_idIndexMarker1171"/>same <strong class="source-inline">EngineAPITestCase</strong> class, add<a id="_idIndexMarker1172"/> the following <strong class="source-inline">test_post()</strong> method:<p class="source-code"><strong class="bold"># /becoming_a_django_entdev/chapter_9/tests.py</strong></p><p class="source-code">...</p><p class="source-code">class <strong class="bold">EngineAPITestCase</strong>(<strong class="bold">APITestCase</strong>):</p><p class="source-code">    ...</p><p class="source-code">    def <strong class="bold">test_post</strong>(self):</p><p class="source-code">        response = <strong class="bold">self.client.post</strong>(</p><p class="source-code">            '/chapter-8/engines/',</p><p class="source-code">            <strong class="bold">{'name': 'New Engine'},</strong></p><p class="source-code">            <strong class="bold">format = 'json'</strong></p><p class="source-code">        )</p><p class="source-code">        self.assertEqual(response.status_code, 201)</p><p class="source-code">        self.assertEqual(<strong class="bold">response.data['name']</strong>, 'New </p><p class="source-code">            Engine')</p></li>
			</ol>
			<p>For the response object, instead of using <strong class="source-inline">self.client.get()</strong>, we are using <strong class="source-inline">self.client.post()</strong> because we want to send information to the test client server. Inside is the data we are sending, noting that the last argument is the format of the data, which is set to JSON format in this example. We then check the <strong class="source-inline">response.status_code</strong> value, this time to see whether it equals <strong class="source-inline">201</strong> and not <strong class="source-inline">200</strong>. A <strong class="source-inline">201</strong> response code indicates that an object was created successfully. The last line checks whether the data that was returned to us, which is the object that was created, has the engine name that we expect. In this case, the new engine name we are expecting is <strong class="source-inline">New Engine</strong>.</p>
			<ol>
				<li value="3">Now, run the following <strong class="source-inline">test</strong> command and you should once again see a successful test:<p class="source-code"><strong class="bold">virtual_env) PS &gt; python manage.py test becoming_a_django_entdev.chapter_9 </strong></p></li>
				<li>Next, go back to <em class="italic">step 1</em> and add an incorrect password, such as <strong class="source-inline">mynewpassword1</strong>, and <a id="_idIndexMarker1173"/>then run your <strong class="source-inline">test</strong> command again. You should see the<a id="_idIndexMarker1174"/> following message:<p class="source-code"><strong class="bold">Found 1 test(s).</strong></p><p class="source-code"><strong class="bold">Creating test database for alias 'default'...</strong></p><p class="source-code"><strong class="bold">System check identified no issues (0 silenced).</strong></p><p class="source-code"><strong class="bold">F</strong></p><p class="source-code"><strong class="bold">======================================================</strong></p><p class="source-code"><strong class="bold">FAIL: test_post (becoming_a_django_entdev.chapter_9.tests.EngineAPITestCase)</strong></p><p class="source-code"><strong class="bold">Checks if it returns a 201 response code (Created).</strong></p><p class="source-code"><strong class="bold">------------------------------------------------------</strong></p><p class="source-code"><strong class="bold">Traceback (most recent call last):</strong></p><p class="source-code"><strong class="bold">  File "C:\Projects\Packt\Repo\becoming_a_django_entdev\becoming_a_django_entdev\chapter_9\tests.py", line 203, in test_post</strong></p><p class="source-code"><strong class="bold">    self.assertEqual(response.status_code, 201)</strong></p><p class="source-code"><strong class="bold">AssertionError: 401 != 201</strong></p><p class="source-code"><strong class="bold">------------------------------------------------------</strong></p><p class="source-code"><strong class="bold">Ran 1 test in 0.363s</strong></p><p class="source-code"><strong class="bold">FAILED (failures=1)</strong></p><p class="source-code"><strong class="bold">Destroying test database for alias 'default'...</strong></p></li>
			</ol>
			<p>We can see in this test that we are being warned of <strong class="source-inline">AssertionError: 401 != 201</strong> and not <strong class="source-inline">200</strong> this time. You can <strong class="source-inline">achieve</strong> the same by changing the expected value of the engine name and you will <a id="_idIndexMarker1175"/>see it warn you of that <a id="_idIndexMarker1176"/>assertion.</p>
			<p>Next, let's add to this class to allow us to test updating an object.</p>
			<h2 id="_idParaDest-258"><a id="_idTextAnchor288"/>Updating an object test case</h2>
			<p>This test <a id="_idIndexMarker1177"/>will<a id="_idIndexMarker1178"/> use the <strong class="source-inline">PUT</strong> request method to send data to the <a href="http://localhost:8000/chapter-8/engines/1/">http://localhost:8000/chapter-8/engines/1/</a> endpoint, a specific engine object to update within the database. </p>
			<p>Follow these steps to update your class for this test case:</p>
			<ol>
				<li value="1">Inside the same <strong class="source-inline">EngineAPITestCase</strong> class, add the following <strong class="source-inline">test_put()</strong> method:<p class="source-code"><strong class="bold"># /becoming_a_django_entdev/chapter_9/tests.py</strong></p><p class="source-code">...</p><p class="source-code">from rest_framework.test import APITestCase, APIClient</p><p class="source-code">class <strong class="bold">EngineAPITestCase</strong>(APITestCase):</p><p class="source-code">    ...</p><p class="source-code">    def test_put(self):</p><p class="source-code">        response = <strong class="bold">self.client.put</strong>(</p><p class="source-code">            '/chapter-8/engines/1/',</p><p class="source-code">            {'name': 'My Changed Engine Name'},</p><p class="source-code">            format = 'json'</p><p class="source-code">        )</p><p class="source-code">        self.assertEqual(response.status_code, 200)</p><p class="source-code">        self.assertEqual(</p><p class="source-code">            response.data['name'],</p><p class="source-code">            'My Changed Engine Name'</p><p class="source-code">        )</p></li>
			</ol>
			<p>Please leave the <strong class="source-inline">setUp()</strong> and <strong class="source-inline">test_post()</strong> methods as they are. In the preceding <strong class="source-inline">test_put()</strong> method, we are using the <strong class="source-inline">self.client.put()</strong> method to create the response object. The data that we are sending is in the same JSON format. Note that in the preceding example, we are specifying the path as <strong class="source-inline">'/chapter-8/engines/1/'</strong>, which refers to the first engine object with <a id="_idIndexMarker1179"/>an ID index of <strong class="source-inline">1</strong>. That <a id="_idIndexMarker1180"/>object is being inserted into the dummy database that gets created through the <strong class="source-inline">chapter_3</strong> fixture that is still being used in this class. We once again are checking that <strong class="source-inline">response.status_code</strong> equals <strong class="source-inline">200</strong>, success. We don't need to check for <strong class="source-inline">201</strong> because nothing is being created currently, only updated. We then check to make sure that the expected object's name equals <strong class="source-inline">My Changed Engine Name</strong>.</p>
			<ol>
				<li value="2">Now, run the following test command and you should see that both tests are a success:<p class="source-code"><strong class="bold">(virtual_env) PS &gt; python3 manage.py test becoming_a_django_entdev.chapter_9</strong></p></li>
				<li>To demonstrate how creating an item in one test cannot be retrieved from another test within the same class, change the ID of <strong class="source-inline">1</strong> to <strong class="source-inline">3</strong> within the <strong class="source-inline">test_put()</strong> method, as in <strong class="source-inline">'/chapter-8/engines/3/'</strong>. </li>
			</ol>
			<p>When we created an object in the <strong class="source-inline">test_post(self)</strong> method, you might expect the newly created object to have had an ID index of <strong class="source-inline">3</strong> since the <strong class="source-inline">chapter_3</strong> fixture only has two objects. The reason we won't find the new object to update that object is that when the <strong class="source-inline">test_post(self)</strong> method is complete, anything created during that operation gets destroyed upon completion.</p>
			<ol>
				<li value="4">Rerun your <strong class="source-inline">test</strong><a id="_idIndexMarker1181"/> command <a id="_idIndexMarker1182"/>and now you should see the failure message shown here:<p class="source-code"><strong class="bold">Found 2 test(s).</strong></p><p class="source-code"><strong class="bold">Creating test database for alias 'default'...</strong></p><p class="source-code"><strong class="bold">System check identified no issues (0 silenced).</strong></p><p class="source-code"><strong class="bold">.F</strong></p><p class="source-code"><strong class="bold">======================================================</strong></p><p class="source-code"><strong class="bold">FAIL: test_put (becoming_a_django_entdev.chapter_9.tests.EngineAPITestCase)</strong></p><p class="source-code"><strong class="bold">Checks if it returns a 200 response code (Success).</strong></p><p class="source-code"><strong class="bold">------------------------------------------------------</strong></p><p class="source-code"><strong class="bold">Traceback (most recent call last):</strong></p><p class="source-code"><strong class="bold">  File "C:\Projects\Packt\Repo\becoming_a_django_entdev\becoming_a_django_entdev\chapter_9\tests.py", line 219, in test_put</strong></p><p class="source-code"><strong class="bold">    self.assertEqual(response.status_code, 200)</strong></p><p class="source-code"><strong class="bold">AssertionError: 404 != 200</strong></p><p class="source-code"><strong class="bold">------------------------------------------------------</strong></p><p class="source-code"><strong class="bold">Ran 2 tests in 1.037s</strong></p><p class="source-code"><strong class="bold">FAILED (failures=1)</strong></p><p class="source-code"><strong class="bold">Destroying test database for alias 'default'...</strong></p></li>
			</ol>
			<p>The reason we are seeing a failure is that Django does not keep objects created between other test cases within the same test class. Django will keep a counter of the last object ID created, which means if or when a test case completes and an object gets destroyed, the counter will continue to count. This could make for a frustrating time testing and, as such, is the reason we are loading a fixture, so that we know for sure that the ID is what it should be for the object that we are testing.</p>
			<p>Now that we <a id="_idIndexMarker1183"/>have a better understanding of how<a id="_idIndexMarker1184"/> automated testing works in Django, let's introduce the DjDT next, a powerful set of tools that helps developers to debug during development.</p>
			<h1 id="_idParaDest-259"><a id="_idTextAnchor289"/>Using the DjDT</h1>
			<p>The DjDT is a <a id="_idIndexMarker1185"/>third-party package that integrates a set of configurable panels that display debug information in real time to the developer. Other third-party packages can be installed to add additional panels to this toolbar. With that in mind, you could also build your own panels too. We will only be installing the DjDT package by itself and then explaining each of its most common features, guiding you through using it, interpreting what it is showing you. To learn more about all of its capabilities, visit <a href="https://pypi.org/project/django-debug-toolbar/">https://pypi.org/project/django-debug-toolbar/</a> and <a href="https://django-debug-toolbar.readthedocs.io/en/latest/">https://django-debug-toolbar.readthedocs.io/en/latest/</a>. </p>
			<h2 id="_idParaDest-260"><a id="_idTextAnchor290"/>Installing the DjDT</h2>
			<p>To get started <a id="_idIndexMarker1186"/>with installing the DjDT, follow these steps:</p>
			<ol>
				<li value="1">Add the <strong class="source-inline">django-debug-toolbar</strong> package to your <strong class="source-inline">requirements.txt</strong> file and install it into your virtual environment via that file or run the following <strong class="source-inline">pip</strong> command, making sure your virtual environment is already active:<p class="source-code"><strong class="bold">PS C:\Projects\Packt\Repo\becoming_a_django_entdev&gt; virtual_env/Scripts/activate</strong></p><p class="source-code"><strong class="bold">(virtual_env) PS &gt; pip install django-debug-toolbar</strong></p></li>
				<li>In your <strong class="source-inline">settings.py</strong> file, add the following items to your <strong class="source-inline">INSTALLED_APPS</strong> list:<p class="source-code"><strong class="bold"># /becoming_a_django_entdev/settings.py</strong></p><p class="source-code">...</p><p class="source-code">INSTALLED_APPS = [</p><p class="source-code">    ...</p><p class="source-code">    <strong class="bold">'debug_toolbar'</strong>,</p><p class="source-code">    ...</p><p class="source-code">]</p></li>
				<li>In the<a id="_idIndexMarker1187"/> same <strong class="source-inline">settings.py</strong> file, add the following middleware to the top of your <strong class="source-inline">MIDDLEWARE</strong> list:<p class="source-code"><strong class="bold"># /becoming_a_django_entdev/settings.py</strong></p><p class="source-code">...</p><p class="source-code">MIDDLEWARE = [</p><p class="source-code">    <strong class="bold">'debug_toolbar.middleware.DebugToolbarMiddleware'</strong>,</p><p class="source-code">    ...</p><p class="source-code">]</p><p class="source-code">...</p></li>
			</ol>
			<p>The <strong class="source-inline">debug_toolbar</strong> app and the <strong class="source-inline">MIDDLEWARE</strong> item should be the only new items that you are adding to this file.</p>
			<ol>
				<li value="4">The <strong class="source-inline">django.contrib.staticfiles</strong> app, the <strong class="source-inline">INTERNAL_IPS</strong> list, and the <strong class="source-inline">STATIC_URL</strong> variable should have already been added in <a href="B17243_02_ePub.xhtml#_idTextAnchor037"><em class="italic">Chapter 2</em></a>, <em class="italic">Project Configuration</em>, when we created and configured the project for the first time. Note that they are required for this toolbar to work. Should you be working on a project of your own that does not follow the <strong class="source-inline">settings.py</strong> specifications of<a id="_idIndexMarker1188"/> this book, make sure that these items are included:<p class="source-code"><strong class="bold"># /becoming_a_django_entdev/settings.py</strong></p><p class="source-code">...</p><p class="source-code"><strong class="bold">INTERNAL_IPS</strong> = [</p><p class="source-code">    <strong class="bold">'127.0.0.1',</strong></p><p class="source-code">]</p><p class="source-code">INSTALLED_APPS = [</p><p class="source-code">    ...</p><p class="source-code">    <strong class="bold">'django.contrib.staticfiles',</strong></p><p class="source-code">    'debug_toolbar',</p><p class="source-code">    ...</p><p class="source-code">]</p><p class="source-code"><strong class="bold">STATIC_URL = '/staticfiles/'</strong></p><p class="source-code">...</p></li>
				<li>Next, you will need to import the URL patterns relative to this third-party app. To make sure this toolbar can be used in all chapters throughout this book, in your main <strong class="source-inline">urls.py</strong> file, add the following <strong class="source-inline">include</strong> pattern:<p class="source-code"><strong class="bold"># /becoming_a_django_entdev/urls.py</strong></p><p class="source-code">...</p><p class="source-code">from django.urls import ..., include, re_path</p><p class="source-code">...</p><p class="source-code"><strong class="bold">if settings.DEBUG:</strong></p><p class="source-code">    ...</p><p class="source-code">    <strong class="bold">import debug_toolbar</strong></p><p class="source-code">    urlpatterns = [</p><p class="source-code">        <strong class="bold">re_path(</strong></p><p class="source-code">            <strong class="bold">r'^__debug__/', </strong></p><p class="source-code">            <strong class="bold">include(debug_toolbar.urls)</strong></p><p class="source-code">        <strong class="bold">),</strong></p><p class="source-code">    ] + urlpatterns</p></li>
			</ol>
			<p>Note that in the preceding example, we are placing the import under the <strong class="source-inline">settings.DEBUG</strong> conditional statement, checking whether our environment is the <strong class="source-inline">DEBUG</strong> environment. We don't ever want this toolbar to appear in a production or production-like test environment, such as staging. The development environment is usually acceptable. </p>
			<p>That's it; by <a id="_idIndexMarker1189"/>now, this toolbar should be installed and working properly. Next, let's discuss making an adjustment to work with our remote environments.</p>
			<h3>Adjusting DjDT settings</h3>
			<p>Any of the panels <a id="_idIndexMarker1190"/>that you are about to learn about have behavioral settings that can be defined in your <strong class="source-inline">settings.py</strong> file. A common example of this is how we need to use the <strong class="source-inline">SHOW_TOOLBAR_CALLBACK</strong> setting to allow us to see the DjDT in a Heroku environment. To learn more about all of the settings available, visit <a href="https://django-debug-toolbar.readthedocs.io/en/latest/configuration.html#23debug-toolbar-config">https://django-debug-toolbar.readthedocs.io/en/latest/configuration.html#debug-toolbar-config</a>.</p>
			<p>Follow these steps to activate this setting:</p>
			<ol>
				<li value="1">In the <strong class="source-inline">settings.py</strong> file, add the following code:<p class="source-code"><strong class="bold"># /becoming_a_django_entdev/settings.py</strong></p><p class="source-code">...</p><p class="source-code">def <strong class="bold">show_toolbar</strong>(request):</p><p class="source-code">    <strong class="bold">return True</strong></p><p class="source-code">if <strong class="bold">os.getenv('SHOW_TOOLBAR_CALLBACK')</strong> == 'True':</p><p class="source-code">    DEBUG_TOOLBAR_CONFIG = {</p><p class="source-code">        'SHOW_TOOLBAR_CALLBACK': <strong class="bold">show_toolbar</strong>,</p><p class="source-code">    }</p></li>
			</ol>
			<p>We have to <a id="_idIndexMarker1191"/>use a callable and a variable in the <strong class="source-inline">.env</strong> file because using the <strong class="source-inline">DEBUG_TOOLBAR_CONFIG</strong> dictionary and running your automated Django test command locally will result in an error due to the DjDT package. Using either the toolbar or the Django testing commands separately will be fine without the preceding code, but when used together, this code is required.</p>
			<ol>
				<li value="2">To show this toolbar in your Heroku-hosted environments, set the following value to <strong class="source-inline">True</strong> in your <strong class="source-inline">.env</strong> file. Refer to the subsection titled <em class="italic">Remote variables</em> found in <a href="B17243_02_ePub.xhtml#_idTextAnchor037"><em class="italic">Chapter 2</em></a>, <em class="italic">Project Configuration</em>:<p class="source-code"><strong class="bold"># .env</strong></p><p class="source-code">SHOW_TOOLBAR_CALLBACK=<strong class="bold">True</strong></p></li>
				<li>Leave this value as <strong class="source-inline">False</strong> in your local environment.</li>
			</ol>
			<p>Now, let's use this toolbar.</p>
			<h2 id="_idParaDest-261"><a id="_idTextAnchor291"/>How to use the DjDT</h2>
			<p>Make sure<a id="_idIndexMarker1192"/> your virtual environment is activated and then take the following steps to use the DjDT:</p>
			<ol>
				<li value="1">Run your project using the following command, or you can use the IDE, as discussed in <a href="B17243_02_ePub.xhtml#_idTextAnchor037"><em class="italic">Chapter 2</em></a>, <em class="italic">Project Configuration</em>:<p class="source-code"><strong class="bold">PS C:\Projects\Packt\Repo\becoming_a_django_entdev&gt; virtual_env/Scripts/activate</strong></p><p class="source-code"><strong class="bold">(virtual_env) PS &gt; python3 manage.py runserver</strong></p></li>
				<li>In your browser, navigate to your home page at <a href="http://localhost:8000/">http://localhost:8000/</a> and you should see the classic home page image with the <strong class="bold">Chapter 9</strong> subtitle and now, a tab in the top right of the window, as shown in the following screenshot, with the arrow pointing to it:</li>
			</ol>
			<p class="figure-caption"> </p>
			<div>
				<div id="_idContainer128" class="IMG---Figure">
					<img src="image/Figure_9.01_B17243.jpg" alt="Figure 9.1 – DjDT – tab&#13;&#10;"/>
				</div>
			</div>
			<p class="figure-caption">Figure 9.1 – DjDT – tab</p>
			<ol>
				<li value="3">Click on this toolbar to open it and see what mysteries behold, as shown in the following screenshot:</li>
			</ol>
			<div>
				<div id="_idContainer129" class="IMG---Figure">
					<img src="image/Figure_9.02_B17243.jpg" alt="Figure 9.2 – DjDT – opened&#13;&#10;"/>
				</div>
			</div>
			<p class="figure-caption">Figure 9.2 – DjDT – opened</p>
			<p>Each item in this <a id="_idIndexMarker1193"/>toolbar can be clicked on to expand it even further. The following subsections give you a breakdown of what each panel actually shows you.</p>
			<h3>History</h3>
			<p>The <strong class="bold">History</strong> panel shows<a id="_idIndexMarker1194"/> us a list of every request that was made within this browser tab. Every time you refresh the page or navigate to a new path within your site, that information will be logged within this panel. For each item within this panel, there is a <strong class="bold">Switch</strong> button. When that button is clicked, debug information will update in the other tabs relative to that request, highlighted with arrows in the following screenshot:</p>
			<div>
				<div id="_idContainer130" class="IMG---Figure">
					<img src="image/Figure_9.03_B17243.jpg" alt="Figure 9.3 – DjDT – History tab&#13;&#10;"/>
				</div>
			</div>
			<p class="figure-caption">Figure 9.3 – DjDT – History tab</p>
			<p>When you click the <strong class="bold">Switch</strong> button, your page won't actually update to that page that is in your browser's history; only the data displayed in your debug toolbar gets updated. That allows you to see what changed from one request to another. The preceding screenshot shows how I refreshed the home page five times before navigating to the Django admin site. The Django admin site URL patterns should have been imported when we imported the <strong class="source-inline">chapter_8</strong> app URL patterns in preparation for this chapter. In this example, I am actually logged into my admin panel, showing in the <strong class="bold">SQL</strong> tab that there are three queries, then when I switch to one of the home page URLs, the <strong class="bold">SQL</strong> tab updates to tell me I now have two queries. I'll explain what these queries mean in the <em class="italic">SQL</em> subsection that follows. For now, you can at least see how this data is changing.</p>
			<h3>Versions</h3>
			<p>The <strong class="bold">Versions</strong> panel <a id="_idIndexMarker1195"/>displays the version number of Django, Python, and all related third-party packages that have been installed in your software stack. It is a quick and easy way to share what is needed in a visually appealing way with your clients and developers. Remember the <strong class="source-inline">requirements.txt</strong> file is shared with developers to automate the installation of the required packages and versions of your project. The following screenshot shows what this tab looks like, verifying that we are indeed using Django 4.0:</p>
			<div>
				<div id="_idContainer131" class="IMG---Figure">
					<img src="image/Figure_9.04_B17243.jpg" alt="Figure 9.4 – DjDT – Versions tab&#13;&#10;"/>
				</div>
			</div>
			<p class="figure-caption">Figure 9.4 – DjDT – Versions tab</p>
			<h3>Time</h3>
			<p>The <strong class="bold">Time</strong> tab only <a id="_idIndexMarker1196"/>displays the time it took to execute the current request. It doesn't actually open a new panel like the first two tabs. It's just a placeholder tab that displays useful information.</p>
			<h3>Settings</h3>
			<p>The <strong class="bold">Settings</strong> panel <a id="_idIndexMarker1197"/>displays a list of all of your <strong class="source-inline">settings.py</strong> variables and their computed values. This is handy if you have methods calculating values, or if you are linking many different <strong class="source-inline">settings.py</strong> files together from other packages that override or change the values in your parent file, they can all be viewed from here. The following screenshot shows you what that looks like:</p>
			<div>
				<div id="_idContainer132" class="IMG---Figure">
					<img src="image/Figure_9.05_B17243.jpg" alt="Figure 9.5 – DjDT – Settings tab&#13;&#10;"/>
				</div>
			</div>
			<p class="figure-caption">Figure 9.5 – DjDT – Settings tab</p>
			<h3>Headers</h3>
			<p>The <strong class="bold">Headers</strong> panel <a id="_idIndexMarker1198"/>displays all of the information pertaining to your HTTP request and response headers. It also displays your WSGI or ASGI environment variables at the bottom of this panel. This can be very helpful when you are working with API endpoints and you need to make sure the information in your request and response headers is as what you would expect it to be. The following screenshot shows you what this looks like:</p>
			<div>
				<div id="_idContainer133" class="IMG---Figure">
					<img src="image/Figure_9.06_B17243.jpg" alt="Figure 9.6 – DjDT – Headers tab&#13;&#10;"/>
				</div>
			</div>
			<p class="figure-caption">Figure 9.6 – DjDT – Headers tab</p>
			<h3>Request</h3>
			<p>The <strong class="bold">Request</strong> panel <a id="_idIndexMarker1199"/>shows you all of the data related to your request, such as keyword arguments and cookie and session data. This tab is very useful for checking to make sure this information is what it is expected to be. The following screenshot shows what this panel looks like:</p>
			<div>
				<div id="_idContainer134" class="IMG---Figure">
					<img src="image/Figure_9.07_B17243.jpg" alt="Figure 9.7 – DjDT – Request tab&#13;&#10;"/>
				</div>
			</div>
			<p class="figure-caption">Figure 9.7 – DjDT – Request tab</p>
			<h3>SQL</h3>
			<p>The <strong class="bold">SQL</strong> panel shows<a id="_idIndexMarker1200"/> you a very detailed and broken-down look of what each query is doing, as well as showing you all of the queries involved in a particular request. For example, if you are visiting the home page while not logged into the Django admin site, the <strong class="bold">SQL</strong> tab will tell you there are zero queries, as depicted in <em class="italic">Figure 9.2</em>. However, if you are logged into the Django admin site and are visiting the home page, you should see at least two queries under the <strong class="bold">SQL</strong> tab. When you click on this tab, you will see what those two queries are, as shown in the following screenshot:</p>
			<div>
				<div id="_idContainer135" class="IMG---Figure">
					<img src="image/Figure_9.08_B17243.jpg" alt="Figure 9.8 – DjDT – SQL tab&#13;&#10;"/>
				</div>
			</div>
			<p class="figure-caption">Figure 9.8 – DjDT – SQL tab</p>
			<p>Here, we can see the first query establishes a session for the current request and then queries the object of the user logged into the system. That user object is a <strong class="source-inline">Seller</strong> model object because of how we extended the <strong class="source-inline">User</strong> model in <a href="B17243_03_ePub.xhtml#_idTextAnchor077"><em class="italic">Chapter 3</em></a>, <em class="italic">Models, Relations, and Inheritance</em>. Each query also has a <strong class="bold">Sel</strong> and <strong class="bold">Expl</strong> button, which provide other details about that query. Clicking the plus sign, found to the left of any one of these queries expands even more, giving you information about that query, including traceback<a id="_idIndexMarker1201"/> information, as shown:</p>
			<div>
				<div id="_idContainer136" class="IMG---Figure">
					<img src="image/Figure_9.09_B17243.jpg" alt="Figure 9.9 – DjDT – SQL tab expanded&#13;&#10;"/>
				</div>
			</div>
			<p class="figure-caption">Figure 9.9 – DjDT – SQL tab expanded</p>
			<h3>Static files</h3>
			<p>The <strong class="bold">Static files</strong> panel <a id="_idIndexMarker1202"/>displays all of the apps installed that actually contain static files. The middle section lists all of the static files related to the current request. You can actually click on them to open and view them in the current or a new tab. The last section in this panel displays a list of all of the static files found in all of the apps that are installed. This can sometimes be helpful if you are comparing a static file that overrides the same static file of another app, you can see which one is used and which ones are ignored. The following screenshot shows you what this panel looks like:</p>
			<div>
				<div id="_idContainer137" class="IMG---Figure">
					<img src="image/Figure_9.10_B17243.jpg" alt="Figure 9.10 – DjDT – Static files tab&#13;&#10;"/>
				</div>
			</div>
			<p class="figure-caption">Figure 9.10 – DjDT – Static files tab</p>
			<p>Here, we can <a id="_idIndexMarker1203"/>see that the only static file being used on this page is the <strong class="source-inline">home_page.jpg</strong> file. Since the <strong class="source-inline">index.html</strong> file is not extending the <strong class="source-inline">base_template_1.html</strong> file, we don't have any CSS or JavaScript files used on this page; they do not get loaded. Should you activate the DjDT and go back to previous chapters, you will likely see those additional assets because we were using the <strong class="source-inline">base_template_1.html</strong> file. Any debug tools, such as CSS and JavaScript files related to the DjDT, will not be shown in the middle section. The idea is that those are debug-related assets and we don't need to know that on the page that we are debugging. Should you inspect a page using your browser tools, you will see assets related to the DjDT; they will not appear in production.</p>
			<h3>Templates</h3>
			<p>The <strong class="bold">Templates</strong> panel <a id="_idIndexMarker1204"/>displays information related to the templates used and the context that is available. The middle section displays all of the templates. If you had partial HTML files using includes or extends, each one of those templates would appear in this list in the order that they are used. When you click on the <strong class="bold">Toggle context</strong> arrow, shown in the following screenshot, it will display a list of all of the context variables and their values related to that file:</p>
			<div>
				<div id="_idContainer138" class="IMG---Figure">
					<img src="image/Figure_9.11_B17243.jpg" alt="Figure 9.11 – DjDT – Templates tab&#13;&#10;"/>
				</div>
			</div>
			<p class="figure-caption">Figure 9.11 – DjDT – Templates tab</p>
			<p>The following screenshot depicts what clicking the <strong class="bold">Toggle context</strong> button looks like, showing us the context available in that particular template or partial file:</p>
			<div>
				<div id="_idContainer139" class="IMG---Figure">
					<img src="image/Figure_9.12_B17243.jpg" alt="Figure 9.12 – DjDT – Templates tab showing context&#13;&#10;"/>
				</div>
			</div>
			<p class="figure-caption">Figure 9.12 – DjDT – Templates tab showing context</p>
			<p>At the bottom of this panel is where all of the context processors are located. You can view the <a id="_idIndexMarker1205"/>context available in each of the context processors available.</p>
			<h3>Cache</h3>
			<p>The <strong class="bold">Cache</strong> panel<a id="_idIndexMarker1206"/> displays all of the cached objects involved with this page. This is if you are using tools that help enhance the performance of your database. This is considered an advanced topic beyond the scope of this book.</p>
			<p class="callout-heading">Note</p>
			<p class="callout">The DjDT publisher also notes in their own documentation that this panel is incompatible with Django's per-site caching.</p>
			<h3>Signals</h3>
			<p>The <strong class="bold">Signals</strong> panel <a id="_idIndexMarker1207"/>displays the notifiers and receivers within an application that are communicating with each other. These can be closely compared to what <strong class="bold">WebSocket</strong> is. This is also considered an advanced topic beyond the scope of this book.</p>
			<h3>Logging</h3>
			<p>The <strong class="bold">Logging</strong> panel is a<a id="_idIndexMarker1208"/> quick and easy way to view logs in Django. Similar to the Django messages framework, introduced in <a href="B17243_07_ePub.xhtml#_idTextAnchor214"><em class="italic">Chapter 7</em></a>, <em class="italic">Working with Messages, Email Notifications, and PDF Reports</em>, Django allows the use of the standard Python <strong class="source-inline">logging</strong> library. Before showing how this panel looks, let's wire up an actual log to view. As with the Django messages framework, the logging system has different levels of messages. The default minimum log level is <strong class="source-inline">WARNING</strong> but you can show <strong class="source-inline">DEBUG</strong>- and <strong class="source-inline">INFO</strong>-level logs the same way, either by setting it in your <strong class="source-inline">settings.py</strong> file or by declaring it inline where your log is set, as we are going to do in the following steps. To learn more about all of the capabilities of using the logging system, visit <a href="https://docs.djangoproject.com/en/4.0/topics/logging/">https://docs.djangoproject.com/en/4.0/topics/logging/</a> and <a href="https://docs.python.org/3/library/logging.html">https://docs.python.org/3/library/logging.html</a>.</p>
			<p>Take the following steps to practice using the logging system:</p>
			<ol>
				<li value="1">In your <strong class="source-inline">/chapter_4/views.py</strong> file, add the following log statements at the beginning of the existing <strong class="source-inline">practice_year_view()</strong>:<p class="source-code"><strong class="bold"># /becoming_a_django_entdev/chapter_4/views.py</strong></p><p class="source-code">...</p><p class="source-code">import <strong class="bold">logging</strong></p><p class="source-code">def <strong class="bold">practice_year_view</strong>(request, year):</p><p class="source-code">    <strong class="bold">logger = logging.getLogger(__name__)</strong></p><p class="source-code">    <strong class="bold">logger.setLevel(logging.INFO)</strong></p><p class="source-code">    <strong class="bold">logger.info('The Requested Year Is: %s' % year)</strong></p><p class="source-code">    ...</p></li>
			</ol>
			<p>The first two<a id="_idIndexMarker1209"/> lines lower the logging level to show all <strong class="source-inline">INFO</strong>-level logs and higher, allowing us to use the <strong class="source-inline">logger.info()</strong> method to create the log message. Otherwise, the lowest level we could use by default would be the <strong class="source-inline">logger.warning()</strong> level method. The log message we are expecting to see should be <strong class="source-inline">The Requested Year Is: 2022</strong> when visiting the URL. </p>
			<ol>
				<li value="2">Now, navigate to <a href="http://localhost:8000/my_year_path/2022/">http://localhost:8000/my_year_path/2022/</a> in your browser and expand the debug toolbar. Open the <strong class="bold">Logging</strong> tab and now you should see the log that we created, as depicted in the following screenshot:</li>
			</ol>
			<div>
				<div id="_idContainer140" class="IMG---Figure">
					<img src="image/Figure_9.13_B17243.jpg" alt="Figure 9.13 – DjDT – Logging tab&#13;&#10;"/>
				</div>
			</div>
			<p class="figure-caption">Figure 9.13 – DjDT – Logging tab</p>
			<h3>Intercept redirects</h3>
			<p>The <strong class="bold">Intercept redirects</strong> checkbox <a id="_idIndexMarker1210"/>is used to display an intermediary page whenever a redirect is performed to display information about that redirect, before the browser is updated with the redirected page.</p>
			<h3>Profiling</h3>
			<p>The <strong class="bold">Profiling</strong> checkbox<a id="_idIndexMarker1211"/> enables the gathering of extra data on page load. It is a detailed analysis of memory and CPU processes taking place. Each process is broken down into the smallest measurements possible. By default, this checkbox is left unchecked. An example of what this looks like is shown in the following screenshot:</p>
			<div>
				<div id="_idContainer141" class="IMG---Figure">
					<img src="image/Figure_9.14_B17243.jpg" alt="Figure 9.14 – DjDT – Profiling tab&#13;&#10;"/>
				</div>
			</div>
			<p class="figure-caption">Figure 9.14 – DjDT – Profiling tab</p>
			<p>We now have a deeper understanding of all of the tabs available within the DjDT and what they are used for. This now adds a wealth of tools to our toolbox to help us make world-class applications with ease.</p>
			<h1 id="_idParaDest-262"><a id="_idTextAnchor292"/>Summary</h1>
			<p>By now, we have developed a solid understanding of how automated testing in Django is performed. We wrote several test cases that test many of the exercises done in previous chapters. We practiced writing test cases that simulate success and others that deliberately trigger a failure to better understand what is happening. We even discovered how to write test cases that work with the Django REST framework. After we worked with automated testing, we then installed what I would consider the most powerful tool of them all, the DjDT. The DjDT is used for real-time debugging of developers' code as they write that code and run their projects locally. </p>
			<p>In the next chapter, we will learn how to use the DjDT to monitor performance as we learn how to optimize database queries.</p>
		</div>
	</body></html>