- en: '7'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The Animation System
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 3D owes much of its popularity to the production of animated content. Its many
    advantages in terms of performance, quality, and scalability made it ubiquitous
    in motion pictures, cartoons, feature animation, and video games. With that comes
    the need for custom tools to ease animation-related tasks.
  prefs: []
  type: TYPE_NORMAL
- en: 'Most applications handle animation similarly, in part inherited from hand-drawn
    workflows: a sequence is broken into frames, whose rapid succession creates the
    illusion of motion.'
  prefs: []
  type: TYPE_NORMAL
- en: A programmer working in 3D will have to account for animated values changing
    over time, and how such data is stored.
  prefs: []
  type: TYPE_NORMAL
- en: That might change in the future, but at the time of writing, animation involves
    a huge amount of manual work, leaving much room for automation.
  prefs: []
  type: TYPE_NORMAL
- en: In this chapter, you will get acquainted with the Blender animation process,
    learn how to access animation data in Python, and build one tool that sets the
    playback range and another that animates objects.
  prefs: []
  type: TYPE_NORMAL
- en: 'This chapter will cover the following topics:'
  prefs: []
  type: TYPE_NORMAL
- en: Understanding the animation system
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Changing the playback settings
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Creating animations with Python
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Technical requirements
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We will use Blender and Visual Studio Code in this chapter. The examples created
    in this chapter can be found at [https://github.com/PacktPublishing/Python-Scripting-in-Blender/tree/main/ch7](https://github.com/PacktPublishing/Python-Scripting-in-Blender/tree/main/ch7).
  prefs: []
  type: TYPE_NORMAL
- en: Understanding the animation system
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'While animations consist of a sequence of frames, only one frame is displayed
    on the screen at one time. Animators can scroll through these frames and play
    their animation like a video:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 7.1: Playing an animation in Blender](img/Figure_7.01_B18375.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 7.1: Playing an animation in Blender'
  prefs: []
  type: TYPE_NORMAL
- en: The animation **Timeline**, at the bottom of the screen in the **Layout** workspace,
    controls and displays the current frame and the start/end of the sequence. It
    provides immediate visual feedback and is essential to animation.
  prefs: []
  type: TYPE_NORMAL
- en: Timeline and Current Frame
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'A **Timeline** is a Blender area for playing animations and changing the playback
    settings. It is marked with a clock icon and, because of its importance, is in
    more than one workspace: **Animation**, **Layout**, **Rendering**, and **Compositing**
    display a timeline.'
  prefs: []
  type: TYPE_NORMAL
- en: 'In addition to the frame **Start** and **End** values, there is a slider for
    the **Current Frame** area and a button bar with **Media Controls**:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 7.2: Blender’s animation Timeline](img/Figure_7.02_B18375.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 7.2: Blender’s animation Timeline'
  prefs: []
  type: TYPE_NORMAL
- en: Besides frame range and controls, the timeline displays the **keyframes** –
    that is, frames that contain changes in the object properties.
  prefs: []
  type: TYPE_NORMAL
- en: The frame range information, which is relevant to other tasks, such as **Rendering**,
    is an attribute of the scene that can be also set in the scene properties.
  prefs: []
  type: TYPE_NORMAL
- en: Duration and Frame Rate
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The duration of the current scene can be set in the **Format** and **Frame Range**
    panels in the **Output** properties, the second tab starting from above, marked
    with a printer icon.
  prefs: []
  type: TYPE_NORMAL
- en: One scene, four tabs!
  prefs: []
  type: TYPE_NORMAL
- en: There are so many scene properties that they span the first four tabs. It can
    be confusing because all of them read **Scene** in their headers.
  prefs: []
  type: TYPE_NORMAL
- en: 'These four categories are as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '- **Render**, marked with a TV icon'
  prefs: []
  type: TYPE_NORMAL
- en: '- **Output**, with a printer icon'
  prefs: []
  type: TYPE_NORMAL
- en: '- **View Layers**, whose icon is a stack of pictures'
  prefs: []
  type: TYPE_NORMAL
- en: '- **Scene**, whose icon represents a cone and a sphere'
  prefs: []
  type: TYPE_NORMAL
- en: Only the **Output** properties contain animation-related settings.
  prefs: []
  type: TYPE_NORMAL
- en: The **Frame Rate** property displays how many frames are contained in 1 second
    of animation and is also known as **frames per** **second** (**FPS**).
  prefs: []
  type: TYPE_NORMAL
- en: 'The default value is `24 FPS`, the historical rate for feature films. Because
    of the frequency of the power grid, footage for American TV is usually shot at
    `30` FPS, while European TVs use `25` FPS. Motion capture or video game animations
    may have higher rates, such as `60` FPS:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 7.3: Scene range attributes](img/Figure_7.03_B18375.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 7.3: Scene range attributes'
  prefs: []
  type: TYPE_NORMAL
- en: Raising the **Frame Rate** value makes the animation play more frames per second,
    so it shortens the playback duration as more frames are spent in less time.
  prefs: []
  type: TYPE_NORMAL
- en: 'While the graphic interface allows the animator to either pick a frame rate
    from a list of presets or display an additional property for custom values, in
    Python, `fps` is a numeric attribute of the `scene.render` properties:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: By default, the first frame of a scene, `1` while the last frame, `250`. These
    values are arbitrary and are changed to the planned duration of a specific shot.
  prefs: []
  type: TYPE_NORMAL
- en: 'The first and last frame of the scene can be accessed in Python as scene attributes:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: '`1`. It can be increased so that not all frames are rendered, a feature used
    by render managers to test the overall state of a sequence:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: While the start, end, and step of the sequence are available in the **Output**
    properties as well, the **current frame** and the **preview range** are displayed
    only in the **Timeline** view.
  prefs: []
  type: TYPE_NORMAL
- en: Current frame and preview range
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Like `frame_start`, `frame_end`, and `frame_step`, the current frame is exposed
    as a Python attribute of the scene:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: 'In the **Timeline** view, the button with a stopwatch icon on the left of **Start**/**End**
    toggles the preview range. It displays an alternate range, different from the
    render settings:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 7.4: Enabling the preview range in the Timeline view](img/Figure_7.04_B18375.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 7.4: Enabling the preview range in the Timeline view'
  prefs: []
  type: TYPE_NORMAL
- en: The region outside the preview range is marked in dark orange. Animators turn
    on the preview range to restrict the playback when they are working on a part
    of their assigned sequence.
  prefs: []
  type: TYPE_NORMAL
- en: 'In Python, we can access `frame_preview_start` and `frame_preview_end` like
    so:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: All the frames between `start` and `end` make the animated sequence, but not
    all frames must store information. Those that do are the keyframes of the animation.
  prefs: []
  type: TYPE_NORMAL
- en: Animation keyframes
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The position of objects at a certain moment is stored as **keyframes**. In this
    section, we will provide a brief overview of how keyframes are created and retrieved
    in the user interface, as well as with Python instructions.
  prefs: []
  type: TYPE_NORMAL
- en: Adding keyframes in Blender
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'There are at least two ways to set keyframes in Blender:'
  prefs: []
  type: TYPE_NORMAL
- en: Right-click on a property, then click on **Insert Keyframe(s)** from the context
    menu
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Press **I** in the Viewport to display the **Insert Keyframe Menu** area and
    select a property to animate
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: We can make changes and insert keyframes at different times to create an animation.
  prefs: []
  type: TYPE_NORMAL
- en: Animating objects
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'To get more familiar with animations, we can open Blender and add keyframes
    for the location of the default cube:'
  prefs: []
  type: TYPE_NORMAL
- en: Open Blender and select an object. If there are none in the scene, we can use
    **Add** | **Mesh** | **Cube** from the top menu.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Press the *N* key to display the properties of the active object.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Right-click on any of the **Location** attributes.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Select **Insert Keyframes**.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'However, one keyframe is not enough to make the cube move on the screen. To
    create a proper animation, we need to do the following:'
  prefs: []
  type: TYPE_NORMAL
- en: Set a new value for the `24`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Move the cube to a new location by pressing the *G* key and panning the mouse.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Confirm the new position by left-clicking or pressing the *Enter* key.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Press `I` to insert a **Location** keyframe.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: We can play our animation by pressing the *spacebar* or clicking the **Play**
    button. In some instances, we might want to restrict the frame range to watch
    our animation in loops. We can set the sequence’s **Start** and **End** manually,
    or we can write an add-on that sets them for us.
  prefs: []
  type: TYPE_NORMAL
- en: Writing the Action to Range add-on
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Animators set the first and last frames of the scene according to the duration
    of the shot. If there are animated objects, this add-on can set the playback range
    automatically.
  prefs: []
  type: TYPE_NORMAL
- en: This operator will allow you to choose between the render and preview range.
  prefs: []
  type: TYPE_NORMAL
- en: Setting the environment
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Let’s create a folder for this chapter in our project. Then, in the `ch7` folder
    as our **Scripts Folder**. We must restart Blender to update its search paths.
  prefs: []
  type: TYPE_NORMAL
- en: 'Our add-on contains an operator, like the ones from [*Chapter 3*](B18375_03.xhtml#_idTextAnchor049),
    and [*Chapter 4*](B18375_04.xhtml#_idTextAnchor075):'
  prefs: []
  type: TYPE_NORMAL
- en: Select `PythonScriptingBlender/ch7/addons`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Create a new file by clicking the **New** **File** icon.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Name the new file `action_to_range.py`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Open the file by double-clicking it.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: We can now start writing our first animation add-on.
  prefs: []
  type: TYPE_NORMAL
- en: Writing the Action to Range information
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The operator will be invoked from the **View** menu of the **Timeline** view,
    as reported in the location information:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: 'The next steps are as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: Writing the operator.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Writing its menu entry.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Registering the classes and user interface.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Let’s start with the operator class and its information.
  prefs: []
  type: TYPE_NORMAL
- en: Writing the Action to Range operator
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'As usual, the `ActionToSceneRange` operator derives from `bpy.types.Operator`
    and starts with the `bl_*` identifiers:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: 'As noted in the *Understanding the animation system* section, there are two
    frame range settings in the scene: the main one affects the scene render, while
    the preview range only affects the Viewport playback.'
  prefs: []
  type: TYPE_NORMAL
- en: 'We want a parameter to switch between the two. We will use a `BooleanProperty`
    so that we can affect either the main or preview range:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: That’s all for the static part of the operator. Adding a `poll` and an `execute`
    method will allow the operator to run.
  prefs: []
  type: TYPE_NORMAL
- en: Writing the operator methods
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: As we learned in [*Chapter 3*](B18375_03.xhtml#_idTextAnchor049), the `poll`
    method returns `False` when the conditions for running the operator are not met;
    it’s `True` otherwise. We need to determine the operator requirements and put
    them in Python form.
  prefs: []
  type: TYPE_NORMAL
- en: Checking the requirements in the poll() method
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'To get the range of the active animation, we must verify the following conditions:'
  prefs: []
  type: TYPE_NORMAL
- en: There should be an active object
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The active object must be animated
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: When an object is animated, its keyframes are grouped into an **action**, which,
    in turn, becomes the active action in the object’s **animation data**.
  prefs: []
  type: TYPE_NORMAL
- en: 'We will explore these entities in more depth in the next section, *Accessing
    animation data in Python*. For now, we can just test their existence in the following
    code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: When any of the `not` conditions are met, the operator is grayed out in the
    interface. Otherwise, the operator can be launched, and that will run its `execute`
    method.
  prefs: []
  type: TYPE_NORMAL
- en: Writing the execute method
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'The `execute` method performs the operator activity. It does the following:'
  prefs: []
  type: TYPE_NORMAL
- en: Finds the frame range of the current action
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Sets the first and last frame of the scene accordingly
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Fits the new frame range in the timeline visually
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'We already know how to access the active object’s action. Its `frame_range`
    attribute contains the first and last frame of the action:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: 'We get the current `scene` and perform *step 2*. If the timeline preview range
    is used, we should set the preview start/end frames. Frame values are stored as
    decimal floats, and we need to convert them into integers before using them for
    the `frame*` attributes:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: 'Otherwise, we must set the standard `frame_start` and `frame_end` of the scene:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: 'Now that we have set our values, we can invoke `ops.action.view_all()` to fit
    the **Timeline** view to the new range, and finish the execution:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: 'We need to add `''UNDO''` to `bl_options` to affect the operator attributes
    after the execution, as we learned in [*Chapter 4*](B18375_04.xhtml#_idTextAnchor075):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: Unfortunately, operators that are launched outside of the `use_preview` to `False`.
  prefs: []
  type: TYPE_NORMAL
- en: To work around that, we can create two entries in the **Timeline** | **View**
    menu.
  prefs: []
  type: TYPE_NORMAL
- en: Writing the menu function
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In [*Chapter 3*](B18375_03.xhtml#_idTextAnchor049), we learned that adding a
    function to a menu class allows us to add elements to its layout.
  prefs: []
  type: TYPE_NORMAL
- en: Also, in [*Chapter 5*](B18375_05.xhtml#_idTextAnchor100), we learned that operator
    properties are returned by the `layout.operator` function and can be set programmatically.
  prefs: []
  type: TYPE_NORMAL
- en: Combining these two techniques, we can create two menu entries that invoke the
    same operator, but we only enable `use_preview` on one of the two. This way, we
    end up with two menu items. They execute the same operator but with different
    settings and outcomes.
  prefs: []
  type: TYPE_NORMAL
- en: 'To make sure that the difference is reflected in the operator label, we can
    change it using the `text=` parameter:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: We have added `" (preview)"` to the operator label so that it’s clear that this
    is a variant of the `ActionToSceneRange` operator.
  prefs: []
  type: TYPE_NORMAL
- en: 'The default entry affects the actual scene range, so there is no need to specify
    the text label explicitly:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: Menu entries are displayed with a **Last In First Out** (**LIFO**) policy. We
    added the (preview) item first, so it will be displayed after the default **Action
    to Scene** **Range** entry.
  prefs: []
  type: TYPE_NORMAL
- en: It won’t default forever!
  prefs: []
  type: TYPE_NORMAL
- en: '`ActionToSceneRange.use_preview` is already `False` by default, but we set
    `props.use_preview` to `False` anyway in `view_menu_items`.'
  prefs: []
  type: TYPE_NORMAL
- en: Unless `is_skip_save` is used for a property, the default value only affects
    the first execution of an operator. From then on, the last user choice becomes
    the new default.
  prefs: []
  type: TYPE_NORMAL
- en: If an element of the interface matches specific operator settings, then we should
    set them explicitly in the code.
  prefs: []
  type: TYPE_NORMAL
- en: Now that we’ve created the elements of the add-on, we need to register the operator
    and menu entries. Then, it will be ready to go.
  prefs: []
  type: TYPE_NORMAL
- en: Finishing the add-on
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: We need the class name of the **Timeline** | **View** menu. To find it, we can
    look up the Python source of the Blender interface.
  prefs: []
  type: TYPE_NORMAL
- en: Finding a menu’s Python class
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'We can right-click the **Timeline** | **View** menu and select **Edit Source**
    to find its Python name:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 7.5: Opening Timeline | View](img/Figure_7.05_B18375.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 7.5: Opening Timeline | View'
  prefs: []
  type: TYPE_NORMAL
- en: 'Then, in the `space_time.py` in the **Text** **Editor** area:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 7.6: space_time.py as a loaded text block](img/Figure_7.06_B18375.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 7.6: space_time.py as a loaded text block'
  prefs: []
  type: TYPE_NORMAL
- en: 'The script found in the `menu()` function is the class name we are looking
    for:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: We can use this name in our `register()` function.
  prefs: []
  type: TYPE_NORMAL
- en: Writing the register/unregister functions
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'We can use `register_class` to add `ActionToSceneRange` to the Blender operators,
    and we can append our items to `TIME_MT_view` to display our new entries in the
    **Timeline** | **View** menu:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: 'Likewise, when the add-on is disabled, `unregister()` removes our items from
    the menu and the operator from Blender:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: Now, the operator is ready. We can use it on the cube we animated earlier in
    this chapter or open one of the files contained in `ch7/_scenes_`.
  prefs: []
  type: TYPE_NORMAL
- en: Enabling and running
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'If the `PythonScriptingBlender/ch7` folder was added to the `scripts` path,
    we can find and enable **Action to Range** in the **Add-ons** preferences:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 7.7: Enabling the Action to Range add-on](img/Figure_7.07_B18375.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 7.7: Enabling the Action to Range add-on'
  prefs: []
  type: TYPE_NORMAL
- en: 'If the add-on was installed correctly, we will find two new entries in **Timeline**
    | **View**:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 7.8: Action to Scene Range and its “preview” variant](img/Figure_7.08_B18375.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 7.8: Action to Scene Range and its “preview” variant'
  prefs: []
  type: TYPE_NORMAL
- en: Clicking **Action to Scene Range** sets the scene range to 1-24, while **Action
    to Scene Range (preview)** sets the preview range.
  prefs: []
  type: TYPE_NORMAL
- en: Since we have set `bl_options = {'REGISTER', 'UNDO'}` in the properties, we’ll
    look at how this operator supports the **Adjust Last** **Operation** window.
  prefs: []
  type: TYPE_NORMAL
- en: Changing the parameters of the last operation
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'We can use **Edit** | **Adjust Last Operation** from the top menu bar to change
    the options in the last execution retroactively:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 7.9: Changing the outcome of the last operation](img/Figure_7.09_B18375.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 7.9: Changing the outcome of the last operation'
  prefs: []
  type: TYPE_NORMAL
- en: 'A small window will appear, displaying the operator properties. Turning `use_preview`
    on and off changes the result of the operation:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 7.10: The Action to Scene Range properties window](img/Figure_7.10_B18375.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 7.10: The Action to Scene Range properties window'
  prefs: []
  type: TYPE_NORMAL
- en: The add-on is finished, but when it comes to recentering the `bpy.ops.action.view_all()`,
    a timeline operator. It is fine to call other operators in `execute`, but they
    can place additional restrictions on the validity of the context, so we must consider
    that their `poll` method might halt our script’s execution.
  prefs: []
  type: TYPE_NORMAL
- en: For instance, by adding our operator to the `action.view_all()`, which requires
    it, will never fail.
  prefs: []
  type: TYPE_NORMAL
- en: 'But what if the `F3` `RuntimeError`:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 7.11: Our script causes an error if the timeline is not displayed](img/Figure_7.11_B18375.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 7.11: Our script causes an error if the timeline is not displayed'
  prefs: []
  type: TYPE_NORMAL
- en: 'We can just warn the user or check the presence timelines in our `poll` method,
    but usually, the best practice is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: Use a `try` statement when calling other operators
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: If possible, if a `RuntimeError` occurs, create an alternate `context` for running
    the other operator
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: This way, even if something goes wrong, our operator will carry on with its
    task.
  prefs: []
  type: TYPE_NORMAL
- en: Fixing context for other operators
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: We can prevent a Python script from stopping in case of errors by using `try`
    and `catch` statements. The code that risks causing errors goes under the `try`
    indent block, while the code to execute in case a specific error happens goes
    under the `except` `ErrorType` indent.
  prefs: []
  type: TYPE_NORMAL
- en: 'In our case, the error message was raised when `RuntimeError`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: 'To get past this issue, we must provide a plan B inside an `except RuntimeError`
    block. If we don’t want to do anything, we can use the empty `pass` instruction:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: 'But we can do better: we can look for a timeline in the window, override `context`,
    and pass it to the operator.'
  prefs: []
  type: TYPE_NORMAL
- en: In [*Chapter 5*](B18375_05.xhtml#_idTextAnchor100), we learned that a Blender
    window is split into `screen`, `areas`, and `regions`. From the documentation,
    we know that timeline editors are of the `'``DOPESHEET_EDITOR'` type.
  prefs: []
  type: TYPE_NORMAL
- en: 'There might be more windows open. For each of them, we can get the screen attribute:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: 'Then, we must look for a `''DOPESHEET_EDITOR''` among `areas` of the screen:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: 'By skipping every area that is *not* a `''DOPESHEET_EDITOR''`, we can ensure
    that the following lines are executed only if the area is a timeline. We need
    to look for its main region, which is of the `''``WINDOW''` type:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: The timeline’s `window`, `area`, and `region` are fed to `context.temp_override`
    inside a `with` statement.
  prefs: []
  type: TYPE_NORMAL
- en: 'In Python, `with` sets a condition that stays valid inside its scope – that
    is, indented lines of code. There, we can call `bpy.ops.action.view_all()`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: The two `break` statements stop the search after a timeline is found. We have
    made sure that `view_all` is called only if its conditions are met.
  prefs: []
  type: TYPE_NORMAL
- en: Our add-on automated a tedious operation by checking the action frame range,
    without looking into the keyframes it contains. To understand how we can access
    and manipulate the animation data, next, we will learn how keyframes are displayed
    and edited.
  prefs: []
  type: TYPE_NORMAL
- en: Editing keyframes
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Animation software gives visual cues of keyframe distribution. In Blender, keyframes
    are displayed with special colors in the interface and as diamond widgets in the
    animation editors.
  prefs: []
  type: TYPE_NORMAL
- en: 'Animated properties have colored backgrounds. If the current frame is a keyframe,
    the background is yellow; otherwise, it is green:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 7.12: Location is animated; the current frame is the keyframe for
    X and Y](img/Figure_7.12_B18375.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 7.12: Location is animated; the current frame is the keyframe for X
    and Y'
  prefs: []
  type: TYPE_NORMAL
- en: 'Keyframes of the selected objects are displayed as diamonds in the **Timeline**
    editor:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 7.13: The animation Timeline. Frames 1 and 24 have keyframes](img/Figure_7.13_B18375.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 7.13: The animation Timeline. Frames 1 and 24 have keyframes'
  prefs: []
  type: TYPE_NORMAL
- en: Blender transitions from one keyframe to the other by tracing a graph between
    them. These graphs are referred to as **animation curves** or **f-curves**.
  prefs: []
  type: TYPE_NORMAL
- en: Animation curves and the Graph Editor
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Like most animation software, Blender generates a transition between two animated
    values by inbetweening two or more keyframes. A keyframe contains two elements
    – a moment in time and the value of a property at that moment.
  prefs: []
  type: TYPE_NORMAL
- en: 'These changes in value over time are represented in the **Graph Editor** area,
    a coordinate system where the horizontal axis is the frame number and the vertical
    axis is the animated value at each frame:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 7.14: Values over time as animation curves in the Graph Editor](img/Figure_7.14_B18375.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 7.14: Values over time as animation curves in the Graph Editor'
  prefs: []
  type: TYPE_NORMAL
- en: A keyframe created at frame `1` that sets a property to `0` is displayed as
    a dot with coordinates of `(``1, 0)`.
  prefs: []
  type: TYPE_NORMAL
- en: Blender interpolates the transition between one keyframe and another. The transition
    between a keyframe and its neighbors is an **F-Curve** – that is, a continuous
    graph that connects two keyframes smoothly.
  prefs: []
  type: TYPE_NORMAL
- en: Say his F-name!
  prefs: []
  type: TYPE_NORMAL
- en: F-curves are named after James Ferguson, a researcher at The Boeing Company
    who, in 1964, published a paper named *Multivariable Curve Interpolation*. His
    interpolation formulas have fueled the advancements in modern computer graphics.
  prefs: []
  type: TYPE_NORMAL
- en: This way, every *animation curve*, or *F-Curve*, contains both the keyframes
    set by the animator and the transition generated by Blender, acting both as storage
    for the animation data and the interpolator that fills the parts where they are
    missing.
  prefs: []
  type: TYPE_NORMAL
- en: Interpolations can make use of straight lines connecting the points, or curve
    lines with tangent handles – that is, **Bezier** curves.
  prefs: []
  type: TYPE_NORMAL
- en: Setting a **Location** keyframe creates curves for the **X**, **Y**, and **Z**
    channels.
  prefs: []
  type: TYPE_NORMAL
- en: 'Animation curves are displayed in the **Graph Editor** area. We can select
    **Graph Editor** from the drop-down list on the left of any area header:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 7.15: Selecting the Graph Editor as the content of a Blender area](img/Figure_7.15_B18375.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 7.15: Selecting the Graph Editor as the content of a Blender area'
  prefs: []
  type: TYPE_NORMAL
- en: The f-curves of an animation are stored in **actions**, which are the top containers
    in the animation data.
  prefs: []
  type: TYPE_NORMAL
- en: The structure of the animation data can be summed up as **Action** | **F-Curves**
    | **Keyframes**.
  prefs: []
  type: TYPE_NORMAL
- en: Traversing this hierarchy is done differently via Python, where we can retrieve
    the animation values in our scripts.
  prefs: []
  type: TYPE_NORMAL
- en: Accessing animation data in Python
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Let’s switch to the **Scripting Workspace** area to familiarize ourselves with
    the animation system API.
  prefs: []
  type: TYPE_NORMAL
- en: Adding keyframes in Python
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The Python class of every animatable object provides a method that we can use
    to insert keyframes, named `keyframe_insert`. It is very similar to the `data_path`
    string for specifying which property to animate. Optional parameters such as `index`
    and `frame` allow us to specify one of the channels of an aggregate property or
    a frame different from the current one:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: 'The following lines set a keyframe for the active object’s location to `10.0,
    10.0, 10.0` at frame `1`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: 'Animation requires a value to change over time, so just one keyframe is not
    enough. We will set another value for frame 24:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: We have only set a keyframe at the start and one at the end of our animation,
    but by default, Blender generates a transition between two neighbor keyframes
    so that the object will move a little bit at each of the frames between 1 and
    24.
  prefs: []
  type: TYPE_NORMAL
- en: Our object starts at the `10.0, 10.0, 10.0` coordinates of the `-10.0, -``10.0,
    -10.0`.
  prefs: []
  type: TYPE_NORMAL
- en: Geometrically speaking, these coordinates mark the front top-right corner and
    bottom-left corner of a cube, implying that the motion happened along the diagonal
    of the three-dimensional space.
  prefs: []
  type: TYPE_NORMAL
- en: Retrieving keyframes in Python
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'If the active object has keyframes, we can traverse its `animation_data`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: 'Since `animation_data` contains the current action, all its f-curves, and keyframes,
    we are going to use this container a lot. It can be convenient to store it as
    a variable as this way, we can avoid long lines of code while we gather the data.
    Here’s how we get the current `action`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: 'From the action, we can retrieve the list of animation `fcurves`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: 'For each curve, we can get the animated `data_path`. A data path identifies
    where a property is stored in Blender, but some properties, such as `location`,
    require an animation curve for each channel – for example, one curve for the *x*,
    one for *y*, and one for the *z* coordinate. For that reason, f-curves also have
    the `array_index` attribute, a number that designates the animated channel of
    an aggregate property. If we animate the three channels of `location` and scroll
    through the f-curves using Python, we will find three curves with the same path,
    `''location''`, each with a different index:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: 'Every `keyframe_point` stores two coordinates in the `co` attribute. The first
    is the frame number, while the second is the value of that frame:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: While the current, first, and last frames of the scene are stored as integers,
    `co[0]` is a `float`. This allows us to insert animations between adjacent frames
    (subframe animation).
  prefs: []
  type: TYPE_NORMAL
- en: 'The curve interpolation mode is stored in the keyframe’s `interpolation` attribute.
    The most used interpolations are as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '`''CONSTANT''`: No interpolation'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`''LINEAR''`: Interpolation using straight lines'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`''BEZIER''`: Interpolation using curves, weighted with *handles*'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Bezier curves, named after the French engineer Pierre Bèzier, are widely used
    in computer graphics because of their smooth and controllable behavior. They are
    the default interpolation in Blender. The current `interpolation` between a keyframe
    and its neighbors is stored as an attribute of the keyframe:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: 'Points of a Bezier curve have two additional coordinates – a left handle and
    a right one, both of which affect the interpolated path. To support curve interpolation,
    Blender keyframes contain two additional coordinates stored as the `handle_left`
    and `handle_right` attributes. Exactly like the `co` attribute, the curve handles
    are two-dimensional points:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs: []
  type: TYPE_PRE
- en: 'Blender supports other interpolations. They cover very specific cases and at
    the time of writing, they are not much used in animation. They are named after
    the mathematical function used in their computation, and they are described in
    the API documentation at [https://docs.blender.org/api/3.2/bpy.types.Keyframe.xhtml](https://docs.blender.org/api/3.2/bpy.types.Keyframe.xhtml)
    and #bpy.types.Keyframe.interpolation:'
  prefs: []
  type: TYPE_NORMAL
- en: '`QUAD`: Quadratic easing'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`CUBIC`: Cubic easing'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`QUART`: Quartic easing'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`QUINT`: Quintic easing'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`SINE`: Sinusoidal easing (weakest, almost linear but with a slight curvature)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`EXPO`: Exponential easing (dramatic)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`CIRC`: Circular easing (strongest and most dynamic)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`BACK`: Cubic easing with overshoot and settle'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`BOUNCE`: Exponentially decaying parabolic bounce, like when objects collide'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`ELASTIC`: Exponentially decaying sine wave, like an elastic band'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: We will get back to keyframes at the end of this chapter; in the meantime, we
    will build a tool that sets the scene playback based on the duration of the current
    animation.
  prefs: []
  type: TYPE_NORMAL
- en: In these examples, our script uses the attributes of existing animations. In
    the next section, we are going to create animations with Python.
  prefs: []
  type: TYPE_NORMAL
- en: Writing the Vert Runner add-on
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In this section, we will write an add-on that animates the selected objects
    along the geometry of the active object. The animation will trace a path that
    connects the vertices of a mesh, hence the name *Vert Runner*:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 7.16: Animating a toy along the vertices of a path](img/Figure_7.16_B18375.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 7.16: Animating a toy along the vertices of a path'
  prefs: []
  type: TYPE_NORMAL
- en: This can be a basis for procedural walks or patrols, motion effects, or any
    other case where we have a geometrical path.
  prefs: []
  type: TYPE_NORMAL
- en: 'In this operator, the selected objects and the active ones are treated differently:
    the active object is the reference geometry on which the selected objects are
    moved.'
  prefs: []
  type: TYPE_NORMAL
- en: Setting the environment
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Let’s start by adding a new script to our add-ons directory:'
  prefs: []
  type: TYPE_NORMAL
- en: Select `PythonScriptingBlender/ch7/addons` in **VS Code**.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Create a new file by clicking on the **New** **File** icon.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Name the new file `vert_runner.py`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Open the file by double-clicking it.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: As usual, we will start with the add-on information.
  prefs: []
  type: TYPE_NORMAL
- en: Writing the Vert Runner information
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Our new operator can be invoked by selecting `location` information:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs: []
  type: TYPE_PRE
- en: 'We will proceed with the usual steps:'
  prefs: []
  type: TYPE_NORMAL
- en: Writing the operator
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Writing the menu entry
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Registering the classes and interface
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Writing the Vert Runner operator
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'After the `import` section, we must create the `VertRunner` class and its `bl_*`
    identifiers:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs: []
  type: TYPE_PRE
- en: 'We set the distance between each keyframe with an `Integer` property:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE37]'
  prefs: []
  type: TYPE_PRE
- en: The next step is writing the `poll` and `execute` methods of this operator.
  prefs: []
  type: TYPE_NORMAL
- en: Writing the operator methods
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: We will write the `poll` method based on what is needed to run the desired operations.
  prefs: []
  type: TYPE_NORMAL
- en: Requirements to check in the poll() method
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'To animate the selected objects over the geometry of the active object, we
    need the following:'
  prefs: []
  type: TYPE_NORMAL
- en: An active object
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Mesh data
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Selected objects
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Using these conditions, to have the `poll()` method return `False`, they translate
    to the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE38]'
  prefs: []
  type: TYPE_PRE
- en: If none of the `return False` conditions are met, the poll is successful. In
    that case, the operator can run its execute method.
  prefs: []
  type: TYPE_NORMAL
- en: Writing the execute() method
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Breaking the operator’s goal into steps, we should do the following:'
  prefs: []
  type: TYPE_NORMAL
- en: Get a list of patrol points; in this case, the vertices of the active object.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Scroll through the selected objects.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Move them through the patrol points and set the keyframes.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'We will start by storing the active object’s vertices in a `list`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE39]'
  prefs: []
  type: TYPE_PRE
- en: 'When we iterate through the selected objects, we should make sure to skip the
    active one, which is likely selected:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE40]'
  prefs: []
  type: TYPE_PRE
- en: 'Then, we must iterate through the vertices list and set keyframes for each
    coordinate, starting with the current frame. We must advance the `frame` number
    at every iteration:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE41]'
  prefs: []
  type: TYPE_PRE
- en: When the for loop is over, we must return a `'FINISHED'` state and exit the
    operator. Now that the `VertRunner` class is complete, we can work on its menu
    entry.
  prefs: []
  type: TYPE_NORMAL
- en: Writing the menu and register functions
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Since menu elements are displayed in reverse order, we must add a `separator`
    first:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE42]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, it’s time to register the operator and menu so that it can run from the
    interface:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE43]'
  prefs: []
  type: TYPE_PRE
- en: 'If we refresh the **Add-ons** list, we will see **Vert Runner** in the **Learning**
    category. Enabling it adds **Vert Runner** to the **Object** | **Animation** menu:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 7.17: Object | Animation | Vert Runner animates the selected objects](img/Figure_7.17_B18375.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 7.17: Object | Animation | Vert Runner animates the selected objects'
  prefs: []
  type: TYPE_NORMAL
- en: Using **Vert Runner** after selecting at least two objects will animate the
    selected objects along the vertices of the active object. We can add an option
    to make the animation cyclic and animate the object rotation.
  prefs: []
  type: TYPE_NORMAL
- en: Creating cyclic animations
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Sometimes, we want the first and last frame of an animation to match so that
    we can watch it in loops – for instance, an endless clip of a character running
    in circles.
  prefs: []
  type: TYPE_NORMAL
- en: In our case, an object passes through all the points of a mesh, starting with
    the first and ending with the last vertex, so the first and last frames of the
    animation will differ.
  prefs: []
  type: TYPE_NORMAL
- en: To create an animation cycle, we need to add the extra step of going back to
    the first coordinates after we have passed the last vertex.
  prefs: []
  type: TYPE_NORMAL
- en: 'The user must be able to choose whether they want a cyclic animation or not,
    so we will add an option to our operator. The `loop` attribute is a Boolean property
    – it can be enabled and disabled when the operator is run:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE44]'
  prefs: []
  type: TYPE_PRE
- en: 'The implementation is very easy: adding a copy of its first element at the
    end of `verts` brings the objects back to their initial position at the end of
    the animation:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE45]'
  prefs: []
  type: TYPE_PRE
- en: Animating rotations is slightly more complex. With the help of a little math,
    at each frame, we can orient the object toward its next destination.
  prefs: []
  type: TYPE_NORMAL
- en: Adding rotations
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The math behind rotations can be challenging at first, but since we just want
    to rotate the objects around their *Z*-axes, we can use basic **trigonometry**.
  prefs: []
  type: TYPE_NORMAL
- en: In trigonometry, angles can be represented as arcs of a circle of radius 1 and
    consequently, maximum length equal to two times π. The letter π (spelled pi) is
    the ratio between a circle and its diameter. Its approximate value is `3.14`.
  prefs: []
  type: TYPE_NORMAL
- en: Trigonometry is a framework that contains many useful functions regarding the
    relationships between angles, segments, and rotations. Among them, there is a
    function that answers the question we are posing – that is, how do we rotate an
    object so that it faces toward a point?
  prefs: []
  type: TYPE_NORMAL
- en: Representing rotation arcs
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Imagine rotating an object toward a point of known *X* and *Y* coordinates.
    If the rotation traces an arc over an imaginary circle, we can consider the `y`
    coordinate of our point as the *height* of that arc. This dimension is called
    the **sine** of the angle, and it is very useful when comparing angles and lengths.
  prefs: []
  type: TYPE_NORMAL
- en: 'The inverse of *sine* is called **arcsine**. It is of interest to us because
    it is the rotation associated with a sine. In other words, if we want to measure
    an angle and we know its *sine*, we can find the rotation using the following
    expression:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE46]'
  prefs: []
  type: TYPE_PRE
- en: 'We know the sine, which is the `y` coordinate of the point we want to look
    at:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 7.18: Trigonometric representation of a look-at rotation](img/Figure_7.18_B18375.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 7.18: Trigonometric representation of a look-at rotation'
  prefs: []
  type: TYPE_NORMAL
- en: So, *arcsine* is the trigonometric function we are looking for. It is shortened
    as `asin` in Python, and to use it, we must import it from the `math` module.
  prefs: []
  type: TYPE_NORMAL
- en: Implementing rotation
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'In trigonometry, we express rotations in `3.14` in our code, we can import
    the `pi` constant from the `math` module. So, besides `asin`, we need `pi` as
    well so that our import section looks like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE47]'
  prefs: []
  type: TYPE_PRE
- en: 'We will write the `VertRunner.aim_to_point` method to address object rotations
    separately. The first step to do that is subtracting the current position from
    the target coordinates so that we can get a direction:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE48]'
  prefs: []
  type: TYPE_PRE
- en: 'Then, we must normalize the direction so that the result is not affected by
    distance:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE49]'
  prefs: []
  type: TYPE_PRE
- en: 'The look-at rotation is returned by `asin(direction.y)`, but there is a catch:
    arcsine always assumes that it must cover the right-hand side of the circle –
    that is, positive values of `direction.x`. What happens when our direction falls
    on the other side?'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 7.19: Look-at rotation for negative values of x](img/Figure_7.19_B18375.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 7.19: Look-at rotation for negative values of x'
  prefs: []
  type: TYPE_NORMAL
- en: 'In that case, we can get to the other side of the circle by subtracting `pi`
    from the `asin` result since `pi` measures half of a unitary circumference length:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE50]'
  prefs: []
  type: TYPE_PRE
- en: We must also account for the fact that, in Blender, objects at rest look in
    the opposite direction of the *Y*-axis, so we must add a 90 degrees clockwise
    rotation to the result.
  prefs: []
  type: TYPE_NORMAL
- en: 'In radians, that’s `pi /` `2`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE51]'
  prefs: []
  type: TYPE_PRE
- en: 'At this point, `arc` contains the rotation we are looking for. We could use
    it right away, but there is still a problem: there are two ways to interpolate
    from one rotation to another.'
  prefs: []
  type: TYPE_NORMAL
- en: Finding the shortest arc
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Imagine rotating an object from 30° to 330°. The quickest way to do this is
    via a counterclockwise rotation that passes through 0° and stops at -30°, which
    is equivalent to 330°. The longest way is by passing clockwise from 30° to 180°
    and then, finally, 330°:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 7.20: Short and long arcs of rotation from 30 to 330 degrees](img/Figure_7.20_B18375.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 7.20: Short and long arcs of rotation from 30 to 330 degrees'
  prefs: []
  type: TYPE_NORMAL
- en: 'Both are a valid transition from 30° to 330°, but we might want to prefer the
    shortest rotation: doing otherwise would cause an object to spin on itself.'
  prefs: []
  type: TYPE_NORMAL
- en: 'To find the shortest arc away from the current rotation, we must store three
    possibilities in a tuple – the target orient, the same value after a complete
    clockwise rotation, and the same value rotated counterclockwise:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE52]'
  prefs: []
  type: TYPE_PRE
- en: 'Then, we must store the absolute rotational differences using a list comprehension.
    From there, we can get the shortest arc using `min`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE53]'
  prefs: []
  type: TYPE_PRE
- en: 'We must use the arc associated with the minimum difference. Using that as a
    condition of the `next` statement, we can find it and assign it to `rotation_euler.z`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE54]'
  prefs: []
  type: TYPE_PRE
- en: We can now animate rotations using the `aim_to_point` method inside `execute`.
  prefs: []
  type: TYPE_NORMAL
- en: Putting everything together
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'The final version of `execute` is only slightly different. It starts in the
    same way: gathering the list of vertices, adding the first vertex again if we
    are animating a cycle, and skipping the active object:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE55]'
  prefs: []
  type: TYPE_PRE
- en: 'Our orient method is based on the current object position, so before we start
    animating, we must move the object to the end of the path:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE56]'
  prefs: []
  type: TYPE_PRE
- en: 'This way, when the animation starts, `aim_to_point` orients the object toward
    the first vertex. Now, we must insert keyframes for `rotation_euler.z` as well
    and repeat the process until all the points have been reached. After that, we
    can finish the execution:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE57]'
  prefs: []
  type: TYPE_PRE
- en: By enabling **Vert Runner** in the add-ons list or updating the scripts if it
    was enabled already, we can test our add-on on any pair of objects.
  prefs: []
  type: TYPE_NORMAL
- en: Using Vert Runner
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'We can use this operator on every couple of objects. There is a peculiar entry
    among the solids available in Blender – a stylized head of a **Monkey** jokingly
    inserted among more common shapes such as **Cube**, **Plane**, **Sphere**, and
    so on. The monkey’s head, affectionately named **Suzanne**, makes rotations easier
    to visualize because of its obvious front side, so using it to test our add-on
    is a natural choice:'
  prefs: []
  type: TYPE_NORMAL
- en: Add a monkey head to the scene via **Add** | **Mesh** | **Monkey** from the
    Viewport menu bar.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Add any other mesh to the scene or use the Cube shape from the default scene
    if present.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Keeping *Shift* pressed (multiple selection), select the monkey, then select
    the object to use as an animation guide.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: From the Viewport menu bar, select **Object** | **Animation** | **Vert Runner**.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Play the animation with *Alt* + *A* or by clicking the media control button.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The cube will pass through each vertex of the active object. Speed and cyclic
    animation can be toggled in the options.
  prefs: []
  type: TYPE_NORMAL
- en: Though relatively simple, this tool can be expanded and generate motion for
    vehicles or even articulated characters.
  prefs: []
  type: TYPE_NORMAL
- en: Programming for animation generally comes down to converting an intuitive concept,
    such as looking toward a direction, into mathematical terms, like we did when
    extrapolating rotations. Plus, we have investigated the geometry structure and
    gained access to the vertex coordinates.
  prefs: []
  type: TYPE_NORMAL
- en: This brings us to the end of this chapter, where we learned how to affect the
    animation settings and the animation of objects.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we became familiar with object animation, learned how animations
    are created and stored, and looked at which scene settings are directly related
    to the animation system. We also learned how animation can be partly automated
    and approached from a geometric perspective, with a glimpse at the trigonometric
    representation of rotation angles.
  prefs: []
  type: TYPE_NORMAL
- en: Being able to automate part of the animation process is a valuable skill. Sometimes,
    the math involved might emerge and require solving, but we should not fear that,
    as math usually comes with a set of ready-to-use solutions for most ordinary use
    cases.
  prefs: []
  type: TYPE_NORMAL
- en: We have just started our journey into generated animation, which will continue
    in [*Chapter 8*](B18375_08.xhtml#_idTextAnchor206), where we will learn how to
    enrich animation curves with procedural effects.
  prefs: []
  type: TYPE_NORMAL
- en: Questions
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: How are animated values stored?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Can one animation curve contain the keyframes of an entire Vector property?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: How are animation curves grouped?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The current frame number is 1\. Without changing that setting, can we insert
    a keyframe at frame 4 using the user interface?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The current frame number is 1\. Without changing that setting, can we insert
    a keyframe at frame 4 using the Python API?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Does a smooth motion require a keyframe on every frame?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: How are keyframes interpolated?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Are there more ways to interpolate two rotations?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
