<html><head></head><body><div><div><div><div><h1 class="title"><a id="ch02"/>Chapter 2. Configuring a Test Project</h1></div></div></div><p>In this chapter, exclusive focus is on the structure and files contained in test. The topic has already been touched upon briefly in the first chapter, but a closer look at them would help set the background for further exploration as tests are the most important feature of the Robot Framework. The following major topics will be covered in this chapter:</p><div><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">Creating a Robot Framework test file and a testsuite.</li><li class="listitem" style="list-style-type: disc">Understanding differences in syntax across different file formats used in configuration. Gaining knowledge about the different configuration files.</li><li class="listitem" style="list-style-type: disc">Understanding and utilizing setup and teardown operations</li><li class="listitem" style="list-style-type: disc">Increasing automation through test re-use</li></ul></div><p>We will start by explaining, what a test is and how it can be defined. Different type of tests and common naming conventions along with examples will be explained thereafter. Test file structure and their supported formats will be understood by the end of the chapter.</p><p>The Robot Framework makes it very easy to change the test configuration used in a project once the project has properly been set up. However, it is best to understand what tests really are, and how should they be organized before diving deep into specific implementation.</p><p>Similar to the development of conventional software, tests can either be created in top-down manner with the big picture upfront or a bottoms-up approach, where the tests are created first and integrated later.</p><p>In the Robot Framework, you are encouraged to follow the top-down approach where the test structure is created first, before creating and writing down the actual implementation. While this is not enforced, it is useful towards writing big and sustainable tests and is the recommended way of creating a test.</p><p>Tests are<a id="id39" class="indexterm"/> organized in a tree-style structure that consists of testsuite, testcase, and testaction. This convention has been followed in most of the structured testing and is a widely followed convention. A<a id="id40" class="indexterm"/> testsuite is a collection of different tests and other testsuites, and provides a logical unit for a set to perform tests. A testcase is a complete test for a particular task. A testaction is the smallest element in any test and is atomic in nature, which only validates a given condition.</p><div><div><div><div><h1 class="title"><a id="ch02lvl1sec15"/>Test naming conventions</h1></div></div></div><p>Test naming conventions are<a id="id41" class="indexterm"/> important for the standardization and coherence of the tests. It also indicative of the quality of tests as the naming and placement <a id="id42" class="indexterm"/>of tests; and the use case scenarios indicate their order and relevance, which can be very useful when the tests are maintained in future.</p><div><div><div><div><h2 class="title"><a id="ch02lvl2sec16"/>Creating an execution order</h2></div></div></div><p>In order to <a id="id43" class="indexterm"/>name tests, the Robot Framework is very peculiar; it uses the configuration file and folder names to determine the execution order and test naming.</p><p>For example, consider the following arrangement of different test files and folders in the test project in the file system:</p><p>application/</p><p>  <code class="literal">tests/</code>
</p><p>    <code class="literal">Test1.txt</code>
</p><p>    <code class="literal">Other tests/</code>
</p><p>      <code class="literal">Another test.txt</code>
</p><p>Running the pybot in the application folder will result in creation of different testsuites in the report based on the order of their presence in the file system. The following screenshot shows the file structure of a Robot Framework test:</p><div><img src="img/3033OS_02_01.jpg" alt="Creating an execution order"/></div><p>After running, the <a id="id44" class="indexterm"/>tree command lists out the file/folder hierarchy. Here, the Robot Framework will infer the test hierarchy, group the tests, and nest test suites in form of files and folders. From this example, you can observe the following:</p><div><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">The <code class="literal">testsuites</code> folder will be the root test suite.</li><li class="listitem" style="list-style-type: disc">The folders such as <code class="literal">1__first_test</code> beneath the <code class="literal">testsuites</code> folder will act as nested test suites.</li><li class="listitem" style="list-style-type: disc">The test files contained within these folders will be the further nested test suites.</li></ul></div><p>For example, tests contained in <code class="literal">testsuites/2__different_file_formats/2__a_tsv_file_test.txt</code> will be nested, which can better be explained from the following screenshot:</p><div><img src="img/3033OS_02_02.jpg" alt="Creating an execution order"/></div><div><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">Test suite<a id="id45" class="indexterm"/> hierarchy is detailed in the log file. In order to organize the results, it is important to ensure proper naming. So, instead of using spaces, underscore "_" should be used (as demonstrated in the preceding example).</li><li class="listitem" style="list-style-type: disc">In order to get proper ordering irrespective of the test names, prefixing the test configuration with numbers can be done.</li></ul></div><div><div><div><div><h3 class="title"><a id="ch02lvl3sec01"/>Test randomization</h3></div></div></div><p>Sometimes, there may be requirement to explicitly disregard the execution order and run tests in random<a id="id46" class="indexterm"/> order. In that case, you can use the randomize option in the pybot command. This has the following options:</p><div><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">To randomize all the test suites as well as the tests contained within them:<div><pre class="programlisting">
<strong>pybot --randomize All all_tests</strong>
</pre></div></li><li class="listitem" style="list-style-type: disc">To randomize suites without affecting the tests contained within the lowest level suite:<div><pre class="programlisting">
<strong>pybot --randomize suites all_tests</strong>
</pre></div></li><li class="listitem" style="list-style-type: disc">To randomize only the tests within the suites, the suite execution order is unchanged:<div><pre class="programlisting">
<strong>pybot --randomize tests all_tests</strong>
</pre></div></li><li class="listitem" style="list-style-type: disc">To remove any randomization, if set in the command line:<div><pre class="programlisting">
<strong>pybot --randomize none all_tests</strong>
</pre></div><div><div><h3 class="title"><a id="note03"/>Note</h3><p>The<a id="id47" class="indexterm"/> command arguments are read from left to right, and randomize option can come more than once.</p></div></div></li></ul></div><p>In case of applying proper naming conventions like the following example, the example's test hierarchy will result in more understandable tests and the execution order of the tests can be easily predetermined. You can now easily infer the order of execution and hierarchy that will be present in the following order:</p><p>
<code class="literal">application/</code>
</p><p>    <code class="literal">testsuites/</code>
</p><p>        <code class="literal">1__Software_initialization.txt</code>
</p><p>        <code class="literal">2__main_screen_checks.txt</code>
</p><p>        <code class="literal">3__test_aux_controls/</code>
</p><p>            <code class="literal">1__check_user_details.txt</code>
</p><p>            <code class="literal">2__check_aux_control.txt</code>
</p><p>        <code class="literal">4__check_values/</code>
</p><p>            <code class="literal">1__primary_values.txt</code>
</p><p>            <code class="literal">2__footer.txt</code>
</p><p>            <code class="literal">3__links_to_other_controls.txt</code>
</p><p>
<code class="literal">....</code>
</p><p>It is noteworthy that the only exception to this naming rule is in form of initialization files, which are named as <code class="literal">__init__</code> followed by the extension as used in other test files. As there is only one <code class="literal">init</code> file per folder, it is clear that such a file contains information about its folder and the information contained in it pertains to the test suite itself.</p></div></div></div></div>
<div><div><div><div><h1 class="title"><a id="ch02lvl1sec16"/>Test file structure</h1></div></div></div><p>So far, it has been <a id="id48" class="indexterm"/>demonstrated that whitespaces play an important role in configuration files. The test configuration is written in a tabular format with each <a id="id49" class="indexterm"/>column having separate elements such as test element. The Robot Framework allows flexibility in specifying the separations among the different columns in a test file as well as supporting different formats for the test files, which you can choose at your discretion. Note that depending upon the file extension; a suitable parser is selected during runtime. Some of the supported formats are as follows:</p><div><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">HTML</li><li class="listitem" style="list-style-type: disc">TSV</li><li class="listitem" style="list-style-type: disc">Plaintext</li><li class="listitem" style="list-style-type: disc">Piped text</li><li class="listitem" style="list-style-type: disc">RestructuredText</li></ul></div><div><div><div><div><h2 class="title"><a id="ch02lvl2sec17"/>HTML format</h2></div></div></div><p>In an HTML format, the HTML is read, <a id="id50" class="indexterm"/>which comprises of different tables for different portions of the test configuration. For each table, the first heading <a id="id51" class="indexterm"/>element is read and based on this information; the rest of the table is understood. A word of caution! Any data that is outside the recognized table is discarded. You can understand this better with the help of following example:</p><div><pre class="programlisting">&lt;table&gt;
  &lt;th&gt;Test Case&lt;/th&gt;
  &lt;th&gt;Action&lt;/th&gt;
  &lt;th&gt;Argument&lt;/th&gt;
  &lt;th&gt;Argument&lt;/th&gt;
  &lt;tr&gt;
    &lt;td&gt;First Test Action&lt;/td&gt;
    &lt;td&gt;Log&lt;/td&gt;
    &lt;td&gt;This is a test written in HTML&lt;/td&gt;
  &lt;/tr&gt;
&lt;/table&gt;</pre></div><div><div><h3 class="title"><a id="tip02"/>Tip</h3><p>
<strong>Downloading the example code</strong>
</p><p>You can download the example code files for all Packt books you have purchased from your account at <a class="ulink" href="http://www.packtpub.com">http://www.packtpub.com</a>. If you purchased this book elsewhere, you can visit <a class="ulink" href="http://www.packtpub.com/support">http://www.packtpub.com/support</a> and register to have the files e-mailed directly to you.</p></div></div><p>Note that in the first column of table heading denotes the table name and it decides the subsequent execution of all elements contained in that table. This is followed by other headings that signify the position and order of other data. The rest of table contents populate the<a id="id52" class="indexterm"/> desired information in the specified order. Here, instead of delimiting the data by two spaces, it is present in different columns of the table. This method needs most overhead and verbose metadata, but the tests are very viewer-friendly and confusion of how much space to keep is also reduced as you can view these files easily in web browsers as well as edit in HTML editors.</p></div><div><div><div><div><h2 class="title"><a id="ch02lvl2sec18"/>TSV format</h2></div></div></div><p>In the tab separated value format, one can specify the different columns by passing the values separated by single <a id="id53" class="indexterm"/>tabs. One of the astounding features of this<a id="id54" class="indexterm"/> format is that it can be opened in any spreadsheet application, which gives you and other users greater control over the test configuration files. If the text editor in use supports viewing of whitespace (spaces and tabs), then it is a good idea to enable it in order to keep the tab separated test without any errors, as users can invariably mix the two, causing the tests to malfunction. Another appropriate way to create and maintain these tests is to use the spreadsheet application alone, which will reduce the chances of corrupting the test. On a spreadsheet (as shown in the following screenshot), the test file is more natural and intuitive to use as the columns are properly differentiated. If you are having prior experience in developing spreadsheet solutions but are new to the Robot Framework, your learning curve is considerably reduced and you may feel at ease while writing and maintaining tests in spreadsheets, which can also be formatted for better visibility and ease of use.</p><div><img src="img/3033OS_02_03.jpg" alt="TSV format"/></div></div><div><div><div><div><h2 class="title"><a id="ch02lvl2sec19"/>Plaintext format</h2></div></div></div><p>If test configuration file display is not an issue, then plaintext file is the best option as it is most readable and contains much less metadata, which makes version control easier. This method is the most widely used in this framework. However, you have to take care to ensure that the elements are properly separated and the column <a id="id55" class="indexterm"/>elements are delimited by two whitespace characters. If the arguments used in tests are small and have limited columns, then this is the appropriate display format. The syntax and placement of the elements in this way first require some acclimatization, but it becomes easier to create and modify test cases in this format as you do not need anything apart from a text editor for creating and updating the tests. Since the whitespaces need to be at least two or more, there is no way that more than a single empty column can be left in place. This might not seem problematic, but is quite handy, especially in situations where there is a need to provide for explicit whitespace <a id="id56" class="indexterm"/>separation for more than a single column.</p></div><div><div><div><div><h2 class="title"><a id="ch02lvl2sec20"/>Pipe-separated format</h2></div></div></div><p>Very closely resembling the previous format is the pipe separated format that uses pipe characters within the document<a id="id57" class="indexterm"/> to delimit the different<a id="id58" class="indexterm"/> columns. This is used where different lines contain varying number of arguments that are hard to spot. Consider the following snippet of a test:</p><div><pre class="programlisting">A Custom test  [Documentation]  this test is done to ensure product quality matches the requirements
    Log  Starting the product quality test
    Verify the initial condition exists  Should Be Equal  ${Product}  Drill Machine</pre></div><p>The verbosity of the test, in this case, makes it harder to read and understand the test. Even worse, if someone is modifying it, he can introduce errors by accident. For instance, the documentation has been updated as follows:</p><div><pre class="programlisting">A Custom test  [Documentation] The test ensures that product quality matches federal requirements</pre></div><p>If you observe the whitespace at the end of <code class="literal">[Documentation]</code>, there is only a single space, which clubs both the <code class="literal">Documentation</code> keyword and its argument into one and the Robot Framework cannot understand this, causing it to fail.</p><p>In order to rectify in the same text file itself, the Robot Framework offers the flexibility to use a pipe symbol (<code class="literal"> | </code>)<a id="id59" class="indexterm"/> instead of two spaces. Barring the first character of line, this symbol is surrounded by spaces on both sides, so the preceding test becomes:</p><div><pre class="programlisting">| A Custom test | [Documentation] | this test is done to ensure product quality matches the requirements |
|  | Log | Starting the product quality test |
|  | Verify the initial condition exists | Should Be Equal | ${Product} | Drill Machine </pre></div><p>This is more readable as the columns are now separated by the pipe. Note that the ending pipe at third line is not present as placement of pipe at the end of last column at any line is optional. If required within any column as a normal text, the pipe can be escaped using the backspace character. The escape string being (<code class="literal">\|</code>). Another advantage that this format offers over the plaintext format is that multiple columns can explicitly be declared empty and the test can still run correctly. This coupled with specific placement of the text in exactly the desired columns leads to creation of tests having very specific structure. Pipelines are also required to nest test structure in the presence of loops within the tests, which is similar to the indentation found in Python programming but is impossible in the Robot Framework as more than two whitespaces do not constitute an empty column or an indent in the test code (more on this later while discussing iteration within tests).</p></div><div><div><div><div><h2 class="title"><a id="ch02lvl2sec21"/>Restructured text format</h2></div></div></div><p>The <strong>ReStructuredText</strong> (<strong>reST</strong>) text format is familiar with any Python developer as it is used in Python documentation. It is a plaintext based markup that can easily be used to create highly formatted<a id="id60" class="indexterm"/> documents, tables, and so on using only a simple text file and a predefined set of markers. The advantage that it offers is very lesser metadata is used and the file contains majority of text that can easily be version controller, edited, differentiated, and well as searched. The <a id="id61" class="indexterm"/>rest mark-up offers advantages of both the HTML as well as plaintext file.</p><p>Similar to the HTML format, the test data is defined within tables and the Robot Framework looks up for the first element of the table to determine whether or not the table is a valid test table and, if this is correct, then its type is determined and the rest of the elements are processed accordingly. In this format, empty cells in the first column need to have a <code class="literal">\</code> or a <code class="literal">..</code> symbol.</p><div><pre class="programlisting">========  ===========  ==========  ========= =======
 Test Case        Action                     Argument            Argument          Argument
========  ===========  ==========  ========= =======
Custom check   [Documentation]    custom checks
\                         Log                        Starting checks
\
\                         Another Test          Should Be Equal<code class="literal">     </code>${Existing}     15.45
========  ===========  ==========  ========= =======</pre></div><p>As tools to process rest markup are part of the docutils project, you will need to have Python docutils module installed in the Python instance that is executing the tests. The Robot Framework internally converts the rest files into HTML documents and in case of problems with this format; other tools can be used to convert rest structured documents into HTML, which can be used to run the tests.</p><p>This is the flexibility of the Robot Framework, which allows you to have different file formats and structures. There is more to such flexibility in the style of writing tests, which will be covered in further chapters.</p></div></div>
<div><div><div><div><h1 class="title"><a id="ch02lvl1sec17"/>Test configuration files</h1></div></div></div><p>As mentioned before, the tests are stored in files and are clubbed in folders that act as test suite for the files. A test file <a id="id62" class="indexterm"/>can contain different sections, which can optionally be moved into other files dedicated specifically towards the work of that particular section. Thus reducing the length and complexity of the actual test file, which is<a id="id63" class="indexterm"/> helpful if the test size is very large.</p><p>The test configuration files apart from the actual test files and folders are:</p><div><div><div><div><h2 class="title"><a id="ch02lvl2sec22"/>Suite initialization files</h2></div></div></div><p>A folder in the Robot Framework denotes a test suite for all the files and subfolders contained in it. As there is no way to specify metadata of the test suite except for the folder name, there <a id="id64" class="indexterm"/>is a provision for special files that pertain to the folder in which they are placed. As with specifying a directory as a module in Python, initialization files have to be named as <code class="literal">__init__</code> and their extension can be any valid extensions allowed by the Robot Framework. The format of these files is the same as test case files, but apart from few exceptions, the test case options are not allowed.</p><p>The configuration specified here overlaps with the allowable configuration in test case files as well in case of defining tags, setup, and teardown actions as well as test case timeouts. However, the changes overridden in these files are applicable to the entire test suite in which this initialization file exists.</p><p>One setting that deserves a considerable mention is the presence of suite <code class="literal">setup</code> and <code class="literal">teardown</code>. These only get executed once before and after the execution of all the tests present in the given test suite as well as in any sub-test suites as well. Also, if there are any sub test suites within the test suite, then the initialization files of these will be run likewise too. An example for this could be as follows:</p><p>
<code class="literal">| Setting | Value | Value | </code>
</p><p>
<code class="literal">| Documentation | suite init file | </code>
</p><p>
<code class="literal">| Suite Setup | Log | This is the setup method for the entire suite | </code>
</p><p>
<code class="literal">| Force Tags | example | </code>
</p><p>
<code class="literal">| Suite Teardown | Log | This suite has ended | </code>
</p></div><div><div><div><div><h2 class="title"><a id="ch02lvl2sec23"/>External variable files</h2></div></div></div><p>These are the files <a id="id65" class="indexterm"/>that contain the variables used in<a id="id66" class="indexterm"/> the test cases. The main purpose of specifying the variables in an external file is to follow the <a id="id67" class="indexterm"/>
<strong>DRY</strong> (<strong>Don't Repeat Yourself</strong>) principle to minimize duplication as well as make changes into the variables at a single place without changing the rest of the test. These files provide the variables that they create to other files<a id="id68" class="indexterm"/> that require variable information, which is different from the variable section of the test, or the variable table which is only applicable for the test case in which it is defined.</p><div><div><h3 class="title"><a id="note04"/>Note</h3><p>Note that variable names are case-sensitive. In order to differentiate between variables and other keywords, keep in mind that generally the variables are kept in uppercase but there is no such rule.</p></div></div><p>The variables are defined as <code class="literal">${Variable Name}</code> for normal, single-valued variables and as <code class="literal">@{Variable Name}</code> for a variable containing a list of different values.</p><p>In a test configuration file, when only the variable table is specified, then the test file becomes a variable file and on its usage, only the table starting with variables will be considered.</p><div><div><div><div><h3 class="title"><a id="ch02lvl3sec02"/>Structure</h3></div></div></div><p>A variable file can<a id="id69" class="indexterm"/> typically store a large amount and type of variables. For example a variable file can have the following structure that declares various types of variables:</p><div><pre class="programlisting">*** Variables *** 
${Weather}  London  Cloudy  25 
${humidity}  75 
${MARKS}  65.5 
@{DAYS}  Monday  Wednesday  Friday  Sunday</pre></div></div><div><div><div><div><h3 class="title"><a id="ch02lvl3sec03"/>Python/Java files containing variables</h3></div></div></div><p>The variables can also be created in a Python or a Java file as in certain<a id="id70" class="indexterm"/> cases a Python or a Java class might need to save some dynamic data value at runtime, which can be passed to the tests in need. Only restrictive thing is that the python class name should be the same as its module and the Java class must not be in any kind of package. The easiest way to do this is to place the Python/ Java source in the same location as the test file itself (but is not recommended if you are having a separate application or a large number of tests/scripts). If you need to refer some value from external service or application, then the source file used can be referred to populate its variables which can be used in the tests.</p><p>For instance, a hash can be set/modified as variable in the Python file as:</p><div><pre class="programlisting">person = { 'name' : 'John Doe','age' : '26', 'grade' : 'A', 'gpa' : 8.9 }</pre></div><p>And in a Java file it can be modified as:</p><div><pre class="programlisting">public String name = "Robot Framework";</pre></div><p>Also, it can <a id="id71" class="indexterm"/>be used in the tests as:</p><div><pre class="programlisting">*** Setting ***
Variables  python_file.py
Variables  JavaFile.java
....
*** Test Cases ***
...
  Log  For ${person['name']}, the grade obtained was ${person['grade']}
  Log  You are using ${name}</pre></div><p>Just as with any other variable defined in the test itself the variables specified in these programs can be used.</p><p>In a similar manner, there is a provision for getting variables from a special function in the Python/Java code as <code class="literal">get_variables</code>/<code class="literal">getVariables</code>. The variables have to be prefixed with <code class="literal">LIST</code> keyword failing, which they will be assumed as scalars and can only have a single value.</p><div><div><h3 class="title"><a id="tip03"/>Tip</h3><p>The variables as well as function setting these variable are visible to the Robot Framework tests if they have default or higher scope in the classes.</p><p>While the variable defined in Java is usable only with Jython runtime, one can use the Python file in any Robot Framework runtime, as all runtimes basically descend from Python.</p></div></div><p>To use the variables present in a resource file into a test case, variables keyword followed by the absolute or relative path to the variable file (the <code class="literal">.class</code> or <code class="literal">.py</code> as the case may be) can be given. And the variables defined in the variable file can be used as they were defined in the variables table within the file itself like the following:</p><div><pre class="programlisting">*** Setting ***
Variables  path/to/variablefile.py
Variables path/to/java_file.class</pre></div></div></div><div><div><div><div><h2 class="title"><a id="ch02lvl2sec24"/>Resource files</h2></div></div></div><p>Resource<a id="id72" class="indexterm"/> files are necessity when there is need to save the variable data as well as higher level user keywords. The<a id="id73" class="indexterm"/> term user keyword will be explained in this book later on, but it is suffice to say that a user keyword is basically a keyword that is not present in any library but in the same file or an external resource file.</p><div><div><div><div><h3 class="title"><a id="ch02lvl3sec04"/>Structure</h3></div></div></div><p>The resource file cannot have test cases. Apart from this, it is the same as the test case file. In the actual test case<a id="id74" class="indexterm"/> file, this file will have to be imported by the name of Resource under the settings table. After specifying the resource, the file path has to be submitted, which can be absolute or relative to the test case in question.</p><p>As mentioned, the resource files specify the variables and custom user keywords, so it contain the tables for the variable definition and keyword definition along with the settings table that can allow for import of some external library as the user keywords might be there to act as an alias for some external library. An example of resource file can be as follows:</p><div><pre class="programlisting">*** Settings ***
Resource  Path/to/another_resource

*** Variable ***
${USER}  Test user

*** Keyword ***
Print welcome message for  [Arguments]  ${USER}
    Log  Welcome ${USER}!</pre></div><p>The creation of keywords adds to the available syntax in the tests and inside the test file, this can easily be used.</p><div><pre class="programlisting">*** Settings ***
Resource  path/to/resource_file.txt

*** Test Cases ***
Test user defined keyword loaded from resource file
  Print welcome message for  Mister President</pre></div></div></div><div><div><div><div><h2 class="title"><a id="ch02lvl2sec25"/>Test setup and teardown</h2></div></div></div><p>During testing, there is a need for performing certain tasks that have to be carried out at specific times during<a id="id75" class="indexterm"/> the execution of the tests. These operations are typically carried out before and after the tests. These are known as test setup and teardown (often known as pre-conditions and post-condition) and are present universally across different structured tests, such as unit, functional, and even acceptance testing.</p><p>A test setup occurs before the beginning of a test and a test teardown occurs after the execution of a test. It is worth mentioning that a test teardown runs after the test irrespective of whether it is a success or a failure. The only condition when it will not execute is the unconditional termination of the test, which occurs during a test error. These portions of test contain pre-conditions needed for tests such as opening of the web browser to a particular page, setting up a database connection and so on. And when the test gets completed, closing the opened connections, browsers, or resources and ensuring any further operation do not carry any repercussions of the actions undertaken during the tests.</p><p>Role of setup/teardown in automated<a id="id76" class="indexterm"/> testing are as follows:</p><div><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">Setup Test Environment</li><li class="listitem" style="list-style-type: disc">Create test environment</li><li class="listitem" style="list-style-type: disc">Load initial test data</li><li class="listitem" style="list-style-type: disc">Repeat for each test<div><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">Set up individual test requirements</li><li class="listitem" style="list-style-type: disc">Perform operations and assert conditions</li><li class="listitem" style="list-style-type: disc">Clean up resources used for test</li></ul></div></li><li class="listitem" style="list-style-type: disc">Summarize/save useful information</li><li class="listitem" style="list-style-type: disc">Restore environment state to its initial condition</li><li class="listitem" style="list-style-type: disc">Analysis of the test execution</li></ul></div><p>The setup and teardown<a id="id77" class="indexterm"/> operations can be applied to both test as well as test suite level. It is not applicable within the tests. If there is a need to insert it between different statements in the tests, there are chances that the tests are not written correctly and the test structure needs to be relooked and refactored into smaller tests and parameterized according to the requirements pertain to stories for individual tests.</p><p>Being a robust framework in itself, the Robot Framework offers the capabilities of using these operations under both test suites as well as individual tests. For test suite, one can use the initialization file and for individual tests. The settings table in the test file itself can be utilized that can contain test setup and test teardown settings or even inside the test case itself in form of setup and teardown action. Using <code class="literal">None</code> after specifying a condition signifies that particular operation is not possible. A brief overview of some feature is provided as follows:</p><div><pre class="programlisting">*** Settings ***
Test Setup  Open database connection
.....
*** Test Case ***
Some test case  [teardown]  Close connection

Case without teardown  [teardown]  NONE

Alternative names  [Precondition]  some conditions
    [Postcondition]  Cleanup this mess</pre></div><p>The test setup and teardown thus offer a way for us to take the repetitive portions of tests at a single place <a id="id78" class="indexterm"/>and do not<a id="id79" class="indexterm"/> repeat same set of instructions all over the place, thus setting up scene for test automation and re-use through test parameterization.</p></div></div>
<div><div><div><div><h1 class="title"><a id="ch02lvl1sec18"/>Summary</h1></div></div></div><p>In this chapter, various files involved in the Robot Framework test creation and configuration together with the test naming conventions for different components such as, test suite, test case, and test action were discussed and the execution order management was detailed. As the test file format is quite different from any other test, it was exhaustively discussed as well. The use of variables as well as extra files are also discussed as these promote test code re-use and separate the test contents. Finally, the test environment management through test setup and teardown was discussed, which is essential if the tests require any prior dependency.</p><p>This serves as the groundwork for further work over the framework and as the basic syntaxes mentioned here are covered, the test automation and re-use will be discussed in the next chapter that continues from the work that has been covered here in order to automate and re-use existing tests.</p></div></body></html>