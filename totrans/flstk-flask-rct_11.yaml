- en: '11'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Fetching and Displaying Data in a React-Flask Application
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In the preceding chapter, you were able to successfully integrate the React
    frontend into the Flask backend. This is a significant milestone in the journey
    of a full stack web developer. In this chapter, you will build on what you have
    learned and dive deeper into data fetching in a full stack web application.
  prefs: []
  type: TYPE_NORMAL
- en: Data fetching is important in a web application because it allows the application
    to retrieve data from a backend server, API, or database and display that data
    to a user. Without the ability to fetch data, a web application would be limited
    to displaying only hardcoded data, which would not be very useful or dynamic.
    By fetching data from a backend server or API, the application can display up-to-date,
    dynamic data to the user.
  prefs: []
  type: TYPE_NORMAL
- en: In addition, data fetching is often used in combination with user interactions
    and updates to the data, allowing the application to perform actions such as inserting,
    updating, or deleting data in a database or API. This allows the application to
    be more interactive and responsive to the user’s actions.
  prefs: []
  type: TYPE_NORMAL
- en: In this chapter, you will learn about the intricacies of data fetching and its
    vital role in web applications, and more importantly, how it concerns integrating
    the React frontend with the Flask backend. You will learn about the role of data
    fetching in enabling web applications to fetch data from a backend server or API,
    ensuring the display of current and dynamic information.
  prefs: []
  type: TYPE_NORMAL
- en: We will discuss the use of data fetching in combination with user interactions
    to perform actions such as retrieving, inserting, updating, or deleting data in
    a database or API. Lastly, we will discuss how you can manage pagination in React–Flask
    applications.
  prefs: []
  type: TYPE_NORMAL
- en: By the end of this chapter, you will understand how to add data to a database,
    display database data, and how pagination is handled in a React–Flask web application.
  prefs: []
  type: TYPE_NORMAL
- en: 'In this chapter, we’ll be covering the following topics:'
  prefs: []
  type: TYPE_NORMAL
- en: Fetching and displaying data – the React–Flask approach
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Adding data to a database – the React–Flask approach
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Editing data – the React–Flask approach
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Deleting data from a database – the React–Flask approach
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Managing pagination in a React–Flask application
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Technical requirements
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The The complete code for this chapter is available on GitHub at: [https://github.com/PacktPublishing/Full-Stack-Flask-and-React/tree/main/Chapter11](https://github.com/PacktPublishing/Full-Stack-Flask-and-React/tree/main/Chapter11).'
  prefs: []
  type: TYPE_NORMAL
- en: Owing to the page-count constraints, some of the code blocks have been snipped.
    Please refer to GitHub for the complete code.
  prefs: []
  type: TYPE_NORMAL
- en: Fetching and displaying data – the React-Flask approach
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, first, we will be fetching data on speakers and displaying
    it to the users of the application. But before heading into that, let’s do some
    code restructuring. You will need to restructure the backend to accommodate the
    growing `app.py` file contents in the project directory. Dividing the code into
    different components improves the overall structure and organization of the application.
  prefs: []
  type: TYPE_NORMAL
- en: Rather than having the entire code in a single module, you can structure your
    code to separate concerns. We’ll discuss more on code structuring for larger applications
    in [*Chapter 14*](B18554_14.xhtml#_idTextAnchor285), *Modular Architecture – The
    Power of Blueprints*. With this code split, developers can easily locate and modify
    specific parts of the code base without affecting other components. This modular
    approach also promotes code reusability.
  prefs: []
  type: TYPE_NORMAL
- en: Now, back to the code, you will add `models.py` to the backend project directory
    (`bizza/backend/models.py`) to house all the models for database interaction.
    This will help us to separate application concerns. The `app.py` file will be
    used to handle endpoints and their associated logic, while the `models.py` file
    contains the application data models.
  prefs: []
  type: TYPE_NORMAL
- en: The restructured `app.py` and `models.py` files can be found on GitHub at [https://github.com/PacktPublishing/Full-Stack-Flask-and-React/tree/main/Chapter11](https://github.com/PacktPublishing/Full-Stack-Flask-and-React/tree/main/Chapter11).
  prefs: []
  type: TYPE_NORMAL
- en: Essentially, we will simulate an admin page for our *Bizza* application so that
    we can create, display, and edit speaker data, and manage pagination via the admin
    page. At this point, we are setting up an admin page for demonstration purposes
    only; we are not going to bother ourselves with data validation, authentication,
    and authorization implementations.
  prefs: []
  type: TYPE_NORMAL
- en: In this section, the focus will be to learn how to retrieve data from the backend
    and display it in the React frontend. Being able to display data from a database
    is important because it allows you to present the data to users in a visual and
    interactive way. By displaying data in a web application, you can create a user-friendly
    interface that allows users to view, search, filter, and manipulate the data as
    needed.
  prefs: []
  type: TYPE_NORMAL
- en: You need to fetch and display data in order to create a functional and useful
    web application that makes use of data stored in a database. To retrieve data
    from the backend, we will use Axios for making network requests. You can use Axios
    to make a `GET` request to the backend server and retrieve the data you need.
  prefs: []
  type: TYPE_NORMAL
- en: Let’s delve into how we can retrieve a list of speakers and their details from
    the backend and display it in the admin page of our *Bizza* application.
  prefs: []
  type: TYPE_NORMAL
- en: Retrieving the speakers’ list from Flask
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The Flask backend will manage the list of speakers and their details with a
    simple API. In `models.py`, add the following code to create the `Speaker` model
    class:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: The preceding code defines a `Speaker` model and has the `__repr__()` and `serialize()`
    methods. The `__repr__` method is a built-in method in Python that is used to
    create a string representation of an object. In this case, it is used to create
    a string representation of a `Speaker` object.
  prefs: []
  type: TYPE_NORMAL
- en: The `serialize()` method is used to convert the `Speaker` object into a dictionary
    format that can be easily converted into JSON. This is useful when you need to
    return the `Speaker` object as a response to an API endpoint.
  prefs: []
  type: TYPE_NORMAL
- en: The method returns a dictionary containing all the properties of the `Speaker`
    object such as `id`, `name`, `email`, `company`, `position`, `bio`, `speaker_avatar`,
    `created_at`, and `updated_at`. The `created_at` and `updated_at` properties are
    converted into string format using the `isoformat()` method.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, let’s create the endpoint to handle the logic for displaying the speakers’
    data:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: The preceding code retrieves the list of speakers from the database with the
    `get_speakers()` function. Now, you need to update the React frontend directory
    to consume the API speakers list endpoint.
  prefs: []
  type: TYPE_NORMAL
- en: Displaying data in React
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In the React frontend, you need to create a route that renders a component at
    the `http://127.0.0.1:3000/admin` path.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following snippet will create the routing system for the admin:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: Let’s now create `AdminPage` in the `/src/pages/Admin/AdminPage/AdminPage.jsx`
    file. `AdminPage` will serve as an index component page for the admin and render
    necessary components, including the CRUD operations for speakers.
  prefs: []
  type: TYPE_NORMAL
- en: 'Add the following code to `AdminPage.jsx`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: The preceding code shows the `AdminPage` component, which represents the structure
    and content of the `admin` page. The `Sidebar` component is imported and rendered
    as a child component to render a list of sidebar menus for the admin. Then, we
    have the `Outlet` component imported from the `react-router-dom` package, which
    is used to render the content specific to the current route.
  prefs: []
  type: TYPE_NORMAL
- en: Next, we will create a data-fetching component for viewing the list of speakers
    in the database.
  prefs: []
  type: TYPE_NORMAL
- en: Displaying the speakers list with the ViewSpeakers component
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: We will start the CRUD operations on speakers with the `ViewSpeakers` component
    that will handle the display of the speakers’ data from the backend to the admin
    users.
  prefs: []
  type: TYPE_NORMAL
- en: First, we will create a module named `SpeakersAPI.js` to handle all the API
    calls. The `SpeakersAPI.js` module encapsulates the API calls, abstracting away
    the low-level details of making HTTP requests. This will also allow other parts
    of the application to interact with the API in a more straightforward manner,
    without having to deal with the intricacies of the Axios library directly. Overall,
    you tend to benefit from having this separate module handle the API calls as it
    promotes code organization, reusability, error handling, header management, and
    the scalability and maintainability of the code base.
  prefs: []
  type: TYPE_NORMAL
- en: Let’s now dig into the `SpeakersAPI` module.
  prefs: []
  type: TYPE_NORMAL
- en: 'Inside the `bizza/frontend/src` project directory, create `SpeakersAPI.js`
    and add the following snippet:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: The preceding code sets up a basic configuration for making HTTP requests to
    an API using Axios and provides a function to retrieve speakers from the API.
    It handles errors and sets the necessary headers for the requests.
  prefs: []
  type: TYPE_NORMAL
- en: Next, we will define the `ViewSpeakers` component and make use of the preceding
    `SpeakersAPI` module.
  prefs: []
  type: TYPE_NORMAL
- en: 'Inside `src/pages/Admin/Speakers/`, create the `ViewSpeakers.js` component
    and add the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: The preceding code sets up a React component called `ViewSpeakers` that fetches
    speaker data using the `getSpeakers` function and updates the component’s state
    accordingly. It handles loading and error states and triggers the data-fetching
    process when the component is mounted. The full code for `ViewSpeakers.js` can
    be found in the GitHub repository.
  prefs: []
  type: TYPE_NORMAL
- en: Next, we will explore how we can add data to the database using the Flask–React
    approach.
  prefs: []
  type: TYPE_NORMAL
- en: Adding data to a database – the React–Flask approach
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We add data to a database to store and organize information that can be easily
    accessed, managed, and updated. It is one of the ways to persistently store data,
    and knowing how to do it is a key requirement for any full stack developer. This
    knowledge allows you to build dynamic and interactive web applications. You then
    have the means to efficiently retrieve and use the data for various purposes,
    such as reporting, analysis, and decision making.
  prefs: []
  type: TYPE_NORMAL
- en: Adding data to Flask
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Now, let’s create an endpoint to handle the logic for adding speaker data to
    the database:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: The preceding code defines a `/api/v1/speakers` route that defines an API route
    that handles a `POST` request to add a new speaker. It extracts the required speaker
    information from the request, validates the data, saves the avatar file if provided,
    checks for duplicate emails, creates a new speaker object, adds it to the database,
    and returns a response with the created speaker’s data.
  prefs: []
  type: TYPE_NORMAL
- en: The preceding code shows the `add_speaker` function that is executed when a
    `POST` request is made to the specified route.
  prefs: []
  type: TYPE_NORMAL
- en: The `add_speaker` function retrieves the JSON data from the request using `request.get_json()`
    and extracts the speaker’s name, email, company, position, bio, and `speaker_avatar`
    (an uploaded file) from the data.
  prefs: []
  type: TYPE_NORMAL
- en: If a `speaker_avatar` is provided and the file extension is allowed (after being
    checked by the `allowed_file` function), the avatar file is saved to the server’s
    upload folder with a secure filename. Otherwise, a default avatar filename is
    assigned.
  prefs: []
  type: TYPE_NORMAL
- en: The function then checks whether all the required fields (`name`, `email`, `company`,
    `position`, and `bio`) have been provided. If any of the fields are missing, it
    returns a JSON response with an error message and a status code of `400` (bad
    request).
  prefs: []
  type: TYPE_NORMAL
- en: Next, the `add_speaker()` function queries the database to check whether a speaker
    with the same email already exists. If a speaker with the same email is found,
    it returns a JSON response with an error message and a status code of `409` (Conflict).
  prefs: []
  type: TYPE_NORMAL
- en: If the speaker is new (no existing speaker with the same email), a new `Speaker`
    object is created with the provided information, including the avatar file. The
    speaker is then added to the database session and committed.
  prefs: []
  type: TYPE_NORMAL
- en: Finally, the `add_speaker()` function returns a JSON response with the serialized
    speaker data and a status code of `201` (Created) to indicate a successful speaker
    creation. The code also includes a helper function, `allowed_file`, that checks
    whether a given filename has an allowed file extension based on the application’s
    configuration.
  prefs: []
  type: TYPE_NORMAL
- en: Next, we are going to set up the React component to add the speaker data to
    the backend.
  prefs: []
  type: TYPE_NORMAL
- en: Adding the speaker data to the backend using the CreateSpeaker component
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In this section, we will add speaker data to the backend. We will create a component
    called `CreateSpeaker`. This component will handle the form inputs for adding
    a new speaker and send the data to the backend API for storage.
  prefs: []
  type: TYPE_NORMAL
- en: 'First, we will add the `AddSpeaker` function to the API call service module
    `SpeakersAPI.js`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: The preceding code provides an `addSpeaker` function that utilizes Axios to
    send a `POST` request to the backend API for adding a new speaker. It handles
    the request, response, and error cases appropriately.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now we will create the `CreateSpeaker.js` component inside `src/pages/Admin/Speakers`
    and add the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: 'The preceding code defines a `CreateSpeaker` component that handles the creation
    of a new speaker. It manages form input values, avatar file selection, loading
    state, error messages, and success messages. When the form is submitted, the component
    sends the data to the backend API and handles the response accordingly:'
  prefs: []
  type: TYPE_NORMAL
- en: The component imports necessary dependencies, including `React`, the `useState`
    hook, the `addSpeaker` function from `SpeakersAPI`, and the `useNavigate` hook
    from `react-router-dom`.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Inside the `CreateSpeaker` component, it sets up state variables using the `useState`
    hook to store the form input values (`name`, `email`, `company`, `position`, and
    `bio`), the avatar file, loading state, error message, and success message. The
    `CreateSpeaker` component also uses the `useNavigate` hook to handle navigation.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The component defines a `handleSubmit` function that is triggered when the form
    is submitted. It first prevents the default form submission behavior. Then, it
    sets the loading state to true and clears any previous error messages. Within
    the `handleSubmit` function, the component constructs a `FormData` object and
    appends the form input values and the avatar file to it.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The `addSpeaker` function (imported from `SpeakersAPI`) is called with the constructed
    `FormData` object, which sends a `POST` request to the backend API to create a
    new speaker.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: If the request is successful, the loading state is set to false, and the form
    input values are reset. A success message is displayed, and the user is navigated
    to the `/speakers` page. If an error occurs during the API request, the loading
    state is set to false, and the error message is stored in the state.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The component also includes a `handleAvatarChange` function to update the avatar
    state variable when a file is selected in the avatar input field.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The component’s rendered function returns JSX elements, including a form with
    form inputs and a submit button. It also displays error and success messages based
    on the respective state variables.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Now, let’s move to the next section to explore how data can be edited in a React–Flask
    application.
  prefs: []
  type: TYPE_NORMAL
- en: Editing data – the React–Flask approach
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In addition to displaying and adding data, it’s also important for a web application
    to allow the user to edit data. In this section, you will learn how to implement
    data editing in a React-Flask web application.
  prefs: []
  type: TYPE_NORMAL
- en: Editing data in Flask
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Now, let’s add the endpoint to handle the logic for updating the speaker data
    in the database. Add the following code to `app.py`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: The preceding code defines a new route for updating a speaker’s information
    at the `/api/v1/speakers/int:speaker_id` endpoint that accepts a `PUT` request.
    The `@app.route` decorator is used to define the endpoint, and the `methods` parameter
    is set to `['PUT']` to specify that this route should only accept `PUT` requests.
    The `<int:speaker_id>` part of the endpoint is a path parameter, which allows
    the route to accept a speaker ID as part of the URL.
  prefs: []
  type: TYPE_NORMAL
- en: The code defines the `update_speaker` function, which takes in a `speaker_id`
    parameter that corresponds to the path parameter in the endpoint.
  prefs: []
  type: TYPE_NORMAL
- en: The code first gets the JSON payload of the request and extracts the speaker’s
    information from it. Then, you retrieve the speaker’s information from the database
    using the `Speaker.query.get(speaker_id)` method. The function queries the database
    to retrieve the existing speaker object based on the provided `speaker_id`. If
    the speaker is not found, it returns a JSON response with an error message and
    a status code of `404` (Not Found).
  prefs: []
  type: TYPE_NORMAL
- en: '`update_speaker()` checks whether all the required fields (`name`, `email`,
    `company`, `position`, and `bio`) have been provided. If any of the fields are
    missing, it returns a JSON response with an error message and a status code of
    `400` (Bad Request).'
  prefs: []
  type: TYPE_NORMAL
- en: If there is an exception in saving the image, it will delete the previous avatar
    image and return an error message and status code. The `update_speaker` function
    then updates the speaker’s information in the database. The `update_speaker` function
    attempts to commit the changes to the database; if it fails, it will roll back
    the transaction and return an error message and status code of `500`.
  prefs: []
  type: TYPE_NORMAL
- en: Finally, if all goes well, the code returns the updated speaker’s information
    as a JSON object and a status code of `200`.
  prefs: []
  type: TYPE_NORMAL
- en: Next, we will create the React component to handle updating a speaker’s data.
  prefs: []
  type: TYPE_NORMAL
- en: Displaying the edited data in React
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'In this section, we will provide the functionality to edit speakers’ information.
    To edit data in React, we can modify the component’s state with the updated values
    and reflect those changes in the user interface. We will start by adding the `UpdateSpeaker`
    component. In `frontend/src/pages/Admin/Speakers/UpdateSpeaker.js`, add the following
    code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: The preceding code defines a component called `UpdateSpeaker`. The component
    allows a user to update the information of a speaker by making a `PUT` request
    to the server using the `updateSpeaker` function from the `SpeakersAPI.js` file.
  prefs: []
  type: TYPE_NORMAL
- en: The component starts by importing `React`, `useState`, and `useEffect` from
    the React library and `updateSpeaker` from the `SpeakersAPI.js` module. When the
    form is submitted, the `handleSubmit` function is called; it calls the `updateSpeaker`
    function from the `SpeakersAPI.js` file and passes in `speakerId` and an object
    containing the updated speaker’s information. If the request is successful, it
    sets the success state to true and if there is an error, it sets the error state
    to `error.message`.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, you need to update the `SpeakersAPI.js` file in `src/services/SpeakersAPI.js`
    to add the `updateSpeaker` API call function:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: 'The preceding code defines an `updateSpeaker` API function used for updating
    a speaker’s information on the backend:'
  prefs: []
  type: TYPE_NORMAL
- en: 'The function takes two parameters: `speakerId` (representing the ID of the
    speaker to be updated) and `speakerData` (an object containing the updated speaker
    information).'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: It constructs the URL for the API endpoint by appending `speakerId` to the base
    URL.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The function uses the Axios library to send a `PUT` request to the constructed
    URL, passing `speakerData` as the request payload and including the appropriate
    headers using the `addHeaders` function.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: If the request is successful, it returns the response data. If an error occurs
    during the request, it catches the error and calls the `handleErrors` function
    to handle and propagate the error.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Next, you will learn how to delete speaker data from the database.
  prefs: []
  type: TYPE_NORMAL
- en: Deleting data from a database – the React–Flask approach
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Deleting data from a database involves removing one or more records or rows
    from a table. In this section, you are going to learn how to handle delete requests
    in a React–Flask web application.
  prefs: []
  type: TYPE_NORMAL
- en: Handling delete requests in Flask
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Let’s create the endpoint to handle the logic for deleting speaker data from
    the database:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: The preceding code defines an API route for deleting a speaker, performs the
    necessary checks, deletes the speaker from the database, handles errors, and returns
    an appropriate response.
  prefs: []
  type: TYPE_NORMAL
- en: Next, we will explore the React component for handling delete requests from
    the frontend.
  prefs: []
  type: TYPE_NORMAL
- en: Handling delete requests in React
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: When building a React application, you can handle a delete request to remove
    a speaker resource by creating a component that interacts with the backend API.
    This component will send the delete request to the appropriate endpoint, handle
    any potential errors, and update the component’s state accordingly to reflect
    the deletion of the speaker resource.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s start by creating a `DeleteSpeaker` component. In `frontend/src/pages/Admin/Speakers/DeleteSpeaker.js`,
    add the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: 'The preceding code defines a component that allows users to delete a speaker
    by `id`. The component starts by importing the `useParams` and `useNavigate` hooks
    from `react-router-dom` to extract the `speakerId` value from the URL. It also
    imports the `deleteSpeaker` function from `src/services/SpeakersAPI.js` to handle
    the deletion of the speaker with an API call on the backend. The component then
    uses the `useState` hook to initialize two state variables: `error` and `success`.'
  prefs: []
  type: TYPE_NORMAL
- en: The component has a single button that, when clicked, triggers the `handleDelete`
    function. This function prevents the default form submission behavior and then
    calls the `deleteSpeaker` function passing in `speakerId` as an argument. If the
    deletion is successful, it sets the success state to true; otherwise, it sets
    the error state to the error message returned from the API. The component then
    renders a message to indicate whether the deletion was successful or there was
    an error.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, you need to update the `SpeakersAPI.js` file in `src/api/SpeakersAPI.js`
    to add the `deleteSpeaker` API call function:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: The preceding code defines a `deleteSpeaker` function that takes in a `speakerId`
    as its parameter. The function uses the Axios library to make HTTP requests to
    the server. The function starts by trying to get the speaker details from the
    server by making a `GET` request to the `/``api/v1/speakers/{speakerId}` endpoint.
  prefs: []
  type: TYPE_NORMAL
- en: It then checks whether the speaker exists. If the speaker doesn’t exist, the
    function throws an error with the message `GET` request to the `/api/v1/events?speakerId=${speakerId}`
    endpoint to get a list of events associated with the speaker. It then checks whether
    the length of events is greater than `0`. If so, it throws an error with the message,
    **This speaker has associated events, please delete** **them first**.
  prefs: []
  type: TYPE_NORMAL
- en: Finally, the function makes a `DELETE` request to the `/api/v1/speakers/{speakerId}`
    endpoint to delete the speaker. If there’s an error during the process, the function
    checks the error and throws an appropriate error message. The function then exports
    the `deleteSpeaker` function so it can be imported and used in other parts of
    the application.
  prefs: []
  type: TYPE_NORMAL
- en: Next, we will discuss how pagination can be handled in the React–Flask application.
  prefs: []
  type: TYPE_NORMAL
- en: Managing pagination in a React–Flask application
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: When working with a large dataset, it’s important to implement pagination to
    make the large dataset more manageable for the user. Pagination is a technique
    used to divide a large set of data into smaller, more manageable chunks called
    **pages**. Each page contains a subset of the total data, allowing users to navigate
    through the data in a controlled manner.
  prefs: []
  type: TYPE_NORMAL
- en: Pagination provides a way to present large datasets efficiently, improves performance,
    and enhances the user experience by making data more accessible. In this section,
    you will learn how to implement pagination in a React–Flask web application. To
    implement pagination, you will need to make some changes to the backend server
    to handle pagination requests.
  prefs: []
  type: TYPE_NORMAL
- en: You can use the Flask-SQLAlchemy library to handle pagination on the backend.
    On the Flask backend, you can implement pagination for the `speaker` model using
    the Flask-SQLAlchemy library’s pagination feature. Let’s delve into how you can
    implement pagination for the `Speaker` model.
  prefs: []
  type: TYPE_NORMAL
- en: 'Update `get_speakers()` with the following code in the `app.py` file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: In the preceding code, we are using the `paginate()` method from Flask-SQLAlchemy
    to add the pagination functionality to the speakers’ collection. The `page` and
    `per_page` arguments are passed in as query parameters in the `GET` request. The
    default value for `page` is `1` and `per_page` is `10`.
  prefs: []
  type: TYPE_NORMAL
- en: For the React frontend, you can use the `useState` and `useEffect` hooks to
    handle pagination in a functional component.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s modify the `ViewSpeakers` components and add pagination functionality
    to the component:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: The preceding code defines a component that displays a list of speakers using
    pagination. The component makes use of React hooks to manage its state. The `speakers`
    state variable is used to store the list of speakers, and the `page` and `perPage`
    state variables are used to store the current page number and the number of items
    to be displayed per page, respectively.
  prefs: []
  type: TYPE_NORMAL
- en: The `useEffect` hook is used to fetch the speakers from the server when the
    component is mounted and whenever the `page` or `perPage` state variables change.
    The `fetchSpeakers` function uses the Axios library to make a `GET` request to
    the `'/api/v1/speakers?page=${page}&per_page=${perPage}'` endpoint, passing in
    the current page number and the number of items per page as query parameters.
  prefs: []
  type: TYPE_NORMAL
- en: The response data is then stored in the `speakers` state variable. The `ViewSpeakers`
    component then maps through the speakers’ array and displays the name and email
    of each speaker. The component also includes two buttons, one for navigating to
    the previous page and one for navigating to the next page.
  prefs: []
  type: TYPE_NORMAL
- en: The `onClick` handlers of these buttons update the page state variable accordingly,
    and the `1` to prevent the user from navigating to a non-existent previous page.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we discussed in detail how you can fetch and display data in
    a React–Flask web application. We examined one of the ways fetching and displaying
    data is handled. You were able to work from the backend in defining the `Speaker`
    model class and implement various endpoints to handle data fetching from the database,
    and adding, updating, and deleting data on it.
  prefs: []
  type: TYPE_NORMAL
- en: We used the Axios library to send a request to the Flask backend, which then
    retrieved the data from a database and returned it to the frontend in a response.
    The React frontend then processed the response and displayed the data to the end
    user. Lastly, we implemented pagination as a way to present large datasets efficiently
    and to improve the performance of React–Flack web application projects.
  prefs: []
  type: TYPE_NORMAL
- en: Next, we are going to discuss authentication and authorization in a React–Flask
    application and examine the best practices to ensure that your application is
    secure and ready for production.
  prefs: []
  type: TYPE_NORMAL
