- en: '11'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '11'
- en: Fetching and Displaying Data in a React-Flask Application
  id: totrans-1
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 在React-Flask应用程序中获取和显示数据
- en: In the preceding chapter, you were able to successfully integrate the React
    frontend into the Flask backend. This is a significant milestone in the journey
    of a full stack web developer. In this chapter, you will build on what you have
    learned and dive deeper into data fetching in a full stack web application.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 在上一章中，您成功地将React前端集成到Flask后端。这是全栈Web开发者旅程中的一个重要里程碑。在本章中，您将在此基础上继续学习，并深入探讨全栈Web应用程序中的数据获取。
- en: Data fetching is important in a web application because it allows the application
    to retrieve data from a backend server, API, or database and display that data
    to a user. Without the ability to fetch data, a web application would be limited
    to displaying only hardcoded data, which would not be very useful or dynamic.
    By fetching data from a backend server or API, the application can display up-to-date,
    dynamic data to the user.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 在Web应用程序中，数据获取非常重要，因为它允许应用程序从后端服务器、API或数据库中检索数据并向用户显示这些数据。如果没有获取数据的能力，Web应用程序将仅限于显示硬编码的数据，这不会很有用或动态。通过从后端服务器或API获取数据，应用程序可以向用户显示最新和动态的数据。
- en: In addition, data fetching is often used in combination with user interactions
    and updates to the data, allowing the application to perform actions such as inserting,
    updating, or deleting data in a database or API. This allows the application to
    be more interactive and responsive to the user’s actions.
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，数据获取通常与用户交互和数据更新结合使用，使应用程序能够执行诸如在数据库或API中插入、更新或删除数据等操作。这使得应用程序能够更加互动并对用户的操作做出响应。
- en: In this chapter, you will learn about the intricacies of data fetching and its
    vital role in web applications, and more importantly, how it concerns integrating
    the React frontend with the Flask backend. You will learn about the role of data
    fetching in enabling web applications to fetch data from a backend server or API,
    ensuring the display of current and dynamic information.
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，您将了解数据获取的复杂性及其在Web应用程序中的关键作用，更重要的是，它如何涉及将React前端与Flask后端集成。您将了解数据获取在使Web应用程序能够从后端服务器或API获取数据并确保显示当前和动态信息方面的作用。
- en: We will discuss the use of data fetching in combination with user interactions
    to perform actions such as retrieving, inserting, updating, or deleting data in
    a database or API. Lastly, we will discuss how you can manage pagination in React–Flask
    applications.
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将讨论结合用户交互使用数据获取来执行诸如检索、插入、更新或删除数据库或API中的数据等操作。最后，我们将讨论如何在React-Flask应用程序中管理分页。
- en: By the end of this chapter, you will understand how to add data to a database,
    display database data, and how pagination is handled in a React–Flask web application.
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: 到本章结束时，您将了解如何向数据库中添加数据、显示数据库数据以及如何在React-Flask Web应用程序中处理分页。
- en: 'In this chapter, we’ll be covering the following topics:'
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将涵盖以下主题：
- en: Fetching and displaying data – the React–Flask approach
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 获取和显示数据 – React-Flask 方法
- en: Adding data to a database – the React–Flask approach
  id: totrans-10
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 向数据库中添加数据 – React-Flask 方法
- en: Editing data – the React–Flask approach
  id: totrans-11
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 编辑数据 – React-Flask 方法
- en: Deleting data from a database – the React–Flask approach
  id: totrans-12
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 从数据库中删除数据 – React-Flask 方法
- en: Managing pagination in a React–Flask application
  id: totrans-13
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在React-Flask应用程序中管理分页
- en: Technical requirements
  id: totrans-14
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 技术要求
- en: 'The The complete code for this chapter is available on GitHub at: [https://github.com/PacktPublishing/Full-Stack-Flask-and-React/tree/main/Chapter11](https://github.com/PacktPublishing/Full-Stack-Flask-and-React/tree/main/Chapter11).'
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 本章的完整代码可在GitHub上找到：[https://github.com/PacktPublishing/Full-Stack-Flask-and-React/tree/main/Chapter11](https://github.com/PacktPublishing/Full-Stack-Flask-and-React/tree/main/Chapter11)。
- en: Owing to the page-count constraints, some of the code blocks have been snipped.
    Please refer to GitHub for the complete code.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 由于页面数量限制，一些代码块已被截断。请参阅GitHub以获取完整代码。
- en: Fetching and displaying data – the React-Flask approach
  id: totrans-17
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 获取和显示数据 – React-Flask 方法
- en: In this chapter, first, we will be fetching data on speakers and displaying
    it to the users of the application. But before heading into that, let’s do some
    code restructuring. You will need to restructure the backend to accommodate the
    growing `app.py` file contents in the project directory. Dividing the code into
    different components improves the overall structure and organization of the application.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，首先，我们将检索演讲者的数据并将其显示给应用程序的用户。但在进入这一部分之前，让我们进行一些代码重构。你需要重构后端以适应项目目录中`app.py`文件内容的增长。将代码划分为不同的组件可以改善应用程序的整体结构和组织。
- en: Rather than having the entire code in a single module, you can structure your
    code to separate concerns. We’ll discuss more on code structuring for larger applications
    in [*Chapter 14*](B18554_14.xhtml#_idTextAnchor285), *Modular Architecture – The
    Power of Blueprints*. With this code split, developers can easily locate and modify
    specific parts of the code base without affecting other components. This modular
    approach also promotes code reusability.
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 而不是将所有代码放在一个模块中，你可以将代码结构化以分离关注点。我们将在[*第14章*](B18554_14.xhtml#_idTextAnchor285)中讨论更多关于大型应用程序的代码结构化，即*模块化架构
    – 蓝图的威力*。通过这种代码拆分，开发者可以轻松地定位和修改代码库的特定部分，而不会影响其他组件。这种模块化方法也促进了代码的可重用性。
- en: Now, back to the code, you will add `models.py` to the backend project directory
    (`bizza/backend/models.py`) to house all the models for database interaction.
    This will help us to separate application concerns. The `app.py` file will be
    used to handle endpoints and their associated logic, while the `models.py` file
    contains the application data models.
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，回到代码，你将在后端项目目录（`bizza/backend/models.py`）中添加`models.py`，以存放所有数据库交互的模型。这将帮助我们分离应用程序的关注点。`app.py`文件将用于处理端点和它们相关的逻辑，而`models.py`文件包含应用程序数据模型。
- en: The restructured `app.py` and `models.py` files can be found on GitHub at [https://github.com/PacktPublishing/Full-Stack-Flask-and-React/tree/main/Chapter11](https://github.com/PacktPublishing/Full-Stack-Flask-and-React/tree/main/Chapter11).
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 重新结构化的`app.py`和`models.py`文件可以在GitHub上找到，网址为[https://github.com/PacktPublishing/Full-Stack-Flask-and-React/tree/main/Chapter11](https://github.com/PacktPublishing/Full-Stack-Flask-and-React/tree/main/Chapter11)。
- en: Essentially, we will simulate an admin page for our *Bizza* application so that
    we can create, display, and edit speaker data, and manage pagination via the admin
    page. At this point, we are setting up an admin page for demonstration purposes
    only; we are not going to bother ourselves with data validation, authentication,
    and authorization implementations.
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 实质上，我们将为我们的*Bizza*应用程序模拟一个管理页面，以便我们可以创建、显示和编辑演讲者数据，并通过管理页面进行分页管理。目前，我们仅为了演示目的设置管理页面；我们不会去烦恼数据验证、身份验证和授权的实现。
- en: In this section, the focus will be to learn how to retrieve data from the backend
    and display it in the React frontend. Being able to display data from a database
    is important because it allows you to present the data to users in a visual and
    interactive way. By displaying data in a web application, you can create a user-friendly
    interface that allows users to view, search, filter, and manipulate the data as
    needed.
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，重点将是如何从后端检索数据并在React前端显示它。能够从数据库中显示数据非常重要，因为它允许你以视觉和交互式的方式向用户展示数据。通过在Web应用程序中显示数据，你可以创建一个用户友好的界面，使用户能够查看、搜索、过滤和按需操作数据。
- en: You need to fetch and display data in order to create a functional and useful
    web application that makes use of data stored in a database. To retrieve data
    from the backend, we will use Axios for making network requests. You can use Axios
    to make a `GET` request to the backend server and retrieve the data you need.
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 为了创建一个功能强大且有用的Web应用程序，你需要从数据库中获取并显示数据。为了从后端检索数据，我们将使用Axios进行网络请求。你可以使用Axios向后端服务器发送`GET`请求并检索所需的数据。
- en: Let’s delve into how we can retrieve a list of speakers and their details from
    the backend and display it in the admin page of our *Bizza* application.
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们深入了解如何从后端检索演讲者列表及其详细信息，并在我们的*Bizza*应用程序的管理页面中显示它们。
- en: Retrieving the speakers’ list from Flask
  id: totrans-26
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 从Flask中检索演讲者列表
- en: 'The Flask backend will manage the list of speakers and their details with a
    simple API. In `models.py`, add the following code to create the `Speaker` model
    class:'
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: Flask后端将通过简单的API管理演讲者的列表及其详细信息。在`models.py`中，添加以下代码以创建`Speaker`模型类：
- en: '[PRE0]'
  id: totrans-28
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: The preceding code defines a `Speaker` model and has the `__repr__()` and `serialize()`
    methods. The `__repr__` method is a built-in method in Python that is used to
    create a string representation of an object. In this case, it is used to create
    a string representation of a `Speaker` object.
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 上述代码定义了一个`Speaker`模型，并具有`__repr__()`和`serialize()`方法。`__repr__`方法是Python中的一个内置方法，用于创建对象的字符串表示。在这种情况下，它用于创建`Speaker`对象的字符串表示。
- en: The `serialize()` method is used to convert the `Speaker` object into a dictionary
    format that can be easily converted into JSON. This is useful when you need to
    return the `Speaker` object as a response to an API endpoint.
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: '`serialize()`方法用于将`Speaker`对象转换为字典格式，可以轻松地转换为JSON。这在您需要将`Speaker`对象作为API端点的响应返回时非常有用。'
- en: The method returns a dictionary containing all the properties of the `Speaker`
    object such as `id`, `name`, `email`, `company`, `position`, `bio`, `speaker_avatar`,
    `created_at`, and `updated_at`. The `created_at` and `updated_at` properties are
    converted into string format using the `isoformat()` method.
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 该方法返回一个包含`Speaker`对象所有属性的字典，如`id`、`name`、`email`、`company`、`position`、`bio`、`speaker_avatar`、`created_at`和`updated_at`。`created_at`和`updated_at`属性使用`isoformat()`方法转换为字符串格式。
- en: 'Now, let’s create the endpoint to handle the logic for displaying the speakers’
    data:'
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们创建一个端点来处理显示演讲者数据的逻辑：
- en: '[PRE1]'
  id: totrans-33
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: The preceding code retrieves the list of speakers from the database with the
    `get_speakers()` function. Now, you need to update the React frontend directory
    to consume the API speakers list endpoint.
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 上述代码使用`get_speakers()`函数从数据库中检索演讲者列表。现在，您需要更新React前端目录以消费API演讲者列表端点。
- en: Displaying data in React
  id: totrans-35
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 在React中显示数据
- en: In the React frontend, you need to create a route that renders a component at
    the `http://127.0.0.1:3000/admin` path.
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 在React前端，您需要创建一个路由，在`http://127.0.0.1:3000/admin`路径上渲染一个组件。
- en: 'The following snippet will create the routing system for the admin:'
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 以下代码片段将创建用于管理员的路由系统：
- en: '[PRE2]'
  id: totrans-38
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: Let’s now create `AdminPage` in the `/src/pages/Admin/AdminPage/AdminPage.jsx`
    file. `AdminPage` will serve as an index component page for the admin and render
    necessary components, including the CRUD operations for speakers.
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们在`/src/pages/Admin/AdminPage/AdminPage.jsx`文件中创建`AdminPage`。`AdminPage`将作为管理员的索引组件页面，并渲染必要的组件，包括演讲者的CRUD操作。
- en: 'Add the following code to `AdminPage.jsx`:'
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 将以下代码添加到`AdminPage.jsx`文件中：
- en: '[PRE3]'
  id: totrans-41
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: The preceding code shows the `AdminPage` component, which represents the structure
    and content of the `admin` page. The `Sidebar` component is imported and rendered
    as a child component to render a list of sidebar menus for the admin. Then, we
    have the `Outlet` component imported from the `react-router-dom` package, which
    is used to render the content specific to the current route.
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 上述代码显示了`AdminPage`组件，它代表了`admin`页面的结构和内容。`Sidebar`组件被导入并作为子组件渲染，以渲染管理员的侧边菜单列表。然后，我们有从`react-router-dom`包中导入的`Outlet`组件，它用于渲染当前路由的特定内容。
- en: Next, we will create a data-fetching component for viewing the list of speakers
    in the database.
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们将创建一个用于查看数据库中演讲者列表的数据获取组件。
- en: Displaying the speakers list with the ViewSpeakers component
  id: totrans-44
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 使用ViewSpeakers组件显示演讲者列表
- en: We will start the CRUD operations on speakers with the `ViewSpeakers` component
    that will handle the display of the speakers’ data from the backend to the admin
    users.
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将使用`ViewSpeakers`组件开始对演讲者的CRUD操作，该组件将处理从后端到管理员用户的演讲者数据的显示。
- en: First, we will create a module named `SpeakersAPI.js` to handle all the API
    calls. The `SpeakersAPI.js` module encapsulates the API calls, abstracting away
    the low-level details of making HTTP requests. This will also allow other parts
    of the application to interact with the API in a more straightforward manner,
    without having to deal with the intricacies of the Axios library directly. Overall,
    you tend to benefit from having this separate module handle the API calls as it
    promotes code organization, reusability, error handling, header management, and
    the scalability and maintainability of the code base.
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们将创建一个名为`SpeakersAPI.js`的模块来处理所有的API调用。`SpeakersAPI.js`模块封装了API调用，抽象出了制作HTTP请求的低级细节。这还将允许应用程序的其他部分以更直接的方式与API交互，而无需直接处理Axios库的复杂性。总的来说，您会从拥有这个独立的模块来处理API调用中受益，因为它促进了代码的组织、可重用性、错误处理、头部管理以及代码库的可扩展性和可维护性。
- en: Let’s now dig into the `SpeakersAPI` module.
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们深入了解`SpeakersAPI`模块。
- en: 'Inside the `bizza/frontend/src` project directory, create `SpeakersAPI.js`
    and add the following snippet:'
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 在 `bizza/frontend/src` 项目目录中，创建 `SpeakersAPI.js` 并添加以下代码片段：
- en: '[PRE4]'
  id: totrans-49
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: The preceding code sets up a basic configuration for making HTTP requests to
    an API using Axios and provides a function to retrieve speakers from the API.
    It handles errors and sets the necessary headers for the requests.
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 前面的代码为使用 Axios 向 API 发送 HTTP 请求设置了基本配置，并提供了一个从 API 获取演讲者的函数。它处理错误并设置请求所需的必要头信息。
- en: Next, we will define the `ViewSpeakers` component and make use of the preceding
    `SpeakersAPI` module.
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们将定义 `ViewSpeakers` 组件并使用前面的 `SpeakersAPI` 模块。
- en: 'Inside `src/pages/Admin/Speakers/`, create the `ViewSpeakers.js` component
    and add the following code:'
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 在 `src/pages/Admin/Speakers/` 目录中创建 `ViewSpeakers.js` 组件并添加以下代码：
- en: '[PRE5]'
  id: totrans-53
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: The preceding code sets up a React component called `ViewSpeakers` that fetches
    speaker data using the `getSpeakers` function and updates the component’s state
    accordingly. It handles loading and error states and triggers the data-fetching
    process when the component is mounted. The full code for `ViewSpeakers.js` can
    be found in the GitHub repository.
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 前面的代码设置了一个名为 `ViewSpeakers` 的 React 组件，该组件使用 `getSpeakers` 函数获取演讲者数据并相应地更新组件的状态。它处理加载和错误状态，并在组件挂载时触发数据获取过程。`ViewSpeakers.js`
    的完整代码可以在 GitHub 仓库中找到。
- en: Next, we will explore how we can add data to the database using the Flask–React
    approach.
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们将探讨如何使用 Flask-React 方法将数据添加到数据库中。
- en: Adding data to a database – the React–Flask approach
  id: totrans-56
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 将数据添加到数据库 – React-Flask 方法
- en: We add data to a database to store and organize information that can be easily
    accessed, managed, and updated. It is one of the ways to persistently store data,
    and knowing how to do it is a key requirement for any full stack developer. This
    knowledge allows you to build dynamic and interactive web applications. You then
    have the means to efficiently retrieve and use the data for various purposes,
    such as reporting, analysis, and decision making.
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将数据添加到数据库以存储和组织易于访问、管理和更新的信息。这是持久化存储数据的一种方式，了解如何执行此操作是任何全栈开发者的关键要求。这种知识使您能够构建动态和交互式网络应用程序。然后您就有能力高效地检索和使用数据，用于各种目的，如报告、分析和决策制定。
- en: Adding data to Flask
  id: totrans-58
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 将数据添加到 Flask
- en: 'Now, let’s create an endpoint to handle the logic for adding speaker data to
    the database:'
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们创建一个端点来处理将演讲者数据添加到数据库的逻辑：
- en: '[PRE6]'
  id: totrans-60
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: The preceding code defines a `/api/v1/speakers` route that defines an API route
    that handles a `POST` request to add a new speaker. It extracts the required speaker
    information from the request, validates the data, saves the avatar file if provided,
    checks for duplicate emails, creates a new speaker object, adds it to the database,
    and returns a response with the created speaker’s data.
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 之前的代码定义了一个 `/api/v1/speakers` 路由，该路由处理添加新演讲者的 `POST` 请求。它从请求中提取所需的演讲者信息，验证数据，如果提供则保存头像文件，检查重复的电子邮件，创建新的演讲者对象，将其添加到数据库中，并返回包含创建的演讲者数据的响应。
- en: The preceding code shows the `add_speaker` function that is executed when a
    `POST` request is made to the specified route.
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 前面的代码显示了在向指定路由发出 `POST` 请求时执行的 `add_speaker` 函数。
- en: The `add_speaker` function retrieves the JSON data from the request using `request.get_json()`
    and extracts the speaker’s name, email, company, position, bio, and `speaker_avatar`
    (an uploaded file) from the data.
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: '`add_speaker` 函数使用 `request.get_json()` 从请求中检索 JSON 数据，并从数据中提取演讲者的姓名、电子邮件、公司、职位、个人简介和
    `speaker_avatar`（一个上传的文件）。'
- en: If a `speaker_avatar` is provided and the file extension is allowed (after being
    checked by the `allowed_file` function), the avatar file is saved to the server’s
    upload folder with a secure filename. Otherwise, a default avatar filename is
    assigned.
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 如果提供了 `speaker_avatar` 并且文件扩展名是允许的（在 `allowed_file` 函数检查后），则将头像文件以安全文件名保存到服务器的上传文件夹中。否则，将分配一个默认的头像文件名。
- en: The function then checks whether all the required fields (`name`, `email`, `company`,
    `position`, and `bio`) have been provided. If any of the fields are missing, it
    returns a JSON response with an error message and a status code of `400` (bad
    request).
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 函数随后检查是否提供了所有必需的字段（`name`、`email`、`company`、`position` 和 `bio`）。如果任何字段缺失，它将返回一个包含错误消息和状态码
    `400`（错误请求）的 JSON 响应。
- en: Next, the `add_speaker()` function queries the database to check whether a speaker
    with the same email already exists. If a speaker with the same email is found,
    it returns a JSON response with an error message and a status code of `409` (Conflict).
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，`add_speaker()` 函数查询数据库以检查是否存在具有相同电子邮件的演讲者。如果找到具有相同电子邮件的演讲者，它将返回一个包含错误消息和状态码
    `409`（冲突）的 JSON 响应。
- en: If the speaker is new (no existing speaker with the same email), a new `Speaker`
    object is created with the provided information, including the avatar file. The
    speaker is then added to the database session and committed.
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 如果演讲者是新的（没有具有相同电子邮件的现有演讲者），则使用提供的信息（包括头像文件）创建一个新的 `Speaker` 对象。然后，演讲者被添加到数据库会话并提交。
- en: Finally, the `add_speaker()` function returns a JSON response with the serialized
    speaker data and a status code of `201` (Created) to indicate a successful speaker
    creation. The code also includes a helper function, `allowed_file`, that checks
    whether a given filename has an allowed file extension based on the application’s
    configuration.
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，`add_speaker()` 函数返回一个包含序列化演讲者数据和状态码 `201`（已创建）的 JSON 响应，以指示演讲者创建成功。该代码还包括一个辅助函数
    `allowed_file`，该函数根据应用程序的配置检查给定的文件名是否具有允许的文件扩展名。
- en: Next, we are going to set up the React component to add the speaker data to
    the backend.
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们将设置 React 组件以将演讲者数据添加到后端。
- en: Adding the speaker data to the backend using the CreateSpeaker component
  id: totrans-70
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用 CreateSpeaker 组件将演讲者数据添加到后端
- en: In this section, we will add speaker data to the backend. We will create a component
    called `CreateSpeaker`. This component will handle the form inputs for adding
    a new speaker and send the data to the backend API for storage.
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们将向后端添加演讲者数据。我们将创建一个名为 `CreateSpeaker` 的组件。此组件将处理添加新演讲者的表单输入并将数据发送到后端
    API 以进行存储。
- en: 'First, we will add the `AddSpeaker` function to the API call service module
    `SpeakersAPI.js`:'
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们将 `AddSpeaker` 函数添加到 API 调用服务模块 `SpeakersAPI.js`：
- en: '[PRE7]'
  id: totrans-73
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: The preceding code provides an `addSpeaker` function that utilizes Axios to
    send a `POST` request to the backend API for adding a new speaker. It handles
    the request, response, and error cases appropriately.
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 上述代码提供了一个 `addSpeaker` 函数，该函数使用 Axios 向后端 API 发送 `POST` 请求以添加新的演讲者。它适当地处理请求、响应和错误情况。
- en: 'Now we will create the `CreateSpeaker.js` component inside `src/pages/Admin/Speakers`
    and add the following code:'
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们将在 `src/pages/Admin/Speakers` 内创建 `CreateSpeaker.js` 组件并添加以下代码：
- en: '[PRE8]'
  id: totrans-76
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'The preceding code defines a `CreateSpeaker` component that handles the creation
    of a new speaker. It manages form input values, avatar file selection, loading
    state, error messages, and success messages. When the form is submitted, the component
    sends the data to the backend API and handles the response accordingly:'
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 上述代码定义了一个 `CreateSpeaker` 组件，该组件处理新演讲者的创建。它管理表单输入值、头像文件选择、加载状态、错误消息和成功消息。当表单提交时，该组件将数据发送到后端
    API 并相应地处理响应：
- en: The component imports necessary dependencies, including `React`, the `useState`
    hook, the `addSpeaker` function from `SpeakersAPI`, and the `useNavigate` hook
    from `react-router-dom`.
  id: totrans-78
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 组件导入必要的依赖项，包括 `React`、`useState` 钩子、从 `SpeakersAPI` 导入的 `addSpeaker` 函数以及从 `react-router-dom`
    导入的 `useNavigate` 钩子。
- en: Inside the `CreateSpeaker` component, it sets up state variables using the `useState`
    hook to store the form input values (`name`, `email`, `company`, `position`, and
    `bio`), the avatar file, loading state, error message, and success message. The
    `CreateSpeaker` component also uses the `useNavigate` hook to handle navigation.
  id: totrans-79
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在 `CreateSpeaker` 组件内部，它使用 `useState` 钩子设置状态变量以存储表单输入值（`name`、`email`、`company`、`position`
    和 `bio`）、头像文件、加载状态、错误消息和成功消息。`CreateSpeaker` 组件还使用 `useNavigate` 钩子来处理导航。
- en: The component defines a `handleSubmit` function that is triggered when the form
    is submitted. It first prevents the default form submission behavior. Then, it
    sets the loading state to true and clears any previous error messages. Within
    the `handleSubmit` function, the component constructs a `FormData` object and
    appends the form input values and the avatar file to it.
  id: totrans-80
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 组件定义了一个 `handleSubmit` 函数，当表单提交时触发。它首先阻止默认的表单提交行为。然后，将加载状态设置为 true 并清除任何之前的错误消息。在
    `handleSubmit` 函数内部，组件构造一个 `FormData` 对象并将表单输入值和头像文件附加到它。
- en: The `addSpeaker` function (imported from `SpeakersAPI`) is called with the constructed
    `FormData` object, which sends a `POST` request to the backend API to create a
    new speaker.
  id: totrans-81
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 从 `SpeakersAPI` 导入的 `addSpeaker` 函数与构造的 `FormData` 对象一起调用，该对象向后端 API 发送 `POST`
    请求以创建新的演讲者。
- en: If the request is successful, the loading state is set to false, and the form
    input values are reset. A success message is displayed, and the user is navigated
    to the `/speakers` page. If an error occurs during the API request, the loading
    state is set to false, and the error message is stored in the state.
  id: totrans-82
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果请求成功，将加载状态设置为false，并重置表单输入值。显示成功消息，并将用户导航到`/speakers`页面。如果在API请求过程中发生错误，将加载状态设置为false，并将错误消息存储在状态中。
- en: The component also includes a `handleAvatarChange` function to update the avatar
    state variable when a file is selected in the avatar input field.
  id: totrans-83
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 该组件还包括一个`handleAvatarChange`函数，用于在头像输入字段中选择文件时更新头像状态变量。
- en: The component’s rendered function returns JSX elements, including a form with
    form inputs and a submit button. It also displays error and success messages based
    on the respective state variables.
  id: totrans-84
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 组件的渲染函数返回JSX元素，包括带有表单输入和提交按钮的表单。它还根据相应的状态变量显示错误和成功消息。
- en: Now, let’s move to the next section to explore how data can be edited in a React–Flask
    application.
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们进入下一节，探索如何在React-Flask应用程序中编辑数据。
- en: Editing data – the React–Flask approach
  id: totrans-86
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 数据编辑 – React-Flask方法
- en: In addition to displaying and adding data, it’s also important for a web application
    to allow the user to edit data. In this section, you will learn how to implement
    data editing in a React-Flask web application.
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 除了显示和添加数据外，对于Web应用程序来说，允许用户编辑数据也很重要。在本节中，您将学习如何在React-Flask Web应用程序中实现数据编辑。
- en: Editing data in Flask
  id: totrans-88
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 在Flask中编辑数据
- en: 'Now, let’s add the endpoint to handle the logic for updating the speaker data
    in the database. Add the following code to `app.py`:'
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们添加端点来处理在数据库中更新演讲者数据的逻辑。将以下代码添加到`app.py`中：
- en: '[PRE9]'
  id: totrans-90
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: The preceding code defines a new route for updating a speaker’s information
    at the `/api/v1/speakers/int:speaker_id` endpoint that accepts a `PUT` request.
    The `@app.route` decorator is used to define the endpoint, and the `methods` parameter
    is set to `['PUT']` to specify that this route should only accept `PUT` requests.
    The `<int:speaker_id>` part of the endpoint is a path parameter, which allows
    the route to accept a speaker ID as part of the URL.
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 上述代码定义了一个新的路由，用于在`/api/v1/speakers/int:speaker_id`端点更新演讲者的信息，该端点接受`PUT`请求。使用`@app.route`装饰器定义端点，并将`methods`参数设置为`['PUT']`，以指定此路由只能接受`PUT`请求。《int:speaker_id》部分是路径参数，允许路由接受演讲者ID作为URL的一部分。
- en: The code defines the `update_speaker` function, which takes in a `speaker_id`
    parameter that corresponds to the path parameter in the endpoint.
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 代码定义了`update_speaker`函数，它接受一个`speaker_id`参数，该参数对应于端点中的路径参数。
- en: The code first gets the JSON payload of the request and extracts the speaker’s
    information from it. Then, you retrieve the speaker’s information from the database
    using the `Speaker.query.get(speaker_id)` method. The function queries the database
    to retrieve the existing speaker object based on the provided `speaker_id`. If
    the speaker is not found, it returns a JSON response with an error message and
    a status code of `404` (Not Found).
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 代码首先获取请求的JSON有效负载，并从中提取演讲者的信息。然后，使用`Speaker.query.get(speaker_id)`方法从数据库中检索演讲者的信息。该函数根据提供的`speaker_id`查询数据库以检索现有的演讲者对象。如果没有找到演讲者，它将返回一个包含错误消息和状态码`404`（未找到）的JSON响应。
- en: '`update_speaker()` checks whether all the required fields (`name`, `email`,
    `company`, `position`, and `bio`) have been provided. If any of the fields are
    missing, it returns a JSON response with an error message and a status code of
    `400` (Bad Request).'
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: '`update_speaker()`检查是否提供了所有必需的字段（`name`、`email`、`company`、`position`和`bio`）。如果任何字段缺失，它将返回一个包含错误消息和状态码`400`（错误请求）的JSON响应。'
- en: If there is an exception in saving the image, it will delete the previous avatar
    image and return an error message and status code. The `update_speaker` function
    then updates the speaker’s information in the database. The `update_speaker` function
    attempts to commit the changes to the database; if it fails, it will roll back
    the transaction and return an error message and status code of `500`.
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 如果保存图像时出现异常，它将删除之前的头像图像，并返回错误消息和状态码。然后，`update_speaker`函数更新数据库中的演讲者信息。`update_speaker`函数尝试将更改提交到数据库；如果失败，它将回滚事务并返回错误消息和状态码`500`。
- en: Finally, if all goes well, the code returns the updated speaker’s information
    as a JSON object and a status code of `200`.
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，如果一切顺利，代码将返回更新后的演讲者信息作为JSON对象和状态码`200`。
- en: Next, we will create the React component to handle updating a speaker’s data.
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们将创建一个React组件来处理更新演讲者数据。
- en: Displaying the edited data in React
  id: totrans-98
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 在React中显示编辑后的数据
- en: 'In this section, we will provide the functionality to edit speakers’ information.
    To edit data in React, we can modify the component’s state with the updated values
    and reflect those changes in the user interface. We will start by adding the `UpdateSpeaker`
    component. In `frontend/src/pages/Admin/Speakers/UpdateSpeaker.js`, add the following
    code:'
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们将提供编辑演讲者信息的功能。要在React中编辑数据，我们可以通过修改组件的状态来使用更新的值，并在用户界面中反映这些更改。我们将首先添加`UpdateSpeaker`组件。在`frontend/src/pages/Admin/Speakers/UpdateSpeaker.js`中，添加以下代码：
- en: '[PRE10]'
  id: totrans-100
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: The preceding code defines a component called `UpdateSpeaker`. The component
    allows a user to update the information of a speaker by making a `PUT` request
    to the server using the `updateSpeaker` function from the `SpeakersAPI.js` file.
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 上述代码定义了一个名为`UpdateSpeaker`的组件。该组件允许用户通过使用`SpeakersAPI.js`文件中的`updateSpeaker`函数向服务器发送`PUT`请求来更新演讲者的信息。
- en: The component starts by importing `React`, `useState`, and `useEffect` from
    the React library and `updateSpeaker` from the `SpeakersAPI.js` module. When the
    form is submitted, the `handleSubmit` function is called; it calls the `updateSpeaker`
    function from the `SpeakersAPI.js` file and passes in `speakerId` and an object
    containing the updated speaker’s information. If the request is successful, it
    sets the success state to true and if there is an error, it sets the error state
    to `error.message`.
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 组件首先从React库中导入`React`、`useState`和`useEffect`，从`SpeakersAPI.js`模块中导入`updateSpeaker`。当表单提交时，将调用`handleSubmit`函数；它调用`SpeakersAPI.js`文件中的`updateSpeaker`函数，并传递`speakerId`和一个包含更新后的演讲者信息的对象。如果请求成功，它将成功状态设置为true，如果有错误，它将错误状态设置为`error.message`。
- en: 'Now, you need to update the `SpeakersAPI.js` file in `src/services/SpeakersAPI.js`
    to add the `updateSpeaker` API call function:'
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，你需要更新`src/services/SpeakersAPI.js`中的`SpeakersAPI.js`文件，以添加`updateSpeaker`
    API调用函数：
- en: '[PRE11]'
  id: totrans-104
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'The preceding code defines an `updateSpeaker` API function used for updating
    a speaker’s information on the backend:'
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 上述代码定义了一个用于在后端更新演讲者信息的`updateSpeaker` API函数：
- en: 'The function takes two parameters: `speakerId` (representing the ID of the
    speaker to be updated) and `speakerData` (an object containing the updated speaker
    information).'
  id: totrans-106
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 该函数接受两个参数：`speakerId`（表示要更新的演讲者的ID）和`speakerData`（一个包含更新后的演讲者信息的对象）。
- en: It constructs the URL for the API endpoint by appending `speakerId` to the base
    URL.
  id: totrans-107
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它通过将`speakerId`附加到基本URL来构造API端点的URL。
- en: The function uses the Axios library to send a `PUT` request to the constructed
    URL, passing `speakerData` as the request payload and including the appropriate
    headers using the `addHeaders` function.
  id: totrans-108
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 该函数使用Axios库向构造的URL发送一个`PUT`请求，将`speakerData`作为请求负载传递，并使用`addHeaders`函数包含适当的头信息。
- en: If the request is successful, it returns the response data. If an error occurs
    during the request, it catches the error and calls the `handleErrors` function
    to handle and propagate the error.
  id: totrans-109
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果请求成功，它返回响应数据。如果在请求过程中发生错误，它捕获错误并调用`handleErrors`函数来处理和传播错误。
- en: Next, you will learn how to delete speaker data from the database.
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，你将学习如何从数据库中删除演讲者数据。
- en: Deleting data from a database – the React–Flask approach
  id: totrans-111
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 从数据库中删除数据 – React-Flask方法
- en: Deleting data from a database involves removing one or more records or rows
    from a table. In this section, you are going to learn how to handle delete requests
    in a React–Flask web application.
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 从数据库中删除数据涉及从表中删除一个或多个记录或行。在本节中，你将学习如何在React-Flask网络应用程序中处理删除请求。
- en: Handling delete requests in Flask
  id: totrans-113
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 在Flask中处理删除请求
- en: 'Let’s create the endpoint to handle the logic for deleting speaker data from
    the database:'
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们创建一个端点来处理从数据库中删除演讲者数据的逻辑：
- en: '[PRE12]'
  id: totrans-115
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: The preceding code defines an API route for deleting a speaker, performs the
    necessary checks, deletes the speaker from the database, handles errors, and returns
    an appropriate response.
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 上述代码定义了一个用于删除演讲者的API路由，执行必要的检查，从数据库中删除演讲者，处理错误，并返回适当的响应。
- en: Next, we will explore the React component for handling delete requests from
    the frontend.
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们将探讨用于处理前端删除请求的React组件。
- en: Handling delete requests in React
  id: totrans-118
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 在React中处理删除请求
- en: When building a React application, you can handle a delete request to remove
    a speaker resource by creating a component that interacts with the backend API.
    This component will send the delete request to the appropriate endpoint, handle
    any potential errors, and update the component’s state accordingly to reflect
    the deletion of the speaker resource.
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 当构建一个 React 应用程序时，你可以通过创建一个与后端 API 交互的组件来处理删除请求以删除演讲者资源。此组件将向适当的端点发送删除请求，处理任何潜在的错误，并根据删除演讲者资源更新组件的状态。
- en: 'Let’s start by creating a `DeleteSpeaker` component. In `frontend/src/pages/Admin/Speakers/DeleteSpeaker.js`,
    add the following code:'
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们从创建一个 `DeleteSpeaker` 组件开始。在 `frontend/src/pages/Admin/Speakers/DeleteSpeaker.js`
    中，添加以下代码：
- en: '[PRE13]'
  id: totrans-121
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'The preceding code defines a component that allows users to delete a speaker
    by `id`. The component starts by importing the `useParams` and `useNavigate` hooks
    from `react-router-dom` to extract the `speakerId` value from the URL. It also
    imports the `deleteSpeaker` function from `src/services/SpeakersAPI.js` to handle
    the deletion of the speaker with an API call on the backend. The component then
    uses the `useState` hook to initialize two state variables: `error` and `success`.'
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 上述代码定义了一个组件，允许用户通过 `id` 删除演讲者。组件首先从 `react-router-dom` 中导入 `useParams` 和 `useNavigate`
    钩子，以从 URL 中提取 `speakerId` 值。它还从 `src/services/SpeakersAPI.js` 中导入 `deleteSpeaker`
    函数，以通过后端 API 调用处理演讲者的删除。然后，组件使用 `useState` 钩子初始化两个状态变量：`error` 和 `success`。
- en: The component has a single button that, when clicked, triggers the `handleDelete`
    function. This function prevents the default form submission behavior and then
    calls the `deleteSpeaker` function passing in `speakerId` as an argument. If the
    deletion is successful, it sets the success state to true; otherwise, it sets
    the error state to the error message returned from the API. The component then
    renders a message to indicate whether the deletion was successful or there was
    an error.
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 该组件有一个单按钮，点击时会触发 `handleDelete` 函数。此函数阻止默认的表单提交行为，然后调用 `deleteSpeaker` 函数，并将
    `speakerId` 作为参数传递。如果删除成功，它将成功状态设置为 true；否则，它将错误状态设置为从 API 返回的错误信息。然后，该组件渲染一条消息，指示删除是否成功或存在错误。
- en: 'Now, you need to update the `SpeakersAPI.js` file in `src/api/SpeakersAPI.js`
    to add the `deleteSpeaker` API call function:'
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，你需要更新 `src/api/SpeakersAPI.js` 中的 `SpeakersAPI.js` 文件，以添加 `deleteSpeaker`
    API 调用函数：
- en: '[PRE14]'
  id: totrans-125
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: The preceding code defines a `deleteSpeaker` function that takes in a `speakerId`
    as its parameter. The function uses the Axios library to make HTTP requests to
    the server. The function starts by trying to get the speaker details from the
    server by making a `GET` request to the `/``api/v1/speakers/{speakerId}` endpoint.
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 上述代码定义了一个 `deleteSpeaker` 函数，该函数接受一个 `speakerId` 作为其参数。该函数使用 Axios 库向服务器发送 HTTP
    请求。该函数首先尝试通过向 `/api/v1/speakers/{speakerId}` 端点发送 `GET` 请求从服务器获取演讲者详细信息。
- en: It then checks whether the speaker exists. If the speaker doesn’t exist, the
    function throws an error with the message `GET` request to the `/api/v1/events?speakerId=${speakerId}`
    endpoint to get a list of events associated with the speaker. It then checks whether
    the length of events is greater than `0`. If so, it throws an error with the message,
    **This speaker has associated events, please delete** **them first**.
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，它会检查演讲者是否存在。如果演讲者不存在，该函数会抛出一个错误，错误信息为向 `/api/v1/events?speakerId=${speakerId}`
    端点发送 `GET` 请求以获取与演讲者相关的事件列表。然后，它会检查事件长度是否大于 `0`。如果是，它会抛出一个错误，错误信息为 **“此演讲者有关联事件，请先删除”**
    **它们**。
- en: Finally, the function makes a `DELETE` request to the `/api/v1/speakers/{speakerId}`
    endpoint to delete the speaker. If there’s an error during the process, the function
    checks the error and throws an appropriate error message. The function then exports
    the `deleteSpeaker` function so it can be imported and used in other parts of
    the application.
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，该函数向 `/api/v1/speakers/{speakerId}` 端点发送一个 `DELETE` 请求以删除演讲者。如果在过程中出现错误，该函数会检查错误并抛出一个适当的错误信息。然后，该函数导出
    `deleteSpeaker` 函数，以便在其他应用程序的部分中导入和使用。
- en: Next, we will discuss how pagination can be handled in the React–Flask application.
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们将讨论如何在 React-Flask 应用程序中处理分页。
- en: Managing pagination in a React–Flask application
  id: totrans-130
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 在 React-Flask 应用程序中管理分页
- en: When working with a large dataset, it’s important to implement pagination to
    make the large dataset more manageable for the user. Pagination is a technique
    used to divide a large set of data into smaller, more manageable chunks called
    **pages**. Each page contains a subset of the total data, allowing users to navigate
    through the data in a controlled manner.
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
- en: Pagination provides a way to present large datasets efficiently, improves performance,
    and enhances the user experience by making data more accessible. In this section,
    you will learn how to implement pagination in a React–Flask web application. To
    implement pagination, you will need to make some changes to the backend server
    to handle pagination requests.
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
- en: You can use the Flask-SQLAlchemy library to handle pagination on the backend.
    On the Flask backend, you can implement pagination for the `speaker` model using
    the Flask-SQLAlchemy library’s pagination feature. Let’s delve into how you can
    implement pagination for the `Speaker` model.
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
- en: 'Update `get_speakers()` with the following code in the `app.py` file:'
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  id: totrans-135
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: In the preceding code, we are using the `paginate()` method from Flask-SQLAlchemy
    to add the pagination functionality to the speakers’ collection. The `page` and
    `per_page` arguments are passed in as query parameters in the `GET` request. The
    default value for `page` is `1` and `per_page` is `10`.
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
- en: For the React frontend, you can use the `useState` and `useEffect` hooks to
    handle pagination in a functional component.
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s modify the `ViewSpeakers` components and add pagination functionality
    to the component:'
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  id: totrans-139
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: The preceding code defines a component that displays a list of speakers using
    pagination. The component makes use of React hooks to manage its state. The `speakers`
    state variable is used to store the list of speakers, and the `page` and `perPage`
    state variables are used to store the current page number and the number of items
    to be displayed per page, respectively.
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
- en: The `useEffect` hook is used to fetch the speakers from the server when the
    component is mounted and whenever the `page` or `perPage` state variables change.
    The `fetchSpeakers` function uses the Axios library to make a `GET` request to
    the `'/api/v1/speakers?page=${page}&per_page=${perPage}'` endpoint, passing in
    the current page number and the number of items per page as query parameters.
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
- en: The response data is then stored in the `speakers` state variable. The `ViewSpeakers`
    component then maps through the speakers’ array and displays the name and email
    of each speaker. The component also includes two buttons, one for navigating to
    the previous page and one for navigating to the next page.
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
- en: The `onClick` handlers of these buttons update the page state variable accordingly,
    and the `1` to prevent the user from navigating to a non-existent previous page.
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  id: totrans-144
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we discussed in detail how you can fetch and display data in
    a React–Flask web application. We examined one of the ways fetching and displaying
    data is handled. You were able to work from the backend in defining the `Speaker`
    model class and implement various endpoints to handle data fetching from the database,
    and adding, updating, and deleting data on it.
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们详细讨论了如何在React-Flask网络应用程序中获取和显示数据。我们考察了处理获取和显示数据的一种方法。您能够从后端开始，定义`Speaker`模型类，并实现各种端点来处理从数据库中获取数据，以及在该数据库上添加、更新和删除数据。
- en: We used the Axios library to send a request to the Flask backend, which then
    retrieved the data from a database and returned it to the frontend in a response.
    The React frontend then processed the response and displayed the data to the end
    user. Lastly, we implemented pagination as a way to present large datasets efficiently
    and to improve the performance of React–Flack web application projects.
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 我们使用了Axios库向Flask后端发送请求，然后从数据库检索数据并将其以响应的形式返回到前端。React前端随后处理响应并将数据显示给最终用户。最后，我们实现了分页作为一种高效展示大量数据集并提高React-Flack网络应用程序项目性能的方法。
- en: Next, we are going to discuss authentication and authorization in a React–Flask
    application and examine the best practices to ensure that your application is
    secure and ready for production.
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们将讨论在React-Flask应用程序中的身份验证和授权，并检查确保您的应用程序安全且准备就绪的最佳实践。
