<html><head></head><body>
  <div><div><div><div><div><h1 class="title"><a id="ch03"/>Chapter 3. Views</h1></div></div></div><p>In the previous chapter we created our first Grok project and learned how to start a simple hello world application. Now we are going to learn about views and templates, which comprise the presentation layer of our web applications. To do this, we will create a simple application to manage to-do lists. The objective is to produce, by the end of this chapter, a working application that allows the user to create and manage any number of lists, add items to them, and mark them off as completed.</p><p>In order to reach our objective, we'll go through the following topics in this chapter:</p><div><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">What are views and where in the Grok application code should they be defined</li><li class="listitem" style="list-style-type: disc">How to use the ZPT templating engine, and examples of the most common statements in action</li><li class="listitem" style="list-style-type: disc">How to write a full Grok application using only views</li><li class="listitem" style="list-style-type: disc">How to get form parameters from a web request</li><li class="listitem" style="list-style-type: disc">How to add static resources to a Grok application</li><li class="listitem" style="list-style-type: disc">How to create and work with additional views</li><li class="listitem" style="list-style-type: disc">How to use views that do not require an associated template</li></ul></div><div><div><div><div><h1 class="title"><a id="ch03lvl1sec01"/>Grok views</h1></div></div></div><p>A<strong> web application</strong> is just a series of web pages that help the user to carry out one or more tasks by allowing him to enter some data, working with it in various ways, and presenting some result or confirmation back to him. In a web application framework, the web pages that allow the user to see what is going on and the web forms that permit him to capture information are known as<strong> views.</strong>
<a id="id54" class="indexterm"/>
</p><p>A view is typically implemented by using some sort of page templates, but in Grok we can also have separate Python code to handle more complex logic more easily. In fact, we could even have the view rendered using only Python code without templates. This gives the developer more power (the full power of Python, indeed) and allows a clean separation of view presentation and view logic, resulting in a more readable code both in the template and the Python sides.</p><p>We already worked with the template part of a view at the end of Chapter 2, when we modified the file<code class="literal"> index.pt</code> in the<code class="literal"> helloworld</code> project. Besides this page template, if you look at the<code class="literal"> app.py</code> file inside the<code class="literal"> src/helloworld</code> directory of this project, you will see the Python part of the view. Here's the full source code for the<code class="literal"> helloworld</code> application:<a id="id55" class="indexterm"/>
</p><div><pre class="programlisting">import grok
class Helloworld(grok.Application, grok.Container):
pass
<strong>class Index(grok.View):
pass # see app_templates/index.pt
</strong>
</pre></div><p>In this case, the Python code for the view consists only of a single class declaration, which we inherit from<code class="literal"> grok.View</code>, which is the basic Grok view. Since we are just going to show the template, we don't need any more code, but we can see one of Grok's conventions at work here if we look at the name of the class:<code class="literal"> Index</code>. As the comment after the class definition says, the template for this class will be found under<code class="literal"> app_templates/index.pt</code> in the<code class="literal"> application</code> directory. Grok doesn't need to be told this either in code or configuration because by convention, the template name will be the same as the class name, with the template name in lowercase and the extension<code class="literal"> .pt</code> appended to it.</p><p>To add a new view to the application, all we need to do is to define a class that inherits from<code class="literal"> grok.View</code> and create the corresponding template inside the<code class="literal"> app_templates</code> folder. Then we can refer to this view in a URL by using the template name. Note that the name<code class="literal"> index.pt</code> is a special case and represents another convention, because a view with that name will be considered the default view of the application, which means that it's not necessary to specify its name in the URL.</p></div></div></div>


  <div><div><div><div><div><h1 class="title"><a id="ch03lvl1sec02"/>Zope Page Templates (ZPT)</h1></div></div></div><p>For the HTML generation, Grok uses <strong> Zope Page Templates</strong> (<strong>ZPT</strong>). They fit Grok's philosophy nicely because one of the driving principles behind their design is the strict separation of logic from presentation. Wherever possible, a view template should contain only presentation and structural logic, along with name and method calls from the view class.<a id="id56" class="indexterm"/>
</p><p>Another important design principle of ZPT is to work well with editing tools, thus allowing designers to take template code back from developers and still be able to see and work with a complete HTML representation of the page without losing any logic. This is achieved by using valid HTML/XHTML for the page template.<a id="id57" class="indexterm"/>
</p><div><div><div><div><h2 class="title"><a id="ch03lvl2sec01"/>The Template Attribute Language (TAL)</h2></div></div></div><p>To accomplish its objective of working well with editing tools, ZPT uses the <strong> Template Attribute Language</strong> (<strong>TAL</strong>). Statements from this language use HTML attributes with an XML namespace, which basically means that they are prefixed with the letters "tal" and a colon, as in<code class="literal"> tal:content</code> or<code class="literal"> tal:replace</code>. Editing tools usually ignore statements which are not a part of regular HTML, and so they leave the TAL statements alone.<a id="id58" class="indexterm"/>
</p><p>Let's take a quick overview of the most important TAL statements and constructs. We'll cover the basics here, but the complete reference can be found at <a class="ulink" href="http://docs.zope.org/zope2/zope2book/AppendixC.html">http://docs.zope.org/zope2/zope2book/AppendixC.html</a>.</p><p>Let's begin our introduction to TAL by showing a simple example:</p><div><pre class="programlisting">&lt;h1 tal:content="python:5*5"&gt;Me Grok can multiply&lt;/h1&gt;
</pre></div><p>
<code class="literal">content</code> is a TAL statement that leaves the tag alone, but replaces its contents with the result of the expression in quotes. In this case, when the page is rendered, we'll get the following:</p><div><pre class="programlisting">&lt;h1&gt;25&lt;/h1&gt;
</pre></div><p>Note that the tag remains an<code class="literal">&lt;h1&gt;</code> tag, but the contents of the tag change to the result of the expression, which will be dynamically calculated each time the page renders. A designer using a WYSIWYG tool will see the words "A simple multiplication" instead, but will be able to correctly see the intended structure of the page.</p><p>By design, ZPT is not a general programming language, so complex code will be better off inside Python code in the view class. However, it is still possible to repeat tags, omit, or display them according to some conditions, or even include parts of other page templates. This will generally be enough for most page structures and even if it's not, part of the HTML can be generated in Python code and inserted inside a template as well.</p><div><h3 class="title"><a id="note02"/>Note</h3><p>ZPT is not the only templating engine that can be used with Grok, as it was carefully designed to allow pluggable engines. At the time of writing, there are packages available for two such engines:<code class="literal"> megrok.genshi</code> and<code class="literal"> megrok.chameleon</code>. A developer can choose which templating engine fits his style better and use that instead of ZPT.</p></div></div><div><div><div><div><h2 class="title"><a id="ch03lvl2sec02"/>Expression types</h2></div></div></div><p>In the previous example, we used the expression<code class="literal"> python:5*5</code> to get the result of a multiplication. These are known as Python expressions and can include any valid Python expression after the colon. Of course, as one of the principles of Grok is the clear separation of presentation and logic, we want to avoid very large expressions. But Python expressions are sometimes very useful, especially when we are dealing with conditions or Python objects such as lists or dictionaries.<a id="id59" class="indexterm"/>
</p><p>There are several reasons why keeping most of the logic out of the templates is a good idea. Debugging and testing code is much easier if we can use Python development tools, for one thing. Also, by using this strategy, we can potentially alter the presentation of an application (the templates) without touching the main code.</p><p>There are other kinds of expressions, though. The default type of expression in ZPT is called<strong> path expression</strong>. Here is an example:<a id="id60" class="indexterm"/>
</p><div><pre class="programlisting">&lt;p tal:content="request/URL"&gt;Me Grok want current URL&lt;/p&gt;
</pre></div><p>The reason it's called a path expression is because it starts with a variable name and uses a slash to separate calls to subobjects of that variable, returning the result of calling the last object in the path, or the object itself if it is not callable. In the preceding example, we get the current URL from the special name<code class="literal"> request</code>, by using a path from<code class="literal"> request</code> to<code class="literal"> URL</code>.</p><p>If a component of the path is not found, an error occurs, but it's possible to fall back to other objects or values in this case. To do that, we use the<code class="literal"> |</code> symbol to separate possible expression values. For example, to get some parameter from the request:</p><div><pre class="programlisting">&lt;span tal:content="request/param1|request/param2|nothing"&gt;Me Grok will settle for any value here&lt;/span&gt;
</pre></div><p>In this path expression, we look for the request parameter<code class="literal"> param1</code>; if it's not defined, we use the value of<code class="literal"> param2</code>, and if none of the two are defined, the special value<code class="literal"> nothing</code> is used. This value is equivalent to Python's<code class="literal"> None</code> value, so nothing will be inside the span tag if this happens, but no error will occur.</p><p>In addition to path and Python expressions, there is a third type, known as<strong> String expressions</strong>. These are useful when you need to combine arbitrary strings with the result of path expressions. Here is an example:<a id="id61" class="indexterm"/>
</p><div><pre class="programlisting">&lt;p tal:content="string:Me Grok web page is at this URL: ${request/URL}"&gt;&lt;/p&gt;
</pre></div><p>Everything after the colon is treated as the string to display, except that the string is searched for path expressions marked with the<code class="literal"> $</code> sign and the results of those expressions are substituted in. When the path expression consists of more than one part (when we have to use the<code class="literal"> /</code> separator) or when it's not separated by spaces from other characters in the string, it is necessary to enclose the expression in<code class="literal"> {}</code> braces, as in the preceding example. To insert a<code class="literal"> $</code> sign, a double<code class="literal"> $</code> is used, like this:</p><div><pre class="programlisting">&lt;p tal:content="string: Me Grok is richer by $$ $amount"&gt;&lt;/p&gt;
</pre></div><p>If the variable<code class="literal"> amount</code> has the value 45, the previous expression will output the following HTML:</p><div><pre class="programlisting">&lt;p&gt;Me Grok is richer by $ 45&lt;/p&gt;
<a id="id62" class="indexterm"/>
</pre></div></div><div><div><div><div><h2 class="title"><a id="ch03lvl2sec03"/>Inserting text</h2></div></div></div><p>We already saw that the<code class="literal"> content</code> statement replaces all of the content of a tag, including any nested tags inside. There is another statement,<code class="literal"> replace</code>, which gets rid of the tag altogether, and inserts the desired text in its place.<a id="id63" class="indexterm"/>
</p><div><pre class="programlisting">&lt;span tal:replace="string:Me Grok need no tag here"&gt;text&lt;/span&gt;
</pre></div><p>In this case, the<code class="literal">&lt;span&gt;</code> tag is only a placeholder tag because it will not be output when the template is rendered.</p><p>In addition to inserting text, the<code class="literal"> replace</code> statement can be used for including dummy content on a page, which can be helpful for some designers who want to work with a more detailed mock web page for illustrative purposes, without this content appearing on the final rendered page. To do that, we simply replace the HTML with the special name<code class="literal"> nothing:</code>
</p><div><pre class="programlisting">&lt;p tal:replace="nothing"&gt;Me Grok will not use this content&lt;/p&gt;
</pre></div></div><div><div><div><div><h2 class="title"><a id="ch03lvl2sec04"/>Repeating tags</h2></div></div></div><p>When working with HTML tables and lists, we will often need to add a table row or a list item for every item in a Python sequence, such as a list or a tuple. For example, we could have a list of weapons for 'Grok the caveman' that we need to display as an HTML unordered list. The<code class="literal"> repeat</code> statement causes a tag, and all of its contents, to be repeated once for every element in a sequence. To see how it works, suppose that we have a list of weapons that is passed to the template as an attribute of the view, with the name<code class="literal"> weapon:</code>
<a id="id64" class="indexterm"/>
</p><div><pre class="programlisting">&lt;h1&gt;Grok's Arsenal&lt;/h1&gt;
&lt;ul&gt;
&lt;li tal:repeat="weapon python:view.weapons" tal:content="weapon"&gt;Weapon&lt;/li&gt;
&lt;/ul&gt;
</pre></div><p>If<code class="literal"> weapon</code> contains the list ['Rock','Club','Spear'], the template will be rendered like this:</p><div><pre class="programlisting">&lt;h1&gt;Grok's Arsenal&lt;/h1&gt;
&lt;ul&gt;
&lt;li&gt;Rock&lt;/li&gt;
&lt;li&gt;Club&lt;/li&gt;
&lt;li&gt;Spear&lt;/li&gt;
&lt;/ul&gt;
</pre></div><p>The<code class="literal"> repeat</code> statement takes two parameters. The first is the name of the loop variable, which will be assigned the value of each element in the list in order. The second is an expression that returns the sequence where the elements are stored. Notice how we use our chosen name<code class="literal"> weapon</code>, together with the<code class="literal"> content</code> statement, to insert the name of the current weapon inside the<code class="literal">&lt;li&gt;</code> tag.</p><p>It is possible to nest multiple<code class="literal"> repeat</code> statements, which is why we need to assign a name to the loop variable. This name can also be useful for determining where on the list are we by using it together with the special<code class="literal"> repeat</code> variable. For example, the expression<code class="literal"> repeat/weapon/number</code> will return 1 for the first element, 2 for the second, and so on. The expression<code class="literal"> repeat/weapon/index</code> does the same, but starts at 0.<a id="id65" class="indexterm"/>
</p></div><div><div><div><div><h2 class="title"><a id="ch03lvl2sec05"/>Conditional elements</h2></div></div></div><p>The<code class="literal"> condition</code> statement is used when we want to decide, at render time, if a tag and its contents should be displayed on the page or not. It evaluates the expression passed to it and removes the tag if the result is false. When the expression is true, the tag is shown as normal.<a id="id66" class="indexterm"/>
</p><p>To help 'Grok the caveman' keep better track of his arsenal, we could turn the list into a table to also show the number of each weapon that he has. A helpful reminder can be added to each row when the number of items is considered too low. The<code class="literal"> view</code> variable would contain a list of dictionaries in this case, such as this one: [{'name':'Rock','quantity':10},{'name':'Club','quantity':1},{'name':'Spear','quantity':3}]. To show the table, we could use this markup:</p><div><pre class="programlisting">&lt;table&gt;
&lt;tr&gt;
&lt;th&gt;Weapon&lt;/th&gt;
&lt;th&gt;Quantity&lt;/th&gt;
&lt;th&gt;Notes&lt;/th&gt;
&lt;/tr&gt;
&lt;tr tal:repeat="weapon view/weapons"&gt;
&lt;td tal:content="weapon/name"&gt;Weapon&lt;/td&gt;
&lt;td tal:content="weapon/quantity"&gt;Quantity&lt;/td&gt;
&lt;td tal:condition="python:weapon['quantity']&gt;=3"&gt;OK&lt;/td&gt;
&lt;td tal:condition="python:weapon['quantity']&lt;3"&gt;Need to get more!&lt;/td&gt;
&lt;/tr&gt;
&lt;/table&gt;
</pre></div><p>This will produce the following HTML:<a id="id67" class="indexterm"/>
</p><div><pre class="programlisting">&lt;table&gt;
&lt;tr&gt;
&lt;th&gt;Weapon&lt;/th&gt;
&lt;th&gt;Quantity&lt;/th&gt;
&lt;th&gt;Notes&lt;/th&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;Rock&lt;/td&gt;
&lt;td&gt;10&lt;/td&gt;
&lt;td&gt;
OK
&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;Club&lt;/td&gt;
&lt;td&gt;1&lt;/td&gt;
&lt;td&gt;
Need to get more!
&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;Spear&lt;/td&gt;
&lt;td&gt;3&lt;/td&gt;
&lt;td&gt;
OK
&lt;/td&gt;
&lt;/tr&gt;
&lt;/table&gt;
</pre></div><p>There are a few things to note about this code. First, notice how we used path expressions to refer to the dictionary keys in the<code class="literal"> name</code> and<code class="literal"> quantity</code> columns. Path expressions work the same way for dictionary keys, object attributes, and methods. By contrast, in the Python expressions for the<code class="literal"> condition</code> statements we had to use the dictionary syntax. The other thing to note is that we essentially need to repeat the same<code class="literal">&lt;span&gt;</code> tag twice with different conditions. The rendered template only shows those tags which are true. In this case, we have mutually exclusive conditions, but in other cases we could have multiple conditions, with independent true or false values.<a id="id68" class="indexterm"/>
</p></div><div><div><div><div><h2 class="title"><a id="ch03lvl2sec06"/>Variables</h2></div></div></div><p>Sometimes we have expressions that we need to reuse throughout a page template. We could just repeat the expression in multiple places, but that would cause it to be evaluated multiple times, which is inefficient. For these situations, ZPT provides a<code class="literal"> define</code> statement that allows us to assign the result of an expression to a variable. Here is an example of a template fragment where a variable definition would be helpful:<a id="id69" class="indexterm"/>
</p><div><pre class="programlisting">&lt;ul&gt;
&lt;li tal:repeat="weapon view/weapons"&gt;
&lt;span tal:replace="weapon"&gt;weapon&lt;/span&gt; is weapon
&lt;span tal:replace="repeat/weapon/number"&gt;number&lt;/span&gt; of
&lt;span tal:replace="python:len(view.weapons)"&gt;total number of weapons &lt;/span&gt;
&lt;/li&gt;
&lt;/ul&gt;
</pre></div><p>In this example, the expression<code class="literal"> view/weapons</code> is calculated once at the<code class="literal"> repeat</code> statement and then once more for every item in the list. The length of the list is also calculated once for every item in the<code class="literal"> weapons</code> list. If we use the<code class="literal"> define</code> statement, this can be avoided:</p><div><pre class="programlisting">&lt;ul tal:define="weapons view/weapons;total_weapons python:len(weapons)"&gt;
&lt;li tal:repeat="weapon weapons"&gt;
&lt;span tal:replace="weapon"&gt;weapon&lt;/span&gt; is weapon
&lt;span tal:replace="repeat/weapon/number"&gt;number&lt;/span&gt; of
&lt;span tal:replace="total_weapons"&gt;total number of weapons&lt;/span&gt;
&lt;/li&gt;
&lt;/ul&gt;
</pre></div><p>The<code class="literal"> define</code> statement takes the name of the variable and a expression for its value, with a space in between. Note that we can have multiple definitions in a single statement, separated by semicolons. Now, let's say that we need to add a header at the top of the list where the total number of weapons must be displayed again:</p><div><pre class="programlisting">&lt;h1&gt;Grok's Arsenal (&lt;span tal:replace="python:len(view.weapons)"&gt; number&lt;/span&gt; total weapons)
&lt;/h1&gt;
</pre></div><p>We can't define the length only in the<code class="literal">&lt;h1&gt;</code> tag because the scope of the<code class="literal"> define</code> statement is limited to the tag where it is used and its contents. Nevertheless, we would like to have just one definition that we can reuse throughout the template. The<code class="literal"> global</code> keyword can be used in this case:</p><div><pre class="programlisting">&lt;h1 tal:define="global weapons view/weapons;total_weapons python:len(weapons)"&gt;Grok's Arsenal (&lt;span tal:replace="python: total_weapons"&gt;number&lt;/span&gt; total weapons)
&lt;/h1&gt;
</pre></div><p>Once a variable is defined using the<code class="literal"> global</code> keyword, it can be reused anywhere in the template, independent of the tag structure of the page.</p><p>One important thing to keep in mind regarding definitions is that path expressions always return the result of calling the last element of the path. Thus, when we are working with callable objects, we could end up assigning the wrong thing to a variable and messing up the page. This can sometimes be hard to debug, so it's not a bad idea to use Python expressions wherever possible, because they are more explicit.</p><p>This doesn't mean that we can't use path expressions (after all, they are the default type), but we have to make sure that we are getting the value that we want. When we need to get an object and not the result of calling that object, we can use the special<code class="literal"> nocall</code> path expression to get it:<a id="id70" class="indexterm"/>
</p><div><pre class="programlisting">&lt;p tal:define="object nocall:view/object"&gt;Me Grok need object&lt;/p&gt;
</pre></div></div><div><div><div><div><h2 class="title"><a id="ch03lvl2sec07"/>Special variables</h2></div></div></div><p>Grok also makes some special variables available to every page template, so that template authors can refer to the different application's objects and views.<a id="id71" class="indexterm"/>
</p><div><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc"><code class="literal">view:</code> Using this special name, all of the methods and attributes of the view class associated with the template can be accessed.<a id="id72" class="indexterm"/></li><li class="listitem" style="list-style-type: disc"><code class="literal">context:</code> The context name refers to the model that is being viewed, and also allows access to its methods and attributes.<a id="id73" class="indexterm"/></li><li class="listitem" style="list-style-type: disc"><code class="literal">request:</code> The request object contains data from the current web request.<a id="id74" class="indexterm"/></li><li class="listitem" style="list-style-type: disc"><code class="literal">static:</code> This special name allows the creation of URLs referring to static resources.<a id="id75" class="indexterm"/></li></ul></div></div><div><div><div><div><h2 class="title"><a id="ch03lvl2sec08"/>Modifying HTML tag attributes</h2></div></div></div><p>In addition to inserting text in a page, it's very common to require the attributes of an HTML tag to be defined dynamically at rendering time. The<code class="literal"> attributes</code> statement allows us to do precisely this. For example, let's add links to a description page for every weapon in Grok the caveman's arsenal:<a id="id76" class="indexterm"/>
</p><div><pre class="programlisting">&lt;h1&gt;Grok's Arsenal&lt;/h1&gt;
&lt;ul&gt;
&lt;li tal:repeat="weapon view/weapons"&gt;
&lt;a tal:content="weapon" href="" tal:attributes="href string:${request/URL}/${weapon}"&gt;Weapon&lt;/a&gt;
&lt;/li&gt;
&lt;/ul&gt;
</pre></div><p>In this example, we modify the link's<code class="literal"> href</code> attribute to use the current page's URL and append to it the name of the weapon, assuming that a weapon description page with that name exists for every weapon in the list.</p><p>As with the<code class="literal"> define</code> statement,<code class="literal"> attributes</code> statements allow multiple attribute definitions separated by semicolons.<a id="id77" class="indexterm"/>
</p></div><div><div><div><div><h2 class="title"><a id="ch03lvl2sec09"/>Inserting structure</h2></div></div></div><p>For security reasons, strings inserted by using the<code class="literal"> content</code> and<code class="literal"> replace</code> tags are quoted, in order to escape any HTML tags, so the<code class="literal">&lt;</code> bracket becomes<code class="literal">&amp;lt</code>; and the<code class="literal">&gt;</code> bracket becomes<code class="literal">&amp;gt</code>;. This results in HTML tags being displayed in the rendered page, instead of being interpreted as HTML. This is useful for preventing some cross-site scripting attacks, but does get in the way of generating HTML from Python code. The<code class="literal"> structure</code> keyword is used before an expression to tell ZPT that the returned text should be interpreted as HTML and rendered like the rest of the tags on the page.<a id="id78" class="indexterm"/>
</p><p>For instance, if we suppose that the variable text contains the following HTML:</p><div><pre class="programlisting">&lt;p&gt;This is the text&lt;/p&gt;
</pre></div><p>This tag will escape the HTML:</p><div><pre class="programlisting">&lt;div tal:content="text"&gt;The text&lt;/div&gt;
</pre></div><p>The resulting HTML will look like this:</p><div><pre class="programlisting">&lt;div&gt;&amp;lt;p&amp;gt;This is the text&amp;lt;/p&amp;gt;&lt;/div&gt;
</pre></div><p>Let's use the<code class="literal"> structure</code> keyword:</p><div><pre class="programlisting">&lt;div tal:content="structure text"&gt;The text&lt;/div&gt;
</pre></div><p>Now we get this result:</p><div><pre class="programlisting">&lt;div&gt;&lt;p&gt;This is the text&lt;/p&gt;&lt;/div&gt;
<a id="id79" class="indexterm"/>
</pre></div></div><div><div><div><div><h2 class="title"><a id="ch03lvl2sec10"/>Multiple statements in one tag</h2></div></div></div><p>In some of the earlier examples, we have used more than one TAL statement inside a single tag. As XML doesn't allow repeating attributes inside a tag, we can use only one of each type of TAL statement inside a given tag, and we can combine them as we see fit, with the exception of the<code class="literal"> content</code> and<code class="literal"> replace</code> statements, which are mutually exclusive and can't be used in the same tag at all.<a id="id80" class="indexterm"/>
</p><p>The most important thing to know when using multiple statements in one tag is that the order in which they are executed is fixed. It doesn't matter how we place them in the tag, they will be executed in the following order:</p><div><ol class="orderedlist arabic"><li class="listitem"><code class="literal"> define</code></li><li class="listitem"><code class="literal"> condition</code></li><li class="listitem"><code class="literal"> repeat</code></li><li class="listitem"><code class="literal"> content/replace</code></li><li class="listitem"><code class="literal"> attributes</code></li></ol></div><p>For this reason, if we need one statement that is lower in this list to be executed before a statement that is higher, we have to add<code class="literal">&lt;div&gt;</code> or<code class="literal">&lt;span&gt;</code> tags as required to get around the fixed order. For example, suppose we want to define some variable for every element in a<code class="literal"> repeat</code> statement. We can't add the<code class="literal"> define</code> statement in the same tag as the<code class="literal"> repeat</code> statement itself, because<code class="literal"> define</code> is executed before<code class="literal"> repeat</code>, so we would get an error due to the loop variable being undefined at that point.</p><p>A possible solution would be to use a<code class="literal">&lt;span&gt;</code> tag to define the variable after the<code class="literal"> repeat</code> statement, as shown in the following example:<a id="id81" class="indexterm"/>
</p><div><pre class="programlisting">&lt;h1&gt;Grok's Arsenal&lt;/h1&gt;
&lt;ul&gt;
&lt;li tal:repeat="weapon view/weapons"&gt;
<strong>
&lt;span tal:define="weapon_uppercase python:weapon.upper()" tal:content="weapon_uppercase"&gt;
Me Grok want uppercase letters
&lt;/span&gt;
</strong>
&lt;/li&gt;
&lt;/ul&gt;
</pre></div><p>A slightly better solution is to use a tag with the XML namespace<code class="literal"> tal</code>, which will serve as a structural marker but not appear in the final page rendering:</p><div><pre class="programlisting">&lt;h1&gt;Grok's Arsenal&lt;/h1&gt;
&lt;ul&gt;
&lt;li tal:repeat="weapon view/weapons"&gt;
<strong>&lt;tal:weapon define="weapon_uppercase python:weapon.upper()" content="weapon_uppercase"&gt;
Me Grok want uppercase letters
&lt;/tal:weapon&gt;
</strong>
&lt;/li&gt;
&lt;/ul&gt;
</pre></div><p>Instead of the<code class="literal">&lt;span&gt;</code> tag, we use<code class="literal">&lt;tal:weapon&gt;</code>. It's not that ZPT has a<code class="literal"> weapon</code> tag; the trick is in the<code class="literal"> tal</code> part of the name. We could use anything else in place of<code class="literal"> weapon</code> here. Note that as the tag itself explicitly uses the<code class="literal"> tal</code> namespace, when using ZPT, the<code class="literal"> define</code> and<code class="literal"> content</code> statements in the same tag do not need to be prefixed by it.</p></div><div><div><div><div><h2 class="title"><a id="ch03lvl2sec11"/>Macros and slots</h2></div></div></div><p>Many websites use standard elements on every page, such as headers, footers, sidebars, and more. One nice feature of ZPT is that it allows us to reuse elements like these without having to repeat them everywhere. The mechanisms used for doing this are called macros and slots.<a id="id82" class="indexterm"/>
</p><p>A<strong> macro</strong> is a page or part of a page that is declared as one and given a name. Once this declaration is done, the markup so named can be reused in different pages. This way, we can have a single-page macro defining the look and feel of our site and have every other page look like it and, most importantly, automatically change whenever the macro changes.<a id="id83" class="indexterm"/>
</p><p>A macro is defined using HTML attributes, just like TAL statements are. The macro definition language is known as<strong> Macro Expansion Template Attribute Language</strong>, or just<strong> METAL</strong> for short. Here's an example:<a id="id84" class="indexterm"/>
</p><div><pre class="programlisting">&lt;div metal:define-macro="about"&gt;
&lt;h1&gt;About Grok&lt;/h1&gt;
&lt;p&gt;Grok is a friendly caveman who likes smashing websites&lt;/p&gt;
&lt;/div&gt;
</pre></div><p>The<code class="literal"> define-macro</code> statement creates a macro with the name given in quotes, which is<code class="literal"> about</code> in this case. This name is added to the list of macros defined on the page, which is appropriately named macros. We can define any number of macros inside a page template, as long as we use different names for each. To use a macro, we access the<code class="literal"> macros</code> attribute of the page in which it was created, by using the desired name. Supposing the<code class="literal"> about</code> macro is defined inside a page template named<code class="literal"> main.pt</code>, we can then use the macro from any other page, like this:<a id="id85" class="indexterm"/>
</p><div><pre class="programlisting">&lt;p metal:use-macro="context/main.pt/macros/about"&gt;
About
&lt;/p&gt;
</pre></div><p>When this other template is rendered, the entire<code class="literal">&lt;p&gt;</code> tag is substituted by the<code class="literal">&lt;div&gt;</code> tag that encloses the macro. It's just as if the HTML from the macro was copied and pasted in place of the tag containing the<code class="literal"> use-macro</code> statement.<a id="id86" class="indexterm"/>
</p><p>By using macros, you can easily reuse big or small pieces of HTML in multiple pages, but what makes this much more useful is the concept of slots. Think of slots as placeholders for custom HTML inside an existing macro. Although the general structure of the HTML remains the same, a template using macros can fill in these placeholders at rendering time, thus allowing much more flexibility than simple macros alone can provide.</p><p>The best use for slots is to define sections within a full-page macro that can be filled in by different templates using the macro. We can then define the structure of our web pages in one single place, and have the whole site take advantage of it.</p><p>Let's define a page macro to show these concepts in action:</p><div><pre class="programlisting">&lt;html metal:define-macro="page"&gt;
&lt;head&gt;
&lt;title tal:content="context/title"&gt;title&lt;/title&gt;
&lt;/head&gt;
&lt;body&gt;
&lt;div metal:define-slot="header"&gt;
&lt;h1 tal:content="context/title"&gt;Grok's Cave&lt;/h1&gt;
&lt;/div&gt;
&lt;div metal:define-slot="body"&gt;
&lt;p&gt;Welcome to Grok's cave.&lt;/p&gt;
&lt;/div&gt;
&lt;div metal:define-slot="footer"&gt;
&lt;p&gt;Brought to you by Grok the caveman.&lt;/p&gt;
&lt;/div&gt;
&lt;/body&gt;
&lt;/html&gt;
</pre></div><p>Notice how we define the macro right inside the very first tag, so that the entire page is a single big macro. Then, using the<code class="literal"> define-slot</code> statement, we define three slots, one each for the header, footer, and body. Other templates can reuse the macro and fill in one or more of these slots to customize the final page rendering. Here's how to do that:<a id="id87" class="indexterm"/>
</p><div><pre class="programlisting">&lt;html metal:use-macro="context/main.pt/page"&gt;
&lt;div fill-slot="body"&gt;
Me Grok likes macros!
&lt;/div&gt;
&lt;/html&gt;
</pre></div><p>The<code class="literal"> fill-slot</code> statement takes the name of a slot and replaces its content with the section beginning with the tag where it is used. Everything else in the<code class="literal"> main.pt</code> template is used exactly as it appears there. This is what the rendered HTML looks like:<a id="id88" class="indexterm"/>
</p><div><pre class="programlisting">&lt;html&gt;
&lt;head&gt;
&lt;title&gt;example&lt;/title&gt;
&lt;/head&gt;
&lt;body&gt;
&lt;div&gt;
&lt;h1&gt;example&lt;/h1&gt;
&lt;/div&gt;
&lt;div&gt;
&lt;p&gt;Me Grok likes macros!&lt;/p&gt;
&lt;/div&gt;
&lt;div&gt;
&lt;p&gt;Brought to you by Grok the caveman.&lt;/p&gt;
&lt;/div&gt;
&lt;/body&gt;
&lt;/html&gt;
<a id="id89" class="indexterm"/>
</pre></div></div><div><div><div><div><h2 class="title"><a id="ch03lvl2sec12"/>Going beyond ZPT basics</h2></div></div></div><p>This has been a short introduction to ZPT, although we did cover a handful of concepts, including inserting text into templates, repeating tags, conditions, variables, attributes, and macros. For more information, a good resource is the Zope book, which is available online at <a class="ulink" href="http://docs.zope.org/zope2/zope2book/">http://docs.zope.org/zope2/zope2book/</a>.<a id="id90" class="indexterm"/>
</p></div></div></div>


  <div><div><div><div><div><h1 class="title"><a id="ch03lvl1sec03"/>The to-do list application</h1></div></div></div><p>Now that we have learned about ZPT, let's begin with the code for our to-do list application. The idea is that the user will have a web page where he can manage his tasks by using lists. Instead of using a single list, he will be able to create several lists for high-level tasks, each with a number of smaller tasks to carry out. The application will allow the user to create a list with a description, add tasks to it, and check them off as completed when he is done. He can add as many lists as he needs, and remove any of them at any time.<a id="id91" class="indexterm"/>
</p><p>This is all very simple, so for now the list manager will use a single view with an associated template. We will add additional functionality as we advance through the chapter.</p><p>The first step of course is to create a new Grok project:</p><div><pre class="programlisting"><strong># grokproject todo
</strong>
</pre></div><p>For now, we'll hold our to-do lists in a Python list. Each one will be a dictionary containing keys of title, description, and items. Our next step will be to create a template to show all of the lists and their items. We'll replace the content of the<code class="literal"> index.pt</code> template inside<code class="literal"> app_templates</code> with this code:</p><div><pre class="programlisting">&lt;html&gt;
&lt;head&gt;
&lt;title&gt;To-Do list manager&lt;/title&gt;
&lt;/head&gt;
&lt;body&gt;
&lt;h1&gt;To-Do list manager&lt;/h1&gt;
&lt;p&gt;Here you can add new lists and check off all the items that you complete.
&lt;/p&gt;
&lt;tal:block repeat="todolist context/todolists"&gt;
&lt;h2 tal:content="todolist/title"&gt;List title&lt;/h2&gt;
&lt;p tal:content="todolist/description"&gt;List description&lt;/p&gt;
&lt;ul&gt;
&lt;li tal:repeat="item todolist/items" tal:content="item"&gt;item 1&lt;/li&gt;
&lt;li tal:replace="nothing"&gt;item 2&lt;/li&gt;
&lt;li tal:replace="nothing"&gt;item 3&lt;/li&gt;
&lt;/ul&gt;
&lt;/tal:block&gt;
&lt;/body&gt;
&lt;/html&gt;
</pre></div><p>Examine the code. Make sure that you understand all of the ZPT statements that we are using. Go look at the ZPT section again, if necessary. We are assuming that the special name<code class="literal"> context</code> will include the lists in an attribute named<code class="literal"> todolists</code> and that it iterates over all of the lists by using the<code class="literal"> repeat</code> statement. We also have a nested<code class="literal"> repeat</code> statement inside that, to list all of the items in each to-do list.</p><p>Before doing anything else, open the<code class="literal"> index.pt</code> file by using the open file option in your web browser. Notice how we get a nice preview of how the page will look once it has real data (see the following screenshot). That's one of the benefits of working with ZPT. We expressly took advantage of this feature by including two dummy list items in the list, by using the<code class="literal"> replace="nothing</code>" trick.<a id="id92" class="indexterm"/>
</p><div><img src="img/7481_03_01.jpg" alt="The to-do list application"/></div><p>Now let's see its working in Grok. Remember that the template assumes that there will be a list named<code class="literal"> todolists</code> available in the<code class="literal"> context</code>. This would in fact refer to the application model, but for now let's just hardcode some value there to see how the template is rendered. We'll use a real model later. Open the<code class="literal"> app.py</code> file in the<code class="literal"> src</code> directory and change it to look like this:<a id="id93" class="indexterm"/>
</p><div><pre class="programlisting">import grok
class Todo(grok.Application, grok.Container):
todolists = [{
'title' : 'Daily tasks for Grok',
'description' : 'A list of tasks that Grok does everyday',
'items' : ['Clean cave',
'Hunt breakfast',
'Sharpen ax']
}]
class Index(grok.View):
pass
</pre></div><p>Now start the application:</p><div><pre class="programlisting"><strong># bin/paster serve etc/deploy.ini
</strong>
</pre></div><p>Create an application by using the admin control panel and click on its link. A screen similar to the following screenshot will be displayed. Notice the similarity to the preview template that we opened before.<a id="id94" class="indexterm"/>
</p><div><img src="img/7481_03_02.jpg" alt="The to-do list application"/></div></div></div>


  <div><div><div><div><div><h1 class="title"><a id="ch03lvl1sec04"/>Handling form data</h1></div></div></div><p>We can now display to-do lists and their items correctly, but we need a way to add new lists and items, and we also need to be able to check them off somehow. We need forms to handle these actions, so let's modify the template to look like this:<a id="id95" class="indexterm"/>
</p><div><pre class="programlisting">&lt;html&gt;
&lt;head&gt;
&lt;title&gt;To-Do list manager&lt;/title&gt;
&lt;/head&gt;
&lt;body&gt;
&lt;h1&gt;To-Do list manager&lt;/h1&gt;
&lt;p&gt;Here you can add new lists and check off all the items that you complete.
&lt;/p&gt;
&lt;tal:lists repeat="todolist context/todolists"&gt;
&lt;form method="post" tal:attributes="action view/url"&gt;
&lt;fieldset&gt;
&lt;legend tal:content="todolist/title"&gt;
title&lt;/legend&gt;
&lt;p tal:content="todolist/description"&gt;
description&lt;/p&gt;
&lt;div tal:repeat="item todolist/items"&gt;
&lt;span tal:content="item/description"&gt;
&lt;/span&gt;
&lt;/div&gt;
&lt;/fieldset&gt;
&lt;/form&gt;
&lt;/tal:lists&gt;
&lt;/body&gt;
&lt;/html&gt;
</pre></div><p>We now use a form for each list, and every form has the same action, defined at rendering time by using the<code class="literal"> attributes</code> statement. A Grok view always has a<code class="literal"> url</code> method that returns the view URL, so what we are doing here is submitting the form to itself. We'll deal with form submissions a bit later, when we add the view's Python code.<a id="id96" class="indexterm"/>
</p><p>To separate the lists visually, each one is inside a<code class="literal"> fieldset</code>, with its title and description. To list individual items, we drop the<code class="literal">&lt;ul&gt;</code> from our first template and use a<code class="literal">&lt;div&gt;</code>, because we now need to have a checkbox to mark the items completed. Let's add the checkbox, and also provide a way to delete items from the list while we are at it:</p><div><pre class="programlisting">&lt;div tal:repeat="item todolist/items"&gt;
&lt;input type="checkbox" tal:attributes="name string:item_{repeat/item/index}; checked item/checked"/&gt;
&lt;span tal:content="item/description"&gt;&lt;/span&gt;
&lt;input type="submit" tal:attributes="name string:delete_${repeat/item/index}" value="Delete"/&gt;
&lt;/div&gt;
&lt;br/&gt;
&lt;input type="hidden" name="list_index" tal:attributes="value repeat/todolist/index"/&gt;
&lt;input type="submit" name="update_list" value="Update list"/&gt;
&lt;br /&gt;
</pre></div><p>Note the use of the<code class="literal"> repeat/item/index</code> variable to name each item according to its place in the list, so that we can refer to them individually in the view. We'll also need to know to which list the item belongs, which is why every list form has a hidden input field with its index, using<code class="literal"> repeat/todolist/index</code> to get that value. Finally, we have an update list button which is used to check and uncheck multiple list items in one go.</p><p>All that's needed now is a way to add new items to a list. We'll just append to the preceding code a text area for the item description, and a submit button for adding it. Nothing really special here:</p><div><pre class="programlisting">&lt;label for="item_description"&gt;Description:&lt;/label&gt;&lt;br/&gt;
&lt;textarea name="item_description"&gt;&lt;/textarea&gt;
&lt;input type="submit" name="new_item" value="Add item"/&gt;
</pre></div><p>After all of the lists are displayed, we want another form to be able to add new lists. This one also submits to itself. Place this code after the closing<code class="literal">&lt;/tal:lists&gt;</code> tag above.</p><div><pre class="programlisting">&lt;form method="post" tal:attributes="action view/url"&gt;
&lt;fieldset&gt;
&lt;legend&gt;Create new list&lt;/legend&gt;
&lt;label for="list_title"&gt;Title:&lt;/label&gt;
&lt;input type="text" name="list_title"/&gt;&lt;br/&gt;
&lt;label for="list_description"&gt;Description:&lt;/label&gt;
&lt;br/&gt;
&lt;textarea name="list_description"&gt;&lt;/textarea&gt;&lt;br/&gt;
&lt;input type="submit" name="new_list" value="Create"/&gt;
&lt;/fieldset&gt;
&lt;/form&gt;
</pre></div><p>The view template is ready. Now let's create the view class. Remember that in Grok, a view usually consists of a template for the UI, and a class for passing calculated data to the template and handling any form input. As we now have various submit buttons that will send form data to the view, we need a way to handle that data. The easiest way to do that is to define an<code class="literal"> update</code> method, which Grok knows to call just before rendering the page template for the view.<a id="id97" class="indexterm"/>
</p><p>To get at the form data, we will use the<code class="literal"> request</code> variable that is available in every view class. This variable contains all of the data for the current<code class="literal"> HTTP</code> request, including form fields. Using<code class="literal"> request.form</code> we'll get a dictionary with all of the available form fields, with the<code class="literal"> name</code> attribute of the field used as the key. Each submit button has its own name, so we can test for it's presence to see which action we need to carry out.</p><p>Change<code class="literal"> app.py</code> to look like the following code:</p><div><pre class="programlisting">import grok
class Todo(grok.Application, grok.Container):
todolists = []
class Index(grok.View):
def update(self):
form = self.request.form
if 'new_list' in form:
title = form['list_title']
description = form['list_description']
self.context.todolists.append({'title':title, 'description':description, 'items':[]})
return
if 'list_index' in form:
index = int(form['list_index'])
items = self.context.todolists[index]['items']
if 'new_item' in form:
description = form['item_description']
items.append({'description':description, 'checked':False})
return
elif 'update_list' in form:
for item in range(len(items)):
if 'item_%s' % item in form:
items[item]['checked'] = True
else:
items[item]['checked'] = False
return
else:
for item in range(len(items)):
if 'delete_%s' % item in form:
items.remove(items[item])
</pre></div><p>First of all, in the application definition, we remove the test data that we added before, leaving the<code class="literal"> todolists</code> attribute defined as an empty list, so that we have a clean slate when we start the application.</p><p>In the<code class="literal"> update</code> method, we assign the form data to the<code class="literal"> form</code> variable by using<code class="literal"> self.request.form</code>, as discussed earlier. We then have three possible cases.</p><div><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc"><strong>Case one:</strong> The add list form was submitted, in which case the name<code class="literal"> new_list</code> will be in the form.</li><li class="listitem" style="list-style-type: disc"><strong>Case two:</strong> One of the buttons for adding an item, removing an item, or updating a particular list was pressed, so the<code class="literal"> list_index</code> hidden field will be in the form.</li><li class="listitem" style="list-style-type: disc"><strong>Case three:</strong> No form submission occurred, such as when the view is accessed for the first time, so no action should be taken.</li></ul></div><p>In the case of a new list, we get the values of the title and description fields and then simply append a new dictionary with an empty item list to the<code class="literal"> todolists</code> variable of the application.</p><p>If one of the specific list buttons was pressed, then we get the list index from the form and use it to get the list items of the affected list. If the<code class="literal"> new_item</code> button was pressed, we get the item description and append a dictionary with this description and a checked key to keep track of its on/off state. If<code class="literal"> update_list</code> was pressed, we go through each of the list items and set its state to<code class="literal"> True</code>, if it is present on the form and<code class="literal"> False</code> otherwise. The last possible case is when the delete button of a list item was pressed, so we go through the items and remove any of them whose name is present in the form.</p><p>Run the application and play with it a little. It doesn't look pretty, but it has the complete functionality that we sketched at the start of the chapter. The following screenshot shows how a test run looks:</p><div><img src="img/7481_03_03.jpg" alt="Handling form data"/></div></div></div>


  <div><div><div><div><div><h1 class="title"><a id="ch03lvl1sec05"/>Adding static resources</h1></div></div></div><p>We now have a working application, so the next step will be to make it look better. We obviously need to add some styles using CSS. In addition, the<strong> Delete</strong> button to the right of the list items is too distracting, so let's use a small trash can icon instead.<a id="id98" class="indexterm"/>
</p><p>In this case, we will be working with static resources, such as images and stylesheets, and not with dynamic templates and classes. To handle these type of resources, Grok uses, by convention, a directory named<code class="literal"> static</code>, which you will find in the same directory as the project source. We can simply place our static files in this directory, and Grok will be able to find them and generate links to them.</p><p>The icon that we will use here is available in the book's code, under the<code class="literal"> static</code> directory of the project. You'll need to put some icon in that directory of your project, if you are following along with this example. For the stylesheet, create a file named<code class="literal"> styles.css</code> in that directory, and add the following CSS code:<a id="id99" class="indexterm"/>
</p><div><pre class="programlisting">body {
background-color: #e0e0e0;
padding: 15px;
}
h1 {
background-color : #223388;
font-size: 1.6em;
color : #ffcc33;
padding : 10px;
margin: 0px;
}
h2 {
background-color: white;
margin: 0px;
padding: 10px;
font-size: 0.8em;
}
.todolist {
background-color: white;
padding: 10px;
margin: 0px;
}
.todolist fieldset {
border: none;
padding: 0px;
}
.todolist legend {
color: #223388;
font-weight: bold;
font-size: 1em;
}
.todolist p {
padding: 0px;
margin: 2px 0px 5px 3px;
color: gray;
font-size: 0.8em;
}
</pre></div><p>This is just a sample. The complete CSS file can be found in the sample code for this book. For the styles to actually work, we need to make a few changes to the<code class="literal"> index.pt</code> template, to add some classes, and modify the delete button to use an image. Here's the code again, with some explanations and the changes highlighted:</p><div><pre class="programlisting">&lt;html&gt;
&lt;head&gt;
&lt;title&gt;To-Do list manager&lt;/title&gt;
<strong>&lt;link rel="stylesheet" type="text/css" tal:attributes="href static/styles.css" /&gt;
</strong>
&lt;/head&gt;
</pre></div><p>First, notice how the link declaration in the document head uses the TAL<code class="literal"> attributes</code> statement to set the<code class="literal"> href</code> attribute. The word<code class="literal"> static</code> in this case does not refer to the file system directory itself, but to the special view that finds the file there and generates a link to the appropriate file. The link is created in this manner to make it work correctly, no matter where the application is installed, even if we are using virtual hosting.<a id="id100" class="indexterm"/>
</p><div><pre class="programlisting">&lt;body&gt;
&lt;h1&gt;To-Do list manager&lt;/h1&gt;
&lt;h2&gt;Here you can add new lists and check off all the items that you complete .&lt;/h2&gt;
&lt;tal:block repeat="todolist context/todolists"&gt;
<strong>&lt;form class="todolist" method="post" tal:attributes="action view/url"&gt;
</strong>
&lt;fieldset&gt;
&lt;legend tal:content="todolist/title"&gt;title&lt;/legend&gt;
&lt;p tal:content="todolist/description"&gt;description&lt;/p&gt;
<strong>&lt;div tal:repeat="item todolist/items" tal:attributes="class python:item['checked'] and 'done' or 'pending'"&gt;
</strong>
&lt;input type="checkbox" tal:attributes="name string:item_${repeat/item/index}; checked item/checked"/&gt;
&lt;span tal:content="item/description"&gt;&lt;/span&gt;
<strong>&lt;input type="image" tal:attributes="name string:delete_${rep eat/item/index}; src static/bin_closed.png" value="Delete"/&gt;&lt;br/&gt;
</strong>
&lt;/div&gt;
<strong>&lt;input type="hidden" name="list_index" tal:attributes="value repeat/todolist/index"/&gt;
</strong>
<strong>&lt;input type="submit" class="update_button" name="update_list" value="Update list"/&gt;&lt;br/&gt;
</strong>
&lt;label for="item_description"&gt;New item:&lt;/label&gt;&lt;br/&gt;
<strong>&lt;input type="text" size="60" name="item_description"&gt;&lt;br/&gt;
</strong>
<strong>&lt;input type="submit" class="new_button" name="new_item" value="Add to list"/&gt;
</strong>
&lt;/fieldset&gt;
&lt;/form&gt;
&lt;/tal:block&gt;
<strong>&lt;form class="add" method="post" tal:attributes="action view/url"&gt;
</strong>
&lt;fieldset&gt;
&lt;legend&gt;Create new list&lt;/legend&gt;
&lt;label for="list_title"&gt;Title:&lt;/label&gt;
&lt;input type="text" name="list_title" size="40"/&gt;&lt;br/&gt;
&lt;label for="list_description"&gt;Description:&lt;/label&gt;&lt;br/&gt;
<strong>&lt;textarea name="list_description" rows="3" cols="50"&gt;&lt;/textarea&gt;&lt;br/&gt;
&lt;input type="submit" class="new_button" name="new_list" value="Create"/&gt;
</strong>
&lt;/fieldset&gt;
&lt;/form&gt;
&lt;/body&gt;
&lt;/html&gt;
</pre></div><p>The class attributes that we added are pretty straightforward, but in the case of list items, we wanted to have checked items display differently to unchecked items, so we used the<code class="literal"> attributes</code> statement again to dynamically decide at render time whether each item is checked (class done) or not (class pending) and use a different class in each case.</p><p>Finally, we switched the input type of the delete button from<code class="literal"> submit</code> to<code class="literal"> image</code> and added a link to an icon using the special<code class="literal"> static</code> name again.<a id="id101" class="indexterm"/>
</p><p>That's it. We don't need to stop the server to see how it looks. Just reload the page and see. The Python code was not even touched, and the template has minimal changes, but the application looks completely different when it uses the CSS, as shown in the following screenshot:</p><div><img src="img/7481_03_04.jpg" alt="Adding static resources"/></div></div></div>


  <div><div><div><div><div><h1 class="title"><a id="ch03lvl1sec06"/>Putting in some JavaScript flourish</h1></div></div></div><p>Our to-do application looks a lot better now, but there are a few touches that we can also do to make it feel better. Having to press the update button each time that we check off one task is somewhat awkward, and can be easily forgotten. It would be nice if the list is automatically updated whenever we click on a checkbox.<a id="id102" class="indexterm"/>
</p><p>Visually, the input box and button for adding list items are a bit distracting, so maybe we could hide them until they are needed. A final visual touch that we could add would be to move all of the checked-off items to the bottom of the list, so that it's clear what has and hasn't been done.</p><p>For hiding the form controls, we have to modify the template to make the new item label clickable, and call a toggle function in JavaScript when the user clicks it. We'll assign the<code class="literal"> onclick</code> attribute dynamically to refer to the unique ID of the<code class="literal">&lt;div&gt;</code> that contains the controls.</p><div><pre class="programlisting">&lt;label for="item_description" tal:attributes="onclick string:toggleAddControls('add_controls_${repeat/todolist/index}');"&gt; New item&lt;/label&gt;&lt;br/&gt;
</pre></div><p>Of course, for this to work we have to wrap the controls in a<code class="literal">&lt;div&gt;</code> tag and assign the same ID to it:</p><div><pre class="programlisting">&lt;div class="controls" tal:attributes="id string:add_controls_${repeat/todolist/index}"&gt;
&lt;input type="text" size="60" name="item_description"&gt;&lt;br/&gt;
&lt;input type="submit" class="new_button" name="new_item" value="Add to list"/&gt;
&lt;/div&gt;
</pre></div><p>That does it. In fact, this is so easy that we can do the same for the create list controls. The only thing is that we don't need a dynamic ID here, since there's only one 'create list' form:</p><div><pre class="programlisting">&lt;legend onclick="toggleAddControls('new_list_controls');"&gt;Create new list&lt;/legend&gt;
&lt;div class="controls" id="new_list_controls"&gt;
&lt;label for="list_title"&gt;Title:&lt;/label&gt;
&lt;input type="text" name="list_title" size="40"/&gt;&lt;br/&gt;
&lt;label for="list_description"&gt;Description:&lt;/label&gt;&lt;br/&gt;
&lt;textarea name="list_description" rows="3" cols="50"&gt;&lt;/textarea&gt;&lt;br/&gt;
&lt;input type="submit" class="new_button" name="new_list" value="Create"/&gt;
&lt;/div&gt;
</pre></div><p>Moving completed items to the bottom does not require us to modify anything in the template. It's all done using JavaScript and the DOM. Skipping the use of the update button, however, is a bit harder, because we will need to use the<code class="literal"> XMLHTTPRequest</code> object (better known by the word AJAX these days) to call a Grok view from JavaScript.</p><p>Earlier, we said that a view usually consists of a template and a class. However, there are cases where a template is not really necessary. What we need here is a simple view that will set the checked state of the checkbox that was clicked on by the user. This view should return just the ID of the affected item, so that we can dynamically change its CSS class to reflect the change.</p><p>Adding a view in Grok is very easy, we just need to define a class that inherits from<code class="literal"> grok.View</code>, and then add the required behavior to this. In this case, we don't even need a template, because we will just be returning the item ID as plain text. Grok allows us to use a<code class="literal"> render</code> method on a view when we don't want to use a template or need to return something other than HTML. We'll add the new view to<code class="literal"> app.py:</code>
<a id="id103" class="indexterm"/>
</p><div><pre class="programlisting">class Check(grok.View):
def update(self,list_index,item_index):
self.div_id = 'div_item_%s_%s' % (list_index,item_index)
list_index=int(list_index)
item_index=int(item_index)
items = self.context.todolists[list_index]['items']
items[item_index]['checked'] = not items[item_index] ['checked']
def render(self):
return self.div_id
</pre></div><p>The new view class name is<code class="literal"> Check</code>, so the view URL will use the word<code class="literal"> check</code> in lowercase. This view expects to be passed a list index and an item index to toggle the state of some item in the list. In this case, we do not need to examine the form, because we know we'll always require the same parameters. Grok can easily retrieve the parameters from the form for us, by specifying them after<code class="literal"> self</code> in the<code class="literal"> update</code> method. An error will occur if one or both of them are not present.</p><p>Note that the<code class="literal"> update</code> method is called first, so we store the item ID in the view attribute<code class="literal"> div_id</code> so that we can return it later when the template is actually rendered. Then, we use the indexes to find the correct item and toggle its state by using the<code class="literal"> not</code> operator.</p><p>As we mentioned before, we'll return a simple string ID, so no template is needed. That's why this view has a<code class="literal"> render</code> method, which in this case just returns the ID that we stored earlier. In other situations, the<code class="literal"> render</code> method could do much more for example, generating the HTML for the page, or sending a specific kind of content, such as an image or a PDF file. To do this, in addition to the code to render the desired document, the<code class="literal"> render</code> method must also set the<code class="literal"> Content-Type</code> by using the special<code class="literal"> response</code> object, as in this example of returning XML:</p><div><pre class="programlisting">self.response.setHeader('Content-Type','text/xml; charset=UTF-8')
</pre></div><p>When we use the<code class="literal"> render</code> method, no template is expected, so if Grok finds a template that should be associated with this view, it will signal an error to avoid ambiguity. In this case, if we put a template named<code class="literal"> check.pt</code> inside the<code class="literal"> app_templates</code> directory, Grok will stop with an error.</p><p>Now that we have our new view, we need to call it from the template when the user clicks on a checkbox. We'll use the<code class="literal"> onclick</code> event handler here, too:</p><div><pre class="programlisting">&lt;div tal:repeat="item todolist/items" tal:attributes="class python:item['checked'] and 'done' or 'pending'; id string:div_item_${repeat/todolist/index}_${repeat/item/index}"&gt;
&lt;input type="checkbox" tal:define="check_url python:view.url('check');" tal:attributes="name string:item_${repeat/item/index}; checked item/checked; onclick string:checkItem( '${check_url}?list_index=${repeat/todolist/index}&amp; item_index=${repeat/item/index}')"/&gt;
&lt;span tal:content="item/description"&gt;&lt;/span&gt;
&lt;input type="image"
tal:attributes="name string:delete_${repeat/item/index}; src static/bin_closed.png" value="Delete"/&gt;
&lt;br/&gt;
&lt;/div&gt;
</pre></div><p>First, we need to assign a unique ID to each item, which we do in the<code class="literal">&lt;div&gt;</code> tag, by using the<code class="literal"> list</code> and<code class="literal"> item</code> indexes. Then we assign the<code class="literal"> onclick</code> attribute by using the TAL<code class="literal"> attributes</code> statement, so that we can dynamically construct the URL with the<code class="literal"> check</code> view name and the list and item indexes as query parameters. To avoid hardcoding URL information, we use the<code class="literal"> url</code> method from the view class, which, when called with a string as a parameter, returns the view with that name. We use the<code class="literal"> define</code> statement for this.<a id="id104" class="indexterm"/>
</p><p>Now, when the user clicks on a checkbox, the<code class="literal"> check</code> view will be called from JavaScript with a<code class="literal"> GET</code> request, and the JavaScript callback function that gets the return value will use it to set the correct CSS class for the checked state, and rearrange the completed items at the bottom.</p><p>The JavaScript code necessary for doing this work is included in the source code for this book. You should study it if you are interested in the details. Explaining that code would be outside the goals of this chapter. The key thing to take away from this example is the ability to have views in Grok that return anything that we want, and not just templates.</p></div></div>


  <div><div><div><div><div><h1 class="title"><a id="ch03lvl1sec07"/>Summary</h1></div></div></div><p>Using our newly acquired knowledge of ZPT, we now have a simple, but complete, Grok application, including a nice design and JavaScript embellishments. As we designed it, we learned what Grok views are and the basics of working with them. In the next chapter, we will see where the data for views comes from: the content objects or models that define Grok applications.</p></div></div>
</body></html>