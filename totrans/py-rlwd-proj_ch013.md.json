["```py\n% python src/clean.py -o analysis -i quartet/Series_1.ndjson\n```", "```py\n% python src/acquire.py -s Series_1Pair --csv source.csv | \\\n    python src/clean.py -o analysis/Series_1.ndjson\n```", "```py\nimport json\nfrom pydantic.json import pydantic_encoder\nfrom typing import TextIO, Iterable\n\nimport analysis_model\n\ndef persist_samples(\n        target_file: TextIO,\n        analysis_samples: Iterable[analysis_model.SeriesSample | None]\n) -> int:\n    count = 0\n    for result in filter(None, analysis_samples):\n        target_file.write(json.dumps(result, default=pydantic_encoder))\n        target_file.write(\"\\n\")\n        count += 1\n    return count\n```", "```py\nfrom pydantic import validator, BaseModel, Field\n\nclass SeriesSample(BaseModel):\n    \"\"\"\n    An individual sample value.\n    \"\"\"\n    x: float = Field(title=\"The x attribute\", ge=0.0)\n    y: float = Field(title=\"The y attribute\", ge=0.0)\n\n    @validator(’x’, ’y’, pre=True)\n    def clean_value(cls, value: str | float) -> str:\n        match value:\n            case str():\n                for char in \"\\N{ZERO WIDTH SPACE}\":\n                    value = value.replace(char, \"\")\n                return value\n            case float():\n                return value\n```", "```py\n    @classmethod\n    def from_acquire_dataclass(\n            cls,\n            acquired: acquire_model.SeriesSample\n    ) -> \"SeriesSample\":\n        return SeriesSample(**asdict(acquired))\n```", "```py\nfrom pydantic import BaseModel\nfrom pydantic.functional_validators import field_validator, BeforeValidator\n\nfrom typing import Annotated\n\ndef clean_value(value: str | float) -> str | float:\n    match value:\n        case str():\n            for char in \"\\N{ZERO WIDTH SPACE}\":\n                value = value.replace(char, \"\")\n            return value\n        case float():\n            return value\n\nclass SeriesSample(BaseModel):\n    x: Annotated[float, BeforeValidator(clean_value)]\n    y: Annotated[float, BeforeValidator(clean_value)]\n```", "```py\nfrom typing import Annotated, TypeAlias\n\nCleanFloat: TypeAlias = Annotated[float, BeforeValidator(clean_value)]\n```", "```py\nfrom typing import TextIO\n\ndef clean_all(acquire_file: TextIO, analysis_file: TextIO) -> None:\n    ...\n```", "```py\nScenario: Valid file is recognized.\n    Given a file \"example_1.ndjson\" with the following content\n        \"\"\"\n        {\"x\": \"1.2\", \"y\": \"3.4\"}\n        {\"x\": \"five\", \"z\": null}\n        \"\"\"\n    When the clean tool is run\n    Then the output shows 1 good records\n    And the output shows 1 faulty records\n```"]