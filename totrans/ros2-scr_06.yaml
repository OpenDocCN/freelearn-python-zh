- en: '4'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Writing and Building a ROS 2 Node
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: To write your own custom code with ROS 2, you will have to create ROS 2 programs,
    or in other words, nodes. You already discovered the concept of nodes in [*Chapter
    3*](B22403_03.xhtml#_idTextAnchor092). In this chapter, we will go deeper, and
    you will write your first node with Python and C++.
  prefs: []
  type: TYPE_NORMAL
- en: 'Before you create a node, there is a bit of setup to do: you need to create
    a ROS 2 workspace, in which you will build your application. In this workspace,
    you will then add packages to better organize your nodes. Then, in those packages,
    you can start to write your nodes. After you write a node, you will build it and
    run it.'
  prefs: []
  type: TYPE_NORMAL
- en: We will do this complete process together, with hands-on code and command lines
    all along the way. This is the process that you will repeat for any new node you
    create when developing a ROS 2 application.
  prefs: []
  type: TYPE_NORMAL
- en: By the end of this chapter, you will be able to create your own packages and
    ROS 2 nodes with Python and C++. You will also be able to run and introspect your
    nodes from the terminal. This is the stepping stone you need in order to learn
    any other ROS 2 functionality. There is no topic, service, action, parameter,
    or launch file without nodes.
  prefs: []
  type: TYPE_NORMAL
- en: All explanations will start with Python, followed by C++, which we’ll cover
    more quickly. If you only want to learn with Python, you can skip the C++ sections.
    However, if you want to learn with C++, reading the previous Python explanations
    is mandatory for comprehension.
  prefs: []
  type: TYPE_NORMAL
- en: All the code examples for this chapter can be found in the **ch4** folder of
    the book’s GitHub repository ([https://github.com/PacktPublishing/ROS-2-from-Scratch](https://github.com/PacktPublishing/ROS-2-from-Scratch)).
  prefs: []
  type: TYPE_NORMAL
- en: 'In this chapter, we will cover the following topics:'
  prefs: []
  type: TYPE_NORMAL
- en: Creating and setting up a ROS 2 workspace
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Creating a package
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Creating a Python node
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Creating a C++ node
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Node template for Python and C++ nodes
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Introspecting your nodes
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Technical requirements
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'To follow this chapter, you need the following:'
  prefs: []
  type: TYPE_NORMAL
- en: Ubuntu 24.04 installed (dual boot or virtual machine)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: ROS Jazzy
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A text editor or IDE (for example, VS Code with the ROS extension)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: These requirements will be valid for all chapters in *Part 2*.
  prefs: []
  type: TYPE_NORMAL
- en: Creating and setting up a ROS 2 workspace
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Before we write any code, we need to do a bit of organization. Nodes will exist
    within packages, and all your packages will exist within a **ROS** **2 workspace**.
  prefs: []
  type: TYPE_NORMAL
- en: What is a ROS 2 workspace? A **workspace** is nothing more than a folder organization
    in which you will create and build your packages. Your entire ROS 2 application
    will live within this workspace.
  prefs: []
  type: TYPE_NORMAL
- en: To create one, you have to follow certain rules. Let’s create your first workspace
    step by step and correctly set it up.
  prefs: []
  type: TYPE_NORMAL
- en: Creating a workspace
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: To create a workspace, you will simply create a new directory inside your home
    directory.
  prefs: []
  type: TYPE_NORMAL
- en: 'As for the workspace’s name, let’s keep it simple for now and use something
    that is recognizable: **ros2_ws**.'
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs: []
  type: TYPE_NORMAL
- en: The name of the workspace is not important, and it will not affect anything
    in your application. As we are just getting started, we only have one workspace.
    When you make progress and start to work on several applications, the best practice
    is to name each workspace with the name of the application or robot. For example,
    if you create a workspace for a robot named `ABC V3`, then you can name it `abc_v3_ws`.
  prefs: []
  type: TYPE_NORMAL
- en: 'Open a terminal, navigate to your home directory, and create the workspace:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'Then, enter the workspace and create a new directory named **src**. This is
    where you will write all the code for your ROS 2 application:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: That’s really all there is to it. To set up a new workspace, you just create
    a new directory (somewhere in your home directory) and create an **src** directory
    inside it.
  prefs: []
  type: TYPE_NORMAL
- en: Building the workspace
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Even if the workspace is empty (we have not created any packages yet), we can
    still build it. To do that, follow these steps:'
  prefs: []
  type: TYPE_NORMAL
- en: Navigate to the workspace root directory. Make sure you are in the right place.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Run the `colcon build` command. `colcon` is the build system in ROS 2, and it
    was installed when you installed the `ros-dev-tools` packages in [*Chapter 2*](B22403_02.xhtml#_idTextAnchor048).
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Let’s build the workspace:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: 'As you can see, no packages were built, but let’s list all directories under
    **~/ros2_ws**:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: 'As you can see, we have three new directories: **build**, **install**, and
    **log**. The **build** directory will contain the intermediate files required
    for the overall build. In **log**, you will find logs for each build. The most
    important directory for you is **install**, which is where all your nodes will
    be installed after you build the workspace.'
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs: []
  type: TYPE_NORMAL
- en: You should always run `colcon build` from the root of your workspace directory,
    not from anywhere else. If you make a mistake and run this command from another
    directory (let’s say, from the `src` directory of the workspace, or inside a package),
    simply remove the new `install`, `build`, and `log` directories that were created
    in the wrong place. Then go back to the workspace root directory and build again.
  prefs: []
  type: TYPE_NORMAL
- en: Sourcing the workspace
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'If you navigate inside the newly created **install** directory, you can see
    a **setup.bash** file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: This might look familiar. If you remember, after we installed ROS 2, we sourced
    a similar bash script from the ROS 2 installation directory (**/opt/ros/jazzy/setup.bash**)
    so that we could use ROS 2 in our environment. We will need to do the same for
    our workspace.
  prefs: []
  type: TYPE_NORMAL
- en: Every time you build your workspace, you have to source it so that the environment
    (the session you are in) knows about the new changes in the workspace.
  prefs: []
  type: TYPE_NORMAL
- en: 'To source the workspace, source this **setup.bash** script:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: Then, as we previously did, we are going to add that line into our **.bashrc**.
    This way, you don’t need to source the workspace every time you open a new terminal.
  prefs: []
  type: TYPE_NORMAL
- en: 'Open your **.bashrc** (located in your home directory the path is **~/.bashrc**)
    using any text editor you want:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: 'Add the line to source the workspace’s **setup.bash** script, just after the
    one to source the global ROS 2 installation. The order is very important here.
    You have to source the global ROS 2 installation first, and then your workspace,
    not the other way around:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: Make sure to save**.bashrc**. Now, both ROS 2 and your workspace will be sourced
    in any new terminal you open.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs: []
  type: TYPE_NORMAL
- en: If you build the workspace in an already sourced environment, you will still
    need to source the workspace once again as there have been some changes, and the
    environment is not aware of that. In this case, you can either source the workspace’s
    `setup.bash` script directly, source the `.bashrc`, or open a new terminal.
  prefs: []
  type: TYPE_NORMAL
- en: 'Your workspace is now correctly set up, and you can build your application.
    Next step: creating a package.'
  prefs: []
  type: TYPE_NORMAL
- en: Creating a package
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Any node you create will exist within a package. Hence, to create a node, you
    first have to create a package (inside your workspace). You will now learn how
    to create your own packages, and we will see the differences between Python and
    C++ packages.
  prefs: []
  type: TYPE_NORMAL
- en: But first, what exactly is a package?
  prefs: []
  type: TYPE_NORMAL
- en: What is a ROS 2 package?
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: A ROS 2 package is a sub-part of your application.
  prefs: []
  type: TYPE_NORMAL
- en: Let’s consider a robotic arm that we want to use to pick up and place objects.
    Before we create any node, we can try to split this application into several sub-parts,
    or packages.
  prefs: []
  type: TYPE_NORMAL
- en: We could have one package to handle a camera, another package for the hardware
    control (motors), and yet another package to compute motion planning for the robot.
  prefs: []
  type: TYPE_NORMAL
- en: "![Figure 4.1\uFEFF – Example of a package organization for a robot](img/B22403_04_1.jpg)"
  prefs: []
  type: TYPE_IMG
- en: Figure 4.1 – Example of a package organization for a robot
  prefs: []
  type: TYPE_NORMAL
- en: Each package is an independent unit, responsible for one sub-part of your application.
  prefs: []
  type: TYPE_NORMAL
- en: Packages are very useful for organizing your nodes, and also to correctly handle
    dependencies, as we will see later in this book.
  prefs: []
  type: TYPE_NORMAL
- en: Now, let’s create a package, and here you have to make a choice. If you want
    to create a node with Python, you will create a Python package, and if you want
    to create a node with C++, you will create a C++ package. The architecture for
    each package type is quite different.
  prefs: []
  type: TYPE_NORMAL
- en: Creating a Python package
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'You will create all your packages in the **src** directory of your ROS 2 workspace.
    So, make sure to navigate to this directory before you do anything else:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: 'Here is how to construct the command to create a package:'
  prefs: []
  type: TYPE_NORMAL
- en: '`ros2 pkg create <pkg_name>`: This is the minimum you need to write.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: You can specify a build type with `--build_type <build_type>`. For a Python
    package, we need to use `ament_python`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: You can also specify some optional dependencies with `--dependencies <list_of_dependencies_separated_with_spaces>`.
    It’s always possible to add dependencies later in the package.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Let’s create our first package named **my_py_pkg**. We will use this name as
    an example to work with the main ROS 2 concepts. Then, as we progress, we will
    use more meaningful names. In the **src** directory of your workspace, run the
    following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: 'With this command, we say that we want to create a package named **my_py_pkg**,
    with the **ament_python** build type, and we specify one dependency: **rclpy**—this
    is the Python library for ROS 2 that you will use in every Python node.'
  prefs: []
  type: TYPE_NORMAL
- en: This will print quite a few logs, showing you what files have been created.
    You might also get a **[WARNING]** log about a missing license, but as we have
    no intention of publishing this package anywhere, we don’t need a license file
    now. You can ignore this warning.
  prefs: []
  type: TYPE_NORMAL
- en: 'You can then see that there is a new directory named **my_py_pkg**. Here is
    the architecture of your newly created Python package:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: Not all the files are important right now. We’ll see how to use those files
    to configure and install our nodes just a bit later.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here is a quick overview of the most important files and directories:'
  prefs: []
  type: TYPE_NORMAL
- en: '`my_py_pkg`: As you can see, inside the package, there is another directory
    with the same name. This directory already contains an `__init__.py` file. This
    is where we will create our Python nodes.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`package.xml`: Every ROS 2 package (Python or C++) must contain this file.
    We will use it to provide more information about the package as well as dependencies.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`setup.py`: This is where you will write the instructions to build and install
    your Python nodes.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Creating a C++ package
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: We will work a lot with Python in this book, but for completeness, I will also
    include C++ code for all examples. They will either be explained in the book,
    or the code will be in the GitHub repository.
  prefs: []
  type: TYPE_NORMAL
- en: Creating a C++ package is very similar to creating a Python package; however,
    the architecture of the package will be quite different.
  prefs: []
  type: TYPE_NORMAL
- en: 'Make sure you navigate to the **src** directory of your workspace, and then
    create a new package. Let’s use a similar pattern as we did for Python and name
    the package **my_cpp_pkg**:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: 'We choose **ament_cmake** for the build type (meaning this will be a C++ package),
    and we specify one dependency: **rclcpp**—this is the C++ library for ROS 2, which
    we will use in every C++ node.'
  prefs: []
  type: TYPE_NORMAL
- en: Once again, you should see quite a few logs, with the newly created files, and
    maybe a warning about the license that you can ignore.
  prefs: []
  type: TYPE_NORMAL
- en: 'The architecture of your new C++ package will look like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: 'Here is a quick explanation of the role of each file or directory:'
  prefs: []
  type: TYPE_NORMAL
- en: '`CMakeLists.txt`: This will be used to provide instructions on how to compile
    your C++ nodes, create libraries, and so on.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`include` directory: In a C++ project, you may split your code into implementation
    files (`.cpp` extension) and header files (`.hpp` extension). If you split your
    C++ nodes into `.cpp` and `.hpp` files, you will put the header files inside the
    `include` directory.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`package.xml`: This file is required for any kind of ROS 2 package. It contains
    more information about the package, and dependencies on other packages.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`src` directory: This is where you will write your C++ nodes (`.``cpp` files).'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Building a package
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Now that you’ve created one or more packages, you can build them, even if you
    don’t have any nodes in the packages yet.
  prefs: []
  type: TYPE_NORMAL
- en: To build the packages, go back to the root of your ROS 2 workspace and run **colcon
    build**. Once again, and as seen previously in this chapter, where you run this
    command is very important.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: Both packages have been built. You will have to do that every time you add or
    modify a node inside a package.
  prefs: []
  type: TYPE_NORMAL
- en: 'The important thing to notice is this line: **Finished <<< <package_name> [time]**.
    This means that the package was correctly built. Even if you see additional warning
    logs, if you also see the **Finished** line, you know the package has been built.'
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs: []
  type: TYPE_NORMAL
- en: 'After you build any package, you also have to source your workspace so that
    the environment is aware of the new changes. You can do any of the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '- Open a new terminal as everything is configured in the `.``bashrc` file'
  prefs: []
  type: TYPE_NORMAL
- en: '- Source the `setup.bash` script directly (`source ~/ros2_ws/install/setup.bash`)'
  prefs: []
  type: TYPE_NORMAL
- en: '- Source the `.bashrc` manually (`source ~/.bashrc`)'
  prefs: []
  type: TYPE_NORMAL
- en: 'To build only a specific package, you can use the **--packages-select** option,
    followed by the name of the package. Here’s an example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: This way, you don’t need to build your entire application every time and can
    just focus on one package.
  prefs: []
  type: TYPE_NORMAL
- en: Now that we have created some packages and we know how to build them, we can
    create nodes in the packages. But how are we going to organize them?
  prefs: []
  type: TYPE_NORMAL
- en: How are nodes organized in a package?
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: To develop a ROS 2 application, you will write code inside nodes. As seen in
    [*Chapter 3*](B22403_03.xhtml#_idTextAnchor092), *node* is simply the name of
    a ROS 2 program.
  prefs: []
  type: TYPE_NORMAL
- en: A node is a subprogram of your application, responsible for one thing. If you
    have two different functionalities to implement, then you will have two nodes.
    Nodes communicate with each other using ROS 2 communications (topics, services,
    and actions).
  prefs: []
  type: TYPE_NORMAL
- en: You will organize your nodes inside packages. For one package (sub-part of your
    application), you can have several nodes (functionalities). To fully understand
    how to organize packages and nodes, you need practice and experience. For now,
    let’s just get an idea with an example.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s come back to the package architecture we had in *Figure 4**.1*, and add
    nodes inside the packages:'
  prefs: []
  type: TYPE_NORMAL
- en: "![Figure 4.2\uFEFF – Example of a package organization with nodes](img/B22403_04_2.jpg)"
  prefs: []
  type: TYPE_IMG
- en: Figure 4.2 – Example of a package organization with nodes
  prefs: []
  type: TYPE_NORMAL
- en: As you can see, in the camera package, we could have one node responsible for
    handling the camera hardware. This node would send images to an image processing
    node, and this latter would extract the coordinates of objects for the robot to
    pick up.
  prefs: []
  type: TYPE_NORMAL
- en: In the meantime, a motion planning node (in the motion planning package) would
    compute the movements that the robot should perform, given a specific command.
    A path correction node can support this motion planning using the data received
    from the image processing node.
  prefs: []
  type: TYPE_NORMAL
- en: Finally, to make the robot move, a hardware driver node would be responsible
    for hardware communication (motors, encoders) and receive commands from the motion
    planning node. An additional state publisher node could be here to publish additional
    data about the robot for other nodes to use.
  prefs: []
  type: TYPE_NORMAL
- en: This node organization is purely fictitious and is here just to give you a general
    idea of how a ROS 2 application can be designed, and which roles a node can have
    in this application.
  prefs: []
  type: TYPE_NORMAL
- en: Now, you are (finally) going to write your first ROS 2 node. ROS 2 requires
    quite a lot of installation and configuration before you can actually write some
    code, but good news, we have completed all of this and can now focus on the code.
  prefs: []
  type: TYPE_NORMAL
- en: We won’t do anything too complicated for now; we won’t dive into complex features
    or communications. We will write a basic node that you can use as a template to
    start any future node. We will also build the node and see how to run it.
  prefs: []
  type: TYPE_NORMAL
- en: Creating a Python node
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Let’s create our first Python node, or in other words, our first ROS 2 Python
    program.
  prefs: []
  type: TYPE_NORMAL
- en: The processes of creating Python and C++ nodes are very different. That’s why
    I have written a separate section for each of them. We will start with Python,
    with complete step-by-step explanations. Then we will see how to do the same with
    C++. If you want to follow the C++ node section, make sure to read this one first.
  prefs: []
  type: TYPE_NORMAL
- en: 'To create a node, you will have to do the following:'
  prefs: []
  type: TYPE_NORMAL
- en: Create a file for the node.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Write the node. We will use **Object Oriented Programming** (**OOP**), as officially
    recommended for ROS 2 (and almost every existing ROS 2 code you find uses OOP).
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Build the package in which the node exists.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Run the node to test it.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Let’s get started with our first Python node.
  prefs: []
  type: TYPE_NORMAL
- en: Creating a file for the node
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: To write a node, we first need to create a file. Where should we create this
    file?
  prefs: []
  type: TYPE_NORMAL
- en: If you remember, when we created the **my_py_pkg** package, another **my_py_pkg**
    directory was created inside the package. This is where we will write the node.
    For every Python package, you have to go to the directory which has the same name
    as the package. If your package name is **abc**, then you’ll go to **~/ros2_ws/src/abc/abc/**.
  prefs: []
  type: TYPE_NORMAL
- en: 'Create a new file in this directory and make it executable:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: After this, open this file to write in it. You can use any text editor or IDE
    you want here, as long as you don’t get lost in all the files.
  prefs: []
  type: TYPE_NORMAL
- en: If you have no idea what to use, I suggest using VS Code with the ROS extension
    (as explained in [*Chapter 2*](B22403_02.xhtml#_idTextAnchor048)). This is the
    tool I’m using for all ROS development.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs: []
  type: TYPE_NORMAL
- en: 'If you are using VS Code, the best way to open it is to first navigate to the
    `src` directory of your workspace in a terminal, and then open it. This way, you
    have access to all the packages in your workspace, and it will make things easier
    with recognized dependencies and auto-completion:'
  prefs: []
  type: TYPE_NORMAL
- en: '`$` `cd ~/ros2_ws/src/`'
  prefs: []
  type: TYPE_NORMAL
- en: '`$` `code .`'
  prefs: []
  type: TYPE_NORMAL
- en: Writing a minimal ROS 2 Python node
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Here is the starting code for any Python node you will create. You can write
    this code into the **my_first_node.py** file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: As you can see, we use OOP here. OOP is everywhere in ROS 2, and this is the
    default (and recommended) way to write a node.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s come back to this code step by step, to understand what it’s doing:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: We first import **rclpy**, the Python library for ROS 2\. Inside this library,
    we can get the **Node** class.
  prefs: []
  type: TYPE_NORMAL
- en: 'We then create a new class that inherits from the **rclpy** **Node** class:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: In this class, make sure you call the parent constructor with **super()**. This
    is also where you will specify the node name.
  prefs: []
  type: TYPE_NORMAL
- en: 'This node is not doing anything for now; we will add a few functionalities
    in a minute. Let''s finish the code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: 'After the class, we create a **main()** function in which we perform the following
    actions:'
  prefs: []
  type: TYPE_NORMAL
- en: Initialize ROS 2 communications with `rclpy.init()`. This should be the first
    line in your `main()`function.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Create an object from the `MyCustomNode` class we wrote before. This will initialize
    the node. There’s no need to destroy the node later, as this will happen automatically
    when the program exits.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Make the node spin. If you omit this line, the node will be created, then the
    program will exit, and the node will be destroyed. Making the node spin means
    that we block the execution here, the program stays alive, and thus the node stays
    alive. In the meantime, as we will see shortly, all registered callbacks for the
    node can be processed. When you press *Ctrl* + *C*, the node will stop spinning
    and this function will return.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: After the node is killed, shut down ROS 2 communications with `rclpy.shutdown()`.
    This will be the last line of your `main()`function.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: This is how all your ROS 2 programs will work. As you can see, the node is in
    fact an object that we create within the program (the node is not the program
    in itself, but still, it is quite common to refer to the word “node” when we talk
    about the program). After being created, the node can stay alive and play its
    part while it is spinning. We will come back to this *spinning* shortly.
  prefs: []
  type: TYPE_NORMAL
- en: 'Finally, we also have added these two lines:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: This is a pure Python thing and has nothing to do with ROS 2\. It just means
    that if you run the Python script directly, the **main()** function will be called,
    so you can try your program without having to install it with **colcon**.
  prefs: []
  type: TYPE_NORMAL
- en: 'Great, you have written your first minimal Python node. Before you build and
    run it, add one more line in the Node’s constructor, so it can do something:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: This line will print **Hello World** when the node starts.
  prefs: []
  type: TYPE_NORMAL
- en: 'As the **MyCustomNode** class inherits from the **Node** class, we get access
    to all the ROS 2 functionalities for nodes. This will make things quite convenient
    for us. Here, you have an example with the logging functionality: we get the **get_logger()**
    method from **Node**. Then, with the **info()**method, we can print a log with
    the info level.'
  prefs: []
  type: TYPE_NORMAL
- en: Building the node
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: You are now going to build the node so that you can run it.
  prefs: []
  type: TYPE_NORMAL
- en: 'You might think: why do we need to build a Python node? Python is an interpreted
    language; couldn’t we just run the file itself?'
  prefs: []
  type: TYPE_NORMAL
- en: 'Yes, this is true: you could test the code just by running it in the terminal
    **($ python3 my_first_node.py**). However, what we want to do is actually install
    the file in our workspace, so we can start the node with **ros2 run**, and later
    on, from a launch file.'
  prefs: []
  type: TYPE_NORMAL
- en: We usually use the word “build”, because to install a Python node, we have to
    run **colcon build**.
  prefs: []
  type: TYPE_NORMAL
- en: 'To build (install) the node, we need to do one more thing in the package. Open
    the **setup.py** file from the **my_py_pkg** package. Locate **entry_points**
    and **''console_scripts''** at the end of the file. For each node we want to build,
    we have to add one line inside the **''****console_scripts''** array:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: 'Here is the syntax:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: 'There are a few important things to correctly write this line:'
  prefs: []
  type: TYPE_NORMAL
- en: First, choose an executable name. This will be the name you use with `ros2 run
    <``pkg_name> <executable_name>`.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: For the filename, skip the `.``py` extension.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The function name is `main`, as we have created a `main()` function in the code.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: If you want to add another executable for another node, don’t forget to add
    a comma between each executable and place one executable per line.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Note
  prefs: []
  type: TYPE_NORMAL
- en: 'When learning ROS 2, there is a common confusion between the node name, filename,
    and executable name:'
  prefs: []
  type: TYPE_NORMAL
- en: '- Node name: defined inside the code, in the constructor. This is what you’ll
    see with the `ros2` `node list`, or in `rqt_graph`.'
  prefs: []
  type: TYPE_NORMAL
- en: '- Filename: the file where you write the code.'
  prefs: []
  type: TYPE_NORMAL
- en: '- Executable name: defined in `setup.py` and used with `ros2 run`.'
  prefs: []
  type: TYPE_NORMAL
- en: In this first example, I made sure to use a different name for each so you can
    be aware that these are three different things. But sometimes all three names
    could be the same. For example, you could create a `temperature_sensor.py` file,
    then name your node and your executable `temperature_sensor`.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now that you have given the instructions to create a new executable, go to
    your workspace root directory and build the package:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: You can also add **--packages-select my_py_pkg** to only build this package.
  prefs: []
  type: TYPE_NORMAL
- en: The executable should now be created and installed in the workspace (it will
    be placed inside the **install** directory). We can say that your Python node
    has been built, or installed.
  prefs: []
  type: TYPE_NORMAL
- en: Running the node
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Now you can run your first node, but just before that, make sure that the workspace
    is sourced in your environment:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: This file already contains the line to source the workspace; you could also
    just open a new terminal, or source the **setup.bash** script from the workspace.
  prefs: []
  type: TYPE_NORMAL
- en: 'You can now run your node using **ros2 run** (if you have any doubts, go back
    to the experiments we did in [*Chapter 3*](B22403_03.xhtml#_idTextAnchor092)):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: Great, we see the log **Hello World**. Your first node is successfully running.
    Note that we wrote **test_node** in the **ros2 run** command, as it’s the executable
    name we chose in the **setup.py** file.
  prefs: []
  type: TYPE_NORMAL
- en: Now, you might notice that the program is hanging there. The node is still alive
    because it is spinning. To stop the node, press *Ctrl* + *C*.
  prefs: []
  type: TYPE_NORMAL
- en: Improving the node – timer and callback
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: At this point, you might feel that writing, building, and running a node is
    a long and complicated process. It’s actually not that complex, and it gets easier
    with each new node that you create. On top of that, modifying an existing node
    is even easier. Let’s see that now.
  prefs: []
  type: TYPE_NORMAL
- en: The node we ran is very basic. Let’s add one more functionality and do something
    more interesting.
  prefs: []
  type: TYPE_NORMAL
- en: Our node is printing one piece of text when it’s started. We now want to make
    the node print a string every second, as long as it’s alive.
  prefs: []
  type: TYPE_NORMAL
- en: This behavior of “doing X action every Y seconds” is very common in robotics.
    For example, you could have a node that “reads a temperature every 2 seconds”,
    or that “gives a new motor command every 0.1 seconds”.
  prefs: []
  type: TYPE_NORMAL
- en: How to do that? We will add a **timer** to our node. A timer will trigger a
    **callback** function at a specified rate.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s go back to the code and modify the **MyCustomNode** class. The rest of
    the code stays the same:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: We still have the constructor with **super()**, but now the log is in a separate
    method. Also, instead of just printing **Hello World**, here we create a **counter_**
    attribute that we increment every time we use the log.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs: []
  type: TYPE_NORMAL
- en: If you’re wondering why there is a trailing underscore `_` at the end of each
    class attribute, this is a common OOP convention that I follow to specify that
    a variable is a class attribute. It’s simply a visual help and has no other function.
    You can follow the same convention or use another one—just make sure to stay consistent
    within one project.
  prefs: []
  type: TYPE_NORMAL
- en: 'The most important line is the one to create the timer. To create the timer
    we use the **create_timer()** method from the **Node** class. We need to give
    two arguments: the rate at which we want to call the function (float number),
    and the callback function. Note that the callback function should be specified
    without any parenthesis.'
  prefs: []
  type: TYPE_NORMAL
- en: This instruction means that we want to call the **print_hello** method every
    **1.0** second.
  prefs: []
  type: TYPE_NORMAL
- en: Let’s now try the code. As we have already specified how to create an executable
    from this file in the **setup.py** file, we don’t need to do it again.
  prefs: []
  type: TYPE_NORMAL
- en: 'All we have to do is to build, source, and run. Remember: “build, source, run.”
    Every time you create a new node, or modify an existing one, you have to “build,
    source, run.”'
  prefs: []
  type: TYPE_NORMAL
- en: 'In a terminal, go to the root directory of your ROS 2 workspace and build the
    package:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: Note
  prefs: []
  type: TYPE_NORMAL
- en: On top of `--packages-select <pkg_name>`, you can add the `--symlink-install`
    option, so you won’t have to build the package every time you modify your Python
    nodes; for example, `$ colcon build --packages-select` `my_py_pkg --symlink-install`.
  prefs: []
  type: TYPE_NORMAL
- en: You might see some warning logs, but as long as you see the line starting with
    `Finished <<< my_py_pkg`, it worked correctly. This will install the executable,
    but then if you modify the code, you should be able to run it without building
    it again.
  prefs: []
  type: TYPE_NORMAL
- en: 'Two important things: this only works for Python packages, and you still have
    to build the package for any new executable you create.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Then, from this terminal or another one, source and run the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: As you can see, the process of build, source, and run is quite fast and not
    that complicated. Here, we can see that the node prints a log every second, and
    the counter increments in each new log.
  prefs: []
  type: TYPE_NORMAL
- en: Now, how is this possible? How is the **print_hello()** method called? We have
    created a timer, yes, but nowhere in the code have we actually called **print_hello()**
    directly.
  prefs: []
  type: TYPE_NORMAL
- en: It works because the node is spinning, thanks to **rclpy.spin(node)**. This
    means that the node is kept alive, and all registered callbacks can be called
    during this time. What we do with **create_timer()** is simply to register a callback,
    which can then be called when the node is spinning.
  prefs: []
  type: TYPE_NORMAL
- en: This was your first example of a callback, and as you will see in the following
    chapters of the book, everything runs with callbacks in ROS 2\. At this point,
    if you still have some trouble with the syntax, the callbacks, and the spinning,
    don’t worry too much. As you make progress with the book, you will repeat this
    process many times. When learning ROS 2, understanding comes with hands-on experience.
  prefs: []
  type: TYPE_NORMAL
- en: We are now done with this Python node. With what you’ve seen here, you should
    be able to create your own new Python nodes (in the same package or another package).
    Let’s now switch to C++. If you are only interested in learning ROS 2 with Python
    for now, you can skip the C++ section.
  prefs: []
  type: TYPE_NORMAL
- en: Creating a C++ node
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'We are going to do exactly the same thing we did for the Python node: create
    a file, write the node, build, source, and run.'
  prefs: []
  type: TYPE_NORMAL
- en: Make sure you have read the previous Python section as I will not repeat everything
    here. We will basically just see how to apply the process for a C++ node.
  prefs: []
  type: TYPE_NORMAL
- en: To create a C++ node, we first need a C++ package. We will use the **my_cpp_pkg**
    package that we created previously.
  prefs: []
  type: TYPE_NORMAL
- en: Writing a C++ node
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Let’s create a file for the node. Go to the **src** directory inside the **my_cpp_pkg**
    package and create a **.****cpp** file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: You could also create the file directly from your IDE and not use the terminal.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, if you haven’t done this previously, open your workspace with VS Code
    or any other IDE:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: 'Open **my_first_node.cpp**. Here is the minimal code to write a C++ node:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: Note
  prefs: []
  type: TYPE_NORMAL
- en: If you are using VS Code and you type this code, you might see an include error
    for the `rclcpp` library. Make sure to save the file and wait a few seconds. If
    the include is still not recognized, go to the **Extensions** tab and disable
    and re-enable the ROS extension.
  prefs: []
  type: TYPE_NORMAL
- en: As you can see (and this was similar with Python), in ROS 2 we heavily use OOP
    with C++ nodes.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s analyze this code step by step:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: 'We first include **rclcpp**, the C++ library for ROS 2\. This library contains
    the **rclcpp::Node** class:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs: []
  type: TYPE_PRE
- en: 'As we did for Python, we have created a class that inherits from the **Node**
    class. The syntax is different, but the principle is the same. From this **Node**
    class, we will be able to access all the ROS 2 functionalities: logger, timer,
    and so on. As you can see, we also specify the node name in the constructor. For
    now, the node does nothing; we will add more functionalities in a minute:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs: []
  type: TYPE_PRE
- en: 'You need a **main()** function if you want to be able to run your C++ program.
    In this function, we do exactly the same thing as for Python, with just some differences
    in the syntax:'
  prefs: []
  type: TYPE_NORMAL
- en: Initialize ROS 2 communications with `rclcpp::init()`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Create a node object from your newly written class. As you can see, we don’t
    create an object directly, but a shared pointer to that object. In ROS 2 and C++,
    almost everything you create will be a smart pointer (shared, unique, and so on).
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: We then make the node spin with `rclcpp::spin()`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Finally, when the node is stopped (*Ctrl* + *C*), we shut down all ROS 2 communications
    with `rclcpp::shutdown()`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: This structure for the **main()** function will be very similar for all your
    ROS 2 programs. As you can see, once again, the node is not the program in itself.
    The node is created inside the program.
  prefs: []
  type: TYPE_NORMAL
- en: Before we go further and build, source, and run our node, let’s improve it now
    with a timer, a callback, and a log.
  prefs: []
  type: TYPE_NORMAL
- en: 'Modify the **MyCustomNode** class, and leave the rest as it is:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs: []
  type: TYPE_PRE
- en: This code example will do the same thing as for the Python node. We create a
    timer so that we can call a callback function every **1.0** second. In this callback
    function, we print **Hello** followed by a counter that we increment every time.
  prefs: []
  type: TYPE_NORMAL
- en: 'There are some specificities related to C++:'
  prefs: []
  type: TYPE_NORMAL
- en: 'For the timer, we have to create a class attribute. As you can see we also
    create a shared pointer here: `rclcpp::TimerBase::SharedPtr`.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: We use `this->create_wall_timer()` to create the timer. `this->` is not required
    here, but I have added it to emphasize that we are using the `create_wall_timer()`
    method from the `Node` class.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: To specify the callback in the timer, as we are in a C++ class, we have to use
    `std::bind(&ClassName::method_name, this)`. Make sure you don’t use any parenthesis
    for the method name.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The node is now finished, so we can build it.
  prefs: []
  type: TYPE_NORMAL
- en: Building and running the node
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'We can’t just run the C++ file; we first have to compile it and create an executable.
    To do this, we will edit the **CMakeLists.txt** file. Open this file, and after
    a few lines, you will find something like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE37]'
  prefs: []
  type: TYPE_PRE
- en: The line to find **rclcpp** is here because we provided **--dependencies rclcpp**
    when we created the package with **ros2 pkg create**. Later on, if your nodes
    in this package require more dependencies, you can add the dependencies here,
    one per line.
  prefs: []
  type: TYPE_NORMAL
- en: 'Just after this line, add an extra new line, and then the following instructions:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE38]'
  prefs: []
  type: TYPE_PRE
- en: 'To build a C++ node, we need to do three things:'
  prefs: []
  type: TYPE_NORMAL
- en: Add a new executable with the `add_executable()`function. Here, you have to
    choose a name for the executable (the one that will be used with `ros2 run <pkg_name>
    <executable_name>`), and we also have to specify the relative path to the C++
    file.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Link all dependencies for this executable with the `ament_target_dependencies()`function.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Install the executable with the `install()`instruction, so that we can find
    it when we use `ros2 run`. Here, we put the executable in a `lib/<package_name>`
    directory.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Then, for each new executable you create, you need to repeat *steps 1* and *2*
    and add the executable inside the **install()** instruction, one per line without
    any commas. There’s no need to create a new **install()** instruction for each
    executable.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs: []
  type: TYPE_NORMAL
- en: The end of your `CMakeLists.txt` will contain a block starting with `if(BUILD_TESTING)`,
    and then `ament_package()`. As we are not doing any build testing here, you can
    remove the entire `if` block. Just make sure to keep the `ament_package()` line,
    which should be the last line of the file.
  prefs: []
  type: TYPE_NORMAL
- en: 'You can now build the package with **colcon build**, which is going to create
    and install the executable:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE39]'
  prefs: []
  type: TYPE_PRE
- en: 'If you get any error during the build process, make sure to fix your code first,
    and then build again. Then, you can source your environment, and run your executable:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE40]'
  prefs: []
  type: TYPE_PRE
- en: As you can see, we run the **test_node** executable (built from **my_first_node.cpp**
    file), which is going to start the **my_node_name** node.
  prefs: []
  type: TYPE_NORMAL
- en: You have now successfully written a C++ node. For each new node that you create,
    you will have to create a new C++ file, write the node class, set the build instructions
    for a new executable in **CMakeLists.txt**, and build the package. Then, to start
    the node, source the environment and run the executable with **ros2 run**.
  prefs: []
  type: TYPE_NORMAL
- en: Node template for Python and C++ nodes
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: All the nodes we start in this book will follow the same structure. As additional
    help to get started quickly, I have created a node template you can use to write
    the base of any Python or C++ node. I use these templates myself when creating
    new nodes, as the code can be quite repetitive.
  prefs: []
  type: TYPE_NORMAL
- en: 'You can copy and paste the templates either from this book directly, or download
    them from the GitHub repository: [https://github.com/PacktPublishing/ROS-2-from-Scratch](https://github.com/PacktPublishing/ROS-2-from-Scratch).'
  prefs: []
  type: TYPE_NORMAL
- en: Template for a Python node
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Use this code to start any new Python node:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE41]'
  prefs: []
  type: TYPE_PRE
- en: All you have to do is remove the **MODIFY NAME** comments and change the class
    name (**MyCustomNode**) and the node name (**"node_name"**). It’s better to use
    names that make sense. For example, if you are writing a node to read data from
    a temperature sensor, you could name the class **TemperatureSensorNode**, and
    the node could be **temperature_sensor**.
  prefs: []
  type: TYPE_NORMAL
- en: Template for a C++ node
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Use this code to start any new C++ node:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE42]'
  prefs: []
  type: TYPE_PRE
- en: Remove the **MODIFY NAME** comments and rename the class and the node.
  prefs: []
  type: TYPE_NORMAL
- en: Those two templates will allow you to start your nodes more quickly. I recommend
    you to use them as much as you can.
  prefs: []
  type: TYPE_NORMAL
- en: Introspecting your nodes
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: To finish this chapter, we will practice a bit more with the **ros2 node** command
    line.
  prefs: []
  type: TYPE_NORMAL
- en: So far, you have seen how to write a node, build it, and run it. One missing
    part is to know how to introspect your nodes. Even if a node can run, it doesn’t
    mean it will do exactly what you want it to do.
  prefs: []
  type: TYPE_NORMAL
- en: Being able to introspect your nodes will help you fix errors that you might
    have made in your code. It will also allow you to easily find more information
    about other nodes that you are starting but didn’t write (as we did in the discovery
    phase in [*Chapter 3*](B22403_03.xhtml#_idTextAnchor092)).
  prefs: []
  type: TYPE_NORMAL
- en: For each core concept in *Part 2*, we will take a bit of time to experiment
    with the command-line tools related to the concept. The command-line tool for
    nodes is **ros2 node**.
  prefs: []
  type: TYPE_NORMAL
- en: 'First, and before we use **ros2 node**, we have to start a node. As a recap,
    to start a node, we use **ros2 run <package_name> <executable_name>**. If we start
    the Python node we have created in this chapter, we use this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE43]'
  prefs: []
  type: TYPE_PRE
- en: Only after we have started a node can we do some introspection with **ros2 node**.
  prefs: []
  type: TYPE_NORMAL
- en: ros2 node command line
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'To list all running nodes, use **ros2** **node list**:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE44]'
  prefs: []
  type: TYPE_PRE
- en: We find the name of the node, which we defined in the code.
  prefs: []
  type: TYPE_NORMAL
- en: 'Once we have the node name, we can get more info about it with **ros2 node**
    **info <node_name>**:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE45]'
  prefs: []
  type: TYPE_PRE
- en: As you can see, there are quite a lot of things on the terminal. We will get
    to know all of them in the following chapters. With **ros2 node info <node_name>**
    you can see all topics (publishers/subscribers), services, and actions running
    for this node.
  prefs: []
  type: TYPE_NORMAL
- en: Changing the node name at run time
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'As we progress throughout the book, I will give you additional tips for working
    with ROS 2 and the command line. Here is one: when starting an executable, you
    can choose to use the default node name (the one defined in the code) or replace
    it with a new name.'
  prefs: []
  type: TYPE_NORMAL
- en: To add any additional argument to **ros2 run**, first add **--ros-args** (only
    once).
  prefs: []
  type: TYPE_NORMAL
- en: 'Then, to rename the node, add **-r __node:=<new_name>**. **-r** means remap;
    you could also use **--remap**. For example, if we want to name the node **abc**,
    we could use this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE46]'
  prefs: []
  type: TYPE_PRE
- en: As you can see from the logs, instead of **my_node_name**, we see **abc**.
  prefs: []
  type: TYPE_NORMAL
- en: 'List all running nodes:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE47]'
  prefs: []
  type: TYPE_PRE
- en: This functionality can be very helpful and gives you more control over how to
    start a node, without having to modify the code directly.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs: []
  type: TYPE_NORMAL
- en: When running multiple nodes, you should make sure that each node has a unique
    name. Having two nodes with the same name can lead to some unexpected issues that
    can take a long time to debug. In the future, you will see that you may want to
    run the same node several times, for example, three `temperature_sensor` nodes,
    one each for a different sensor. You could rename them so that you have `temperature_sensor_1`,
    `temperature_sensor_2`, and `temperature_sensor_3`.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, you have created your first node. Let’s do a quick recap of
    all the steps.
  prefs: []
  type: TYPE_NORMAL
- en: 'Before creating any node, you need to follow these steps:'
  prefs: []
  type: TYPE_NORMAL
- en: You first need to create and set up a ROS 2 workspace.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: In this workspace, you can create several packages (Python or C++) that represent
    different sub-parts of your application.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Then, in one package you can create one or several nodes. For each node, you
    will have to do the following:'
  prefs: []
  type: TYPE_NORMAL
- en: Create a file inside the package.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Write the node (using the OOP template as a base).
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Set the build instructions (`setup.py` for Python, `CMakeLists.txt` for C++).
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Build the package.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: To run the node, don’t forget to source the workspace first, and then start
    the node with **ros2 run <****pkg_name> <executable_name>**.
  prefs: []
  type: TYPE_NORMAL
- en: Finally, you can introspect your nodes and even change their names when you
    start them, using the **ros2 node** command line.
  prefs: []
  type: TYPE_NORMAL
- en: Feel free to come back to this chapter anytime to see the complete process of
    creating a node for both Python and C++. All the code is available on GitHub at
    [https://github.com/PacktPublishing/ROS-2-from-Scratch](https://github.com/PacktPublishing/ROS-2-from-Scratch).
    There you can find the OOP template code for Python and C++, **my_py_pkg** package,
    and **my_cpp_pkg** package.
  prefs: []
  type: TYPE_NORMAL
- en: In this chapter, you have also seen how to create a timer and a callback function.
    You have a better idea of how the spin mechanism works, and how it allows the
    node to stay alive and run the callbacks. This will be very useful for the following
    chapters.
  prefs: []
  type: TYPE_NORMAL
- en: In the next chapter, we will see how nodes communicate with each other using
    topics. You will write your own topics (publishers/subscribers) inside nodes and
    experiment with them.
  prefs: []
  type: TYPE_NORMAL
