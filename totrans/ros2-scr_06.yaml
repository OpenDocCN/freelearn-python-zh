- en: '4'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '4'
- en: Writing and Building a ROS 2 Node
  id: totrans-1
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 编写和构建 ROS 2 节点
- en: To write your own custom code with ROS 2, you will have to create ROS 2 programs,
    or in other words, nodes. You already discovered the concept of nodes in [*Chapter
    3*](B22403_03.xhtml#_idTextAnchor092). In this chapter, we will go deeper, and
    you will write your first node with Python and C++.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 要使用 ROS 2 编写自己的自定义代码，你必须创建 ROS 2 程序，换句话说，就是节点。你已经在 [*第 3 章*](B22403_03.xhtml#_idTextAnchor092)
    中发现了节点的概念。在本章中，我们将更深入地探讨，你将使用 Python 和 C++ 编写你的第一个节点。
- en: 'Before you create a node, there is a bit of setup to do: you need to create
    a ROS 2 workspace, in which you will build your application. In this workspace,
    you will then add packages to better organize your nodes. Then, in those packages,
    you can start to write your nodes. After you write a node, you will build it and
    run it.'
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 在你创建节点之前，有一些设置要做：你需要创建一个 ROS 2 工作空间，你将在其中构建你的应用程序。在这个工作空间中，你将添加软件包以更好地组织你的节点。然后，在这些软件包中，你可以开始编写你的节点。在你编写一个节点之后，你将构建它并运行它。
- en: We will do this complete process together, with hands-on code and command lines
    all along the way. This is the process that you will repeat for any new node you
    create when developing a ROS 2 application.
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将一起完成这个完整的过程，一路上都有动手代码和命令行。这是你在开发 ROS 2 应用程序时创建任何新节点时需要重复的过程。
- en: By the end of this chapter, you will be able to create your own packages and
    ROS 2 nodes with Python and C++. You will also be able to run and introspect your
    nodes from the terminal. This is the stepping stone you need in order to learn
    any other ROS 2 functionality. There is no topic, service, action, parameter,
    or launch file without nodes.
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 到本章结束时，你将能够使用 Python 和 C++ 创建自己的软件包和 ROS 2 节点。你还将能够从终端运行和检查你的节点。这是学习任何其他 ROS
    2 功能性所需的基础。没有节点，就没有主题、服务、动作、参数或启动文件。
- en: All explanations will start with Python, followed by C++, which we’ll cover
    more quickly. If you only want to learn with Python, you can skip the C++ sections.
    However, if you want to learn with C++, reading the previous Python explanations
    is mandatory for comprehension.
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: 所有解释都将从 Python 开始，然后是 C++，我们将快速介绍。如果你只想用 Python 学习，你可以跳过 C++ 部分。然而，如果你想用 C++
    学习，阅读之前的 Python 解释对于理解是强制性的。
- en: All the code examples for this chapter can be found in the **ch4** folder of
    the book’s GitHub repository ([https://github.com/PacktPublishing/ROS-2-from-Scratch](https://github.com/PacktPublishing/ROS-2-from-Scratch)).
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: 本章的所有代码示例都可以在本书 GitHub 仓库的 **ch4** 文件夹中找到（[https://github.com/PacktPublishing/ROS-2-from-Scratch](https://github.com/PacktPublishing/ROS-2-from-Scratch)）。
- en: 'In this chapter, we will cover the following topics:'
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将涵盖以下主题：
- en: Creating and setting up a ROS 2 workspace
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 创建和设置 ROS 2 工作空间
- en: Creating a package
  id: totrans-10
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 创建一个软件包
- en: Creating a Python node
  id: totrans-11
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 创建一个 Python 节点
- en: Creating a C++ node
  id: totrans-12
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 创建一个 C++ 节点
- en: Node template for Python and C++ nodes
  id: totrans-13
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Python 和 C++ 节点的节点模板
- en: Introspecting your nodes
  id: totrans-14
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 检查你的节点
- en: Technical requirements
  id: totrans-15
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 技术要求
- en: 'To follow this chapter, you need the following:'
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 要跟随本章，你需要以下内容：
- en: Ubuntu 24.04 installed (dual boot or virtual machine)
  id: totrans-17
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 安装了 Ubuntu 24.04（双启动或虚拟机）
- en: ROS Jazzy
  id: totrans-18
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: ROS Jazzy
- en: A text editor or IDE (for example, VS Code with the ROS extension)
  id: totrans-19
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 文本编辑器或 IDE（例如，带有 ROS 扩展的 VS Code）
- en: These requirements will be valid for all chapters in *Part 2*.
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 这些要求将适用于 *第二部分* 中的所有章节。
- en: Creating and setting up a ROS 2 workspace
  id: totrans-21
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 创建和设置 ROS 2 工作空间
- en: Before we write any code, we need to do a bit of organization. Nodes will exist
    within packages, and all your packages will exist within a **ROS** **2 workspace**.
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们编写任何代码之前，我们需要做一些组织工作。节点将存在于软件包中，而你所有的软件包都将存在于一个 **ROS 2 工作空间** 中。
- en: What is a ROS 2 workspace? A **workspace** is nothing more than a folder organization
    in which you will create and build your packages. Your entire ROS 2 application
    will live within this workspace.
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 什么是 ROS 2 工作空间？**工作空间** 仅仅是一个文件夹组织，你将在其中创建和构建你的软件包。你的整个 ROS 2 应用程序都将生活在这个工作空间中。
- en: To create one, you have to follow certain rules. Let’s create your first workspace
    step by step and correctly set it up.
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 要创建一个工作空间，你必须遵循某些规则。让我们一步一步地创建你的第一个工作空间，并正确地设置它。
- en: Creating a workspace
  id: totrans-25
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 创建工作空间
- en: To create a workspace, you will simply create a new directory inside your home
    directory.
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 要创建一个工作空间，你只需在你的家目录中创建一个新的目录。
- en: 'As for the workspace’s name, let’s keep it simple for now and use something
    that is recognizable: **ros2_ws**.'
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 关于工作空间的名称，让我们现在保持简单，使用一个易于识别的名称：**ros2_ws**。
- en: Note
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: The name of the workspace is not important, and it will not affect anything
    in your application. As we are just getting started, we only have one workspace.
    When you make progress and start to work on several applications, the best practice
    is to name each workspace with the name of the application or robot. For example,
    if you create a workspace for a robot named `ABC V3`, then you can name it `abc_v3_ws`.
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 工作空间的名称并不重要，它不会影响你的应用程序中的任何内容。因为我们刚开始，我们只有一个工作空间。当你取得进展并开始处理多个应用程序时，最佳实践是为每个工作空间命名应用程序或机器人的名称。例如，如果你为名为`ABC
    V3`的机器人创建一个工作空间，那么你可以将其命名为`abc_v3_ws`。
- en: 'Open a terminal, navigate to your home directory, and create the workspace:'
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 打开一个终端，导航到你的家目录，并创建工作空间：
- en: '[PRE0]'
  id: totrans-31
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'Then, enter the workspace and create a new directory named **src**. This is
    where you will write all the code for your ROS 2 application:'
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，进入工作空间并创建一个名为**src**的新目录。这就是你将编写所有ROS 2应用程序代码的地方：
- en: '[PRE1]'
  id: totrans-33
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: That’s really all there is to it. To set up a new workspace, you just create
    a new directory (somewhere in your home directory) and create an **src** directory
    inside it.
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 这就是全部内容。要设置新的工作空间，你只需创建一个新的目录（在你的家目录中的任何位置），并在其中创建一个**src**目录。
- en: Building the workspace
  id: totrans-35
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 构建工作空间
- en: 'Even if the workspace is empty (we have not created any packages yet), we can
    still build it. To do that, follow these steps:'
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 即使工作空间为空（我们还没有创建任何包），我们仍然可以构建它。为此，请按照以下步骤操作：
- en: Navigate to the workspace root directory. Make sure you are in the right place.
  id: totrans-37
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 导航到工作空间根目录。确保你处于正确的位置。
- en: Run the `colcon build` command. `colcon` is the build system in ROS 2, and it
    was installed when you installed the `ros-dev-tools` packages in [*Chapter 2*](B22403_02.xhtml#_idTextAnchor048).
  id: totrans-38
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 运行`colcon build`命令。`colcon`是ROS 2的构建系统，在你安装`ros-dev-tools`包时已安装（见[*第2章*](B22403_02.xhtml#_idTextAnchor048)）。
- en: 'Let’s build the workspace:'
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们构建工作空间：
- en: '[PRE2]'
  id: totrans-40
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'As you can see, no packages were built, but let’s list all directories under
    **~/ros2_ws**:'
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 如你所见，没有构建任何包，但让我们列出**~/ros2_ws**下的所有目录：
- en: '[PRE3]'
  id: totrans-42
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'As you can see, we have three new directories: **build**, **install**, and
    **log**. The **build** directory will contain the intermediate files required
    for the overall build. In **log**, you will find logs for each build. The most
    important directory for you is **install**, which is where all your nodes will
    be installed after you build the workspace.'
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 如你所见，我们有了三个新的目录：**build**、**install**和**log**。**build**目录将包含整体构建所需的中间文件。在**log**中，你会找到每个构建的日志。对你来说最重要的目录是**install**，这是你在构建工作空间后所有节点将被安装的地方。
- en: Note
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: You should always run `colcon build` from the root of your workspace directory,
    not from anywhere else. If you make a mistake and run this command from another
    directory (let’s say, from the `src` directory of the workspace, or inside a package),
    simply remove the new `install`, `build`, and `log` directories that were created
    in the wrong place. Then go back to the workspace root directory and build again.
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 你应该始终从工作空间目录的根目录运行`colcon build`，而不是从其他任何地方。如果你犯了一个错误，并从另一个目录（比如说，从工作空间的`src`目录，或者在一个包内部）运行此命令，只需简单地删除在错误位置创建的新`install`、`build`和`log`目录。然后回到工作空间根目录并重新构建。
- en: Sourcing the workspace
  id: totrans-46
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 源代码工作空间
- en: 'If you navigate inside the newly created **install** directory, you can see
    a **setup.bash** file:'
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你导航到新创建的**install**目录内部，你可以看到一个**setup.bash**文件：
- en: '[PRE4]'
  id: totrans-48
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: This might look familiar. If you remember, after we installed ROS 2, we sourced
    a similar bash script from the ROS 2 installation directory (**/opt/ros/jazzy/setup.bash**)
    so that we could use ROS 2 in our environment. We will need to do the same for
    our workspace.
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 这可能看起来很熟悉。如果你记得，在我们安装ROS 2之后，我们从ROS 2安装目录（**/opt/ros/jazzy/setup.bash**）源代码了一个类似的bash脚本，以便我们可以在环境中使用ROS
    2。我们还需要为我们的工作空间做同样的事情。
- en: Every time you build your workspace, you have to source it so that the environment
    (the session you are in) knows about the new changes in the workspace.
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 每次你构建工作空间时，都必须源代码它，以便环境（你所在的会话）了解工作空间中的新更改。
- en: 'To source the workspace, source this **setup.bash** script:'
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 要源代码工作空间，源代码这个**setup.bash**脚本：
- en: '[PRE5]'
  id: totrans-52
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: Then, as we previously did, we are going to add that line into our **.bashrc**.
    This way, you don’t need to source the workspace every time you open a new terminal.
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，就像我们之前做的那样，我们将把这一行添加到我们的**.bashrc**中。这样，你就不需要在每次打开新终端时都源代码工作空间。
- en: 'Open your **.bashrc** (located in your home directory the path is **~/.bashrc**)
    using any text editor you want:'
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 使用你想要的任何文本编辑器打开你的**.bashrc**（位于你的家目录中，路径为**~/.bashrc**）：
- en: '[PRE6]'
  id: totrans-55
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'Add the line to source the workspace’s **setup.bash** script, just after the
    one to source the global ROS 2 installation. The order is very important here.
    You have to source the global ROS 2 installation first, and then your workspace,
    not the other way around:'
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 在全局ROS 2安装的源代码行之后添加一行，用于源代码工作空间的**setup.bash**脚本。这里的顺序非常重要。您必须首先源代码全局ROS 2安装，然后是您的
    workspace，而不是反过来：
- en: '[PRE7]'
  id: totrans-57
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: Make sure to save**.bashrc**. Now, both ROS 2 and your workspace will be sourced
    in any new terminal you open.
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 确保保存**.bashrc**。现在，无论是 ROS 2 还是您的工作空间，在您打开任何新的终端时都会被源代码。
- en: Note
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: If you build the workspace in an already sourced environment, you will still
    need to source the workspace once again as there have been some changes, and the
    environment is not aware of that. In this case, you can either source the workspace’s
    `setup.bash` script directly, source the `.bashrc`, or open a new terminal.
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您在一个已经源代码的环境中构建工作空间，您仍然需要再次源代码工作空间，因为有一些变化，环境并不知情。在这种情况下，您可以直接源代码工作空间的 `setup.bash`
    脚本，源代码 `.bashrc`，或者打开一个新的终端。
- en: 'Your workspace is now correctly set up, and you can build your application.
    Next step: creating a package.'
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 您的工作空间现在已正确设置，您可以构建您的应用程序。下一步：创建一个包。
- en: Creating a package
  id: totrans-62
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 创建一个包
- en: Any node you create will exist within a package. Hence, to create a node, you
    first have to create a package (inside your workspace). You will now learn how
    to create your own packages, and we will see the differences between Python and
    C++ packages.
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 您创建的任何节点都将存在于一个包中。因此，要创建一个节点，您首先必须创建一个包（在您的 workspace 中）。您现在将学习如何创建自己的包，我们将看到Python包和C++包之间的区别。
- en: But first, what exactly is a package?
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 但首先，包究竟是什么？
- en: What is a ROS 2 package?
  id: totrans-65
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: ROS 2包是什么？
- en: A ROS 2 package is a sub-part of your application.
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: ROS 2包是您应用程序的一个子部分。
- en: Let’s consider a robotic arm that we want to use to pick up and place objects.
    Before we create any node, we can try to split this application into several sub-parts,
    or packages.
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们考虑一个我们想要用来拾取和放置物体的机械臂。在我们创建任何节点之前，我们可以尝试将这个应用程序分成几个子部分，或者包。
- en: We could have one package to handle a camera, another package for the hardware
    control (motors), and yet another package to compute motion planning for the robot.
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以有一个包来处理相机，另一个包用于硬件控制（电机），还有一个包用于计算机器人的运动规划。
- en: "![Figure 4.1\uFEFF – Example of a package organization for a robot](img/B22403_04_1.jpg)"
  id: totrans-69
  prefs: []
  type: TYPE_IMG
  zh: '![图4.1 – 机器人包组织示例](img/B22403_04_1.jpg)'
- en: Figure 4.1 – Example of a package organization for a robot
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 图4.1 – 机器人包组织示例
- en: Each package is an independent unit, responsible for one sub-part of your application.
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 每个包都是一个独立的单元，负责您应用程序的一个子部分。
- en: Packages are very useful for organizing your nodes, and also to correctly handle
    dependencies, as we will see later in this book.
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 包对于组织您的节点非常有用，并且可以正确处理依赖项，正如我们将在本书后面看到的那样。
- en: Now, let’s create a package, and here you have to make a choice. If you want
    to create a node with Python, you will create a Python package, and if you want
    to create a node with C++, you will create a C++ package. The architecture for
    each package type is quite different.
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们创建一个包，在这里您必须做出选择。如果您想用Python创建节点，您将创建一个Python包，如果您想用C++创建节点，您将创建一个C++包。每种包类型的架构都相当不同。
- en: Creating a Python package
  id: totrans-74
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 创建一个Python包
- en: 'You will create all your packages in the **src** directory of your ROS 2 workspace.
    So, make sure to navigate to this directory before you do anything else:'
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 您将创建所有包在您的 ROS 2 工作空间的 **src** 目录中。因此，在您做其他任何事情之前，请确保导航到这个目录：
- en: '[PRE8]'
  id: totrans-76
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'Here is how to construct the command to create a package:'
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 这是构建包的命令构造方法：
- en: '`ros2 pkg create <pkg_name>`: This is the minimum you need to write.'
  id: totrans-78
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`ros2 pkg create <pkg_name>`: 这是您需要编写的最小内容。'
- en: You can specify a build type with `--build_type <build_type>`. For a Python
    package, we need to use `ament_python`.
  id: totrans-79
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 您可以使用`--build_type <build_type>`指定构建类型。对于Python包，我们需要使用`ament_python`。
- en: You can also specify some optional dependencies with `--dependencies <list_of_dependencies_separated_with_spaces>`.
    It’s always possible to add dependencies later in the package.
  id: totrans-80
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 您还可以使用`--dependencies <list_of_dependencies_separated_with_spaces>`指定一些可选依赖项。在包中添加依赖项总是可能的。
- en: 'Let’s create our first package named **my_py_pkg**. We will use this name as
    an example to work with the main ROS 2 concepts. Then, as we progress, we will
    use more meaningful names. In the **src** directory of your workspace, run the
    following:'
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们创建我们的第一个包，命名为**my_py_pkg**。我们将使用此名称作为示例来处理主要的ROS 2概念。然后，随着我们的进展，我们将使用更有意义的名称。在您工作区的**src**目录中运行以下命令：
- en: '[PRE9]'
  id: totrans-82
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'With this command, we say that we want to create a package named **my_py_pkg**,
    with the **ament_python** build type, and we specify one dependency: **rclpy**—this
    is the Python library for ROS 2 that you will use in every Python node.'
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 使用此命令，我们表示我们想要创建一个名为**my_py_pkg**的包，使用**ament_python**构建类型，并指定一个依赖项：**rclpy**——这是您将在每个Python节点中使用的ROS
    2的Python库。
- en: This will print quite a few logs, showing you what files have been created.
    You might also get a **[WARNING]** log about a missing license, but as we have
    no intention of publishing this package anywhere, we don’t need a license file
    now. You can ignore this warning.
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 这将打印出很多日志，显示已经创建了哪些文件。您也可能收到一条关于缺少许可证的**[警告]**日志，但由于我们没有任何意图将此包发布到任何地方，我们现在不需要许可证文件。您可以忽略此警告。
- en: 'You can then see that there is a new directory named **my_py_pkg**. Here is
    the architecture of your newly created Python package:'
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以看到，有一个名为**my_py_pkg**的新目录。这是您新创建的Python包的架构：
- en: '[PRE10]'
  id: totrans-86
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: Not all the files are important right now. We’ll see how to use those files
    to configure and install our nodes just a bit later.
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 目前并非所有文件都很重要。我们将在稍后看到如何使用这些文件来配置和安装我们的节点。
- en: 'Here is a quick overview of the most important files and directories:'
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 这里是关于最重要的文件和目录的快速概述：
- en: '`my_py_pkg`: As you can see, inside the package, there is another directory
    with the same name. This directory already contains an `__init__.py` file. This
    is where we will create our Python nodes.'
  id: totrans-89
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`my_py_pkg`：如您所见，在包内部，还有一个同名的目录。这个目录已经包含了一个`__init__.py`文件。这就是我们将创建我们的Python节点的地方。'
- en: '`package.xml`: Every ROS 2 package (Python or C++) must contain this file.
    We will use it to provide more information about the package as well as dependencies.'
  id: totrans-90
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`package.xml`：每个ROS 2包（Python或C++）都必须包含此文件。我们将使用它来提供有关包以及依赖项的更多信息。'
- en: '`setup.py`: This is where you will write the instructions to build and install
    your Python nodes.'
  id: totrans-91
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`setup.py`：这是您将编写构建和安装您的Python节点的说明的地方。'
- en: Creating a C++ package
  id: totrans-92
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 创建C++包
- en: We will work a lot with Python in this book, but for completeness, I will also
    include C++ code for all examples. They will either be explained in the book,
    or the code will be in the GitHub repository.
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 在这本书中，我们将大量使用Python，但为了完整性，我还会包括所有示例的C++代码。这些代码要么在书中解释，要么在GitHub仓库中提供。
- en: Creating a C++ package is very similar to creating a Python package; however,
    the architecture of the package will be quite different.
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 创建C++包与创建Python包非常相似；然而，包的架构将会有很大的不同。
- en: 'Make sure you navigate to the **src** directory of your workspace, and then
    create a new package. Let’s use a similar pattern as we did for Python and name
    the package **my_cpp_pkg**:'
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 确保您导航到您工作区的**src**目录，然后创建一个新的包。让我们使用与Python相同的模式，将包命名为**my_cpp_pkg**：
- en: '[PRE11]'
  id: totrans-96
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'We choose **ament_cmake** for the build type (meaning this will be a C++ package),
    and we specify one dependency: **rclcpp**—this is the C++ library for ROS 2, which
    we will use in every C++ node.'
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 我们选择**ament_cmake**作为构建类型（这意味着这将是一个C++包），并指定一个依赖项：**rclcpp**——这是ROS 2的C++库，我们将用于每个C++节点。
- en: Once again, you should see quite a few logs, with the newly created files, and
    maybe a warning about the license that you can ignore.
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 再次提醒，您应该会看到很多日志，包括新创建的文件，以及可能关于许可证的警告，但您可以忽略。
- en: 'The architecture of your new C++ package will look like this:'
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 您的新C++包的架构将如下所示：
- en: '[PRE12]'
  id: totrans-100
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'Here is a quick explanation of the role of each file or directory:'
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 这里是关于每个文件或目录角色的快速解释：
- en: '`CMakeLists.txt`: This will be used to provide instructions on how to compile
    your C++ nodes, create libraries, and so on.'
  id: totrans-102
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`CMakeLists.txt`：这将用于提供如何编译您的C++节点、创建库等的说明。'
- en: '`include` directory: In a C++ project, you may split your code into implementation
    files (`.cpp` extension) and header files (`.hpp` extension). If you split your
    C++ nodes into `.cpp` and `.hpp` files, you will put the header files inside the
    `include` directory.'
  id: totrans-103
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`include`目录：在C++项目中，您可以将代码分成实现文件（`.cpp`扩展名）和头文件（`.hpp`扩展名）。如果您将C++节点分成`.cpp`和`.hpp`文件，您将把头文件放在`include`目录中。'
- en: '`package.xml`: This file is required for any kind of ROS 2 package. It contains
    more information about the package, and dependencies on other packages.'
  id: totrans-104
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`package.xml`：此文件是任何类型的 ROS 2 包所必需的。它包含有关包的更多信息，以及其他包的依赖关系。'
- en: '`src` directory: This is where you will write your C++ nodes (`.``cpp` files).'
  id: totrans-105
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`src` 目录：这是你将编写你的 C++ 节点（`.cpp` 文件）的地方。'
- en: Building a package
  id: totrans-106
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 构建包
- en: Now that you’ve created one or more packages, you can build them, even if you
    don’t have any nodes in the packages yet.
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 现在你已经创建了一个或多个包，你可以构建它们，即使包中还没有任何节点。
- en: To build the packages, go back to the root of your ROS 2 workspace and run **colcon
    build**. Once again, and as seen previously in this chapter, where you run this
    command is very important.
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 要构建包，回到你的 ROS 2 工作空间根目录并运行 **colcon build**。再次强调，就像在本章前面所看到的，运行此命令的位置非常重要。
- en: '[PRE13]'
  id: totrans-109
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: Both packages have been built. You will have to do that every time you add or
    modify a node inside a package.
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 两个包都已经构建完成。每次你在包内添加或修改节点时，你都必须这样做。
- en: 'The important thing to notice is this line: **Finished <<< <package_name> [time]**.
    This means that the package was correctly built. Even if you see additional warning
    logs, if you also see the **Finished** line, you know the package has been built.'
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 重要的是要注意这一行：**Finished <<< <package_name> [time]**。这意味着包已正确构建。即使你看到额外的警告日志，如果你也看到了
    **Finished** 行，你就知道包已经构建。
- en: Note
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: 'After you build any package, you also have to source your workspace so that
    the environment is aware of the new changes. You can do any of the following:'
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 在构建任何包之后，你还需要源你的工作空间，以便环境能够意识到新的更改。你可以执行以下任何一项操作：
- en: '- Open a new terminal as everything is configured in the `.``bashrc` file'
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: '- 打开一个新的终端，因为所有配置都在 `.bashrc` 文件中'
- en: '- Source the `setup.bash` script directly (`source ~/ros2_ws/install/setup.bash`)'
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: '- 直接源 `setup.bash` 脚本（`source ~/ros2_ws/install/setup.bash`）'
- en: '- Source the `.bashrc` manually (`source ~/.bashrc`)'
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: '- 手动源 `.bashrc` 文件 (`source ~/.bashrc`)'
- en: 'To build only a specific package, you can use the **--packages-select** option,
    followed by the name of the package. Here’s an example:'
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 要仅构建特定的包，可以使用 **--packages-select** 选项，后跟包的名称。以下是一个示例：
- en: '[PRE14]'
  id: totrans-118
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: This way, you don’t need to build your entire application every time and can
    just focus on one package.
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 这样，你不需要每次都构建整个应用程序，只需专注于一个包即可。
- en: Now that we have created some packages and we know how to build them, we can
    create nodes in the packages. But how are we going to organize them?
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经创建了一些包，并且我们知道如何构建它们，我们可以在包中创建节点。但我们如何组织它们呢？
- en: How are nodes organized in a package?
  id: totrans-121
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 包中的节点是如何组织的？
- en: To develop a ROS 2 application, you will write code inside nodes. As seen in
    [*Chapter 3*](B22403_03.xhtml#_idTextAnchor092), *node* is simply the name of
    a ROS 2 program.
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 要开发 ROS 2 应用程序，你将在节点内部编写代码。如[第 3 章](B22403_03.xhtml#_idTextAnchor092)中所示，*节点*只是
    ROS 2 程序的名称。
- en: A node is a subprogram of your application, responsible for one thing. If you
    have two different functionalities to implement, then you will have two nodes.
    Nodes communicate with each other using ROS 2 communications (topics, services,
    and actions).
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 节点是应用程序的子程序，负责一件事情。如果你有两个不同的功能需要实现，那么你将有两个节点。节点通过 ROS 2 通信（主题、服务和动作）相互通信。
- en: You will organize your nodes inside packages. For one package (sub-part of your
    application), you can have several nodes (functionalities). To fully understand
    how to organize packages and nodes, you need practice and experience. For now,
    let’s just get an idea with an example.
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 你将在包内部组织你的节点。对于某个包（应用程序的子部分），你可以有多个节点（功能）。要完全理解如何组织包和节点，你需要实践和经验。现在，让我们用一个例子来获得一个概念。
- en: 'Let’s come back to the package architecture we had in *Figure 4**.1*, and add
    nodes inside the packages:'
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们回到我们在 *图 4**.1* 中看到的包架构，并在包内添加节点：
- en: "![Figure 4.2\uFEFF – Example of a package organization with nodes](img/B22403_04_2.jpg)"
  id: totrans-126
  prefs: []
  type: TYPE_IMG
  zh: '![图 4.2 – 包组织节点的示例](img/B22403_04_2.jpg)'
- en: Figure 4.2 – Example of a package organization with nodes
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 图 4.2 – 包组织节点的示例
- en: As you can see, in the camera package, we could have one node responsible for
    handling the camera hardware. This node would send images to an image processing
    node, and this latter would extract the coordinates of objects for the robot to
    pick up.
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 如你所见，在相机包中，我们可以有一个节点负责处理相机硬件。这个节点会将图像发送到图像处理节点，而这个后者会提取机器人拾取物体的坐标。
- en: In the meantime, a motion planning node (in the motion planning package) would
    compute the movements that the robot should perform, given a specific command.
    A path correction node can support this motion planning using the data received
    from the image processing node.
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 同时，一个运动规划节点（在运动规划包中）将根据特定的命令计算机器人应执行的运动。路径校正节点可以使用从图像处理节点接收到的数据来支持这种运动规划。
- en: Finally, to make the robot move, a hardware driver node would be responsible
    for hardware communication (motors, encoders) and receive commands from the motion
    planning node. An additional state publisher node could be here to publish additional
    data about the robot for other nodes to use.
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，为了使机器人移动，一个硬件驱动节点将负责硬件通信（电机、编码器）并从运动规划节点接收命令。还可以有一个额外的状态发布节点，用于向其他节点发布有关机器人的额外数据。
- en: This node organization is purely fictitious and is here just to give you a general
    idea of how a ROS 2 application can be designed, and which roles a node can have
    in this application.
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 这种节点组织纯粹是虚构的，这里只是为了给你一个ROS 2应用程序如何设计的总体概念，以及节点在这个应用程序中可以扮演哪些角色。
- en: Now, you are (finally) going to write your first ROS 2 node. ROS 2 requires
    quite a lot of installation and configuration before you can actually write some
    code, but good news, we have completed all of this and can now focus on the code.
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，你终于要编写你的第一个ROS 2节点了。ROS 2在你可以实际编写代码之前需要相当多的安装和配置，但好消息是，我们已经完成了所有这些，现在我们可以专注于代码了。
- en: We won’t do anything too complicated for now; we won’t dive into complex features
    or communications. We will write a basic node that you can use as a template to
    start any future node. We will also build the node and see how to run it.
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 目前我们不会做任何太复杂的事情；我们不会深入复杂的特性或通信。我们将编写一个基本的节点，你可以将其作为模板来开始任何未来的节点。我们还将构建这个节点，看看如何运行它。
- en: Creating a Python node
  id: totrans-134
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 创建一个Python节点
- en: Let’s create our first Python node, or in other words, our first ROS 2 Python
    program.
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们创建我们的第一个Python节点，或者换句话说，我们的第一个ROS 2 Python程序。
- en: The processes of creating Python and C++ nodes are very different. That’s why
    I have written a separate section for each of them. We will start with Python,
    with complete step-by-step explanations. Then we will see how to do the same with
    C++. If you want to follow the C++ node section, make sure to read this one first.
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 创建Python和C++节点的过程非常不同。这就是为什么我为每个都写了单独的部分。我们将从Python开始，提供完整的逐步说明。然后我们将看到如何用C++做同样的事情。如果你想跟随C++节点部分，请确保先阅读这一部分。
- en: 'To create a node, you will have to do the following:'
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 要创建一个节点，你必须做以下事情：
- en: Create a file for the node.
  id: totrans-138
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 为节点创建一个文件。
- en: Write the node. We will use **Object Oriented Programming** (**OOP**), as officially
    recommended for ROS 2 (and almost every existing ROS 2 code you find uses OOP).
  id: totrans-139
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 编写节点。我们将使用**面向对象编程**（**OOP**），这是ROS 2官方推荐的（并且你几乎可以找到的每个现有的ROS 2代码都使用OOP）。
- en: Build the package in which the node exists.
  id: totrans-140
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 构建节点存在的包。
- en: Run the node to test it.
  id: totrans-141
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 运行节点以测试它。
- en: Let’s get started with our first Python node.
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们开始我们的第一个Python节点。
- en: Creating a file for the node
  id: totrans-143
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 为节点创建一个文件
- en: To write a node, we first need to create a file. Where should we create this
    file?
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 要编写节点，我们首先需要创建一个文件。我们应该在哪里创建这个文件？
- en: If you remember, when we created the **my_py_pkg** package, another **my_py_pkg**
    directory was created inside the package. This is where we will write the node.
    For every Python package, you have to go to the directory which has the same name
    as the package. If your package name is **abc**, then you’ll go to **~/ros2_ws/src/abc/abc/**.
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你记得，当我们创建**my_py_pkg**包时，在包内部创建了一个名为**my_py_pkg**的目录。这就是我们将编写节点的地方。对于每个Python包，你必须进入与包同名目录。如果你的包名是**abc**，那么你将进入**~/ros2_ws/src/abc/abc/**。
- en: 'Create a new file in this directory and make it executable:'
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个目录中创建一个新文件并使其可执行：
- en: '[PRE15]'
  id: totrans-147
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: After this, open this file to write in it. You can use any text editor or IDE
    you want here, as long as you don’t get lost in all the files.
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，打开这个文件进行编写。你可以使用任何你想要的文本编辑器或IDE，只要你不迷失在所有文件中。
- en: If you have no idea what to use, I suggest using VS Code with the ROS extension
    (as explained in [*Chapter 2*](B22403_02.xhtml#_idTextAnchor048)). This is the
    tool I’m using for all ROS development.
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你不知道该使用什么，我建议使用带有ROS扩展的VS Code（如[*第2章*](B22403_02.xhtml#_idTextAnchor048)中所述）。这是我用于所有ROS开发的工具。
- en: Note
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: 'If you are using VS Code, the best way to open it is to first navigate to the
    `src` directory of your workspace in a terminal, and then open it. This way, you
    have access to all the packages in your workspace, and it will make things easier
    with recognized dependencies and auto-completion:'
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你使用VS Code，最佳方式是首先在终端中导航到你的工作区`src`目录，然后打开它。这样，你可以访问工作区中的所有包，并且这将使处理已识别的依赖项和自动完成变得更容易：
- en: '`$` `cd ~/ros2_ws/src/`'
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: '`$` `cd ~/ros2_ws/src/`'
- en: '`$` `code .`'
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: '`$` `code .`'
- en: Writing a minimal ROS 2 Python node
  id: totrans-154
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 编写一个最小的ROS 2 Python节点
- en: 'Here is the starting code for any Python node you will create. You can write
    this code into the **my_first_node.py** file:'
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 这是任何你将创建的Python节点的起始代码。你可以将此代码写入**my_first_node.py**文件：
- en: '[PRE16]'
  id: totrans-156
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: As you can see, we use OOP here. OOP is everywhere in ROS 2, and this is the
    default (and recommended) way to write a node.
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 如你所见，我们在这里使用了面向对象编程（OOP）。在ROS 2中，OOP无处不在，这是默认（也是推荐）的编写节点的方式。
- en: 'Let’s come back to this code step by step, to understand what it’s doing:'
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们一步一步地回到这段代码，来理解它在做什么：
- en: '[PRE17]'
  id: totrans-159
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: We first import **rclpy**, the Python library for ROS 2\. Inside this library,
    we can get the **Node** class.
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 我们首先导入**rclpy**，这是ROS 2的Python库。在这个库中，我们可以获取**Node**类。
- en: 'We then create a new class that inherits from the **rclpy** **Node** class:'
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 我们接着创建一个新的类，它继承自**rclpy**的**Node**类：
- en: '[PRE18]'
  id: totrans-162
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: In this class, make sure you call the parent constructor with **super()**. This
    is also where you will specify the node name.
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个类中，确保你使用**super()**调用父构造函数。这也是你指定节点名称的地方。
- en: 'This node is not doing anything for now; we will add a few functionalities
    in a minute. Let''s finish the code:'
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 这个节点目前什么都没做；我们将在一分钟内添加一些功能。让我们完成代码：
- en: '[PRE19]'
  id: totrans-165
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'After the class, we create a **main()** function in which we perform the following
    actions:'
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 在类之后，我们在其中创建一个**main()**函数，执行以下操作：
- en: Initialize ROS 2 communications with `rclpy.init()`. This should be the first
    line in your `main()`function.
  id: totrans-167
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用`rclpy.init()`初始化ROS 2通信。这应该是你`main()`函数中的第一行。
- en: Create an object from the `MyCustomNode` class we wrote before. This will initialize
    the node. There’s no need to destroy the node later, as this will happen automatically
    when the program exits.
  id: totrans-168
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 从我们之前写的`MyCustomNode`类创建一个对象。这将初始化节点。不需要在之后销毁节点，因为当程序退出时，这会自动发生。
- en: Make the node spin. If you omit this line, the node will be created, then the
    program will exit, and the node will be destroyed. Making the node spin means
    that we block the execution here, the program stays alive, and thus the node stays
    alive. In the meantime, as we will see shortly, all registered callbacks for the
    node can be processed. When you press *Ctrl* + *C*, the node will stop spinning
    and this function will return.
  id: totrans-169
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 让节点旋转。如果你省略这一行，节点将被创建，然后程序将退出，节点将被销毁。让节点旋转意味着我们在这里阻塞执行，程序保持活跃，因此节点也保持活跃。在此期间，正如我们很快将看到的，所有注册的节点回调都可以被处理。当你按下*Ctrl*
    + *C*时，节点将停止旋转，这个函数将返回。
- en: After the node is killed, shut down ROS 2 communications with `rclpy.shutdown()`.
    This will be the last line of your `main()`function.
  id: totrans-170
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在节点被杀死后，使用`rclpy.shutdown()`关闭ROS 2通信。这将是你`main()`函数中的最后一行。
- en: This is how all your ROS 2 programs will work. As you can see, the node is in
    fact an object that we create within the program (the node is not the program
    in itself, but still, it is quite common to refer to the word “node” when we talk
    about the program). After being created, the node can stay alive and play its
    part while it is spinning. We will come back to this *spinning* shortly.
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 这就是所有你的ROS 2程序的工作方式。如你所见，节点实际上是我们程序中创建的一个对象（节点本身不是程序，但当我们谈论程序时，仍然非常常见地提到“节点”这个词）。创建后，节点可以在旋转时保持活跃并发挥其作用。我们很快会回到这个*旋转*的概念。
- en: 'Finally, we also have added these two lines:'
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们还添加了这两行：
- en: '[PRE20]'
  id: totrans-173
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: This is a pure Python thing and has nothing to do with ROS 2\. It just means
    that if you run the Python script directly, the **main()** function will be called,
    so you can try your program without having to install it with **colcon**.
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一个纯Python的东西，与ROS 2无关。它只是意味着如果你直接运行Python脚本，**main()**函数将被调用，因此你可以尝试你的程序而无需使用**colcon**安装它。
- en: 'Great, you have written your first minimal Python node. Before you build and
    run it, add one more line in the Node’s constructor, so it can do something:'
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 太好了，你已经编写了你的第一个最小Python节点。在你构建和运行它之前，在节点的构造函数中添加一行，这样它就可以做些事情：
- en: '[PRE21]'
  id: totrans-176
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: This line will print **Hello World** when the node starts.
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 这行代码将在节点启动时打印**Hello World**。
- en: 'As the **MyCustomNode** class inherits from the **Node** class, we get access
    to all the ROS 2 functionalities for nodes. This will make things quite convenient
    for us. Here, you have an example with the logging functionality: we get the **get_logger()**
    method from **Node**. Then, with the **info()**method, we can print a log with
    the info level.'
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: 由于 **MyCustomNode** 类继承自 **Node** 类，我们可以访问所有 ROS 2 的节点功能。这将使我们的事情变得相当方便。这里有一个使用日志功能的例子：我们从
    **Node** 中获取 **get_logger()** 方法。然后，使用 **info()** 方法，我们可以打印一个信息级别的日志。
- en: Building the node
  id: totrans-179
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 构建节点
- en: You are now going to build the node so that you can run it.
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: 你现在将要构建节点以便运行它。
- en: 'You might think: why do we need to build a Python node? Python is an interpreted
    language; couldn’t we just run the file itself?'
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: 你可能会想：为什么我们需要构建一个 Python 节点？Python 是一种解释型语言；我们难道不能直接运行文件本身吗？
- en: 'Yes, this is true: you could test the code just by running it in the terminal
    **($ python3 my_first_node.py**). However, what we want to do is actually install
    the file in our workspace, so we can start the node with **ros2 run**, and later
    on, from a launch file.'
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: 是的，这是真的：你只需在终端中运行代码即可测试它 **($ python3 my_first_node.py**)。然而，我们真正想要做的是在我们的工作区中安装文件，这样我们就可以使用
    **ros2 run** 启动节点，稍后还可以从启动文件中启动。
- en: We usually use the word “build”, because to install a Python node, we have to
    run **colcon build**.
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: 我们通常使用“构建”这个词，因为要安装 Python 节点，我们必须运行 **colcon build**。
- en: 'To build (install) the node, we need to do one more thing in the package. Open
    the **setup.py** file from the **my_py_pkg** package. Locate **entry_points**
    and **''console_scripts''** at the end of the file. For each node we want to build,
    we have to add one line inside the **''****console_scripts''** array:'
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: 要构建（安装）节点，我们需要在软件包中做一件事。打开 **my_py_pkg** 软件包中的 **setup.py** 文件。在文件末尾找到 **entry_points**
    和 **'console_scripts'**。对于我们要构建的每个节点，我们必须在 **'console_scripts'** 数组中添加一行：
- en: '[PRE22]'
  id: totrans-185
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'Here is the syntax:'
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: 这里是语法：
- en: '[PRE23]'
  id: totrans-187
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'There are a few important things to correctly write this line:'
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: 在正确编写这一行时有一些重要的事情需要注意：
- en: First, choose an executable name. This will be the name you use with `ros2 run
    <``pkg_name> <executable_name>`.
  id: totrans-189
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 首先，选择一个可执行文件名。这将是你使用 `ros2 run <pkg_name> <executable_name>` 时的名称。
- en: For the filename, skip the `.``py` extension.
  id: totrans-190
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 对于文件名，跳过 `.py` 扩展名。
- en: The function name is `main`, as we have created a `main()` function in the code.
  id: totrans-191
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 函数名是 `main`，因为我们已经在代码中创建了一个 `main()` 函数。
- en: If you want to add another executable for another node, don’t forget to add
    a comma between each executable and place one executable per line.
  id: totrans-192
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果你想要为另一个节点添加另一个可执行文件，别忘了在每个可执行文件之间添加逗号，并且每个可执行文件占一行。
- en: Note
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: 'When learning ROS 2, there is a common confusion between the node name, filename,
    and executable name:'
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: 在学习 ROS 2 时，节点名、文件名和可执行文件名之间有一个常见的混淆：
- en: '- Node name: defined inside the code, in the constructor. This is what you’ll
    see with the `ros2` `node list`, or in `rqt_graph`.'
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: '- 节点名：在代码中的构造函数内定义。这就是你在 `ros2 node list` 或 `rqt_graph` 中看到的内容。'
- en: '- Filename: the file where you write the code.'
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: '- 文件名：你编写代码的文件。'
- en: '- Executable name: defined in `setup.py` and used with `ros2 run`.'
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: '- 可执行文件名：在 `setup.py` 中定义并用于 `ros2 run`。'
- en: In this first example, I made sure to use a different name for each so you can
    be aware that these are three different things. But sometimes all three names
    could be the same. For example, you could create a `temperature_sensor.py` file,
    then name your node and your executable `temperature_sensor`.
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个第一个例子中，我确保为每个使用了不同的名称，这样你可以意识到这些都是三件不同的事情。但有时这三个名称可以是相同的。例如，你可以创建一个 `temperature_sensor.py`
    文件，然后给你的节点和可执行文件命名为 `temperature_sensor`。
- en: 'Now that you have given the instructions to create a new executable, go to
    your workspace root directory and build the package:'
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: 现在你已经给出了创建新可执行文件的指令，请前往你的工作区根目录并构建该软件包：
- en: '[PRE24]'
  id: totrans-200
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: You can also add **--packages-select my_py_pkg** to only build this package.
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: 你也可以添加 **--packages-select my_py_pkg** 以仅构建此软件包。
- en: The executable should now be created and installed in the workspace (it will
    be placed inside the **install** directory). We can say that your Python node
    has been built, or installed.
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: 可执行文件现在应该已创建并安装在工作区中（它将被放置在 **install** 目录中）。我们可以这样说，你的 Python 节点已经构建或安装了。
- en: Running the node
  id: totrans-203
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 运行节点
- en: 'Now you can run your first node, but just before that, make sure that the workspace
    is sourced in your environment:'
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: 现在你可以运行你的第一个节点了，但在运行之前，请确保工作区已在你的环境中源码：
- en: '[PRE25]'
  id: totrans-205
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: This file already contains the line to source the workspace; you could also
    just open a new terminal, or source the **setup.bash** script from the workspace.
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: 这个文件已经包含了源码工作空间的行；你也可以打开一个新的终端，或者从工作空间中源码**setup.bash**脚本。
- en: 'You can now run your node using **ros2 run** (if you have any doubts, go back
    to the experiments we did in [*Chapter 3*](B22403_03.xhtml#_idTextAnchor092)):'
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: 你现在可以使用**ros2 run**来运行你的节点（如果你有任何疑问，请回到我们在[*第3章*](B22403_03.xhtml#_idTextAnchor092)中做的实验）：
- en: '[PRE26]'
  id: totrans-208
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: Great, we see the log **Hello World**. Your first node is successfully running.
    Note that we wrote **test_node** in the **ros2 run** command, as it’s the executable
    name we chose in the **setup.py** file.
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
  zh: 太好了，我们看到日志**Hello World**。你的第一个节点已经成功运行。请注意，我们在**ros2 run**命令中写了**test_node**，因为这是我们选择在**setup.py**文件中的可执行文件名。
- en: Now, you might notice that the program is hanging there. The node is still alive
    because it is spinning. To stop the node, press *Ctrl* + *C*.
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，你可能会注意到程序在那里挂起了。节点仍然活着，因为它正在自旋。要停止节点，请按*Ctrl* + *C*。
- en: Improving the node – timer and callback
  id: totrans-211
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 改进节点——计时器和回调
- en: At this point, you might feel that writing, building, and running a node is
    a long and complicated process. It’s actually not that complex, and it gets easier
    with each new node that you create. On top of that, modifying an existing node
    is even easier. Let’s see that now.
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，你可能觉得编写、构建和运行一个节点是一个漫长且复杂的过程。实际上，它并不那么复杂，而且随着你创建的新节点的增加而变得更容易。此外，修改现有的节点甚至更容易。我们现在就看看。
- en: The node we ran is very basic. Let’s add one more functionality and do something
    more interesting.
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
  zh: 我们运行的这个节点非常基础。让我们再添加一个功能，做一些更有趣的事情。
- en: Our node is printing one piece of text when it’s started. We now want to make
    the node print a string every second, as long as it’s alive.
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的这个节点在启动时会打印一段文本。现在我们希望节点每秒打印一个字符串，只要它还活着。
- en: This behavior of “doing X action every Y seconds” is very common in robotics.
    For example, you could have a node that “reads a temperature every 2 seconds”,
    or that “gives a new motor command every 0.1 seconds”.
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
  zh: “每Y秒执行X动作”这种行为在机器人技术中非常常见。例如，你可以有一个节点“每2秒读取一次温度”，或者“每0.1秒发送一个新的电机命令”。
- en: How to do that? We will add a **timer** to our node. A timer will trigger a
    **callback** function at a specified rate.
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
  zh: 如何做到这一点？我们将在我们的节点中添加一个**计时器**。计时器将以指定的速率触发一个**回调**函数。
- en: 'Let’s go back to the code and modify the **MyCustomNode** class. The rest of
    the code stays the same:'
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们回到代码中，并修改**MyCustomNode**类。其余的代码保持不变：
- en: '[PRE27]'
  id: totrans-218
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: We still have the constructor with **super()**, but now the log is in a separate
    method. Also, instead of just printing **Hello World**, here we create a **counter_**
    attribute that we increment every time we use the log.
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
  zh: 我们仍然有带有**super()**的构造函数，但现在日志在单独的方法中。此外，我们不再只是打印**Hello World**，在这里我们创建了一个**counter_**属性，每次我们使用日志时都会增加它。
- en: Note
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: If you’re wondering why there is a trailing underscore `_` at the end of each
    class attribute, this is a common OOP convention that I follow to specify that
    a variable is a class attribute. It’s simply a visual help and has no other function.
    You can follow the same convention or use another one—just make sure to stay consistent
    within one project.
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你想知道为什么每个类属性末尾都有一个尾随下划线`_`，这是一个常见的面向对象编程约定，我遵循这个约定来指定一个变量是类属性。它仅仅是一个视觉上的帮助，没有其他功能。你可以遵循相同的约定或使用另一个约定——只要确保在一个项目中保持一致性。
- en: 'The most important line is the one to create the timer. To create the timer
    we use the **create_timer()** method from the **Node** class. We need to give
    two arguments: the rate at which we want to call the function (float number),
    and the callback function. Note that the callback function should be specified
    without any parenthesis.'
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
  zh: 最重要的一行是创建计时器的代码。为了创建计时器，我们使用**Node**类的**create_timer()**方法。我们需要提供两个参数：我们想要调用函数的速率（浮点数）和回调函数。请注意，回调函数应指定不带任何括号。
- en: This instruction means that we want to call the **print_hello** method every
    **1.0** second.
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
  zh: 这条指令意味着我们想要每**1.0**秒调用一次**print_hello**方法。
- en: Let’s now try the code. As we have already specified how to create an executable
    from this file in the **setup.py** file, we don’t need to do it again.
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们来尝试一下代码。因为我们已经在**setup.py**文件中指定了如何从这个文件创建可执行文件，所以我们不需要再次做这件事。
- en: 'All we have to do is to build, source, and run. Remember: “build, source, run.”
    Every time you create a new node, or modify an existing one, you have to “build,
    source, run.”'
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
  zh: 我们需要做的只是构建、源码和运行。记住：“构建、源码、运行。”每次你创建一个新的节点或修改现有的节点时，你都必须“构建、源码、运行。”
- en: 'In a terminal, go to the root directory of your ROS 2 workspace and build the
    package:'
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
  zh: 在终端中，转到你的 ROS 2 工作空间的根目录并构建包：
- en: '[PRE28]'
  id: totrans-227
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: Note
  id: totrans-228
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: On top of `--packages-select <pkg_name>`, you can add the `--symlink-install`
    option, so you won’t have to build the package every time you modify your Python
    nodes; for example, `$ colcon build --packages-select` `my_py_pkg --symlink-install`.
  id: totrans-229
  prefs: []
  type: TYPE_NORMAL
  zh: 在 `--packages-select <pkg_name>` 的基础上，你可以添加 `--symlink-install` 选项，这样你就不必每次修改
    Python 节点时都构建包；例如，`$ colcon build --packages-select my_py_pkg --symlink-install`。
- en: You might see some warning logs, but as long as you see the line starting with
    `Finished <<< my_py_pkg`, it worked correctly. This will install the executable,
    but then if you modify the code, you should be able to run it without building
    it again.
  id: totrans-230
  prefs: []
  type: TYPE_NORMAL
  zh: 你可能会看到一些警告日志，但只要看到以 `Finished <<< my_py_pkg` 开头的行，就说明它已经正确工作了。这将安装可执行文件，但如果修改了代码，你应该能够运行它而无需再次构建。
- en: 'Two important things: this only works for Python packages, and you still have
    to build the package for any new executable you create.'
  id: totrans-231
  prefs: []
  type: TYPE_NORMAL
  zh: 两个重要的事情：这仅适用于 Python 包，并且你仍然需要为任何新创建的可执行文件构建包。
- en: 'Then, from this terminal or another one, source and run the following:'
  id: totrans-232
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，从这个终端或另一个终端，执行以下操作：
- en: '[PRE29]'
  id: totrans-233
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: As you can see, the process of build, source, and run is quite fast and not
    that complicated. Here, we can see that the node prints a log every second, and
    the counter increments in each new log.
  id: totrans-234
  prefs: []
  type: TYPE_NORMAL
  zh: 如您所见，构建、源代码和运行的过程相当快，并不复杂。在这里，我们可以看到节点每秒打印一条日志，并且计数器在每条新日志中递增。
- en: Now, how is this possible? How is the **print_hello()** method called? We have
    created a timer, yes, but nowhere in the code have we actually called **print_hello()**
    directly.
  id: totrans-235
  prefs: []
  type: TYPE_NORMAL
  zh: 现在这是怎么做到的？**print_hello()** 方法是如何被调用的？我们确实创建了一个计时器，但是代码中并没有直接调用 **print_hello()**。
- en: It works because the node is spinning, thanks to **rclpy.spin(node)**. This
    means that the node is kept alive, and all registered callbacks can be called
    during this time. What we do with **create_timer()** is simply to register a callback,
    which can then be called when the node is spinning.
  id: totrans-236
  prefs: []
  type: TYPE_NORMAL
  zh: 它之所以能工作，是因为节点正在旋转，这要归功于 **rclpy.spin(node)**。这意味着节点被保持活跃状态，并且在此期间可以调用所有已注册的回调。我们使用
    **create_timer()** 做的事情仅仅是注册一个回调，这样当节点在旋转时就可以被调用。
- en: This was your first example of a callback, and as you will see in the following
    chapters of the book, everything runs with callbacks in ROS 2\. At this point,
    if you still have some trouble with the syntax, the callbacks, and the spinning,
    don’t worry too much. As you make progress with the book, you will repeat this
    process many times. When learning ROS 2, understanding comes with hands-on experience.
  id: totrans-237
  prefs: []
  type: TYPE_NORMAL
  zh: 这是你第一个回调示例，正如你将在本书的后续章节中看到的，在 ROS 2 中，一切操作都是通过回调来运行的。到目前为止，如果你在语法、回调和旋转方面还有一些困难，不要过于担心。随着你对本书的进步，你会多次重复这个过程。在学习
    ROS 2 时，理解伴随着动手实践。
- en: We are now done with this Python node. With what you’ve seen here, you should
    be able to create your own new Python nodes (in the same package or another package).
    Let’s now switch to C++. If you are only interested in learning ROS 2 with Python
    for now, you can skip the C++ section.
  id: totrans-238
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在已经完成了这个 Python 节点。根据你所看到的，你应该能够创建你自己的新 Python 节点（在同一个包或另一个包中）。现在让我们切换到 C++。如果你目前只对使用
    Python 学习 ROS 2 感兴趣，你可以跳过 C++ 部分。
- en: Creating a C++ node
  id: totrans-239
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 创建一个 C++ 节点
- en: 'We are going to do exactly the same thing we did for the Python node: create
    a file, write the node, build, source, and run.'
  id: totrans-240
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将要做的与为 Python 节点所做的是完全相同的：创建一个文件，编写节点，构建，源代码，然后运行。
- en: Make sure you have read the previous Python section as I will not repeat everything
    here. We will basically just see how to apply the process for a C++ node.
  id: totrans-241
  prefs: []
  type: TYPE_NORMAL
  zh: 确保你已经阅读了之前的 Python 部分，因为我不会在这里重复所有内容。我们基本上只是看看如何为一个 C++ 节点应用这个过程。
- en: To create a C++ node, we first need a C++ package. We will use the **my_cpp_pkg**
    package that we created previously.
  id: totrans-242
  prefs: []
  type: TYPE_NORMAL
  zh: 要创建一个 C++ 节点，我们首先需要一个 C++ 包。我们将使用之前创建的 **my_cpp_pkg** 包。
- en: Writing a C++ node
  id: totrans-243
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 编写 C++ 节点
- en: 'Let’s create a file for the node. Go to the **src** directory inside the **my_cpp_pkg**
    package and create a **.****cpp** file:'
  id: totrans-244
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们为节点创建一个文件。转到 **my_cpp_pkg** 包内的 **src** 目录并创建一个 **.cpp** 文件：
- en: '[PRE30]'
  id: totrans-245
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: You could also create the file directly from your IDE and not use the terminal.
  id: totrans-246
  prefs: []
  type: TYPE_NORMAL
  zh: 你也可以直接从你的 IDE 创建文件，而不使用终端。
- en: 'Now, if you haven’t done this previously, open your workspace with VS Code
    or any other IDE:'
  id: totrans-247
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，如果你之前没有这样做，请使用 VS Code 或任何其他 IDE 打开你的工作空间：
- en: '[PRE31]'
  id: totrans-248
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: 'Open **my_first_node.cpp**. Here is the minimal code to write a C++ node:'
  id: totrans-249
  prefs: []
  type: TYPE_NORMAL
  zh: 打开 **my_first_node.cpp**。以下是编写 C++ 节点的最小代码：
- en: '[PRE32]'
  id: totrans-250
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: Note
  id: totrans-251
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: If you are using VS Code and you type this code, you might see an include error
    for the `rclcpp` library. Make sure to save the file and wait a few seconds. If
    the include is still not recognized, go to the **Extensions** tab and disable
    and re-enable the ROS extension.
  id: totrans-252
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你使用 VS Code 并输入此代码，你可能会看到 `rclcpp` 库的包含错误。请确保保存文件并等待几秒钟。如果包含仍然没有被识别，请转到 **扩展**
    选项卡，禁用并重新启用 ROS 扩展。
- en: As you can see (and this was similar with Python), in ROS 2 we heavily use OOP
    with C++ nodes.
  id: totrans-253
  prefs: []
  type: TYPE_NORMAL
  zh: 正如你所见（这与 Python 类似），在 ROS 2 中，我们大量使用 C++ 节点的面向对象编程。
- en: 'Let’s analyze this code step by step:'
  id: totrans-254
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们一步一步分析这段代码：
- en: '[PRE33]'
  id: totrans-255
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: 'We first include **rclcpp**, the C++ library for ROS 2\. This library contains
    the **rclcpp::Node** class:'
  id: totrans-256
  prefs: []
  type: TYPE_NORMAL
  zh: 我们首先包含 **rclcpp**，这是 ROS 2 的 C++ 库。这个库包含 **rclcpp::Node** 类：
- en: '[PRE34]'
  id: totrans-257
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: 'As we did for Python, we have created a class that inherits from the **Node**
    class. The syntax is different, but the principle is the same. From this **Node**
    class, we will be able to access all the ROS 2 functionalities: logger, timer,
    and so on. As you can see, we also specify the node name in the constructor. For
    now, the node does nothing; we will add more functionalities in a minute:'
  id: totrans-258
  prefs: []
  type: TYPE_NORMAL
  zh: 就像我们对 Python 所做的那样，我们创建了一个继承自 **Node** 类的类。语法不同，但原理相同。从这个 **Node** 类，我们将能够访问所有
    ROS 2 功能：记录器、计时器等。正如你所见，我们在构造函数中也指定了节点名称。目前，节点什么也不做；我们将在一分钟内添加更多功能：
- en: '[PRE35]'
  id: totrans-259
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: 'You need a **main()** function if you want to be able to run your C++ program.
    In this function, we do exactly the same thing as for Python, with just some differences
    in the syntax:'
  id: totrans-260
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你想要能够运行你的 C++ 程序，你需要一个 **main()** 函数。在这个函数中，我们与 Python 完全相同，只是在语法上有些差异：
- en: Initialize ROS 2 communications with `rclcpp::init()`.
  id: totrans-261
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用 `rclcpp::init()` 初始化 ROS 2 通信。
- en: Create a node object from your newly written class. As you can see, we don’t
    create an object directly, but a shared pointer to that object. In ROS 2 and C++,
    almost everything you create will be a smart pointer (shared, unique, and so on).
  id: totrans-262
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 从你新编写的类中创建一个节点对象。正如你所见，我们不是直接创建一个对象，而是创建对该对象的智能指针。在 ROS 2 和 C++ 中，你创建的几乎所有内容都将是一个智能指针（共享、唯一等）。
- en: We then make the node spin with `rclcpp::spin()`.
  id: totrans-263
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后我们使用 `rclcpp::spin()` 让节点运行。
- en: Finally, when the node is stopped (*Ctrl* + *C*), we shut down all ROS 2 communications
    with `rclcpp::shutdown()`.
  id: totrans-264
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后，当节点停止时（*Ctrl* + *C*），我们使用 `rclcpp::shutdown()` 关闭所有 ROS 2 通信。
- en: This structure for the **main()** function will be very similar for all your
    ROS 2 programs. As you can see, once again, the node is not the program in itself.
    The node is created inside the program.
  id: totrans-265
  prefs: []
  type: TYPE_NORMAL
  zh: 这个 **main()** 函数的结构将非常类似于你所有的 ROS 2 程序。正如你所见，再次强调，节点本身不是程序。节点是在程序内部创建的。
- en: Before we go further and build, source, and run our node, let’s improve it now
    with a timer, a callback, and a log.
  id: totrans-266
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们进一步构建、源代码和运行我们的节点之前，让我们现在通过计时器、回调和日志来改进它。
- en: 'Modify the **MyCustomNode** class, and leave the rest as it is:'
  id: totrans-267
  prefs: []
  type: TYPE_NORMAL
  zh: 修改 **MyCustomNode** 类，其余保持不变：
- en: '[PRE36]'
  id: totrans-268
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: This code example will do the same thing as for the Python node. We create a
    timer so that we can call a callback function every **1.0** second. In this callback
    function, we print **Hello** followed by a counter that we increment every time.
  id: totrans-269
  prefs: []
  type: TYPE_NORMAL
  zh: 这个代码示例将执行与 Python 节点相同的功能。我们创建一个计时器，以便每 **1.0** 秒调用一次回调函数。在这个回调函数中，我们打印 **Hello**
    后跟一个计数器，每次调用时都会增加。
- en: 'There are some specificities related to C++:'
  id: totrans-270
  prefs: []
  type: TYPE_NORMAL
  zh: 与 C++ 相关有一些特定性：
- en: 'For the timer, we have to create a class attribute. As you can see we also
    create a shared pointer here: `rclcpp::TimerBase::SharedPtr`.'
  id: totrans-271
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 对于计时器，我们必须创建一个类属性。正如你所见，我们在这里也创建了一个共享指针：`rclcpp::TimerBase::SharedPtr`。
- en: We use `this->create_wall_timer()` to create the timer. `this->` is not required
    here, but I have added it to emphasize that we are using the `create_wall_timer()`
    method from the `Node` class.
  id: totrans-272
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们使用 `this->create_wall_timer()` 创建计时器。`this->` 在这里不是必需的，但我添加它来强调我们正在使用 `Node`
    类的 `create_wall_timer()` 方法。
- en: To specify the callback in the timer, as we are in a C++ class, we have to use
    `std::bind(&ClassName::method_name, this)`. Make sure you don’t use any parenthesis
    for the method name.
  id: totrans-273
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 要在计时器中指定回调，由于我们处于 C++ 类中，我们必须使用 `std::bind(&ClassName::method_name, this)`。确保你不对方法名称使用任何括号。
- en: The node is now finished, so we can build it.
  id: totrans-274
  prefs: []
  type: TYPE_NORMAL
  zh: 节点现在已经完成，因此我们可以构建它。
- en: Building and running the node
  id: totrans-275
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 构建和运行节点
- en: 'We can’t just run the C++ file; we first have to compile it and create an executable.
    To do this, we will edit the **CMakeLists.txt** file. Open this file, and after
    a few lines, you will find something like this:'
  id: totrans-276
  prefs: []
  type: TYPE_NORMAL
  zh: 我们不能直接运行 C++ 文件；我们首先必须编译它并创建一个可执行文件。为此，我们将编辑 **CMakeLists.txt** 文件。打开此文件，在几行之后，你会找到类似以下的内容：
- en: '[PRE37]'
  id: totrans-277
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: The line to find **rclcpp** is here because we provided **--dependencies rclcpp**
    when we created the package with **ros2 pkg create**. Later on, if your nodes
    in this package require more dependencies, you can add the dependencies here,
    one per line.
  id: totrans-278
  prefs: []
  type: TYPE_NORMAL
  zh: 查找 **rclcpp** 的行在这里，因为我们创建包时使用了 **ros2 pkg create** 并提供了 **--dependencies rclcpp**。之后，如果这个包中的节点需要更多的依赖，你可以在这里添加依赖，每行一个。
- en: 'Just after this line, add an extra new line, and then the following instructions:'
  id: totrans-279
  prefs: []
  type: TYPE_NORMAL
  zh: 在此行之后，添加一个额外的空行，然后添加以下指令：
- en: '[PRE38]'
  id: totrans-280
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: 'To build a C++ node, we need to do three things:'
  id: totrans-281
  prefs: []
  type: TYPE_NORMAL
  zh: 要构建一个 C++ 节点，我们需要做三件事：
- en: Add a new executable with the `add_executable()`function. Here, you have to
    choose a name for the executable (the one that will be used with `ros2 run <pkg_name>
    <executable_name>`), and we also have to specify the relative path to the C++
    file.
  id: totrans-282
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用 `add_executable()` 函数添加一个新的可执行文件。在这里，你必须为可执行文件选择一个名称（将用于 `ros2 run <pkg_name>
    <executable_name>`），我们还需要指定 C++ 文件的相对路径。
- en: Link all dependencies for this executable with the `ament_target_dependencies()`function.
  id: totrans-283
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用 `ament_target_dependencies()` 函数链接此可执行文件的所有依赖。
- en: Install the executable with the `install()`instruction, so that we can find
    it when we use `ros2 run`. Here, we put the executable in a `lib/<package_name>`
    directory.
  id: totrans-284
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用 `install()` 指令安装可执行文件，这样我们就可以在运行 `ros2 run` 时找到它。在这里，我们将可执行文件放在 `lib/<package_name>`
    目录中。
- en: Then, for each new executable you create, you need to repeat *steps 1* and *2*
    and add the executable inside the **install()** instruction, one per line without
    any commas. There’s no need to create a new **install()** instruction for each
    executable.
  id: totrans-285
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，对于你创建的每个新的可执行文件，你需要重复 *步骤 1* 和 *步骤 2*，并在 **install()** 指令内添加可执行文件，每行一个，不要加逗号。不需要为每个可执行文件创建一个新的
    **install()** 指令。
- en: Note
  id: totrans-286
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: The end of your `CMakeLists.txt` will contain a block starting with `if(BUILD_TESTING)`,
    and then `ament_package()`. As we are not doing any build testing here, you can
    remove the entire `if` block. Just make sure to keep the `ament_package()` line,
    which should be the last line of the file.
  id: totrans-287
  prefs: []
  type: TYPE_NORMAL
  zh: 你的 `CMakeLists.txt` 文件的末尾将包含一个以 `if(BUILD_TESTING)` 开头的块，然后是 `ament_package()`。由于我们这里没有进行任何构建测试，你可以删除整个
    `if` 块。只需确保保留 `ament_package()` 行，这应该是文件的最后一行。
- en: 'You can now build the package with **colcon build**, which is going to create
    and install the executable:'
  id: totrans-288
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，你可以使用 **colcon build** 构建包，这将创建并安装可执行文件：
- en: '[PRE39]'
  id: totrans-289
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: 'If you get any error during the build process, make sure to fix your code first,
    and then build again. Then, you can source your environment, and run your executable:'
  id: totrans-290
  prefs: []
  type: TYPE_NORMAL
  zh: 如果在构建过程中遇到任何错误，请首先修复你的代码，然后再次构建。然后，你可以源环境，并运行你的可执行文件：
- en: '[PRE40]'
  id: totrans-291
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: As you can see, we run the **test_node** executable (built from **my_first_node.cpp**
    file), which is going to start the **my_node_name** node.
  id: totrans-292
  prefs: []
  type: TYPE_NORMAL
  zh: 如你所见，我们运行了 **test_node** 可执行文件（由 **my_first_node.cpp** 文件构建），这将启动 **my_node_name**
    节点。
- en: You have now successfully written a C++ node. For each new node that you create,
    you will have to create a new C++ file, write the node class, set the build instructions
    for a new executable in **CMakeLists.txt**, and build the package. Then, to start
    the node, source the environment and run the executable with **ros2 run**.
  id: totrans-293
  prefs: []
  type: TYPE_NORMAL
  zh: 你现在已经成功编写了一个 C++ 节点。对于你创建的每个新节点，你将必须创建一个新的 C++ 文件，编写节点类，在 **CMakeLists.txt**
    中为新可执行文件设置构建指令，并构建包。然后，要启动节点，源环境并使用 **ros2 run** 运行可执行文件。
- en: Node template for Python and C++ nodes
  id: totrans-294
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Python 和 C++ 节点的模板
- en: All the nodes we start in this book will follow the same structure. As additional
    help to get started quickly, I have created a node template you can use to write
    the base of any Python or C++ node. I use these templates myself when creating
    new nodes, as the code can be quite repetitive.
  id: totrans-295
  prefs: []
  type: TYPE_NORMAL
  zh: 本书开始的所有节点都将遵循相同的结构。为了快速入门提供额外的帮助，我创建了一个节点模板，你可以用它来编写任何 Python 或 C++ 节点的基类。我在创建新节点时也使用这些模板，因为代码可能相当重复。
- en: 'You can copy and paste the templates either from this book directly, or download
    them from the GitHub repository: [https://github.com/PacktPublishing/ROS-2-from-Scratch](https://github.com/PacktPublishing/ROS-2-from-Scratch).'
  id: totrans-296
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以直接从这本书复制粘贴模板，或者从 GitHub 仓库下载它们：[https://github.com/PacktPublishing/ROS-2-from-Scratch](https://github.com/PacktPublishing/ROS-2-from-Scratch)。
- en: Template for a Python node
  id: totrans-297
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: Python 节点的模板
- en: 'Use this code to start any new Python node:'
  id: totrans-298
  prefs: []
  type: TYPE_NORMAL
  zh: 使用此代码来启动任何新的 Python 节点：
- en: '[PRE41]'
  id: totrans-299
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: All you have to do is remove the **MODIFY NAME** comments and change the class
    name (**MyCustomNode**) and the node name (**"node_name"**). It’s better to use
    names that make sense. For example, if you are writing a node to read data from
    a temperature sensor, you could name the class **TemperatureSensorNode**, and
    the node could be **temperature_sensor**.
  id: totrans-300
  prefs: []
  type: TYPE_NORMAL
  zh: 您需要做的就是移除 **MODIFY NAME** 注释，并更改类名（**MyCustomNode**）和节点名（**"node_name"**）。使用有意义的名称会更好。例如，如果您正在编写一个从温度传感器读取数据的节点，您可以将类命名为
    **TemperatureSensorNode**，节点可以是 **temperature_sensor**。
- en: Template for a C++ node
  id: totrans-301
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: C++ 节点的模板
- en: 'Use this code to start any new C++ node:'
  id: totrans-302
  prefs: []
  type: TYPE_NORMAL
  zh: 使用此代码来启动任何新的 C++ 节点：
- en: '[PRE42]'
  id: totrans-303
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: Remove the **MODIFY NAME** comments and rename the class and the node.
  id: totrans-304
  prefs: []
  type: TYPE_NORMAL
  zh: 移除 **MODIFY NAME** 注释并重命名类和节点。
- en: Those two templates will allow you to start your nodes more quickly. I recommend
    you to use them as much as you can.
  id: totrans-305
  prefs: []
  type: TYPE_NORMAL
  zh: 这两个模板将允许您更快地启动节点。我建议您尽可能多地使用它们。
- en: Introspecting your nodes
  id: totrans-306
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 检查您的节点
- en: To finish this chapter, we will practice a bit more with the **ros2 node** command
    line.
  id: totrans-307
  prefs: []
  type: TYPE_NORMAL
  zh: 为了完成本章，我们将使用 **ros2 node** 命令行进行一些练习。
- en: So far, you have seen how to write a node, build it, and run it. One missing
    part is to know how to introspect your nodes. Even if a node can run, it doesn’t
    mean it will do exactly what you want it to do.
  id: totrans-308
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，您已经看到了如何编写节点、构建它并运行它。一个缺失的部分是了解如何检查您的节点。即使节点可以运行，这也并不意味着它将完全按照您希望的方式执行。
- en: Being able to introspect your nodes will help you fix errors that you might
    have made in your code. It will also allow you to easily find more information
    about other nodes that you are starting but didn’t write (as we did in the discovery
    phase in [*Chapter 3*](B22403_03.xhtml#_idTextAnchor092)).
  id: totrans-309
  prefs: []
  type: TYPE_NORMAL
  zh: 能够检查您的节点将帮助您修复您可能在代码中犯的错误。它还将允许您轻松地找到有关您启动但未编写的其他节点的更多信息（如我们在 [*第 3 章*](B22403_03.xhtml#_idTextAnchor092)
    中的发现阶段所做的那样）。
- en: For each core concept in *Part 2*, we will take a bit of time to experiment
    with the command-line tools related to the concept. The command-line tool for
    nodes is **ros2 node**.
  id: totrans-310
  prefs: []
  type: TYPE_NORMAL
  zh: 对于 *第二部分* 中的每个核心概念，我们将花一些时间来实验与该概念相关的命令行工具。节点的命令行工具是 **ros2 node**。
- en: 'First, and before we use **ros2 node**, we have to start a node. As a recap,
    to start a node, we use **ros2 run <package_name> <executable_name>**. If we start
    the Python node we have created in this chapter, we use this:'
  id: totrans-311
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，在我们使用 **ros2 node** 之前，我们必须启动一个节点。作为回顾，要启动节点，我们使用 **ros2 run <package_name>
    <executable_name>**。如果我们启动本章中创建的 Python 节点，我们使用这个：
- en: '[PRE43]'
  id: totrans-312
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: Only after we have started a node can we do some introspection with **ros2 node**.
  id: totrans-313
  prefs: []
  type: TYPE_NORMAL
  zh: 只有在我们启动了一个节点之后，我们才能使用 **ros2 node** 进行一些检查。
- en: ros2 node command line
  id: totrans-314
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: ros2 node 命令行
- en: 'To list all running nodes, use **ros2** **node list**:'
  id: totrans-315
  prefs: []
  type: TYPE_NORMAL
  zh: 要列出所有正在运行的节点，使用 **ros2 node list**：
- en: '[PRE44]'
  id: totrans-316
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: We find the name of the node, which we defined in the code.
  id: totrans-317
  prefs: []
  type: TYPE_NORMAL
  zh: 我们找到了在代码中定义的节点名称。
- en: 'Once we have the node name, we can get more info about it with **ros2 node**
    **info <node_name>**:'
  id: totrans-318
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦我们有了节点名称，我们可以使用 **ros2 node info <node_name>** 获取更多关于它的信息：
- en: '[PRE45]'
  id: totrans-319
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: As you can see, there are quite a lot of things on the terminal. We will get
    to know all of them in the following chapters. With **ros2 node info <node_name>**
    you can see all topics (publishers/subscribers), services, and actions running
    for this node.
  id: totrans-320
  prefs: []
  type: TYPE_NORMAL
  zh: 如您所见，终端上有很多东西。我们将在接下来的章节中了解它们。使用 **ros2 node info <node_name>** 可以查看此节点运行的所有主题（发布者/订阅者）、服务和动作。
- en: Changing the node name at run time
  id: totrans-321
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 在运行时更改节点名称
- en: 'As we progress throughout the book, I will give you additional tips for working
    with ROS 2 and the command line. Here is one: when starting an executable, you
    can choose to use the default node name (the one defined in the code) or replace
    it with a new name.'
  id: totrans-322
  prefs: []
  type: TYPE_NORMAL
  zh: 随着我们在本书中的进展，我将为您提供一些关于使用 ROS 2 和命令行的额外技巧。这里有一个：在启动可执行文件时，您可以选择使用默认的节点名称（代码中定义的名称）或用新名称替换它。
- en: To add any additional argument to **ros2 run**, first add **--ros-args** (only
    once).
  id: totrans-323
  prefs: []
  type: TYPE_NORMAL
  zh: 要向 **ros2 run** 添加任何额外的参数，首先需要添加 **--ros-args**（只添加一次）。
- en: 'Then, to rename the node, add **-r __node:=<new_name>**. **-r** means remap;
    you could also use **--remap**. For example, if we want to name the node **abc**,
    we could use this:'
  id: totrans-324
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，要重命名节点，添加 **-r __node:=<new_name>**。**-r** 表示重映射；您也可以使用 **--remap**。例如，如果我们想将节点命名为
    **abc**，我们可以使用这个：
- en: '[PRE46]'
  id: totrans-325
  prefs: []
  type: TYPE_PRE
  zh: '[PRE46]'
- en: As you can see from the logs, instead of **my_node_name**, we see **abc**.
  id: totrans-326
  prefs: []
  type: TYPE_NORMAL
  zh: 如从日志中所示，我们看到的不是 **my_node_name**，而是 **abc**。
- en: 'List all running nodes:'
  id: totrans-327
  prefs: []
  type: TYPE_NORMAL
  zh: 列出所有正在运行的节点：
- en: '[PRE47]'
  id: totrans-328
  prefs: []
  type: TYPE_PRE
  zh: '[PRE47]'
- en: This functionality can be very helpful and gives you more control over how to
    start a node, without having to modify the code directly.
  id: totrans-329
  prefs: []
  type: TYPE_NORMAL
  zh: 这个功能非常有用，它让你能够更好地控制如何启动节点，而无需直接修改代码。
- en: Note
  id: totrans-330
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: When running multiple nodes, you should make sure that each node has a unique
    name. Having two nodes with the same name can lead to some unexpected issues that
    can take a long time to debug. In the future, you will see that you may want to
    run the same node several times, for example, three `temperature_sensor` nodes,
    one each for a different sensor. You could rename them so that you have `temperature_sensor_1`,
    `temperature_sensor_2`, and `temperature_sensor_3`.
  id: totrans-331
  prefs: []
  type: TYPE_NORMAL
  zh: 当运行多个节点时，你应该确保每个节点都有一个独特的名称。如果有两个节点具有相同的名称，可能会导致一些意想不到的问题，这些问题可能需要很长时间才能调试。在未来，你可能需要运行同一个节点多次，例如，三个`temperature_sensor`节点，每个节点对应不同的传感器。你可以将它们重命名为`temperature_sensor_1`、`temperature_sensor_2`和`temperature_sensor_3`。
- en: Summary
  id: totrans-332
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: In this chapter, you have created your first node. Let’s do a quick recap of
    all the steps.
  id: totrans-333
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，你已经创建了你的第一个节点。让我们快速回顾一下所有步骤。
- en: 'Before creating any node, you need to follow these steps:'
  id: totrans-334
  prefs: []
  type: TYPE_NORMAL
  zh: 在创建任何节点之前，你需要遵循以下步骤：
- en: You first need to create and set up a ROS 2 workspace.
  id: totrans-335
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 你首先需要创建并设置一个ROS 2工作区。
- en: In this workspace, you can create several packages (Python or C++) that represent
    different sub-parts of your application.
  id: totrans-336
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在这个工作区中，你可以创建几个包（Python或C++），它们代表应用程序的不同子部分。
- en: 'Then, in one package you can create one or several nodes. For each node, you
    will have to do the following:'
  id: totrans-337
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，在一个包中你可以创建一个或多个节点。对于每个节点，你都需要执行以下操作：
- en: Create a file inside the package.
  id: totrans-338
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在包内创建一个文件。
- en: Write the node (using the OOP template as a base).
  id: totrans-339
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 编写节点（以OOP模板为基础）。
- en: Set the build instructions (`setup.py` for Python, `CMakeLists.txt` for C++).
  id: totrans-340
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 设置构建说明（Python的`setup.py`，C++的`CMakeLists.txt`）。
- en: Build the package.
  id: totrans-341
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 构建包。
- en: To run the node, don’t forget to source the workspace first, and then start
    the node with **ros2 run <****pkg_name> <executable_name>**.
  id: totrans-342
  prefs: []
  type: TYPE_NORMAL
  zh: 要运行节点，别忘了首先源代码工作区，然后使用**ros2 run <pkg_name> <executable_name>**启动节点。
- en: Finally, you can introspect your nodes and even change their names when you
    start them, using the **ros2 node** command line.
  id: totrans-343
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，当你启动节点时，可以使用**ros2 node**命令行来检查你的节点，甚至更改它们的名称。
- en: Feel free to come back to this chapter anytime to see the complete process of
    creating a node for both Python and C++. All the code is available on GitHub at
    [https://github.com/PacktPublishing/ROS-2-from-Scratch](https://github.com/PacktPublishing/ROS-2-from-Scratch).
    There you can find the OOP template code for Python and C++, **my_py_pkg** package,
    and **my_cpp_pkg** package.
  id: totrans-344
  prefs: []
  type: TYPE_NORMAL
  zh: 随时可以回到本章，查看创建Python和C++节点的完整过程。所有代码都可在GitHub上找到，网址为[https://github.com/PacktPublishing/ROS-2-from-Scratch](https://github.com/PacktPublishing/ROS-2-from-Scratch)。在那里你可以找到Python和C++的OOP模板代码，**my_py_pkg**包和**my_cpp_pkg**包。
- en: In this chapter, you have also seen how to create a timer and a callback function.
    You have a better idea of how the spin mechanism works, and how it allows the
    node to stay alive and run the callbacks. This will be very useful for the following
    chapters.
  id: totrans-345
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，你还看到了如何创建计时器和回调函数。你对自旋机制的工作原理有了更好的理解，以及它是如何使节点保持活跃并运行回调的。这将在后续章节中非常有用。
- en: In the next chapter, we will see how nodes communicate with each other using
    topics. You will write your own topics (publishers/subscribers) inside nodes and
    experiment with them.
  id: totrans-346
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章中，我们将看到节点如何通过主题进行通信。你将在节点内部编写自己的主题（发布者/订阅者）并对其进行实验。
