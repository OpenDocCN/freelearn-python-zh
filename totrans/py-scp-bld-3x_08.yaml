- en: '8'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Animation Modifiers
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Animation curves, or F-Curves, can be altered by modifiers without having their
    keyframes changed. This way, cinematic or motion effects can replace the initial
    curve completely or add to its original value.
  prefs: []
  type: TYPE_NORMAL
- en: The output of a modifier can be the input of another modifier, which, when combined,
    allows us to build complex results on top of simple animations.
  prefs: []
  type: TYPE_NORMAL
- en: Python scripts can be used to help automate this and streamline the workflow.
  prefs: []
  type: TYPE_NORMAL
- en: Changing a parameter affects the modifier’s result, while its overall **Influence**
    can be reduced using the slider in the modifier interface.
  prefs: []
  type: TYPE_NORMAL
- en: In this chapter, you will learn how to add modifiers to animation F-Curves with
    your scripts and how to change their parameters.
  prefs: []
  type: TYPE_NORMAL
- en: 'This chapter will cover the following topics:'
  prefs: []
  type: TYPE_NORMAL
- en: Understanding F-Curve Modifiers in the Blender UI
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Adding F-Curve Modifiers via Python
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Using F-Curve Modifiers in our add-ons
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Technical requirements
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We will use Blender and Visual Studio Code in this chapter. The examples created
    in this chapter can be found at [https://github.com/PacktPublishing/Python-Scripting-in-Blender/tree/main/ch8](https://github.com/PacktPublishing/Python-Scripting-in-Blender/tree/main/ch8).
  prefs: []
  type: TYPE_NORMAL
- en: Using F-Curve Modifiers
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Modifiers for animation curves, called **F-Curve Modifiers** or **F-Modifiers**,
    add non-destructive changes to animations while preserving their original data.
    We examined similar functionality in **Object Constraints** in [*Chapter 4*](B18375_04.xhtml#_idTextAnchor075),
    where we learned how to affect an object’s position without changing the values
    stored in its channels.
  prefs: []
  type: TYPE_NORMAL
- en: Like object constraints, F-Modifiers are exposed to Python scripts through a
    collection property.
  prefs: []
  type: TYPE_NORMAL
- en: Before we delve into how F-Modifiers are scripted, we will have a look at how
    to create them in the **Graph Editor**.
  prefs: []
  type: TYPE_NORMAL
- en: Adding F-Curve Modifiers in the Graph Editor
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: We will now look at how to add variation to an animated object using F-Curve
    Modifiers.
  prefs: []
  type: TYPE_NORMAL
- en: For this example, we will use the `ani_loop.blend` scene, from the accompanying
    `PythonScriptingBlender/ch8/_scenes_` folder, but you can use any scene.
  prefs: []
  type: TYPE_NORMAL
- en: 'The animation along the *8*-shaped path in `ani_loop.blend` wasn’t created
    by hand: it was generated using the **Vert Runner** add-on developed in [*Chapter
    7*](B18375_07.xhtml#_idTextAnchor171).'
  prefs: []
  type: TYPE_NORMAL
- en: 'We will add some variation to the path of an animated object by creating an
    F-Curve Modifier in **Graph Editor**:'
  prefs: []
  type: TYPE_NORMAL
- en: Select an animated object.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Change one of the UI areas to **Graph Editor**. A good place is the left Viewport
    in the **Animation Workspace**.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: In the **Graph Editor** left panel, select the **X** **Location** channel.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Press *N* to display the property tabs. Make sure that the **Graph Editor**
    has focus and is large enough, or the tabs will not show up.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: In the right panel of the **Graph Editor**, select the **Modifiers** tab.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: From the **Modifiers** tab, select a modifier from the **Add Modifier** menu.
    In this example, we will use the **Stepped** **Interpolation** modifier.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![Figure 8.1: Adding curve modifiers in the Graph Editor](img/Figure_8.01_B18375.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 8.1: Adding curve modifiers in the Graph Editor'
  prefs: []
  type: TYPE_NORMAL
- en: The animation curve for **Z Location** changes to a stepped graph. If we play
    the animation now, we will see the object proceeding in little jumps rather than
    smoothly, as before.
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 8.2: Stepped modifier applied on a smooth curve](img/Figure_8.02_B18375.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 8.2: Stepped modifier applied on a smooth curve'
  prefs: []
  type: TYPE_NORMAL
- en: 'The Blender manual describes modifiers in detail on the **F-Curve** **Modifiers**
    page:'
  prefs: []
  type: TYPE_NORMAL
- en: '[docs.blender.org/manual/en/3.2/editors/graph_editor/fcurves/modifiers.xhtml](https://docs.blender.org/manual/en/3.2/editors/graph_editor/fcurves/modifiers.xhtml%0D)'
  prefs: []
  type: TYPE_NORMAL
- en: 'There are seven available types. The first two generate curves based on mathematical
    formulas:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Generator**: Expressions for lines, parabolas, and curves of higher degrees'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Built-in**: Trigonometric and logarithmic formulas'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The other five cover some basic animation tasks:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Envelope**: Control points for editing the overall shape of the curve'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Cyclic**: To repeat animations in loops after their last frame'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Noise**: Adds random jitter to the animation'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Limits**: Limits the animation values to a range'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Stepped Interpolation**: Converts smooth animation to jerky motion'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Like constraints, modifiers of an F-Curve are exposed to Python as a collection.
    We can use the `fcurve.modifiers.new` method to add new modifiers via scripting.
  prefs: []
  type: TYPE_NORMAL
- en: Adding F-Curve Modifiers in Python
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The `fcurve.modifiers.new(type)` method creates a new modifier according to
    the type provided in the argument. It returns the new modifier.
  prefs: []
  type: TYPE_NORMAL
- en: 'With the exception of `FNGENERATOR` and `STEPPED`, modifiers of a given type
    are created using the type name in uppercase letters:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'So, to add a `''STEPPED''` modifier to the `2`), we use the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: 'Likewise, a modifier can be removed using the `fcurve.modifiers.remove` method.
    This time, the Python instance of the modifier must be used as an argument:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: Now that we have learned where F-Modifiers can be found, how they work, and
    how to add more of them, both in the user interface and the Python Console, we
    can use this knowledge in our scripts.
  prefs: []
  type: TYPE_NORMAL
- en: The add-on we will write in the next section allows us to create shaky animations
    using F-Modifiers.
  prefs: []
  type: TYPE_NORMAL
- en: Writing the Shaker add-on
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The **Shaker** add-on creates a shaky effect on the active object by adding
    noise modifiers to its animation curves.
  prefs: []
  type: TYPE_NORMAL
- en: There are cases when we want to add some shaking to a motion. For instance,
    directors often use a *camera shake* to suggest an object being bumped or hit.
    Another use case is the bumpy motion of a vehicle, or hairs and feathers in a
    windy environment. The Python script we are going to write will contain an operator
    and a menu function for quick execution.
  prefs: []
  type: TYPE_NORMAL
- en: Setting up the environment
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'We first create a Python script for our add-on:'
  prefs: []
  type: TYPE_NORMAL
- en: Create the `PythonScriptingBlender/ch8/addons` folder. We can use the file manager
    or the **File** tab of our code editor, such as **VS Code**.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Create a new file in that folder and name it `object_shaker.py`. We can use
    the file manager or the **New File** button of our code editor.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Open the file in your editor of choice.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Set the `PythonScriptingBlender/ch8` in the Blender **File** **Paths** preferences.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Now, we will start writing the add-on code as usual.
  prefs: []
  type: TYPE_NORMAL
- en: Writing the Shaker add-on info
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'We will add our new operator, `location` attribute of the add-on info:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: Writing the Add Object Shake operator class
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'We import the `bpy` module, then write the `bl_*` identifiers of `Object Shaker`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: 'This operator needs two float parameters:'
  prefs: []
  type: TYPE_NORMAL
- en: Noise `duration` in seconds
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Noise `strength`, that is, how much this modifier contributes to the animation
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`duration` should be a positive number: there is no such thing as a negative
    amount of time. So, we set `0.0` as the property minimum. The amount of shaking,
    on the other hand, could benefit from values below `0.0` or above `1.0`. It’s
    a more peculiar circumstance in which we still want to set the range of values
    from `0.0` to `1.0` as the ordinary condition, but we don’t want to prevent the
    user from going beyond those limits if they want to. We can set limits that apply
    to the slider but accept an out-of-range numerical input using the `soft_min`
    and `soft_max` parameters.'
  prefs: []
  type: TYPE_NORMAL
- en: Adding limits and soft limits to properties
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Normally, the influence, or `strength`, of the modifier, should range between
    `0.0` and `1.0` (meaning no influence and full influence, respectively) but using
    values outside that range has a multiplicative effect. For instance, an influence
    of `2.0` doubles the modifier’s contribution.
  prefs: []
  type: TYPE_NORMAL
- en: 'Soft limits for Blender properties are useful in this case: `min`, `max`, `soft_min`,
    and `soft_max` limit the range of the slider in the interface, but while `min`
    and `max` never accept any number exceeding their range, `soft_min` and `soft_max`
    allow the user to click on the slider and type any value they wish using the keyboard.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Values exceeding the initial `soft_min` and `soft_max` parameters are considered
    valid input and become the new range of the slider:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: Now, we can write the `poll` method for verifying the conditions and the `execute`
    method to perform the action of adding noise.
  prefs: []
  type: TYPE_NORMAL
- en: Writing the operator methods
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Besides the usual `poll` and `execute` methods, we will write a utility function
    for finding the F-Curve of a given property.
  prefs: []
  type: TYPE_NORMAL
- en: Writing the poll method
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'The condition for the `poll` method is very simple – the operator can be invoked
    if there is an active object:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: We need an animated property to add a noise modifier. If it is already animated,
    we pick the existing animation curve, otherwise, we create a new one. This operation
    can be implemented as a separate function, named `get_fcurve`, which takes `data_path`
    as an argument and returns its animation curve. It creates a new curve if it doesn’t
    exist yet.
  prefs: []
  type: TYPE_NORMAL
- en: Writing the get_fcurve method
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: We delegate the task of finding or creating a property animation curve to the
    `get_fcurve` function. Since it will be used by the `ObjectShaker` operator alone,
    we write it as a class method, with `self` as its first argument. We might want
    to use it on more than one property and object, so we also pass the object to
    inspect and `data_path` of the property to animate. In case of vector properties,
    we pass the `index` component as well. We use `obj` rather than `object` as a
    parameter name because the latter represents the Python basic class, a term we
    don’t want to override.
  prefs: []
  type: TYPE_NORMAL
- en: 'We know from [*Chapter 7*](B18375_07.xhtml#_idTextAnchor171), that F-Curves
    belong to an action, and our operator adds noise to the current action, so this
    function will look for the `action` attribute of the object’s animation data.
    Before we run `get_fcurve`, we should make sure that such an action exists, so,
    in line with the *Defensive Programming* practice learned in [*Chapter 6*](B18375_06.xhtml#_idTextAnchor129),
    we use `assert` to halt the script if, for unforeseen reasons, no current action
    is found:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: Now we need to return the F-Curve that animates the `data_path` instance provided
    as an argument, and create it if it doesn’t exist. We can attempt its creation
    using `try`, a statement learned in the *Improving our code* section of [*Chapter
    3*](B18375_03.xhtml#_idTextAnchor049).
  prefs: []
  type: TYPE_NORMAL
- en: Trying to create two F-Curves with the same path causes a `RuntimeError` error,
    which, in a `try` statement, triggers the `except` clause. By looking for existing
    curves only if we need to, our code will be leaner and slightly faster.
  prefs: []
  type: TYPE_NORMAL
- en: 'Under the `except` statement, we use the `next` function on a conditional *iterator*,
    that is, a sequence of objects that satisfy our criteria, in this case, a matching
    `data_path` and `index`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: In either case, we will end up with the `crv` variable containing the F-Curve
    we are looking for. We could have used a `for` loop to iterate `action.fcurves`,
    but the `next` function provides a valid and compact alternative.
  prefs: []
  type: TYPE_NORMAL
- en: Scrolling through collections efficiently
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: The `next` function returns the first valid element of a sequence. For example,
    typing `next(action.fcurves)` simply gives the first curve of an action. The argument
    of `next` can be any iterator, though, not just a list or a collection. Since
    iterators can contain conditional statements such as `if`, `next` can be a concise
    and performant alternative to `for` loops.
  prefs: []
  type: TYPE_NORMAL
- en: While `fc for fc in action.fcurves` scrolls all the elements of `fcurves`, the
    conditions on `fc.data_path` and `fc.array_index` ensure that the first curve
    that complies with those requirements is returned.
  prefs: []
  type: TYPE_NORMAL
- en: 'If no curve is found, `next` fails with a `StopIteration` error, but we know
    that it will not happen: an existing curve brought us to the `except` block of
    this `try` statement in the first place. So, either under the `try` block or under
    `except`, the `crv` variable now contains the F-Curve we are looking for. Before
    we add a modifier to it, we must make sure that it contains at least one keyframe.'
  prefs: []
  type: TYPE_NORMAL
- en: Ensuring the presence of keyframes
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'At this point, we have stored an animation curve in the `crv` variable, but
    we must look for its keyframe points, or it will not be evaluated. If the `keyframe_points`
    collection is empty, we add keyframes to it by using `keyframe_points.insert`.
    We will use the current frame and value as arguments:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: 'Now that we have an animation curve and it is guaranteed to support modifiers,
    we can return the `crv` variable and exit the `get_fcurve` function:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: This function will be called in the `execute` method, the last missing piece
    of the operator.
  prefs: []
  type: TYPE_NORMAL
- en: Writing the execute method
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'If our object has not been animated yet, we create new `animation_data`, otherwise,
    we store the existing data in the `anim` variable:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: 'Likewise, we should create a new action if there isn’t one yet or get the current
    one. In either case, it is going to be stored in the `action` variable:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, it’s finally time to add some shaking motion. First, we need to express
    the duration of the effect in frames, rather than seconds. To do that, we multiply
    the `duration` parameter by the frames-per-second of the scene. Once we have the
    duration in frames, we divide it by half to center the object shake around the
    current frame; half of the frames will be played before it, while the second half
    will be played afterward:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: 'The next step is looking for the animation curves that we want to alter: `location`
    Z, `rotation_euler` X, and `rotation_euler` Y. We need these ones specifically
    as they represent the up-down shake, yaw shake, and pitch shake of a camera, respectively.'
  prefs: []
  type: TYPE_NORMAL
- en: 'If they don’t exist, our `get_fcurve` method creates and returns them:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: 'Since F-Modifiers are specific to each curve, we create a `NOISE` modifier
    for each of them. We use a `for` loop to create all three at once. The noise `strength`
    value, a float attribute, can be set directly from the `strength` parameter of
    the operator, while we computed the `start` and `end` values for the noise earlier:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: 'We have turned `use_restricted_range` on to limit the noise in our `start`
    and `end` frames: the `frame_start` and `frame_end` attributes would have no effect
    otherwise. Once we have set F-Modifiers for the three curves, we can finally exit
    the method.'
  prefs: []
  type: TYPE_NORMAL
- en: Now that our operator is complete, we can add a menu item to the interface and
    the `register`/`unregister` functions.
  prefs: []
  type: TYPE_NORMAL
- en: Adding menu items
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: As we learned when writing interfaces, a menu function takes `self` and `context`
    as arguments.
  prefs: []
  type: TYPE_NORMAL
- en: 'Inside the menu function, we add a separator and the `ObjectShaker` operator
    to `self.layout`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: This function can then be added to any menu, but since our operator affects
    the animation of object transforms, we can use the right-click menu displayed
    by the Viewport in **Object Mode**.
  prefs: []
  type: TYPE_NORMAL
- en: Finding the class names of context menus
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The API documentation doesn’t contain a list of all menus. We can look for them
    in `bpy.types`, which contains all the Blender classes, and keep in mind that
    the class name we are looking for starts with `VIEW3D_MT` and ends with `_context_menu`.
  prefs: []
  type: TYPE_NORMAL
- en: 'We can use these criteria in a *list comprehension*, that is, a list-like object
    delimited by square brackets that, like the `next` function we have met earlier
    in this section, is built with a conditional iterator. We can run it in Blender’s
    **Python Console**:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: 'Among the listed context menus, we find `VIEW3D_MT_object_context_menu`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: 'In returning the results that match the `context_menu` suffix, our list comprehension
    acted almost like a small search engine. To filter the result even further, we
    can add an `"object"` string as a requirement to filter the output to one result:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: 'This list comprehension narrows the results down to the object context menu
    only:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: Now that we know which menu class to use, we can move to registering the add-on.
  prefs: []
  type: TYPE_NORMAL
- en: Registering the Shaker add-on
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Enabling the add-on produces these two results:'
  prefs: []
  type: TYPE_NORMAL
- en: Adds the `ObjectShaker` class to Blender
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Adds the `m_items` function to the object right-click menu
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Each of those tasks happen in the `register` function:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: 'Following the same logic, when the add-on is disabled, its code is purged from
    Blender, upon which `m_items` should be removed from the menu and `ObjectShaker`
    from the registered classes. Failing to do so would leave orphan entities in Blender.
    The `unregister` function takes care of that:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: We can refresh the add-ons using the **Refresh** button in the **Add-ons** preferences
    and enable **Object Shaker** from the **Learning** category. When the add-on is
    enabled, the **Add Object Shake** option appears in the given object’s right-click
    menu.
  prefs: []
  type: TYPE_NORMAL
- en: Using the Shaker add-on
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Using our add-on, we can add a shaking motion to any object by following these
    steps:'
  prefs: []
  type: TYPE_NORMAL
- en: Make the object active.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Right-click (or press `W` if **Select with Mouse Button** was set to **Right**
    in **Preferences** | **Keymap**).
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Select **Add Object Shake** from the menu.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Adjust the **duration** and **strength** values in the **Execution** panel.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Like with the *Action Range add-on* from [*Chapter 7*](B18375_07.xhtml#_idTextAnchor171),
    the selected amount of **duration** and **strength** can be changed after execution
    using **Edit** | **Adjust Last Operation** from the top bar.
  prefs: []
  type: TYPE_NORMAL
- en: We have created a tool that adds a procedural behavior to an object using animation
    modifiers. This is a valuable shortcut when animating with Python. Moreover, it
    introduces us to the concept of a non-destructive modifier, that is, adding parametric
    changes that can be removed or edited at will.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We have learned how to create animation effects for our scenes and have seen
    how we can convert an idea into a procedural tool. Artists and technical animators
    can come up with convoluted conceptual configurations, which we can turn into
    quick-setup operators following the process outlined in this chapter.
  prefs: []
  type: TYPE_NORMAL
- en: Using the animation system is a convenient way to implement parametric behaviors,
    as it relies on the application update logic and produces fast, reliable outputs.
  prefs: []
  type: TYPE_NORMAL
- en: We will explore a similar but more powerful technique in [*Chapter 9*](B18375_09.xhtml#_idTextAnchor226),
    thus completing our overview of the animation system.
  prefs: []
  type: TYPE_NORMAL
- en: Questions
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: What do we mean by non-destructive modifiers?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Do modifiers change the keyframe points of a curve?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Can we add animation modifiers to non-animated objects?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: How do we make sure that a property is animated?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: What is a parameter soft limit?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: In which cases do we use soft rather than strong limits?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: How can we look for a class name in Python?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
