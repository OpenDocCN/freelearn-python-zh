- en: '7'
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Basics of Classes and Objects
  prefs: []
  type: TYPE_NORMAL
- en: The point of computing is to process data. We often encapsulate the processing
    and the data into a single definition. We can organize objects into classes with
    a common collection of attributes to define their internal state and common behavior.
    Each instance of a class is a distinct object with unique internal state and behavior.
  prefs: []
  type: TYPE_NORMAL
- en: This concept of state and behavior applies particularly well to the way games
    work. When building something like an interactive game, the user’s actions update
    the game state. Each of the player’s possible actions is a method to change the
    state of the game. In many games this leads to a lot of animation to show the
    transition from state to state. In a single-player arcade-style game, the enemies
    or opponents will often be separate objects, each with an internal state that
    changes based on other enemy actions and the player’s actions.
  prefs: []
  type: TYPE_NORMAL
- en: On the other hand, if we consider a card or dice game, there may be very few
    states possible. A game like Zonk involves a player rolling (and rerolling) dice
    as long as their score improves. If a subsequent roll fails to improve their hand
    of dice, their turn is over. The hand’s state is the pool of dice that comprise
    the scoring subset, often pushed to one side of the table. In a six-dice game,
    there will be from one to six scoring dice as distinct states. Additionally, when
    all dice are scoring, the player can begin the rolling process again by rerolling
    all of the dice. This leads to an additional ”over-the-top” state that the players
    must also bear in mind.
  prefs: []
  type: TYPE_NORMAL
- en: The point of object-oriented design is to define the current state with the
    attributes of an object. Each object is defined as an instance of a class of similar
    objects. We write the class definitions in Python and use these to create objects.
    The methods defined in the class cause the state changes on an object.
  prefs: []
  type: TYPE_NORMAL
- en: 'In this chapter, we will look at the following recipes:'
  prefs: []
  type: TYPE_NORMAL
- en: '[Using a class to encapsulate data and processing](ch011_split_000.xhtml#x1-3770001)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[Essential type hints for class definitions](ch011_split_000.xhtml#x1-3830002)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[Designing classes with lots of processing](ch011_split_000.xhtml#x1-3890003)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[Using typing.NamedTuple for immutable objects](ch011_split_000.xhtml#x1-3950004)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[Using dataclasses for mutable objects](ch011_split_000.xhtml#x1-4010005)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[Using frozen dataclasses for immutable objects](ch011_split_000.xhtml#x1-4070006)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[Optimizing small objects with __slots__](ch011_split_001.xhtml#x1-4130007)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[Using more sophisticated collections](ch011_split_001.xhtml#x1-4190008)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[Extending a built-in collection – a list that does statistics](ch011_split_001.xhtml#x1-4250009)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[Using properties for lazy attributes](ch011_split_001.xhtml#x1-43100010)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[Creating contexts and context managers](ch011_split_001.xhtml#x1-43700011)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[Managing multiple contexts with multiple resources](ch011_split_001.xhtml#x1-44300012)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The subject of object-oriented design is quite large. In this chapter, we’ll
    cover some of the essentials. We’ll start with some foundational concepts, such
    as how a class definition encapsulates state and processing details for all instances
    of a class.
  prefs: []
  type: TYPE_NORMAL
- en: 7.1 Using a class to encapsulate data and processing
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Class design is influenced by the SOLID design principles. The Single Responsibility
    and Interface Segregation principles offer helpful advice. Taken together, these
    principles advise us that a class should have methods narrowly focused on a single,
    well-defined responsibility.
  prefs: []
  type: TYPE_NORMAL
- en: Another way of considering a class is as a group of closely-related functions
    working with common data. We call these methods for working with the data. A class
    definition should contain the smallest collection of methods for working with
    the object’s data.
  prefs: []
  type: TYPE_NORMAL
- en: We’d like to create class definitions based on a narrow allocation of responsibilities.
    How can we define responsibilities effectively? What’s a good way to design a
    class?
  prefs: []
  type: TYPE_NORMAL
- en: 7.1.1 Getting ready
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Let’s look at a simple, stateful object – a pair of dice. The context for this
    is an application that simulates a simple game like Craps.
  prefs: []
  type: TYPE_NORMAL
- en: A software object can be viewed as analogous to a thing – a noun. The behaviors
    of the class can then be viewed as verbs. This identification with nouns and verbs
    gives us a hint as to how we can proceed to design classes to work effectively.
  prefs: []
  type: TYPE_NORMAL
- en: 'This leads us to several steps of preparation. We’ll provide concrete examples
    of these steps using a pair of dice for game simulation. We proceed as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Write down simple sentences that describe what an instance of the class does.
    We can call these the problem statements. It’s essential to focus on single-verb
    sentences, with a focus on only the nouns and verbs. Here are some examples:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The game of Craps has two standard dice.
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: Each die has six faces, with point values from one to six.
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: Dice are rolled by a player. While writers and editors prefer the active voice
    version, ”A player rolls the dice,” the dice are often acted upon by other objects,
    making passive-voice sentences slightly more useful.
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: The total of the dice changes the state of the Craps game. Those rules are separate
    from the dice.
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: If the two dice match, the number was described as being rolled “the hard way”.
    If the two dice do not match, the roll was described as being made “the easy way”.
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: Identify all of the nouns in the sentences. In this example, the nouns include
    dice, faces, point values, and a player. The nouns identify different classes
    of objects that may be collaborators, like player and game. Nouns may also identify
    attributes of objects, like face and point value.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Identify all the verbs in the sentences. Verbs often become methods of the class
    in question. In this example, verbs include roll and match.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: This information helps define the state and behavior of the objects. Having
    this background information will help us write the class definition.
  prefs: []
  type: TYPE_NORMAL
- en: 7.1.2 How to do it...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Since the simulation we’re writing involves random throws of dice, we’ll depend
    on from random import randint to provide the useful randint() function. The steps
    for defining a class are as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Start writing the class with the class statement:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Initialize the object’s attributes within the body of an __init__() method.
    We’ll model the internal state of the dice with a faces attribute. A self variable
    is required to be sure that we’re referencing an attribute of a given instance
    of a class. We’ll provide a type hint on each attribute to be sure it’s used properly
    throughout the class definition:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Define the object’s methods based on the verbs in the description. When the
    player rolls the dice, a roll() method can set the values shown on the faces of
    the two dice. We implement this with a method to set the faces attribute of the
    self object:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: This method mutates the internal state of the object. We’ve elected to not return
    a value.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'After a player rolls the dice, a total() method helps compute the total of
    the dice:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Additional methods can provide answers to questions about the state of the
    dice. In this case, the total was made ”the hard way” when both dice match:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 7.1.3 How it works...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The core idea here is to use ordinary rules of grammar – nouns, verbs, and adjectives
    – as a way to identify basic features of a class. In our example, dice are real
    things. We try to avoid using abstract terms such as randomizers or event generators.
    It’s easier to describe the tangible features of real things, and then define
    an implementation to match the tangible features.
  prefs: []
  type: TYPE_NORMAL
- en: The idea of rolling the dice is an example physical action that we can model
    with a method definition. This action of rolling the dice changes the state of
    the object. In rare cases – 1 time in 36 – the next state will happen to match
    the previous state.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here’s an example of using the Dice class:'
  prefs: []
  type: TYPE_NORMAL
- en: 'First, we’ll seed the random number generator with a fixed value so that we
    can get a fixed sequence of results:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'We’ll create a Dice object, and assign it to a variable, d1\. We can then set
    its state with the roll() method. We’ll then look at the total() method to see
    what was rolled. We’ll examine the state by looking at the faces attribute:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 7.1.4 There’s more...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Capturing the essential internal state and methods that cause state change
    is the first step in good class design. We can summarize some helpful design principles
    using the acronym SOLID:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Single Responsibility Principle: A class should have one clearly defined responsibility.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Open/Closed Principle: A class should be open to extension – generally via
    inheritance – but closed to modification. We should design our classes so that
    we don’t need to tweak the code to add or change features.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Liskov Substitution Principle: We need to design inheritance so that a subclass
    can be used in place of the superclass.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Interface Segregation Principle: When writing a problem statement, we want
    to be sure that collaborating classes have as few dependencies as possible. In
    many cases, this principle will lead us to decompose large problems into many
    small class definitions.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Dependency Inversion Principle: It’s less than ideal for a class to depend
    directly on other classes. It’s better if a class depends on an abstraction, and
    a concrete implementation class is substituted for the abstract class.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The goal is to create classes that have the necessary behavior and also adhere
    to the design principles so they can be extended and reused.
  prefs: []
  type: TYPE_NORMAL
- en: 7.1.5 See also
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: See the [Using properties for lazy attributes](ch011_split_001.xhtml#x1-43100010)
    recipe, where we’ll look at the choice between an eager attribute and a lazy property.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: In Chapter [8](ch012.xhtml#x1-4520008), we’ll look in more depth at class design
    techniques.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: See Chapter [15](ch019_split_000.xhtml#x1-79400015), for recipes on how to write
    appropriate unit tests for the class.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 7.2 Essential type hints for class definitions
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: A class name is also a type hint, allowing a direct reference between a variable
    and the class that should define the objects associated with the variable. This
    relationship lets tools such as mypy reason about our programs to be sure that
    object references and method references appear to match the type hints in our
    code.
  prefs: []
  type: TYPE_NORMAL
- en: 'In addition to the class name, we’ll use type hints in three common places
    within a class definition:'
  prefs: []
  type: TYPE_NORMAL
- en: In method definitions, we’ll use type hints to annotate the parameters and the
    return type.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: In the __init__() method, we may need to provide hints for the instance variables
    that define the state of the object.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Inside the attributes of the class overall. These are not common and type hints
    are rare here.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 7.2.1 Getting ready
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: We’re going to examine a class with a variety of type hints. In this example,
    our class will model a handful of dice. We’ll allow rerolling selected dice, making
    the instance of the class stateful.
  prefs: []
  type: TYPE_NORMAL
- en: The collection of dice can be set by a first roll, where all the dice are rolled.
    The class allows subsequent rolls of a subset of dice. The number of rolls is
    counted as well.
  prefs: []
  type: TYPE_NORMAL
- en: The type hints will reflect the nature of the collection of dice, the integer
    counts, a floating-point average value, and a string representation of the hand
    as a whole. This will show a number of type hints and how to write them.
  prefs: []
  type: TYPE_NORMAL
- en: 7.2.2 How to do it...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'This definition will involve random numbers as well as type hints for sets
    and lists. We import the random module:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Define the class. This creates a new type:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'It’s rare for class-level variables to require a type hint. They’re almost
    always created with assignment statements that make the type information clear
    to a person or a tool like mypy. In this case, we want all instances of our class
    of dice to share a common random number generator object:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'The __init__() method creates the instance variables that define the state
    of the object. In this case, we’ll save some configuration details, plus some
    internal state. The __init__() method also has the initialization parameters.
    Generally, we’ll put the type hints on these parameters. Other internal state
    variables may require type hints to show what kinds of values will be assigned
    by other methods of the class. In this example, the faces attribute has no initial
    value; we state that when it is set, it will be a List[int] object:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Methods that compute new derived values can be annotated with their return
    type information. Here are three examples to return a string representation, compute
    the total, and also compute an average of the dice. These functions have return
    types of str, int, and float, as shown:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'For methods with parameters, we include type hints on the parameters as well
    as a return type. In this case, the methods that change the internal state also
    return values. The return value from both methods is a list of dice faces, described
    as list[int]. The parameter for the reroll() method is a set of dice to be rolled
    again. This is shown as a set[int] requiring a set of integers. Python is a little
    more flexible than this, and we’ll look at some alternatives:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 7.2.3 How it works...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The type hint information is used by programs such as mypy to be sure that the
    instances of the class are used properly throughout the application.
  prefs: []
  type: TYPE_NORMAL
- en: 'If we try to write a function like the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: 'The attempt to create an instance of the Dice class using a float value for
    the n parameter represents a conflict with the type hints. The hint for the Dice
    class’s __init__() method claimed the argument value should be an integer. The
    mypy program reports the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: If we try to execute the application, it will raise a TypeError exception in
    another place. The error will manifest when evaluating the d.first_roll() method.
    The exception is raised here because the body of the __init__() method works well
    with values of any type. The hints claim specific types are expected, but at runtime,
    any object can be provided. The hints are not checked during execution.
  prefs: []
  type: TYPE_NORMAL
- en: 'Similarly, when we use other methods, the mypy program checks to be sure our
    use of the method matches the expectations defined by the type hints. Here’s another
    example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: This assignment statement has a type hint for the r1 variable that doesn’t match
    the type hint for the return type from the first_roll() method. This conflict
    is found by mypy and reported as an Incompatible types in assignment error.
  prefs: []
  type: TYPE_NORMAL
- en: 7.2.4 There’s more...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: One of the type hints in this example is too specific. The function for re-rolling
    the dice, reroll(), has a positions parameter. The positions parameter is used
    in a for statement, which means the object must be some kind of iterable object.
  prefs: []
  type: TYPE_NORMAL
- en: The mistake was providing a type hint, set[int], which is only one of many kinds
    of iterable objects. We can generalize this definition by switching the type hint
    from the very specific set[int] to the more general Iterable[int].
  prefs: []
  type: TYPE_NORMAL
- en: Relaxing the hint means that any set, list, or tuple object can be a valid argument
    value for this parameter. The only other code change required is to import Iterable
    from the collections.abc module.
  prefs: []
  type: TYPE_NORMAL
- en: The for statement has a specific protocol for getting the iterator object from
    an iterable collection, assigning values to a variable, and executing the indented
    body. This protocol is defined by the Iterable type hint. There are many such
    protocol-based types, and they allow us to provide type hints that match Python’s
    inherent flexibility with respect to type.
  prefs: []
  type: TYPE_NORMAL
- en: 7.2.5 See also
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In Chapter [3](ch007_split_000.xhtml#x1-1610003), in the [Function parameters
    and type hints](ch007_split_000.xhtml#x1-1620001) recipe, a number of similar
    concepts are shown.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: In Chapter [4](ch008_split_000.xhtml#x1-2240004), the [Writing list-related
    type hints](ch008_split_001.xhtml#x1-2560005) and [Writing set-related type hints](ch008_split_001.xhtml#x1-2800009)
    recipes address additional detailed type hinting.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: In Chapter [5](ch009.xhtml#x1-2890005), the [Writing dictionary-related type
    hints](ch009.xhtml#x1-3040003) recipe also addresses type hinting.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 7.3 Designing classes with lots of processing
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Some of the time, an object will contain all of the data that defines its internal
    state. There are cases, however, where a class doesn’t hold the data, but instead
    is designed to consolidate processing for data held in separate containers.
  prefs: []
  type: TYPE_NORMAL
- en: Some prime examples of this design are statistical algorithms, which are often
    outside the data being analyzed. The data might be in a built-in list or Counter
    object; the processing is defined in a class separate from the data container.
  prefs: []
  type: TYPE_NORMAL
- en: 7.3.1 Getting ready
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: It’s quite common to do analysis on data that’s already been summarized into
    groups or bins. We might, for example, have a vast data file with a large number
    of measurements of an industrial process.
  prefs: []
  type: TYPE_NORMAL
- en: 'For background, see the NIST Aerosol Particle Size case study: [https://www.itl.nist.gov/div898/handbook/pmc/section6/pmc62.htm](https://www.itl.nist.gov/div898/handbook/pmc/section6/pmc62.htm)'
  prefs: []
  type: TYPE_NORMAL
- en: 'Rather than analyze the voluminous raw data, it’s often much faster to first
    summarize the important variables, then analyze the summarized data. The summary
    data can be kept in a Counter object. The data looks like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: The keys (7, 6, 8, 9, and so on) are codes reflecting the particle size. The
    actual sizes varied from 109 to 119\. Computing the actual size, c, from the s
    code is done with c = ⌊2(s − 109)⌋.
  prefs: []
  type: TYPE_NORMAL
- en: (The units aren’t provided in the NIST background information. Since a lot of
    the data reflects electronic chip wafers and fabrication, the units are likely
    something very small.)
  prefs: []
  type: TYPE_NORMAL
- en: 'We want to compute some statistics on this Counter object without being forced
    to work with the original voluminous dataset. In general, there are two general
    design strategies for designing classes to store and process data:'
  prefs: []
  type: TYPE_NORMAL
- en: Extend the storage class definition, Counter in this case, to add statistical
    processing. We’ll cover this in detail in the [Extending a built-in collection
    – a list that does statistics](ch011_split_001.xhtml#x1-4250009) recipe.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Wrap a Counter object in a class that provides the additional features required.
    When we do this, though, we have two more choices:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Expose the underlying Counter object. We’ll focus on this.
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: Write special methods to make the wrapper appear to also be a collection, encapsulating
    the Counter object. We’ll look at this in Chapter [8](ch012.xhtml#x1-4520008).
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: 'For this recipe, we’ll focus on the wrap variant where we define a statistical
    computation class that exposes a Counter object. We have two ways to design this
    compute-intensive processing:'
  prefs: []
  type: TYPE_NORMAL
- en: An Eager implementation computes the statistics as soon as possible. The values
    become simple attributes. We’ll focus on this choice.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A Lazy approach doesn’t compute anything until the value is required via a method
    function or property. We’ll look at this in the [Using properties for lazy attributes](ch011_split_001.xhtml#x1-43100010)
    recipe.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The essential algorithm for both designs is the same. The only question is when
    the work of the computation gets done.
  prefs: []
  type: TYPE_NORMAL
- en: 7.3.2 How to do it...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Import the appropriate class from the collections module. The computation uses
    math.sqrt(). Be sure to add the needed import math also:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Define the class with a descriptive name:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Write the __init__() method to include the object where the data is located.
    In this case, the type hint is Counter[int] because the keys used in the Counter
    object will be integers:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Initialize any other local variables in the __init__() method that might be
    useful. Since we’re going to calculate values eagerly, the most eager possible
    time is when the object is created. We’ll write references to some yet to be defined
    functions:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Define the required methods for the various values. Here’s the calculation
    of the mean:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Here’s how we can calculate the standard deviation:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Note that this calculation requires that the mean is computed first and the
    self.mean instance variable has been created. This internal state change from
    no known mean to a known mean to a known standard deviation is a potential complication
    that requires clear documentation.
  prefs: []
  type: TYPE_NORMAL
- en: The raw data for this example is at [https://www.itl.nist.gov/div898/handbook//datasets/NEGIZ4.DAT](https://www.itl.nist.gov/div898/handbook//datasets/NEGIZ4.DAT).
    This file has an awkwardly complicated layout because there are 50 lines of header
    text in front of the data. Further, the file isn’t in a common CSV format. For
    these reasons, it’s easier to work with summarized data.
  prefs: []
  type: TYPE_NORMAL
- en: 'The repository of code for this book includes a file named data/binned.csv
    that has the binned summary data. This data has three columns: size_code, size,
    and frequency. We’re only interested in size_code and frequency.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Here’s how we can build a suitable Counter object from this file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: 'We’ve used a dictionary comprehension to create a mapping from size_code to
    the frequency of that code value. This is then provided to the Counter class to
    build a Counter object named data from this existing summary. We can provide this
    data to the CounterStatistics class to get useful summary statistics from the
    binned data. This looks like the following example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: We provided the data object to create an instance of the CounterStatistics class.
    Creating this instance will also immediately compute the summary statistics. No
    additional explicit method evaluations are required. These values are available
    as the stats.mean and stats.stddev attributes.
  prefs: []
  type: TYPE_NORMAL
- en: The processing cost to compute the statistics is paid initially. As we’ll see
    below, a tiny incremental cost can be associated with any change to the underlying
    data.
  prefs: []
  type: TYPE_NORMAL
- en: 7.3.3 How it works...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: This class encapsulates two complex algorithms, but doesn’t include any of the
    data for those algorithms. The data is kept separately, in a Counter object. We
    wrote a high-level specification for the processing and placed it in the __init__()
    method. Then we wrote methods to implement the processing steps that were specified.
    We can set as many attributes as are needed, making this a very flexible approach.
  prefs: []
  type: TYPE_NORMAL
- en: The advantage of this design is that the attribute values can be used repeatedly.
    The cost of computation for the mean and standard deviation is paid once; each
    time an attribute value is used, no further processing is required.
  prefs: []
  type: TYPE_NORMAL
- en: The disadvantage of this design is that any changes to the state of the underlying
    Counter object will render the CounterStatistics object’s state obsolete and incorrect.
    If, for example, we added a few hundred more data values, the mean and standard
    deviation would need to be recomputed. A design that eagerly computes values is
    appropriate when the underlying Counter object isn’t going to change.
  prefs: []
  type: TYPE_NORMAL
- en: 7.3.4 There’s more...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'If we need to do computations on stateful, mutable objects, we have several
    choices:'
  prefs: []
  type: TYPE_NORMAL
- en: Encapsulate the Counter object and make changes via the CounterStatistics class.
    This requires some care to expose enough methods of the data collection. We’ll
    defer this kind of design until Chapter [8](ch012.xhtml#x1-4520008).
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Use lazy computations. See the [Using properties for lazy attributes](ch011_split_001.xhtml#x1-43100010)
    recipe in this chapter.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Add a method to implement the computation of mean and standard deviation, so
    these can be recomputed after changing the underlying Counter object. This leads
    to refactoring the __init__() method to use this new computation method. We’ll
    leave this as an exercise for the reader.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Write documentation explaining the requirement to create a new CounterStatistics
    instance each time the underlying Counter object changes. This involves no code,
    merely an explicit statement of the constraints on the object’s state.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 7.3.5 See also
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In the [Extending a built-in collection – a list that does statistics](ch011_split_001.xhtml#x1-4250009)
    recipe, we’ll look at a different design approach where these new summary functions
    are used to extend a class definition.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: We’ll look at a different approach in the [Using properties for lazy attributes](ch011_split_001.xhtml#x1-43100010)
    recipe. This alternative recipe will use properties to compute the attributes
    as needed.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The wrap=extend design choice is also looked at in Chapter [8](ch012.xhtml#x1-4520008).
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 7.4 Using typing.NamedTuple for immutable objects
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In some cases, an object is a container of rather complex data, but doesn’t
    really do very much processing on that data. Indeed, in many cases, we’ll define
    a class that doesn’t require any unique method functions. These classes are relatively
    passive containers of data items, without a lot of processing.
  prefs: []
  type: TYPE_NORMAL
- en: In many cases, Python’s built-in container classes – list, set, or dict – can
    cover your use cases. The small problem is that the syntax for accessing an item
    in a dictionary or a list isn’t quite as elegant as the syntax for accessing an
    attribute of an object.
  prefs: []
  type: TYPE_NORMAL
- en: How can we create a class that allows us to use object.attribute syntax instead
    of the more elaborate object[’attribute’]?
  prefs: []
  type: TYPE_NORMAL
- en: 7.4.1 Getting ready
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'There are two cases for any kind of class design:'
  prefs: []
  type: TYPE_NORMAL
- en: Is it stateless (or immutable)? Does it embody attributes with values that never
    change? This is a good example of a NamedTuple.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Is it stateful (or mutable)? Will there be state changes for one or more attributes?
    This is the default for Python class definitions. An ordinary class is stateful.
    We can simplify creating stateful objects using the [Using dataclasses for mutable
    objects](ch011_split_000.xhtml#x1-4010005) recipe.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: We’ll define a class to describe simple playing cards that have a rank and a
    suit. Since a card’s rank and suit don’t change, we’ll create a small stateless
    class for this. The typing.NamedTuple class serves as a handy base class for these
    kinds of class definitions.
  prefs: []
  type: TYPE_NORMAL
- en: 7.4.2 How to do it...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'We’ll define stateless objects as a subclass of typing.NamedTuple:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Define the class name as an extension to NamedTuple. Include the attributes
    with their individual type hints:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Here’s how we can use this class definition to create Card objects:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: 'We’ve created a new class, named Card, which has two attribute names: rank
    and suit. After defining the class, we can create an instance of the class. We
    built a single Card object, eight_hearts, with a rank of eight and a suit of ♡.'
  prefs: []
  type: TYPE_NORMAL
- en: We can refer to attributes of this object with their name or their position
    within the tuple. When we use eight_hearts.rank or eight_hearts[0], we’ll see
    the value of the rank attribute because this attribute is defined first in the
    sequence of attribute names.
  prefs: []
  type: TYPE_NORMAL
- en: 'This kind of object is immutable. Here’s an example of attempting to change
    the instance attributes:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: We attempted to change the suit attribute of the eight_hearts object. This raised
    an AttributeError exception showing that instances of NamedTuple are immutable.
  prefs: []
  type: TYPE_NORMAL
- en: A tuple can contain objects of any type.
  prefs: []
  type: TYPE_NORMAL
- en: When a tuple contains mutable items, like lists, sets, or dictionaries, those
    objects remain mutable.
  prefs: []
  type: TYPE_NORMAL
- en: Only the top-level containing tuple is immutable. Lists, sets, or dictionaries
    within a tuple are mutable.
  prefs: []
  type: TYPE_NORMAL
- en: 7.4.3 How it works...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The typing.NamedTuple class lets us define a new subclass that has a well-defined
    list of attributes. A number of methods are created automatically to provide a
    minimal level of Python behavior. We can see an instance will display a readable
    text representation showing the values of the various attributes.
  prefs: []
  type: TYPE_NORMAL
- en: In the case of a NamedTuple subclass, the behavior is based on the way a built-in
    tuple instance works. The order of the attributes defines the comparison between
    tuples. Our definition of Card, for example, lists the rank attribute first. This
    means that we can easily sort cards by rank. For two cards of equal rank, the
    suits will be sorted into order. Because a NamedTuple is also a tuple, it works
    well as a member of a set or a key for a dictionary.
  prefs: []
  type: TYPE_NORMAL
- en: The two attributes, rank and suit in this example, are named as part of the
    class definition, but are implemented as instance variables. A variation on the
    tuple’s __new__() method is created for us. This method has two parameters matching
    the instance variable names. The automatically created method will assign argument
    values to the instance variables when the object is created.
  prefs: []
  type: TYPE_NORMAL
- en: 7.4.4 There’s more...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'We can add methods to this class definition. For example, if each card has
    a number of points, we might want to extend the class to look like this example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: We’ve written a CardsPoints class with a points() method that returns the points
    assigned to each rank. This point rule applies to games like Cribbage, not to
    games like Blackjack.
  prefs: []
  type: TYPE_NORMAL
- en: Because this is a tuple, the methods cannot add new attributes or change the
    attributes. In some cases, we build complex tuples from other tuples.
  prefs: []
  type: TYPE_NORMAL
- en: 7.4.5 See also
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In the [Designing classes with lots of processing](ch011_split_000.xhtml#x1-3890003)
    recipe, we looked at a class that is entirely processing and almost no data. It
    acts as the polar opposite of this class.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 7.5 Using dataclasses for mutable objects
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'We’ve noted two general kinds of objects in Python:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Immutable: During design, we’ll ask if something has attributes with values
    that never change. If the answer is yes, see the [Using typing.NamedTuple for
    immutable objects](ch011_split_000.xhtml#x1-3950004) recipe, which offers a way
    to build class definitions for immutable objects.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Mutable: Will there be state changes for one or more attributes? In this case,
    we can either build a class from the ground up, or we can leverage the @dataclass
    decorator to create a class definition from a few attributes and type hints. This
    case is the focus of this recipe.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: How can we leverage the dataclasses library to help design mutable objects?
  prefs: []
  type: TYPE_NORMAL
- en: 7.5.1 Getting ready
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: We’ll look closely at a mutable object with an internal state to represent a
    hand of cards. While individual cards are immutable, they can be inserted into
    a hand and removed from a hand. In a game like Cribbage, the hand has a number
    of state changes. Initially, six cards are dealt to both players. The players
    will each lay away a pair of cards to create the crib. The remaining four cards
    are then played alternately to create scoring opportunities. The hands are then
    counted in isolation, with a slightly different mix of scoring opportunities.
    The dealer gets the score from counting the cards in the crib as an extra hand.
    (Yes, it’s unfair initially, but the deal alternates, so it’s eventually fair.)
  prefs: []
  type: TYPE_NORMAL
- en: We’ll look at a simple collection to hold the cards and discard two that form
    the crib.
  prefs: []
  type: TYPE_NORMAL
- en: 7.5.2 How to do it...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'To define data classes, we’ll import the @dataclass decorator:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Define the new class using the @dataclass decorator:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Define the various attributes with appropriate type hints. For this example,
    we’ll expect a player to have a collection of cards represented by list[CardPoints].
    Because each card is unique, we could also use a set[CardPoints] type hint:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Define any methods that change the state of the object:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Here’s the complete class definition, properly indented:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs: []
  type: TYPE_PRE
- en: This definition provides a single instance variable, self.cards, that can be
    used by any method that is written. Because we provided a type hint, the mypy
    program can check the class to be sure that it is being used properly.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here’s how it looks when we create an instance of this CribbageHand class:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE37]'
  prefs: []
  type: TYPE_PRE
- en: 'In the following example, the player decided (perhaps unwisely) to lay away
    the 3♢ and A♠ cards for the crib:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE38]'
  prefs: []
  type: TYPE_PRE
- en: After the to_crib() method removed two cards from the hand, the remaining four
    cards were displayed. Another list comprehension was created with the point values
    of the remaining four cards.
  prefs: []
  type: TYPE_NORMAL
- en: 7.5.3 How it works...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The @dataclass decorator helps us define a class with several useful methods
    as well as a list of attributes drawn from the named variables and their type
    hints. We can see that an instance displays a readable text representation showing
    the values of the various attributes.
  prefs: []
  type: TYPE_NORMAL
- en: The attributes are named as part of the class definition, but are actually implemented
    as instance variables. In this example, there’s only one attribute, cards. A very
    sophisticated __init__() method is created for us. In this example, it will have
    a parameter that matches the name of each instance variable and will assign the
    argument value to a matching instance variable.
  prefs: []
  type: TYPE_NORMAL
- en: 'The @dataclass decorator has a number of options to help us choose what features
    we want in the class. Here are the options we can select from and the default
    settings:'
  prefs: []
  type: TYPE_NORMAL
- en: 'init=True: By default, an __init__() method will be created with parameters
    to match the instance variables.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'repr=True: By default, a __repr__() method will be created to return a string
    showing the state of the object.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'eq=True: By default, the __eq__() and __ne__() methods are provided. These
    methods implement the == and != operators.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'order=False: The __lt__(), __le__(), __gt__(), and __ge__() methods are not
    created automatically. These methods implement the <, <=, >, and >= operators.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'unsafe_hash=False: Normally, mutable objects do not have hash values, and cannot
    be used as keys for dictionaries or elements of a set. It’s possible to have a
    __hash__() method added automatically, but this is rarely a sensible choice for
    mutable objects, which is why the option is called an ”unsafe” hash.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'frozen=False: This creates an immutable object. See the [Using frozen dataclasses
    for immutable objects](ch011_split_000.xhtml#x1-4070006) recipe in this chapter
    for more details.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Because a great deal of code is written for us, we can focus on the attributes
    of the class definition. We can write the methods that are truly distinctive and
    avoid writing ”boilerplate” methods that have obvious definitions.
  prefs: []
  type: TYPE_NORMAL
- en: 7.5.4 There’s more...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: A hand of cards requires an initialization method to provide the collection
    of Card objects. A default __init__() method can populate the collection.
  prefs: []
  type: TYPE_NORMAL
- en: Consider creating a deck of cards, in contrast to a hand of cards. The initial
    deck of cards is an example of a dataclass that doesn’t need an initialization
    method to set the instance variables. Instead, a deck of cards needs a customized
    __init__() method without any parameters; it always creates the same collection
    of 52 Card objects. This means we’ll use init=False in the @dataclass decorator
    to define this method for a Deck class definition.
  prefs: []
  type: TYPE_NORMAL
- en: The general pattern for @dataclass definitions is to provide class-level names,
    which are used to both define the instance variables and also create the initialization
    method, __init__(). This covers a common use case for stateful objects.
  prefs: []
  type: TYPE_NORMAL
- en: In some cases, however, we want to define a class-level variable that is not
    used to create instance variables, but will remain a class-level variable. This
    is done with the ClassVar type hint. A ClassVar type indicates a class-level variable
    that is not part of the instance variables or the __init__() method.
  prefs: []
  type: TYPE_NORMAL
- en: 'In the following example, we’ll create a class variable with a sequence of
    suit strings:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE39]'
  prefs: []
  type: TYPE_PRE
- en: This example class definition provides a class-level variable, SUITS, which
    is part of the Deck class. This variable is a tuple of the characters used to
    define the suits.
  prefs: []
  type: TYPE_NORMAL
- en: The cards variable has a hint claiming it will have the list[CardPoints] type.
    This information is used by the mypy program to confirm that the body of the __init__()
    method performs the proper initialization of this attribute. It also confirms
    that this attribute is used appropriately by other classes.
  prefs: []
  type: TYPE_NORMAL
- en: 7.5.5 See also
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: See the [Using typing.NamedTuple for immutable objects](ch011_split_000.xhtml#x1-3950004)
    recipe for a way to build class definitions for stateless objects.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The [Using a class to encapsulate data and processing](ch011_split_000.xhtml#x1-3770001)
    recipe covers techniques for building a class without the additional methods created
    by the @dataclass decorator.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 7.6 Using frozen dataclasses for immutable objects
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In the [Using typing.NamedTuple for immutable objects](ch011_split_000.xhtml#x1-3950004)
    recipe, we saw how to define a class that has a fixed set of attributes. The attributes
    can be checked by the mypy program to ensure that they’re being used properly.
    In some cases, we might want to make use of the slightly more flexible dataclass
    to create an immutable object.
  prefs: []
  type: TYPE_NORMAL
- en: One potential reason for using a dataclass is because it can have more complex
    field definitions than a NamedTuple subclass. Another potential reason is the
    ability to customize the initialization and the hashing function that is created.
    Because a NamedTuple is essentially a tuple, there’s limited ability to fine-tune
    the behavior of the instances in this class.
  prefs: []
  type: TYPE_NORMAL
- en: 7.6.1 Getting ready
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: We’ll revisit the idea of defining simple playing cards with rank and suit.
    The rank can be modeled by an integer between 1 (ace) and 13 (king.) The suit
    can be modeled by a single Unicode character from the set {’♠’, ’♡’, ’♢’, ’♣’}.
    Since a card’s rank and suit don’t change, we’ll create a small, frozen dataclass
    for this.
  prefs: []
  type: TYPE_NORMAL
- en: 7.6.2 How to do it...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'From the dataclasses module, import the dataclass decorator:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE40]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Start the class definition with the @dataclass decorator, using the frozen=True
    option to ensure that the objects are immutable. We’ve also included order=True
    so that the comparison operators are defined, allowing instances of this class
    to be sorted into order:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE41]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Provide the attribute names and type hints for the attributes of each instance
    of this class:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE42]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'We can use these objects in code as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE43]'
  prefs: []
  type: TYPE_PRE
- en: 'We’ve created an instance of the Card class with a specific value for the rank
    and suit attributes. Because the object is immutable, any attempt to change the
    state will result in an exception that looks like the following example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE44]'
  prefs: []
  type: TYPE_PRE
- en: This shows an attempt to change an attribute of a frozen dataclass instance.
    The dataclasses.FrozenInstanceError exception is raised to signal that this kind
    of operation is not permitted.
  prefs: []
  type: TYPE_NORMAL
- en: 7.6.3 How it works...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: This @dataclass decorator adds a number of built-in methods to a class definition.
    As we noted in the [Using dataclasses for mutable objects](ch011_split_000.xhtml#x1-4010005)
    recipe, there are a number of features that can be enabled or disabled. Each feature
    may lead us to include one or several individual methods in the class definition.
  prefs: []
  type: TYPE_NORMAL
- en: 7.6.4 There’s more...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The @dataclass initialization method is quite sophisticated. We’ll look at one
    feature that’s sometimes handy for defining optional attributes.
  prefs: []
  type: TYPE_NORMAL
- en: Consider a class that can hold a hand of cards. While the common use case provides
    a set of cards to initialize the hand, we can also have hands that might be built
    incrementally, starting with an empty collection and adding cards during the game.
  prefs: []
  type: TYPE_NORMAL
- en: 'We can define this kind of optional attribute using the field() function from
    the dataclasses module. The field() function lets us provide a function to build
    default values, called default_factory. We’d use it as shown in the following
    example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE45]'
  prefs: []
  type: TYPE_PRE
- en: 'The Hand dataclass has a single attribute, cards, which is a list of CardPoints
    objects. The field() function provides a default factory: in the event no initial
    value is provided, the list() function will be executed to create a new, empty
    list.'
  prefs: []
  type: TYPE_NORMAL
- en: 'We can create two kinds of hands with this dataclass. Here’s the conventional
    example, where we deal six cards:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE46]'
  prefs: []
  type: TYPE_PRE
- en: 'The Hands() type expects a single attribute, matching the definition of the
    attributes in the class. This is optional, and we can build an empty hand as shown
    in this example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE47]'
  prefs: []
  type: TYPE_PRE
- en: In this example, we’ve created a Hand() instance with no argument values, assigned
    to the crib variable. Because the cards attribute was defined with a field that
    provided a default_factory, the list() function will be used to create an empty
    list for the cards attribute.
  prefs: []
  type: TYPE_NORMAL
- en: 7.6.5 See also
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The [Using dataclasses for mutable objects](ch011_split_000.xhtml#x1-4010005)
    recipe covers some additional topics on using dataclasses to avoid some of the
    complexities of writing class definitions.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 7.7 Optimizing small objects with __slots__
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The general case for an object allows a dynamic collection of attributes. There’s
    a special case for an object with a fixed collection of attributes based on the
    tuple class. We looked at both of these in the [Using typing.NamedTuple for immutable
    objects](ch011_split_000.xhtml#x1-3950004) recipe.
  prefs: []
  type: TYPE_NORMAL
- en: There’s a middle ground. We can also define an object with a fixed number of
    attributes, but the values of the attributes can be changed. By changing the class
    from an unlimited collection of attributes to a fixed set of attributes, it turns
    out that we can also save memory and processing time.
  prefs: []
  type: TYPE_NORMAL
- en: How can we create optimized classes with a fixed set of attributes?
  prefs: []
  type: TYPE_NORMAL
- en: 7.7.1 Getting ready
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Generally, Python allows adding attributes to an object. This can be undesirable,
    particularly when working with a large number of objects. The flexibility of the
    way most class definitions use a dictionary has a cost in memory use. Using specific
    __slots__ names limits the class to the named attributes, saving memory.
  prefs: []
  type: TYPE_NORMAL
- en: 'The card game of Cribbage, for example, has a few components:'
  prefs: []
  type: TYPE_NORMAL
- en: A deck of cards.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Two players, who will alternate in the role of dealer and opponent.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: This small domain of things seems like a candidate for a class definition. Each
    player has a hand of cards and a score. The player’s role is an interesting complication.
    There are import differences in the two roles.
  prefs: []
  type: TYPE_NORMAL
- en: The player who is the dealer gets the crib cards.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: If the starter card is a Jack, the player in the dealer role gets points for
    this.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The opponent plays the first card.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The opponent counts their hand first.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The dealer plays from their hand, but counts their hand and the crib.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The specific order of play and counting hands is important because the first
    player to pass 120 points is the winner, no matter what state the game is in.
  prefs: []
  type: TYPE_NORMAL
- en: It seems like the Cribbage game includes a deck of cards and two players. The
    crib – which belongs to the dealer – can be seen as a feature of the game overall.
    We’ll look at ways to switch the role between dealer and opponent when a new round
    of play starts.
  prefs: []
  type: TYPE_NORMAL
- en: 7.7.2 How to do it...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'We’ll leverage the __slots__ special name when creating the class:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Define the class with a descriptive name:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE48]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Define the list of attribute names. This identifies the only two attributes
    that are allowed for instances of this class. Any attempt to add another attribute
    will raise an AttributeError exception:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE49]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Add an initialization method. This must create instance variables for the named
    slots:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE50]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: The Deck class definition is shown in the [Using dataclasses for mutable objects](ch011_split_000.xhtml#x1-4010005)
    recipe in this chapter.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Add methods to update the collection. For this example, we’ve defined a method
    to switch roles.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE51]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Here’s how we can use this class to build a hand of cards. We’ll need the definition
    of the Card class based on the example in the [Using typing.NamedTuple for immutable
    objects](ch011_split_000.xhtml#x1-3950004) recipe:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE52]'
  prefs: []
  type: TYPE_PRE
- en: The initial Cribbage object was created with a Deck and two Player instances.
    These three objects filled in the the deck and players slots. The __init__() method
    then randomized the players, making one of them the dealer and the other the opponent.
    The crib was initialized to an empty Hand instance.
  prefs: []
  type: TYPE_NORMAL
- en: The new_deal() method makes a number of changes to the state of the Cribbage
    instance. This is revealed when the dealer and opponent attributes are examined.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here’s what happens if we try to create a new attribute:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE53]'
  prefs: []
  type: TYPE_PRE
- en: We attempted to create an attribute named some_other_attribute on the Cribbage
    object, c. This raised an AttributeError exception. Using __slots__ means that
    new attributes cannot be added to an instance of the class.
  prefs: []
  type: TYPE_NORMAL
- en: 7.7.3 How it works...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: When we create an object instance, the steps in the process are defined in part
    by the object’s class and the built-in type() function. Implicitly, a class has
    a special __new__() method that handles the internal house-keeping required to
    create a new, empty object. After this, the __init__() method creates and initializes
    the attributes.
  prefs: []
  type: TYPE_NORMAL
- en: 'Python has three essential paths for creating instances of a class:'
  prefs: []
  type: TYPE_NORMAL
- en: The default behavior, defined by the built-ins object and type(), is used when
    we define a class without doing anything unusual. Each instance contains a __dict__
    attribute that is used to hold all other attributes. Because the object’s attributes
    are kept in a dictionary, we can add, change, and delete attributes freely. This
    flexibility requires the use of additional memory for the dictionary object inside
    each instance.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The __slots__ behavior avoids creating the __dict__ attribute. Because the object
    has only the attributes named in the __slots__ sequence, we can’t add or delete
    attributes. We can change the values of the defined attributes. This lack of flexibility
    means that less memory is used for each object.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The subclass of tuple behavior defines immutable objects. An easy way to create
    these classes is with typing.NamedTuple as a parent class. Once built, the instances
    are immutable and cannot be changed. While it’s possible to directly subclass
    tuple, the extra features of a NamedTuple seem to make this ideal.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A large application might be constrained by the amount of memory used, and switching
    the class with the largest number of instances to __slots__ can lead to an improvement
    in performance.
  prefs: []
  type: TYPE_NORMAL
- en: 7.7.4 There’s more...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: It’s possible to tailor the way the __new__() method works to replace the default
    __dict__ attribute with a different kind of dictionary. This is an advanced technique
    because it exposes the inner workings of classes and objects.
  prefs: []
  type: TYPE_NORMAL
- en: Python relies on a metaclass to create instances of a class. The default metaclass
    is the type class. The idea is that the metaclass provides a few pieces of functionality
    that are used to create each object. Once the empty object has been created, then
    the class’s __init__() method will initialize the empty object.
  prefs: []
  type: TYPE_NORMAL
- en: Generally, a metaclass will provide a definition of __new__(), and perhaps __prepare__(),
    if there’s a need to customize the object. There’s a widely used example in the
    Python Language Reference document that tweaks the namespace used to create a
    class.
  prefs: []
  type: TYPE_NORMAL
- en: For more details, see [https://docs.python.org/3/reference/datamodel.html#metaclass-example](https://docs.python.org/3/reference/datamodel.html#metaclass-example).
  prefs: []
  type: TYPE_NORMAL
- en: 7.7.5 See also
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The more common cases of an immutable object or a completely flexible object
    are covered in the [Using typing.NamedTuple for immutable objects](ch011_split_000.xhtml#x1-3950004)
    recipe.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 7.8 Using more sophisticated collections
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Python has a wide variety of built-in collections. In Chapter [4](ch008_split_000.xhtml#x1-2240004),
    we looked at them closely. In the [Choosing a data structure](ch008_split_000.xhtml#x1-2250001)
    recipe, we provided a kind of decision tree to help locate the appropriate data
    structure from the available choices.
  prefs: []
  type: TYPE_NORMAL
- en: When we consider built-in types and other data structures in the standard library,
    we have more choices, and more decisions to make. How can we choose the right
    data structure for our problem?
  prefs: []
  type: TYPE_NORMAL
- en: 7.8.1 Getting ready
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Before we put data into a collection, we’ll need to consider how we’ll gather
    the data, and what we’ll do with the collection once we have it. The big question
    is always how we’ll identify a particular item within the collection. We’ll look
    at a few key questions that we need to answer to help select a proper collection
    for our needs.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here’s an overview of some of the alternative collections. The collections
    module contains a number of variations on the built-in collections. These include
    the following:'
  prefs: []
  type: TYPE_NORMAL
- en: 'deque: A double-ended queue. This is a mutable sequence with optimizations
    for pushing and popping from each end. Note that the class name starts with a
    lowercase letter; this is atypical for Python.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'defaultdict: A mapping that can provide a default value for a missing key.
    Note that the class name starts with a lowercase letter; this is atypical for
    Python.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Counter: A mapping that is designed to count the number of occurrences of distinct
    keys. This is sometimes called a multiset or a bag.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'ChainMap: A mapping that combines several dictionaries into a single mapping.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The heapq module includes a priority queue implementation. This is a specialized
    library that leverages the built-in list sequence to maintain items in a sorted
    order.
  prefs: []
  type: TYPE_NORMAL
- en: The bisect module includes methods for searching a sorted list. This creates
    some overlap between the dictionary features and the list features.
  prefs: []
  type: TYPE_NORMAL
- en: Additionally, there’s an OrderedDict class in the collections module. Starting
    with Python 3.7, the dictionary keys for an ordinary dictionary are retained in
    the order they were created, making the OrderedDict class redundant.
  prefs: []
  type: TYPE_NORMAL
- en: 7.8.2 How to do it...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'There are a number of questions we need to answer to decide if we need a library
    data collection instead of one of the built-in collections:'
  prefs: []
  type: TYPE_NORMAL
- en: Is the structure a buffer between the producer and the consumer? Does some part
    of the algorithm produce data items and another part consume the data items?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: A queue is used for First-In-First-Out (FIFO) processing. Items are inserted
    at one end and consumed from the other end. We can use list.append() and list.pop(0)
    to simulate this, though collections.deque will be more efficient; we can use
    deque.append() and deque.popleft().
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: A stack is used for Last-In-First-Out (LIFO) processing. Items are inserted
    and consumed from the same end. We can use list.append() and list.pop() to simulate
    this, though collections.deque will be more efficient; we can use deque.append()
    and deque.pop().
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: A priority queue (or heap queue) keeps the queue sorted in some order, distinct
    from the arrival order. We can try to simulate this by using the list.append(),
    list.sort(key=lambda x:x.priority), and list.pop(-1) operations to keep items
    in priority order. Performing a sort after each insert can make it inefficient.
    Using the heapq module can be more efficient. The heapq module has functions for
    creating and updating heaps.
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: How do we want to deal with missing keys from a dictionary?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Raise an exception. This is the way the built-in dict class works.
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: Create a default item. This is how collections.defaultdict works. We must provide
    a function that returns the default value. Common examples include defaultdict(int)
    and defaultdict(float) to use a default value of 0 or 0.0\. We can also use defauldict(list)
    and defauldict(set) to create dictionary-of-list or dictionary-of-set structures.
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: The defaultdict(int) used to create a dictionary for counting items is so common
    that the collections.Counter class does exactly this.
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: How do we want to handle the order of keys in a dictionary? Generally, Python
    above version 3.6 keeps the keys in insertion order. If we want a different order,
    we’ll have to sort them manually.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: How will we build the dictionary?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: We have a simple algorithm to create items. In this case, a built-in dict object
    may be sufficient.
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: We have multiple dictionaries that will need to be merged. This can happen when
    reading configuration files. We might have an individual configuration, a system-wide
    configuration, and a default application configuration that all need to be merged
    into a single dictionary using a ChainMap collection.
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: 7.8.3 How it works...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'There are two principle resource constraints on data processing:'
  prefs: []
  type: TYPE_NORMAL
- en: Storage
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Time
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'All of our programming must respect these constraints. In most cases, the two
    are inverses: anything we do to reduce storage use tends to increase processing
    time, and anything we do to reduce processing time increases storage use. Algorithm
    and data structure design seeks to find an optimal balance among the constraints.'
  prefs: []
  type: TYPE_NORMAL
- en: 'The time aspect is formalized via a complexity metric. There are several ways
    to describe the complexity of an algorithm:'
  prefs: []
  type: TYPE_NORMAL
- en: Complexity O(1) doesn’t change with the volume of data. For some collections,
    the actual overall long-term average is nearly O(1) with minor exceptions. Many
    dictionary operations are O(1). Appending to a list, and popping from the end
    of a list is very fast, making a LIFO stack very efficient. Popping from the front
    of a list is O(n), making a FIFO queue built from a simple list rather expensive;
    the deque class and heapq module remedy this with better designs.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Complexity described as O(log n) means the cost grows more slowly than the volume
    of data, n. The bisect module lets us search a sorted list more efficiently than
    the list class by dividing the list into halves. Note that sorting the list in
    the first place is O(nlog n), so there needs to be a great many searches to amortize
    the cost of sorting.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Complexity described as O(n) means the cost grows as the volume of data, n,
    grows. Finding an item in a list has this complexity. If the item is at the end
    of the list, all n items must be checked. Sets and mappings don’t have this problem,
    and have nearly O(1) complexity.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A complexity described as O(nlog n) grows more quickly than the volume of data.
    Sorting a list tends to have this complexity. For this reason, it helps to minimize
    or eliminate sorting large volumes of data.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: There are even worse cases. Some algorithms have a complexity of O(n²), O(2^n),
    or even O(n!). We’d like to avoid these kinds of very expensive algorithms through
    clever design and good choice of data structure. These can be deceptive in practice.
    We may be able to work out an O(2^n) algorithm that seems to perform well on small
    test cases where n is 3 or 4\. In these cases, there are only 8 or 16 combinations.
    If real data involves 70 items, the number of combinations is on the order of
    10^(22), a number with 22 digits.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The various data structures available in the standard library reflect a number
    of time and storage trade-offs.
  prefs: []
  type: TYPE_NORMAL
- en: 7.8.4 There’s more...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'As a concrete and extreme example, let’s look at searching a web log file for
    a particular sequence of events. We have two overall design strategies:'
  prefs: []
  type: TYPE_NORMAL
- en: Read all of the events into a list structure with something like file.read().splitlines().
    We can then use a for statement to iterate through the list looking for the combination
    of events. While the initial read may take some time, the search will be very
    fast because the log is all in memory.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Read and process each individual event from a log file. When a log entry is
    part of the searched-for pattern, it makes sense to save only this event in a
    subset of the log. We might use a defaultdict with a session ID or client IP address
    as the key and a list of events as the value. This will take longer to read the
    logs, but the resulting structure in memory will be much smaller than a list of
    all log entries.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The first algorithm, reading everything into memory, can be wildly impractical.
    On a large web server, the logs might involve hundreds of gigabytes of data. Logs
    can easily be too large to fit into any computer’s memory.
  prefs: []
  type: TYPE_NORMAL
- en: 'The second approach has a number of alternative implementations:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Single process: The general approach to most of the Python recipes here assumes
    that we’re creating an application that runs as a single process.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Multiple processes: We might expand the row-by-row search into a multi-processing
    application using the multiprocessing or concurrent.futures packages. These packages
    let us create a collection of worker processes, each of which can process a subset
    of the available data and return the results to a consumer that combines the results.
    On a modern multiprocessor, multi-core computer, this can be a very effective
    use of resources.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Multiple hosts: The extreme case requires multiple servers, each of which handles
    a subset of the data. This requires more elaborate coordination among the hosts
    to share result sets. Generally, it can work out well to use a framework such
    as Dask or Spark for this kind of processing. While the multiprocessing module
    is quite sophisticated, tools like Dask are even more suitable for large-scale
    computation.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: We’ll often decompose a large search into map and reduce processing. The map
    phase applies some processing or filtering to every item in the collection. The
    reduce phase combines map results into summary or aggregate objects. In many cases,
    there is a complex hierarchy of Map-Reduce stages applied to the results of previous
    Map-Reduce operations.
  prefs: []
  type: TYPE_NORMAL
- en: 7.8.5 See also
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: See the [Choosing a data structure](ch008_split_000.xhtml#x1-2250001) recipe
    in Chapter [4](ch008_split_000.xhtml#x1-2240004), for a foundational set of decisions
    for selecting data structures.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 7.9 Extending a built-in collection – a list that does statistics
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In the [Designing classes with lots of processing](ch011_split_000.xhtml#x1-3890003)
    recipe, we looked at a way to distinguish between a complex algorithm and a collection.
    We showed how to encapsulate the algorithm and the data into separate classes.
    The alternative design strategy is to extend the collection to incorporate a useful
    algorithm.
  prefs: []
  type: TYPE_NORMAL
- en: How can we extend Python’s built-in collections? How can we add features to
    the built-in list?
  prefs: []
  type: TYPE_NORMAL
- en: 7.9.1 Getting ready
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: We’ll create a sophisticated list class where each instance can compute the
    sums and averages of the items in the list. This will require an application to
    put only numbers in the list; otherwise, there will be ValueError exceptions raised.
  prefs: []
  type: TYPE_NORMAL
- en: 'We’re going to show methods that explicitly use generator expressions as places
    where additional processing can be included. Rather than use sum(self), we’re
    going to emphasize sum(v for v in self) because there are two common future extensions:
    sum(m(v) for v in self) and sum(v for v in self if f(v)). These are the mapping
    and filtering alternatives where a mapping function, m(v), is applied to each
    item; or a filter function, f(v), is applied to pass or reject each item. Computing
    a sum of squares, for example, applies a mapping to compute the square of each
    value before summing.'
  prefs: []
  type: TYPE_NORMAL
- en: 7.9.2 How to do it...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Pick a name for the list that also does simple statistics. Define the class
    as an extension to the built-in list class:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE54]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: We can stick with a generic type hint of list. This is often too broad. Since
    the structure will contain numbers, it’s more sensible to use the narrower hint
    of list[float].
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: When working with numeric data, mypy treats the float type as a superclass for
    both float and int, saving us from having to define an explicit Union[float, int].
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Define the additional processing as methods. The self variable will be an object
    that has inherited all of the attributes and methods from the superclass. In this
    case, the superclass is list[float]. We’ll use a generator expression here as
    a place where future changes might be incorporated. Here’s a sum() method:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE55]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Here’s another method that we often apply to a list. This counts items and
    returns the size. We’ve used a generator expression to make it easy to add mappings
    or filter criteria if that ever becomes necessary:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE56]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Here’s the mean method:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE57]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Here are some additional methods. The sum2() method computes the sum of squares
    of values in the list. This is used to compute variance. The variance is then
    used to compute the standard deviation of the values in the list. Unlike with
    the previous sum() and count() methods, where there’s no mapping, in this case,
    the generator expression includes a mapping transformation:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE58]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'The StatsList class definition inherits all the features of a list object.
    It is extended by the methods that we added. Here’s an example of creating an
    instance in this collection:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE59]'
  prefs: []
  type: TYPE_PRE
- en: 'We’ve created two StatsList objects, subset1 and data, from literal lists of
    objects. We used the extend() method, inherited from the list superclass, to combine
    the two objects. Here’s the resulting object:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE60]'
  prefs: []
  type: TYPE_PRE
- en: 'Here’s how we can use the additional methods that we defined on this object:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE61]'
  prefs: []
  type: TYPE_PRE
- en: We’ve displayed the results of the mean() and variance() methods. All the features
    of the built-in list class are also present in our extension.
  prefs: []
  type: TYPE_NORMAL
- en: 7.9.3 How it works...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: One of the essential features of class definition is the concept of inheritance.
    When we create a superclass-subclass relationship, the subclass inherits all of
    the features of the superclass. This is sometimes called the generalization-specialization
    relationship. The superclass is a more generalized class; the subclass is more
    specialized because it adds or modifies features.
  prefs: []
  type: TYPE_NORMAL
- en: All of the built-in classes can be extended to add features. In this example,
    we added some statistical processing that created a subclass that’s a specialized
    kind of list of numbers.
  prefs: []
  type: TYPE_NORMAL
- en: 'There’s an important tension between the two design strategies:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Extending: In this case, we extended a class to add features. The features
    are deeply entrenched with this single data structure, and we can’t easily use
    them for a different kind of sequence.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Wrapping: In designing classes with lots of processing, we kept the processing
    separate from the collection. This leads to some more complexity in juggling two
    objects.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: It’s difficult to suggest that one of these is inherently superior to the other.
    In many cases, we’ll find that wrapping may have an advantage because it seems
    to be a better fit to the SOLID design principles. However, there will often be
    cases where it’s appropriate to extend a built-in collection.
  prefs: []
  type: TYPE_NORMAL
- en: 7.9.4 There’s more...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The idea of generalization can lead to superclasses that are abstractions. Because
    an abstract class is incomplete, it requires a subclass to extend it and provide
    missing implementation details. We can’t make an instance of an abstract class
    because it would be missing features that make it useful.
  prefs: []
  type: TYPE_NORMAL
- en: As we noted in the [Choosing a data structure](ch008_split_000.xhtml#x1-2250001)
    recipe in Chapter [4](ch008_split_000.xhtml#x1-2240004), there are abstract superclasses
    for all of the built-in collections. Rather than starting from a concrete class,
    we can also start our design from an abstract base class.
  prefs: []
  type: TYPE_NORMAL
- en: 'We could, for example, start a class definition like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE62]'
  prefs: []
  type: TYPE_PRE
- en: 'In order to finish this class, we’ll need to provide an implementation for
    a number of special methods:'
  prefs: []
  type: TYPE_NORMAL
- en: __getitem__()
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: __setitem__()
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: __delitem__()
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: __iter__()
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: __len__()
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Each of these methods is missing from the abstract class; they have no concrete
    implementation in the Mapping class. Once we’ve provided workable implementations
    for each method, we can then make instances of the new subclass.
  prefs: []
  type: TYPE_NORMAL
- en: 7.9.5 See also
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In the [Designing classes with lots of processing](ch011_split_000.xhtml#x1-3890003)
    recipe, we took a different approach. In that recipe, we left the complex algorithms
    in a separate class.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 7.10 Using properties for lazy attributes
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In the [Designing classes with lots of processing](ch011_split_000.xhtml#x1-3890003)
    recipe, we defined a class that eagerly computed a number of attributes of the
    data in a collection. The idea there was to compute the values as soon as possible,
    so that the attributes would have no further computational cost.
  prefs: []
  type: TYPE_NORMAL
- en: We described this as eager processing, since the work was done as soon as possible.
    The other approach is lazy processing, where the work is done as late as possible.
  prefs: []
  type: TYPE_NORMAL
- en: What if we have values that are used rarely, and are very expensive to compute?
    What can we do to minimize the up-front computation, and only compute values when
    they are truly needed?
  prefs: []
  type: TYPE_NORMAL
- en: 7.10.1 Getting ready...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'For background, see the NIST Aerosol Particle Size case study: [https://www.itl.nist.gov/div898/handbook/pmc/section6/pmc62.htm](https://www.itl.nist.gov/div898/handbook/pmc/section6/pmc62.htm)'
  prefs: []
  type: TYPE_NORMAL
- en: See the [Designing classes with lots of processing](ch011_split_000.xhtml#x1-3890003)
    recipe in this chapter for more details on this dataset. Rather than work with
    the raw data, it can help to work with summary information contained in a Counter
    object. The recipe shows a mapping from particle size to number to a count of
    times the particular size was measured.
  prefs: []
  type: TYPE_NORMAL
- en: 'We want to compute some statistics on this Counter. We have two overall strategies
    for doing this:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Extend: We covered this in detail in the [Extending a built-in collection –
    a list that does statistics](ch011_split_001.xhtml#x1-4250009) recipe, and we
    will look at other examples of extending a class in Chapter [8](ch012.xhtml#x1-4520008).'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Wrap: We can wrap the Counter object in another class that provides just the
    features we need. We’ll look at this in Chapter [8](ch012.xhtml#x1-4520008).'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A common variation on wrapping creates a statistical computation object separate
    from the data collection object. This variation on wrapping often leads to an
    elegant solution.
  prefs: []
  type: TYPE_NORMAL
- en: 'No matter which class architecture we choose, we also have two ways to design
    the processing:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Eager: This means we’ll compute the statistics as soon as possible. This was
    the approach followed in the [Designing classes with lots of processing](ch011_split_000.xhtml#x1-3890003)
    recipe.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Lazy: This means we won’t compute anything until it’s required via a method
    function or property. In the [Extending a built-in collection – a list that does
    statistics](ch011_split_001.xhtml#x1-4250009) recipe, we added methods to a collection
    class. These additional methods are examples of lazy calculation. The statistical
    values are computed only when required.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The essential math for both designs is the same. The only question is when the
    computation is done.
  prefs: []
  type: TYPE_NORMAL
- en: 7.10.2 How to do it...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Define the class with a descriptive name:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE63]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Write the initialization method to include the object to which this object
    will be connected. We’ve defined a method function that takes a Counter object
    as an argument value. This Counter object is saved as part of the Counter_Statistics
    instance:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE64]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Define some useful helper methods. Each of these is decorated with @property
    to make it behave like a simple attribute:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE65]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Define the required methods for the various values. Here’s the calculation
    of the mean. This too is decorated with @property. The other methods can be referenced
    as if they are attributes, even though they are proper method functions:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE66]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Here’s how we can calculate the standard deviation. Note that we’ve been using
    math.sqrt(). Be sure to add the required import math statement in the Python module:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE67]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'To show how this works, we’ll apply an instance of this class to some summarized
    data. The repository of code for this book includes a data/binned.csv file that
    has the binned summary data. This data has three columns: size_code, size, and
    frequency. We’re only interested in size_code and frequency.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Here’s how we can build a suitable Counter object from this file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE68]'
  prefs: []
  type: TYPE_PRE
- en: We’ve used a dictionary comprehension to create a mapping from size_code to
    the frequency of that code value. This is then provided to the Counter class to
    build a Counter object named data from this existing summary.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here’s how we can analyze the Counter object:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE69]'
  prefs: []
  type: TYPE_PRE
- en: We provided the data object to create an instance of the LazyCounterStatistics
    class, the stats variable. When we print the value for the stats.mean property
    and the stats.stddev property, the methods are invoked to do the appropriate calculations
    of the various values.
  prefs: []
  type: TYPE_NORMAL
- en: The cost for the computation is not paid until a client object requests the
    stats.mean or stats.stddev property values. This will invoke a cascade of computation
    to compute these values.
  prefs: []
  type: TYPE_NORMAL
- en: When the underlying data is changed, the entire computation is performed again.
    This can be costly in the rare case of highly dynamic data. In the more common
    case of analyzing previously summarized data, this is quite efficient.
  prefs: []
  type: TYPE_NORMAL
- en: 7.10.3 How it works...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The idea of lazy calculation works out well when the value is used rarely. In
    this example, the count is computed twice as part of computing the variance and
    standard deviation.
  prefs: []
  type: TYPE_NORMAL
- en: A naïve lazy design may not be optimal in some cases when values are recomputed
    frequently. This is an easy problem to fix in general. We can always create additional
    local variables to cache intermediate results instead of recomputing them. We’ll
    look at this later in this recipe.
  prefs: []
  type: TYPE_NORMAL
- en: To make this class look like it has performed eager calculations, we used the
    @property decorator. This makes a method appear to be an attribute. This can only
    work for methods that have no argument values.
  prefs: []
  type: TYPE_NORMAL
- en: In all cases, an attribute that’s computed eagerly can be replaced by a lazy
    property. The principle reason for creating eager attribute variables is to optimize
    computation costs. In the case where a computed result may not always be used,
    a lazy property can avoid an expensive calculation.
  prefs: []
  type: TYPE_NORMAL
- en: 7.10.4 There’s more...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: There are some situations in which we can further optimize a property to limit
    the amount of additional computation that’s done when a value changes. This requires
    a careful analysis of the use cases in order to understand the pattern of updates
    to the underlying data.
  prefs: []
  type: TYPE_NORMAL
- en: 'In the situation where a collection is loaded with data and an analysis is
    performed, we can cache results to save computing them a second time. We might
    do something like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE70]'
  prefs: []
  type: TYPE_PRE
- en: This technique uses two attributes to save the results of the sum and count
    calculations, self._sum and self._count. These values will be computed once and
    returned as often as needed with no additional cost for recalculation.
  prefs: []
  type: TYPE_NORMAL
- en: The type hints show these attributes as being optional. Once the values for
    self._sum and self._count have been computed, the values are no longer optional,
    but will be present. We describe this to tools like mypy with the cast() type
    hint. This hint tells type-checking tools to consider self._sum as being a float
    object, not a float | None object. There’s no cost to this function as it does
    nothing; its purpose is to annotate the processing to show the design intent.
  prefs: []
  type: TYPE_NORMAL
- en: This caching optimization is helpful if the state of the raw_counter object
    never changes. In an application that updates the underlying Counter, this cached
    value would become out of date. That kind of application would need to reset the
    internal cache values of self._sum and self._count when the underlying Counter
    is updated.
  prefs: []
  type: TYPE_NORMAL
- en: 7.10.5 See also...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In the [Designing classes with lots of processing](ch011_split_000.xhtml#x1-3890003)
    recipe, we defined a class that eagerly computed a number of attributes. This
    represents a different strategy for managing the cost of the computation.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 7.11 Creating contexts and context managers
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'A number of Python objects behave like context managers. Some of the most visible
    examples are file objects. We generally use with path.open() as file: to process
    a file in a context that can guarantee the resources are released. In Chapter [2](ch006_split_000.xhtml#x1-840002),
    the [Managing a context using the with statement](ch006_split_001.xhtml#x1-15200011)
    recipe covers the basics of using a file-based context manager.'
  prefs: []
  type: TYPE_NORMAL
- en: How can we create our own classes that act as context managers?
  prefs: []
  type: TYPE_NORMAL
- en: 7.11.1 Getting ready
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: We’ll look at a function from Chapter [3](ch007_split_000.xhtml#x1-1610003),
    in the [Picking an order for parameters based on partial functions](ch007_split_001.xhtml#x1-1940006)
    recipe. This recipe introduced a function, haversine(), which has a context-like
    parameter used to adjust the answer from dimensionless radians to a useful unit
    of measure, such as kilometers, nautical miles, or US statute miles. In many ways,
    this distance factor is a kind of context, used to define the kinds of computations
    that are done.
  prefs: []
  type: TYPE_NORMAL
- en: 'What we want is to be able to use the with statement to describe an object
    that doesn’t change very quickly; indeed the change acts as a kind of boundary,
    defining the scope of computations. We might want to use code like the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE71]'
  prefs: []
  type: TYPE_PRE
- en: The Distance(r=NM) constructor provides the definition of the context, creating
    a new object, nm_dist, that has been configured to perform the required calculation
    in nautical miles. This can be used only within the body of the with statement.
  prefs: []
  type: TYPE_NORMAL
- en: This Distance class definition can be seen as creating a partial function, nm_dist().
    This function provides a fixed unit-of-measure parameter, r, for a number of following
    computations using the haversine() function.
  prefs: []
  type: TYPE_NORMAL
- en: There are a number of other ways to create partial functions, including a lambda
    object, the functools.partial() function, and callable objects. We looked at the
    partial function alternative in Chapter [3](ch007_split_000.xhtml#x1-1610003),
    in the [Picking an order for parameters based on partial functions](ch007_split_001.xhtml#x1-1940006)
    recipe.
  prefs: []
  type: TYPE_NORMAL
- en: 7.11.2 How to do it...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'A context manager class has two special methods that we need to define:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Start with a meaningful class name:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE72]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Define an initializer that creates any unique features of the context. In this
    case, we want to set the units of distance that are used:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE73]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Define the __enter__() method. This is called when the with statement block
    begins. The statement with Distance(r=NM) as nm_dist does two things. First, it
    creates the instance of the Distance class, then it calls the __enter__() method
    of that object to start the context. The return value from the __enter__() method
    is assigned to a local variable via the as clause. This isn’t always required.
    For simple cases, the context manager often returns itself. If this method needs
    to return an instance in the same class, note that the class hasn’t been fully
    defined yet, and the class name type hint must be provided as a string. For this
    recipe, we’ll return a function, with the type hint based on Callable:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE74]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Define the __exit__() method. When the context finishes, this method is invoked.
    This is where resources are released and cleanup can happen. In this example,
    nothing more needs to be done. The details of any exception are provided to this
    method; the method can silence the exception or allow it to propagate. If the
    return value from the __exit__() method is True, the exception is silenced. A
    return value of False or None will allow the exception to be seen outside the
    with statement:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE75]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Create a class (or define the methods of this class) that works within the
    context. In this case, the method will make use of a separately defined haversine()
    function from Chapter [3](ch007_split_000.xhtml#x1-1610003):'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE76]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Most context-manager classes require a fairly large number of imports:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE77]'
  prefs: []
  type: TYPE_PRE
- en: 'This class has been defined to work with objects of the class Point. This can
    be a NamedTuple, @dataclass, or some other class that provides the required two
    attributes. Here’s the NamedTuple definition:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE78]'
  prefs: []
  type: TYPE_PRE
- en: This class definition provides a class, Point, with the required attribute names.
  prefs: []
  type: TYPE_NORMAL
- en: 7.11.3 How it works...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The context manager relies on the with statement doing a large number of things.
  prefs: []
  type: TYPE_NORMAL
- en: 'We’ll put the following construct under a microscope:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE79]'
  prefs: []
  type: TYPE_PRE
- en: The first line creates an instance of the Distance class. This has a value for
    the r parameter equal to the constant NM, allowing us to do computations in nautical
    miles. The Distance instance is assigned to the nm_distance variable.
  prefs: []
  type: TYPE_NORMAL
- en: When the with statement starts execution, the context manager object is notified
    by having the __enter__() method executed. In this case, the value returned by
    the __enter__() method is a function, with the type Callable[[Point, Point], float].
    The function accepts two Point objects and returns a floating-point result. The
    as clause assigns this function object to the nm_calc name.
  prefs: []
  type: TYPE_NORMAL
- en: The print() function does its work using the nm_calc object. The object is a
    function that will compute a distance from two Point instances.
  prefs: []
  type: TYPE_NORMAL
- en: When the with statement finishes, the __exit__() method will be executed. For
    more complex context managers, this may involve closing files or releasing network
    connections. There are a great many kinds of context cleanup that might be necessary.
    In this case, there’s nothing that needs to be done to clean up the context.
  prefs: []
  type: TYPE_NORMAL
- en: This has the advantage of defining a fixed boundary in which the partial function
    is used. In some cases, the computation inside the context manager might involve
    a database or complex web services, leading to a more complex __exit__() method.
  prefs: []
  type: TYPE_NORMAL
- en: 7.11.4 There’s more…
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The operation of the __exit__() method is central to making best use of a context
    manager. In the previous example, we use the following ”do nothing” __exit__()
    method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE80]'
  prefs: []
  type: TYPE_PRE
- en: 'The point here is to allow any exception to propagate normally. We often see
    any cleanup processing replacing the # Cleanup goes here. comment. This is where
    buffers are flushed, files are closed, and error log messages are written.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Sometimes, we’ll need to handle specific exception details. Consider the following
    snippet of an interactive session:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE81]'
  prefs: []
  type: TYPE_PRE
- en: The Distance object was initialized with the r argument value set to None. While
    this code will lead to warnings from tools like mypy, it’s syntactically valid.
    The TypeError traceback, however, doesn’t point to Distance; it points to a line
    of code within the haversine() function.
  prefs: []
  type: TYPE_NORMAL
- en: 'We might want to report a ValueError instead of this TypeError. Here’s a variation
    on the Distance class, which conceals the TypeError, replacing it with a ValueError:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE82]'
  prefs: []
  type: TYPE_PRE
- en: This shows how we can examine the details of the exception in the __exit__()
    method. The information provided parallels the sys.exc_info() function, and includes
    the exception’s type, the exception object, and a traceback object with the types.TracebackType
    type.
  prefs: []
  type: TYPE_NORMAL
- en: 7.11.5 See also
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In the [Managing a context using the with statement](ch006_split_001.xhtml#x1-15200011)
    recipe in Chapter [2](ch006_split_000.xhtml#x1-840002), we cover the basics of
    using a file-based context manager.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 7.12 Managing multiple contexts with multiple resources
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We often use context managers with open files. Because the context manager can
    guarantee the OS resources are released, doing so prevents resource leaks. It
    can be used to prevent files from being closed without having all buffers flushed
    to persistent storage.
  prefs: []
  type: TYPE_NORMAL
- en: When multiple resources are being processed, it often means multiple context
    managers will be needed. For example, if we have three open files, we could require
    three nested with statements? How can we optimize or simplify multiple with statements?
  prefs: []
  type: TYPE_NORMAL
- en: 7.12.1 Getting ready
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'We’ll look at creating a plan for a journey with multiple legs. Our starting
    data collection is a list of points that define our route. For example, traveling
    through Chesapeake Bay may involve starting in Annapolis, Maryland, sailing to
    Solomon’s Island, Deltaville, Virginia, and then Norfolk, Virginia. For planning
    purposes, we’d like to think of this as three legs, instead of four points. A
    leg has a distance and takes time to traverse: computing time, speed, and distance
    is the essence of the planning problem.'
  prefs: []
  type: TYPE_NORMAL
- en: 'We’ll start with some foundational definitions before we run the recipe. First
    is the definition of a single point, with attributes of latitude and longitude:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE83]'
  prefs: []
  type: TYPE_PRE
- en: 'A point can be built with a statement like this: p = Point(38.9784, -76.4922).
    This lets us refer to p.lat and p.lon in subsequent computations. The use of attribute
    names makes the code much easier to read.'
  prefs: []
  type: TYPE_NORMAL
- en: 'A leg is a pair of points. We can define it as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE84]'
  prefs: []
  type: TYPE_PRE
- en: We’ve created this as a mutable object. The distance attribute has an initial
    value defined by the dataclasses.field() function. The use of init=False means
    the attribute is not provided when the object is initialized; it must be supplied
    after initialization.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here’s a context manager to create Leg objects from Point instances. This is
    similar to the context managers shown in the [Creating contexts and context managers](ch011_split_001.xhtml#x1-43700011)
    recipe. There is a tiny but important difference here. The __init__() saves a
    value for self.r to set the distance unit context. The default value is nautical
    miles:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE85]'
  prefs: []
  type: TYPE_PRE
- en: 'The important method, waypoint(), accepts a waypoint and creates a Leg object.
    The very first waypoint, the starting point for the voyage, will return None.
    All subsequent points will return a Leg object:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE86]'
  prefs: []
  type: TYPE_PRE
- en: This method uses a cached Point object, self.last_point, and the next point,
    next_point, to create a Leg instance and then update that instance.
  prefs: []
  type: TYPE_NORMAL
- en: 'If we want to create an output file in CSV format, we’ll need to use two context
    managers: one to create Leg objects, and another to manage the open file. We’ll
    put this complex multi-context processing into a single function.'
  prefs: []
  type: TYPE_NORMAL
- en: 7.12.2 How to do it...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'We’ll be working with the csv and pathlib modules. Additionally, this recipe
    will also make use of the Iterable type hint, and the asdict function from the
    dataclasses module:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE87]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Since we’ll be creating a CSV file, we need to define the headers to be used
    for the CSV output:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE88]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Define a function to transform complex objects into a dictionary suitable for
    writing each individual row. The input is a Leg object; the output is a dictionary
    with keys that match the HEADERS list of column names:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE89]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Define the function with a meaningful name. We’ll provide two parameters: a
    list of Point objects and a Path object showing where the CSV file should be created.
    We’ve used Iterable[Point] as a type hint so this function can accept any iterable
    collection of Point instances:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE90]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Start the two contexts with a single with statement. This will invoke both
    __enter__() methods to prepare both contexts for work. This line can get long:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE91]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Once the contexts are ready for work, we can create a CSV writer and begin
    writing rows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE92]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'At the end of the context, do any final summary processing. This is not indented
    within the with statement’s body; it is at the same indentation level as the with
    keyword itself:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE93]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: By keeping this outside the with context, this message provides important evidence
    that the files were properly closed and all of the computations were completed.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 7.12.3 How it works...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The compound with statement created a number of context managers for us. All
    of the managers will have their __enter__() methods used to both start processing
    and, optionally, return an object usable within the context. The LegMaker class
    defined an __enter__() method that returned the LegMaker instance. The Path.open()
    method returns a TextIO object; these are also context managers.
  prefs: []
  type: TYPE_NORMAL
- en: When the context exits at the end of the with statement, all of the context
    manager __exit__() methods are called. This allows each context manager to do
    any finalization. In the case of TextIO objects, this closes the external files,
    releasing any of the OS resources being used.
  prefs: []
  type: TYPE_NORMAL
- en: In the case of the LegMaker object, there is no finalization processing on context
    exit. A LegMaker object was created; the value returned from the __enter__() method
    is a reference to a method of this object. The legger callable will continue to
    operate correctly even outside the context. This is an odd special case that occurs
    in instances where there is no cleanup in the __exit__() method. If it’s important
    to prevent further use of the legger callable, then the __exit__() method needs
    to make an explicit state change inside the LegMaker object so it raises an exception.
    One approach is for the __exit__() method to set the self.r value to None, which
    would prevent further use of the waypoint() method.
  prefs: []
  type: TYPE_NORMAL
- en: 7.12.4 There’s more...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: A context manager’s job is to isolate details of resource management. The most
    common examples are files and network connections. We’ve shown the use of a context
    manager around an algorithm to help manage a cache with a single Point object.
  prefs: []
  type: TYPE_NORMAL
- en: When working with very large datasets, it’s often helpful to use compression.
    This can create a different kind of context around the processing. The built-in
    open() method is generally assigned to the io.open() function in the io module.
    This means we can often replace io.open() with a function such as bz2.open() to
    work with compressed files.
  prefs: []
  type: TYPE_NORMAL
- en: 'We can replace an uncompressed file context manager with something like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE94]'
  prefs: []
  type: TYPE_PRE
- en: We’ve replaced the original path.open() method with bz2.open(path). The rest
    of the context processing remains identical. This flexibility allows us to work
    with text files initially and later convert them to compressed files when the
    volume of data grows.
  prefs: []
  type: TYPE_NORMAL
- en: 7.12.5 See also
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In the [Managing a context using the with statement](ch006_split_001.xhtml#x1-15200011)
    recipe in Chapter [2](ch006_split_000.xhtml#x1-840002), we cover the basics of
    using a file-based context manager.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The [Creating contexts and context managers](ch011_split_001.xhtml#x1-43700011)
    recipe covers the core of creating a class that is a context manager.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Join our community Discord space
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Join our Python Discord workspace to discuss and find out more about the book:
    [https://packt.link/dHrHU](https://packt.link/dHrHU)'
  prefs: []
  type: TYPE_NORMAL
- en: '![PIC](img/file1.png)'
  prefs: []
  type: TYPE_IMG
