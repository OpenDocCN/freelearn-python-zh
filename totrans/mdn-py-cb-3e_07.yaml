- en: '7'
  id: totrans-0
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: '7'
- en: Basics of Classes and Objects
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 类和对象的基础
- en: The point of computing is to process data. We often encapsulate the processing
    and the data into a single definition. We can organize objects into classes with
    a common collection of attributes to define their internal state and common behavior.
    Each instance of a class is a distinct object with unique internal state and behavior.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 计算的目的在于处理数据。我们通常将处理和数据封装到单个定义中。我们可以将具有共同属性集的对象组织成类，以定义它们的内部状态和共同行为。类的每个实例都是一个具有独特内部状态和行为的独立对象。
- en: This concept of state and behavior applies particularly well to the way games
    work. When building something like an interactive game, the user’s actions update
    the game state. Each of the player’s possible actions is a method to change the
    state of the game. In many games this leads to a lot of animation to show the
    transition from state to state. In a single-player arcade-style game, the enemies
    or opponents will often be separate objects, each with an internal state that
    changes based on other enemy actions and the player’s actions.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 这种状态和行为的概念特别适用于游戏的工作方式。当构建类似交互式游戏的东西时，用户的操作会更新游戏状态。玩家的每个可能动作都是一个改变游戏状态的方法。在许多游戏中，这会导致大量的动画来展示状态之间的转换。在单人街机风格的游戏中，敌人或对手通常会是独立的对象，每个对象都有一个基于其他敌人动作和玩家动作而变化的内部状态。
- en: On the other hand, if we consider a card or dice game, there may be very few
    states possible. A game like Zonk involves a player rolling (and rerolling) dice
    as long as their score improves. If a subsequent roll fails to improve their hand
    of dice, their turn is over. The hand’s state is the pool of dice that comprise
    the scoring subset, often pushed to one side of the table. In a six-dice game,
    there will be from one to six scoring dice as distinct states. Additionally, when
    all dice are scoring, the player can begin the rolling process again by rerolling
    all of the dice. This leads to an additional ”over-the-top” state that the players
    must also bear in mind.
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 另一方面，如果我们考虑一副牌或掷骰子游戏，可能的状态可能非常少。像 Zonk 这样的游戏涉及玩家掷（并重新掷）骰子，只要他们的分数提高。如果随后的掷骰子未能改善他们的骰子组合，他们的回合就结束了。手牌的状态是由构成得分子集的骰子池，通常推到桌子的一个边上。在一个六骰子的游戏中，将有从一到六个得分骰子作为不同的状态。此外，当所有骰子都是得分骰子时，玩家可以通过重新掷所有骰子来再次开始掷骰子的过程。这导致了一个额外的“超常”状态，玩家也必须记住。
- en: The point of object-oriented design is to define the current state with the
    attributes of an object. Each object is defined as an instance of a class of similar
    objects. We write the class definitions in Python and use these to create objects.
    The methods defined in the class cause the state changes on an object.
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 面向对象设计的目的是使用对象的属性来定义当前状态。每个对象都被定义为类似对象的类的一个实例。我们用Python编写类定义，并使用这些定义来创建对象。类中定义的方法会在对象上引起状态变化。
- en: 'In this chapter, we will look at the following recipes:'
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将探讨以下食谱：
- en: '[Using a class to encapsulate data and processing](ch011_split_000.xhtml#x1-3770001)'
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[使用类来封装数据和处理](ch011_split_000.xhtml#x1-3770001)'
- en: '[Essential type hints for class definitions](ch011_split_000.xhtml#x1-3830002)'
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[类定义的基本类型提示](ch011_split_000.xhtml#x1-3830002)'
- en: '[Designing classes with lots of processing](ch011_split_000.xhtml#x1-3890003)'
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[设计具有大量处理的类](ch011_split_000.xhtml#x1-3890003)'
- en: '[Using typing.NamedTuple for immutable objects](ch011_split_000.xhtml#x1-3950004)'
  id: totrans-10
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[使用 typing.NamedTuple 来表示不可变对象](ch011_split_000.xhtml#x1-3950004)'
- en: '[Using dataclasses for mutable objects](ch011_split_000.xhtml#x1-4010005)'
  id: totrans-11
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[使用数据类来表示可变对象](ch011_split_000.xhtml#x1-4010005)'
- en: '[Using frozen dataclasses for immutable objects](ch011_split_000.xhtml#x1-4070006)'
  id: totrans-12
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[使用冻结的数据类来表示不可变对象](ch011_split_000.xhtml#x1-4070006)'
- en: '[Optimizing small objects with __slots__](ch011_split_001.xhtml#x1-4130007)'
  id: totrans-13
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[使用 __slots__ 优化小对象](ch011_split_001.xhtml#x1-4130007)'
- en: '[Using more sophisticated collections](ch011_split_001.xhtml#x1-4190008)'
  id: totrans-14
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[使用更复杂的集合](ch011_split_001.xhtml#x1-4190008)'
- en: '[Extending a built-in collection – a list that does statistics](ch011_split_001.xhtml#x1-4250009)'
  id: totrans-15
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[扩展内置集合 – 一个可以进行统计的列表](ch011_split_001.xhtml#x1-4250009)'
- en: '[Using properties for lazy attributes](ch011_split_001.xhtml#x1-43100010)'
  id: totrans-16
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[使用属性来表示延迟属性](ch011_split_001.xhtml#x1-43100010)'
- en: '[Creating contexts and context managers](ch011_split_001.xhtml#x1-43700011)'
  id: totrans-17
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[创建上下文和上下文管理器](ch011_split_001.xhtml#x1-43700011)'
- en: '[Managing multiple contexts with multiple resources](ch011_split_001.xhtml#x1-44300012)'
  id: totrans-18
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[使用多个资源管理多个上下文](ch011_split_001.xhtml#x1-44300012)'
- en: The subject of object-oriented design is quite large. In this chapter, we’ll
    cover some of the essentials. We’ll start with some foundational concepts, such
    as how a class definition encapsulates state and processing details for all instances
    of a class.
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 面向对象设计的主旨相当广泛。在本章中，我们将介绍一些基本概念。我们将从一些基础概念开始，例如类定义如何封装类的所有实例的状态和处理细节。
- en: 7.1 Using a class to encapsulate data and processing
  id: totrans-20
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 7.1 使用类封装数据和处理
- en: Class design is influenced by the SOLID design principles. The Single Responsibility
    and Interface Segregation principles offer helpful advice. Taken together, these
    principles advise us that a class should have methods narrowly focused on a single,
    well-defined responsibility.
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 类设计受到SOLID设计原则的影响。单一责任和接口隔离原则提供了有用的建议。综合考虑，这些原则建议我们，一个类应该有方法，这些方法专注于单一、明确的责任。
- en: Another way of considering a class is as a group of closely-related functions
    working with common data. We call these methods for working with the data. A class
    definition should contain the smallest collection of methods for working with
    the object’s data.
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 考虑类的一种另一种方式是作为一个紧密相关的函数组，这些函数使用共同的数据。我们称这些为处理数据的函数。类定义应该包含处理对象数据的最小方法集合。
- en: We’d like to create class definitions based on a narrow allocation of responsibilities.
    How can we define responsibilities effectively? What’s a good way to design a
    class?
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 我们希望基于狭窄的责任分配创建类定义。我们如何有效地定义责任？设计一个类的好方法是什么？
- en: 7.1.1 Getting ready
  id: totrans-24
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 7.1.1 准备工作
- en: Let’s look at a simple, stateful object – a pair of dice. The context for this
    is an application that simulates a simple game like Craps.
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看一个简单的、有状态的对象——一对骰子。这个背景是一个模拟简单游戏如Craps的应用程序。
- en: A software object can be viewed as analogous to a thing – a noun. The behaviors
    of the class can then be viewed as verbs. This identification with nouns and verbs
    gives us a hint as to how we can proceed to design classes to work effectively.
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 软件对象可以看作是类似事物——名词。类的行为可以看作是动词。这种与名词和动词的认同给我们提供了如何有效地设计类以有效工作的线索。
- en: 'This leads us to several steps of preparation. We’ll provide concrete examples
    of these steps using a pair of dice for game simulation. We proceed as follows:'
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 这引导我们进入几个准备步骤。我们将通过使用一对骰子进行游戏模拟来提供这些步骤的具体示例。我们按以下步骤进行：
- en: 'Write down simple sentences that describe what an instance of the class does.
    We can call these the problem statements. It’s essential to focus on single-verb
    sentences, with a focus on only the nouns and verbs. Here are some examples:'
  id: totrans-28
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 写下描述类实例所做事情的简单句子。我们可以称之为问题陈述。专注于单动词句子，只关注名词和动词是至关重要的。以下是一些例子：
- en: The game of Craps has two standard dice.
  id: totrans-29
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: Craps游戏有两个标准的骰子。
- en: Each die has six faces, with point values from one to six.
  id: totrans-30
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 每个骰子有六个面，点数从一到六。
- en: Dice are rolled by a player. While writers and editors prefer the active voice
    version, ”A player rolls the dice,” the dice are often acted upon by other objects,
    making passive-voice sentences slightly more useful.
  id: totrans-31
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 玩家掷骰子。虽然作者和编辑更喜欢主动语态版本，“玩家掷骰子”，但骰子通常被其他对象所作用，使得被动语态句子稍微更有用。
- en: The total of the dice changes the state of the Craps game. Those rules are separate
    from the dice.
  id: totrans-32
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 骰子的总和改变了Craps游戏的状态。这些规则与骰子是分开的。
- en: If the two dice match, the number was described as being rolled “the hard way”.
    If the two dice do not match, the roll was described as being made “the easy way”.
  id: totrans-33
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果两个骰子匹配，这个数字被描述为“硬掷”。如果两个骰子不匹配，掷骰子被描述为“易掷”。
- en: Identify all of the nouns in the sentences. In this example, the nouns include
    dice, faces, point values, and a player. The nouns identify different classes
    of objects that may be collaborators, like player and game. Nouns may also identify
    attributes of objects, like face and point value.
  id: totrans-34
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 识别句子中的所有名词。在这个例子中，名词包括骰子、面、点数和玩家。名词识别不同类别的对象，可能是合作者，如玩家和游戏。名词也可能识别对象的属性，如面和点数。
- en: Identify all the verbs in the sentences. Verbs often become methods of the class
    in question. In this example, verbs include roll and match.
  id: totrans-35
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 识别句子中的所有动词。动词通常成为所讨论的类的成员方法。在这个例子中，动词包括roll和match。
- en: This information helps define the state and behavior of the objects. Having
    this background information will help us write the class definition.
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 这些信息有助于定义对象的状态和行为。拥有这些背景信息将帮助我们编写类定义。
- en: 7.1.2 How to do it...
  id: totrans-37
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 7.1.2 如何做...
- en: 'Since the simulation we’re writing involves random throws of dice, we’ll depend
    on from random import randint to provide the useful randint() function. The steps
    for defining a class are as follows:'
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 由于我们编写的模拟涉及骰子的随机投掷，我们将依赖于 from random import randint 提供有用的 randint() 函数。定义类的步骤如下：
- en: 'Start writing the class with the class statement:'
  id: totrans-39
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用类声明开始编写类：
- en: '[PRE0]'
  id: totrans-40
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'Initialize the object’s attributes within the body of an __init__() method.
    We’ll model the internal state of the dice with a faces attribute. A self variable
    is required to be sure that we’re referencing an attribute of a given instance
    of a class. We’ll provide a type hint on each attribute to be sure it’s used properly
    throughout the class definition:'
  id: totrans-41
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 __init__() 方法的主体中初始化对象的属性。我们将使用 faces 属性来模拟骰子的内部状态。需要一个 self 变量来确保我们引用的是类的给定实例的属性。我们将在每个属性上提供类型提示，以确保在整个类定义中正确使用：
- en: '[PRE1]'
  id: totrans-42
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'Define the object’s methods based on the verbs in the description. When the
    player rolls the dice, a roll() method can set the values shown on the faces of
    the two dice. We implement this with a method to set the faces attribute of the
    self object:'
  id: totrans-43
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 根据描述中的动词定义对象的方法。当玩家掷骰子时，roll() 方法可以设置两个骰子面上的值。我们通过设置 self 对象的 faces 属性来实现这一点：
- en: '[PRE2]'
  id: totrans-44
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE2]'
- en: This method mutates the internal state of the object. We’ve elected to not return
    a value.
  id: totrans-45
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 此方法会改变对象的内部状态。我们选择不返回任何值。
- en: 'After a player rolls the dice, a total() method helps compute the total of
    the dice:'
  id: totrans-46
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 玩家掷骰子后，total() 方法有助于计算骰子的总和：
- en: '[PRE3]'
  id: totrans-47
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'Additional methods can provide answers to questions about the state of the
    dice. In this case, the total was made ”the hard way” when both dice match:'
  id: totrans-48
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 可以提供额外的方法来回答有关骰子状态的问题。在这种情况下，当两个骰子都匹配时，总和是通过“困难的方式”得到的：
- en: '[PRE4]'
  id: totrans-49
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 7.1.3 How it works...
  id: totrans-50
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 7.1.3 它是如何工作的...
- en: The core idea here is to use ordinary rules of grammar – nouns, verbs, and adjectives
    – as a way to identify basic features of a class. In our example, dice are real
    things. We try to avoid using abstract terms such as randomizers or event generators.
    It’s easier to describe the tangible features of real things, and then define
    an implementation to match the tangible features.
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 核心思想是使用普通的语法规则——名词、动词和形容词——作为识别类基本特征的一种方式。在我们的例子中，骰子是真实的事物。我们尽量避免使用抽象术语，如随机化器或事件生成器。描述真实事物的可触摸特征更容易，然后定义一个实现来匹配这些可触摸特征。
- en: The idea of rolling the dice is an example physical action that we can model
    with a method definition. This action of rolling the dice changes the state of
    the object. In rare cases – 1 time in 36 – the next state will happen to match
    the previous state.
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 掷骰子的想法是一个我们可以通过方法定义来模拟的物理动作。这个掷骰子的动作会改变对象的状态。在极少数情况下——36次中的1次——下一个状态会恰好与之前的状态相同。
- en: 'Here’s an example of using the Dice class:'
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 下面是使用 Dice 类的一个示例：
- en: 'First, we’ll seed the random number generator with a fixed value so that we
    can get a fixed sequence of results:'
  id: totrans-54
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 首先，我们将使用一个固定值来初始化随机数生成器，以便我们可以得到一个固定的结果序列：
- en: '[PRE5]'
  id: totrans-55
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'We’ll create a Dice object, and assign it to a variable, d1\. We can then set
    its state with the roll() method. We’ll then look at the total() method to see
    what was rolled. We’ll examine the state by looking at the faces attribute:'
  id: totrans-56
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们将创建一个 Dice 对象，并将其分配给变量 d1。然后我们可以使用 roll() 方法设置其状态。然后我们将查看 total() 方法以查看掷出了什么。我们将通过查看
    faces 属性来检查状态：
- en: '[PRE6]'
  id: totrans-57
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 7.1.4 There’s more...
  id: totrans-58
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 7.1.4 更多...
- en: 'Capturing the essential internal state and methods that cause state change
    is the first step in good class design. We can summarize some helpful design principles
    using the acronym SOLID:'
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 捕获导致状态变化的必要内部状态和方法是良好类设计的第一步。我们可以使用缩写 SOLID 总结一些有用的设计原则：
- en: 'Single Responsibility Principle: A class should have one clearly defined responsibility.'
  id: totrans-60
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 单一职责原则：一个类应该有一个明确定义的责任。
- en: 'Open/Closed Principle: A class should be open to extension – generally via
    inheritance – but closed to modification. We should design our classes so that
    we don’t need to tweak the code to add or change features.'
  id: totrans-61
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 开放/封闭原则：一个类应该对扩展开放——通常通过继承——但对修改封闭。我们应该设计我们的类，以便我们不需要调整代码来添加或更改功能。
- en: 'Liskov Substitution Principle: We need to design inheritance so that a subclass
    can be used in place of the superclass.'
  id: totrans-62
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 李斯克夫替换原则：我们需要设计继承，使得子类可以替代父类使用。
- en: 'Interface Segregation Principle: When writing a problem statement, we want
    to be sure that collaborating classes have as few dependencies as possible. In
    many cases, this principle will lead us to decompose large problems into many
    small class definitions.'
  id: totrans-63
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 接口隔离原则：在编写问题陈述时，我们希望确保协作类尽可能少地依赖。在许多情况下，这一原则将引导我们将大问题分解成许多小的类定义。
- en: 'Dependency Inversion Principle: It’s less than ideal for a class to depend
    directly on other classes. It’s better if a class depends on an abstraction, and
    a concrete implementation class is substituted for the abstract class.'
  id: totrans-64
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 依赖倒置原则：一个类直接依赖于其他类并不理想。如果类依赖于抽象，并且用具体实现类替换抽象类，则更好。
- en: The goal is to create classes that have the necessary behavior and also adhere
    to the design principles so they can be extended and reused.
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 目标是创建具有必要行为并遵循设计原则的类，以便它们可以被扩展和重用。
- en: 7.1.5 See also
  id: totrans-66
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 7.1.5 参考内容
- en: See the [Using properties for lazy attributes](ch011_split_001.xhtml#x1-43100010)
    recipe, where we’ll look at the choice between an eager attribute and a lazy property.
  id: totrans-67
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 请参阅[使用属性实现懒属性](ch011_split_001.xhtml#x1-43100010)的配方，我们将探讨选择积极属性和懒属性之间的选择。
- en: In Chapter [8](ch012.xhtml#x1-4520008), we’ll look in more depth at class design
    techniques.
  id: totrans-68
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在第[8](ch012.xhtml#x1-4520008)章中，我们将更深入地探讨类设计技术。
- en: See Chapter [15](ch019_split_000.xhtml#x1-79400015), for recipes on how to write
    appropriate unit tests for the class.
  id: totrans-69
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 请参阅第[15](ch019_split_000.xhtml#x1-79400015)章，了解如何为类编写适当的单元测试配方。
- en: 7.2 Essential type hints for class definitions
  id: totrans-70
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 7.2 类定义的必要类型提示
- en: A class name is also a type hint, allowing a direct reference between a variable
    and the class that should define the objects associated with the variable. This
    relationship lets tools such as mypy reason about our programs to be sure that
    object references and method references appear to match the type hints in our
    code.
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 类名也是一个类型提示，允许变量直接引用应该定义与变量相关联的对象的类。这种关系使工具如mypy能够推理我们的程序，以确保对象引用和方法引用似乎与代码中的类型提示相匹配。
- en: 'In addition to the class name, we’ll use type hints in three common places
    within a class definition:'
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 除了类名之外，我们将在类定义中的三个常见位置使用类型提示：
- en: In method definitions, we’ll use type hints to annotate the parameters and the
    return type.
  id: totrans-73
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在方法定义中，我们将使用类型提示来注释参数和返回类型。
- en: In the __init__() method, we may need to provide hints for the instance variables
    that define the state of the object.
  id: totrans-74
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在`__init__()`方法中，我们可能需要为定义对象状态的实例变量提供提示。
- en: Inside the attributes of the class overall. These are not common and type hints
    are rare here.
  id: totrans-75
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在类的整体属性中。这些不是常见的，这里的类型提示也很少。
- en: 7.2.1 Getting ready
  id: totrans-76
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 7.2.1 准备工作
- en: We’re going to examine a class with a variety of type hints. In this example,
    our class will model a handful of dice. We’ll allow rerolling selected dice, making
    the instance of the class stateful.
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将检查一个具有各种类型提示的类。在这个例子中，我们的类将模拟一把骰子。我们将允许重新掷选定的骰子，使类的实例具有状态。
- en: The collection of dice can be set by a first roll, where all the dice are rolled.
    The class allows subsequent rolls of a subset of dice. The number of rolls is
    counted as well.
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 骰子集合可以通过第一次掷骰子来设置，其中所有骰子都被掷出。该类允许掷出骰子子集的后续掷骰。同时也会计算掷骰子的次数。
- en: The type hints will reflect the nature of the collection of dice, the integer
    counts, a floating-point average value, and a string representation of the hand
    as a whole. This will show a number of type hints and how to write them.
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 类型提示将反映骰子集合的性质、整数计数、浮点平均值以及整个手牌的字符串表示。这将展示一系列类型提示及其编写方式。
- en: 7.2.2 How to do it...
  id: totrans-80
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 7.2.2 如何实现...
- en: 'This definition will involve random numbers as well as type hints for sets
    and lists. We import the random module:'
  id: totrans-81
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 此定义将涉及随机数以及集合和列表的类型提示。我们导入random模块：
- en: '[PRE7]'
  id: totrans-82
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'Define the class. This creates a new type:'
  id: totrans-83
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 定义类。这创建了一个新类型：
- en: '[PRE8]'
  id: totrans-84
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'It’s rare for class-level variables to require a type hint. They’re almost
    always created with assignment statements that make the type information clear
    to a person or a tool like mypy. In this case, we want all instances of our class
    of dice to share a common random number generator object:'
  id: totrans-85
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 类级别的变量很少需要类型提示。它们几乎总是通过赋值语句创建的，这些语句使类型信息对人类或像mypy这样的工具来说很清晰。在这种情况下，我们希望我们的骰子类的所有实例共享一个共同的随机数生成器对象：
- en: '[PRE9]'
  id: totrans-86
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'The __init__() method creates the instance variables that define the state
    of the object. In this case, we’ll save some configuration details, plus some
    internal state. The __init__() method also has the initialization parameters.
    Generally, we’ll put the type hints on these parameters. Other internal state
    variables may require type hints to show what kinds of values will be assigned
    by other methods of the class. In this example, the faces attribute has no initial
    value; we state that when it is set, it will be a List[int] object:'
  id: totrans-87
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: __init__()方法创建了定义对象状态的实例变量。在这种情况下，我们将保存一些配置细节和一些内部状态。__init__()方法还有初始化参数。通常，我们会在这些参数上放置类型提示。其他内部状态变量可能需要类型提示来显示其他类方法将分配哪些类型的值。在这个例子中，faces属性没有初始值；我们声明当它被设置时，它将是一个List[int]对象：
- en: '[PRE10]'
  id: totrans-88
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'Methods that compute new derived values can be annotated with their return
    type information. Here are three examples to return a string representation, compute
    the total, and also compute an average of the dice. These functions have return
    types of str, int, and float, as shown:'
  id: totrans-89
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 计算新导出值的方法可以用它们的返回类型信息进行注解。这里有三个例子，用于返回字符串表示、计算总和以及计算骰子的平均值。这些函数的返回类型分别是str、int和float，如下所示：
- en: '[PRE11]'
  id: totrans-90
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'For methods with parameters, we include type hints on the parameters as well
    as a return type. In this case, the methods that change the internal state also
    return values. The return value from both methods is a list of dice faces, described
    as list[int]. The parameter for the reroll() method is a set of dice to be rolled
    again. This is shown as a set[int] requiring a set of integers. Python is a little
    more flexible than this, and we’ll look at some alternatives:'
  id: totrans-91
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 对于有参数的方法，我们在参数上以及返回类型上包含类型提示。在这种情况下，改变内部状态的方法也会返回值。两个方法的返回值都是骰子面的列表，描述为list[int]。reroll()方法的参数是要重新掷的骰子集合。这表示为set[int]，需要一组整数。Python比这要灵活一些，我们将探讨一些替代方案：
- en: '[PRE12]'
  id: totrans-92
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 7.2.3 How it works...
  id: totrans-93
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 7.2.3 工作原理...
- en: The type hint information is used by programs such as mypy to be sure that the
    instances of the class are used properly throughout the application.
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 类型提示信息被程序如mypy使用，以确保在整个应用程序中正确使用类的实例。
- en: 'If we try to write a function like the following:'
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们尝试编写如下函数：
- en: '[PRE13]'
  id: totrans-96
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'The attempt to create an instance of the Dice class using a float value for
    the n parameter represents a conflict with the type hints. The hint for the Dice
    class’s __init__() method claimed the argument value should be an integer. The
    mypy program reports the following:'
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 使用浮点值作为n参数创建Dice类实例的尝试与类型提示发生冲突。Dice类的__init__()方法的提示称参数值应该是整数。mypy程序报告如下：
- en: '[PRE14]'
  id: totrans-98
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: If we try to execute the application, it will raise a TypeError exception in
    another place. The error will manifest when evaluating the d.first_roll() method.
    The exception is raised here because the body of the __init__() method works well
    with values of any type. The hints claim specific types are expected, but at runtime,
    any object can be provided. The hints are not checked during execution.
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们尝试执行应用程序，它将在另一个地方引发TypeError异常。错误将在评估d.first_roll()方法时显现。异常在这里被引发，因为__init__()方法的主体可以很好地处理任何类型的值。提示称期望特定的类型，但在运行时，可以提供任何对象。在执行期间不会检查提示。
- en: 'Similarly, when we use other methods, the mypy program checks to be sure our
    use of the method matches the expectations defined by the type hints. Here’s another
    example:'
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 类似地，当我们使用其他方法时，mypy程序会检查我们的方法使用是否与类型提示定义的期望相匹配。这里有一个另一个例子：
- en: '[PRE15]'
  id: totrans-101
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: This assignment statement has a type hint for the r1 variable that doesn’t match
    the type hint for the return type from the first_roll() method. This conflict
    is found by mypy and reported as an Incompatible types in assignment error.
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 这个赋值语句中，r1变量的类型提示与first_roll()方法返回值的类型提示不匹配。这种冲突是由mypy检测到的，并报告为“赋值中不兼容的类型”错误。
- en: 7.2.4 There’s more...
  id: totrans-103
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 7.2.4 更多内容...
- en: One of the type hints in this example is too specific. The function for re-rolling
    the dice, reroll(), has a positions parameter. The positions parameter is used
    in a for statement, which means the object must be some kind of iterable object.
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个例子中，有一个类型提示过于具体。用于重新掷骰子的reroll()函数有一个positions参数。positions参数在for语句中使用，这意味着对象必须是某种可迭代对象。
- en: The mistake was providing a type hint, set[int], which is only one of many kinds
    of iterable objects. We can generalize this definition by switching the type hint
    from the very specific set[int] to the more general Iterable[int].
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 错误在于提供了一个类型提示set[int]，这仅仅是许多可迭代对象中的一种。我们可以通过将类型提示从非常具体的set[int]切换到更通用的Iterable[int]来泛化这个定义。
- en: Relaxing the hint means that any set, list, or tuple object can be a valid argument
    value for this parameter. The only other code change required is to import Iterable
    from the collections.abc module.
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 放宽提示意味着任何集合、列表或元组对象都可以作为此参数的有效参数值。所需的唯一其他代码更改是导入collections.abc模块中的Iterable。
- en: The for statement has a specific protocol for getting the iterator object from
    an iterable collection, assigning values to a variable, and executing the indented
    body. This protocol is defined by the Iterable type hint. There are many such
    protocol-based types, and they allow us to provide type hints that match Python’s
    inherent flexibility with respect to type.
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: for语句有一个从可迭代集合获取迭代器对象、将值赋给变量和执行缩进体的特定协议。这个协议由Iterable类型提示定义。有许多这样的基于协议的类型，它们允许我们提供与Python固有的类型灵活性相匹配的类型提示。
- en: 7.2.5 See also
  id: totrans-108
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 7.2.5 参考信息
- en: In Chapter [3](ch007_split_000.xhtml#x1-1610003), in the [Function parameters
    and type hints](ch007_split_000.xhtml#x1-1620001) recipe, a number of similar
    concepts are shown.
  id: totrans-109
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在第[3](ch007_split_000.xhtml#x1-1610003)章的[函数参数和类型提示](ch007_split_000.xhtml#x1-1620001)配方中，展示了多个类似的概念。
- en: In Chapter [4](ch008_split_000.xhtml#x1-2240004), the [Writing list-related
    type hints](ch008_split_001.xhtml#x1-2560005) and [Writing set-related type hints](ch008_split_001.xhtml#x1-2800009)
    recipes address additional detailed type hinting.
  id: totrans-110
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在第[4](ch008_split_000.xhtml#x1-2240004)章中，[编写与列表相关的类型提示](ch008_split_001.xhtml#x1-2560005)和[编写与集合相关的类型提示](ch008_split_001.xhtml#x1-2800009)配方解决了额外的详细类型提示。
- en: In Chapter [5](ch009.xhtml#x1-2890005), the [Writing dictionary-related type
    hints](ch009.xhtml#x1-3040003) recipe also addresses type hinting.
  id: totrans-111
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在第[5](ch009.xhtml#x1-2890005)章中，[编写与字典相关的类型提示](ch009.xhtml#x1-3040003)配方也解决了类型提示。
- en: 7.3 Designing classes with lots of processing
  id: totrans-112
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 7.3 设计具有大量处理的类
- en: Some of the time, an object will contain all of the data that defines its internal
    state. There are cases, however, where a class doesn’t hold the data, but instead
    is designed to consolidate processing for data held in separate containers.
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 有时，一个对象将包含定义其内部状态的所有数据。然而，有些情况下，一个类不持有数据，而是设计用来对存储在单独容器中的数据进行处理进行整合。
- en: Some prime examples of this design are statistical algorithms, which are often
    outside the data being analyzed. The data might be in a built-in list or Counter
    object; the processing is defined in a class separate from the data container.
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 这种设计的典型例子是统计算法，这些算法通常位于被分析的数据之外。数据可能在一个内置的列表或Counter对象中；处理定义在数据容器之外的一个类中。
- en: 7.3.1 Getting ready
  id: totrans-115
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 7.3.1 准备工作
- en: It’s quite common to do analysis on data that’s already been summarized into
    groups or bins. We might, for example, have a vast data file with a large number
    of measurements of an industrial process.
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 在对已经总结成组或箱的数据进行分析是很常见的。例如，我们可能有一个包含大量工业过程测量的巨大数据文件。
- en: 'For background, see the NIST Aerosol Particle Size case study: [https://www.itl.nist.gov/div898/handbook/pmc/section6/pmc62.htm](https://www.itl.nist.gov/div898/handbook/pmc/section6/pmc62.htm)'
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 为了了解背景，请参阅NIST气溶胶粒子尺寸案例研究：[https://www.itl.nist.gov/div898/handbook/pmc/section6/pmc62.htm](https://www.itl.nist.gov/div898/handbook/pmc/section6/pmc62.htm)
- en: 'Rather than analyze the voluminous raw data, it’s often much faster to first
    summarize the important variables, then analyze the summarized data. The summary
    data can be kept in a Counter object. The data looks like this:'
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 与分析大量的原始数据相比，首先总结重要的变量，然后分析总结后的数据通常要快得多。总结数据可以保存在一个Counter对象中。数据看起来是这样的：
- en: '[PRE16]'
  id: totrans-119
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: '[PRE17]'
  id: totrans-120
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: '[PRE18]'
  id: totrans-121
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: The keys (7, 6, 8, 9, and so on) are codes reflecting the particle size. The
    actual sizes varied from 109 to 119\. Computing the actual size, c, from the s
    code is done with c = ⌊2(s − 109)⌋.
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 键（7、6、8、9等等）是反映粒子大小的代码。实际尺寸从109到119不等。从s代码计算实际尺寸c，公式为c = ⌊2(s − 109)⌋。
- en: (The units aren’t provided in the NIST background information. Since a lot of
    the data reflects electronic chip wafers and fabrication, the units are likely
    something very small.)
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: （NIST背景信息中没有提供单位。由于大量数据反映了电子芯片晶圆和制造过程，单位可能非常小。）
- en: 'We want to compute some statistics on this Counter object without being forced
    to work with the original voluminous dataset. In general, there are two general
    design strategies for designing classes to store and process data:'
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 我们希望在不需要强制与原始大量数据集一起工作的前提下，计算这个Counter对象上的某些统计数据。一般来说，设计用于存储和处理数据的类有两种一般的设计策略：
- en: Extend the storage class definition, Counter in this case, to add statistical
    processing. We’ll cover this in detail in the [Extending a built-in collection
    – a list that does statistics](ch011_split_001.xhtml#x1-4250009) recipe.
  id: totrans-125
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 扩展存储类定义，在这个例子中是Counter，以添加统计处理。我们将在[扩展内置集合 – 具有统计功能的列表](ch011_split_001.xhtml#x1-4250009)食谱中详细说明。
- en: 'Wrap a Counter object in a class that provides the additional features required.
    When we do this, though, we have two more choices:'
  id: totrans-126
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在一个提供所需额外功能的类中包装Counter对象。当我们这样做时，我们还有两个选择：
- en: Expose the underlying Counter object. We’ll focus on this.
  id: totrans-127
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 暴露底层Counter对象。我们将关注这一点。
- en: Write special methods to make the wrapper appear to also be a collection, encapsulating
    the Counter object. We’ll look at this in Chapter [8](ch012.xhtml#x1-4520008).
  id: totrans-128
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 编写特殊方法以使包装器看起来也是一个集合，封装Counter对象。我们将在第[8](ch012.xhtml#x1-4520008)章中探讨这一点。
- en: 'For this recipe, we’ll focus on the wrap variant where we define a statistical
    computation class that exposes a Counter object. We have two ways to design this
    compute-intensive processing:'
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 对于这个食谱，我们将专注于包装变体，其中我们定义一个统计计算类，该类公开一个Counter对象。我们有两种设计这种计算密集型处理的方法：
- en: An Eager implementation computes the statistics as soon as possible. The values
    become simple attributes. We’ll focus on this choice.
  id: totrans-130
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 积极实现会在尽可能早的时候计算统计数据。这些值成为简单的属性。我们将关注这个选择。
- en: A Lazy approach doesn’t compute anything until the value is required via a method
    function or property. We’ll look at this in the [Using properties for lazy attributes](ch011_split_001.xhtml#x1-43100010)
    recipe.
  id: totrans-131
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 懒惰方法不会在需要通过方法函数或属性获取值之前进行任何计算。我们将在[使用属性进行懒惰属性](ch011_split_001.xhtml#x1-43100010)食谱中探讨这一点。
- en: The essential algorithm for both designs is the same. The only question is when
    the work of the computation gets done.
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 两种设计的基本算法是相同的。唯一的问题是计算工作何时完成。
- en: 7.3.2 How to do it...
  id: totrans-133
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 7.3.2 如何实现...
- en: 'Import the appropriate class from the collections module. The computation uses
    math.sqrt(). Be sure to add the needed import math also:'
  id: totrans-134
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 从collections模块导入适当的类。计算使用math.sqrt()。务必添加所需的导入math：
- en: '[PRE19]'
  id: totrans-135
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'Define the class with a descriptive name:'
  id: totrans-136
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用描述性的名称定义类：
- en: '[PRE20]'
  id: totrans-137
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'Write the __init__() method to include the object where the data is located.
    In this case, the type hint is Counter[int] because the keys used in the Counter
    object will be integers:'
  id: totrans-138
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 编写__init__()方法以包含数据所在的对象。在这种情况下，类型提示是Counter[int]，因为Counter对象中使用的键将是整数：
- en: '[PRE21]'
  id: totrans-139
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'Initialize any other local variables in the __init__() method that might be
    useful. Since we’re going to calculate values eagerly, the most eager possible
    time is when the object is created. We’ll write references to some yet to be defined
    functions:'
  id: totrans-140
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在__init__()方法中初始化任何其他可能有用的局部变量。由于我们将积极计算值，最积极的时间是在对象创建时。我们将编写对一些尚未定义的函数的引用：
- en: '[PRE22]'
  id: totrans-141
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'Define the required methods for the various values. Here’s the calculation
    of the mean:'
  id: totrans-142
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 定义所需的方法以计算各种值。以下是计算平均值的示例：
- en: '[PRE23]'
  id: totrans-143
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'Here’s how we can calculate the standard deviation:'
  id: totrans-144
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 这是我们如何计算标准差的方法：
- en: '[PRE24]'
  id: totrans-145
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE24]'
- en: Note that this calculation requires that the mean is computed first and the
    self.mean instance variable has been created. This internal state change from
    no known mean to a known mean to a known standard deviation is a potential complication
    that requires clear documentation.
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，这个计算需要首先计算平均值，并创建self.mean实例变量。从无已知平均值到已知平均值再到已知标准差这种内部状态变化是一个潜在的复杂性，需要清晰的文档说明。
- en: The raw data for this example is at [https://www.itl.nist.gov/div898/handbook//datasets/NEGIZ4.DAT](https://www.itl.nist.gov/div898/handbook//datasets/NEGIZ4.DAT).
    This file has an awkwardly complicated layout because there are 50 lines of header
    text in front of the data. Further, the file isn’t in a common CSV format. For
    these reasons, it’s easier to work with summarized data.
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 本例的原始数据位于[https://www.itl.nist.gov/div898/handbook//datasets/NEGIZ4.DAT](https://www.itl.nist.gov/div898/handbook//datasets/NEGIZ4.DAT)。由于数据前有50行标题文本，这个文件的结构显得很复杂。此外，文件不是常见的CSV格式。因此，处理汇总数据更容易。
- en: 'The repository of code for this book includes a file named data/binned.csv
    that has the binned summary data. This data has three columns: size_code, size,
    and frequency. We’re only interested in size_code and frequency.'
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 本书代码库中包含一个名为data/binned.csv的文件，其中包含分箱的摘要数据。该数据有三个列：size_code、size和frequency。我们只对size_code和frequency感兴趣。
- en: 'Here’s how we can build a suitable Counter object from this file:'
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 这是我们可以从该文件构建合适的Counter对象的方法：
- en: '[PRE25]'
  id: totrans-150
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'We’ve used a dictionary comprehension to create a mapping from size_code to
    the frequency of that code value. This is then provided to the Counter class to
    build a Counter object named data from this existing summary. We can provide this
    data to the CounterStatistics class to get useful summary statistics from the
    binned data. This looks like the following example:'
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 我们使用字典推导来创建从size_code到该代码值频率的映射。然后将其提供给Counter类，从现有的摘要构建Counter对象data。我们可以将此数据提供给CounterStatistics类，从分箱数据中获得有用的摘要统计信息。这看起来像以下示例：
- en: '[PRE26]'
  id: totrans-152
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: We provided the data object to create an instance of the CounterStatistics class.
    Creating this instance will also immediately compute the summary statistics. No
    additional explicit method evaluations are required. These values are available
    as the stats.mean and stats.stddev attributes.
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 我们提供了数据对象来创建CounterStatistics类的实例。创建这个实例也将立即计算摘要统计信息。不需要额外的显式方法评估。这些值作为stats.mean和stats.stddev属性可用。
- en: The processing cost to compute the statistics is paid initially. As we’ll see
    below, a tiny incremental cost can be associated with any change to the underlying
    data.
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 计算统计信息的处理成本最初就支付了。正如我们下面将看到的，任何对底层数据的更改都可以关联一个非常小的增量成本。
- en: 7.3.3 How it works...
  id: totrans-155
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 7.3.3 它是如何工作的...
- en: This class encapsulates two complex algorithms, but doesn’t include any of the
    data for those algorithms. The data is kept separately, in a Counter object. We
    wrote a high-level specification for the processing and placed it in the __init__()
    method. Then we wrote methods to implement the processing steps that were specified.
    We can set as many attributes as are needed, making this a very flexible approach.
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 这个类封装了两个复杂算法，但不包括这些算法的任何数据。数据被单独保存在Counter对象中。我们编写了一个高级规范来处理，并将其放置在__init__()方法中。然后我们编写了实现指定处理步骤的方法。我们可以设置所需的所有属性，这使得这是一种非常灵活的方法。
- en: The advantage of this design is that the attribute values can be used repeatedly.
    The cost of computation for the mean and standard deviation is paid once; each
    time an attribute value is used, no further processing is required.
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 这种设计的优点是，属性值可以重复使用。计算平均值和标准差的成本只支付一次；每次使用属性值时，不需要进一步处理。
- en: The disadvantage of this design is that any changes to the state of the underlying
    Counter object will render the CounterStatistics object’s state obsolete and incorrect.
    If, for example, we added a few hundred more data values, the mean and standard
    deviation would need to be recomputed. A design that eagerly computes values is
    appropriate when the underlying Counter object isn’t going to change.
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 这种设计的缺点是，对底层Counter对象状态的任何更改都将使CounterStatistics对象的状态过时且不正确。例如，如果我们添加了数百个更多数据值，平均值和标准差就需要重新计算。当底层Counter对象不会改变时，急切计算值的设计是合适的。
- en: 7.3.4 There’s more...
  id: totrans-159
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 7.3.4 更多内容...
- en: 'If we need to do computations on stateful, mutable objects, we have several
    choices:'
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们需要对有状态、可变对象进行计算，我们有几种选择：
- en: Encapsulate the Counter object and make changes via the CounterStatistics class.
    This requires some care to expose enough methods of the data collection. We’ll
    defer this kind of design until Chapter [8](ch012.xhtml#x1-4520008).
  id: totrans-161
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 封装Counter对象并通过CounterStatistics类进行更改。这需要小心地暴露数据收集足够多的方法。我们将把这种设计推迟到第8章（ch012.xhtml#x1-4520008）。
- en: Use lazy computations. See the [Using properties for lazy attributes](ch011_split_001.xhtml#x1-43100010)
    recipe in this chapter.
  id: totrans-162
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用延迟计算。参见本章中的[使用属性进行延迟属性](ch011_split_001.xhtml#x1-43100010)配方。
- en: Add a method to implement the computation of mean and standard deviation, so
    these can be recomputed after changing the underlying Counter object. This leads
    to refactoring the __init__() method to use this new computation method. We’ll
    leave this as an exercise for the reader.
  id: totrans-163
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 添加一个方法来实现计算平均值和标准差，这样在更改底层Counter对象后可以重新计算这些值。这导致重构__init__()方法以使用这种新的计算方法。我们将把这个留作读者的练习。
- en: Write documentation explaining the requirement to create a new CounterStatistics
    instance each time the underlying Counter object changes. This involves no code,
    merely an explicit statement of the constraints on the object’s state.
  id: totrans-164
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 编写文档说明每次底层 Counter 对象发生变化时创建新的 CounterStatistics 实例的要求。这不需要代码，只需明确说明对象状态上的约束即可。
- en: 7.3.5 See also
  id: totrans-165
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 7.3.5 参见
- en: In the [Extending a built-in collection – a list that does statistics](ch011_split_001.xhtml#x1-4250009)
    recipe, we’ll look at a different design approach where these new summary functions
    are used to extend a class definition.
  id: totrans-166
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在[扩展内置集合 – 统计列表](ch011_split_001.xhtml#x1-4250009)的菜谱中，我们将探讨一种不同的设计方法，其中这些新的汇总函数被用来扩展类定义。
- en: We’ll look at a different approach in the [Using properties for lazy attributes](ch011_split_001.xhtml#x1-43100010)
    recipe. This alternative recipe will use properties to compute the attributes
    as needed.
  id: totrans-167
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们将在[使用属性创建懒属性](ch011_split_001.xhtml#x1-43100010)的菜谱中探讨不同的方法。这个替代菜谱将使用属性按需计算属性。
- en: The wrap=extend design choice is also looked at in Chapter [8](ch012.xhtml#x1-4520008).
  id: totrans-168
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在第 [8](ch012.xhtml#x1-4520008) 章中，也探讨了 wrap=extend 设计选择。
- en: 7.4 Using typing.NamedTuple for immutable objects
  id: totrans-169
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 7.4 使用 typing.NamedTuple 创建不可变对象
- en: In some cases, an object is a container of rather complex data, but doesn’t
    really do very much processing on that data. Indeed, in many cases, we’ll define
    a class that doesn’t require any unique method functions. These classes are relatively
    passive containers of data items, without a lot of processing.
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 在某些情况下，一个对象是一个相对复杂数据的容器，但实际上并没有对数据进行很多处理。实际上，在许多情况下，我们将定义一个不需要任何独特方法函数的类。这些类是相对被动的数据项容器，没有太多的处理。
- en: In many cases, Python’s built-in container classes – list, set, or dict – can
    cover your use cases. The small problem is that the syntax for accessing an item
    in a dictionary or a list isn’t quite as elegant as the syntax for accessing an
    attribute of an object.
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 在许多情况下，Python 的内置容器类 – 列表、集合或字典 – 可以覆盖你的用例。小问题是，访问字典或列表中项的语法并不像访问对象属性那样优雅。
- en: How can we create a class that allows us to use object.attribute syntax instead
    of the more elaborate object[’attribute’]?
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 我们如何创建一个类，使我们能够使用 object.attribute 语法而不是更复杂的 object[‘attribute’] 语法？
- en: 7.4.1 Getting ready
  id: totrans-173
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 7.4.1 准备工作
- en: 'There are two cases for any kind of class design:'
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 任何类型的类设计都有两种情况：
- en: Is it stateless (or immutable)? Does it embody attributes with values that never
    change? This is a good example of a NamedTuple.
  id: totrans-175
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它是无状态的（或不可变的）吗？它是否包含永远不会改变的值的属性？这是一个 NamedTuple 的好例子。
- en: Is it stateful (or mutable)? Will there be state changes for one or more attributes?
    This is the default for Python class definitions. An ordinary class is stateful.
    We can simplify creating stateful objects using the [Using dataclasses for mutable
    objects](ch011_split_000.xhtml#x1-4010005) recipe.
  id: totrans-176
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它是有状态的（或可变的）吗？是否会有一个或多个属性的状态变化？这是 Python 类定义的默认情况。一个普通类是有状态的。我们可以使用[使用 dataclasses
    创建可变对象](ch011_split_000.xhtml#x1-4010005)的菜谱来简化创建有状态对象的过程。
- en: We’ll define a class to describe simple playing cards that have a rank and a
    suit. Since a card’s rank and suit don’t change, we’ll create a small stateless
    class for this. The typing.NamedTuple class serves as a handy base class for these
    kinds of class definitions.
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将定义一个类来描述具有点数和花色的简单扑克牌。由于牌的点数和花色不会改变，我们将为这个创建一个小型的无状态类。typing.NamedTuple 类是这类类定义的便捷基类。
- en: 7.4.2 How to do it...
  id: totrans-178
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 7.4.2 如何做...
- en: 'We’ll define stateless objects as a subclass of typing.NamedTuple:'
  id: totrans-179
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们将定义无状态对象为 typing.NamedTuple 的子类：
- en: '[PRE27]'
  id: totrans-180
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE27]'
- en: 'Define the class name as an extension to NamedTuple. Include the attributes
    with their individual type hints:'
  id: totrans-181
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将类名称定义为 NamedTuple 的扩展。包括具有各自类型提示的属性：
- en: '[PRE28]'
  id: totrans-182
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE28]'
- en: 'Here’s how we can use this class definition to create Card objects:'
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: 这是我们如何使用这个类定义来创建 Card 对象的方法：
- en: '[PRE29]'
  id: totrans-184
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: 'We’ve created a new class, named Card, which has two attribute names: rank
    and suit. After defining the class, we can create an instance of the class. We
    built a single Card object, eight_hearts, with a rank of eight and a suit of ♡.'
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: 我们创建了一个名为 Card 的新类，它有两个属性名称：rank 和 suit。在定义了类之后，我们可以创建类的实例。我们构建了一个单张 Card 对象，eight_hearts，其点数为八，花色为
    ♡。
- en: We can refer to attributes of this object with their name or their position
    within the tuple. When we use eight_hearts.rank or eight_hearts[0], we’ll see
    the value of the rank attribute because this attribute is defined first in the
    sequence of attribute names.
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以用其名称或其元组内的位置来引用这个对象的属性。当我们使用eight_hearts.rank或eight_hearts[0]时，我们会看到rank属性的值，因为该属性在属性名称序列中定义在第一位。
- en: 'This kind of object is immutable. Here’s an example of attempting to change
    the instance attributes:'
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: 这种类型的对象是不可变的。以下是一个尝试更改实例属性的示例：
- en: '[PRE30]'
  id: totrans-188
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: We attempted to change the suit attribute of the eight_hearts object. This raised
    an AttributeError exception showing that instances of NamedTuple are immutable.
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: 我们尝试更改eight_hearts对象的suit属性。这引发了一个AttributeError异常，表明命名元组的实例是不可变的。
- en: A tuple can contain objects of any type.
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: 元组可以包含任何类型的对象。
- en: When a tuple contains mutable items, like lists, sets, or dictionaries, those
    objects remain mutable.
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: 当元组包含可变项，如列表、集合或字典时，这些对象保持可变。
- en: Only the top-level containing tuple is immutable. Lists, sets, or dictionaries
    within a tuple are mutable.
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: 只有顶层包含的元组是不可变的。元组内的列表、集合或字典是可变的。
- en: 7.4.3 How it works...
  id: totrans-193
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 7.4.3 它是如何工作的...
- en: The typing.NamedTuple class lets us define a new subclass that has a well-defined
    list of attributes. A number of methods are created automatically to provide a
    minimal level of Python behavior. We can see an instance will display a readable
    text representation showing the values of the various attributes.
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: typing.NamedTuple类让我们定义一个具有明确定义属性列表的新子类。自动创建了一些方法，以提供最小级别的Python行为。我们可以看到一个实例将显示一个可读的文本表示，显示各种属性的值。
- en: In the case of a NamedTuple subclass, the behavior is based on the way a built-in
    tuple instance works. The order of the attributes defines the comparison between
    tuples. Our definition of Card, for example, lists the rank attribute first. This
    means that we can easily sort cards by rank. For two cards of equal rank, the
    suits will be sorted into order. Because a NamedTuple is also a tuple, it works
    well as a member of a set or a key for a dictionary.
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: 对于命名元组子类，其行为基于内置元组实例的工作方式。属性的顺序定义了元组之间的比较。例如，我们的Card定义首先列出rank属性。这意味着我们可以很容易地按等级排序牌。对于等级相同的两张牌，花色将按顺序排序。因为命名元组也是元组，所以它很好地作为集合的成员或字典的键。
- en: The two attributes, rank and suit in this example, are named as part of the
    class definition, but are implemented as instance variables. A variation on the
    tuple’s __new__() method is created for us. This method has two parameters matching
    the instance variable names. The automatically created method will assign argument
    values to the instance variables when the object is created.
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个例子中，rank和suit这两个属性作为类定义的一部分命名，但作为实例变量实现。为我们创建了一个元组的__new__()方法的变体。该方法有两个参数与实例变量名称匹配。自动创建的方法将在对象创建时将参数值分配给实例变量。
- en: 7.4.4 There’s more...
  id: totrans-197
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 7.4.4 更多...
- en: 'We can add methods to this class definition. For example, if each card has
    a number of points, we might want to extend the class to look like this example:'
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以向这个类定义添加方法。例如，如果每张牌都有一个点数，我们可能希望扩展类，使其看起来像以下示例：
- en: '[PRE31]'
  id: totrans-199
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: We’ve written a CardsPoints class with a points() method that returns the points
    assigned to each rank. This point rule applies to games like Cribbage, not to
    games like Blackjack.
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: 我们编写了一个CardsPoints类，它有一个points()方法，该方法返回分配给每个等级的点数。这种点规则适用于像克里比奇这样的游戏，而不适用于像黑杰克这样的游戏。
- en: Because this is a tuple, the methods cannot add new attributes or change the
    attributes. In some cases, we build complex tuples from other tuples.
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: 因为这是一个元组，所以方法不能添加新的属性或更改属性。在某些情况下，我们通过其他元组构建复杂的元组。
- en: 7.4.5 See also
  id: totrans-202
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 7.4.5 参见
- en: In the [Designing classes with lots of processing](ch011_split_000.xhtml#x1-3890003)
    recipe, we looked at a class that is entirely processing and almost no data. It
    acts as the polar opposite of this class.
  id: totrans-203
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在[设计大量处理的类](ch011_split_000.xhtml#x1-3890003)的配方中，我们查看了一个完全处理且几乎没有数据的类。它作为这个类的完全对立面。
- en: 7.5 Using dataclasses for mutable objects
  id: totrans-204
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 7.5 使用dataclasses处理可变对象
- en: 'We’ve noted two general kinds of objects in Python:'
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经记录了Python中的两种一般类型的对象：
- en: 'Immutable: During design, we’ll ask if something has attributes with values
    that never change. If the answer is yes, see the [Using typing.NamedTuple for
    immutable objects](ch011_split_000.xhtml#x1-3950004) recipe, which offers a way
    to build class definitions for immutable objects.'
  id: totrans-206
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 不可变：在设计过程中，我们会询问是否有属性具有永远不会改变的值。如果答案是肯定的，请参阅[使用 typing.NamedTuple 为不可变对象](ch011_split_000.xhtml#x1-3950004)菜谱，它提供了一种为不可变对象构建类定义的方法。
- en: 'Mutable: Will there be state changes for one or more attributes? In this case,
    we can either build a class from the ground up, or we can leverage the @dataclass
    decorator to create a class definition from a few attributes and type hints. This
    case is the focus of this recipe.'
  id: totrans-207
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 可变：一个或多个属性会有状态变化吗？在这种情况下，我们可以从头开始构建一个类，或者我们可以利用 @dataclass 装饰器从一些属性和类型提示中创建一个类定义。这个案例是这个菜谱的重点。
- en: How can we leverage the dataclasses library to help design mutable objects?
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: 我们如何利用 dataclasses 库来帮助设计可变对象？
- en: 7.5.1 Getting ready
  id: totrans-209
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 7.5.1 准备工作
- en: We’ll look closely at a mutable object with an internal state to represent a
    hand of cards. While individual cards are immutable, they can be inserted into
    a hand and removed from a hand. In a game like Cribbage, the hand has a number
    of state changes. Initially, six cards are dealt to both players. The players
    will each lay away a pair of cards to create the crib. The remaining four cards
    are then played alternately to create scoring opportunities. The hands are then
    counted in isolation, with a slightly different mix of scoring opportunities.
    The dealer gets the score from counting the cards in the crib as an extra hand.
    (Yes, it’s unfair initially, but the deal alternates, so it’s eventually fair.)
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将仔细研究一个具有内部状态的可变对象，以表示一副牌。虽然单个卡片是不可变的，但它们可以被插入到一副牌中并从一副牌中移除。在像克里比（Cribbage）这样的游戏中，手牌会有许多状态变化。最初，六张牌被分给两位玩家。玩家将各自放下一对牌来创建克里比。然后，剩下的四张牌交替出牌，以创造得分机会。然后，手牌在隔离状态下计数，得分机会的混合略有所不同。庄家从计数克里比中的牌中获得额外的手牌得分。（是的，最初是不公平的，但发牌轮流进行，所以最终是公平的。）
- en: We’ll look at a simple collection to hold the cards and discard two that form
    the crib.
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将研究一个简单的集合来存放卡片，并丢弃形成克里比的两张卡片。
- en: 7.5.2 How to do it...
  id: totrans-212
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 7.5.2 如何操作...
- en: 'To define data classes, we’ll import the @dataclass decorator:'
  id: totrans-213
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 为了定义数据类，我们将导入 @dataclass 装饰器：
- en: '[PRE32]'
  id: totrans-214
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE32]'
- en: 'Define the new class using the @dataclass decorator:'
  id: totrans-215
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用 @dataclass 装饰器定义新的类：
- en: '[PRE33]'
  id: totrans-216
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE33]'
- en: 'Define the various attributes with appropriate type hints. For this example,
    we’ll expect a player to have a collection of cards represented by list[CardPoints].
    Because each card is unique, we could also use a set[CardPoints] type hint:'
  id: totrans-217
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用适当的类型提示定义各种属性。在这个例子中，我们期望玩家拥有一组由 list[CardPoints] 表示的卡片集合。因为每张卡片都是唯一的，我们也可以使用
    set[CardPoints] 类型提示：
- en: '[PRE34]'
  id: totrans-218
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE34]'
- en: 'Define any methods that change the state of the object:'
  id: totrans-219
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 定义任何会改变对象状态的函数：
- en: '[PRE35]'
  id: totrans-220
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE35]'
- en: 'Here’s the complete class definition, properly indented:'
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
  zh: 这是完整的类定义，正确缩进：
- en: '[PRE36]'
  id: totrans-222
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: This definition provides a single instance variable, self.cards, that can be
    used by any method that is written. Because we provided a type hint, the mypy
    program can check the class to be sure that it is being used properly.
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
  zh: 这个定义提供了一个单一的实例变量 self.cards，它可以被任何编写的函数使用。因为我们提供了类型提示，所以 mypy 程序可以检查类以确保它被正确使用。
- en: 'Here’s how it looks when we create an instance of this CribbageHand class:'
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
  zh: 这是创建这个 CribbageHand 类实例时的样子：
- en: '[PRE37]'
  id: totrans-225
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: 'In the following example, the player decided (perhaps unwisely) to lay away
    the 3♢ and A♠ cards for the crib:'
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
  zh: 在以下示例中，玩家决定（可能不明智）将 3♢ 和 A♠ 卡片放进行克里比：
- en: '[PRE38]'
  id: totrans-227
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: After the to_crib() method removed two cards from the hand, the remaining four
    cards were displayed. Another list comprehension was created with the point values
    of the remaining four cards.
  id: totrans-228
  prefs: []
  type: TYPE_NORMAL
  zh: 在 to_crib() 方法从手中移除两张卡片后，剩余的四张卡片被显示出来。然后创建了一个新的列表推导式，包含剩余四张卡片的点数。
- en: 7.5.3 How it works...
  id: totrans-229
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 7.5.3 它是如何工作的...
- en: The @dataclass decorator helps us define a class with several useful methods
    as well as a list of attributes drawn from the named variables and their type
    hints. We can see that an instance displays a readable text representation showing
    the values of the various attributes.
  id: totrans-230
  prefs: []
  type: TYPE_NORMAL
  zh: '@dataclass 装饰器帮助我们定义一个具有几个有用方法以及从命名变量及其类型提示中抽取的属性列表的类。我们可以看到，一个实例显示了一个可读的文本表示，显示了各种属性的值。'
- en: The attributes are named as part of the class definition, but are actually implemented
    as instance variables. In this example, there’s only one attribute, cards. A very
    sophisticated __init__() method is created for us. In this example, it will have
    a parameter that matches the name of each instance variable and will assign the
    argument value to a matching instance variable.
  id: totrans-231
  prefs: []
  type: TYPE_NORMAL
  zh: 属性作为类定义的一部分命名，但实际上作为实例变量实现。在这个例子中，只有一个属性，cards。为我们创建了一个非常复杂的__init__()方法。在这个例子中，它将有一个与每个实例变量名称匹配的参数，并将参数值分配给匹配的实例变量。
- en: 'The @dataclass decorator has a number of options to help us choose what features
    we want in the class. Here are the options we can select from and the default
    settings:'
  id: totrans-232
  prefs: []
  type: TYPE_NORMAL
  zh: '@dataclass装饰器有几个选项可以帮助我们选择我们想要的类特性。以下是我们可以选择的选项和默认设置：'
- en: 'init=True: By default, an __init__() method will be created with parameters
    to match the instance variables.'
  id: totrans-233
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: init=True：默认情况下，将创建一个__init__()方法，其参数与实例变量相匹配。
- en: 'repr=True: By default, a __repr__() method will be created to return a string
    showing the state of the object.'
  id: totrans-234
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: repr=True：默认情况下，将创建一个__repr__()方法来返回显示对象状态的字符串。
- en: 'eq=True: By default, the __eq__() and __ne__() methods are provided. These
    methods implement the == and != operators.'
  id: totrans-235
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: eq=True：默认情况下，提供了__eq__()和__ne__()方法。这些方法实现了==和!=运算符。
- en: 'order=False: The __lt__(), __le__(), __gt__(), and __ge__() methods are not
    created automatically. These methods implement the <, <=, >, and >= operators.'
  id: totrans-236
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: order=False：不会自动创建__lt__(), __le__(), __gt__(), 和 __ge__()方法。这些方法实现了<, <=, >,
    和 >=运算符。
- en: 'unsafe_hash=False: Normally, mutable objects do not have hash values, and cannot
    be used as keys for dictionaries or elements of a set. It’s possible to have a
    __hash__() method added automatically, but this is rarely a sensible choice for
    mutable objects, which is why the option is called an ”unsafe” hash.'
  id: totrans-237
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: unsafe_hash=False：通常，可变对象没有哈希值，不能用作字典的键或集合的元素。可以自动添加__hash__()方法，但这很少是可变对象的一个明智选择，这就是为什么这个选项被称为“不安全”的哈希。
- en: 'frozen=False: This creates an immutable object. See the [Using frozen dataclasses
    for immutable objects](ch011_split_000.xhtml#x1-4070006) recipe in this chapter
    for more details.'
  id: totrans-238
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: frozen=False：这创建了一个不可变对象。有关更多详细信息，请参阅本章中的[使用冻结数据类创建不可变对象](ch011_split_000.xhtml#x1-4070006)配方。
- en: Because a great deal of code is written for us, we can focus on the attributes
    of the class definition. We can write the methods that are truly distinctive and
    avoid writing ”boilerplate” methods that have obvious definitions.
  id: totrans-239
  prefs: []
  type: TYPE_NORMAL
  zh: 由于为我们编写了大量的代码，我们可以专注于类定义的属性。我们可以编写真正有特色的函数，避免编写具有明显定义的“样板”方法。
- en: 7.5.4 There’s more...
  id: totrans-240
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 7.5.4 更多...
- en: A hand of cards requires an initialization method to provide the collection
    of Card objects. A default __init__() method can populate the collection.
  id: totrans-241
  prefs: []
  type: TYPE_NORMAL
  zh: 一副牌需要一种初始化方法来提供Card对象的集合。一个默认的__init__()方法可以填充这个集合。
- en: Consider creating a deck of cards, in contrast to a hand of cards. The initial
    deck of cards is an example of a dataclass that doesn’t need an initialization
    method to set the instance variables. Instead, a deck of cards needs a customized
    __init__() method without any parameters; it always creates the same collection
    of 52 Card objects. This means we’ll use init=False in the @dataclass decorator
    to define this method for a Deck class definition.
  id: totrans-242
  prefs: []
  type: TYPE_NORMAL
  zh: 考虑创建一副牌，而不是一手牌。初始牌组是一个不需要初始化方法来设置实例变量的数据类的例子。相反，牌组需要一个没有参数的自定义__init__()方法；它总是创建相同的52个Card对象集合。这意味着我们将使用init=False在@dataclass装饰器中定义这个方法，用于Deck类定义。
- en: The general pattern for @dataclass definitions is to provide class-level names,
    which are used to both define the instance variables and also create the initialization
    method, __init__(). This covers a common use case for stateful objects.
  id: totrans-243
  prefs: []
  type: TYPE_NORMAL
  zh: '@dataclass定义的一般模式是提供类级别的名称，这些名称既用于定义实例变量，也用于创建初始化方法__init__()。这涵盖了状态对象的一个常见用例。'
- en: In some cases, however, we want to define a class-level variable that is not
    used to create instance variables, but will remain a class-level variable. This
    is done with the ClassVar type hint. A ClassVar type indicates a class-level variable
    that is not part of the instance variables or the __init__() method.
  id: totrans-244
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，在某些情况下，我们想要定义一个不用于创建实例变量但将保留为类级别变量的类级别变量。这可以通过ClassVar类型提示来完成。ClassVar类型表示一个不是实例变量或__init__()方法部分的类级别变量。
- en: 'In the following example, we’ll create a class variable with a sequence of
    suit strings:'
  id: totrans-245
  prefs: []
  type: TYPE_NORMAL
  zh: 在以下示例中，我们将创建一个具有花色字符串序列的类变量：
- en: '[PRE39]'
  id: totrans-246
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: This example class definition provides a class-level variable, SUITS, which
    is part of the Deck class. This variable is a tuple of the characters used to
    define the suits.
  id: totrans-247
  prefs: []
  type: TYPE_NORMAL
  zh: 此示例类定义提供了一个类级变量 `SUITS`，它是 `Deck` 类的一部分。此变量是用于定义花色的字符的元组。
- en: The cards variable has a hint claiming it will have the list[CardPoints] type.
    This information is used by the mypy program to confirm that the body of the __init__()
    method performs the proper initialization of this attribute. It also confirms
    that this attribute is used appropriately by other classes.
  id: totrans-248
  prefs: []
  type: TYPE_NORMAL
  zh: '`cards` 变量有一个提示表明它将具有 `list[CardPoints]` 类型。此信息被 `mypy` 程序用于确认 `__init__()`
    方法的主体正确初始化了此属性。它还确认此属性被其他类适当地使用。'
- en: 7.5.5 See also
  id: totrans-249
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 7.5.5 参考信息
- en: See the [Using typing.NamedTuple for immutable objects](ch011_split_000.xhtml#x1-3950004)
    recipe for a way to build class definitions for stateless objects.
  id: totrans-250
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 查看[使用 `typing.NamedTuple` 构建无状态对象](ch011_split_000.xhtml#x1-3950004) 菜单了解如何为无状态对象构建类定义。
- en: The [Using a class to encapsulate data and processing](ch011_split_000.xhtml#x1-3770001)
    recipe covers techniques for building a class without the additional methods created
    by the @dataclass decorator.
  id: totrans-251
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[使用类封装数据和处理](ch011_split_000.xhtml#x1-3770001) 菜单涵盖了构建不使用 `@dataclass` 装饰器创建的额外方法的类技术。'
- en: 7.6 Using frozen dataclasses for immutable objects
  id: totrans-252
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 7.6 使用冻结数据类实现不可变对象
- en: In the [Using typing.NamedTuple for immutable objects](ch011_split_000.xhtml#x1-3950004)
    recipe, we saw how to define a class that has a fixed set of attributes. The attributes
    can be checked by the mypy program to ensure that they’re being used properly.
    In some cases, we might want to make use of the slightly more flexible dataclass
    to create an immutable object.
  id: totrans-253
  prefs: []
  type: TYPE_NORMAL
  zh: 在 [使用 `typing.NamedTuple` 构建无状态对象](ch011_split_000.xhtml#x1-3950004) 菜单中，我们看到了如何定义具有固定属性集的类。这些属性可以通过
    `mypy` 程序进行检查，以确保它们被正确使用。在某些情况下，我们可能想使用稍微更灵活的数据类来创建不可变对象。
- en: One potential reason for using a dataclass is because it can have more complex
    field definitions than a NamedTuple subclass. Another potential reason is the
    ability to customize the initialization and the hashing function that is created.
    Because a NamedTuple is essentially a tuple, there’s limited ability to fine-tune
    the behavior of the instances in this class.
  id: totrans-254
  prefs: []
  type: TYPE_NORMAL
  zh: 使用数据类的一个潜在原因是因为它比 `NamedTuple` 子类具有更复杂的字段定义。另一个潜在原因是能够自定义初始化和创建的哈希函数。由于 `NamedTuple`
    实质上是一个元组，因此在此类中调整实例的行为的能力有限。
- en: 7.6.1 Getting ready
  id: totrans-255
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 7.6.1 准备工作
- en: We’ll revisit the idea of defining simple playing cards with rank and suit.
    The rank can be modeled by an integer between 1 (ace) and 13 (king.) The suit
    can be modeled by a single Unicode character from the set {’♠’, ’♡’, ’♢’, ’♣’}.
    Since a card’s rank and suit don’t change, we’ll create a small, frozen dataclass
    for this.
  id: totrans-256
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将重新审视定义具有等级和花色的简单扑克牌的想法。等级可以通过介于 1（A）和 13（K）之间的整数来表示。花色可以通过集合 {‘♠’，‘♡’，‘♢’，‘♣’}
    中的单个 Unicode 字符来表示。由于牌的等级和花色不会改变，我们将创建一个小的、冻结的数据类来表示这一点。
- en: 7.6.2 How to do it...
  id: totrans-257
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 7.6.2 如何实现...
- en: 'From the dataclasses module, import the dataclass decorator:'
  id: totrans-258
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 从 `dataclasses` 模块导入 `dataclass` 装饰器：
- en: '[PRE40]'
  id: totrans-259
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE40]'
- en: 'Start the class definition with the @dataclass decorator, using the frozen=True
    option to ensure that the objects are immutable. We’ve also included order=True
    so that the comparison operators are defined, allowing instances of this class
    to be sorted into order:'
  id: totrans-260
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用 `@dataclass` 装饰器开始类定义，使用 `frozen=True` 选项确保对象是不可变的。我们还包含了 `order=True` 以定义比较运算符，允许将此类实例按顺序排序：
- en: '[PRE41]'
  id: totrans-261
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE41]'
- en: 'Provide the attribute names and type hints for the attributes of each instance
    of this class:'
  id: totrans-262
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 为此类每个实例的属性提供属性名称和类型提示：
- en: '[PRE42]'
  id: totrans-263
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE42]'
- en: 'We can use these objects in code as follows:'
  id: totrans-264
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以在代码中如下使用这些对象：
- en: '[PRE43]'
  id: totrans-265
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: 'We’ve created an instance of the Card class with a specific value for the rank
    and suit attributes. Because the object is immutable, any attempt to change the
    state will result in an exception that looks like the following example:'
  id: totrans-266
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经创建了一个具有特定等级和花色属性的 `Card` 类实例。由于该对象是不可变的，任何尝试更改状态的操作都将导致一个异常，如下面的示例所示：
- en: '[PRE44]'
  id: totrans-267
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: This shows an attempt to change an attribute of a frozen dataclass instance.
    The dataclasses.FrozenInstanceError exception is raised to signal that this kind
    of operation is not permitted.
  id: totrans-268
  prefs: []
  type: TYPE_NORMAL
  zh: 这显示了尝试更改冻结数据类实例的属性。`dataclasses.FrozenInstanceError` 异常被抛出以表示此类操作是不允许的。
- en: 7.6.3 How it works...
  id: totrans-269
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 7.6.3 它是如何工作的...
- en: This @dataclass decorator adds a number of built-in methods to a class definition.
    As we noted in the [Using dataclasses for mutable objects](ch011_split_000.xhtml#x1-4010005)
    recipe, there are a number of features that can be enabled or disabled. Each feature
    may lead us to include one or several individual methods in the class definition.
  id: totrans-270
  prefs: []
  type: TYPE_NORMAL
  zh: 这个 @dataclass 装饰器向类定义中添加了多个内置方法。正如我们在[使用 dataclasses 处理可变对象](ch011_split_000.xhtml#x1-4010005)配方中提到的，有一些特性可以被启用或禁用。每个特性可能会让我们在类定义中包含一个或多个单独的方法。
- en: 7.6.4 There’s more...
  id: totrans-271
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 7.6.4 更多内容...
- en: The @dataclass initialization method is quite sophisticated. We’ll look at one
    feature that’s sometimes handy for defining optional attributes.
  id: totrans-272
  prefs: []
  type: TYPE_NORMAL
  zh: '@dataclass 初始化方法相当复杂。我们将探讨一个有时很有用的特性，用于定义可选属性。'
- en: Consider a class that can hold a hand of cards. While the common use case provides
    a set of cards to initialize the hand, we can also have hands that might be built
    incrementally, starting with an empty collection and adding cards during the game.
  id: totrans-273
  prefs: []
  type: TYPE_NORMAL
  zh: 考虑一个可以持有牌手的类。虽然常见用例提供了牌集来初始化手，但我们也可以有在游戏中逐步构建的手，从空集合开始，并在游戏过程中添加牌。
- en: 'We can define this kind of optional attribute using the field() function from
    the dataclasses module. The field() function lets us provide a function to build
    default values, called default_factory. We’d use it as shown in the following
    example:'
  id: totrans-274
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以使用 dataclasses 模块中的 field() 函数定义这种可选属性。field() 函数允许我们提供一个函数来构建默认值，称为 default_factory。我们将在以下示例中这样使用它：
- en: '[PRE45]'
  id: totrans-275
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: 'The Hand dataclass has a single attribute, cards, which is a list of CardPoints
    objects. The field() function provides a default factory: in the event no initial
    value is provided, the list() function will be executed to create a new, empty
    list.'
  id: totrans-276
  prefs: []
  type: TYPE_NORMAL
  zh: Hand dataclass 有一个单一属性，cards，它是一个 CardPoints 对象的列表。field() 函数提供了一个默认工厂：如果没有提供初始值，将执行
    list() 函数来创建一个新的空列表。
- en: 'We can create two kinds of hands with this dataclass. Here’s the conventional
    example, where we deal six cards:'
  id: totrans-277
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以使用这个 dataclass 创建两种类型的手。以下是一个传统示例，其中我们处理六张牌：
- en: '[PRE46]'
  id: totrans-278
  prefs: []
  type: TYPE_PRE
  zh: '[PRE46]'
- en: 'The Hands() type expects a single attribute, matching the definition of the
    attributes in the class. This is optional, and we can build an empty hand as shown
    in this example:'
  id: totrans-279
  prefs: []
  type: TYPE_NORMAL
  zh: The Hands() 类型期望一个单一属性，与该类中属性的定义相匹配。这是可选的，我们可以像以下示例中那样构建一个空手：
- en: '[PRE47]'
  id: totrans-280
  prefs: []
  type: TYPE_PRE
  zh: '[PRE47]'
- en: In this example, we’ve created a Hand() instance with no argument values, assigned
    to the crib variable. Because the cards attribute was defined with a field that
    provided a default_factory, the list() function will be used to create an empty
    list for the cards attribute.
  id: totrans-281
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个例子中，我们创建了一个没有参数值的 Hand() 实例，并将其分配给 crib 变量。由于 cards 属性是用提供了一个 default_factory
    的字段定义的，因此将使用 list() 函数为 cards 属性创建一个空列表。
- en: 7.6.5 See also
  id: totrans-282
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 7.6.5 另请参阅
- en: The [Using dataclasses for mutable objects](ch011_split_000.xhtml#x1-4010005)
    recipe covers some additional topics on using dataclasses to avoid some of the
    complexities of writing class definitions.
  id: totrans-283
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[使用 dataclasses 处理可变对象](ch011_split_000.xhtml#x1-4010005)配方涵盖了使用 dataclasses
    避免编写类定义复杂性的额外主题。'
- en: 7.7 Optimizing small objects with __slots__
  id: totrans-284
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 7.7 使用 __slots__ 优化小对象
- en: The general case for an object allows a dynamic collection of attributes. There’s
    a special case for an object with a fixed collection of attributes based on the
    tuple class. We looked at both of these in the [Using typing.NamedTuple for immutable
    objects](ch011_split_000.xhtml#x1-3950004) recipe.
  id: totrans-285
  prefs: []
  type: TYPE_NORMAL
  zh: 对象的一般情况允许动态属性集合。对于基于元组类的固定属性集合的对象有一个特殊情况。我们在[使用 typing.NamedTuple 处理不可变对象](ch011_split_000.xhtml#x1-3950004)配方中探讨了这两个。
- en: There’s a middle ground. We can also define an object with a fixed number of
    attributes, but the values of the attributes can be changed. By changing the class
    from an unlimited collection of attributes to a fixed set of attributes, it turns
    out that we can also save memory and processing time.
  id: totrans-286
  prefs: []
  type: TYPE_NORMAL
  zh: 存在一个折衷方案。我们也可以定义一个具有固定数量属性的对象，但属性的值可以更改。通过将类从无限属性集合转换为固定属性集，我们发现我们还可以节省内存和处理时间。
- en: How can we create optimized classes with a fixed set of attributes?
  id: totrans-287
  prefs: []
  type: TYPE_NORMAL
  zh: 我们如何创建具有固定属性集的优化类？
- en: 7.7.1 Getting ready
  id: totrans-288
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 7.7.1 准备工作
- en: Generally, Python allows adding attributes to an object. This can be undesirable,
    particularly when working with a large number of objects. The flexibility of the
    way most class definitions use a dictionary has a cost in memory use. Using specific
    __slots__ names limits the class to the named attributes, saving memory.
  id: totrans-289
  prefs: []
  type: TYPE_NORMAL
  zh: 通常，Python允许向对象添加属性。这可能是不可取的，尤其是在处理大量对象时。大多数类定义使用字典的方式的灵活性在内存使用上是有代价的。使用特定的__slots__名称将类限制在命名属性上，从而节省内存。
- en: 'The card game of Cribbage, for example, has a few components:'
  id: totrans-290
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，Cribbage纸牌游戏有几个组成部分：
- en: A deck of cards.
  id: totrans-291
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一副牌。
- en: Two players, who will alternate in the role of dealer and opponent.
  id: totrans-292
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 两名玩家，他们将轮流担任庄家和对手的角色。
- en: This small domain of things seems like a candidate for a class definition. Each
    player has a hand of cards and a score. The player’s role is an interesting complication.
    There are import differences in the two roles.
  id: totrans-293
  prefs: []
  type: TYPE_NORMAL
  zh: 这个小领域的事物似乎适合作为类定义的候选。每位玩家都有一手牌和一个分数。玩家的角色是一个有趣的复杂因素。两个角色之间有一些重要差异。
- en: The player who is the dealer gets the crib cards.
  id: totrans-294
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 作为庄家的玩家将获得crib牌。
- en: If the starter card is a Jack, the player in the dealer role gets points for
    this.
  id: totrans-295
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果起始牌是JACK，庄家角色将为此获得分数。
- en: The opponent plays the first card.
  id: totrans-296
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 对手先出第一张牌。
- en: The opponent counts their hand first.
  id: totrans-297
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 对手先计算他们的手牌。
- en: The dealer plays from their hand, but counts their hand and the crib.
  id: totrans-298
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 庄家从他们的手中出牌，但计算他们的手牌和crib。
- en: The specific order of play and counting hands is important because the first
    player to pass 120 points is the winner, no matter what state the game is in.
  id: totrans-299
  prefs: []
  type: TYPE_NORMAL
  zh: 比赛的特定顺序和计分方式很重要，因为第一个通过120分的玩家就是赢家，无论游戏处于何种状态。
- en: It seems like the Cribbage game includes a deck of cards and two players. The
    crib – which belongs to the dealer – can be seen as a feature of the game overall.
    We’ll look at ways to switch the role between dealer and opponent when a new round
    of play starts.
  id: totrans-300
  prefs: []
  type: TYPE_NORMAL
  zh: 看起来Cribbage游戏包括一副牌和两名玩家。属于庄家的crib（底牌）可以被视为游戏整体的一个特性。当新一轮游戏开始时，我们将探讨如何切换庄家和对手的角色。
- en: 7.7.2 How to do it...
  id: totrans-301
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 7.7.2 如何实现...
- en: 'We’ll leverage the __slots__ special name when creating the class:'
  id: totrans-302
  prefs: []
  type: TYPE_NORMAL
  zh: 在创建类时，我们将利用__slots__特殊名称：
- en: 'Define the class with a descriptive name:'
  id: totrans-303
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 定义一个具有描述性名称的类：
- en: '[PRE48]'
  id: totrans-304
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE48]'
- en: 'Define the list of attribute names. This identifies the only two attributes
    that are allowed for instances of this class. Any attempt to add another attribute
    will raise an AttributeError exception:'
  id: totrans-305
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 定义属性名称列表。这标识了允许此类实例的唯一两个属性。任何尝试添加另一个属性都将引发AttributeError异常：
- en: '[PRE49]'
  id: totrans-306
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE49]'
- en: 'Add an initialization method. This must create instance variables for the named
    slots:'
  id: totrans-307
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 添加一个初始化方法。这必须为命名槽位创建实例变量：
- en: '[PRE50]'
  id: totrans-308
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE50]'
- en: The Deck class definition is shown in the [Using dataclasses for mutable objects](ch011_split_000.xhtml#x1-4010005)
    recipe in this chapter.
  id: totrans-309
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: Deck类的定义在本章的[使用dataclasses创建可变对象](ch011_split_000.xhtml#x1-4010005)配方中展示。
- en: Add methods to update the collection. For this example, we’ve defined a method
    to switch roles.
  id: totrans-310
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 添加更新集合的方法。在这个例子中，我们定义了一个切换角色的方法。
- en: '[PRE51]'
  id: totrans-311
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE51]'
- en: 'Here’s how we can use this class to build a hand of cards. We’ll need the definition
    of the Card class based on the example in the [Using typing.NamedTuple for immutable
    objects](ch011_split_000.xhtml#x1-3950004) recipe:'
  id: totrans-312
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是我们可以使用此类构建一手牌的方法。我们需要Card类的定义，基于[使用typing.NamedTuple创建不可变对象](ch011_split_000.xhtml#x1-3950004)配方中的示例：
- en: '[PRE52]'
  id: totrans-313
  prefs: []
  type: TYPE_PRE
  zh: '[PRE52]'
- en: The initial Cribbage object was created with a Deck and two Player instances.
    These three objects filled in the the deck and players slots. The __init__() method
    then randomized the players, making one of them the dealer and the other the opponent.
    The crib was initialized to an empty Hand instance.
  id: totrans-314
  prefs: []
  type: TYPE_NORMAL
  zh: 初始的Cribbage对象是用Deck和两个Player实例创建的。这三个对象填充了牌和玩家槽位。然后__init__()方法随机化玩家，使其中一名成为庄家，另一名成为对手。crib被初始化为一个空的Hand实例。
- en: The new_deal() method makes a number of changes to the state of the Cribbage
    instance. This is revealed when the dealer and opponent attributes are examined.
  id: totrans-315
  prefs: []
  type: TYPE_NORMAL
  zh: new_deal()方法会对Cribbage实例的状态进行多项更改。这可以通过检查庄家和对手属性来揭示。
- en: 'Here’s what happens if we try to create a new attribute:'
  id: totrans-316
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们尝试创建一个新属性，会发生以下情况：
- en: '[PRE53]'
  id: totrans-317
  prefs: []
  type: TYPE_PRE
  zh: '[PRE53]'
- en: We attempted to create an attribute named some_other_attribute on the Cribbage
    object, c. This raised an AttributeError exception. Using __slots__ means that
    new attributes cannot be added to an instance of the class.
  id: totrans-318
  prefs: []
  type: TYPE_NORMAL
  zh: 我们尝试在Cribbage对象c上创建一个名为some_other_attribute的属性。这引发了一个AttributeError异常。使用__slots__意味着不能向类的实例添加新属性。
- en: 7.7.3 How it works...
  id: totrans-319
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 7.7.3 它是如何工作的...
- en: When we create an object instance, the steps in the process are defined in part
    by the object’s class and the built-in type() function. Implicitly, a class has
    a special __new__() method that handles the internal house-keeping required to
    create a new, empty object. After this, the __init__() method creates and initializes
    the attributes.
  id: totrans-320
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们创建一个对象实例时，该过程中的步骤部分由对象的类和内置的 type() 函数定义。隐式地，一个类有一个特殊的 __new__() 方法，用于处理创建新、空对象所需的内部管理。之后，__init__()
    方法创建并初始化属性。
- en: 'Python has three essential paths for creating instances of a class:'
  id: totrans-321
  prefs: []
  type: TYPE_NORMAL
  zh: Python 有三个创建类实例的基本路径：
- en: The default behavior, defined by the built-ins object and type(), is used when
    we define a class without doing anything unusual. Each instance contains a __dict__
    attribute that is used to hold all other attributes. Because the object’s attributes
    are kept in a dictionary, we can add, change, and delete attributes freely. This
    flexibility requires the use of additional memory for the dictionary object inside
    each instance.
  id: totrans-322
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 当我们定义一个类而没有做任何不寻常的事情时，默认行为是由内置的 object 和 type() 函数定义的。每个实例都包含一个 __dict__ 属性，用于存储所有其他属性。因为对象的属性保存在字典中，所以我们可以自由地添加、更改和删除属性。这种灵活性需要为每个实例内部的字典对象使用额外的内存。
- en: The __slots__ behavior avoids creating the __dict__ attribute. Because the object
    has only the attributes named in the __slots__ sequence, we can’t add or delete
    attributes. We can change the values of the defined attributes. This lack of flexibility
    means that less memory is used for each object.
  id: totrans-323
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: __slots__ 行为避免了创建 __dict__ 属性。因为对象只有 __slots__ 序列中命名的属性，所以我们不能添加或删除属性。我们可以更改定义的属性值。这种缺乏灵活性意味着每个对象使用的内存更少。
- en: The subclass of tuple behavior defines immutable objects. An easy way to create
    these classes is with typing.NamedTuple as a parent class. Once built, the instances
    are immutable and cannot be changed. While it’s possible to directly subclass
    tuple, the extra features of a NamedTuple seem to make this ideal.
  id: totrans-324
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 元组子类的行为定义了不可变对象。创建这些类的一个简单方法是以 typing.NamedTuple 作为父类。一旦构建，实例就是不可变的，不能被更改。虽然可以直接从元组中派生，但
    NamedTuple 的额外功能似乎使这成为理想的选择。
- en: A large application might be constrained by the amount of memory used, and switching
    the class with the largest number of instances to __slots__ can lead to an improvement
    in performance.
  id: totrans-325
  prefs: []
  type: TYPE_NORMAL
  zh: 一个大型应用程序可能会受到内存使用的限制，将具有最大实例数的类切换到 __slots__ 可以提高性能。
- en: 7.7.4 There’s more...
  id: totrans-326
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 7.7.4 更多...
- en: It’s possible to tailor the way the __new__() method works to replace the default
    __dict__ attribute with a different kind of dictionary. This is an advanced technique
    because it exposes the inner workings of classes and objects.
  id: totrans-327
  prefs: []
  type: TYPE_NORMAL
  zh: 可以调整 __new__() 方法的工作方式，用不同类型的字典替换默认的 __dict__ 属性。这是一个高级技术，因为它暴露了类和对象的内部工作原理。
- en: Python relies on a metaclass to create instances of a class. The default metaclass
    is the type class. The idea is that the metaclass provides a few pieces of functionality
    that are used to create each object. Once the empty object has been created, then
    the class’s __init__() method will initialize the empty object.
  id: totrans-328
  prefs: []
  type: TYPE_NORMAL
  zh: Python 依赖于元类来创建类的实例。默认的元类是 type 类。其思想是元类提供了一些用于创建每个对象的功能。一旦创建了空对象，类的 __init__()
    方法将初始化这个空对象。
- en: Generally, a metaclass will provide a definition of __new__(), and perhaps __prepare__(),
    if there’s a need to customize the object. There’s a widely used example in the
    Python Language Reference document that tweaks the namespace used to create a
    class.
  id: totrans-329
  prefs: []
  type: TYPE_NORMAL
  zh: 通常，元类会提供一个 __new__() 方法的定义，如果需要定制对象，可能还会提供 __prepare__()。Python 语言参考文档中有一个广泛使用的例子，它调整了用于创建类的命名空间。
- en: For more details, see [https://docs.python.org/3/reference/datamodel.html#metaclass-example](https://docs.python.org/3/reference/datamodel.html#metaclass-example).
  id: totrans-330
  prefs: []
  type: TYPE_NORMAL
  zh: 更多详情，请参阅 [https://docs.python.org/3/reference/datamodel.html#metaclass-example](https://docs.python.org/3/reference/datamodel.html#metaclass-example)。
- en: 7.7.5 See also
  id: totrans-331
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 7.7.5 参见
- en: The more common cases of an immutable object or a completely flexible object
    are covered in the [Using typing.NamedTuple for immutable objects](ch011_split_000.xhtml#x1-3950004)
    recipe.
  id: totrans-332
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 不可变对象或完全灵活对象的更常见情况在 [使用 typing.NamedTuple 创建不可变对象](ch011_split_000.xhtml#x1-3950004)
    章节中进行了介绍。
- en: 7.8 Using more sophisticated collections
  id: totrans-333
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 7.8 使用更复杂的集合
- en: Python has a wide variety of built-in collections. In Chapter [4](ch008_split_000.xhtml#x1-2240004),
    we looked at them closely. In the [Choosing a data structure](ch008_split_000.xhtml#x1-2250001)
    recipe, we provided a kind of decision tree to help locate the appropriate data
    structure from the available choices.
  id: totrans-334
  prefs: []
  type: TYPE_NORMAL
  zh: Python拥有丰富的内置集合。在第[4](ch008_split_000.xhtml#x1-2240004)章中，我们对其进行了详细探讨。在[选择数据结构](ch008_split_000.xhtml#x1-2250001)的配方中，我们提供了一个决策树，以帮助从可用的选择中定位适当的数据结构。
- en: When we consider built-in types and other data structures in the standard library,
    we have more choices, and more decisions to make. How can we choose the right
    data structure for our problem?
  id: totrans-335
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们考虑标准库中的内置类型和其他数据结构时，我们有更多的选择，需要做出的决定也更多。我们如何为我们的问题选择正确的数据结构？
- en: 7.8.1 Getting ready
  id: totrans-336
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 7.8.1 准备工作
- en: Before we put data into a collection, we’ll need to consider how we’ll gather
    the data, and what we’ll do with the collection once we have it. The big question
    is always how we’ll identify a particular item within the collection. We’ll look
    at a few key questions that we need to answer to help select a proper collection
    for our needs.
  id: totrans-337
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们将数据放入集合之前，我们需要考虑我们将如何收集数据，以及一旦我们拥有它，我们将如何处理这个集合。始终存在的一个大问题是我们在集合中如何识别特定的项目。我们将探讨一些关键问题，这些问题需要我们回答，以帮助我们选择适合我们需求的适当集合。
- en: 'Here’s an overview of some of the alternative collections. The collections
    module contains a number of variations on the built-in collections. These include
    the following:'
  id: totrans-338
  prefs: []
  type: TYPE_NORMAL
  zh: 这里是一些替代集合的概述。collections模块包含许多内置集合的变体。以下是一些包括的内容：
- en: 'deque: A double-ended queue. This is a mutable sequence with optimizations
    for pushing and popping from each end. Note that the class name starts with a
    lowercase letter; this is atypical for Python.'
  id: totrans-339
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: deque：一个双端队列。这是一个可变序列，对从两端推入和弹出进行了优化。请注意，类名以小写字母开头；这在Python中是不典型的。
- en: 'defaultdict: A mapping that can provide a default value for a missing key.
    Note that the class name starts with a lowercase letter; this is atypical for
    Python.'
  id: totrans-340
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: defaultdict：一种可以为一个缺失的键提供默认值的映射。请注意，类名以小写字母开头；这在Python中是不典型的。
- en: 'Counter: A mapping that is designed to count the number of occurrences of distinct
    keys. This is sometimes called a multiset or a bag.'
  id: totrans-341
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Counter：一种设计用来计算不同键出现次数的映射。这有时被称为多重集或包。
- en: 'ChainMap: A mapping that combines several dictionaries into a single mapping.'
  id: totrans-342
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: ChainMap：一种将多个字典组合成一个单一映射的映射。
- en: The heapq module includes a priority queue implementation. This is a specialized
    library that leverages the built-in list sequence to maintain items in a sorted
    order.
  id: totrans-343
  prefs: []
  type: TYPE_NORMAL
  zh: heapq模块包含一个优先队列实现。这是一个专门化的库，利用内置的列表序列来保持项目排序。
- en: The bisect module includes methods for searching a sorted list. This creates
    some overlap between the dictionary features and the list features.
  id: totrans-344
  prefs: []
  type: TYPE_NORMAL
  zh: bisect模块包含搜索排序列表的方法。这在大字典功能和列表功能之间产生了一些重叠。
- en: Additionally, there’s an OrderedDict class in the collections module. Starting
    with Python 3.7, the dictionary keys for an ordinary dictionary are retained in
    the order they were created, making the OrderedDict class redundant.
  id: totrans-345
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，collections模块中还有一个OrderedDict类。从Python 3.7开始，普通字典的键按创建顺序保留，这使得OrderedDict类变得冗余。
- en: 7.8.2 How to do it...
  id: totrans-346
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 7.8.2 如何实现...
- en: 'There are a number of questions we need to answer to decide if we need a library
    data collection instead of one of the built-in collections:'
  id: totrans-347
  prefs: []
  type: TYPE_NORMAL
  zh: 我们需要回答一些问题来决定是否需要一个库数据集合而不是内置集合：
- en: Is the structure a buffer between the producer and the consumer? Does some part
    of the algorithm produce data items and another part consume the data items?
  id: totrans-348
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 这种结构是生产者和消费者之间的缓冲吗？算法的某个部分产生数据项，而另一个部分消费数据项吗？
- en: A queue is used for First-In-First-Out (FIFO) processing. Items are inserted
    at one end and consumed from the other end. We can use list.append() and list.pop(0)
    to simulate this, though collections.deque will be more efficient; we can use
    deque.append() and deque.popleft().
  id: totrans-349
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 队列用于先入先出（FIFO）处理。项目在一端插入，从另一端消费。我们可以使用list.append()和list.pop(0)来模拟这个过程，尽管collections.deque将更高效；我们可以使用deque.append()和deque.popleft()。
- en: A stack is used for Last-In-First-Out (LIFO) processing. Items are inserted
    and consumed from the same end. We can use list.append() and list.pop() to simulate
    this, though collections.deque will be more efficient; we can use deque.append()
    and deque.pop().
  id: totrans-350
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 栈用于后进先出（LIFO）处理。项目从同一端插入和消耗。我们可以使用list.append()和list.pop()来模拟这一点，尽管collections.deque将更高效；我们可以使用deque.append()和deque.pop()。
- en: A priority queue (or heap queue) keeps the queue sorted in some order, distinct
    from the arrival order. We can try to simulate this by using the list.append(),
    list.sort(key=lambda x:x.priority), and list.pop(-1) operations to keep items
    in priority order. Performing a sort after each insert can make it inefficient.
    Using the heapq module can be more efficient. The heapq module has functions for
    creating and updating heaps.
  id: totrans-351
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 优先队列（或堆队列）按某种顺序保持队列排序，这种顺序与到达顺序不同。我们可以通过使用list.append()、list.sort(key=lambda
    x:x.priority)和list.pop(-1)操作来模拟这一点，以保持项目按优先级排序。每次插入后进行排序可能会使其效率低下。使用heapq模块可能更高效。heapq模块有用于创建和更新堆的函数。
- en: How do we want to deal with missing keys from a dictionary?
  id: totrans-352
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们应该如何处理字典中的缺失键？
- en: Raise an exception. This is the way the built-in dict class works.
  id: totrans-353
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 抛出异常。这是内置的dict类的工作方式。
- en: Create a default item. This is how collections.defaultdict works. We must provide
    a function that returns the default value. Common examples include defaultdict(int)
    and defaultdict(float) to use a default value of 0 or 0.0\. We can also use defauldict(list)
    and defauldict(set) to create dictionary-of-list or dictionary-of-set structures.
  id: totrans-354
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 创建一个默认项。这是collections.defaultdict的工作方式。我们必须提供一个返回默认值的函数。常见的例子包括defaultdict(int)和defaultdict(float)来使用默认值0或0.0。我们还可以使用defauldict(list)和defauldict(set)来创建字典-of-list或字典-of-set结构。
- en: The defaultdict(int) used to create a dictionary for counting items is so common
    that the collections.Counter class does exactly this.
  id: totrans-355
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 用于创建计数字典的defaultdict(int)非常常见，以至于collections.Counter类正是这样做的。
- en: How do we want to handle the order of keys in a dictionary? Generally, Python
    above version 3.6 keeps the keys in insertion order. If we want a different order,
    we’ll have to sort them manually.
  id: totrans-356
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们希望如何处理字典中键的顺序？通常，Python 3.6以上版本会保持键的插入顺序。如果我们想有不同的顺序，我们将不得不手动排序它们。
- en: How will we build the dictionary?
  id: totrans-357
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们将如何构建字典？
- en: We have a simple algorithm to create items. In this case, a built-in dict object
    may be sufficient.
  id: totrans-358
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们有一个简单的算法来创建项。在这种情况下，一个内置的dict对象可能就足够了。
- en: We have multiple dictionaries that will need to be merged. This can happen when
    reading configuration files. We might have an individual configuration, a system-wide
    configuration, and a default application configuration that all need to be merged
    into a single dictionary using a ChainMap collection.
  id: totrans-359
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们有多个需要合并的字典。这可能在读取配置文件时发生。我们可能有一个单独的配置、系统范围的配置以及默认的应用程序配置，所有这些都需要使用ChainMap集合合并成一个单一的字典。
- en: 7.8.3 How it works...
  id: totrans-360
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 7.8.3 它是如何工作的...
- en: 'There are two principle resource constraints on data processing:'
  id: totrans-361
  prefs: []
  type: TYPE_NORMAL
  zh: 数据处理有两个主要资源约束：
- en: Storage
  id: totrans-362
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 存储
- en: Time
  id: totrans-363
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 时间
- en: 'All of our programming must respect these constraints. In most cases, the two
    are inverses: anything we do to reduce storage use tends to increase processing
    time, and anything we do to reduce processing time increases storage use. Algorithm
    and data structure design seeks to find an optimal balance among the constraints.'
  id: totrans-364
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的所有编程都必须遵守这些约束。在大多数情况下，这两者是相反的：我们为了减少存储使用而做的事情往往会增加处理时间，而我们为了减少处理时间而做的事情会增加存储使用。算法和数据结构设计寻求在约束之间找到一个最佳平衡。
- en: 'The time aspect is formalized via a complexity metric. There are several ways
    to describe the complexity of an algorithm:'
  id: totrans-365
  prefs: []
  type: TYPE_NORMAL
  zh: 时间方面通过复杂度指标形式化。描述算法复杂性的方法有很多：
- en: Complexity O(1) doesn’t change with the volume of data. For some collections,
    the actual overall long-term average is nearly O(1) with minor exceptions. Many
    dictionary operations are O(1). Appending to a list, and popping from the end
    of a list is very fast, making a LIFO stack very efficient. Popping from the front
    of a list is O(n), making a FIFO queue built from a simple list rather expensive;
    the deque class and heapq module remedy this with better designs.
  id: totrans-366
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 复杂度O(1)不随数据量的大小而改变。对于某些集合，实际的长期平均整体几乎接近O(1)，但有少数例外。许多字典操作是O(1)。向列表中添加元素，以及从列表末尾弹出元素非常快，使得LIFO栈非常高效。从列表前面弹出元素是O(n)，这使得由简单列表构建的FIFO队列相当昂贵；deque类和heapq模块通过更好的设计来解决这个问题。
- en: Complexity described as O(log n) means the cost grows more slowly than the volume
    of data, n. The bisect module lets us search a sorted list more efficiently than
    the list class by dividing the list into halves. Note that sorting the list in
    the first place is O(nlog n), so there needs to be a great many searches to amortize
    the cost of sorting.
  id: totrans-367
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 被描述为O(log n)的复杂度意味着成本的增长速度低于数据量n的增长速度。二分查找模块允许我们通过将列表分成两半来更有效地搜索排序后的列表。请注意，首先对列表进行排序是O(nlog
    n)，因此需要大量的搜索来分摊排序的成本。
- en: Complexity described as O(n) means the cost grows as the volume of data, n,
    grows. Finding an item in a list has this complexity. If the item is at the end
    of the list, all n items must be checked. Sets and mappings don’t have this problem,
    and have nearly O(1) complexity.
  id: totrans-368
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 被描述为O(n)的复杂度意味着成本随着数据量n的增长而增长。在列表中查找一个项目具有这种复杂度。如果项目在列表的末尾，必须检查所有n个项目。集合和映射没有这个问题，并且具有接近O(1)的复杂度。
- en: A complexity described as O(nlog n) grows more quickly than the volume of data.
    Sorting a list tends to have this complexity. For this reason, it helps to minimize
    or eliminate sorting large volumes of data.
  id: totrans-369
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 被描述为O(nlog n)的复杂度比数据量增长得更快。排序列表通常具有这种复杂度。因此，最小化或消除大量数据的排序是有帮助的。
- en: There are even worse cases. Some algorithms have a complexity of O(n²), O(2^n),
    or even O(n!). We’d like to avoid these kinds of very expensive algorithms through
    clever design and good choice of data structure. These can be deceptive in practice.
    We may be able to work out an O(2^n) algorithm that seems to perform well on small
    test cases where n is 3 or 4\. In these cases, there are only 8 or 16 combinations.
    If real data involves 70 items, the number of combinations is on the order of
    10^(22), a number with 22 digits.
  id: totrans-370
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 有些情况甚至更糟。一些算法的复杂度为O(n²)、O(2^n)，甚至O(n!)。我们希望通过巧妙的设计和良好的数据结构选择来避免这些非常昂贵的算法。在实践中，这些算法可能会具有欺骗性。我们可能能够设计出一个O(2^n)的算法，在n为3或4的小测试用例中似乎表现良好。在这些情况下，组合数只有8或16种。如果实际数据涉及70个项目，组合数将达到10^(22)的数量级，一个有22位数的数字。
- en: The various data structures available in the standard library reflect a number
    of time and storage trade-offs.
  id: totrans-371
  prefs: []
  type: TYPE_NORMAL
  zh: 标准库中可用的各种数据结构反映了时间和存储之间的许多权衡。
- en: 7.8.4 There’s more...
  id: totrans-372
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 7.8.4 更多内容...
- en: 'As a concrete and extreme example, let’s look at searching a web log file for
    a particular sequence of events. We have two overall design strategies:'
  id: totrans-373
  prefs: []
  type: TYPE_NORMAL
  zh: 作为具体和极端的例子，让我们看看搜索一个特定事件序列的Web日志文件。我们有两个总体设计策略：
- en: Read all of the events into a list structure with something like file.read().splitlines().
    We can then use a for statement to iterate through the list looking for the combination
    of events. While the initial read may take some time, the search will be very
    fast because the log is all in memory.
  id: totrans-374
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用类似file.read().splitlines()的方法将所有事件读入一个列表结构中。然后我们可以使用for语句遍历列表，寻找事件的组合。虽然初始读取可能需要一些时间，但由于日志全部在内存中，搜索将会非常快。
- en: Read and process each individual event from a log file. When a log entry is
    part of the searched-for pattern, it makes sense to save only this event in a
    subset of the log. We might use a defaultdict with a session ID or client IP address
    as the key and a list of events as the value. This will take longer to read the
    logs, but the resulting structure in memory will be much smaller than a list of
    all log entries.
  id: totrans-375
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 从日志文件中逐个读取和处理事件。当一个日志条目是搜索到的模式的一部分时，只保存这个事件在日志的子集中是有意义的。我们可能使用一个以会话ID或客户端IP地址作为键，事件列表作为值的defaultdict。这将花费更长的时间来读取日志，但内存中的结果结构将比所有日志条目的列表小得多。
- en: The first algorithm, reading everything into memory, can be wildly impractical.
    On a large web server, the logs might involve hundreds of gigabytes of data. Logs
    can easily be too large to fit into any computer’s memory.
  id: totrans-376
  prefs: []
  type: TYPE_NORMAL
  zh: 第一个算法，将所有内容读入内存，可能非常不切实际。在一个大型网络服务器上，日志可能涉及数百GB的数据。日志可能太大，无法放入任何计算机的内存中。
- en: 'The second approach has a number of alternative implementations:'
  id: totrans-377
  prefs: []
  type: TYPE_NORMAL
  zh: 第二种方法有几个替代实现：
- en: 'Single process: The general approach to most of the Python recipes here assumes
    that we’re creating an application that runs as a single process.'
  id: totrans-378
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 单进程：这里大多数Python食谱的一般方法假设我们正在创建一个作为单个进程运行的应用程序。
- en: 'Multiple processes: We might expand the row-by-row search into a multi-processing
    application using the multiprocessing or concurrent.futures packages. These packages
    let us create a collection of worker processes, each of which can process a subset
    of the available data and return the results to a consumer that combines the results.
    On a modern multiprocessor, multi-core computer, this can be a very effective
    use of resources.'
  id: totrans-379
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 多进程：我们可能会将逐行搜索扩展为多进程应用程序，使用 multiprocessing 或 concurrent.futures 包。这些包让我们创建一组工作进程，每个进程可以处理可用数据的一个子集，并将结果返回给一个消费者，该消费者将结果组合起来。在现代多处理器、多核计算机上，这可以是非常有效的资源利用方式。
- en: 'Multiple hosts: The extreme case requires multiple servers, each of which handles
    a subset of the data. This requires more elaborate coordination among the hosts
    to share result sets. Generally, it can work out well to use a framework such
    as Dask or Spark for this kind of processing. While the multiprocessing module
    is quite sophisticated, tools like Dask are even more suitable for large-scale
    computation.'
  id: totrans-380
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 多主机：极端情况需要多个服务器，每个服务器处理数据的一个子集。这需要在主机之间进行更复杂的协调以共享结果集。通常，使用 Dask 或 Spark 这样的框架来处理这类工作效果很好。虽然
    multiprocessing 模块相当复杂，但像 Dask 这样的工具更适合大规模计算。
- en: We’ll often decompose a large search into map and reduce processing. The map
    phase applies some processing or filtering to every item in the collection. The
    reduce phase combines map results into summary or aggregate objects. In many cases,
    there is a complex hierarchy of Map-Reduce stages applied to the results of previous
    Map-Reduce operations.
  id: totrans-381
  prefs: []
  type: TYPE_NORMAL
  zh: 我们经常将大搜索分解为映射和归约处理。映射阶段对集合中的每个项目应用一些处理或过滤。归约阶段将映射结果组合成摘要或聚合对象。在许多情况下，有一个复杂的
    Map-Reduce 阶段层次结构应用于先前 Map-Reduce 操作的结果。
- en: 7.8.5 See also
  id: totrans-382
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 7.8.5 相关阅读
- en: See the [Choosing a data structure](ch008_split_000.xhtml#x1-2250001) recipe
    in Chapter [4](ch008_split_000.xhtml#x1-2240004), for a foundational set of decisions
    for selecting data structures.
  id: totrans-383
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 请参阅第[4](ch008_split_000.xhtml#x1-2240004)章中的[选择数据结构](ch008_split_000.xhtml#x1-2250001)配方，以了解选择数据结构的基础决策集。
- en: 7.9 Extending a built-in collection – a list that does statistics
  id: totrans-384
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 7.9 扩展内置集合 – 一个能进行统计的列表
- en: In the [Designing classes with lots of processing](ch011_split_000.xhtml#x1-3890003)
    recipe, we looked at a way to distinguish between a complex algorithm and a collection.
    We showed how to encapsulate the algorithm and the data into separate classes.
    The alternative design strategy is to extend the collection to incorporate a useful
    algorithm.
  id: totrans-385
  prefs: []
  type: TYPE_NORMAL
  zh: 在[设计具有大量处理的类](ch011_split_000.xhtml#x1-3890003)的配方中，我们查看了一种区分复杂算法和集合的方法。我们展示了如何将算法和数据封装到不同的类中。另一种设计策略是扩展集合以包含有用的算法。
- en: How can we extend Python’s built-in collections? How can we add features to
    the built-in list?
  id: totrans-386
  prefs: []
  type: TYPE_NORMAL
  zh: 我们如何扩展 Python 的内置集合？我们如何向内置列表添加功能？
- en: 7.9.1 Getting ready
  id: totrans-387
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 7.9.1 准备工作
- en: We’ll create a sophisticated list class where each instance can compute the
    sums and averages of the items in the list. This will require an application to
    put only numbers in the list; otherwise, there will be ValueError exceptions raised.
  id: totrans-388
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将创建一个复杂的列表类，其中每个实例都可以计算列表中项目的总和和平均值。这需要应用仅将数字放入列表中；否则，将引发 ValueError 异常。
- en: 'We’re going to show methods that explicitly use generator expressions as places
    where additional processing can be included. Rather than use sum(self), we’re
    going to emphasize sum(v for v in self) because there are two common future extensions:
    sum(m(v) for v in self) and sum(v for v in self if f(v)). These are the mapping
    and filtering alternatives where a mapping function, m(v), is applied to each
    item; or a filter function, f(v), is applied to pass or reject each item. Computing
    a sum of squares, for example, applies a mapping to compute the square of each
    value before summing.'
  id: totrans-389
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将展示一些方法，这些方法明确使用生成器表达式作为可以包含额外处理的地方。我们不会使用 sum(self)，而是强调 sum(v for v in self)，因为有两个常见的未来扩展：sum(m(v)
    for v in self) 和 sum(v for v in self if f(v))。这些是映射和过滤的替代方案，其中映射函数 m(v) 应用于每个项目；或者过滤函数
    f(v) 应用于通过或拒绝每个项目。例如，计算平方和将映射应用于计算每个值的平方，然后再求和。
- en: 7.9.2 How to do it...
  id: totrans-390
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 7.9.2 如何实现...
- en: 'Pick a name for the list that also does simple statistics. Define the class
    as an extension to the built-in list class:'
  id: totrans-391
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 为列表选择一个同时也能进行简单统计的名字。将类定义为内置列表类的扩展：
- en: '[PRE54]'
  id: totrans-392
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE54]'
- en: We can stick with a generic type hint of list. This is often too broad. Since
    the structure will contain numbers, it’s more sensible to use the narrower hint
    of list[float].
  id: totrans-393
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 我们可以坚持使用通用的类型提示list。这通常太宽泛了。由于结构将包含数字，使用更窄的提示list[float]更合理。
- en: When working with numeric data, mypy treats the float type as a superclass for
    both float and int, saving us from having to define an explicit Union[float, int].
  id: totrans-394
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 当处理数值数据时，mypy将float类型视为float和int的超类，从而节省了我们定义显式Union[float, int]的需要。
- en: 'Define the additional processing as methods. The self variable will be an object
    that has inherited all of the attributes and methods from the superclass. In this
    case, the superclass is list[float]. We’ll use a generator expression here as
    a place where future changes might be incorporated. Here’s a sum() method:'
  id: totrans-395
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将额外的处理定义为方法。self变量将是一个继承了超类所有属性和方法的对象。在这种情况下，超类是list[float]。我们在这里使用生成器表达式作为一个可能包含未来更改的地方。以下是一个sum()方法：
- en: '[PRE55]'
  id: totrans-396
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE55]'
- en: 'Here’s another method that we often apply to a list. This counts items and
    returns the size. We’ve used a generator expression to make it easy to add mappings
    or filter criteria if that ever becomes necessary:'
  id: totrans-397
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 这里是另一个我们经常应用于列表的方法。它计算项目数量并返回大小。我们使用生成器表达式使其易于添加映射或过滤条件，如果需要的话：
- en: '[PRE56]'
  id: totrans-398
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE56]'
- en: 'Here’s the mean method:'
  id: totrans-399
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 这里是平均数方法：
- en: '[PRE57]'
  id: totrans-400
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE57]'
- en: 'Here are some additional methods. The sum2() method computes the sum of squares
    of values in the list. This is used to compute variance. The variance is then
    used to compute the standard deviation of the values in the list. Unlike with
    the previous sum() and count() methods, where there’s no mapping, in this case,
    the generator expression includes a mapping transformation:'
  id: totrans-401
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 这里有一些额外的函数。sum2()方法计算列表中值的平方和。这用于计算方差。然后使用方差来计算列表中值的标准差。与之前的sum()和count()方法不同，那里没有映射，在这种情况下，生成器表达式包括一个映射转换：
- en: '[PRE58]'
  id: totrans-402
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE58]'
- en: 'The StatsList class definition inherits all the features of a list object.
    It is extended by the methods that we added. Here’s an example of creating an
    instance in this collection:'
  id: totrans-403
  prefs: []
  type: TYPE_NORMAL
  zh: StatsList类的定义继承了内置列表对象的所有特性。它通过我们添加的方法进行了扩展。以下是创建此集合中实例的示例：
- en: '[PRE59]'
  id: totrans-404
  prefs: []
  type: TYPE_PRE
  zh: '[PRE59]'
- en: 'We’ve created two StatsList objects, subset1 and data, from literal lists of
    objects. We used the extend() method, inherited from the list superclass, to combine
    the two objects. Here’s the resulting object:'
  id: totrans-405
  prefs: []
  type: TYPE_NORMAL
  zh: 我们从字面列表对象中创建了两个StatsList对象，分别是subset1和data。我们使用了从列表超类继承的extend()方法来合并这两个对象。以下是结果对象：
- en: '[PRE60]'
  id: totrans-406
  prefs: []
  type: TYPE_PRE
  zh: '[PRE60]'
- en: 'Here’s how we can use the additional methods that we defined on this object:'
  id: totrans-407
  prefs: []
  type: TYPE_NORMAL
  zh: 这是我们可以使用这个对象上定义的额外方法的方式：
- en: '[PRE61]'
  id: totrans-408
  prefs: []
  type: TYPE_PRE
  zh: '[PRE61]'
- en: We’ve displayed the results of the mean() and variance() methods. All the features
    of the built-in list class are also present in our extension.
  id: totrans-409
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经展示了mean()和variance()方法的结果。内置列表类的所有特性也存在于我们的扩展中。
- en: 7.9.3 How it works...
  id: totrans-410
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 7.9.3 它是如何工作的...
- en: One of the essential features of class definition is the concept of inheritance.
    When we create a superclass-subclass relationship, the subclass inherits all of
    the features of the superclass. This is sometimes called the generalization-specialization
    relationship. The superclass is a more generalized class; the subclass is more
    specialized because it adds or modifies features.
  id: totrans-411
  prefs: []
  type: TYPE_NORMAL
  zh: 类定义的一个基本特征是继承的概念。当我们创建一个超类-子类关系时，子类继承超类的所有特性。这有时被称为泛化-特殊化关系。超类是一个更通用的类；子类更特殊，因为它添加或修改了特性。
- en: All of the built-in classes can be extended to add features. In this example,
    we added some statistical processing that created a subclass that’s a specialized
    kind of list of numbers.
  id: totrans-412
  prefs: []
  type: TYPE_NORMAL
  zh: 所有内置类都可以扩展以添加功能。在这个例子中，我们添加了一些统计处理，创建了一个特殊的数字列表子类。
- en: 'There’s an important tension between the two design strategies:'
  id: totrans-413
  prefs: []
  type: TYPE_NORMAL
  zh: 两种设计策略之间存在重要的紧张关系：
- en: 'Extending: In this case, we extended a class to add features. The features
    are deeply entrenched with this single data structure, and we can’t easily use
    them for a different kind of sequence.'
  id: totrans-414
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 扩展：在这种情况下，我们扩展了一个类以添加功能。这些特性与这个单一的数据结构紧密相连，我们无法轻易地将其用于不同类型的序列。
- en: 'Wrapping: In designing classes with lots of processing, we kept the processing
    separate from the collection. This leads to some more complexity in juggling two
    objects.'
  id: totrans-415
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 包装：在设计具有大量处理功能的类时，我们保持了处理与集合的分离。这导致在处理两个对象时出现一些复杂性。
- en: It’s difficult to suggest that one of these is inherently superior to the other.
    In many cases, we’ll find that wrapping may have an advantage because it seems
    to be a better fit to the SOLID design principles. However, there will often be
    cases where it’s appropriate to extend a built-in collection.
  id: totrans-416
  prefs: []
  type: TYPE_NORMAL
  zh: 很难说其中哪一种本质上优于另一种。在许多情况下，我们会发现包装可能具有优势，因为它似乎更适合SOLID设计原则。然而，通常会有一些情况，扩展内置集合是合适的。
- en: 7.9.4 There’s more...
  id: totrans-417
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 7.9.4 更多内容...
- en: The idea of generalization can lead to superclasses that are abstractions. Because
    an abstract class is incomplete, it requires a subclass to extend it and provide
    missing implementation details. We can’t make an instance of an abstract class
    because it would be missing features that make it useful.
  id: totrans-418
  prefs: []
  type: TYPE_NORMAL
  zh: 概化的想法可能导致抽象超类。由于抽象类是不完整的，它需要一个子类来扩展它并提供缺失的实现细节。我们不能创建一个抽象类的实例，因为它会缺少使其有用的功能。
- en: As we noted in the [Choosing a data structure](ch008_split_000.xhtml#x1-2250001)
    recipe in Chapter [4](ch008_split_000.xhtml#x1-2240004), there are abstract superclasses
    for all of the built-in collections. Rather than starting from a concrete class,
    we can also start our design from an abstract base class.
  id: totrans-419
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我们在第[4](ch008_split_000.xhtml#x1-2240004)章的[选择数据结构](ch008_split_000.xhtml#x1-2250001)配方中提到的，所有内置集合都有抽象超类。我们不仅可以从一个具体类开始，还可以从一个抽象基类开始我们的设计。
- en: 'We could, for example, start a class definition like this:'
  id: totrans-420
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，我们可以这样开始一个类定义：
- en: '[PRE62]'
  id: totrans-421
  prefs: []
  type: TYPE_PRE
  zh: '[PRE62]'
- en: 'In order to finish this class, we’ll need to provide an implementation for
    a number of special methods:'
  id: totrans-422
  prefs: []
  type: TYPE_NORMAL
  zh: 为了完成这门课程，我们需要为一些特殊方法提供实现：
- en: __getitem__()
  id: totrans-423
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`__getitem__`'
- en: __setitem__()
  id: totrans-424
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`__setitem__`'
- en: __delitem__()
  id: totrans-425
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`__delitem__`'
- en: __iter__()
  id: totrans-426
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`__iter__`'
- en: __len__()
  id: totrans-427
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`__len__`'
- en: Each of these methods is missing from the abstract class; they have no concrete
    implementation in the Mapping class. Once we’ve provided workable implementations
    for each method, we can then make instances of the new subclass.
  id: totrans-428
  prefs: []
  type: TYPE_NORMAL
  zh: 这些方法在抽象类中都不存在；在Mapping类中没有具体的实现。一旦我们为每个方法提供了可行的实现，我们就可以创建新子类实例。
- en: 7.9.5 See also
  id: totrans-429
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 7.9.5 参考信息
- en: In the [Designing classes with lots of processing](ch011_split_000.xhtml#x1-3890003)
    recipe, we took a different approach. In that recipe, we left the complex algorithms
    in a separate class.
  id: totrans-430
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在[设计大量处理类的配方](ch011_split_000.xhtml#x1-3890003)中，我们采取了不同的方法。在那个配方中，我们将复杂的算法留在了另一个类中。
- en: 7.10 Using properties for lazy attributes
  id: totrans-431
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 7.10 使用属性懒加载
- en: In the [Designing classes with lots of processing](ch011_split_000.xhtml#x1-3890003)
    recipe, we defined a class that eagerly computed a number of attributes of the
    data in a collection. The idea there was to compute the values as soon as possible,
    so that the attributes would have no further computational cost.
  id: totrans-432
  prefs: []
  type: TYPE_NORMAL
  zh: 在[设计大量处理类的配方](ch011_split_000.xhtml#x1-3890003)中，我们定义了一个类，它会急切地计算集合中数据的许多属性。那里的想法是尽可能早地计算值，这样属性就不会有进一步的计算成本。
- en: We described this as eager processing, since the work was done as soon as possible.
    The other approach is lazy processing, where the work is done as late as possible.
  id: totrans-433
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将其描述为急切处理，因为工作尽可能早地完成。另一种方法是懒处理，其中工作尽可能晚地完成。
- en: What if we have values that are used rarely, and are very expensive to compute?
    What can we do to minimize the up-front computation, and only compute values when
    they are truly needed?
  id: totrans-434
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们有一些很少使用且计算成本很高的值，我们该怎么办？我们如何最小化初始计算，并且只在真正需要时计算值？
- en: 7.10.1 Getting ready...
  id: totrans-435
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 7.10.1 准备工作...
- en: 'For background, see the NIST Aerosol Particle Size case study: [https://www.itl.nist.gov/div898/handbook/pmc/section6/pmc62.htm](https://www.itl.nist.gov/div898/handbook/pmc/section6/pmc62.htm)'
  id: totrans-436
  prefs: []
  type: TYPE_NORMAL
  zh: 对于背景信息，请参阅NIST气溶胶粒子尺寸案例研究：[https://www.itl.nist.gov/div898/handbook/pmc/section6/pmc62.htm](https://www.itl.nist.gov/div898/handbook/pmc/section6/pmc62.htm)
- en: See the [Designing classes with lots of processing](ch011_split_000.xhtml#x1-3890003)
    recipe in this chapter for more details on this dataset. Rather than work with
    the raw data, it can help to work with summary information contained in a Counter
    object. The recipe shows a mapping from particle size to number to a count of
    times the particular size was measured.
  id: totrans-437
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，请参阅[设计大量处理类的配方](ch011_split_000.xhtml#x1-3890003)以获取更多关于此数据集的详细信息。与处理原始数据相比，处理包含在Counter对象中的摘要信息可能会有所帮助。配方展示了从粒子大小到数量的映射，以及特定大小被测量的次数。
- en: 'We want to compute some statistics on this Counter. We have two overall strategies
    for doing this:'
  id: totrans-438
  prefs: []
  type: TYPE_NORMAL
  zh: 我们想计算这个Counter的一些统计数据。我们有两个总体策略来完成这项工作：
- en: 'Extend: We covered this in detail in the [Extending a built-in collection –
    a list that does statistics](ch011_split_001.xhtml#x1-4250009) recipe, and we
    will look at other examples of extending a class in Chapter [8](ch012.xhtml#x1-4520008).'
  id: totrans-439
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 扩展：我们在[扩展内置集合 – 执行统计的列表](ch011_split_001.xhtml#x1-4250009)的菜谱中详细介绍了这一点，我们将在第[8](ch012.xhtml#x1-4520008)章中查看其他扩展类的例子。
- en: 'Wrap: We can wrap the Counter object in another class that provides just the
    features we need. We’ll look at this in Chapter [8](ch012.xhtml#x1-4520008).'
  id: totrans-440
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 包装：我们可以将Counter对象包装在另一个只提供所需功能的类中。我们将在第[8](ch012.xhtml#x1-4520008)章中探讨这一点。
- en: A common variation on wrapping creates a statistical computation object separate
    from the data collection object. This variation on wrapping often leads to an
    elegant solution.
  id: totrans-441
  prefs: []
  type: TYPE_NORMAL
  zh: 在包装时的一种常见变体是创建一个与数据收集对象分开的统计计算对象。这种包装的变体通常会导致一个优雅的解决方案。
- en: 'No matter which class architecture we choose, we also have two ways to design
    the processing:'
  id: totrans-442
  prefs: []
  type: TYPE_NORMAL
  zh: 无论我们选择哪种类架构，我们还有两种设计处理的方式：
- en: 'Eager: This means we’ll compute the statistics as soon as possible. This was
    the approach followed in the [Designing classes with lots of processing](ch011_split_000.xhtml#x1-3890003)
    recipe.'
  id: totrans-443
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 贪婪：这意味着我们将尽快计算统计值。这是[设计具有大量处理的类](ch011_split_000.xhtml#x1-3890003)菜谱中采用的方法。
- en: 'Lazy: This means we won’t compute anything until it’s required via a method
    function or property. In the [Extending a built-in collection – a list that does
    statistics](ch011_split_001.xhtml#x1-4250009) recipe, we added methods to a collection
    class. These additional methods are examples of lazy calculation. The statistical
    values are computed only when required.'
  id: totrans-444
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 懒惰：这意味着我们不会在需要之前通过方法函数或属性进行任何计算。在[扩展内置集合 – 执行统计的列表](ch011_split_001.xhtml#x1-4250009)的菜谱中，我们向集合类添加了方法。这些额外的方法是惰性计算的例子。统计值仅在需要时才进行计算。
- en: The essential math for both designs is the same. The only question is when the
    computation is done.
  id: totrans-445
  prefs: []
  type: TYPE_NORMAL
  zh: 两种设计的基本数学是相同的。唯一的问题是何时进行计算。
- en: 7.10.2 How to do it...
  id: totrans-446
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 7.10.2 如何实现...
- en: 'Define the class with a descriptive name:'
  id: totrans-447
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用描述性的名称定义类：
- en: '[PRE63]'
  id: totrans-448
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE63]'
- en: 'Write the initialization method to include the object to which this object
    will be connected. We’ve defined a method function that takes a Counter object
    as an argument value. This Counter object is saved as part of the Counter_Statistics
    instance:'
  id: totrans-449
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 编写初始化方法以包含此对象将要连接的对象。我们定义了一个方法函数，它接受一个Counter对象作为参数值。这个Counter对象被保存为Counter_Statistics实例的一部分：
- en: '[PRE64]'
  id: totrans-450
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE64]'
- en: 'Define some useful helper methods. Each of these is decorated with @property
    to make it behave like a simple attribute:'
  id: totrans-451
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 定义一些有用的辅助方法。这些方法中的每一个都用@property装饰，使其表现得像简单的属性：
- en: '[PRE65]'
  id: totrans-452
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE65]'
- en: 'Define the required methods for the various values. Here’s the calculation
    of the mean. This too is decorated with @property. The other methods can be referenced
    as if they are attributes, even though they are proper method functions:'
  id: totrans-453
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 定义所需的各种值的必要方法。以下是对平均值的计算。这也用@property装饰。其他方法可以像属性一样引用，尽管它们是正确的方法函数：
- en: '[PRE66]'
  id: totrans-454
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE66]'
- en: 'Here’s how we can calculate the standard deviation. Note that we’ve been using
    math.sqrt(). Be sure to add the required import math statement in the Python module:'
  id: totrans-455
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 这是我们如何计算标准差的方法。注意，我们一直在使用math.sqrt()。务必在Python模块中添加所需的import math语句：
- en: '[PRE67]'
  id: totrans-456
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE67]'
- en: 'To show how this works, we’ll apply an instance of this class to some summarized
    data. The repository of code for this book includes a data/binned.csv file that
    has the binned summary data. This data has three columns: size_code, size, and
    frequency. We’re only interested in size_code and frequency.'
  id: totrans-457
  prefs: []
  type: TYPE_NORMAL
  zh: 为了展示这是如何工作的，我们将这个类的实例应用于一些汇总数据。这本书的代码库包括一个data/binned.csv文件，它包含汇总数据的分箱。这些数据有三个列：size_code，size和frequency。我们只对size_code和frequency感兴趣。
- en: 'Here’s how we can build a suitable Counter object from this file:'
  id: totrans-458
  prefs: []
  type: TYPE_NORMAL
  zh: 这是我们如何从这个文件中构建一个合适的Counter对象的方法：
- en: '[PRE68]'
  id: totrans-459
  prefs: []
  type: TYPE_PRE
  zh: '[PRE68]'
- en: We’ve used a dictionary comprehension to create a mapping from size_code to
    the frequency of that code value. This is then provided to the Counter class to
    build a Counter object named data from this existing summary.
  id: totrans-460
  prefs: []
  type: TYPE_NORMAL
  zh: 我们使用字典推导来创建从size_code到该代码值频率的映射。然后，我们将它提供给Counter类，从现有的汇总中构建一个名为data的Counter对象。
- en: 'Here’s how we can analyze the Counter object:'
  id: totrans-461
  prefs: []
  type: TYPE_NORMAL
  zh: 这是我们如何分析Counter对象的方法：
- en: '[PRE69]'
  id: totrans-462
  prefs: []
  type: TYPE_PRE
  zh: '[PRE69]'
- en: We provided the data object to create an instance of the LazyCounterStatistics
    class, the stats variable. When we print the value for the stats.mean property
    and the stats.stddev property, the methods are invoked to do the appropriate calculations
    of the various values.
  id: totrans-463
  prefs: []
  type: TYPE_NORMAL
  zh: 我们提供了数据对象来创建LazyCounterStatistics类的实例，即stats变量。当我们打印stats.mean属性和stats.stddev属性的值时，将调用方法来进行适当的值计算。
- en: The cost for the computation is not paid until a client object requests the
    stats.mean or stats.stddev property values. This will invoke a cascade of computation
    to compute these values.
  id: totrans-464
  prefs: []
  type: TYPE_NORMAL
  zh: 计算成本只有在客户端对象请求stats.mean或stats.stddev属性值时才会支付。这将引发一系列计算来计算这些值。
- en: When the underlying data is changed, the entire computation is performed again.
    This can be costly in the rare case of highly dynamic data. In the more common
    case of analyzing previously summarized data, this is quite efficient.
  id: totrans-465
  prefs: []
  type: TYPE_NORMAL
  zh: 当底层数据发生变化时，整个计算将再次执行。在高度动态数据的罕见情况下，这可能很昂贵。在更常见的情况下，分析先前汇总的数据，这相当高效。
- en: 7.10.3 How it works...
  id: totrans-466
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 7.10.3 它是如何工作的...
- en: The idea of lazy calculation works out well when the value is used rarely. In
    this example, the count is computed twice as part of computing the variance and
    standard deviation.
  id: totrans-467
  prefs: []
  type: TYPE_NORMAL
  zh: 当值很少使用时，懒计算的思路效果很好。在这个例子中，计数在计算方差和标准差时被计算了两次。
- en: A naïve lazy design may not be optimal in some cases when values are recomputed
    frequently. This is an easy problem to fix in general. We can always create additional
    local variables to cache intermediate results instead of recomputing them. We’ll
    look at this later in this recipe.
  id: totrans-468
  prefs: []
  type: TYPE_NORMAL
  zh: 在值频繁重新计算的情况下，一个简单的懒设计在某些情况下可能不是最优的。这通常是一个容易解决的问题。我们总是可以创建额外的局部变量来缓存中间结果，而不是重新计算。我们将在本食谱的后面讨论这个问题。
- en: To make this class look like it has performed eager calculations, we used the
    @property decorator. This makes a method appear to be an attribute. This can only
    work for methods that have no argument values.
  id: totrans-469
  prefs: []
  type: TYPE_NORMAL
  zh: 为了使这个类看起来像它已经执行了急切计算，我们使用了@property装饰器。这使得一个方法看起来像是一个属性。这只能适用于没有参数值的方法。
- en: In all cases, an attribute that’s computed eagerly can be replaced by a lazy
    property. The principle reason for creating eager attribute variables is to optimize
    computation costs. In the case where a computed result may not always be used,
    a lazy property can avoid an expensive calculation.
  id: totrans-470
  prefs: []
  type: TYPE_NORMAL
  zh: 在所有情况下，一个被急切计算的属性可以被一个懒属性所替代。创建急切属性变量的主要原因是优化计算成本。在计算结果可能不会被总是使用的情况下，懒属性可以避免昂贵的计算。
- en: 7.10.4 There’s more...
  id: totrans-471
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 7.10.4 更多内容...
- en: There are some situations in which we can further optimize a property to limit
    the amount of additional computation that’s done when a value changes. This requires
    a careful analysis of the use cases in order to understand the pattern of updates
    to the underlying data.
  id: totrans-472
  prefs: []
  type: TYPE_NORMAL
  zh: 有一些情况下，我们可以进一步优化一个属性，以限制在值变化时所做的额外计算量。这需要仔细分析使用案例，以便理解底层数据的更新模式。
- en: 'In the situation where a collection is loaded with data and an analysis is
    performed, we can cache results to save computing them a second time. We might
    do something like this:'
  id: totrans-473
  prefs: []
  type: TYPE_NORMAL
  zh: 在数据被加载到集合中并执行分析的情况下，我们可以缓存结果以避免第二次计算。我们可能做如下操作：
- en: '[PRE70]'
  id: totrans-474
  prefs: []
  type: TYPE_PRE
  zh: '[PRE70]'
- en: This technique uses two attributes to save the results of the sum and count
    calculations, self._sum and self._count. These values will be computed once and
    returned as often as needed with no additional cost for recalculation.
  id: totrans-475
  prefs: []
  type: TYPE_NORMAL
  zh: 这种技术使用两个属性来保存求和和计数计算的值，self._sum和self._count。这些值将只计算一次，并在需要时返回，无需额外的计算成本。
- en: The type hints show these attributes as being optional. Once the values for
    self._sum and self._count have been computed, the values are no longer optional,
    but will be present. We describe this to tools like mypy with the cast() type
    hint. This hint tells type-checking tools to consider self._sum as being a float
    object, not a float | None object. There’s no cost to this function as it does
    nothing; its purpose is to annotate the processing to show the design intent.
  id: totrans-476
  prefs: []
  type: TYPE_NORMAL
  zh: 类型提示显示这些属性是可选的。一旦self._sum和self._count的值被计算出来，这些值就不再是可选的，但将始终存在。我们用cast()类型提示向像mypy这样的工具描述这一点。这个提示告诉类型检查工具将self._sum视为一个float对象，而不是float
    | None对象。这个函数没有成本，因为它什么也不做；它的目的是注释处理过程，以显示设计意图。
- en: This caching optimization is helpful if the state of the raw_counter object
    never changes. In an application that updates the underlying Counter, this cached
    value would become out of date. That kind of application would need to reset the
    internal cache values of self._sum and self._count when the underlying Counter
    is updated.
  id: totrans-477
  prefs: []
  type: TYPE_NORMAL
  zh: 如果raw_counter对象的状态从不改变，这种缓存优化是有帮助的。在一个更新底层Counter的应用程序中，这个缓存的值会过时。这种类型的应用程序需要在底层Counter更新时重置self._sum和self._count的内部缓存值。
- en: 7.10.5 See also...
  id: totrans-478
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 7.10.5 参见...
- en: In the [Designing classes with lots of processing](ch011_split_000.xhtml#x1-3890003)
    recipe, we defined a class that eagerly computed a number of attributes. This
    represents a different strategy for managing the cost of the computation.
  id: totrans-479
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在[设计具有大量处理的类](ch011_split_000.xhtml#x1-3890003)的配方中，我们定义了一个类，它急切地计算了许多属性。这代表了一种管理计算成本的不同策略。
- en: 7.11 Creating contexts and context managers
  id: totrans-480
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 7.11 创建上下文和上下文管理器
- en: 'A number of Python objects behave like context managers. Some of the most visible
    examples are file objects. We generally use with path.open() as file: to process
    a file in a context that can guarantee the resources are released. In Chapter [2](ch006_split_000.xhtml#x1-840002),
    the [Managing a context using the with statement](ch006_split_001.xhtml#x1-15200011)
    recipe covers the basics of using a file-based context manager.'
  id: totrans-481
  prefs: []
  type: TYPE_NORMAL
  zh: 许多Python对象表现得像上下文管理器。其中一些最明显的例子是文件对象。我们通常使用with path.open() as file:来在一个可以保证资源释放的上下文中处理文件。在第[2](ch006_split_000.xhtml#x1-840002)章中，[使用with语句管理上下文](ch006_split_001.xhtml#x1-15200011)的配方涵盖了使用基于文件的上下文管理器的基础知识。
- en: How can we create our own classes that act as context managers?
  id: totrans-482
  prefs: []
  type: TYPE_NORMAL
  zh: 我们如何创建自己的类，使其充当上下文管理器？
- en: 7.11.1 Getting ready
  id: totrans-483
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 7.11.1 准备工作
- en: We’ll look at a function from Chapter [3](ch007_split_000.xhtml#x1-1610003),
    in the [Picking an order for parameters based on partial functions](ch007_split_001.xhtml#x1-1940006)
    recipe. This recipe introduced a function, haversine(), which has a context-like
    parameter used to adjust the answer from dimensionless radians to a useful unit
    of measure, such as kilometers, nautical miles, or US statute miles. In many ways,
    this distance factor is a kind of context, used to define the kinds of computations
    that are done.
  id: totrans-484
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将在第[3](ch007_split_000.xhtml#x1-1610003)章的[基于部分函数选择参数顺序](ch007_split_001.xhtml#x1-1940006)配方中查看一个函数。这个配方介绍了一个函数，haversine()，它有一个上下文类似的参数，用于将答案从无量纲弧度调整到有用的单位，如公里、海里或美国英里。在许多方面，这个距离因子是一种上下文，用于定义所进行的计算类型。
- en: 'What we want is to be able to use the with statement to describe an object
    that doesn’t change very quickly; indeed the change acts as a kind of boundary,
    defining the scope of computations. We might want to use code like the following:'
  id: totrans-485
  prefs: []
  type: TYPE_NORMAL
  zh: 我们希望能够使用with语句来描述一个变化不快的对象；实际上，这种变化充当了一种边界，定义了计算的范围。我们可能想要使用如下代码：
- en: '[PRE71]'
  id: totrans-486
  prefs: []
  type: TYPE_PRE
  zh: '[PRE71]'
- en: The Distance(r=NM) constructor provides the definition of the context, creating
    a new object, nm_dist, that has been configured to perform the required calculation
    in nautical miles. This can be used only within the body of the with statement.
  id: totrans-487
  prefs: []
  type: TYPE_NORMAL
  zh: Distance(r=NM)构造函数提供了上下文的定义，创建了一个新的对象nm_dist，该对象已配置为以海里为单位执行所需的计算。这只能在with语句体中使用。
- en: This Distance class definition can be seen as creating a partial function, nm_dist().
    This function provides a fixed unit-of-measure parameter, r, for a number of following
    computations using the haversine() function.
  id: totrans-488
  prefs: []
  type: TYPE_NORMAL
  zh: 这个Distance类定义可以看作是创建了一个部分函数，nm_dist()。这个函数为使用haversine()函数的多个后续计算提供了一个固定的单位参数，r。
- en: There are a number of other ways to create partial functions, including a lambda
    object, the functools.partial() function, and callable objects. We looked at the
    partial function alternative in Chapter [3](ch007_split_000.xhtml#x1-1610003),
    in the [Picking an order for parameters based on partial functions](ch007_split_001.xhtml#x1-1940006)
    recipe.
  id: totrans-489
  prefs: []
  type: TYPE_NORMAL
  zh: 有许多其他方法可以创建部分函数，包括lambda对象、functools.partial()函数和可调用对象。我们在第[3](ch007_split_000.xhtml#x1-1610003)章的[基于部分函数选择参数顺序](ch007_split_001.xhtml#x1-1940006)配方中探讨了部分函数的替代方案。
- en: 7.11.2 How to do it...
  id: totrans-490
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 7.11.2 如何做...
- en: 'A context manager class has two special methods that we need to define:'
  id: totrans-491
  prefs: []
  type: TYPE_NORMAL
  zh: 上下文管理器类有两个特殊方法，我们需要定义：
- en: 'Start with a meaningful class name:'
  id: totrans-492
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 从一个有意义的类名开始：
- en: '[PRE72]'
  id: totrans-493
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE72]'
- en: 'Define an initializer that creates any unique features of the context. In this
    case, we want to set the units of distance that are used:'
  id: totrans-494
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 定义一个初始化器，创建上下文的任何独特功能。在这种情况下，我们想要设置使用的距离单位：
- en: '[PRE73]'
  id: totrans-495
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE73]'
- en: 'Define the __enter__() method. This is called when the with statement block
    begins. The statement with Distance(r=NM) as nm_dist does two things. First, it
    creates the instance of the Distance class, then it calls the __enter__() method
    of that object to start the context. The return value from the __enter__() method
    is assigned to a local variable via the as clause. This isn’t always required.
    For simple cases, the context manager often returns itself. If this method needs
    to return an instance in the same class, note that the class hasn’t been fully
    defined yet, and the class name type hint must be provided as a string. For this
    recipe, we’ll return a function, with the type hint based on Callable:'
  id: totrans-496
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 定义 `__enter__()` 方法。当 `with` 语句块开始时，会调用此方法。语句 `with Distance(r=NM) as nm_dist`
    执行了两件事。首先，它创建了 `Distance` 类的实例，然后调用该对象的 `__enter__()` 方法以启动上下文。`__enter__()` 方法的返回值通过
    `as` 子句分配给一个局部变量。这并不总是必需的。对于简单情况，上下文管理器通常返回自身。如果此方法需要返回同一类别的实例，请注意类尚未完全定义，必须提供类名类型提示作为字符串。对于这个配方，我们将返回一个函数，类型提示基于
    `Callable`：
- en: '[PRE74]'
  id: totrans-497
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE74]'
- en: 'Define the __exit__() method. When the context finishes, this method is invoked.
    This is where resources are released and cleanup can happen. In this example,
    nothing more needs to be done. The details of any exception are provided to this
    method; the method can silence the exception or allow it to propagate. If the
    return value from the __exit__() method is True, the exception is silenced. A
    return value of False or None will allow the exception to be seen outside the
    with statement:'
  id: totrans-498
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 定义 `__exit__()` 方法。当上下文结束时，将调用此方法。这是释放资源和进行清理的地方。在这个例子中，不需要做更多的事情。任何异常的详细信息都提供给此方法；方法可以静默异常或允许其传播。如果
    `__exit__()` 方法的返回值为 `True`，则异常将被静默。返回值 `False` 或 `None` 将允许异常在 `with` 语句外部可见：
- en: '[PRE75]'
  id: totrans-499
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE75]'
- en: 'Create a class (or define the methods of this class) that works within the
    context. In this case, the method will make use of a separately defined haversine()
    function from Chapter [3](ch007_split_000.xhtml#x1-1610003):'
  id: totrans-500
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个类（或定义此类的函数）以在上下文中工作。在这种情况下，该方法将使用第 [3](ch007_split_000.xhtml#x1-1610003)
    章中单独定义的 `haversine()` 函数：
- en: '[PRE76]'
  id: totrans-501
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE76]'
- en: 'Most context-manager classes require a fairly large number of imports:'
  id: totrans-502
  prefs: []
  type: TYPE_NORMAL
  zh: 大多数上下文管理器类需要相当多的导入：
- en: '[PRE77]'
  id: totrans-503
  prefs: []
  type: TYPE_PRE
  zh: '[PRE77]'
- en: 'This class has been defined to work with objects of the class Point. This can
    be a NamedTuple, @dataclass, or some other class that provides the required two
    attributes. Here’s the NamedTuple definition:'
  id: totrans-504
  prefs: []
  type: TYPE_NORMAL
  zh: 此类已定义为与 `Point` 类的对象一起工作。这可以是 `NamedTuple`、`@dataclass` 或其他提供所需两个属性的类。以下是 `NamedTuple`
    的定义：
- en: '[PRE78]'
  id: totrans-505
  prefs: []
  type: TYPE_PRE
  zh: '[PRE78]'
- en: This class definition provides a class, Point, with the required attribute names.
  id: totrans-506
  prefs: []
  type: TYPE_NORMAL
  zh: 此类定义提供了一个名为 `Point` 的类，具有所需的属性名称。
- en: 7.11.3 How it works...
  id: totrans-507
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 7.11.3 它是如何工作的...
- en: The context manager relies on the with statement doing a large number of things.
  id: totrans-508
  prefs: []
  type: TYPE_NORMAL
  zh: 上下文管理器依赖于 `with` 语句执行大量操作。
- en: 'We’ll put the following construct under a microscope:'
  id: totrans-509
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将把以下结构放在显微镜下观察：
- en: '[PRE79]'
  id: totrans-510
  prefs: []
  type: TYPE_PRE
  zh: '[PRE79]'
- en: The first line creates an instance of the Distance class. This has a value for
    the r parameter equal to the constant NM, allowing us to do computations in nautical
    miles. The Distance instance is assigned to the nm_distance variable.
  id: totrans-511
  prefs: []
  type: TYPE_NORMAL
  zh: 第一行创建了 `Distance` 类的一个实例。该实例的 `r` 参数值等于常数 `NM`，这使得我们能够在海里进行计算。`Distance` 实例被分配给
    `nm_distance` 变量。
- en: When the with statement starts execution, the context manager object is notified
    by having the __enter__() method executed. In this case, the value returned by
    the __enter__() method is a function, with the type Callable[[Point, Point], float].
    The function accepts two Point objects and returns a floating-point result. The
    as clause assigns this function object to the nm_calc name.
  id: totrans-512
  prefs: []
  type: TYPE_NORMAL
  zh: 当 `with` 语句开始执行时，通过执行 `__enter__()` 方法来通知上下文管理器对象。在这种情况下，`__enter__()` 方法返回的值是一个函数，类型为
    `Callable[[Point, Point], float]`。该函数接受两个 `Point` 对象并返回一个浮点结果。`as` 子句将此函数对象分配给
    `nm_calc` 名称。
- en: The print() function does its work using the nm_calc object. The object is a
    function that will compute a distance from two Point instances.
  id: totrans-513
  prefs: []
  type: TYPE_NORMAL
  zh: '`print()` 函数使用 `nm_calc` 对象来完成其工作。该对象是一个函数，将从两个 `Point` 实例计算距离。'
- en: When the with statement finishes, the __exit__() method will be executed. For
    more complex context managers, this may involve closing files or releasing network
    connections. There are a great many kinds of context cleanup that might be necessary.
    In this case, there’s nothing that needs to be done to clean up the context.
  id: totrans-514
  prefs: []
  type: TYPE_NORMAL
  zh: 当 with 语句结束时，__exit__() 方法将被执行。对于更复杂的上下文管理器，这可能涉及关闭文件或释放网络连接。可能需要许多种类的上下文清理。在这种情况下，不需要做任何清理上下文的事情。
- en: This has the advantage of defining a fixed boundary in which the partial function
    is used. In some cases, the computation inside the context manager might involve
    a database or complex web services, leading to a more complex __exit__() method.
  id: totrans-515
  prefs: []
  type: TYPE_NORMAL
  zh: 这有一个优点，就是定义了一个固定边界，在这个边界内使用部分函数。在某些情况下，上下文管理器内部的计算可能涉及数据库或复杂的网络服务，从而导致更复杂的 __exit__()
    方法。
- en: 7.11.4 There’s more…
  id: totrans-516
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 7.11.4 更多内容…
- en: 'The operation of the __exit__() method is central to making best use of a context
    manager. In the previous example, we use the following ”do nothing” __exit__()
    method:'
  id: totrans-517
  prefs: []
  type: TYPE_NORMAL
  zh: __exit__() 方法的操作对于充分利用上下文管理器至关重要。在先前的例子中，我们使用了以下“什么都不做”的 __exit__() 方法：
- en: '[PRE80]'
  id: totrans-518
  prefs: []
  type: TYPE_PRE
  zh: '[PRE80]'
- en: 'The point here is to allow any exception to propagate normally. We often see
    any cleanup processing replacing the # Cleanup goes here. comment. This is where
    buffers are flushed, files are closed, and error log messages are written.'
  id: totrans-519
  prefs: []
  type: TYPE_NORMAL
  zh: '这里的问题是允许任何异常正常传播。我们经常看到任何清理处理替换了 # Cleanup goes here. 注释。这就是缓冲区被刷新、文件被关闭和错误日志消息被写入的地方。'
- en: 'Sometimes, we’ll need to handle specific exception details. Consider the following
    snippet of an interactive session:'
  id: totrans-520
  prefs: []
  type: TYPE_NORMAL
  zh: 有时，我们需要处理特定的异常细节。考虑以下交互会话的片段：
- en: '[PRE81]'
  id: totrans-521
  prefs: []
  type: TYPE_PRE
  zh: '[PRE81]'
- en: The Distance object was initialized with the r argument value set to None. While
    this code will lead to warnings from tools like mypy, it’s syntactically valid.
    The TypeError traceback, however, doesn’t point to Distance; it points to a line
    of code within the haversine() function.
  id: totrans-522
  prefs: []
  type: TYPE_NORMAL
  zh: Distance 对象使用 r 参数值设置为 None 进行初始化。虽然这段代码会导致像 mypy 这样的工具发出警告，但从语法上是有效的。然而，TypeError
    的 traceback 并不指向 Distance；它指向 haversine() 函数中的一行代码。
- en: 'We might want to report a ValueError instead of this TypeError. Here’s a variation
    on the Distance class, which conceals the TypeError, replacing it with a ValueError:'
  id: totrans-523
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可能想报告一个 ValueError 而不是这个 TypeError。下面是 Distance 类的一个变体，它隐藏了 TypeError，用 ValueError
    替换它：
- en: '[PRE82]'
  id: totrans-524
  prefs: []
  type: TYPE_PRE
  zh: '[PRE82]'
- en: This shows how we can examine the details of the exception in the __exit__()
    method. The information provided parallels the sys.exc_info() function, and includes
    the exception’s type, the exception object, and a traceback object with the types.TracebackType
    type.
  id: totrans-525
  prefs: []
  type: TYPE_NORMAL
  zh: 这显示了如何在 __exit__() 方法中检查异常的详细信息。提供的信息与 sys.exc_info() 函数类似，包括异常的类型、异常对象以及一个具有
    types.TracebackType 类型的 traceback 对象。
- en: 7.11.5 See also
  id: totrans-526
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 7.11.5 参见
- en: In the [Managing a context using the with statement](ch006_split_001.xhtml#x1-15200011)
    recipe in Chapter [2](ch006_split_000.xhtml#x1-840002), we cover the basics of
    using a file-based context manager.
  id: totrans-527
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在第 [2](ch006_split_000.xhtml#x1-840002) 章的[使用 with 语句管理上下文](ch006_split_001.xhtml#x1-15200011)
    节中，我们介绍了使用基于文件的上下文管理器的基础知识。
- en: 7.12 Managing multiple contexts with multiple resources
  id: totrans-528
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 7.12 使用多个资源管理多个上下文
- en: We often use context managers with open files. Because the context manager can
    guarantee the OS resources are released, doing so prevents resource leaks. It
    can be used to prevent files from being closed without having all buffers flushed
    to persistent storage.
  id: totrans-529
  prefs: []
  type: TYPE_NORMAL
  zh: 我们经常使用上下文管理器与打开的文件一起使用。因为上下文管理器可以保证操作系统资源被释放，这样做可以防止资源泄漏。它可以用来防止在没有将所有缓冲区刷新到持久存储的情况下关闭文件。
- en: When multiple resources are being processed, it often means multiple context
    managers will be needed. For example, if we have three open files, we could require
    three nested with statements? How can we optimize or simplify multiple with statements?
  id: totrans-530
  prefs: []
  type: TYPE_NORMAL
  zh: 当处理多个资源时，通常意味着需要多个上下文管理器。例如，如果我们有三个打开的文件，我们可能需要三个嵌套的 with 语句？我们如何优化或简化多个 with
    语句？
- en: 7.12.1 Getting ready
  id: totrans-531
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 7.12.1 准备工作
- en: 'We’ll look at creating a plan for a journey with multiple legs. Our starting
    data collection is a list of points that define our route. For example, traveling
    through Chesapeake Bay may involve starting in Annapolis, Maryland, sailing to
    Solomon’s Island, Deltaville, Virginia, and then Norfolk, Virginia. For planning
    purposes, we’d like to think of this as three legs, instead of four points. A
    leg has a distance and takes time to traverse: computing time, speed, and distance
    is the essence of the planning problem.'
  id: totrans-532
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将查看创建包含多个腿的行程计划。我们的起始数据收集是一个定义我们路线的点列表。例如，穿越切萨皮克湾可能涉及从马里兰州安纳波利斯出发，航行到索尔omon岛、弗吉尼亚州的Deltaville，然后到弗吉尼亚州的诺福克。为了规划目的，我们希望将其视为三条腿，而不是四个点。一条腿有距离，需要时间穿越：计算时间、速度和距离是规划问题的本质。
- en: 'We’ll start with some foundational definitions before we run the recipe. First
    is the definition of a single point, with attributes of latitude and longitude:'
  id: totrans-533
  prefs: []
  type: TYPE_NORMAL
  zh: 在运行配方之前，我们将先进行一些基础定义。首先是单个点的定义，具有纬度和经度属性：
- en: '[PRE83]'
  id: totrans-534
  prefs: []
  type: TYPE_PRE
  zh: '[PRE83]'
- en: 'A point can be built with a statement like this: p = Point(38.9784, -76.4922).
    This lets us refer to p.lat and p.lon in subsequent computations. The use of attribute
    names makes the code much easier to read.'
  id: totrans-535
  prefs: []
  type: TYPE_NORMAL
  zh: 可以使用如下语句构建一个点：p = Point(38.9784, -76.4922)。这让我们可以在后续计算中引用p.lat和p.lon。使用属性名称使代码更容易阅读。
- en: 'A leg is a pair of points. We can define it as follows:'
  id: totrans-536
  prefs: []
  type: TYPE_NORMAL
  zh: 一条腿是一对点。我们可以如下定义它：
- en: '[PRE84]'
  id: totrans-537
  prefs: []
  type: TYPE_PRE
  zh: '[PRE84]'
- en: We’ve created this as a mutable object. The distance attribute has an initial
    value defined by the dataclasses.field() function. The use of init=False means
    the attribute is not provided when the object is initialized; it must be supplied
    after initialization.
  id: totrans-538
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已将其创建为可变对象。距离属性具有由dataclasses.field()函数定义的初始值。使用init=False表示在初始化对象时不会提供该属性；它必须在初始化后提供。
- en: 'Here’s a context manager to create Leg objects from Point instances. This is
    similar to the context managers shown in the [Creating contexts and context managers](ch011_split_001.xhtml#x1-43700011)
    recipe. There is a tiny but important difference here. The __init__() saves a
    value for self.r to set the distance unit context. The default value is nautical
    miles:'
  id: totrans-539
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一个上下文管理器，用于从点实例创建Leg对象。这与[创建上下文和上下文管理器](ch011_split_001.xhtml#x1-43700011)配方中显示的上下文管理器类似。这里有一个微小但重要的区别。__init__()保存一个值给self.r来设置距离单位上下文。默认值是海里：
- en: '[PRE85]'
  id: totrans-540
  prefs: []
  type: TYPE_PRE
  zh: '[PRE85]'
- en: 'The important method, waypoint(), accepts a waypoint and creates a Leg object.
    The very first waypoint, the starting point for the voyage, will return None.
    All subsequent points will return a Leg object:'
  id: totrans-541
  prefs: []
  type: TYPE_NORMAL
  zh: 重要的方法waypoint()接受一个航点并创建一个Leg对象。第一个航点，即航行的起点，将返回None。所有后续的点将返回一个Leg对象：
- en: '[PRE86]'
  id: totrans-542
  prefs: []
  type: TYPE_PRE
  zh: '[PRE86]'
- en: This method uses a cached Point object, self.last_point, and the next point,
    next_point, to create a Leg instance and then update that instance.
  id: totrans-543
  prefs: []
  type: TYPE_NORMAL
  zh: 此方法使用缓存的点对象self.last_point和下一个点next_point来创建一个Leg实例，然后更新该实例。
- en: 'If we want to create an output file in CSV format, we’ll need to use two context
    managers: one to create Leg objects, and another to manage the open file. We’ll
    put this complex multi-context processing into a single function.'
  id: totrans-544
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们想在CSV格式中创建输出文件，我们需要使用两个上下文管理器：一个用于创建Leg对象，另一个用于管理打开的文件。我们将把这个复杂的多上下文处理放入一个单独的函数中。
- en: 7.12.2 How to do it...
  id: totrans-545
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 7.12.2 如何做到这一点...
- en: 'We’ll be working with the csv and pathlib modules. Additionally, this recipe
    will also make use of the Iterable type hint, and the asdict function from the
    dataclasses module:'
  id: totrans-546
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们将使用csv和pathlib模块。此外，此配方还将使用Iterable类型提示和dataclasses模块中的asdict函数：
- en: '[PRE87]'
  id: totrans-547
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE87]'
- en: 'Since we’ll be creating a CSV file, we need to define the headers to be used
    for the CSV output:'
  id: totrans-548
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 由于我们将创建CSV文件，我们需要定义用于CSV输出的标题：
- en: '[PRE88]'
  id: totrans-549
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE88]'
- en: 'Define a function to transform complex objects into a dictionary suitable for
    writing each individual row. The input is a Leg object; the output is a dictionary
    with keys that match the HEADERS list of column names:'
  id: totrans-550
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 定义一个函数，将复杂对象转换为适合写入每一行数据的字典。输入是一个Leg对象；输出是一个具有与HEADERS列表中列名匹配的键的字典：
- en: '[PRE89]'
  id: totrans-551
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE89]'
- en: 'Define the function with a meaningful name. We’ll provide two parameters: a
    list of Point objects and a Path object showing where the CSV file should be created.
    We’ve used Iterable[Point] as a type hint so this function can accept any iterable
    collection of Point instances:'
  id: totrans-552
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 定义一个具有意义名称的函数。我们将提供两个参数：一个点对象列表和一个Path对象，显示CSV文件应该创建的位置。我们已使用Iterable[Point]作为类型提示，因此此函数可以接受任何可迭代的点实例集合：
- en: '[PRE90]'
  id: totrans-553
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE90]'
- en: 'Start the two contexts with a single with statement. This will invoke both
    __enter__() methods to prepare both contexts for work. This line can get long:'
  id: totrans-554
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用单个with语句启动两个上下文。这将调用两个__enter__()方法来为工作准备两个上下文。这一行可能会很长：
- en: '[PRE91]'
  id: totrans-555
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE91]'
- en: 'Once the contexts are ready for work, we can create a CSV writer and begin
    writing rows:'
  id: totrans-556
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 一旦上下文准备好工作，我们可以创建一个CSV写入器并开始写入行：
- en: '[PRE92]'
  id: totrans-557
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE92]'
- en: 'At the end of the context, do any final summary processing. This is not indented
    within the with statement’s body; it is at the same indentation level as the with
    keyword itself:'
  id: totrans-558
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在上下文结束时，进行任何最终的汇总处理。这不是在with语句体的缩进内；它与with关键字本身的缩进级别相同：
- en: '[PRE93]'
  id: totrans-559
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE93]'
- en: By keeping this outside the with context, this message provides important evidence
    that the files were properly closed and all of the computations were completed.
  id: totrans-560
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 通过将此消息放在with上下文之外，它提供了重要的证据，表明文件已正确关闭，所有的计算都已完成。
- en: 7.12.3 How it works...
  id: totrans-561
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 7.12.3 它是如何工作的...
- en: The compound with statement created a number of context managers for us. All
    of the managers will have their __enter__() methods used to both start processing
    and, optionally, return an object usable within the context. The LegMaker class
    defined an __enter__() method that returned the LegMaker instance. The Path.open()
    method returns a TextIO object; these are also context managers.
  id: totrans-562
  prefs: []
  type: TYPE_NORMAL
  zh: 复合的with语句为我们创建了一系列上下文管理器。所有的管理器都将使用它们的__enter__()方法来开始处理，并且可选地返回一个可以在上下文中使用的对象。LegMaker类定义了一个返回LegMaker实例的__enter__()方法。Path.open()方法返回一个TextIO对象；这些也是上下文管理器。
- en: When the context exits at the end of the with statement, all of the context
    manager __exit__() methods are called. This allows each context manager to do
    any finalization. In the case of TextIO objects, this closes the external files,
    releasing any of the OS resources being used.
  id: totrans-563
  prefs: []
  type: TYPE_NORMAL
  zh: 当with语句结束时上下文退出，将调用所有上下文管理器的__exit__()方法。这允许每个上下文管理器执行任何最终的清理。在TextIO对象的情况下，这将关闭外部文件，释放正在使用的任何OS资源。
- en: In the case of the LegMaker object, there is no finalization processing on context
    exit. A LegMaker object was created; the value returned from the __enter__() method
    is a reference to a method of this object. The legger callable will continue to
    operate correctly even outside the context. This is an odd special case that occurs
    in instances where there is no cleanup in the __exit__() method. If it’s important
    to prevent further use of the legger callable, then the __exit__() method needs
    to make an explicit state change inside the LegMaker object so it raises an exception.
    One approach is for the __exit__() method to set the self.r value to None, which
    would prevent further use of the waypoint() method.
  id: totrans-564
  prefs: []
  type: TYPE_NORMAL
  zh: 在LegMaker对象的情况下，上下文退出时没有进行最终的清理处理。创建了一个LegMaker对象；从__enter__()方法返回的值是这个对象方法的引用。legger可调用对象将继续在上下文外部正确运行。这是一个特殊的情况，在没有在__exit__()方法中进行清理的情况下发生。如果需要防止进一步使用legger可调用对象，那么__exit__()方法需要在LegMaker对象内部进行显式的状态改变，以便抛出异常。一种方法是在__exit__()方法中将self.r值设置为None，这将防止进一步使用waypoint()方法。
- en: 7.12.4 There’s more...
  id: totrans-565
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 7.12.4 更多内容...
- en: A context manager’s job is to isolate details of resource management. The most
    common examples are files and network connections. We’ve shown the use of a context
    manager around an algorithm to help manage a cache with a single Point object.
  id: totrans-566
  prefs: []
  type: TYPE_NORMAL
  zh: 上下文管理器的任务是隔离资源管理的细节。最常见的情况是文件和网络连接。我们已经展示了在算法周围使用上下文管理器来帮助管理带有单个Point对象的缓存。
- en: When working with very large datasets, it’s often helpful to use compression.
    This can create a different kind of context around the processing. The built-in
    open() method is generally assigned to the io.open() function in the io module.
    This means we can often replace io.open() with a function such as bz2.open() to
    work with compressed files.
  id: totrans-567
  prefs: []
  type: TYPE_NORMAL
  zh: 当处理非常大的数据集时，使用压缩通常很有帮助。这可以在处理周围创建不同的上下文。内置的open()方法通常在io模块中分配给io.open()函数。这意味着我们通常可以用bz2.open()这样的函数替换io.open()来处理压缩文件。
- en: 'We can replace an uncompressed file context manager with something like this:'
  id: totrans-568
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以用类似这样的事物替换一个未压缩的文件上下文管理器：
- en: '[PRE94]'
  id: totrans-569
  prefs: []
  type: TYPE_PRE
  zh: '[PRE94]'
- en: We’ve replaced the original path.open() method with bz2.open(path). The rest
    of the context processing remains identical. This flexibility allows us to work
    with text files initially and later convert them to compressed files when the
    volume of data grows.
  id: totrans-570
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经用bz2.open(path)替换了原始的path.open()方法。其余的上下文处理保持不变。这种灵活性允许我们在数据量增长时，最初处理文本文件，然后将其转换为压缩文件。
- en: 7.12.5 See also
  id: totrans-571
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 7.12.5 参见
- en: In the [Managing a context using the with statement](ch006_split_001.xhtml#x1-15200011)
    recipe in Chapter [2](ch006_split_000.xhtml#x1-840002), we cover the basics of
    using a file-based context manager.
  id: totrans-572
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在第 [2](ch006_split_000.xhtml#x1-840002) 章的[使用 with 语句管理上下文](ch006_split_001.xhtml#x1-15200011)
    菜单中，我们介绍了基于文件上下文管理器的使用基础。
- en: The [Creating contexts and context managers](ch011_split_001.xhtml#x1-43700011)
    recipe covers the core of creating a class that is a context manager.
  id: totrans-573
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[创建上下文和上下文管理器](ch011_split_001.xhtml#x1-43700011) 菜单涵盖了创建一个上下文管理器类的核心内容。'
- en: Join our community Discord space
  id: totrans-574
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 加入我们的社区 Discord 空间
- en: 'Join our Python Discord workspace to discuss and find out more about the book:
    [https://packt.link/dHrHU](https://packt.link/dHrHU)'
  id: totrans-575
  prefs: []
  type: TYPE_NORMAL
  zh: 加入我们的 Python Discord 工作空间，讨论并了解更多关于这本书的信息：[https://packt.link/dHrHU](https://packt.link/dHrHU)
- en: '![PIC](img/file1.png)'
  id: totrans-576
  prefs: []
  type: TYPE_IMG
  zh: '![PIC](img/file1.png)'
