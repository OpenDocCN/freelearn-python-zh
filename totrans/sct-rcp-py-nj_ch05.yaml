- en: Generators, Coroutines, and Parallel Processing
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 生成器、协程和并行处理
- en: 'In this chapter, we will take a look at generators, coroutines, and parallel
    processing. Specifically, we will cover the following topics:'
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将探讨生成器、协程和并行处理。具体来说，我们将涵盖以下主题：
- en: How iteration works in Python
  id: totrans-2
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Python 中迭代是如何工作的
- en: Using the itertools module
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用 itertools 模块
- en: Using generator functions
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用生成器函数
- en: Simulating multithreading with coroutines
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用协程模拟多线程
- en: When to use parallel processing
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 何时使用并行处理
- en: Forking processes
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 进程分叉
- en: How to implement multithreading
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如何实现多线程
- en: How to implement multiprocessing
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如何实现多进程
- en: Although the various topics that will be covered in this chapter may seem to
    have little to do with each other, they do have an effect on one another. First,
    iteration is the process of walking through a sequence; Python provides several
    ways to iterate over objects. Generators are functions that generate values in
    a sequential order, implementing iteration functionality under the hood.
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管本章将要涵盖的各种主题似乎彼此之间没有太多关联，但它们确实相互影响。首先，迭代是通过遍历序列的过程；Python 提供了多种遍历对象的方法。生成器是按顺序生成值的函数，在幕后实现迭代功能。
- en: This moves into parallelism. Coroutines use generators to effectively create
    multiple processes to allow multitasking but it is controlled by the programmer.
    Multithreading switches processing based on when the operating system decides,
    not the programmer; this allows for concurrency. Multiprocessing utilizes multiple
    CPUs to allow true parallelism.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 这就进入了并行处理。协程使用生成器有效地创建多个进程以实现多任务处理，但它由程序员控制。多线程根据操作系统决定何时切换处理，而不是程序员；这允许并发。多进程利用多个
    CPU 以实现真正的并行处理。
- en: Without further ado, let's get started on our journey.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 不再拖延，让我们开始我们的旅程。
- en: How iteration works in Python
  id: totrans-13
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Python 中迭代是如何工作的
- en: In Python, an iterator is an object that represents a stream of data. While
    iterators are available for containers, sequences in particular always support
    iteration.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 在 Python 中，迭代器是一个表示数据流的对象。虽然迭代器适用于容器，但特别是序列始终支持迭代。
- en: Iterators have the `__next__()` method available (or the built-in `next()` function).
    Calling `next()` multiple times returns successive items from the data stream.
    When no more items are available, a `StopIteration` exception is thrown.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 迭代器具有可用的 `__next__()` 方法（或内置的 `next()` 函数）。多次调用 `next()` 会从数据流中返回连续的项目。当没有更多项目可用时，会抛出
    `StopIteration` 异常。
- en: Any class can use an iterator by defining a `container.__iter__()` method. This
    method returns an iterator object, typically just `self`. This object is necessary
    to support the iterator protocol. Different types of iteration can be supported,
    with each one providing a specific iterator request. For example, a tree structure
    could support both breadth-first and depth-first traversals.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 任何类都可以通过定义 `container.__iter__()` 方法来使用迭代器。此方法返回一个迭代器对象，通常是 `self`。此对象是支持迭代器协议所必需的。可以支持不同类型的迭代，每种类型都提供特定的迭代器请求。例如，树结构可以支持广度优先和深度优先遍历。
- en: 'The iterator protocol mentioned previously actually comprises two methods:
    `iterator.__next__()` and `iterator.__iter__()`. (Notice that `__iter__()` has
    a different class compared to the one above.)'
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 之前提到的迭代器协议实际上包含两个方法：`iterator.__next__()` 和 `iterator.__iter__()`。（注意 `__iter__()`
    与上面的类不同。）
- en: As we have already talked about `__next__()`, a short discussion of `__iter__()`
    is necessary. The `__iter__()` method returns the iterator object itself; this
    allows containers and iterators to be used with `for` and `in` statements.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我们已经讨论过的 `__next__()`，对 `__iter__()` 进行简短讨论是必要的。`__iter__()` 方法返回迭代器对象本身；这允许容器和迭代器与
    `for` 和 `in` 语句一起使用。
- en: How to do it...
  id: totrans-19
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 如何做到...
- en: 'The most common use of an interator is to loop through a sequence, printing
    out each element:'
  id: totrans-20
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 迭代器的最常见用途是循环遍历序列，打印出每个元素：
- en: '![](img/3acd45af-2b51-49f1-9627-3dc09db1a463.png)'
  id: totrans-21
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/3acd45af-2b51-49f1-9627-3dc09db1a463.png)'
- en: In the preceding example, we have simply iterated through a variety of sequence
    containers, specifically a list (*line 1*), a tuple (*line 2*), dictionary keys
    (*line 3*), characters in a string (*line 4*), and lines in a file (*line 5*).
  id: totrans-22
  prefs:
  - PREF_UL
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在前面的例子中，我们只是遍历了各种序列容器，具体来说是一个列表（*第 1 行*）、一个元组（*第 2 行*）、字典键（*第 3 行*）、字符串中的字符（*第
    4 行*）和文件中的行（*第 5 行*）。
- en: While a dictionary is not a sequence type but a mapping type, it does support
    iteration, as it has an `iter()` call that is only applicable to a dictionary's
    keys.
  id: totrans-23
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 尽管字典不是序列类型，而是映射类型，但它确实支持迭代，因为它有一个仅适用于字典键的 `iter()` 调用。
- en: When a `for` statement is used, it calls the built-in `iter()` function on the
    container. The `iter()` function returns an iterator object that defines the `__next__()`
    method to access each element within the container, sequentially. When the container
    is empty, the `StopIteration` exception is raised and the iteration process exits.
  id: totrans-24
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 当使用 `for` 语句时，它会调用容器上的内置 `iter()` 函数。`iter()` 函数返回一个迭代器对象，该对象定义了 `__next__()`
    方法以按顺序访问容器中的每个元素。当容器为空时，会引发 `StopIteration` 异常，迭代过程退出。
- en: 'The `__next__()` method can be manually called, if desired, as follows:'
  id: totrans-25
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果需要，可以手动调用 `__next__()` 方法，如下所示：
- en: '![](img/d9e283cd-f976-499b-8486-d7562c8b0b64.png)'
  id: totrans-26
  prefs: []
  type: TYPE_IMG
  zh: '![](img/d9e283cd-f976-499b-8486-d7562c8b0b64.png)'
- en: The *line 8* creates a string of three characters.
  id: totrans-27
  prefs:
  - PREF_UL
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在 *第8行* 中，创建一个由三个字符组成的字符串。
- en: The *line 9* manually creates an iterator object of the string.
  id: totrans-28
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在 *第9行* 中，手动创建一个字符串的迭代器对象。
- en: The *line 10* shows the iterator object's location in memory. It also shows
    what type of iterator it is, that is, a string iterator.
  id: totrans-29
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在 *第10行* 中，显示了迭代器对象在内存中的位置。它还显示了它是什么类型的迭代器，即字符串迭代器。
- en: The *line 11*-*line 13* manually call the `__next__()` method, which is available
    via the iterator object.
  id: totrans-30
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在 *第11行*-*第13行* 中，手动调用 `__next__()` 方法，该方法通过迭代器对象可用。
- en: The *line 14* attempts to call the next character in the string, but since the
    string is empty at this point, an exception is raised, terminating the iteration
    process.
  id: totrans-31
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在 *第14行* 中，尝试调用字符串中的下一个字符，但由于此时字符串为空，会引发异常，终止迭代过程。
- en: 'Modifying the iteration process is relatively easy:'
  id: totrans-32
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 修改迭代过程相对简单：
- en: Create a class object
  id: totrans-33
  prefs:
  - PREF_UL
  - PREF_UL
  type: TYPE_NORMAL
  zh: 创建一个类对象
- en: 'Define an `__iter__()` method that returns an object that is capable of using
    the `__next__()` method, typically `self` if the class defines the `__next__()`
    within itself. `reverse_seq.py` shows an example of this:'
  id: totrans-34
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 定义一个 `__iter__()` 方法，该方法返回一个可以使用 `__next__()` 方法的对象，通常是 `self`，如果类在其自身中定义了 `__next__()`。`reverse_seq.py`
    展示了这样一个例子：
- en: '[PRE0]'
  id: totrans-35
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'The following screenshot shows how the preceding code block deals with data
    input:'
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 以下截图显示了前面的代码块如何处理数据输入：
- en: '![](img/2ad6a306-6cf1-4183-814d-e03421f9649e.png)'
  id: totrans-37
  prefs: []
  type: TYPE_IMG
  zh: '![](img/2ad6a306-6cf1-4183-814d-e03421f9649e.png)'
- en: The example code creates a class designed to reverse-iterate through a supplied
    sequence. The input data can be any sequence object. The class defines the initial
    index value as the last item within the supplied sequence.
  id: totrans-38
  prefs:
  - PREF_UL
  - PREF_UL
  type: TYPE_NORMAL
  zh: 示例代码创建了一个类，用于通过提供的序列反向迭代。输入数据可以是任何序列对象。该类将初始索引值定义为提供的序列中的最后一个项目。
- en: The *line 23* creates an instance of the class, with a string sequence argument
    provided.
  id: totrans-39
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在 *第23行* 中，创建了一个类的实例，提供了一个字符串序列参数。
- en: The *line 24* simply shows the instance in memory.
  id: totrans-40
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在 *第24行* 中，简单地显示了内存中的实例。
- en: The l*ine 25* calls the iteration process, moving backward through the supplied
    sequence, starting from the end.
  id: totrans-41
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在 *第25行* 中，调用迭代过程，从提供的序列的末尾开始向前移动。
- en: The *line 26* creates another type of sequence, a list.
  id: totrans-42
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在 *第26行* 中，创建另一种类型的序列，即列表。
- en: The list is passed into a new instance in *line 27*.
  id: totrans-43
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在 *第27行* 中，将列表传递给一个新的实例。
- en: Like *line 25*, we work backward through the list in *line 28*. This demonstrates
    that any sequence object can be iterated through in reverse using this class.
  id: totrans-44
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 与 *第25行* 类似，我们在 *第28行* 中通过列表向后工作。这证明了可以使用此类反向迭代任何序列对象。
- en: 'For a more detailed exploration of iterators, we will walk through the iteration
    process, manually calling `next()` for each item in the sequence:'
  id: totrans-45
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 为了更详细地探索迭代器，我们将通过迭代过程进行讲解，手动对序列中的每个项目调用 `next()`：
- en: '![](img/f497abbe-d901-44e1-8779-ed041f0143cd.png)'
  id: totrans-46
  prefs: []
  type: TYPE_IMG
  zh: '![](img/f497abbe-d901-44e1-8779-ed041f0143cd.png)'
- en: In *line 31*, this time we are passing a tuple object directly into the instance
    argument.
  id: totrans-47
  prefs:
  - PREF_UL
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在 *第31行*，这次我们将一个元组对象直接传递给实例参数。
- en: In *lines 32*-*36*, we manually pull the next element from the tuple.
  id: totrans-48
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在 *第32行*-*第36行* 中，我们手动从元组中提取下一个元素。
- en: The *line 37* is the error given when there are no more elements to process.
  id: totrans-49
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在 *第37行* 中，当没有更多元素要处理时，会给出错误。
- en: Using the itertools module
  id: totrans-50
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用 itertools 模块
- en: Beyond just the standard iteration protocol, Python also provides the `itertools`
    module. This module provides a number of iterator building blocks that, used singly
    or in combination, can create specialized iteration tools for efficient looping.
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 除了标准的迭代协议之外，Python还提供了`itertools`模块。此模块提供了一系列迭代构建块，单独使用或组合使用，可以创建用于高效循环的特殊迭代工具。
- en: How to do it...
  id: totrans-52
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 如何实现...
- en: 'There are three main categories of `itertools`: infinite iterators, combinatoric
    iterators, and iterators that terminate on the shortest input sequence.'
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: '`itertools`主要有三类：无限迭代器、组合迭代器和在最短输入序列上终止的迭代器。'
- en: Infinite iterators
  id: totrans-54
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 无限迭代器
- en: 'Infinite iterators return values repeatedly until a terminating condition is
    reached:'
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 无限迭代器会重复返回值，直到达到终止条件：
- en: 'The `count(start=0, step=1)` function returns evenly spaced values that start
    at the `start` argument provided. Stepping is provided to allow skipping values.
    This function is frequently used with `map()` to generate consecutive data points.
    When used with `zip()`, it can be used to add sequence numbers:'
  id: totrans-56
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`count(start=0, step=1)`函数返回从提供的`start`参数开始的均匀间隔的值。步长提供以跳过值。此函数经常与`map()`一起使用来生成连续的数据点。当与`zip()`一起使用时，它可以用来添加序列号：'
- en: '![](img/391ebcff-8bff-4390-89a1-2b70bdc17138.png)'
  id: totrans-57
  prefs: []
  type: TYPE_IMG
  zh: '![](img/391ebcff-8bff-4390-89a1-2b70bdc17138.png)'
- en: In this example, we import the `count()` function from the `itertools` module
    in *line 54*.
  id: totrans-58
  prefs:
  - PREF_UL
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在这个例子中，我们在第54行从`itertools`模块中导入`count()`函数。
- en: In *line 55*, we create a counting loop, starting with the integer `5` and a
    stepping value of `5`, that is, counting by fives. When the count exceeds `50`,
    the loop quits.
  id: totrans-59
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在第55行，我们创建一个计数循环，从整数`5`开始，步长为`5`，即以五的倍数计数。当计数超过`50`时，循环退出。
- en: 'The `cycle(iterable)` function returns elements from an iterable and saves
    a copy of each one. When the sequence is completed, the saved copies are returned;
    this repeats forever:'
  id: totrans-60
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`cycle(iterable)`函数从可迭代对象中返回元素并保存每个元素的副本。当序列完成时，保存的副本将被返回；这会永远重复：'
- en: '![](img/6495f940-bf35-4670-b576-852b1eca884d.png)'
  id: totrans-61
  prefs: []
  type: TYPE_IMG
  zh: '![](img/6495f940-bf35-4670-b576-852b1eca884d.png)'
- en: After importing the `cycle()` function, we create a counter variable. This is
    because `cycle()` will continue indefinitely if an outside condition doesn't stop
    it.
  id: totrans-62
  prefs:
  - PREF_UL
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在导入`cycle()`函数后，我们创建一个计数器变量。这是因为如果没有外部条件停止它，`cycle()`将无限期地继续。
- en: The loop will repeatedly print the string `123` until the break condition is
    met, in this case, after 10 characters have been printed to the screen.
  id: totrans-63
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 循环将反复打印字符串`123`，直到满足退出条件，在这种情况下，在屏幕上打印了10个字符后。
- en: The `repeat(object, [, times])` function returns `object` indefinitely unless
    a value is supplied for `times`. While it may not seem to have an obvious use,
    `repeat()` is used with the `map()` function to map unchanging parameters to the
    called function, as well as with `zip()` to create a constant part of a tuple
    record.
  id: totrans-64
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`repeat(object, [, times])`函数在未提供`times`值的情况下无限期地返回`object`。虽然它可能看起来没有明显的用途，但`repeat()`与`map()`函数一起使用，将不变的参数映射到被调用的函数，以及与`zip()`一起使用，以创建元组记录的常数部分。'
- en: 'One benefit to the `repeat()` iterator is that the single object that is repeated
    is the only memory space allocated. If you want to repeat an object normally,
    that is, *x * n*, multiple copies of *x* are placed into memory:'
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: '`repeat()`迭代器的一个好处是重复的单个对象只分配了唯一的内存空间。如果你想正常地重复一个对象，即*x * n*，多个*x*的副本将被放入内存中：'
- en: '![](img/e894eeba-518c-4c59-bce0-a02a9cb112de.png)'
  id: totrans-66
  prefs: []
  type: TYPE_IMG
  zh: '![](img/e894eeba-518c-4c59-bce0-a02a9cb112de.png)'
- en: After we import the `repeat()` class, we run the command in *line 2*.
  id: totrans-67
  prefs:
  - PREF_UL
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在导入`repeat()`类后，我们在第2行运行命令。
- en: As the return object is an iterator, calling the `repeat()` command directly
    (*lines 2* and *3*) doesn't do anything besides returning the object itself.
  id: totrans-68
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 由于返回对象是一个迭代器，直接调用`repeat()`命令（第2行和第3行）除了返回对象本身之外，不会做任何事情。
- en: We have to make an instance (*line 4*) before we can do anything with the iterator.
  id: totrans-69
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在我们可以对迭代器做任何事情之前，我们必须创建一个实例（第4行）。
- en: Calling the instance directly (*line 5*) again only gives us the `repeat()`
    object.
  id: totrans-70
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 再次直接调用实例（第5行）只会给我们`repeat()`对象。
- en: Walking through the instance using iteration (*line 6*) displays the actual
    repetition process.
  id: totrans-71
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用迭代遍历实例（第6行）显示了实际的重复过程。
- en: The *line 7* gives an example of using `repeat()` with `map()` to provide a
    steady stream of values to `map()`. In this case, the line creates a list of squared
    values by mapping the `pow()` function to a range of 10 repeated integers.
  id: totrans-72
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 第7行给出了使用`repeat()`与`map()`结合提供一个稳定值流的例子，用于传递给`map()`。在这种情况下，该行通过将`pow()`函数映射到10个重复的整数范围，创建了一个平方值的列表。
- en: Combinatoric iterators
  id: totrans-73
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 组合迭代器
- en: 'Combinatoric iterators are concerned with the enumeration, combination, and
    permutation of element sets:'
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 组合迭代器关注元素集合的枚举、组合和排列：
- en: The `product(*iterables, repeat=1)` iterator produces a Cartesian product from
    the inputted iterable objects; it is essentially the same as using nested `for`
    loops in a generator. The nested loops cycle through the input iterables, with
    the rightmost element incrementing every iteration. The pattern returned is dependent
    upon the input; that is, if the input iterables are sorted, the output product
    tuples will be sorted as well.
  id: totrans-75
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`product(*iterables, repeat=1)`迭代器从输入的可迭代对象生成笛卡尔积；它本质上与在生成器中使用嵌套`for`循环相同。嵌套循环遍历输入的可迭代对象，最右边的元素在每次迭代时递增。返回的模式取决于输入；也就是说，如果输入的可迭代对象已排序，则输出乘积元组也将排序。'
- en: 'It is important to point out that Cartesian products are not mathematical products;
    that is, they aren''t the result of multiplication. They are actually part of
    analytic geometry and are all the possible ordered combinations of numbers from
    each input set. In other words, if a line is defined by two different points,
    each with an *x, y* value, the product set would be all the possible ordered pairs
    from those two sets, with the first value coming from the first set and the second
    value coming from the second set. The following example shows the Cartesian products
    created from a set of three points:'
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 需要指出的是，笛卡尔积不是数学乘积；也就是说，它们不是乘法的结果。实际上，它们是解析几何的一部分，并且是来自每个输入集的所有可能的有序数组合。换句话说，如果一条线由两个不同的点定义，每个点都有一个*x,
    y*值，那么乘积集将包含来自这两个集的所有可能的有序对，第一个值来自第一个集，第二个值来自第二个集。以下示例显示了由三个点集生成的笛卡尔积：
- en: '![](img/9288935b-aac0-42dd-a247-7ae92b086c82.png)'
  id: totrans-77
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/9288935b-aac0-42dd-a247-7ae92b086c82.png)'
- en: The  `product()` function is imported into the program in *line 18*.
  id: totrans-78
  prefs:
  - PREF_UL
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在*第18行*中，将`product()`函数导入到程序中。
- en: The *line 19* creates a list of three sets, such as representing a line in a
    three-dimensional box.
  id: totrans-79
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 第19行创建了一个包含三个集合的列表，例如表示一个三维盒子中的线。
- en: In *line 20*, the iterator from `product()` is assigned to a variable. In this
    case, the final object is a tuple to collect the final sets.
  id: totrans-80
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在*第20行*中，将`product()`的迭代器分配给一个变量。在这种情况下，最终对象是一个元组，用于收集最终的集合。
- en: The *line 21* shows the product sets that were created from the three input
    sets. All possible combinations of input values have been produced.
  id: totrans-81
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 第21行显示了从三个输入集创建的乘积集。已经生成了所有可能的输入值组合。
- en: 'The `permutations(iterable, r=None)` function returns successive `r` length
    permutations of the elements provided in the `iterable` argument. If `r` is not
    provided, then the full length of the provided argument is iterated through, with
    all possible permutations provided. Elements are considered unique to their position,
    not their value, so there will be no repeated values in the returned permutations
    if the input elements are unique:'
  id: totrans-82
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`permutations(iterable, r=None)`函数返回`iterable`参数提供的元素的连续`r`长度排列。如果未提供`r`，则遍历提供的参数的完整长度，提供所有可能的排列。元素被认为是其位置的唯一，而不是其值，因此如果输入元素是唯一的，则返回的排列中不会有重复的值：'
- en: '![](img/ac7bd07d-75a3-46db-81a9-de5cd0bda548.png)'
  id: totrans-83
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/ac7bd07d-75a3-46db-81a9-de5cd0bda548.png)'
- en: After importation, a short string is created and passed into the `permutations()`
    function (*line 28*).
  id: totrans-84
  prefs:
  - PREF_UL
  - PREF_UL
  type: TYPE_NORMAL
  zh: 导入后，创建了一个短字符串并将其传递给`permutations()`函数（*第28行*）。
- en: The results of printing the permutations are provided as tuples.
  id: totrans-85
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 打印排列的结果以元组的形式提供。
- en: To have the items in the tuples returned in a more normal fashion, the `join()`
    function can be used (*line 29*).
  id: totrans-86
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 为了以更正常的方式返回元组中的项，可以使用`join()`函数（*第29行*）。
- en: 'The  `combinations_with_replacement(iterable, r)` function returns `r` length
    subsets of the elements from `iterable`; this allows the elements to be repeated,
    unlike the normal `combinations()`:'
  id: totrans-87
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`combinations_with_replacement(iterable, r)`函数返回`iterable`中元素的`r`长度子集；这允许元素重复，与正常的`combinations()`不同：'
- en: '![](img/3b43c128-a4d9-4e83-a569-aee5c63c561b.png)'
  id: totrans-88
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/3b43c128-a4d9-4e83-a569-aee5c63c561b.png)'
- en: In this example, we have limited the returned values to only two elements of
    the input string from *line 27* of the previous example.
  id: totrans-89
  prefs:
  - PREF_UL
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在这个例子中，我们将返回的值限制为从上一个示例的 *第27行* 开始的输入字符串的仅两个元素。
- en: Because elements can repeat, if we set `r=3`, we get the results in *line 34*.
    When compared to *line 28*, not only are there more results, but the elements
    are duplicated; sometimes this is desired, but usually it is not.
  id: totrans-90
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 因为元素可以重复，如果我们设置 `r=3`，我们得到 *第34行* 中的结果。与 *第28行* 相比，不仅结果更多，而且元素被重复；有时这是所希望的，但通常不是。
- en: Terminating iterators
  id: totrans-91
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 终止迭代器
- en: 'Terminating iterators return values until the shortest input sequence has been
    iterated through, then it terminates:'
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 终止迭代器返回值，直到迭代最短输入序列，然后终止：
- en: 'The `accumulate(iterable[, func])` function returns an iterator of accumulated
    sums, or the results of other binary functions, as determined by the value provided
    to the `func` argument. If `func` is provided, it should be a function of two
    arguments. The `iterable` elements can be any type that can be used by `func`
    as arguments. The default function is `addition`. The following example shows
    this default functionality:'
  id: totrans-93
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`accumulate(iterable[, func])` 函数返回一个累积总和的迭代器，或其他二元函数的结果，这取决于 `func` 参数提供的值。如果提供了
    `func`，它应该是两个参数的函数。`iterable` 元素可以是 `func` 作为参数使用的任何类型。默认函数是 `addition`。以下示例显示了此默认功能：'
- en: '![](img/dfe379ed-91f4-4117-b89a-4dba0072c5df.png)'
  id: totrans-94
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/dfe379ed-91f4-4117-b89a-4dba0072c5df.png)'
- en: As the default function is addition, using `accumulate` to add a range of five numbers
    returns the sum of each addition process. The sum of the previous addition is
    one of the input values to the next addition calculation. Thus, in the output
    of *line 37*, it is seen that *0 + 0 = 0, 0 + 1 = 1, 1 + 2 = 3, 3 + 3 = 6, 6 +
    4 = 10*.
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 由于默认函数是加法，使用 `accumulate` 添加五个数字的范围返回每个加法过程的和。前一次加法的和是下一次加法计算的输入值之一。因此，在 *第37行*
    的输出中可以看到：*0 + 0 = 0, 0 + 1 = 1, 1 + 2 = 3, 3 + 3 = 6, 6 + 4 = 10*。
- en: 'The `func` argument has a variety of uses. It can be set to `min()` to track
    the minimum value during the iteration, `max()` to track the maximum value, or
    `operator.mul()` to track the multiplication product, as demonstrated in the following
    example:'
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: '`func` 参数有多种用途。它可以设置为 `min()` 以在迭代过程中跟踪最小值，`max()` 以跟踪最大值，或者 `operator.mul()`
    以跟踪乘积，如下面的示例所示：'
- en: '![](img/17e99a24-b650-4363-9242-c333d852554d.png)'
  id: totrans-97
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/17e99a24-b650-4363-9242-c333d852554d.png)'
- en: The *line 34* shows the minimum value that is processed during the iteration
    process. In this case, since the iterable argument is a `range()`, the lowest
    value will be zero.
  id: totrans-98
  prefs:
  - PREF_UL
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*第34行* 显示了迭代过程中处理的最小值。在这种情况下，由于可迭代参数是 `range()`，最低值将是零。'
- en: If we switch to tracking the maximum running value (*line 35*), the results
    show that each addition shows the next value to be added.
  id: totrans-99
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果我们切换到跟踪最大运行值 (*第35行*)，结果显示每次加法都会显示下一个要添加的值。
- en: The *line 36* imports `operator`, which is then used in *line 37* to multiply
    each subsequent value in a given range. Note that the range has to start at one,
    otherwise all the results will be zero because each value will be multiplied against
    the initial starting zero value in the range.
  id: totrans-100
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*第36行* 导入了 `operator`，然后在 *第37行* 中用于乘以给定范围内的每个后续值。请注意，范围必须从1开始，否则所有结果都将为零，因为每个值都将与范围中的初始起始零值相乘。'
- en: 'One use of `accumulate()` is in debt management; amortization tables can be
    created by accumulating the interest and accounting for payments:'
  id: totrans-101
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`accumulate()` 的一种用途是债务管理；可以通过累积利息和考虑付款来创建摊销表：'
- en: '![](img/80fd4c31-086e-41a6-8e59-b1615896668e.png)'
  id: totrans-102
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/80fd4c31-086e-41a6-8e59-b1615896668e.png)'
- en: The *line 38* shows an initial loan of $1,000, then four payments of $120.
  id: totrans-103
  prefs:
  - PREF_UL
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*第38行* 显示了一笔初始贷款 1000 美元，然后四次付款各 120 美元。'
- en: The *line 39* uses a lambda function to return the current balance, with each
    value in the `money` list used as the payment and the previous balance as the
    input balance value. The value of `1.05` equals an interest rate of 5%.
  id: totrans-104
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*第39行* 使用 lambda 函数返回当前余额，`money` 列表中的每个值用作付款，前一个余额作为输入余额值。`1.05` 的值等于 5% 的利率。'
- en: Another use of `accumulate()` is in recurrence relations. A recurrence relation
    is an equation that recursively defines a sequence or multidimensional array when
    one or more initial items are given; subsequent items of the sequence are defined
    as a function of the preceding terms.
  id: totrans-105
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`accumulate()` 的另一个用途是递归关系。递归关系是一个方程，它通过给定一个或多个初始项递归地定义一个序列或多维数组；序列的后续项被定义为前一项的函数。'
- en: 'In the following example, a recurrence relation is created after an initial
    value is supplied for the iterable and the accumulated total is passed into the
    `func` argument. This particular example applies to logistic mapping (this is
    how chaotic behavior develops from simple, non-linear dynamical equations) and
    comes from [https://docs.python.org/3.6/library/itertools.html#itertools.accumulate](https://docs.python.org/3.6/library/itertools.html#itertools.accumulate):'
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 在以下示例中，在为可迭代对象提供一个初始值并将累积总和传递给`func`参数之后，创建了一个递归关系。这个特定的例子适用于逻辑映射（这就是混沌行为如何从简单的非线性动力学方程中发展而来），并来自[https://docs.python.org/3.6/library/itertools.html#itertools.accumulate](https://docs.python.org/3.6/library/itertools.html#itertools.accumulate)：
- en: '![](img/a90eef80-6f70-4c9c-ae53-3a58ae7b1ccd.png)'
  id: totrans-107
  prefs: []
  type: TYPE_IMG
  zh: '![](img/a90eef80-6f70-4c9c-ae53-3a58ae7b1ccd.png)'
- en: As this book isn't designed to discuss such topics as chaotic recurrence relations,
    I won't delve into how this code actually works. However, I will note that *line
    40* shows a lambda function that only has a single input argument, `x`. The other
    value is ignored, as `r` is taken from the subsequently assigned variable in *line
    41*.
  id: totrans-108
  prefs:
  - PREF_UL
  - PREF_UL
  type: TYPE_NORMAL
  zh: 由于这本书不是用来讨论诸如混沌递归关系等主题的，所以我不深入探讨这段代码的实际工作原理。然而，我将指出*第40行*显示了一个只有一个输入参数`x`的lambda函数。其他值被忽略，因为`r`是从随后分配的变量中取的*第41行*。
- en: In *line 43*, only the initial `x` value is provided to the `iterable` argument.
    Also note this is an example of the `repeat()` itertool in a practical use.
  id: totrans-109
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在*第43行*，只提供了初始的`x`值给`iterable`参数。同时注意这也是`repeat()`迭代工具在实际应用中的例子。
- en: The *line 44* defines a list comprehension printing the value of `x` to two
    decimal points as the `log_map` anonymous function is run through the accumulator.
  id: totrans-110
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*第44行*定义了一个列表推导式，打印出`x`的两位小数值，当`log_map`匿名函数通过累加器运行时。'
- en: 'The `chain(*iterables)` function returns elements from the first iterable argument
    until there are no more values. At that point, the next iterable argument is processed
    until empty. This continues until all iterable arguments are finished. The `chain()` function
    essentially turns multiple sequences into a single sequence:'
  id: totrans-111
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`chain(*iterables)`函数从第一个可迭代参数返回元素，直到没有更多值。此时，处理下一个可迭代参数直到为空。这会一直持续到所有可迭代参数都完成。`chain()`函数本质上将多个序列转换为一个序列：'
- en: '![](img/d2d4b640-1409-408f-bef6-2c79e862fa97.png)'
  id: totrans-112
  prefs: []
  type: TYPE_IMG
  zh: '![](img/d2d4b640-1409-408f-bef6-2c79e862fa97.png)'
- en: After importing the `chain` tool, in *line 46* we create a list object that
    passes two lists and a tuple to `chain()`. These arguments could have also been
    predefined variables, but are simply the raw data in this case.
  id: totrans-113
  prefs:
  - PREF_UL
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在导入`chain`工具后，我们在*第46行*创建了一个列表对象，该对象将两个列表和一个元组传递给`chain()`。这些参数也可以是预定义的变量，但在这个例子中它们只是原始数据。
- en: When we print out the `chain` results in *line 47*, we see that it has combined
    all the disparate sequence objects as a single list.
  id: totrans-114
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 当我们在*第47行*打印出`chain`结果时，我们看到它已将所有不同的序列对象合并为一个列表。
- en: 'An alternative way to accomplish the same thing is to simply concatenate objects:'
  id: totrans-115
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 完成相同任务的一种替代方法是简单地连接对象：
- en: '![](img/1ecc3e39-ed59-4190-b365-42c47b306c18.png)'
  id: totrans-116
  prefs: []
  type: TYPE_IMG
  zh: '![](img/1ecc3e39-ed59-4190-b365-42c47b306c18.png)'
- en: The *lines 55*-*57* create variables from the raw data used in *line 53*.
  id: totrans-117
  prefs:
  - PREF_UL
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*第55行*至*第57行*从*第53行*中使用的原始数据创建变量。'
- en: The *line 58* concatenates all the lists together. Printing the results in *line
    59* shows the same output as achieved in *line 54*. Either way is correct; which
    method to use just depends on which makes more sense to the developer.
  id: totrans-118
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*第58行*将所有列表连接在一起。在*第59行*打印结果时，显示的输出与*第54行*达到的输出相同。两种方法都是正确的；使用哪种方法取决于哪种方法对开发者来说更有意义。'
- en: There is a modified version of `chain()`—`chain.from_iterable(iterable)`. This
    is effectively the same thing as `chain`, except it chains inputs from a single
    iterable argument. The argument is evaluated lazily, meaning it delays evaluation
    of the expression until its value is needed. For example, in Python 2, the `range()`
    function is immediately evaluated, so all the integers produced by the `range()`
    are stored in memory when the function is examined.
  id: totrans-119
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 存在`chain()`的一个修改版本——`chain.from_iterable(iterable)`。这实际上与`chain`相同，只是它从单个可迭代参数中链式连接输入。该参数是惰性评估的，这意味着它将表达式评估延迟到其值需要时。例如，在Python
    2中，`range()`函数立即评估，所以当函数被检查时，由`range()`产生的所有整数都存储在内存中。
- en: 'In contrast, Python 3 has a lazy `range()` evaluation. While a variable could
    be assigned to a `range()` call, the call itself would reside in memory while
    the integers would only be called into existence when needed. Consider the following
    examples:'
  id: totrans-120
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 相比之下，Python 3有一个懒加载的`range()`评估。虽然可以将变量分配给`range()`调用，但调用本身会驻留在内存中，而整数只有在需要时才会被调用到存在。考虑以下示例：
- en: 'In the following example screenshot, we see that, when printing a range variable
    in Python 2, all the integers are immediately available; when calling an indexed
    value, its result is obviously provided:'
  id: totrans-121
  prefs:
  - PREF_UL
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在下面的示例屏幕截图，我们看到，当在Python 2中打印一个范围变量时，所有整数都立即可用；当调用索引值时，其结果显然提供：
- en: '![](img/9201badf-62d2-4e5e-a288-c1b295b349b8.png)'
  id: totrans-122
  prefs: []
  type: TYPE_IMG
  zh: '![](img/9201badf-62d2-4e5e-a288-c1b295b349b8.png)'
- en: 'In the next example screenshot, Python 3 returns only the `range` object, not
    the entire list of integers. However, when calling an indexed value, it is returned
    because the `range` object is evaluated at that time to determine the value of
    the index. However, only that value is determined; attempting to print the variable
    again still shows the `range` object, rather than the list of integers:'
  id: totrans-123
  prefs:
  - PREF_UL
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在下一个示例屏幕截图，Python 3只返回`range`对象，而不是整个整数列表。然而，当调用索引值时，它被返回，因为此时`range`对象被评估以确定索引的值。然而，只确定那个值；再次尝试打印变量时，仍然显示`range`对象，而不是整数列表：
- en: '![](img/d0ded41a-8f4e-4f49-ac02-b6b8090f4e48.png)'
  id: totrans-124
  prefs: []
  type: TYPE_IMG
  zh: '![](img/d0ded41a-8f4e-4f49-ac02-b6b8090f4e48.png)'
- en: 'Going back to `chain.from_iterable()`, the following example shows how it can
    be used:'
  id: totrans-125
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 回到`chain.from_iterable()`，以下示例显示了如何使用它：
- en: '![](img/9deb358c-13ce-4c03-8e6b-84aabe6dec54.png)'
  id: totrans-126
  prefs: []
  type: TYPE_IMG
  zh: '![](img/9deb358c-13ce-4c03-8e6b-84aabe6dec54.png)'
- en: In this case, `from_iterable()` is actually a method of the `chain` class, so
    it is called using dot nomenclature.
  id: totrans-127
  prefs:
  - PREF_UL
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在这种情况下，`from_iterable()`实际上是`chain`类的一个方法，因此使用点命名法调用。
- en: Whereas the normal `chain` call takes in separate, iterable objects, `from_iterable`
    takes a single object that has multiple elements, for example, a typical list.
    The elements are combined into a single object in the returned value.
  id: totrans-128
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 与正常的`chain`调用接受单独的可迭代对象不同，`from_iterable`接受一个包含多个元素的单一对象，例如，一个典型的列表。元素在返回值中组合成一个单一对象。
- en: With `compress(data, selectors)`, an iterator is created that filters the elements
    from the `data` argument and returns only those elements that match `selectors`.
    When either `data` or `selectors` is empty, the process is finished.
  id: totrans-129
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用`compress(data, selectors)`，创建一个迭代器，从`data`参数中过滤元素，并只返回与`selectors`匹配的元素。当`data`或`selectors`中的任何一个为空时，过程结束。
- en: 'In reality, the matching occurs when an element in `selectors` is evaluated
    as `True`, rather than matching the exact element type. Thus, Boolean-type values
    are used, that is, `True`*/*`False` or 1/0:'
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 实际上，匹配发生在`selectors`中的元素被评估为`True`时，而不是匹配确切的元素类型。因此，使用布尔类型值，即`True`/*`False`或1/0：
- en: '![](img/861dba34-fef2-44d0-8797-760de5feede0.png)'
  id: totrans-131
  prefs: []
  type: TYPE_IMG
  zh: '![](img/861dba34-fef2-44d0-8797-760de5feede0.png)'
- en: The preceding example shows that both Boolean values (*line 3*) and binary integers
    (*line 4*) can be used as comparison values for `selectors`.
  id: totrans-132
  prefs:
  - PREF_UL
  - PREF_UL
  type: TYPE_NORMAL
  zh: 前面的例子表明，布尔值（*第3行*）和二进制整数（*第4行*）都可以用作`selectors`的比较值。
- en: 'The  `dropwhile(predicate, iterable)` function makes an iterator that drops
    elements from `iterable` while the `predicate` is `true`. When `predicate` is
    `false`, every element will be returned. Of note is the fact that the iterator
    will not show any output until `predicate` becomes `false`, so there may be some
    delay before output occurs:'
  id: totrans-133
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`dropwhile(predicate, iterable)`函数创建一个迭代器，在`predicate`为`true`时从`iterable`中丢弃元素。当`predicate`为`false`时，将返回每个元素。值得注意的是，迭代器不会显示任何输出，直到`predicate`变为`false`，因此输出可能存在一些延迟：'
- en: '![](img/96d4f29e-4f85-4e13-9e9e-9a6ec43b83cd.png)'
  id: totrans-134
  prefs: []
  type: TYPE_IMG
  zh: '![](img/96d4f29e-4f85-4e13-9e9e-9a6ec43b83cd.png)'
- en: The preceding example uses an anonymous lambda function to drop all values that
    are less than 4\. The *line 8* reinforces the fact that iterator objects do not
    automatically do anything without being processed by something that can deal with
    iterators.
  id: totrans-135
  prefs:
  - PREF_UL
  - PREF_UL
  type: TYPE_NORMAL
  zh: 前面的例子使用匿名lambda函数丢弃所有小于4的值。*第8行*强调了迭代器对象在没有被能够处理迭代器的某个东西处理的情况下不会自动执行任何事情。
- en: Thus, *line 9* passes the `dropwhile` object into a list, which runs the lambda
    function and drops all values within the iterable argument, returning only those
    values that are greater than or equal to four.
  id: totrans-136
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 因此，*第9行*将`dropwhile`对象传递给一个列表，该列表运行lambda函数并丢弃可迭代参数内的所有值，只返回大于或等于四的值。
- en: Similar to `dropwhile`*,* `filterfalse(predicate, iterable)` filters the elements
    in `iterable` and returns only those where the `predicate` is `False`. Conversely,
    if `predicate` is `None`, then it only returns those elements that are, themselves,
    `False`*.*
  id: totrans-137
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 与`dropwhile`*相同，* `filterfalse(predicate, iterable)`过滤`iterable`中的元素，并仅返回那些`predicate`为`False`的元素。相反，如果`predicate`是`None`，则它仅返回那些自身就是`False`的元素*.*
- en: 'It should be pointed that, unlike `dropwhile`, `filterfalse` will evaluate
    every single element. The `dropwhile` object functions only until a `false` comparison
    is made; after that, everything is returned. Thus, `filterfalse` can be used to
    ensure every item is evaluated where as `dropwhile` can be used as a one-shot
    check:'
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 应该指出，与`dropwhile`不同，`filterfalse`会评估每个单独的元素。`dropwhile`对象仅在执行到`false`比较时才会停止工作；之后，所有内容都会被返回。因此，`filterfalse`可以用来确保每个项目都被评估，而`dropwhile`则可以用作一次性检查：
- en: '*![](img/ffd3d75f-0f7b-4612-950f-3fd6863ee860.png)*'
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: '![图片](img/ffd3d75f-0f7b-4612-950f-3fd6863ee860.png)'
- en: In this example, `filterfalse` takes a lambda function (*line 11*) that uses
    the modulus of a range of numbers to return those values with a remainder of zero.
    Since zero is considered `False`, only those values will be returned.
  id: totrans-140
  prefs:
  - PREF_UL
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在这个例子中，`filterfalse`使用一个lambda函数（*第11行*），该函数使用一系列数字的余数来返回那些余数为零的值。由于零被认为是`False`，因此只有那些值会被返回。
- en: To make an easier comparison with `dropwhile`, we will used the same input as
    the `dropwhile` example in *line 12*. This is a good way to show that every element
    is evaluated separately, since the only output is those values greater than or
    equal to 4\. In the `dropwhile` example, even though the numbers returned were
    the same, the values of `2` and `3` were returned even though they are less than
    4 because `dropwhile` failed to open when the first `False` value occurred.
  id: totrans-141
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 为了与`dropwhile`更容易地进行比较，我们将使用与*第12行*中`dropwhile`示例相同的输入。这是一个展示每个元素都是单独评估的好方法，因为唯一的输出是大于或等于4的值。在`dropwhile`示例中，尽管返回的数字相同，但`2`和`3`的值也被返回，尽管它们小于4，因为`dropwhile`在第一个`False`值出现时未能打开。
- en: The `groupby(iterable, key=None)` method produces an iterator that returns consecutive
    keys and groups from the supplied `iterable`. The `key` function is a function
    that computes a key value for each element; if `key` is `None`, it defaults to
    returning the elements unchanged. It is preferable that the `iterable` be pre-sorted
    on the same `key` function.
  id: totrans-142
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`groupby(iterable, key=None)`方法产生一个迭代器，它返回从提供的`iterable`中连续的键和组。`key`函数是一个计算每个元素键值的函数；如果`key`是`None`，则默认返回未更改的元素。最好在相同的`key`函数上对`iterable`进行预排序。'
- en: This method operates in a similar way to the `uniq` filter in Unix, as it creates
    a new group or a break every time the `key` function value changes. However, it
    differs from SQL's `group by` function, as that aggregates common elements regardless
    of their input order.
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 此方法与Unix中的`uniq`过滤器以类似的方式运行，因为它在`key`函数值改变时创建一个新的组或一个断点。然而，它与SQL的`group by`函数不同，因为后者无论输入顺序如何都会聚合共同元素。
- en: 'To use the following example, ensure that `from itertools import groupby` is
    used as it is used in *line 34*:'
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 要使用以下示例，请确保使用与*第34行*中相同的`from itertools import groupby`：
- en: '![](img/ade56270-ba45-469a-a055-aac39e1dd64d.png)'
  id: totrans-145
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/ade56270-ba45-469a-a055-aac39e1dd64d.png)'
- en: For this example, *line 31* is simply a list of tuples that contain the make
    and model of cars.
  id: totrans-146
  prefs:
  - PREF_UL
  - PREF_UL
  type: TYPE_NORMAL
  zh: 对于这个例子，*第31行*只是一个包含汽车制造商和型号的元组列表。
- en: The *line 32* sorts the list based on the first item in each tuple, as shown
    in *line 33*.
  id: totrans-147
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*第32行*根据每个元组的第一个项目对列表进行排序，如*第33行*所示。'
- en: The *line 34* actually implements the `groupby` method. The `groupby` method
    takes as its arguments the sorted list and an anonymous function that tells `groupby`
    to use the first item in each tuple as the grouping key.
  id: totrans-148
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*第34行*实际上实现了`groupby`方法。`groupby`方法将其参数作为排序后的列表和一个匿名函数，告诉`groupby`使用每个元组的第一个项目作为分组键。'
- en: Then, in an enclosed loop, we look at the second element in the tuple and print
    out the model (second tuple element) and make (first tuple element, that is, the
    group key) of the cars list. We finish by adding a separation line to indicate
    where each group ends.
  id: totrans-149
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后，在一个封闭的循环中，我们查看元组的第二个元素，并打印出模型（第二个元组元素）和列表中的汽车（第一个元组元素，即组键）。我们通过添加一个分隔线来结束，以指示每个组结束的位置。
- en: 'The following screenshot shows what happens if you forget to sort your input
    iterable. In this case, `groupby` still works by grouping common elements, but
    only if they are follow one another within the iterable:'
  id: totrans-150
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 以下截图显示了如果你忘记对输入的可迭代进行排序会发生什么。在这种情况下，`groupby` 仍然通过分组常见元素来工作，但前提是它们在可迭代中依次排列：
- en: '![](img/b0745e51-7029-4a04-bdde-ce5048e5422a.png)'
  id: totrans-151
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/b0745e51-7029-4a04-bdde-ce5048e5422a.png)'
- en: 'The  `isslice(iterable[, start], stop[, step])` function returns selected elements
    from the `iterable` argument. If `start` is provided and is not zero, elements
    within `iterable` are skipped until the start index is reached. If `stop` is `None`,
    then all elements within the `iterable` are processed. The `isslice()` function
    works differently from regular slices, as it doesn''t allow negative numbers for
    `start`*,* `stop`, or `step`:'
  id: totrans-152
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`isslice(iterable[, start], stop[, step])` 函数从 `iterable` 参数返回选定的元素。如果提供了 `start`
    并且不是零，则跳过 `iterable` 中的元素，直到达到起始索引。如果 `stop` 为 `None`，则处理 `iterable` 中的所有元素。`isslice()`
    函数与常规切片不同，因为它不允许 `start`、`stop` 或 `step` 为负数：'
- en: '![](img/432575ba-630f-4eb1-a09a-011c8f82367c.png)'
  id: totrans-153
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/432575ba-630f-4eb1-a09a-011c8f82367c.png)'
- en: The preceding example shows the different variations that can be used with `islice`.
    The *line 38* shows the iterator stopping after four element indexes are returned.
  id: totrans-154
  prefs:
  - PREF_UL
  - PREF_UL
  type: TYPE_NORMAL
  zh: 上述示例显示了可以使用 `islice` 的不同变体。*第 38* 行显示了迭代器在返回四个元素索引后停止。
- en: '*The line 39* shows the iterator starting at element index `2` and stopping
    after index `4`.'
  id: totrans-155
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*第 39* 行显示了迭代器从元素索引 `2` 开始，并在索引 `4` 之后停止。'
- en: The *line 40* starts at index `2` and returns all values in `iterable`.
  id: totrans-156
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 第 *40* 行从索引 `2` 开始，并返回 `iterable` 中的所有值。
- en: The *line 41* is the same as *line 40*, except that the returned values have
    a stepping of `2`.
  id: totrans-157
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 第 *41* 行与 *40* 行相同，区别在于返回值有一个步长为 `2`。
- en: 'The  `starmap(function, iterable)` method computes `function` using arguments
    from `iterable`*.* This method is used in lieu of `map()` when argument parameters
    are pre-zipped; that is, they are already combined into tuples in a single iterable.
    In essence, `starmap()` can take any number of arguments (hence the `star` part
    of the name) whereas `map()` can only accept two arguments:'
  id: totrans-158
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`starmap(function, iterable)` 方法使用来自 `iterable` 的参数计算 `function`。当参数参数预先打包；也就是说，它们已经组合成单个可迭代中的元组时，使用该方法代替
    `map()`。本质上，`starmap()` 可以接受任意数量的参数（因此名称中的 `star` 部分），而 `map()` 只能接受两个参数：'
- en: '![](img/6264d201-cf4d-4813-86d6-583d3e1cf7c6.png)'
  id: totrans-159
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/6264d201-cf4d-4813-86d6-583d3e1cf7c6.png)'
- en: After importation, a `starmap` object is created and confirmed in *line 43*
  id: totrans-160
  prefs:
  - PREF_UL
  - PREF_UL
  type: TYPE_NORMAL
  zh: 导入后，在 *第 43* 行创建并确认了 `starmap` 对象。
- en: Displaying the results of `starmap` in *line 44*, we can see that an arbitrary
    number of arguments can be input, so `starmap(`*)* acts like `function(*args)`,
    whereas `map()` is more like `function(a, b)`
  id: totrans-161
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在 *第 44* 行显示 `starmap` 的结果，我们可以看到可以输入任意数量的参数，因此 `starmap(*)` 类似于 `function(*)`，而
    `map()` 更像 `function(a, b)`。
- en: 'The `takewhile(predicate, iterable)` method generates an iterator that returns
    all elements from `iterable` as long as `predicate` is `true`. In practice, `takewhile()`
    is the opposite of `dropwhile()`. Once the `predicate` becomes `False`, no further
    elements are processed:'
  id: totrans-162
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`takewhile(predicate, iterable)` 方法生成一个迭代器，只要 `predicate` 为 `true`，就返回 `iterable`
    中的所有元素。在实践中，`takewhile()` 是 `dropwhile()` 的反义词。一旦 `predicate` 变为 `False`，就不再处理进一步元素：'
- en: '![](img/f0090454-495a-4e04-bbb0-4c7e8493ae91.png)'
  id: totrans-163
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/f0090454-495a-4e04-bbb0-4c7e8493ae91.png)'
- en: '*Line 46* shows that elements within the iterable input are processed until
    the results of the processing are `false`; in this case, `6` is not less than
    `4`. At that point, no further processing is performed and the iterator is returned
    with what was successfully processed upto that point.'
  id: totrans-164
  prefs:
  - PREF_UL
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*第 46* 行显示，在可迭代输入中的元素被处理，直到处理结果为 `false`；在这种情况下，`6` 不小于 `4`。此时，不再进行进一步处理，并返回到那时成功处理的迭代器。'
- en: The  `tee(iterable, n=2)` method returns `n` independent iterators from a single
    iterable argument. In other words, you can create multiple iterators from a single
    interable input.
  id: totrans-165
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`tee(iterable, n=2)` 方法从单个可迭代参数返回 `n` 个独立的迭代器。换句话说，你可以从单个可迭代输入创建多个迭代器。'
- en: 'Once `tee()` has done its work, `iterable` should not be used elsewhere, otherwise
    it could be modified without the `tee()` output iterators being updated. In addition,
    the resulting iterators may require significant memory allocation; if one iterator
    uses most or all of the data prior to another iterator starting, it is quicker
    to use `list()` than `tee()`:'
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦`tee()`完成了其工作，`iterable`就不应该在其他地方使用，否则它可能会在没有更新`tee()`输出迭代器的情况下被修改。此外，生成的迭代器可能需要大量的内存分配；如果一个迭代器在另一个迭代器开始之前使用了大部分或全部数据，那么使用`list()`比使用`tee()`更快：
- en: '![](img/ca79bb8b-bf28-4482-ac51-3c0806cb5c44.png)'
  id: totrans-167
  prefs: []
  type: TYPE_IMG
  zh: '![](img/ca79bb8b-bf28-4482-ac51-3c0806cb5c44.png)'
- en: In this example, a simple string of characters is created in *line 48*.
  id: totrans-168
  prefs:
  - PREF_UL
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在这个例子中，在第*48*行创建了一个简单的字符字符串。
- en: Unpacking is performed in *line 49*. As we are using the default `n=2` for the
    resulting iterators, only two variables are required.
  id: totrans-169
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在第*49*行执行了解包操作。由于我们为生成的迭代器使用默认的`n=2`，因此只需要两个变量。
- en: The *lines 50* and *51* show that, after processing `tee()`*,* we now have two
    identical iterator objects.
  id: totrans-170
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 第*50*行和*51*行显示，在处理`tee()`之后，我们现在有两个相同的迭代器对象。
- en: 'The final itertool to cover is `zip_longest(*iterables, fillvalue=None)`. This
    makes an iterator that aggregates elements from each of the iterable input arguments;
    in short, merging two or more iterables into one. If the arguments are of uneven
    length, missing elements are filled in with the `fillvalue`. Iteration of this
    method continues until the longest iterable argument is empty. In the event that
    the longest argument could potentially be infinite, a wrapper should be used to
    limit the number of calls, such as `islice()` or `takewhile()`:'
  id: totrans-171
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后要介绍的是`zip_longest(*iterables, fillvalue=None)`。这个方法创建一个迭代器，它从每个可迭代输入参数中聚合元素；简而言之，将两个或多个可迭代合并为一个。如果参数长度不均匀，缺失的元素会用`fillvalue`填充。这个方法的迭代会一直持续到最长的可迭代参数为空。如果最长的参数可能是无限的，应该使用包装器来限制调用次数，例如`islice()`或`takewhile()`：
- en: '![](img/3a39e8aa-ac05-4b50-a4ba-ea1894317576.png)'
  id: totrans-172
  prefs: []
  type: TYPE_IMG
  zh: '![](img/3a39e8aa-ac05-4b50-a4ba-ea1894317576.png)'
- en: In this example, we have provided two inline string arguments to `zip_longest()`,
    and the filler is another string. Printing the results shows that argument `1`
    is merged with argument `2`, until no more characters are available in argument
    `2`. At that point, the `fillvalue` is provided as a substitute until argument
    `1` is empty.
  id: totrans-173
  prefs:
  - PREF_UL
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在这个例子中，我们向`zip_longest()`提供了两个内联字符串参数，填充值是另一个字符串。打印结果显示参数`1`与参数`2`合并，直到参数`2`中没有更多的字符可用。在那个点上，提供`fillvalue`作为替代，直到参数`1`为空。
- en: Using generator functions
  id: totrans-174
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用生成器函数
- en: Generators allow you to declare a function that operates like an iterator. This
    allows you to write a custom function that can be used in a `for` loop or an other
    iteration capacity. The key feature of a generator is that it yields a value,
    rather than using `return`*.*
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 生成器允许你声明一个像迭代器一样工作的函数。这允许你编写一个自定义函数，可以在`for`循环或其他迭代能力中使用。生成器的关键特性是它产生一个值，而不是使用`return`。
- en: When a generator function is called, it returns an iterator known as a generator.
    This generator controls the operation of the generator function. When the generator
    is called, the function proceeds like normal but, when the logic flow reaches
    the `yield` statement, processing is suspended while returning the first evaluation.
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 当调用生成器函数时，它返回一个称为生成器的迭代器。这个生成器控制生成器函数的操作。当生成器被调用时，函数像正常一样执行，但当逻辑流程达到`yield`语句时，处理会暂停并返回第一次评估的结果。
- en: During the suspension, the local state of the function is retained in memory;
    it's just like a normal function was paused in completing its processing. When
    the generator is resumed by calling it again, it continues as if nothing happened,
    returns the next evaluation value, and suspends again. This continues until all
    the values to be processed are completed, at which point a `StopIteration` exception
    is thrown.
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 在暂停期间，函数的局部状态被保留在内存中；就像一个正常函数在完成其处理时被暂停一样。当再次调用生成器以恢复它时，它继续就像什么都没发生一样，返回下一个评估值，然后再次暂停。这会一直持续到所有要处理的值都完成，此时会抛出一个`StopIteration`异常。
- en: How to do it...
  id: totrans-178
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 如何实现...
- en: Generators are incredibly simple to create. Define a function, but instead of
    using `return`, use the keyword `yield`*:*
  id: totrans-179
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 生成器函数的创建非常简单。定义一个函数，但不要使用`return`，而是使用关键字`yield`。
- en: '[PRE1]'
  id: totrans-180
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'Create an instance of the function. Don''t forget the argument:'
  id: totrans-181
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建函数的一个实例。别忘了参数：
- en: '[PRE2]'
  id: totrans-182
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'Call the instance as an argument to `next()`:'
  id: totrans-183
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将实例作为`next()`的参数调用：
- en: '[PRE3]'
  id: totrans-184
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: Continue until iteration stops.
  id: totrans-185
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 继续直到迭代停止。
- en: How it works...
  id: totrans-186
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: 'Here is an example of a generator in action:'
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: 这里是一个生成器在行动中的例子：
- en: '![](img/83aa60b3-667f-4f60-a219-bcf0b0caba59.png)'
  id: totrans-188
  prefs: []
  type: TYPE_IMG
  zh: '![](img/83aa60b3-667f-4f60-a219-bcf0b0caba59.png)'
- en: The *line 1* simply creates the function as provided previously.
  id: totrans-189
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*第1行*简单地创建了之前提供的函数。'
- en: The *line 2* calls the generator like a normal function, showing that generators
    can operate exactly like a regular function. You could capture the results in
    a `list` object if you wanted a permanent copy of the results.
  id: totrans-190
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*第2行*像调用常规函数一样调用生成器，表明生成器可以像常规函数一样操作。如果你想要结果的永久副本，可以将结果捕获在`list`对象中。'
- en: The *line 3* creates an instance of the generator.
  id: totrans-191
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*第3行*创建了一个生成器的实例。'
- en: The *lines 4*-*6* show how a generator is typically used. By calling the generator
    instance as the argument for `next()`, the generator processing is paused after
    each evaluation cycle. Rather than receiving all results at once, only one value
    is provided from the generator when called by `next()`. This is due to using `yield`
    rather than `return`*.*
  id: totrans-192
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*第4行*至*第6行*展示了生成器通常是如何使用的。通过将生成器实例作为`next()`的参数调用，生成器处理在每个评估周期后暂停。而不是一次性接收所有结果，当通过`next()`调用时，只从生成器提供单个值。这是由于使用了`yield`而不是`return`*.*'
- en: In *line 7*, there are no more values to be evaluated in the generator, so processing
    is cancelled and the expected `StopIteration` exception is returned instead.
  id: totrans-193
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在*第7行*，生成器中不再有要评估的值，因此处理被取消，并返回预期的`StopIteration`异常。
- en: As shown by this example, generators operate exactly like other iterator functions.
    They just let you write iterator operations without having to define iterator
    classes with the `__iter__` and `__next__` methods. However, one catch is that
    generators can only be used once; after a sequence is iterated through, it is
    no longer in memory. To iterate more than once, you have to call the generator
    again.
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: 如此例所示，生成器的工作方式与其它迭代函数完全一样。它们只是让你能够编写迭代操作，而无需定义具有`__iter__`和`__next__`方法的迭代器类。然而，一个要注意的问题是生成器只能使用一次；在遍历序列之后，它就不再在内存中了。要多次迭代，你必须再次调用生成器。
- en: There's more...
  id: totrans-195
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 还有更多...
- en: 'By default, generators provide lazy evaluation: they don''t perform a process
    action until explicitly called. This is a valuable trait when working with large
    datasets, such as processing millions of calculations. If you attempted to store
    all the results in memory at one time, that is, via a normal function call, you
    could run out of space.'
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: 默认情况下，生成器提供懒加载评估：它们不会在明确调用之前执行任何过程操作。当处理大型数据集时，例如处理数百万次计算，这是一个非常有价值的特性。如果你试图一次性将所有结果存储在内存中，即通过常规函数调用，你可能会耗尽空间。
- en: Another option is when you don't know if you actually need to use all the values
    returned. There is no need to perform a calculation if you won't use it, so you
    can reduce the memory footprint and improve performance.
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: 另一个选项是当你不确定你是否真的需要使用返回的所有值。如果你不会使用它，就没有必要进行计算，因此你可以减少内存占用并提高性能。
- en: Still another option is when you want to call another generator or access some
    other resource, but you want to control when that access occurs. If you don't
    need an immediate response, for example, you don't want to store the result in
    a temporary variable, then being able to run the generator at the desired time
    can help the design process.
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: 另一个选项是当你想要调用另一个生成器或访问其他资源，但你想控制访问发生的时间。如果你不需要立即响应，例如，你不想将结果存储在临时变量中，那么能够在期望的时间运行生成器可以帮助设计过程。
- en: One great place for generators is in replacing callback functions. Callback
    functions are called by something else, do their processing, and occasionally
    send a status report back to the caller. This has the inherent problems of full-processing,
    that is, everything is processed at one time and stored in memory for access.
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: 生成器的一个很好的用途是替换回调函数。回调函数由其他东西调用，执行它们的处理，并偶尔向调用者发送状态报告。这固有的问题是全处理，即所有内容一次性处理并存储在内存中以供访问。
- en: If a generator is used instead, the same processing occurs but there is no status
    report to the caller. The generator function simply yields when it wants to report.
    The caller gets the generator's result and deals with the reporting work as a
    simple `for` loop that wraps the generator call. If, for some reason, you still
    want to have the generator provide everything at once, you can simply wrap a generator
    call in `list`.
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: 如果使用生成器，将发生相同的处理，但没有状态报告给调用者。生成器函数在需要报告时简单地产生值。调用者获取生成器的结果，并将报告工作作为简单的 `for`
    循环处理，该循环包装了生成器调用。如果出于某种原因，你仍然希望生成器一次性提供所有内容，你可以简单地在一个 `list` 中包装生成器调用。
- en: Python uses both of these cases for different versions. In Python 2, `os.path.walk()`
    uses a callback function, whereas Python 3 has `os.walk()`, which uses a filesystem-walking
    generator.
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: Python 使用这两种情况的不同版本。在 Python 2 中，`os.path.walk()` 使用回调函数，而 Python 3 有 `os.walk()`，它使用文件系统遍历生成器。
- en: 'Finally, there is one last trick that can help with Python performance. Normally,
    list comprehensions are used to quickly iterate through a list, as in the following
    example:'
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，有一个最后的技巧可以帮助提高 Python 的性能。通常，列表推导式用于快速遍历列表，如下面的示例所示：
- en: '[PRE4]'
  id: totrans-203
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'A simple generator can be created in a similar fashion. Basically, you just
    replace the square brackets with parentheses:'
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: 可以以类似的方式创建一个简单的生成器。基本上，你只需要将方括号替换为圆括号：
- en: '[PRE5]'
  id: totrans-205
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'Once you have that, you can use the generator instance within a simple `for`
    loop:'
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦有了这个，你就可以在简单的 `for` 循环中使用生成器实例：
- en: '[PRE6]'
  id: totrans-207
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'Here is the process in use:'
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: 这是正在使用的过程：
- en: '![](img/475cddb1-9c6f-4827-937b-df4889e1c091.png)'
  id: totrans-209
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/475cddb1-9c6f-4827-937b-df4889e1c091.png)'
- en: The benefit of using a generator instead of a list comprehension is that intermediate
    memory storage is not required. The values are created on demand, as it were,
    so the entire list is not dumped to memory at one time. This can achieve significant
    speed increases and reduce memory usage, depending on the program.
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: 使用生成器而不是列表推导式的优点是无需中间内存存储。值是按需创建的，就像这样，所以整个列表不会一次性全部加载到内存中。这可以实现显著的速度提升并减少内存使用，具体取决于程序。
- en: Simulating multithreading with coroutines
  id: totrans-211
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用协程模拟多线程
- en: Where generators can generate data from a function via `yield`, they can also
    be used to accept data if they are used on the right-hand side of the `=` sign
    in a variable assignment. This creates a coroutine.
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
  zh: 在生成器可以通过 `yield` 从函数生成数据的地方，如果它们在变量赋值的右侧使用 `=` 符号，它们也可以接受数据。这创建了一个协程。
- en: A coroutine is a type of function that can suspend and resume execution, via
    `yield`*,* at predefined locations within its code. In addition to `yield()`,
    coroutines also have `send()` and `close()` functions for processing data. The `send()` function
    passes data to a coroutine (the *acceptance* part of the function) and `close()`
    terminates the coroutine (as there is no way for garbage collection to inherently
    close it for us).
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
  zh: 协程是一种函数类型，可以通过 `yield`* 在其代码中的预定义位置暂停和恢复执行。除了 `yield()` 之外，协程还有 `send()` 和 `close()`
    函数用于处理数据。`send()` 函数将数据传递给协程（函数的 *接受* 部分）和 `close()` 终止协程（因为没有方法让垃圾回收自动为我们关闭它）。
- en: Using the `asyncio` module allows coroutines to be used to write single-threaded,
    concurrent programs. As they are single-threaded, they still only perform one
    job but the concurrency simulates multithreading. More information about concurrency
    and parallel programming can be found in the next section, *When to use parallel
    processing.*
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
  zh: 使用 `asyncio` 模块允许协程被用来编写单线程的并发程序。由于它们是单线程的，它们仍然只执行一个任务，但并发模拟了多线程。关于并发和并行编程的更多信息可以在下一节中找到，*何时使用并行处理*。
- en: How to do it...
  id: totrans-215
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 如何做到这一点...
- en: 'Define the function:'
  id: totrans-216
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 定义函数：
- en: '[PRE7]'
  id: totrans-217
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'Create an instance:'
  id: totrans-218
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个实例：
- en: '[PRE8]'
  id: totrans-219
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'Use `next()` to process the function:'
  id: totrans-220
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用 `next()` 处理函数：
- en: '[PRE9]'
  id: totrans-221
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'Use `send()` to provide an input value to the function:'
  id: totrans-222
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用 `send()` 向函数提供一个输入值：
- en: '[PRE10]'
  id: totrans-223
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'This is what it looks like put together:'
  id: totrans-224
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 这就是组合在一起的样子：
- en: '![](img/aa0e8a58-8311-462a-9f86-7051f4161736.png)'
  id: totrans-225
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/aa0e8a58-8311-462a-9f86-7051f4161736.png)'
- en: 'To make life easier and avoid having to manually call `next()` every time,
    `coroutine_decorator.py` shows how a decorator can be made to handle the iteration
    for us:'
  id: totrans-226
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 为了使生活更轻松并避免每次都手动调用 `next()`，`coroutine_decorator.py` 展示了如何创建一个装饰器来为我们处理迭代：
- en: '[PRE11]'
  id: totrans-227
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: According to the official documentation ([https://docs.python.org/3/library/asyncio-task.html#coroutines](https://docs.python.org/3/library/asyncio-task.html#coroutines)),
    it is preferable to use `@asyncio.coroutine` to decorate generator-based coroutines.
    It isn't strictly enforced, but it enables compatibility with `async def` coroutines
    and also serves as documentation.
  id: totrans-228
  prefs: []
  type: TYPE_NORMAL
  zh: 根据官方文档（[https://docs.python.org/3/library/asyncio-task.html#coroutines](https://docs.python.org/3/library/asyncio-task.html#coroutines)），最好使用`@asyncio.coroutine`来装饰基于生成器的协程。这并不是强制性的，但它使得与`async
    def`协程兼容，同时也起到文档的作用。
- en: '`asyncio_concurrent.py`, from [https://docs.python.org/3/library/asyncio-task.html#example-chain-coroutines](https://docs.python.org/3/library/asyncio-task.html#example-chain-coroutines),
    shows how to use `asyncio` to perform concurrent processing:'
  id: totrans-229
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`asyncio_concurrent.py`，来自[https://docs.python.org/3/library/asyncio-task.html#example-chain-coroutines](https://docs.python.org/3/library/asyncio-task.html#example-chain-coroutines)，展示了如何使用`asyncio`进行并发处理：'
- en: '[PRE12]'
  id: totrans-230
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: The event loop is started (`get_event_loop()`) and calls `print_sum()`
  id: totrans-231
  prefs:
  - PREF_UL
  - PREF_UL
  type: TYPE_NORMAL
  zh: 事件循环被启动（`get_event_loop()`）并调用`print_sum()`
- en: The  `print_sum()` coroutine is suspended while it calls `compute()`
  id: totrans-232
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 当`print_sum()`协程调用`compute()`时，它被挂起
- en: The `compute()` coroutine starts but immediately goes to sleep for 1 second
  id: totrans-233
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`compute()`协程启动但立即进入休眠状态1秒'
- en: When `compute()` restarts, it finishes its computation and returns the result
  id: totrans-234
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 当`compute()`重新启动时，它完成其计算并返回结果
- en: The `print_sum()` coroutine receives the result and prints it
  id: totrans-235
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`print_sum()`协程接收结果并打印它'
- en: There are no more computations to perform so the `print_sum()` coroutine raises
    the `StopIteration` exception
  id: totrans-236
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 没有更多的计算要执行，因此`print_sum()`协程引发`StopIteration`异常
- en: The exception causes the event loop to terminate and the loop is closed
  id: totrans-237
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 该异常导致事件循环终止，循环被关闭
- en: 'Here is `asyncio_multi_jobs.py` ([https://docs.python.org/3/library/asyncio-task.html#example-parallel-execution-of-tasks](https://docs.python.org/3/library/asyncio-task.html#example-parallel-execution-of-tasks))
    that shows a better illustration of the concurrent execution of multiple jobs:'
  id: totrans-238
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 这里是`asyncio_multi_jobs.py`（[https://docs.python.org/3/library/asyncio-task.html#example-parallel-execution-of-tasks](https://docs.python.org/3/library/asyncio-task.html#example-parallel-execution-of-tasks)），它展示了多个作业并发执行的更好示例：
- en: '[PRE13]'
  id: totrans-239
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: In this example, three factorial coroutines are created. Because of the asynchronous
    nature of the code, they aren't necessarily started in order, nor are they processed
    and completed in order.
  id: totrans-240
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个例子中，创建了三个阶乘协程。由于代码的异步性质，它们不一定按顺序启动，也不一定按顺序处理和完成。
- en: 'Your results may vary, but here is an example of the output of this code:'
  id: totrans-241
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 你的结果可能会有所不同，但以下是此代码输出的一个示例：
- en: '![](img/c96c1ee5-def5-47a5-a25b-0d49a8dde3e4.png)'
  id: totrans-242
  prefs: []
  type: TYPE_IMG
  zh: '![](img/c96c1ee5-def5-47a5-a25b-0d49a8dde3e4.png)'
- en: As can be seen, the jobs were started in reverse order; if you look at the official
    documentation, they were started in order. Each task was completed at a different
    time so, while the results are in order, each individual task took a varying amount
    of time. This can also be seen when compared to the official documentation.
  id: totrans-243
  prefs: []
  type: TYPE_NORMAL
  zh: 如所见，工作是从相反的顺序开始的；如果你查看官方文档，它们是按顺序开始的。每个任务完成的时间不同，因此，虽然结果是有序的，但每个单独的任务所需的时间各不相同。这也可以与官方文档进行比较。
- en: There's more...
  id: totrans-244
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 还有更多...
- en: When working with asynchronous code, a developer has to carefully consider the
    libraries and modules being used. Any imported modules need to be non-blocking;
    that is, they can't stop code execution while waiting for something else to finish.
  id: totrans-245
  prefs: []
  type: TYPE_NORMAL
  zh: 当使用异步代码时，开发者必须仔细考虑所使用的库和模块。任何导入的模块都需要是非阻塞的；也就是说，它们不能在等待其他事情完成时停止代码执行。
- en: In addition, a coroutine schedule involving an event loop needs to be created
    to manually handle coroutine scheduling. While operating systems can handle multithreading
    and multiprocessing internally, coroutine scheduling (by its very nature) must
    be handled by the developer. Thus, while coroutines and asynchronous operations
    can be powerful and useful tools, they also take a lot of work to get right.
  id: totrans-246
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，还需要创建一个涉及事件循环的协程调度，以手动处理协程调度。虽然操作系统可以在内部处理多线程和多进程，但协程调度（由于其本质）必须由开发者处理。因此，虽然协程和异步操作可以是强大且有用的工具，但它们也需要大量的工作才能正确实现。
- en: When to use parallel processing
  id: totrans-247
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 何时使用并行处理
- en: Concurrency means stopping one task to work on another. With a coroutine, the
    function stops execution and waits for more input to continue. In this sense,
    you can have several operations pending at the same time; the computer simply
    switches to the next one when it is time.
  id: totrans-248
  prefs: []
  type: TYPE_NORMAL
  zh: 并发意味着停止一个任务去处理另一个任务。使用协程时，函数停止执行并等待更多输入以继续。从这个意义上说，您可以同时有多个操作挂起；当时间到了，计算机简单地切换到下一个操作。
- en: 'This is where multitasking in operating systems comes from: a single CPU can
    handle multiple jobs at the same time by switching between them. In simple terms,
    concurrency is when multiple threads are being processed during a given time period.
    In contrast, parallelism means the system runs two or more threads simultaneously;
    that is, multiple threads are processed at a given point in time. This can only
    occur when there is more than one CPU core available.'
  id: totrans-249
  prefs: []
  type: TYPE_NORMAL
  zh: 这就是操作系统中的多任务处理的来源：单个CPU可以通过在它们之间切换来同时处理多个任务。简单来说，并发是指在给定的时间段内处理多个线程。相比之下，并行性意味着系统同时运行两个或更多线程；也就是说，在给定的时间点处理多个线程。这只能在有多个CPU核心可用的情况下发生。
- en: The benefit of parallelizing code comes from doing more with less. In this case,
    it's doing more work with fewer CPU cycles. Before multi-core systems, the only
    real way to improve performance was to increase the clock speed on the computer,
    allowing the system to do more work in a given amount of time. As thermal limitations
    became a problem with higher CPU frequencies, manufacturers found that adding
    more cores and reducing the frequency could provide similar benefits without overheating
    the system and reducing energy usage, something vital in portable devices. Depending
    on the task, splitting a job into multiple, smaller jobs could actually be quicker
    on a multi-core device than increasing the clock speed.
  id: totrans-250
  prefs: []
  type: TYPE_NORMAL
  zh: 并行化代码的好处在于用更少的资源做更多的事情。在这种情况下，就是用更少的CPU周期完成更多的工作。在多核系统出现之前，提高性能的唯一真正方法是增加计算机的时钟速度，使得系统在给定的时间内能完成更多的工作。随着更高的CPU频率带来的热限制问题，制造商发现增加核心数量并降低频率可以在不过热系统并减少能耗的情况下提供类似的好处，这在便携式设备中至关重要。根据任务的不同，将一个任务分成多个较小的任务，在多核设备上实际上可能比增加时钟速度更快。
- en: The biggest problem with making parallel programs is figuring out when parallelism
    will help. Not all tasks need the boost, and sometimes you can actually make things
    slower if you try to use parallel programming. While there are certain types of
    problems than can be looked at and a determination made, in this author's experience,
    you sometimes just have to try it out and see what happens.
  id: totrans-251
  prefs: []
  type: TYPE_NORMAL
  zh: 制作并行程序的最大问题在于确定何时并行化会有帮助。并非所有任务都需要这种提升，有时如果你尝试使用并行编程，实际上可能会使事情变慢。虽然可以检查某些类型的问题并做出决定，但根据作者的经验，有时你只能尝试一下，看看会发生什么。
- en: How to do it...
  id: totrans-252
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 如何做到这一点...
- en: 'Rather than a traditional walk-through of how to code, this will be more of
    a flow-chart to determine which type of parallel processing paradigm to use, if
    any:'
  id: totrans-253
  prefs: []
  type: TYPE_NORMAL
  zh: 与传统的代码编写流程相比，这将是更多关于确定是否使用以及使用哪种类型的并行处理范例的流程图：
- en: How large is your dataset? If your dataset is small (based on your experience),
    then a single-threaded process may not hurt you too much.
  id: totrans-254
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 您的数据集有多大？如果您的数据集很小（根据您的经验），那么单线程进程可能不会对您造成太大的伤害。
- en: Can your data processing and logic flow be split into simultaneous operations?
    Frequently, the type of program and the data being worked on simply don't allow
    for any type of concurrency or parallel programming.
  id: totrans-255
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 您的数据处理和逻辑流程能否分成同时进行的操作？通常，程序类型和正在处理的数据类型不允许任何类型的并发或并行编程。
- en: Is your processing CPU-limited or I/O-limited? CPU-intensive applications are
    best met with multiprocessing whereas I/O-intensive applications are handled better
    with multithreading.
  id: totrans-256
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 您的处理是CPU受限还是I/O受限？CPU密集型应用程序最好使用多进程来解决，而I/O密集型应用程序则更适合使用多线程处理。
- en: Do you need to have a shared memory pool? In a shared memory pool, you have
    to make sure that each data request doesn't occur at the same time as a data write,
    that is, a race condition, so locking each data transaction is necessary. Non-shared
    memory requires the creation of communication calls between threads/processes
    if data transfer is required.
  id: totrans-257
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 您是否需要一个共享内存池？在共享内存池中，您必须确保每个数据请求不会与数据写入同时发生，即竞态条件，因此锁定每个数据事务是必要的。非共享内存需要创建线程/进程之间的通信调用，如果需要数据传输。
- en: Have you identified where the bottlenecks are? Before you design a parallel
    program, you have to find the troublespots within the process. While you can parallelize
    the whole program, you get a better return if you focus on optimizing the data
    bottlenecks and functions that do most of the work.
  id: totrans-258
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 你已经确定了瓶颈在哪里吗？在设计并行程序之前，你必须找到进程中的问题点。虽然你可以并行化整个程序，但如果你专注于优化数据瓶颈和做大部分工作的函数，你会得到更好的回报。
- en: There's more...
  id: totrans-259
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 还有更多...
- en: The previous steps listed aren't all-inclusive. Designing parallel programs
    takes a lot of practice, and you can find college courses that are nothing but
    parallel programming, such as [https://ocw.mit.edu/courses/mathematics/18-337j-parallel-computing-fall-2011/](https://ocw.mit.edu/courses/mathematics/18-337j-parallel-computing-fall-2011/).
  id: totrans-260
  prefs: []
  type: TYPE_NORMAL
  zh: 列出的前几步并不全面。设计并行程序需要大量的实践，你可以找到只有并行编程的大学课程，例如[https://ocw.mit.edu/courses/mathematics/18-337j-parallel-computing-fall-2011/](https://ocw.mit.edu/courses/mathematics/18-337j-parallel-computing-fall-2011/)。
- en: It also can't be overstated that you should take the time to determine whether
    the problem you're trying to answer can be parallelized. One example used in computer
    science is sorting algorithms. For example, if you have a group of numbers that
    need to be sorted smallest to largest, you could break the entire group into multiples
    of two, that is, compare two numbers to each other. Each of these subgroups could
    then be compared simultaneously. Then, you merge some of the groups together and
    perform another simultaneous comparison. Do this enough times and you eventually
    come up with the final, sorted answer.
  id: totrans-261
  prefs: []
  type: TYPE_NORMAL
  zh: 还必须强调的是，你应该花时间确定你试图解决的问题是否可以并行化。计算机科学中使用的例子之一是排序算法。例如，如果你有一组需要从小到大排序的数字，你可以将整个组分成两两一组，即比较两个数字。然后，这些子组可以同时进行比较。然后，你可以将一些组合并在一起，并执行另一个同时比较。这样做足够多次，你最终会得到最终的、排序的答案。
- en: If you think about it, parallel processing is similar to recursive programming,
    since you have to break down the problem into smaller chunks, or at least identify
    similar actions. The main goal is to find tasks that can be performed independently
    of each other, as well as tasks that need to exchange data. Independent tasks
    allow work to be distributed between independent workers, while data exchange
    tasks help define which tasks need to be put together in a single worker.
  id: totrans-262
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你仔细想想，并行处理与递归编程类似，因为你必须将问题分解成更小的部分，或者至少识别出相似的操作。主要目标是找到可以独立执行的任务，以及需要交换数据的任务。独立任务允许工作在独立工作者之间分配，而数据交换任务有助于定义哪些任务需要在单个工作者中组合在一起。
- en: If your program ends up slowing down system response when running, you might
    want to look at parallelizing it. Spinning off new threads or processes allows
    the system to remain responsive to user input while still performing your program's
    work.
  id: totrans-263
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你的程序在运行时导致系统响应变慢，你可能需要考虑并行化它。通过启动新的线程或进程，可以让系统在执行程序工作的同时，仍然对用户输入保持响应。
- en: Forking processes
  id: totrans-264
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 进程创建
- en: Process forking is the traditional method of parallelizing work, especially
    in *nix operating systems. When a program is forked, the OS simply makes a new
    copy of the original program, including its memory state, and proceeds to run
    the two versions of the program simultaneously. Naturally, the copied program
    can have its own forks, creating a hierarchy of the original, parent process,
    with numerous children and grandchildren copies. If the parent program is killed,
    the child processes can still operate normally.
  id: totrans-265
  prefs: []
  type: TYPE_NORMAL
  zh: 进程创建是并行化工作的传统方法，尤其是在*nix操作系统上。当一个程序被创建时，操作系统只是简单地创建原始程序的一个新副本，包括其内存状态，然后同时运行这两个版本的程序。自然地，这个副本程序可以有自己的创建，形成一个以原始、父进程为根的层次结构，有众多子进程和孙进程副本。如果父程序被杀死，子进程仍然可以正常操作。
- en: How to do it...
  id: totrans-266
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 如何实现...
- en: 'In Python, to fork a process, all you have to do is import the `os` module
    and invoke the `fork()` function. The following example creates a simple parent/child
    process forking program:'
  id: totrans-267
  prefs: []
  type: TYPE_NORMAL
  zh: 在Python中，要创建一个进程，你只需要导入`os`模块并调用`fork()`函数。以下示例创建了一个简单的父/子进程创建程序：
- en: 'Import the `os` module, necessary to access `fork()`:'
  id: totrans-268
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 导入必要的`os`模块以访问`fork()`：
- en: '[PRE14]'
  id: totrans-269
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'Define the child process:'
  id: totrans-270
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 定义子进程：
- en: '[PRE15]'
  id: totrans-271
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'Create the parent process:'
  id: totrans-272
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建父进程：
- en: '[PRE16]'
  id: totrans-273
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: How it works...
  id: totrans-274
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: The child process is very simple. All it does is return the process ID of the
    child. The `os._exit()` call is important as it ensures the child process is killed
    and is not a zombie when the parent is killed.
  id: totrans-275
  prefs: []
  type: TYPE_NORMAL
  zh: 子进程非常简单。它所做的只是返回子进程的进程ID。`os._exit()`调用很重要，因为它确保在父进程被杀死时，子进程被杀死并且不是僵尸进程。
- en: As the parent process will be forked to create new children, it is the `key`
    function. Only one parent process is created; all other processes will be children.
  id: totrans-276
  prefs: []
  type: TYPE_NORMAL
  zh: 由于父进程将被分叉以创建新的子进程，因此它是`关键`函数。只有一个父进程被创建；所有其他进程都将作为子进程。
- en: 'The following screenshot demonstrates one possible result; as process IDs are
    different for every system, your results will be different:'
  id: totrans-277
  prefs: []
  type: TYPE_NORMAL
  zh: 以下截图演示了一种可能的结果；由于每个系统的进程ID都不同，您的结果将不同：
- en: '![](img/900c9959-1282-41da-9f40-947462b6ff08.png)'
  id: totrans-278
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/900c9959-1282-41da-9f40-947462b6ff08.png)'
- en: 'As you can see from the output, the child processes may not be immediately
    created; the parent may have a chance to spawn several children before the child
    process is able to actually start functioning. Another point: explicitly killing
    the child process ensures that the child doesn''t return to the parent loop and
    spawn its own processes, which would generate grandchildren processes.'
  id: totrans-279
  prefs: []
  type: TYPE_NORMAL
  zh: 如您从输出中看到的，子进程可能不会立即创建；父进程在子进程真正开始运行之前可能有机会生成几个子进程。另一个要点：明确杀死子进程可以确保子进程不会返回父循环并生成自己的进程，这会产生孙进程。
- en: There's more...
  id: totrans-280
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 还有更多...
- en: The problem with using `os.fork()` is that it only reliably works on *nix OSes,
    including Macs. Windows uses a different forking model; unless you happen to run
    Cygwin (a Windows application that allows for *nix-like functionality), you'll
    have to rely on threads or the `multiprocessing` module.
  id: totrans-281
  prefs: []
  type: TYPE_NORMAL
  zh: 使用`os.fork()`的问题在于它只在*nix操作系统上可靠地工作，包括Mac。Windows使用不同的分叉模型；除非你恰好运行了Cygwin（一个允许*nix类似功能的Windows应用程序），否则你将不得不依赖于线程或`multiprocessing`模块。
- en: How to implement multithreading
  id: totrans-282
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 如何实现多线程
- en: 'Because forking isn''t fully cross-platform compatible, there are two primary
    workers used in parallel Python programming: threads and processes. Threads are
    typically the "go-to" parallel tool for many programmers. Simply put, threads
    are separate workers that function simultaneously to complete the larger job.
    One job can have multiple threads.'
  id: totrans-283
  prefs: []
  type: TYPE_NORMAL
  zh: 由于分叉不是完全跨平台兼容的，在并行Python编程中使用了两个主要的并行工作者：线程和进程。线程通常是许多程序员的“首选”并行工具。简单来说，线程是同时完成更大任务的独立工作者。一个任务可以有多个线程。
- en: 'A good example is a web browser: while the browser itself is a single process
    when viewed in Windows Task Manager or using the `ps` command in Linux, the browser
    can spawn many threads to accomplish tasks, such as going to a URL, rendering
    HTML, processing JavaScript, and so on. All those threads are working together
    to accomplish the mission of the browser process.'
  id: totrans-284
  prefs: []
  type: TYPE_NORMAL
  zh: 一个很好的例子是网页浏览器：当在Windows任务管理器中查看或使用Linux中的`ps`命令时，浏览器本身是一个单独的进程，但浏览器可以生成许多线程来完成任务，例如访问URL、渲染HTML、处理JavaScript等。所有这些线程都在共同努力完成浏览器进程的任务。
- en: Threads are sometimes called **lightweight processes** because they run in parallel
    like *nix forked processes, but they are actually generated by a single parent
    process. Threads are frequently used in graphical interfaces to wait for, and
    respond to, user interaction. They are also prime candidates for programs that
    can be designed into multiple, independent tasks; this makes them ideal for networking,
    where I/O operations are the bottleneck, rather than the CPU.
  id: totrans-285
  prefs: []
  type: TYPE_NORMAL
  zh: 线程有时被称为**轻量级进程**，因为它们像*nix分叉进程一样并行运行，但实际上它们是由单个父进程生成的。线程常用于图形界面中等待和响应用户交互。它们也是适合设计成多个独立任务的程序的首选；这使得它们非常适合网络，在网络上，I/O操作是瓶颈，而不是CPU。
- en: How to do it...
  id: totrans-286
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 如何实现...
- en: 'First, we will create `single_thread.py` to give us a benchmark for comparison.
    For this example, we will be contacting a number of websites and calculating the
    time it takes to open a connection to all of them:'
  id: totrans-287
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 首先，我们将创建`single_thread.py`来为我们提供一个基准进行比较。在这个例子中，我们将联系一些网站，并计算打开所有这些网站连接所需的时间：
- en: '[PRE17]'
  id: totrans-288
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: As we will be contacting websites, we need to import `urllib.request` to actually
    open the connection and `urllib.error` in case there is a problem reaching a website.
  id: totrans-289
  prefs:
  - PREF_UL
  - PREF_UL
  type: TYPE_NORMAL
  zh: 由于我们将要联系网站，我们需要导入`urllib.request`来实际打开连接，以及`urllib.error`以防无法连接到网站。
- en: To make a benchmark, we need to know how long it takes to run the function,
    so we import `time`*.*
  id: totrans-290
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 为了做一个基准测试，我们需要知道运行函数需要多长时间，因此我们需要导入`time`*.*
- en: When we create the function, the first thing we do is figure out the time the
    function started.
  id: totrans-291
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在创建函数时，我们首先确定函数开始的时间。
- en: Next, we create a list of URLs to access. Feel free to add to or modify this
    list.
  id: totrans-292
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 接下来，我们创建一个要访问的URL列表。您可以随意添加或修改此列表。
- en: In case there are any errors when accessing a website, we wrap the actual website
    request within a `try...except` block.
  id: totrans-293
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果在访问网站时出现任何错误，我们将实际的网站请求包裹在 `try...except` 块中。
- en: For each website in the list, we open a connection to the site. As we only care
    how long it takes to connect, we don't do anything with the `urlopen()` return
    object.
  id: totrans-294
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 对于列表中的每个网站，我们打开到该网站的连接。因为我们只关心连接所需的时间，所以我们不对 `urlopen()` 返回的对象做任何处理。
- en: If a website errors out, for example, 403 Forbidden, we simply ignore it and
    move on.
  id: totrans-295
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果网站出现错误，例如403禁止访问，我们简单地忽略它并继续。
- en: Finally, we calculate the total time it took for the function to run and return
    that value.
  id: totrans-296
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 最后，我们计算函数运行并返回所需的总时间。
- en: 'Because we are accessing websites, and connectivity can fluctuate, we will
    write `time_funct.py` that will calculate the average time to run the preceding
    function. This works best as a function included with the preceding example, but
    can be used separately if desired:'
  id: totrans-297
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 因为我们要访问网站，并且连接可能会波动，所以我们将编写 `time_funct.py` 来计算运行前面函数的平均时间。这最好作为前面示例中的函数使用，但如果需要也可以单独使用：
- en: '[PRE18]'
  id: totrans-298
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: We import the `statistics` library, as it provides basic math functions, such
    as calculating the average.
  id: totrans-299
  prefs:
  - PREF_UL
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们导入 `statistics` 库，因为它提供了基本的数学函数，例如计算平均值。
- en: An empty list is created to store the individual time calculations.
  id: totrans-300
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 创建一个空列表来存储单个时间计算。
- en: The averaging function is created. In this case, to allow it to be used for
    other situations, it accepts as arguments a function call and an integer.
  id: totrans-301
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 创建一个平均函数。在这种情况下，为了允许它在其他情况下使用，它接受一个函数调用和一个整数作为参数。
- en: The integer argument becomes the number of times to run the function argument.
  id: totrans-302
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 整数参数成为运行函数参数的次数。
- en: Finally, we calculate the average time and return that value.
  id: totrans-303
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 最后，我们计算平均时间并返回该值。
- en: 'To figure out the average, single-threaded time to access 10 URLs, we simply
    print the result of the `avg_time()` function:'
  id: totrans-304
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 为了找出访问10个URL的平均单线程时间，我们只需打印 `avg_time()` 函数的结果：
- en: '![](img/b9bc4839-c176-470e-865e-84b45897d5ad.png)'
  id: totrans-305
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/b9bc4839-c176-470e-865e-84b45897d5ad.png)'
- en: Now, let's compare it to `multi_thread_retrieval.py`. This is more complicated
    to write compared to the single-threaded application, and the example could probably
    we rewritten in a more concise fashion, but it suffices for our needs. The file
    itself is broken into three parts, below, to aid in explanation.
  id: totrans-306
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，让我们将其与 `multi_thread_retrieval.py` 进行比较。与单线程应用程序相比，编写这个程序更复杂，示例可能可以以更简洁的方式重写，但对我们来说已经足够了。文件本身被分成三部分，如下所示，以帮助解释。
- en: '[PRE19]'
  id: totrans-307
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: First, we need to import several modules. The two new ones are `threading` and
    `queue`, necessary when dealing with multiple threads.
  id: totrans-308
  prefs:
  - PREF_UL
  - PREF_UL
  type: TYPE_NORMAL
  zh: 首先，我们需要导入几个模块。其中两个新模块是 `threading` 和 `queue`，在处理多个线程时是必要的。
- en: We make a class for the object that will be receiving the URLs and actually
    performing the URL request. The class itself inherits from the `Thread` class,
    allowing it to inherit threading functionality.
  id: totrans-309
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们为接收URL并实际执行URL请求的对象创建了一个类。这个类本身继承自 `Thread` 类，允许它继承线程功能。
- en: The initialization method creates a new thread and fills a queue variable with
    input data.
  id: totrans-310
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 初始化方法创建一个新的线程并将输入数据填充到一个队列变量中。
- en: 'The `run` method looks at the queue variable and pulls the URL from it. As
    long as the URL is not `quit`, the program will attempt to reach the website.
    If an exception is generated when accessing the site, it is skipped, just like
    the single-threaded program:'
  id: totrans-311
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`run` 方法查看队列变量并从中拉取URL。只要URL不是 `quit`，程序将尝试访问网站。如果在访问网站时生成异常，它将被跳过，就像单线程程序一样：'
- en: '[PRE20]'
  id: totrans-312
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: Next, we define the function that will push the URLs to the receiver. The URL
    list from the single-threaded program is used again. To keep things unambiguous,
    the queue is renamed to `cue`, otherwise we run into problems with the `queue`
    module.
  id: totrans-313
  prefs:
  - PREF_UL
  - PREF_UL
  type: TYPE_NORMAL
  zh: 接下来，我们定义一个将URL推送到接收器的函数。单线程程序中的URL列表再次被使用。为了保持明确，我们将队列重命名为 `cue`，否则我们会在 `queue`
    模块中遇到问题。
- en: The cue is used to create a worker pool of four threads. This pool is available
    for job requests; as one worker finishes a task, it returns to the pool and awaits
    another task.
  id: totrans-314
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用队列创建一个包含四个线程的工作池。这个池可用于工作请求；当一个工作线程完成一个任务后，它将返回池中并等待另一个任务。
- en: 'We have the start time again, so we can calculate how long the task will take:'
  id: totrans-315
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们再次有了开始时间，因此我们可以计算任务将花费多长时间：
- en: '[PRE21]'
  id: totrans-316
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: Next, we have three `for` loops that take the URLs from the list and populate
    the cue. When the list is empty, the next URL provided is the word `quit`. The
    final loop joins all the workers together. Basically, the main thread is paused
    while the subthreads process their data. When they finish, they tell the main
    thread, which then continues.
  id: totrans-317
  prefs:
  - PREF_UL
  - PREF_UL
  type: TYPE_NORMAL
  zh: 接下来，我们有三个 `for` 循环，从列表中获取 URL 并填充队列。当列表为空时，提供的下一个 URL 是单词 `quit`。最后的循环将所有工作线程连接在一起。基本上，主线程在子线程处理数据时被暂停。当它们完成时，它们会通知主线程，然后主线程继续。
- en: The final function creates the worker pool. Depending on the integer provided
    to the pool manager, a number of threads are spawned and start working on a provided
    task. The threads are appended to an empty list and the complete list is returned
    to step `f` earlier.
  id: totrans-318
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 最后的函数创建工作池。根据提供给池管理器的整数，会启动一定数量的线程并开始执行提供的任务。线程被追加到一个空列表中，并将完整的列表返回到之前的步骤 `f`。
- en: 'Here are the results of several different thread counts:'
  id: totrans-319
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 这里是不同线程数量的结果：
- en: '![](img/9b65c5a4-91ac-4cee-8b48-5a22d71930f7.png)'
  id: totrans-320
  prefs: []
  type: TYPE_IMG
  zh: '![](img/9b65c5a4-91ac-4cee-8b48-5a22d71930f7.png)'
- en: 'The default number of threads (4) is about 3.5x faster than the average of
    10 single-threaded calls:'
  id: totrans-321
  prefs: []
  type: TYPE_NORMAL
  zh: 默认的线程数（4）比 10 个单线程调用的平均值快约 3.5 倍：
- en: Using 10 threads, the speed increase is nearly 6x faster.
  id: totrans-322
  prefs:
  - PREF_UL
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用 10 个线程，速度提升接近 6 倍。
- en: At 20 threads, we are reaching the point of diminished returns. In this case,
    the speed increase is only 7x faster. This makes sense, as there are only 10 URLs
    in the list.
  id: totrans-323
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 当有 20 个线程时，我们达到了收益递减的点。在这种情况下，速度提升仅为 7 倍。这是有道理的，因为列表中只有 10 个 URL。
- en: Just for fun, we see that using two threads yields a 2x speed increase. This
    again makes sense, as we have double the number of workers.
  id: totrans-324
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 为了好玩，我们发现使用两个线程可以带来 2 倍的速度提升。这同样是有道理的，因为我们有双倍的工人数量。
- en: There's more...
  id: totrans-325
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 还有更多...
- en: While multithreading has benefits, it's important to recognize when multithreading
    is advantageous and when it is a burden.
  id: totrans-326
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然多线程有好处，但重要的是要认识到在什么情况下多线程是有益的，在什么情况下它是一个负担。
- en: Advantages
  id: totrans-327
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 优点
- en: 'A number of advantages come from multithreading, which is why it is a very
    popular option for a lot of developers:'
  id: totrans-328
  prefs: []
  type: TYPE_NORMAL
  zh: 多线程带来了一些优势，这也是为什么它成为许多开发者非常受欢迎的选择的原因：
- en: When a process spawns new threads, the heavy lifting has already been done by
    the process. The new threads don't require copying an entire program like a forked
    program and the memory requirements are low, so there is little performance overhead.
    If you look at Task Manager or view threads in Linux, you'll see hundreds or possibly
    thousands of threads being used, yet your system is still responsive.
  id: totrans-329
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 当进程生成新线程时，繁重的工作已经由进程完成。新线程不需要像分叉程序那样复制整个程序，内存需求低，因此几乎没有性能开销。如果你查看任务管理器或在 Linux
    中查看线程，你会看到数百或甚至数千个线程正在使用，但你的系统仍然响应。
- en: Programming threads is relatively easy compared to dealing with actual processes.
  id: totrans-330
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 与处理实际进程相比，编程线程相对容易。
- en: Threads have a shared memory space they can use, controlled by the parent process.
    This memory space is how threads can communicate with each other and share data.
    In Python, this means that global namespaces, object passing, and program-wide
    components such as imported modules are all available to every thread from a given
    process.
  id: totrans-331
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 线程可以使用共享内存空间，由父进程控制。这个内存空间是线程之间如何相互通信和共享数据的方式。在 Python 中，这意味着全局命名空间、对象传递和程序范围内的组件（如导入的模块）对所有给定进程的每个线程都是可用的。
- en: Thread programming is portable between OSes. As mentioned, Windows doesn't directly
    support process forking, but every OS supports threads. Code it once, and it will
    run anywhere.
  id: totrans-332
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 线程编程在操作系统之间是可移植的。正如所提到的，Windows 不直接支持进程分叉，但每个操作系统都支持线程。编写一次代码，它就可以在任何地方运行。
- en: Good choice for I/O-limited applications, as application responsiveness is improved.
  id: totrans-333
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 对于 I/O 限制的应用程序来说是一个好的选择，因为应用程序的响应性得到了提高。
- en: Disadvantages
  id: totrans-334
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 缺点
- en: 'However, there are some disadvantages with multithreading. Some are inherent
    in the multithreading paradigm, and others (such as GIL), are particular to Python:'
  id: totrans-335
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，多线程也有一些缺点。一些是多线程范式的固有缺点，而其他（如 GIL）则是特定于 Python 的：
- en: Threads cannot directly start another program. They can only call functions
    or methods in parallel with the rest of the program that spawned them, that is,
    threads can only utilize and interact with the components of their parent but
    can't work with other programs.
  id: totrans-336
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 线程不能直接启动另一个程序。它们只能并行调用由它们产生的程序中的函数或方法，也就是说，线程只能利用和与其父进程的组件交互，但不能与其他程序一起工作。
- en: Threads have to contend with synchronization and queues to ensure operations
    don't block others. For example, there is only one `stdin`, `stdout`, and `stderr` available
    per program and all the threads for that program have to share those interfaces,
    so managing thread conflicts can become a problem.
  id: totrans-337
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 线程必须通过同步和队列来竞争，以确保操作不会阻塞其他操作。例如，每个程序只有一个`stdin`、`stdout`和`stderr`可用，并且该程序的所有线程都必须共享这些接口，因此管理线程冲突可能会成为一个问题。
- en: '**G****lobal interpreter lock** (**GIL**) is the bane of many thread programmers.
    Simply put, GIL prevents multiple threads from operating within the Python interpreter
    environment simultaneously. While the OS may have dozens or hundreds of threads,
    Python programs can only utilize the Python environment one at a time. When a
    Python thread wants to do work, it must lock down the interpreter until the work
    is over. Then, the next thread in line gains access to the interpreter and locks
    it in turn. In other words, you can have multithreading but you can''t have true,
    simultaneous operations. Because of this, threads can''t be split across multiple
    CPUs; you can only have multithreading within one CPU.'
  id: totrans-338
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**全局解释器锁**（**GIL**）是许多线程程序员的噩梦。简单来说，GIL阻止多个线程同时在Python解释器环境中运行。虽然操作系统可能有成百上千个线程，但Python程序一次只能利用Python环境。当一个Python线程想要执行工作，它必须锁定解释器直到工作完成。然后，下一个线程获得对解释器的访问并依次锁定。换句话说，你可以有多线程，但你不能有真正的、同时的操作。正因为如此，线程不能跨多个CPU分割；你只能在单个CPU内进行多线程。'
- en: Shared memory means a crashed/misbehaving thread can trash data and corrupt
    the parent process.
  id: totrans-339
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 共享内存意味着崩溃/行为不当的线程可能会破坏数据并损坏父进程。
- en: How to implement multiprocessing
  id: totrans-340
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 如何实现多进程
- en: Multiprocessing in Python involves starting separate processes, much like forking.
    This gets around the GIL and its effect on multiple threads, but you have to deal
    with the overhead of increased memory usage and the multiple instances of the
    Python interpreter that are spawned for all the processes. However, in multi-core
    systems, multiprocessing can take advantage of the different CPUs so you have
    true parallelism; more cores = more processing power.
  id: totrans-341
  prefs: []
  type: TYPE_NORMAL
  zh: Python中的多进程涉及启动独立的进程，这与分叉类似。这绕过了全局解释器锁（GIL）及其对多个线程的影响，但你必须处理增加的内存使用量和为所有进程产生的多个Python解释器实例的开销。然而，在多核系统中，多进程可以利用不同的CPU，从而实现真正的并行处理；更多的核心=更多的处理能力。
- en: As there isn't room to cover everything about parallel Python programming (there
    are entire books written on the subject), I'm going to finish this chapter by
    demonstrating how to automate multiprocessing using `Pool()`, which controls worker
    processes automatically. `Pool()` accepts a number of input arguments, probably
    the most important one being the number of processes. By default, `Pool()` uses
    all the available CPUs on your system. This is useful because, if your system
    is upgraded, your program will automatically use more processing power without
    having to be rewritten.
  id: totrans-342
  prefs: []
  type: TYPE_NORMAL
  zh: 由于没有足够的空间涵盖关于并行Python编程的所有内容（关于这个主题已经写出了整本书），我将通过演示如何使用`Pool()`来自动化多进程来结束这一章，`Pool()`可以自动控制工作进程。`Pool()`接受多个输入参数，其中最重要的可能是进程数。默认情况下，`Pool()`使用系统上所有可用的CPU。这很有用，因为如果你的系统升级了，你的程序将自动使用更多的处理能力，而无需重写。
- en: How to do it...
  id: totrans-343
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 如何做到这一点...
- en: 'Using `pool()` is the easiest way to work with multiprocessing, as you don''t
    have to think about manually spawning processes and controlling interaction between
    them. Obviously, this limits your programs somewhat, as you have to figure out
    how to write your programs to take advantage of `pool()`, whereas manual control
    gives you a little more leeway. `multi_process_retrieval.py` demonstrates how
    `pool()` can be used to allocate work:'
  id: totrans-344
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用`pool()`是与多进程一起工作的最简单方法，因为你不必手动生成进程并控制它们之间的交互。显然，这限制了你的程序，因为你必须弄清楚如何编写程序以利用`pool()`，而手动控制则给你更多的灵活性。`multi_process_retrieval.py`演示了如何使用`pool()`来分配工作：
- en: '[PRE22]'
  id: totrans-345
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: As before, we are going to access the same websites, so we need to import the
    `urllib` modules and `time`. We also need to import `Pool()` from the `multiprocessing`
    module.
  id: totrans-346
  prefs:
  - PREF_UL
  - PREF_UL
  type: TYPE_NORMAL
  zh: 和之前一样，我们将访问相同的网站，因此需要导入`urllib`模块和`time`。我们还需要从`multiprocessing`模块导入`Pool()`。
- en: Again, we capture the start time so we can calculate how long the retrieval
    takes.
  id: totrans-347
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 再次，我们记录开始时间，以便计算检索所需的时间。
- en: 'Like the multithreading example, we create a pool of workers; four in this
    case. In this instance, `multiprocessing.pool()` takes a bit less setup: assign
    an instance of `Pool()` and that''s it. No need to bother with a queue, at least
    with simple programs such as this one.'
  id: totrans-348
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 和多线程示例一样，我们创建了一个工人池；这次是四个。在这种情况下，`multiprocessing.pool()`需要更少的设置：分配一个`Pool()`实例就足够了。至少对于像这样的简单程序，不需要处理队列。
- en: We use a `try...except` block to spawn the pool workers, in case there is a
    problem accessing a website. In this example, we use `map()` to place each URL
    in the list with the `urlopen` process.
  id: totrans-349
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们使用`try...except`块来启动池中的工人，以防访问网站时出现问题。在这个例子中，我们使用`map()`将每个URL放入列表中，并使用`urlopen`进程。
- en: Close the pool of workers then join them so the main process is suspended until
    the rest of the processes are complete.
  id: totrans-350
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 关闭工人池，并将它们连接起来，这样主进程就会暂停，直到其他进程完成。
- en: Finally, print the time taken.
  id: totrans-351
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 最后，打印出所花费的时间。
- en: 'The following screenshot shows some sample results:'
  id: totrans-352
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 下面的截图显示了部分样本结果：
- en: '![](img/0e350067-3f7b-4f96-8e35-dba5367125d5.png)'
  id: totrans-353
  prefs: []
  type: TYPE_IMG
  zh: '![](img/0e350067-3f7b-4f96-8e35-dba5367125d5.png)'
- en: Using the default value we gave the pool (four workers), the result is about
    1 second. This is comparable to multithreading; while it could be ascribed to
    the fickleness of network connections, there is some overhead due to launching
    larger-weight processes rather than lightweight threads.
  id: totrans-354
  prefs:
  - PREF_UL
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用我们给池提供的默认值（四个工人），结果大约是1秒。这和多线程相似；虽然可以归因于网络连接的不稳定性，但启动较重的进程而不是轻量级的线程会有一些开销。
- en: Dropping the pool to 1 gives us a time of about 3 seconds. Again, this is comparable
    to the average time of 10 runs for a single-threaded application, which makes
    sense as this is exactly the same thing.
  id: totrans-355
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 将池减少到1个工人，所需时间大约为3秒。再次，这相当于单线程应用程序10次运行的平均时间，这是有道理的，因为这正是同一件事。
- en: Bumping the pool to two workers takes about half the time of a single one, as
    it should be.
  id: totrans-356
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 将池增加到两个工人，所需时间大约是单个工人的时间的一半，正如预期的那样。
- en: Using eight workers yields slightly more than half the time of four workers,
    showing that processing time decreases linearly the more CPUs you can throw at
    it.
  id: totrans-357
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用8名工人可以得到比4名工人多一半的时间，这表明处理时间随着可以投入的CPU数量的增加而线性减少。
- en: 'As this author''s computer has eight cores, eight workers is probably about
    the best we can expect in terms of performance. To confirm this, the following
    shows the results of throwing more workers in the pool:'
  id: totrans-358
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 由于作者的计算器有八个核心，所以使用8名工人可能是在性能方面我们能期望的最好的了。为了确认这一点，以下展示了向池中投入更多工人的结果：
- en: '![](img/88cadc8e-03cb-4261-b0eb-25613eb90bcd.png)'
  id: totrans-359
  prefs: []
  type: TYPE_IMG
  zh: '![](img/88cadc8e-03cb-4261-b0eb-25613eb90bcd.png)'
- en: With 10 workers (two more than the number of CPUs available), the speed is actually
    worse than using eight workers.
  id: totrans-360
  prefs:
  - PREF_UL
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用10名工人（比可用的CPU数量多两个），实际上速度比使用8名工人还要慢。
- en: However, with 20 workers, the program speed is 16% faster. Realistically, the
    difference in speed is due to network issues and not the speed of the computer.
    Again, with only eight cores, putting more workers in the pool doesn't help anything
    because only eight workers can perform tasks simultaneously.
  id: totrans-361
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 然而，使用20名工人，程序速度提高了16%。实际上，速度差异是由于网络问题，而不是计算机速度。再次，由于只有八个核心，将更多工人放入池中并没有帮助，因为只能同时执行八个工人的任务。
- en: There's more...
  id: totrans-362
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 还有更多...
- en: 'One thing to note about `multiprocessing.pool()`: if you don''t provide an
    integer argument to specify the number of workers in the pool, the program will
    default to all the CPUs available in your system. If you have a dual-core system,
    you''ll get two workers. Have a monster of a system with 48 cores, then you get
    48 workers.'
  id: totrans-363
  prefs: []
  type: TYPE_NORMAL
  zh: 关于`multiprocessing.pool()`需要注意的一点是：如果你没有提供一个整数参数来指定池中工人的数量，程序将默认使用系统中可用的所有CPU。如果你有一个双核系统，你会得到两个工人。如果你有一个拥有48个核心的怪物级系统，那么你会得到48个工人。
- en: When it comes to cores, if you have Intel CPUs with hyper-threading, each individual
    CPU counts as two when it comes to multiprocessing. So, if you plan on writing
    a lot of parallelized software, it may be better to spend the extra money and
    maximize the number of hyper-threaded CPUs you can get.
  id: totrans-364
  prefs: []
  type: TYPE_NORMAL
  zh: 当涉及到核心时，如果你有支持超线程的英特尔CPU，每个单独的CPU在多进程处理时都算作两个。所以，如果你计划编写大量的并行化软件，可能最好多花些钱，以最大化你能够获得的超线程CPU数量。
- en: The `map()` function is a function that applies another function over a sequence,
    typically a list. It takes a little getting used to (at least for me), but once
    you figure it out, it's a great shortcut too. To use single-threaded web retrieval
    code as an example, you could rewrite the `for` loop as `map(urllib.request.urlopen,
    urls)`. It's important to remember that the items you're passing to the function
    are in a sequence (list, tuple, dictionary, and so on), otherwise you'll get an
    error.
  id: totrans-365
  prefs: []
  type: TYPE_NORMAL
  zh: '`map()` 函数是一个将另一个函数应用于序列（通常是列表）的函数。它需要一点时间来习惯（至少对我来说是这样的），但一旦你弄明白了，它也是一个很好的快捷方式。以使用单线程网络检索代码为例，你可以将
    `for` 循环重写为 `map(urllib.request.urlopen, urls)`。重要的是要记住，你传递给函数的项目必须是一个序列（列表、元组、字典等），否则你会得到一个错误。'
- en: Combining `map()` with `Pool()` eliminates a lot of the manual templating you
    have to do otherwise. One thing to note, though, is that you'll probably want
    to adjust the number of processes created. While `Pool()` defaults to all the
    CPUs it finds, you can give it an integer argument, explicitly telling it how
    many processes to start, that is, more or less than the number of CPUs you actually
    have. To get maximum performance, you'll have to adjust your program until you
    get diminishing returns.
  id: totrans-366
  prefs: []
  type: TYPE_NORMAL
  zh: 将 `map()` 与 `Pool()` 结合使用可以消除你通常必须做的许多手动模板。不过，需要注意的是，你可能需要调整创建的进程数量。虽然 `Pool()`
    默认使用它找到的所有CPU，但你也可以给它一个整数参数，明确地告诉它要启动多少个进程，即多于或少于你实际拥有的CPU数量。为了获得最佳性能，你必须调整你的程序，直到你得到递减的回报。
- en: This is also important if your program is going to be running for a long time.
    You don't want to use all your processing power for the program if you're going
    to be running it on your main computer, otherwise it will make your computer unavailable.
    When first learning how to write parallel programs, this author's dual-core system
    was unusable for more than 20 minutes just testing to see what the performance
    difference was between multi- and single-processing.
  id: totrans-367
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你的程序将要长时间运行，这也是很重要的。如果你打算在你的主计算机上运行它，你不想用尽所有的处理能力，否则这会使你的计算机不可用。当刚开始学习如何编写并行程序时，这位作者的双核系统在测试多进程和单进程性能差异时，超过20分钟都无法使用。
- en: Working with Python's Math Module
  id: totrans-368
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用Python的数学模块
- en: 'In this chapter, we will cover Python''s `math` module and the various mathematical
    functions provided in it. We will also talk about math-related modules, including
    cryptography and statistics. Specifically, we will discuss the following topics:'
  id: totrans-369
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将介绍Python的 `math` 模块以及其中提供的各种数学函数。我们还将讨论与数学相关的模块，包括密码学和统计学。具体来说，我们将讨论以下主题：
- en: Using the math module's functions and constants
  id: totrans-370
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用数学模块的函数和常量
- en: Working with complex numbers
  id: totrans-371
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 处理复数
- en: Improving decimal numbers
  id: totrans-372
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 提高十进制数
- en: Increasing accuracy with fractions
  id: totrans-373
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用分数提高精度
- en: Working with random numbers
  id: totrans-374
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 处理随机数
- en: Using the secrets module
  id: totrans-375
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用 secrets 模块
- en: Implementing basic statistics
  id: totrans-376
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 实现基本统计
- en: Improving functionality with comath
  id: totrans-377
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用 comath 提高功能
- en: 'Python uses a hierarchy of abstract base classes to represent number-like classes.
    While the types defined by the abstract classes cannot be instantiated, they are
    used to create a numbers tower of subclasses: number -> complex -> real -> rational
    -> integral.'
  id: totrans-378
  prefs: []
  type: TYPE_NORMAL
  zh: Python使用一系列抽象基类来表示类似数字的类。虽然由抽象类定义的类型不能实例化，但它们被用来创建一个数字子类塔：number -> complex
    -> real -> rational -> integral。
- en: The reason for this is to allow functions that accept numbers as arguments to
    determine the properties of the arguments, thus allowing for backend functionality
    to be applied without user intervention. For example, slicing requires arguments
    to be integrals, whereas math module functions require real numbers as arguments.
    By ensuring these number classes are used, Python can provide for inherent functionality,
    for example, arithmetic operations, concatenation, and so on, as determined by
    the types used.
  id: totrans-379
  prefs: []
  type: TYPE_NORMAL
  zh: 原因是为了允许接受数字作为参数的函数确定参数的性质，从而允许在不进行用户干预的情况下应用后端功能。例如，切片需要参数为整数，而 math 模块函数需要实数作为参数。通过确保使用这些数字类，Python
    可以提供固有功能，例如算术运算、连接等，这些功能由使用的类型确定。
- en: Using the math module's functions and constants
  id: totrans-380
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用 math 模块中的函数和常量
- en: Python's `math` module is built in; therefore, it is always available for import.
    The mathematical functions contained within it are defined by the C standard,
    so if something doesn't work, blame the C developers.
  id: totrans-381
  prefs: []
  type: TYPE_NORMAL
  zh: Python 的 `math` 模块是内置的；因此，它总是可用于导入。它包含的数学函数由 C 标准定义，所以如果有什么问题，请责怪 C 开发者。
- en: Complex numbers are handled by a separate module (`cmath`), so the math module
    can only be used with integers and floating point numbers. This was done on purpose,
    as dealing with complex numbers requires more effort than most people need for
    general functions. Unless otherwise indicated, all math arguments can be integers
    or floats.
  id: totrans-382
  prefs: []
  type: TYPE_NORMAL
  zh: 复数由一个单独的模块 (`cmath`) 处理，因此 math 模块只能用于整数和浮点数。这是故意为之的，因为处理复数比大多数人需要的通用函数要复杂得多。除非另有说明，所有数学参数都可以是整数或浮点数。
- en: How to do it...
  id: totrans-383
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 如何做到这一点...
- en: 'The `ceil(x)` function returns the smallest integer `>= x`. Normal mathematical
    rounding is not used, so `12.3` will be rounded up to `13`, rather than rounding
    up starting at `12.5`; any value greater than `x.0` will be rounded up to the
    next value, as shown in the following screenshot:'
  id: totrans-384
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`ceil(x)` 函数返回大于等于 `x` 的最小整数。不使用常规的数学舍入，因此 `12.3` 将被舍入到 `13`，而不是从 `12.5` 开始向上舍入；任何大于
    `x.0` 的值都将向上舍入到下一个值，如下面的截图所示：'
- en: '![](img/efda8ea8-66ce-4652-90a3-3632f87236f1.png)'
  id: totrans-385
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/efda8ea8-66ce-4652-90a3-3632f87236f1.png)'
- en: 'The `copysign(x, y)` function returns a float value with an absolute value
    of `x` but with the sign of `y`. If the OS supports signed zeros, `copysign(1.0,
    -0.0)` gives the value `-1.0`, as shown in the following screenshot:'
  id: totrans-386
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`copysign(x, y)` 函数返回一个具有 `x` 的绝对值但具有 `y` 符号的浮点值。如果操作系统支持有符号的零，则 `copysign(1.0,
    -0.0)` 将给出 `-1.0` 的值，如下面的截图所示：'
- en: '![](img/09b0fe5d-eb44-4565-956c-b0d637858924.png)'
  id: totrans-387
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/09b0fe5d-eb44-4565-956c-b0d637858924.png)'
- en: 'The  `fabs(x)` function returns the absolute value of an argument, effectively
    stripping the sign from the argument:'
  id: totrans-388
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`fabs(x)` 函数返回一个参数的绝对值，实际上是从参数中移除了符号：'
- en: '![](img/fea0b7e3-fd77-4e01-81fd-8c97d9cb9a65.png)'
  id: totrans-389
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/fea0b7e3-fd77-4e01-81fd-8c97d9cb9a65.png)'
- en: 'The  `factorial(x)` function returns the factorial of `x`; if the argument
    is not integral or is negative, an error is generated:'
  id: totrans-390
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`factorial(x)` 函数返回 `x` 的阶乘；如果参数不是整数或为负数，将生成错误：'
- en: '![](img/1361186f-1c8c-4d9a-ae6f-a64822363294.png)'
  id: totrans-391
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/1361186f-1c8c-4d9a-ae6f-a64822363294.png)'
- en: 'The  `floor(x)` function returns the largest integer `<= x`. Like `ceil`, normal
    rounding is ignored; in this case, floating point values are truncated, converting
    them into integers:'
  id: totrans-392
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`floor(x)` 函数返回小于等于 `x` 的最大整数。与 `ceil` 类似，常规舍入被忽略；在这种情况下，浮点值被截断，转换为整数：'
- en: '![](img/b83a2e32-c096-4afa-b8cb-003863c2813a.png)'
  id: totrans-393
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/b83a2e32-c096-4afa-b8cb-003863c2813a.png)'
- en: 'The `fmod(x, y)` function returns the modulus of the two arguments. This is
    defined by the operating system''s C library, so results may vary depending on
    the platform. It differs from the normal `x % y` operation in that `fmod` returns
    a result with the same sign as `x` and is mathematically precise for float types;
    the normal modulus returns with the sign from `y` and can produce rounding errors.
    Hence, `fmod` should be used for float types while normal modulus should be used
    for integers:'
  id: totrans-394
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`fmod(x, y)` 函数返回两个参数的模数。这是由操作系统的 C 库定义的，因此结果可能因平台而异。它与正常的 `x % y` 操作不同，因为
    `fmod` 返回一个与 `x` 具有相同符号的结果，并且对于浮点类型在数学上是精确的；正常的模数返回一个具有 `y` 符号的结果，可能会产生舍入错误。因此，对于浮点类型应使用
    `fmod`，而对于整数应使用正常的模数：'
- en: '![](img/5effd3bd-6101-4d50-a5a6-ec4d41bc1ff0.png)'
  id: totrans-395
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/5effd3bd-6101-4d50-a5a6-ec4d41bc1ff0.png)'
- en: Here, *line 24* shows that `fmod` can provide the correct value for large exponent
    values, including the sign. The *line 25* shows the results of normal modulus
    operation, which rounds to the incorrect value of zero.
  id: totrans-396
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，*第 24 行* 显示 `fmod` 可以提供包括符号在内的大指数值的正确值。*第 25 行* 显示了正常模运算的结果，它四舍五入到错误为零的值。
- en: 'The `frexp(x)` function returns the mantissa (the decimal part of a number)
    [`m`] and exponent [`e`] of `x`. `m` is a float and `e` is an integer such that
    `m * 2**e = x`. This function is commonly used to see the internal representation
    of a float value in a portable manner:'
  id: totrans-397
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`frexp(x)` 函数返回 `x` 的尾数（数字的小数部分）[`m`] 和指数 [`e`]。`m` 是一个浮点数，`e` 是一个整数，使得 `m
    * 2**e = x`。此函数通常用于以可移植的方式查看浮点值的内部表示：'
- en: '![](img/bbcc3981-4dba-4b33-bc69-4934459402ba.png)'
  id: totrans-398
  prefs: []
  type: TYPE_IMG
  zh: '![](img/bbcc3981-4dba-4b33-bc69-4934459402ba.png)'
- en: 'The `fsum(iterable)` function returns a floating point sum of values from an
    iterable. This avoids precision issues found in the default `sum()` function by
    tracking intermediate partial sums, though the accuracy depends on the operating
    system, as the backend C library can cause rounding errors:'
  id: totrans-399
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`fsum(iterable)` 函数返回一个可迭代对象中值的浮点数总和。通过跟踪中间部分总和来避免默认 `sum()` 函数中发现的精度问题，尽管准确性取决于操作系统，因为后端
    C 库可能会引起舍入错误：'
- en: '![](img/896abef1-3823-4bc7-bbb0-d57ced978229.png)'
  id: totrans-400
  prefs: []
  type: TYPE_IMG
  zh: '![](img/896abef1-3823-4bc7-bbb0-d57ced978229.png)'
- en: 'The `gcd(a, b)` function returns the greatest common divisor of two integer
    arguments:'
  id: totrans-401
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`gcd(a, b)` 函数返回两个整数参数的最大公约数：'
- en: '![](img/01a347de-dd59-4a03-8d64-6c2edc72053a.png)'
  id: totrans-402
  prefs: []
  type: TYPE_IMG
  zh: '![](img/01a347de-dd59-4a03-8d64-6c2edc72053a.png)'
- en: The `isclose(a, b, *, rel_tol=1e-09, abs_tol=0.0)` function returns `True` if
    `a` and `b` are close to each other in value and returns `False` if not. The determination
    of *close enough* comes from the relative and absolute tolerances.
  id: totrans-403
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`isclose(a, b, *, rel_tol=1e-09, abs_tol=0.0)` 函数如果 `a` 和 `b` 在数值上彼此接近则返回 `True`，如果不接近则返回
    `False`。*足够接近* 的确定来自相对和绝对容差。'
- en: Relative tolerance (`rel_tol`) is the maximum difference allowed between the
    arguments, relative to the larger absolute value of `a` or `b`. The default value
    ensures that the two argument values are the same to nine decimal places.
  id: totrans-404
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 相对容差 (`rel_tol`) 是允许的参数之间的最大差异，相对于 `a` 或 `b` 的较大绝对值。默认值确保两个参数值在九位小数处相同。
- en: 'Absolute tolerance (`abs_tol`) is the minimum allowed difference; it is particularly
    useful when comparing values close to zero:'
  id: totrans-405
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 绝对容差 (`abs_tol`) 是允许的最小差异；它在比较接近零的值时特别有用：
- en: '![](img/7a9b55d8-daa5-40e8-bf6b-b1996f44c6c6.png)'
  id: totrans-406
  prefs: []
  type: TYPE_IMG
  zh: '![](img/7a9b55d8-daa5-40e8-bf6b-b1996f44c6c6.png)'
- en: The *line 44* is just a simple check that compares the exact same values.
  id: totrans-407
  prefs:
  - PREF_UL
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*第 44 行* 只是一个简单的检查，它比较了完全相同的值。'
- en: The *line 45* rounds the first argument to the eighth decimal place and compares
    it using default values.
  id: totrans-408
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*第 45 行* 将第一个参数四舍五入到第八位小数，并使用默认值进行比较。'
- en: The *line 46* compares values at two decimal places. Using the default values,
    they are not close in value, even though they differ by only 1/100.
  id: totrans-409
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*第 46 行* 在两位小数处比较值。使用默认值，它们的值并不接近，尽管它们只相差 1/100。'
- en: The *line 47* uses the same values as *line 46*, but changes the relative tolerance
    to 5%. With this change, they are considered close to each other.
  id: totrans-410
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*第 47 行* 使用与 *第 46 行* 相同的值，但将相对容差更改为 5%。这个变化使得它们被认为是彼此接近的。'
- en: The *line 48* does a similar thing, except it is looking at values close to
    zero, so absolute tolerance is changed from 0% different to 5%.
  id: totrans-411
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*第 48 行* 做了类似的事情，但它是在查看接近零的值，因此绝对容差从 0% 不同更改为 5%。'
- en: 'The `isfinite(x)` function returns `True` if *`x`* is a finite number, that
    is, not `inf` or `NaN`; it returns `False` only if the argument is infinite or
    not a number. The number 0.0 is considered a finite number:'
  id: totrans-412
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`isfinite(x)` 函数如果 *`x`* 是有限数，即不是 `inf` 或 `NaN`，则返回 `True`；只有当参数是无限或不是数字时才返回
    `False`。数字 0.0 被认为是有限数：'
- en: '![](img/773785fe-efef-467e-b18d-9d4be913a46b.png)'
  id: totrans-413
  prefs: []
  type: TYPE_IMG
  zh: '![](img/773785fe-efef-467e-b18d-9d4be913a46b.png)'
- en: 'The `isinf(x)` function returns `True` if the argument is `±∞`;  it returns
    `False` for any other value:'
  id: totrans-414
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`isinf(x)` 函数如果参数是 `±∞` 则返回 `True`；对于任何其他值返回 `False`：'
- en: '![](img/81210a58-75a7-42ba-a355-e65109e60bc2.png)'
  id: totrans-415
  prefs: []
  type: TYPE_IMG
  zh: '![](img/81210a58-75a7-42ba-a355-e65109e60bc2.png)'
- en: 'The `isnan(x)` function returns `True` if argument is `NaN` (not a number),
    and `False` otherwise:'
  id: totrans-416
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`isnan(x)` 函数如果参数是 `NaN`（非数字）则返回 `True`，否则返回 `False`：'
- en: '![](img/64f507d8-8108-4900-b70c-dd1a4119e67e.png)'
  id: totrans-417
  prefs: []
  type: TYPE_IMG
  zh: '![](img/64f507d8-8108-4900-b70c-dd1a4119e67e.png)'
- en: 'The `ldexp(x, i)` function is the inverse of `frexp()` and returns `x * 2^i`:'
  id: totrans-418
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`ldexp(x, i)` 函数是 `frexp()` 的逆函数，返回 `x * 2^i`：'
- en: '![](img/e95df07c-bedd-4441-95dd-e59d53bce123.png)'
  id: totrans-419
  prefs: []
  type: TYPE_IMG
  zh: '![](img/e95df07c-bedd-4441-95dd-e59d53bce123.png)'
- en: The preceding screenshot uses the results of the previous `frexp()` screenshot,
    demonstrating that the process is reversed to find the original floating point
    value.
  id: totrans-420
  prefs: []
  type: TYPE_NORMAL
  zh: 前一个截图使用了之前的 `frexp()` 截图的结果，展示了如何反向操作以找到原始浮点值。
- en: 'The  `modf(x)` function returns the integer and fractional parts of the argument;
    both returned values are floats with the sign of the argument:'
  id: totrans-421
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`modf(x)` 函数返回参数的整数部分和小数部分；两个返回值都是带有参数符号的浮点数：'
- en: '![](img/3558cf99-2f71-4b25-8753-71b5f15f3a24.png)'
  id: totrans-422
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/3558cf99-2f71-4b25-8753-71b5f15f3a24.png)'
- en: Notice that the fractional parts have rounding errors. Limiting the results
    to the minimum-needed precision may help alleviate this for display, but computations
    using the raw values may have significant errors propagated through the calculations.
  id: totrans-423
  prefs: []
  type: TYPE_NORMAL
  zh: 注意到小数部分有舍入误差。将结果限制在所需的最小精度可能有助于减轻显示时的这个问题，但使用原始值进行计算可能会导致计算过程中出现显著的误差传播。
- en: 'The `trunc(x)` function returns the truncated integral part of a real number,
    that is, it converts a float to an integer:'
  id: totrans-424
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`trunc(x)` 函数返回实数的截断整数部分，即它将浮点数转换为整数：'
- en: '![](img/24f44147-f5d7-48f2-bf40-7c90d058e4da.png)'
  id: totrans-425
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/24f44147-f5d7-48f2-bf40-7c90d058e4da.png)'
- en: 'The `exp(x)` function returns `e^x`, where `e` is the natural log:'
  id: totrans-426
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`exp(x)` 函数返回 `e^x`，其中 `e` 是自然对数：'
- en: '![](img/59276551-64fa-4ab1-b8de-c3164bf2a2b1.png)'
  id: totrans-427
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/59276551-64fa-4ab1-b8de-c3164bf2a2b1.png)'
- en: 'The `expm1(x)` function returns `e^x - 1`. This is primarily for small values
    of `x`, as manual calculation can cause a loss in precision. Using `expm1()` maintains
    the precision without rounding errors:'
  id: totrans-428
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`expm1(x)` 函数返回 `e^x - 1`。这主要用于 `x` 的较小值，因为手动计算可能会导致精度损失。使用 `expm1()` 可以保持精度，而不会出现舍入误差：'
- en: '![](img/9a5cbd83-440a-4c58-9b61-28cb4953f620.png)'
  id: totrans-429
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/9a5cbd83-440a-4c58-9b61-28cb4953f620.png)'
- en: When the exponent is `-9`, that is, `0.000000001`, significant rounding errors
    occur when manually creating the formula `e^x - 1`. Using `expm1`, full precision
    is maintained.
  id: totrans-430
  prefs: []
  type: TYPE_NORMAL
  zh: 当指数为 `-9`，即 `0.000000001` 时，手动创建公式 `e^x - 1` 会出现显著的舍入误差。使用 `expm1` 可以保持完全精度。
- en: 'The `log(x[, base])` function returns the natural log of `x` when provided
    one argument; two arguments provides the log of `x` to a given base:'
  id: totrans-431
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`log(x[, base])` 函数在提供一个参数时返回 `x` 的自然对数；提供两个参数时返回 `x` 到给定底数的对数：'
- en: '![](img/dfd51747-e673-497b-9979-5ae7e6e16fc1.png)'
  id: totrans-432
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/dfd51747-e673-497b-9979-5ae7e6e16fc1.png)'
- en: 'The  `log1p(x)` function returns the base `-e` log of `1 + x` . The result
    is calculated to maximize accuracy when `x` is near zero:'
  id: totrans-433
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`log1p(x)` 函数返回 `1 + x` 的以 `-e` 为底的对数。当 `x` 接近零时，结果计算以最大化精度：'
- en: '![](img/63463908-83c1-440d-97a9-1a8c34b96443.png)'
  id: totrans-434
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/63463908-83c1-440d-97a9-1a8c34b96443.png)'
- en: 'The `log2(x)` function returns the base `-2` log of `x`. This is more accurate
    than using `log(x, 2)`:'
  id: totrans-435
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`log2(x)` 函数返回 `x` 的以 `-2` 为底的对数。这比使用 `log(x, 2)` 更准确：'
- en: '![](img/d9444b88-076d-4ef1-a996-185c096356b1.png)'
  id: totrans-436
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/d9444b88-076d-4ef1-a996-185c096356b1.png)'
- en: As shown in this screenshot, the accuracy of `log2` doesn't really become a
    factor until the number of decimal places for the argument exceeds 30.
  id: totrans-437
  prefs: []
  type: TYPE_NORMAL
  zh: 如此截图所示，当参数的小数位数超过30时，`log2` 的精度才真正成为一个因素。
- en: 'The `log10(x)` function returns the base `-10` log of `x`. Like `log2`, it
    is generally more accurate than `log(x, 10)`:'
  id: totrans-438
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`log10(x)` 函数返回 `x` 的以10为底的对数。像 `log2` 一样，它通常比 `log(x, 10)` 更准确：'
- en: '![](img/2d42957c-de41-4417-989d-e23d7d3ac1de.png)'
  id: totrans-439
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/2d42957c-de41-4417-989d-e23d7d3ac1de.png)'
- en: In this case, the example shows accuracy differs when arguments are greater
    than 40 decimal places. Of course, individual results will differ depending on
    the use case, so it's probably best to use the functions provided by the module.
  id: totrans-440
  prefs: []
  type: TYPE_NORMAL
  zh: 在这种情况下，示例表明当参数超过40位小数时，精度会有所不同。当然，具体结果会根据使用情况而有所不同，因此最好使用模块提供的函数。
- en: 'The `pow(x, y)` function returns `x^y`. The `math.pow()` function converts
    arguments to float types; to calculate exact integer values, use the built-in
    `pow()` function or the `**` operator:'
  id: totrans-441
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`pow(x, y)` 函数返回 `x^y`。`math.pow()` 函数将参数转换为浮点类型；要计算精确的整数值，请使用内置的 `pow()` 函数或
    `**` 运算符：'
- en: '![](img/3a5d7f98-5e78-4c68-a6ea-0962568d341c.png)'
  id: totrans-442
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/3a5d7f98-5e78-4c68-a6ea-0962568d341c.png)'
- en: The *lines 116* and* line 117* compare the output when using the built-in `pow`
    versus `math.pow`.
  id: totrans-443
  prefs:
  - PREF_UL
  - PREF_UL
  type: TYPE_NORMAL
  zh: 第116行和第117行比较了使用内置的 `pow` 与 `math.pow` 的输出：
- en: The *line 119* and *line 120* show a discrepancy in the underlying library.
    When either argument is zero or `NaN`, the result is `1.0`, even if an error would
    be expected. While Python attempts to follow the C99 standards as much as possible,
    there are limits, and this is one of them.
  id: totrans-444
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*第 119 行* 和 *第 120 行* 显示了底层库中的差异。当任一参数为零或 `NaN` 时，结果为 `1.0`，即使预期会出现错误。虽然 Python
    尽可能遵循 C99 标准，但存在限制，这是其中之一。'
- en: 'The `sqrt(x)` function returns the `√x`:'
  id: totrans-445
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`sqrt(x)` 函数返回 `√x`：'
- en: '![](img/3dab7c7f-1873-40bd-a2c7-63707e09ff2a.png)'
  id: totrans-446
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/3dab7c7f-1873-40bd-a2c7-63707e09ff2a.png)'
- en: As shown in *line 123*, taking the root of a negative number yields an error,
    as expected. To deal with square roots of negative numbers, you have to use the
    `cmath` module.
  id: totrans-447
  prefs: []
  type: TYPE_NORMAL
  zh: 如 *第 123 行* 所示，取负数的根会产生错误，这是预期的。要处理负数的平方根，必须使用 `cmath` 模块。
- en: 'The `acos(x)` function returns the arc cosine of `x`, in radians:'
  id: totrans-448
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`acos(x)` 函数返回 `x` 的反余弦值，以弧度为单位：'
- en: '![](img/e986e666-80d6-4aa5-a45a-ecfd68ea2976.png)'
  id: totrans-449
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/e986e666-80d6-4aa5-a45a-ecfd68ea2976.png)'
- en: As expected, an argument `>1` will return an error, since when converted from
    radians to decimals, values are always less than one.
  id: totrans-450
  prefs: []
  type: TYPE_NORMAL
  zh: 如预期，参数 `>1` 将返回错误，因为当从弧度转换为十进制时，值总是小于一。
- en: 'The `asin(x)` function returns the arc sign of `x`, in radians:'
  id: totrans-451
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`asin(x)` 函数返回 `x` 的反正弦值，以弧度为单位：'
- en: '![](img/72d7bc1f-c759-49e0-8e2b-3ab1ac3efff2.png)'
  id: totrans-452
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/72d7bc1f-c759-49e0-8e2b-3ab1ac3efff2.png)'
- en: Again, values `>1` result in errors, so ensure you convert your argument to
    the correct radian value first.
  id: totrans-453
  prefs: []
  type: TYPE_NORMAL
  zh: 再次强调，值 `>1` 会导致错误，因此请确保首先将您的参数转换为正确的弧度值。
- en: 'The `atan(x)` function returns the arc tangent of `x`, in radians:'
  id: totrans-454
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`atan(x)` 函数返回 `x` 的反正切值，以弧度为单位：'
- en: '![](img/955848b2-f2f4-46b6-9d2a-e8ce9c6ab33a.png)'
  id: totrans-455
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/955848b2-f2f4-46b6-9d2a-e8ce9c6ab33a.png)'
- en: 'The `atan2(y, x)` returns the result of `atan(y / x)`, in radians and between
    the values of `-π` to  `π` . The vector from origin to `(x,y)` makes the angle
    in the first quadrant, that is, the positive *X *axis. This means that `atan2`
    can compute the correct quadrant for the angle since the signs for both arguments
    are known:'
  id: totrans-456
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`atan2(y, x)` 函数返回 `atan(y / x)` 的结果，以弧度为单位，介于 `-π` 到 `π` 之间。从原点到 `(x,y)` 的向量形成第一象限的角度，即正
    *X* 轴。这意味着 `atan2` 可以计算角度的正确象限，因为已知两个参数的符号：'
- en: '![](img/adb2003a-ced1-442a-ae92-3097702f3a37.png)'
  id: totrans-457
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/adb2003a-ced1-442a-ae92-3097702f3a37.png)'
- en: 'The `hypot(x, y)` returns the hypotenuse of a triangle with sides of length
    `x` and `y`*.* Basically, this is a shortcut of the Pythagorean theorem: *√(x²
    + y²)*:'
  id: totrans-458
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`hypot(x, y)` 函数返回边长为 `x` 和 `y` 的三角形的斜边长度*.* 这实际上是勾股定理的快捷方式：*√(x² + y²)*：'
- en: '![](img/5af23f27-03a8-4a17-8050-aded17d2a9dc.png)'
  id: totrans-459
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/5af23f27-03a8-4a17-8050-aded17d2a9dc.png)'
- en: The `cos(x)` function returns the cosine of `x` in radians.
  id: totrans-460
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`cos(x)` 函数返回 `x` 的余弦值，以弧度为单位。'
- en: The `sin(x)` function returns the sine of `x` in radians.
  id: totrans-461
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`sin(x)` 函数返回 `x` 的正弦值，以弧度为单位。'
- en: The `tan(x)` function returns the tangent of `x` in radians.
  id: totrans-462
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`tan(x)` 函数返回 `x` 的正切值，以弧度为单位。'
- en: 'The `degrees(x)` function returns the conversion of the argument from radians
    to degrees:'
  id: totrans-463
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`degrees(x)` 函数将参数从弧度转换为度：'
- en: '![](img/5eb5216a-a858-4718-a02b-bdc8f3581e69.png)'
  id: totrans-464
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/5eb5216a-a858-4718-a02b-bdc8f3581e69.png)'
- en: 'The `radian(x)` function returns the conversion of degrees to radians:'
  id: totrans-465
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`radian(x)` 函数将度转换为弧度：'
- en: '![](img/427cea25-acf3-483e-a5f0-65cdab2f0204.png)'
  id: totrans-466
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/427cea25-acf3-483e-a5f0-65cdab2f0204.png)'
- en: 'To save space, I won''t provide examples of all the following, but here is
    a list of the hyperbolic trigonometric functions available in Python: `acosh(x)`*,*
    `asinh(x)`*,* `atanh(x)`*,* `cosh(x)`*,* `sinh(x)`*,* and `tanh(x)`. These operate
    in the same way as the normal trigonometric functions, except they are used for
    hyperbolas instead of circles.'
  id: totrans-467
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 为了节省空间，我不会提供所有以下函数的示例，但这里是一个 Python 中可用的双曲三角函数列表：`acosh(x)`*,* `asinh(x)`*,*
    `atanh(x)`*,* `cosh(x)`*,* `sinh(x)`*,* 和 `tanh(x)`。这些函数与常规三角函数的操作方式相同，只是它们用于双曲线而不是圆。
- en: 'The `erf(x)` function returns the error function, that is, the Gauss error
    function, at `x`. This is used to calculate statistical functions such as the
    cumulative standard normal distribution, as demonstrated at [https://docs.python.org/3/library/math.html](https://docs.python.org/3/library/math.html):'
  id: totrans-468
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`erf(x)` 函数返回 `x` 处的错误函数，即高斯误差函数。这用于计算统计函数，例如累积标准正态分布，如 [https://docs.python.org/3/library/math.html](https://docs.python.org/3/library/math.html)
    中所示：'
- en: '[![](img/d2ef31b2-81d0-4086-8570-cc6481cb1aaf.png)](https://docs.python.org/3/library/math.html)'
  id: totrans-469
  prefs: []
  type: TYPE_NORMAL
  zh: '[![图片](img/d2ef31b2-81d0-4086-8570-cc6481cb1aaf.png)](https://docs.python.org/3/library/math.html)'
- en: 'The `erfc(x)` function returns the complementary error function at `x`*,* which
    is defined as `1.0 - erf(x)`. This is used for large values of `x` where subtraction
    would cause a loss in significance:'
  id: totrans-470
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`erfc(x)` 函数返回在 `x` 处的补余误差函数，定义为 `1.0 - erf(x)`。这在 `x` 的值很大时使用，因为减法会导致显著性损失：'
- en: '![](img/b54c5f86-dbfd-4e88-b88a-ed188e7e4149.png)'
  id: totrans-471
  prefs: []
  type: TYPE_IMG
  zh: '![](img/b54c5f86-dbfd-4e88-b88a-ed188e7e4149.png)'
- en: 'The `gamma(x)` function returns the Gamma function at `x`:'
  id: totrans-472
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`gamma(x)` 函数返回 `x` 处的伽玛函数：'
- en: '![](img/50e2a711-bbcc-4650-8a67-2fdc36dd5596.png)'
  id: totrans-473
  prefs: []
  type: TYPE_IMG
  zh: '![](img/50e2a711-bbcc-4650-8a67-2fdc36dd5596.png)'
- en: 'The `lgamma(x)` function returns the natural log of the absolute value of the
    Gamma function at `x`:'
  id: totrans-474
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`lgamma(x)` 函数返回在 `x` 处伽玛函数的绝对值的自然对数：'
- en: '![](img/2ce28ad0-306b-458e-8cda-56d655d06621.png)'
  id: totrans-475
  prefs: []
  type: TYPE_IMG
  zh: '![](img/2ce28ad0-306b-458e-8cda-56d655d06621.png)'
- en: The `pi` represents the value of Pi (3.14...) to the operating system's available
    precision.
  id: totrans-476
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`pi` 代表 Pi（3.14...）在操作系统可用精度下的值。'
- en: The `e` represents the value of Euler's number (2.718...) to the system's available
    precision.
  id: totrans-477
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`e` 代表欧拉数（2.718...）在系统可用精度下的值。'
- en: The `tau` represents the constant `2pi` (6.28...) to the system's available
    precision.
  id: totrans-478
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`tau` 代表常数 `2pi`（6.28...）在系统可用精度下的值。'
- en: The `inf` represents the float type `∞`. `- ∞` is represented by `-inf`.
  id: totrans-479
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`inf` 代表浮点类型 `∞`。`- ∞` 用 `-inf` 表示。'
- en: The `nan` represents the float type `not a number`.
  id: totrans-480
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`nan` 代表浮点类型 `not a number`。'
- en: Working with complex numbers
  id: totrans-481
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 复数的处理
- en: Because complex numbers, that is, numbers that have an imaginary element, cannot
    be used with the regular math module functions, the `cmath` module is available
    for these special numbers.
  id: totrans-482
  prefs: []
  type: TYPE_NORMAL
  zh: 因为复数，即具有虚数部分的数，不能与常规的数学模块函数一起使用，所以 `cmath` 模块可用于这些特殊数字。
- en: As a built-in module, it is always available for import. Of note, the functions
    accept integers, floats, and complex numbers as arguments. They will also accept
    any Python object that has a `__complex__()` or `__float__()` method as part of
    its class.
  id: totrans-483
  prefs: []
  type: TYPE_NORMAL
  zh: 作为内置模块，它始终可用于导入。值得注意的是，函数接受整数、浮点数和复数作为参数。它们还将接受任何具有 `__complex__()` 或 `__float__()`
    方法的 Python 对象，作为其类的一部分。
- en: On systems that support signed zeros, branch cuts ([https://en.wikipedia.org/wiki/Branch_point#Branch_cuts](https://en.wikipedia.org/wiki/Branch_point#Branch_cuts))
    are continuous on both sides of the cut, as the sign of the zero designates which
    side of the cut the branch is on. On systems that do not support signed zeros,
    continuity is noted for the specific functions in the next section.
  id: totrans-484
  prefs: []
  type: TYPE_NORMAL
  zh: 在支持有符号零的系统上，分支切割（[https://en.wikipedia.org/wiki/Branch_point#Branch_cuts](https://en.wikipedia.org/wiki/Branch_point#Branch_cuts)）在切割的两侧都是连续的，因为零的符号指定了分支在切割的哪一侧。在不支持有符号零的系统上，下一节中特定函数的连续性被标记。
- en: How to do it...
  id: totrans-485
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 如何做到这一点...
- en: 'The following functions and constants operate like their normal math cousins,
    except where noted:'
  id: totrans-486
  prefs: []
  type: TYPE_NORMAL
  zh: 以下函数和常数与它们的常规数学类似物操作相同，除非有说明：
- en: '`exp(x)`: Calculate math constant `e` to the power of `x`.'
  id: totrans-487
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`exp(x)`: 计算数学常数 `e` 的 `x` 次幂。'
- en: '`log(x[, base])`: There is one branch cut—from `0`, along the negative real
    axis to `-∞`, and continuous from above.'
  id: totrans-488
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`log(x[, base])`: 存在一条分支切割——从 `0` 沿负实轴到 `-∞`，并从上方连续。'
- en: '`log10(x)`: Same branch cut as `log`'
  id: totrans-489
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`log10(x)`: 与 `log` 具有相同的分支切割。'
- en: '`sqrt(x)`: Same branch cut as `log`'
  id: totrans-490
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`sqrt(x)`: 与 `log` 具有相同的分支切割。'
- en: '`acos(x)`: Two branch cuts—one from `1` to the right along the real axis to `∞` and
    continuous from below. The other extends left from `-1` to `-∞` and is continuous
    from above.'
  id: totrans-491
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`acos(x)`: 两条分支切割——一条从 `1` 沿实轴到 `∞`，并从下方连续。另一条从 `-1` 向左延伸到 `-∞`，并从上方连续。'
- en: '`asin(x)`: Same branch cuts as `acos`'
  id: totrans-492
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`asin(x)`: 与 `acos` 具有相同的分支切割。'
- en: '`atan(x)`: Two branch cuts: one from `1j` along the imaginary axis to `∞j`,
    continuous from the right. The other extends from `*-*1j` to `-∞j` and continuous
    from the left.'
  id: totrans-493
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`atan(x)`: 两条分支切割：一条从 `1j` 沿虚轴到 `∞j`，并从右侧连续。另一条从 `*-*1j` 到 `-∞j`，并从左侧连续。'
- en: '`cos(x)`: Calculate the cosine of `x`.'
  id: totrans-494
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`cos(x)`: 计算 `x` 的余弦值。'
- en: '`sin(x)`: Calculate the sine of `x`.'
  id: totrans-495
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`sin(x)`: 计算 `x` 的正弦值。'
- en: '`tan(x)`: Calculate the tangent of `x`.'
  id: totrans-496
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`tan(x)`: 计算 `x` 的正切值。'
- en: '`acosh(x)`: One branch cut from `1` to the left along the real axis to  `-∞`,
    continuous from above.'
  id: totrans-497
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`acosh(x)`: 从 `1` 到左侧沿实轴到 `-∞` 有一条分支切割，从上方连续。'
- en: '`asinh(x)`: Two cuts—one from `1j` along the imaginary axis to `∞j` and continuous
    from the right. The other is from `-1j` along the imaginary axis to `-∞j` and
    continuous from the left.'
  id: totrans-498
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`asinh(x)`: 两条切割——一条从 `1j` 沿虚轴到 `∞j`，并从右侧连续。另一条从 `-1j` 沿虚轴到 `-∞j`，并从左侧连续。'
- en: '`atanh(x)`: Two cuts—one from 1 to real `∞`, continuous from above. The other
    is from `-1` to real `-∞`, continuous from above.'
  id: totrans-499
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`atanh(x)`: 两个切线——一个从 1 到实数 `∞`，从上方连续。另一个从 `-1` 到实数 `-∞`，从上方连续。'
- en: '`cosh(x)`: Calculate the hyperbolic cosine of `x`.'
  id: totrans-500
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`cosh(x)`: 计算 `x` 的双曲余弦。'
- en: '`sinh(x)`: Calculate the hyperbolic sine of `x`.'
  id: totrans-501
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`sinh(x)`: 计算 `x` 的双曲正弦。'
- en: '`tanh(x)`: Calculate the hyperbolic tangent of `x`.'
  id: totrans-502
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`tanh(x)`: 计算 `x` 的双曲正切。'
- en: '`pi`: Return the math constant π as a number.'
  id: totrans-503
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`pi`: 返回数学常数 π 作为数字。'
- en: '`e`: Return the math constant *e* as a number.'
  id: totrans-504
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`e`: 返回数学常数 *e* 作为数字。'
- en: '`tau`: Return the math constant τ as a number.'
  id: totrans-505
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`tau`: 返回数学常数 τ 作为数字。'
- en: '`inf`: Represent the floating-point value `∞`.'
  id: totrans-506
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`inf`: 表示浮点值 `∞`。'
- en: '`nan`: Represent the floating-point value "not a number".'
  id: totrans-507
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`nan`: 表示浮点值 "不是一个数"。'
- en: 'New constants in the `cmath` module include the following:'
  id: totrans-508
  prefs: []
  type: TYPE_NORMAL
  zh: '`cmath` 模块中的新常数包括以下内容：'
- en: '`infj`: Constant complex number with 0 real part and `∞j` imaginary part'
  id: totrans-509
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`infj`: 常数复数，实部为 0，虚部为 `∞j`'
- en: '`nanj`: Constant complex number with 0 real part and `NaN` imaginary part'
  id: totrans-510
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`nanj`: 常数复数，实部为 0，虚部为 `NaN`'
- en: 'Polar coordinates are supported within the `cmath` module. In Python, `z` represents
    the real part `z.real` and the imaginary part `z.imag`. Using polar coordinates,
    `z` is defined by the modulus `r` and the phase angle `φ` (phi):'
  id: totrans-511
  prefs: []
  type: TYPE_NORMAL
  zh: '`cmath` 模块支持极坐标。在 Python 中，`z` 代表实部 `z.real` 和虚部 `z.imag`。使用极坐标，`z` 由模数 `r`
    和相位角 `φ`（phi）定义：'
- en: 'The `phase(x)` function returns the phase of `x` (provided as a complex number);
    the returned value is a float. The result is within the range of -π and  π  and
    the branch cut is along the negative real axis, continuous from above:'
  id: totrans-512
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`phase(x)` 函数返回 `x`（作为复数提供）的相位；返回值是一个浮点数。结果在 -π 和 π 范围内，分支切线沿负实轴，从上方连续：'
- en: '![](img/de2234e7-f2a8-408f-a156-d9c957864649.png)'
  id: totrans-513
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/de2234e7-f2a8-408f-a156-d9c957864649.png)'
- en: 'The `polar(x)` function returns the phase of `x` in polar coordinates as a
    `(r, φ)` pair:'
  id: totrans-514
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`polar(x)` 函数返回 `x` 在极坐标中的相位，作为一个 `(r, φ)` 对：'
- en: '![](img/dceef515-6388-469d-a45a-fc74fd55584e.png)'
  id: totrans-515
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/dceef515-6388-469d-a45a-fc74fd55584e.png)'
- en: 'The `rect(r, phi)` function returns the complex number `x` as a (real, imag)
    pair:'
  id: totrans-516
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`rect(r, phi)` 函数返回复数 `x` 作为 (实部, 虚部) 对：'
- en: '![](img/c6179529-18e2-4fd9-8fa8-102cc44ba119.png)'
  id: totrans-517
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/c6179529-18e2-4fd9-8fa8-102cc44ba119.png)'
- en: Improving decimal numbers
  id: totrans-518
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 改进十进制数
- en: 'Python''s built-in decimal module provides improved support for fast, precise
    floating point calculations. Normal float types are based on binary objects; decimal
    floats are completely different. Specifically, it improves on the normal float
    type by doing the following:'
  id: totrans-519
  prefs: []
  type: TYPE_NORMAL
  zh: Python 的内置十进制模块提供了对快速、精确浮点计算的改进支持。普通浮点类型基于二进制对象；十进制浮点数完全不同。具体来说，它通过以下方式改进了普通浮点类型：
- en: Operating like people learned in school, rather than forcing people to conform
    to a new arithmetic paradigm.
  id: totrans-520
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 按照人们在学校学习的方式操作，而不是强迫人们适应新的算术范式。
- en: 'Representing decimal values exactly, rather than having results such as the
    following:'
  id: totrans-521
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 准确表示十进制值，而不是得到如下结果：
- en: '![](img/a1e727dc-27d1-4623-98b6-4c4307edf154.png)'
  id: totrans-522
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/a1e727dc-27d1-4623-98b6-4c4307edf154.png)'
- en: Ensuring the exactness of decimal values is carried through calculations, preventing
    rounding errors from compounding.
  id: totrans-523
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 确保在计算过程中保持十进制值的精确性，防止舍入误差累积。
- en: Accounting for significant digits, for example, 1.20 + 2.10 = 3.20, not 3.2,
    and 1.20 * 1.30 = 1.5600.
  id: totrans-524
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 考虑有效数字，例如，1.20 + 2.10 = 3.20，而不是 3.2，以及 1.20 * 1.30 = 1.5600。
- en: Allowing for user-specified precision, up to 28 places. This is different from
    float, which is dependent upon the platform.
  id: totrans-525
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 允许用户指定精度，最高 28 位。这与 float 不同，float 的精度取决于平台。
- en: Normal, binary float types only have a small portion of their capabilities exposed
    to the user. Decimal floats expose all required parts of the standard, allowing
    full control of all calculations.
  id: totrans-526
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 普通的二进制浮点类型只向用户暴露了一小部分功能。十进制浮点数暴露了标准中所有必需的部分，允许完全控制所有计算。
- en: Supporting both exact, fixed-point arithmetic and rounded, floating-point arithmetic.
  id: totrans-527
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 支持精确的定点算术和四舍五入的浮点算术。
- en: 'Three main concepts apply to decimal floats: the decimal number itself, arithmetic
    context, and signal handling. Decimal numbers are immutable, signed, and significant,
    that is, trailing zeros aren''t truncated. Arithmetic context specifies things
    such as precision, rounding, exponent limits, and so on. Signals are exceptional
    conditions and are handled depending on the application needs.'
  id: totrans-528
  prefs: []
  type: TYPE_NORMAL
  zh: 十进制浮点数有三个主要概念：十进制数本身、算术上下文和信号处理。十进制数是不可变的、有符号的且是有效的，即尾随零不会被截断。算术上下文指定诸如精度、舍入、指数限制等事项。信号是异常条件，其处理取决于应用需求。
- en: How to do it...
  id: totrans-529
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 如何做到这一点...
- en: 'Because the official documentation ([https://docs.python.org/3/library/decimal.html](https://docs.python.org/3/library/decimal.html))
    comprises more than 35 pages, this section will only provide a brief examination
    of the decimal module:'
  id: totrans-530
  prefs: []
  type: TYPE_NORMAL
  zh: 因为官方文档([https://docs.python.org/3/library/decimal.html](https://docs.python.org/3/library/decimal.html))包含超过35页，本节将只简要介绍十进制模块：
- en: 'When using the decimal module, it is a good idea to figure out what the current
    conditions are and modify them, if needed:'
  id: totrans-531
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 当使用十进制模块时，弄清楚当前条件并如有必要进行修改是个好主意：
- en: '![](img/44dc0684-7f2a-4506-a547-753e9d810fb2.png)'
  id: totrans-532
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/44dc0684-7f2a-4506-a547-753e9d810fb2.png)'
- en: 'In this case, `getcontext` tells us the following:'
  id: totrans-533
  prefs: []
  type: TYPE_NORMAL
  zh: 在这种情况下，`getcontext`告诉我们以下信息：
- en: The system is set for 28 places of precision.
  id: totrans-534
  prefs:
  - PREF_OL
  - PREF_UL
  type: TYPE_NORMAL
  zh: 系统设置为28位精度。
- en: Rounding is to the nearest whole value with ties going to the nearest even integer.
  id: totrans-535
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 舍入到最近的整数，如果存在平局，则舍入到最近的偶数整数。
- en: Emin and Emax are the bottom/top limits allowed for exponents.
  id: totrans-536
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: Emin和Emax是指数允许的底部/顶部限制。
- en: Capital letters are used for designating exponents, for example, *1.2E+12*.
  id: totrans-537
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用大写字母表示指数，例如，*1.2E+12*。
- en: Clamping is set to allow exponents to be adjusted to, at most, `Emax`.
  id: totrans-538
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 限制设置为允许指数调整到最多`Emax`。
- en: Flags monitor for exceptional conditions and remain until explicitly cleared.
    This is one reason why checking the context is one of the first things to do,
    to ensure no undesired flags are still set.
  id: totrans-539
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 标志监控异常条件，直到明确清除。这也是检查上下文是首先要做的事情之一的原因，以确保没有设置不希望设置的标志。
- en: Traps capture the designated conditions and raise errors when they occur.
  id: totrans-540
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 捕获指定的条件，并在条件发生时引发错误。
- en: 'Decimals can be created from integers, floats, strings, or tuples:'
  id: totrans-541
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 十进制可以从整数、浮点数、字符串或元组创建：
- en: '![](img/0e3acda8-0984-4677-8253-9ac16655da0f.png)'
  id: totrans-542
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/0e3acda8-0984-4677-8253-9ac16655da0f.png)'
- en: 'One signal worth using is `FloatOperation`, as it will warn when mixing decimals
    and floats in constructors or ordering comparisons:'
  id: totrans-543
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 一个值得使用的信号是`FloatOperation`，因为它会在构造函数或排序比较中混合十进制和浮点数时发出警告：
- en: '![](img/d7310cb7-c73f-438b-8c4f-76569b8d29a9.png)'
  id: totrans-544
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/d7310cb7-c73f-438b-8c4f-76569b8d29a9.png)'
- en: 'Decimal point significance, when declaring a new `Decimal`, is determined only
    by the number of digits provided. Rounding and precision only applies during arithmetic
    operations:'
  id: totrans-545
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 当声明新的`Decimal`时，小数点的意义仅由提供的数字位数确定。舍入和精度仅在算术操作期间适用：
- en: '![](img/68f52ad6-e9c2-4d0b-bd08-1db884c16704.png)'
  id: totrans-546
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/68f52ad6-e9c2-4d0b-bd08-1db884c16704.png)'
- en: Notice that a precision value of 4 means only four digits will be displayed,
    regardless of how many values after the decimal point are provided.
  id: totrans-547
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，精度值为4表示只显示四位数字，无论小数点后提供多少位数值。
- en: 'Here''s a brief example of how decimal objects interact with other Python objects:'
  id: totrans-548
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 下面是一个简例，说明十进制对象如何与其他Python对象交互：
- en: '![](img/68dc6cb8-3284-46fd-8c3d-4d298595c9df.png)'
  id: totrans-549
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/68dc6cb8-3284-46fd-8c3d-4d298595c9df.png)'
- en: Increasing accuracy with fractions
  id: totrans-550
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用分数提高精度
- en: The `fractions` module adds support for rational number arithmetic to Python.
    Rather than using *x/y* to represent a fraction, true, precise fractions can be
    written; the former method returns a float type which may or not not be truly
    accurate.
  id: totrans-551
  prefs: []
  type: TYPE_NORMAL
  zh: '`fractions`模块为Python添加了对有理数算术的支持。而不是使用*x/y*来表示分数，可以写出真正的、精确的分数；前者方法返回一个浮点类型，可能或可能不是真正准确的。'
- en: A constructor is available to create a fraction from integer pairs, from another
    fraction, a float, a decimal, or a string. If the denominator is 0, a `ZeroDivisionError`
    is generated.
  id: totrans-552
  prefs: []
  type: TYPE_NORMAL
  zh: 可用构造函数从整数对、另一个分数、浮点数、十进制或字符串创建分数。如果分母为0，则生成`ZeroDivisionError`。
- en: How to do it...
  id: totrans-553
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 如何做到这一点...
- en: 'The following properties and methods are available for the fractions class:'
  id: totrans-554
  prefs: []
  type: TYPE_NORMAL
  zh: 分数类有以下属性和方法可用：
- en: '`numerator`: This returns the numerator in the lowest term.'
  id: totrans-555
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`numerator`：这返回最低项中的分子。'
- en: '`denominator`: This returns the denominator in the lowest term.'
  id: totrans-556
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`denominator`：这返回最低项中的分母。'
- en: '`from_float(float)`: This is constructor that takes a float type and creates
    a fraction representing the exact value of the argument. It''s generally easier
    to just make a fraction instance directly from a float.'
  id: totrans-557
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`from_float(float)`: 这是一个构造函数，它接受一个浮点数类型并创建一个表示参数精确值的分数。通常直接从浮点数创建分数实例会更简单。'
- en: '`from_decimal(dec)`: This is a constructor that takes a decimal instance and
    creates a fraction representing the exact value of the argument. It''s generally
    easier to just make a fraction instance directly from a decimal instance.'
  id: totrans-558
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`from_decimal(dec)`: 这是一个构造函数，它接受一个十进制实例并创建一个表示参数精确值的分数。通常直接从十进制实例创建分数实例会更简单。'
- en: '`limit_denominator(max=1000000)`: This returns the closest fraction to the
    argument that has a denominator no greater than `max`. It is useful for approximating
    floats.'
  id: totrans-559
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`limit_denominator(max=1000000)`: 这个函数返回一个与参数最接近的分数，其分母不大于`max`。这对于近似浮点数很有用。'
- en: '`__floor__()`: This returns the greatest integer `<=` the fraction. It is also
    available via `math.floor()`.'
  id: totrans-560
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`__floor__()`: 这个函数返回小于等于分数的最大整数。它也可以通过`math.floor()`访问。'
- en: '`__ceil__()`: This returns the least integer `>=` the fraction. It is also
    available via `math.ceil()`.'
  id: totrans-561
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`__ceil__()`: 这个函数返回大于等于分数的最小整数。它也可以通过`math.ceil()`访问。'
- en: '`__round__(); __round__(n)`: The first method returns the integer closest to
    the fraction, rounding half to even. The second method rounds the fraction to
    the nearest multiple of `Fraction(1, 10**n)`, rounding half to even. It is also
    available via `round()`.'
  id: totrans-562
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`__round__(); __round__(n)`: 第一个方法返回最接近分数的整数，四舍五入到偶数。第二个方法将分数四舍五入到最接近的`Fraction(1,
    10**n)`的倍数，四舍五入到偶数。它也可以通过`round()`访问。'
- en: '`gcd(a, b)`: This returns the greatest common divisor of the two arguments.
    It has been deprecated since `v3.5` in lieu of `math.gcd()`.'
  id: totrans-563
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`gcd(a, b)`: 这个函数返回两个参数的最大公约数。自`v3.5`以来已弃用，取而代之的是`math.gcd()`。'
- en: 'The following screenshot shows some use cases for the fraction module:'
  id: totrans-564
  prefs: []
  type: TYPE_NORMAL
  zh: 下面的截图显示了分数模块的一些用例：
- en: '![](img/bee692e2-53e5-4bab-ac32-c55a74c0f267.png)'
  id: totrans-565
  prefs: []
  type: TYPE_IMG
  zh: '![](img/bee692e2-53e5-4bab-ac32-c55a74c0f267.png)'
- en: Working with random numbers
  id: totrans-566
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 处理随机数
- en: The math-oriented `random` module utilizes a **pseudo-random number generator**
    (**PRNG**) for use in various applications. It is designed for modeling and simulation
    purposes and should not be used for any security or cryptography programs.
  id: totrans-567
  prefs: []
  type: TYPE_NORMAL
  zh: 以数学为导向的`random`模块使用**伪随机数生成器**（**PRNG**）用于各种应用。它旨在用于建模和仿真目的，不应用于任何安全或密码学程序。
- en: PRNGs use a seed value as an argument to the generator. This allows for re-creation
    of randomized scenarios or determining what random value will be generated next
    in a sequence; hence, they are not cryptographically secure. A common application
    of a PRNG is in security key fobs; the PRNG in the fob is provided with the same
    seed value as on the server. Thus, the server and the fob will have the same number
    available at the exact same time, allowing a user to input the number as a second
    form of authentication.
  id: totrans-568
  prefs: []
  type: TYPE_NORMAL
  zh: PRNGs使用种子值作为生成器的参数。这允许重新创建随机化场景或确定序列中下一个生成的随机值；因此，它们不是密码学安全的。PRNG的一个常见应用是在安全密钥链中；密钥链中的PRNG提供了与服务器上相同的种子值。因此，服务器和密钥链将在完全相同的时间拥有相同的数字，允许用户将数字作为第二种身份验证方式输入。
- en: How to do it...
  id: totrans-569
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 如何做到这一点...
- en: 'Note that examples are provided where output is generated for a command. Also
    note that, as these are randomized values, your results may be different:'
  id: totrans-570
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，这里提供了生成命令输出时的示例。还请注意，由于这些是随机值，您的结果可能会有所不同：
- en: The `seed(a=None, version=2)` function initializes the PRNG. If `a` is `None`,
    any system-based randomness sources that are available will be used to generate
    the seed; otherwise, the current system time is used for the seed value. If `a`
    is an integer, then it will be used directly as the seed value.
  id: totrans-571
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`seed(a=None, version=2)`函数初始化伪随机数生成器（PRNG）。如果`a`为`None`，将使用任何可用的基于系统的随机数源来生成种子；否则，使用当前系统时间作为种子值。如果`a`是一个整数，则它将直接用作种子值。'
- en: '`version` can be 1 or 2\. The default is 2, meaning strings, bytes, and bytearrays
    will be converted to integers and all bits will be used for the seed. If version
    1 is used (necessary when working with versions prior to 3.2), the conversion
    to integer creates a smaller range of seed values.'
  id: totrans-572
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '`version`可以是1或2。默认是2，这意味着字符串、字节和字节数组将被转换为整数，并且所有位都将用于种子。如果使用版本1（在处理3.2之前的版本时是必要的），转换为整数将创建一个更小的种子值范围。'
- en: The `getstate()` function returns an object that captures the internal state
    of the PRNG.
  id: totrans-573
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`getstate()`函数返回一个对象，它捕获PRNG的内部状态。'
- en: The `setstate(state)` function restores the internal generator state to the
    value of `state`. Used in conjunction with `getstate`, this allows for setting
    the PRNG to a previous condition.
  id: totrans-574
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`setstate(state)` 函数将内部生成器状态恢复到 `state` 的值。与 `getstate` 一起使用，这允许将 PRNG 设置为先前条件。'
- en: 'The `getrandbits(k)` function returns an integer comprised of `k` random bits:'
  id: totrans-575
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`getrandbits(k)` 函数返回一个由 `k` 个随机位组成的整数：'
- en: '![](img/d38f8e4a-fb80-4855-a002-72f1e967b049.png)'
  id: totrans-576
  prefs: []
  type: TYPE_IMG
  zh: '![](img/d38f8e4a-fb80-4855-a002-72f1e967b049.png)'
- en: 'The `randrange(stop); randrange(start, stop[, step])` function returns a randomly
    selected value from a range of numbers; essentially, it turns the `range` function
    into a random-number picker, limited to the integer range it generates:'
  id: totrans-577
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`randrange(stop); randrange(start, stop[, step])` 函数从一组数字中返回一个随机选择的值；本质上，它将
    `range` 函数转换为一个随机数选择器，限于它生成的整数范围：'
- en: '![](img/3a7a33d2-ea39-489c-9e2f-fd6f585f1bde.png)'
  id: totrans-578
  prefs: []
  type: TYPE_IMG
  zh: '![](img/3a7a33d2-ea39-489c-9e2f-fd6f585f1bde.png)'
- en: 'The `randint(a, b)` function returns a random integer that is between `a` and
    `b`, inclusive:'
  id: totrans-579
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`randint(a, b)` 函数返回一个介于 `a` 和 `b` 之间（包括 `a` 和 `b`）的随机整数：'
- en: '![](img/2d5ef35d-8e29-42d7-8e65-304a24ade43a.png)'
  id: totrans-580
  prefs: []
  type: TYPE_IMG
  zh: '![](img/2d5ef35d-8e29-42d7-8e65-304a24ade43a.png)'
- en: The `choice(seq)` function returns a random element from a pre-made sequence.
    Whereas `randrange` creates a range of numbers; if the sequence argument is empty,
    an error will be generated.
  id: totrans-581
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`choice(seq)` 函数从预先制作的序列中返回一个随机元素。与 `randrange` 创建一个数字范围不同；如果序列参数为空，将生成错误。'
- en: The `choices(population, weights=None, *, cum_weights=None, k=1)` function returns
    a `k`-sized list of elements, selected from a pre-made `population` with replacement.
  id: totrans-582
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`choices(population, weights=None, *, cum_weights=None, k=1)` 函数返回一个由 `k` 个元素组成的列表，这些元素是从预先制作的
    `population` 中有放回地选择的。'
- en: '`weights` allows selection based on relative weights of a `weights` sequence,
    whereas `cum_weights` makes selections based on the cumulative weights of a sequence.
    If neither argument is provided, then selections are based using equal probability.'
  id: totrans-583
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`weights` 允许根据 `weights` 序列的相对权重进行选择，而 `cum_weights` 则根据序列的累积权重进行选择。如果两个参数都没有提供，则选择基于等概率。'
- en: '`shuffle(x[, random])` function shuffles a provided sequence in place. The `random` function
    is actually a function that returns a random float; by default it is the function
    `random()`.'
  id: totrans-584
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`shuffle(x[, random])` 函数就地打乱提供的序列。`random` 函数实际上是一个返回随机浮点数的函数；默认情况下，它是 `random()`
    函数。'
- en: '`sample(population, k)` function returns a `k`-length list of unique elements
    from a provided sequence or set; it provides for random sampling without replacement.
    It returns a new list with elements from the original sequence without affecting
    the original.'
  id: totrans-585
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`sample(population, k)` 函数返回一个由 `k` 个唯一元素组成的列表，这些元素来自提供的序列或集合；它提供了随机抽样不重复的功能。它返回一个新列表，包含来自原始序列的元素，而不影响原始序列。'
- en: '`random()` function returns a random float in the range from 0.0 (inclusive)
    to 1.0 (exclusive).'
  id: totrans-586
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`random()` 函数返回一个介于 0.0（包括）到 1.0（不包括）之间的随机浮点数。'
- en: '`uniform(a, b)` function returns a random float between the values of `a` and
    `b`, inclusive.'
  id: totrans-587
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`uniform(a, b)` 函数返回一个介于 `a` 和 `b` 之间的随机浮点数，包括 `a` 和 `b`。'
- en: '`triangular(low, high, mode)` function returns a random float between `low`
    (default = 0) and `high` (default = 1), with the specified `mode` (default = midpoint).'
  id: totrans-588
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`triangular(low, high, mode)` 函数返回一个介于 `low`（默认为 0）和 `high`（默认为 1）之间的随机浮点数，具有指定的
    `mode`（默认为中间值）。'
- en: '`betavariate(alpha, beta)` function creates a beta distribution, based on `alpha`
    and `beta` both > 0\. Values returned are between 0 and 1.'
  id: totrans-589
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`betavariate(alpha, beta)` 函数基于 `alpha` 和 `beta`（均大于 0）创建一个贝塔分布。返回的值介于 0 和
    1 之间。'
- en: '`expovariate(lambd)` function creates an exponential distribution. `lambd`
    is 1.0 divided by the desired mean and should be non-zero. Values returned are
    0 to ∞ if `lambd` is positive and - ∞  to 0 if negative.'
  id: totrans-590
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`expovariate(lambd)` 函数创建一个指数分布。`lambd` 是期望平均值除以 1.0，且不应为零。如果 `lambd` 为正，则返回的值是
    0 到 ∞；如果为负，则返回 -∞ 到 0。'
- en: '`gammavariate(alpha, beta)` function creates a Gamma distribution, based on
    `alpha` and `beta` both > 0.'
  id: totrans-591
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`gammavariate(alpha, beta)` 函数基于 `alpha` 和 `beta`（均大于 0）创建一个伽马分布。'
- en: '`gauss(mu, sigma)` function creates a Gaussian distribution (bell curve); `mu`
    is the mean and `sigma` the standard deviation. This function is faster than `normalvariate()`,
    but only slightly because it is not thread-safe.'
  id: totrans-592
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`gauss(mu, sigma)` 函数创建一个高斯分布（钟形曲线）；`mu` 是均值，`sigma` 是标准差。此函数比 `normalvariate()`
    快，但仅略快，因为它不是线程安全的。'
- en: '`lognormvariate(mu, sigma)` function creates a log-normal distribution; `mu`
    can be any value but `sigma` must be > 0.'
  id: totrans-593
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`lognormvariate(mu, sigma)` 函数创建一个对数正态分布；`mu` 可以是任何值，但 `sigma` 必须大于 0。'
- en: '`normalvariate(mu, sigma)` function creates a normal distribution; `mu` is
    the mean and `sigma` the standard deviation. This is thread-safe to avoid race
    conditions.'
  id: totrans-594
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`normalvariate(mu, sigma)` 函数创建一个正态分布；`mu` 是均值，`sigma` 是标准差。这是线程安全的，以避免竞争条件。'
- en: '`vonmisesvariate(mu, kappa)` function creates a **bivariate von Mises** (**BVM**)
    distribution to describe values on a torus; `mu` is the mean angle, expressed
    in radians between 0 and 2*π, and `kappa` is the concentration parameter, which
    is >= 0\. If `kappa` = 0, this distribution reduces to a uniform random angle
    over the range 0 to 2* π .'
  id: totrans-595
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`vonmisesvariate(mu, kappa)` 函数创建一个**双变量冯·米塞斯**（**BVM**）分布来描述环面上的值；`mu` 是均值角度，用弧度表示，介于0和2π之间，`kappa`
    是集中参数，其值大于等于0。如果`kappa` = 0，则此分布简化为0到2π范围内的均匀随机角度。'
- en: '`paretovariate(alpha)` function creates a Pareto distribution; `alpha` is a
    shape parameter.'
  id: totrans-596
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`paretovariate(alpha)` 函数创建一个帕累托分布；`alpha` 是形状参数。'
- en: '`weibullvariate(alpha, beta)` function creates a Weibull distribution; `alpha`
    is a scale parameter and `beta` is the shape parameter.'
  id: totrans-597
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`weibullvariate(alpha, beta)` 函数创建一个韦伯分布；`alpha` 是尺度参数，`beta` 是形状参数。'
- en: '`SystemRandom([seed])` function uses `os.urandom()` to create random numbers
    from OS sources but is not available on all systems. As it is not software based,
    the results are not reproducible, that is, this is for truly random numbers, such
    as for cryptography.'
  id: totrans-598
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`SystemRandom([seed])` 函数使用`os.urandom()`从操作系统源创建随机数，但并非所有系统都提供。因为它不是基于软件的，所以结果是不可重复的，也就是说，这是用于真正随机数的情况，例如加密。'
- en: 'The following screenshot contains examples of how some of the `random` functions
    operate:'
  id: totrans-599
  prefs: []
  type: TYPE_NORMAL
  zh: 下面的截图包含了一些`random`函数操作的示例：
- en: '![](img/b5aedf4c-2311-4d53-954e-920637357515.png)'
  id: totrans-600
  prefs: []
  type: TYPE_IMG
  zh: '![](img/b5aedf4c-2311-4d53-954e-920637357515.png)'
- en: Using the secrets module
  id: totrans-601
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用`secrets`模块
- en: This module, while not part of the math set, is important because it makes random
    numbers that are cryptographically secure. Thus, we will look at how this module
    differs from the random module.
  id: totrans-602
  prefs: []
  type: TYPE_NORMAL
  zh: 此模块虽然不属于数学集，但很重要，因为它生成的是加密安全的随机数。因此，我们将探讨这个模块与随机模块的不同之处。
- en: How to do it...
  id: totrans-603
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 如何做到...
- en: '`SystemRandom` class is the same as the `random.SystemRandom` class, that is,
    it provides random numbers and uses the best quality random seeding sources of
    the system.'
  id: totrans-604
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`SystemRandom` 类与`random.SystemRandom` 类相同，即它提供随机数并使用系统最佳质量的随机种子源。'
- en: '`choice(sequence)` method also works just like the `random.choice()` method.'
  id: totrans-605
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`choice(sequence)` 方法也像`random.choice()`方法一样工作。'
- en: '`randbelow(n)` function returns a random integer in the range `[0, n)`.'
  id: totrans-606
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`randbelow(n)` 函数返回一个在范围 `[0, n)` 内的随机整数。'
- en: '`randbits(k)` method returns an integer with `k` random bits.'
  id: totrans-607
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`randbits(k)` 方法返回一个具有`k`个随机位的整数。'
- en: '`token_bytes([nbytes=None])` function returns a random byte string. If `nbytes`
    is not provided, a reasonable default is used; if provided, the returned string
    contains that many bytes.'
  id: totrans-608
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`token_bytes([nbytes=None])` 函数返回一个随机字节字符串。如果没有提供`nbytes`，则使用合理的默认值；如果提供了，返回的字符串包含那么多字节。'
- en: '`token_hex([nbytes=None])` function returns a random text string in hex. The
    bytes used in the string are converted to two hex digits each.'
  id: totrans-609
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`token_hex([nbytes=None])` 函数返回一个十六进制随机文本字符串。字符串中使用的字节被转换为每个字节两个十六进制数字。'
- en: '`token_urlsafe([nbytes=None])` function returns a random, URL-safe text string
    of random bytes. The string is Base64-encoded, so the average byte returned is
    roughly 1.3 characters.'
  id: totrans-610
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`token_urlsafe([nbytes=None])` 函数返回一个随机的、URL安全的文本字符串，该字符串由随机字节组成。该字符串是Base64编码的，因此平均返回的字节大约是1.3个字符。'
- en: '`compare_digest(a, b)` function returns `True` if the arguments are equal and
    `False` if not. The functionality is such that the ability to use timing attacks
    is reduced.'
  id: totrans-611
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`compare_digest(a, b)` 函数如果参数相等则返回`True`，如果不相等则返回`False`。其功能是减少使用时间攻击的能力。'
- en: 'Here are some examples using parts of the `secrets` module:'
  id: totrans-612
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 下面是一些使用`secrets`模块部分的示例：
- en: '![](img/fc2578ee-cd83-47f7-8503-d52f19441a64.png)'
  id: totrans-613
  prefs: []
  type: TYPE_IMG
  zh: '![](img/fc2578ee-cd83-47f7-8503-d52f19441a64.png)'
- en: The *line 3* creates a string of all the letters in the ASCII alphabet and all
    digits.
  id: totrans-614
  prefs:
  - PREF_UL
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*第3行* 创建了一个包含ASCII字母表中所有字母和所有数字的字符串。'
- en: The *line 4* creates a simple password of 12 characters, using all the available
    alphanumeric values the previous string.
  id: totrans-615
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*第4行* 创建了一个由前一个字符串中所有可用的字母数字值组成的12个字符的简单密码。'
- en: The *line 6* creates a more complex password, comprising at least one uppercase
    letter, a lowercase letter, and at least five digits.
  id: totrans-616
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*第6行* 创建了一个更复杂的密码，至少包含一个大小写字母和一个至少包含五个数字。'
- en: The *line 8* creates a token that is sufficiently strong to be used for password
    recovery/reset on a website.
  id: totrans-617
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*第8行* 创建了一个足够强大的令牌，可用于网站的密码恢复/重置。'
- en: Implementing basic statistics
  id: totrans-618
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 实现基本统计
- en: Starting in version 3.4, basic statistical tools were provided to Python. While
    nowhere near as comprehensive as NumPy, SciPy, Pandas, or the like, they are useful
    when having to perform simple calculations and not wanting, or having access to,
    advanced numeric modules.
  id: totrans-619
  prefs: []
  type: TYPE_NORMAL
  zh: 从版本3.4开始，Python提供了基本统计工具。虽然它们远不如NumPy、SciPy、Pandas等全面，但在需要执行简单计算而不想使用或无法访问高级数值模块时很有用。
- en: How to do it...
  id: totrans-620
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 如何做到这一点...
- en: 'Note that the `import` statement is omitted in the following screenshots:'
  id: totrans-621
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，以下截图中的`import`语句被省略了：
- en: 'The `mean(data)` function returns the normal average of a sequence or iterator:'
  id: totrans-622
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`mean(data)`函数返回序列或迭代器的正常平均值：'
- en: '![](img/03717de8-6f3d-41cc-be1d-c3f6fafd50cf.png)'
  id: totrans-623
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/03717de8-6f3d-41cc-be1d-c3f6fafd50cf.png)'
- en: The *line 3* is the mean of integers.
  id: totrans-624
  prefs:
  - PREF_UL
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*第3行* 是整数的平均值。'
- en: The *line 4* is the mean of floats.
  id: totrans-625
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*第4行* 是浮点数的平均值。'
- en: The *lines 6* and *line 8* show that fractions can be averaged, as well as decimals.
  id: totrans-626
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*第6行* 和 *第8行* 显示，分数可以平均，也可以是小数。'
- en: The `harmonic_mean(data)` function returns the harmonic average of a sequence
    or iterator. The harmonic mean is the reciprocal of the arithmetic `mean` of the
    reciprocals of the argument and is typically used when the average of rates or
    rations is needed.
  id: totrans-627
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`harmonic_mean(data)`函数返回序列或迭代器的调和平均值。调和平均值是参数倒数算术平均值的倒数，通常在需要平均速率或比率时使用。'
- en: 'For example, if a car traveled for a given distance at 60 mph, then the same
    distance back at 50 mph, its average speed would be the harmonic mean of 60 and
    50, that is, 2/(1/60 + 1/50) = 54.5 mph:'
  id: totrans-628
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，如果一辆车以60英里/小时的速度行驶了给定距离，然后以50英里/小时的速度返回同样的距离，其平均速度将是60和50的调和平均数，即2/(1/60
    + 1/50) = 54.5英里/小时：
- en: '![](img/a00fd5fd-9ff5-4379-9922-537b11aa24a7.png)'
  id: totrans-629
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/a00fd5fd-9ff5-4379-9922-537b11aa24a7.png)'
- en: 'This is very close to the regular mean of 55 mph, so let''s look at a larger
    difference, say 20 mph and 80 mph:'
  id: totrans-630
  prefs: []
  type: TYPE_NORMAL
  zh: 这非常接近55英里/小时的常规平均值，所以让我们看看一个更大的差异，比如20英里/小时和80英里/小时：
- en: '![](img/16c98b68-3700-4c88-8256-528cc0c06f3b.png)'
  id: totrans-631
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/16c98b68-3700-4c88-8256-528cc0c06f3b.png)'
- en: The reason the harmonic mean is more appropriate in this example is because
    the normal, arithmetic mean doesn't account for the time required to complete
    the same distance, that is, it takes four times longer to travel a given distance
    at 20 mph compared to 80 mph
  id: totrans-632
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个例子中，调和平均数更合适的原因是，正常的算术平均数没有考虑到完成相同距离所需的时间，也就是说，以20英里/小时的速度行驶给定距离所需的时间是80英里/小时的四倍。
- en: If the distance was 120 miles, then it would take six hours to travel at 20
    mph but only one and a half hours at 80 mph. The total distance traveled would
    be 240 miles and the total time would be 7.5 hours. 240 miles/7.5 hours = 32 miles
    per hour.
  id: totrans-633
  prefs: []
  type: TYPE_NORMAL
  zh: 如果距离是120英里，那么以20英里/小时的速度行驶需要六小时，而以80英里/小时的速度只需要一个半小时。总行程将是240英里，总时间是7.5小时。240英里/7.5小时
    = 32英里/小时。
- en: 'The `median(data)` function returns the middle value of a sequence or iterator:'
  id: totrans-634
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`median(data)`函数返回序列或迭代器的中间值：'
- en: '![](img/ea167712-15df-4ba9-a9f7-b6e5eb7f0c5d.png)'
  id: totrans-635
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/ea167712-15df-4ba9-a9f7-b6e5eb7f0c5d.png)'
- en: The *line 19* demonstrates that the average of the two middle values is returned
    when the number of data points is even.
  id: totrans-636
  prefs:
  - PREF_UL
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*第19行* 说明了当数据点的数量为偶数时，返回两个中间值的平均值。'
- en: When the number of data points is odd (*line 20*), then the middle value is
    returned.
  id: totrans-637
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 当数据点的数量为奇数（*第20行*）时，则返回中间值。
- en: 'The `median_low(data)` function returns the low median of a sequence or iterator.
    It is used when the dataset contains discrete values and it is desired to have
    the returned value be part of the dataset:'
  id: totrans-638
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`median_low(data)`函数返回序列或迭代器的低中位数。当数据集包含离散值且希望返回的值是数据集的一部分时使用：'
- en: '![](img/5dfbba1c-bb3f-4ff3-98a8-0a1732cd5568.png)'
  id: totrans-639
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/5dfbba1c-bb3f-4ff3-98a8-0a1732cd5568.png)'
- en: If the dataset is an odd count (*line 21*), the middle value is returned, just
    like a normal median.
  id: totrans-640
  prefs:
  - PREF_UL
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果数据集是奇数（*第21行*），则返回中间值，就像正常的平均值一样。
- en: If the dataset is an even count (*line 22*), then the smaller of two middle
    values is returned.
  id: totrans-641
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果数据集是偶数（*第22行*），则返回两个中间值中较小的一个。
- en: 'The `median_high(data)` function returns the high median of a sequence or iterator.
    It is used when the dataset contains discrete values and it is desired to have
    the returned value be part of the dataset:'
  id: totrans-642
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`median_high(data)`函数返回序列或迭代器的高中位数。当数据集包含离散值且希望返回的值是数据集的一部分时使用：'
- en: '![](img/bc1392ef-a449-4b33-be4c-57719548cce1.png)'
  id: totrans-643
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/bc1392ef-a449-4b33-be4c-57719548cce1.png)'
- en: The *line 23* shows the larger of two middle values is returned if the dataset
    is an even number.
  id: totrans-644
  prefs:
  - PREF_UL
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*第23行* 显示，如果数据集是偶数，则返回两个中间值中较大的一个。'
- en: The *line 24* shows the normal median is returned when there is an odd number
    of values in the data.
  id: totrans-645
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*第24行* 显示当数据中有奇数个值时，返回正常的中位数。'
- en: 'The `median_grouped(data, interval=1)` function returns the median of a group
    of continuous data, using interpolation and calculated at the 50th percentile:'
  id: totrans-646
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`median_grouped(data, interval=1)` 函数返回一组连续数据的平均值，使用插值并在第50百分位计算：'
- en: '![](img/1ff58166-e437-473a-9556-cf947a55bf07.png)'
  id: totrans-647
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/1ff58166-e437-473a-9556-cf947a55bf07.png)'
- en: In this screenshot, the groups are 5–15, 15–25, 25–35, and 35–45, with the values
    shown being in the middle of those groups. The middle value is in the 15–25 group
    so it must be interpolated. By adjusting the interval, which adjusts the class
    interval, the interpolated result changes.
  id: totrans-648
  prefs: []
  type: TYPE_NORMAL
  zh: 在此屏幕截图中，组别为 5-15，15-25，25-35 和 35-45，显示的值位于这些组的中部。中间值位于 15-25 组，因此必须进行插值。通过调整间隔，即调整组距，插值结果会改变。
- en: 'The `mode(data)` function returns the most common value from `data`, and assumes
    `data` is discrete. It can be used for numeric or non-numeric data:'
  id: totrans-649
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`mode(data)` 函数从 `data` 返回最常见值，并假设 `data` 是离散的。它可以用于数值或非数值数据：'
- en: '![](img/222f47ec-3c78-40df-afae-1a46d51d304f.png)'
  id: totrans-650
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/222f47ec-3c78-40df-afae-1a46d51d304f.png)'
- en: The *line 30* shows that if there isn't a single value with the largest count,
    an error will be generated.
  id: totrans-651
  prefs:
  - PREF_UL
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*第30行* 显示如果没有单个值具有最大的计数，将生成错误。'
- en: 'The `pstdev(data, mu=None)` function returns the population standard deviation.
    If `mu` is not provided, the mean of the dataset will be automatically calculated:'
  id: totrans-652
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`pstdev(data, mu=None)` 函数返回总体标准差。如果没有提供 `mu`，则自动计算数据集的平均值：'
- en: '![](img/d3dbf7e6-35fb-49a9-927f-e4b9d498c1ac.png)'
  id: totrans-653
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/d3dbf7e6-35fb-49a9-927f-e4b9d498c1ac.png)'
- en: The *line 1* is a basic standard deviation. However, the mean of a dataset can
    be passed into the method so a separate calculation isn't required (*lines 32*-34).
  id: totrans-654
  prefs:
  - PREF_UL
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*第1行* 是一个基本的标准差。然而，数据集的平均值可以传递给该方法，因此不需要单独计算（*第32-34行*）。'
- en: 'The `pvariance(data, mu=None)` function returns the variance of a population
    dataset. The same conditions for arguments as in `pstdev` applies. Decimals and
    fractions are supported:'
  id: totrans-655
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`pvariance(data, mu=None)` 函数返回总体数据集的方差。与 `pstdev` 中相同的参数条件适用。支持小数和分数：'
- en: '![](img/91b4ab86-d5f7-433b-9cf8-db178b8e5601.png)'
  id: totrans-656
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/91b4ab86-d5f7-433b-9cf8-db178b8e5601.png)'
- en: While `mu` should be the calculated average for the dataset, passing in incorrect
    values may change the results (this also applies to `pstdev`).
  id: totrans-657
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然 `mu` 应该是数据集的计算平均值，但传入错误值可能会改变结果（这也适用于 `pstdev`）。
- en: The `stdev(data, xbar=None)` function is the same functionality as `pstdev`
    but is designed for use with population samples, rather than entire populations.
  id: totrans-658
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`stdev(data, xbar=None)` 函数与 `pstdev` 具有相同的功能，但设计用于与总体样本一起使用，而不是整个总体。'
- en: The `variance(data, xbar=None)` function provides the same functionality as
    `pvariance` but should only be used with samples rather than populations.
  id: totrans-659
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`variance(data, xbar=None)` 函数提供与 `pvariance` 相同的功能，但应仅用于样本而不是总体。'
- en: Improving functionality with comath
  id: totrans-660
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用 comath 提高功能
- en: PyPi provides the `comath` module, which adds additional math functionality
    to Python.
  id: totrans-661
  prefs: []
  type: TYPE_NORMAL
  zh: PyPi 提供了 `comath` 模块，它为 Python 添加了额外的数学功能。
- en: Getting ready
  id: totrans-662
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 准备工作
- en: 'The module can be installed using or downloading and installing the wheel package
    or `.tar.gz` file from [https://pypi.python.org/pypi/comath/0.0.3](https://pypi.python.org/pypi/comath/0.0.3):'
  id: totrans-663
  prefs: []
  type: TYPE_NORMAL
  zh: 可以使用或下载并安装从 [https://pypi.python.org/pypi/comath/0.0.3](https://pypi.python.org/pypi/comath/0.0.3)
    的 wheel 包或 `.tar.gz` 文件来安装该模块：
- en: '[PRE23]'
  id: totrans-664
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: How to do it...
  id: totrans-665
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 如何操作...
- en: 'Note that not all functions in `comath` are displayed here, as some require
    additional packages such as NumPy, which are beyond the scope of this book, or
    are modified versions of existing `math` functions:'
  id: totrans-666
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，这里没有显示 `comath` 中的所有函数，因为一些函数需要额外的包，如 NumPy，这超出了本书的范围，或者是对现有 `math` 函数的修改版本：
- en: '`array.percentile(sorted_list, percent [, key=lambda x: x])` function returns
    the desired percentile (as defined by `percent`) from a sorted list of numbers:'
  id: totrans-667
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`array.percentile(sorted_list, percent [, key=lambda x: x])` 函数从排序后的数字列表中返回所需的百分位数（由
    `percent` 定义）：'
- en: '![](img/434ffb47-5360-4032-93ad-e9b0687fb215.png)'
  id: totrans-668
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/434ffb47-5360-4032-93ad-e9b0687fb215.png)'
- en: For the list of numbers, *line 4* returns the 10^(th) percentile.
  id: totrans-669
  prefs:
  - PREF_UL
  - PREF_UL
  type: TYPE_NORMAL
  zh: 对于数字列表，*第4行* 返回第10百分位数。
- en: The *line 5* returns the 30^(th) percentile.
  id: totrans-670
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*第5行* 返回第30百分位数。'
- en: The *line 6* returns the 50^(th) percentile.
  id: totrans-671
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*第6行* 返回第50百分位数。'
- en: The *line 7* returns the 75^(th) percentile.
  id: totrans-672
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*第7行* 返回第75百分位数。'
- en: The *line 8* returns the 99^(th) percentile.
  id: totrans-673
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*第8行* 返回第99百分位数。'
- en: '`func.get_smooth_step_function(min_val, max_val, switch_point, smooth_factor)`
    function returns a function that moves smoothly from minimum to maximum values
    when its value increases from a given switch point to infinity.'
  id: totrans-674
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`func.get_smooth_step_function(min_val, max_val, switch_point, smooth_factor)`函数返回一个函数，当其值从给定的切换点到无穷大增加时，该函数会平滑地从最小值移动到最大值。'
- en: 'Graphically, this looks like an S-curve, with the switch point being the middle
    of the curve. An example of use is taking an audio signal and smoothing it to
    reduce the jaggedness and show where the significant peaks are:'
  id: totrans-675
  prefs: []
  type: TYPE_NORMAL
  zh: 从图形上看，这看起来像一条S形曲线，切换点位于曲线的中间。一个使用示例是取一个音频信号，将其平滑以减少锯齿状并显示显著峰值的位置：
- en: '![](img/b19ee4fd-783e-42e2-9dfe-0e0b98cfd527.png)'
  id: totrans-676
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/b19ee4fd-783e-42e2-9dfe-0e0b98cfd527.png)'
- en: The function is defined in line 10.
  id: totrans-677
  prefs:
  - PREF_UL
  - PREF_UL
  type: TYPE_NORMAL
  zh: 函数在第10行定义。
- en: The *line 11* shows that `smooth` is, indeed, a function returned by a function.
  id: totrans-678
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 第11行显示`smooth`确实是一个由函数返回的函数。
- en: The *lines 12*-*16* show the values returned for various positions on the graph.
    Near the center, results center around 1.0, while the results from the ends of
    the line are near 0 (minimum end) to near 2 (maximum end).
  id: totrans-679
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 第12行到第16行显示了图表上各种位置的返回值。接近中心的位置，结果围绕1.0，而线段两端的值接近0（最小端）到接近2（最大端）。
- en: '`func.closest_larger_power_of_2(number)` function returns the closest power
    of 2 that is larger than the argument:'
  id: totrans-680
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`func.closest_larger_power_of_2(number)`函数返回大于参数的最接近的2的幂：'
- en: '![](img/4f6d4a47-3bc6-436e-aa77-d58dc9734709.png)'
  id: totrans-681
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/4f6d4a47-3bc6-436e-aa77-d58dc9734709.png)'
- en: The `metric` module has four metric-related classes that all do similar things.
  id: totrans-682
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`metric`模块有四个与度量相关的类，它们都做类似的事情。'
- en: '`MovingMetricTracker` class creates an object that tracks and computes a moving
    metric value.'
  id: totrans-683
  prefs:
  - PREF_UL
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`MovingMetricTracker`类创建一个对象，用于跟踪和计算移动度量值。'
- en: '`MovingAverageTracker` class creates an object to track and compute a moving
    average.'
  id: totrans-684
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`MovingAverageTracker`类创建一个对象来跟踪和计算移动平均值。'
- en: '`MovingVarianceTracker` class creates an object to track and computer a moving
    variance.'
  id: totrans-685
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`MovingVarianceTracker`类创建一个对象来跟踪和计算移动方差。'
- en: '`MovingPrecisionTracker` class creates an object to track and computes a moving
    precision measure.'
  id: totrans-686
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`MovingPrecisionTracker`类创建一个对象来跟踪和计算移动精度度量。'
- en: 'While they all measure different things, the usage is the same, so only one
    will be demonstrated in the following screenshot:'
  id: totrans-687
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 虽然它们都测量不同的事物，但用法相同，所以以下截图只演示一个：
- en: '![](img/477b65f1-61a9-427b-9a19-e9941c2dd662.png)'
  id: totrans-688
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/477b65f1-61a9-427b-9a19-e9941c2dd662.png)'
- en: Because all the `Moving*Tracker` classes are abstract, all that is necessary
    is to create a new class is simply subclass the desired `comath` class (*line
    35*).
  id: totrans-689
  prefs:
  - PREF_UL
  - PREF_UL
  type: TYPE_NORMAL
  zh: 因为所有`Moving*Tracker`类都是抽象的，所以创建一个新类只需要简单地从所需的`comath`类继承（*第35行*）。
- en: Creating an instance (*line 36*) allows access to the abstract class methods
    (*lines 37*-*40*). In this case, we are simply updating a counter as a value changes
    through a computation. In the end, we get back the average over the course of
    the computation.
  id: totrans-690
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 创建一个实例（*第36行*）允许访问抽象类方法（*第37行*-*第40行*）。在这种情况下，我们只是在计算过程中更新一个计数器，作为值的变化。最终，我们得到计算过程中的平均值。
- en: '`segment.LineSegment` class is a class that defines a one-dimensional line
    segment. Methods are provided to allow some useful testing of the segment:'
  id: totrans-691
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`segment.LineSegment`类是一个定义一维线段的类。提供了方法来允许对线段进行一些有用的测试：'
- en: '![](img/cf360a69-85a5-4670-bb15-e721320aca69.png)'
  id: totrans-692
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/cf360a69-85a5-4670-bb15-e721320aca69.png)'
- en: The *line 50* shows the instance creation of a line segment. Arguments are the
    endpoints of the segment.
  id: totrans-693
  prefs:
  - PREF_UL
  - PREF_UL
  type: TYPE_NORMAL
  zh: 第50行显示了线段实例的创建。参数是线段的端点。
- en: The *lines 51* and *line 52* test the `contains()` method, which indicates whether
    a provided argument lies within the boundaries of the segment.
  id: totrans-694
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 第51行和第52行测试`contains()`方法，该方法指示提供的参数是否位于线段的边界内。
- en: The *lines 53* and *line 54* use the `intersection()` method to return a set.
    A sequence is passed in and only those values that are within the boundaries of
    the segment are returned in the set.
  id: totrans-695
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 第53行和第54行使用`intersection()`方法返回一个集合。传入一个序列，并只返回那些在线段边界内的值。
