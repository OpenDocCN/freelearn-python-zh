- en: Generators, Coroutines, and Parallel Processing
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In this chapter, we will take a look at generators, coroutines, and parallel
    processing. Specifically, we will cover the following topics:'
  prefs: []
  type: TYPE_NORMAL
- en: How iteration works in Python
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Using the itertools module
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Using generator functions
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Simulating multithreading with coroutines
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: When to use parallel processing
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Forking processes
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: How to implement multithreading
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: How to implement multiprocessing
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Although the various topics that will be covered in this chapter may seem to
    have little to do with each other, they do have an effect on one another. First,
    iteration is the process of walking through a sequence; Python provides several
    ways to iterate over objects. Generators are functions that generate values in
    a sequential order, implementing iteration functionality under the hood.
  prefs: []
  type: TYPE_NORMAL
- en: This moves into parallelism. Coroutines use generators to effectively create
    multiple processes to allow multitasking but it is controlled by the programmer.
    Multithreading switches processing based on when the operating system decides,
    not the programmer; this allows for concurrency. Multiprocessing utilizes multiple
    CPUs to allow true parallelism.
  prefs: []
  type: TYPE_NORMAL
- en: Without further ado, let's get started on our journey.
  prefs: []
  type: TYPE_NORMAL
- en: How iteration works in Python
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In Python, an iterator is an object that represents a stream of data. While
    iterators are available for containers, sequences in particular always support
    iteration.
  prefs: []
  type: TYPE_NORMAL
- en: Iterators have the `__next__()` method available (or the built-in `next()` function).
    Calling `next()` multiple times returns successive items from the data stream.
    When no more items are available, a `StopIteration` exception is thrown.
  prefs: []
  type: TYPE_NORMAL
- en: Any class can use an iterator by defining a `container.__iter__()` method. This
    method returns an iterator object, typically just `self`. This object is necessary
    to support the iterator protocol. Different types of iteration can be supported,
    with each one providing a specific iterator request. For example, a tree structure
    could support both breadth-first and depth-first traversals.
  prefs: []
  type: TYPE_NORMAL
- en: 'The iterator protocol mentioned previously actually comprises two methods:
    `iterator.__next__()` and `iterator.__iter__()`. (Notice that `__iter__()` has
    a different class compared to the one above.)'
  prefs: []
  type: TYPE_NORMAL
- en: As we have already talked about `__next__()`, a short discussion of `__iter__()`
    is necessary. The `__iter__()` method returns the iterator object itself; this
    allows containers and iterators to be used with `for` and `in` statements.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The most common use of an interator is to loop through a sequence, printing
    out each element:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/3acd45af-2b51-49f1-9627-3dc09db1a463.png)'
  prefs: []
  type: TYPE_IMG
- en: In the preceding example, we have simply iterated through a variety of sequence
    containers, specifically a list (*line 1*), a tuple (*line 2*), dictionary keys
    (*line 3*), characters in a string (*line 4*), and lines in a file (*line 5*).
  prefs:
  - PREF_UL
  - PREF_UL
  type: TYPE_NORMAL
- en: While a dictionary is not a sequence type but a mapping type, it does support
    iteration, as it has an `iter()` call that is only applicable to a dictionary's
    keys.
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: When a `for` statement is used, it calls the built-in `iter()` function on the
    container. The `iter()` function returns an iterator object that defines the `__next__()`
    method to access each element within the container, sequentially. When the container
    is empty, the `StopIteration` exception is raised and the iteration process exits.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'The `__next__()` method can be manually called, if desired, as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/d9e283cd-f976-499b-8486-d7562c8b0b64.png)'
  prefs: []
  type: TYPE_IMG
- en: The *line 8* creates a string of three characters.
  prefs:
  - PREF_UL
  - PREF_UL
  type: TYPE_NORMAL
- en: The *line 9* manually creates an iterator object of the string.
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: The *line 10* shows the iterator object's location in memory. It also shows
    what type of iterator it is, that is, a string iterator.
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: The *line 11*-*line 13* manually call the `__next__()` method, which is available
    via the iterator object.
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: The *line 14* attempts to call the next character in the string, but since the
    string is empty at this point, an exception is raised, terminating the iteration
    process.
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Modifying the iteration process is relatively easy:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Create a class object
  prefs:
  - PREF_UL
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Define an `__iter__()` method that returns an object that is capable of using
    the `__next__()` method, typically `self` if the class defines the `__next__()`
    within itself. `reverse_seq.py` shows an example of this:'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'The following screenshot shows how the preceding code block deals with data
    input:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/2ad6a306-6cf1-4183-814d-e03421f9649e.png)'
  prefs: []
  type: TYPE_IMG
- en: The example code creates a class designed to reverse-iterate through a supplied
    sequence. The input data can be any sequence object. The class defines the initial
    index value as the last item within the supplied sequence.
  prefs:
  - PREF_UL
  - PREF_UL
  type: TYPE_NORMAL
- en: The *line 23* creates an instance of the class, with a string sequence argument
    provided.
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: The *line 24* simply shows the instance in memory.
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: The l*ine 25* calls the iteration process, moving backward through the supplied
    sequence, starting from the end.
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: The *line 26* creates another type of sequence, a list.
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: The list is passed into a new instance in *line 27*.
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: Like *line 25*, we work backward through the list in *line 28*. This demonstrates
    that any sequence object can be iterated through in reverse using this class.
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: 'For a more detailed exploration of iterators, we will walk through the iteration
    process, manually calling `next()` for each item in the sequence:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/f497abbe-d901-44e1-8779-ed041f0143cd.png)'
  prefs: []
  type: TYPE_IMG
- en: In *line 31*, this time we are passing a tuple object directly into the instance
    argument.
  prefs:
  - PREF_UL
  - PREF_UL
  type: TYPE_NORMAL
- en: In *lines 32*-*36*, we manually pull the next element from the tuple.
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: The *line 37* is the error given when there are no more elements to process.
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: Using the itertools module
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Beyond just the standard iteration protocol, Python also provides the `itertools`
    module. This module provides a number of iterator building blocks that, used singly
    or in combination, can create specialized iteration tools for efficient looping.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'There are three main categories of `itertools`: infinite iterators, combinatoric
    iterators, and iterators that terminate on the shortest input sequence.'
  prefs: []
  type: TYPE_NORMAL
- en: Infinite iterators
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Infinite iterators return values repeatedly until a terminating condition is
    reached:'
  prefs: []
  type: TYPE_NORMAL
- en: 'The `count(start=0, step=1)` function returns evenly spaced values that start
    at the `start` argument provided. Stepping is provided to allow skipping values.
    This function is frequently used with `map()` to generate consecutive data points.
    When used with `zip()`, it can be used to add sequence numbers:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/391ebcff-8bff-4390-89a1-2b70bdc17138.png)'
  prefs: []
  type: TYPE_IMG
- en: In this example, we import the `count()` function from the `itertools` module
    in *line 54*.
  prefs:
  - PREF_UL
  - PREF_UL
  type: TYPE_NORMAL
- en: In *line 55*, we create a counting loop, starting with the integer `5` and a
    stepping value of `5`, that is, counting by fives. When the count exceeds `50`,
    the loop quits.
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The `cycle(iterable)` function returns elements from an iterable and saves
    a copy of each one. When the sequence is completed, the saved copies are returned;
    this repeats forever:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/6495f940-bf35-4670-b576-852b1eca884d.png)'
  prefs: []
  type: TYPE_IMG
- en: After importing the `cycle()` function, we create a counter variable. This is
    because `cycle()` will continue indefinitely if an outside condition doesn't stop
    it.
  prefs:
  - PREF_UL
  - PREF_UL
  type: TYPE_NORMAL
- en: The loop will repeatedly print the string `123` until the break condition is
    met, in this case, after 10 characters have been printed to the screen.
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: The `repeat(object, [, times])` function returns `object` indefinitely unless
    a value is supplied for `times`. While it may not seem to have an obvious use,
    `repeat()` is used with the `map()` function to map unchanging parameters to the
    called function, as well as with `zip()` to create a constant part of a tuple
    record.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'One benefit to the `repeat()` iterator is that the single object that is repeated
    is the only memory space allocated. If you want to repeat an object normally,
    that is, *x * n*, multiple copies of *x* are placed into memory:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/e894eeba-518c-4c59-bce0-a02a9cb112de.png)'
  prefs: []
  type: TYPE_IMG
- en: After we import the `repeat()` class, we run the command in *line 2*.
  prefs:
  - PREF_UL
  - PREF_UL
  type: TYPE_NORMAL
- en: As the return object is an iterator, calling the `repeat()` command directly
    (*lines 2* and *3*) doesn't do anything besides returning the object itself.
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: We have to make an instance (*line 4*) before we can do anything with the iterator.
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: Calling the instance directly (*line 5*) again only gives us the `repeat()`
    object.
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: Walking through the instance using iteration (*line 6*) displays the actual
    repetition process.
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: The *line 7* gives an example of using `repeat()` with `map()` to provide a
    steady stream of values to `map()`. In this case, the line creates a list of squared
    values by mapping the `pow()` function to a range of 10 repeated integers.
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: Combinatoric iterators
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Combinatoric iterators are concerned with the enumeration, combination, and
    permutation of element sets:'
  prefs: []
  type: TYPE_NORMAL
- en: The `product(*iterables, repeat=1)` iterator produces a Cartesian product from
    the inputted iterable objects; it is essentially the same as using nested `for`
    loops in a generator. The nested loops cycle through the input iterables, with
    the rightmost element incrementing every iteration. The pattern returned is dependent
    upon the input; that is, if the input iterables are sorted, the output product
    tuples will be sorted as well.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'It is important to point out that Cartesian products are not mathematical products;
    that is, they aren''t the result of multiplication. They are actually part of
    analytic geometry and are all the possible ordered combinations of numbers from
    each input set. In other words, if a line is defined by two different points,
    each with an *x, y* value, the product set would be all the possible ordered pairs
    from those two sets, with the first value coming from the first set and the second
    value coming from the second set. The following example shows the Cartesian products
    created from a set of three points:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/9288935b-aac0-42dd-a247-7ae92b086c82.png)'
  prefs: []
  type: TYPE_IMG
- en: The  `product()` function is imported into the program in *line 18*.
  prefs:
  - PREF_UL
  - PREF_UL
  type: TYPE_NORMAL
- en: The *line 19* creates a list of three sets, such as representing a line in a
    three-dimensional box.
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: In *line 20*, the iterator from `product()` is assigned to a variable. In this
    case, the final object is a tuple to collect the final sets.
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: The *line 21* shows the product sets that were created from the three input
    sets. All possible combinations of input values have been produced.
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The `permutations(iterable, r=None)` function returns successive `r` length
    permutations of the elements provided in the `iterable` argument. If `r` is not
    provided, then the full length of the provided argument is iterated through, with
    all possible permutations provided. Elements are considered unique to their position,
    not their value, so there will be no repeated values in the returned permutations
    if the input elements are unique:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/ac7bd07d-75a3-46db-81a9-de5cd0bda548.png)'
  prefs: []
  type: TYPE_IMG
- en: After importation, a short string is created and passed into the `permutations()`
    function (*line 28*).
  prefs:
  - PREF_UL
  - PREF_UL
  type: TYPE_NORMAL
- en: The results of printing the permutations are provided as tuples.
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: To have the items in the tuples returned in a more normal fashion, the `join()`
    function can be used (*line 29*).
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The  `combinations_with_replacement(iterable, r)` function returns `r` length
    subsets of the elements from `iterable`; this allows the elements to be repeated,
    unlike the normal `combinations()`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/3b43c128-a4d9-4e83-a569-aee5c63c561b.png)'
  prefs: []
  type: TYPE_IMG
- en: In this example, we have limited the returned values to only two elements of
    the input string from *line 27* of the previous example.
  prefs:
  - PREF_UL
  - PREF_UL
  type: TYPE_NORMAL
- en: Because elements can repeat, if we set `r=3`, we get the results in *line 34*.
    When compared to *line 28*, not only are there more results, but the elements
    are duplicated; sometimes this is desired, but usually it is not.
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: Terminating iterators
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Terminating iterators return values until the shortest input sequence has been
    iterated through, then it terminates:'
  prefs: []
  type: TYPE_NORMAL
- en: 'The `accumulate(iterable[, func])` function returns an iterator of accumulated
    sums, or the results of other binary functions, as determined by the value provided
    to the `func` argument. If `func` is provided, it should be a function of two
    arguments. The `iterable` elements can be any type that can be used by `func`
    as arguments. The default function is `addition`. The following example shows
    this default functionality:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/dfe379ed-91f4-4117-b89a-4dba0072c5df.png)'
  prefs: []
  type: TYPE_IMG
- en: As the default function is addition, using `accumulate` to add a range of five numbers
    returns the sum of each addition process. The sum of the previous addition is
    one of the input values to the next addition calculation. Thus, in the output
    of *line 37*, it is seen that *0 + 0 = 0, 0 + 1 = 1, 1 + 2 = 3, 3 + 3 = 6, 6 +
    4 = 10*.
  prefs: []
  type: TYPE_NORMAL
- en: 'The `func` argument has a variety of uses. It can be set to `min()` to track
    the minimum value during the iteration, `max()` to track the maximum value, or
    `operator.mul()` to track the multiplication product, as demonstrated in the following
    example:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/17e99a24-b650-4363-9242-c333d852554d.png)'
  prefs: []
  type: TYPE_IMG
- en: The *line 34* shows the minimum value that is processed during the iteration
    process. In this case, since the iterable argument is a `range()`, the lowest
    value will be zero.
  prefs:
  - PREF_UL
  - PREF_UL
  type: TYPE_NORMAL
- en: If we switch to tracking the maximum running value (*line 35*), the results
    show that each addition shows the next value to be added.
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: The *line 36* imports `operator`, which is then used in *line 37* to multiply
    each subsequent value in a given range. Note that the range has to start at one,
    otherwise all the results will be zero because each value will be multiplied against
    the initial starting zero value in the range.
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: 'One use of `accumulate()` is in debt management; amortization tables can be
    created by accumulating the interest and accounting for payments:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/80fd4c31-086e-41a6-8e59-b1615896668e.png)'
  prefs: []
  type: TYPE_IMG
- en: The *line 38* shows an initial loan of $1,000, then four payments of $120.
  prefs:
  - PREF_UL
  - PREF_UL
  type: TYPE_NORMAL
- en: The *line 39* uses a lambda function to return the current balance, with each
    value in the `money` list used as the payment and the previous balance as the
    input balance value. The value of `1.05` equals an interest rate of 5%.
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: Another use of `accumulate()` is in recurrence relations. A recurrence relation
    is an equation that recursively defines a sequence or multidimensional array when
    one or more initial items are given; subsequent items of the sequence are defined
    as a function of the preceding terms.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'In the following example, a recurrence relation is created after an initial
    value is supplied for the iterable and the accumulated total is passed into the
    `func` argument. This particular example applies to logistic mapping (this is
    how chaotic behavior develops from simple, non-linear dynamical equations) and
    comes from [https://docs.python.org/3.6/library/itertools.html#itertools.accumulate](https://docs.python.org/3.6/library/itertools.html#itertools.accumulate):'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/a90eef80-6f70-4c9c-ae53-3a58ae7b1ccd.png)'
  prefs: []
  type: TYPE_IMG
- en: As this book isn't designed to discuss such topics as chaotic recurrence relations,
    I won't delve into how this code actually works. However, I will note that *line
    40* shows a lambda function that only has a single input argument, `x`. The other
    value is ignored, as `r` is taken from the subsequently assigned variable in *line
    41*.
  prefs:
  - PREF_UL
  - PREF_UL
  type: TYPE_NORMAL
- en: In *line 43*, only the initial `x` value is provided to the `iterable` argument.
    Also note this is an example of the `repeat()` itertool in a practical use.
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: The *line 44* defines a list comprehension printing the value of `x` to two
    decimal points as the `log_map` anonymous function is run through the accumulator.
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The `chain(*iterables)` function returns elements from the first iterable argument
    until there are no more values. At that point, the next iterable argument is processed
    until empty. This continues until all iterable arguments are finished. The `chain()` function
    essentially turns multiple sequences into a single sequence:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/d2d4b640-1409-408f-bef6-2c79e862fa97.png)'
  prefs: []
  type: TYPE_IMG
- en: After importing the `chain` tool, in *line 46* we create a list object that
    passes two lists and a tuple to `chain()`. These arguments could have also been
    predefined variables, but are simply the raw data in this case.
  prefs:
  - PREF_UL
  - PREF_UL
  type: TYPE_NORMAL
- en: When we print out the `chain` results in *line 47*, we see that it has combined
    all the disparate sequence objects as a single list.
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: 'An alternative way to accomplish the same thing is to simply concatenate objects:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/1ecc3e39-ed59-4190-b365-42c47b306c18.png)'
  prefs: []
  type: TYPE_IMG
- en: The *lines 55*-*57* create variables from the raw data used in *line 53*.
  prefs:
  - PREF_UL
  - PREF_UL
  type: TYPE_NORMAL
- en: The *line 58* concatenates all the lists together. Printing the results in *line
    59* shows the same output as achieved in *line 54*. Either way is correct; which
    method to use just depends on which makes more sense to the developer.
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: There is a modified version of `chain()`—`chain.from_iterable(iterable)`. This
    is effectively the same thing as `chain`, except it chains inputs from a single
    iterable argument. The argument is evaluated lazily, meaning it delays evaluation
    of the expression until its value is needed. For example, in Python 2, the `range()`
    function is immediately evaluated, so all the integers produced by the `range()`
    are stored in memory when the function is examined.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'In contrast, Python 3 has a lazy `range()` evaluation. While a variable could
    be assigned to a `range()` call, the call itself would reside in memory while
    the integers would only be called into existence when needed. Consider the following
    examples:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'In the following example screenshot, we see that, when printing a range variable
    in Python 2, all the integers are immediately available; when calling an indexed
    value, its result is obviously provided:'
  prefs:
  - PREF_UL
  - PREF_UL
  type: TYPE_NORMAL
- en: '![](img/9201badf-62d2-4e5e-a288-c1b295b349b8.png)'
  prefs: []
  type: TYPE_IMG
- en: 'In the next example screenshot, Python 3 returns only the `range` object, not
    the entire list of integers. However, when calling an indexed value, it is returned
    because the `range` object is evaluated at that time to determine the value of
    the index. However, only that value is determined; attempting to print the variable
    again still shows the `range` object, rather than the list of integers:'
  prefs:
  - PREF_UL
  - PREF_UL
  type: TYPE_NORMAL
- en: '![](img/d0ded41a-8f4e-4f49-ac02-b6b8090f4e48.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Going back to `chain.from_iterable()`, the following example shows how it can
    be used:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/9deb358c-13ce-4c03-8e6b-84aabe6dec54.png)'
  prefs: []
  type: TYPE_IMG
- en: In this case, `from_iterable()` is actually a method of the `chain` class, so
    it is called using dot nomenclature.
  prefs:
  - PREF_UL
  - PREF_UL
  type: TYPE_NORMAL
- en: Whereas the normal `chain` call takes in separate, iterable objects, `from_iterable`
    takes a single object that has multiple elements, for example, a typical list.
    The elements are combined into a single object in the returned value.
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: With `compress(data, selectors)`, an iterator is created that filters the elements
    from the `data` argument and returns only those elements that match `selectors`.
    When either `data` or `selectors` is empty, the process is finished.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'In reality, the matching occurs when an element in `selectors` is evaluated
    as `True`, rather than matching the exact element type. Thus, Boolean-type values
    are used, that is, `True`*/*`False` or 1/0:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/861dba34-fef2-44d0-8797-760de5feede0.png)'
  prefs: []
  type: TYPE_IMG
- en: The preceding example shows that both Boolean values (*line 3*) and binary integers
    (*line 4*) can be used as comparison values for `selectors`.
  prefs:
  - PREF_UL
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The  `dropwhile(predicate, iterable)` function makes an iterator that drops
    elements from `iterable` while the `predicate` is `true`. When `predicate` is
    `false`, every element will be returned. Of note is the fact that the iterator
    will not show any output until `predicate` becomes `false`, so there may be some
    delay before output occurs:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/96d4f29e-4f85-4e13-9e9e-9a6ec43b83cd.png)'
  prefs: []
  type: TYPE_IMG
- en: The preceding example uses an anonymous lambda function to drop all values that
    are less than 4\. The *line 8* reinforces the fact that iterator objects do not
    automatically do anything without being processed by something that can deal with
    iterators.
  prefs:
  - PREF_UL
  - PREF_UL
  type: TYPE_NORMAL
- en: Thus, *line 9* passes the `dropwhile` object into a list, which runs the lambda
    function and drops all values within the iterable argument, returning only those
    values that are greater than or equal to four.
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: Similar to `dropwhile`*,* `filterfalse(predicate, iterable)` filters the elements
    in `iterable` and returns only those where the `predicate` is `False`. Conversely,
    if `predicate` is `None`, then it only returns those elements that are, themselves,
    `False`*.*
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'It should be pointed that, unlike `dropwhile`, `filterfalse` will evaluate
    every single element. The `dropwhile` object functions only until a `false` comparison
    is made; after that, everything is returned. Thus, `filterfalse` can be used to
    ensure every item is evaluated where as `dropwhile` can be used as a one-shot
    check:'
  prefs: []
  type: TYPE_NORMAL
- en: '*![](img/ffd3d75f-0f7b-4612-950f-3fd6863ee860.png)*'
  prefs: []
  type: TYPE_NORMAL
- en: In this example, `filterfalse` takes a lambda function (*line 11*) that uses
    the modulus of a range of numbers to return those values with a remainder of zero.
    Since zero is considered `False`, only those values will be returned.
  prefs:
  - PREF_UL
  - PREF_UL
  type: TYPE_NORMAL
- en: To make an easier comparison with `dropwhile`, we will used the same input as
    the `dropwhile` example in *line 12*. This is a good way to show that every element
    is evaluated separately, since the only output is those values greater than or
    equal to 4\. In the `dropwhile` example, even though the numbers returned were
    the same, the values of `2` and `3` were returned even though they are less than
    4 because `dropwhile` failed to open when the first `False` value occurred.
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: The `groupby(iterable, key=None)` method produces an iterator that returns consecutive
    keys and groups from the supplied `iterable`. The `key` function is a function
    that computes a key value for each element; if `key` is `None`, it defaults to
    returning the elements unchanged. It is preferable that the `iterable` be pre-sorted
    on the same `key` function.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: This method operates in a similar way to the `uniq` filter in Unix, as it creates
    a new group or a break every time the `key` function value changes. However, it
    differs from SQL's `group by` function, as that aggregates common elements regardless
    of their input order.
  prefs: []
  type: TYPE_NORMAL
- en: 'To use the following example, ensure that `from itertools import groupby` is
    used as it is used in *line 34*:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/ade56270-ba45-469a-a055-aac39e1dd64d.png)'
  prefs: []
  type: TYPE_IMG
- en: For this example, *line 31* is simply a list of tuples that contain the make
    and model of cars.
  prefs:
  - PREF_UL
  - PREF_UL
  type: TYPE_NORMAL
- en: The *line 32* sorts the list based on the first item in each tuple, as shown
    in *line 33*.
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: The *line 34* actually implements the `groupby` method. The `groupby` method
    takes as its arguments the sorted list and an anonymous function that tells `groupby`
    to use the first item in each tuple as the grouping key.
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: Then, in an enclosed loop, we look at the second element in the tuple and print
    out the model (second tuple element) and make (first tuple element, that is, the
    group key) of the cars list. We finish by adding a separation line to indicate
    where each group ends.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'The following screenshot shows what happens if you forget to sort your input
    iterable. In this case, `groupby` still works by grouping common elements, but
    only if they are follow one another within the iterable:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/b0745e51-7029-4a04-bdde-ce5048e5422a.png)'
  prefs: []
  type: TYPE_IMG
- en: 'The  `isslice(iterable[, start], stop[, step])` function returns selected elements
    from the `iterable` argument. If `start` is provided and is not zero, elements
    within `iterable` are skipped until the start index is reached. If `stop` is `None`,
    then all elements within the `iterable` are processed. The `isslice()` function
    works differently from regular slices, as it doesn''t allow negative numbers for
    `start`*,* `stop`, or `step`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/432575ba-630f-4eb1-a09a-011c8f82367c.png)'
  prefs: []
  type: TYPE_IMG
- en: The preceding example shows the different variations that can be used with `islice`.
    The *line 38* shows the iterator stopping after four element indexes are returned.
  prefs:
  - PREF_UL
  - PREF_UL
  type: TYPE_NORMAL
- en: '*The line 39* shows the iterator starting at element index `2` and stopping
    after index `4`.'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: The *line 40* starts at index `2` and returns all values in `iterable`.
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: The *line 41* is the same as *line 40*, except that the returned values have
    a stepping of `2`.
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The  `starmap(function, iterable)` method computes `function` using arguments
    from `iterable`*.* This method is used in lieu of `map()` when argument parameters
    are pre-zipped; that is, they are already combined into tuples in a single iterable.
    In essence, `starmap()` can take any number of arguments (hence the `star` part
    of the name) whereas `map()` can only accept two arguments:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/6264d201-cf4d-4813-86d6-583d3e1cf7c6.png)'
  prefs: []
  type: TYPE_IMG
- en: After importation, a `starmap` object is created and confirmed in *line 43*
  prefs:
  - PREF_UL
  - PREF_UL
  type: TYPE_NORMAL
- en: Displaying the results of `starmap` in *line 44*, we can see that an arbitrary
    number of arguments can be input, so `starmap(`*)* acts like `function(*args)`,
    whereas `map()` is more like `function(a, b)`
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The `takewhile(predicate, iterable)` method generates an iterator that returns
    all elements from `iterable` as long as `predicate` is `true`. In practice, `takewhile()`
    is the opposite of `dropwhile()`. Once the `predicate` becomes `False`, no further
    elements are processed:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/f0090454-495a-4e04-bbb0-4c7e8493ae91.png)'
  prefs: []
  type: TYPE_IMG
- en: '*Line 46* shows that elements within the iterable input are processed until
    the results of the processing are `false`; in this case, `6` is not less than
    `4`. At that point, no further processing is performed and the iterator is returned
    with what was successfully processed upto that point.'
  prefs:
  - PREF_UL
  - PREF_UL
  type: TYPE_NORMAL
- en: The  `tee(iterable, n=2)` method returns `n` independent iterators from a single
    iterable argument. In other words, you can create multiple iterators from a single
    interable input.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Once `tee()` has done its work, `iterable` should not be used elsewhere, otherwise
    it could be modified without the `tee()` output iterators being updated. In addition,
    the resulting iterators may require significant memory allocation; if one iterator
    uses most or all of the data prior to another iterator starting, it is quicker
    to use `list()` than `tee()`:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/ca79bb8b-bf28-4482-ac51-3c0806cb5c44.png)'
  prefs: []
  type: TYPE_IMG
- en: In this example, a simple string of characters is created in *line 48*.
  prefs:
  - PREF_UL
  - PREF_UL
  type: TYPE_NORMAL
- en: Unpacking is performed in *line 49*. As we are using the default `n=2` for the
    resulting iterators, only two variables are required.
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: The *lines 50* and *51* show that, after processing `tee()`*,* we now have two
    identical iterator objects.
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The final itertool to cover is `zip_longest(*iterables, fillvalue=None)`. This
    makes an iterator that aggregates elements from each of the iterable input arguments;
    in short, merging two or more iterables into one. If the arguments are of uneven
    length, missing elements are filled in with the `fillvalue`. Iteration of this
    method continues until the longest iterable argument is empty. In the event that
    the longest argument could potentially be infinite, a wrapper should be used to
    limit the number of calls, such as `islice()` or `takewhile()`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/3a39e8aa-ac05-4b50-a4ba-ea1894317576.png)'
  prefs: []
  type: TYPE_IMG
- en: In this example, we have provided two inline string arguments to `zip_longest()`,
    and the filler is another string. Printing the results shows that argument `1`
    is merged with argument `2`, until no more characters are available in argument
    `2`. At that point, the `fillvalue` is provided as a substitute until argument
    `1` is empty.
  prefs:
  - PREF_UL
  - PREF_UL
  type: TYPE_NORMAL
- en: Using generator functions
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Generators allow you to declare a function that operates like an iterator. This
    allows you to write a custom function that can be used in a `for` loop or an other
    iteration capacity. The key feature of a generator is that it yields a value,
    rather than using `return`*.*
  prefs: []
  type: TYPE_NORMAL
- en: When a generator function is called, it returns an iterator known as a generator.
    This generator controls the operation of the generator function. When the generator
    is called, the function proceeds like normal but, when the logic flow reaches
    the `yield` statement, processing is suspended while returning the first evaluation.
  prefs: []
  type: TYPE_NORMAL
- en: During the suspension, the local state of the function is retained in memory;
    it's just like a normal function was paused in completing its processing. When
    the generator is resumed by calling it again, it continues as if nothing happened,
    returns the next evaluation value, and suspends again. This continues until all
    the values to be processed are completed, at which point a `StopIteration` exception
    is thrown.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Generators are incredibly simple to create. Define a function, but instead of
    using `return`, use the keyword `yield`*:*
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: 'Create an instance of the function. Don''t forget the argument:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: 'Call the instance as an argument to `next()`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: Continue until iteration stops.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: How it works...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Here is an example of a generator in action:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/83aa60b3-667f-4f60-a219-bcf0b0caba59.png)'
  prefs: []
  type: TYPE_IMG
- en: The *line 1* simply creates the function as provided previously.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The *line 2* calls the generator like a normal function, showing that generators
    can operate exactly like a regular function. You could capture the results in
    a `list` object if you wanted a permanent copy of the results.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The *line 3* creates an instance of the generator.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The *lines 4*-*6* show how a generator is typically used. By calling the generator
    instance as the argument for `next()`, the generator processing is paused after
    each evaluation cycle. Rather than receiving all results at once, only one value
    is provided from the generator when called by `next()`. This is due to using `yield`
    rather than `return`*.*
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: In *line 7*, there are no more values to be evaluated in the generator, so processing
    is cancelled and the expected `StopIteration` exception is returned instead.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: As shown by this example, generators operate exactly like other iterator functions.
    They just let you write iterator operations without having to define iterator
    classes with the `__iter__` and `__next__` methods. However, one catch is that
    generators can only be used once; after a sequence is iterated through, it is
    no longer in memory. To iterate more than once, you have to call the generator
    again.
  prefs: []
  type: TYPE_NORMAL
- en: There's more...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'By default, generators provide lazy evaluation: they don''t perform a process
    action until explicitly called. This is a valuable trait when working with large
    datasets, such as processing millions of calculations. If you attempted to store
    all the results in memory at one time, that is, via a normal function call, you
    could run out of space.'
  prefs: []
  type: TYPE_NORMAL
- en: Another option is when you don't know if you actually need to use all the values
    returned. There is no need to perform a calculation if you won't use it, so you
    can reduce the memory footprint and improve performance.
  prefs: []
  type: TYPE_NORMAL
- en: Still another option is when you want to call another generator or access some
    other resource, but you want to control when that access occurs. If you don't
    need an immediate response, for example, you don't want to store the result in
    a temporary variable, then being able to run the generator at the desired time
    can help the design process.
  prefs: []
  type: TYPE_NORMAL
- en: One great place for generators is in replacing callback functions. Callback
    functions are called by something else, do their processing, and occasionally
    send a status report back to the caller. This has the inherent problems of full-processing,
    that is, everything is processed at one time and stored in memory for access.
  prefs: []
  type: TYPE_NORMAL
- en: If a generator is used instead, the same processing occurs but there is no status
    report to the caller. The generator function simply yields when it wants to report.
    The caller gets the generator's result and deals with the reporting work as a
    simple `for` loop that wraps the generator call. If, for some reason, you still
    want to have the generator provide everything at once, you can simply wrap a generator
    call in `list`.
  prefs: []
  type: TYPE_NORMAL
- en: Python uses both of these cases for different versions. In Python 2, `os.path.walk()`
    uses a callback function, whereas Python 3 has `os.walk()`, which uses a filesystem-walking
    generator.
  prefs: []
  type: TYPE_NORMAL
- en: 'Finally, there is one last trick that can help with Python performance. Normally,
    list comprehensions are used to quickly iterate through a list, as in the following
    example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: 'A simple generator can be created in a similar fashion. Basically, you just
    replace the square brackets with parentheses:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: 'Once you have that, you can use the generator instance within a simple `for`
    loop:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: 'Here is the process in use:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/475cddb1-9c6f-4827-937b-df4889e1c091.png)'
  prefs: []
  type: TYPE_IMG
- en: The benefit of using a generator instead of a list comprehension is that intermediate
    memory storage is not required. The values are created on demand, as it were,
    so the entire list is not dumped to memory at one time. This can achieve significant
    speed increases and reduce memory usage, depending on the program.
  prefs: []
  type: TYPE_NORMAL
- en: Simulating multithreading with coroutines
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Where generators can generate data from a function via `yield`, they can also
    be used to accept data if they are used on the right-hand side of the `=` sign
    in a variable assignment. This creates a coroutine.
  prefs: []
  type: TYPE_NORMAL
- en: A coroutine is a type of function that can suspend and resume execution, via
    `yield`*,* at predefined locations within its code. In addition to `yield()`,
    coroutines also have `send()` and `close()` functions for processing data. The `send()` function
    passes data to a coroutine (the *acceptance* part of the function) and `close()`
    terminates the coroutine (as there is no way for garbage collection to inherently
    close it for us).
  prefs: []
  type: TYPE_NORMAL
- en: Using the `asyncio` module allows coroutines to be used to write single-threaded,
    concurrent programs. As they are single-threaded, they still only perform one
    job but the concurrency simulates multithreading. More information about concurrency
    and parallel programming can be found in the next section, *When to use parallel
    processing.*
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Define the function:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: 'Create an instance:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: 'Use `next()` to process the function:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: 'Use `send()` to provide an input value to the function:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: 'This is what it looks like put together:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/aa0e8a58-8311-462a-9f86-7051f4161736.png)'
  prefs: []
  type: TYPE_IMG
- en: 'To make life easier and avoid having to manually call `next()` every time,
    `coroutine_decorator.py` shows how a decorator can be made to handle the iteration
    for us:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: According to the official documentation ([https://docs.python.org/3/library/asyncio-task.html#coroutines](https://docs.python.org/3/library/asyncio-task.html#coroutines)),
    it is preferable to use `@asyncio.coroutine` to decorate generator-based coroutines.
    It isn't strictly enforced, but it enables compatibility with `async def` coroutines
    and also serves as documentation.
  prefs: []
  type: TYPE_NORMAL
- en: '`asyncio_concurrent.py`, from [https://docs.python.org/3/library/asyncio-task.html#example-chain-coroutines](https://docs.python.org/3/library/asyncio-task.html#example-chain-coroutines),
    shows how to use `asyncio` to perform concurrent processing:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: The event loop is started (`get_event_loop()`) and calls `print_sum()`
  prefs:
  - PREF_UL
  - PREF_UL
  type: TYPE_NORMAL
- en: The  `print_sum()` coroutine is suspended while it calls `compute()`
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: The `compute()` coroutine starts but immediately goes to sleep for 1 second
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: When `compute()` restarts, it finishes its computation and returns the result
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: The `print_sum()` coroutine receives the result and prints it
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: There are no more computations to perform so the `print_sum()` coroutine raises
    the `StopIteration` exception
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: The exception causes the event loop to terminate and the loop is closed
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Here is `asyncio_multi_jobs.py` ([https://docs.python.org/3/library/asyncio-task.html#example-parallel-execution-of-tasks](https://docs.python.org/3/library/asyncio-task.html#example-parallel-execution-of-tasks))
    that shows a better illustration of the concurrent execution of multiple jobs:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: In this example, three factorial coroutines are created. Because of the asynchronous
    nature of the code, they aren't necessarily started in order, nor are they processed
    and completed in order.
  prefs: []
  type: TYPE_NORMAL
- en: 'Your results may vary, but here is an example of the output of this code:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/c96c1ee5-def5-47a5-a25b-0d49a8dde3e4.png)'
  prefs: []
  type: TYPE_IMG
- en: As can be seen, the jobs were started in reverse order; if you look at the official
    documentation, they were started in order. Each task was completed at a different
    time so, while the results are in order, each individual task took a varying amount
    of time. This can also be seen when compared to the official documentation.
  prefs: []
  type: TYPE_NORMAL
- en: There's more...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: When working with asynchronous code, a developer has to carefully consider the
    libraries and modules being used. Any imported modules need to be non-blocking;
    that is, they can't stop code execution while waiting for something else to finish.
  prefs: []
  type: TYPE_NORMAL
- en: In addition, a coroutine schedule involving an event loop needs to be created
    to manually handle coroutine scheduling. While operating systems can handle multithreading
    and multiprocessing internally, coroutine scheduling (by its very nature) must
    be handled by the developer. Thus, while coroutines and asynchronous operations
    can be powerful and useful tools, they also take a lot of work to get right.
  prefs: []
  type: TYPE_NORMAL
- en: When to use parallel processing
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Concurrency means stopping one task to work on another. With a coroutine, the
    function stops execution and waits for more input to continue. In this sense,
    you can have several operations pending at the same time; the computer simply
    switches to the next one when it is time.
  prefs: []
  type: TYPE_NORMAL
- en: 'This is where multitasking in operating systems comes from: a single CPU can
    handle multiple jobs at the same time by switching between them. In simple terms,
    concurrency is when multiple threads are being processed during a given time period.
    In contrast, parallelism means the system runs two or more threads simultaneously;
    that is, multiple threads are processed at a given point in time. This can only
    occur when there is more than one CPU core available.'
  prefs: []
  type: TYPE_NORMAL
- en: The benefit of parallelizing code comes from doing more with less. In this case,
    it's doing more work with fewer CPU cycles. Before multi-core systems, the only
    real way to improve performance was to increase the clock speed on the computer,
    allowing the system to do more work in a given amount of time. As thermal limitations
    became a problem with higher CPU frequencies, manufacturers found that adding
    more cores and reducing the frequency could provide similar benefits without overheating
    the system and reducing energy usage, something vital in portable devices. Depending
    on the task, splitting a job into multiple, smaller jobs could actually be quicker
    on a multi-core device than increasing the clock speed.
  prefs: []
  type: TYPE_NORMAL
- en: The biggest problem with making parallel programs is figuring out when parallelism
    will help. Not all tasks need the boost, and sometimes you can actually make things
    slower if you try to use parallel programming. While there are certain types of
    problems than can be looked at and a determination made, in this author's experience,
    you sometimes just have to try it out and see what happens.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Rather than a traditional walk-through of how to code, this will be more of
    a flow-chart to determine which type of parallel processing paradigm to use, if
    any:'
  prefs: []
  type: TYPE_NORMAL
- en: How large is your dataset? If your dataset is small (based on your experience),
    then a single-threaded process may not hurt you too much.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Can your data processing and logic flow be split into simultaneous operations?
    Frequently, the type of program and the data being worked on simply don't allow
    for any type of concurrency or parallel programming.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Is your processing CPU-limited or I/O-limited? CPU-intensive applications are
    best met with multiprocessing whereas I/O-intensive applications are handled better
    with multithreading.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Do you need to have a shared memory pool? In a shared memory pool, you have
    to make sure that each data request doesn't occur at the same time as a data write,
    that is, a race condition, so locking each data transaction is necessary. Non-shared
    memory requires the creation of communication calls between threads/processes
    if data transfer is required.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Have you identified where the bottlenecks are? Before you design a parallel
    program, you have to find the troublespots within the process. While you can parallelize
    the whole program, you get a better return if you focus on optimizing the data
    bottlenecks and functions that do most of the work.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: There's more...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The previous steps listed aren't all-inclusive. Designing parallel programs
    takes a lot of practice, and you can find college courses that are nothing but
    parallel programming, such as [https://ocw.mit.edu/courses/mathematics/18-337j-parallel-computing-fall-2011/](https://ocw.mit.edu/courses/mathematics/18-337j-parallel-computing-fall-2011/).
  prefs: []
  type: TYPE_NORMAL
- en: It also can't be overstated that you should take the time to determine whether
    the problem you're trying to answer can be parallelized. One example used in computer
    science is sorting algorithms. For example, if you have a group of numbers that
    need to be sorted smallest to largest, you could break the entire group into multiples
    of two, that is, compare two numbers to each other. Each of these subgroups could
    then be compared simultaneously. Then, you merge some of the groups together and
    perform another simultaneous comparison. Do this enough times and you eventually
    come up with the final, sorted answer.
  prefs: []
  type: TYPE_NORMAL
- en: If you think about it, parallel processing is similar to recursive programming,
    since you have to break down the problem into smaller chunks, or at least identify
    similar actions. The main goal is to find tasks that can be performed independently
    of each other, as well as tasks that need to exchange data. Independent tasks
    allow work to be distributed between independent workers, while data exchange
    tasks help define which tasks need to be put together in a single worker.
  prefs: []
  type: TYPE_NORMAL
- en: If your program ends up slowing down system response when running, you might
    want to look at parallelizing it. Spinning off new threads or processes allows
    the system to remain responsive to user input while still performing your program's
    work.
  prefs: []
  type: TYPE_NORMAL
- en: Forking processes
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Process forking is the traditional method of parallelizing work, especially
    in *nix operating systems. When a program is forked, the OS simply makes a new
    copy of the original program, including its memory state, and proceeds to run
    the two versions of the program simultaneously. Naturally, the copied program
    can have its own forks, creating a hierarchy of the original, parent process,
    with numerous children and grandchildren copies. If the parent program is killed,
    the child processes can still operate normally.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In Python, to fork a process, all you have to do is import the `os` module
    and invoke the `fork()` function. The following example creates a simple parent/child
    process forking program:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Import the `os` module, necessary to access `fork()`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: 'Define the child process:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: 'Create the parent process:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: How it works...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The child process is very simple. All it does is return the process ID of the
    child. The `os._exit()` call is important as it ensures the child process is killed
    and is not a zombie when the parent is killed.
  prefs: []
  type: TYPE_NORMAL
- en: As the parent process will be forked to create new children, it is the `key`
    function. Only one parent process is created; all other processes will be children.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following screenshot demonstrates one possible result; as process IDs are
    different for every system, your results will be different:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/900c9959-1282-41da-9f40-947462b6ff08.png)'
  prefs: []
  type: TYPE_IMG
- en: 'As you can see from the output, the child processes may not be immediately
    created; the parent may have a chance to spawn several children before the child
    process is able to actually start functioning. Another point: explicitly killing
    the child process ensures that the child doesn''t return to the parent loop and
    spawn its own processes, which would generate grandchildren processes.'
  prefs: []
  type: TYPE_NORMAL
- en: There's more...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The problem with using `os.fork()` is that it only reliably works on *nix OSes,
    including Macs. Windows uses a different forking model; unless you happen to run
    Cygwin (a Windows application that allows for *nix-like functionality), you'll
    have to rely on threads or the `multiprocessing` module.
  prefs: []
  type: TYPE_NORMAL
- en: How to implement multithreading
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Because forking isn''t fully cross-platform compatible, there are two primary
    workers used in parallel Python programming: threads and processes. Threads are
    typically the "go-to" parallel tool for many programmers. Simply put, threads
    are separate workers that function simultaneously to complete the larger job.
    One job can have multiple threads.'
  prefs: []
  type: TYPE_NORMAL
- en: 'A good example is a web browser: while the browser itself is a single process
    when viewed in Windows Task Manager or using the `ps` command in Linux, the browser
    can spawn many threads to accomplish tasks, such as going to a URL, rendering
    HTML, processing JavaScript, and so on. All those threads are working together
    to accomplish the mission of the browser process.'
  prefs: []
  type: TYPE_NORMAL
- en: Threads are sometimes called **lightweight processes** because they run in parallel
    like *nix forked processes, but they are actually generated by a single parent
    process. Threads are frequently used in graphical interfaces to wait for, and
    respond to, user interaction. They are also prime candidates for programs that
    can be designed into multiple, independent tasks; this makes them ideal for networking,
    where I/O operations are the bottleneck, rather than the CPU.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'First, we will create `single_thread.py` to give us a benchmark for comparison.
    For this example, we will be contacting a number of websites and calculating the
    time it takes to open a connection to all of them:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: As we will be contacting websites, we need to import `urllib.request` to actually
    open the connection and `urllib.error` in case there is a problem reaching a website.
  prefs:
  - PREF_UL
  - PREF_UL
  type: TYPE_NORMAL
- en: To make a benchmark, we need to know how long it takes to run the function,
    so we import `time`*.*
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: When we create the function, the first thing we do is figure out the time the
    function started.
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: Next, we create a list of URLs to access. Feel free to add to or modify this
    list.
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: In case there are any errors when accessing a website, we wrap the actual website
    request within a `try...except` block.
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: For each website in the list, we open a connection to the site. As we only care
    how long it takes to connect, we don't do anything with the `urlopen()` return
    object.
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: If a website errors out, for example, 403 Forbidden, we simply ignore it and
    move on.
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: Finally, we calculate the total time it took for the function to run and return
    that value.
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Because we are accessing websites, and connectivity can fluctuate, we will
    write `time_funct.py` that will calculate the average time to run the preceding
    function. This works best as a function included with the preceding example, but
    can be used separately if desired:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: We import the `statistics` library, as it provides basic math functions, such
    as calculating the average.
  prefs:
  - PREF_UL
  - PREF_UL
  type: TYPE_NORMAL
- en: An empty list is created to store the individual time calculations.
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: The averaging function is created. In this case, to allow it to be used for
    other situations, it accepts as arguments a function call and an integer.
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: The integer argument becomes the number of times to run the function argument.
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: Finally, we calculate the average time and return that value.
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: 'To figure out the average, single-threaded time to access 10 URLs, we simply
    print the result of the `avg_time()` function:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/b9bc4839-c176-470e-865e-84b45897d5ad.png)'
  prefs: []
  type: TYPE_IMG
- en: Now, let's compare it to `multi_thread_retrieval.py`. This is more complicated
    to write compared to the single-threaded application, and the example could probably
    we rewritten in a more concise fashion, but it suffices for our needs. The file
    itself is broken into three parts, below, to aid in explanation.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: First, we need to import several modules. The two new ones are `threading` and
    `queue`, necessary when dealing with multiple threads.
  prefs:
  - PREF_UL
  - PREF_UL
  type: TYPE_NORMAL
- en: We make a class for the object that will be receiving the URLs and actually
    performing the URL request. The class itself inherits from the `Thread` class,
    allowing it to inherit threading functionality.
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: The initialization method creates a new thread and fills a queue variable with
    input data.
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The `run` method looks at the queue variable and pulls the URL from it. As
    long as the URL is not `quit`, the program will attempt to reach the website.
    If an exception is generated when accessing the site, it is skipped, just like
    the single-threaded program:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: Next, we define the function that will push the URLs to the receiver. The URL
    list from the single-threaded program is used again. To keep things unambiguous,
    the queue is renamed to `cue`, otherwise we run into problems with the `queue`
    module.
  prefs:
  - PREF_UL
  - PREF_UL
  type: TYPE_NORMAL
- en: The cue is used to create a worker pool of four threads. This pool is available
    for job requests; as one worker finishes a task, it returns to the pool and awaits
    another task.
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: 'We have the start time again, so we can calculate how long the task will take:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: Next, we have three `for` loops that take the URLs from the list and populate
    the cue. When the list is empty, the next URL provided is the word `quit`. The
    final loop joins all the workers together. Basically, the main thread is paused
    while the subthreads process their data. When they finish, they tell the main
    thread, which then continues.
  prefs:
  - PREF_UL
  - PREF_UL
  type: TYPE_NORMAL
- en: The final function creates the worker pool. Depending on the integer provided
    to the pool manager, a number of threads are spawned and start working on a provided
    task. The threads are appended to an empty list and the complete list is returned
    to step `f` earlier.
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Here are the results of several different thread counts:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/9b65c5a4-91ac-4cee-8b48-5a22d71930f7.png)'
  prefs: []
  type: TYPE_IMG
- en: 'The default number of threads (4) is about 3.5x faster than the average of
    10 single-threaded calls:'
  prefs: []
  type: TYPE_NORMAL
- en: Using 10 threads, the speed increase is nearly 6x faster.
  prefs:
  - PREF_UL
  - PREF_UL
  type: TYPE_NORMAL
- en: At 20 threads, we are reaching the point of diminished returns. In this case,
    the speed increase is only 7x faster. This makes sense, as there are only 10 URLs
    in the list.
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: Just for fun, we see that using two threads yields a 2x speed increase. This
    again makes sense, as we have double the number of workers.
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: There's more...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: While multithreading has benefits, it's important to recognize when multithreading
    is advantageous and when it is a burden.
  prefs: []
  type: TYPE_NORMAL
- en: Advantages
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'A number of advantages come from multithreading, which is why it is a very
    popular option for a lot of developers:'
  prefs: []
  type: TYPE_NORMAL
- en: When a process spawns new threads, the heavy lifting has already been done by
    the process. The new threads don't require copying an entire program like a forked
    program and the memory requirements are low, so there is little performance overhead.
    If you look at Task Manager or view threads in Linux, you'll see hundreds or possibly
    thousands of threads being used, yet your system is still responsive.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Programming threads is relatively easy compared to dealing with actual processes.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Threads have a shared memory space they can use, controlled by the parent process.
    This memory space is how threads can communicate with each other and share data.
    In Python, this means that global namespaces, object passing, and program-wide
    components such as imported modules are all available to every thread from a given
    process.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Thread programming is portable between OSes. As mentioned, Windows doesn't directly
    support process forking, but every OS supports threads. Code it once, and it will
    run anywhere.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Good choice for I/O-limited applications, as application responsiveness is improved.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Disadvantages
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'However, there are some disadvantages with multithreading. Some are inherent
    in the multithreading paradigm, and others (such as GIL), are particular to Python:'
  prefs: []
  type: TYPE_NORMAL
- en: Threads cannot directly start another program. They can only call functions
    or methods in parallel with the rest of the program that spawned them, that is,
    threads can only utilize and interact with the components of their parent but
    can't work with other programs.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Threads have to contend with synchronization and queues to ensure operations
    don't block others. For example, there is only one `stdin`, `stdout`, and `stderr` available
    per program and all the threads for that program have to share those interfaces,
    so managing thread conflicts can become a problem.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**G****lobal interpreter lock** (**GIL**) is the bane of many thread programmers.
    Simply put, GIL prevents multiple threads from operating within the Python interpreter
    environment simultaneously. While the OS may have dozens or hundreds of threads,
    Python programs can only utilize the Python environment one at a time. When a
    Python thread wants to do work, it must lock down the interpreter until the work
    is over. Then, the next thread in line gains access to the interpreter and locks
    it in turn. In other words, you can have multithreading but you can''t have true,
    simultaneous operations. Because of this, threads can''t be split across multiple
    CPUs; you can only have multithreading within one CPU.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Shared memory means a crashed/misbehaving thread can trash data and corrupt
    the parent process.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: How to implement multiprocessing
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Multiprocessing in Python involves starting separate processes, much like forking.
    This gets around the GIL and its effect on multiple threads, but you have to deal
    with the overhead of increased memory usage and the multiple instances of the
    Python interpreter that are spawned for all the processes. However, in multi-core
    systems, multiprocessing can take advantage of the different CPUs so you have
    true parallelism; more cores = more processing power.
  prefs: []
  type: TYPE_NORMAL
- en: As there isn't room to cover everything about parallel Python programming (there
    are entire books written on the subject), I'm going to finish this chapter by
    demonstrating how to automate multiprocessing using `Pool()`, which controls worker
    processes automatically. `Pool()` accepts a number of input arguments, probably
    the most important one being the number of processes. By default, `Pool()` uses
    all the available CPUs on your system. This is useful because, if your system
    is upgraded, your program will automatically use more processing power without
    having to be rewritten.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Using `pool()` is the easiest way to work with multiprocessing, as you don''t
    have to think about manually spawning processes and controlling interaction between
    them. Obviously, this limits your programs somewhat, as you have to figure out
    how to write your programs to take advantage of `pool()`, whereas manual control
    gives you a little more leeway. `multi_process_retrieval.py` demonstrates how
    `pool()` can be used to allocate work:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: As before, we are going to access the same websites, so we need to import the
    `urllib` modules and `time`. We also need to import `Pool()` from the `multiprocessing`
    module.
  prefs:
  - PREF_UL
  - PREF_UL
  type: TYPE_NORMAL
- en: Again, we capture the start time so we can calculate how long the retrieval
    takes.
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Like the multithreading example, we create a pool of workers; four in this
    case. In this instance, `multiprocessing.pool()` takes a bit less setup: assign
    an instance of `Pool()` and that''s it. No need to bother with a queue, at least
    with simple programs such as this one.'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: We use a `try...except` block to spawn the pool workers, in case there is a
    problem accessing a website. In this example, we use `map()` to place each URL
    in the list with the `urlopen` process.
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: Close the pool of workers then join them so the main process is suspended until
    the rest of the processes are complete.
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: Finally, print the time taken.
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The following screenshot shows some sample results:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/0e350067-3f7b-4f96-8e35-dba5367125d5.png)'
  prefs: []
  type: TYPE_IMG
- en: Using the default value we gave the pool (four workers), the result is about
    1 second. This is comparable to multithreading; while it could be ascribed to
    the fickleness of network connections, there is some overhead due to launching
    larger-weight processes rather than lightweight threads.
  prefs:
  - PREF_UL
  - PREF_UL
  type: TYPE_NORMAL
- en: Dropping the pool to 1 gives us a time of about 3 seconds. Again, this is comparable
    to the average time of 10 runs for a single-threaded application, which makes
    sense as this is exactly the same thing.
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: Bumping the pool to two workers takes about half the time of a single one, as
    it should be.
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: Using eight workers yields slightly more than half the time of four workers,
    showing that processing time decreases linearly the more CPUs you can throw at
    it.
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: 'As this author''s computer has eight cores, eight workers is probably about
    the best we can expect in terms of performance. To confirm this, the following
    shows the results of throwing more workers in the pool:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/88cadc8e-03cb-4261-b0eb-25613eb90bcd.png)'
  prefs: []
  type: TYPE_IMG
- en: With 10 workers (two more than the number of CPUs available), the speed is actually
    worse than using eight workers.
  prefs:
  - PREF_UL
  - PREF_UL
  type: TYPE_NORMAL
- en: However, with 20 workers, the program speed is 16% faster. Realistically, the
    difference in speed is due to network issues and not the speed of the computer.
    Again, with only eight cores, putting more workers in the pool doesn't help anything
    because only eight workers can perform tasks simultaneously.
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: There's more...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'One thing to note about `multiprocessing.pool()`: if you don''t provide an
    integer argument to specify the number of workers in the pool, the program will
    default to all the CPUs available in your system. If you have a dual-core system,
    you''ll get two workers. Have a monster of a system with 48 cores, then you get
    48 workers.'
  prefs: []
  type: TYPE_NORMAL
- en: When it comes to cores, if you have Intel CPUs with hyper-threading, each individual
    CPU counts as two when it comes to multiprocessing. So, if you plan on writing
    a lot of parallelized software, it may be better to spend the extra money and
    maximize the number of hyper-threaded CPUs you can get.
  prefs: []
  type: TYPE_NORMAL
- en: The `map()` function is a function that applies another function over a sequence,
    typically a list. It takes a little getting used to (at least for me), but once
    you figure it out, it's a great shortcut too. To use single-threaded web retrieval
    code as an example, you could rewrite the `for` loop as `map(urllib.request.urlopen,
    urls)`. It's important to remember that the items you're passing to the function
    are in a sequence (list, tuple, dictionary, and so on), otherwise you'll get an
    error.
  prefs: []
  type: TYPE_NORMAL
- en: Combining `map()` with `Pool()` eliminates a lot of the manual templating you
    have to do otherwise. One thing to note, though, is that you'll probably want
    to adjust the number of processes created. While `Pool()` defaults to all the
    CPUs it finds, you can give it an integer argument, explicitly telling it how
    many processes to start, that is, more or less than the number of CPUs you actually
    have. To get maximum performance, you'll have to adjust your program until you
    get diminishing returns.
  prefs: []
  type: TYPE_NORMAL
- en: This is also important if your program is going to be running for a long time.
    You don't want to use all your processing power for the program if you're going
    to be running it on your main computer, otherwise it will make your computer unavailable.
    When first learning how to write parallel programs, this author's dual-core system
    was unusable for more than 20 minutes just testing to see what the performance
    difference was between multi- and single-processing.
  prefs: []
  type: TYPE_NORMAL
- en: Working with Python's Math Module
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In this chapter, we will cover Python''s `math` module and the various mathematical
    functions provided in it. We will also talk about math-related modules, including
    cryptography and statistics. Specifically, we will discuss the following topics:'
  prefs: []
  type: TYPE_NORMAL
- en: Using the math module's functions and constants
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Working with complex numbers
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Improving decimal numbers
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Increasing accuracy with fractions
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Working with random numbers
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Using the secrets module
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Implementing basic statistics
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Improving functionality with comath
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Python uses a hierarchy of abstract base classes to represent number-like classes.
    While the types defined by the abstract classes cannot be instantiated, they are
    used to create a numbers tower of subclasses: number -> complex -> real -> rational
    -> integral.'
  prefs: []
  type: TYPE_NORMAL
- en: The reason for this is to allow functions that accept numbers as arguments to
    determine the properties of the arguments, thus allowing for backend functionality
    to be applied without user intervention. For example, slicing requires arguments
    to be integrals, whereas math module functions require real numbers as arguments.
    By ensuring these number classes are used, Python can provide for inherent functionality,
    for example, arithmetic operations, concatenation, and so on, as determined by
    the types used.
  prefs: []
  type: TYPE_NORMAL
- en: Using the math module's functions and constants
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Python's `math` module is built in; therefore, it is always available for import.
    The mathematical functions contained within it are defined by the C standard,
    so if something doesn't work, blame the C developers.
  prefs: []
  type: TYPE_NORMAL
- en: Complex numbers are handled by a separate module (`cmath`), so the math module
    can only be used with integers and floating point numbers. This was done on purpose,
    as dealing with complex numbers requires more effort than most people need for
    general functions. Unless otherwise indicated, all math arguments can be integers
    or floats.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The `ceil(x)` function returns the smallest integer `>= x`. Normal mathematical
    rounding is not used, so `12.3` will be rounded up to `13`, rather than rounding
    up starting at `12.5`; any value greater than `x.0` will be rounded up to the
    next value, as shown in the following screenshot:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/efda8ea8-66ce-4652-90a3-3632f87236f1.png)'
  prefs: []
  type: TYPE_IMG
- en: 'The `copysign(x, y)` function returns a float value with an absolute value
    of `x` but with the sign of `y`. If the OS supports signed zeros, `copysign(1.0,
    -0.0)` gives the value `-1.0`, as shown in the following screenshot:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/09b0fe5d-eb44-4565-956c-b0d637858924.png)'
  prefs: []
  type: TYPE_IMG
- en: 'The  `fabs(x)` function returns the absolute value of an argument, effectively
    stripping the sign from the argument:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/fea0b7e3-fd77-4e01-81fd-8c97d9cb9a65.png)'
  prefs: []
  type: TYPE_IMG
- en: 'The  `factorial(x)` function returns the factorial of `x`; if the argument
    is not integral or is negative, an error is generated:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/1361186f-1c8c-4d9a-ae6f-a64822363294.png)'
  prefs: []
  type: TYPE_IMG
- en: 'The  `floor(x)` function returns the largest integer `<= x`. Like `ceil`, normal
    rounding is ignored; in this case, floating point values are truncated, converting
    them into integers:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/b83a2e32-c096-4afa-b8cb-003863c2813a.png)'
  prefs: []
  type: TYPE_IMG
- en: 'The `fmod(x, y)` function returns the modulus of the two arguments. This is
    defined by the operating system''s C library, so results may vary depending on
    the platform. It differs from the normal `x % y` operation in that `fmod` returns
    a result with the same sign as `x` and is mathematically precise for float types;
    the normal modulus returns with the sign from `y` and can produce rounding errors.
    Hence, `fmod` should be used for float types while normal modulus should be used
    for integers:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/5effd3bd-6101-4d50-a5a6-ec4d41bc1ff0.png)'
  prefs: []
  type: TYPE_IMG
- en: Here, *line 24* shows that `fmod` can provide the correct value for large exponent
    values, including the sign. The *line 25* shows the results of normal modulus
    operation, which rounds to the incorrect value of zero.
  prefs: []
  type: TYPE_NORMAL
- en: 'The `frexp(x)` function returns the mantissa (the decimal part of a number)
    [`m`] and exponent [`e`] of `x`. `m` is a float and `e` is an integer such that
    `m * 2**e = x`. This function is commonly used to see the internal representation
    of a float value in a portable manner:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/bbcc3981-4dba-4b33-bc69-4934459402ba.png)'
  prefs: []
  type: TYPE_IMG
- en: 'The `fsum(iterable)` function returns a floating point sum of values from an
    iterable. This avoids precision issues found in the default `sum()` function by
    tracking intermediate partial sums, though the accuracy depends on the operating
    system, as the backend C library can cause rounding errors:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/896abef1-3823-4bc7-bbb0-d57ced978229.png)'
  prefs: []
  type: TYPE_IMG
- en: 'The `gcd(a, b)` function returns the greatest common divisor of two integer
    arguments:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/01a347de-dd59-4a03-8d64-6c2edc72053a.png)'
  prefs: []
  type: TYPE_IMG
- en: The `isclose(a, b, *, rel_tol=1e-09, abs_tol=0.0)` function returns `True` if
    `a` and `b` are close to each other in value and returns `False` if not. The determination
    of *close enough* comes from the relative and absolute tolerances.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Relative tolerance (`rel_tol`) is the maximum difference allowed between the
    arguments, relative to the larger absolute value of `a` or `b`. The default value
    ensures that the two argument values are the same to nine decimal places.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Absolute tolerance (`abs_tol`) is the minimum allowed difference; it is particularly
    useful when comparing values close to zero:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '![](img/7a9b55d8-daa5-40e8-bf6b-b1996f44c6c6.png)'
  prefs: []
  type: TYPE_IMG
- en: The *line 44* is just a simple check that compares the exact same values.
  prefs:
  - PREF_UL
  - PREF_UL
  type: TYPE_NORMAL
- en: The *line 45* rounds the first argument to the eighth decimal place and compares
    it using default values.
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: The *line 46* compares values at two decimal places. Using the default values,
    they are not close in value, even though they differ by only 1/100.
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: The *line 47* uses the same values as *line 46*, but changes the relative tolerance
    to 5%. With this change, they are considered close to each other.
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: The *line 48* does a similar thing, except it is looking at values close to
    zero, so absolute tolerance is changed from 0% different to 5%.
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The `isfinite(x)` function returns `True` if *`x`* is a finite number, that
    is, not `inf` or `NaN`; it returns `False` only if the argument is infinite or
    not a number. The number 0.0 is considered a finite number:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/773785fe-efef-467e-b18d-9d4be913a46b.png)'
  prefs: []
  type: TYPE_IMG
- en: 'The `isinf(x)` function returns `True` if the argument is `±∞`;  it returns
    `False` for any other value:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/81210a58-75a7-42ba-a355-e65109e60bc2.png)'
  prefs: []
  type: TYPE_IMG
- en: 'The `isnan(x)` function returns `True` if argument is `NaN` (not a number),
    and `False` otherwise:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/64f507d8-8108-4900-b70c-dd1a4119e67e.png)'
  prefs: []
  type: TYPE_IMG
- en: 'The `ldexp(x, i)` function is the inverse of `frexp()` and returns `x * 2^i`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/e95df07c-bedd-4441-95dd-e59d53bce123.png)'
  prefs: []
  type: TYPE_IMG
- en: The preceding screenshot uses the results of the previous `frexp()` screenshot,
    demonstrating that the process is reversed to find the original floating point
    value.
  prefs: []
  type: TYPE_NORMAL
- en: 'The  `modf(x)` function returns the integer and fractional parts of the argument;
    both returned values are floats with the sign of the argument:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/3558cf99-2f71-4b25-8753-71b5f15f3a24.png)'
  prefs: []
  type: TYPE_IMG
- en: Notice that the fractional parts have rounding errors. Limiting the results
    to the minimum-needed precision may help alleviate this for display, but computations
    using the raw values may have significant errors propagated through the calculations.
  prefs: []
  type: TYPE_NORMAL
- en: 'The `trunc(x)` function returns the truncated integral part of a real number,
    that is, it converts a float to an integer:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/24f44147-f5d7-48f2-bf40-7c90d058e4da.png)'
  prefs: []
  type: TYPE_IMG
- en: 'The `exp(x)` function returns `e^x`, where `e` is the natural log:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/59276551-64fa-4ab1-b8de-c3164bf2a2b1.png)'
  prefs: []
  type: TYPE_IMG
- en: 'The `expm1(x)` function returns `e^x - 1`. This is primarily for small values
    of `x`, as manual calculation can cause a loss in precision. Using `expm1()` maintains
    the precision without rounding errors:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/9a5cbd83-440a-4c58-9b61-28cb4953f620.png)'
  prefs: []
  type: TYPE_IMG
- en: When the exponent is `-9`, that is, `0.000000001`, significant rounding errors
    occur when manually creating the formula `e^x - 1`. Using `expm1`, full precision
    is maintained.
  prefs: []
  type: TYPE_NORMAL
- en: 'The `log(x[, base])` function returns the natural log of `x` when provided
    one argument; two arguments provides the log of `x` to a given base:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/dfd51747-e673-497b-9979-5ae7e6e16fc1.png)'
  prefs: []
  type: TYPE_IMG
- en: 'The  `log1p(x)` function returns the base `-e` log of `1 + x` . The result
    is calculated to maximize accuracy when `x` is near zero:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/63463908-83c1-440d-97a9-1a8c34b96443.png)'
  prefs: []
  type: TYPE_IMG
- en: 'The `log2(x)` function returns the base `-2` log of `x`. This is more accurate
    than using `log(x, 2)`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/d9444b88-076d-4ef1-a996-185c096356b1.png)'
  prefs: []
  type: TYPE_IMG
- en: As shown in this screenshot, the accuracy of `log2` doesn't really become a
    factor until the number of decimal places for the argument exceeds 30.
  prefs: []
  type: TYPE_NORMAL
- en: 'The `log10(x)` function returns the base `-10` log of `x`. Like `log2`, it
    is generally more accurate than `log(x, 10)`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/2d42957c-de41-4417-989d-e23d7d3ac1de.png)'
  prefs: []
  type: TYPE_IMG
- en: In this case, the example shows accuracy differs when arguments are greater
    than 40 decimal places. Of course, individual results will differ depending on
    the use case, so it's probably best to use the functions provided by the module.
  prefs: []
  type: TYPE_NORMAL
- en: 'The `pow(x, y)` function returns `x^y`. The `math.pow()` function converts
    arguments to float types; to calculate exact integer values, use the built-in
    `pow()` function or the `**` operator:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/3a5d7f98-5e78-4c68-a6ea-0962568d341c.png)'
  prefs: []
  type: TYPE_IMG
- en: The *lines 116* and* line 117* compare the output when using the built-in `pow`
    versus `math.pow`.
  prefs:
  - PREF_UL
  - PREF_UL
  type: TYPE_NORMAL
- en: The *line 119* and *line 120* show a discrepancy in the underlying library.
    When either argument is zero or `NaN`, the result is `1.0`, even if an error would
    be expected. While Python attempts to follow the C99 standards as much as possible,
    there are limits, and this is one of them.
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The `sqrt(x)` function returns the `√x`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/3dab7c7f-1873-40bd-a2c7-63707e09ff2a.png)'
  prefs: []
  type: TYPE_IMG
- en: As shown in *line 123*, taking the root of a negative number yields an error,
    as expected. To deal with square roots of negative numbers, you have to use the
    `cmath` module.
  prefs: []
  type: TYPE_NORMAL
- en: 'The `acos(x)` function returns the arc cosine of `x`, in radians:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/e986e666-80d6-4aa5-a45a-ecfd68ea2976.png)'
  prefs: []
  type: TYPE_IMG
- en: As expected, an argument `>1` will return an error, since when converted from
    radians to decimals, values are always less than one.
  prefs: []
  type: TYPE_NORMAL
- en: 'The `asin(x)` function returns the arc sign of `x`, in radians:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/72d7bc1f-c759-49e0-8e2b-3ab1ac3efff2.png)'
  prefs: []
  type: TYPE_IMG
- en: Again, values `>1` result in errors, so ensure you convert your argument to
    the correct radian value first.
  prefs: []
  type: TYPE_NORMAL
- en: 'The `atan(x)` function returns the arc tangent of `x`, in radians:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/955848b2-f2f4-46b6-9d2a-e8ce9c6ab33a.png)'
  prefs: []
  type: TYPE_IMG
- en: 'The `atan2(y, x)` returns the result of `atan(y / x)`, in radians and between
    the values of `-π` to  `π` . The vector from origin to `(x,y)` makes the angle
    in the first quadrant, that is, the positive *X *axis. This means that `atan2`
    can compute the correct quadrant for the angle since the signs for both arguments
    are known:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/adb2003a-ced1-442a-ae92-3097702f3a37.png)'
  prefs: []
  type: TYPE_IMG
- en: 'The `hypot(x, y)` returns the hypotenuse of a triangle with sides of length
    `x` and `y`*.* Basically, this is a shortcut of the Pythagorean theorem: *√(x²
    + y²)*:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/5af23f27-03a8-4a17-8050-aded17d2a9dc.png)'
  prefs: []
  type: TYPE_IMG
- en: The `cos(x)` function returns the cosine of `x` in radians.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The `sin(x)` function returns the sine of `x` in radians.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The `tan(x)` function returns the tangent of `x` in radians.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'The `degrees(x)` function returns the conversion of the argument from radians
    to degrees:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/5eb5216a-a858-4718-a02b-bdc8f3581e69.png)'
  prefs: []
  type: TYPE_IMG
- en: 'The `radian(x)` function returns the conversion of degrees to radians:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/427cea25-acf3-483e-a5f0-65cdab2f0204.png)'
  prefs: []
  type: TYPE_IMG
- en: 'To save space, I won''t provide examples of all the following, but here is
    a list of the hyperbolic trigonometric functions available in Python: `acosh(x)`*,*
    `asinh(x)`*,* `atanh(x)`*,* `cosh(x)`*,* `sinh(x)`*,* and `tanh(x)`. These operate
    in the same way as the normal trigonometric functions, except they are used for
    hyperbolas instead of circles.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'The `erf(x)` function returns the error function, that is, the Gauss error
    function, at `x`. This is used to calculate statistical functions such as the
    cumulative standard normal distribution, as demonstrated at [https://docs.python.org/3/library/math.html](https://docs.python.org/3/library/math.html):'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[![](img/d2ef31b2-81d0-4086-8570-cc6481cb1aaf.png)](https://docs.python.org/3/library/math.html)'
  prefs: []
  type: TYPE_NORMAL
- en: 'The `erfc(x)` function returns the complementary error function at `x`*,* which
    is defined as `1.0 - erf(x)`. This is used for large values of `x` where subtraction
    would cause a loss in significance:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/b54c5f86-dbfd-4e88-b88a-ed188e7e4149.png)'
  prefs: []
  type: TYPE_IMG
- en: 'The `gamma(x)` function returns the Gamma function at `x`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/50e2a711-bbcc-4650-8a67-2fdc36dd5596.png)'
  prefs: []
  type: TYPE_IMG
- en: 'The `lgamma(x)` function returns the natural log of the absolute value of the
    Gamma function at `x`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/2ce28ad0-306b-458e-8cda-56d655d06621.png)'
  prefs: []
  type: TYPE_IMG
- en: The `pi` represents the value of Pi (3.14...) to the operating system's available
    precision.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The `e` represents the value of Euler's number (2.718...) to the system's available
    precision.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The `tau` represents the constant `2pi` (6.28...) to the system's available
    precision.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The `inf` represents the float type `∞`. `- ∞` is represented by `-inf`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The `nan` represents the float type `not a number`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Working with complex numbers
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Because complex numbers, that is, numbers that have an imaginary element, cannot
    be used with the regular math module functions, the `cmath` module is available
    for these special numbers.
  prefs: []
  type: TYPE_NORMAL
- en: As a built-in module, it is always available for import. Of note, the functions
    accept integers, floats, and complex numbers as arguments. They will also accept
    any Python object that has a `__complex__()` or `__float__()` method as part of
    its class.
  prefs: []
  type: TYPE_NORMAL
- en: On systems that support signed zeros, branch cuts ([https://en.wikipedia.org/wiki/Branch_point#Branch_cuts](https://en.wikipedia.org/wiki/Branch_point#Branch_cuts))
    are continuous on both sides of the cut, as the sign of the zero designates which
    side of the cut the branch is on. On systems that do not support signed zeros,
    continuity is noted for the specific functions in the next section.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The following functions and constants operate like their normal math cousins,
    except where noted:'
  prefs: []
  type: TYPE_NORMAL
- en: '`exp(x)`: Calculate math constant `e` to the power of `x`.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`log(x[, base])`: There is one branch cut—from `0`, along the negative real
    axis to `-∞`, and continuous from above.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`log10(x)`: Same branch cut as `log`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`sqrt(x)`: Same branch cut as `log`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`acos(x)`: Two branch cuts—one from `1` to the right along the real axis to `∞` and
    continuous from below. The other extends left from `-1` to `-∞` and is continuous
    from above.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`asin(x)`: Same branch cuts as `acos`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`atan(x)`: Two branch cuts: one from `1j` along the imaginary axis to `∞j`,
    continuous from the right. The other extends from `*-*1j` to `-∞j` and continuous
    from the left.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`cos(x)`: Calculate the cosine of `x`.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`sin(x)`: Calculate the sine of `x`.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`tan(x)`: Calculate the tangent of `x`.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`acosh(x)`: One branch cut from `1` to the left along the real axis to  `-∞`,
    continuous from above.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`asinh(x)`: Two cuts—one from `1j` along the imaginary axis to `∞j` and continuous
    from the right. The other is from `-1j` along the imaginary axis to `-∞j` and
    continuous from the left.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`atanh(x)`: Two cuts—one from 1 to real `∞`, continuous from above. The other
    is from `-1` to real `-∞`, continuous from above.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`cosh(x)`: Calculate the hyperbolic cosine of `x`.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`sinh(x)`: Calculate the hyperbolic sine of `x`.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`tanh(x)`: Calculate the hyperbolic tangent of `x`.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`pi`: Return the math constant π as a number.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`e`: Return the math constant *e* as a number.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`tau`: Return the math constant τ as a number.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`inf`: Represent the floating-point value `∞`.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`nan`: Represent the floating-point value "not a number".'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'New constants in the `cmath` module include the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '`infj`: Constant complex number with 0 real part and `∞j` imaginary part'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`nanj`: Constant complex number with 0 real part and `NaN` imaginary part'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Polar coordinates are supported within the `cmath` module. In Python, `z` represents
    the real part `z.real` and the imaginary part `z.imag`. Using polar coordinates,
    `z` is defined by the modulus `r` and the phase angle `φ` (phi):'
  prefs: []
  type: TYPE_NORMAL
- en: 'The `phase(x)` function returns the phase of `x` (provided as a complex number);
    the returned value is a float. The result is within the range of -π and  π  and
    the branch cut is along the negative real axis, continuous from above:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '![](img/de2234e7-f2a8-408f-a156-d9c957864649.png)'
  prefs: []
  type: TYPE_IMG
- en: 'The `polar(x)` function returns the phase of `x` in polar coordinates as a
    `(r, φ)` pair:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '![](img/dceef515-6388-469d-a45a-fc74fd55584e.png)'
  prefs: []
  type: TYPE_IMG
- en: 'The `rect(r, phi)` function returns the complex number `x` as a (real, imag)
    pair:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '![](img/c6179529-18e2-4fd9-8fa8-102cc44ba119.png)'
  prefs: []
  type: TYPE_IMG
- en: Improving decimal numbers
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Python''s built-in decimal module provides improved support for fast, precise
    floating point calculations. Normal float types are based on binary objects; decimal
    floats are completely different. Specifically, it improves on the normal float
    type by doing the following:'
  prefs: []
  type: TYPE_NORMAL
- en: Operating like people learned in school, rather than forcing people to conform
    to a new arithmetic paradigm.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Representing decimal values exactly, rather than having results such as the
    following:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '![](img/a1e727dc-27d1-4623-98b6-4c4307edf154.png)'
  prefs: []
  type: TYPE_IMG
- en: Ensuring the exactness of decimal values is carried through calculations, preventing
    rounding errors from compounding.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Accounting for significant digits, for example, 1.20 + 2.10 = 3.20, not 3.2,
    and 1.20 * 1.30 = 1.5600.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Allowing for user-specified precision, up to 28 places. This is different from
    float, which is dependent upon the platform.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Normal, binary float types only have a small portion of their capabilities exposed
    to the user. Decimal floats expose all required parts of the standard, allowing
    full control of all calculations.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Supporting both exact, fixed-point arithmetic and rounded, floating-point arithmetic.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Three main concepts apply to decimal floats: the decimal number itself, arithmetic
    context, and signal handling. Decimal numbers are immutable, signed, and significant,
    that is, trailing zeros aren''t truncated. Arithmetic context specifies things
    such as precision, rounding, exponent limits, and so on. Signals are exceptional
    conditions and are handled depending on the application needs.'
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Because the official documentation ([https://docs.python.org/3/library/decimal.html](https://docs.python.org/3/library/decimal.html))
    comprises more than 35 pages, this section will only provide a brief examination
    of the decimal module:'
  prefs: []
  type: TYPE_NORMAL
- en: 'When using the decimal module, it is a good idea to figure out what the current
    conditions are and modify them, if needed:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/44dc0684-7f2a-4506-a547-753e9d810fb2.png)'
  prefs: []
  type: TYPE_IMG
- en: 'In this case, `getcontext` tells us the following:'
  prefs: []
  type: TYPE_NORMAL
- en: The system is set for 28 places of precision.
  prefs:
  - PREF_OL
  - PREF_UL
  type: TYPE_NORMAL
- en: Rounding is to the nearest whole value with ties going to the nearest even integer.
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: Emin and Emax are the bottom/top limits allowed for exponents.
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: Capital letters are used for designating exponents, for example, *1.2E+12*.
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: Clamping is set to allow exponents to be adjusted to, at most, `Emax`.
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: Flags monitor for exceptional conditions and remain until explicitly cleared.
    This is one reason why checking the context is one of the first things to do,
    to ensure no undesired flags are still set.
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: Traps capture the designated conditions and raise errors when they occur.
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Decimals can be created from integers, floats, strings, or tuples:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/0e3acda8-0984-4677-8253-9ac16655da0f.png)'
  prefs: []
  type: TYPE_IMG
- en: 'One signal worth using is `FloatOperation`, as it will warn when mixing decimals
    and floats in constructors or ordering comparisons:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/d7310cb7-c73f-438b-8c4f-76569b8d29a9.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Decimal point significance, when declaring a new `Decimal`, is determined only
    by the number of digits provided. Rounding and precision only applies during arithmetic
    operations:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/68f52ad6-e9c2-4d0b-bd08-1db884c16704.png)'
  prefs: []
  type: TYPE_IMG
- en: Notice that a precision value of 4 means only four digits will be displayed,
    regardless of how many values after the decimal point are provided.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here''s a brief example of how decimal objects interact with other Python objects:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/68dc6cb8-3284-46fd-8c3d-4d298595c9df.png)'
  prefs: []
  type: TYPE_IMG
- en: Increasing accuracy with fractions
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The `fractions` module adds support for rational number arithmetic to Python.
    Rather than using *x/y* to represent a fraction, true, precise fractions can be
    written; the former method returns a float type which may or not not be truly
    accurate.
  prefs: []
  type: TYPE_NORMAL
- en: A constructor is available to create a fraction from integer pairs, from another
    fraction, a float, a decimal, or a string. If the denominator is 0, a `ZeroDivisionError`
    is generated.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The following properties and methods are available for the fractions class:'
  prefs: []
  type: TYPE_NORMAL
- en: '`numerator`: This returns the numerator in the lowest term.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`denominator`: This returns the denominator in the lowest term.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`from_float(float)`: This is constructor that takes a float type and creates
    a fraction representing the exact value of the argument. It''s generally easier
    to just make a fraction instance directly from a float.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`from_decimal(dec)`: This is a constructor that takes a decimal instance and
    creates a fraction representing the exact value of the argument. It''s generally
    easier to just make a fraction instance directly from a decimal instance.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`limit_denominator(max=1000000)`: This returns the closest fraction to the
    argument that has a denominator no greater than `max`. It is useful for approximating
    floats.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`__floor__()`: This returns the greatest integer `<=` the fraction. It is also
    available via `math.floor()`.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`__ceil__()`: This returns the least integer `>=` the fraction. It is also
    available via `math.ceil()`.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`__round__(); __round__(n)`: The first method returns the integer closest to
    the fraction, rounding half to even. The second method rounds the fraction to
    the nearest multiple of `Fraction(1, 10**n)`, rounding half to even. It is also
    available via `round()`.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`gcd(a, b)`: This returns the greatest common divisor of the two arguments.
    It has been deprecated since `v3.5` in lieu of `math.gcd()`.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The following screenshot shows some use cases for the fraction module:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/bee692e2-53e5-4bab-ac32-c55a74c0f267.png)'
  prefs: []
  type: TYPE_IMG
- en: Working with random numbers
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The math-oriented `random` module utilizes a **pseudo-random number generator**
    (**PRNG**) for use in various applications. It is designed for modeling and simulation
    purposes and should not be used for any security or cryptography programs.
  prefs: []
  type: TYPE_NORMAL
- en: PRNGs use a seed value as an argument to the generator. This allows for re-creation
    of randomized scenarios or determining what random value will be generated next
    in a sequence; hence, they are not cryptographically secure. A common application
    of a PRNG is in security key fobs; the PRNG in the fob is provided with the same
    seed value as on the server. Thus, the server and the fob will have the same number
    available at the exact same time, allowing a user to input the number as a second
    form of authentication.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Note that examples are provided where output is generated for a command. Also
    note that, as these are randomized values, your results may be different:'
  prefs: []
  type: TYPE_NORMAL
- en: The `seed(a=None, version=2)` function initializes the PRNG. If `a` is `None`,
    any system-based randomness sources that are available will be used to generate
    the seed; otherwise, the current system time is used for the seed value. If `a`
    is an integer, then it will be used directly as the seed value.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`version` can be 1 or 2\. The default is 2, meaning strings, bytes, and bytearrays
    will be converted to integers and all bits will be used for the seed. If version
    1 is used (necessary when working with versions prior to 3.2), the conversion
    to integer creates a smaller range of seed values.'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: The `getstate()` function returns an object that captures the internal state
    of the PRNG.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The `setstate(state)` function restores the internal generator state to the
    value of `state`. Used in conjunction with `getstate`, this allows for setting
    the PRNG to a previous condition.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The `getrandbits(k)` function returns an integer comprised of `k` random bits:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '![](img/d38f8e4a-fb80-4855-a002-72f1e967b049.png)'
  prefs: []
  type: TYPE_IMG
- en: 'The `randrange(stop); randrange(start, stop[, step])` function returns a randomly
    selected value from a range of numbers; essentially, it turns the `range` function
    into a random-number picker, limited to the integer range it generates:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '![](img/3a7a33d2-ea39-489c-9e2f-fd6f585f1bde.png)'
  prefs: []
  type: TYPE_IMG
- en: 'The `randint(a, b)` function returns a random integer that is between `a` and
    `b`, inclusive:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '![](img/2d5ef35d-8e29-42d7-8e65-304a24ade43a.png)'
  prefs: []
  type: TYPE_IMG
- en: The `choice(seq)` function returns a random element from a pre-made sequence.
    Whereas `randrange` creates a range of numbers; if the sequence argument is empty,
    an error will be generated.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The `choices(population, weights=None, *, cum_weights=None, k=1)` function returns
    a `k`-sized list of elements, selected from a pre-made `population` with replacement.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`weights` allows selection based on relative weights of a `weights` sequence,
    whereas `cum_weights` makes selections based on the cumulative weights of a sequence.
    If neither argument is provided, then selections are based using equal probability.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`shuffle(x[, random])` function shuffles a provided sequence in place. The `random` function
    is actually a function that returns a random float; by default it is the function
    `random()`.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`sample(population, k)` function returns a `k`-length list of unique elements
    from a provided sequence or set; it provides for random sampling without replacement.
    It returns a new list with elements from the original sequence without affecting
    the original.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`random()` function returns a random float in the range from 0.0 (inclusive)
    to 1.0 (exclusive).'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`uniform(a, b)` function returns a random float between the values of `a` and
    `b`, inclusive.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`triangular(low, high, mode)` function returns a random float between `low`
    (default = 0) and `high` (default = 1), with the specified `mode` (default = midpoint).'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`betavariate(alpha, beta)` function creates a beta distribution, based on `alpha`
    and `beta` both > 0\. Values returned are between 0 and 1.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`expovariate(lambd)` function creates an exponential distribution. `lambd`
    is 1.0 divided by the desired mean and should be non-zero. Values returned are
    0 to ∞ if `lambd` is positive and - ∞  to 0 if negative.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`gammavariate(alpha, beta)` function creates a Gamma distribution, based on
    `alpha` and `beta` both > 0.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`gauss(mu, sigma)` function creates a Gaussian distribution (bell curve); `mu`
    is the mean and `sigma` the standard deviation. This function is faster than `normalvariate()`,
    but only slightly because it is not thread-safe.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`lognormvariate(mu, sigma)` function creates a log-normal distribution; `mu`
    can be any value but `sigma` must be > 0.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`normalvariate(mu, sigma)` function creates a normal distribution; `mu` is
    the mean and `sigma` the standard deviation. This is thread-safe to avoid race
    conditions.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`vonmisesvariate(mu, kappa)` function creates a **bivariate von Mises** (**BVM**)
    distribution to describe values on a torus; `mu` is the mean angle, expressed
    in radians between 0 and 2*π, and `kappa` is the concentration parameter, which
    is >= 0\. If `kappa` = 0, this distribution reduces to a uniform random angle
    over the range 0 to 2* π .'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`paretovariate(alpha)` function creates a Pareto distribution; `alpha` is a
    shape parameter.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`weibullvariate(alpha, beta)` function creates a Weibull distribution; `alpha`
    is a scale parameter and `beta` is the shape parameter.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`SystemRandom([seed])` function uses `os.urandom()` to create random numbers
    from OS sources but is not available on all systems. As it is not software based,
    the results are not reproducible, that is, this is for truly random numbers, such
    as for cryptography.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The following screenshot contains examples of how some of the `random` functions
    operate:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/b5aedf4c-2311-4d53-954e-920637357515.png)'
  prefs: []
  type: TYPE_IMG
- en: Using the secrets module
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: This module, while not part of the math set, is important because it makes random
    numbers that are cryptographically secure. Thus, we will look at how this module
    differs from the random module.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '`SystemRandom` class is the same as the `random.SystemRandom` class, that is,
    it provides random numbers and uses the best quality random seeding sources of
    the system.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`choice(sequence)` method also works just like the `random.choice()` method.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`randbelow(n)` function returns a random integer in the range `[0, n)`.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`randbits(k)` method returns an integer with `k` random bits.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`token_bytes([nbytes=None])` function returns a random byte string. If `nbytes`
    is not provided, a reasonable default is used; if provided, the returned string
    contains that many bytes.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`token_hex([nbytes=None])` function returns a random text string in hex. The
    bytes used in the string are converted to two hex digits each.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`token_urlsafe([nbytes=None])` function returns a random, URL-safe text string
    of random bytes. The string is Base64-encoded, so the average byte returned is
    roughly 1.3 characters.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`compare_digest(a, b)` function returns `True` if the arguments are equal and
    `False` if not. The functionality is such that the ability to use timing attacks
    is reduced.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Here are some examples using parts of the `secrets` module:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '![](img/fc2578ee-cd83-47f7-8503-d52f19441a64.png)'
  prefs: []
  type: TYPE_IMG
- en: The *line 3* creates a string of all the letters in the ASCII alphabet and all
    digits.
  prefs:
  - PREF_UL
  - PREF_UL
  type: TYPE_NORMAL
- en: The *line 4* creates a simple password of 12 characters, using all the available
    alphanumeric values the previous string.
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: The *line 6* creates a more complex password, comprising at least one uppercase
    letter, a lowercase letter, and at least five digits.
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: The *line 8* creates a token that is sufficiently strong to be used for password
    recovery/reset on a website.
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: Implementing basic statistics
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Starting in version 3.4, basic statistical tools were provided to Python. While
    nowhere near as comprehensive as NumPy, SciPy, Pandas, or the like, they are useful
    when having to perform simple calculations and not wanting, or having access to,
    advanced numeric modules.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Note that the `import` statement is omitted in the following screenshots:'
  prefs: []
  type: TYPE_NORMAL
- en: 'The `mean(data)` function returns the normal average of a sequence or iterator:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/03717de8-6f3d-41cc-be1d-c3f6fafd50cf.png)'
  prefs: []
  type: TYPE_IMG
- en: The *line 3* is the mean of integers.
  prefs:
  - PREF_UL
  - PREF_UL
  type: TYPE_NORMAL
- en: The *line 4* is the mean of floats.
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: The *lines 6* and *line 8* show that fractions can be averaged, as well as decimals.
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: The `harmonic_mean(data)` function returns the harmonic average of a sequence
    or iterator. The harmonic mean is the reciprocal of the arithmetic `mean` of the
    reciprocals of the argument and is typically used when the average of rates or
    rations is needed.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'For example, if a car traveled for a given distance at 60 mph, then the same
    distance back at 50 mph, its average speed would be the harmonic mean of 60 and
    50, that is, 2/(1/60 + 1/50) = 54.5 mph:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/a00fd5fd-9ff5-4379-9922-537b11aa24a7.png)'
  prefs: []
  type: TYPE_IMG
- en: 'This is very close to the regular mean of 55 mph, so let''s look at a larger
    difference, say 20 mph and 80 mph:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/16c98b68-3700-4c88-8256-528cc0c06f3b.png)'
  prefs: []
  type: TYPE_IMG
- en: The reason the harmonic mean is more appropriate in this example is because
    the normal, arithmetic mean doesn't account for the time required to complete
    the same distance, that is, it takes four times longer to travel a given distance
    at 20 mph compared to 80 mph
  prefs: []
  type: TYPE_NORMAL
- en: If the distance was 120 miles, then it would take six hours to travel at 20
    mph but only one and a half hours at 80 mph. The total distance traveled would
    be 240 miles and the total time would be 7.5 hours. 240 miles/7.5 hours = 32 miles
    per hour.
  prefs: []
  type: TYPE_NORMAL
- en: 'The `median(data)` function returns the middle value of a sequence or iterator:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/ea167712-15df-4ba9-a9f7-b6e5eb7f0c5d.png)'
  prefs: []
  type: TYPE_IMG
- en: The *line 19* demonstrates that the average of the two middle values is returned
    when the number of data points is even.
  prefs:
  - PREF_UL
  - PREF_UL
  type: TYPE_NORMAL
- en: When the number of data points is odd (*line 20*), then the middle value is
    returned.
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The `median_low(data)` function returns the low median of a sequence or iterator.
    It is used when the dataset contains discrete values and it is desired to have
    the returned value be part of the dataset:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/5dfbba1c-bb3f-4ff3-98a8-0a1732cd5568.png)'
  prefs: []
  type: TYPE_IMG
- en: If the dataset is an odd count (*line 21*), the middle value is returned, just
    like a normal median.
  prefs:
  - PREF_UL
  - PREF_UL
  type: TYPE_NORMAL
- en: If the dataset is an even count (*line 22*), then the smaller of two middle
    values is returned.
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The `median_high(data)` function returns the high median of a sequence or iterator.
    It is used when the dataset contains discrete values and it is desired to have
    the returned value be part of the dataset:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/bc1392ef-a449-4b33-be4c-57719548cce1.png)'
  prefs: []
  type: TYPE_IMG
- en: The *line 23* shows the larger of two middle values is returned if the dataset
    is an even number.
  prefs:
  - PREF_UL
  - PREF_UL
  type: TYPE_NORMAL
- en: The *line 24* shows the normal median is returned when there is an odd number
    of values in the data.
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The `median_grouped(data, interval=1)` function returns the median of a group
    of continuous data, using interpolation and calculated at the 50th percentile:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/1ff58166-e437-473a-9556-cf947a55bf07.png)'
  prefs: []
  type: TYPE_IMG
- en: In this screenshot, the groups are 5–15, 15–25, 25–35, and 35–45, with the values
    shown being in the middle of those groups. The middle value is in the 15–25 group
    so it must be interpolated. By adjusting the interval, which adjusts the class
    interval, the interpolated result changes.
  prefs: []
  type: TYPE_NORMAL
- en: 'The `mode(data)` function returns the most common value from `data`, and assumes
    `data` is discrete. It can be used for numeric or non-numeric data:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/222f47ec-3c78-40df-afae-1a46d51d304f.png)'
  prefs: []
  type: TYPE_IMG
- en: The *line 30* shows that if there isn't a single value with the largest count,
    an error will be generated.
  prefs:
  - PREF_UL
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The `pstdev(data, mu=None)` function returns the population standard deviation.
    If `mu` is not provided, the mean of the dataset will be automatically calculated:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/d3dbf7e6-35fb-49a9-927f-e4b9d498c1ac.png)'
  prefs: []
  type: TYPE_IMG
- en: The *line 1* is a basic standard deviation. However, the mean of a dataset can
    be passed into the method so a separate calculation isn't required (*lines 32*-34).
  prefs:
  - PREF_UL
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The `pvariance(data, mu=None)` function returns the variance of a population
    dataset. The same conditions for arguments as in `pstdev` applies. Decimals and
    fractions are supported:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/91b4ab86-d5f7-433b-9cf8-db178b8e5601.png)'
  prefs: []
  type: TYPE_IMG
- en: While `mu` should be the calculated average for the dataset, passing in incorrect
    values may change the results (this also applies to `pstdev`).
  prefs: []
  type: TYPE_NORMAL
- en: The `stdev(data, xbar=None)` function is the same functionality as `pstdev`
    but is designed for use with population samples, rather than entire populations.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The `variance(data, xbar=None)` function provides the same functionality as
    `pvariance` but should only be used with samples rather than populations.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Improving functionality with comath
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: PyPi provides the `comath` module, which adds additional math functionality
    to Python.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The module can be installed using or downloading and installing the wheel package
    or `.tar.gz` file from [https://pypi.python.org/pypi/comath/0.0.3](https://pypi.python.org/pypi/comath/0.0.3):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: How to do it...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Note that not all functions in `comath` are displayed here, as some require
    additional packages such as NumPy, which are beyond the scope of this book, or
    are modified versions of existing `math` functions:'
  prefs: []
  type: TYPE_NORMAL
- en: '`array.percentile(sorted_list, percent [, key=lambda x: x])` function returns
    the desired percentile (as defined by `percent`) from a sorted list of numbers:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/434ffb47-5360-4032-93ad-e9b0687fb215.png)'
  prefs: []
  type: TYPE_IMG
- en: For the list of numbers, *line 4* returns the 10^(th) percentile.
  prefs:
  - PREF_UL
  - PREF_UL
  type: TYPE_NORMAL
- en: The *line 5* returns the 30^(th) percentile.
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: The *line 6* returns the 50^(th) percentile.
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: The *line 7* returns the 75^(th) percentile.
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: The *line 8* returns the 99^(th) percentile.
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '`func.get_smooth_step_function(min_val, max_val, switch_point, smooth_factor)`
    function returns a function that moves smoothly from minimum to maximum values
    when its value increases from a given switch point to infinity.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Graphically, this looks like an S-curve, with the switch point being the middle
    of the curve. An example of use is taking an audio signal and smoothing it to
    reduce the jaggedness and show where the significant peaks are:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/b19ee4fd-783e-42e2-9dfe-0e0b98cfd527.png)'
  prefs: []
  type: TYPE_IMG
- en: The function is defined in line 10.
  prefs:
  - PREF_UL
  - PREF_UL
  type: TYPE_NORMAL
- en: The *line 11* shows that `smooth` is, indeed, a function returned by a function.
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: The *lines 12*-*16* show the values returned for various positions on the graph.
    Near the center, results center around 1.0, while the results from the ends of
    the line are near 0 (minimum end) to near 2 (maximum end).
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '`func.closest_larger_power_of_2(number)` function returns the closest power
    of 2 that is larger than the argument:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/4f6d4a47-3bc6-436e-aa77-d58dc9734709.png)'
  prefs: []
  type: TYPE_IMG
- en: The `metric` module has four metric-related classes that all do similar things.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '`MovingMetricTracker` class creates an object that tracks and computes a moving
    metric value.'
  prefs:
  - PREF_UL
  - PREF_UL
  type: TYPE_NORMAL
- en: '`MovingAverageTracker` class creates an object to track and compute a moving
    average.'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '`MovingVarianceTracker` class creates an object to track and computer a moving
    variance.'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '`MovingPrecisionTracker` class creates an object to track and computes a moving
    precision measure.'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: 'While they all measure different things, the usage is the same, so only one
    will be demonstrated in the following screenshot:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/477b65f1-61a9-427b-9a19-e9941c2dd662.png)'
  prefs: []
  type: TYPE_IMG
- en: Because all the `Moving*Tracker` classes are abstract, all that is necessary
    is to create a new class is simply subclass the desired `comath` class (*line
    35*).
  prefs:
  - PREF_UL
  - PREF_UL
  type: TYPE_NORMAL
- en: Creating an instance (*line 36*) allows access to the abstract class methods
    (*lines 37*-*40*). In this case, we are simply updating a counter as a value changes
    through a computation. In the end, we get back the average over the course of
    the computation.
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '`segment.LineSegment` class is a class that defines a one-dimensional line
    segment. Methods are provided to allow some useful testing of the segment:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/cf360a69-85a5-4670-bb15-e721320aca69.png)'
  prefs: []
  type: TYPE_IMG
- en: The *line 50* shows the instance creation of a line segment. Arguments are the
    endpoints of the segment.
  prefs:
  - PREF_UL
  - PREF_UL
  type: TYPE_NORMAL
- en: The *lines 51* and *line 52* test the `contains()` method, which indicates whether
    a provided argument lies within the boundaries of the segment.
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: The *lines 53* and *line 54* use the `intersection()` method to return a set.
    A sequence is passed in and only those values that are within the boundaries of
    the segment are returned in the set.
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
