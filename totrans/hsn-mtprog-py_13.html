<html><head></head><body>
<div id="sbo-rt-content"><div id="_idContainer113">
<h1 id="_idParaDest-133"><em class="italic"><a id="_idTextAnchor135"/>Chapter 10</em>: Understanding Method Resolution Order of Inheritance</h1>
<p>In this chapter, we will look at the<a id="_idIndexMarker476"/> concept of <strong class="bold">method resolution order</strong> (<strong class="bold">MRO</strong>) in Python 3 and how it works on inheritance.</p>
<p>As the name suggests, MRO is the order in which methods of a class get resolved while calling them in a program. </p>
<p>Throughout this chapter, we will look at understanding the MRO through a few examples, how method resolution can go wrong, and how the current Python 3 implementation handles methods defined in a class. We will be making use of MRO throughout this chapter to understand the behavior of code while inheritance is implemented in Python 3.</p>
<p>Why should we understand MRO? In scenarios where we are using multiple classes in Python code, we need to inherit methods from multiple parent classes or superclasses. Understanding the order in which the methods would get resolved from the existing class to its parent class helps in avoiding incorrect method calls. This in turn helps in avoiding incorrect results in the algorithm of Python code.</p>
<p>In this chapter, we will be taking a look at the following main topics:</p>
<ul>
<li>Understanding the MRO of a class</li>
<li>Understanding the impact of modifying the order of inheritance</li>
<li>Impact of unintended change of order in inheritance</li>
</ul>
<p>By the end of this chapter, you should be able to get an understanding of how methods are resolved in Python class hierarchy, understand how methods are processed in multiple inheritances, and write the methods on your own with the knowledge of how they would get resolved.</p>
<h1 id="_idParaDest-134"><a id="_idTextAnchor136"/>Technical requirements</h1>
<p>The code examples shared in this chapter are available on GitHub under the code for this chapter here: <a href="https://github.com/PacktPublishing/Metaprogramming-with-Python/tree/main/Chapter10">https://github.com/PacktPublishing/Metaprogramming-with-Python/tree/main/Chapter10</a>.</p>
<h1 id="_idParaDest-135"><a id="_idTextAnchor137"/>Understanding the MRO of a class</h1>
<p>In this section, let’s <a id="_idIndexMarker477"/>explore how methods are <a id="_idIndexMarker478"/>resolved in a class that has no inheritance specified within its code. A class by default in Python 3 is inherited by <strong class="source-inline">object</strong>. To understand how MRO works on a class that has no parent class, looking at it in its simplest form is the easiest approach. We will then see how MRO works on a class with single, multiple, and multilevel inheritance. </p>
<p>In this example, let’s create a class for a branch of <em class="italic">ABC Megamart</em> as follows:</p>
<ol>
<li>In the <strong class="source-inline">Branch</strong> class, let’s create attributes for branch ID, street, city, state and ZIP code, product, sales, and invoice. Let’s also create methods such as <strong class="source-inline">get_product</strong> (which returns the product), <strong class="source-inline">get_sales</strong> (which returns sales), and <strong class="source-inline">get_invoice</strong> (which returns the invoice). The following code represents the <strong class="source-inline">Branch</strong> class:<p class="source-code">class Branch:</p><p class="source-code">    def __init__(self, branch_id, branch_street, </p><p class="source-code">                 branch_city, branch_state, </p><p class="source-code">                 branch_zip, product, sales, invoice):</p><p class="source-code">        self.branch_id = branch_id</p><p class="source-code">        self.branch_street = branch_street</p><p class="source-code">        self.branch_city = branch_city</p><p class="source-code">        self.branch_state = branch_state</p><p class="source-code">        self.branch_zip = branch_zip</p><p class="source-code">        self.product = product</p><p class="source-code">        self.sales = sales</p><p class="source-code">        self.invoice = invoice        </p><p class="source-code">    def get_product(self):</p><p class="source-code">        return self.product</p><p class="source-code">    def get_sales(self):</p><p class="source-code">        return self.sales</p><p class="source-code">    def get_invoice(self):</p><p class="source-code">        return self.invoice</p></li>
</ol>
<p>There are five attributes and three methods in the preceding class. The MRO for the preceding<a id="_idIndexMarker479"/> class <a id="_idIndexMarker480"/>can be reviewed by calling a built-in method on the class, known as <strong class="source-inline">mro</strong>. </p>
<ol>
<li value="2">Next, let’s call the <strong class="source-inline">mro</strong> method of the <strong class="source-inline">Branch</strong> class:<p class="source-code">Branch.mro()</p></li>
</ol>
<p>The <strong class="source-inline">mro</strong> of the <strong class="source-inline">Branch</strong> class is represented as follows:</p>
<p class="source-code"><strong class="bold">[__main__.Branch, object]</strong></p>
<p>In the preceding output, we can see that the <strong class="source-inline">Branch</strong> class did not have any explicit definition of a superclass or parent class, and so it is, by default, inherited from the object. </p>
<p>In this section, we understood the concept of MRO along with an example of how to look at the MRO of a class. Now, let’s look further to see how MRO works on a class that has a single parent class or superclass.</p>
<h2 id="_idParaDest-136"><a id="_idTextAnchor138"/>Understanding MRO in single inheritance</h2>
<p>When a <a id="_idIndexMarker481"/>class inherits one parent class or<a id="_idIndexMarker482"/> superclass, it is single inheritance. Let’s look at how methods are resolved in the case of the <strong class="source-inline">Branch</strong> class example when it becomes a parent class:</p>
<ol>
<li value="1">Before proceeding with the creation of the child class, let’s redefine the <strong class="source-inline">Branch</strong> class with suitable methods that can be used for testing this concept:<p class="source-code">class Branch:</p><p class="source-code">    def __init__(self, branch, sales, product):</p><p class="source-code">        self.branch = branch</p><p class="source-code">        self.sales = sales</p><p class="source-code">        self.product = product</p><p class="source-code">    def set_branch(self, value):</p><p class="source-code">        self.branch = value          </p><p class="source-code">  </p><p class="source-code">    def set_sales(self, value):</p><p class="source-code">        self.sales = value            </p><p class="source-code">    def set_product(self, value):</p><p class="source-code">        self.product = value        </p><p class="source-code">    def calc_tax(self):</p><p class="source-code">        branch = self.branch</p><p class="source-code">        product = self.product</p><p class="source-code">        sales = self.sales</p><p class="source-code">        pricebeforetax = sales['purchase_price'] + </p><p class="source-code">                         sales['purchase_price'] * </p><p class="source-code">                         sales['profit_margin']</p><p class="source-code">        finalselling_price = pricebeforetax + </p><p class="source-code">            (pricebeforetax * sales['tax_rate'])</p><p class="source-code">        sales['selling_price'] = finalselling_price</p><p class="source-code">        return branch, product, sales</p></li>
<li>For this example, let’s <a id="_idIndexMarker483"/>create another <a id="_idIndexMarker484"/>class, named <strong class="source-inline">NYC</strong>, which inherits from the <strong class="source-inline">Branch</strong> class:<p class="source-code">class NYC(Branch):</p><p class="source-code">    def __init__(self, intercitybranch):</p><p class="source-code">        self.intercitybranch = intercitybranch</p><p class="source-code">        </p><p class="source-code">    def set_management(self, value):</p><p class="source-code">        self.intercitybranch = value</p><p class="source-code">            </p><p class="source-code">    def calc_tax_nyc(self):</p><p class="source-code">        branch = self.branch</p><p class="source-code">        intercitybranch = self.intercitybranch</p><p class="source-code">        product = self.product</p><p class="source-code">        sales = self.sales</p><p class="source-code">        pricebeforetax = sales['purchase_price'] + </p><p class="source-code">                         sales['purchase_price'] * </p><p class="source-code">                         sales['profit_margin']</p><p class="source-code">        finalselling_price = pricebeforetax + </p><p class="source-code">            (pricebeforetax * (sales['tax_rate'] + </p><p class="source-code">             sales['local_rate']))  </p><p class="source-code">        sales['selling_price'] = finalselling_price</p><p class="source-code">        return branch, intercitybranch, product, </p><p class="source-code">               sales    </p><p class="source-code">NYC.mro()</p></li>
</ol>
<p>In the preceding code, we have the <strong class="source-inline">NYC</strong> class inherited from the <strong class="source-inline">Branch</strong> class, and the <strong class="source-inline">NYC</strong> class has two methods defined. The <strong class="source-inline">set_management</strong> method returns the value stored in <strong class="source-inline">intercitybranch</strong>, and the <strong class="source-inline">calc_tax_nyc</strong> method calculates tax for <strong class="source-inline">NYC</strong>.</p>
<p>The MRO<a id="_idIndexMarker485"/> of <a id="_idIndexMarker486"/>the <strong class="source-inline">NYC</strong> class is represented in the following output:</p>
<p class="source-code"><strong class="bold">[__main__.NYC, __main__.Branch, object]</strong></p>
<p>The methods present in <strong class="source-inline">NYC</strong> will be resolved first, followed by the methods of <strong class="source-inline">Branch</strong> and then the methods of <strong class="source-inline">object</strong>.</p>
<ol>
<li value="3">Let’s look at what happens when a method required by <strong class="source-inline">NYC</strong> is not present in <strong class="source-inline">NYC</strong> but instead defined in its parent class. In the <strong class="source-inline">NYC</strong> class, <strong class="source-inline">calc_tax_nyc</strong> is the method that calculates tax for the <strong class="source-inline">NYC</strong> branch, and this method needs values for attributes such as <strong class="source-inline">branch</strong>, <strong class="source-inline">intercitybranch</strong>, <strong class="source-inline">product</strong>, and <strong class="source-inline">sales</strong>. The value for the <strong class="source-inline">intercitybranch</strong> attribute alone can be set within the <strong class="source-inline">NYC</strong> class using the <strong class="source-inline">set_management</strong> method, whereas the remaining attributes, such as <strong class="source-inline">branch</strong>, <strong class="source-inline">product</strong>, and <strong class="source-inline">sales</strong>, do not have a set method in <strong class="source-inline">NYC</strong>.</li>
<li>Let’s start by creating a variable named <strong class="source-inline">intercitybranch</strong> and defining an instance for <strong class="source-inline">NYC</strong>:<p class="source-code">intercitybranch = {</p><p class="source-code">    }</p><p class="source-code">branch_manhattan = NYC(intercitybranch)</p></li>
<li>Let’s set the value for <strong class="source-inline">intercitybranch</strong> first, and then look at how to deal with the set methods for the remaining attributes:<p class="source-code">branch_manhattan.set_management({'regionalManager' : 'John M',</p><p class="source-code">    'branchManager' : 'Tom H',</p><p class="source-code">    'subbranch_id' : '2021-01' })</p></li>
<li>The set methods required to set <strong class="source-inline">branch</strong>, <strong class="source-inline">product</strong>, and <strong class="source-inline">sales</strong> are available in the parent class of <strong class="source-inline">Branch</strong>. Since the MRO of the <strong class="source-inline">NYC</strong> class is to resolve from <strong class="source-inline">NYC</strong> followed by <strong class="source-inline">Branch</strong> followed by <strong class="source-inline">object</strong>, the set methods of <strong class="source-inline">Branch</strong> can now<a id="_idIndexMarker487"/> be<a id="_idIndexMarker488"/> called by <strong class="source-inline">NYC</strong> to set the values for <strong class="source-inline">branch</strong>, <strong class="source-inline">product</strong>, and <strong class="source-inline">sales</strong> as follows:<p class="source-code">branch = {'branch_id' : 2021,</p><p class="source-code">'branch_street' : '40097 5th Main Street',</p><p class="source-code">'branchBorough' : 'Manhattan',</p><p class="source-code">'branch_city' : 'New York City',</p><p class="source-code">'branch_state' : 'New York',</p><p class="source-code">'branch_zip' : 11007}</p><p class="source-code">product = {'productId' : 100002,</p><p class="source-code">    'productName' : 'WashingMachine',</p><p class="source-code">    'productBrand' : 'Whirlpool'  </p><p class="source-code">}</p><p class="source-code">sales = {</p><p class="source-code">    'purchase_price' : 450,</p><p class="source-code">    'profit_margin' : 0.19,</p><p class="source-code">    'tax_rate' : 0.4,</p><p class="source-code">    'local_rate' : 0.055      </p><p class="source-code">}</p><p class="source-code">branch_manhattan.set_branch(branch)</p><p class="source-code">branch_manhattan.set_product(product)</p><p class="source-code">branch_manhattan.set_sales(sales)</p></li>
<li>Now that the<a id="_idIndexMarker489"/> required<a id="_idIndexMarker490"/> values are set, we are good to call the <strong class="source-inline">calc_tax_nyc</strong> method from the <strong class="source-inline">NYC</strong> class that inherited the <strong class="source-inline">Branch</strong> class:<p class="source-code">branch_manhattan.calc_tax_nyc()</p></li>
<li>The selling price calculated using the tax rate and the other supporting values of <strong class="source-inline">branch</strong>, <strong class="source-inline">product</strong>, and <strong class="source-inline">sales</strong> set using the parent class is represented in the following output:<p class="source-code"><strong class="bold">({'branch_id': 2021,</strong></p><p class="source-code"><strong class="bold">  'branch_street': '40097 5th Main Street',</strong></p><p class="source-code"><strong class="bold">  'branchBorough': 'Manhattan',</strong></p><p class="source-code"><strong class="bold">  'branch_city': 'New York City',</strong></p><p class="source-code"><strong class="bold">  'branch_state': 'New York',</strong></p><p class="source-code"><strong class="bold">  'branch_zip': 11007},</strong></p><p class="source-code"><strong class="bold"> {'regionalManager': 'John M',</strong></p><p class="source-code"><strong class="bold">  'branchManager': 'Tom H',</strong></p><p class="source-code"><strong class="bold">  'subbranch_id': '2021-01'},</strong></p><p class="source-code"><strong class="bold"> {'productId': 100002,</strong></p><p class="source-code"><strong class="bold">  'productName': 'WashingMachine',</strong></p><p class="source-code"><strong class="bold">  'productBrand': 'Whirlpool'},</strong></p><p class="source-code"><strong class="bold"> {'purchase_price': 450,</strong></p><p class="source-code"><strong class="bold">  'profit_margin': 0.19,</strong></p><p class="source-code"><strong class="bold">  'tax_rate': 0.4,</strong></p><p class="source-code"><strong class="bold">  'local_rate': 0.055,</strong></p><p class="source-code"><strong class="bold">  'selling_price': 779.1525})</strong></p></li>
</ol>
<p>In this section, we <a id="_idIndexMarker491"/>looked<a id="_idIndexMarker492"/> at how MRO works in classes that have a single inheritance. Now, let’s look at what happens when a class inherits from two classes.</p>
<h2 id="_idParaDest-137"><a id="_idTextAnchor139"/>Understanding MRO in multiple inheritances</h2>
<p>In this section, we<a id="_idIndexMarker493"/> will look at inheriting <a id="_idIndexMarker494"/>from more than one superclass or parent class and its corresponding MRO. </p>
<p>For this example, let’s create two parent classes, <strong class="source-inline">Product</strong> and <strong class="source-inline">Branch</strong>, as follows:</p>
<ol>
<li value="1">The <strong class="source-inline">Product</strong> class will have a set of attributes followed by a method named <strong class="source-inline">get_product</strong>:<p class="source-code">class Product:</p><p class="source-code">    _product_id = 100902</p><p class="source-code">    _product_name = 'Iphone X'</p><p class="source-code">    _product_category = 'Electronics'</p><p class="source-code">    _unit_price = 700</p><p class="source-code">    </p><p class="source-code">    def get_product(self):</p><p class="source-code">        return self._product_id, self._productName, self._product_category, self._unit_price</p></li>
<li>The <strong class="source-inline">Branch</strong> class will have a set of attributes followed by a method named <strong class="source-inline">get_branch</strong>:<p class="source-code">class Branch:</p><p class="source-code">    _branch_id = 2021</p><p class="source-code">    _branch_street = '40097 5th Main Street'</p><p class="source-code">    _branch_borough = 'Manhattan'</p><p class="source-code">    _branch_city = 'New York City'</p><p class="source-code">    _branch_state = 'New York'</p><p class="source-code">    _branch_zip = 11007</p><p class="source-code">    </p><p class="source-code">    def get_branch(self):</p><p class="source-code">        return self._branch_id, self._branch_street, </p><p class="source-code">            self._branch_borough, self._branch_city, </p><p class="source-code">            self._branch_state, self._branch_zip</p></li>
<li>Let’s next create <a id="_idIndexMarker495"/>a<a id="_idIndexMarker496"/> child class or subclass named <strong class="source-inline">Sales</strong> and inherit from the <strong class="source-inline">Product</strong> and <strong class="source-inline">Branch</strong> classes. <strong class="source-inline">Sales</strong> will have one attribute date and a <strong class="source-inline">get_sales</strong> method:<p class="source-code">class Sales(Product, Branch):</p><p class="source-code">    date = '08/02/2021'</p><p class="source-code">    def get_sales(self):</p><p class="source-code">        return self.date, Product.get_product(self), </p><p class="source-code">               Branch.get_branch(self)</p></li>
<li>The <strong class="source-inline">Sales</strong> class inherits <strong class="source-inline">Product</strong> followed by <strong class="source-inline">Branch</strong>:<p class="source-code">Sales.mro()</p></li>
<li>Let’s look at the order of its method resolution:<p class="source-code"><strong class="bold">[__main__.Sales, __main__.Product, __main__.Branch, object]</strong></p></li>
</ol>
<p>In the preceding output, the methods are resolved in the order of <strong class="source-inline">Sales</strong> followed by <strong class="source-inline">Product</strong> followed by <strong class="source-inline">Branch</strong> followed by <strong class="source-inline">object</strong>. If a method called by an object of the <strong class="source-inline">Sales</strong> class is not present in <strong class="source-inline">Sales</strong>, the MRO algorithm searches for it within the <strong class="source-inline">Product</strong> class followed by the <strong class="source-inline">Branch</strong> class.</p>
<ol>
<li value="6">Let’s create<a id="_idIndexMarker497"/> another<a id="_idIndexMarker498"/> class (named <strong class="source-inline">Invoice</strong>) and inherit both <strong class="source-inline">Branch</strong> and <strong class="source-inline">Product</strong> in an order that's different from the inheritance of the <strong class="source-inline">Sales</strong> class:<p class="source-code">class Invoice(Branch, Product):</p><p class="source-code">    date = '08/02/2021'</p><p class="source-code">    def get_invoice(self):</p><p class="source-code">        return self.date, Branch.get_branch(self), </p><p class="source-code">               Product.get_product(self)</p></li>
<li>Let’s examine <strong class="source-inline">mro</strong> for the <strong class="source-inline">Invoice</strong> class:<p class="source-code">Invoice.mro()</p></li>
<li>The <strong class="source-inline">mro</strong> for the <strong class="source-inline">Invoice</strong> class is represented in the following output:<p class="source-code"><strong class="bold">[__main__.Invoice, __main__.Branch, __main__.Product, object]</strong></p></li>
</ol>
<p>In the preceding output, the methods are resolved in the order of <strong class="source-inline">Invoice</strong> followed by <strong class="source-inline">Branch</strong> followed by <strong class="source-inline">Product</strong> followed by <strong class="source-inline">object</strong>. If a method called by an object of the <strong class="source-inline">Invoice</strong> class is not present in <strong class="source-inline">Invoice</strong>, the MRO algorithm searches for it within the <strong class="source-inline">Branch</strong> class followed by the <strong class="source-inline">Product</strong> class.</p>
<p>In the case of multiple inheritances, we reviewed how the order of method resolution changes when the <a id="_idIndexMarker499"/>order <a id="_idIndexMarker500"/>of inheriting superclasses or parent classes changes in Python 3.</p>
<p>Now, let’s look at what happens to MRO in the case of multilevel inheritance.</p>
<h2 id="_idParaDest-138"><a id="_idTextAnchor140"/>Reviewing MRO in multilevel inheritance</h2>
<p>Classes in Python <a id="_idIndexMarker501"/>can also inherit from <a id="_idIndexMarker502"/>superclasses at multiple levels, and the MRO gets more complicated as the number of superclasses or parent classes increases. In this section, let’s look at the order of method resolution for such multiple inheritances with a few more examples. </p>
<p>In this example, we will perform the following steps:</p>
<ol>
<li value="1">Let’s first create a class named <strong class="source-inline">StoreCoupon</strong>, where we will be defining attributes for a store such as product name, product category, the brand of the product, store name where the product is sold, expiry date of the product, and quantity to be purchased to get a coupon. </li>
<li>We will then define a method named <strong class="source-inline">generate_coupon</strong>, where we will be generating two coupons for the product with random coupon ID values and all the details of the product and its store:<p class="source-code">class StoreCoupon:</p><p class="source-code">    productName = "Strawberry Ice Cream"</p><p class="source-code">    product_category = "Desserts"</p><p class="source-code">    brand = "ABCBrand3"</p><p class="source-code">    store = "Los Angeles Store"</p><p class="source-code">    expiry_date = "10/1/2021"</p><p class="source-code">    quantity = 10</p><p class="source-code">    </p><p class="source-code">    def generate_coupon(self):</p><p class="source-code">        import random</p><p class="source-code">        coupon_id =  random.sample(range(</p><p class="source-code">                     100000000000,900000000000),2)</p><p class="source-code">        for i in coupon_id:</p><p class="source-code">            print('***********------------------**************')</p><p class="source-code">            print('Product:', self.productName)</p><p class="source-code">            print('Product Category:', </p><p class="source-code">                   self.product_category)</p><p class="source-code">            print('Coupon ID:', i)</p><p class="source-code">            print('Brand:', self.brand)</p><p class="source-code">            print('Store:', self.store)</p><p class="source-code">            print('Expiry Date:', self.expiry_date)</p><p class="source-code">            print('Quantity:', self.quantity)</p><p class="source-code">            print('***********------------------</p><p class="source-code">                   **************')</p></li>
<li>Let’s now<a id="_idIndexMarker503"/> define <a id="_idIndexMarker504"/>a class, <strong class="source-inline">SendStoreCoupon</strong>, that inherits <strong class="source-inline">StoreCoupon</strong> and does not add any methods or attributes to it:<p class="source-code">class SendStoreCoupon(StoreCoupon):</p><p class="source-code">    pass</p><p class="source-code">SendStoreCoupon.mro()</p></li>
<li>The MRO of this class is represented in the following output:<p class="source-code"><strong class="bold">[__main__.SendStoreCoupon, __main__.StoreCoupon, object]</strong></p></li>
<li>The methods in <strong class="source-inline">SendStoreCoupon</strong> are resolved first, followed by the methods in the <strong class="source-inline">StoreCoupon</strong> class, followed by <strong class="source-inline">object</strong>.</li>
<li>Let’s add one more level of inheritance by defining another class, named <strong class="source-inline">SendCoupon</strong>, and inheriting it from the <strong class="source-inline">SendStoreCoupon</strong> classes: <p class="source-code">class SendCoupon(SendStoreCoupon):</p><p class="source-code">    pass</p><p class="source-code">SendCoupon.mro()</p></li>
<li>The MRO of this<a id="_idIndexMarker505"/> class<a id="_idIndexMarker506"/> is represented in the following output:<p class="source-code"><strong class="bold">[__main__.SendCoupon,</strong></p><p class="source-code"><strong class="bold">  __main__.SendStoreCoupon,</strong></p><p class="source-code"><strong class="bold"> __main__.StoreCoupon,</strong></p><p class="source-code"><strong class="bold"> object]</strong></p></li>
<li>In the preceding output, the methods are resolved from <strong class="source-inline">SendCoupon</strong> followed by <strong class="source-inline">SendStoreCoupon</strong> followed by <strong class="source-inline">StoreCoupon</strong> followed by <strong class="source-inline">object</strong>. </li>
<li>Let’s create an object for the <strong class="source-inline">SendCoupon</strong> class and call the <strong class="source-inline">generate_coupon</strong> method:<p class="source-code">coupon = SendCoupon()</p><p class="source-code">coupon.generate_coupon()</p></li>
<li>The <strong class="source-inline">SendCoupon</strong> class does not have a definition for the <strong class="source-inline">generate_coupon</strong> method and so, as per the MRO, the parent class or superclass’ <strong class="source-inline">SendStoreCoupon</strong> method<a id="_idIndexMarker507"/> will <a id="_idIndexMarker508"/>be called, as in the following output:<p class="source-code"><strong class="bold">***********------------------**************</strong></p><p class="source-code"><strong class="bold">Product: Strawberry Ice Cream</strong></p><p class="source-code"><strong class="bold">Product Category: Desserts</strong></p><p class="source-code"><strong class="bold">Coupon ID: 532129664296</strong></p><p class="source-code"><strong class="bold">Brand: ABCBrand3</strong></p><p class="source-code"><strong class="bold">Store: Los Angeles Store</strong></p><p class="source-code"><strong class="bold">Expiry Date: 10/1/2021</strong></p><p class="source-code"><strong class="bold">Quantity: 10</strong></p><p class="source-code"><strong class="bold">***********------------------**************</strong></p><p class="source-code"><strong class="bold">***********------------------**************</strong></p><p class="source-code"><strong class="bold">Product: Strawberry Ice Cream</strong></p><p class="source-code"><strong class="bold">Product Category: Desserts</strong></p><p class="source-code"><strong class="bold">Coupon ID: 183336814176</strong></p><p class="source-code"><strong class="bold">Brand: ABCBrand3</strong></p><p class="source-code"><strong class="bold">Store: Los Angeles Store</strong></p><p class="source-code"><strong class="bold">Expiry Date: 10/1/2021</strong></p><p class="source-code"><strong class="bold">Quantity: 10</strong></p><p class="source-code"><strong class="bold">***********------------------**************</strong></p></li>
</ol>
<p>In this example, we<a id="_idIndexMarker509"/> looked at how the <a id="_idIndexMarker510"/>methods are resolved from one level of inheritance to the other. </p>
<p>Now, let’s look further into the impact of modifying the order of inheritance.</p>
<h1 id="_idParaDest-139"><a id="_idTextAnchor141"/>Understanding the importance of modifying the order of inheritance</h1>
<p>In this section, we will <a id="_idIndexMarker511"/>look at inheriting from more than one parent class. We will see what happens to the method resolution when the order of the parent class changes in addition to the <strong class="source-inline">SendStoreCoupon</strong> class that was created in the preceding section:</p>
<ol>
<li value="1">First, we will be creating another class, named <strong class="source-inline">ManufacturerCoupon</strong>, where we will be defining attributes for a manufacturer such as the product name, product category, brand of the product, manufacturer name where the product is sold, expiry date of the product, and quantity to be purchased to get a coupon.</li>
<li>We will then define a method named <strong class="source-inline">generate_coupon</strong>, where we will be generating two coupons for the product with random coupon ID values and all the details of the product and its manufacturer:<p class="source-code">class ManufacturerCoupon:</p><p class="source-code">    productName = "Strawberry Ice Cream"</p><p class="source-code">    product_category = "Desserts"</p><p class="source-code">    brand = "ABCBrand3"</p><p class="source-code">    manufacturer = "ABC Manufacturer"</p><p class="source-code">    expiry_date = "10/1/2021"</p><p class="source-code">    quantity = 10</p><p class="source-code">    </p><p class="source-code">    def generate_coupon(self):</p><p class="source-code">        import random</p><p class="source-code">        coupon_id =  random.sample(range(</p><p class="source-code">                     100000000000,900000000000),2)</p><p class="source-code">        for i in coupon_id:</p><p class="source-code">            print('***********------------------**************')</p><p class="source-code">            print('Product:', self.productName)</p><p class="source-code">            print('Product Category:', </p><p class="source-code">                   self.product_category)</p><p class="source-code">            print('Coupon ID:', i)</p><p class="source-code">            print('Brand:', self.brand)</p><p class="source-code">            print('Manufacturer:', self.manufacturer)</p><p class="source-code">            print('Expiry Date:', self.expiry_date)</p><p class="source-code">            print('Quantity:', self.quantity)</p><p class="source-code">            print('***********------------------</p><p class="source-code">                   **************')</p></li>
<li>Let’s also <a id="_idIndexMarker512"/>define the <strong class="source-inline">SendCoupon</strong> class with two parent classes—<strong class="source-inline">ManufacturerCoupon</strong> and <strong class="source-inline">SendStoreCoupon</strong>:<p class="source-code">class SendCoupon(ManufacturerCoupon,SendStoreCoupon):</p><p class="source-code">    pass</p><p class="source-code">SendCoupon.mro()</p></li>
<li>The MRO of the class is represented in the following output:<p class="source-code"><strong class="bold">[__main__.SendCoupon,</strong></p><p class="source-code"><strong class="bold"> __main__.ManufacturerCoupon,</strong></p><p class="source-code"><strong class="bold"> __main__.SendStoreCoupon,</strong></p><p class="source-code"><strong class="bold"> __main__.StoreCoupon,</strong></p><p class="source-code"><strong class="bold"> object]</strong></p></li>
<li>Let’s further create an object for the class and call the <strong class="source-inline">generate_coupon</strong> method:<p class="source-code">coupon = SendCoupon()</p><p class="source-code">coupon.generate_coupon()</p></li>
<li>The <strong class="source-inline">generate_coupon</strong> method generated coupons for the manufacturer in this example since the first parent that has the <strong class="source-inline">generate_coupon</strong> method definition is <strong class="source-inline">ManufacturerCoupon</strong>. The following coupons are generated from<a id="_idIndexMarker513"/> the <strong class="source-inline">generate_coupon</strong> method:<p class="source-code"><strong class="bold">***********------------------**************</strong></p><p class="source-code"><strong class="bold">Product: Strawberry Ice Cream</strong></p><p class="source-code"><strong class="bold">Product Category: Desserts</strong></p><p class="source-code"><strong class="bold">Coupon ID: 262335232934</strong></p><p class="source-code"><strong class="bold">Brand: ABCBrand3</strong></p><p class="source-code"><strong class="bold">Manufacturer: ABC Manufacturer</strong></p><p class="source-code"><strong class="bold">Expiry Date: 10/1/2021</strong></p><p class="source-code"><strong class="bold">Quantity: 10</strong></p><p class="source-code"><strong class="bold">***********------------------**************</strong></p><p class="source-code"><strong class="bold">***********------------------**************</strong></p><p class="source-code"><strong class="bold">Product: Strawberry Ice Cream</strong></p><p class="source-code"><strong class="bold">Product Category: Desserts</strong></p><p class="source-code"><strong class="bold">Coupon ID: 752333180295</strong></p><p class="source-code"><strong class="bold">Brand: ABCBrand3</strong></p><p class="source-code"><strong class="bold">Manufacturer: ABC Manufacturer</strong></p><p class="source-code"><strong class="bold">Expiry Date: 10/1/2021</strong></p><p class="source-code"><strong class="bold">Quantity: 10</strong></p><p class="source-code"><strong class="bold">***********------------------**************</strong></p></li>
<li>Let’s further change the order of inheritance in the <strong class="source-inline">SendCoupon</strong> class and look at how the methods are resolved: <p class="source-code">class SendCoupon(SendStoreCoupon,ManufacturerCoupon):</p><p class="source-code">    pass</p><p class="source-code">SendCoupon.mro()</p></li>
<li>The MRO of the class is represented in the following output:<p class="source-code"><strong class="bold">[__main__.SendCoupon,</strong></p><p class="source-code"><strong class="bold"> __main__.SendStoreCoupon,</strong></p><p class="source-code"><strong class="bold"> __main__.StoreCoupon,</strong></p><p class="source-code"><strong class="bold"> __main__.ManufacturerCoupon,</strong></p><p class="source-code"><strong class="bold"> object]</strong></p></li>
<li>Let’s further <a id="_idIndexMarker514"/>create an object for the class and call the <strong class="source-inline">generate_coupon</strong> method:<p class="source-code">coupon = SendCoupon()</p><p class="source-code">coupon.generate_coupon()</p></li>
<li>The <strong class="source-inline">generate_coupon</strong> method generated coupons for the store in this example since the first parent that has the <strong class="source-inline">generate_coupon</strong> method definition is <strong class="source-inline">SendStoreCoupon</strong>, which in turn inherits the method from its <strong class="source-inline">StoreCoupon</strong> parent class, as represented in the following output:<p class="source-code"><strong class="bold">***********------------------**************</strong></p><p class="source-code"><strong class="bold">Product: Strawberry Ice Cream</strong></p><p class="source-code"><strong class="bold">Product Category: Desserts</strong></p><p class="source-code"><strong class="bold">Coupon ID: 167466225705</strong></p><p class="source-code"><strong class="bold">Brand: ABCBrand3</strong></p><p class="source-code"><strong class="bold">Store: Los Angeles Store</strong></p><p class="source-code"><strong class="bold">Expiry Date: 10/1/2021</strong></p><p class="source-code"><strong class="bold">Quantity: 10</strong></p><p class="source-code"><strong class="bold">***********------------------**************</strong></p><p class="source-code"><strong class="bold">***********------------------**************</strong></p><p class="source-code"><strong class="bold">Product: Strawberry Ice Cream</strong></p><p class="source-code"><strong class="bold">Product Category: Desserts</strong></p><p class="source-code"><strong class="bold">Coupon ID: 450583881080</strong></p><p class="source-code"><strong class="bold">Brand: ABCBrand3</strong></p><p class="source-code"><strong class="bold">Store: Los Angeles Store</strong></p><p class="source-code"><strong class="bold">Expiry Date: 10/1/2021</strong></p><p class="source-code"><strong class="bold">Quantity: 10</strong></p><p class="source-code"><strong class="bold">***********------------------**************</strong></p></li>
</ol>
<p>In this section, we understood the impact of the order in which a child class resolved the parent classes<a id="_idIndexMarker515"/> or the superclasses.</p>
<p>With this understanding, let’s look at what happens when the inheritance becomes even more complex and where it can lead to errors.</p>
<h1 id="_idParaDest-140"><a id="_idTextAnchor142"/>Impact of unintended change of order in inheritance</h1>
<p>In this section, we <a id="_idIndexMarker516"/>will be looking at examples that demonstrate how important the order of inheritance is to resolve the methods in the case of multilevel inheritance, and what happens when the order changes in one of the parent or superclasses unintentionally.</p>
<p>This is how it works:</p>
<ol>
<li value="1">Let’s start by creating a class named <strong class="source-inline">CommonCounter</strong> that initializes with two attributes, <strong class="source-inline">items</strong> and <strong class="source-inline">name</strong>. Let’s also add two methods to this class, <strong class="source-inline">return_cart</strong> (which returns the items in the cart) and <strong class="source-inline">goto_counter</strong> (which returns the name of the counter). This is how the code looks:<p class="source-code">class CommonCounter():</p><p class="source-code">    def __init__(self,items,name):</p><p class="source-code">        self.items = items</p><p class="source-code">        self.name = name</p><p class="source-code">    def return_cart(self):</p><p class="source-code">        cartItems = []</p><p class="source-code">        for i in self.items:</p><p class="source-code">            cartItems.append(i)</p><p class="source-code">        return cartItems</p><p class="source-code">    def goto_counter(self):</p><p class="source-code">        countername = self.name</p><p class="source-code">        return countername</p><p class="source-code">CommonCounter.mro()</p></li>
<li>The MRO <a id="_idIndexMarker517"/>of the class is represented in the following output:<p class="source-code"><strong class="bold">[__main__.CommonCounter, object]</strong></p></li>
<li>Let’s now create another class, named <strong class="source-inline">CheckItems</strong>, which is also going to be a parent class in multilevel inheritance applied in this section. This class will have one attribute named <strong class="source-inline">item_type</strong> and one method named <strong class="source-inline">review_items</strong> that returns the name of the counter based on the type of items in the cart:<p class="source-code">class CheckItems():</p><p class="source-code">    def __init__(self, item_type = None):</p><p class="source-code">        self.item_type = item_type</p><p class="source-code">    </p><p class="source-code">    def review_items(self, item_type = None):</p><p class="source-code">        veg_cart = ['Vegetables', 'Dairy', 'Fruits']</p><p class="source-code">        if (item_type == 'Electronics'):</p><p class="source-code">            print("Move to Electronics Counter")</p><p class="source-code">        elif (item_type in veg_cart):        </p><p class="source-code">            print("Move to Vege Counter") </p><p class="source-code">CheckItems.mro()</p></li>
<li>The MRO of the class is represented in the following output:<p class="source-code"><strong class="bold">[__main__.CheckItems, object]</strong></p></li>
<li>On the second level of inheritance, let’s create a class named <strong class="source-inline">ElectronicsCounter</strong>, which inherits from the <strong class="source-inline">CommonCounter</strong> and <strong class="source-inline">CheckItems</strong> classes, in<a id="_idIndexMarker518"/> that order:<p class="source-code">class ElectronicsCounter(CommonCounter,CheckItems):</p><p class="source-code">    def __init__(status = None):</p><p class="source-code">        self.status = status</p><p class="source-code">    def test_electronics(self):</p><p class="source-code">        teststatus = []</p><p class="source-code">        for i in self.status:</p><p class="source-code">            teststatus.append(i)</p><p class="source-code">        return teststatus</p><p class="source-code">ElectronicsCounter.mro()</p></li>
<li>The MRO of the class is represented in the following output:<p class="source-code"><strong class="bold">[__main__.ElectronicsCounter,</strong></p><p class="source-code"><strong class="bold"> __main__.CommonCounter,</strong></p><p class="source-code"><strong class="bold"> __main__.CheckItems,</strong></p><p class="source-code"><strong class="bold"> object]</strong></p></li>
<li>On the second level of inheritance, let’s also create a class named <strong class="source-inline">VegeCounter</strong>, which inherits from the <strong class="source-inline">CheckItems</strong> and <strong class="source-inline">CommonCounter</strong> classes, in that order:<p class="source-code">class VegeCounter(CheckItems,CommonCounter):</p><p class="source-code">    def __init__(weights = None):</p><p class="source-code">        self.weights = weights</p><p class="source-code">    def weigh_items(self):</p><p class="source-code">        item_weight = dict(zip(self.items, </p><p class="source-code">                               self.weights))</p><p class="source-code">        return item_weight</p><p class="source-code">VegeCounter.mro()</p></li>
<li>The MRO <a id="_idIndexMarker519"/>of the class is represented in the following output:<p class="source-code"><strong class="bold">[__main__.VegeCounter, </strong></p><p class="source-code"><strong class="bold">__main__.CheckItems, </strong></p><p class="source-code"><strong class="bold">__main__.CommonCounter, </strong></p><p class="source-code"><strong class="bold">object]</strong></p></li>
<li>Let’s now create another class, named <strong class="source-inline">ScanCode</strong>, which inherits the <strong class="source-inline">ElectronicsCounter</strong> and <strong class="source-inline">VegCounter</strong> classes:<p class="source-code">class ScanCode(ElectronicsCounter,VegeCounter):</p><p class="source-code">    pass</p></li>
</ol>
<p>The preceding code results in the following error message:</p>
<div>
<div class="IMG---Figure" id="_idContainer112">
<img alt="Figure 10.1 – MRO error " height="139" src="image/Figure_10.1_B13426.jpg" width="588"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 10.1 – MRO error</p>
<ol>
<li value="10">Even though the MRO of the class is <strong class="source-inline">ScanCode</strong> followed by <strong class="source-inline">ElectronicsCounter</strong> followed by <strong class="source-inline">VegeCounter</strong> followed by <strong class="source-inline">CommonCounter</strong> followed by <strong class="source-inline">CheckItems</strong> followed by <strong class="source-inline">object</strong>, the MROs of the <strong class="source-inline">CommonCounter</strong> and <strong class="source-inline">CheckItems</strong> base classes are reversed. Therefore, the overall class definition throws an error in this scenario. </li>
</ol>
<p>This example demonstrates the impact of unintended change in the order of inheritance. It<a id="_idIndexMarker520"/> is important to ensure that the order of classes is correct while defining classes with multilevel inheritance in Python so that the MRO is consistent for base classes. </p>
<h1 id="_idParaDest-141"><a id="_idTextAnchor143"/>Summary</h1>
<p>In this chapter, we have learned about the concept of method resolution by exploring the MRO method in Python 3. We also inspected the MRO of Python code by implementing different types of inheritance. We understood the impact of MRO by modifying the order of inheritance at various levels for multiple classes from our core example.</p>
<p>Similar to other chapters covered in this book, this chapter explains that the MRO also focuses on metaprogramming and its impact on Python code.</p>
<p>In the next chapter, we will be looking at the concept of dynamic objects, with some other interesting examples.</p>
</div>
<div>
<div id="_idContainer114">
</div>
</div>
</div></body></html>