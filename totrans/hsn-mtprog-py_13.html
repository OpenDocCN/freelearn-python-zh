<html><head></head><body>
<div><div><h1 id="_idParaDest-133"><em class="italic"><a id="_idTextAnchor135"/>Chapter 10</em>: Understanding Method Resolution Order of Inheritance</h1>
<p>In this chapter, we will look at the<a id="_idIndexMarker476"/> concept of <strong class="bold">method resolution order</strong> (<strong class="bold">MRO</strong>) in Python 3 and how it works on inheritance.</p>
<p>As the name suggests, MRO is the order in which methods of a class get resolved while calling them in a program. </p>
<p>Throughout this chapter, we will look at understanding the MRO through a few examples, how method resolution can go wrong, and how the current Python 3 implementation handles methods defined in a class. We will be making use of MRO throughout this chapter to understand the behavior of code while inheritance is implemented in Python 3.</p>
<p>Why should we understand MRO? In scenarios where we are using multiple classes in Python code, we need to inherit methods from multiple parent classes or superclasses. Understanding the order in which the methods would get resolved from the existing class to its parent class helps in avoiding incorrect method calls. This in turn helps in avoiding incorrect results in the algorithm of Python code.</p>
<p>In this chapter, we will be taking a look at the following main topics:</p>
<ul>
<li>Understanding the MRO of a class</li>
<li>Understanding the impact of modifying the order of inheritance</li>
<li>Impact of unintended change of order in inheritance</li>
</ul>
<p>By the end of this chapter, you should be able to get an understanding of how methods are resolved in Python class hierarchy, understand how methods are processed in multiple inheritances, and write the methods on your own with the knowledge of how they would get resolved.</p>
<h1 id="_idParaDest-134"><a id="_idTextAnchor136"/>Technical requirements</h1>
<p>The code examples shared in this chapter are available on GitHub under the code for this chapter here: <a href="https://github.com/PacktPublishing/Metaprogramming-with-Python/tree/main/Chapter10">https://github.com/PacktPublishing/Metaprogramming-with-Python/tree/main/Chapter10</a>.</p>
<h1 id="_idParaDest-135"><a id="_idTextAnchor137"/>Understanding the MRO of a class</h1>
<p>In this section, let’s <a id="_idIndexMarker477"/>explore how methods are <a id="_idIndexMarker478"/>resolved in a class that has no inheritance specified within its code. A class by default in Python 3 is inherited by <code>object</code>. To understand how MRO works on a class that has no parent class, looking at it in its simplest form is the easiest approach. We will then see how MRO works on a class with single, multiple, and multilevel inheritance. </p>
<p>In this example, let’s create a class for a branch of <em class="italic">ABC Megamart</em> as follows:</p>
<ol>
<li>In the <code>Branch</code> class, let’s create attributes for branch ID, street, city, state and ZIP code, product, sales, and invoice. Let’s also create methods such as <code>get_product</code> (which returns the product), <code>get_sales</code> (which returns sales), and <code>get_invoice</code> (which returns the invoice). The following code represents the <code>Branch</code> class:<pre>class Branch:
    def __init__(self, branch_id, branch_street, 
                 branch_city, branch_state, 
                 branch_zip, product, sales, invoice):
        self.branch_id = branch_id
        self.branch_street = branch_street
        self.branch_city = branch_city
        self.branch_state = branch_state
        self.branch_zip = branch_zip
        self.product = product
        self.sales = sales
        self.invoice = invoice        
    def get_product(self):
        return self.product
    def get_sales(self):
        return self.sales
    def get_invoice(self):
        return self.invoice</pre></li>
</ol>
<p>There are five attributes and three methods in the preceding class. The MRO for the preceding<a id="_idIndexMarker479"/> class <a id="_idIndexMarker480"/>can be reviewed by calling a built-in method on the class, known as <code>mro</code>. </p>
<ol>
<li value="2">Next, let’s call the <code>mro</code> method of the <code>Branch</code> class:<pre>Branch.mro()</pre></li>
</ol>
<p>The <code>mro</code> of the <code>Branch</code> class is represented as follows:</p>
<pre><strong class="bold">[__main__.Branch, object]</strong></pre>
<p>In the preceding output, we can see that the <code>Branch</code> class did not have any explicit definition of a superclass or parent class, and so it is, by default, inherited from the object. </p>
<p>In this section, we understood the concept of MRO along with an example of how to look at the MRO of a class. Now, let’s look further to see how MRO works on a class that has a single parent class or superclass.</p>
<h2 id="_idParaDest-136"><a id="_idTextAnchor138"/>Understanding MRO in single inheritance</h2>
<p>When a <a id="_idIndexMarker481"/>class inherits one parent class or<a id="_idIndexMarker482"/> superclass, it is single inheritance. Let’s look at how methods are resolved in the case of the <code>Branch</code> class example when it becomes a parent class:</p>
<ol>
<li value="1">Before proceeding with the creation of the child class, let’s redefine the <code>Branch</code> class with suitable methods that can be used for testing this concept:<pre>class Branch:
    def __init__(self, branch, sales, product):
        self.branch = branch
        self.sales = sales
        self.product = product
    def set_branch(self, value):
        self.branch = value          
  
    def set_sales(self, value):
        self.sales = value            
    def set_product(self, value):
        self.product = value        
    def calc_tax(self):
        branch = self.branch
        product = self.product
        sales = self.sales
        pricebeforetax = sales['purchase_price'] + 
                         sales['purchase_price'] * 
                         sales['profit_margin']
        finalselling_price = pricebeforetax + 
            (pricebeforetax * sales['tax_rate'])
        sales['selling_price'] = finalselling_price
        return branch, product, sales</pre></li>
<li>For this example, let’s <a id="_idIndexMarker483"/>create another <a id="_idIndexMarker484"/>class, named <code>NYC</code>, which inherits from the <code>Branch</code> class:<pre>class NYC(Branch):
    def __init__(self, intercitybranch):
        self.intercitybranch = intercitybranch
        
    def set_management(self, value):
        self.intercitybranch = value
            
    def calc_tax_nyc(self):
        branch = self.branch
        intercitybranch = self.intercitybranch
        product = self.product
        sales = self.sales
        pricebeforetax = sales['purchase_price'] + 
                         sales['purchase_price'] * 
                         sales['profit_margin']
        finalselling_price = pricebeforetax + 
            (pricebeforetax * (sales['tax_rate'] + 
             sales['local_rate']))  
        sales['selling_price'] = finalselling_price
        return branch, intercitybranch, product, 
               sales    
NYC.mro()</pre></li>
</ol>
<p>In the preceding code, we have the <code>NYC</code> class inherited from the <code>Branch</code> class, and the <code>NYC</code> class has two methods defined. The <code>set_management</code> method returns the value stored in <code>intercitybranch</code>, and the <code>calc_tax_nyc</code> method calculates tax for <code>NYC</code>.</p>
<p>The MRO<a id="_idIndexMarker485"/> of <a id="_idIndexMarker486"/>the <code>NYC</code> class is represented in the following output:</p>
<pre><strong class="bold">[__main__.NYC, __main__.Branch, object]</strong></pre>
<p>The methods present in <code>NYC</code> will be resolved first, followed by the methods of <code>Branch</code> and then the methods of <code>object</code>.</p>
<ol>
<li value="3">Let’s look at what happens when a method required by <code>NYC</code> is not present in <code>NYC</code> but instead defined in its parent class. In the <code>NYC</code> class, <code>calc_tax_nyc</code> is the method that calculates tax for the <code>NYC</code> branch, and this method needs values for attributes such as <code>branch</code>, <code>intercitybranch</code>, <code>product</code>, and <code>sales</code>. The value for the <code>intercitybranch</code> attribute alone can be set within the <code>NYC</code> class using the <code>set_management</code> method, whereas the remaining attributes, such as <code>branch</code>, <code>product</code>, and <code>sales</code>, do not have a set method in <code>NYC</code>.</li>
<li>Let’s start by creating a variable named <code>intercitybranch</code> and defining an instance for <code>NYC</code>:<pre>intercitybranch = {
    }
branch_manhattan = NYC(intercitybranch)</pre></li>
<li>Let’s set the value for <code>intercitybranch</code> first, and then look at how to deal with the set methods for the remaining attributes:<pre>branch_manhattan.set_management({'regionalManager' : 'John M',
    'branchManager' : 'Tom H',
    'subbranch_id' : '2021-01' })</pre></li>
<li>The set methods required to set <code>branch</code>, <code>product</code>, and <code>sales</code> are available in the parent class of <code>Branch</code>. Since the MRO of the <code>NYC</code> class is to resolve from <code>NYC</code> followed by <code>Branch</code> followed by <code>object</code>, the set methods of <code>Branch</code> can now<a id="_idIndexMarker487"/> be<a id="_idIndexMarker488"/> called by <code>NYC</code> to set the values for <code>branch</code>, <code>product</code>, and <code>sales</code> as follows:<pre>branch = {'branch_id' : 2021,
'branch_street' : '40097 5th Main Street',
'branchBorough' : 'Manhattan',
'branch_city' : 'New York City',
'branch_state' : 'New York',
'branch_zip' : 11007}
product = {'productId' : 100002,
    'productName' : 'WashingMachine',
    'productBrand' : 'Whirlpool'  
}
sales = {
    'purchase_price' : 450,
    'profit_margin' : 0.19,
    'tax_rate' : 0.4,
    'local_rate' : 0.055      
}
branch_manhattan.set_branch(branch)
branch_manhattan.set_product(product)
branch_manhattan.set_sales(sales)</pre></li>
<li>Now that the<a id="_idIndexMarker489"/> required<a id="_idIndexMarker490"/> values are set, we are good to call the <code>calc_tax_nyc</code> method from the <code>NYC</code> class that inherited the <code>Branch</code> class:<pre>branch_manhattan.calc_tax_nyc()</pre></li>
<li>The selling price calculated using the tax rate and the other supporting values of <code>branch</code>, <code>product</code>, and <code>sales</code> set using the parent class is represented in the following output:<pre><strong class="bold">({'branch_id': 2021,</strong>
<strong class="bold">  'branch_street': '40097 5th Main Street',</strong>
<strong class="bold">  'branchBorough': 'Manhattan',</strong>
<strong class="bold">  'branch_city': 'New York City',</strong>
<strong class="bold">  'branch_state': 'New York',</strong>
<strong class="bold">  'branch_zip': 11007},</strong>
<strong class="bold"> {'regionalManager': 'John M',</strong>
<strong class="bold">  'branchManager': 'Tom H',</strong>
<strong class="bold">  'subbranch_id': '2021-01'},</strong>
<strong class="bold"> {'productId': 100002,</strong>
<strong class="bold">  'productName': 'WashingMachine',</strong>
<strong class="bold">  'productBrand': 'Whirlpool'},</strong>
<strong class="bold"> {'purchase_price': 450,</strong>
<strong class="bold">  'profit_margin': 0.19,</strong>
<strong class="bold">  'tax_rate': 0.4,</strong>
<strong class="bold">  'local_rate': 0.055,</strong>
<strong class="bold">  'selling_price': 779.1525})</strong></pre></li>
</ol>
<p>In this section, we <a id="_idIndexMarker491"/>looked<a id="_idIndexMarker492"/> at how MRO works in classes that have a single inheritance. Now, let’s look at what happens when a class inherits from two classes.</p>
<h2 id="_idParaDest-137"><a id="_idTextAnchor139"/>Understanding MRO in multiple inheritances</h2>
<p>In this section, we<a id="_idIndexMarker493"/> will look at inheriting <a id="_idIndexMarker494"/>from more than one superclass or parent class and its corresponding MRO. </p>
<p>For this example, let’s create two parent classes, <code>Product</code> and <code>Branch</code>, as follows:</p>
<ol>
<li value="1">The <code>Product</code> class will have a set of attributes followed by a method named <code>get_product</code>:<pre>class Product:
    _product_id = 100902
    _product_name = 'Iphone X'
    _product_category = 'Electronics'
    _unit_price = 700
    
    def get_product(self):
        return self._product_id, self._productName, self._product_category, self._unit_price</pre></li>
<li>The <code>Branch</code> class will have a set of attributes followed by a method named <code>get_branch</code>:<pre>class Branch:
    _branch_id = 2021
    _branch_street = '40097 5th Main Street'
    _branch_borough = 'Manhattan'
    _branch_city = 'New York City'
    _branch_state = 'New York'
    _branch_zip = 11007
    
    def get_branch(self):
        return self._branch_id, self._branch_street, 
            self._branch_borough, self._branch_city, 
            self._branch_state, self._branch_zip</pre></li>
<li>Let’s next create <a id="_idIndexMarker495"/>a<a id="_idIndexMarker496"/> child class or subclass named <code>Sales</code> and inherit from the <code>Product</code> and <code>Branch</code> classes. <code>Sales</code> will have one attribute date and a <code>get_sales</code> method:<pre>class Sales(Product, Branch):
    date = '08/02/2021'
    def get_sales(self):
        return self.date, Product.get_product(self), 
               Branch.get_branch(self)</pre></li>
<li>The <code>Sales</code> class inherits <code>Product</code> followed by <code>Branch</code>:<pre>Sales.mro()</pre></li>
<li>Let’s look at the order of its method resolution:<pre><strong class="bold">[__main__.Sales, __main__.Product, __main__.Branch, object]</strong></pre></li>
</ol>
<p>In the preceding output, the methods are resolved in the order of <code>Sales</code> followed by <code>Product</code> followed by <code>Branch</code> followed by <code>object</code>. If a method called by an object of the <code>Sales</code> class is not present in <code>Sales</code>, the MRO algorithm searches for it within the <code>Product</code> class followed by the <code>Branch</code> class.</p>
<ol>
<li value="6">Let’s create<a id="_idIndexMarker497"/> another<a id="_idIndexMarker498"/> class (named <code>Invoice</code>) and inherit both <code>Branch</code> and <code>Product</code> in an order that's different from the inheritance of the <code>Sales</code> class:<pre>class Invoice(Branch, Product):
    date = '08/02/2021'
    def get_invoice(self):
        return self.date, Branch.get_branch(self), 
               Product.get_product(self)</pre></li>
<li>Let’s examine <code>mro</code> for the <code>Invoice</code> class:<pre>Invoice.mro()</pre></li>
<li>The <code>mro</code> for the <code>Invoice</code> class is represented in the following output:<pre><strong class="bold">[__main__.Invoice, __main__.Branch, __main__.Product, object]</strong></pre></li>
</ol>
<p>In the preceding output, the methods are resolved in the order of <code>Invoice</code> followed by <code>Branch</code> followed by <code>Product</code> followed by <code>object</code>. If a method called by an object of the <code>Invoice</code> class is not present in <code>Invoice</code>, the MRO algorithm searches for it within the <code>Branch</code> class followed by the <code>Product</code> class.</p>
<p>In the case of multiple inheritances, we reviewed how the order of method resolution changes when the <a id="_idIndexMarker499"/>order <a id="_idIndexMarker500"/>of inheriting superclasses or parent classes changes in Python 3.</p>
<p>Now, let’s look at what happens to MRO in the case of multilevel inheritance.</p>
<h2 id="_idParaDest-138"><a id="_idTextAnchor140"/>Reviewing MRO in multilevel inheritance</h2>
<p>Classes in Python <a id="_idIndexMarker501"/>can also inherit from <a id="_idIndexMarker502"/>superclasses at multiple levels, and the MRO gets more complicated as the number of superclasses or parent classes increases. In this section, let’s look at the order of method resolution for such multiple inheritances with a few more examples. </p>
<p>In this example, we will perform the following steps:</p>
<ol>
<li value="1">Let’s first create a class named <code>StoreCoupon</code>, where we will be defining attributes for a store such as product name, product category, the brand of the product, store name where the product is sold, expiry date of the product, and quantity to be purchased to get a coupon. </li>
<li>We will then define a method named <code>generate_coupon</code>, where we will be generating two coupons for the product with random coupon ID values and all the details of the product and its store:<pre>class StoreCoupon:
    productName = "Strawberry Ice Cream"
    product_category = "Desserts"
    brand = "ABCBrand3"
    store = "Los Angeles Store"
    expiry_date = "10/1/2021"
    quantity = 10
    
    def generate_coupon(self):
        import random
        coupon_id =  random.sample(range(
                     100000000000,900000000000),2)
        for i in coupon_id:
            print('***********------------------**************')
            print('Product:', self.productName)
            print('Product Category:', 
                   self.product_category)
            print('Coupon ID:', i)
            print('Brand:', self.brand)
            print('Store:', self.store)
            print('Expiry Date:', self.expiry_date)
            print('Quantity:', self.quantity)
            print('***********------------------
                   **************')</pre></li>
<li>Let’s now<a id="_idIndexMarker503"/> define <a id="_idIndexMarker504"/>a class, <code>SendStoreCoupon</code>, that inherits <code>StoreCoupon</code> and does not add any methods or attributes to it:<pre>class SendStoreCoupon(StoreCoupon):
    pass
SendStoreCoupon.mro()</pre></li>
<li>The MRO of this class is represented in the following output:<pre><strong class="bold">[__main__.SendStoreCoupon, __main__.StoreCoupon, object]</strong></pre></li>
<li>The methods in <code>SendStoreCoupon</code> are resolved first, followed by the methods in the <code>StoreCoupon</code> class, followed by <code>object</code>.</li>
<li>Let’s add one more level of inheritance by defining another class, named <code>SendCoupon</code>, and inheriting it from the <code>SendStoreCoupon</code> classes: <pre>class SendCoupon(SendStoreCoupon):
    pass
SendCoupon.mro()</pre></li>
<li>The MRO of this<a id="_idIndexMarker505"/> class<a id="_idIndexMarker506"/> is represented in the following output:<pre><strong class="bold">[__main__.SendCoupon,</strong>
<strong class="bold">  __main__.SendStoreCoupon,</strong>
<strong class="bold"> __main__.StoreCoupon,</strong>
<strong class="bold"> object]</strong></pre></li>
<li>In the preceding output, the methods are resolved from <code>SendCoupon</code> followed by <code>SendStoreCoupon</code> followed by <code>StoreCoupon</code> followed by <code>object</code>. </li>
<li>Let’s create an object for the <code>SendCoupon</code> class and call the <code>generate_coupon</code> method:<pre>coupon = SendCoupon()
coupon.generate_coupon()</pre></li>
<li>The <code>SendCoupon</code> class does not have a definition for the <code>generate_coupon</code> method and so, as per the MRO, the parent class or superclass’ <code>SendStoreCoupon</code> method<a id="_idIndexMarker507"/> will <a id="_idIndexMarker508"/>be called, as in the following output:<pre><strong class="bold">***********------------------**************</strong>
<strong class="bold">Product: Strawberry Ice Cream</strong>
<strong class="bold">Product Category: Desserts</strong>
<strong class="bold">Coupon ID: 532129664296</strong>
<strong class="bold">Brand: ABCBrand3</strong>
<strong class="bold">Store: Los Angeles Store</strong>
<strong class="bold">Expiry Date: 10/1/2021</strong>
<strong class="bold">Quantity: 10</strong>
<strong class="bold">***********------------------**************</strong>
<strong class="bold">***********------------------**************</strong>
<strong class="bold">Product: Strawberry Ice Cream</strong>
<strong class="bold">Product Category: Desserts</strong>
<strong class="bold">Coupon ID: 183336814176</strong>
<strong class="bold">Brand: ABCBrand3</strong>
<strong class="bold">Store: Los Angeles Store</strong>
<strong class="bold">Expiry Date: 10/1/2021</strong>
<strong class="bold">Quantity: 10</strong>
<strong class="bold">***********------------------**************</strong></pre></li>
</ol>
<p>In this example, we<a id="_idIndexMarker509"/> looked at how the <a id="_idIndexMarker510"/>methods are resolved from one level of inheritance to the other. </p>
<p>Now, let’s look further into the impact of modifying the order of inheritance.</p>
<h1 id="_idParaDest-139"><a id="_idTextAnchor141"/>Understanding the importance of modifying the order of inheritance</h1>
<p>In this section, we will <a id="_idIndexMarker511"/>look at inheriting from more than one parent class. We will see what happens to the method resolution when the order of the parent class changes in addition to the <code>SendStoreCoupon</code> class that was created in the preceding section:</p>
<ol>
<li value="1">First, we will be creating another class, named <code>ManufacturerCoupon</code>, where we will be defining attributes for a manufacturer such as the product name, product category, brand of the product, manufacturer name where the product is sold, expiry date of the product, and quantity to be purchased to get a coupon.</li>
<li>We will then define a method named <code>generate_coupon</code>, where we will be generating two coupons for the product with random coupon ID values and all the details of the product and its manufacturer:<pre>class ManufacturerCoupon:
    productName = "Strawberry Ice Cream"
    product_category = "Desserts"
    brand = "ABCBrand3"
    manufacturer = "ABC Manufacturer"
    expiry_date = "10/1/2021"
    quantity = 10
    
    def generate_coupon(self):
        import random
        coupon_id =  random.sample(range(
                     100000000000,900000000000),2)
        for i in coupon_id:
            print('***********------------------**************')
            print('Product:', self.productName)
            print('Product Category:', 
                   self.product_category)
            print('Coupon ID:', i)
            print('Brand:', self.brand)
            print('Manufacturer:', self.manufacturer)
            print('Expiry Date:', self.expiry_date)
            print('Quantity:', self.quantity)
            print('***********------------------
                   **************')</pre></li>
<li>Let’s also <a id="_idIndexMarker512"/>define the <code>SendCoupon</code> class with two parent classes—<code>ManufacturerCoupon</code> and <code>SendStoreCoupon</code>:<pre>class SendCoupon(ManufacturerCoupon,SendStoreCoupon):
    pass
SendCoupon.mro()</pre></li>
<li>The MRO of the class is represented in the following output:<pre><strong class="bold">[__main__.SendCoupon,</strong>
<strong class="bold"> __main__.ManufacturerCoupon,</strong>
<strong class="bold"> __main__.SendStoreCoupon,</strong>
<strong class="bold"> __main__.StoreCoupon,</strong>
<strong class="bold"> object]</strong></pre></li>
<li>Let’s further create an object for the class and call the <code>generate_coupon</code> method:<pre>coupon = SendCoupon()
coupon.generate_coupon()</pre></li>
<li>The <code>generate_coupon</code> method generated coupons for the manufacturer in this example since the first parent that has the <code>generate_coupon</code> method definition is <code>ManufacturerCoupon</code>. The following coupons are generated from<a id="_idIndexMarker513"/> the <code>generate_coupon</code> method:<pre><strong class="bold">***********------------------**************</strong>
<strong class="bold">Product: Strawberry Ice Cream</strong>
<strong class="bold">Product Category: Desserts</strong>
<strong class="bold">Coupon ID: 262335232934</strong>
<strong class="bold">Brand: ABCBrand3</strong>
<strong class="bold">Manufacturer: ABC Manufacturer</strong>
<strong class="bold">Expiry Date: 10/1/2021</strong>
<strong class="bold">Quantity: 10</strong>
<strong class="bold">***********------------------**************</strong>
<strong class="bold">***********------------------**************</strong>
<strong class="bold">Product: Strawberry Ice Cream</strong>
<strong class="bold">Product Category: Desserts</strong>
<strong class="bold">Coupon ID: 752333180295</strong>
<strong class="bold">Brand: ABCBrand3</strong>
<strong class="bold">Manufacturer: ABC Manufacturer</strong>
<strong class="bold">Expiry Date: 10/1/2021</strong>
<strong class="bold">Quantity: 10</strong>
<strong class="bold">***********------------------**************</strong></pre></li>
<li>Let’s further change the order of inheritance in the <code>SendCoupon</code> class and look at how the methods are resolved: <pre>class SendCoupon(SendStoreCoupon,ManufacturerCoupon):
    pass
SendCoupon.mro()</pre></li>
<li>The MRO of the class is represented in the following output:<pre><strong class="bold">[__main__.SendCoupon,</strong>
<strong class="bold"> __main__.SendStoreCoupon,</strong>
<strong class="bold"> __main__.StoreCoupon,</strong>
<strong class="bold"> __main__.ManufacturerCoupon,</strong>
<strong class="bold"> object]</strong></pre></li>
<li>Let’s further <a id="_idIndexMarker514"/>create an object for the class and call the <code>generate_coupon</code> method:<pre>coupon = SendCoupon()
coupon.generate_coupon()</pre></li>
<li>The <code>generate_coupon</code> method generated coupons for the store in this example since the first parent that has the <code>generate_coupon</code> method definition is <code>SendStoreCoupon</code>, which in turn inherits the method from its <code>StoreCoupon</code> parent class, as represented in the following output:<pre><strong class="bold">***********------------------**************</strong>
<strong class="bold">Product: Strawberry Ice Cream</strong>
<strong class="bold">Product Category: Desserts</strong>
<strong class="bold">Coupon ID: 167466225705</strong>
<strong class="bold">Brand: ABCBrand3</strong>
<strong class="bold">Store: Los Angeles Store</strong>
<strong class="bold">Expiry Date: 10/1/2021</strong>
<strong class="bold">Quantity: 10</strong>
<strong class="bold">***********------------------**************</strong>
<strong class="bold">***********------------------**************</strong>
<strong class="bold">Product: Strawberry Ice Cream</strong>
<strong class="bold">Product Category: Desserts</strong>
<strong class="bold">Coupon ID: 450583881080</strong>
<strong class="bold">Brand: ABCBrand3</strong>
<strong class="bold">Store: Los Angeles Store</strong>
<strong class="bold">Expiry Date: 10/1/2021</strong>
<strong class="bold">Quantity: 10</strong>
<strong class="bold">***********------------------**************</strong></pre></li>
</ol>
<p>In this section, we understood the impact of the order in which a child class resolved the parent classes<a id="_idIndexMarker515"/> or the superclasses.</p>
<p>With this understanding, let’s look at what happens when the inheritance becomes even more complex and where it can lead to errors.</p>
<h1 id="_idParaDest-140"><a id="_idTextAnchor142"/>Impact of unintended change of order in inheritance</h1>
<p>In this section, we <a id="_idIndexMarker516"/>will be looking at examples that demonstrate how important the order of inheritance is to resolve the methods in the case of multilevel inheritance, and what happens when the order changes in one of the parent or superclasses unintentionally.</p>
<p>This is how it works:</p>
<ol>
<li value="1">Let’s start by creating a class named <code>CommonCounter</code> that initializes with two attributes, <code>items</code> and <code>name</code>. Let’s also add two methods to this class, <code>return_cart</code> (which returns the items in the cart) and <code>goto_counter</code> (which returns the name of the counter). This is how the code looks:<pre>class CommonCounter():
    def __init__(self,items,name):
        self.items = items
        self.name = name
    def return_cart(self):
        cartItems = []
        for i in self.items:
            cartItems.append(i)
        return cartItems
    def goto_counter(self):
        countername = self.name
        return countername
CommonCounter.mro()</pre></li>
<li>The MRO <a id="_idIndexMarker517"/>of the class is represented in the following output:<pre><strong class="bold">[__main__.CommonCounter, object]</strong></pre></li>
<li>Let’s now create another class, named <code>CheckItems</code>, which is also going to be a parent class in multilevel inheritance applied in this section. This class will have one attribute named <code>item_type</code> and one method named <code>review_items</code> that returns the name of the counter based on the type of items in the cart:<pre>class CheckItems():
    def __init__(self, item_type = None):
        self.item_type = item_type
    
    def review_items(self, item_type = None):
        veg_cart = ['Vegetables', 'Dairy', 'Fruits']
        if (item_type == 'Electronics'):
            print("Move to Electronics Counter")
        elif (item_type in veg_cart):        
            print("Move to Vege Counter") 
CheckItems.mro()</pre></li>
<li>The MRO of the class is represented in the following output:<pre><strong class="bold">[__main__.CheckItems, object]</strong></pre></li>
<li>On the second level of inheritance, let’s create a class named <code>ElectronicsCounter</code>, which inherits from the <code>CommonCounter</code> and <code>CheckItems</code> classes, in<a id="_idIndexMarker518"/> that order:<pre>class ElectronicsCounter(CommonCounter,CheckItems):
    def __init__(status = None):
        self.status = status
    def test_electronics(self):
        teststatus = []
        for i in self.status:
            teststatus.append(i)
        return teststatus
ElectronicsCounter.mro()</pre></li>
<li>The MRO of the class is represented in the following output:<pre><strong class="bold">[__main__.ElectronicsCounter,</strong>
<strong class="bold"> __main__.CommonCounter,</strong>
<strong class="bold"> __main__.CheckItems,</strong>
<strong class="bold"> object]</strong></pre></li>
<li>On the second level of inheritance, let’s also create a class named <code>VegeCounter</code>, which inherits from the <code>CheckItems</code> and <code>CommonCounter</code> classes, in that order:<pre>class VegeCounter(CheckItems,CommonCounter):
    def __init__(weights = None):
        self.weights = weights
    def weigh_items(self):
        item_weight = dict(zip(self.items, 
                               self.weights))
        return item_weight
VegeCounter.mro()</pre></li>
<li>The MRO <a id="_idIndexMarker519"/>of the class is represented in the following output:<pre><strong class="bold">[__main__.VegeCounter, </strong>
<strong class="bold">__main__.CheckItems, </strong>
<strong class="bold">__main__.CommonCounter, </strong>
<strong class="bold">object]</strong></pre></li>
<li>Let’s now create another class, named <code>ScanCode</code>, which inherits the <code>ElectronicsCounter</code> and <code>VegCounter</code> classes:<pre>class ScanCode(ElectronicsCounter,VegeCounter):
    pass</pre></li>
</ol>
<p>The preceding code results in the following error message:</p>
<div><div><img alt="Figure 10.1 – MRO error " height="139" src="img/Figure_10.1_B13426.jpg" width="588"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 10.1 – MRO error</p>
<ol>
<li value="10">Even though the MRO of the class is <code>ScanCode</code> followed by <code>ElectronicsCounter</code> followed by <code>VegeCounter</code> followed by <code>CommonCounter</code> followed by <code>CheckItems</code> followed by <code>object</code>, the MROs of the <code>CommonCounter</code> and <code>CheckItems</code> base classes are reversed. Therefore, the overall class definition throws an error in this scenario. </li>
</ol>
<p>This example demonstrates the impact of unintended change in the order of inheritance. It<a id="_idIndexMarker520"/> is important to ensure that the order of classes is correct while defining classes with multilevel inheritance in Python so that the MRO is consistent for base classes. </p>
<h1 id="_idParaDest-141"><a id="_idTextAnchor143"/>Summary</h1>
<p>In this chapter, we have learned about the concept of method resolution by exploring the MRO method in Python 3. We also inspected the MRO of Python code by implementing different types of inheritance. We understood the impact of MRO by modifying the order of inheritance at various levels for multiple classes from our core example.</p>
<p>Similar to other chapters covered in this book, this chapter explains that the MRO also focuses on metaprogramming and its impact on Python code.</p>
<p>In the next chapter, we will be looking at the concept of dynamic objects, with some other interesting examples.</p>
</div>
<div><div></div>
</div>
</div></body></html>