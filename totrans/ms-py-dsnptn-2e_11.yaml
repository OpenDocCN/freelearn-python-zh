- en: '11'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Python Anti-Patterns
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this final chapter, we will explore Python anti-patterns. These are common
    programming practices that, while not necessarily wrong, often lead to less efficient,
    less readable, and less maintainable code. By understanding these pitfalls, you
    can write cleaner, more efficient code for your Python applications.
  prefs: []
  type: TYPE_NORMAL
- en: 'In this chapter, we’re going to cover the following main topics:'
  prefs: []
  type: TYPE_NORMAL
- en: Code style violations
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Correctness anti-patterns
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Maintainability anti-patterns
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Performance anti-patterns
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Technical requirements
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: See the requirements presented in [*Chapter 1*](B21896_01.xhtml#_idTextAnchor017).
  prefs: []
  type: TYPE_NORMAL
- en: Code style violations
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The Python style guide, also known as **Python Enhancement Proposal no 8**
    (**PEP 8**), provides recommendations for readability and consistency in your
    code, making it easier for developers to collaborate and maintain projects over
    time. You can find the style guide details on its official page here: [https://peps.python.org/pep-0008](https://peps.python.org/pep-0008).
    In this section, we are going to present some of the recommendations of the style
    guide so that you can avoid them when writing your application’s or library’s
    code.'
  prefs: []
  type: TYPE_NORMAL
- en: Tools for fixing coding style violations
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Note that we have formatting tools such as *Black* ([https://black.readthedocs.io/en/stable/](https://black.readthedocs.io/en/stable/)),
    *isort* ([https://pycqa.github.io/isort/](https://pycqa.github.io/isort/)), and/or
    *Ruff* ([https://docs.astral.sh/ruff/](https://docs.astral.sh/ruff/)) that can
    help you fix code that does not follow the style guide recommendations. We are
    not going to spend time on how to use these tools here since you can find all
    the needed documentation on their official documentation pages and start using
    them in a matter of minutes.
  prefs: []
  type: TYPE_NORMAL
- en: Now, let’s explore our selected code style recommendations.
  prefs: []
  type: TYPE_NORMAL
- en: Indentation
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: You should use four spaces per indentation level, and you should avoid mixing
    tabs and spaces.
  prefs: []
  type: TYPE_NORMAL
- en: Maximum line length and blank lines
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The style guide recommends limiting all lines of code to a maximum of 79 characters,
    for better readability.
  prefs: []
  type: TYPE_NORMAL
- en: Also, there are rules related to blank lines. First, you should surround top-level
    function and class definitions with two blank lines. Second, method definitions
    inside a class should be surrounded by a single blank line.
  prefs: []
  type: TYPE_NORMAL
- en: 'For example, the formatting with the following code snippet is incorrect:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'The right formatting is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: Imports
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The way you write, organize, and order your import lines is also important.
    According to the style guide, imports should be on separate lines and grouped
    into three categories in this order: standard library imports, related third-party
    imports, and local-specific imports within the application’s or library’s code
    base. Also, each group should be separated by a blank line.'
  prefs: []
  type: TYPE_NORMAL
- en: 'For example, the following is not compliant with the style guide:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: 'The best practice for the same imports is the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: Naming conventions
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'You should use descriptive names for variables, functions, classes, and modules.
    The following are specific naming conventions for different types of cases:'
  prefs: []
  type: TYPE_NORMAL
- en: '`lower_case_with_underscores`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`CapWords`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`ALL_CAPS_WITH_UNDERSCORES`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'For example, the following is not good practice:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: 'The best practice is the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: Comments
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Comments should be complete sentences, with the first word capitalized, and
    should be clear and concise. We have specific recommendations for two cases of
    comments—block comments and inline comments:'
  prefs: []
  type: TYPE_NORMAL
- en: Block comments generally apply to some (or all) code that follows them and are
    indented to the same level as that code. Each line of a block comment starts with
    `#` and a single space.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Inline comments should be used sparingly. An inline comment is placed on the
    same line as a statement, separated by at least two spaces from the statement.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'For example, in the following, we have a bad comment style:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: 'Here is the equivalent code, with the style fixed:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: Whitespace in expressions and statements
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'You should avoid extraneous whitespace in the following situations:'
  prefs: []
  type: TYPE_NORMAL
- en: Immediately inside parentheses, brackets, or braces
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Immediately before a comma, semicolon, or colon
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: More than one space around an assignment operator to align it with another
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: This ends our review of the most common code style violations to pay attention
    to. As previously said, there are tools to detect and fix such violations in your
    code in a productive way, and they are generally included in the developer workflow
    (for example, via `git commit` hooks and/or in the project’s CI/CD processes).
  prefs: []
  type: TYPE_NORMAL
- en: Correctness anti-patterns
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'These anti-patterns can lead to bugs or unintended behavior if not addressed.
    We are going to discuss the most common of these anti-patterns and alternative,
    recommended ways and approaches. We are going to focus on the following anti-patterns:'
  prefs: []
  type: TYPE_NORMAL
- en: Using the `type()` function for comparing types
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Mutable default argument
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Accessing a protected member from outside a class
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Note that using IDEs such as *Visual Studio Code* or *PyCharm* or command-line
    tools such as *Flake8* will help you spot such bad practices in your code, but
    it is important to know the recommendations and the reason behind each one.
  prefs: []
  type: TYPE_NORMAL
- en: Using the type() function for comparing types
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Sometimes, we need to identify the type of a value through comparison, for our
    algorithm. The common technique one may think of for that is to use the `type()`
    function. But using `type()` to compare object types does not account for subclassing
    and is not as flexible as the alternative which is based on using the `isinstance()`
    function.
  prefs: []
  type: TYPE_NORMAL
- en: 'Imagine we have two classes, `CustomListA` and `CustomListB`, that are subclasses
    of the `UserList` class, which is the recommended class one should inherit from
    when defining a class for a custom list, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: If we wanted to check if an object is of one of the custom list types, using
    the first approach, we would test the `type(obj) in (CustomListA,` `CustomListB)`
    condition.
  prefs: []
  type: TYPE_NORMAL
- en: Alternatively, we would simply test `isinstance(obj, UserList)`, and that would
    be enough since `CustomListA` and `CustomListB` are subclasses of `UserList`.
  prefs: []
  type: TYPE_NORMAL
- en: 'As a demonstration, we write a `compare()` function that uses the first approach,
    as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: 'Then, we write a `better_compare()` function to do the equivalent using the
    alternative approach, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: 'The following lines of code can help test both functions:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: 'The complete demonstration code is in the `ch11/compare_types.py` file. Running
    the `python ch11/compare_types.py` command should give the following output:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: This shows that both functions can produce the expected result. But the function
    using the recommended technique, `isinstance()`, is simpler to write and more
    flexible since it takes subclasses into account.
  prefs: []
  type: TYPE_NORMAL
- en: Mutable default argument
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: When you define a function with a parameter that expects a mutable value, such
    as a list or a dictionary, you may be tempted to provide a default argument (`[]`
    or `{}` respectively). But such a function retains changes between calls, which
    will lead to unexpected behaviors.
  prefs: []
  type: TYPE_NORMAL
- en: The recommended practice is to use a default value of `None` and set it to a
    mutable data structure within the function if needed.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s create a function called `manipulate()` whose `mylist` parameter has
    a default value of `[]`. The function appends the `"test"` string to the `mylist`
    list and then returns it, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: 'In another function called `better_manipulate()` whose `mylist` parameter has
    a default value of `None`, we start by setting `mylist` to `[]` if it is `None`,
    then we append the `"test"` string to `mylist` before returning it, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: 'The following lines help us test each function by calling it several times
    with the default argument:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: 'Running the `python ch11/mutable_default_argument.py` command should give the
    following output:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: 'class Book:'
  prefs: []
  type: TYPE_NORMAL
- en: 'def __init__(self, title, author):'
  prefs: []
  type: TYPE_NORMAL
- en: self._title = title
  prefs: []
  type: TYPE_NORMAL
- en: self._author = author
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: 'class BetterBook:'
  prefs: []
  type: TYPE_NORMAL
- en: 'def __init__(self, title, author):'
  prefs: []
  type: TYPE_NORMAL
- en: self._title = title
  prefs: []
  type: TYPE_NORMAL
- en: self._author = author
  prefs: []
  type: TYPE_NORMAL
- en: 'def presentation_line(self):'
  prefs: []
  type: TYPE_NORMAL
- en: return f"{self._title} by {self._author}"
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: 'if __name__ == "__main__":'
  prefs: []
  type: TYPE_NORMAL
- en: b1 = Book(
  prefs: []
  type: TYPE_NORMAL
- en: '"Mastering Object-Oriented Python",'
  prefs: []
  type: TYPE_NORMAL
- en: '"Steven F. Lott",'
  prefs: []
  type: TYPE_NORMAL
- en: )
  prefs: []
  type: TYPE_NORMAL
- en: print(
  prefs: []
  type: TYPE_NORMAL
- en: '"Bad practice: Direct access of protected members"'
  prefs: []
  type: TYPE_NORMAL
- en: )
  prefs: []
  type: TYPE_NORMAL
- en: print(f"{b1._title} by {b1._author}")
  prefs: []
  type: TYPE_NORMAL
- en: b2 = BetterBook(
  prefs: []
  type: TYPE_NORMAL
- en: '"Python Algorithms",'
  prefs: []
  type: TYPE_NORMAL
- en: '"Magnus Lie Hetland",'
  prefs: []
  type: TYPE_NORMAL
- en: )
  prefs: []
  type: TYPE_NORMAL
- en: print(
  prefs: []
  type: TYPE_NORMAL
- en: '"Recommended: Access via the public interface"'
  prefs: []
  type: TYPE_NORMAL
- en: )
  prefs: []
  type: TYPE_NORMAL
- en: print(b2.presentation_line())
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: 'Bad practice: Direct access of protected members'
  prefs: []
  type: TYPE_NORMAL
- en: Mastering Object-Oriented Python by Steven F. Lott
  prefs: []
  type: TYPE_NORMAL
- en: 'Recommended: Access via the public interface'
  prefs: []
  type: TYPE_NORMAL
- en: Python Algorithms by Magnus Lie Hetland
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: 'if os.path.exists(filename):'
  prefs: []
  type: TYPE_NORMAL
- en: 'with open(filename) as f:'
  prefs: []
  type: TYPE_NORMAL
- en: print(f.text)
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: 'try:'
  prefs: []
  type: TYPE_NORMAL
- en: 'with open(filename) as f:'
  prefs: []
  type: TYPE_NORMAL
- en: print(f.text)
  prefs: []
  type: TYPE_NORMAL
- en: 'except FileNotFoundError:'
  prefs: []
  type: TYPE_NORMAL
- en: print("No file there")
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: 'def test_open_file(filename):'
  prefs: []
  type: TYPE_NORMAL
- en: 'if os.path.exists(filename):'
  prefs: []
  type: TYPE_NORMAL
- en: 'with open(filename) as f:'
  prefs: []
  type: TYPE_NORMAL
- en: print(f.text)
  prefs: []
  type: TYPE_NORMAL
- en: 'else:'
  prefs: []
  type: TYPE_NORMAL
- en: print("No file there")
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: 'def better_test_open_file(filename):'
  prefs: []
  type: TYPE_NORMAL
- en: 'try:'
  prefs: []
  type: TYPE_NORMAL
- en: 'with open(filename) as f:'
  prefs: []
  type: TYPE_NORMAL
- en: print(f.text)
  prefs: []
  type: TYPE_NORMAL
- en: 'except FileNotFoundError:'
  prefs: []
  type: TYPE_NORMAL
- en: print("No file there")
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: filename = "no_file.txt"
  prefs: []
  type: TYPE_NORMAL
- en: test_open_file(filename)
  prefs: []
  type: TYPE_NORMAL
- en: better_test_open_file(filename)
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: No file there
  prefs: []
  type: TYPE_NORMAL
- en: try/except way makes our code cleaner.
  prefs: []
  type: TYPE_NORMAL
- en: Overusing inheritance and tight coupling
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: Inheritance is a powerful feature of OOP, but overusing it – for example, creating
    a new class for every slight variation of behavior – can lead to tight coupling
    between classes. This increases complexity and makes the code less flexible and
    harder to maintain.
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: 'It is not recommended to create a deep inheritance hierarchy such as the following
    (as a simplified example):'
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: 'The best practice is to create smaller, more focused classes and combine them
    to achieve the desired behavior, as with the following:'
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: As you may remember, this is the composition approach, which we discussed in
    the *Following the Favor Composition over Inheritance principle* section of [*Chapter
    1*](B21896_01.xhtml#_idTextAnchor017), *Foundational* *Design Principles*.
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: Using global variables for sharing data between functions
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: Global variables are variables that are accessible throughout the entire program,
    making them tempting to use for sharing data between functions—for example, configuration
    settings that are used across multiple modules or shared resources such as database
    connections.
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: However, they can lead to bugs where different parts of the application unexpectedly
    modify global state. Also, they make it harder to scale applications as they can
    lead to issues in multithreaded environments where multiple threads might attempt
    to modify the global variable simultaneously.
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Here is an example of the non-recommended practice:'
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: 'Instead of using a global variable, you should pass the needed data as arguments
    to functions or encapsulate state within a class, which improves the modularity
    and testability of the code. So, the best-practice equivalent for the counterexample
    would be defining a `Counter` class holding a `counter` attribute, as follows:'
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: 'Next, we add code for testing the `Counter` class as follows:'
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: 'You can check the complete code of the example in the  `ch11/instead_of_global_variable.py`
    file, and running it should give the following output:'
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: This shows how using a class instead of global variables is effective and can
    be scalable, thus the recommended practice.
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: Performance anti-patterns
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: 'These anti-patterns lead to inefficiencies that can degrade performance, especially
    noticeable in large-scale applications or data-intensive tasks. We will focus
    on the following such anti-patterns:'
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: Not using `.join()` to concatenate strings in a loop
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: Using global variables for caching
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: Let’s start.
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: Not using .join() to concatenate strings in a loop
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: Concatenating strings with `+` or `+=` in a loop creates a new string object
    each time, which is inefficient. The best solution is to use the `.join()` method
    on strings, which is designed for efficiency when concatenating strings from a
    sequence or iterable.
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Let’s create a `concatenate()` function where we use `+=` for concatenating
    items from a list of strings, as follows:'
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: 'Then, let’s create a `better_concatenate()` function for the same result, but
    using the `str.join()` method, as follows:'
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: 'We can then test both functions using the following:'
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs: []
  type: TYPE_PRE
- en: 'Running the code (in the `ch11/concatenate_strings_in_loop.py` file) gives
    the following output:'
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs: []
  type: TYPE_PRE
- en: import time
  prefs: []
  type: TYPE_NORMAL
- en: import random
  prefs: []
  type: TYPE_NORMAL
- en: Global variable as cache
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: _cache = {}
  prefs: []
  type: TYPE_NORMAL
- en: 'def get_data(query):'
  prefs: []
  type: TYPE_NORMAL
- en: 'if query in _cache:'
  prefs: []
  type: TYPE_NORMAL
- en: return _cache[query]
  prefs: []
  type: TYPE_NORMAL
- en: 'else:'
  prefs: []
  type: TYPE_NORMAL
- en: result = perform_expensive_operation(query)
  prefs: []
  type: TYPE_NORMAL
- en: _cache[query] = result
  prefs: []
  type: TYPE_NORMAL
- en: return result
  prefs: []
  type: TYPE_NORMAL
- en: 'def perform_expensive_operation(user_id):'
  prefs: []
  type: TYPE_NORMAL
- en: time.sleep(random.uniform(0.5, 2.0))
  prefs: []
  type: TYPE_NORMAL
- en: user_data = {
  prefs: []
  type: TYPE_NORMAL
- en: '1: {"name": "Alice", "email": "alice@example.com"},'
  prefs: []
  type: TYPE_NORMAL
- en: '2: {"name": "Bob", "email": "bob@example.com"},'
  prefs: []
  type: TYPE_NORMAL
- en: '3: {"name": "Charlie", "email": "charlie@example.com"},'
  prefs: []
  type: TYPE_NORMAL
- en: '}'
  prefs: []
  type: TYPE_NORMAL
- en: 'result = user_data.get(user_id, {"error": "User not found"})'
  prefs: []
  type: TYPE_NORMAL
- en: return result
  prefs: []
  type: TYPE_NORMAL
- en: 'if __name__ == "__main__":'
  prefs: []
  type: TYPE_NORMAL
- en: print(get_data(1))
  prefs: []
  type: TYPE_NORMAL
- en: print(get_data(1))
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs: []
  type: TYPE_PRE
- en: '{''name'': ''Alice'', ''email'': ''alice@example.com''}'
  prefs: []
  type: TYPE_NORMAL
- en: functools.lru_cache() function. The lru_cache decorator provides a lru_cache
    are optimized for performance, using efficient data structures and algorithms
    to manage the cache.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here’s how you can implement the functionality of caching results from a time-consuming
    function using `functools.lru_cache`. The complete code (in the `ch11/caching/using_lru_cache.py`
    file) is as follows:'
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE37]'
  prefs: []
  type: TYPE_PRE
- en: 'To test this code, run the `python ch11/caching/using_lru_cache.py`  command.
    You should get the following output:'
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE38]'
  prefs: []
  type: TYPE_PRE
- en: As we can see, this approach not only enhances the robustness of the caching
    mechanism but also improves code readability and maintainability.
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: Understanding and avoiding common Python anti-patterns will help you write cleaner,
    more efficient, and maintainable code.
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: First, we presented common Python code style violations. Then we discussed several
    anti-patterns that are related to correctness and can lead to bugs. Next, we covered
    practices that, beyond the code style itself, are not good for code readability
    and maintainability. Finally, we saw a couple of anti-patterns that one should
    avoid for writing code that has good performance.
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: Always remember – the best code is not just about making it work but also about
    making it work well. Even more, ideally, it should be easy to maintain.
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: We finally reached the end of this book. It was quite a journey. We started
    with the main design principles, then moved on to cover the most popular design
    patterns in the way they can be applied to Python, and finally touched upon Python
    anti-patterns. That’s a lot! The ideas and examples we discussed help us to think
    about different implementation options or techniques to choose from whenever we
    have a use case. Whatever the solution you choose, keep in mind that Python favors
    simplicity, try to use patterns and techniques that are considered Pythonic, and
    avoid Python’s anti-patterns.
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE39]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE40]'
  prefs: []
  type: TYPE_PRE
