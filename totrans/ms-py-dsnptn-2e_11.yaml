- en: '11'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '11'
- en: Python Anti-Patterns
  id: totrans-1
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Python 反模式
- en: In this final chapter, we will explore Python anti-patterns. These are common
    programming practices that, while not necessarily wrong, often lead to less efficient,
    less readable, and less maintainable code. By understanding these pitfalls, you
    can write cleaner, more efficient code for your Python applications.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章的最后部分，我们将探讨 Python 反模式。这些是常见的编程实践，虽然它们并不一定错误，但往往会导致代码效率低下、可读性差和难以维护。通过了解这些陷阱，你可以为你的
    Python 应用程序编写更干净、更高效的代码。
- en: 'In this chapter, we’re going to cover the following main topics:'
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将涵盖以下主要内容：
- en: Code style violations
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 代码风格违规
- en: Correctness anti-patterns
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 正确性反模式
- en: Maintainability anti-patterns
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 可维护性反模式
- en: Performance anti-patterns
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 性能反模式
- en: Technical requirements
  id: totrans-8
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 技术要求
- en: See the requirements presented in [*Chapter 1*](B21896_01.xhtml#_idTextAnchor017).
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 请参阅在[*第一章*](B21896_01.xhtml#_idTextAnchor017)中提出的要求数据。
- en: Code style violations
  id: totrans-10
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 代码风格违规
- en: 'The Python style guide, also known as **Python Enhancement Proposal no 8**
    (**PEP 8**), provides recommendations for readability and consistency in your
    code, making it easier for developers to collaborate and maintain projects over
    time. You can find the style guide details on its official page here: [https://peps.python.org/pep-0008](https://peps.python.org/pep-0008).
    In this section, we are going to present some of the recommendations of the style
    guide so that you can avoid them when writing your application’s or library’s
    code.'
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: Python 风格指南，也称为**Python 增强提案第 8 号**（**PEP 8**），为你的代码的可读性和一致性提供了建议，使得开发者能够更容易地在长时间内协作和维护项目。你可以在其官方页面找到风格指南的详细信息：[https://peps.python.org/pep-0008](https://peps.python.org/pep-0008)。在本节中，我们将介绍风格指南的一些建议，以便你在编写应用程序或库的代码时避免它们。
- en: Tools for fixing coding style violations
  id: totrans-12
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 修复代码风格违规的工具
- en: Note that we have formatting tools such as *Black* ([https://black.readthedocs.io/en/stable/](https://black.readthedocs.io/en/stable/)),
    *isort* ([https://pycqa.github.io/isort/](https://pycqa.github.io/isort/)), and/or
    *Ruff* ([https://docs.astral.sh/ruff/](https://docs.astral.sh/ruff/)) that can
    help you fix code that does not follow the style guide recommendations. We are
    not going to spend time on how to use these tools here since you can find all
    the needed documentation on their official documentation pages and start using
    them in a matter of minutes.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，我们有如 *Black* ([https://black.readthedocs.io/en/stable/](https://black.readthedocs.io/en/stable/))、*isort*
    ([https://pycqa.github.io/isort/](https://pycqa.github.io/isort/)) 和/或 *Ruff*
    ([https://docs.astral.sh/ruff/](https://docs.astral.sh/ruff/)) 等格式化工具，可以帮助你修复不符合风格指南建议的代码。我们不会在这里花费时间讲解如何使用这些工具，因为你可以找到所有需要的文档在它们的官方文档页面上，并且可以在几分钟内开始使用它们。
- en: Now, let’s explore our selected code style recommendations.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们来探讨我们选定的代码风格建议。
- en: Indentation
  id: totrans-15
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 缩进
- en: You should use four spaces per indentation level, and you should avoid mixing
    tabs and spaces.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 你应该使用每个缩进级别四个空格，并应避免混合使用制表符和空格。
- en: Maximum line length and blank lines
  id: totrans-17
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 最大行长度和空行
- en: The style guide recommends limiting all lines of code to a maximum of 79 characters,
    for better readability.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 风格指南建议将所有代码行限制在最多 79 个字符，以提高可读性。
- en: Also, there are rules related to blank lines. First, you should surround top-level
    function and class definitions with two blank lines. Second, method definitions
    inside a class should be surrounded by a single blank line.
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，还有一些与空行相关的规则。首先，你应该在顶级函数和类定义周围使用两个空行。其次，类内部的方法定义应使用单个空行。
- en: 'For example, the formatting with the following code snippet is incorrect:'
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，以下代码片段的格式是不正确的：
- en: '[PRE0]'
  id: totrans-21
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'The right formatting is as follows:'
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 正确的格式如下：
- en: '[PRE1]'
  id: totrans-23
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: Imports
  id: totrans-24
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 导入
- en: 'The way you write, organize, and order your import lines is also important.
    According to the style guide, imports should be on separate lines and grouped
    into three categories in this order: standard library imports, related third-party
    imports, and local-specific imports within the application’s or library’s code
    base. Also, each group should be separated by a blank line.'
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 你编写、组织和排序导入语句的方式也很重要。根据风格指南，导入应单独成行，并按以下顺序分为三类：标准库导入、相关第三方库导入以及应用程序或库代码库中的本地特定导入。此外，每个组之间应有一个空行。
- en: 'For example, the following is not compliant with the style guide:'
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，以下内容不符合风格指南：
- en: '[PRE2]'
  id: totrans-27
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'The best practice for the same imports is the following:'
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 对于相同的导入，最佳实践如下：
- en: '[PRE3]'
  id: totrans-29
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: Naming conventions
  id: totrans-30
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 命名约定
- en: 'You should use descriptive names for variables, functions, classes, and modules.
    The following are specific naming conventions for different types of cases:'
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 你应该为变量、函数、类和模块使用描述性的名称。以下是为不同类型情况的具体命名约定：
- en: '`lower_case_with_underscores`'
  id: totrans-32
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`lower_case_with_underscores`'
- en: '`CapWords`'
  id: totrans-33
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`CapWords`'
- en: '`ALL_CAPS_WITH_UNDERSCORES`'
  id: totrans-34
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`ALL_CAPS_WITH_UNDERSCORES`'
- en: 'For example, the following is not good practice:'
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，以下不是良好的实践：
- en: '[PRE4]'
  id: totrans-36
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'The best practice is the following:'
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 最佳实践如下：
- en: '[PRE5]'
  id: totrans-38
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: Comments
  id: totrans-39
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 注释
- en: 'Comments should be complete sentences, with the first word capitalized, and
    should be clear and concise. We have specific recommendations for two cases of
    comments—block comments and inline comments:'
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 注释应该是完整的句子，首字母大写，应该清晰简洁。我们对注释的两种情况有具体的建议——块注释和行内注释：
- en: Block comments generally apply to some (or all) code that follows them and are
    indented to the same level as that code. Each line of a block comment starts with
    `#` and a single space.
  id: totrans-41
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 块注释通常适用于其后的某些（或所有）代码，并且缩进与该代码相同级别。块注释的每一行都以 `#` 和一个空格开始。
- en: Inline comments should be used sparingly. An inline comment is placed on the
    same line as a statement, separated by at least two spaces from the statement.
  id: totrans-42
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 行内注释应谨慎使用。行内注释位于语句的同一行上，至少与语句有两个空格的距离。
- en: 'For example, in the following, we have a bad comment style:'
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，以下是一个不良的注释风格：
- en: '[PRE6]'
  id: totrans-44
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'Here is the equivalent code, with the style fixed:'
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 下面是修复了风格的等效代码：
- en: '[PRE7]'
  id: totrans-46
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: Whitespace in expressions and statements
  id: totrans-47
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 表达式和语句中的空白
- en: 'You should avoid extraneous whitespace in the following situations:'
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 在以下情况下，你应该避免多余的空白：
- en: Immediately inside parentheses, brackets, or braces
  id: totrans-49
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 立即位于括号、方括号或花括号内
- en: Immediately before a comma, semicolon, or colon
  id: totrans-50
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 立即位于逗号、分号或冒号之前
- en: More than one space around an assignment operator to align it with another
  id: totrans-51
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在赋值运算符周围留出多个空格以对齐
- en: This ends our review of the most common code style violations to pay attention
    to. As previously said, there are tools to detect and fix such violations in your
    code in a productive way, and they are generally included in the developer workflow
    (for example, via `git commit` hooks and/or in the project’s CI/CD processes).
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 这结束了我们对最常见代码风格违规的审查。正如之前所说，有工具可以帮助以生产性的方式检测和修复这些违规，它们通常包含在开发工作流程中（例如，通过 `git
    commit` 钩子以及/或在项目的 CI/CD 流程中）。
- en: Correctness anti-patterns
  id: totrans-53
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 正确性反模式
- en: 'These anti-patterns can lead to bugs or unintended behavior if not addressed.
    We are going to discuss the most common of these anti-patterns and alternative,
    recommended ways and approaches. We are going to focus on the following anti-patterns:'
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 如果不解决这些问题，这些反模式可能会导致错误或意外的行为。我们将讨论这些反模式中最常见的一些，以及推荐的替代方法和途径。我们将重点关注以下反模式：
- en: Using the `type()` function for comparing types
  id: totrans-55
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用 `type()` 函数比较类型
- en: Mutable default argument
  id: totrans-56
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 可变默认参数
- en: Accessing a protected member from outside a class
  id: totrans-57
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 从类外部访问受保护的成员
- en: Note that using IDEs such as *Visual Studio Code* or *PyCharm* or command-line
    tools such as *Flake8* will help you spot such bad practices in your code, but
    it is important to know the recommendations and the reason behind each one.
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，使用如 *Visual Studio Code* 或 *PyCharm* 这样的 IDE 或如 *Flake8* 这样的命令行工具可以帮助你在代码中找到这样的不良实践，但了解每个建议及其背后的原因同样重要。
- en: Using the type() function for comparing types
  id: totrans-59
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用 `type()` 函数比较类型
- en: Sometimes, we need to identify the type of a value through comparison, for our
    algorithm. The common technique one may think of for that is to use the `type()`
    function. But using `type()` to compare object types does not account for subclassing
    and is not as flexible as the alternative which is based on using the `isinstance()`
    function.
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 有时，为了我们的算法，我们需要通过比较来识别值的类型。人们可能会想到的常见技术是使用 `type()` 函数。但使用 `type()` 来比较对象类型不考虑子类化，并且不如基于使用
    `isinstance()` 函数的替代方案灵活。
- en: 'Imagine we have two classes, `CustomListA` and `CustomListB`, that are subclasses
    of the `UserList` class, which is the recommended class one should inherit from
    when defining a class for a custom list, as follows:'
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 假设我们有两个类，`CustomListA` 和 `CustomListB`，它们是 `UserList` 类的子类，当定义自定义列表的类时，推荐从该类继承，如下所示：
- en: '[PRE8]'
  id: totrans-62
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: If we wanted to check if an object is of one of the custom list types, using
    the first approach, we would test the `type(obj) in (CustomListA,` `CustomListB)`
    condition.
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们想检查一个对象是否是自定义列表类型之一，使用第一种方法，我们会测试 `type(obj) in (CustomListA, CustomListB)`
    条件。
- en: Alternatively, we would simply test `isinstance(obj, UserList)`, and that would
    be enough since `CustomListA` and `CustomListB` are subclasses of `UserList`.
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 或者，我们只需简单地测试`isinstance(obj, UserList)`，这已经足够了，因为`CustomListA`和`CustomListB`是`UserList`的子类。
- en: 'As a demonstration, we write a `compare()` function that uses the first approach,
    as follows:'
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 作为演示，我们编写一个`compare()`函数，使用以下第一种方法：
- en: '[PRE9]'
  id: totrans-66
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'Then, we write a `better_compare()` function to do the equivalent using the
    alternative approach, as follows:'
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们编写一个`better_compare()`函数，使用以下替代方法执行等效操作：
- en: '[PRE10]'
  id: totrans-68
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'The following lines of code can help test both functions:'
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 以下代码行可以帮助测试这两个函数：
- en: '[PRE11]'
  id: totrans-70
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'The complete demonstration code is in the `ch11/compare_types.py` file. Running
    the `python ch11/compare_types.py` command should give the following output:'
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 完整的演示代码在`ch11/compare_types.py`文件中。运行`python ch11/compare_types.py`命令应给出以下输出：
- en: '[PRE12]'
  id: totrans-72
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: This shows that both functions can produce the expected result. But the function
    using the recommended technique, `isinstance()`, is simpler to write and more
    flexible since it takes subclasses into account.
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 这表明两个函数都可以产生预期的结果。但使用推荐技术`isinstance()`的函数更简单易写，并且更灵活，因为它考虑了子类。
- en: Mutable default argument
  id: totrans-74
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 可变默认参数
- en: When you define a function with a parameter that expects a mutable value, such
    as a list or a dictionary, you may be tempted to provide a default argument (`[]`
    or `{}` respectively). But such a function retains changes between calls, which
    will lead to unexpected behaviors.
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 当你定义一个带有期望可变值参数的函数，例如列表或字典时，你可能想提供一个默认参数（分别为`[]`或`{}`）。但这样的函数会在调用之间保留更改，这会导致意外的行为。
- en: The recommended practice is to use a default value of `None` and set it to a
    mutable data structure within the function if needed.
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 建议的做法是使用`None`作为默认值，并在需要时在函数内部将其设置为可变数据结构。
- en: 'Let’s create a function called `manipulate()` whose `mylist` parameter has
    a default value of `[]`. The function appends the `"test"` string to the `mylist`
    list and then returns it, as follows:'
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们创建一个名为`manipulate()`的函数，其`mylist`参数的默认值为`[]`。该函数将`"test"`字符串追加到`mylist`列表中，然后返回它，如下所示：
- en: '[PRE13]'
  id: totrans-78
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'In another function called `better_manipulate()` whose `mylist` parameter has
    a default value of `None`, we start by setting `mylist` to `[]` if it is `None`,
    then we append the `"test"` string to `mylist` before returning it, as follows:'
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 在另一个名为`better_manipulate()`的函数中，其`mylist`参数的默认值为`None`，我们首先将`mylist`设置为`[]`，如果它是`None`，然后在返回之前将`"test"`字符串追加到`mylist`中，如下所示：
- en: '[PRE14]'
  id: totrans-80
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'The following lines help us test each function by calling it several times
    with the default argument:'
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 以下行帮助我们通过多次使用默认参数调用每个函数来测试每个函数：
- en: '[PRE15]'
  id: totrans-82
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'Running the `python ch11/mutable_default_argument.py` command should give the
    following output:'
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 运行`python ch11/mutable_default_argument.py`命令应给出以下输出：
- en: '[PRE16]'
  id: totrans-84
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'class Book:'
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 'class Book:'
- en: 'def __init__(self, title, author):'
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 'def __init__(self, title, author):'
- en: self._title = title
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: self._title = title
- en: self._author = author
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: self._author = author
- en: '[PRE17]'
  id: totrans-89
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'class BetterBook:'
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 'class BetterBook:'
- en: 'def __init__(self, title, author):'
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 'def __init__(self, title, author):'
- en: self._title = title
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: self._title = title
- en: self._author = author
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: self._author = author
- en: 'def presentation_line(self):'
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 'def presentation_line(self):'
- en: return f"{self._title} by {self._author}"
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: return f"{self._title} by {self._author}"
- en: '[PRE18]'
  id: totrans-96
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'if __name__ == "__main__":'
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 'if __name__ == "__main__":'
- en: b1 = Book(
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: b1 = Book(
- en: '"Mastering Object-Oriented Python",'
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: '"Mastering Object-Oriented Python",'
- en: '"Steven F. Lott",'
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: '"Steven F. Lott",'
- en: )
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: )
- en: print(
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: print(
- en: '"Bad practice: Direct access of protected members"'
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: '"不良做法：直接访问受保护的成员"'
- en: )
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: )
- en: print(f"{b1._title} by {b1._author}")
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: print(f"{b1._title} by {b1._author}")
- en: b2 = BetterBook(
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: b2 = BetterBook(
- en: '"Python Algorithms",'
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: '"Python算法",'
- en: '"Magnus Lie Hetland",'
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: '"Magnus Lie Hetland",'
- en: )
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: )
- en: print(
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: print(
- en: '"Recommended: Access via the public interface"'
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: '"推荐：通过公共接口访问"'
- en: )
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: )
- en: print(b2.presentation_line())
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: print(b2.presentation_line())
- en: '[PRE19]'
  id: totrans-114
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'Bad practice: Direct access of protected members'
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 不良做法：直接访问受保护的成员
- en: Mastering Object-Oriented Python by Steven F. Lott
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 《精通面向对象Python》由Steven F. Lott著
- en: 'Recommended: Access via the public interface'
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 推荐：通过公共接口访问
- en: Python Algorithms by Magnus Lie Hetland
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: '"Python Algorithms" by Magnus Lie Hetland'
- en: '[PRE20]'
  id: totrans-119
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'if os.path.exists(filename):'
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 'if os.path.exists(filename):'
- en: 'with open(filename) as f:'
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 'with open(filename) as f:'
- en: print(f.text)
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: print(f.text)
- en: '[PRE21]'
  id: totrans-123
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'try:'
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 'try:'
- en: 'with open(filename) as f:'
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 'with open(filename) as f:'
- en: print(f.text)
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: print(f.text)
- en: 'except FileNotFoundError:'
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 'except FileNotFoundError:'
- en: print("No file there")
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: print("此处无文件")
- en: '[PRE22]'
  id: totrans-129
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'def test_open_file(filename):'
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 'def test_open_file(filename):'
- en: 'if os.path.exists(filename):'
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 'if os.path.exists(filename):'
- en: 'with open(filename) as f:'
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 'with open(filename) as f:'
- en: print(f.text)
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: print(f.text)
- en: 'else:'
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 'else:'
- en: print("No file there")
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: print("此处无文件")
- en: '[PRE23]'
  id: totrans-136
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'def better_test_open_file(filename):'
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 'def better_test_open_file(filename):'
- en: 'try:'
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 'try:'
- en: 'with open(filename) as f:'
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 'with open(filename) as f:'
- en: print(f.text)
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: print(f.text)
- en: 'except FileNotFoundError:'
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 'except FileNotFoundError:'
- en: print("No file there")
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: print("No file there")
- en: '[PRE24]'
  id: totrans-143
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: filename = "no_file.txt"
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: filename = "no_file.txt"
- en: test_open_file(filename)
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: test_open_file(filename)
- en: better_test_open_file(filename)
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: better_test_open_file(filename)
- en: '[PRE25]'
  id: totrans-147
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: No file there
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 没有该文件
- en: try/except way makes our code cleaner.
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: try/except 方法使我们的代码更简洁。
- en: Overusing inheritance and tight coupling
  id: totrans-150
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: 过度使用继承和紧密耦合
- en: Inheritance is a powerful feature of OOP, but overusing it – for example, creating
    a new class for every slight variation of behavior – can lead to tight coupling
    between classes. This increases complexity and makes the code less flexible and
    harder to maintain.
  id: totrans-151
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: 继承是面向对象编程的一个强大功能，但过度使用它——例如，为每个轻微的行为变化创建一个新的类——会导致类之间的紧密耦合。这增加了复杂性，并使代码更不灵活，更难以维护。
- en: 'It is not recommended to create a deep inheritance hierarchy such as the following
    (as a simplified example):'
  id: totrans-152
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: 不推荐创建如下的深层继承层次结构（作为一个简化的例子）：
- en: '[PRE26]'
  id: totrans-153
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: 'The best practice is to create smaller, more focused classes and combine them
    to achieve the desired behavior, as with the following:'
  id: totrans-154
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: 最佳实践是创建更小、更专注的类，并将它们组合起来以实现所需的行为，如下所示：
- en: '[PRE27]'
  id: totrans-155
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: As you may remember, this is the composition approach, which we discussed in
    the *Following the Favor Composition over Inheritance principle* section of [*Chapter
    1*](B21896_01.xhtml#_idTextAnchor017), *Foundational* *Design Principles*.
  id: totrans-156
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: 如您所记得，这是组合方法，我们在 [*第一章*](B21896_01.xhtml#_idTextAnchor017) 的 *遵循组合优于继承原则* 部分进行了讨论，*基础*
    *设计原则*。
- en: Using global variables for sharing data between functions
  id: totrans-157
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: 使用全局变量在函数之间共享数据
- en: Global variables are variables that are accessible throughout the entire program,
    making them tempting to use for sharing data between functions—for example, configuration
    settings that are used across multiple modules or shared resources such as database
    connections.
  id: totrans-158
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: 全局变量是可以在整个程序中访问的变量，这使得它们在函数之间共享数据时很有吸引力——例如，跨多个模块使用的配置设置或共享资源，如数据库连接。
- en: However, they can lead to bugs where different parts of the application unexpectedly
    modify global state. Also, they make it harder to scale applications as they can
    lead to issues in multithreaded environments where multiple threads might attempt
    to modify the global variable simultaneously.
  id: totrans-159
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: 然而，它们可能导致应用程序的不同部分意外地修改全局状态，从而导致错误。此外，它们使得扩展应用程序变得更加困难，因为它们可能导致多线程环境中的问题，在多线程环境中，多个线程可能会尝试同时修改全局变量。
- en: 'Here is an example of the non-recommended practice:'
  id: totrans-160
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: 下面是一个不推荐的做法示例：
- en: '[PRE28]'
  id: totrans-161
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: 'Instead of using a global variable, you should pass the needed data as arguments
    to functions or encapsulate state within a class, which improves the modularity
    and testability of the code. So, the best-practice equivalent for the counterexample
    would be defining a `Counter` class holding a `counter` attribute, as follows:'
  id: totrans-162
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: 而不是使用全局变量，你应该将所需的数据作为参数传递给函数或封装状态在类中，这提高了代码的模块化和可测试性。因此，对于反例的最佳实践是定义一个包含 `counter`
    属性的 `Counter` 类，如下所示：
- en: '[PRE29]'
  id: totrans-163
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: 'Next, we add code for testing the `Counter` class as follows:'
  id: totrans-164
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: 接下来，我们添加测试 `Counter` 类的代码如下：
- en: '[PRE30]'
  id: totrans-165
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: 'You can check the complete code of the example in the  `ch11/instead_of_global_variable.py`
    file, and running it should give the following output:'
  id: totrans-166
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: 你可以在 `ch11/instead_of_global_variable.py` 文件中查看示例的完整代码，运行它应该会给出以下输出：
- en: '[PRE31]'
  id: totrans-167
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: This shows how using a class instead of global variables is effective and can
    be scalable, thus the recommended practice.
  id: totrans-168
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: 这表明使用类而不是全局变量是有效且可扩展的，因此是推荐的做法。
- en: Performance anti-patterns
  id: totrans-169
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: 性能反模式
- en: 'These anti-patterns lead to inefficiencies that can degrade performance, especially
    noticeable in large-scale applications or data-intensive tasks. We will focus
    on the following such anti-patterns:'
  id: totrans-170
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: 这些反模式会导致效率低下，尤其是在大型应用程序或数据密集型任务中，这会降低性能。我们将关注以下此类反模式：
- en: Not using `.join()` to concatenate strings in a loop
  id: totrans-171
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在循环中不使用 `.join()` 连接字符串
- en: Using global variables for caching
  id: totrans-172
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用全局变量进行缓存
- en: Let’s start.
  id: totrans-173
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: 让我们开始吧。
- en: Not using .join() to concatenate strings in a loop
  id: totrans-174
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: 在循环中不使用 .join() 连接字符串
- en: Concatenating strings with `+` or `+=` in a loop creates a new string object
    each time, which is inefficient. The best solution is to use the `.join()` method
    on strings, which is designed for efficiency when concatenating strings from a
    sequence or iterable.
  id: totrans-175
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: 在循环中使用 `+` 或 `+=` 连接字符串会每次创建一个新的字符串对象，这是低效的。最好的解决方案是使用字符串的 `.join()` 方法，该方法专为从序列或可迭代对象中连接字符串时的效率而设计。
- en: 'Let’s create a `concatenate()` function where we use `+=` for concatenating
    items from a list of strings, as follows:'
  id: totrans-176
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: 让我们创建一个`concatenate()`函数，其中我们使用`+=`来连接字符串列表中的项，如下所示：
- en: '[PRE32]'
  id: totrans-177
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: 'Then, let’s create a `better_concatenate()` function for the same result, but
    using the `str.join()` method, as follows:'
  id: totrans-178
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: 然后，让我们创建一个`better_concatenate()`函数，以实现相同的结果，但使用`str.join()`方法，如下所示：
- en: '[PRE33]'
  id: totrans-179
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: 'We can then test both functions using the following:'
  id: totrans-180
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: 我们可以使用以下方式测试这两个函数：
- en: '[PRE34]'
  id: totrans-181
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: 'Running the code (in the `ch11/concatenate_strings_in_loop.py` file) gives
    the following output:'
  id: totrans-182
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: 运行代码（在`ch11/concatenate_strings_in_loop.py`文件中）会得到以下输出：
- en: '[PRE35]'
  id: totrans-183
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: import time
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: import time
- en: import random
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: import random
- en: Global variable as cache
  id: totrans-186
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 全局变量作为缓存
- en: _cache = {}
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: _cache = {}
- en: 'def get_data(query):'
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: 'def get_data(query):'
- en: 'if query in _cache:'
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: 'if query in _cache:'
- en: return _cache[query]
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: return _cache[query]
- en: 'else:'
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: 'else:'
- en: result = perform_expensive_operation(query)
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: result = perform_expensive_operation(query)
- en: _cache[query] = result
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: _cache[query] = result
- en: return result
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: return result
- en: 'def perform_expensive_operation(user_id):'
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: 'def perform_expensive_operation(user_id):'
- en: time.sleep(random.uniform(0.5, 2.0))
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: time.sleep(random.uniform(0.5, 2.0))
- en: user_data = {
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: user_data = {
- en: '1: {"name": "Alice", "email": "alice@example.com"},'
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: '1: {"name": "Alice", "email": "alice@example.com"},'
- en: '2: {"name": "Bob", "email": "bob@example.com"},'
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: '2: {"name": "Bob", "email": "bob@example.com"},'
- en: '3: {"name": "Charlie", "email": "charlie@example.com"},'
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: '3: {"name": "Charlie", "email": "charlie@example.com"},'
- en: '}'
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: '}'
- en: 'result = user_data.get(user_id, {"error": "User not found"})'
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: 'result = user_data.get(user_id, {"error": "User not found"})'
- en: return result
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: return result
- en: 'if __name__ == "__main__":'
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: 'if __name__ == "__main__":'
- en: print(get_data(1))
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: print(get_data(1))
- en: print(get_data(1))
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: print(get_data(1))
- en: '[PRE36]'
  id: totrans-207
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: '{''name'': ''Alice'', ''email'': ''alice@example.com''}'
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: '{''name'': ''Alice'', ''email'': ''alice@example.com''}'
- en: functools.lru_cache() function. The lru_cache decorator provides a lru_cache
    are optimized for performance, using efficient data structures and algorithms
    to manage the cache.
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
  zh: functools.lru_cache() 函数。lru_cache 装饰器提供的 lru_cache 是针对性能优化的，使用高效的数据结构和算法来管理缓存。
- en: 'Here’s how you can implement the functionality of caching results from a time-consuming
    function using `functools.lru_cache`. The complete code (in the `ch11/caching/using_lru_cache.py`
    file) is as follows:'
  id: totrans-210
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: 这就是如何使用`functools.lru_cache`实现从耗时函数缓存结果的功能。完整的代码（在`ch11/caching/using_lru_cache.py`文件中）如下所示：
- en: '[PRE37]'
  id: totrans-211
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: 'To test this code, run the `python ch11/caching/using_lru_cache.py`  command.
    You should get the following output:'
  id: totrans-212
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: 要测试此代码，请运行`python ch11/caching/using_lru_cache.py`命令。你应该得到以下输出：
- en: '[PRE38]'
  id: totrans-213
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: As we can see, this approach not only enhances the robustness of the caching
    mechanism but also improves code readability and maintainability.
  id: totrans-214
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: 如我们所见，这种方法不仅增强了缓存机制的鲁棒性，还提高了代码的可读性和可维护性。
- en: Summary
  id: totrans-215
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: 摘要
- en: Understanding and avoiding common Python anti-patterns will help you write cleaner,
    more efficient, and maintainable code.
  id: totrans-216
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: 理解和避免常见的 Python 反模式将帮助你编写更干净、更高效、更易于维护的代码。
- en: First, we presented common Python code style violations. Then we discussed several
    anti-patterns that are related to correctness and can lead to bugs. Next, we covered
    practices that, beyond the code style itself, are not good for code readability
    and maintainability. Finally, we saw a couple of anti-patterns that one should
    avoid for writing code that has good performance.
  id: totrans-217
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: 首先，我们介绍了常见的 Python 代码风格违规。然后，我们讨论了几种与正确性相关的反模式，这些反模式可能导致错误。接下来，我们介绍了除了代码风格本身之外，对代码可读性和可维护性不利的实践。最后，我们看到了一些应该避免的反模式，以编写具有良好性能的代码。
- en: Always remember – the best code is not just about making it work but also about
    making it work well. Even more, ideally, it should be easy to maintain.
  id: totrans-218
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: 总是记住——最好的代码不仅仅是让它工作，还要让它工作得很好。更进一步，理想情况下，它应该易于维护。
- en: We finally reached the end of this book. It was quite a journey. We started
    with the main design principles, then moved on to cover the most popular design
    patterns in the way they can be applied to Python, and finally touched upon Python
    anti-patterns. That’s a lot! The ideas and examples we discussed help us to think
    about different implementation options or techniques to choose from whenever we
    have a use case. Whatever the solution you choose, keep in mind that Python favors
    simplicity, try to use patterns and techniques that are considered Pythonic, and
    avoid Python’s anti-patterns.
  id: totrans-219
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: 我们终于到达了这本书的结尾。这是一段旅程。我们从主要设计原则开始，然后转向介绍最流行的设计模式，以及它们如何应用于 Python，最后简要介绍了 Python
    的反模式。这有很多！我们讨论的思想和例子帮助我们思考不同的实现选项或技术，以便在遇到用例时选择。无论你选择哪种解决方案，都要记住 Python 倾向于简单性，尽量使用被认为是
    Pythonic 的模式和技巧，并避免 Python 的反模式。
- en: '[PRE39]'
  id: totrans-220
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: '[PRE40]'
  id: totrans-221
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
