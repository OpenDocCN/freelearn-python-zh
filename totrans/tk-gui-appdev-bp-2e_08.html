<html><head></head><body>
        <section>

                            <header>
                    <h1 class="header-title">Fun with Canvas</h1>
                </header>
            
            <article>
                
<p>Canvas is undoubtedly one of the most versatile widgets of Tkinter. Given that it provides direct control over the drawing of each individual pixel, combine it with some maths and it can be used to create all sorts of neat visualizations. While the possibilities are endless, we will explore how to implement some of the important mathematical ideas in this chapter.</p>
<p class="mce-root">The key objectives for this chapter are:</p>
<ul>
<li class="mce-root">Learning to animate with the Tkinter canvas</li>
<li class="mce-root">Understanding the usage of polar and Cartesian coordinates on the canvas</li>
<li class="mce-root">Implementing ordinary differential equations</li>
<li class="mce-root">Modeling simulations given a list of formulas</li>
<li class="mce-root">Modeling 3D graphics and studying some common transformation matrices used in 3D animation</li>
</ul>
<p>Note that many of the code samples in this chapter requires heavy computations. However, code optimization for speed is not our first preference. <span>The primary goal here is comprehension of the underlying concepts.</span></p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Building a screen saver</h1>
                </header>
            
            <article>
                
<p>We will start by building a screen saver. The program will consist of several random-colored and random-sized balls bouncing all over the screen at random velocity, as shown in the following screenshot:</p>
<div class="CDPAlignCenter CDPAlign"><img height="151" src="assets/d4b6f8f8-1f84-457e-9a31-2139efebfe4a.png" width="267"/></div>
<p>Let's create a class to generate balls with random attributes. Accordingly, we define a new class named <kbd>RandomBall</kbd>. Refer the code file <kbd>8.01_screensaver</kbd>:</p>
<pre>class RandomBall:<br/><br/>def __init__(self, canvas):<br/> self.canvas = canvas<br/> self.screen_width = canvas.winfo_screenwidth()<br/> self.screen_height = canvas.winfo_screenheight()<br/> self.create_ball()<br/><br/>def create_ball(self):<br/> self.generate_random_attributes()<br/> self.create_oval() <br/><br/>def generate_random_attributes(self):<br/> self.radius = r = randint(40, 70)<br/> self.x_coordinate = randint(r, self.screen_width - r)<br/> self.y_coordinate = randint(r, self.screen_height - r)<br/> self.x_velocity = randint(6, 12)<br/> self.y_velocity = randint(6, 12)<br/> self.color = self.generate_random_color()<br/><br/>def generate_random_color(self):<br/> r = lambda: randint(0, 0xffff)<br/> return '#{:04x}{:04x}{:04x}'.format(r(), r(), r())<br/><br/>def create_oval(self):<br/> x1 = self.x_coordinate - self.radius<br/> y1 = self.y_coordinate - self.radius<br/> x2 = self.x_coordinate + self.radius<br/> y2 = self.y_coordinate + self.radius<br/> self.ball = self.canvas.create_oval( x1, y1, x2, y2, fill=self.color, <br/>   outline=self.color)<br/><br/>def move_ball(self):<br/> self.check_screen_bounds()<br/> self.x_coordinate += self.x_velocity<br/> self.y_coordinate += self.y_velocity<br/> self.canvas.move(self.ball, self.x_velocity, self.y_velocity)<br/><br/>def check_screen_bounds(self):<br/> r = self.radius<br/> if not r &lt; self.y_coordinate &lt; self.screen_height - r:<br/>   self.y_velocity = -self.y_velocity<br/> if not r &lt; self.x_coordinate &lt; self.screen_width - r:<br/>   self.x_velocity = -self.x_velocity</pre>
<p><span>Here's the description for the preceding code</span>:</p>
<ul>
<li>Two key methods here are <kbd>create_ball</kbd> and <kbd>move_ball</kbd>. All other methods are helpers to these two methods. The <kbd>__init__</kbd> method takes a <kbd>canvas</kbd> as a parameter and then calls the <kbd>create_ball</kbd> method to draw the ball on the given canvas. To move the ball around, we will explicitly need to call the <kbd>move_ball</kbd> method.</li>
<li>The <kbd>create_ball</kbd> method uses the <kbd>canvas.create_oval()</kbd> method and <kbd>move_ball</kbd> uses the <kbd>canvas.move(item, dx, dy)</kbd> method, where <kbd>dx</kbd> and <kbd>dy</kbd> are <kbd>x</kbd> and <kbd>y</kbd> offsets for the canvas item.</li>
<li>Also, note how we create a random color for the ball. Because the hexadecimal color coding system uses up to four hexadecimal digits for each of red, green, and blue, there are up to <kbd>0xffff</kbd> possibilities for each color. We, therefore, create a lambda function that generates a random number from <kbd>0-0xffff</kbd>, and use this function to generate three random numbers. We convert this decimal number to its two-digit equivalent hexadecimal notation using the format specifier <kbd>#{:04x}{:04x}{:04x} </kbd>to get a random color code for the ball.</li>
</ul>
<p>That is all there is to the <kbd>RandomBall</kbd> class. We can use this class to create as many ball objects as we want to display in our screensaver.</p>
<p>Next, let's create the <kbd>ScreenSaver</kbd> class that will show the actual screensaver:</p>
<pre>class ScreenSaver:<br/><br/>balls = []<br/><br/>def __init__(self, number_of_balls):<br/> self.root = Tk()<br/> self.number_of_balls = number_of_balls<br/> self.root.attributes('-fullscreen', True)<br/> self.root.attributes('-alpha', 0.1)<br/> self.root.wm_attributes('-alpha',0.1)<br/> self.quit_on_interaction()<br/> self.create_screensaver()<br/> self.root.mainloop()<br/><br/>def create_screensaver(self):<br/> self.create_canvas()<br/> self.add_balls_to_canvas()<br/> self.animate_balls()<br/><br/>def create_canvas(self):<br/> self.canvas = Canvas(self.root)<br/> self.canvas.pack(expand=1, fill=BOTH)<br/><br/>def add_balls_to_canvas(self):<br/> for i in range(self.number_of_balls):<br/>    self.balls.append(RandomBall(self.canvas))<br/><br/>def quit_on_interaction(self):<br/>  for seq in ('&lt;Any-KeyPress&gt;', '&lt;Any-Button&gt;', '&lt;Motion&gt;'):<br/>    self.root.bind(seq, self.quit_screensaver)<br/><br/>def animate_balls(self):<br/> for ball in self.balls:<br/>    ball.move_ball()<br/> self.root.after(30, self.animate_balls)<br/><br/>def quit_screensaver(self, event):<br/>   self.root.destroy()</pre>
<p>The description of the code is as follows:</p>
<ul>
<li> The <kbd>__init__</kbd> method of the ScreenSaver class takes the number of balls (<kbd>number_of_balls</kbd>) as its argument</li>
<li>We use <kbd>root.attributes ( -fullscreen, True )</kbd> to remove the enclosing frame from the parent window and make it a full-screen window.</li>
<li>The <kbd>quit_on_interaction</kbd> method binds the root to call our <kbd>quit_screensaver</kbd> method in case of any interactions from the user's end.</li>
<li>We then create a canvas to cover the entire screen with <kbd>Canvas(self.root)</kbd> with <kbd>pack ( expand=1, fill=BOTH )</kbd> options to fill the entire screen.</li>
<li>We create several random ball objects using the <kbd>RandomBall</kbd> class, passing along the Canvas widget instance as its arguments.</li>
<li>We finally make a call to the <kbd>animate_balls</kbd> method, which uses the standard <kbd>widget.after()</kbd> method to keep running the animation in a loop at a regular interval of 30 milliseconds.</li>
<li>To run the screen saver, we instantiate an object from our <kbd>ScreenSaver</kbd> class, passing the number of balls as its argument as follows: <kbd>ScreenSaver(number_of_balls=18)</kbd></li>
</ul>
<p>Our screensaver is now ready! In fact, if you are working on the Windows platform, and when you learn to create an executable program from Python programs (discussed in <a href="cabe3587-e359-4987-9dde-52d04270aba3.xhtml" target="_blank">Chapter 10</a>, <em>Miscellaneous Tips</em>), you can create an executable file with a <kbd>.exe</kbd> extension for this screensaver. You can then change its extension from <kbd>.exe</kbd> to <kbd>.scr</kbd>, right-click, and select <span class="packt_screen">Install</span> to add it to your list of screensavers.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Graphing with Tkinter</h1>
                </header>
            
            <article>
                
<p>Tkinter is not a graphing tool. However, should you need to draw graphs with Tkinter, you can use the Canvas widget to draw graphs.</p>
<p>In this iteration, we will draw the following graphs:</p>
<ul>
<li>Pie chart (<kbd>8.02_pie_chart.py</kbd>)</li>
<li>Bar graph (<kbd>8.03_bar_graph.py</kbd>)</li>
<li>Scatter plot (<kbd>8.04_scatter_plot.py</kbd>)</li>
</ul>
<p>The three graphs show up as follows:</p>
<div class="CDPAlignCenter CDPAlign"><img src="assets/07e15b42-6540-4937-87a7-dc635ed13f19.png"/></div>
<p>Let's look at the pie chart first. You can easily create a pie chart in Tkinter using the Canvas widget's <kbd>create_arc</kbd> method. </p>
<p>The <kbd>create_arc</kbd> method has the following signature:</p>
<pre>item_id = canvas.create_arc(x1, y1, x2, y2, option, ...)</pre>
<p>Point (<kbd>x1</kbd>, <kbd>y1</kbd>) is the top-left corner and point (<kbd>x2</kbd>, <kbd>y2</kbd>) is the bottom-right corner of the rectangle into which the arc fits. If the bounding rectangle is a square, it makes a circle. The method also takes two arguments, named <kbd>start</kbd> and <kbd>extent</kbd>, which we will use to create the pie chart.</p>
<p>The <kbd>start</kbd> option specifies the start angle for the arc, measured in degrees from the <kbd>+x</kbd> direction. When omitted, you get the complete ellipse. The <kbd>extent</kbd> option specifies the width of the arc in degrees.</p>
<p>The arc begins at the angle given by the <kbd>start</kbd> option and draws counterclockwise up to the degrees specified by the <kbd>extent</kbd> option.</p>
<p>To create the pie chart, let's define a method that, given a number <em>n</em>, divides the circle into, say, 1,000 equal parts and then, given a number less than 1,000, returns the equivalent angle in the arc. Since there are 360 degrees in a circle, the method is defined as follows:</p>
<pre>total_value_to_represent_by_pie_chart = 1000<br/>def angle(n):<br/>   return 360.0 * n / total_value_to_represent_by_pie_chart</pre>
<p>Next, we plot the various sections of the pie chart using code like this:</p>
<pre>canvas.create_arc((2,2,152,152), fill="#FAF402", outline="#FAF402", start=angle(0), extent = <strong>angle(200)</strong>)</pre>
<p>You can check out an example of a pie chart in <kbd>8.02_pie_chart.py</kbd>.</p>
<p>Next, the bar graph. This is very simple. We use <kbd>create_rectangle</kbd> to draw a bar graph:</p>
<pre>plot_data= [random.randint(75,200) for r in range(12)]<br/>for x, y in enumerate(plot_data):<br/>  x1 = x + x * bar_width<br/>  y1 = canvas_height - y <br/>  x2 = x + x * bar_width + bar_width<br/>  y2 = canvas_height<br/>  canv.create_rectangle(x1, y1, x2, y2, fill="blue")<br/>  canv.create_text(x1+3, y1, font=("", 6),<br/>    text=str(y),anchor='sw' )</pre>
<p>One important thing to note here. Since the Canvas widget represents the <kbd>y</kbd> coordinate starting from the top-left corner, we need to subtract the <kbd>y</kbd> position from the canvas height to get the <kbd>y</kbd> coordinate for the graphs.</p>
<p>You can check out the complete code of the bar graph in <kbd>8.03_bar_graph.py</kbd>.</p>
<p>Similarly, we use the <kbd>create_oval</kbd> method to draw the scatter plot. Check out the code for the scatter plot in <kbd>8.04_scatter_plot.py</kbd><em>.</em> </p>
<p>Next, let us see how to embed <kbd>matplotlib</kbd> graphs in Tkinter.</p>
<p>Using the Tkinter canvas to draw graphs may work fine for trivial cases. However, Tkinter is not the best choice when it comes to drawing more sophisticated and interactive graphs.</p>
<p>Several Python modules have been developed for making graphs. However, <kbd>matplotlib</kbd> stands out as a clear winner for producing professional-quality interactive graphs with Python.</p>
<p>Although a detailed discussion on <kbd>matplotlib</kbd> is beyond the scope of this book, we will take a brief look at embedding matplotlib-generated graphs on a Tkinter canvas.</p>
<p>You can install <kbd>matplotlib</kbd> and NumPy (a dependency for <kbd>matplotlib</kbd>) using the following commands:</p>
<pre><strong>pip3 install matplotlib<br/></strong><strong>pip3 install numpy</strong></pre>
<p>The <kbd>matplotlib</kbd> targets many types of use cases and output formats. Some of the different use cases for <kbd>matplotlib</kbd> are to:</p>
<ul>
<li>Make interactive graphs from the Python shell</li>
<li>Embed <kbd>matplotlib</kbd> in GUI modules such as Tkinter, wxPython, or PyGTK</li>
<li>Generate postscript images from simulations</li>
<li>Serve on web pages from backend web servers</li>
</ul>
<p>In order to target all these use cases, <kbd>matplotlib</kbd> uses the concept of a backend. In order to display a <kbd>matplotlib</kbd> graph on Tkinter, we use a backend called <kbd>TkAgg</kbd>.</p>
<p>We import the backend into <kbd>matplotlib</kbd> as follows:</p>
<pre>import tkinter as tk<br/>from numpy import arange, sin, pi<br/>from matplotlib.backends.backend_tkagg import FigureCanvasTkAgg,NavigationToolbar2TkAgg<br/>from matplotlib.figure import Figure</pre>
<p>We then create the <kbd>matplotlib</kbd> graph as we would normally do in the <kbd>matplotlib</kbd> API:</p>
<pre>f = Figure(figsize=(5,4), dpi=100)<br/>a = f.add_subplot(111)<br/>t = arange(-1.0, 1.0, 0.001)<br/>s = t*sin(1/t)<br/>a.plot(t, s)</pre>
<p>Finally, we embed the generated graph in the <kbd>tkinter</kbd> main loop using the <kbd>TkAgg</kbd> backend as follows:</p>
<pre>canvas = FigureCanvasTkAgg(f, master=root)<br/>canvas.get_tk_widget().pack(side=tk.TOP, fill=tk.BOTH, expand=1)</pre>
<p>We can also embed the navigation toolbar of <kbd>matplotlib</kbd> using the command:</p>
<pre>toolbar = NavigationToolbar2TkAgg(canvas, root )<br/>toolbar.update()</pre>
<p>The preceding code (<kbd>8.05_matplotlib_embedding_graphs.py</kbd>) generates a graph as shown in the following diagram:</p>
<div class="CDPAlignCenter CDPAlign"><img height="334" src="assets/5cde33cc-6f63-4a28-9a94-fb9ce7b86b51.png" width="364"/></div>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Polar plots with Tkinter</h1>
                </header>
            
            <article>
                
<p>A point in space can be represented using the Cartesian coordinate using two numbers <strong>x</strong> and <strong>y</strong>.  The same point can also be represented in the polar coordinate by using the distance from the origin (<strong>r</strong>) and the angle from the <em>x</em> axis (theta), as shown in the following diagram:</p>
<div class="CDPAlignCenter CDPAlign"><img height="143" src="assets/eefd2e49-44e1-4572-b7de-e4df3234d708.png" width="235"/></div>
<p>To convert between polar and Cartesian coordinates, we use the following equalities:</p>
<p class="CDPAlignCenter CDPAlign"><em>x= r cos(θ) and y = rsin(θ)</em></p>
<p>It is easier to plot equations expressed in terms of <strong>r</strong> and <strong>θ</strong> on a special kind of graph called the <strong>polar plot</strong>, which is divided into small concentric circles and radial lines emanating from the center. The radial lines are normally spaced at intervals of 15◦, while the radius of concentric circles depends on the scale on which the distance is to be measured from the center.  Here's an example of a polar plot that we will draw:</p>
<div class="CDPAlignCenter"><img src="assets/39b67f13-33c1-42c4-b2ad-46c1b2ddfd13.png"/></div>
<p>The Tkinter canvas understands Cartesian coordinates. It is, however, easy to convert from polar to Cartesian coordinates. We  accordingly define a method named <kbd>polar_to_cartesian</kbd><span>; see</span> <kbd>8.06_polar_plot.py</kbd>:</p>
<pre>def polar_to_cartesian(r, theta, scaling_factor, x_center, y_center):<br/> x = r * math.cos(theta) * scaling_factor + x_center<br/> y = r * math.sin(theta) * scaling_factor + y_center<br/> return(x, y)</pre>
<p>Here's a brief description of the preceding code:</p>
<ul>
<li><span>The method converts an input of  (</span><kbd>r</kbd><span>, <kbd>theta</kbd>) value to (<kbd>x</kbd>, <kbd>y</kbd>) coordinates using the equalities </span><em>x= r cos(</em><span><em>θ) and y = rsin(θ)</em>.</span></li>
<li>The <kbd>scaling_factor</kbd> <span>in the preceding equation decides how many pixels will equal to one unit in our polar plot and is set to a constant value. Changing it changes the size of the plot.</span></li>
<li>We add the <kbd>x_center</kbd> <span>and</span> <kbd>y_center</kbd> <span>values to the final results.</span> <kbd>x_center</kbd> <span>is defined as half the</span> <kbd>window_width</kbd> <span>while</span> <kbd>y_center</kbd> <span>is half the window size. We add these as offsets because Canvas considers (<em>0</em></span>,<span><em>0</em>) as the top left of the canvas, while we want to consider the center of the canvas as (</span><span><em>0</em></span>,<span><em>0</em>)</span><span>.</span></li>
</ul>
<p>We begin by creating a canvas in a Tkinter root window, and add radial lines and concentric circles to the canvas using the following code:</p>
<pre># draw radial lines at interval of 15 degrees<br/>for theta in range(0,360,15): <br/> r = 180<br/> x, y = x_center + math.cos(math.radians(theta))*r, \<br/>        y_center - math.sin(math.radians(theta)) *r<br/> c.create_line(x_center, y_center, x, y, fill='green', dash=(2, 4),\<br/>               activedash=(6, 5, 2, 4) )<br/> c.create_text(x, y, anchor=W, font="Purisa 8", text=str(theta) + '°')<br/><br/># draw concentric_circles<br/>for radius in range(1,4):<br/> x_max = x_center + radius * scaling_factor<br/> x_min = x_center - radius * scaling_factor<br/> y_max = y_center + radius * scaling_factor<br/> y_min = y_center - radius * scaling_factor<br/> c.create_oval(x_max, y_max, x_min, y_min, width=1, outline='grey', \<br/>               dash=(2, 4), activedash=(6, 5, 2, 4))</pre>
<p>Now that our graph paper is ready, it's time to plot the actual polar plot. The following code plots <kbd>3000</kbd> points of the polar equation <kbd>r = 2*math.sin(2*theta)</kbd><span> </span>on the graph:</p>
<pre>for theta in range(0, 3000):<br/>  r = 2*math.sin(2*theta)<br/>  x, y = polar_to_cartesian(r, theta, scaling_factor, x_center, y_center)<br/>  c.create_oval(x, y, x, y, width=1, outline='navy')</pre>
<p>This creates the curve of the <kbd>form. r = a sin nθ</kbd>, where <kbd>n</kbd> is even. It is a  <strong>2n-leaved rose</strong>. If <kbd>n</kbd> is odd, it will form an <strong>n-leaved rose</strong>. There are many other good looking plots that you can plot by changing the <kbd>r</kbd> equation in the previous method. A few other equations that you can try are as follows:</p>
<pre><span>r = 0.0006 * theta   # an archimedean spiral</span><br/><span>r = 1 + 2*math.cos(theta) # cardoid pattern</span><br/><span>r = 3 * math.cos(theta) # circle</span><br/><span>r = 2*math.sin(5*theta) # 5 leaved rose</span><br/><span>r = 3 * math.cos(3*theta) # 3 leaved rose</span><br/><span>r = 2 * math.sin(theta)**2 # a  lemniscate</span><br/><span>r = (4 * math.cos(2*theta))**1/2 # another lemniscate</span></pre>
<p>You can also play with the parameters of the individual equation to see the difference they make to the plot.</p>
<p>This concludes the iteration.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Gravity simulation</h1>
                </header>
            
            <article>
                
<p>Let's now simulate gravity. We will simulate the movement of four planets (Mercury, Venus, Earth, and Mars), and our very own Moon, using<span> </span>Newton's law of universal gravitation.</p>
<p>Our simulation assumes the Sun at the center, but it does not draw an oval for the Sun as that would make our planets invisible at that scale. Our simulation programs shows the four planets and moon revolving in circular orbits (<kbd>8.07_gravity_simulation.py</kbd>):</p>
<div class="CDPAlignCenter CDPAlign"><img height="205" src="assets/2abbba07-1d86-4467-93b2-7e166b78f881.png" width="223"/></div>
<div class="packt_infobox">While the system could be extended to include other planets from the solar system - putting them all on the rectangular window of our screen would not be possible as the differences in planet sizes and distances are so disproportionate that making one planet, such as Jupiter, show up would make sizes and distances of planets such as Earth  smaller than a pixel, making them invisible. So our visualization sticks to just the four relatively nearby planets and our Moon. A very insightful interactive visualization of the entire solar system, titled <em>If the moon were only 1 pixel</em>, can be found here:<span> </span><a href="http://joshworth.com/dev/pixelspace/pixelspace_solarsystem.html">http://joshworth.com/dev/pixelspace/pixelspace_solarsystem.html</a>.</div>
<p class="mce-root"><span>Newton's law of gravitation</span> established the fact that gravitation is universal and that all objects attract each other with a force of gravity that is related to the mass of the two bodies and the distance between them, using this formula:</p>
<div class="CDPAlignCenter CDPAlign"><img class="fm-editor-equation" height="37" src="assets/9677f10d-b22c-4e26-adf1-a08659666779.png" width="118"/></div>
<p>Where:</p>
<ul>
<li class="mce-root"><strong>F</strong> = Force of attraction between two objects </li>
<li class="mce-root"><strong>m1</strong> = Mass of object 1</li>
<li class="mce-root"><strong>m2</strong> = Mass of object 2</li>
<li class="mce-root"><strong>d</strong> = Distance between the two objects</li>
<li class="mce-root"><strong>G</strong> = 6.673 x 10<sup>-11</sup><span> </span>N m<sup>2</sup>/kg<sup><sup>2</sup></sup></li>
</ul>
<p>Once the preceding equation yields us the gravitational force, we can then find the angular velocity of the object using this formula:  </p>
<div class="CDPAlignCenter CDPAlign"><img class="fm-editor-equation" height="48" src="assets/9fc254f4-bbb3-48e2-a944-e1dd6f513c77.png" width="271"/></div>
<p>The preceding formula holds true for motion in circular paths, which is somewhat an approximation of the actual motion of planets in an elliptical orbit. With angular velocity in hand, we can get the angular position (θ):</p>
<div class="CDPAlignCenter CDPAlign"><img class="fm-editor-equation" height="16" src="assets/d7681fc0-bc81-4a5e-b733-fe16083c3cbb.png" width="60"/></div>
<p>With the distance from the Sun (center) and θ in hand, we can convert it from a polar coordinate to a Cartesian coordinate as we have done in previous examples. Next, it's just a matter of drawing spheres on the Tkinter canvas at various locations.</p>
<p>With the formulas in hand, we define a <kbd>Planet</kbd> class (<kbd>8.07_gravity_simulation.py</kbd>):</p>
<pre>class Planet:<br/> sun_mass = 1.989 * math.pow(10, 30)<br/> G = 6.67 * math.pow(10, -11)<br/><br/> def __init__(self, name, mass, distance, radius, color, canvas):<br/>  self.name = name<br/>  self.mass = mass<br/>  self.distance = distance<br/>  self.radius = radius<br/>  self.canvas = canvas<br/>  self.color = color<br/>  self.angular_velocity = -math.sqrt(self.gravitational_force() /<br/>                          (self.mass * self.distance))<br/>  self.oval_id = self.draw_initial_planet()<br/>  self.scaled_radius = self.radius_scaler(self.radius)<br/>  self.scaled_distance = self.distance_scaler(self.distance)</pre>
<p>While most of the preceding code is a simple instantiation of variables, note that it takes in a canvas as an input on which it will draw the planet.</p>
<p>We also need to scale down the planet distances and radii to fit into our window screen, so we have defined two methods in the class to scale distance and radius (<kbd>8.07_gravity_simulation.py</kbd>):</p>
<pre>def distance_scaler(self, value):<br/>  #[57.91, 4497.1] scaled to [0, self.canvas.winfo_width()/2]<br/>  return (self.canvas.winfo_width() / 2 - 1) * (value - 1e10) /  <br/>    (2.27e11 - 1e10) + 1 <br/><br/>def radius_scaler(self, value):<br/>  #[2439, 6051.8] scaled to [0, self.canvas.winfo_width()/2]<br/>  return (16 * (value - 2439) / (6052 - 2439)) + 2</pre>
<p>For scaling the distance, we take the maximum distance and scale it to fit in half of the canvas width. For scaling radius, we take the maximum and minimum radii from the first four planets and multiply them with the arbitrary number 16, so that the planets' scales look acceptable on the screen. Most of the preceding code was obtained by experimenting with what looks best on the screen, and the numbers were chosen <span>purely</span><span> </span><span>arbitrarily.</span></p>
<p>The constructor then calls a method, <kbd>draw_initial_planet</kbd>, which creates an oval of a scaled radius and at a scaled distance on the canvas. It also returns the unique ID of the created oval so that the oval's position can be updated using the id as a handle.</p>
<p>We then define two helper methods using the formulas we discussed earlier:</p>
<pre class="mce-root">def gravitational_force(self):<br/> force = self.G * (self.mass * self.sun_mass) / math.pow(self.distance, 2)<br/> return force<br/><br/>def angular_position(self, t):<br/> theta = self.angular_velocity * t<br/> return theta</pre>
<p class="mce-root">Now we calculate the angular position (<kbd>theta</kbd>), convert it from polar to Cartesian coordinates, and update the <em>x</em>, <em>y</em> position for the oval pertaining to the planet. We also leave a 1-pixel trail for the planet's position using <kbd>create_rectangle</kbd>:</p>
<pre class="mce-root">def update_location(self, t):<br/> theta = self.angular_position(t)<br/> x, y = self.coordinates(theta)<br/> scaled_radius = self.scaled_radius<br/> self.canvas.create_rectangle(x, y, x, y, outline="grey")<br/> self.canvas.coords(self.oval_id, x - scaled_radius, y - scaled_radius,<br/>                   x + scaled_radius, y + scaled_radius)</pre>
<p>The code to convert from polar to Cartesian coordinates is as follows:</p>
<pre class="mce-root">def coordinates(self, theta):<br/> screen_dim = self.canvas.winfo_width()<br/> y = self.scaled_distance * math.sin(theta) + screen_dim / 2<br/> x = self.scaled_distance * math.cos(theta) + screen_dim / 2<br/> return (x, y)</pre>
<p>Next, we define a <kbd>Moon</kbd> class, which is similar in all aspects to the <kbd>Planet</kbd> class, so it inherits from the <kbd>Planet</kbd> class. However, the most important difference is that instead of taking distance from the Sun and the mass of the Sun as a reference, it takes distance from Earth and the mass of Earth as a reference. <span>As scaling on actual values would have made the Moon's size smaller than 1 pixel, w</span>e have also hardcoded the scaled distance and scaled radius values for Moon to make it visible on the screen. Since Moon needs to go round Earth, we also need to pass Earth as an extra argument to the <kbd>__init__</kbd> method of the <kbd>Moon</kbd> class (<kbd>8.07_gravity_simulation.py</kbd>).</p>
<p>Finally, we create the four planets and the Moon, passing in their actual values taken from Wikipedia:</p>
<pre>#name,mass,distance,radius, color, canvas<br/>mercury = Planet("Mercury", 3.302e23, 5.7e10, 2439.7, 'red2', canvas)<br/>venus = Planet("Venus", 4.8685e24, 1.08e11, 6051.8, 'CadetBlue1', canvas)<br/>earth = Planet("Earth", 5.973e24, 1.49e11, 6378, 'RoyalBlue1', canvas)<br/>mars = Planet("Mars", 6.4185e23, 2.27e11, 3396, 'tomato2', canvas)<br/>planets = [mercury, venus, earth, mars]<br/>moon = Moon("Moon", 7.347e22, 3.844e5, 173, 'white', canvas, earth)</pre>
<p>Then we create a Tkinter canvas and define an <kbd>update_bodies_positions</kbd> method that runs every 100 ms, as follows:</p>
<pre class="mce-root">time = 0<br/>time_step = 100000<br/><br/>def update_bodies_position():<br/> global time, time_step<br/> for planet in planets:<br/>   planet.update_location(time)<br/> moon.update_location(time)<br/> time = time + time_step<br/> root.after(100, update_bodies_position)</pre>
<p class="mce-root">That concludes the gravity simulation project. If you now go and run <kbd>8.07_gravity_simulation.py</kbd>, you can see the planets and our Moon responding to gravitational force.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Drawing fractals</h1>
                </header>
            
            <article>
                
<p>A fractal is a never-ending pattern that repeats itself at all scales. Fractals are found everywhere in nature. We find them in our blood vessels, branches of trees, and in the structure of our galaxies, and the beauty of them lies in the fact that they are made out of simple formulas. </p>
<p>We will demonstrate the simplicity of these seemingly complex-looking phenomena by drawing a fractal named a Mandelbrot set. <span>We assume a basic knowledge of set theory and complex numbers in this section. </span> Our code produces a Mandelbrot set that looks like the following diagram:</p>
<div class="CDPAlignCenter CDPAlign"><img height="218" src="assets/bf88fd1a-298b-4302-b1b2-7cf48f33b8a4.png" width="200"/></div>
<p>The Mandelbrot set  is defined as a set of complex numbers, <em>c</em><span>:</span></p>
<div class="CDPAlignCenter CDPAlign"><img class="fm-editor-equation" height="32" src="assets/aa4f32fe-a773-4ebd-92a8-52c2036389f3.png" width="241"/></div>
<p><span>So that the complex number <em>c</em> obeys the following recurrence relation:</span></p>
<div class="CDPAlignCenter CDPAlign"><img class="fm-editor-equation" height="23" src="assets/dc255dd5-3718-4b28-a33e-0ab66f2d6417.png" width="109"/></div>
<p><span>Think of recurrence relations as functions where the last output is fed as input into the same function in the next iteration.</span></p>
<p><span>So the Mandelbrot set is a set that only includes those complex numbers for which the previous equation does not, after any number of iterations, blow up the value of <em>z</em></span><sub>n</sub> <span>to infinity.  </span></p>
<p>For a clearer understanding, if we take the number 1 as <em>c</em> and apply it to the preceding equation (note that 1 is also a complex number with no imaginary component—so real numbers are a subset of complex numbers and hence they too lie on the complex plane):</p>
<table style="width: 583px;height: 275px">
<tbody>
<tr>
<td><strong>Value of z after n iterations(z<sub>n</sub>)</strong></td>
<td><strong>Value of z<sub>n+1 =</sub> z<sup>2</sup> <sub>n</sub> + c for c = 1</strong></td>
</tr>
<tr>
<td>z<sub>0</sub></td>
<td>0<sup>2</sup> + 1 = 1</td>
</tr>
<tr>
<td>z<sub>1</sub></td>
<td>1<sup>2</sup> + 1 = 2</td>
</tr>
<tr>
<td>z<sub>2</sub></td>
<td>2<sup>2</sup> +1 = 5</td>
</tr>
<tr>
<td>z<sub>3</sub></td>
<td>5<sup>2</sup> +1 = 26</td>
</tr>
</tbody>
</table>
<p> </p>
<p>It is clear that the previous series will blow up to infinity as the number of iterations tends to infinity. Since this complex number 1 blows up the equation, it is not a part of the Mandelbrot set.</p>
<p>Contrast this with another number, c = -1  the values for which are plotted in the next table:</p>
<table style="width: 593px;height: 363px">
<tbody>
<tr>
<td><strong>Value of z after n  iterations(z<sub>n</sub>)</strong></td>
<td>
<p class="mce-root"><strong>Value of  z<sub>n+1</sub> = z<sup>2</sup> <sub>n</sub> + c for c = -1</strong></p>
</td>
</tr>
<tr>
<td>z<sub>0</sub></td>
<td>0<sup>2</sup> + -1 = -1</td>
</tr>
<tr>
<td>z<sub>1</sub></td>
<td>-1<sup>2</sup> + -1  = 0</td>
</tr>
<tr>
<td>z<sub>2</sub></td>
<td>0<sup>2</sup> + -1 = -1</td>
</tr>
<tr>
<td>z<sub>3</sub></td>
<td>-1<sup>2</sup> + -1 = 0</td>
</tr>
</tbody>
</table>
<p> </p>
<p>Note that you may continue the preceding series up to infinity but the value will keep alternating between <em>-1</em> and <em>0</em>, thus never exploding. This makes the complex number <em>-1</em> eligible for inclusion in the Mandelbrot set.</p>
<p>Now, let us try to model the preceding equation.</p>
<p class="mce-root">One immediate problem to overcome is that we cannot model infinity in the previous equation. Fortunately, it can be seen from the equation that if the absolute value of <em>z</em> <span>ever</span><span> </span><span>exceeds</span> <em>2</em><span>, the equation will eventually blow up.</span></p>
<p class="mce-root">So a definitive way to check whether the equation blows up is to check whether the magnitude of <em>Z &gt; 2</em>. The magnitude of a complex number <em>a + ib</em> is defined as follows:</p>
<div class="CDPAlignCenter CDPAlign"><img class="fm-editor-equation" height="27" src="assets/d870b266-0079-44cd-9d8b-41b99dcae571.png" width="76"/></div>
<p>So in order to check whether a complex number <em>a+ib</em> blows up the preceding equation, we need to check the following:</p>
<div class="CDPAlignCenter CDPAlign"><img class="fm-editor-equation" height="27" src="assets/2ad774df-1d79-44fb-a18f-9db0c23a0821.png" width="110"/></div>
<p>Or:</p>
<div class="CDPAlignCenter CDPAlign"><img class="fm-editor-equation" height="21" src="assets/d8b37d55-6d6d-4991-9c3a-4dc9db53b699.png" width="91"/></div>
<p>The next question to consider is how many times should we iterate <em>Zn</em> to see if its magnitude exceeds <em>2</em> or not?<br/>
The answer to this depends on the kind of image resolution you seek to obtain in the final image. In general, the higher the maximum number of iterations, the greater the image resolution, subject to the limitation of individual pixel size, beyond which you can never go in terms of details. In practice, an iteration of a few hundred times is sufficient. We use a maximum iteration of <kbd>200</kbd> as that is enough to determine whether or not the equation blows up for a small-scale image that we will draw. Accordingly, we define a variable in <kbd>8.08_Mandelbrot.py</kbd> as follows:</p>
<pre>max_number_of_iterations = 200</pre>
<p>Next, we define a method that takes in the real and imaginary components of a complex number, and tells whether the equation blows up for the complex number <span>input</span><span>. </span></p>
<p>For example, the method should return <kbd>2</kbd> for an input of <kbd>1</kbd>, as the path to blow up is sensed right in the second iteration for the input value <kbd>1</kbd>. However, if we give it an input of <kbd>-1</kbd>, the equation never blows up so it runs for the maximum number of iterations and returns the <kbd>maximum_iteration_count</kbd>, which we have defined as <kbd>200</kbd> and is akin to saying that the said number belongs to the Mandelbrot set (<kbd>8.08_Mandelbrot.py</kbd>):</p>
<pre class="mce-root">print(mandelbrot_set_check(1, 0)) # returns 2<br/>print(mandelbrot_set_check(-1, 0)) # returns 200</pre>
<p>Accordingly, we define the <kbd>mandelbrot_set_check</kbd> <span>method</span><span> </span><span>as follows (</span><kbd>8.08_Mandelbrot.py</kbd><span>):</span></p>
<pre>def mandelbrot_set_check(real, imaginary):<br/>  iteration_count = 0<br/>  z_real = 0.0<br/>  z_imaginary = 0.0<br/>  while iteration_count &lt; max_number_of_iterations and \<br/>        z_real * z_real + z_imaginary * z_imaginary &lt; 4.0:<br/>    temp = z_real * z_real - z_imaginary * z_imaginary + real<br/>    z_imaginary = 2.0 * z_real * z_imaginary + imaginary<br/>    z_real = temp<br/>    iteration_count += 1<br/>  return iteration_count</pre>
<p>The code simply implements the recurrence relation for the Mandelbrot set.</p>
<p>While it's sufficient to know whether a complex number lies in the Mandelbrot set, we also keep a track of the iteration count, also called the escape time, which is the number of iterations it took a complex number to blow up, if it does blow up.  If the iteration count returns as <kbd>maximum_number_of_iterations</kbd>, it means the complex number does not blow up the equation and the escape time is infinite, that is, the number is a part of the Mandelbrot set. We keep track of the iteration count as we will use this data to paint areas with different escape times in different colors.</p>
<p class="mce-root"><span>Now that we have a way to tell whether or not a complex number belongs to the Mandelbrot set, we need a set of complex numbers to run through this method. In order to do that, we first define a maximum and a minimum complex number, between which we will check for inclusion in the Mandelbrot set. Note that in the following example, we have set the range of complex numbers between <em>-1.5-1i and 0.7+1i. </em></span></p>
<p>You can try different ranges of these complex numbers, as long as the area falls inside a circle of radius 2,  and it will print different regions of the Mandelbrot set:</p>
<pre><span>min_real, max_real, min_imaginary, max_imaginary = -1.5, 0.7, -1.0, 1.0</span></pre>
<p>Let's next proceed by defining the <kbd>image_width</kbd> and <kbd>image_height</kbd> variables as follows:</p>
<pre>image_width = 512<br/>image_height = 512</pre>
<p>To draw the Mandelbrot set in an image, we need to map each pixel coordinate of the image to our complex numbers. Having defined the maximum and minimum range for the real and imaginary parts of our complex numbers, it's simply a matter of interpolating the complex numbers to map them to the pixel coordinates.</p>
<p>The following two methods do that for us (<kbd>8.08_Mandelbrot.py</kbd>):</p>
<pre>def map_pixels_to_real(x):<br/>  real_range = max_real - min_real<br/>  return x * (real_range / image_width) + min_real<br/><br/>def map_pixels_to_imaginary(y):<br/>  imaginary_range = max_imaginary - min_imaginary<br/>  return y * (imaginary_range / image_height) + min_imaginary</pre>
<p>Now we are ready to draw the actual image. We create a Tkinter root window, draw a canvas atop it, and then run the following loops:</p>
<pre>for y in range(image_height):<br/> for x in range(image_width):<br/>   real = map_pixels_to_real(x)<br/>   imaginary = map_pixels_to_imaginary(y)<br/>   num_iterations = mandelbrot_set_check(real, imaginary)<br/>   rgb = get_color(num_iterations)<br/>   canvas.create_rectangle([x, y, x, y], fill=rgb, width=0)</pre>
<p>The preceding code takes each pixel in the image, maps its <kbd>x</kbd>, <kbd>y</kbd> coordinates to a real and imaginary number respectively, and then send this number out to the <kbd>mandelbrot_set_check</kbd> method, which in turn returns the number of iterations it took for the number to blow up. If the number did not blow up, it returns the value of <kbd>maximum_number_of_iterations. </kbd>With this number in hand, we call another method that gives an RGB color code, which is just based on some arbitrary numbers. It just adds the cosmetic value, and you can play with different arbitrarily designed color mapping schemes to generate Mandelbrot images of different colors. Finally, we use this color to fill the (<em>x</em>, <em>y</em>)<sup>th</sup> pixel on the canvas.</p>
<p>This concludes the iteration. Our code can now generate the Mandelbrot set. However, note that this code takes some time to generate the Mandelbrot set. </p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Voronoi diagrams</h1>
                </header>
            
            <article>
                
<p>We will now draw a Voronoi diagram. Voronoi diagrams are a simple yet very powerful tool used in modeling lots of physical systems. Wikipedia (<a href="https://en.wikipedia.org/wiki/Voronoi_diagram#Applications">https://en.wikipedia.org/wiki/Voronoi_diagram#Applications</a>)  lists more than 20 disciplines of science and technology where Voronoi diagrams are used to model and solve real-world problems. </p>
<p>There are many little variations to the rules for drawing Voronoi diagrams,  but the most common type of Voronoi diagram is made by choosing a finite number of points on a 2D plane. We call these points the seeds or the attractors. The tiny blue dots shown in the following image are attractor points.  We then map or attach all the points on the plane to their nearest attractor point. All points closer to a particular attractor point is drawn in one color, which partitions the plane into what are called <strong>Voronoi cells</strong>, as shown in the following diagram:</p>
<div class="CDPAlignCenter"><img height="216" src="assets/d8f62e37-5420-43f4-bdf0-2f43884694ce.png" width="331"/></div>
<p><span>Voronoi diagrams can be drawn in spaces of arbitrary dimensions, but we stick to studying them in a two-dimensional plane. </span></p>
<p>There are many efficient but complicated algorithms for drawing Voronoi diagrams. However, we will use the simplest <span>algorithm </span><span>to understand. However, being simple comes at a cost. The algorithm requires more time to compute when compared to other faster but more complex algorithms.</span></p>
<p class="mce-root">We will begin by creating a fixed number of random attractor points on a canvas of given width and height. Accordingly, we define three variables in the program (<kbd>8.09_vornoi_diagram.py</kbd>):</p>
<pre>width = 800<br/>height = 500<br/>number_of_attractor_points = 125</pre>
<p>Next, we create a canvas on a Tkinter root window with the preceding width and height and pass the canvas to a method named <kbd>generate_vornoi_diagram</kbd>, which does all the processing and drawing for us. Its code is as follows:</p>
<pre>def create_voronoi_diagram(canvas, w, h, number_of_attractor_points):<br/>  attractor_points = []<br/>  colors = []<br/>  for i in range(number_of_attractor_points):<br/>    attractor_points.append((random.randrange(w), random.randrange(h)))<br/>    colors.append('#%02x%02x%02x' % (random.randrange(256),<br/>                                     random.randrange(256),<br/>                                     random.randrange(256)))<br/>  for y in range(h):<br/>    for x in range(w):<br/>      minimum_distance = math.hypot(w , h )<br/>      index_of_nearest_attractor = -1<br/>      for i in range(number_of_attractor_points):<br/>        distance = math.hypot(attractor_points[i][0] - x, <br/>          attractor_points[i][1] - y)<br/>        if distance &lt; minimum_distance:<br/>          minimum_distance = distance<br/>          index_of_nearest_attractor = i<br/>      canvas.create_rectangle([x, y, x, y], <br/>        fill=colors[index_of_neasrest_attractor], width=0)<br/>  for point in attractor_points:<br/>    x, y = point<br/>    dot = [x - 1, y - 1, x + 1, y + 1]<br/>    canvas.create_rectangle(dot, fill='blue', width=1)</pre>
<p>Here's a brief description of the preceding code:</p>
<ul>
<li>We begin by creating two lists. The first <kbd>for</kbd> loop is used to populate the <kbd>attractor_points</kbd> list with tuples (<em>x</em>, <em>y</em>) for each of the attractor points. We also create another list, <kbd>colors</kbd>, which holds the random color hexadecimal string for the cell of each attractor point.</li>
<li>The second triple nested <kbd>for</kbd> loops goes through each pixel on the canvas and finds the index of the nearest attractor. Once that has been established, it colors the individual pixel using the color assigned to that attractor point.</li>
<li>The last <kbd>for</kbd> loop then draws an overlapping blue colored square for each of the attractor points. This loop is deliberately run last to ensure that the attractor point draws over the colored cell region.</li>
</ul>
<p>Since the preceding code has to go through three nested loops for checking each <em>x</em>,<em>y</em> location on the plane against each attractor point, it has a computational complexity of O<span>(</span>n<span><sup>3</sup></span><span>) as per Big-O notation. This means that the algorithm is not at all scalable to drawing images of larger sizes and explains why this code takes some time to generate the Voronoi diagram, even for this modest-sized image. More efficient algorithms are available and if you do not want to reinvent the wheel, you can even use the <kbd>Voronoi</kbd> class from the <kbd>scipy.spatial</kbd> module to implement this much faster. That is left as an exercise for you to explore.</span></p>
<p>This concludes the section. If you now run the <kbd>8.09_vornoi_diagram.py</kbd><span> program</span><span>, it should generate a Voronoi diagram.</span></p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Spring pendulum simulation</h1>
                </header>
            
            <article>
                
<p>A lot of real-world phenomena can be called <strong>dynamical systems</strong>.  The state of such systems <span>varies with time. Modeling such systems requires the use of</span> <strong>differential equations</strong><span>. We will take here an example of modeling a pendulum attached to a spring, as shown in the following image. The pendulum swings to and fro. Furthermore, since the bob is attached to a spring, the bob also oscillates up and down:</span></p>
<div class="CDPAlignCenter CDPAlign"><span><img height="245" src="assets/1f6149ef-e83f-4274-b07c-ebe23df86a7d.png" width="232"/> </span></div>
<p>We study the evolution of two variables over time:</p>
<ul>
<li class="mce-root">Length l of the spring</li>
<li class="mce-root">Angle (<span>θ</span>) between the spring and the center line, as shown in the preceding diagram.</li>
</ul>
<p class="mce-root">Since there are two variables changing over time, the state of our system at any time can be represented by using four state variables:</p>
<ul>
<li>Spring length (l)</li>
<li>Change in spring length (dl/dt), which is  velocity</li>
<li>Angle (θ)</li>
<li>Change in angle (dθ/dt), which is the angular velocity</li>
</ul>
<p class="mce-root">They are modeled by the following four differential equations:</p>
<ul>
<li><img class="fm-editor-equation" height="41" src="assets/bb296051-9f19-419a-8f0a-ee8f0e9749bc.png" width="64"/></li>
<li><img class="fm-editor-equation" height="45" src="assets/6cad5a03-616a-42d2-9116-a2b0da1c47a2.png" width="308"/></li>
<li><img class="fm-editor-equation" height="42" src="assets/5d321d29-5b86-4872-ad58-deafa87db22d.png" width="64"/></li>
<li><img class="fm-editor-equation" height="48" src="assets/a4b83c6d-bccd-4279-a615-f102a1dc2a8f.png" width="302"/></li>
</ul>
<p>The first equation measures linear velocity, which is the rate of change of <em>L</em> over time. The second equation is a second derivative and gives us the acceleration. The third equation measures change in theta over time and hence represents the angular velocity. The last equation is the second derivative of theta over time and hence it represents the angular acceleration.</p>
<p class="mce-root"><span>Let us begin by defining the following constants:</span></p>
<pre>UNSTRETCHED_SPRING_LENGTH = 30<br/>SPRING_CONSTANT = 0.1<br/>MASS = 0.3<br/>GRAVITY = 9.8<br/>NUMBER_OF_STEPS_IN_SIMULATION = 500</pre>
<p class="mce-root"><span>Accordingly, let us begin by defining the initial value for all these four state variables:</span></p>
<pre class="mce-root">state_vector = [ 1, 1, 0.3, 1 ]  <br/># 4 values represent 'l', 'dl/dt', '<span>θ</span>', 'd<span>θ/dt</span>' respectively</pre>
<p>Then, we define the <kbd>differentials_functions</kbd>  method which returns an array of the four differential functions defined previously:</p>
<pre>def differential_functions(state_vector, time):<br/> func1 = state_vector[1]<br/> func2 = (UNSTRETCHED_SPRING_LENGHT + state_vector[0]) * <br/>   state_vector[3]**2 -  <br/>   (SPRING_CONSTANT / MASS * state_vector[0]) + GRAVITY * <br/>     np.cos(state_vector[2])<br/> func3 = state_vector[3]<br/> func4 = -(GRAVITY * np.sin(state_vector[2]) + 2.0 * state_vector[1] * <br/>   state_vector[3]) / (UNSTRETCHED_SPRING_LENGHT + state_vector[0])<br/> return np.array([func1, func2, func3, func4])</pre>
<p><span>Next, we will use <kbd>scipy.integrate.odeint</kbd>  to solve the differential equations. This method can be used to solve a system of ordinary differential equations of the following form:</span></p>
<div class="CDPAlignCenter CDPAlign"><img class="fm-editor-equation" height="41" src="assets/492ae2f7-b43c-4395-ac54-3ee8545e1644.png" width="144"/></div>
<p><span>Here's the signature of </span><kbd>scipy.integrate.odeint</kbd>:</p>
<pre>scipy.integrate.odeint(func, y0, t, optional arguments)</pre>
<p>Where:</p>
<ul>
<li class="mce-root"><kbd>func</kbd>: Callable(y, t0, ...), which computes the derivative of y at t0</li>
<li class="mce-root"><kbd>y0</kbd>: Array of initial condition (can be a vector)</li>
<li><kbd>t</kbd>: Array of time points for which to solve for y</li>
</ul>
<p>The initial value point should be the first element of this sequence.</p>
<p>This method takes as input the derivative function (<kbd>func</kbd>), an array of initial state values (<kbd>yθ</kbd>),<span> </span>and an array of times (<kbd>t</kbd>). It returns an array of state values corresponding to those times.</p>
<p>Since we are differentiating against time, we need a variable to track time (<kbd>8.10_spring_pendulum.py</kbd>):</p>
<pre>time = np.linspace(0, 37, NUMBER_OF_STEPS_IN_SIMULATION)</pre>
<p>The number <kbd>37</kbd> here is the step size for sampling time. Changing this value will change the speed of simulation.</p>
<p>Now we finally solve the sets of differential equations using <kbd>scipy.integrate.odeint</kbd> as follows <span>(</span><kbd>8.10_spring_pendulum.py</kbd>):</p>
<pre>ode_solution = odeint(differential_functions, state_vector, time)</pre>
<p>Since we have set the number of simulation steps to 500 and there are four state variables, the <kbd>odeint</kbd> method returns a numpy array of the shape (<em>500</em>, <em>4</em>), where each row represents the value of the four state variables at a given point of time.</p>
<p>Now recall that our state vector is a list of four values, <kbd>['l', 'dl/dt', 'θ', 'dθ/dt']</kbd>. So the 0<sup>th</sup> column returns the value <kbd>'l'</kbd> and the 2<sup>nd</sup> column represents the value <kbd>'<span>θ</span>'</kbd>.  This is the polar format representation. Our canvas understands the Cartesian coordinate system. So we obtain the Cartesian coordinates (<em>x</em>, <em>y</em>) for the values of each value of (<em>l</em>, <em>θ</em>) as follows <span>(</span><kbd>8.10_spring_pendulum.py</kbd><span>):</span></p>
<pre>x_coordinates = (UNSTRETCHED_SPRING_LENGHT + ode_solution[:, 0]) <br/>                * np.sin(ode_solution[:, 2])<br/>y_coordinates = (UNSTRETCHED_SPRING_LENGHT + ode_solution[:, 0]) <br/>                * np.cos(ode_solution[:, 2])</pre>
<p>With that data in hand, it's now just a matter of plotting it on the canvas. So we create a Canvas widget in a <kbd>mainloop</kbd> and call an <kbd>update_graph </kbd><span>method</span><span> </span><span>that runs every 15 milliseconds, deleting everything on the canvas and redrawing the line and an oval (pendulum bob).  We also add an increment variable, </span><kbd>plot_step</kbd><span>, which is reset to zero every time the simulation ends. This keeps the pendulum swinging forever </span><span>(</span><kbd>8.10_spring_pendulum.py</kbd><span>):</span></p>
<pre>plot_step = 0<br/><br/>def update_graph():<br/> global plot_step<br/> if plot_step == NUMBER_OF_STEPS_IN_SIMULATION: # simulation ended<br/>   plot_step = 0 # repeat the simulation<br/> x, y = int(x_coordinates[plot_step]) + w / 2, <br/>   int(y_coordinates[plot_step] + h / 2)<br/> canvas.delete('all')<br/> canvas.create_line(w / 2, 0, x, y, dash=(2, 1), width=1, fill="gold4")<br/> canvas.create_oval(x - 10, y - 10, x + 10, y + 10, outline="gold4", <br/>   fill="lavender")<br/> plot_step = plot_step + 1<br/> root.after(15, update_graph)</pre>
<p class="mce-root">This will create a spring pendulum, as shown in the following screenshot:</p>
<div class="mce-root CDPAlignCenter CDPAlign"><img height="272" src="assets/3eb3d837-7cf3-44c5-8fa4-17e10c581d98.png" width="219"/></div>
<p>That concludes the iteration. You can explore this simulation by changing the values of the constants (mass, spring constant, and gravity). Also, change the initial state vector elements, such as the angle and velocity, and the program should respond as it would in a real-world situation.</p>
<p class="mce-root"><span>We saw how to obtain ODE, which is a derivative with respect to only one variable. </span><span>An extension of this concept is <strong>partial differential equations</strong> (<strong>PDEs</strong>), which are derivatives with respect to several variables.</span> <span>More complex phenomena, such as electromagnetism, fluid mechanics, heat transfer, electromagnetic theory and various biological models, are all modeled by partial differential equations. </span></p>
<div class="packt_tip packt_infobox"><span>The FEniCS computing platform (</span><a href="https://fenicsproject.org/">https://fenicsproject.org/</a>) is a popular open-source software tool <span>for solving PDEs with a Python binding.</span></div>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Chaos game – building triangles out of randomness</h1>
                </header>
            
            <article>
                
<p>The Chaos game refers to the emergence of fractal patterns with random numbers when the selection of random numbers are subject to some constraints. Let's look at the rules of one of the simplest chaos games:</p>
<ol>
<li>We start by creating three points on a plane to form a triangle. </li>
<li>To begin the game, we draw a random point inside the triangle.</li>
<li>We then roll a dice. Given the outcome, we move halfway between the last point and any one of the vertices of the triangle. For example, if the outcome is 1 or 2, we move halfway between the last point and vertex A. If the outcome is 3 or 4, we move halfway from the current point towards vertex B, or if the outcome is 5 or 6, we draw the next point halfway between the current point and vertex C, as shown in the following image. This is repeated over and over again:</li>
</ol>
<div class="CDPAlignCenter"><img height="293" src="assets/4ef6d36e-c739-4336-a64d-c14c1878d497.png" width="467"/></div>
<p>Here is the surprise part of it. While all the points except for the three vertexes were selected at random, the end result is not a haphazard set of points but rather a fractal—a set of repeating patterns of triangles called the Sierpinski triangle, shown in the following screenshot. This, according to some mathematicians, is a glimpse into the orderliness of the universe hidden inside what appears to be otherwise chaotic:</p>
<div class="CDPAlignCenter"><img src="assets/00afbbfe-41d0-4207-8f13-1f0cde1c4f8d.png"/></div>
<div class="packt_infobox">Note that repeating this same rule inside a set of four points does not create a fractal. However, placing some specific kinds of restrictions on the choice of vertices produces a variety of interesting fractal shapes. You can read more about different varieties of fractals generated out of chaos games at <a href="https://en.wikipedia.org/wiki/Chaos_game">https://en.wikipedia.org/wiki/Chaos_game</a>.</div>
<p>Let us now code this program.  We first define the three vertices of the triangle, as shown in the preceding screenshot:</p>
<pre>v1 = (float(WIDTH/2), 0.0)<br/>v2 = (0.00, float(HEIGHT))<br/>v3 = (float(WIDTH), float(HEIGHT))</pre>
<p>Here, <kbd>WIDTH</kbd> and <kbd>HEIGHT</kbd> are the window dimensions.  </p>
<p>Our next task is to choose a random point inside our triangle as the starting point. This can be done using what are called <strong>barycentric coordinates</strong>.</p>
<p>Let <em>V1</em>, <em>V2</em>, <em>V3</em> be the three vertices of a triangle. A point <em>P</em> inside the triangle can be expressed as <em>P = aV<sub>1</sub> + bV<sub>2</sub> + cV<sub>3</sub></em>, where <em>a+b+c=1</em> and <em>a,b,c</em> are each <em>≥ 0</em>. If we know and <em>b</em>, we can calculate <em>c</em> as <em>1-a-b</em>.</p>
<p class="mce-root">So we generate two random numbers, <kbd>a</kbd> and <kbd>b</kbd>, each in the range [<em>0</em>,<em>1</em>] so that their sum ≤ 1. If the sum of two random points exceeds 1, we replace a with 1-a and b with 1-b, so that their sum falls back below 1.  Then,  aV<sub>1</sub> + bV<sub>2</sub> + cV<sub>3</sub> is uniformly distributed inside the triangle.</p>
<p class="mce-root">Now that we have the barycentric coordinates a, b, and c,  we can compute point P inside the triangle as  aV1 + bV2 + cV3. Here is the idea expressed in code (<kbd>8.11_chaos_game.py</kbd>):</p>
<pre>def random_point_inside_triangle(v1, v2, v3):<br/>  a = random.random()<br/>  b = random.random()<br/>  if a + b &gt; 1:<br/>    a = 1-a<br/>    b = 1-b<br/>  c = 1 - a -b<br/>  x = (a*v1[0])+(b*v2[0])+(c*v3[0]);<br/>  y = (a*v1[1])+(b*v2[1])+(c*v3[1]);<br/>  return (x,y)</pre>
<p>We next define a method to calculate the halfway distance between two points:</p>
<pre>def midway_point(p1, p2):<br/>  x = p1[0] + (p2[0] - p1[0]) //2<br/>  y = p1[1] + (p2[1] - p1[1]) //2<br/>  return (x,y)</pre>
<p><span>This is a simple linear interpolation between two points based on the Pythagorean theorem. </span>Note <span>that in Python, the <kbd>/</kbd> operator does floating point division while <kbd>//</kbd> does integer division (dropping the remainder).</span></p>
<p>Next, we put the laws of the game in a method called <kbd>get_next_point</kbd>:</p>
<pre>def get_next_point():<br/>  global last_point<br/>  roll = random.choice(range(6))+1<br/>  mid_point = None<br/>  if roll == 1 or roll == 2:<br/>    mid_point = midway_point(last_point, v1)<br/>  elif roll == 3 or roll == 4:<br/>    mid_point = midway_point(last_point, v2)<br/>  elif roll == 5 or roll == 6:<br/>    mid_point = midway_point(last_point, v3)<br/> last_point = mid_point<br/> return mid_point</pre>
<p>Finally, we create a Tkinter canvas and define a method, <kbd>update</kbd>, to draw the individual pixels every 1 millisecond as follows:</p>
<pre>def update():<br/> x,y = get_next_point()<br/> canvas.create_rectangle(x, y, x, y, outline="#FFFF33")<br/> root.after(1, update)</pre>
<p>Calling this <kbd>update</kbd> method creates the fractal pattern in our chaos game. </p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Phyllotaxy</h1>
                </header>
            
            <article>
                
<p>Phyllotaxy is derived from the Greek words phýllon (meaning leaf) and táxis (meaning arrangement). Accordingly, phyllotaxy is the study of the spiral arrangements found in leaves and flowers. </p>
<p>In this section, we will code the following floral pattern:</p>
<div class="CDPAlignCenter CDPAlign"><img height="188" src="assets/7ddf3794-1d86-4007-895a-699e8f729751.png" width="189"/></div>
<p class="mce-root">The mathematical details for this program have been taken from <em>Chapter 4</em> of the book  <em>Algorithmic Botany of Plants</em>—a PDF of which can be obtained from here: <a href="http://algorithmicbotany.org/papers/abop/abop-ch4.pdf">http://algorithmicbotany.org/papers/abop/abop-ch4.pdf.</a></p>
<p class="mce-root">Here are the two formulas from the chapter that we will be using:</p>
<p><img class="fm-editor-equation" height="23" src="assets/5a5db8a9-72ab-4c74-bc8e-4f56e981f834.png" width="91"/>   and   <img class="fm-editor-equation" height="21" src="assets/a77cada8-49e1-452c-ba4d-5580ccd5e115.png" width="121"/></p>
<p><img class="fm-editor-equation" height="21" src="assets/052e08bf-e3b2-4780-8928-33a38ee15dd1.png" width="42"/> represents the polar coordinate of each point on the canvas. As you shall see, our phyllotaxy will be made up of dots arranged in a spiral pattern. So the variable <em>n</em> in the preceding example represents the count or the index of the <em>n</em><sup>th</sup> dot starting at zero at the center of the spiral. The variable c is used as a scale factor that in turn decides how near or far the dots will appear in the final image. The angle <kbd>137.5</kbd> is related to the golden ratio and the Fibonacci angle and looks the most natural. You can read more about it in the linked PDF.</p>
<p>To begin with, we define all the values that we discussed so far:</p>
<pre>width, height = 500, 500<br/>number_of_dots = 2000<br/>angle = 137.5<br/>scaling_factor = 4<br/>dot_size = 4<br/>n = np.arange(number_of_dots)<br/>r = np.zeros(number_of_dots)<br/>phi = np.zeros(number_of_dots)<br/>x= np.zeros(number_of_dots)<br/>y= np.zeros(number_of_dots)<br/>dots = []<br/>colors = []</pre>
<p>Next, we create a Tkinter canvas and add colors to the <kbd>colors</kbd> list. We also create the dots using <kbd>create_oval</kbd> and save the reference to all ovals in the <kbd>dots</kbd> list:</p>
<pre>for i in n:<br/>  r = (scaling_factor * np.sqrt(i) * 6 ) %256<br/>  color = '#%02x%02x%02x' % (int(r) , 0, 0)<br/>  colors.append(color)<br/>  dots.append(canvas.create_oval(x[i]-dot_size, y[i]-dot_size,<br/>                    x[i]+dot_size, y[i]+dot_size, fill=color ))</pre>
<p>The color defined in the preceding code is based on the value of <kbd>r</kbd> and is purely arbitrary. We could have used any other variable or rule for defining the color.</p>
<p>Lastly, we define the update function, which calculates the value of the <kbd>r</kbd> and <kbd>∅</kbd> values every 15 milliseconds and updates the coordinates of all the ovals on the canvas:</p>
<pre>def update():<br/> global angle<br/> angle +=0.000001<br/> phi = angle * n<br/> r = scaling_factor * np.sqrt(n)<br/> x = r * np.cos(phi) + width/2<br/> y = r * np.sin(phi) + height/2<br/> for i in n:<br/> canvas.coords(dots[i],x[i]-dot_size, y[i]-dot_size,x[i]+dot_size, <br/>   y[i]+dot_size )<br/> root.after(15, update )</pre>
<p>You should now see the phyllotaxy pattern. Try changing all the parameters to see how the image changes.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">3D graphics with Tkinter</h1>
                </header>
            
            <article>
                
<p>Tkinter's Canvas widget provides for drawing with exact coordinate specifications. Therefore, it can be used to create all sorts of 3D graphics. Furthermore, we have already seen the animation abilities of Tkinter. We can apply these abilities to also animate in 3D.</p>
<p>Let's create a simple application where we create a cube in the center. We add event listeners to rotate the cube on mouse events. We also make a small animation in which the cube keeps rotating by itself when no mouse intervention occurs.<br/>
In its final form, the application would look as follows (<kbd>8.13_3D_graphics.py</kbd>):</p>
<p class="CDPAlignCenter CDPAlign"><img height="260" src="assets/dab367b8-d190-4fd3-bc90-e4d34f94ded1.png" width="259"/></p>
<p class="CDPAlignCenter CDPAlign CDPAlignLeft">Transposing or unzipping can be done in Python by using the special * operator, any point in a 3D space can be represented by <em>x</em>, <em>y</em>, and <em>z</em> coordinates. This is usually represented by a vector of the form:</p>
<div class="CDPAlignCenter"><img class="fm-editor-equation" height="21" src="assets/245c7267-8d78-4f8c-b3f8-e95f79a1b053.png" width="128"/></div>
<p>This is an example of a row vector as all three points are written in a single row.</p>
<p>This is convenient for humans to read. However, as per convention and for some mathematical advantage that we will see later, positions are taken as a column vector. So it is written in a column as follows:</p>
<div class="CDPAlignCenter"><img class="fm-editor-equation" height="74" src="assets/dfda0a51-6d8d-4018-bee1-e7dd4a2ccda9.png" width="113"/></div>
<p>Since a shape is a collection of points, it is, therefore, a collection of column vectors. A collection of column vectors is a matrix, where each individual column of the matrix represents a single point in 3D space:</p>
<div class="CDPAlignCenter"><img class="fm-editor-equation" height="74" src="assets/39fe396f-ca68-4f28-8535-9c7100c7a2d1.png" width="333"/></div>
<p class="mce-root">Let's take the example of a cube. A cube has eight defining vertices. A representative cube could have the following eight points with its center located at [<em>0</em>,<em>0</em>,<em>0</em>]:</p>
<pre class="mce-root">Vertex 1 : <span>[-100,-100,-100],</span><br/>Vertex 2 : <span>[-100, 100,-100],</span><br/>Vertex 3: <span>[-100,-100,100],</span><br/>Vertex 4: <span>[-100,100,100],</span><br/>Vertex 5: <span>[100,-100,-100],</span><br/>Vertex 6: <span>[100,100,-100],</span><br/>Vertex 7: <span>[100,-100,100],</span><br/>Vertex 8: <span>[100,100,100]</span></pre>
<p class="mce-root">However, here the vertices are represented as row vectors. To represent the vectors as column vectors, we need to transpose the preceding matrix. Since transposition will be a common operation, let's start by building a class called <kbd>MatrixHelpers</kbd> and defining a method named <kbd>transpose_matrix</kbd>( <kbd>8.13_3D_graphics.py</kbd>):</p>
<pre>class MatrixHelpers():<br/><br/>  def transpose_matrix(self,matrix):<br/>    return list(zip(*matrix))</pre>
<p class="mce-root">Transposing or unzipping can be done in Python by using the special <kbd>*</kbd> operator, which makes zip its own inverse.</p>
<p class="mce-root">Another issue with the preceding coordinates is that it centers at (<em>0</em>,<em>0</em>,<em>0</em>). This means that if we try to plot the preceding points on a canvas, it will show up only partly, centered at the top-left corner of the canvas, something like this:</p>
<div class="mce-root CDPAlignCenter CDPAlign"><img height="148" src="assets/3691b678-dcc7-4559-8ddf-71bf07a5223d.png" width="279"/></div>
<p class="mce-root">We need to move all the points to the center of the screen. We can achieve this by adding <em>x</em> and <em>y</em> offset values to the original matrix.</p>
<p class="mce-root"><br/>
We accordingly define a new method named <kbd>translate_matrix</kbd> as follows:</p>
<pre>def translate_vector(self, x,y,dx,dy):<br/>  return x+dx, y+dy</pre>
<p class="mce-root">Now let's draw the actual cube. We define a new class named <kbd>Cube</kbd> that inherits from the <kbd>MatrixHelper</kbd> class because we want to use the <kbd>transpose_matrix</kbd> and <kbd>translate_vector</kbd> methods defined in the <kbd>MatrixHelper</kbd> class (see <kbd>code 8.13_3D_graphics.py</kbd>):</p>
<pre>class Cube(MatrixHelpers):<br/>  def __init__(self, root):<br/>   self.root = root<br/>   self.init_data()<br/>   self.create_canvas()<br/>   self.draw_cube()</pre>
<p class="mce-root">The <kbd>__init__</kbd> method simply calls four new methods. The <kbd>init_data</kbd> method sets the coordinate values for all the eight vertices of the cube (<kbd>8.13_3D_graphics.py</kbd>):</p>
<pre>def init_data(self):<br/>  self.cube = self.transpose_matrix([<br/>            [-100,-100,-100],<br/>            [-100, 100,-100],<br/>            [-100,-100,100],<br/>            [-100,100,100],<br/>            [100,-100,-100],<br/>            [100,100,-100],<br/>            [100,-100,100],<br/>            [100,100,100]<br/>         ])</pre>
<p class="mce-root">The <kbd>create_canvas</kbd> method creates a <kbd>400</kbd> x <kbd>400</kbd> sized canvas on top of the root window and assigns a background and fill color to the canvas:</p>
<pre> def create_canvas(self):<br/>   self.canvas = Canvas(self.root, width=400, height=400, background=self.bg_color)<br/>   self.canvas.pack(fill=BOTH,expand=YES)</pre>
<p class="mce-root">Lastly, we define the <kbd>draw_cube </kbd><span>method</span><span>, which uses</span> <kbd>canvas.create_line</kbd> <span>to draw </span><span>lines between selected points. We do not want lines between all the points, but rather </span><span>lines between some selected vertices to create a cube. We accordingly define the method as follows (</span><kbd>8.13_3D_graphics.py</kbd><span>):</span></p>
<pre>def draw_cube(self):<br/> cube_points_to_draw_line = [[0, 1, 2, 4],<br/>           [3, 1, 2, 7],<br/>           [5, 1, 4, 7],<br/>           [6, 2, 4, 7]]<br/> w = self.canvas.winfo_width()/2<br/> h = self.canvas.winfo_height()/2<br/> self.canvas.delete(ALL)<br/> for i in cube_points_to_draw_line:<br/>  for j in i:<br/>    self.canvas.create_line(self.translate_vector(self.cube[0][i[0]], <br/>     self.cube[1][i[0]], w, h), <br/>    self.translate_vector(self.cube[0][j], self.cube[1][j], w, h), fill <br/>      = self.fg_color)</pre>
<p class="mce-root"/>
<p class="mce-root">This code draws a cube on the canvas. However, since the cube draws upfront, all we see is a square from the front. In order to see the cube, we need to rotate the cube to a different angle. That brings us to the topic of 3D transformations.</p>
<p class="mce-root">A wide variety of 3D transformations, such as scaling, rotation, shearing, reflection, and orthogonal projections, can be accomplished by multiplying the shape matrix with another matrix known as a transformation matrix.</p>
<p class="mce-root">For example, the transformation matrix for scaling a shape is:</p>
<div class="mce-root CDPAlignCenter"><img class="fm-editor-equation" height="101" src="assets/063945c9-1566-4227-9861-69c36eb9efaa.png" width="450"/></div>
<p class="mce-root">Where <em>S</em><sub>x</sub>, <em>S</em><sub>y</sub>, and <em>S</em><sub>z</sub> are scaling factors in <em>x</em>, <em>y</em>, and <em>z</em> directions. Multiply any shape matrix with this matrix and you get the matrices for the scaled shape.</p>
<p class="mce-root"><br/>
Let's, therefore, add a new method named <kbd>matrix_multiply</kbd> to our <kbd>MatrixHelper</kbd> class (<kbd>8.13_3D_graphics.py</kbd>):</p>
<pre>def matrix_multiply(self, matrix_a, matrix_b):<br/>  zip_b = list(zip(*matrix_b))<br/>  return [[sum(ele_a*ele_b for ele_a, ele_b in zip(row_a, col_b)) <br/>          for col_b in zip_b] for row_a in matrix_a]</pre>
<p class="mce-root">Next, let's add the ability to rotate the cube. We will be using the rotation transformation matrix. Furthermore, since rotation can happen along any of the <em>x</em>, <em>y</em>, or <em>z</em> axes, there are actually three different transformation matrices. The three rotation matrices are as follows:</p>
<div class="mce-root CDPAlignCenter CDPAlign"><img class="fm-editor-equation" height="76" src="assets/4dcd5250-3d43-4975-9566-ea5afea1faa1.png" width="727"/></div>
<p class="mce-root">Multiply the shape coordinates by the first matrix for a given value of <em>a</em> and you get the shape rotated by an angle <em>a</em> about the <em>x </em>axis in a counterclockwise direction. Similarly, the other two matrices rotate along the <em>y </em>axis and <em>z </em>axis respectively. </p>
<p class="mce-root">To rotate in a clockwise direction, we simply need to flip the sign of all sin values in the preceding matrix.<br/>
Note, however, that the order of rotation matters. So if you first rotate along the <em>x </em>axis and then rotate along the <em>y </em>axis, it is not the same as first rotating along <em>y</em> and then along the <em>x </em>axis.</p>
<div class="mce-root packt_infobox">More details on rotation matrices can be found at <a href="https://en.wikipedia.org/wiki/Rotation_matrix">https://en.wikipedia.org/wiki/Rotation_matrix</a>.<a href="https://en.wikipedia.org/wiki/Rotation_matrix"/></div>
<p class="mce-root">So now that we know the three rotation matrices, let's define the following three methods in our <kbd>MatrixHelper</kbd> class (<kbd>8.13_3D_graphics.py</kbd>):</p>
<pre>def rotate_along_x(self, x, shape):<br/>   return self.matrix_multiply([[1, 0, 0],<br/>                                [0, cos(x), -sin(x)], <br/>                                [0, sin(x), cos(x)]], shape)<br/><br/>def rotate_along_y(self, y, shape):<br/>   return self.matrix_multiply([[cos(y), 0, sin(y)], <br/>                                [0, 1, 0], <br/>                                [-sin(y), 0, cos(y)]], shape)<br/> <br/>def rotate_along_z(self, z, shape):<br/>   return self.matrix_multiply([[cos(z), sin(z), 0],<br/>                                [-sin(z), cos(z), 0], <br/>                                [0, 0, 1]], shape)</pre>
<p class="mce-root">Next, we define a method named <kbd>continually_rotate</kbd> and call this method from the <kbd>__init__</kbd> method of our <kbd>Cube</kbd> class:</p>
<pre>def continually_rotate(self):<br/> self.cube = self.rotate_along_x(0.01, self.cube)<br/> self.cube = self.rotate_along_y(0.01, self.cube)<br/> self.cube = self.rotate_along_z(0.01, self.cube)<br/> self.draw_cube()<br/> self.root.after(15, self.continually_rotate)</pre>
<p class="mce-root">The method uses <kbd>root.after</kbd> to call itself back every 15 milliseconds. At each loop, the coordinates of the cube are rotated by <kbd>0.01</kbd> degrees along all three axes. This is followed by a call to draw the cube with a fresh set of coordinates. Now, if you run this code, the cube rotates continuously.</p>
<p class="mce-root">Next, let's bind the rotation of the cube to a mouse button click and mouse motion. This will let the user rotate the cube by clicking and dragging the mouse over the cube.</p>
<p class="mce-root">Accordingly, we define the following method and call it from the <kbd>__init__</kbd> method of the <kbd>Cube</kbd> class:</p>
<pre>def bind_mouse_buttons(self):<br/>  self.canvas.bind("&lt;Button-1&gt;", self.on_mouse_clicked)<br/>  self.canvas.bind("&lt;B1-Motion&gt;", self.on_mouse_motion)</pre>
<p class="mce-root">The methods linked from the preceding event binding are defined as follows:</p>
<pre>def on_mouse_clicked(self, event):<br/>  self.last_x = event.x<br/>  self.last_y = event.y<br/><br/>def on_mouse_motion(self, event):<br/>  dx = self.last_y - event.y<br/>  self.cube = self.rotate_along_x(self.epsilon(-dx), self.cube)<br/>  dy = self.last_x - event.x<br/>  self.cube = self.rotate_along_y(self.epsilon(dy), self.cube)<br/>  self.draw_cube()<br/>  self.on_mouse_clicked(event)</pre>
<p class="mce-root">Note that the preceding method maps mouse displacements along the <em>y </em>axis to rotations along the <em>x </em>axis and vice versa.<br/>
Also, note that the last line of the code calls <kbd>on_mouse_clicked()</kbd> to update the value of <kbd>last_x</kbd> and <kbd>last_y</kbd>. If you skip that line, the rotation becomes exceedingly fast as you increase the displacement from the last clicked position.</p>
<p class="mce-root">The method also refers to another method, named epsilon, which translates the distance into an equivalent angle for rotation. The epsilon method is defined as follows:</p>
<pre>self.epsilon = lambda d: d * 0.01</pre>
<p class="mce-root">The epsilon here is obtained by multiplying the displacement, d, with an arbitrary value of 0.01. You can increase or decrease the sensitivity of rotation to mouse displacement by changing this value.</p>
<p class="mce-root">Now the cube becomes responsive to mouse click and drag over the canvas. This concludes the last project of this chapter.</p>
<p class="mce-root">Here, we have just scratched the surface of 3D graphics. A much more detailed discussion on 3D programming with Tkinter can be found at <a href="https://sites.google.com/site/3dprogramminginpython/">https://sites.google.com/site/3dprogramminginpython/</a>.<a href="https://sites.google.com/site/3dprogramminginpython/"/></p>
<p class="mce-root">There have also been attempts to further abstract and build 3D programming frameworks for Tkinter. You can find an example of a 3D framework for Tkinter at <a href="https://github.com/calroc/Tkinter3D">https://github.com/calroc/Tkinter3D</a>.<a href="https://github.com/calroc/Tkinter3D"/></p>
<p>That concludes the chapter, and also our experiments with the Canvas widget. In the next chapter, we will look at some of the most commonly recurring themes of writing GUI applications, such as using a queue data structure, database programming, network programming, interprocess communication, use of the <kbd>asyncio</kbd> module, and a few other important concepts in programming.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Summary</h1>
                </header>
            
            <article>
                
<p class="mce-root">Let's summarize the concepts we discussed in this chapter.</p>
<p class="mce-root">We built a screen saver and in the process saw how to implement animations on the Tkinter canvas. Next, we saw how to create Cartesian and polar plots on the canvas. We also saw how to embed <kbd>matplotlib</kbd> plots on a Tkinter window. </p>
<p class="mce-root">We then implemented a basic gravity simulation that showed how we could take a physical model and implement it using a Tkinter canvas. We got a glimpse into the implementation of Voronoi diagrams, which are being used to model and solve so many practical real-world problems.  </p>
<p class="mce-root">We also build some nice visualizations such as the Mandelbrot set and Phyllotaxies.</p>
<p class="mce-root">Finally, we learned how to use a Tkinter canvas to draw and animate 3D graphics using transformation matrices.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">QA section</h1>
                </header>
            
            <article>
                
<p>Here are a few questions to reflect upon:</p>
<ul>
<li>How do you convert between polar and Cartesian coordinates? When should we prefer one coordinate system over the other?</li>
<li>How do you animate on a Tkinter canvas? What determines the speed of the animation?</li>
<li>How do we model real-world phenomena on a Tkinter canvas using differential equations?</li>
<li>What are some real-world applications of fractals?</li>
<li>Fractals are still under active research. Can you find out more about some cutting-edge technology that relies on the use of fractals?</li>
<li>What are some of the real-world applications of Voronoi diagrams?</li>
<li>How can we extend our 3D cube program to show meshes of other objects—say the model of a car, or a human body, or a real-world object?</li>
</ul>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Further reading</h1>
                </header>
            
            <article>
                
<p>A close cousin of the Mandelbrot set is the Julia set. Read about the Julia set and then modify <kbd>8.07_Mandelbrot.py</kbd> to produce a Julia set. Fractals are a very interesting topic to study and a lot of the maths behind them is still unexplored.  Besides the fact that they are beautiful to look at, they are also used in a lot of practical applications. See <a href="https://en.wikipedia.org/wiki/Fractal#Applications_in_technology">https://en.wikipedia.org/wiki/Fractal#Applications_in_technology</a>.<a href="https://en.wikipedia.org/wiki/Fractal#Applications_in_technology"/></p>
<p>If fractals pique your interest, you can also take a look at other variants of the Mandelbrot set such as the M<span>agnet 1 fractal and Buddhabrot. </span></p>
<p>If you are interested in learning more about chaotic behavior, try to plot Hénon’s Function on a Tkinter canvas.</p>
<p>We modeled a spring pendulum and it worked in a deterministic manner. However, adding two pendulums together to form a double pendulum creates a dynamic system that is chaotic. Even though such systems follow the ordinary differential equation, the net outcome may vary immensely, even for a very small change in the initial condition. It may be worth trying to model a double pendulum by modifying our spring pendulum.</p>
<p>We used the built-in odeint method from <kbd>scipy</kbd>. However, we could have written our own variation using either the Euler's method or Runge-Kutta method. You can read more about these numerical methods for approximating ordinary differential equations over here:  <a href="https://en.wikipedia.org/wiki/Numerical_methods_for_ordinary_differential_equations">https://en.wikipedia.org/wiki/Numerical_methods_for_ordinary_differential_equations.</a></p>
<p>If neat or intriguing visualizations looks like a fun thing to do,  here are a few more interesting canvas projects that you can undertake: Barnsley fern, the cellular automata, the Lorenz attractor, and simulating tearable cloth with verlet integration.</p>
<p>Ray tracing is another powerful but very simple to implement 3D rendering technique that can be easily implemented in about 100 lines of code. </p>
<p> </p>
<p> </p>


            </article>

            
        </section>
    </body></html>