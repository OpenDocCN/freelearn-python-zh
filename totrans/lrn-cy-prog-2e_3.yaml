- en: Chapter 3. Extending Applications
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: As mentioned in previous chapters, I want to show you how to interact or extend
    existing code using Cython. So, let's get right to doing that. Cython was originally
    designed to make raw Python computation faster. So, the initial proof of concept
    for Cython was to enable programmers to take existing Python code and use Cython's
    `cdef` keyword to require native typing to bypass the Python runtime for heavy
    computation. The culmination of this is increased performance in the time it takes
    to perform calculations and lower memory usage. It's even possible to write type-safe
    wrappers to existing Python libraries for fully typed Python code.
  prefs: []
  type: TYPE_NORMAL
- en: In this chapter, we will first see an example of typing Python code. Next, I
    will demonstrate the Cython `cdef` class, which allow us to wrap native C/C++
    types into garbage collected Python classes. We will also see how to extend the
    native application **Tmux** with Python code by creating a pure Python command
    object, which is directly embedded into the native code.
  prefs: []
  type: TYPE_NORMAL
- en: 'In this chapter, we will cover the following topics:'
  prefs: []
  type: TYPE_NORMAL
- en: Cython pure Python code
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Compiling pure Python code
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Python garbage collector
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Extending Tmux
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Embedding Python
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Cythonzing struct cmd_entry
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Implementing a Tmux command
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Cython pure Python code
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Let''s view a mathematical application that is actually taken from the Cython
    documentation. I wrote this equivalent in pure Python so that we can compare the
    speed. If you open the `primes` example for this chapter, you will see two programs—the
    Cython `primes.pyx` example, and my pure Python port. They both look almost the
    same:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'This really is a direct Python port of that Cython code. Both call `primes
    (10000)`, but the evaluation time is very different between them in terms of performance:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: You can see that the pure Python version was almost five times slower in doing
    the exact same job. Moreover, nearly every line of code is the same. Cython can
    do this because we have explicitly expressed the C types, hence there is no type
    conversion or folding, and we don't even have to use the Python runtime. I want
    to draw attention to the kind of speedups you can get with just simple code without
    calling into other native libraries. This is what makes Cython so prevalent in
    SAGE.
  prefs: []
  type: TYPE_NORMAL
- en: Compiling pure Python code
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Another use for Cython is to compile Python code. For example, if we go back
    to the `primes` example, we can do the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: 'Then, we can compare the three different versions of the same program: the
    Cython version using `cdef` for native types, the pure Python version running
    as a Python script, and finally, the Cython-compiled pure Python version, which
    results in an executable binary of Python code:'
  prefs: []
  type: TYPE_NORMAL
- en: 'First, the Cython version using native types:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Next, the executable pure Python version:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'And finally, the Python script version:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: The pure Python version runs the slowest, the compiled Python version runs a
    little bit faster, and finally, the natively-typed Cython version runs the fastest.
    I think it just draws attention to how well Cython can give you some dynamic language
    optimizations in several different ways.
  prefs: []
  type: TYPE_NORMAL
- en: Notice that when compiling the Python version to a binary, I specified `–embed`
    on invoking the Cython compiler. This tells the compiler to **--embed** a main
    method for us and to run as you would expect a normal Python script to run.
  prefs: []
  type: TYPE_NORMAL
- en: Avoid Makefiles – pyximport
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: From the previous example, you can see that it was code which didn't depend
    on any outside libraries. To make such code useful, wouldn't it be nice if we
    could bypass the Makefile and the invocation of compilers? It turns out that,
    in cases where we do not require linking against other native libraries, we can
    directly import our `.pyx` files into Python programs. You are required, however,
    to have Cython installed as a dependency.
  prefs: []
  type: TYPE_NORMAL
- en: 'Going back to [Chapter 1](ch01.html "Chapter 1. Cython Won''t Bite"), *Cython
    Won''t Bite*, we can simply import our `helloworld.pyx` by importing `pyximport`
    first:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: Behind the scenes, Cython is invoking all the compiler work for you so that
    you don't have to. But this leads to interesting ideas, such as that you could
    simply add Cython code to any Python project so long as Cython is a dependency.
  prefs: []
  type: TYPE_NORMAL
- en: Python garbage collector
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'When wrapping up native structs, for example, it can be very tempting to follow
    standard C/C++ idioms and require the Python programmer to call, allocate, and
    release manually on different objects. This is very tedious and not very Pythonic.
    Cython allows us to create `cdef` classes, which have extra hooks for initialization
    and deallocation that we can use to control all memory management of structs.
    These hooks are triggered automatically by the Python garbage collector, making
    everything nice and simple. Consider the following simple `struct`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: 'We can then write the Cython declaration of the C `struct` into `PyData.pxd`
    as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: 'Now that we have defined the `struct`, we can wrap up the `struct` into a class:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: 'Wrapping up data into a class like this will require us to allocate and deallocate
    memory at the right moments. Thankfully, Cython exposes almost all of the `libc`
    as imports:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: 'Now that we can allocate memory and free it, all that is left is to understand
    the lifecycle of classes and where to hook into. Cython classes provide two special
    methods: `__cinit__` and `__dealloc__`. The `__cinit__` provides a way of instantiating
    native code, so for our case, we will allocate memory to the native C struct,
    and as you can guess on deallocate this is the destroy hook from the garbage collector
    and gives us a chance to free any allocated resources:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: 'It''s important to note that `__cinit__` doesn''t override Python `__init__`,
    and more importantly, `__cinit__` is not designed to call into any Python code
    at this point as it does not guarantee full initialization of the class. An init
    method might look as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: 'Note that we were able to type the arguments on these functions to ensure that
    we don''t try and put a Python object into the `struct`, which would fail. What
    is impressive here is that this class behaves as if it was just a normal Python
    class:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: If you put a simple `print` statement on the `__dealloc__` hook and run the
    program, you will see all destructors are executed, as you would expect. It means
    we have just leveraged the Python garbage collector on top of native code.
  prefs: []
  type: TYPE_NORMAL
- en: Extending Tmux
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '**Tmux** is a terminal multiplexer inspired by GNU Screen ([http://tmux.github.io/](http://tmux.github.io/)),
    but it supports much simpler and better configuration. More importantly, the implementation
    is much cleaner and easier to maintain, and it also uses `libevent` and very well-written
    C code.'
  prefs: []
  type: TYPE_NORMAL
- en: 'I want to show you how you can extend Tmux with new built-in commands by writing
    Python code instead of C. Overall, there are several parts to this project, as
    follows:'
  prefs: []
  type: TYPE_NORMAL
- en: Hack the autotool's build system to compile in Cython
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Create PXD declarations to the relevant declarations such as `struct cmd_entry`
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Embed Python into Tmux
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Add the Python command to the global Tmux `cmd_table`
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Let''s take a quick look at the Tmux source, and in particular any of the `cmd-*.c`
    files that contain command declarations and implementations. Consider, for example,
    that `cmd-kill-window.c` is the command entry. This tells Tmux the name of the
    command, its alias, and how it may or may not accept arguments; finally, it accepts
    a function pointer to the actual command code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: So, if we are able to implement and initialize our own `struct` containing this
    information, we can run our `cdef` code. Next, we need to look at how Tmux picks
    up this command definition and how it gets executed.
  prefs: []
  type: TYPE_NORMAL
- en: 'If we look at `tmux.h`, we find the prototypes for everything that we need
    to manipulate:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: 'So, we need to add a prototype here for our `cmd_entry` definition. Next, we
    need to look at `cmd.c`; this is where the command table is initialized so that
    it can be looked up later on to execute commands:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: 'Now that the command table is initialized, where does the code get executed?
    If we look at the `cmd_entry` definition in the `tmux.h` header, we can see the
    following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: 'The `execc` hook is the function pointer we really care about, so if you `grep`
    the sources, you should find the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: You might notice that in the official Tmux Git, this hook is simply named `exec`.
    I renamed this to `execc` because `exec` is a reserved word in Python—we need
    to avoid things like that. To begin with, let's get some code compiled. First,
    we need to get the build system to play ball.
  prefs: []
  type: TYPE_NORMAL
- en: Tmux build system
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Tmux uses autotools, so we can reuse the snippets from [Chapter 2](ch02.html
    "Chapter 2. Understanding Cython"), *Understanding Cython*, to add in Python support.
    We can add the `–enable-python` switch into `configure.ac` as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: 'This gives us the `./configure –-enable-python` option. Next, we need to look
    at the `Makefile.am` file. Let''s call our Cython file `cmdpython.pyx`. Note that
    Cython doesn''t like awkward characters such as "`-`" in the filename, as explained
    in [Chapter 2](ch02.html "Chapter 2. Understanding Cython"), *Understanding Cython*.
    If we are to make Python support a conditional option at build time, we should
    add the following to `Makefile.am`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: 'We have to make sure that it is needed and compiled first. Remember that if
    we create `public` declarations, Cython generates a header for us. We will simply
    add our public header to `tmux.h` to keep headers very simple. Then, to make sure
    Cython files get picked up by automake and is compiled properly according to the
    correct dependency management at build time, we need to add the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: 'This adds in the suffix rule to make sure the `*.pyx` files are Cythoned and
    then told to compile the resulting `.c` file just as any normal C file. This snippet
    plays well if you happen to use `AM_SILENT_RULES([yes])` in your autotools project,
    which formats the echo message correctly. Lastly, we need to make sure we add
    the necessary `CFLAGS` and `LIBS` options to the compiler from `AC_SUBST` in the
    configure script:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: Now you should have everything ready in the build system, but we have to regenerate
    the autotools stuff now because of the changes made. Simply run `./autogen.sh`.
  prefs: []
  type: TYPE_NORMAL
- en: Embedding Python
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Now that we have files being compiled, we need to initialize Python. Our module.
    Tmux is a forked server that clients connect to, so try not to think of it as
    a single-threaded system. It''s a client *and* a server, so all commands are executed
    on the server. Now, let''s find where the event loop is started in the server,
    and initialize and finalize the server here so that it''s done correctly. Looking
    at `int server_start(int lockfd, char *lockfile)`, we can add the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: Python is now embedded into the Tmux server. Notice that instead of using simply
    `Py_Initialize`, I used `Py_InitializeEx (0)`. This replicates the same behavior,
    but doesn't start up normal Python signal handlers. Tmux has its own signal handlers,
    so I don't want to override them. It's probably a good idea when extending established
    applications such as this to use `Py_InitializeEx (0)`, since they generally implement
    their own signal handling. Using this stops Python from trying to handle signals
    that would conflict.
  prefs: []
  type: TYPE_NORMAL
- en: Cythonizing struct cmd_entry
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Next, let''s consider creating a `cythonfile.pxd` file for the necessary `cdef`
    declarations of Tmux that we need to be aware of. We need to look at the `struct
    cmd_entry` declaration, and work backwards from this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: As you can see, `cmd_entry` depends on several other types, so we need to work
    backwards a little bit. If you're going to be lazy and live dangerously, you can
    get away with it sometimes if you don't care about accessing the data correctly
    by casting any pointers such as `void *`. But if you're a seasoned C programmer,
    you know this is fairly dangerous and should be avoided. You can see this type
    depends on `struct cmd *`, `struct cmd_q *`, and `struct args *`. We would ideally
    want to access these at some point, so it's a good idea to work backwards and
    implement them one at a time, since the rest are just native C types, which Cython
    understands.
  prefs: []
  type: TYPE_NORMAL
- en: 'Implementing the `enum` should be by far the simplest:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: 'Then, turn it into the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: 'Now that we have the return value for the `exec` hook, we need to look at `struct
    cmd` next and implement it:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: 'Take a look at `TAILQ_ENTRY`. This is simply a preprocessor macro that is a
    **BSD libc** extension to turn any type into its own linked list. We can ignore
    this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: 'Note that this `struct` depends on the `struct cmd_entry` and `struct args`
    definitions, which we haven''t implemented yet. Don''t worry about this yet; just
    put them in for now. Next, let''s implement `struct args`, since it''s simple:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: 'Note that it uses `bitstr_t` and a variable-length array list. I choose to
    ignore `bitstr_t` because I think it''s a system-dependent header that is fairly
    tricky to implement. Let''s simply cast these as `char *` and `char **` to get
    things working:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: 'Now that the `args` structure is Cythonized, let''s implement `struct cmd_q`,
    which is a little trickier:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: 'There are quite a few more structs that this depends on, but we will not see
    them here. Let''s try and cast these for now; for example, `struct client *`.
    We can cast this as `void *`, and then `struct cmd_q_items` simply as `int`, even
    though it isn''t correct. As long as we are not going to try and access these
    fields, we will be okay. But remember that if we were to use Cython `sizeof`,
    we could run into memory corruption with different sizes allocated by C and by
    Cython. We can work down the other types such as `struct cmd_q_item *` and cast
    them as `void *` again. Finally, we come to `time_t`, where we can reuse `libc.stdlib
    cimport` time from Cython. This is a really good exercise to implement Cython
    declarations for C applications; it really exercises your code analysis. When
    going through really long structures, remember that we can get things going by
    just casting them as `void`. Be careful about the `struct` alignment and typing
    if you care about the data types in your Cython API:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: 'That was a fairly deep dive into a lot of project-specific internals, but I
    hope you get the idea—we really didn''t do anything terribly scary. We even cheated
    and casted things that we really don''t care about. With all these auxiliary types
    implemented, we can finally implement the type we care about, namely, `struct
    cmd_entry`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: With this `cmdpython.pxd` file, we can now implement our Tmux command!
  prefs: []
  type: TYPE_NORMAL
- en: Implementing a Tmux command
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'One caveat with Cython is that we cannot statically initialize structs like
    we can in C, so we need to make a hook so that we can initialize `cmd_entry` on
    Python startup:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs: []
  type: TYPE_PRE
- en: 'With this, we now have a public declaration of `cmd_entry_python`, which we
    will initialize in a startup hook as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs: []
  type: TYPE_PRE
- en: 'Remember that because we declared this in the top level, we know it''s on the
    heap and don''t need to declare any memory to the structure, which is very handy
    for us. You''ve seen struct access before; the function suite should look familiar.
    But let me draw attention to a few things here:'
  prefs: []
  type: TYPE_NORMAL
- en: We declared `public` to make sure we can call it.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The execution hook is simply a `cdef` Cython function.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Finally, you might notice the `gil`. I will explain what this is used for in
    [Chapter 5](ch05.html "Chapter 5. Advanced Cython"), *Advanced Cython*.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Now, let''s see a simple execution hook:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs: []
  type: TYPE_PRE
- en: There is not much left to do to hook this into Tmux now. It simply needs to
    be added to `cmd_table` and the startup hook needs to be added to the server initialization.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Note that I added something in the `log_debug` function to the PXD; if you look
    into Tmux, this is a `VA_ARGS` function. Cython doesn't understand these yet,
    but we can hack it just to get it going by simply casting it as a function that
    takes a string. As long as we don't try and use it like any `printf`, we should
    be fine.
  prefs: []
  type: TYPE_NORMAL
- en: Hooking everything together
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'We now have to fiddle with Tmux just a tiny bit more, but it''s fairly painless,
    and once we are done we are free to be creative. Fundamentally, we should call
    the `cmd_entry` initialization hook in `server.c` just before we forget about
    it:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE37]'
  prefs: []
  type: TYPE_PRE
- en: 'Now that this is done, we need to make sure we add the `cmd_entry_python` extern
    declaration to `tmux.h`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE38]'
  prefs: []
  type: TYPE_PRE
- en: 'Finally, add this to `cmd_table`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE39]'
  prefs: []
  type: TYPE_PRE
- en: 'Now that this is done, I think we''re good to go—let''s test out this baby.
    Compile Tmux with the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE40]'
  prefs: []
  type: TYPE_PRE
- en: 'We can look into `tmux-server-*.log` to see our debug message:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE41]'
  prefs: []
  type: TYPE_PRE
- en: I hope you can now see how easily you can extend this to do something of your
    own choosing, such as using Python libraries to call directly into your music
    player, and it would all be integrated with Tmux.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: There are many different techniques and ideas demonstrated in this chapter,
    but it should serve as a strong reference on common techniques. We saw the speedups
    in using native types to bypass the runtime, and compiled Python code into its
    own binary. The `pyximport` statement shows us we can bypass compilation and simply
    import `.pyx` files as if it was normal Python. Finally, I ended the chapter with
    a step-by-step demonstration of my process in embedding Python into Tmux. In the
    next chapter, we will see debugging in action using `gdb`, and some caveats in
    using Cython.
  prefs: []
  type: TYPE_NORMAL
