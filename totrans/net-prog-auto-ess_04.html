<html><head></head><body>
<div id="_idContainer041">
<h1 class="chapter-number" id="_idParaDest-100"><a id="_idTextAnchor100"/><span class="koboSpan" id="kobo.1.1">4</span></h1>
<h1 id="_idParaDest-101"><a id="_idTextAnchor101"/><span class="koboSpan" id="kobo.2.1">Working with Network Configurations and Definitions</span></h1>
<p><span class="koboSpan" id="kobo.3.1">One important point in network automation is how the configuration is organized and how we can automate our network in a scalable way. </span><span class="koboSpan" id="kobo.3.2">In this chapter, we are going to explore how to work with a network configuration and how to define it for effective use with network automation. </span><span class="koboSpan" id="kobo.3.3">We want to build scalable and future-proof solutions. </span></p>
<p><span class="koboSpan" id="kobo.4.1">Why do we care about configuration and network definition? </span><span class="koboSpan" id="kobo.4.2">Why is it important which file to use? </span><span class="koboSpan" id="kobo.4.3">How can we create a lifelong definition? </span><span class="koboSpan" id="kobo.4.4">How can we use this to help network automation? </span><span class="koboSpan" id="kobo.4.5">Let’s explore answers to these questions in this chapter.</span></p>
<p><span class="koboSpan" id="kobo.5.1">We are going to explore the following:</span></p>
<ul>
<li><span class="koboSpan" id="kobo.6.1">Describing the configuration problem</span></li>
<li><span class="koboSpan" id="kobo.7.1">Helping network automation using definitions</span></li>
<li><span class="koboSpan" id="kobo.8.1">Creating network definitions</span></li>
<li><span class="koboSpan" id="kobo.9.1">Exploring different file types</span></li>
</ul>
<h1 id="_idParaDest-102"><a id="_idTextAnchor102"/><span class="koboSpan" id="kobo.10.1">Technical requirements</span></h1>
<p><span class="koboSpan" id="kobo.11.1">The source code described in this chapter is stored in the GitHub repository at  </span><a href="https://github.com/PacktPublishing/Network-Programming-and-Automation-Essentials/tree/main/Chapter04"><span class="koboSpan" id="kobo.12.1">https://github.com/PacktPublishing/Network-Programming-and-Automation-Essentials/tree/main/Chapter04</span></a><span class="koboSpan" id="kobo.13.1">.</span></p>
<h1 id="_idParaDest-103"><a id="_idTextAnchor103"/><span class="koboSpan" id="kobo.14.1">Describing the configuration problem </span></h1>
<p><span class="koboSpan" id="kobo.15.1">Several </span><a id="_idIndexMarker448"/><span class="koboSpan" id="kobo.16.1">production networks out there have their configuration applied to network devices without any additional external definition. </span><span class="koboSpan" id="kobo.16.2">Some of them have network diagrams describing the network, but the majority have outdated or incomplete diagrams. </span><span class="koboSpan" id="kobo.16.3">Therefore, in most cases, you might need to read running device configurations to understand the details of the network operation.</span></p>
<p><span class="koboSpan" id="kobo.17.1">In some network providers, diagrams are used for an initial understanding of the network or as an overall overview. </span><span class="koboSpan" id="kobo.17.2">Once the engineers have enough confidence in their network, the diagrams are just ignored or not used anymore. </span><span class="koboSpan" id="kobo.17.3">Some would update their diagrams, but for most engineers, this task is not a priority and usually is left behind.</span></p>
<p><span class="koboSpan" id="kobo.18.1">It is also common for some engineers to apply configuration fixes directly into production devices to solve catastrophic or urgent failures. </span><span class="koboSpan" id="kobo.18.2">In other cases, additional configuration is applied temporarily for troubleshooting, but never removed. </span><span class="koboSpan" id="kobo.18.3">These configuration changes are forgotten in some cases that they were applied and the network runs with a configuration difference that is not perceived until a software update is necessary.</span></p>
<p><span class="koboSpan" id="kobo.19.1">Let’s discuss the issues further in the following subsections.</span></p>
<h2 id="_idParaDest-104"><a id="_idTextAnchor104"/><span class="koboSpan" id="kobo.20.1">Source of truth</span></h2>
<p><strong class="bold"><span class="koboSpan" id="kobo.21.1">Source of truth</span></strong><span class="koboSpan" id="kobo.22.1"> is a</span><a id="_idIndexMarker449"/><span class="koboSpan" id="kobo.23.1"> term used in computer networks to describe where the definition is and what all other systems have to rely on when consulting or using the information to create further definitions. </span><span class="koboSpan" id="kobo.23.2">The source of truth can be either a file, a router configuration, a database, a memory space, or a network diagram.</span></p>
<p><span class="koboSpan" id="kobo.24.1">We want to have the source of truth as steadily defined as possible; it should not change over a short period of time and should be used as a reference for any other definition.</span></p>
<p><span class="koboSpan" id="kobo.25.1">The majority of network engineers rely on the router configuration as the source of truth, because routers are frequently updated and have the correct definitions to run the network; however, this does not help our network automation.</span></p>
<p><span class="koboSpan" id="kobo.26.1">Ideally, we want the source of the truth to be in a database or files stored in a secure and future-proof environment that can be ready to be read by any system quickly.</span></p>
<h2 id="_idParaDest-105"><a id="_idTextAnchor105"/><span class="koboSpan" id="kobo.27.1">The startup configuration and the running configuration</span></h2>
<p><span class="koboSpan" id="kobo.28.1">A network device has</span><a id="_idIndexMarker450"/><span class="koboSpan" id="kobo.29.1"> two configuration states, the </span><strong class="bold"><span class="koboSpan" id="kobo.30.1">running configuration</span></strong><span class="koboSpan" id="kobo.31.1"> and </span><a id="_idIndexMarker451"/><span class="koboSpan" id="kobo.32.1">the </span><strong class="bold"><span class="koboSpan" id="kobo.33.1">startup configuration</span></strong><span class="koboSpan" id="kobo.34.1">. </span><span class="koboSpan" id="kobo.34.2">The </span><a id="_idIndexMarker452"/><span class="koboSpan" id="kobo.35.1">running configuration is the current configuration </span><a id="_idIndexMarker453"/><span class="koboSpan" id="kobo.36.1">on the device’s memory that is being used to operate at that present moment. </span><span class="koboSpan" id="kobo.36.2">The startup configuration is used to boot the device from </span><em class="italic"><span class="koboSpan" id="kobo.37.1">off</span></em><span class="koboSpan" id="kobo.38.1"> to </span><em class="italic"><span class="koboSpan" id="kobo.39.1">on</span></em><span class="koboSpan" id="kobo.40.1">. </span><span class="koboSpan" id="kobo.40.2">The difference is that one is volatile and will be deleted once the device is turned off or loses power supply, and the other is permanent and will always exist independent of whether it has a power supply or not.</span></p>
<p><span class="koboSpan" id="kobo.41.1">The startup configuration is normally stored in a non-volatile memory store such as SSD, a flash drive, or a hard drive.</span></p>
<p><span class="koboSpan" id="kobo.42.1">For our automation, we want to have the same running configuration as the startup configuration. </span><span class="koboSpan" id="kobo.42.2">When they differ, it might cause automation issues if not well documented.</span></p>
<h2 id="_idParaDest-106"><a id="_idTextAnchor106"/><span class="koboSpan" id="kobo.43.1">Configuration states and history</span></h2>
<p><span class="koboSpan" id="kobo.44.1">A good network automation design</span><a id="_idIndexMarker454"/><span class="koboSpan" id="kobo.45.1"> should aim to have multiple configuration states and history, which will help to determine how the network is operating now, how it should operate in the future, and how it operated in the past.</span></p>
<p><span class="koboSpan" id="kobo.46.1">For deployment and automation, it is very useful to separate the configuration into at least four stages: </span><strong class="bold"><span class="koboSpan" id="kobo.47.1">Desired</span></strong><span class="koboSpan" id="kobo.48.1">, </span><strong class="bold"><span class="koboSpan" id="kobo.49.1">Approved</span></strong><span class="koboSpan" id="kobo.50.1">, </span><strong class="bold"><span class="koboSpan" id="kobo.51.1">Applied</span></strong><span class="koboSpan" id="kobo.52.1">, and </span><strong class="bold"><span class="koboSpan" id="kobo.53.1">Running</span></strong><span class="koboSpan" id="kobo.54.1">, as shown in </span><em class="italic"><span class="koboSpan" id="kobo.55.1">Figure 4.1</span></em><span class="koboSpan" id="kobo.56.1">:</span></p>
<div>
<div class="IMG---Figure" id="_idContainer037">
<span class="koboSpan" id="kobo.57.1"><img alt=" Figure 4.1 – Configuration stages and control layer" src="image/B18165_04_001.jpg"/></span>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US"><span class="koboSpan" id="kobo.58.1"> Figure 4.1 – Configuration stages and control layer</span></p>
<p><span class="koboSpan" id="kobo.59.1">We’ll discuss each of these in the following sub sections.</span></p>
<h3><span class="koboSpan" id="kobo.60.1">Desired-configuration</span></h3>
<p><span class="koboSpan" id="kobo.61.1">The </span><strong class="bold"><span class="koboSpan" id="kobo.62.1">desired-configuration</span></strong><span class="koboSpan" id="kobo.63.1"> is </span><a id="_idIndexMarker455"/><span class="koboSpan" id="kobo.64.1">used to </span><a id="_idIndexMarker456"/><span class="koboSpan" id="kobo.65.1">document the configuration that should be applied in the near future. </span><span class="koboSpan" id="kobo.65.2">It is used to check for inconsistencies and to be applied in a test network (or a network simulation) to evaluate future deployments, possible syntax errors, and other functional problems.</span></p>
<p><span class="koboSpan" id="kobo.66.1">Modern networks use the desired-configuration to feed a configuration pipeline that will perform a series of tests, including simulation to validate and anticipate errors. </span><span class="koboSpan" id="kobo.66.2">It is also used to test the deployment sequence, and evaluate which devices can be deployed in parallel or which ones need to wait until some have finished being deployed.  </span></p>
<h3><span class="koboSpan" id="kobo.67.1">Approved-configuration</span></h3>
<p><span class="koboSpan" id="kobo.68.1">The </span><strong class="bold"><span class="koboSpan" id="kobo.69.1">approved-configuration</span></strong><span class="koboSpan" id="kobo.70.1"> is </span><a id="_idIndexMarker457"/><span class="koboSpan" id="kobo.71.1">the configuration </span><a id="_idIndexMarker458"/><span class="koboSpan" id="kobo.72.1">that has passed all approval stages in the configuration pipeline, whether they are automated approval stages, such as syntax checks, or manual stages, done by a human approval.</span></p>
<p><span class="koboSpan" id="kobo.73.1">To enhance confidence, some configuration pipelines will apply the desired-configuration in a network simulation for further function testing, and if everything passes, the configuration pipeline will approve the configuration.</span></p>
<p><span class="koboSpan" id="kobo.74.1">From all configuration stages, the approval-configuration is the one that takes more time to finish as large networks have thousands of routers, and some require sequential functional testing instead of parallel testing. </span><span class="koboSpan" id="kobo.74.2">After everything is completed, the configurations are ready to be deployed.</span></p>
<h3><span class="koboSpan" id="kobo.75.1">Applied-configuration</span></h3>
<p><span class="koboSpan" id="kobo.76.1">The </span><strong class="bold"><span class="koboSpan" id="kobo.77.1">applied-configuration</span></strong><span class="koboSpan" id="kobo.78.1"> is</span><a id="_idIndexMarker459"/><span class="koboSpan" id="kobo.79.1"> the configuration </span><a id="_idIndexMarker460"/><span class="koboSpan" id="kobo.80.1">saved on the device’s non-volatile configuration or the startup configuration. </span><span class="koboSpan" id="kobo.80.2">At the end of this stage, we confidently know that the configuration has been saved in all routers.</span></p>
<p><span class="koboSpan" id="kobo.81.1">This stage also can take a long time because deployment cannot necessarily be performed in parallel.</span></p>
<h3><span class="koboSpan" id="kobo.82.1">Running-configuration</span></h3>
<p><span class="koboSpan" id="kobo.83.1">This stage is used as a</span><a id="_idIndexMarker461"/><span class="koboSpan" id="kobo.84.1"> safeguard for future deployments and approval processes. </span><span class="koboSpan" id="kobo.84.2">The </span><strong class="bold"><span class="koboSpan" id="kobo.85.1">running-configuration</span></strong><span class="koboSpan" id="kobo.86.1"> has to be the</span><a id="_idIndexMarker462"/><span class="koboSpan" id="kobo.87.1"> same as the applied configuration; however, it might not be the same configuration, especially after a catastrophic event that required configuration intervention.</span></p>
<p><span class="koboSpan" id="kobo.88.1">The running-configuration is constantly updated by trigger points such as privileged access to the device, faulty hardware, or any configuration changes.</span></p>
<p><span class="koboSpan" id="kobo.89.1">Using configuration pipelines requires that only the pipeline is able to change the startup configuration of the router. </span><span class="koboSpan" id="kobo.89.2">That means network engineers are not able to save configuration changes on the device to avoid this happening.</span></p>
<p><span class="koboSpan" id="kobo.90.1">For</span><a id="_idIndexMarker463"/><span class="koboSpan" id="kobo.91.1"> catastrophic scenarios where the configuration has to be changed quickly, the configuration pipelines are normally bypassed and the configuration updates are done by manual </span><a id="_idIndexMarker464"/><span class="koboSpan" id="kobo.92.1">intervention from network engineers. </span><span class="koboSpan" id="kobo.92.2">These changes are normally applied to running-configuration and are not saved to the device. </span><span class="koboSpan" id="kobo.92.3">If a configuration audit runs it will show the difference between the running-configuration and the applied-configuration.</span></p>
<h3><span class="koboSpan" id="kobo.93.1">Configuration history</span></h3>
<p><span class="koboSpan" id="kobo.94.1">It is</span><a id="_idIndexMarker465"/><span class="koboSpan" id="kobo.95.1"> most desirable to have a history of the configuration for each of the devices for all configuration stages. </span><span class="koboSpan" id="kobo.95.2">The configuration history helps us to understand possible failures or improvements by comparing an old setup to a new one. </span><span class="koboSpan" id="kobo.95.3">It is also used to build an entire network in simulation for troubleshooting a failure in deployment during configuration updates. </span><span class="koboSpan" id="kobo.95.4">A configuration history might also benefit other teams, such as security auditing and capacity planners.</span></p>
<h2 id="_idParaDest-107"><a id="_idTextAnchor107"/><span class="koboSpan" id="kobo.96.1">Deployment pipeline</span></h2>
<p><strong class="bold"><span class="koboSpan" id="kobo.97.1">Deployment pipelines</span></strong><span class="koboSpan" id="kobo.98.1"> are</span><a id="_idIndexMarker466"/><span class="koboSpan" id="kobo.99.1"> used on large</span><a id="_idIndexMarker467"/><span class="koboSpan" id="kobo.100.1"> networks that require fast and reliable changes. </span><span class="koboSpan" id="kobo.100.2">The pipeline is constructed with modern techniques of simulation and testing, which include extensive use of network automation coding.</span></p>
<p><span class="koboSpan" id="kobo.101.1">An </span><a id="_idIndexMarker468"/><span class="koboSpan" id="kobo.102.1">example of a network deployment pipeline can be seen as follows:</span></p>
<div>
<div class="IMG---Figure" id="_idContainer038">
<span class="koboSpan" id="kobo.103.1"><img alt="Figure 4.2 – Example of a configuration deployment pipeline " src="image/B18165_04_002.jpg"/></span>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US"><span class="koboSpan" id="kobo.104.1">Figure 4.2 – Example of a configuration deployment pipeline </span></p>
<p><span class="koboSpan" id="kobo.105.1">In the </span><a id="_idIndexMarker469"/><span class="koboSpan" id="kobo.106.1">preceding figure, we can see how we can use the configuration states in our deployment pipeline. </span><span class="koboSpan" id="kobo.106.2">The input to the pipeline is the generated desired configuration, and the approved configuration will only be updated when the final tests have finished. </span><span class="koboSpan" id="kobo.106.3">With the use of this workflow, it is possible to automate deployment, reduce mistakes, and allow faster parallel deployments. </span><span class="koboSpan" id="kobo.106.4">Let’s describe each step of the pipeline process:</span></p>
<ol>
<li><span class="koboSpan" id="kobo.107.1">First, the configuration syntax is checked automatically. </span><span class="koboSpan" id="kobo.107.2">If it passes, go to the next steps. </span><span class="koboSpan" id="kobo.107.3">If it fails, the pipeline process stops and waits until a valid configuration is presented.</span></li>
<li><span class="koboSpan" id="kobo.108.1">Second, the pipeline verifies any differences between the running and applied configurations, which in some cases could be due to an urgent configuration fix. </span><span class="koboSpan" id="kobo.108.2">If the configurations are different, it will require manual approval to go to the next steps.</span></li>
<li><span class="koboSpan" id="kobo.109.1">Third, the pipeline launches a simulation for the routers in the configuration change scope and deploys the new configuration to the simulated network.</span></li>
<li><span class="koboSpan" id="kobo.110.1">Fourth, the </span><a id="_idIndexMarker470"/><span class="koboSpan" id="kobo.111.1">pipeline runs functional tests in the simulation that will confirm that the new configuration does not break any functions that are already present. </span><span class="koboSpan" id="kobo.111.2">If it passes, it goes to the next step. </span><span class="koboSpan" id="kobo.111.3">If it fails, the pipeline stops and awaits rejection or acceptance.</span></li>
<li><span class="koboSpan" id="kobo.112.1">Fifth, the pipeline applies the new configuration to the network, following all parallel dependencies and time restrictions.</span></li>
</ol>
<h2 id="_idParaDest-108"><a id="_idTextAnchor108"/><span class="koboSpan" id="kobo.113.1">Network diagrams and automation</span></h2>
<p><span class="koboSpan" id="kobo.114.1">Network diagrams </span><a id="_idIndexMarker471"/><span class="koboSpan" id="kobo.115.1">are graphical, human-friendly, and readable representations of the network, but they are not easy for machines to read. </span><span class="koboSpan" id="kobo.115.2">Most of the time, they are generated by humans from graphical tools such as Visio, Lucid Chart, and Draw.io. </span><span class="koboSpan" id="kobo.115.3">When generated by humans, the updates on the diagrams, to reflect the current state, are normally left behind, causing information on the diagram to be outdated.</span></p>
<p><span class="koboSpan" id="kobo.116.1">To have an</span><a id="_idIndexMarker472"/><span class="koboSpan" id="kobo.117.1"> accurate network diagram, we need to have some sort of diagram generator that reads data from either the router configuration or network definition files.</span></p>
<p><span class="koboSpan" id="kobo.118.1">In our previous example of the deployment pipeline, the diagram generator could read the configuration from any configuration stage and have a different diagram for the running configuration and desired configuration stages.</span></p>
<p><span class="koboSpan" id="kobo.119.1">With</span><a id="_idIndexMarker473"/><span class="koboSpan" id="kobo.120.1"> automatic diagram generation, an </span><a id="_idIndexMarker474"/><span class="koboSpan" id="kobo.121.1">up-to-date diagram can be generated for any stage of the pipeline. </span><span class="koboSpan" id="kobo.121.2">These diagrams can be used to help network engineers to troubleshoot a problem or help network designers to understand how to </span><a id="_idIndexMarker475"/><span class="koboSpan" id="kobo.122.1">improve the current network functions.</span></p>
<p><span class="koboSpan" id="kobo.123.1">In this section, we discussed how multiple configuration stages can help deploy solutions and how problems can occur when the source of truth is not defined or updated. </span><span class="koboSpan" id="kobo.123.2">Next, we will examine how we can create abstract definitions from a device configuration to create a better source of truth.</span></p>
<h1 id="_idParaDest-109"><a id="_idTextAnchor109"/><span class="koboSpan" id="kobo.124.1">Using network definitions to aid automation</span></h1>
<p><span class="koboSpan" id="kobo.125.1">The previous </span><a id="_idIndexMarker476"/><span class="koboSpan" id="kobo.126.1">section explored the configuration stages and how we can rely on them to build a better network deployment pipeline. </span><span class="koboSpan" id="kobo.126.2">On the other hand, we have not covered another issue with the router configuration, which is related to router software versions and router vendors.</span></p>
<p><span class="koboSpan" id="kobo.127.1">Using a </span><a id="_idIndexMarker477"/><span class="koboSpan" id="kobo.128.1">router configuration as a source of truth has advantages if your network will not update, grow, or change vendors. </span><span class="koboSpan" id="kobo.128.2">If your network is not intended to change, you might not need a definition at all. </span><span class="koboSpan" id="kobo.128.3">However, as the majority of the network will need to upgrade or grow, it is important to think about getting away from vendor-specific solutions and create vendor-agnostic definitions of your network.</span></p>
<p><span class="koboSpan" id="kobo.129.1">A </span><a id="_idIndexMarker478"/><span class="koboSpan" id="kobo.130.1">router vendor has different configuration defaults, which means some configuration lines might not be necessary with one vendor but be required with the other vendor. </span><span class="koboSpan" id="kobo.130.2">For network automation, we want to avoid traps like that and have a network source of truth that explicitly says what is necessary to configure. </span><span class="koboSpan" id="kobo.130.3">We then have to add a translation layer that will produce a router configuration specifically for that vendor.</span></p>
<p><span class="koboSpan" id="kobo.131.1">Another point is some vendors change default configuration between versions of the same operational system. </span><span class="koboSpan" id="kobo.131.2">One version might have extra lines that are not present in the other version. </span><span class="koboSpan" id="kobo.131.3">This can also cause problems with our network automation. </span><span class="koboSpan" id="kobo.131.4">Again, we want to add a translation layer that is vendor- and version-specific, therefore generating configurations appropriately.</span></p>
<h2 id="_idParaDest-110"><a id="_idTextAnchor110"/><span class="koboSpan" id="kobo.132.1">The router configuration render</span></h2>
<p><span class="koboSpan" id="kobo.133.1">A </span><a id="_idIndexMarker479"/><span class="koboSpan" id="kobo.134.1">router configuration render is a software layer that sits between our agnostic definitions and the desired configuration in our deployment pipeline described earlier. </span><span class="koboSpan" id="kobo.134.2">It works like a translator and needs to be aware of the vendor and the version of the router to generate an appropriate configuration. </span><span class="koboSpan" id="kobo.134.3">The following figure shows an example of two different configuration renders, one for Juniper and one for Cisco:</span></p>
<div>
<div class="IMG---Figure" id="_idContainer039">
<span class="koboSpan" id="kobo.135.1"><img alt="Figure 4.3 – Configuration render examples for Cisco and Juniper" src="image/B18165_04_003.jpg"/></span>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US"><span class="koboSpan" id="kobo.136.1">Figure 4.3 – Configuration render examples for Cisco and Juniper</span></p>
<p><span class="koboSpan" id="kobo.137.1">A configuration render can be flexible when generating configuration lines for the same vendor, but it must be aware of the configuration defaults and difference for each vendor and its operating system version. </span><span class="koboSpan" id="kobo.137.2">Normally, a render can cover a series of versions and platforms from the same vendor.</span></p>
<h2 id="_idParaDest-111"><a id="_idTextAnchor111"/><span class="koboSpan" id="kobo.138.1">Using configuration templates</span></h2>
<p><span class="koboSpan" id="kobo.139.1">An easy </span><a id="_idIndexMarker480"/><span class="koboSpan" id="kobo.140.1">way to generate a router configuration is to use </span><strong class="bold"><span class="koboSpan" id="kobo.141.1">configuration templates</span></strong><span class="koboSpan" id="kobo.142.1">. </span><span class="koboSpan" id="kobo.142.2">With these, it is easy to construct a generic configuration and then modify by adding key text words to the configuration text that has to be changed.</span></p>
<p><span class="koboSpan" id="kobo.143.1">In our case, the router configuration render will read the definitions from a file and then read a configuration template to generate the router configuration as described in the following</span><a id="_idIndexMarker481"/><span class="koboSpan" id="kobo.144.1"> diagram. </span><span class="koboSpan" id="kobo.144.2">It shows an example for a Juniper router, but it can be used for any other router:</span></p>
<div>
<div class="IMG---Figure" id="_idContainer040">
<span class="koboSpan" id="kobo.145.1"><img alt="Figure 4.4 – Router configuration render using templates" src="image/B18165_04_004.jpg"/></span>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US"><span class="koboSpan" id="kobo.146.1">Figure 4.4 – Router configuration render using templates</span></p>
<p><span class="koboSpan" id="kobo.147.1">Creating a template is not difficult and it requires only a sample of the router configuration platform that you want to generate; you simply replace the elements you want with a key string. </span><span class="koboSpan" id="kobo.147.2">An example using </span><strong class="source-inline"><span class="koboSpan" id="kobo.148.1">{{ADDRESS}}</span></strong><span class="koboSpan" id="kobo.149.1"> and </span><strong class="source-inline"><span class="koboSpan" id="kobo.150.1">{{DESTINATION}}</span></strong><span class="koboSpan" id="kobo.151.1"> is shown in the preceding figure. </span></p>
<h2 id="_idParaDest-112"><a id="_idTextAnchor112"/><span class="koboSpan" id="kobo.152.1">Using Python engine templates</span></h2>
<p><strong class="bold"><span class="koboSpan" id="kobo.153.1">Jinja</span></strong><span class="koboSpan" id="kobo.154.1"> is a </span><a id="_idIndexMarker482"/><span class="koboSpan" id="kobo.155.1">template</span><a id="_idIndexMarker483"/><span class="koboSpan" id="kobo.156.1"> engine library for Python that is also commonly referred to as </span><strong class="bold"><span class="koboSpan" id="kobo.157.1">Jinja2</span></strong><span class="koboSpan" id="kobo.158.1"> to </span><a id="_idIndexMarker484"/><span class="koboSpan" id="kobo.159.1">reflect the newest release version. </span><span class="koboSpan" id="kobo.159.2">Jinja is used to create HTML, XML, and, for us, router configurations. </span><span class="koboSpan" id="kobo.159.3">It was created by Armin Ronacher and is open source with the BSD license. </span><span class="koboSpan" id="kobo.159.4">Jinja is similar to the Django template engine, but with the advantage of using Python expressions. </span><span class="koboSpan" id="kobo.159.5">It uses a text template and, therefore, can be used to generate any text, markup, or even source code, and router configurations in our case.</span></p>
<p><span class="koboSpan" id="kobo.160.1">For router configurations, Jinja is useful because it has a consistent template tag syntax and the router template configuration is extracted as an independent source, so it can be used as a dependency by other code libraries.</span></p>
<p><span class="koboSpan" id="kobo.161.1">The following </span><a id="_idIndexMarker485"/><span class="koboSpan" id="kobo.162.1">is an example of an input Jinja template file for a Cisco router (a file called </span><strong class="source-inline"><span class="koboSpan" id="kobo.163.1">cisco_template.txt</span></strong><span class="koboSpan" id="kobo.164.1">):</span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.165.1">
hostname {{name}}
!
</span><span class="koboSpan" id="kobo.165.2">interface Loopback100
description {{name}} router loopback
ip address 100.100.100.{{id}} 255.255.255.255
!
</span><span class="koboSpan" id="kobo.165.3">interface GigabitEthernet1/0
description Connection to {{to_name}} router G0/1
!
</span><span class="koboSpan" id="kobo.165.4">interface GigabitEthernet1/0.1{{id}}
description Access to {{to_name}}
encapsulation dot1Q 1{{id}}
ip address 100.0.1{{id}}.2 255.255.255.252
ip ospf network point-to-point
ip ospf cost 100
!
</span><span class="koboSpan" id="kobo.165.5">router ospf 100
router-id 100.100.100.{{id}}
network 100.0.0.0 0.255.255.255 area 0
!</span></pre>
<p><span class="koboSpan" id="kobo.166.1">The following is the input definition file used to feed the configuration render (a file called </span><strong class="source-inline"><span class="koboSpan" id="kobo.167.1">router_definitions.yaml</span></strong><span class="koboSpan" id="kobo.168.1">):</span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.169.1">
- id: 11
  name: Sydney
  to_name: Melbourne
- id: 12
  name: Brisbane
  to_name: Melbourne
- id: 13
  name: Adelaide
  to_name: Melbourne</span></pre>
<p><span class="koboSpan" id="kobo.170.1">The</span><a id="_idIndexMarker486"/><span class="koboSpan" id="kobo.171.1"> following is the Python code used to generate the router configurations:</span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.172.1">
from jinja2 import Environment, FileSystemLoader
import yaml
env = Environment(loader=FileSystemLoader('templates'))
template = env.get_template('cisco_template_python.txt')
with open('router_definitions.yaml') as f:
    routers = yaml.safe_load(f)
for router in routers:
    router_conf = router['name'] + '_router_config.txt'
    with open(router_conf, 'w') as f:
        f.write(template.render(router))</span></pre>
<p><span class="koboSpan" id="kobo.173.1">After running the preceding Python script, it will generate three files with three different configurations for Sydney, Brisbane, and Adelaide.</span></p>
<p><span class="koboSpan" id="kobo.174.1">Here is the content of the </span><strong class="source-inline"><span class="koboSpan" id="kobo.175.1">Sydney_router_config.txt</span></strong><span class="koboSpan" id="kobo.176.1"> output file:</span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.177.1">
hostname </span><strong class="bold"><span class="koboSpan" id="kobo.178.1">Sydney</span></strong><span class="koboSpan" id="kobo.179.1">
!
</span><span class="koboSpan" id="kobo.179.2">interface Loopback100
description </span><strong class="bold"><span class="koboSpan" id="kobo.180.1">Sydney</span></strong><span class="koboSpan" id="kobo.181.1"> router loopback
ip address 100.100.100.</span><strong class="bold"><span class="koboSpan" id="kobo.182.1">11</span></strong><span class="koboSpan" id="kobo.183.1"> 255.255.255.255
!
</span><span class="koboSpan" id="kobo.183.2">interface GigabitEthernet1/0
description Connection to </span><strong class="bold"><span class="koboSpan" id="kobo.184.1">Melbourne</span></strong><span class="koboSpan" id="kobo.185.1"> router G0/1
!
</span><span class="koboSpan" id="kobo.185.2">interface GigabitEthernet1/0.1</span><strong class="bold"><span class="koboSpan" id="kobo.186.1">11</span></strong><span class="koboSpan" id="kobo.187.1">
description Access to </span><strong class="bold"><span class="koboSpan" id="kobo.188.1">Melbourne</span></strong><span class="koboSpan" id="kobo.189.1">
encapsulation dot1Q 1</span><strong class="bold"><span class="koboSpan" id="kobo.190.1">11</span></strong><span class="koboSpan" id="kobo.191.1">
ip address 100.0.1</span><strong class="bold"><span class="koboSpan" id="kobo.192.1">11</span></strong><span class="koboSpan" id="kobo.193.1">.2 255.255.255.252
ip ospf network point-to-point
ip ospf cost 100
!
</span><span class="koboSpan" id="kobo.193.2">router ospf 100
router-id 100.100.100.</span><strong class="bold"><span class="koboSpan" id="kobo.194.1">11</span></strong><span class="koboSpan" id="kobo.195.1">
network 100.0.0.0 0.255.255.255 area 0
!</span></pre>
<p><span class="koboSpan" id="kobo.196.1">The</span><a id="_idIndexMarker487"/><span class="koboSpan" id="kobo.197.1"> following is the content of the </span><strong class="source-inline"><span class="koboSpan" id="kobo.198.1">Brisbane_router_config.txt</span></strong><span class="koboSpan" id="kobo.199.1"> output file, just to show the slight differences between the files:</span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.200.1">
hostname </span><strong class="bold"><span class="koboSpan" id="kobo.201.1">Brisbane</span></strong><span class="koboSpan" id="kobo.202.1">
!
</span><span class="koboSpan" id="kobo.202.2">interface Loopback100
description </span><strong class="bold"><span class="koboSpan" id="kobo.203.1">Brisbane</span></strong><span class="koboSpan" id="kobo.204.1"> router loopback
ip address 100.100.100.</span><strong class="bold"><span class="koboSpan" id="kobo.205.1">12</span></strong><span class="koboSpan" id="kobo.206.1"> 255.255.255.255
!
</span><span class="koboSpan" id="kobo.206.2">interface GigabitEthernet1/0
description Connection to </span><strong class="bold"><span class="koboSpan" id="kobo.207.1">Melbourne</span></strong><span class="koboSpan" id="kobo.208.1"> router G0/1
!
</span><span class="koboSpan" id="kobo.208.2">interface GigabitEthernet1/0.112
description Access to </span><strong class="bold"><span class="koboSpan" id="kobo.209.1">Melbourne</span></strong><span class="koboSpan" id="kobo.210.1">
encapsulation dot1Q 1</span><strong class="bold"><span class="koboSpan" id="kobo.211.1">12</span></strong><span class="koboSpan" id="kobo.212.1">
ip address 100.0.1</span><strong class="bold"><span class="koboSpan" id="kobo.213.1">12</span></strong><span class="koboSpan" id="kobo.214.1">.2 255.255.255.252
ip ospf network point-to-point
ip ospf cost 100
!
</span><span class="koboSpan" id="kobo.214.2">router ospf 100
router-id 100.100.100.</span><strong class="bold"><span class="koboSpan" id="kobo.215.1">12</span></strong><span class="koboSpan" id="kobo.216.1">
network 100.0.0.0 0.255.255.255 area 0
!</span></pre>
<p><span class="koboSpan" id="kobo.217.1">Like </span><a id="_idIndexMarker488"/><span class="koboSpan" id="kobo.218.1">Sydney and Brisbane, the Adelaide file will be created with the required fields changed. </span><span class="koboSpan" id="kobo.218.2">The preceding example is quite simple and has only three keys to be modified: </span><strong class="source-inline"><span class="koboSpan" id="kobo.219.1">{{id}}</span></strong><span class="koboSpan" id="kobo.220.1">, </span><strong class="source-inline"><span class="koboSpan" id="kobo.221.1">{{name}}</span></strong><span class="koboSpan" id="kobo.222.1">, and </span><strong class="source-inline"><span class="koboSpan" id="kobo.223.1">{{to_name}}</span></strong><span class="koboSpan" id="kobo.224.1">. </span><span class="koboSpan" id="kobo.224.2">More complex examples can be found in the Jinja documentation at </span><a href="https://jinja.palletsprojects.com/"><span class="koboSpan" id="kobo.225.1">https://jinja.palletsprojects.com/</span></a><span class="koboSpan" id="kobo.226.1">.</span></p>
<h2 id="_idParaDest-113"><a id="_idTextAnchor113"/><span class="koboSpan" id="kobo.227.1">Using Go engine templates</span></h2>
<p><span class="koboSpan" id="kobo.228.1">Since</span><a id="_idIndexMarker489"/><span class="koboSpan" id="kobo.229.1"> Jinja is limited to just Python, </span><strong class="bold"><span class="koboSpan" id="kobo.230.1">Go</span></strong><span class="koboSpan" id="kobo.231.1"> has</span><a id="_idIndexMarker490"/><span class="koboSpan" id="kobo.232.1"> a native text template engine that can be used to generate router configurations.</span></p>
<p><span class="koboSpan" id="kobo.233.1">Different from Python, Go templates are executed by applying a data structure to the template text. </span><span class="koboSpan" id="kobo.233.2">The template has annotations that refer to the data structure, which is normally a field of </span><strong class="source-inline"><span class="koboSpan" id="kobo.234.1">Struct </span></strong><span class="koboSpan" id="kobo.235.1">or </span><strong class="source-inline"><span class="koboSpan" id="kobo.236.1">Map</span></strong><span class="koboSpan" id="kobo.237.1"> in Go.</span></p>
<p><span class="koboSpan" id="kobo.238.1">For our example using Go, let’s use a similar template for the Cisco configuration used for Jinja in the previous example, but with small changes to accommodate Go standards. </span><span class="koboSpan" id="kobo.238.2">Let’s use the file named </span><strong class="source-inline"><span class="koboSpan" id="kobo.239.1">cisco_template_go.txt</span></strong><span class="koboSpan" id="kobo.240.1">:</span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.241.1">
hostname {{.Name}}
!
</span><span class="koboSpan" id="kobo.241.2">interface Loopback100
description {{.Name}} router loopback
ip address 100.100.100.{{.Id}} 255.255.255.255
!
</span><span class="koboSpan" id="kobo.241.3">interface GigabitEthernet1/0
description Connection to {{.Toname}} router G0/1
!
</span><span class="koboSpan" id="kobo.241.4">interface GigabitEthernet1/0.1{{.Id}}
description Access to {{.Toname}}
encapsulation dot1Q 1{{.Id}}
ip address 100.0.1{{.Id}}.2 255.255.255.252
ip ospf network point-to-point
ip ospf cost 100
!
</span><span class="koboSpan" id="kobo.241.5">router ospf 100
router-id 100.100.100.{{.Id}}
network 100.0.0.0 0.255.255.255 area 0
!</span></pre>
<p><span class="koboSpan" id="kobo.242.1">And </span><a id="_idIndexMarker491"/><span class="koboSpan" id="kobo.243.1">for the router definition, the </span><strong class="source-inline"><span class="koboSpan" id="kobo.244.1">router_definitions.yaml</span></strong><span class="koboSpan" id="kobo.245.1"> file is the same as that used in the Python example.</span></p>
<p><span class="koboSpan" id="kobo.246.1">The following is the Go code used to generate the same router configurations created in Python:</span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.247.1">
package main
import (
    "io/ioutil"
    "os"
    "text/template"
    "gopkg.in/yaml.v3"
)
</span><strong class="bold"><span class="koboSpan" id="kobo.248.1">type Router struct {</span></strong>
<strong class="bold"><span class="koboSpan" id="kobo.249.1">    Id     int    `yaml:"id"`</span></strong>
<strong class="bold"><span class="koboSpan" id="kobo.250.1">    Name   string `yaml:"name"`</span></strong>
<strong class="bold"><span class="koboSpan" id="kobo.251.1">    Toname string `yaml:"to_name"`</span></strong>
<strong class="bold"><span class="koboSpan" id="kobo.252.1">}</span></strong>
<strong class="bold"><span class="koboSpan" id="kobo.253.1">type RouterList []Router</span></strong><span class="koboSpan" id="kobo.254.1">
func check(e error) {
    if e != nil {
        panic(e)
    }
}
func main() {
    var routers RouterList
    yamlFile, err := ioutil.ReadFile("router_definitions.yaml")
    check(err)
    err = yaml.Unmarshal(yamlFile, &amp;routers)
    check(err)
    templateFile, err := ioutil.ReadFile("cisco_template_go.txt")
    check(err)
    for _, router := range routers {
        outFile, err := os.Create(router.Name + "_router_config.txt")
        check(err)
        tmpl, err := template.New("render").Parse(string(templateFile))
        check(err)
        err = tmpl.Execute(outFile, router)
        check(err)
    }
}</span></pre>
<p><span class="koboSpan" id="kobo.255.1">The </span><a id="_idIndexMarker492"/><span class="koboSpan" id="kobo.256.1">code in Go is similar to Python, but note that in Go, you have to explicitly describe all the fields you are going to read from the </span><strong class="source-inline"><span class="koboSpan" id="kobo.257.1">router_definitions.yaml</span></strong><span class="koboSpan" id="kobo.258.1"> file. </span><span class="koboSpan" id="kobo.258.2">This is done in the code with the </span><strong class="source-inline"><span class="koboSpan" id="kobo.259.1">Router</span></strong><span class="koboSpan" id="kobo.260.1"> and </span><strong class="source-inline"><span class="koboSpan" id="kobo.261.1">RouterList</span></strong><span class="koboSpan" id="kobo.262.1"> types (lines 11 and 17 in the preceding code).</span></p>
<p><span class="koboSpan" id="kobo.263.1">In this section, we explored how we can improve network automation by having router configuration</span><a id="_idIndexMarker493"/><span class="koboSpan" id="kobo.264.1"> renders. </span><span class="koboSpan" id="kobo.264.2">We also explored some very useful libraries in Python and Go to be used for router configuration renders. </span><span class="koboSpan" id="kobo.264.3">Next, we are going to explore the nuances of creating network definitions.</span></p>
<h1 id="_idParaDest-114"><a id="_idTextAnchor114"/><span class="koboSpan" id="kobo.265.1">Creating network definitions</span></h1>
<p><span class="koboSpan" id="kobo.266.1">We have</span><a id="_idIndexMarker494"/><span class="koboSpan" id="kobo.267.1"> seen so far how template engines are extremely useful to create router configurations using network automation. </span><span class="koboSpan" id="kobo.267.2">It is also important to define a good router definition, so we can have templates that are less specific, allowing the router definition file to determine how the router should be configured. </span><span class="koboSpan" id="kobo.267.3">Additionally, if router definitions are created properly, it will not be necessary to change them if a vendor change or a router upgrade is necessary. </span><span class="koboSpan" id="kobo.267.4">The only change will be to the router configuration templates. </span></p>
<p><span class="koboSpan" id="kobo.268.1">So, how can we create a network definition that will last longer and can be used as the source of truth for the entire network automation? </span><span class="koboSpan" id="kobo.268.2">Let’s explore a few points that would help with that.</span></p>
<h2 id="_idParaDest-115"><a id="_idTextAnchor115"/><span class="koboSpan" id="kobo.269.1">Nested and hierarchical definitions</span></h2>
<p><span class="koboSpan" id="kobo.270.1">A </span><a id="_idIndexMarker495"/><span class="koboSpan" id="kobo.271.1">network definition does not need to be a flat unique file definition but can use a group of files in a nested setup. </span><span class="koboSpan" id="kobo.271.2">The reason is that some definition files can be specific to a particular characteristic present in all devices, such as vendor, device type, device rules, ACLs, or device function. </span><span class="koboSpan" id="kobo.271.3">Subsequent files that follow the hierarchy can have details that are more specific, such as location, name, capacity limits, or size.</span></p>
<p><span class="koboSpan" id="kobo.272.1">Using nested or hierarchical network definitions will help to avoid having large definition files for each device, and most important of all, avoid the repetition of definitions across different files.</span></p>
<p><span class="koboSpan" id="kobo.273.1">For instance, imagine that you want to control a list of IP addresses that are allowed to log into all routers in your network. </span><span class="koboSpan" id="kobo.273.2">If you don’t use nested definitions, you might need to add the list of IPs to all router definitions. </span><span class="koboSpan" id="kobo.273.3">But if you have nested definitions, you might be able to use only one file definition for that.</span></p>
<p><span class="koboSpan" id="kobo.274.1">To use hierarchy and groups, though, you must create a custom library that compiles the final definition </span><a id="_idIndexMarker496"/><span class="koboSpan" id="kobo.275.1">of one specific router by looking into all hierarchical definition files that belong to that router. </span><span class="koboSpan" id="kobo.275.2">The final compiled definition can then be used on the router configuration render to complete the router template and output the correct router configuration.</span></p>
<h2 id="_idParaDest-116"><a id="_idTextAnchor116"/><span class="koboSpan" id="kobo.276.1">IP allocation considerations</span></h2>
<p><span class="koboSpan" id="kobo.277.1">One</span><a id="_idIndexMarker497"/><span class="koboSpan" id="kobo.278.1"> important point to be observed with definitions is the IP addresses that are associated to every interface or protocol on the network devices. </span><span class="koboSpan" id="kobo.278.2">The IP addresses are normally unique to the network, unless </span><strong class="bold"><span class="koboSpan" id="kobo.279.1">Network Address Translator</span></strong><span class="koboSpan" id="kobo.280.1"> (</span><strong class="bold"><span class="koboSpan" id="kobo.281.1">NAT</span></strong><span class="koboSpan" id="kobo.282.1">) is being used, but the majority of the IP address range is unique per region and per device.</span></p>
<p><span class="koboSpan" id="kobo.283.1">To create a more flexible and future-proof solution, the IP allocation has to be as unfixed as possible, and rules can be taken for the configuration render to allow better use of the IP allocation.</span></p>
<p><span class="koboSpan" id="kobo.284.1">Using an IP allocation engine in combination with nested definitions, it is possible to reserve IPs that are essential for device identification, such as loopbacks, and leave other IP ranges to be associated to network interfaces.</span></p>
<p><span class="koboSpan" id="kobo.285.1">One enhancement that can be made when IP addresses are not fixed is to have a service that translates the IP address to a name associated with the network definition files. </span><span class="koboSpan" id="kobo.285.2">That can be done using DNS, for instance.</span></p>
<p><span class="koboSpan" id="kobo.286.1">The strategy of having less-fixed IPs in the definitions will allow a more flexible solution and avoid complications for the network definition files.</span></p>
<h2 id="_idParaDest-117"><a id="_idTextAnchor117"/><span class="koboSpan" id="kobo.287.1">Using files for definitions</span></h2>
<p><span class="koboSpan" id="kobo.288.1">When</span><a id="_idIndexMarker498"/><span class="koboSpan" id="kobo.289.1"> creating definitions, the best practice is to use plain files, not databases or any other storage method. </span><span class="koboSpan" id="kobo.289.2">This will allow engineers to have a complete source of truth without dependency on any system or application, thus the files can be </span><a id="_idIndexMarker499"/><span class="koboSpan" id="kobo.290.1">read even after a catastrophic event with multiple system failures.</span></p>
<h2 id="_idParaDest-118"><a id="_idTextAnchor118"/><span class="koboSpan" id="kobo.291.1">File format</span></h2>
<p><span class="koboSpan" id="kobo.292.1">Network </span><a id="_idIndexMarker500"/><span class="koboSpan" id="kobo.293.1">automation should use only one file format across all network definitions. </span><span class="koboSpan" id="kobo.293.2">The file should be text-based but use a well-known format that enforces, among other things, typing. </span><span class="koboSpan" id="kobo.293.3">If the structure of the file is standard and easy to read, it will help engineers to review it if necessary.</span></p>
<h2 id="_idParaDest-119"><a id="_idTextAnchor119"/><span class="koboSpan" id="kobo.294.1">Names</span></h2>
<p><span class="koboSpan" id="kobo.295.1">Whenever</span><a id="_idIndexMarker501"/><span class="koboSpan" id="kobo.296.1"> associating names to network definitions, avoid acronyms or any sort of abbreviation. </span><span class="koboSpan" id="kobo.296.2">Although shortening can help engineers to type faster, it can create confusion and raise problems when humans have to investigate. </span><span class="koboSpan" id="kobo.296.3">Remember that you can always create hotkeys or aliases locally in your environment to type device names faster.</span></p>
<p><span class="koboSpan" id="kobo.297.1">Some devices have a limit on string sizes for names, so use names wisely and describe as much as possible the device you are naming to avoid economizing space.</span></p>
<p><span class="koboSpan" id="kobo.298.1">This section has shown how important it is to examine some details when creating network definitions. </span><span class="koboSpan" id="kobo.298.2">We’ll now review the most common data representation types in our network definitions.</span></p>
<h1 id="_idParaDest-120"><a id="_idTextAnchor120"/><span class="koboSpan" id="kobo.299.1">Exploring different file types</span></h1>
<p><span class="koboSpan" id="kobo.300.1">The examples </span><a id="_idIndexMarker502"/><span class="koboSpan" id="kobo.301.1">that we have seen in this chapter had network definitions with files ending with </span><strong class="source-inline"><span class="koboSpan" id="kobo.302.1">.yaml</span></strong><span class="koboSpan" id="kobo.303.1">, which is an indication that they are in YAML format. </span><span class="koboSpan" id="kobo.303.2">But why? </span><span class="koboSpan" id="kobo.303.3">Why not XML or JSON formats? </span><span class="koboSpan" id="kobo.303.4">Let’s explore the pros and cons of the most used file formats.</span></p>
<p><span class="koboSpan" id="kobo.304.1">For our network definitions, we want to choose a format that is easy to read by humans and systems, fast to parse, and small to store. </span><span class="koboSpan" id="kobo.304.2">Then we can write a large content of definitions in files without worrying about performance</span><a id="_idTextAnchor121"/><span class="koboSpan" id="kobo.305.1">, reading difficulty, or storage issues.</span></p>
<h2 id="_idParaDest-121"><a id="_idTextAnchor122"/><span class="koboSpan" id="kobo.306.1">XML files</span></h2>
<p><strong class="bold"><span class="koboSpan" id="kobo.307.1">Extensible Markup Language</span></strong><span class="koboSpan" id="kobo.308.1"> or </span><strong class="bold"><span class="koboSpan" id="kobo.309.1">XML</span></strong><span class="koboSpan" id="kobo.310.1"> is</span><a id="_idIndexMarker503"/><span class="koboSpan" id="kobo.311.1"> the oldest markup language of those described </span><a id="_idIndexMarker504"/><span class="koboSpan" id="kobo.312.1">in this section, with the first implementation dated 1996. </span><span class="koboSpan" id="kobo.312.2">Its first standard publication was created in 1998 by the World Wide Web Consortium as the version 1.0 specification. </span></p>
<p><span class="koboSpan" id="kobo.313.1">The main goals of the initial XML design were to create a markup language that was simple, could cover general cases, and was easy to use across the internet. </span><span class="koboSpan" id="kobo.313.2">Even though the initial idea was for XML to create documents, the language has been used for arbitrary data structures on client and server interactions.</span></p>
<p><span class="koboSpan" id="kobo.314.1">Because of its schema system, XML can use several media types. </span><span class="koboSpan" id="kobo.314.2">In 2001, IETF published the RFC3023, which described all possible media types, including </span><strong class="source-inline"><span class="koboSpan" id="kobo.315.1">application/xml</span></strong><span class="koboSpan" id="kobo.316.1"> and </span><strong class="source-inline"><span class="koboSpan" id="kobo.317.1">text/xml</span></strong><span class="koboSpan" id="kobo.318.1">. </span><span class="koboSpan" id="kobo.318.2">In 2014, IETF published RFC7303, which refined the standards for media types and rendered RFC3023 obsolete.</span></p>
<p><span class="koboSpan" id="kobo.319.1">Here is an example:</span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.320.1">
&lt;router&gt;
  &lt;interface&gt;
    &lt;ip&gt;
       &lt;unicast&gt;
       </span><strong class="bold"><span class="koboSpan" id="kobo.321.1">10.2.2.3</span></strong><span class="koboSpan" id="kobo.322.1">
       &lt;/unicast&gt;
    &lt;/ip&gt;
  &lt;/interface&gt;
  &lt;loopback&gt;
    &lt;ip&gt;
       &lt;unicast&gt;
       </span><strong class="bold"><span class="koboSpan" id="kobo.323.1">100.1.1.1</span></strong><span class="koboSpan" id="kobo.324.1">
       &lt;/unicast&gt;
    &lt;/ip&gt;
  &lt;/loopback&gt;
&lt;/router&gt;</span></pre>
<p><span class="koboSpan" id="kobo.325.1">Note that in the example, we only have two data values (the highlighted IP addresses); the rest is</span><a id="_idIndexMarker505"/><span class="koboSpan" id="kobo.326.1"> markup overhead.</span></p>
<p><span class="koboSpan" id="kobo.327.1">Here are </span><a id="_idIndexMarker506"/><span class="koboSpan" id="kobo.328.1">the</span><a id="_idIndexMarker507"/><span class="koboSpan" id="kobo.329.1"> pros and cons:</span></p>
<ul>
<li><span class="koboSpan" id="kobo.330.1">Pros:</span><ul><li><span class="koboSpan" id="kobo.331.1">More flexible for representing general data </span></li></ul></li>
<li><span class="koboSpan" id="kobo.332.1">Cons:</span><ul><li><span class="koboSpan" id="kobo.333.1">Slow to process because of its complexity</span></li><li><span class="koboSpan" id="kobo.334.1">Lots of overhead from using many repetitive structure markers</span></li><li><span class="koboSpan" id="kobo.335.1">Less human-readable</span></li><li><span class="koboSpan" id="kobo.336.1">Is prone to redundancies in structure</span></li></ul></li>
</ul>
<h2 id="_idParaDest-122"><a id="_idTextAnchor123"/><span class="koboSpan" id="kobo.337.1">JSON files</span></h2>
<p><strong class="bold"><span class="koboSpan" id="kobo.338.1">JavaScript Object Notation</span></strong><span class="koboSpan" id="kobo.339.1">, or </span><strong class="bold"><span class="koboSpan" id="kobo.340.1">JSON</span></strong><span class="koboSpan" id="kobo.341.1">, is a newer method for data interchange representation</span><a id="_idIndexMarker508"/><span class="koboSpan" id="kobo.342.1"> compared to XML, with the original specification </span><a id="_idIndexMarker509"/><span class="koboSpan" id="kobo.343.1">having been done by Douglas Crockford in the early 2000s. </span><span class="koboSpan" id="kobo.343.2">In 2004, IETF published an informational RFC4627, but only in 2014 did IETF create the RFC7159 standard. </span><span class="koboSpan" id="kobo.343.3">Now the latest standard is RFC8259.</span></p>
<p><span class="koboSpan" id="kobo.344.1">JSON, like objects in JavaScript, has primitive types such as string, Boolean, number, and null. </span><span class="koboSpan" id="kobo.344.2">The structure in JSON consists of a key name and a value surrounded by a pair of curly brackets, as in </span><strong class="source-inline"><span class="koboSpan" id="kobo.345.1">{"key": &lt;value&gt;}</span></strong><span class="koboSpan" id="kobo.346.1">. </span><span class="koboSpan" id="kobo.346.2">The key name is always a string. </span><span class="koboSpan" id="kobo.346.3">Here is an example:</span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.347.1">
{
  "router": {
    "interface": {
      "ip": {
        "unicast": "10.2.2.3"
      },
    "loopback": {
      "ip": {
        "unicast": "100.1.1.1"
    }
  }
}</span></pre>
<p><span class="koboSpan" id="kobo.348.1">Note that</span><a id="_idIndexMarker510"/><span class="koboSpan" id="kobo.349.1"> JSON carries much less overhead than XML.</span></p>
<p><span class="koboSpan" id="kobo.350.1">The preceding representation can also be written in one line, but it is not easy to read:</span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.351.1">
{"router": {"interface": {"ip": {"unicast": "10.2.2.3"}}, "loopback": {"ip": {"unicast": "100.1.1.1"}}}</span></pre>
<p><span class="koboSpan" id="kobo.352.1">Here are</span><a id="_idIndexMarker511"/><span class="koboSpan" id="kobo.353.1"> the </span><a id="_idIndexMarker512"/><span class="koboSpan" id="kobo.354.1">pros and cons:</span></p>
<ul>
<li><span class="koboSpan" id="kobo.355.1">Pros:</span><ul><li><span class="koboSpan" id="kobo.356.1">Simpler and faster than XML</span></li><li><span class="koboSpan" id="kobo.357.1">Better parsing performance</span></li><li><span class="koboSpan" id="kobo.358.1">Loading truncated files is avoided</span></li></ul></li>
<li><span class="koboSpan" id="kobo.359.1">Cons:</span><ul><li><span class="koboSpan" id="kobo.360.1">Does not support comments</span></li><li><span class="koboSpan" id="kobo.361.1">Does not allow aliases</span></li><li><span class="koboSpan" id="kobo.362.1">Carries more overhead than other formats</span></li><li><span class="koboSpan" id="kobo.363.1">Is not human-readable, depending on the format</span></li></ul></li>
</ul>
<h2 id="_idParaDest-123"><a id="_idTextAnchor124"/><span class="koboSpan" id="kobo.364.1">YAML files</span></h2>
<p><strong class="bold"><span class="koboSpan" id="kobo.365.1">YAML</span></strong><span class="koboSpan" id="kobo.366.1"> was</span><a id="_idIndexMarker513"/><span class="koboSpan" id="kobo.367.1"> originally an acronym for </span><strong class="bold"><span class="koboSpan" id="kobo.368.1">Yet Another Markup Language</span></strong><span class="koboSpan" id="kobo.369.1"> because</span><a id="_idIndexMarker514"/><span class="koboSpan" id="kobo.370.1"> it was created after the proliferation of markup languages such as XML and HTML in late 1990. </span><span class="koboSpan" id="kobo.370.2">The creator Clark Evans wanted YAML to sound different, so the name was changed to </span><strong class="bold"><span class="koboSpan" id="kobo.371.1">YAML Ain’t Markup Language</span></strong><span class="koboSpan" id="kobo.372.1">, a recursive acronym, to differentiate the purpose of YAML from other markup languages. </span><span class="koboSpan" id="kobo.372.2">The standard version 1.0 was published in 2004 and the latest version, 1.2.2, was published in 2021.</span></p>
<p><span class="koboSpan" id="kobo.373.1">YAML is intended to be human-readable and its data representation requires the use of indentation and new lines, which are used for delimitation and the grouping of data; this is different from JSON, which doesn’t actually require newlines or indentation.</span></p>
<p><span class="koboSpan" id="kobo.374.1">YAML also supports advanced features that are not supported by other data representation languages, such as anchors and references, which are very useful for avoiding repetition and data errors. </span><span class="koboSpan" id="kobo.374.2">Natively, YAML encodes scalars (such as strings, integers, and floats), dictionaries (or maps), and lists.</span></p>
<p><span class="koboSpan" id="kobo.375.1">Here is </span><a id="_idIndexMarker515"/><span class="koboSpan" id="kobo.376.1">an example:</span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.377.1">
router:
  interface:
    ip:
      unicast: 10.2.2.3
  loopback:
    ip:
      unicast: 100.1.1.1</span></pre>
<p><span class="koboSpan" id="kobo.378.1">As you can see, YAML has an even shorter representation and is very easy to read. </span><span class="koboSpan" id="kobo.378.2">As opposed to JSON, though, it can’t be represented in just one line as the format alters the data representation.</span></p>
<p><span class="koboSpan" id="kobo.379.1">Here are the </span><a id="_idIndexMarker516"/><span class="koboSpan" id="kobo.380.1">pros and cons:</span></p>
<ul>
<li><span class="koboSpan" id="kobo.381.1">Pros:</span><ul><li><span class="koboSpan" id="kobo.382.1">Simpler and smaller</span></li><li><span class="koboSpan" id="kobo.383.1">Easy to read</span></li><li><span class="koboSpan" id="kobo.384.1">Allows aliases and anchors</span></li><li><span class="koboSpan" id="kobo.385.1">Allows comments</span></li></ul></li>
<li><span class="koboSpan" id="kobo.386.1">Cons:</span><ul><li><span class="koboSpan" id="kobo.387.1">Not </span><a id="_idIndexMarker517"/><span class="koboSpan" id="kobo.388.1">as fast to parse as JSON</span></li></ul></li>
</ul>
<p><span class="koboSpan" id="kobo.389.1">There</span><a id="_idIndexMarker518"/><span class="koboSpan" id="kobo.390.1"> are other formats, such </span><a id="_idIndexMarker519"/><span class="koboSpan" id="kobo.391.1">as </span><strong class="bold"><span class="koboSpan" id="kobo.392.1">TOML</span></strong><span class="koboSpan" id="kobo.393.1">, </span><strong class="bold"><span class="koboSpan" id="kobo.394.1">HOCON</span></strong><span class="koboSpan" id="kobo.395.1">, and </span><strong class="bold"><span class="koboSpan" id="kobo.396.1">HCL</span></strong><span class="koboSpan" id="kobo.397.1">. </span><span class="koboSpan" id="kobo.397.2">Each of </span><a id="_idIndexMarker520"/><span class="koboSpan" id="kobo.398.1">them </span><a id="_idIndexMarker521"/><span class="koboSpan" id="kobo.399.1">has its advantages and disadvantages, but for our network automation and for most of our network definitions, YAML is the best option so far. </span><span class="koboSpan" id="kobo.399.2">It is also the most common one in network definitions.</span></p>
<h1 id="_idParaDest-124"><a id="_idTextAnchor125"/><span class="koboSpan" id="kobo.400.1">Summary</span></h1>
<p><span class="koboSpan" id="kobo.401.1">In this chapter, we explored how network automation and engineers can benefit from having a proper configuration and network definition solution. </span><span class="koboSpan" id="kobo.401.2">It is not easy to grow a network with minimal human interaction and low dependency on network vendors and operating system versions.</span></p>
<p><span class="koboSpan" id="kobo.402.1">You are now familiar with network configuration issues and how to tackle them. </span><span class="koboSpan" id="kobo.402.2">You are able to distinguish the stages of a deployment pipeline. </span><span class="koboSpan" id="kobo.402.3">You are also able to create a robust network definition to feed an automated router configuration render and choose the best file type to represent the network definition.</span></p>
<p><span class="koboSpan" id="kobo.403.1">The next chapter will cover network programming by looking at what we should and should not do when writing code for networks.</span></p>
</div>


<div class="Content" id="_idContainer042">
<h1 id="_idParaDest-125"><a id="_idTextAnchor126"/><span class="koboSpan" id="kobo.1.1">Part 2: Network Programming for Automation</span></h1>
<p><span class="koboSpan" id="kobo.2.1">The second part of the book is focused more on the programming aspects of network automation. </span><span class="koboSpan" id="kobo.2.2">This includes a description of the popular libraries, runtime performance, scaling aspects, error handling, logging, and more. </span><span class="koboSpan" id="kobo.2.3">Go and Python are used, and, in some cases, there are comparable examples to show how either language can be used for better network automation work.</span></p>
<p><span class="koboSpan" id="kobo.3.1">This part has the following chapters:</span></p>
<ul>
<li><a href="B18165_05.xhtml#_idTextAnchor127"><em class="italic"><span class="koboSpan" id="kobo.4.1">Chapter 5</span></em></a><span class="koboSpan" id="kobo.5.1">, </span><em class="italic"><span class="koboSpan" id="kobo.6.1">Dos and Don’ts for Network Programming</span></em></li>
<li><a href="B18165_06.xhtml#_idTextAnchor166"><em class="italic"><span class="koboSpan" id="kobo.7.1">Chapter 6</span></em></a><span class="koboSpan" id="kobo.8.1">, </span><em class="italic"><span class="koboSpan" id="kobo.9.1">Using Go and Python for Network Programming</span></em></li>
<li><a href="B18165_07.xhtml#_idTextAnchor183"><em class="italic"><span class="koboSpan" id="kobo.10.1">Chapter 7</span></em></a><span class="koboSpan" id="kobo.11.1">, </span><em class="italic"><span class="koboSpan" id="kobo.12.1">Error Handling and Logging</span></em></li>
<li><a href="B18165_08.xhtml#_idTextAnchor195"><em class="italic"><span class="koboSpan" id="kobo.13.1">Chapter 8</span></em></a><span class="koboSpan" id="kobo.14.1">, </span><em class="italic"><span class="koboSpan" id="kobo.15.1">Scaling Your Code</span></em></li>
</ul>
</div>
<div>
<div id="_idContainer043">
</div>
</div>
<div>
<div id="_idContainer044">
</div>
</div>
</body></html>