<html><head></head><body>
<div><h1 class="chapter-number" id="_idParaDest-100"><a id="_idTextAnchor100"/>4</h1>
<h1 id="_idParaDest-101"><a id="_idTextAnchor101"/>Working with Network Configurations and Definitions</h1>
<p>One important point in network automation is how the configuration is organized and how we can automate our network in a scalable way. In this chapter, we are going to explore how to work with a network configuration and how to define it for effective use with network automation. We want to build scalable and future-proof solutions. </p>
<p>Why do we care about configuration and network definition? Why is it important which file to use? How can we create a lifelong definition? How can we use this to help network automation? Let’s explore answers to these questions in this chapter.</p>
<p>We are going to explore the following:</p>
<ul>
<li>Describing the configuration problem</li>
<li>Helping network automation using definitions</li>
<li>Creating network definitions</li>
<li>Exploring different file types</li>
</ul>
<h1 id="_idParaDest-102"><a id="_idTextAnchor102"/>Technical requirements</h1>
<p>The source code described in this chapter is stored in the GitHub repository at  <a href="https://github.com/PacktPublishing/Network-Programming-and-Automation-Essentials/tree/main/Chapter04">https://github.com/PacktPublishing/Network-Programming-and-Automation-Essentials/tree/main/Chapter04</a>.</p>
<h1 id="_idParaDest-103"><a id="_idTextAnchor103"/>Describing the configuration problem </h1>
<p>Several <a id="_idIndexMarker448"/>production networks out there have their configuration applied to network devices without any additional external definition. Some of them have network diagrams describing the network, but the majority have outdated or incomplete diagrams. Therefore, in most cases, you might need to read running device configurations to understand the details of the network operation.</p>
<p>In some network providers, diagrams are used for an initial understanding of the network or as an overall overview. Once the engineers have enough confidence in their network, the diagrams are just ignored or not used anymore. Some would update their diagrams, but for most engineers, this task is not a priority and usually is left behind.</p>
<p>It is also common for some engineers to apply configuration fixes directly into production devices to solve catastrophic or urgent failures. In other cases, additional configuration is applied temporarily for troubleshooting, but never removed. These configuration changes are forgotten in some cases that they were applied and the network runs with a configuration difference that is not perceived until a software update is necessary.</p>
<p>Let’s discuss the issues further in the following subsections.</p>
<h2 id="_idParaDest-104"><a id="_idTextAnchor104"/>Source of truth</h2>
<p><strong class="bold">Source of truth</strong> is a<a id="_idIndexMarker449"/> term used in computer networks to describe where the definition is and what all other systems have to rely on when consulting or using the information to create further definitions. The source of truth can be either a file, a router configuration, a database, a memory space, or a network diagram.</p>
<p>We want to have the source of truth as steadily defined as possible; it should not change over a short period of time and should be used as a reference for any other definition.</p>
<p>The majority of network engineers rely on the router configuration as the source of truth, because routers are frequently updated and have the correct definitions to run the network; however, this does not help our network automation.</p>
<p>Ideally, we want the source of the truth to be in a database or files stored in a secure and future-proof environment that can be ready to be read by any system quickly.</p>
<h2 id="_idParaDest-105"><a id="_idTextAnchor105"/>The startup configuration and the running configuration</h2>
<p>A network device has<a id="_idIndexMarker450"/> two configuration states, the <strong class="bold">running configuration</strong> and <a id="_idIndexMarker451"/>the <strong class="bold">startup configuration</strong>. The <a id="_idIndexMarker452"/>running configuration is the current configuration <a id="_idIndexMarker453"/>on the device’s memory that is being used to operate at that present moment. The startup configuration is used to boot the device from <em class="italic">off</em> to <em class="italic">on</em>. The difference is that one is volatile and will be deleted once the device is turned off or loses power supply, and the other is permanent and will always exist independent of whether it has a power supply or not.</p>
<p>The startup configuration is normally stored in a non-volatile memory store such as SSD, a flash drive, or a hard drive.</p>
<p>For our automation, we want to have the same running configuration as the startup configuration. When they differ, it might cause automation issues if not well documented.</p>
<h2 id="_idParaDest-106"><a id="_idTextAnchor106"/>Configuration states and history</h2>
<p>A good network automation design<a id="_idIndexMarker454"/> should aim to have multiple configuration states and history, which will help to determine how the network is operating now, how it should operate in the future, and how it operated in the past.</p>
<p>For deployment and automation, it is very useful to separate the configuration into at least four stages: <strong class="bold">Desired</strong>, <strong class="bold">Approved</strong>, <strong class="bold">Applied</strong>, and <strong class="bold">Running</strong>, as shown in <em class="italic">Figure 4.1</em>:</p>
<div><div><img alt=" Figure 4.1 – Configuration stages and control layer" src="img/B18165_04_001.jpg"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US"> Figure 4.1 – Configuration stages and control layer</p>
<p>We’ll discuss each of these in the following sub sections.</p>
<h3>Desired-configuration</h3>
<p>The <strong class="bold">desired-configuration</strong> is <a id="_idIndexMarker455"/>used to <a id="_idIndexMarker456"/>document the configuration that should be applied in the near future. It is used to check for inconsistencies and to be applied in a test network (or a network simulation) to evaluate future deployments, possible syntax errors, and other functional problems.</p>
<p>Modern networks use the desired-configuration to feed a configuration pipeline that will perform a series of tests, including simulation to validate and anticipate errors. It is also used to test the deployment sequence, and evaluate which devices can be deployed in parallel or which ones need to wait until some have finished being deployed.  </p>
<h3>Approved-configuration</h3>
<p>The <strong class="bold">approved-configuration</strong> is <a id="_idIndexMarker457"/>the configuration <a id="_idIndexMarker458"/>that has passed all approval stages in the configuration pipeline, whether they are automated approval stages, such as syntax checks, or manual stages, done by a human approval.</p>
<p>To enhance confidence, some configuration pipelines will apply the desired-configuration in a network simulation for further function testing, and if everything passes, the configuration pipeline will approve the configuration.</p>
<p>From all configuration stages, the approval-configuration is the one that takes more time to finish as large networks have thousands of routers, and some require sequential functional testing instead of parallel testing. After everything is completed, the configurations are ready to be deployed.</p>
<h3>Applied-configuration</h3>
<p>The <strong class="bold">applied-configuration</strong> is<a id="_idIndexMarker459"/> the configuration <a id="_idIndexMarker460"/>saved on the device’s non-volatile configuration or the startup configuration. At the end of this stage, we confidently know that the configuration has been saved in all routers.</p>
<p>This stage also can take a long time because deployment cannot necessarily be performed in parallel.</p>
<h3>Running-configuration</h3>
<p>This stage is used as a<a id="_idIndexMarker461"/> safeguard for future deployments and approval processes. The <strong class="bold">running-configuration</strong> has to be the<a id="_idIndexMarker462"/> same as the applied configuration; however, it might not be the same configuration, especially after a catastrophic event that required configuration intervention.</p>
<p>The running-configuration is constantly updated by trigger points such as privileged access to the device, faulty hardware, or any configuration changes.</p>
<p>Using configuration pipelines requires that only the pipeline is able to change the startup configuration of the router. That means network engineers are not able to save configuration changes on the device to avoid this happening.</p>
<p>For<a id="_idIndexMarker463"/> catastrophic scenarios where the configuration has to be changed quickly, the configuration pipelines are normally bypassed and the configuration updates are done by manual <a id="_idIndexMarker464"/>intervention from network engineers. These changes are normally applied to running-configuration and are not saved to the device. If a configuration audit runs it will show the difference between the running-configuration and the applied-configuration.</p>
<h3>Configuration history</h3>
<p>It is<a id="_idIndexMarker465"/> most desirable to have a history of the configuration for each of the devices for all configuration stages. The configuration history helps us to understand possible failures or improvements by comparing an old setup to a new one. It is also used to build an entire network in simulation for troubleshooting a failure in deployment during configuration updates. A configuration history might also benefit other teams, such as security auditing and capacity planners.</p>
<h2 id="_idParaDest-107"><a id="_idTextAnchor107"/>Deployment pipeline</h2>
<p><strong class="bold">Deployment pipelines</strong> are<a id="_idIndexMarker466"/> used on large<a id="_idIndexMarker467"/> networks that require fast and reliable changes. The pipeline is constructed with modern techniques of simulation and testing, which include extensive use of network automation coding.</p>
<p>An <a id="_idIndexMarker468"/>example of a network deployment pipeline can be seen as follows:</p>
<div><div><img alt="Figure 4.2 – Example of a configuration deployment pipeline " src="img/B18165_04_002.jpg"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 4.2 – Example of a configuration deployment pipeline </p>
<p>In the <a id="_idIndexMarker469"/>preceding figure, we can see how we can use the configuration states in our deployment pipeline. The input to the pipeline is the generated desired configuration, and the approved configuration will only be updated when the final tests have finished. With the use of this workflow, it is possible to automate deployment, reduce mistakes, and allow faster parallel deployments. Let’s describe each step of the pipeline process:</p>
<ol>
<li>First, the configuration syntax is checked automatically. If it passes, go to the next steps. If it fails, the pipeline process stops and waits until a valid configuration is presented.</li>
<li>Second, the pipeline verifies any differences between the running and applied configurations, which in some cases could be due to an urgent configuration fix. If the configurations are different, it will require manual approval to go to the next steps.</li>
<li>Third, the pipeline launches a simulation for the routers in the configuration change scope and deploys the new configuration to the simulated network.</li>
<li>Fourth, the <a id="_idIndexMarker470"/>pipeline runs functional tests in the simulation that will confirm that the new configuration does not break any functions that are already present. If it passes, it goes to the next step. If it fails, the pipeline stops and awaits rejection or acceptance.</li>
<li>Fifth, the pipeline applies the new configuration to the network, following all parallel dependencies and time restrictions.</li>
</ol>
<h2 id="_idParaDest-108"><a id="_idTextAnchor108"/>Network diagrams and automation</h2>
<p>Network diagrams <a id="_idIndexMarker471"/>are graphical, human-friendly, and readable representations of the network, but they are not easy for machines to read. Most of the time, they are generated by humans from graphical tools such as Visio, Lucid Chart, and Draw.io. When generated by humans, the updates on the diagrams, to reflect the current state, are normally left behind, causing information on the diagram to be outdated.</p>
<p>To have an<a id="_idIndexMarker472"/> accurate network diagram, we need to have some sort of diagram generator that reads data from either the router configuration or network definition files.</p>
<p>In our previous example of the deployment pipeline, the diagram generator could read the configuration from any configuration stage and have a different diagram for the running configuration and desired configuration stages.</p>
<p>With<a id="_idIndexMarker473"/> automatic diagram generation, an <a id="_idIndexMarker474"/>up-to-date diagram can be generated for any stage of the pipeline. These diagrams can be used to help network engineers to troubleshoot a problem or help network designers to understand how to <a id="_idIndexMarker475"/>improve the current network functions.</p>
<p>In this section, we discussed how multiple configuration stages can help deploy solutions and how problems can occur when the source of truth is not defined or updated. Next, we will examine how we can create abstract definitions from a device configuration to create a better source of truth.</p>
<h1 id="_idParaDest-109"><a id="_idTextAnchor109"/>Using network definitions to aid automation</h1>
<p>The previous <a id="_idIndexMarker476"/>section explored the configuration stages and how we can rely on them to build a better network deployment pipeline. On the other hand, we have not covered another issue with the router configuration, which is related to router software versions and router vendors.</p>
<p>Using a <a id="_idIndexMarker477"/>router configuration as a source of truth has advantages if your network will not update, grow, or change vendors. If your network is not intended to change, you might not need a definition at all. However, as the majority of the network will need to upgrade or grow, it is important to think about getting away from vendor-specific solutions and create vendor-agnostic definitions of your network.</p>
<p>A <a id="_idIndexMarker478"/>router vendor has different configuration defaults, which means some configuration lines might not be necessary with one vendor but be required with the other vendor. For network automation, we want to avoid traps like that and have a network source of truth that explicitly says what is necessary to configure. We then have to add a translation layer that will produce a router configuration specifically for that vendor.</p>
<p>Another point is some vendors change default configuration between versions of the same operational system. One version might have extra lines that are not present in the other version. This can also cause problems with our network automation. Again, we want to add a translation layer that is vendor- and version-specific, therefore generating configurations appropriately.</p>
<h2 id="_idParaDest-110"><a id="_idTextAnchor110"/>The router configuration render</h2>
<p>A <a id="_idIndexMarker479"/>router configuration render is a software layer that sits between our agnostic definitions and the desired configuration in our deployment pipeline described earlier. It works like a translator and needs to be aware of the vendor and the version of the router to generate an appropriate configuration. The following figure shows an example of two different configuration renders, one for Juniper and one for Cisco:</p>
<div><div><img alt="Figure 4.3 – Configuration render examples for Cisco and Juniper" src="img/B18165_04_003.jpg"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 4.3 – Configuration render examples for Cisco and Juniper</p>
<p>A configuration render can be flexible when generating configuration lines for the same vendor, but it must be aware of the configuration defaults and difference for each vendor and its operating system version. Normally, a render can cover a series of versions and platforms from the same vendor.</p>
<h2 id="_idParaDest-111"><a id="_idTextAnchor111"/>Using configuration templates</h2>
<p>An easy <a id="_idIndexMarker480"/>way to generate a router configuration is to use <strong class="bold">configuration templates</strong>. With these, it is easy to construct a generic configuration and then modify by adding key text words to the configuration text that has to be changed.</p>
<p>In our case, the router configuration render will read the definitions from a file and then read a configuration template to generate the router configuration as described in the following<a id="_idIndexMarker481"/> diagram. It shows an example for a Juniper router, but it can be used for any other router:</p>
<div><div><img alt="Figure 4.4 – Router configuration render using templates" src="img/B18165_04_004.jpg"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 4.4 – Router configuration render using templates</p>
<p>Creating a template is not difficult and it requires only a sample of the router configuration platform that you want to generate; you simply replace the elements you want with a key string. An example using <code>{{ADDRESS}}</code> and <code>{{DESTINATION}}</code> is shown in the preceding figure. </p>
<h2 id="_idParaDest-112"><a id="_idTextAnchor112"/>Using Python engine templates</h2>
<p><strong class="bold">Jinja</strong> is a <a id="_idIndexMarker482"/>template<a id="_idIndexMarker483"/> engine library for Python that is also commonly referred to as <strong class="bold">Jinja2</strong> to <a id="_idIndexMarker484"/>reflect the newest release version. Jinja is used to create HTML, XML, and, for us, router configurations. It was created by Armin Ronacher and is open source with the BSD license. Jinja is similar to the Django template engine, but with the advantage of using Python expressions. It uses a text template and, therefore, can be used to generate any text, markup, or even source code, and router configurations in our case.</p>
<p>For router configurations, Jinja is useful because it has a consistent template tag syntax and the router template configuration is extracted as an independent source, so it can be used as a dependency by other code libraries.</p>
<p>The following <a id="_idIndexMarker485"/>is an example of an input Jinja template file for a Cisco router (a file called <code>cisco_template.txt</code>):</p>
<pre class="source-code">
hostname {{name}}
!
interface Loopback100
description {{name}} router loopback
ip address 100.100.100.{{id}} 255.255.255.255
!
interface GigabitEthernet1/0
description Connection to {{to_name}} router G0/1
!
interface GigabitEthernet1/0.1{{id}}
description Access to {{to_name}}
encapsulation dot1Q 1{{id}}
ip address 100.0.1{{id}}.2 255.255.255.252
ip ospf network point-to-point
ip ospf cost 100
!
router ospf 100
router-id 100.100.100.{{id}}
network 100.0.0.0 0.255.255.255 area 0
!</pre>
<p>The following is the input definition file used to feed the configuration render (a file called <code>router_definitions.yaml</code>):</p>
<pre class="source-code">
- id: 11
  name: Sydney
  to_name: Melbourne
- id: 12
  name: Brisbane
  to_name: Melbourne
- id: 13
  name: Adelaide
  to_name: Melbourne</pre>
<p>The<a id="_idIndexMarker486"/> following is the Python code used to generate the router configurations:</p>
<pre class="source-code">
from jinja2 import Environment, FileSystemLoader
import yaml
env = Environment(loader=FileSystemLoader('templates'))
template = env.get_template('cisco_template_python.txt')
with open('router_definitions.yaml') as f:
    routers = yaml.safe_load(f)
for router in routers:
    router_conf = router['name'] + '_router_config.txt'
    with open(router_conf, 'w') as f:
        f.write(template.render(router))</pre>
<p>After running the preceding Python script, it will generate three files with three different configurations for Sydney, Brisbane, and Adelaide.</p>
<p>Here is the content of the <code>Sydney_router_config.txt</code> output file:</p>
<pre class="source-code">
hostname <strong class="bold">Sydney</strong>
!
interface Loopback100
description <strong class="bold">Sydney</strong> router loopback
ip address 100.100.100.<strong class="bold">11</strong> 255.255.255.255
!
interface GigabitEthernet1/0
description Connection to <strong class="bold">Melbourne</strong> router G0/1
!
interface GigabitEthernet1/0.1<strong class="bold">11</strong>
description Access to <strong class="bold">Melbourne</strong>
encapsulation dot1Q 1<strong class="bold">11</strong>
ip address 100.0.1<strong class="bold">11</strong>.2 255.255.255.252
ip ospf network point-to-point
ip ospf cost 100
!
router ospf 100
router-id 100.100.100.<strong class="bold">11</strong>
network 100.0.0.0 0.255.255.255 area 0
!</pre>
<p>The<a id="_idIndexMarker487"/> following is the content of the <code>Brisbane_router_config.txt</code> output file, just to show the slight differences between the files:</p>
<pre class="source-code">
hostname <strong class="bold">Brisbane</strong>
!
interface Loopback100
description <strong class="bold">Brisbane</strong> router loopback
ip address 100.100.100.<strong class="bold">12</strong> 255.255.255.255
!
interface GigabitEthernet1/0
description Connection to <strong class="bold">Melbourne</strong> router G0/1
!
interface GigabitEthernet1/0.112
description Access to <strong class="bold">Melbourne</strong>
encapsulation dot1Q 1<strong class="bold">12</strong>
ip address 100.0.1<strong class="bold">12</strong>.2 255.255.255.252
ip ospf network point-to-point
ip ospf cost 100
!
router ospf 100
router-id 100.100.100.<strong class="bold">12</strong>
network 100.0.0.0 0.255.255.255 area 0
!</pre>
<p>Like <a id="_idIndexMarker488"/>Sydney and Brisbane, the Adelaide file will be created with the required fields changed. The preceding example is quite simple and has only three keys to be modified: <code>{{id}}</code>, <code>{{name}}</code>, and <code>{{to_name}}</code>. More complex examples can be found in the Jinja documentation at <a href="https://jinja.palletsprojects.com/">https://jinja.palletsprojects.com/</a>.</p>
<h2 id="_idParaDest-113"><a id="_idTextAnchor113"/>Using Go engine templates</h2>
<p>Since<a id="_idIndexMarker489"/> Jinja is limited to just Python, <strong class="bold">Go</strong> has<a id="_idIndexMarker490"/> a native text template engine that can be used to generate router configurations.</p>
<p>Different from Python, Go templates are executed by applying a data structure to the template text. The template has annotations that refer to the data structure, which is normally a field of <code>Struct </code>or <code>Map</code> in Go.</p>
<p>For our example using Go, let’s use a similar template for the Cisco configuration used for Jinja in the previous example, but with small changes to accommodate Go standards. Let’s use the file named <code>cisco_template_go.txt</code>:</p>
<pre class="source-code">
hostname {{.Name}}
!
interface Loopback100
description {{.Name}} router loopback
ip address 100.100.100.{{.Id}} 255.255.255.255
!
interface GigabitEthernet1/0
description Connection to {{.Toname}} router G0/1
!
interface GigabitEthernet1/0.1{{.Id}}
description Access to {{.Toname}}
encapsulation dot1Q 1{{.Id}}
ip address 100.0.1{{.Id}}.2 255.255.255.252
ip ospf network point-to-point
ip ospf cost 100
!
router ospf 100
router-id 100.100.100.{{.Id}}
network 100.0.0.0 0.255.255.255 area 0
!</pre>
<p>And <a id="_idIndexMarker491"/>for the router definition, the <code>router_definitions.yaml</code> file is the same as that used in the Python example.</p>
<p>The following is the Go code used to generate the same router configurations created in Python:</p>
<pre class="source-code">
package main
import (
    "io/ioutil"
    "os"
    "text/template"
    "gopkg.in/yaml.v3"
)
<strong class="bold">type Router struct {</strong>
<strong class="bold">    Id     int    `yaml:"id"`</strong>
<strong class="bold">    Name   string `yaml:"name"`</strong>
<strong class="bold">    Toname string `yaml:"to_name"`</strong>
<strong class="bold">}</strong>
<strong class="bold">type RouterList []Router</strong>
func check(e error) {
    if e != nil {
        panic(e)
    }
}
func main() {
    var routers RouterList
    yamlFile, err := ioutil.ReadFile("router_definitions.yaml")
    check(err)
    err = yaml.Unmarshal(yamlFile, &amp;routers)
    check(err)
    templateFile, err := ioutil.ReadFile("cisco_template_go.txt")
    check(err)
    for _, router := range routers {
        outFile, err := os.Create(router.Name + "_router_config.txt")
        check(err)
        tmpl, err := template.New("render").Parse(string(templateFile))
        check(err)
        err = tmpl.Execute(outFile, router)
        check(err)
    }
}</pre>
<p>The <a id="_idIndexMarker492"/>code in Go is similar to Python, but note that in Go, you have to explicitly describe all the fields you are going to read from the <code>router_definitions.yaml</code> file. This is done in the code with the <code>Router</code> and <code>RouterList</code> types (lines 11 and 17 in the preceding code).</p>
<p>In this section, we explored how we can improve network automation by having router configuration<a id="_idIndexMarker493"/> renders. We also explored some very useful libraries in Python and Go to be used for router configuration renders. Next, we are going to explore the nuances of creating network definitions.</p>
<h1 id="_idParaDest-114"><a id="_idTextAnchor114"/>Creating network definitions</h1>
<p>We have<a id="_idIndexMarker494"/> seen so far how template engines are extremely useful to create router configurations using network automation. It is also important to define a good router definition, so we can have templates that are less specific, allowing the router definition file to determine how the router should be configured. Additionally, if router definitions are created properly, it will not be necessary to change them if a vendor change or a router upgrade is necessary. The only change will be to the router configuration templates. </p>
<p>So, how can we create a network definition that will last longer and can be used as the source of truth for the entire network automation? Let’s explore a few points that would help with that.</p>
<h2 id="_idParaDest-115"><a id="_idTextAnchor115"/>Nested and hierarchical definitions</h2>
<p>A <a id="_idIndexMarker495"/>network definition does not need to be a flat unique file definition but can use a group of files in a nested setup. The reason is that some definition files can be specific to a particular characteristic present in all devices, such as vendor, device type, device rules, ACLs, or device function. Subsequent files that follow the hierarchy can have details that are more specific, such as location, name, capacity limits, or size.</p>
<p>Using nested or hierarchical network definitions will help to avoid having large definition files for each device, and most important of all, avoid the repetition of definitions across different files.</p>
<p>For instance, imagine that you want to control a list of IP addresses that are allowed to log into all routers in your network. If you don’t use nested definitions, you might need to add the list of IPs to all router definitions. But if you have nested definitions, you might be able to use only one file definition for that.</p>
<p>To use hierarchy and groups, though, you must create a custom library that compiles the final definition <a id="_idIndexMarker496"/>of one specific router by looking into all hierarchical definition files that belong to that router. The final compiled definition can then be used on the router configuration render to complete the router template and output the correct router configuration.</p>
<h2 id="_idParaDest-116"><a id="_idTextAnchor116"/>IP allocation considerations</h2>
<p>One<a id="_idIndexMarker497"/> important point to be observed with definitions is the IP addresses that are associated to every interface or protocol on the network devices. The IP addresses are normally unique to the network, unless <strong class="bold">Network Address Translator</strong> (<strong class="bold">NAT</strong>) is being used, but the majority of the IP address range is unique per region and per device.</p>
<p>To create a more flexible and future-proof solution, the IP allocation has to be as unfixed as possible, and rules can be taken for the configuration render to allow better use of the IP allocation.</p>
<p>Using an IP allocation engine in combination with nested definitions, it is possible to reserve IPs that are essential for device identification, such as loopbacks, and leave other IP ranges to be associated to network interfaces.</p>
<p>One enhancement that can be made when IP addresses are not fixed is to have a service that translates the IP address to a name associated with the network definition files. That can be done using DNS, for instance.</p>
<p>The strategy of having less-fixed IPs in the definitions will allow a more flexible solution and avoid complications for the network definition files.</p>
<h2 id="_idParaDest-117"><a id="_idTextAnchor117"/>Using files for definitions</h2>
<p>When<a id="_idIndexMarker498"/> creating definitions, the best practice is to use plain files, not databases or any other storage method. This will allow engineers to have a complete source of truth without dependency on any system or application, thus the files can be <a id="_idIndexMarker499"/>read even after a catastrophic event with multiple system failures.</p>
<h2 id="_idParaDest-118"><a id="_idTextAnchor118"/>File format</h2>
<p>Network <a id="_idIndexMarker500"/>automation should use only one file format across all network definitions. The file should be text-based but use a well-known format that enforces, among other things, typing. If the structure of the file is standard and easy to read, it will help engineers to review it if necessary.</p>
<h2 id="_idParaDest-119"><a id="_idTextAnchor119"/>Names</h2>
<p>Whenever<a id="_idIndexMarker501"/> associating names to network definitions, avoid acronyms or any sort of abbreviation. Although shortening can help engineers to type faster, it can create confusion and raise problems when humans have to investigate. Remember that you can always create hotkeys or aliases locally in your environment to type device names faster.</p>
<p>Some devices have a limit on string sizes for names, so use names wisely and describe as much as possible the device you are naming to avoid economizing space.</p>
<p>This section has shown how important it is to examine some details when creating network definitions. We’ll now review the most common data representation types in our network definitions.</p>
<h1 id="_idParaDest-120"><a id="_idTextAnchor120"/>Exploring different file types</h1>
<p>The examples <a id="_idIndexMarker502"/>that we have seen in this chapter had network definitions with files ending with <code>.yaml</code>, which is an indication that they are in YAML format. But why? Why not XML or JSON formats? Let’s explore the pros and cons of the most used file formats.</p>
<p>For our network definitions, we want to choose a format that is easy to read by humans and systems, fast to parse, and small to store. Then we can write a large content of definitions in files without worrying about performance<a id="_idTextAnchor121"/>, reading difficulty, or storage issues.</p>
<h2 id="_idParaDest-121"><a id="_idTextAnchor122"/>XML files</h2>
<p><strong class="bold">Extensible Markup Language</strong> or <strong class="bold">XML</strong> is<a id="_idIndexMarker503"/> the oldest markup language of those described <a id="_idIndexMarker504"/>in this section, with the first implementation dated 1996. Its first standard publication was created in 1998 by the World Wide Web Consortium as the version 1.0 specification. </p>
<p>The main goals of the initial XML design were to create a markup language that was simple, could cover general cases, and was easy to use across the internet. Even though the initial idea was for XML to create documents, the language has been used for arbitrary data structures on client and server interactions.</p>
<p>Because of its schema system, XML can use several media types. In 2001, IETF published the RFC3023, which described all possible media types, including <code>application/xml</code> and <code>text/xml</code>. In 2014, IETF published RFC7303, which refined the standards for media types and rendered RFC3023 obsolete.</p>
<p>Here is an example:</p>
<pre class="source-code">
&lt;router&gt;
  &lt;interface&gt;
    &lt;ip&gt;
       &lt;unicast&gt;
       <strong class="bold">10.2.2.3</strong>
       &lt;/unicast&gt;
    &lt;/ip&gt;
  &lt;/interface&gt;
  &lt;loopback&gt;
    &lt;ip&gt;
       &lt;unicast&gt;
       <strong class="bold">100.1.1.1</strong>
       &lt;/unicast&gt;
    &lt;/ip&gt;
  &lt;/loopback&gt;
&lt;/router&gt;</pre>
<p>Note that in the example, we only have two data values (the highlighted IP addresses); the rest is<a id="_idIndexMarker505"/> markup overhead.</p>
<p>Here are <a id="_idIndexMarker506"/>the<a id="_idIndexMarker507"/> pros and cons:</p>
<ul>
<li>Pros:<ul><li>More flexible for representing general data </li></ul></li>
<li>Cons:<ul><li>Slow to process because of its complexity</li><li>Lots of overhead from using many repetitive structure markers</li><li>Less human-readable</li><li>Is prone to redundancies in structure</li></ul></li>
</ul>
<h2 id="_idParaDest-122"><a id="_idTextAnchor123"/>JSON files</h2>
<p><strong class="bold">JavaScript Object Notation</strong>, or <strong class="bold">JSON</strong>, is a newer method for data interchange representation<a id="_idIndexMarker508"/> compared to XML, with the original specification <a id="_idIndexMarker509"/>having been done by Douglas Crockford in the early 2000s. In 2004, IETF published an informational RFC4627, but only in 2014 did IETF create the RFC7159 standard. Now the latest standard is RFC8259.</p>
<p>JSON, like objects in JavaScript, has primitive types such as string, Boolean, number, and null. The structure in JSON consists of a key name and a value surrounded by a pair of curly brackets, as in <code>{"key": &lt;value&gt;}</code>. The key name is always a string. Here is an example:</p>
<pre class="source-code">
{
  "router": {
    "interface": {
      "ip": {
        "unicast": "10.2.2.3"
      },
    "loopback": {
      "ip": {
        "unicast": "100.1.1.1"
    }
  }
}</pre>
<p>Note that<a id="_idIndexMarker510"/> JSON carries much less overhead than XML.</p>
<p>The preceding representation can also be written in one line, but it is not easy to read:</p>
<pre class="source-code">
{"router": {"interface": {"ip": {"unicast": "10.2.2.3"}}, "loopback": {"ip": {"unicast": "100.1.1.1"}}}</pre>
<p>Here are<a id="_idIndexMarker511"/> the <a id="_idIndexMarker512"/>pros and cons:</p>
<ul>
<li>Pros:<ul><li>Simpler and faster than XML</li><li>Better parsing performance</li><li>Loading truncated files is avoided</li></ul></li>
<li>Cons:<ul><li>Does not support comments</li><li>Does not allow aliases</li><li>Carries more overhead than other formats</li><li>Is not human-readable, depending on the format</li></ul></li>
</ul>
<h2 id="_idParaDest-123"><a id="_idTextAnchor124"/>YAML files</h2>
<p><strong class="bold">YAML</strong> was<a id="_idIndexMarker513"/> originally an acronym for <strong class="bold">Yet Another Markup Language</strong> because<a id="_idIndexMarker514"/> it was created after the proliferation of markup languages such as XML and HTML in late 1990. The creator Clark Evans wanted YAML to sound different, so the name was changed to <strong class="bold">YAML Ain’t Markup Language</strong>, a recursive acronym, to differentiate the purpose of YAML from other markup languages. The standard version 1.0 was published in 2004 and the latest version, 1.2.2, was published in 2021.</p>
<p>YAML is intended to be human-readable and its data representation requires the use of indentation and new lines, which are used for delimitation and the grouping of data; this is different from JSON, which doesn’t actually require newlines or indentation.</p>
<p>YAML also supports advanced features that are not supported by other data representation languages, such as anchors and references, which are very useful for avoiding repetition and data errors. Natively, YAML encodes scalars (such as strings, integers, and floats), dictionaries (or maps), and lists.</p>
<p>Here is <a id="_idIndexMarker515"/>an example:</p>
<pre class="source-code">
router:
  interface:
    ip:
      unicast: 10.2.2.3
  loopback:
    ip:
      unicast: 100.1.1.1</pre>
<p>As you can see, YAML has an even shorter representation and is very easy to read. As opposed to JSON, though, it can’t be represented in just one line as the format alters the data representation.</p>
<p>Here are the <a id="_idIndexMarker516"/>pros and cons:</p>
<ul>
<li>Pros:<ul><li>Simpler and smaller</li><li>Easy to read</li><li>Allows aliases and anchors</li><li>Allows comments</li></ul></li>
<li>Cons:<ul><li>Not <a id="_idIndexMarker517"/>as fast to parse as JSON</li></ul></li>
</ul>
<p>There<a id="_idIndexMarker518"/> are other formats, such <a id="_idIndexMarker519"/>as <strong class="bold">TOML</strong>, <strong class="bold">HOCON</strong>, and <strong class="bold">HCL</strong>. Each of <a id="_idIndexMarker520"/>them <a id="_idIndexMarker521"/>has its advantages and disadvantages, but for our network automation and for most of our network definitions, YAML is the best option so far. It is also the most common one in network definitions.</p>
<h1 id="_idParaDest-124"><a id="_idTextAnchor125"/>Summary</h1>
<p>In this chapter, we explored how network automation and engineers can benefit from having a proper configuration and network definition solution. It is not easy to grow a network with minimal human interaction and low dependency on network vendors and operating system versions.</p>
<p>You are now familiar with network configuration issues and how to tackle them. You are able to distinguish the stages of a deployment pipeline. You are also able to create a robust network definition to feed an automated router configuration render and choose the best file type to represent the network definition.</p>
<p>The next chapter will cover network programming by looking at what we should and should not do when writing code for networks.</p>
</div>


<div><h1 id="_idParaDest-125"><a id="_idTextAnchor126"/>Part 2: Network Programming for Automation</h1>
<p>The second part of the book is focused more on the programming aspects of network automation. This includes a description of the popular libraries, runtime performance, scaling aspects, error handling, logging, and more. Go and Python are used, and, in some cases, there are comparable examples to show how either language can be used for better network automation work.</p>
<p>This part has the following chapters:</p>
<ul>
<li><a href="B18165_05.xhtml#_idTextAnchor127"><em class="italic">Chapter 5</em></a>, <em class="italic">Dos and Don’ts for Network Programming</em></li>
<li><a href="B18165_06.xhtml#_idTextAnchor166"><em class="italic">Chapter 6</em></a>, <em class="italic">Using Go and Python for Network Programming</em></li>
<li><a href="B18165_07.xhtml#_idTextAnchor183"><em class="italic">Chapter 7</em></a>, <em class="italic">Error Handling and Logging</em></li>
<li><a href="B18165_08.xhtml#_idTextAnchor195"><em class="italic">Chapter 8</em></a>, <em class="italic">Scaling Your Code</em></li>
</ul>
</div>
<div><div></div>
</div>
<div><div></div>
</div>
</body></html>