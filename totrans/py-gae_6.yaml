- en: Chapter 6. Using Channels to Implement a Real-time Application
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第6章。使用频道实现实时应用程序
- en: Web applications use the request/response message exchange pattern to communicate
    with the server. The communication flow always starts from the client (usually
    a web browser), initiating a request and a server that provides a response and
    closes the connection immediately after. This means that if we need to get information
    from a server as soon as they are available, our client has to actively and repeatedly
    request for them using a polling strategy, which is a simple but often ineffective
    solution. In fact, if the poll interval is short, we need to perform a lot of
    requests, which consumes time and bandwidth and overloads the server; on the other
    hand, if the poll interval is long, we cannot consider the delivery of the information
    as real time anymore.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 网络应用程序使用请求/响应消息交换模式与服务器通信。通信流程始终从客户端（通常是网页浏览器）开始，发起请求，服务器提供响应并在之后立即关闭连接。这意味着如果我们需要从服务器获取信息，而这些信息一旦可用，我们的客户端就必须主动且反复地使用轮询策略请求它们，这虽然是一个简单但通常效果不佳的解决方案。实际上，如果轮询间隔短，我们需要执行大量的请求，这会消耗时间和带宽，并使服务器过载；另一方面，如果轮询间隔长，我们不能再将信息的传递视为实时了。
- en: Real-time interaction between clients and servers is a requirement for a large
    set of web applications such as collaborative editors, online multiplayer games,
    or instant messaging software. In general, anytime a client needs to get information
    that is not systematic or predictable, similar to how it is when interacting with
    human users, we better go real time.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 客户端和服务器之间的实时交互是许多网络应用程序（如协作编辑器、在线多人游戏或即时通讯软件）的要求。一般来说，每当客户端需要获取非系统化或不可预测的信息时，类似于与人类用户交互时的情况，我们最好采用实时方式。
- en: If our application runs on App Engine, we can use the **Channel** API to create
    an apparently persistent connection between the browsers that access the application
    and Google servers; this connection can be used at any time to send messages to
    the connected clients nearly in real time, without having to take care of the
    underlying communication mechanisms.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们的应用程序运行在App Engine上，我们可以使用**Channel** API在访问应用程序的浏览器和Google服务器之间创建一个看似持久的连接；这个连接可以在任何时间用来向连接的客户端发送几乎实时的消息，而无需关心底层的通信机制。
- en: 'In this chapter, we will cover the following topics:'
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将涵盖以下主题：
- en: The technology behind the Channel API
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Channel API背后的技术
- en: How to implement the server part of a real-time application
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如何实现实时应用程序的服务器部分
- en: How to implement the client part of a real-time application with JavaScript
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如何使用JavaScript实现实时应用程序的客户端部分
- en: How to deal with a client's disconnection
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如何处理客户端的断开连接
- en: Understanding how the Channel API works
  id: totrans-9
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 理解Channel API的工作原理
- en: 'The Channel API basically consists of the following elements:'
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: Channel API基本上由以下元素组成：
- en: '**Channel**: This is a one-way communication path between the server and a
    JavaScript client. There is exactly one channel for each client and the server
    uses it to dispatch messages.'
  id: totrans-11
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**频道**：这是服务器和JavaScript客户端之间的一条单向通信路径。每个客户端恰好有一个频道，服务器使用它来派发消息。'
- en: '**Client ID**: This is a string that identifies individual JavaScript clients
    on the server. We can specify any string as the Client ID, for example, the identifier
    of the current user.'
  id: totrans-12
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**客户端ID**：这是一个字符串，用于在服务器上标识单个JavaScript客户端。我们可以指定任何字符串作为客户端ID，例如，当前用户的标识符。'
- en: '**JavaScript client**: The client is responsible for connecting to a specific
    channel, listening to updates on the channel itself, and sending messages to the
    server via HTTP requests.'
  id: totrans-13
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**JavaScript客户端**：客户端负责连接到特定的频道，监听频道本身的更新，并通过HTTP请求向服务器发送消息。'
- en: '**Server**: The server is responsible for creating channels for each JavaScript
    client connected, providing access tokens to authenticate connections, receiving
    messages from the client via HTTP requests, and sending updates through the channels.'
  id: totrans-14
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**服务器**：服务器负责为每个连接的JavaScript客户端创建频道，提供访问令牌以验证连接，通过HTTP请求接收来自客户端的消息，并通过频道发送更新。'
- en: 'The first step for using the Channel API is delivering the JavaScript client
    to our users and building the code into the web pages served by the application.
    After the browser receives and executes the client code, the following occurs:'
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 使用Channel API的第一步是将JavaScript客户端交付给我们的用户，并将代码集成到应用程序提供的网页中。在浏览器接收并执行客户端代码后，以下情况会发生：
- en: The JavaScript client asks the server with an HTTP request for a token to open
    a channel providing its own Client ID.
  id: totrans-16
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: JavaScript客户端通过HTTP请求向服务器请求一个token来打开一个提供其自己的Client ID的通道。
- en: The server creates a channel and assigns a token to it; the token is sent back
    to the client.
  id: totrans-17
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 服务器创建一个通道并为其分配一个token；token被发送回客户端。
- en: The JavaScript client uses the token to connect to the channel.
  id: totrans-18
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: JavaScript客户端使用token连接到通道。
- en: 'Once the client is connected to the channel, the server can push messages through
    the channel with the JavaScript client handling them in real time, as shown in
    the following screenshot:'
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦客户端连接到通道，服务器就可以通过通道推送消息，JavaScript客户端可以实时处理这些消息，如下面的截图所示：
- en: '![Understanding how the Channel API works](img/8194OS_06_01.jpg)'
  id: totrans-20
  prefs: []
  type: TYPE_IMG
  zh: '![理解Channel API的工作原理](img/8194OS_06_01.jpg)'
- en: 'We have to keep in mind two important limitations when we design an application
    that makes use of the Channel API:'
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 在设计一个利用Channel API的应用程序时，我们必须记住两个重要的限制：
- en: Only one client at a time can connect to a channel using a given Client ID;
    we cannot share the same channel among multiple clients.
  id: totrans-22
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 同时只能有一个客户端使用给定的Client ID连接到一个通道；我们不能在多个客户端之间共享同一个通道。
- en: A JavaScript client can connect only to one channel for each page; if we want
    to send and receive multiple types of data from the server (for example, data
    regarding different parts of the page), we need to multiplex them so that all
    the information can flow through the same channel.
  id: totrans-23
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: JavaScript客户端每个页面只能连接到一个通道；如果我们想从服务器发送和接收多种类型的数据（例如，关于页面不同部分的数据），我们需要将它们多路复用，以便所有信息都能通过同一个通道流动。
- en: Making our application real time
  id: totrans-24
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使我们的应用程序实时化
- en: To show how to use the Channel API, we will add a small feature to our Notes
    application. If we open the main page in a browser, there is no way for us to
    realize that a new note was created until we refresh the page. As a note can be
    created using the inbound e-mail service, it'd be nice to immediately see the
    change in our browser.
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 为了展示如何使用Channel API，我们将在我们的笔记应用程序中添加一个小的功能。如果我们在一个浏览器中打开主页面，除非我们刷新页面，否则我们无法意识到已经创建了一个新的笔记。由于笔记可以通过入站电子邮件服务创建，所以立即在我们的浏览器中看到变化会很好。
- en: 'We are going to implement this feature using the Channel API: when we visit
    the main page, our application will open a channel, which will wait for new notes
    to be created. We will keep things as simple as possible for the scope of this
    book, and to avoid writing too much JavaScript code, we won''t modify the **Document
    Object Model** (**DOM**) of the page; we will only show a dialog that suggests
    to refresh the page to see new content as soon as new notes are added.'
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将使用Channel API实现这个功能：当我们访问主页面时，我们的应用程序将打开一个通道，该通道将等待创建新的笔记。为了本书的范围，以及避免编写过多的JavaScript代码，我们不会修改页面的**文档对象模型**（**DOM**）；我们只会显示一个对话框，建议在添加新笔记后立即刷新页面以查看新内容。
- en: Implementing the server
  id: totrans-27
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 实现服务器
- en: 'We will start by adding the Python code needed to handle channels on the server
    side. We expect the JavaScript client will make an HTTP `GET` request to request
    a channel, so we add a request handler that will create a channel and return a
    token in the JSON format to access it. We first import the modules needed at the
    top of our `main.py` module:'
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将首先添加在服务器端处理通道所需的Python代码。我们预计JavaScript客户端将发出HTTP `GET`请求来请求一个通道，因此我们添加了一个请求处理器，该处理器将创建一个通道并返回一个JSON格式的token以访问它。我们首先在`main.py`模块的顶部导入所需的模块：
- en: '[PRE0]'
  id: totrans-29
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'Then, we add the code for the request handler:'
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们添加请求处理器的代码：
- en: '[PRE1]'
  id: totrans-31
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'We first check that the user is logged in and return an **HTTP 401: Unauthorized
    error** page if this is not the case. Then, we create a Client ID for the current
    JavaScript client using a `get_notification_client_id()` method that generates
    a string that composes the identifier of the `user` instance we pass to it together
    with an arbitrary prefix:'
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 我们首先检查用户是否已登录，如果没有，则返回一个**HTTP 401：未经授权错误**页面。然后，我们使用`get_notification_client_id()`方法为当前的JavaScript客户端创建一个Client
    ID，该方法生成一个字符串，该字符串由我们传递给它的`user`实例的标识符和任意前缀组成：
- en: '[PRE2]'
  id: totrans-33
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: We can add the preceding code to the `utils.py` module for convenience.
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以将前面的代码添加到`utils.py`模块中以便于使用。
- en: Back to the `GetTokenHandler` code; after we get a Client ID for the client,
    we can proceed to creating the channel by calling the `create_channel()` method
    and passing the identifier as the first argument. The second parameter we pass
    to the function is the timeout for the channel expressed in minutes; when a channel
    expires, an error is raised to the JavaScript client and the channel is closed.
    The default value when we do not specify that parameter is 2 hours, after which
    the client can ask for a new channel. We then set the `Content-Type` header for
    the response to the `application/json` parameter and finally write the token in
    the response body.
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 回到`GetTokenHandler`代码；在为客户获取到Client ID之后，我们可以通过调用`create_channel()`方法并传递标识符作为第一个参数来创建通道。我们传递给函数的第二个参数是通道的超时时间，以分钟为单位；当通道过期时，会向JavaScript客户端抛出错误，并关闭通道。如果我们没有指定该参数，默认值为2小时，之后客户端可以请求新的通道。然后我们设置响应的`Content-Type`头为`application/json`参数，并在响应体中写入令牌。
- en: 'We finally map the `GetTokenHandler` handler to the `/notify_token` URL in
    our `main.py` module:'
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们在`main.py`模块中将`GetTokenHandler`处理器映射到`/notify_token` URL。
- en: '[PRE3]'
  id: totrans-37
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'We can check whether the endpoint is working properly by visiting the `http://localhost:8080/notify_token`
    URL with the local development server running. We should see something like this
    in the browser window:'
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以通过访问运行中的本地开发服务器上的`http://localhost:8080/notify_token` URL来检查端点是否正常工作。在浏览器窗口中，我们应该看到如下内容：
- en: '![Implementing the server](img/8194OS_06_02.jpg)'
  id: totrans-39
  prefs: []
  type: TYPE_IMG
  zh: '![实现服务器](img/8194OS_06_02.jpg)'
- en: 'The last part of the work we need to do on the server side is actually using
    the channels we create to send messages to our users. In particular, we want to
    notify a user as soon as a new note is created using the inbound e-mail service.
    So, we are going to add some code to the `CreateNoteHandler` handler, modifying
    the code of the `receive()` method as follows:'
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在服务器端需要做的最后一部分工作实际上是使用我们创建的通道向我们的用户发送消息。特别是，我们希望在创建新的笔记时立即通过入站电子邮件服务通知用户。因此，我们将在`CreateNoteHandler`处理器中添加一些代码，修改`receive()`方法的代码如下：
- en: '[PRE4]'
  id: totrans-41
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: After a note is actually created, we use the `send_message()` method from the
    channel module to send a message to a particular client. To get the Client ID
    of the recipient, we use the `get_notification_client_id()` method as we did before
    during channel creation. The second parameter we pass to the `send_message()`
    method is the string that represents the message we want to send to our client;
    in this case, we will show some simple text on a dialog in the browser as soon
    as the message is delivered. In a real-world scenario, we would use a more complex
    message than a plain string, adding some more data to let JavaScript clients identify
    the type and the destination of the message; this is very useful if we have to
    multiplex the channel to carry different information for different consumers.
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 实际创建笔记后，我们使用通道模块中的`send_message()`方法向特定客户端发送消息。为了获取接收者的Client ID，我们使用与创建通道时相同的`get_notification_client_id()`方法。传递给`send_message()`方法的第二个参数是代表我们想要发送给客户端的消息的字符串；在这种情况下，一旦消息送达，我们将在浏览器对话框上显示一些简单的文本。在实际场景中，我们会使用比纯字符串更复杂的消息，添加更多数据以让JavaScript客户端识别消息的类型和目的地；如果我们需要为不同的消费者传输不同的信息，这非常有用。
- en: We have now completed all the required work on the server, so we can move to
    the client side and write the JavaScript code we need to interact with the Channel
    API.
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经完成了服务器端的所有必要工作，因此我们可以转向客户端，并编写我们需要与Channel API交互的JavaScript代码。
- en: The JavaScript code for clients
  id: totrans-44
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 客户端的JavaScript代码
- en: App Engine provides a small JavaScript library that simplifies some operations
    needed to manage the socket connection for a channel, so the first thing we need
    to do before proceeding is include this code in our HTML pages. The JavaScript
    code must be included within the `<body></body>` tags, and we will put it just
    before the closing tag so that its execution will not slow down the page-rendering
    process.
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: App Engine提供了一个小的JavaScript库，它简化了管理通道的套接字连接所需的某些操作，因此在我们继续之前，我们需要在HTML页面中包含此代码。JavaScript代码必须包含在`<body></body>`标签内，我们将将其放在关闭标签之前，以避免其执行减慢页面渲染过程。
- en: 'In our `main.html` template file, we add the following:'
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的`main.html`模板文件中，我们添加以下内容：
- en: '[PRE5]'
  id: totrans-47
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: The JavaScript code will be served by App Engine, both in the local development
    environment and in production, at the `/_ah/channel/jsapi` URL.
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: JavaScript代码将由App Engine在本地开发环境和生产环境中，在`/_ah/channel/jsapi` URL上提供。
- en: The code required to provide the logic for the JavaScript client will be added
    in a file called `client.js` that we will store in the `static/js/` path relative
    to the application root folder. In this manner, the file will be uploaded to App
    Engine servers together with the other static assets during the deployment process.
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 为JavaScript客户端提供逻辑所需的代码将被添加到一个名为`client.js`的文件中，我们将将其存储在相对于应用程序根文件夹的`static/js/`路径中。这样，在部署过程中，该文件将与其他静态资源一起上传到App
    Engine服务器。
- en: Note
  id: totrans-50
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: 'We will write our JavaScript code inside a type of closure known as an **Immediately-Invoked
    Function Expression** (**IIFE**), which is nothing more than a self-invoked anonymous
    function executed in the context of the `window` parameter as follows:'
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将在一种称为**立即执行函数表达式**（**IIFE**）的闭包中编写我们的JavaScript代码，这实际上是一个在`window`参数的上下文中自我调用的匿名函数，如下所示：
- en: '[PRE6]'
  id: totrans-52
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: This is a common JavaScript expression most useful when attempting to preserve
    the global namespace; in fact, any variable declared within the function's body
    will be local to the closure but will still live throughout runtime.
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一个在尝试保留全局命名空间时非常有用的常见JavaScript表达式；实际上，在函数体内部声明的任何变量都将属于闭包，但仍然会在整个运行时中存在。
- en: 'Once we have created our `client.js` file, we need to include it within the
    HTML pages served by our Notes application. In the `main.html` file, we add the
    following:'
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦我们创建了`client.js`文件，我们需要将其包含在我们的笔记应用程序提供的HTML页面中。在`main.html`文件中，我们添加以下内容：
- en: '[PRE7]'
  id: totrans-55
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: The order of the `<script>` tags is important because the JavaScript client
    must be available before executing our code.
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: '`<script>`标签的顺序很重要，因为JavaScript客户端必须在执行我们的代码之前可用。'
- en: 'Thanks to the functionalities provided by the JavaScript client library, we
    do not need to write much code. First of all, we need to retrieve the channel
    token from our backend, so we add the following to the `client.js` file:'
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 多亏了JavaScript客户端库提供的功能，我们不需要编写很多代码。首先，我们需要从我们的后端获取频道令牌，因此我们在`client.js`文件中添加以下内容：
- en: '[PRE8]'
  id: totrans-58
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: Here, we declare a function named `init` that will perform an **XMLHttpRequest**
    (**XHR**) request to our backend in order to retrieve the token and will then
    print its value on JavaScript Console.
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们声明了一个名为`init`的函数，该函数将执行一个**XMLHttpRequest**（**XHR**）请求到我们的后端以获取令牌，然后将在JavaScript控制台上打印其值。
- en: Note
  id: totrans-60
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: 'Logging information on JavaScript Console is nonstandard, and it won''t work
    for every user; this largely depends on the browser in use. For example, to enable
    JavaScript Console on Google Chrome, we need to perform the following steps:'
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 在JavaScript控制台上的日志信息是非标准的，并且不会对每个用户都有效；这很大程度上取决于所使用的浏览器。例如，为了在Google Chrome上启用JavaScript控制台，我们需要执行以下步骤：
- en: Go to the **View** menu.
  id: totrans-62
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 前往**视图**菜单。
- en: Select **Developer.**
  id: totrans-63
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 选择**开发者**。
- en: Click on **JavaScript Console**.
  id: totrans-64
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 点击**JavaScript控制台**。
- en: The first instruction on the function body creates an `XMLHttpRequest` object
    that we will use to perform an HTTP `GET` request to our backend. Before firing
    the request, we set the `onload` callback to an anonymous function that will be
    executed once the response is correctly retrieved with no errors from the server.
    The callback function parses the text in the response body into a `json` object
    and logs it on JavaScript Console immediately after. After defining the callback,
    we initialize the request that calls the `open()` method on the `XMLHttpRequest`
    object and specify the HTTP method we want to use, the URL we want to reach, and
    a Boolean flag that represents whether we want to perform the request asynchronously
    or not. Later, we actually perform the request that calls the `send()` method.
    We then call the `init()` function itself so that it is executed the first time
    we visit the page and the script is loaded.
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 函数体中的第一条指令创建了一个`XMLHttpRequest`对象，我们将使用它来对我们的后端执行HTTP `GET`请求。在发送请求之前，我们将`onload`回调设置为匿名函数，该函数将在从服务器正确检索响应且没有错误时执行。回调函数将响应体中的文本解析为`json`对象，并在JavaScript控制台上立即记录。在定义回调后，我们初始化请求，该请求在`XMLHttpRequest`对象上调用`open()`方法，并指定我们想要使用的HTTP方法、我们想要到达的URL以及一个表示我们是否想要异步执行请求的布尔标志。稍后，我们实际上执行了调用`send()`方法的请求。然后我们调用`init()`函数本身，以确保它在第一次访问页面和脚本加载时执行。
- en: 'To check whether everything is working fine, we can start the local development
    server and point the browser to the main page after enabling JavaScript Console
    in our browser. If the request completed successfully, we should see the log message
    that contains the token on the console, as shown in the following screenshot:'
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 为了检查一切是否正常工作，我们可以在浏览器中启用JavaScript控制台后，启动本地开发服务器并将浏览器指向主页面。如果请求成功完成，我们应该在控制台中看到包含令牌的日志消息，如下面的截图所示：
- en: '![The JavaScript code for clients](img/8194OS_06_03.jpg)'
  id: totrans-67
  prefs: []
  type: TYPE_IMG
  zh: '![客户端的JavaScript代码](img/8194OS_06_03.jpg)'
- en: 'We can now use the token retrieved from the backend to open a channel. In the
    `client.js` file, we modify the code as follows:'
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在可以使用从后端检索到的令牌打开一个通道。在`client.js`文件中，我们修改代码如下：
- en: '[PRE9]'
  id: totrans-69
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: We first add a function called `setupChannel()` that takes a valid token as
    its only parameter. Using the JavaScript client code from App Engine, we then
    create a `goog.appengine.Channel` object passing the token to the constructor.
    We then call the `open` method that returns a `goog.appengine.Socket` object for
    the channel. The socket object keeps track of the connection status and exposes
    several callback functions with which we can perform operations in response to
    channel activities. For the moment, we only provide callbacks for the `onopen`
    and `onclose` socket events, logging a message on JavaScript Console. Notice that
    we changed the `init()` function so that it now calls the `setupChannel()` function
    instead of simply logging a message into JavaScript Console.
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 我们首先添加一个名为`setupChannel()`的函数，它只接受一个有效的令牌作为其唯一参数。使用App Engine的JavaScript客户端代码，我们创建一个`goog.appengine.Channel`对象，并将令牌传递给构造函数。然后我们调用`open`方法，该方法返回一个用于该通道的`goog.appengine.Socket`对象。该socket对象跟踪连接状态，并公开几个回调函数，我们可以通过这些回调函数对通道活动执行操作。目前，我们只为`onopen`和`onclose`socket事件提供回调，在JavaScript控制台中记录一条消息。请注意，我们已经修改了`init()`函数，使其现在调用`setupChannel()`函数而不是简单地将在JavaScript控制台中记录一条消息。
- en: 'To test whether the callbacks work properly or not, we can set a very short
    timeout for the channels when we create them in the backend so that we can see
    what happens when a channel expires in a reasonable amount of time. In the `main.py`
    module, we change the call to the `create_channel()` function in the `get()` method
    of the `GetTokenHandler` class in this way:'
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 为了测试回调是否正常工作，我们可以在后端创建通道时为通道设置一个非常短的超时，这样我们就可以在合理的时间内看到通道过期时会发生什么。在`main.py`模块中，我们以这种方式更改对`create_channel()`函数的调用，在`GetTokenHandler`类的`get()`方法中：
- en: '[PRE10]'
  id: totrans-72
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'Now, if we open the main page of the Notes application in the browser with
    JavaScript Console open, we should see something similar to the following screenshot
    after 1 minute:'
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，如果我们用JavaScript控制台打开浏览器中的笔记应用主页面，1分钟后我们应该看到以下截图类似的内容：
- en: '![The JavaScript code for clients](img/8194OS_06_04.jpg)'
  id: totrans-74
  prefs: []
  type: TYPE_IMG
  zh: '![客户端的JavaScript代码](img/8194OS_06_04.jpg)'
- en: As we can see, the channel is opened and after 1 minute it expires, causing
    an error in the JavaScript client and finally calling the callback we set to be
    called for the `onclose` event of the socket object.
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 如我们所见，通道已打开，1分钟后过期，导致JavaScript客户端出现错误，并最终调用我们为socket对象的`onclose`事件设置的回调。
- en: 'To deal with expiring channels, we can add a callback for the `onerror` event
    of the socket object. In our `client.js` file, we add the following:'
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 为了处理即将过期的通道，我们可以在socket对象的`onerror`事件中添加一个回调。在我们的`client.js`文件中，我们添加以下内容：
- en: '[PRE11]'
  id: totrans-77
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'The callback we added is executed when an error occurs in the channel management.
    The callback receives an object as a parameter that contains the error message
    and the error code. If we receive an **HTTP 401 error** page, we assume that the
    channel expired and we call the `init` function to create and set up a new channel.
    This time, if we hit the main page and wait for 1 minute, we can see something
    like the following screenshot:'
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 当通道管理中出现错误时，我们添加的回调会被执行。该回调接收一个参数为对象的参数，其中包含错误消息和错误代码。如果我们收到一个**HTTP 401错误**页面，我们假设通道已过期，并调用`init`函数来创建和设置一个新的通道。这次，如果我们点击主页面并等待1分钟，我们可以看到如下截图所示的内容：
- en: '![The JavaScript code for clients](img/8194OS_06_05.jpg)'
  id: totrans-79
  prefs: []
  type: TYPE_IMG
  zh: '![客户端的JavaScript代码](img/8194OS_06_05.jpg)'
- en: As we can see, after the channel has expired, a new one is immediately created;
    depending on how we use the channel, this can be completely transparent for our
    users.
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 如我们所见，通道过期后，会立即创建一个新的通道；根据我们如何使用通道，这可能会对我们的用户完全透明。
- en: 'Now, we can proceed to adding the code to handle messages pushed by the server
    through the channel. We have to provide a callback for the `onmessage` event of
    the `goog.appengine.Socket` class. When the socket receives a message, the callback
    is invoked and a parameter is passed: the message object. The `data` field of
    this object contains the string passed to the `send_message()` method on the server.
    We then add the following code to the `client.js` file:'
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们可以继续添加处理服务器通过通道推送的消息的代码。我们必须为 `goog.appengine.Socket` 类的 `onmessage` 事件提供一个回调。当套接字收到消息时，回调被调用，并传递一个参数：消息对象。该对象的
    `data` 字段包含传递给服务器上 `send_message()` 方法的字符串。然后我们在 `client.js` 文件中添加以下代码：
- en: '[PRE12]'
  id: totrans-82
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: As soon as a message arrives, we open a dialog on the browser using the `alert()`
    method of the `window` object. The dialog displays the string contained in the
    `data` field of the message object, stating that a new note was created and we
    should refresh the page to see the updated list.
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦收到消息，我们就使用 `window` 对象的 `alert()` 方法在浏览器上打开一个对话框。对话框显示消息对象的 `data` 字段中包含的字符串，指出已创建新笔记，我们应该刷新页面以查看更新后的列表。
- en: To see the code in action, we can point the browser to the main page of the
    Notes application; then, using the local development console, we can simulate
    an inbound e-mail as we did in [Chapter 3](ch03.html "Chapter 3. Storing and Processing
    Users' Data"), *Storing and Processing Users' Data*.
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 要查看代码的实际效果，我们可以将浏览器指向笔记应用的主页；然后，使用本地开发控制台，我们可以模拟入站电子邮件，就像我们在[第 3 章](ch03.html
    "第 3 章。存储和处理用户数据")中做的那样，*存储和处理用户数据*。
- en: 'As soon as the e-mail is received and the new note created, we should see something
    like this in our browser:'
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦收到电子邮件并创建新笔记，我们应该在我们的浏览器中看到如下内容：
- en: '![The JavaScript code for clients](img/8194OS_06_06.jpg)'
  id: totrans-86
  prefs: []
  type: TYPE_IMG
  zh: '![客户端的 JavaScript 代码](img/8194OS_06_06.jpg)'
- en: We are assuming that the only messages that arrive through the channel involve
    the creation of a new note, but we can send more structured data from the server;
    the callback function can then implement more complex logic to distinguish the
    content of the message and perform different operations according to this.
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 我们假设通过通道到达的消息仅涉及新笔记的创建，但我们可以从服务器发送更多结构化数据；回调函数可以实施更复杂的逻辑来区分消息内容，并根据此执行不同的操作。
- en: Tracking connections and disconnections
  id: totrans-88
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 跟踪连接和断开连接
- en: An App Engine application is responsible for the creation of channels and the
    transmission of the token, but it doesn't know whether the JavaScript client is
    connected or not. For example, our Notes application sends a message upon the
    creation of a new note through the inbound e-mail service, but on the other side,
    the JavaScript client might or might not receive it. In some contexts, this is
    not an issue, but there are several use cases where an App Engine application
    needs to know when a client connects or disconnects from a channel.
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: App Engine 应用负责创建通道和传输令牌，但它不知道 JavaScript 客户端是否已连接。例如，我们的笔记应用通过入站电子邮件服务在新笔记创建时发送消息，但在另一端，JavaScript
    客户端可能收到也可能收不到。在某些情况下，这并不是一个问题，但有几个用例中，App Engine 应用需要知道何时客户端连接或断开连接。
- en: 'To enable channel notifications, we first need to enable **inbound Channel
    presence service**. To do this, we have to change our `app.yaml` configuration
    file by adding the following code:'
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 要启用通道通知，我们首先需要启用**入站通道存在服务**。为此，我们必须更改我们的 `app.yaml` 配置文件，添加以下代码：
- en: '[PRE13]'
  id: totrans-91
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'Now that the `presence` service is enabled, our Notes application will receive
    HTTP `POST` requests to the following URLs:'
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，`presence` 服务已启用，我们的笔记应用将接收以下 URL 的 HTTP `POST` 请求：
- en: 'The `/_ah/channel/connected/` URL: When a JavaScript client has connected to
    the channel and can receive messages'
  id: totrans-93
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`_/_ah/channel/connected/` URL：当 JavaScript 客户端连接到通道并可以接收消息时'
- en: 'The `/_ah/channel/disconnected/` URL: When a client has disconnected from the
    channel'
  id: totrans-94
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`_/_ah/channel/disconnected/` URL：当客户端从通道断开连接时'
- en: 'To see how the service works, we can add two handlers to the `main.py` module:'
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 要查看服务的工作方式，我们可以在 `main.py` 模块中添加两个处理器：
- en: '[PRE14]'
  id: totrans-96
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: Each handler receives the `from` field into the `POST` request body. The field
    contains the Client ID of the client that has connected or disconnected from the
    channel. We can check out the application logs to see when the notifications take
    place.
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 每个处理器都会接收到 `POST` 请求体中的 `from` 字段。该字段包含连接或断开连接的客户端的 Client ID。我们可以查看应用程序日志以了解何时发生通知。
- en: Summary
  id: totrans-98
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: In this chapter, we learned the differences between an application that uses
    the standard request/response exchange pattern to get data from a server and a
    real-time application, where the clients are persistently connected to the server
    and receive data as soon as it's available. Using the Channel API, we saw how
    easy it can be to implement a real-time web application when it runs on App Engine.
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们学习了使用标准请求/响应交换模式从服务器获取数据的应用程序与实时应用程序之间的区别，在实时应用程序中，客户端持续连接到服务器，并在数据可用时立即接收数据。使用Channel
    API，我们看到了当它在App Engine上运行时，实现实时网络应用是多么容易。
- en: By adding a new feature to our Notes application, we should now have an idea
    of the features offered by the Channel API and what we can do to get the most
    out of its components.
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 通过为我们的笔记应用添加新功能，我们现在应该对Channel API提供的功能以及我们可以如何充分利用其组件有所了解。
- en: We first implemented the server part, managing channel creation and message
    sending. Then, we moved to the client side, where we managed to implement the
    logic needed to interact with a channel by writing just a few lines of JavaScript
    code.
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 我们首先实现了服务器部分，管理通道创建和消息发送。然后，我们转向客户端，我们设法通过仅编写几行JavaScript代码就实现了与通道交互所需的逻辑。
- en: The Notes application is almost complete now and we have enough familiarity
    with Google Cloud Platform that we can stand to break it up and start over by
    using another Python web framework instead of webapp2\. In the next chapter, we
    will re-implement Notes using Django.
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 现在笔记应用几乎完成了，我们对谷歌云平台已经足够熟悉，以至于我们可以拆分它并重新开始，使用另一个Python网络框架而不是webapp2。在下一章中，我们将使用Django重新实现笔记应用。
