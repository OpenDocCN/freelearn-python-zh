- en: '1'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Understanding the Raspberry Pi
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Welcome to the wonderful world of **Internet of Things** (**IoT**) projects
    and the Raspberry Pi in this, the second edition of *Internet of Things* *Programming
    Projects*.
  prefs: []
  type: TYPE_NORMAL
- en: In this book, we will take a journey into IoT projects using the Raspberry Pi.
    In the first part of this book, we’ll explore IoT projects on the Raspberry Pi,
    initially transforming it into a weather station with the Sense HAT to capture
    real-time data. Later, we’ll use motors and **general-purpose input/output** (**GPIO**)
    pins to repurpose the Pi as an analog metering device.
  prefs: []
  type: TYPE_NORMAL
- en: 'We will then create an IoT home security system, using the Raspberry Pi as
    the central hub for an alarm system. We’ll also develop a LoRa-enabled IoT monitoring
    station for remote sensing. The book culminates with our most ambitious project:
    building an IoT robot car powered by the Raspberry Pi.'
  prefs: []
  type: TYPE_NORMAL
- en: We will start this chapter by exploring the various Raspberry Pi models and
    their significance, observing the evolution and advancements in processing power,
    memory, and capabilities over time.
  prefs: []
  type: TYPE_NORMAL
- en: We will also look at alternatives to the Raspberry Pi available in the IoT landscape,
    enabling us to make informed decisions based on our project requirements. We compare
    these alternatives with the Raspberry Pi, highlighting their unique specifications
    and capabilities.
  prefs: []
  type: TYPE_NORMAL
- en: Furthermore, we dive into Raspberry Pi’s **Hardware Attached on Top** (**HAT**),
    which expands the Raspberry Pi’s capabilities through add-on boards. Specifically,
    we explore the Pibrella HAT and the Raspberry Pi Sense HAT, highlighting their
    ability to enhance the Raspberry Pi with additional features and functionalities.
  prefs: []
  type: TYPE_NORMAL
- en: Our Sense HAT projects will make use of an optional custom Raspberry Pi case
    we see in *Figure 1**.1*. This case allows us to display our Raspberry Pi in a
    vertical format and make use of the dot matrix display on the Sense HAT. The build
    files for the Raspberry Pi 4B and Raspberry Pi 5 versions’ case are available
    in the GitHub repository for the book.
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 1.1 – Raspberry Pi 4B and Sense HAT in a custom case](img/B21282_01_1.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 1.1 – Raspberry Pi 4B and Sense HAT in a custom case
  prefs: []
  type: TYPE_NORMAL
- en: We will also discuss a range of operating systems compatible with the Raspberry
    Pi beyond the official Raspberry Pi OS. These options cater to various applications,
    including networked audio systems, aviation-related projects, retro gaming, and
    3D printing.
  prefs: []
  type: TYPE_NORMAL
- en: In the context of IoT applications, we will highlight the Raspberry Pi’s versatility
    and power as it serves as an optimal platform for processing real-time data and
    controlling physical devices, pivotal in the development and deployment of versatile
    IoT projects.
  prefs: []
  type: TYPE_NORMAL
- en: Finally, we will explore the Raspberry Pi as a robust development platform,
    equipped with pre-installed tools for software development. We conclude the chapter
    with a series of programming projects using the Raspberry Pi with the Sense HAT
    to extract sensory information as we build a scrolling environmental data display.
  prefs: []
  type: TYPE_NORMAL
- en: Our hands-on dive into programming in this chapter will fine-tune our programming
    abilities and ready us for exciting IoT project development throughout this book.
    Although there is a lot of information that is covered in this chapter, we should
    not worry if we feel overwhelmed or if we can’t digest all the information from
    the first chapter right away. As we progress through the book, we will gain more
    experience and understanding, making it easier to grasp the concepts introduced
    early on.
  prefs: []
  type: TYPE_NORMAL
- en: 'We will cover the following:'
  prefs: []
  type: TYPE_NORMAL
- en: Exploring Raspberry Pi models
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Exploring alternatives to the Raspberry Pi
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Looking at the power of HATs
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Investigating operating systems for the Raspberry Pi
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Using the Raspberry Pi for IoT
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Getting started with Raspberry Pi development
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Technical requirements
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The following are required to complete this chapter:'
  prefs: []
  type: TYPE_NORMAL
- en: Late-model Raspberry Pi, such as the Raspberry Pi 5 4/8 GB model or Raspberry
    Pi 4B 4/8 GB model
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Keyboard, mouse, and monitor
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Raspberry Pi Sense HAT is optional but encouraged; we will be making use of
    the Sense HAT software emulator
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The GitHub repository for the chapter is located at [https://github.com/PacktPublishing/-Internet-of-Things-Programming-Projects-2nd-Edition/tree/main/Chapter1](https://github.com/PacktPublishing/-Internet-of-Things-Programming-Projects-2nd-Edition/tree/main/Chapter1).
  prefs: []
  type: TYPE_NORMAL
- en: For those that have access to a 3D printer or 3D printing service, there are
    `.stl` files available in the `Build Files` directory of this chapter’s GitHub
    repository for the construction of the optional custom case. Files are available
    for the Raspberry Pi 5 and Raspberry Pi 4B versions of the case.
  prefs: []
  type: TYPE_NORMAL
- en: A general knowledge of programming is also required. We will be using the Python
    programming language in this book. We will start with basic code and work our
    way toward more advanced coding as we go through the projects in the book.
  prefs: []
  type: TYPE_NORMAL
- en: Exploring Raspberry Pi models
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Every Raspberry Pi model, from the initial Raspberry Pi 1 to the current Raspberry
    Pi 5 and the compact Pi Zero, possesses distinct characteristics and functionalities
    that make it an exciting choice for IoT developers. Each model excels in different
    areas, such as processing power, size, and energy efficiency.
  prefs: []
  type: TYPE_NORMAL
- en: The Raspberry Pi models have evolved significantly over time, with each iteration
    bringing notable advancements in processing power, memory, and capabilities.
  prefs: []
  type: TYPE_NORMAL
- en: 'In the following list, we compare the various models of the Raspberry Pi, starting
    with the first one:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Raspberry Pi 1**: Launched in February 2012, the Raspberry Pi 1 changed the
    world of computing with its affordability and accessibility. Equipped with a 700
    MHz processor, 512 MB RAM, and a $35 price point, the first model of the Raspberry
    Pi spurred digital innovation and highlighted the potential of single-board computers.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Raspberry Pi 2**: Released in February 2015, the Raspberry Pi 2 improved
    on the first model with a 900 MHz quad-core processor and doubled RAM at 1 GB.
    The Raspberry Pi 2 also expanded the GPIO from 26 to 40 pins, allowing for a new
    wave of 40-pin HATs. These advancements allowed the Raspberry Pi 2 to become a
    hub for complex projects, from robotics to IoT applications.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Raspberry Pi 3**: Released in February 2016, the Raspberry Pi 3 sported a
    1.2 GHz quad-core processor. This improved performance by 50-60% and enabled more
    resource-intensive applications. Like the Raspberry Pi 2, it maintained 1 GB RAM.
    Wi-Fi and Bluetooth 4.1 were integrated, simplifying connectivity and freeing
    USB ports (a USB Wi-Fi dongle was required on the Raspberry Pi 2). A new dual-core
    VideoCore IV GPU enhanced multimedia projects with improved video capabilities.
    *Figure 1**.2* provides a layout of a Raspberry Pi 3, highlighting several of
    its key components:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '![Figure 1.2 – Raspberry Pi 3B](img/B21282_01_2.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 1.2 – Raspberry Pi 3B
  prefs: []
  type: TYPE_NORMAL
- en: '**Raspberry Pi 4**: Unveiled in June 2019, the Raspberry Pi 4 marked a significant
    evolution in the series, pushing the boundaries of single-board computers closer
    to conventional desktop PCs in terms of capabilities, all while preserving its
    compact size and affordability. What set the Pi 4 apart was the variety of memory
    options it offered, 2 GB, 4 GB, and 8 GB LPDDR4-3200 SDRAM, a substantial improvement
    over the previous 1 GB LPDDR2 RAM, enabling smoother multitasking and handling
    of data-intensive tasks. Improved connectivity featured Gigabit Ethernet, dual-band
    802.11ac Wi-Fi, and Bluetooth 5.0\. Its multimedia capabilities saw a boost with
    two micro-HDMI ports supporting 4K resolution, allowing the operation of two monitors
    at once. The Raspberry Pi 4 introduced two USB 3.0 ports for quicker data transfer
    and replaced the micro-USB power connector with a USB-C, supporting its enhanced
    features. In *Figure 1**.3*, we see a layout of a Raspberry Pi 4 with several
    of its key components highlighted:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '![Figure 1.3 – Raspberry 4B](img/B21282_01_3.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 1.3 – Raspberry 4B
  prefs: []
  type: TYPE_NORMAL
- en: The Raspberry Pi 4 includes two micro-HDMI ports (for dual displays), four USB
    ports (two 3.0, two 2.0), a Gigabit Ethernet port, a USB-C power port, a micro-SD
    slot, a camera port, and a 3.5mm audio-composite video jack.
  prefs: []
  type: TYPE_NORMAL
- en: '**Raspberry Pi 5**: The Raspberry Pi 5, released in October 2023, marks a significant
    advancement in the series, enhancing computational and multimedia capabilities
    for educational and DIY applications with its upgraded CPU and GPU.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Priced at $60 for 4 GB and $80 for 8 GB, the Raspberry Pi 5 features a 2.4GHz
    quad-core Arm Cortex-A76 CPU, VideoCore VII GPU, dual 4Kp60 HDMI outputs, and
    various connectivity options including Wi-Fi and Bluetooth. It also introduces
    a power button, enhanced memory, and I/O capabilities, including two four-lane
    Mobile Industry Processor Interface (MIPI) camera/display transceivers. These
    transceivers offer the flexibility to connect any combination of two cameras or
    displays, making them ideal for advanced multimedia projects.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: The Raspberry Pi 5 also features a PCIe 2.0 x1 interface, allowing the connection
    of fast peripherals to expand its capabilities for advanced applications, such
    as high-speed networking or storage solutions.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'The accompanying Raspberry Pi Active Cooler, with its efficient heatsink and
    fan design, reduces CPU temperatures by approximately 20 degrees Celsius, vital
    for intensive tasks. It offers easy installation and up to 8000 RPM fan speed,
    enhancing performance and longevity. In *Figure 1**.4*, the Raspberry Pi 5 is
    displayed alongside its Active Cooler, with key components such as the PCIe 2.0
    Interface, GPIO Header, USB Ports, Ethernet Port, dual micro-HDMI Ports, and the
    two MIPI Transceivers labeled:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '![Figure 1.4 – Raspberry Pi 5 (right) and Raspberry Pi Active Cooler (left)](img/B21282_01_4.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 1.4 – Raspberry Pi 5 (right) and Raspberry Pi Active Cooler (left)
  prefs: []
  type: TYPE_NORMAL
- en: We will feature the Raspberry Pi 5 for our projects that involve a single-board
    computer, although the late-model Raspberry Pi 4B should suffice too.
  prefs: []
  type: TYPE_NORMAL
- en: '**Raspberry Pi Zero and Zero W**: Launched in November 2015, the Raspberry
    Pi Zero shrank the Raspberry Pi to a size of just 65mm by 30mm. It packed a 1
    GHz single-core CPU and 512 MB of RAM at an affordable price. It came with a mini-HDMI
    Port, a micro-USB OTG Port, a micro-USB Power Port, and a HAT-compatible 40-pin
    header, making it ideal for compact applications such as IoT projects, wearables,
    as well as embedded systems. The Raspberry Pi Zero 2W was built on the same form
    factor and was introduced in 2021\. It brought an enhanced 1 GHz quad-core ARM
    Cortex-A53 CPU, boosting performance and handling more demanding tasks. Its wireless
    capabilities with onboard Wi-Fi and Bluetooth further expanded its versatility,
    making it an excellent choice for compact projects. *Figure 1**.5* provides a
    layout of a Raspberry Pi Zero 2W:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '![Figure 1.5 – Raspberry Pi Zero 2W](img/B21282_01_5.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 1.5 – Raspberry Pi Zero 2W
  prefs: []
  type: TYPE_NORMAL
- en: '**Raspberry Pi Pico and Pico W**: Introduced in January 2021, the Raspberry
    Pi Pico is a compact microcontroller board designed for embedded projects and
    low-level programming. It’s only 51mm x 21mm in size, but highly flexible. It
    supports **Serial Peripheral Interface** (**SPI**) for high-speed data exchange,
    **Inter-Integrated Circuit** (**I2C**) for communication between peripherals,
    and **Universal Asynchronous Receiver/Transmitter** (**UART**) for serial communication.
    The Raspberry Pi Pico W, launched in February 2022, extended this flexibility
    with onboard Wi-Fi and Bluetooth. Unlike the traditional Raspberry Pi boards,
    both Pico models offer a unique set of **General Purpose** (**GP**) pins. Importantly,
    the Pico series, as microcontrollers rather than single-board computers, do not
    have an operating system. This enables bare metal programming, an approach where
    code runs directly on the hardware, resulting in faster, more efficient code execution
    and precise control. This makes devices such as the Raspberry Pi Pico ideal for
    applications requiring immediate reactions and close interactions with hardware,
    making it perfect for time-sensitive tasks. In *Figure 1**.6*, we see a Raspberry
    Pi Pico W and a mapping of its GP pins:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '![Figure 1.6 – Raspberry Pi Pico W](img/B21282_01_6.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 1.6 – Raspberry Pi Pico W
  prefs: []
  type: TYPE_NORMAL
- en: We will be using the variations of the Raspberry Pi Pico for projects where
    microcontrollers are more suitable than single-board computers.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following is a table outlining some of the differences between Raspberry
    Pi models:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 1.7 – Table of Raspberry Pi models](img/B21282_01_7.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 1.7 – Table of Raspberry Pi models
  prefs: []
  type: TYPE_NORMAL
- en: Now that we have a better understanding of the ecosystem of Raspberry Pi devices,
    let’s look at some alternatives.
  prefs: []
  type: TYPE_NORMAL
- en: Exploring alternatives to the Raspberry Pi
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The IoT landscape is filled with a variety of single-board computers and microcontrollers,
    each offering unique specifications that cater to specific project needs. By comparing
    these alternatives with the Raspberry Pi, we can make informed decisions about
    the ideal platform for our unique requirements. The following is a breakdown of
    some of the alternatives to the Raspberry Pi that we may consider for our IoT
    projects. We will only focus on the Raspberry Pi and not the Raspberry Pi Pico
    as we will be using the former for this chapter’s programming projects:'
  prefs: []
  type: TYPE_NORMAL
- en: '**BeagleBone Black**: The BeagleBone Black features a 1GHz ARM Cortex-A8 processor,
    512MB DDR3 RAM, 4 GB flash storage, and many connectivity options. Its distinct
    feature, the **Programmable Real-Time Units** (**PRUs**), allow for precise real-time
    processing, ideal for applications such as robotics or industrial automation.
    Despite this, the Raspberry Pi remains popular due to its faster 1.5GHz 64-bit
    quad-core processor, beneficial for resource-intensive applications. The Raspberry
    Pi’s main advantage, however, is its large community software ecosystem, which
    greatly helps in easing development.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Arduino Uno**: Like the Raspberry Pi Pico, the Arduino Uno is a microcontroller
    rather than a single-board computer. It uses the ATmega328P microcontroller, operates
    at 16 MHz, and has 2 KB of RAM. The Arduino Uno shines with its easy-to-use shields
    for functionality expansion, including Wi-Fi, Bluetooth, and sensor capabilities,
    making it ideal for simpler IoT projects. It benefits from an extensive ecosystem
    and easy-to-use **Integrated Development Environment** (**IDE**). However, for
    projects requiring heavy computations, multitasking, or extensive data processing,
    the more powerful Raspberry Pi is a preferable option.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**ESP32**: The ESP32 by Espressif Systems is a microcontroller like the Arduino
    Uno but with distinctive features. Its dual-core Xtensa LX6 microprocessor and
    520 KB of SRAM, combined with in-built Wi-Fi and Bluetooth, enable robust wireless
    connectivity for IoT applications. Certain ESP32 models further expand their potential
    with additional sensors and communication protocols, such as LoRa for long-range,
    low-power communications. Although it doesn’t match the Raspberry Pi’s processing
    and RAM capabilities, it shines in areas prioritizing wireless connectivity and
    low power use. Its compactness and cost-effectiveness make it suitable for diverse
    IoT projects, from remote monitoring to home automation and wearables. In *Figure
    1**.8*, we see an ESP32 with built-in LoRa communication and **Organic Light-Emitting
    Diode** (**OLED**) screen (the LoRa board is covered by the screen):'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '![Figure 1.8 – ESP32 with the OLED screen and LoRa](img/B21282_01_8.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 1.8 – ESP32 with the OLED screen and LoRa
  prefs: []
  type: TYPE_NORMAL
- en: '**Arduino Nano RP2040 Connect**: The Arduino Nano RP2040 Connect was developed
    to integrate Raspberry Pi’s RP2040 microcontroller into a compact, feature-rich
    Arduino board, offering a unique blend of performance and connectivity for IoT
    projects and embedded AI solutions. It combines the dual-core processing power
    of the RP2040 with onboard Wi-Fi and Bluetooth, a six-axis IMU, microphone, and
    RGB LED, targeting a seamless IoT development experience. Its compatibility with
    the Arduino Cloud platform simplifies project management with capabilities such
    as over-the-air updates.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Now that we have explored some of the alternatives to the Raspberry Pi, we will
    now turn our focus to expanding the functionality of the Raspberry Pi using HATs.
  prefs: []
  type: TYPE_NORMAL
- en: Looking at the power of HATs
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Raspberry Pi HATs are add-on boards that extend the capabilities of the Raspberry
    Pi, offering a wide range of functionality for various applications. These HATs
    provide an easy and convenient way to enhance the Raspberry Pi’s capabilities
    by adding features such as sensors, actuators, displays, communication interfaces,
    and more. In this section, we will explore two notable HATs: the Pibrella HAT
    and the Raspberry Pi Sense HAT.'
  prefs: []
  type: TYPE_NORMAL
- en: Pibrella HAT
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The Pibrella HAT is an excellent beginner-friendly board designed to introduce
    electronics and programming concepts to users of all ages. It features buttons,
    LEDs, and a buzzer, providing a hands-on experience for physical computing projects
    with the Raspberry Pi. With its intuitive interface and Python library, the Pibrella
    HAT offers a great starting point for learning and prototyping.
  prefs: []
  type: TYPE_NORMAL
- en: 'Despite being designed for the first version of the Raspberry Pi and thus having
    only a 26-pin GPIO connection, the Pibrella HAT can still be used with the current
    40-pin versions of the Raspberry Pi. We can see the Pibrella HAT being attached
    to a Raspberry Pi 3B in *Figure 1**.9*:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 1.9 – Attaching the Pibrella to a Raspberry Pi 3B](img/B21282_01_9.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 1.9 – Attaching the Pibrella to a Raspberry Pi 3B
  prefs: []
  type: TYPE_NORMAL
- en: With the Pibrella HAT, users can explore the fundamentals of physical computing,
    learn about input and output interactions, and gain hands-on experience in programming
    with the Raspberry Pi.
  prefs: []
  type: TYPE_NORMAL
- en: The Raspberry Pi Sense HAT
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The Raspberry Pi Sense HAT (as shown in *Figure 1**.10*) is an impressive add-on
    board designed to enhance the capabilities of the Raspberry Pi for sensing and
    environmental monitoring applications. Equipped with a variety of sensors, including
    temperature, humidity, pressure, gyroscope, accelerometer, and magnetometer, the
    Sense HAT allows users to gather data from the surrounding environment with ease.
    Its LED matrix display offers a visual output, enabling users to display real-time
    information, including animations:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 1.10 – Raspberry Pi Sense HAT](img/B21282_01_10.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 1.10 – Raspberry Pi Sense HAT
  prefs: []
  type: TYPE_NORMAL
- en: In addition to its wide range of applications, the Sense HAT also plays a vital
    role in the AstroPi program, which enables students to run their own experiments
    on the International Space Station. With its sensors and compact form factor,
    the Sense HAT is an ideal choice for collecting valuable data in a space station.
  prefs: []
  type: TYPE_NORMAL
- en: In this chapter, we begin writing code using a Raspberry Pi 5 and Sense HAT.
    We will write code to fetch the current temperature from Sense HAT’s built-in
    temperature sensor and display it as a scrolling message on the Sense HAT’s dot
    matrix display.
  prefs: []
  type: TYPE_NORMAL
- en: Before we do this, however, we will continue our exploration of the Raspberry
    Pi by looking at the various operating systems available for the Raspberry Pi.
  prefs: []
  type: TYPE_NORMAL
- en: Investigating operating systems for the Raspberry Pi
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'While the official Raspberry Pi OS (formerly Raspbian) is the most widely used
    operating system for the Raspberry Pi, there is also support for various other
    operating systems. These options range from specialized systems tailored for specific
    applications, such as audio players including Volumio, and more general-purpose
    systems, such as Ubuntu and Raspberry Pi OS itself. In this section, we explore
    a selection of these operating systems and their unique features. They are as
    follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Volumio**: For those of us aiming to build a networked audio system accessible
    via a computer or smartphone, Volumio is a fitting choice. It transforms the Raspberry
    Pi into a headless audio player, rendering a keyboard or mouse unnecessary. This
    system connects to our audio files via a USB or network, with the option to enhance
    the audio output quality through an add-on HAT. Notably, Volumio includes a Spotify
    plugin, letting us stream music over a sound system.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**PiFM radio transmitter**: This system image turns the Raspberry Pi into an
    FM transmitter, broadcasting audio files to any standard FM radio receiver. We
    simply need to attach a wire to one of the GPIO pins to function as an antenna,
    creating a surprisingly robust FM signal.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Stratux**: Stratux is open-source aviation software that can transform a
    Raspberry Pi into a powerful **Automatic Dependent Surveillance-Broadcast** (**ADS-B**)
    receiver. ADS-B is a modern aviation standard that allows aircraft to share their
    position, velocity, and other flight data with air traffic control and other aircraft.
    By installing Stratux on a Raspberry Pi and pairing it with additional hardware,
    we can create our own ADS-B ground station. This enables us to receive real-time
    data from aircraft in our vicinity, including flight trajectories, altitude, and
    speed.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**RetroPie**: For gaming buffs, RetroPie converts our Raspberry Pi into a retro
    gaming console. It effectively emulates several vintage gaming consoles and computers
    such as Amiga, Apple II, Atari 2600, and the Nintendo Entertainment System from
    the early 1980s.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**OctoPi**: For those of us involved in 3D printing, OctoPi transforms a Raspberry
    Pi into a server for a 3D printer, offering control and monitoring remotely through
    a network connection.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '![Figure 1.11 – OctoDash main screen](img/B21282_01_11.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 1.11 – OctoDash main screen
  prefs: []
  type: TYPE_NORMAL
- en: A companion to OctoPi is **OctoDash** (as shown in *Figure 1**.11*), a touchscreen
    interface that provides an easy-to-use, visually appealing control panel for managing
    and monitoring 3D printing tasks. Using OctoPi with OctoDash can make the interaction
    with a 3D printer more flexible and efficient.
  prefs: []
  type: TYPE_NORMAL
- en: '**Ubuntu for Raspberry Pi**: Ubuntu, a leading open-source Linux distribution
    company, offers a platform for Raspberry Pi. Among Ubuntu’s key strengths is its
    compatibility with the **Robot Operating System** (**ROS**), an adaptable framework
    for writing robot software. With ROS on Ubuntu installed on a Raspberry Pi, we
    can engage in robotics projects, from simple hobbyist endeavors to sophisticated
    industrial automation systems. We will begin our exploration of ROS in [*Chapter
    11*](B21282_11.xhtml#_idTextAnchor173).'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Raspberry Pi OS**: Formerly known as Raspbian, Raspberry Pi OS is the most
    widely used operating system for Raspberry Pi due to its direct compatibility,
    lightweight design, and ease of use. Tailored specifically for Raspberry Pi, this
    operating system is abundant in educational software and programming tools, thereby
    aligning with Raspberry Pi’s mission of promoting learning in computer science
    and related fields. Installing Raspberry Pi OS is straightforward with the Raspberry
    Pi Imager, a tool that simplifies the process of burning the system image to a
    microSD card. Once installed, Raspberry Pi OS provides a graphical user interface
    along with a comprehensive suite of programming, internet, and multimedia apps,
    thereby making it a versatile choice for a wide range of Raspberry Pi projects.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Now that we have a general understanding of the operating systems available
    for the Raspberry Pi, let’s explore using the Raspberry Pi in the field that this
    book is based on – IoT.
  prefs: []
  type: TYPE_NORMAL
- en: Using the Raspberry Pi for IoT
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: IoT has revolutionized the way we interact with technology, giving everyday
    objects the ability to communicate, automate tasks, and generate invaluable data
    for use over the internet. The Raspberry Pi is central to many of these systems.
    Its versatility and robust processing capabilities enable this powerful single-board
    computer to function both as a data processor and a controller for physical devices.
  prefs: []
  type: TYPE_NORMAL
- en: Uniquely equipped with features such as GPIO pins, USB ports, and Wi-Fi capabilities,
    the Raspberry Pi is a cost-effective and instrumental tool in implementing IoT
    solutions. The Raspberry Pi is especially valuable for processing real-time data
    and managing hardware. The following is a look at examples of Raspberry Pi-based
    IoT systems.
  prefs: []
  type: TYPE_NORMAL
- en: Utilizing web services for IoT applications
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: One of the distinct advantages of using the Raspberry Pi in IoT applications
    is its capacity to process real-time data and control other hardware elements
    based on this data. This capability becomes particularly useful when the data
    is sourced from the internet. The applications for such a setup are vast, from
    environmental monitoring to health tracking, traffic management, and more.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following example introduces a specific instance of such an application
    – a Raspberry Pi-driven IoT system that suggests appropriate clothing based on
    the current weather conditions (*Figure 1**.12*):'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 1.12 – Analog dashboard for weather information](img/B21282_01_12.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 1.12 – Analog dashboard for weather information
  prefs: []
  type: TYPE_NORMAL
- en: Built in the first edition of *Internet of Things Programming Projects*, this
    application utilizes an intuitive analog dashboard to suggest appropriate clothing
    based on the weather conditions. It includes an LED, which indicates if an umbrella
    will be necessary.
  prefs: []
  type: TYPE_NORMAL
- en: In addition to being a weather-based application, we can modify this Raspberry
    Pi-powered IoT solution for various applications that involve collecting real-time
    data from a web service and representing it as analog data and an LED.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here are a few examples:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Traffic density monitor**: Leveraging similar concepts as described in *Figure
    1**.12*, this application would gather real-time traffic data from a city’s traffic
    monitoring API. The analog meter would show the current traffic density, and the
    LED could flash to indicate heavy traffic or congestion on a specific route. This
    allows commuters to choose the best routes and times to travel.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Health monitoring system**: With data sourced from a health API or smart
    health devices, the analog meter could display heart rate, blood pressure, or
    any other vital statistic. The LED would act as an immediate visual alert for
    abnormal values, prompting immediate medical attention if necessary.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Water quality monitor**: The IoT device could connect to a web service that
    receives data from water quality sensors in a river, lake, or ocean. The analog
    meter could display metrics such as pH level and the LED could flash when the
    readings indicate potentially hazardous conditions.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Agricultural monitor**: Connected to a web service that pulls data from sensors
    in a farm field (such as soil moisture, temperature, etc.), the analog meter could
    display current conditions, while the LED could indicate when conditions are ripe
    for irrigation or if there’s a risk of frost.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Moving beyond metered dashboards, the powerful features of Raspberry Pi are
    particularly effective in robotics. The Raspberry Pi acts as the *brain* for these
    systems, managing tasks such as sensor data analysis, decision-making, and motor
    control. The integration of IoT and robotics has resulted in major advancements
    in various fields including security, automation, and surveillance. An example
    of this is **T.A.R.A.S.** (short for **This Amazing Raspberry-Pi Automated Security
    agent**), an automated security agent powered by Raspberry Pi and IoT principles,
    as presented in the first edition of *Internet of Things* *Programming Projects*.
  prefs: []
  type: TYPE_NORMAL
- en: Re-introducing T.A.R.A.S. – an IoT-based robotics project
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: T.A.R.A.S., a backronym named in honor of one of the author’s business mentors,
    Taras, serves as an automated security guard.
  prefs: []
  type: TYPE_NORMAL
- en: 'This application of IoT in robotics exhibits how a Raspberry Pi can manage
    sensory and motor functions. It uses **Message Queuing Telemetry Transport** (**MQTT**)
    messages, a lightweight, publish–subscribe network protocol, enabling seamless
    communication between devices. We can see a graphic of T.A.R.A.S. in *Figure 1**.13*:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 1.13 – T.A.R.A.S. communicates over the internet by sending and receiving
    MQTT messages](img/B21282_01_13.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 1.13 – T.A.R.A.S. communicates over the internet by sending and receiving
    MQTT messages
  prefs: []
  type: TYPE_NORMAL
- en: Alongside sensory inputs, LED, and buzzer outputs, T.A.R.A.S. encapsulates the
    dynamic range of possibilities within IoT. In the previous edition, we built a
    web-based controller for T.A.R.A.S., integrating a host of skills acquired throughout
    the book.
  prefs: []
  type: TYPE_NORMAL
- en: In this edition of *Internet of Things Programming Projects*, we say goodbye
    to T.A.R.A.S. as he has taken a package and retired from the security field. We
    will say hello to **A.R.E.S.**, or **Advanced Robotic Eyes for Security**. Named
    after the author’s beloved late dog, A.R.E.S. will take security and mobility
    to a new level by incorporating vision recognition and ROS.
  prefs: []
  type: TYPE_NORMAL
- en: Getting started with Raspberry Pi development
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Our Raspberry Pi can serve as a robust development platform ideal for various
    programming environments. The default Linux-based Raspberry Pi OS is equipped
    with Python, Scratch, and many other tools that cater to both beginners and seasoned
    programmers. It’s particularly effective for IoT projects and edge computing,
    thanks to its small form factor. As developers, we can use it for software development,
    web hosting, home automation projects, and prototyping, making it a versatile
    and accessible tool for innovation.
  prefs: []
  type: TYPE_NORMAL
- en: In this book, we will develop IoT projects using the Raspberry Pi, specifically
    utilizing the Raspberry Pi 5 with 8 GB of RAM for optimal performance. While other
    versions of the Raspberry Pi may be sufficient, the Raspberry Pi 5 with 8 GB of
    RAM is currently the most powerful model available. Our projects will encompass
    an array of exciting applications, including an analog metered weather dashboard,
    an internet-connected home security system, an IoT remote monitoring station,
    and A.R.E.S. our advanced IoT-enabled robot car. In the remainder of this chapter,
    we will familiarize ourselves with reading sensory data from a Raspberry Pi Sense
    HAT.
  prefs: []
  type: TYPE_NORMAL
- en: Before diving into development though, it’s crucial to familiarize ourselves
    with the development tools that are available for the Raspberry Pi.
  prefs: []
  type: TYPE_NORMAL
- en: Raspberry Pi development tools
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The following is a range of development tools available for our Raspberry Pi
    projects. It’s important to note that not all these programs come pre-installed
    with Raspberry Pi OS and may require manual installation:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Python**: Python is a high-level interpreted programming language for general-purpose
    programming. Its simple syntax and readability make it excellent for beginners,
    and its powerful libraries and versatility also suit advanced users for complex
    projects. Python comes pre-installed on Raspberry Pi OS.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Thonny**: Thonny is an IDE for Python that comes pre-installed with Raspberry
    Pi OS. It’s easy to use for beginners and includes features such as **step-by-step
    debugging** and **error highlighting**. It’s also robust enough for advanced users,
    offering comprehensive tools for more complex coding. We will utilize Thonny for
    our projects in this book.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Scratch**: Scratch is a block-based visual programming language aimed at
    children. With Scratch, children can create animation and games all while learning
    the basics of programming.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Greenfoot and BlueJ**: These are two IDEs for Java. They are primarily used
    in education and are designed to help beginners get a grip on object-oriented
    programming.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Mu** – This is a Python editor for beginner programmers. It’s designed to
    be simple and easy to understand.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Geany**: It is a lightweight and highly customizable IDE that supports a
    wide range of programming languages including C, Java, PHP, HTML, Python, Perl,
    Pascal.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Wolfram Mathematica and Wolfram Language**: Wolfram provides a high-level
    language and interactive environment for programming, mathematical visualization,
    and general computation.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Node-RED**: This is a flow-based open source tool used for visual programming.
    Node-RED allows access to APIs and online services.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**GCC and GDB**: The **GNU Compiler Collection** (**GCC**) (including gcc and
    g++) and the **GNU Debugger** (**GDB**) allow us to compile and debug code written
    in languages such as C and C++.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Apart from these, we can install other software development tools from the Raspberry
    Pi OS repositories using the apt package manager or download and install them
    manually. For example, we might want to install Git for version control, Docker
    for containerization, or Visual Studio Code for a more advanced development environment.
  prefs: []
  type: TYPE_NORMAL
- en: The Raspberry Pi supports a wide array of development tools, catering to various
    programming needs. By looking at these tools, we’ve underscored the Raspberry
    Pi’s adaptability and capacity for innovative projects.
  prefs: []
  type: TYPE_NORMAL
- en: Raspberry Pi and Sense HAT development
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: It is a great idea to start our journey into IoT development by learning how
    to write simple code for the Raspberry Pi Sense HAT. The Sense HAT serves as an
    excellent IoT device, equipped with a range of sensors and an LED matrix display
    that can be harnessed to create innovative applications.
  prefs: []
  type: TYPE_NORMAL
- en: 'For our coding examples, we will securely mount our Raspberry Pi 5 into a case
    specifically designed for this book. In *Figure 1**.14*, we can see a CAD render
    of the case that we will be using. The case features a front cover that exposes
    the dot matrix LED screen of the Sense HAT. It also includes a circular vent to
    ensure proper heat dissipation inside the case. On the back part of the case,
    we have incorporated a GoPro-style hook, providing us with the flexibility to
    mount the Raspberry Pi and Sense HAT using any GoPro stand. Files to build the
    case are available from the book’s GitHub repository. Using a standard FDM 3D
    printer to make the case should be sufficient; however, better quality and durability
    are obtained using a liquid resin printer and engineering resins such as Siraya
    Tech Blu. *Figure 1**.14* shows what the assembled case will look like with the
    printed stem and base plate in place of a GoPro stand:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 1.14 – Custom-designed Sense HAT case for Raspberry Pi 5](img/B21282_01_14.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 1.14 – Custom-designed Sense HAT case for Raspberry Pi 5
  prefs: []
  type: TYPE_NORMAL
- en: We can find all the necessary files for 3D printing (`.stl` files) in the `Build
    Files` folder within the book’s GitHub repository. It is worth noting that most
    Raspberry Pi cases do not account for the accommodation of HATs, making our Raspberry
    Pi/Sense HAT case an excellent accessory for this book. However, it is important
    to mention that the case is not mandatory to complete the exercises in this book.
    Furthermore, if we decide not to purchase a Sense HAT, we can still run the examples
    by utilizing the Sense HAT simulator available for the Raspberry Pi OS.
  prefs: []
  type: TYPE_NORMAL
- en: Before we start writing code, we’ll set up the development environment on our
    Raspberry Pi. Once our environment is ready, we’ll dive right into coding.
  prefs: []
  type: TYPE_NORMAL
- en: Let’s get started!
  prefs: []
  type: TYPE_NORMAL
- en: Setting up our development environment
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: In this section, we will go through the process of setting up Thonny for development
    with the Raspberry Pi and Sense HAT. Thonny is a beginner-friendly IDE that offers
    a user-friendly interface. With Thonny, we can easily write, test, and debug our
    code, allowing us to focus on the development process without unnecessary complexity.
  prefs: []
  type: TYPE_NORMAL
- en: 'We will use a Python virtual environment for our development. As there are
    libraries that only work with the root installation of Python, we will use system
    packages in our Python virtual environment. To do so, we do the following:'
  prefs: []
  type: TYPE_NORMAL
- en: 'On our Raspberry Pi 5, we open a Terminal application by clicking on the fourth
    icon on the top-left menu (*Figure 1**.15*):'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![Figure 1.15 – Opening the Terminal application (indicated by the red arrow)](img/B21282_01_15.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 1.15 – Opening the Terminal application (indicated by the red arrow)
  prefs: []
  type: TYPE_NORMAL
- en: 'To store our project files, we create a new directory with the following:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'We then navigate to the new directory with the following:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'We create a new Python virtual environment for our project with the following:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'With our new Python virtual environment created, we source into it with the
    following command:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '![Figure 1.16 – Terminal using ch1-env environment](img/B21282_01_16.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 1.16 – Terminal using ch1-env environment
  prefs: []
  type: TYPE_NORMAL
- en: 'For our project, we need the Sense HAT and the Sense HAT emulator libraries.
    The Sense HAT library is pre-installed in our Python virtual environment; however,
    the Sense HAT emulator requires manual installation via a Terminal command:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Installing the Sense HAT emulator library lets us run code with either the
    actual Sense HAT or the Sense HAT emulator. We can close the Terminal with a specific
    command:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'We are now ready to load up Thonny. We do so by clicking on the **Menu** icon
    in the Raspberry Pi taskbar, navigating to the **Programming** category, and selecting
    **Thonny** (*Figure 1**.17*):'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![Figure 1.17 – Thonny IDE interface](img/B21282_01_17.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 1.17 – Thonny IDE interface
  prefs: []
  type: TYPE_NORMAL
- en: By default, Thonny uses the Raspberry Pi’s built-in version of Python (red arrow
    in *Figure 1**.17*). For our project, we will use the Python virtual environment
    we just created. To start, we need to view the project files by clicking on **View**
    and selecting **Files** if it is not already selected (we may have to switch to
    regular mode first by clicking on the **Switch to regular mode** tab at the top-right
    side of the screen).
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: In the `ch1-env` directory.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'We then right-click on the folder and select the **Activate virtual** **environment**
    option:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![Figure 1.18 – Activating ch1-env virtual environment in Thonny](img/B21282_01_18.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 1.18 – Activating ch1-env virtual environment in Thonny
  prefs: []
  type: TYPE_NORMAL
- en: With our project folder created, our Python virtual environment set up and activated,
    and the Sense HAT emulator package installed, we may now start writing code.
  prefs: []
  type: TYPE_NORMAL
- en: Sense HAT development – reading sensor data
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The goal for our first project is to create a program that reads sensor information
    from the Sense HAT and displays it in the Thonny Shell. Before we can read sensory
    information, however, we must ensure that we have the Sense HAT properly connected
    to our Raspberry Pi.
  prefs: []
  type: TYPE_NORMAL
- en: 'To start, follow these steps:'
  prefs: []
  type: TYPE_NORMAL
- en: If not already running, we launch Thonny by clicking on the `ch1-env` virtual
    environment if not already activated.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'We then create a new tab by selecting **File** and then **New** or by hitting
    *Ctrl*+*N* on the keyboard:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![Figure 1.19 – Creating a new file in Thonny](img/B21282_01_19.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 1.19 – Creating a new file in Thonny
  prefs: []
  type: TYPE_NORMAL
- en: 'Inside the new tab, we enter the following code:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'For those of us using the Sense HAT simulator, we simply need to change the
    first line of code to the following:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'We save the code with a descriptive name such as `sensor-test.py`. Before we
    run the code, let’s break it down to understand it:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Our code starts by importing the `SenseHat` class from the `sense_hat` library.
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: An instance of the `SenseHat` class is created and assigned to the variable
    `sense_hat`.
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: The `get_temperature()` method is called on the `sense_hat` object to retrieve
    the temperature data and assigned to the `temp` variable.
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: The `get_humidity()` method is called on the `sense_hat` object to retrieve
    the humidity data and assigned to the `humidity` variable.
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: The `get_pressure()` method is called on the `sense_hat` object to retrieve
    the air pressure data and assigned to the `press` variable.
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: The `get_accelerometer_raw()` method is called on the `sense_hat` object to
    retrieve the raw accelerometer data, which includes values for the *x*, *y*, and
    *z* axes. The data is assigned to the `accel` variable.
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: The `get_gyroscope_raw()` method is called on the `sense_hat` object to retrieve
    the raw gyroscope data, which also includes values for the *x*, *y*, and *z* axes.
    The data is assigned to the `gyroscope` variable.
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: The obtained data is then printed out with appropriate formatting using the
    `print()` function and formatted string placeholders ``(`{:.2f}`)`` to display
    the values with two decimal places.
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: 'We run the code by either clicking on the green **Run** button, hitting *F5*
    on the keyboard, or clicking on the **Run** menu option at the top and then **Run**
    **current script**:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![Figure 1.20 – Running a program in Thonny](img/B21282_01_20.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 1.20 – Running a program in Thonny
  prefs: []
  type: TYPE_NORMAL
- en: 'After running the code, we should observe a message like the following in the
    Shell:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 1.21 – Results after running sensor-test.py](img/B21282_01_21.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 1.21 – Results after running sensor-test.py
  prefs: []
  type: TYPE_NORMAL
- en: For those of us using the Sense HAT emulator, the values displayed will be determined
    by the slider values set in the emulator.
  prefs: []
  type: TYPE_NORMAL
- en: Important notes
  prefs: []
  type: TYPE_NORMAL
- en: We can disregard the warning since the Sense HAT does not include a TCS34725
    color sensor. It is likely that the warning is caused by an internal issue in
    the Sense HAT Python library. Our code is not affected by this warning and can
    continue to run as intended.
  prefs: []
  type: TYPE_NORMAL
- en: It’s important to note that the temperature readings are influenced by the heat
    generated by the Raspberry Pi, resulting in higher values compared to the actual
    room temperature. The humidity readings are also affected. However, the accelerometer
    and gyroscope values accurately reflect the position and orientation of the Sense
    HAT and can be observed to change when the case is swiveled in different directions.
    To see updated values from the accelerometer and gyroscope, the code must be run
    again after swiveling the case.
  prefs: []
  type: TYPE_NORMAL
- en: Now that we have learned how to read sensory data from Sense HAT, let’s shift
    our focus to the dot matrix screen. In the next section, we will explore creating
    a simple animation using the dot matrix display.
  prefs: []
  type: TYPE_NORMAL
- en: Sense HAT development – creating animations
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: In this section, we will create an explosion animation using Sense HAT and the
    Raspberry Pi. We will use Thonny as our development environment to write and execute
    the code.
  prefs: []
  type: TYPE_NORMAL
- en: 'To start, follow these steps:'
  prefs: []
  type: TYPE_NORMAL
- en: If not already running, we launch Thonny by clicking on the `ch1-env` virtual
    environment if not already activated.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: We then create a new tab by selecting **File** and then **New** or by hitting
    *Ctrl* + *N* on the keyboard.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'We start our code by entering our imports:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: We import the `SenseHat` module from the `sense_hat` library, allowing us to
    interact with the Sense HAT board.
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: We also import the `time` module, which will be used for adding delays in our
    program.
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: 'We then set our variable declarations:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: We create an instance of the SenseHAT class called `sense_hat`, enabling us
    to access the Sense HAT’s functionality.
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: We define color values for red, orange, yellow, and black, which will be used
    to create our animation.
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: We create `frame1` as a list of color values, representing the desired image
    on the LED matrix.
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: We define `frame2` and `frame3` as additional frames.
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: We create a list called `frames`, which holds the defined frames in a specific
    order.
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: 'To have our animation run continuously, we set up an infinite loop:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Within the loop, we iterate through each frame in the `frames` list.
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: We set the pixels of the LED matrix to the current frame using `sense_hat.set_pixels(frame)`,
    displaying the corresponding image.
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: We introduce a brief pause of 0.5 seconds using `time.sleep(0.5)` to control
    the animation speed.
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: After displaying all frames, we clear the LED matrix using `sense_hat.clear()`,
    preparing for the next iteration.
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: We add a slight delay of 0.2 seconds using `time.sleep(0.2)` before starting
    the animation loop again, creating the explosion pattern.
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: 'For those of us using the Sense HAT simulator we simply need to change the
    first line of code to the following and open the Sense HAT simulator on our Raspberry
    Pi:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: We save the code with a descriptive name such as `animation-test.py`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'We run the code by clicking on the green **Run** button, hitting *F5* on the
    keyboard, or clicking on the **Run** menu option at the top and then **Run current
    script**. We should observe an explosion animation on our Sense HAT or in the
    Sense HAT emulator:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '![Figure 1.22 – Frame from explosion animation on the Sense HAT emulator](img/B21282_01_22.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 1.22 – Frame from explosion animation on the Sense HAT emulator
  prefs: []
  type: TYPE_NORMAL
- en: In this section, we explored creating animations with Sense HAT and Raspberry
    Pi. We learned how to write code that displays a sequence of frames on the LED
    matrix, resulting in an explosion animation. For our final programming project
    in this chapter, we will create a scrolling message on the Sense HAT’s dot matrix
    screen. This message will dynamically show temperature, humidity, and air pressure
    data, providing us with valuable environmental insights in a visually appealing
    way.
  prefs: []
  type: TYPE_NORMAL
- en: Sense HAT development – creating a scrolling environmental data display
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Building upon our previous projects, where we gained experience in reading sensory
    data from Sense HAT and creating animations on its LED matrix, we will now dive
    into the creation of a scrolling text application using the Sense HAT’s dot matrix
    display.
  prefs: []
  type: TYPE_NORMAL
- en: 'To start, follow these steps:'
  prefs: []
  type: TYPE_NORMAL
- en: If not already running, we launch Thonny by clicking on the `ch1-env` virtual
    environment if not already activated.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: We create a new tab by selecting **File** and then **New** or by hitting *Ctrl*
    + *N* on the keyboard.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'We start our code by importing the libraries we need:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: We import the `SenseHat` module from the `sense_hat` library, allowing us to
    interact with the Sense HAT board. For those of us using the Sense HAT emulator,
    we would use the `sense_emu` library instead.
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: We also import the `time` module, which will be used for adding delays in our
    program.
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: 'We then set our variable declarations in our code:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: We create an instance of the `SenseHAT` class we call `sense_hat`.
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: We set the scrolling speed of the messages on the LED matrix using the variable
    `speed`.
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: The line `sense_hat.set_rotation(270)` adjusts the orientation of the Sense
    HAT’s LED matrix so that it matches the orientation of the Raspberry Pi in the
    custom case.
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: We define two color variables, `red` and `green`, for the text color.
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: 'To have our scrolling message continuously play, we create an infinite loop:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'In the infinite loop, we do the following:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: We display the temperature reading on the LED matrix, formatted with one decimal
    place.
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: We display the humidity reading on the LED matrix, formatted with one decimal
    place.
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: We display the pressure reading on the LED matrix, formatted with one decimal
    place.
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: We pause for one second before the next iteration of the loop.
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: We save the code with a descriptive name such as `sensor-scroll.py`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: We run the code by clicking on the green **Run** button, hitting *F5* on the
    keyboard, or clicking on the **Run** menu option at the top and then **Run** **current
    script**.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: We should observe a scrolling message of sensory data displayed on the dot matrix
    screen of our Sense HAT (or Sense HAT emulator).
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: In this exercise, we created a scrolling text application on the Sense HAT,
    displaying real-time environmental data. This project enhanced our skills in data
    acquisition from sensors and visual presentation, using the Sense HAT’s LED matrix
    for effective data visualization. Completing this final chapter project, we’re
    now equipped to tackle more advanced IoT applications with the Sense HAT and Raspberry
    Pi.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we began our journey into the world of IoT projects with the
    Raspberry Pi. We explored the various Raspberry Pi models, their distinct characteristics,
    and their significance in IoT development. We took a brief look at the alternatives
    to the Raspberry Pi for IoT applications and explored Raspberry Pi HATs, such
    as the Pibrella HAT and the Raspberry Pi Sense HAT.
  prefs: []
  type: TYPE_NORMAL
- en: Additionally, we looked at operating systems compatible with the Raspberry Pi,
    outside of the official Raspberry Pi OS. We highlighted the versatility and power
    of the Raspberry Pi in IoT applications, emphasizing its ability to process real-time
    data and control physical devices. The chapter also introduced the Raspberry Pi
    as a robust development platform, equipped with pre-installed tools for software
    development.
  prefs: []
  type: TYPE_NORMAL
- en: At the end of the chapter, we engaged in practical programming projects that
    utilized Sense HAT and explored its potential in IoT applications. These projects
    included a scrolling environmental data display, providing hands-on experience
    in extracting sensory information, and creating dynamic visual displays.
  prefs: []
  type: TYPE_NORMAL
- en: This chapter equipped us with the knowledge we may use to make informed choices
    when developing IoT projects. Understanding the strengths of different Raspberry
    Pi models and alternatives prepares us to choose the right device for specific
    applications. Familiarity with Raspberry Pi HATs and various operating systems
    expands our toolkit. In this chapter, we unlocked the potential of the Raspberry
    Pi by understanding its data and control capabilities. Our Sense HAT practice
    prepared us for more complex projects in the future.
  prefs: []
  type: TYPE_NORMAL
- en: Looking ahead, in the next chapter, we will harness the power of web services
    as we continue to build more sophisticated IoT applications.
  prefs: []
  type: TYPE_NORMAL
