- en: Robot Control and Simulation
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, you will set up your ROS development environment specifically
    for programming GoPiGo3. This understanding is going to be built by going from
    using the keys of your laptop keyboard to the more technical way of using ROS
    topics. Finally, you will guess what topics will allow you to wire manual keyboard/topic-based
    control to internal programming logic (that is, smart behavior) that will make
    the robot capable of executing autonomous tasks. In this sense, 3D simulation
    in Gazebo is an essential tool for testing behavior during development before
    pushing the app to the physical robot, saving time and effort when it comes to
    field-based work.
  prefs: []
  type: TYPE_NORMAL
- en: By the end of this chapter, you will have learned how to set up the ROS environment
    for a real robot. Remote control and autonomous control establish a qualitative
    difference in terms of robot software development. By experimenting with remote
    control by yourself, you will be ready to cross the frontier of what makes a robot
    really autonomous.
  prefs: []
  type: TYPE_NORMAL
- en: Finally, you will understand the usefulness of using simulation during the development
    of robotic applications by establishing a comparison with how the physical robot
    behaves. These observed differences will allow you to adjust the parameters of
    the virtual robot's simulation in Gazebo. The main advantage of this approach
    is that you can keep on developing and testing the software with the virtual model
    and then only test with the real hardware in the final development stage.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following topics will be covered in this chapter:'
  prefs: []
  type: TYPE_NORMAL
- en: Setting up the GoPiGo3 development environment and making it capable of networking
    with ROS on a laptop
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Case study 3 – remotely controlling the physical robot using the keyboard
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Remotely controlling robots using ROS topics from the command line
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Comparing the behavior of both of the physical robot and the virtual model in
    Gazebo under manual remote control
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'We will provide explanations of these concepts based on our third case study
    regarding robot drives (motors and encoders). Remember that the first two case
    studies were covered in [Chapter 6](0b20bdff-f1dc-42e8-ae83-fc290da31381.xhtml),
    *Programming in ROS – Commands and Tools*, and were as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Case study 1**: Publishing and reading the distance sensor'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Case study 2**: Acquiring and visualizing images from the Pi camera'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: By the end of this chapter, we will have our first complete version of the ROS
    package of GoPiGo3\. This will be the basis that our smart robot behaviors will
    be built upon in the rest of this book.
  prefs: []
  type: TYPE_NORMAL
- en: Technical requirements
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'For this chapter, no additional hardware or software configuration will be
    needed. Just make sure that you have the following:'
  prefs: []
  type: TYPE_NORMAL
- en: GoPiGo3, as per the *Technical requirements* section of [Chapter 6](0b20bdff-f1dc-42e8-ae83-fc290da31381.xhtml), *Programming
    in ROS – Commands and Tools*
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A laptop, as per the *Configure your ROS Development Environment* section of
    [Chapter 3](f3ecc0de-28c4-4140-9a9c-ed351c68d121.xhtml), *Getting Started with
    ROS*
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'In the next section, we will prepare the ROS environment so that your laptop
    and the robot can communicate with each other under a unique ROS graph. Let''s
    go over the code we''ll need:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Code for this chapter (laptop)**: In this chapter, we will make use of the
    code located in the `Chapter7_Robot_control_simulation` folder ([https://github.com/PacktPublishing/Hands-On-ROS-for-Robotics-Programming/tree/master/Chapter7_Robot_control_simulation](https://github.com/PacktPublishing/Hands-On-ROS-for-Robotics-Programming/tree/master/Chapter7_Robot_control_simulation)).
    Copy its files to the ROS workspace so that they''re available to you and leave
    the rest outside the `src` folder. This way, you will have a cleaner ROS environment:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'The code contains a new ROS package named `gazebo_control`. Rebuild the workspace
    so that it is known to your ROS installation:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: 'Check that the package has been correctly installed by selecting it and listing
    the files:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: '**Code for this chapter (GoPiGo3)**: You will be using the same code that we
    developed in [Chapter 6](0b20bdff-f1dc-42e8-ae83-fc290da31381.xhtml), *Programming
    in ROS – Commands and Tools*. Remember that it corresponds to the ROS package
    called `mygopigo` that''s located in the Raspberry Pi.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Now, you are ready to follow the explanations in this chapter and understand
    them in a practical way.
  prefs: []
  type: TYPE_NORMAL
- en: Setting up the GoPiGo3 development environment
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In the previous chapter, you tried the ROS desktop version in the Raspberry
    Pi of GoPiGo3\. For a serious development strategy, you should launch the minimum
    configuration of the application in the robot and launch all the accompanying
    development tasks within the laptop.
  prefs: []
  type: TYPE_NORMAL
- en: Remember that in [Chapter 3](f3ecc0de-28c4-4140-9a9c-ed351c68d121.xhtml), *Getting
    Started with ROS*, you run ROS on your laptop. Hence, the robot application itself
    was executed in such an environment, with no possibility to move a physical robot
    since we didn't establish a connection outside of the computer.
  prefs: []
  type: TYPE_NORMAL
- en: In this section, you will learn how to work simultaneously with the laptop and
    Raspberry Pi ROS environments when they're linked, that is, the Raspberry Pi controlling
    the GoPiGo3 robot and the laptop for CPU-intensive computing/visualization tasks.
  prefs: []
  type: TYPE_NORMAL
- en: ROS networking between the robot and the remote computer
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'To make two ROS environments, there are two prior conditions we need to meet:'
  prefs: []
  type: TYPE_NORMAL
- en: The robot and computer ROS environments need to know how to communicate with
    each other.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The master node (`roscore` process) should be unique and run in either.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Let's learn how to accomplish both conditions.
  prefs: []
  type: TYPE_NORMAL
- en: Communication between ROS environments
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The way that a computer is identified in a network is by means of its IP address,
    normally using the IPv4 protocol. In general, you can find the IP that''s been
    assigned to your machine with the `ifconfig` command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: You should focus on the wireless interface, typically named `wlan0`, since you
    configured your robot for Wi-Fi access. The IP address is the 4 x 4 bytes field
    following the word `inet`. So, for the Raspberry Pi in GoPiGo3, this field is
    `192.168.1.58`.
  prefs: []
  type: TYPE_NORMAL
- en: 'Do the same for the laptop, opening in it a Terminal. If you are using a wired
    connection, you should look at `eth0` instead of `wlan0`. For our example case,
    the computer''s IP is `192.168.1.54`. If there were too many network interfaces,
    the output could be too verbose. To focus on what you are looking for, you can
    filter the output, like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: Once you have both IP addresses, you just have to indicate them using ROS environment
    variables. In the following subsections, we will show you how to configure each
    of the computers.
  prefs: []
  type: TYPE_NORMAL
- en: Robot network configuration
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Next, you have to follow three steps to set up the Raspberry Pi:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Execute the following two commands in a Terminal to define the environment
    variables needed by ROS:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: The first command sets the variable that allows ROS to know the IP of the host where
    it is currently running. The second line is the URL of the master node. Since it
    is set to `ROS_HOSTNAME`, we are saying that it will run on the robot computer.
    Port `11311` is the default that's set by ROS to communicate with the master node.
    Each subsequently launched node will be automatically assigned a new available
    port.
  prefs: []
  type: TYPE_NORMAL
- en: 'There is a way to abstract the IP number itself because, in Ubuntu systems, `avahi-daemon` ([http://manpages.ubuntu.com/manpages/bionic/man8/avahi-daemon.8.html](http://manpages.ubuntu.com/manpages/bionic/man8/avahi-daemon.8.html))
    allows you to point to a machine in the local network by simply appending `.local`
    to its hostname. For this, the configuration command will be as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: 'The hostname can be found in the prompt of the Terminal and is usually in the
    format `user@hostname :~$`. If you have any doubts, you can ask for it in the
    Terminal by using `hostname` command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: 'Each new Terminal you launch will need this configuration. So, if we include
    it as additional lines in the `.bashrc` file, you won''t have to care about doing
    this by hand:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: 'Check the result by listing the end of the file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: You should see the cited two configuration lines.
  prefs: []
  type: TYPE_NORMAL
- en: Now that the Raspberry Pi has been configured, we will do something similar
    for the laptop.
  prefs: []
  type: TYPE_NORMAL
- en: Laptop network configuration
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'For the remote computer, these are the equivalent steps:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Execute the following two commands in a Terminal to set the environment variables:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: You specify its IP address as `192.168.1.54` in the first line, while in the
    second, we are stating that the ROS master is located in the robot, that is, `gopigo3.local`.
    This way, your system won't need to be reconfigured if the network is restarted
    and a different IP address is assigned to the Raspberry Pi.
  prefs: []
  type: TYPE_NORMAL
- en: 'As for the robot, add the following two lines to the `.bashrc` file to automate
    the configuration each time a new Terminal is launched:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: We are also showing the alternative for setting `ROS_HOSTNAME`, that is, using `rosbot.local`
    instead of the numeric IP address.
  prefs: []
  type: TYPE_NORMAL
- en: Launching the master node and connecting
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The following procedure allows us to establish a connection between the laptop
    and the Raspberry Pi:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Launch the ROS master node in the robot by using the already familiar `roscore`
    command:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: 'Then, perform a basic check in the laptop to find out if it is aware of the
    master node''s existence:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: '`/rosout_agg` and `/rosout_agg` are the topics that are published by the master
    node.'
  prefs: []
  type: TYPE_NORMAL
- en: If everything has gone well, you can remotely control your GoPiGo3\. Close the
    Terminal before moving on to the next section to make sure `roscore` is off.
  prefs: []
  type: TYPE_NORMAL
- en: Case study 3 – remote control using the keyboard
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: This case study will help you complete the first version of the GoPiGo3 ROS
    package. In the previous chapter, you were dealing with the distance sensor and
    the Pi camera, and we devoted one case study to each of them.
  prefs: []
  type: TYPE_NORMAL
- en: 'By including the motion functionality with the present robot drives, you will
    have a robot that is able to perform basic interactions with its environment:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Perception capabilities** include detecting obstacles with the distance sensor
    and visual recognition of the surroundings with the Pi camera.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Actuation capability**, where the robot is able to move on the floor while
    being aware of the possible obstacles with the distance sensor and recognizing
    shapes and people with the image feed from its camera.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Case study 3 focuses on actuation capability. In this section, you will learn
    how to remotely move the robot using a keyboard and a mouse.
  prefs: []
  type: TYPE_NORMAL
- en: Running the gopigo3 node in the robot
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In this section, we are going to run a node in the Raspberry Pi that will provide
    the control capability:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Launch the GoPiGo3 ROS package in the robot:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: This is the only command you need to run directly in the Raspberry Pi. Since
    you configured ROS so that the laptop can talk to the robot, the following commands
    can be run on the laptop.
  prefs: []
  type: TYPE_NORMAL
- en: When preceding a bash command with `T1`, `T2`, `T3`, or `T4`, we will always
    be referring to consecutive Terminals on the laptop.
  prefs: []
  type: TYPE_NORMAL
- en: '2\. Then, on your laptop, ensure that you have a single node, that is, `gopigo3`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: Remember that the `/rosout` topic corresponds to the master node.
  prefs: []
  type: TYPE_NORMAL
- en: '3\. Next, list all the available ROS topics to find out what their names are:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: Bear in mind that the three topics of interest are called `/battery_voltage`,
    `/cmd_vel`, and `/motor/status`. We will provide details about them later in this
    section.
  prefs: []
  type: TYPE_NORMAL
- en: '4\. To get additional information about these topics, you can use the `info`
    option of the `rosnode` command. This will tell you what the `gopigo3` node can
    do:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: 'Here, you can see that `/battery_voltage` and **`/motor/status` **are publishers (objects
    in the code of the node that stream data to such topics), while `/cmd_vel` is
    a subscriber (as well as an object that''s declared in the node that allows us
    to consume data from an existing topic):'
  prefs: []
  type: TYPE_NORMAL
- en: The publishers allow you to get status information from the battery level and
    the motors, respectively.
  prefs:
  - PREF_UL
  - PREF_UL
  type: TYPE_NORMAL
- en: The `/cmd_vel` subscriber allows the robot to accept motion commands for remote
    control.
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: In the next subsection, we will inspect the publishers in order to understand
    the structure of the messages they stream.
  prefs: []
  type: TYPE_NORMAL
- en: Inspecting published topics and messages
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Now that we''ve identified the three topics, let''s take a look at them and
    get some robot-specific information:'
  prefs: []
  type: TYPE_NORMAL
- en: 'To find the last five values of the battery, run the following command in a
    Terminal. This will allow you to inspect the `/battery_voltage` topic:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: You can infer that the voltage is about 9.6V on average, which means the batteries
    are charged.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s investigate how this topic is built:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: 'It uses the `std_msgs/Float64` message type, which corresponds to a floating-point
    number that''s 64 bits size. This message type is part of the ROS standard message
    library ([http://wiki.ros.org/std_msgs](http://wiki.ros.org/std_msgs)). To find
    out what a ROS message is made up of, you can use the `rosmsg` command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: 'There is another topic in this node, `/motor/status`, that makes use of a custom
    and more complex message:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: 'Let''s find the structure of the message. Note that the definition of the message
    is declared within the `mygopigo` package under the `msg` folder:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: 'There are three parts to this:'
  prefs: []
  type: TYPE_NORMAL
- en: A header with the sequence number and the timestamp
  prefs:
  - PREF_UL
  - PREF_UL
  type: TYPE_NORMAL
- en: Data from the left motor
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: Data from the right motor
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: 'If we take the content of the last published message, we can visualize this
    structure in practice:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: Here, you can see that the topic reports the `low_voltage` level warning, the
    motor `overload` warning, `power`, `encoder` data, and the current `speed`.
  prefs: []
  type: TYPE_NORMAL
- en: Now, let's proceed to the practical part of moving the robot.
  prefs: []
  type: TYPE_NORMAL
- en: Teleoperation package
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '`key_teleop` ([http://wiki.ros.org/key_teleop](http://wiki.ros.org/key_teleop))
    is a ROS-contributed package that provides a very simple mechanism for controlling
    a robot using the arrow keys of the keyboard. Clone the source code and install
    the package on your laptop as usual:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: 'Another two packages are available here that are also part of the `teleop_tools` bundle:'
  prefs: []
  type: TYPE_NORMAL
- en: '`joy_teleop`, a generic joystick interface for topics and actions'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`mouse_teleop`, a pointing device (for example, mouse, touchpad, and so on)
    teleoperation utility'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Since you have built the whole repository, both of these are available to you.
  prefs: []
  type: TYPE_NORMAL
- en: Running teleoperation on a laptop
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Since you''ve completed the *Running gopigo3 node in the robot* subsection,
    you should have the `gopigo3` node running as a result of the `$ roslaunch mygopigo
    gopigo3.launch` command. Let''s learn how to achieve remote control of it:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Launch the teleoperation node on your laptop:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: 'The preceding command launches the `key_teleop` node, and the Terminal''s prompt
    is substituted by an interface that looks similar to the one shown in the following
    screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/e17ef85c-6ac9-4447-9bfd-65b622b02626.png)'
  prefs: []
  type: TYPE_IMG
- en: 'This gray window tells you how to move the robot using the arrow keys of the
    keyboard:'
  prefs: []
  type: TYPE_NORMAL
- en: The up arrow key moves the robot forward at 0.8 m/s. You can see the commanded
    speed in the interface.
  prefs:
  - PREF_UL
  - PREF_UL
  type: TYPE_NORMAL
- en: The down arrow key moves the robot backward at -0.5 m/s (the minus sign means
    backward).
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: The left arrow key rotates the robot counter-clockwise (left) at 1 rad/s.
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: The right arrow key rotates the robot clockwise at -1 rad/s  (the minus sign
    means rotation to the right).
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: So that you can effectively move it, be aware that the Terminal that you launched
    the `key_teleop` node from has to be the active window. If that's not the case,
    just click anywhere on it to make it the active one.
  prefs: []
  type: TYPE_NORMAL
- en: 'With the `T2` command, we can visualize the ROS graph as usual:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: 'It should look as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/1cfb3f28-184f-4f78-86fc-edb683002ae1.png)'
  prefs: []
  type: TYPE_IMG
- en: The`  T1` command that was appended after the executable script of the node
    with the `/key_vel:=/cmd_vel`assignment is what we call remapping. This technique
    allows two nodes to communicate, where the literal of the subscriber of the listener
    node, `/cmd_vel`, does not match the literal of the publisher node, `/key_vel`.
    Hence, remapping consists of wiring the published topic of one node to the subscribed
    topic of another node. This way, we know that the output from the `key_teleop` node
    is going to be the input of the `gopigo3` node.
  prefs: []
  type: TYPE_NORMAL
- en: Now, let's learn how to teleoperate the robot with the mouse instead of the
    keyboard.
  prefs: []
  type: TYPE_NORMAL
- en: Teleoperation with the mouse
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'This procedure is equivalent to that of the keyboard:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Write the following command in a third Terminal to apply the `mouse_teleop`
    package from the `teleop_tools` bundle:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: In this case, the remapping topic is `/mouse_vel:=/cmd_vel`.
  prefs: []
  type: TYPE_NORMAL
- en: 'Refresh the `rqt_graph` window; you will see the following:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/28ea3127-edeb-430e-b1b9-bdcff048da1f.png)'
  prefs: []
  type: TYPE_IMG
- en: The preceding graph suggests that the robot simultaneously accepts commands
    from the mouse and the keyboard without any trouble. This happens if we don't
    kill the keyboard control in the `T1` Terminal before launching the mouse control
    command.
  prefs: []
  type: TYPE_NORMAL
- en: On the other hand, if you kill the `T1` terminal, the robot will keep on working,
    but then you will only control it with the mouse since the process in `T3` keeps
    it live (the `key_teleop` node will disappear from `rqt_graph` if we refresh the
    window).
  prefs: []
  type: TYPE_NORMAL
- en: 'Finally, check if the mouse control works (restart the `T1` command if you
    killed it previously):'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Select the window of `T1`. You will move GoPiGo3 with the arrow keys.
  prefs:
  - PREF_UL
  - PREF_UL
  type: TYPE_NORMAL
- en: Select the new window that appeared by implementing the `T3` command. Now, you
    can move GoPiGo3 with the mouse (while the left button is being held down).
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The following is the new window that appears for controlling the mouse:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/1271a71c-ab5a-4efc-b57d-5315162bd5ac.png)'
  prefs: []
  type: TYPE_IMG
- en: The blue line represents the forward (positive speed)-backward directions. In
    this case, it moves at -0.3 m/s (backward). The longer the line, the greater the
    speed. The red circular sector represents the same but for the rotation. It is
    positive when rotating left (counter-clockwise), at 15.08 degrees/second in this
    case.
  prefs: []
  type: TYPE_NORMAL
- en: 'This example illustrates two important concepts of ROS:'
  prefs: []
  type: TYPE_NORMAL
- en: '**The concurrency of messages**: If there two or more nodes that publish to
    a topic that is mapped to the subscriber of another node, this node will accept
    the messages from both and will try to execute all of them. This is a nice feature
    that you will exploit when working with ROS at an advanced level.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**The resilience of the runtime enviroment**: The robot can work with partial
    functionality. It will only lose the functionality provided by the ROS nodes that
    die.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'At this point, it is important that you think of how ROS provides a high-level
    layer for programming robots compared to the usage of procedural languages such
    as C or Python. Furthermore, this also means that you will focus more on the robot''s
    functionality and less on programming the code: you will integrate existing packages
    that provide the low-level layer (control commands from a keyboard or mouse, for
    example) and relate them via ROS topics to build the high-level layer (motion
    control of the robot with the keyboard and/or mouse).'
  prefs: []
  type: TYPE_NORMAL
- en: Remote control using ROS topics
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In the previous section, you controlled the robot's publishing messages in the
    `/cmd_vel` topic using a human interface, the keyboard and the mouse. In this
    section, you will publish the messages directly using `rostopic` from the command
    line. This way, you will become familiar with this relevant topic and the structure
    of its messages. It is crucial to understand how `/cmd_vel` works under the hood
    since you will be using it in many of the advanced examples we'll be covering
    in the remaining chapters of this book.
  prefs: []
  type: TYPE_NORMAL
- en: The motion control topic – /cmd_vel
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Now that we''ve enjoyed playing with the robot, let''s understand how this
    form of control works. The `/cmd_vel` topic that the gopigo3 node is subscribed
    to is the key to producing translations and rotations of the robot. Run the `rostopic`
    command while having the `gopigo3` node running in the robot to retrieve the information
    from the topic:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: 'The topic `/cmd_vel` uses the `geometry_msgs/Twist` type (64 bits) of the `geometry_msgs`
    message library ([http://wiki.ros.org/geometry_msgs](http://wiki.ros.org/geometry_msgs)).
    This library provides messages for working with geometric primitives: points,
    vectors, and poses. The command is also telling you which nodes are subscribed
    to the topic, which is only `gopigo3` in our case. Now, let''s retrieve the structure
    of the message type:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: Here, we can see that it is composed of six 64-bit float numbers that will allow
    you to treat it as two vectors of three components each. The first three components
    form the linear vector and refer to the speed along the *X*, *Y*, and *Z* axes,
    while the remaining three form the rotation vector, expressing the angular speed
    about each of those axes. Let's see how this works in practice.
  prefs: []
  type: TYPE_NORMAL
- en: Using /cmd_vel to directly drive GoPiGo3
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Previously, we focused on the end user''s perspective of controlling the robot,
    that is, keyboard strokes or mouse clicks and displacement. Now, we are going
    to discover how to achieve the same kind of control from the developer''s perspective,
    which is the one you need to build new applications in ROS. Let''s get started:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Rotate the robot at a 1 rad/s rate by publishing a message from the command
    line. Remember that the `gopigo3` node must be running in the robot:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: As soon as you enter the command, apart from seeing GoPiGo3 rotating left (counter-clockwise),
    you will receive the accompanying information message about the command.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Since you did not specify a publishing frequency, ROS assumes that you want
    to keep that message latched, that is, running forever. Check this by using `rostopic`
    in another Terminal:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: 'How can we stop the robot? Easy – send a new message with the rotation set
    to zero:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: You will see that GoPiGo3 stops and that `T2` throws a new set of six values,
    informing us that angular `z` is now equal to `0`.
  prefs: []
  type: TYPE_NORMAL
- en: 'The next step is to introduce a message update at a given rate. Stop the process
    in `T1` and write the following command:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: In `T2`, you should see a new message every 2 seconds (= 0.5 Hz frequency).
    The `-r` option (initial of rate) is the one you use to specify how often you
    want the message to be sent. Since you are keeping the same rotation speed, you
    won't appreciate any changes in the robot motion.
  prefs: []
  type: TYPE_NORMAL
- en: 'Go to another Terminal and publish a double speed (2 rad/s) in the `/cmd_vel`
    topic at the same frequency of 0.5 Hz:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs: []
  type: TYPE_PRE
- en: You will see GoPiGo3 alternating between angular speeds of 1 and 2 rad/s at
    the specified rate.
  prefs: []
  type: TYPE_NORMAL
- en: 'Go to `T4` and send a stop rotation command:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs: []
  type: TYPE_PRE
- en: Observe how the robot stops for a while every 2 seconds.
  prefs: []
  type: TYPE_NORMAL
- en: 'What if you want the robot to stop more often? Stop the process in `T4` and
    relaunch the command with a higher rate of 1 Hz:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs: []
  type: TYPE_PRE
- en: How do we make it stop for longer? Easy – specify a higher frequency, that is,
    10 Hz. When using such a value, you will find that GoPiGo3 rotates very little,
    since 10 times every second, it receives a stop command, superseding the most
    recent effect of the speeds set in `T1` (1 rad/s) and `T3` (2 rad/s).
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Finally, how do we stop everything? Follow these steps:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Stop Terminal `T1`. This avoids new messages from being sent by setting the
    speed at 1 rad/s.
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: Stop Terminal `T3`. This cancels the speed commands of 2 rad/s. At this point,
    the robot only receives zero speed commands from the last Terminal. The robot
    has stopped, but ROS is still running some processes, although they're not visible
    as robot motions.
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: Stop Terminal `T4`. This makes sure that the gopigo3 node is now idle from any
    message that's published in the `/cmd_vel` topic.
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: You should check how `T2` (using the`$ rostopic echo /cmd_vel` command) stops
    providing updates. You can also kill this Terminal.
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: Try to think about what would happen if the first action you had made were to
    stop `T4`. Check this by applying the sequence to the physical robot and see what
    result you get.
  prefs: []
  type: TYPE_NORMAL
- en: In the next section, you will publish `geometry_msgs/Twist` messages in the`/cmd_vel` topic
    to find about what the actual *X*, *Y*, and *Z* axes of your robot are.
  prefs: []
  type: TYPE_NORMAL
- en: Checking the X, Y, and Z axes of GoPiGo3
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Now, you will apply what you have learned to practically find the *X*, *Y*,
    and *Z* axes of your robot and their positive and negative direction. Apply the
    following command in `T1` and make sure you''re ready with `T2` to stop it afterward
    to avoid the robot crashing into any obstacles:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE37]'
  prefs: []
  type: TYPE_PRE
- en: 'You should see GoPiGo3 advancing forward, that is, the distance sensor facing
    forward while the caster wheel is facing back. For the negative *X* axis, change
    the sign of the linear speed:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE38]'
  prefs: []
  type: TYPE_PRE
- en: You should find that GoPiGo is now advancing backward, that is, the distance
    sensor is facing backward. To guess the direction of the remaining axis, *Y*,
    remember that, in the previous subsection, you checked that the rotation around
    the *Z* axis is positive when the robot rotates left (counter-clockwise). This
    means that the *Z* axis points up, to the ceiling. Since you have empirically
    found the orientation of the *X* and *Z* axes, you can easily infer that the Y
    axis points left.
  prefs: []
  type: TYPE_NORMAL
- en: Why haven't we checked the *Z* axis with **rostopic pub**? You have a robot
    moving on a plane, that is, the floor. If you tried to apply a linear speed command
    for the *Z* axis, you will see nothing, because... well, GoPiGo3 cannot fly!
  prefs: []
  type: TYPE_NORMAL
- en: It is left to you to deduce why a similar linear speed command for the *Y* axis
    will have no visible effect on GoPiGo3's motion.
  prefs: []
  type: TYPE_NORMAL
- en: Composing motions
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We have already learned how to find the actual X, Y, and Z axes of the robot.
    Go back to [Chapter 4](742e6846-70e4-4bd4-8576-f3e4f445df3f.xhtml), *Creating
    the Virtual Two-Wheeled ROS Robot*, the *Building a differential drive robot with
    URDF* section, if you need to remember how.
  prefs: []
  type: TYPE_NORMAL
- en: 'Keeping their orientations in mind, let''s design a more complex trajectory
    by combining both translation (linear *X*) and rotation (angular *Z*). The goal
    is to get GoPiGo3 to follow a circumferential path that has a 0.25 m radius at
    a speed of 45º/s:'
  prefs: []
  type: TYPE_NORMAL
- en: The angular *Z* speed is 45º/s = 0.785 rad/s. We just need to change units from
    sexagesimal degrees to radians.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The linear *X* speed can be obtained by multiplying the requested radius by
    the angular speed; that is, *0.25 m * 0.785 rad/s = 0.196 m*.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Follows these steps to do so:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Apply these two values in a single `/cmd_vel` message:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE39]'
  prefs: []
  type: TYPE_PRE
- en: 'To stop this process, you can send a message where all six components are equal
    to zero:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE40]'
  prefs: []
  type: TYPE_PRE
- en: This is an alternative `geometry_msgs/Twist` message syntax, in which you specify
    a three-component vector for linear speed (following the order *X*, *Y*, *Z*)
    and another vector with the three components of the angular speed (also in the
    order *X*, *Y*, *Z*).
  prefs: []
  type: TYPE_NORMAL
- en: 'Finally, check how the superposition principle applies to motion composition
    by sending separate commands for the translation and rotation:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE41]'
  prefs: []
  type: TYPE_PRE
- en: The command in `T1` makes GoPiGo3 move forward at 0.196 m/s. Then, the command
    in `T2` adds an angular motion of 0.785 rad/s, thereby producing the trajectory
    for GoPiGo3 to evolve from a straight line to a circumference of 0.25 m radius,
    as expected.
  prefs: []
  type: TYPE_NORMAL
- en: Stop the robot and shut down the Raspberry Pi. In the next section, we'll switch
    to the Gazebo simulation environment, so we will only need the laptop. We will
    return to the virtual model of GoPiGo3 at the point we left it in [Chapter 5](74284adc-e0d7-4e40-a54b-e2e447b8e2fe.xhtml),
    *Simulating the Robot Behavior with Gazebo*.
  prefs: []
  type: TYPE_NORMAL
- en: Remotely controlling both physical and virtual robots
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Up to this point, you have dealt with a piece of configuration where the ROS
    master node ran in the robot. For the rest of this chapter, you will only be working
    with the laptop. Due to this, you need to revert your configuration so that the
    master node can be located again on the desktop computer. Otherwise, you will
    receive an error and won't be able to launch any ROS environment.
  prefs: []
  type: TYPE_NORMAL
- en: Reverting the ROS master to the local computer
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The solution to this is pretty simple; just follow these steps:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Open your local `.bashrc` file and comment the line at the end that specifies
    what URL to point to in order to find the ROS master:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE42]'
  prefs: []
  type: TYPE_PRE
- en: Be aware that, in place of `rosbot.local`, you should have your current hostname, `<your-hostname>.local`.
    Simply run `$ hostname` in a Terminal to recall it if you are in doubt and it
    hasn't been set correctly in your configuration file.
  prefs: []
  type: TYPE_NORMAL
- en: 'Close all the Terminals, open a new one, and check the `ROS_MASTER_URI` variable:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE43]'
  prefs: []
  type: TYPE_PRE
- en: You should find that the environment variable has reverted to the default server
    (localhost) and default port (`11311`). Now, we are ready to switch to the virtual
    robot.
  prefs: []
  type: TYPE_NORMAL
- en: Simulating GoPiGo3 with Gazebo
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Recall the Gazebo simulation we performed in [Chapter 5](74284adc-e0d7-4e40-a54b-e2e447b8e2fe.xhtml),
    *Simulating the Robot Behavior with Gazebo*, in the *Launching the GoPiGo model
    in Gazebo* section. Its files have been included in the sample code for this chapter
    so that we can use them as a starting point. Now, follow these steps:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Launch the Gazebo environment with the GoPiGo3 model:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE44]'
  prefs: []
  type: TYPE_PRE
- en: Although you may find that the launch filename is different from what it was
    in the code of [Chapter 5](74284adc-e0d7-4e40-a54b-e2e447b8e2fe.xhtml), *Simulating
    the Robot Behavior with Gazebo*, its content is exactly the same, that is, `gopigo_gazebo.launch`.
  prefs: []
  type: TYPE_NORMAL
- en: 'Then, in another Terminal, list the relevant topics:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE45]'
  prefs: []
  type: TYPE_PRE
- en: All the new ones correspond to Gazebo nodes.
  prefs: []
  type: TYPE_NORMAL
- en: 'In particular, the `/clock` topic is where Gazebo publishes timestamps, thus
    allowing for a system with simulation-synchronized time. The parameter definition
    within the `spawn.launch` file for `/clock` is as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE46]'
  prefs: []
  type: TYPE_PRE
- en: 'The `use_sim_time` parameter asks ROS to simulate a clock whose timestamps
    are published on `/clock`. You can inspect the topic and its message type as usual:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE47]'
  prefs: []
  type: TYPE_PRE
- en: The clock message type belongs to the `rosgraph_msgs` package. Take a look at
    the following link to find out more about this package: [http://wiki.ros.org/rosgraph_msgs](http://wiki.ros.org/rosgraph_msgs).
  prefs: []
  type: TYPE_NORMAL
- en: Now that we've set up the environment, we can add a virtual controller that
    will allow us to control GoPiGo3 inside Gazebo in the same way we did before with
    the physical robot.
  prefs: []
  type: TYPE_NORMAL
- en: Adding the controller to the Gazebo model of the robot
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Here, we are going to use a mechanism called **controller** to transform speed
    `/cmd_vel` messages into motions for the left and right wheels of the robot. For
    the case of a two-wheeled robot, this is known as a **differential drive controller**.
    This name is due to the fact that straight paths are achieved by rotating the
    wheels at the same speed. Any difference between the left and right angular speeds
    will make the robot describe a circumferential path. The larger the difference,
    the lower the radius of such a circumference (a straight path corresponds to describing
    a sector of a circumference of infinite radius, that is, the infinitesimal speed
    difference between wheels).
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s get to the practical part:'
  prefs: []
  type: TYPE_NORMAL
- en: 'To include the differential drive controller in your model of the robot, add
    the following snippet inside the `<robot>` tag of the `urdf/gopigo.gazebo` file:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE48]'
  prefs: []
  type: TYPE_PRE
- en: 'You must set these correspondences, as defined in the URDF model of your robot:'
  prefs: []
  type: TYPE_NORMAL
- en: '`<robotBaseFrame>` to `base_link`'
  prefs:
  - PREF_UL
  - PREF_UL
  type: TYPE_NORMAL
- en: '`<leftJoint>` to `joint_left_wheel`'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '`<rightJoint>` to `joint_right_wheel`'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: The `<torque>` tag is where you specify the maximum torque each can exert. This
    is all you need to know to carry out the experiment we suggested in [Chapter 5](74284adc-e0d7-4e40-a54b-e2e447b8e2fe.xhtml),
    *Simulating the Robot Behavior with Gazebo, *in the last section, entitled *Guidelines
    for tuning the Gazebo model*.
  prefs: []
  type: TYPE_NORMAL
- en: 'Notice how you tell the controller what topics it will receive the motion commands
    in by setting the `<commandTopic>` tag to the ROS `/cmd_vel` topic:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE49]'
  prefs: []
  type: TYPE_PRE
- en: 'Then, stop and relaunch Gazebo to find the new features that the differential
    drive provides to the simulation:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE50]'
  prefs: []
  type: TYPE_PRE
- en: 'There are two new topics, `/cmd_vel` and `/tf`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE51]'
  prefs: []
  type: TYPE_PRE
- en: 'Remember from the previous section that we controlled the physical GoPiGo3
    with the `/cmd_vel` topic. Following the same steps, you can teleoperate the virtual
    robot with the keyboard (arrow keys):'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE52]'
  prefs: []
  type: TYPE_PRE
- en: Make sure you are on the window where you launched `T2` so that any keystrokes
    are caught and you can see the effect they have on the robot in Gazebo.
  prefs: []
  type: TYPE_NORMAL
- en: 'Visualize the ROS graph with `T3 $ rqt_graph`. You should obtain the result
    shown in the following diagram:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/bca82557-588a-49bf-aa55-e7bf67e66a6e.png)'
  prefs: []
  type: TYPE_IMG
- en: As before, the topic that's remapping `/key_vel:=/cmd_vel` in the `T2` Terminal
    allows the virtual robot to be controlled with the arrow keys.
  prefs: []
  type: TYPE_NORMAL
- en: Finally, we are going to join the physical and the virtual robot in the same
    ROS environment.
  prefs: []
  type: TYPE_NORMAL
- en: Real-world and simulation at once
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Since we will be working with the robot, we need to specify the ROS master
    in the laptop so that it''s pointing to GoPiGo3\. To do so, uncomment the following
    line in your local `.bashrc` file to switch back to that configuration:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE53]'
  prefs: []
  type: TYPE_PRE
- en: 'Instead of killing the rest of the bash Terminals, you can reload the updated
    `.bashrc` in each of them:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE54]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, you are ready to execute ROS with both versions of GoPiGo3:'
  prefs: []
  type: TYPE_NORMAL
- en: 'First, launch the robot:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE55]'
  prefs: []
  type: TYPE_PRE
- en: 'Then, launch the rest of the ROS environment on the laptop. First, launch the
    keyboard control:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE56]'
  prefs: []
  type: TYPE_PRE
- en: 'Next, launch the virtual model:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE57]'
  prefs: []
  type: TYPE_PRE
- en: 'Finally, check the ROS graph:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE58]'
  prefs: []
  type: TYPE_PRE
- en: 'If everything went well, you should see the following familiar graph:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/1196fb4d-fc0c-4c20-b109-e048075edbd4.png)'
  prefs: []
  type: TYPE_IMG
- en: This states that you should be able to simultaneously control the physical robot
    (the `gopigo3` node) and the virtual robot (the `gazebo` node) with the same keystrokes
    (the `key_teleop` node).
  prefs: []
  type: TYPE_NORMAL
- en: Check teleoperation by clicking the left or right arrow key of the laptop keyboard.
    Both the physical and virtual GoPiGo3 will rotate at the same time. A similar
    result will be obtained if you press the *up* or *down* arrow keys.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: For the keystrokes to be effective, you need to have selected the Terminal window
    where you launched the `key_teleop.py` node, that is, `T2`.
  prefs: []
  type: TYPE_NORMAL
- en: Congratulations – you have successfully completed a whole tour of how to control
    a robot in ROS!
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, you have achieved correspondence between the physical GoPiGo3
    and its virtual model in Gazebo. You have checked how it doesn't matter whether
    you're controlling the actual robot or a virtual robot from the point of view
    of ROS. Since both are moved using the same topic, `/cmd_vel`, ROS does not care
    about which type of robot you're dealing with.
  prefs: []
  type: TYPE_NORMAL
- en: This fact explains how, from the point of view of ROS, you have the choice to
    test your code with a virtual robot and then safely apply it to the physical robot.
    We just need to launch the ROS node of the physical robot. This is useful in three
    situations. First, when you are developing a new application for an existing robot,
    you can debug the code with a virtual model in Gazebo. Second, when you do not
    have available the hardware of the robot – because you are still deciding which
    one to buy – you can virtually play and test the robot prior to the buy decision.
    And third, when you are designing a new robot, you have the choice of launching
    its mechanical design and software development in parallel. When you do this,
    the developed code will send feedback to your mechanical design before carrying
    out any manufacturing activities. This iterative loop should benefit the final
    product by cutting its development costs.
  prefs: []
  type: TYPE_NORMAL
- en: 'In the next chapter, you will tackle the first autonomous task of the robot:
    to make it aware of its environment and be able to navigate to reach a predefined
    destination. These tasks will introduce you to the **Simultaneous Localization
    and Mapping** (**SLAM**) technique, an algorithm that''s intensively used in all
    kinds of autonomous vehicles, especially in self-driving cars.'
  prefs: []
  type: TYPE_NORMAL
- en: Questions
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: If you need to have two different computers communicating over ROS, where should
    you locate the ROS master node?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: A) In the one that has the more recent version of ROS.
  prefs: []
  type: TYPE_NORMAL
- en: B) The ROS master node will run in the first one where you launch the `roscore`
    process.
  prefs: []
  type: TYPE_NORMAL
- en: C) You can place the master wherever you want. In one of the computers, you
    run `roscore`, and in the other one, you tell ROS that the master node is located
    in the other machine.
  prefs: []
  type: TYPE_NORMAL
- en: You have a physical robot named `mazinger_zeta` that accepts `geometry_msgs/Twist`
    messages in the `/walk` topic. What is the correct topic remapping command for
    remotely controlling the robot with the keyboard?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: A) `rosrun key_teleop key_teleop.py /walk:=/cmd_vel`
  prefs: []
  type: TYPE_NORMAL
- en: B)**` rosrun key_teleop key_teleop.py /key_vel:=/walk`**
  prefs: []
  type: TYPE_NORMAL
- en: C) `rosrun key_teleop key_teleop.py /walk:=/key_vel`
  prefs: []
  type: TYPE_NORMAL
- en: If you apply a speed command of 1 m/s to the *Y* axis, how will it move GoPiGo3?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: A) The robot will move left at 1 m/s
  prefs: []
  type: TYPE_NORMAL
- en: B) Nothing will happen
  prefs: []
  type: TYPE_NORMAL
- en: C) You need to specify a publishing frequency so that the command takes effect
  prefs: []
  type: TYPE_NORMAL
- en: What visible effect does this command have on the physical robot?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE59]'
  prefs: []
  type: TYPE_PRE
- en: A) It will rotate at the maximum possible speed since this is lower than 90
    radians/seconds.
  prefs: []
  type: TYPE_NORMAL
- en: B) GoPiGo3 cannot move at such a large angular speed.
  prefs: []
  type: TYPE_NORMAL
- en: C) Since it exceeds the maximum speed that GoPiGo3 can handle, the robot will
    stay still.
  prefs: []
  type: TYPE_NORMAL
- en: If you're controlling GoPiGo3 and the virtual robot with the keyboard simultaneously,
    what difference will you appreciate if you tell both of them to rotate at π rad/s
    every 2 seconds?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: A) Both will do a complete turn of 360º.
  prefs: []
  type: TYPE_NORMAL
- en: B) The virtual robot will rotate 360º but the physical robot will not complete
    the turn since there is the opposing force of the friction of the wheels against
    the floor.
  prefs: []
  type: TYPE_NORMAL
- en: C) The virtual robot will do exactly 360º, but the physical robot won't because
    of the wheel encoder's limited precision.
  prefs: []
  type: TYPE_NORMAL
- en: Further reading
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: ROS networking and time synchronization: [http://wiki.ros.org/ROS/NetworkSetup](http://wiki.ros.org/ROS/NetworkSetup)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*ROS Robot Programming: A handbook Written by TurtleBot3 Developers*, YoonSeok
    Pyo, HanCheol Cho, RyuWoon Jung, TaeHoon Lim (2017), ROBOTIS Co. Ltd, 1st edition: [http://www.pishrobot.com/wp-content/uploads/2018/02/ROS-robot-programming-book-by-turtlebo3-developers-EN.pdf](http://www.pishrobot.com/wp-content/uploads/2018/02/ROS-robot-programming-book-by-turtlebo3-developers-EN.pdf),
    Chapter: *Mobile Robots*'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Integrating sonar and IR sensor plugins into the robot model in Gazebo with
    ROS: [https://medium.com/teamarimac/integrating-sonar-and-ir-sensor-plugin-to-robot-model-in-gazebo-with-ros-656fd9452607](https://medium.com/teamarimac/integrating-sonar-and-ir-sensor-plugin-to-robot-model-in-gazebo-with-ros-656fd9452607)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
