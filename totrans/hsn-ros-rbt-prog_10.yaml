- en: Robot Control and Simulation
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 机器人控制和仿真
- en: In this chapter, you will set up your ROS development environment specifically
    for programming GoPiGo3. This understanding is going to be built by going from
    using the keys of your laptop keyboard to the more technical way of using ROS
    topics. Finally, you will guess what topics will allow you to wire manual keyboard/topic-based
    control to internal programming logic (that is, smart behavior) that will make
    the robot capable of executing autonomous tasks. In this sense, 3D simulation
    in Gazebo is an essential tool for testing behavior during development before
    pushing the app to the physical robot, saving time and effort when it comes to
    field-based work.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，你将设置专门用于编程GoPiGo3的ROS开发环境。这种理解将通过从使用笔记本电脑键盘的键到更技术性的使用ROS主题的方式建立。最后，你将猜测哪些主题将允许你将基于键盘/主题的手动控制与内部编程逻辑（即智能行为）连接起来，从而使机器人能够执行自主任务。从这个意义上说，Gazebo中的3D模拟是测试开发过程中的行为并在将应用程序推送到物理机器人之前的重要工具，这有助于在基于现场的工作中节省时间和精力。
- en: By the end of this chapter, you will have learned how to set up the ROS environment
    for a real robot. Remote control and autonomous control establish a qualitative
    difference in terms of robot software development. By experimenting with remote
    control by yourself, you will be ready to cross the frontier of what makes a robot
    really autonomous.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 到本章结束时，你将学会如何为真实机器人设置ROS环境。远程控制和自主控制在机器人软件开发方面建立了质的差异。通过自己尝试远程控制，你将准备好跨越机器人真正自主的边界。
- en: Finally, you will understand the usefulness of using simulation during the development
    of robotic applications by establishing a comparison with how the physical robot
    behaves. These observed differences will allow you to adjust the parameters of
    the virtual robot's simulation in Gazebo. The main advantage of this approach
    is that you can keep on developing and testing the software with the virtual model
    and then only test with the real hardware in the final development stage.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，你将通过将物理机器人的行为与仿真进行比较，了解在机器人应用开发中使用仿真的有用性。这些观察到的差异将允许你调整Gazebo中虚拟机器人仿真的参数。这种方法的主要优势是，你可以在最终的开发阶段仅使用真实硬件进行测试，而在开发过程中始终使用虚拟模型进行开发和测试。
- en: 'The following topics will be covered in this chapter:'
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 本章将涵盖以下主题：
- en: Setting up the GoPiGo3 development environment and making it capable of networking
    with ROS on a laptop
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 设置GoPiGo3开发环境，使其能够在笔记本电脑上与ROS进行网络连接
- en: Case study 3 – remotely controlling the physical robot using the keyboard
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 案例研究3 - 使用键盘远程控制物理机器人
- en: Remotely controlling robots using ROS topics from the command line
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用命令行通过ROS主题远程控制机器人
- en: Comparing the behavior of both of the physical robot and the virtual model in
    Gazebo under manual remote control
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在Gazebo中，比较手动遥控下物理机器人和虚拟模型的行为
- en: 'We will provide explanations of these concepts based on our third case study
    regarding robot drives (motors and encoders). Remember that the first two case
    studies were covered in [Chapter 6](0b20bdff-f1dc-42e8-ae83-fc290da31381.xhtml),
    *Programming in ROS – Commands and Tools*, and were as follows:'
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将根据关于机器人驱动（电机和编码器）的第三个案例研究对这些概念进行解释。记住，前两个案例研究已在[第6章](0b20bdff-f1dc-42e8-ae83-fc290da31381.xhtml)，*ROS编程
    - 命令和工具*中介绍，如下：
- en: '**Case study 1**: Publishing and reading the distance sensor'
  id: totrans-10
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**案例研究1**：发布和读取距离传感器'
- en: '**Case study 2**: Acquiring and visualizing images from the Pi camera'
  id: totrans-11
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**案例研究2**：从Pi摄像头获取并可视化图像'
- en: By the end of this chapter, we will have our first complete version of the ROS
    package of GoPiGo3\. This will be the basis that our smart robot behaviors will
    be built upon in the rest of this book.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 到本章结束时，我们将拥有GoPiGo3的ROS包的第一个完整版本。这将成为本书其余部分构建我们智能机器人行为的基础。
- en: Technical requirements
  id: totrans-13
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 技术要求
- en: 'For this chapter, no additional hardware or software configuration will be
    needed. Just make sure that you have the following:'
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 对于本章，不需要额外的硬件或软件配置。只需确保你具备以下条件：
- en: GoPiGo3, as per the *Technical requirements* section of [Chapter 6](0b20bdff-f1dc-42e8-ae83-fc290da31381.xhtml), *Programming
    in ROS – Commands and Tools*
  id: totrans-15
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 根据[第6章](0b20bdff-f1dc-42e8-ae83-fc290da31381.xhtml)的*技术要求*部分，GoPiGo3的*ROS编程
    - 命令和工具*
- en: A laptop, as per the *Configure your ROS Development Environment* section of
    [Chapter 3](f3ecc0de-28c4-4140-9a9c-ed351c68d121.xhtml), *Getting Started with
    ROS*
  id: totrans-16
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 笔记本电脑，根据[第3章](f3ecc0de-28c4-4140-9a9c-ed351c68d121.xhtml)，*ROS入门*中的*配置你的ROS开发环境*部分
- en: 'In the next section, we will prepare the ROS environment so that your laptop
    and the robot can communicate with each other under a unique ROS graph. Let''s
    go over the code we''ll need:'
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一节中，我们将准备ROS环境，以便你的笔记本电脑和机器人可以在一个独特的ROS图中相互通信。让我们回顾一下我们需要用到的代码：
- en: '**Code for this chapter (laptop)**: In this chapter, we will make use of the
    code located in the `Chapter7_Robot_control_simulation` folder ([https://github.com/PacktPublishing/Hands-On-ROS-for-Robotics-Programming/tree/master/Chapter7_Robot_control_simulation](https://github.com/PacktPublishing/Hands-On-ROS-for-Robotics-Programming/tree/master/Chapter7_Robot_control_simulation)).
    Copy its files to the ROS workspace so that they''re available to you and leave
    the rest outside the `src` folder. This way, you will have a cleaner ROS environment:'
  id: totrans-18
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**本章代码（笔记本电脑）**：在本章中，我们将使用位于`Chapter7_Robot_control_simulation`文件夹中的代码（[https://github.com/PacktPublishing/Hands-On-ROS-for-Robotics-Programming/tree/master/Chapter7_Robot_control_simulation](https://github.com/PacktPublishing/Hands-On-ROS-for-Robotics-Programming/tree/master/Chapter7_Robot_control_simulation)）。将其文件复制到ROS工作空间，以便你可以使用它们，并将其余文件放在`src`文件夹之外。这样，你将拥有一个更干净的ROS环境：'
- en: '[PRE0]'
  id: totrans-19
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'The code contains a new ROS package named `gazebo_control`. Rebuild the workspace
    so that it is known to your ROS installation:'
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 代码中包含一个名为`gazebo_control`的新ROS包。重建工作空间，使其为你的ROS安装所知：
- en: '[PRE1]'
  id: totrans-21
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'Check that the package has been correctly installed by selecting it and listing
    the files:'
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 通过选择该包并列出文件来检查该包是否已正确安装：
- en: '[PRE2]'
  id: totrans-23
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: '**Code for this chapter (GoPiGo3)**: You will be using the same code that we
    developed in [Chapter 6](0b20bdff-f1dc-42e8-ae83-fc290da31381.xhtml), *Programming
    in ROS – Commands and Tools*. Remember that it corresponds to the ROS package
    called `mygopigo` that''s located in the Raspberry Pi.'
  id: totrans-24
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**本章代码（GoPiGo3）**：你将使用我们在[第6章](0b20bdff-f1dc-42e8-ae83-fc290da31381.xhtml)，*在ROS中编程
    - 命令和工具*中开发的相同代码。记住，它对应于位于Raspberry Pi上的名为`mygopigo`的ROS包。'
- en: Now, you are ready to follow the explanations in this chapter and understand
    them in a practical way.
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，你准备好跟随本章的解释，并以实际的方式理解它们。
- en: Setting up the GoPiGo3 development environment
  id: totrans-26
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 设置GoPiGo3开发环境
- en: In the previous chapter, you tried the ROS desktop version in the Raspberry
    Pi of GoPiGo3\. For a serious development strategy, you should launch the minimum
    configuration of the application in the robot and launch all the accompanying
    development tasks within the laptop.
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 在上一章中，你尝试了在GoPiGo3的Raspberry Pi上运行ROS桌面版本。对于严肃的开发策略，你应该在机器人上启动应用程序的最小配置，并在笔记本电脑上启动所有伴随的开发任务。
- en: Remember that in [Chapter 3](f3ecc0de-28c4-4140-9a9c-ed351c68d121.xhtml), *Getting
    Started with ROS*, you run ROS on your laptop. Hence, the robot application itself
    was executed in such an environment, with no possibility to move a physical robot
    since we didn't establish a connection outside of the computer.
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 记住，在[第3章](f3ecc0de-28c4-4140-9a9c-ed351c68d121.xhtml)，*ROS入门*中，你在笔记本电脑上运行ROS。因此，机器人应用程序本身是在这种环境中执行的，由于我们没有在计算机之外建立连接，所以没有移动物理机器人的可能性。
- en: In this section, you will learn how to work simultaneously with the laptop and
    Raspberry Pi ROS environments when they're linked, that is, the Raspberry Pi controlling
    the GoPiGo3 robot and the laptop for CPU-intensive computing/visualization tasks.
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，你将学习如何在它们连接时同时使用笔记本电脑和Raspberry Pi ROS环境，即Raspberry Pi控制GoPiGo3机器人，笔记本电脑用于CPU密集型计算/可视化任务。
- en: ROS networking between the robot and the remote computer
  id: totrans-30
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 机器人和远程计算机之间的ROS网络
- en: 'To make two ROS environments, there are two prior conditions we need to meet:'
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 要创建两个ROS环境，我们需要满足两个先决条件：
- en: The robot and computer ROS environments need to know how to communicate with
    each other.
  id: totrans-32
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 机器人和计算机ROS环境需要知道如何相互通信。
- en: The master node (`roscore` process) should be unique and run in either.
  id: totrans-33
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 主节点（`roscore`进程）应该是唯一的，并且可以在其中任何一个运行。
- en: Let's learn how to accomplish both conditions.
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们学习如何满足这两个条件。
- en: Communication between ROS environments
  id: totrans-35
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: ROS环境之间的通信
- en: 'The way that a computer is identified in a network is by means of its IP address,
    normally using the IPv4 protocol. In general, you can find the IP that''s been
    assigned to your machine with the `ifconfig` command:'
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 计算机在网络中的识别方式是通过其IP地址，通常使用IPv4协议。一般来说，你可以使用`ifconfig`命令找到分配给你的机器的IP地址：
- en: '[PRE3]'
  id: totrans-37
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: You should focus on the wireless interface, typically named `wlan0`, since you
    configured your robot for Wi-Fi access. The IP address is the 4 x 4 bytes field
    following the word `inet`. So, for the Raspberry Pi in GoPiGo3, this field is
    `192.168.1.58`.
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 你应该关注无线接口，通常命名为 `wlan0`，因为你已经为机器人配置了Wi-Fi访问。IP地址是跟在 `inet` 单词后面的4 x 4字节字段。因此，对于GoPiGo3中的Raspberry
    Pi，这个字段是 `192.168.1.58`。
- en: 'Do the same for the laptop, opening in it a Terminal. If you are using a wired
    connection, you should look at `eth0` instead of `wlan0`. For our example case,
    the computer''s IP is `192.168.1.54`. If there were too many network interfaces,
    the output could be too verbose. To focus on what you are looking for, you can
    filter the output, like this:'
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 对于笔记本电脑，也以终端打开。如果你使用的是有线连接，你应该查看 `eth0` 而不是 `wlan0`。在我们的示例案例中，计算机的IP地址是 `192.168.1.54`。如果有太多的网络接口，输出可能会过于冗长。为了专注于你正在寻找的内容，你可以过滤输出，如下所示：
- en: '[PRE4]'
  id: totrans-40
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: Once you have both IP addresses, you just have to indicate them using ROS environment
    variables. In the following subsections, we will show you how to configure each
    of the computers.
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦你有了两个IP地址，你只需使用ROS环境变量来指示它们。在以下小节中，我们将向你展示如何配置每台计算机。
- en: Robot network configuration
  id: totrans-42
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 机器人网络配置
- en: 'Next, you have to follow three steps to set up the Raspberry Pi:'
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，你必须遵循三个步骤来设置Raspberry Pi：
- en: 'Execute the following two commands in a Terminal to define the environment
    variables needed by ROS:'
  id: totrans-44
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在终端中执行以下两个命令来定义ROS所需的环境变量：
- en: '[PRE5]'
  id: totrans-45
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: The first command sets the variable that allows ROS to know the IP of the host where
    it is currently running. The second line is the URL of the master node. Since it
    is set to `ROS_HOSTNAME`, we are saying that it will run on the robot computer.
    Port `11311` is the default that's set by ROS to communicate with the master node.
    Each subsequently launched node will be automatically assigned a new available
    port.
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 第一条命令设置了允许ROS知道其当前运行的主机IP地址的变量。第二行是主节点的URL。由于它被设置为 `ROS_HOSTNAME`，我们是在说它将在机器人计算机上运行。端口
    `11311` 是ROS设置用于与主节点通信的默认端口。随后启动的每个节点都将自动分配一个新的可用端口。
- en: 'There is a way to abstract the IP number itself because, in Ubuntu systems, `avahi-daemon` ([http://manpages.ubuntu.com/manpages/bionic/man8/avahi-daemon.8.html](http://manpages.ubuntu.com/manpages/bionic/man8/avahi-daemon.8.html))
    allows you to point to a machine in the local network by simply appending `.local`
    to its hostname. For this, the configuration command will be as follows:'
  id: totrans-47
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 有一种方法可以抽象IP地址本身，因为在Ubuntu系统中，`avahi-daemon` ([http://manpages.ubuntu.com/manpages/bionic/man8/avahi-daemon.8.html](http://manpages.ubuntu.com/manpages/bionic/man8/avahi-daemon.8.html))
    允许你通过简单地将 `.local` 添加到主机名来指向本地网络中的机器。为此，配置命令将如下所示：
- en: '[PRE6]'
  id: totrans-48
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'The hostname can be found in the prompt of the Terminal and is usually in the
    format `user@hostname :~$`. If you have any doubts, you can ask for it in the
    Terminal by using `hostname` command:'
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 主机名可以在终端提示符中找到，通常格式为 `user@hostname :~$`。如果你有任何疑问，可以在终端中使用 `hostname` 命令来询问：
- en: '[PRE7]'
  id: totrans-50
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'Each new Terminal you launch will need this configuration. So, if we include
    it as additional lines in the `.bashrc` file, you won''t have to care about doing
    this by hand:'
  id: totrans-51
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 每次你启动新的终端时都需要这个配置。因此，如果我们将其作为额外的行包含在 `.bashrc` 文件中，你就不必手动做这件事：
- en: '[PRE8]'
  id: totrans-52
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'Check the result by listing the end of the file:'
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 通过列出文件末尾来检查结果：
- en: '[PRE9]'
  id: totrans-54
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: You should see the cited two configuration lines.
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 你应该能看到引用的两个配置行。
- en: Now that the Raspberry Pi has been configured, we will do something similar
    for the laptop.
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 现在Raspberry Pi已经配置好了，我们将为笔记本电脑做类似的事情。
- en: Laptop network configuration
  id: totrans-57
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 笔记本网络配置
- en: 'For the remote computer, these are the equivalent steps:'
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 对于远程计算机，这些是等效的步骤：
- en: 'Execute the following two commands in a Terminal to set the environment variables:'
  id: totrans-59
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在终端中执行以下两个命令来设置环境变量：
- en: '[PRE10]'
  id: totrans-60
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: You specify its IP address as `192.168.1.54` in the first line, while in the
    second, we are stating that the ROS master is located in the robot, that is, `gopigo3.local`.
    This way, your system won't need to be reconfigured if the network is restarted
    and a different IP address is assigned to the Raspberry Pi.
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 你在第一行指定其IP地址为 `192.168.1.54`，而在第二行中，我们声明ROS主节点位于机器人上，即 `gopigo3.local`。这样，如果你的网络重启并且Raspberry
    Pi被分配了不同的IP地址，你的系统就不需要重新配置。
- en: 'As for the robot, add the following two lines to the `.bashrc` file to automate
    the configuration each time a new Terminal is launched:'
  id: totrans-62
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 至于机器人，将以下两行添加到 `.bashrc` 文件中，以便每次启动新终端时自动配置：
- en: '[PRE11]'
  id: totrans-63
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: We are also showing the alternative for setting `ROS_HOSTNAME`, that is, using `rosbot.local`
    instead of the numeric IP address.
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还展示了设置 `ROS_HOSTNAME` 的替代方法，即使用 `rosbot.local` 而不是数字 IP 地址。
- en: Launching the master node and connecting
  id: totrans-65
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 启动主节点并连接
- en: 'The following procedure allows us to establish a connection between the laptop
    and the Raspberry Pi:'
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 以下过程允许我们在笔记本电脑和 Raspberry Pi 之间建立连接：
- en: 'Launch the ROS master node in the robot by using the already familiar `roscore`
    command:'
  id: totrans-67
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用已熟悉的 `roscore` 命令在机器人上启动 ROS 主节点：
- en: '[PRE12]'
  id: totrans-68
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'Then, perform a basic check in the laptop to find out if it is aware of the
    master node''s existence:'
  id: totrans-69
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后，在笔记本电脑上执行基本检查，以确定它是否知道主节点存在：
- en: '[PRE13]'
  id: totrans-70
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: '`/rosout_agg` and `/rosout_agg` are the topics that are published by the master
    node.'
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: '`/rosout_agg` 和 `/rosout_agg` 是由主节点发布的主题。'
- en: If everything has gone well, you can remotely control your GoPiGo3\. Close the
    Terminal before moving on to the next section to make sure `roscore` is off.
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 如果一切顺利，你可以远程控制你的 GoPiGo3。在进入下一节之前关闭终端，以确保 `roscore` 已关闭。
- en: Case study 3 – remote control using the keyboard
  id: totrans-73
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 案例研究 3 – 使用键盘进行遥控
- en: This case study will help you complete the first version of the GoPiGo3 ROS
    package. In the previous chapter, you were dealing with the distance sensor and
    the Pi camera, and we devoted one case study to each of them.
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 本案例研究将帮助你完成 GoPiGo3 ROS 软件包的第一个版本。在前一章中，你处理的是距离传感器和 Pi 摄像头，我们为每个都进行了一个案例研究。
- en: 'By including the motion functionality with the present robot drives, you will
    have a robot that is able to perform basic interactions with its environment:'
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 通过将运动功能与现有的机器人驱动程序相结合，你将拥有一个能够与其环境进行基本交互的机器人：
- en: '**Perception capabilities** include detecting obstacles with the distance sensor
    and visual recognition of the surroundings with the Pi camera.'
  id: totrans-76
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**感知能力**包括使用距离传感器检测障碍物，以及使用 Pi 摄像头对周围环境的视觉识别。'
- en: '**Actuation capability**, where the robot is able to move on the floor while
    being aware of the possible obstacles with the distance sensor and recognizing
    shapes and people with the image feed from its camera.'
  id: totrans-77
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**驱动能力**，其中机器人能够在地板上移动，同时通过距离传感器感知可能的障碍物，并通过其摄像头的图像流识别形状和人。'
- en: Case study 3 focuses on actuation capability. In this section, you will learn
    how to remotely move the robot using a keyboard and a mouse.
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 案例研究 3 侧重于驱动能力。在本节中，你将学习如何使用键盘和鼠标远程移动机器人。
- en: Running the gopigo3 node in the robot
  id: totrans-79
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 在机器人上运行 gopigo3 节点
- en: 'In this section, we are going to run a node in the Raspberry Pi that will provide
    the control capability:'
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们将运行一个在 Raspberry Pi 上的节点，该节点将提供控制能力：
- en: 'Launch the GoPiGo3 ROS package in the robot:'
  id: totrans-81
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在机器人上启动 GoPiGo3 ROS 软件包：
- en: '[PRE14]'
  id: totrans-82
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: This is the only command you need to run directly in the Raspberry Pi. Since
    you configured ROS so that the laptop can talk to the robot, the following commands
    can be run on the laptop.
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 这是你需要直接在 Raspberry Pi 上运行的唯一命令。由于你已配置 ROS，使笔记本电脑能够与机器人通信，因此以下命令可以在笔记本电脑上运行。
- en: When preceding a bash command with `T1`, `T2`, `T3`, or `T4`, we will always
    be referring to consecutive Terminals on the laptop.
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 当在 bash 命令前加上 `T1`、`T2`、`T3` 或 `T4` 时，我们总是会指代笔记本电脑上的连续终端。
- en: '2\. Then, on your laptop, ensure that you have a single node, that is, `gopigo3`:'
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 2. 然后，在你的笔记本电脑上，确保只有一个节点，即 `gopigo3`：
- en: '[PRE15]'
  id: totrans-86
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: Remember that the `/rosout` topic corresponds to the master node.
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 记住，`/rosout` 主题对应于主节点。
- en: '3\. Next, list all the available ROS topics to find out what their names are:'
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 3. 接下来，列出所有可用的 ROS 主题，以找出它们的名称：
- en: '[PRE16]'
  id: totrans-89
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: Bear in mind that the three topics of interest are called `/battery_voltage`,
    `/cmd_vel`, and `/motor/status`. We will provide details about them later in this
    section.
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 请记住，三个感兴趣的主题被称为 `/battery_voltage`、`/cmd_vel` 和 `/motor/status`。我们将在本节后面提供它们的详细信息。
- en: '4\. To get additional information about these topics, you can use the `info`
    option of the `rosnode` command. This will tell you what the `gopigo3` node can
    do:'
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 4. 要获取有关这些主题的更多信息，可以使用 `rosnode` 命令的 `info` 选项。这将告诉你 `gopigo3` 节点能做什么：
- en: '[PRE17]'
  id: totrans-92
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'Here, you can see that `/battery_voltage` and **`/motor/status` **are publishers (objects
    in the code of the node that stream data to such topics), while `/cmd_vel` is
    a subscriber (as well as an object that''s declared in the node that allows us
    to consume data from an existing topic):'
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，你可以看到 `/battery_voltage` 和 **`/motor/status`** 是发布者（节点代码中的对象，将数据流到这些主题），而
    `/cmd_vel` 是一个订阅者（以及一个在节点中声明的对象，允许我们从现有主题中消费数据）：
- en: The publishers allow you to get status information from the battery level and
    the motors, respectively.
  id: totrans-94
  prefs:
  - PREF_UL
  - PREF_UL
  type: TYPE_NORMAL
  zh: 发布者允许你从电池电量和电机分别获取状态信息。
- en: The `/cmd_vel` subscriber allows the robot to accept motion commands for remote
    control.
  id: totrans-95
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`/cmd_vel`订阅者允许机器人接受远程控制的运动命令。'
- en: In the next subsection, we will inspect the publishers in order to understand
    the structure of the messages they stream.
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一小节中，我们将检查发布者，以便了解它们流出的消息结构。
- en: Inspecting published topics and messages
  id: totrans-97
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 检查发布的主题和消息
- en: 'Now that we''ve identified the three topics, let''s take a look at them and
    get some robot-specific information:'
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经确定了三个主题，让我们来看看它们，并获取一些机器人特定的信息：
- en: 'To find the last five values of the battery, run the following command in a
    Terminal. This will allow you to inspect the `/battery_voltage` topic:'
  id: totrans-99
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 要找到电池的最后五个值，请在终端中运行以下命令。这将允许你检查`/battery_voltage`主题：
- en: '[PRE18]'
  id: totrans-100
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: You can infer that the voltage is about 9.6V on average, which means the batteries
    are charged.
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以推断出电压大约是9.6V，这意味着电池已经充电。
- en: 'Let''s investigate how this topic is built:'
  id: totrans-102
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 让我们调查这个主题是如何构建的：
- en: '[PRE19]'
  id: totrans-103
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'It uses the `std_msgs/Float64` message type, which corresponds to a floating-point
    number that''s 64 bits size. This message type is part of the ROS standard message
    library ([http://wiki.ros.org/std_msgs](http://wiki.ros.org/std_msgs)). To find
    out what a ROS message is made up of, you can use the `rosmsg` command:'
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 它使用`std_msgs/Float64`消息类型，这对应于一个64位大小的浮点数。这种消息类型是ROS标准消息库的一部分([http://wiki.ros.org/std_msgs](http://wiki.ros.org/std_msgs))。要了解ROS消息由什么组成，你可以使用`rosmsg`命令：
- en: '[PRE20]'
  id: totrans-105
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'There is another topic in this node, `/motor/status`, that makes use of a custom
    and more complex message:'
  id: totrans-106
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在这个节点中还有一个主题，`/motor/status`，它使用一个自定义的更复杂的消息：
- en: '[PRE21]'
  id: totrans-107
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'Let''s find the structure of the message. Note that the definition of the message
    is declared within the `mygopigo` package under the `msg` folder:'
  id: totrans-108
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 让我们找到消息的结构。请注意，消息的定义是在`mygopigo`包下的`msg`文件夹中声明的：
- en: '[PRE22]'
  id: totrans-109
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'There are three parts to this:'
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 这有三个部分：
- en: A header with the sequence number and the timestamp
  id: totrans-111
  prefs:
  - PREF_UL
  - PREF_UL
  type: TYPE_NORMAL
  zh: 包含序列号和时间戳的头部
- en: Data from the left motor
  id: totrans-112
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 来自左侧电机的数据
- en: Data from the right motor
  id: totrans-113
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 来自右侧电机的数据
- en: 'If we take the content of the last published message, we can visualize this
    structure in practice:'
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们取最后发布的消息的内容，我们可以在实践中可视化这个结构：
- en: '[PRE23]'
  id: totrans-115
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: Here, you can see that the topic reports the `low_voltage` level warning, the
    motor `overload` warning, `power`, `encoder` data, and the current `speed`.
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，你可以看到主题报告了`low_voltage`级别警告，电机`overload`警告，`power`，`encoder`数据和当前的`speed`。
- en: Now, let's proceed to the practical part of moving the robot.
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们继续到移动机器人的实际部分。
- en: Teleoperation package
  id: totrans-118
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 遥操作包
- en: '`key_teleop` ([http://wiki.ros.org/key_teleop](http://wiki.ros.org/key_teleop))
    is a ROS-contributed package that provides a very simple mechanism for controlling
    a robot using the arrow keys of the keyboard. Clone the source code and install
    the package on your laptop as usual:'
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: '`key_teleop`([http://wiki.ros.org/key_teleop](http://wiki.ros.org/key_teleop))是一个由ROS贡献的包，它提供了一个非常简单的机制，使用键盘的箭头键来控制机器人。按照常规方式克隆源代码并在你的笔记本电脑上安装该包：'
- en: '[PRE24]'
  id: totrans-120
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'Another two packages are available here that are also part of the `teleop_tools` bundle:'
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 这里还有另外两个包可用，它们也是`teleop_tools`包的一部分：
- en: '`joy_teleop`, a generic joystick interface for topics and actions'
  id: totrans-122
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`joy_teleop`，一个通用的操纵杆接口，用于主题和动作'
- en: '`mouse_teleop`, a pointing device (for example, mouse, touchpad, and so on)
    teleoperation utility'
  id: totrans-123
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`mouse_teleop`，一个指向设备（例如鼠标、触摸板等）遥操作工具'
- en: Since you have built the whole repository, both of these are available to you.
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 由于你已经构建了整个仓库，这两个都对你可用。
- en: Running teleoperation on a laptop
  id: totrans-125
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 在笔记本电脑上运行遥操作
- en: 'Since you''ve completed the *Running gopigo3 node in the robot* subsection,
    you should have the `gopigo3` node running as a result of the `$ roslaunch mygopigo
    gopigo3.launch` command. Let''s learn how to achieve remote control of it:'
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 自从你完成了*在机器人中运行gopigo3节点*这一小节，你应该已经通过`$ roslaunch mygopigo gopigo3.launch`命令使`gopigo3`节点运行。现在让我们学习如何远程控制它：
- en: 'Launch the teleoperation node on your laptop:'
  id: totrans-127
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在你的笔记本电脑上启动遥操作节点：
- en: '[PRE25]'
  id: totrans-128
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'The preceding command launches the `key_teleop` node, and the Terminal''s prompt
    is substituted by an interface that looks similar to the one shown in the following
    screenshot:'
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 之前的命令启动了`key_teleop`节点，终端的提示被一个类似于以下截图的界面所替换：
- en: '![](img/e17ef85c-6ac9-4447-9bfd-65b622b02626.png)'
  id: totrans-130
  prefs: []
  type: TYPE_IMG
  zh: '![](img/e17ef85c-6ac9-4447-9bfd-65b622b02626.png)'
- en: 'This gray window tells you how to move the robot using the arrow keys of the
    keyboard:'
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 这个灰色窗口告诉您如何使用键盘上的箭头键移动机器人：
- en: The up arrow key moves the robot forward at 0.8 m/s. You can see the commanded
    speed in the interface.
  id: totrans-132
  prefs:
  - PREF_UL
  - PREF_UL
  type: TYPE_NORMAL
  zh: 向上箭头键使机器人以 0.8 m/s 的速度向前移动。您可以在界面上看到命令速度。
- en: The down arrow key moves the robot backward at -0.5 m/s (the minus sign means
    backward).
  id: totrans-133
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 向下箭头键使机器人以 -0.5 m/s 的速度向后移动（负号表示向后）。
- en: The left arrow key rotates the robot counter-clockwise (left) at 1 rad/s.
  id: totrans-134
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 向左箭头键使机器人以 1 rad/s 的速度逆时针（向左）旋转。
- en: The right arrow key rotates the robot clockwise at -1 rad/s  (the minus sign
    means rotation to the right).
  id: totrans-135
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 向右箭头键使机器人以 -1 rad/s 的速度顺时针旋转（负号表示向右旋转）。
- en: So that you can effectively move it, be aware that the Terminal that you launched
    the `key_teleop` node from has to be the active window. If that's not the case,
    just click anywhere on it to make it the active one.
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 为了有效地移动它，请注意，启动 `key_teleop` 节点的终端必须是活动窗口。如果不是这种情况，只需点击它上的任何位置使其成为活动窗口。
- en: 'With the `T2` command, we can visualize the ROS graph as usual:'
  id: totrans-137
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用 `T2` 命令，我们可以像往常一样可视化 ROS 图：
- en: '[PRE26]'
  id: totrans-138
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: 'It should look as follows:'
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 它应该看起来如下：
- en: '![](img/1cfb3f28-184f-4f78-86fc-edb683002ae1.png)'
  id: totrans-140
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/1cfb3f28-184f-4f78-86fc-edb683002ae1.png)'
- en: The`  T1` command that was appended after the executable script of the node
    with the `/key_vel:=/cmd_vel`assignment is what we call remapping. This technique
    allows two nodes to communicate, where the literal of the subscriber of the listener
    node, `/cmd_vel`, does not match the literal of the publisher node, `/key_vel`.
    Hence, remapping consists of wiring the published topic of one node to the subscribed
    topic of another node. This way, we know that the output from the `key_teleop` node
    is going to be the input of the `gopigo3` node.
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 在节点可执行脚本之后附加的 `T1` 命令就是我们所说的重新映射。这项技术允许两个节点进行通信，其中监听节点订阅者的字面量 `/cmd_vel` 与发布节点
    `/key_vel` 的字面量不匹配。因此，重新映射包括将一个节点的发布主题连接到另一个节点的订阅主题。这样，我们知道 `key_teleop` 节点的输出将成为
    `gopigo3` 节点的输入。
- en: Now, let's learn how to teleoperate the robot with the mouse instead of the
    keyboard.
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们学习如何使用鼠标而不是键盘来遥控机器人。
- en: Teleoperation with the mouse
  id: totrans-143
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用鼠标进行遥操作
- en: 'This procedure is equivalent to that of the keyboard:'
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 此过程与键盘上的操作等效：
- en: 'Write the following command in a third Terminal to apply the `mouse_teleop`
    package from the `teleop_tools` bundle:'
  id: totrans-145
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在第三个终端中输入以下命令以应用来自 `teleop_tools` 包的 `mouse_teleop` 包：
- en: '[PRE27]'
  id: totrans-146
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: In this case, the remapping topic is `/mouse_vel:=/cmd_vel`.
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 在此情况下，重新映射的主题是 `/mouse_vel:=/cmd_vel`。
- en: 'Refresh the `rqt_graph` window; you will see the following:'
  id: totrans-148
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 刷新 `rqt_graph` 窗口；您将看到以下内容：
- en: '![](img/28ea3127-edeb-430e-b1b9-bdcff048da1f.png)'
  id: totrans-149
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/28ea3127-edeb-430e-b1b9-bdcff048da1f.png)'
- en: The preceding graph suggests that the robot simultaneously accepts commands
    from the mouse and the keyboard without any trouble. This happens if we don't
    kill the keyboard control in the `T1` Terminal before launching the mouse control
    command.
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 前面的图表表明，机器人可以无障碍地同时接受来自鼠标和键盘的命令。这种情况发生在我们在启动鼠标控制命令之前没有在 `T1` 终端中终止键盘控制。
- en: On the other hand, if you kill the `T1` terminal, the robot will keep on working,
    but then you will only control it with the mouse since the process in `T3` keeps
    it live (the `key_teleop` node will disappear from `rqt_graph` if we refresh the
    window).
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 另一方面，如果您终止了 `T1` 终端，机器人将继续工作，但那时您只能通过鼠标控制它，因为 `T3` 中的进程使其保持活动状态（如果我们刷新窗口，`key_teleop`
    节点将从 `rqt_graph` 中消失）。
- en: 'Finally, check if the mouse control works (restart the `T1` command if you
    killed it previously):'
  id: totrans-152
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后，检查鼠标控制是否正常工作（如果您之前终止了它，请重新启动 `T1` 命令）：
- en: Select the window of `T1`. You will move GoPiGo3 with the arrow keys.
  id: totrans-153
  prefs:
  - PREF_UL
  - PREF_UL
  type: TYPE_NORMAL
  zh: 选择 `T1` 的窗口。您将使用箭头键移动 GoPiGo3。
- en: Select the new window that appeared by implementing the `T3` command. Now, you
    can move GoPiGo3 with the mouse (while the left button is being held down).
  id: totrans-154
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 通过执行 `T3` 命令选择出现的新窗口。现在，您可以使用鼠标移动 GoPiGo3（同时按住左键）。
- en: 'The following is the new window that appears for controlling the mouse:'
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 下面的新窗口是用于控制鼠标的：
- en: '![](img/1271a71c-ab5a-4efc-b57d-5315162bd5ac.png)'
  id: totrans-156
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/1271a71c-ab5a-4efc-b57d-5315162bd5ac.png)'
- en: The blue line represents the forward (positive speed)-backward directions. In
    this case, it moves at -0.3 m/s (backward). The longer the line, the greater the
    speed. The red circular sector represents the same but for the rotation. It is
    positive when rotating left (counter-clockwise), at 15.08 degrees/second in this
    case.
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 蓝线代表前进（正速度）- 向后方向。在这种情况下，它以-0.3 m/s（向后）的速度移动。线越长，速度越快。红色圆形区域代表相同的旋转方向。在这种情况下，当向左旋转（逆时针）时，旋转速度为每秒15.08度。
- en: 'This example illustrates two important concepts of ROS:'
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 这个例子说明了ROS的两个重要概念：
- en: '**The concurrency of messages**: If there two or more nodes that publish to
    a topic that is mapped to the subscriber of another node, this node will accept
    the messages from both and will try to execute all of them. This is a nice feature
    that you will exploit when working with ROS at an advanced level.'
  id: totrans-159
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**消息的并发性**：如果有两个或更多节点向映射到另一个节点订阅者的主题发布消息，该节点将接受来自两者的消息，并尝试执行所有这些消息。这是一个当你以高级水平使用ROS时会利用的好特性。'
- en: '**The resilience of the runtime enviroment**: The robot can work with partial
    functionality. It will only lose the functionality provided by the ROS nodes that
    die.'
  id: totrans-160
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**运行环境的弹性**：机器人可以以部分功能工作。它将仅丢失由已死亡的ROS节点提供的功能。'
- en: 'At this point, it is important that you think of how ROS provides a high-level
    layer for programming robots compared to the usage of procedural languages such
    as C or Python. Furthermore, this also means that you will focus more on the robot''s
    functionality and less on programming the code: you will integrate existing packages
    that provide the low-level layer (control commands from a keyboard or mouse, for
    example) and relate them via ROS topics to build the high-level layer (motion
    control of the robot with the keyboard and/or mouse).'
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 在这一点上，重要的是要思考ROS如何为编程机器人提供高级层，与使用C或Python等过程式语言相比。此外，这也意味着你将更多地关注机器人的功能，而不是编程代码：你将集成现有的提供低级层（例如来自键盘或鼠标的控制命令）的包，并通过ROS主题将它们联系起来，以构建高级层（使用键盘和/或鼠标控制机器人的运动）。
- en: Remote control using ROS topics
  id: totrans-162
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用ROS主题进行远程控制
- en: In the previous section, you controlled the robot's publishing messages in the
    `/cmd_vel` topic using a human interface, the keyboard and the mouse. In this
    section, you will publish the messages directly using `rostopic` from the command
    line. This way, you will become familiar with this relevant topic and the structure
    of its messages. It is crucial to understand how `/cmd_vel` works under the hood
    since you will be using it in many of the advanced examples we'll be covering
    in the remaining chapters of this book.
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 在上一节中，你使用人机界面（键盘和鼠标）控制了在`/cmd_vel`主题上发布的机器人消息。在本节中，你将直接使用命令行中的`rostopic`发布消息。这样，你将熟悉这个相关主题及其消息结构。理解`/cmd_vel`在底层的工作方式至关重要，因为你在本书剩余章节中将要覆盖的许多高级示例中都将使用它。
- en: The motion control topic – /cmd_vel
  id: totrans-164
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 运动控制主题 - `/cmd_vel`
- en: 'Now that we''ve enjoyed playing with the robot, let''s understand how this
    form of control works. The `/cmd_vel` topic that the gopigo3 node is subscribed
    to is the key to producing translations and rotations of the robot. Run the `rostopic`
    command while having the `gopigo3` node running in the robot to retrieve the information
    from the topic:'
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经享受了与机器人的玩耍，让我们了解这种控制形式是如何工作的。gopigo3节点订阅的`/cmd_vel`主题是产生机器人平移和旋转的关键。在机器人上运行`gopigo3`节点的同时，运行`rostopic`命令以从主题检索信息：
- en: '[PRE28]'
  id: totrans-166
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: 'The topic `/cmd_vel` uses the `geometry_msgs/Twist` type (64 bits) of the `geometry_msgs`
    message library ([http://wiki.ros.org/geometry_msgs](http://wiki.ros.org/geometry_msgs)).
    This library provides messages for working with geometric primitives: points,
    vectors, and poses. The command is also telling you which nodes are subscribed
    to the topic, which is only `gopigo3` in our case. Now, let''s retrieve the structure
    of the message type:'
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 主题`/cmd_vel`使用`geometry_msgs/Twist`类型（64位）的`geometry_msgs`消息库（[http://wiki.ros.org/geometry_msgs](http://wiki.ros.org/geometry_msgs)）。这个库提供了用于处理几何原语（点、向量、姿态）的消息。命令还告诉你哪些节点订阅了该主题，在我们的例子中，只有`gopigo3`。现在，让我们检索消息类型的结构：
- en: '[PRE29]'
  id: totrans-168
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: Here, we can see that it is composed of six 64-bit float numbers that will allow
    you to treat it as two vectors of three components each. The first three components
    form the linear vector and refer to the speed along the *X*, *Y*, and *Z* axes,
    while the remaining three form the rotation vector, expressing the angular speed
    about each of those axes. Let's see how this works in practice.
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们可以看到它由六个 64 位浮点数组成，这将允许你将其视为两个各由三个分量组成的三维向量。前三个分量形成线性向量，并指代沿 *X*、*Y* 和
    *Z* 轴的速度，而剩下的三个形成旋转向量，表示绕每个轴的角速度。让我们看看这在实践中是如何工作的。
- en: Using /cmd_vel to directly drive GoPiGo3
  id: totrans-170
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用 /cmd_vel 直接驱动 GoPiGo3
- en: 'Previously, we focused on the end user''s perspective of controlling the robot,
    that is, keyboard strokes or mouse clicks and displacement. Now, we are going
    to discover how to achieve the same kind of control from the developer''s perspective,
    which is the one you need to build new applications in ROS. Let''s get started:'
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 以前，我们关注的是最终用户的机器人控制视角，即键盘按键或鼠标点击和位移。现在，我们将从开发者的视角来发现如何实现相同类型的控制，这是你在 ROS 中构建新应用程序所需要的。让我们开始吧：
- en: 'Rotate the robot at a 1 rad/s rate by publishing a message from the command
    line. Remember that the `gopigo3` node must be running in the robot:'
  id: totrans-172
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 以 1 rad/s 的速率旋转机器人，通过命令行发布消息。记住，`gopigo3` 节点必须在机器人上运行：
- en: '[PRE30]'
  id: totrans-173
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: As soon as you enter the command, apart from seeing GoPiGo3 rotating left (counter-clockwise),
    you will receive the accompanying information message about the command.
  id: totrans-174
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 一旦你输入命令，除了看到 GoPiGo3 向左旋转（逆时针）外，你还会收到关于该命令的伴随信息消息。
- en: 'Since you did not specify a publishing frequency, ROS assumes that you want
    to keep that message latched, that is, running forever. Check this by using `rostopic`
    in another Terminal:'
  id: totrans-175
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 由于你没有指定发布频率，ROS 假设你想要保持该消息锁定，即永远运行。你可以通过在另一个终端使用 `rostopic` 来检查这一点：
- en: '[PRE31]'
  id: totrans-176
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: 'How can we stop the robot? Easy – send a new message with the rotation set
    to zero:'
  id: totrans-177
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们如何停止机器人？很简单——发送一个新的消息，将旋转设置为零：
- en: '[PRE32]'
  id: totrans-178
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: You will see that GoPiGo3 stops and that `T2` throws a new set of six values,
    informing us that angular `z` is now equal to `0`.
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: 你会看到 GoPiGo3 停止，并且 `T2` 抛出一个新的六值集合，告诉我们角 `z` 现在等于 `0`。
- en: 'The next step is to introduce a message update at a given rate. Stop the process
    in `T1` and write the following command:'
  id: totrans-180
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 下一步是引入以给定速率的消息更新。在 `T1` 中停止进程并写下以下命令：
- en: '[PRE33]'
  id: totrans-181
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: In `T2`, you should see a new message every 2 seconds (= 0.5 Hz frequency).
    The `-r` option (initial of rate) is the one you use to specify how often you
    want the message to be sent. Since you are keeping the same rotation speed, you
    won't appreciate any changes in the robot motion.
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: 在 `T2` 中，你应该每 2 秒（= 0.5 Hz 频率）看到一个新消息。`-r` 选项（速率的缩写）是你用来指定消息发送频率的选项。由于你保持相同的旋转速度，你不会注意到机器人运动中的任何变化。
- en: 'Go to another Terminal and publish a double speed (2 rad/s) in the `/cmd_vel`
    topic at the same frequency of 0.5 Hz:'
  id: totrans-183
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 前往另一个终端，并在 `/cmd_vel` 主题上以相同的 0.5 Hz 频率发布双倍速度（2 rad/s）：
- en: '[PRE34]'
  id: totrans-184
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: You will see GoPiGo3 alternating between angular speeds of 1 and 2 rad/s at
    the specified rate.
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: 你会看到 GoPiGo3 在指定的速率下在 1 和 2 rad/s 的角速度之间交替。
- en: 'Go to `T4` and send a stop rotation command:'
  id: totrans-186
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 前往 `T4` 并发送停止旋转命令：
- en: '[PRE35]'
  id: totrans-187
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: Observe how the robot stops for a while every 2 seconds.
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: 观察机器人每 2 秒停止一段时间。
- en: 'What if you want the robot to stop more often? Stop the process in `T4` and
    relaunch the command with a higher rate of 1 Hz:'
  id: totrans-189
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果你想让机器人更频繁地停止？在 `T4` 中停止进程，并以更高的 1 Hz 速率重新启动命令：
- en: '[PRE36]'
  id: totrans-190
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: How do we make it stop for longer? Easy – specify a higher frequency, that is,
    10 Hz. When using such a value, you will find that GoPiGo3 rotates very little,
    since 10 times every second, it receives a stop command, superseding the most
    recent effect of the speeds set in `T1` (1 rad/s) and `T3` (2 rad/s).
  id: totrans-191
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们如何让它停止更长时间？很简单——指定更高的频率，即 10 Hz。当使用这样的值时，你会发现 GoPiGo3 旋转非常少，因为每秒钟 10 次接收停止命令，覆盖了在
    `T1`（1 rad/s）和 `T3`（2 rad/s）中设置的最近速度设置的效果。
- en: 'Finally, how do we stop everything? Follow these steps:'
  id: totrans-192
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后，我们如何停止一切？按照以下步骤操作：
- en: Stop Terminal `T1`. This avoids new messages from being sent by setting the
    speed at 1 rad/s.
  id: totrans-193
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 停止终端 `T1`。这通过将速度设置为 1 rad/s 来避免发送新消息。
- en: Stop Terminal `T3`. This cancels the speed commands of 2 rad/s. At this point,
    the robot only receives zero speed commands from the last Terminal. The robot
    has stopped, but ROS is still running some processes, although they're not visible
    as robot motions.
  id: totrans-194
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 停止终端`T3`。这将取消2弧度/秒的速度命令。此时，机器人只从最后一个终端接收零速度命令。机器人已经停止，但ROS仍在运行一些进程，尽管它们不是以机器人运动的形式可见。
- en: Stop Terminal `T4`. This makes sure that the gopigo3 node is now idle from any
    message that's published in the `/cmd_vel` topic.
  id: totrans-195
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 停止终端`T4`。这确保gopigo3节点现在对`/cmd_vel`主题发布的任何消息都是空闲的。
- en: You should check how `T2` (using the`$ rostopic echo /cmd_vel` command) stops
    providing updates. You can also kill this Terminal.
  id: totrans-196
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 你应该检查`T2`（使用`$ rostopic echo /cmd_vel`命令）是如何停止提供更新的。你也可以关闭这个终端。
- en: Try to think about what would happen if the first action you had made were to
    stop `T4`. Check this by applying the sequence to the physical robot and see what
    result you get.
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: 尝试思考如果你首先采取的行动是停止`T4`会发生什么。通过将序列应用于物理机器人并查看结果来检查这一点。
- en: In the next section, you will publish `geometry_msgs/Twist` messages in the`/cmd_vel` topic
    to find about what the actual *X*, *Y*, and *Z* axes of your robot are.
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一节中，你将在`/cmd_vel`主题中发布`geometry_msgs/Twist`消息，以了解你的机器人的实际*X*、*Y*和*Z*轴。
- en: Checking the X, Y, and Z axes of GoPiGo3
  id: totrans-199
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 检查GoPiGo3的X、Y和Z轴
- en: 'Now, you will apply what you have learned to practically find the *X*, *Y*,
    and *Z* axes of your robot and their positive and negative direction. Apply the
    following command in `T1` and make sure you''re ready with `T2` to stop it afterward
    to avoid the robot crashing into any obstacles:'
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，你将应用你所学的知识，实际找到机器人的*X*、*Y*和*Z*轴及其正负方向。在`T1`中应用以下命令，并确保你准备好在之后用`T2`停止它，以避免机器人撞到任何障碍物：
- en: '[PRE37]'
  id: totrans-201
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: 'You should see GoPiGo3 advancing forward, that is, the distance sensor facing
    forward while the caster wheel is facing back. For the negative *X* axis, change
    the sign of the linear speed:'
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: 你应该看到GoPiGo3向前移动，即距离传感器向前，而万向轮向后。对于负*X*轴，改变线性速度的符号：
- en: '[PRE38]'
  id: totrans-203
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: You should find that GoPiGo is now advancing backward, that is, the distance
    sensor is facing backward. To guess the direction of the remaining axis, *Y*,
    remember that, in the previous subsection, you checked that the rotation around
    the *Z* axis is positive when the robot rotates left (counter-clockwise). This
    means that the *Z* axis points up, to the ceiling. Since you have empirically
    found the orientation of the *X* and *Z* axes, you can easily infer that the Y
    axis points left.
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: 你应该发现GoPiGo现在正在向后移动，即距离传感器向后。要猜测剩余轴*Y*的方向，记得在先前的子节中，你检查了围绕*Z*轴的旋转在机器人向左旋转（逆时针）时是正的。这意味着*Z*轴向上，指向天花板。由于你已经通过经验找到了*X*和*Z*轴的朝向，你可以轻松推断出Y轴指向左侧。
- en: Why haven't we checked the *Z* axis with **rostopic pub**? You have a robot
    moving on a plane, that is, the floor. If you tried to apply a linear speed command
    for the *Z* axis, you will see nothing, because... well, GoPiGo3 cannot fly!
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: 为什么我们没有用**rostopic pub**检查*Z*轴？你有一个在平面上移动的机器人，即地板。如果你尝试为*Z*轴应用线性速度命令，你将什么也看不到，因为...好吧，GoPiGo3不能飞！
- en: It is left to you to deduce why a similar linear speed command for the *Y* axis
    will have no visible effect on GoPiGo3's motion.
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: 留给你去推断为什么类似的线性速度命令对GoPiGo3的运动没有可见的影响。
- en: Composing motions
  id: totrans-207
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 组合运动
- en: We have already learned how to find the actual X, Y, and Z axes of the robot.
    Go back to [Chapter 4](742e6846-70e4-4bd4-8576-f3e4f445df3f.xhtml), *Creating
    the Virtual Two-Wheeled ROS Robot*, the *Building a differential drive robot with
    URDF* section, if you need to remember how.
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经学习了如何找到机器人的实际X、Y和Z轴。如果你需要回忆如何做，请回到[第4章](742e6846-70e4-4bd4-8576-f3e4f445df3f.xhtml)，*创建虚拟双轮ROS机器人*，*使用URDF构建差速驱动机器人*部分。
- en: 'Keeping their orientations in mind, let''s design a more complex trajectory
    by combining both translation (linear *X*) and rotation (angular *Z*). The goal
    is to get GoPiGo3 to follow a circumferential path that has a 0.25 m radius at
    a speed of 45º/s:'
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
  zh: 在考虑它们的朝向的同时，让我们通过结合平移（线性*X*）和旋转（角度*Z*）来设计一个更复杂的轨迹。目标是让GoPiGo3以45º/s的速度沿着半径为0.25米的圆周路径行驶：
- en: The angular *Z* speed is 45º/s = 0.785 rad/s. We just need to change units from
    sexagesimal degrees to radians.
  id: totrans-210
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 角度*Z*速度是45º/s = 0.785弧度/秒。我们只需要将单位从六十进制的度数转换为弧度。
- en: The linear *X* speed can be obtained by multiplying the requested radius by
    the angular speed; that is, *0.25 m * 0.785 rad/s = 0.196 m*.
  id: totrans-211
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 线性 *X* 速度可以通过将请求的半径乘以角速度来获得；即，*0.25 m * 0.785 rad/s = 0.196 m*。
- en: 'Follows these steps to do so:'
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
  zh: 按照以下步骤进行：
- en: 'Apply these two values in a single `/cmd_vel` message:'
  id: totrans-213
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在单个`/cmd_vel`消息中应用这两个值：
- en: '[PRE39]'
  id: totrans-214
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: 'To stop this process, you can send a message where all six components are equal
    to zero:'
  id: totrans-215
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 要停止此过程，你可以发送一个消息，其中所有六个组件都等于零：
- en: '[PRE40]'
  id: totrans-216
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: This is an alternative `geometry_msgs/Twist` message syntax, in which you specify
    a three-component vector for linear speed (following the order *X*, *Y*, *Z*)
    and another vector with the three components of the angular speed (also in the
    order *X*, *Y*, *Z*).
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一个替代的`geometry_msgs/Twist`消息语法，其中你指定一个线性速度的三分量向量（按照顺序 *X*，*Y*，*Z*），以及一个包含角速度三个分量的向量（同样按照顺序
    *X*，*Y*，*Z*）。
- en: 'Finally, check how the superposition principle applies to motion composition
    by sending separate commands for the translation and rotation:'
  id: totrans-218
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后，通过发送分别针对平移和旋转的单独命令来检查叠加原理如何应用于运动合成：
- en: '[PRE41]'
  id: totrans-219
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: The command in `T1` makes GoPiGo3 move forward at 0.196 m/s. Then, the command
    in `T2` adds an angular motion of 0.785 rad/s, thereby producing the trajectory
    for GoPiGo3 to evolve from a straight line to a circumference of 0.25 m radius,
    as expected.
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
  zh: '`T1`中的命令使 GoPiGo3 以 0.196 m/s 的速度向前移动。然后，`T2`中的命令添加一个 0.785 rad/s 的角运动，从而产生
    GoPiGo3 从直线运动到半径为 0.25 m 的圆周轨迹的预期轨迹。'
- en: Stop the robot and shut down the Raspberry Pi. In the next section, we'll switch
    to the Gazebo simulation environment, so we will only need the laptop. We will
    return to the virtual model of GoPiGo3 at the point we left it in [Chapter 5](74284adc-e0d7-4e40-a54b-e2e447b8e2fe.xhtml),
    *Simulating the Robot Behavior with Gazebo*.
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
  zh: 停止机器人并关闭 Raspberry Pi。在下一节中，我们将切换到 Gazebo 模拟环境，因此我们只需要笔记本电脑。我们将在[第5章](74284adc-e0d7-4e40-a54b-e2e447b8e2fe.xhtml)中停止的地方返回
    GoPiGo3 的虚拟模型，*使用 Gazebo 模拟机器人行为*。
- en: Remotely controlling both physical and virtual robots
  id: totrans-222
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 远程控制物理和虚拟机器人
- en: Up to this point, you have dealt with a piece of configuration where the ROS
    master node ran in the robot. For the rest of this chapter, you will only be working
    with the laptop. Due to this, you need to revert your configuration so that the
    master node can be located again on the desktop computer. Otherwise, you will
    receive an error and won't be able to launch any ROS environment.
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，你已经处理了一个配置片段，其中 ROS 主节点在机器人上运行。对于本章的其余部分，你将只使用笔记本电脑。因此，你需要调整你的配置，以便主节点可以再次定位在台式计算机上。否则，你会收到错误，并且无法启动任何
    ROS 环境。
- en: Reverting the ROS master to the local computer
  id: totrans-224
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 将 ROS 主机还原到本地计算机
- en: 'The solution to this is pretty simple; just follow these steps:'
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
  zh: 解决这个问题很简单；只需遵循以下步骤：
- en: 'Open your local `.bashrc` file and comment the line at the end that specifies
    what URL to point to in order to find the ROS master:'
  id: totrans-226
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 打开你的本地`.bashrc`文件，并注释掉指定要指向以找到 ROS 主机的 URL 的最后一行：
- en: '[PRE42]'
  id: totrans-227
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: Be aware that, in place of `rosbot.local`, you should have your current hostname, `<your-hostname>.local`.
    Simply run `$ hostname` in a Terminal to recall it if you are in doubt and it
    hasn't been set correctly in your configuration file.
  id: totrans-228
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，在`rosbot.local`的位置，你应该使用你的当前主机名，`<your-hostname>.local`。如果你不确定，或者它还没有在你的配置文件中正确设置，只需在终端中运行`$
    hostname`来回忆它。
- en: 'Close all the Terminals, open a new one, and check the `ROS_MASTER_URI` variable:'
  id: totrans-229
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 关闭所有终端，打开一个新的终端，并检查`ROS_MASTER_URI`变量：
- en: '[PRE43]'
  id: totrans-230
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: You should find that the environment variable has reverted to the default server
    (localhost) and default port (`11311`). Now, we are ready to switch to the virtual
    robot.
  id: totrans-231
  prefs: []
  type: TYPE_NORMAL
  zh: 你应该发现环境变量已经恢复到默认服务器（localhost）和默认端口（`11311`）。现在，我们准备好切换到虚拟机器人。
- en: Simulating GoPiGo3 with Gazebo
  id: totrans-232
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用 Gazebo 模拟 GoPiGo3
- en: 'Recall the Gazebo simulation we performed in [Chapter 5](74284adc-e0d7-4e40-a54b-e2e447b8e2fe.xhtml),
    *Simulating the Robot Behavior with Gazebo*, in the *Launching the GoPiGo model
    in Gazebo* section. Its files have been included in the sample code for this chapter
    so that we can use them as a starting point. Now, follow these steps:'
  id: totrans-233
  prefs: []
  type: TYPE_NORMAL
  zh: 回想一下我们在[第5章](74284adc-e0d7-4e40-a54b-e2e447b8e2fe.xhtml)中进行的 Gazebo 模拟，*使用 Gazebo
    模拟机器人行为*部分。其文件已包含在本章的示例代码中，以便我们可以将它们作为起点。现在，按照以下步骤进行：
- en: 'Launch the Gazebo environment with the GoPiGo3 model:'
  id: totrans-234
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用 GoPiGo3 模型启动 Gazebo 环境：
- en: '[PRE44]'
  id: totrans-235
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: Although you may find that the launch filename is different from what it was
    in the code of [Chapter 5](74284adc-e0d7-4e40-a54b-e2e447b8e2fe.xhtml), *Simulating
    the Robot Behavior with Gazebo*, its content is exactly the same, that is, `gopigo_gazebo.launch`.
  id: totrans-236
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管你可能发现启动文件名与[第5章](74284adc-e0d7-4e40-a54b-e2e447b8e2fe.xhtml)中“使用Gazebo模拟机器人行为”的代码中的文件名不同，但其内容完全相同，即`gopigo_gazebo.launch`。
- en: 'Then, in another Terminal, list the relevant topics:'
  id: totrans-237
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后，在另一个终端中列出相关主题：
- en: '[PRE45]'
  id: totrans-238
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: All the new ones correspond to Gazebo nodes.
  id: totrans-239
  prefs: []
  type: TYPE_NORMAL
  zh: 所有新的主题都对应于Gazebo节点。
- en: 'In particular, the `/clock` topic is where Gazebo publishes timestamps, thus
    allowing for a system with simulation-synchronized time. The parameter definition
    within the `spawn.launch` file for `/clock` is as follows:'
  id: totrans-240
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 特别是，`/clock`主题是Gazebo发布时间戳的地方，从而允许具有模拟同步时间系统的存在。`spawn.launch`文件中`/clock`的参数定义如下：
- en: '[PRE46]'
  id: totrans-241
  prefs: []
  type: TYPE_PRE
  zh: '[PRE46]'
- en: 'The `use_sim_time` parameter asks ROS to simulate a clock whose timestamps
    are published on `/clock`. You can inspect the topic and its message type as usual:'
  id: totrans-242
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`use_sim_time`参数请求ROS模拟一个时钟，其时间戳在`/clock`上发布。你可以像往常一样检查主题及其消息类型：'
- en: '[PRE47]'
  id: totrans-243
  prefs: []
  type: TYPE_PRE
  zh: '[PRE47]'
- en: The clock message type belongs to the `rosgraph_msgs` package. Take a look at
    the following link to find out more about this package: [http://wiki.ros.org/rosgraph_msgs](http://wiki.ros.org/rosgraph_msgs).
  id: totrans-244
  prefs: []
  type: TYPE_NORMAL
  zh: 时钟消息类型属于`rosgraph_msgs`包。查看以下链接了解更多关于此包的信息：[http://wiki.ros.org/rosgraph_msgs](http://wiki.ros.org/rosgraph_msgs)。
- en: Now that we've set up the environment, we can add a virtual controller that
    will allow us to control GoPiGo3 inside Gazebo in the same way we did before with
    the physical robot.
  id: totrans-245
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经设置了环境，我们可以添加一个虚拟控制器，这将允许我们以与之前使用物理机器人相同的方式在Gazebo中控制GoPiGo3。
- en: Adding the controller to the Gazebo model of the robot
  id: totrans-246
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 将控制器添加到机器人的Gazebo模型中
- en: Here, we are going to use a mechanism called **controller** to transform speed
    `/cmd_vel` messages into motions for the left and right wheels of the robot. For
    the case of a two-wheeled robot, this is known as a **differential drive controller**.
    This name is due to the fact that straight paths are achieved by rotating the
    wheels at the same speed. Any difference between the left and right angular speeds
    will make the robot describe a circumferential path. The larger the difference,
    the lower the radius of such a circumference (a straight path corresponds to describing
    a sector of a circumference of infinite radius, that is, the infinitesimal speed
    difference between wheels).
  id: totrans-247
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们将使用一个名为**控制器**的机制，将速度`/cmd_vel`消息转换为机器人的左右轮的运动。对于两轮机器人的情况，这被称为**差速驱动控制器**。这个名字是因为通过以相同的速度旋转车轮来实现直线路径。左右角速度之间的任何差异都会使机器人描述一个圆周路径。差异越大，这样的圆的半径就越小（直线路径对应于描述一个无限半径的圆的扇形，即车轮之间无限小的速度差异）。
- en: 'Let''s get to the practical part:'
  id: totrans-248
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们进入实际部分：
- en: 'To include the differential drive controller in your model of the robot, add
    the following snippet inside the `<robot>` tag of the `urdf/gopigo.gazebo` file:'
  id: totrans-249
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 要将差速驱动控制器包含到你的机器人模型中，请将以下片段添加到`urdf/gopigo.gazebo`文件的`<robot>`标签内：
- en: '[PRE48]'
  id: totrans-250
  prefs: []
  type: TYPE_PRE
  zh: '[PRE48]'
- en: 'You must set these correspondences, as defined in the URDF model of your robot:'
  id: totrans-251
  prefs: []
  type: TYPE_NORMAL
  zh: 你必须设置这些对应关系，这些对应关系定义在你的机器人URDF模型中：
- en: '`<robotBaseFrame>` to `base_link`'
  id: totrans-252
  prefs:
  - PREF_UL
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`<robotBaseFrame>`对应于`base_link`'
- en: '`<leftJoint>` to `joint_left_wheel`'
  id: totrans-253
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`<leftJoint>`对应于`joint_left_wheel`'
- en: '`<rightJoint>` to `joint_right_wheel`'
  id: totrans-254
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`<rightJoint>`对应于`joint_right_wheel`'
- en: The `<torque>` tag is where you specify the maximum torque each can exert. This
    is all you need to know to carry out the experiment we suggested in [Chapter 5](74284adc-e0d7-4e40-a54b-e2e447b8e2fe.xhtml),
    *Simulating the Robot Behavior with Gazebo, *in the last section, entitled *Guidelines
    for tuning the Gazebo model*.
  id: totrans-255
  prefs: []
  type: TYPE_NORMAL
  zh: '`<torque>`标签是您指定每个可以施加的最大扭矩的地方。这就是您需要了解的，以便执行我们在[第5章](74284adc-e0d7-4e40-a54b-e2e447b8e2fe.xhtml)中建议的实验，即“使用Gazebo模拟机器人行为”章节的最后部分，“调整Gazebo模型的指南”。'
- en: 'Notice how you tell the controller what topics it will receive the motion commands
    in by setting the `<commandTopic>` tag to the ROS `/cmd_vel` topic:'
  id: totrans-256
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 注意你是如何通过将`<commandTopic>`标签设置为ROS的`/cmd_vel`主题来告诉控制器它将接收哪些运动命令的：
- en: '[PRE49]'
  id: totrans-257
  prefs: []
  type: TYPE_PRE
  zh: '[PRE49]'
- en: 'Then, stop and relaunch Gazebo to find the new features that the differential
    drive provides to the simulation:'
  id: totrans-258
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后，停止并重新启动Gazebo以找到差速驱动为模拟提供的新的功能：
- en: '[PRE50]'
  id: totrans-259
  prefs: []
  type: TYPE_PRE
  zh: '[PRE50]'
- en: 'There are two new topics, `/cmd_vel` and `/tf`:'
  id: totrans-260
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 有两个新的主题，`/cmd_vel`和`/tf`：
- en: '[PRE51]'
  id: totrans-261
  prefs: []
  type: TYPE_PRE
  zh: '[PRE51]'
- en: 'Remember from the previous section that we controlled the physical GoPiGo3
    with the `/cmd_vel` topic. Following the same steps, you can teleoperate the virtual
    robot with the keyboard (arrow keys):'
  id: totrans-262
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 记住从上一节中我们使用`/cmd_vel`主题控制物理GoPiGo3。按照相同的步骤，你可以使用键盘（箭头键）进行遥操作虚拟机器人：
- en: '[PRE52]'
  id: totrans-263
  prefs: []
  type: TYPE_PRE
  zh: '[PRE52]'
- en: Make sure you are on the window where you launched `T2` so that any keystrokes
    are caught and you can see the effect they have on the robot in Gazebo.
  id: totrans-264
  prefs: []
  type: TYPE_NORMAL
  zh: 确保你处于启动`T2`的窗口，这样任何按键都会被捕获，你可以在Gazebo中看到它们对机器人产生的影响。
- en: 'Visualize the ROS graph with `T3 $ rqt_graph`. You should obtain the result
    shown in the following diagram:'
  id: totrans-265
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用`T3 $ rqt_graph`可视化ROS图。你应该获得以下图中所示的结果：
- en: '![](img/bca82557-588a-49bf-aa55-e7bf67e66a6e.png)'
  id: totrans-266
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/bca82557-588a-49bf-aa55-e7bf67e66a6e.png)'
- en: As before, the topic that's remapping `/key_vel:=/cmd_vel` in the `T2` Terminal
    allows the virtual robot to be controlled with the arrow keys.
  id: totrans-267
  prefs: []
  type: TYPE_NORMAL
  zh: 和之前一样，`T2`终端中重映射`/key_vel:=/cmd_vel`的主题允许使用箭头键控制虚拟机器人。
- en: Finally, we are going to join the physical and the virtual robot in the same
    ROS environment.
  id: totrans-268
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们将把物理机器人和虚拟机器人在同一个ROS环境中连接起来。
- en: Real-world and simulation at once
  id: totrans-269
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 同时进行现实世界和模拟
- en: 'Since we will be working with the robot, we need to specify the ROS master
    in the laptop so that it''s pointing to GoPiGo3\. To do so, uncomment the following
    line in your local `.bashrc` file to switch back to that configuration:'
  id: totrans-270
  prefs: []
  type: TYPE_NORMAL
  zh: 由于我们将与机器人一起工作，我们需要在笔记本电脑上指定ROS主节点，使其指向GoPiGo3。为此，在本地`.bashrc`文件中取消以下行的注释以切换回该配置：
- en: '[PRE53]'
  id: totrans-271
  prefs: []
  type: TYPE_PRE
  zh: '[PRE53]'
- en: 'Instead of killing the rest of the bash Terminals, you can reload the updated
    `.bashrc` in each of them:'
  id: totrans-272
  prefs: []
  type: TYPE_NORMAL
  zh: 你不需要关闭其他bash终端，你可以在每个终端中重新加载更新的`.bashrc`：
- en: '[PRE54]'
  id: totrans-273
  prefs: []
  type: TYPE_PRE
  zh: '[PRE54]'
- en: 'Now, you are ready to execute ROS with both versions of GoPiGo3:'
  id: totrans-274
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，你可以使用两种版本的GoPiGo3执行ROS：
- en: 'First, launch the robot:'
  id: totrans-275
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 首先，启动机器人：
- en: '[PRE55]'
  id: totrans-276
  prefs: []
  type: TYPE_PRE
  zh: '[PRE55]'
- en: 'Then, launch the rest of the ROS environment on the laptop. First, launch the
    keyboard control:'
  id: totrans-277
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后，在笔记本电脑上启动剩余的ROS环境。首先，启动键盘控制：
- en: '[PRE56]'
  id: totrans-278
  prefs: []
  type: TYPE_PRE
  zh: '[PRE56]'
- en: 'Next, launch the virtual model:'
  id: totrans-279
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，启动虚拟模型：
- en: '[PRE57]'
  id: totrans-280
  prefs: []
  type: TYPE_PRE
  zh: '[PRE57]'
- en: 'Finally, check the ROS graph:'
  id: totrans-281
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后，检查ROS图：
- en: '[PRE58]'
  id: totrans-282
  prefs: []
  type: TYPE_PRE
  zh: '[PRE58]'
- en: 'If everything went well, you should see the following familiar graph:'
  id: totrans-283
  prefs: []
  type: TYPE_NORMAL
  zh: 如果一切顺利，你应该看到以下熟悉的图：
- en: '![](img/1196fb4d-fc0c-4c20-b109-e048075edbd4.png)'
  id: totrans-284
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/1196fb4d-fc0c-4c20-b109-e048075edbd4.png)'
- en: This states that you should be able to simultaneously control the physical robot
    (the `gopigo3` node) and the virtual robot (the `gazebo` node) with the same keystrokes
    (the `key_teleop` node).
  id: totrans-285
  prefs: []
  type: TYPE_NORMAL
  zh: 这表示你应该能够同时使用相同的按键（`key_teleop`节点）控制物理机器人（`gopigo3`节点）和虚拟机器人（`gazebo`节点）。
- en: Check teleoperation by clicking the left or right arrow key of the laptop keyboard.
    Both the physical and virtual GoPiGo3 will rotate at the same time. A similar
    result will be obtained if you press the *up* or *down* arrow keys.
  id: totrans-286
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 通过点击笔记本电脑键盘的左右箭头键检查遥操作。物理和虚拟GoPiGo3将同时旋转。如果你按下*上*或*下*箭头键，也会得到类似的结果。
- en: For the keystrokes to be effective, you need to have selected the Terminal window
    where you launched the `key_teleop.py` node, that is, `T2`.
  id: totrans-287
  prefs: []
  type: TYPE_NORMAL
  zh: 为了使按键有效，你需要选择启动`key_teleop.py`节点的终端窗口，即`T2`。
- en: Congratulations – you have successfully completed a whole tour of how to control
    a robot in ROS!
  id: totrans-288
  prefs: []
  type: TYPE_NORMAL
  zh: 恭喜你——你已经成功完成了一次如何使用ROS控制机器人的全程之旅！
- en: Summary
  id: totrans-289
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 概述
- en: In this chapter, you have achieved correspondence between the physical GoPiGo3
    and its virtual model in Gazebo. You have checked how it doesn't matter whether
    you're controlling the actual robot or a virtual robot from the point of view
    of ROS. Since both are moved using the same topic, `/cmd_vel`, ROS does not care
    about which type of robot you're dealing with.
  id: totrans-290
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，你已经在物理GoPiGo3和其在Gazebo中的虚拟模型之间建立了对应关系。你已经检查了从ROS的角度来看，控制实际机器人或虚拟机器人并没有区别。因为两者都是使用相同的主题`/cmd_vel`移动，ROS不会关心你处理的是哪种类型的机器人。
- en: This fact explains how, from the point of view of ROS, you have the choice to
    test your code with a virtual robot and then safely apply it to the physical robot.
    We just need to launch the ROS node of the physical robot. This is useful in three
    situations. First, when you are developing a new application for an existing robot,
    you can debug the code with a virtual model in Gazebo. Second, when you do not
    have available the hardware of the robot – because you are still deciding which
    one to buy – you can virtually play and test the robot prior to the buy decision.
    And third, when you are designing a new robot, you have the choice of launching
    its mechanical design and software development in parallel. When you do this,
    the developed code will send feedback to your mechanical design before carrying
    out any manufacturing activities. This iterative loop should benefit the final
    product by cutting its development costs.
  id: totrans-291
  prefs: []
  type: TYPE_NORMAL
  zh: 这个事实解释了从ROS的角度来看，你可以选择用虚拟机器人测试你的代码，然后安全地将其应用到物理机器人上。我们只需要启动物理机器人的ROS节点。这在三种情况下很有用。首先，当你为现有的机器人开发新应用程序时，你可以用Gazebo中的虚拟模型进行代码调试。其次，当你没有可用的机器人硬件时——因为你还在决定购买哪一款——你可以在购买决定之前虚拟地玩耍和测试机器人。第三，当你设计新机器人时，你可以选择并行启动其机械设计和软件开发。当你这样做时，开发的代码将在进行任何制造活动之前向你的机械设计发送反馈。这个迭代循环应该通过降低开发成本来使最终产品受益。
- en: 'In the next chapter, you will tackle the first autonomous task of the robot:
    to make it aware of its environment and be able to navigate to reach a predefined
    destination. These tasks will introduce you to the **Simultaneous Localization
    and Mapping** (**SLAM**) technique, an algorithm that''s intensively used in all
    kinds of autonomous vehicles, especially in self-driving cars.'
  id: totrans-292
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章中，你将面对机器人的第一个自主任务：让它意识到其环境，并能够导航到达预定义的目的地。这些任务将向你介绍**同时定位与建图**（**SLAM**）技术，这是一种在所有类型的自主车辆中广泛使用的算法，尤其是在自动驾驶汽车中。
- en: Questions
  id: totrans-293
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 问题
- en: If you need to have two different computers communicating over ROS, where should
    you locate the ROS master node?
  id: totrans-294
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果你需要让两台不同的计算机通过ROS进行通信，你应该将ROS主节点放在哪里？
- en: A) In the one that has the more recent version of ROS.
  id: totrans-295
  prefs: []
  type: TYPE_NORMAL
  zh: A) 在拥有更新版本ROS的那个上。
- en: B) The ROS master node will run in the first one where you launch the `roscore`
    process.
  id: totrans-296
  prefs: []
  type: TYPE_NORMAL
  zh: B) ROS主节点将在你启动`roscore`进程的第一个计算机上运行。
- en: C) You can place the master wherever you want. In one of the computers, you
    run `roscore`, and in the other one, you tell ROS that the master node is located
    in the other machine.
  id: totrans-297
  prefs: []
  type: TYPE_NORMAL
  zh: C) 你可以将主节点放在你想要的位置。在一台计算机上运行`roscore`，在另一台计算机上，你告诉ROS主节点位于另一台机器上。
- en: You have a physical robot named `mazinger_zeta` that accepts `geometry_msgs/Twist`
    messages in the `/walk` topic. What is the correct topic remapping command for
    remotely controlling the robot with the keyboard?
  id: totrans-298
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 你有一个名为`mazinger_zeta`的物理机器人，它接受`/walk`主题中的`geometry_msgs/Twist`消息。使用键盘远程控制机器人时，正确的主题重映射命令是什么？
- en: A) `rosrun key_teleop key_teleop.py /walk:=/cmd_vel`
  id: totrans-299
  prefs: []
  type: TYPE_NORMAL
  zh: A) `rosrun key_teleop key_teleop.py /walk:=/cmd_vel`
- en: B)**` rosrun key_teleop key_teleop.py /key_vel:=/walk`**
  id: totrans-300
  prefs: []
  type: TYPE_NORMAL
  zh: B)**`rosrun key_teleop key_teleop.py /key_vel:=/walk`**
- en: C) `rosrun key_teleop key_teleop.py /walk:=/key_vel`
  id: totrans-301
  prefs: []
  type: TYPE_NORMAL
  zh: C) `rosrun key_teleop key_teleop.py /walk:=/key_vel`
- en: If you apply a speed command of 1 m/s to the *Y* axis, how will it move GoPiGo3?
  id: totrans-302
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果你将1 m/s的速度命令应用到*Y*轴，GoPiGo3会如何移动？
- en: A) The robot will move left at 1 m/s
  id: totrans-303
  prefs: []
  type: TYPE_NORMAL
  zh: A) 机器人将向左以1 m/s的速度移动
- en: B) Nothing will happen
  id: totrans-304
  prefs: []
  type: TYPE_NORMAL
  zh: B) 不会发生任何事情
- en: C) You need to specify a publishing frequency so that the command takes effect
  id: totrans-305
  prefs: []
  type: TYPE_NORMAL
  zh: C) 你需要指定一个发布频率，以便命令生效
- en: What visible effect does this command have on the physical robot?
  id: totrans-306
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 这个命令对物理机器人有什么可见的影响？
- en: '[PRE59]'
  id: totrans-307
  prefs: []
  type: TYPE_PRE
  zh: '[PRE59]'
- en: A) It will rotate at the maximum possible speed since this is lower than 90
    radians/seconds.
  id: totrans-308
  prefs: []
  type: TYPE_NORMAL
  zh: A) 它将以最大可能的速度旋转，因为这是低于90弧度/秒的。
- en: B) GoPiGo3 cannot move at such a large angular speed.
  id: totrans-309
  prefs: []
  type: TYPE_NORMAL
  zh: B) GoPiGo3不能以如此大的角速度移动。
- en: C) Since it exceeds the maximum speed that GoPiGo3 can handle, the robot will
    stay still.
  id: totrans-310
  prefs: []
  type: TYPE_NORMAL
  zh: C) 由于它超过了GoPiGo3能处理的最大速度，机器人将保持静止。
- en: If you're controlling GoPiGo3 and the virtual robot with the keyboard simultaneously,
    what difference will you appreciate if you tell both of them to rotate at π rad/s
    every 2 seconds?
  id: totrans-311
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果你同时用键盘控制GoPiGo3和虚拟机器人，如果你告诉它们每2秒旋转π弧度，你会注意到什么区别？
- en: A) Both will do a complete turn of 360º.
  id: totrans-312
  prefs: []
  type: TYPE_NORMAL
  zh: A) 它们都会完成一个360º的完整转弯。
- en: B) The virtual robot will rotate 360º but the physical robot will not complete
    the turn since there is the opposing force of the friction of the wheels against
    the floor.
  id: totrans-313
  prefs: []
  type: TYPE_NORMAL
  zh: B) 虚拟机器人将旋转360度，但物理机器人不会完成整个转弯，因为车轮与地板之间的摩擦力会产生相反的力。
- en: C) The virtual robot will do exactly 360º, but the physical robot won't because
    of the wheel encoder's limited precision.
  id: totrans-314
  prefs: []
  type: TYPE_NORMAL
  zh: C) 虚拟机器人将精确旋转360度，但物理机器人不会，因为轮编码器的精度有限。
- en: Further reading
  id: totrans-315
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 进一步阅读
- en: ROS networking and time synchronization: [http://wiki.ros.org/ROS/NetworkSetup](http://wiki.ros.org/ROS/NetworkSetup)
  id: totrans-316
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: ROS网络和时序同步：[http://wiki.ros.org/ROS/NetworkSetup](http://wiki.ros.org/ROS/NetworkSetup)
- en: '*ROS Robot Programming: A handbook Written by TurtleBot3 Developers*, YoonSeok
    Pyo, HanCheol Cho, RyuWoon Jung, TaeHoon Lim (2017), ROBOTIS Co. Ltd, 1st edition: [http://www.pishrobot.com/wp-content/uploads/2018/02/ROS-robot-programming-book-by-turtlebo3-developers-EN.pdf](http://www.pishrobot.com/wp-content/uploads/2018/02/ROS-robot-programming-book-by-turtlebo3-developers-EN.pdf),
    Chapter: *Mobile Robots*'
  id: totrans-317
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*《ROS机器人编程：由TurtleBot3开发者编写的手册》*，YoonSeok Pyo，HanCheol Cho，RyuWoon Jung，TaeHoon
    Lim（2017），ROBOTIS Co. Ltd，第1版：[http://www.pishrobot.com/wp-content/uploads/2018/02/ROS-robot-programming-book-by-turtlebo3-developers-EN.pdf](http://www.pishrobot.com/wp-content/uploads/2018/02/ROS-robot-programming-book-by-turtlebo3-developers-EN.pdf)，章节：*移动机器人*'
- en: 'Integrating sonar and IR sensor plugins into the robot model in Gazebo with
    ROS: [https://medium.com/teamarimac/integrating-sonar-and-ir-sensor-plugin-to-robot-model-in-gazebo-with-ros-656fd9452607](https://medium.com/teamarimac/integrating-sonar-and-ir-sensor-plugin-to-robot-model-in-gazebo-with-ros-656fd9452607)'
  id: totrans-318
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在Gazebo中使用ROS将声纳和红外传感器插件集成到机器人模型中：[https://medium.com/teamarimac/integrating-sonar-and-ir-sensor-plugin-to-robot-model-in-gazebo-with-ros-656fd9452607](https://medium.com/teamarimac/integrating-sonar-and-ir-sensor-plugin-to-robot-model-in-gazebo-with-ros-656fd9452607)
