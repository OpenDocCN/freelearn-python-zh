["```py\nProject-name\n|-- src\n|   -- __init__.py\n|   -- myadd/myadd.py \n|-- tests\n|   -- __init__.py\n|   -- tests_myadd/test_myadd1.py \n|   -- tests_myadd/test_myadd2.py\n|-- README.md\n```", "```py\n# myadd.py with add two numbers\ndef add(x, y):\n    \"\"\"This function adds two numbers\"\"\"\n    return x + y\n```", "```py\n#test_myadd1.py test suite for myadd function\nimport unittest\nfrom myunittest.src.myadd.myadd import add\nclass MyAddTestSuite(unittest.TestCase):\ndef test_add1(self):\n    \"\"\" test case to validate two positive numbers\"\"\"\n    self.assertEqual(15, add(10 , 5), \"should be 15\")\ndef test_add2(self):\n    \"\"\" test case to validate positive and negative \\\n     numbers\"\"\"\n    self.assertEqual(5, add(10 , -5), \"should be 5\")\ndef test_add3(self):\n    \"\"\" test case to validate positive and negative \\\n     numbers\"\"\"\n    self.assertEqual(-5, add(-10 , 5), \"should be -5\")\ndef test_add4(self):\n    \"\"\" test case to validate two negative numbers\"\"\"\n    self.assertEqual(-15, add(-10 , -5), \"should be -15\")\nif __name__ == '__main__':\n    unittest.main()\n```", "```py\n# myadd2.py is a class with add two numbers method\nclass MyAdd:\n    def add(self, x, y):\n        \"\"\"This function adds two numbers\"\"\"\n        if (not isinstance(x, (int, float))) | \\\n                (not isinstance(y, (int, float))) :\n            raise TypeError(\"only numbers are allowed\")\n        return x + y\n```", "```py\n#test_myadd2.py test suite for myadd2 class method\nimport unittest\nfrom myunittest.src.myadd.myadd2 import MyAdd\nclass MyAddTestSuite(unittest.TestCase):\n    def setUp(self):\n        self.myadd = MyAdd()\n    def tearDown(self):\n        del (self.myadd)\n    def test_add1(self):\n       \"\"\" test case to validate two positive numbers\"\"\"\n       self.assertEqual(15, self.myadd.add(10 , 5), \\\n        \"should be 15\")\n    def test_add2(self):\n        \"\"\" test case to validate positive and negative           numbers\"\"\"\n        self.assertEqual(5, self.myadd.add(10 , -5), \\\n         \"should be 5\")\n#test_add3 and test_add4 are skipped as they are very \\\n same as test_add1 and test_add2\n```", "```py\n#test_myadd3.py test suite for myadd2 class method to validate errors\nimport unittest\nfrom myunittest.src.myadd.myadd2 import MyAdd\nclass MyAddTestSuite(unittest.TestCase):\n    def setUp(self):\n        self.myadd = MyAdd()\n    def test_typeerror1(self):\n        \"\"\" test case to check if we can handle non \\\n         number input\"\"\"\n        self.assertRaises(TypeError, self.myadd.add, \\\n         'a' , -5)\n    def test_typeerror2(self):\n        \"\"\" test case to check if we can handle non \\\n         number input\"\"\"\n        self.assertRaises(TypeError, self.myadd.add, \\\n         'a' , 'b')\n```", "```py\n# mycalc.py with add, subtract, multiply and divide functions\nclass MyCalc:\n    def add(self, x, y):\n        \"\"\"This function adds two numbers\"\"\"\n        return x + y\n    def subtract(self, x, y):\n        \"\"\"This function subtracts two numbers\"\"\"\n        return x - y\n    def multiply(self, x, y):\n        \"\"\"This function subtracts two numbers\"\"\"\n        return x * y\n    def divide(self, x, y):\n        \"\"\"This function subtracts two numbers\"\"\"\n        return x / y\n```", "```py\n# test_mycalc_add.py test suite for add class method\nimport unittest\nfrom myunittest.src.mycalc.mycalc import MyCalc\nclass MyCalcAddTestSuite(unittest.TestCase):\n    def setUp(self):\n        self.calc = MyCalc()\n    def test_add(self):\n        \"\"\" test case to validate two positive numbers\"\"\"\n        self.assertEqual(15, self.calc.add(10, 5), \\\n         \"should be 15\")\n```", "```py\n#test_mycalc_subtract.py test suite for subtract class method\nimport unittest\nfrom myunittest.src.mycalc.mycalc import MyCalc\nclass MyCalcSubtractTestSuite(unittest.TestCase):\n    def setUp(self):\n        self.calc = MyCalc()\n    def test_subtract(self):\n        \"\"\" test case to validate two positive numbers\"\"\"\n        self.assertEqual(5, self.calc.subtract(10,5), \\\n         \"should be 5\")\n```", "```py\n#test_mycalc_multiply.py test suite for multiply class method\nimport unittest\nfrom myunittest.src.mycalc.mycalc import MyCalc\nclass MyCalcMultiplyTestSuite(unittest.TestCase):\n    def setUp(self):\n        self.calc = MyCalc()\n    def test_multiply(self):\n        \"\"\" test case to validate two positive numbers\"\"\"\n        self.assertEqual(50, self.calc.multiply(10, 5), \"should           be 50\")\n```", "```py\n#test_mycalc_divide.py test suite for divide class method\nimport unittest\nfrom myunittest.src.mycalc.mycalc import MyCalc\nclass MyCalcDivideTestSuite(unittest.TestCase):\n    def setUp(self):\n        self.calc = MyCalc()\n    def test_divide(self):\n        \"\"\" test case to validate two positive numbers\"\"\"\n        self.assertEqual(2, self.calc.divide(10 , 5), \\\n         \"should be 2\")\n```", "```py\npython -m unittest discover myunittest/tests/tests_mycalc\n```", "```py\nimport unittest\nfrom test_mycalc_add import MyCalcAddTestSuite\nfrom test_mycalc_subtract import MyCalcSubtractTestSuite\nfrom test_mycalc_multiply import MyCalcMultiplyTestSuite\nfrom test_mycalc_divide import MyCalcDivideTestSuite\ndef run_mytests():\n    test_classes = [MyCalcAddTestSuite, \\\n      MyCalcSubtractTestSuite,\\\n      MyCalcMultiplyTestSuite,MyCalcDivideTestSuite ]\n    loader = unittest.TestLoader()\n    test_suites = []\n    for t_class in test_classes:\n        suite = loader.loadTestsFromTestCase(t_class)\n        test_suites.append(suite)\n    final_suite = unittest.TestSuite(test_suites)\n    runner = unittest.TextTestRunner()\n    results = runner.run(final_suite)\n\nif __name__ == '__main__':\n    run_mytests()\n```", "```py\n# myadd3.py is a class with add two numbers method\ndef add(self, x, y):\n    \"\"\"This function adds two numbers\"\"\"\n    if (not isinstance(x, (int, float))) | \\\n            (not isinstance(y, (int, float))):\n        raise TypeError(\"only numbers are allowed\")\n    return x + y\n```", "```py\n#test_myadd3.py test suite for myadd function\nimport pytest\nfrom mypytest.src.myadd3 import add\ndef test_add1():\n    \"\"\" test case to validate two positive numbers\"\"\"\n    assert add(10, 5) == 15\"\ndef test_add2():\n    \"\"\" test case to validate two positive numbers\"\"\"\n    assert add(10, -5) == 5, \"should be 5\"\n```", "```py\ntest_myadd3.py::test_add1 PASSED                         [25%]\ntest_myadd3.py::test_add2 PASSED                         [50%]\ntest_myadd3.py::test_add3 PASSED                         [75%]\ntest_myadd3.py::test_add4 PASSED                         [100%]\n===================== 4 passed in 0.03s =======================\n```", "```py\ndef test_typeerror1():\n    \"\"\" test case to check if we can handle non number \\\n     input\"\"\"\n    with pytest.raises(TypeError):\n        add('a', 5)\ndef test_typeerror2():\n    \"\"\" test case to check if we can handle non number \\\n      input\"\"\"\n    with pytest.raises(TypeError, match=\"only numbers are \\\n     allowed\"):\n        add('a', 'b')\n```", "```py\n@pytest.mark.skip\ndef test_add1():\n    \"\"\" test case to validate two positive numbers\"\"\"\n    assert add(10, 5) == 15\n@pytest.mark.skipif(sys.version_info > (3,6),\\ \nreason=\" skipped for release > than Python 3.6\")\ndef test_add2():\n    \"\"\" test case to validate two positive numbers\"\"\"\n    assert add(10, -5) == 5, \"should be 5\"\n@pytest.mark.xfail(sys.platform == \"win32\", \\\nreason=\"ignore exception for windows\")\ndef test_add3():\n    \"\"\" test case to validate two positive numbers\"\"\"\n    assert add(-10, 5) == -5\n    raise Exception()\n```", "```py\ntest_myadd4.py::test_add1 SKIPPED (unconditional skip)   [33%]\nSkipped: unconditional skip\ntest_myadd4.py::test_add2 SKIPPED ( skipped for release > than Pytho...)                                                [66%]\nSkipped:  skipped for release > than Python 3.6\ntest_myadd4.py::test_add3 XFAIL (ignore exception for mac)                                                    [100%]\n@pytest.mark.xfail(sys.platform == \"win32\",\n                       reason=\"ignore exception for mac\")\n============== 2 skipped, 1 xfailed in 0.06s =================\n```", "```py\n# test_myadd5.py test suite using parameterize marker\nimport sys\nimport pytest\nfrom mypytest.src.myadd3 import add\n@pytest.mark.parametrize(\"x,y,ans\",\n                         [(10,5,15),(10,-5,5),\n                          (-10,5,-5),(-10,-5,-15)],\n                         ids=[\"pos-pos\",\"pos-neg\",\n                              \"neg-pos\", \"neg-neg\"])\ndef test_add(x, y, ans):\n    \"\"\" test case to validate two positive numbers\"\"\"\n    assert add(x, y) == ans\n```", "```py\ntest_myadd5.py::test_add[pos-pos] PASSED                 [ 25%]\ntest_myadd5.py::test_add[pos-neg] PASSED                 [ 50%]\ntest_myadd5.py::test_add[neg-pos] PASSED                 [ 75%]\ntest_myadd5.py::test_add[neg-neg] PASSED                 [100%]\n=============== 4 passed in 0.04s ================= \n```", "```py\n# test_mycalc1.py test calc functions using test fixture\nimport sys\nimport pytest\nfrom mypytest.src.myadd3 import add\nfrom mypytest.src.mycalc import MyCalc\n@pytest.fixture(scope=\"module\")\ndef my_calc():\n    return MyCalc()\n@pytest.fixture\ndef test_data ():\n    return {'x':10, 'y':5}\ndef test_add(my_calc, test_data):\n    \"\"\" test case to add two numbers\"\"\"\n    assert my_calc.add(test_data.get('x'),\\\n      test_data.get('y')) == 15\ndef test_subtract(my_calc, test_data):\n    \"\"\" test case to subtract two numbers\"\"\"\n    assert my_calc.subtract(test_data.get('x'), \\\n     test_data.get('y'))== 5\n```", "```py\n# test_mycalc2.py test calc functions using test fixture\n<import statements>\n@pytest.fixture(scope=\"module\")\ndef my_calc():\n    my_calc = MyCalc()\n    yield my_calc\n    del my_calc\n@pytest.fixture\ndef data_set(request):\n    dict = {'x':10, 'y':5}\n    def delete_dict(obj):\n        del obj\n    request.addfinalizer(lambda: delete_dict(dict))\n    return dict\n<rest of the test cases>\n```"]