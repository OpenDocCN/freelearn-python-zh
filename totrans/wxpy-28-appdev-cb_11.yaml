- en: Chapter 11. Using Threads and Timers to Create Responsive Interfaces
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In this chapter, we will cover:'
  prefs: []
  type: TYPE_NORMAL
- en: Non-Blocking GUI
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Understanding thread safety
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Threading tools
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Using Timers
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Capturing output
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Introduction
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: It's all too familiar and an annoying issue when you are using an application
    and click on some button or control only to find that the application's UI all
    of a sudden appears to stop responding, the busy cursor shows up, and you are
    left there wondering if the application is still working, or if it has locked
    up and needs to be forced quit. This unpleasant experience is almost always the
    result of a function or action that takes a considerable amount of time to return
    after being called. If this function or action is called on the same thread that
    the GUI objects live on, it will block all the code that is running in the background
    and that is managing the GUI, leading to this locked up and unresponsive interface.
  prefs: []
  type: TYPE_NORMAL
- en: Being able to design an application in a way that prevents this situation from
    being presented to its users requires additional considerations in comparison
    to most traditional procedural approaches. This chapter explores this problem
    by providing solutions, and hopefully all the tools necessary, to build highly-responsive,
    multi-threaded applications in wxPython.
  prefs: []
  type: TYPE_NORMAL
- en: Non-Blocking GUI
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this recipe, we explore what a responsive interface is and try to gain a
    good understanding of what the problem is that the other recipes in this chapter
    will provide solutions to. The recipe creates a simple application with two buttons.
    Each button will perform exactly the same task. However, the way in which the
    application responds and provides feedback to the user after the button is clicked
    will differ greatly between the two buttons, due to how the control flow is carried
    out.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'To illustrate the issue at hand, we will create a simple Fibonacci number calculator
    application. First, we will begin by defining a Thread class and the function
    that will be used to calculate the Nth Fibonacci number:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'Now let''s create the user interface for our Fibonacci number calculator:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: 'Here, in the `Panel`, is where most of the action will be taking place in this
    example. Here we lay out a simple interface with an input field and an output
    field, two buttons, and a progress bar:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: 'Here, in our handler for `EVT_BUTTON`, is where we do the calculations. First,
    we clear the current output and then start the progress `Gauge`. After that, we
    take one of two paths depending upon which `Button` was clicked. If the "Blocking"
    button, we do the calculations right here in the same thread. If the "Non-Blocking"
    button was clicked, we delegate the task to a background thread in order to allow
    the GUI to continue processing:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: 'These methods were added to control the progress Gauge and to update the state
    of the GUI, depending upon whether the application is busy calculating or not:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: How it works...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Running the previous code will result in the following application window being
    displayed:'
  prefs: []
  type: TYPE_NORMAL
- en: '![How it works...](img/1780_11_01.jpg)'
  prefs: []
  type: TYPE_IMG
- en: This application will calculate the Nth Fibonacci number specified by the first
    field. Using a number of 35 or higher will take from many seconds to several minutes
    to calculate by using the `SlowFib` function. Clicking on either of the two buttons
    will result in the same `SlowFib` function being called, and ultimately the same
    result being generated. So with this in mind, let's jump to the `BlockingPanel's
    OnButton` method to see what happens differently between the two buttons.
  prefs: []
  type: TYPE_NORMAL
- en: When `OnButton` is called, we first clear the result field and then `Start`
    the `Timer` to `Pulse` the `Gauge` at the top of the window to give the user feedback
    that we are busy calculating the result. If the Blocking button was clicked, we
    directly call the `SlowFib` function to get the result. At this point, the control
    flow of the application will be stuck waiting for `SlowFib` to return, which means
    that the `MainLoop` will be waiting on our `OnButton` method to return. Since
    `OnButton` will not return until `SlowFib` finishes, the framework will not be
    able to process any events for things such as repainting the window, mouse clicks,
    or our `TimerEvent` for pulsing the `Gauge`. Because of this, the Blocking button
    will still appear to be pressed, and the `Frame` and all of its controls will
    be completely unresponsive until `SlowFib` finishes and returns control to the
    `MainLoop:`
  prefs: []
  type: TYPE_NORMAL
- en: '![How it works...](img/1780OS_11_02.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'On the contrary, if you click on the Non-Blocking button we still run the same
    `SlowFib` function, but do it in a separate `Thread`. This allows `OnButton` to
    return immediately, returning control to the `MainLoop`. So since the `MainLoop`
    isn''t stuck in `OnButton`, it is free to process other events, allowing our busy
    indicator to be updated, the buttons to be shown as disabled, and the `Frame`
    to be freely moved around the desktop. When the calculations finish on the `FibThread`,
    it uses the `CallAfter` function to send a message to call the required functions
    to update the GUI back on the main thread and then exits, leaving the GUI ready
    to start another calculation:'
  prefs: []
  type: TYPE_NORMAL
- en: '![How it works...](img/1780OS_11_03.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Both buttons will take about the same time to produce the result, but the Non-Blocking
    button allows the GUI to continue running smoothly and will give the user a better
    impression of knowing that the software is busy working and is not just locked
    up.
  prefs: []
  type: TYPE_NORMAL
- en: See also
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: See the *Understanding thread safety* recipe in this chapter for more information
    on creating thread-safe GUIs.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: See the *Using Timers* recipe in this chapter for another approach to keeping
    the GUI responsive while performing a long-running task.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Understanding thread safety
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Nearly all user interface toolkits are designed to run within a single thread
    of execution. Knowing how to interact with the GUI thread from other worker threads
    in a threaded application is an important task that needs to be performed with
    care in order to avoid seemingly unexplainable and random crashes in an application.
    This is as true in wxPython as any other typical GUI toolkit.
  prefs: []
  type: TYPE_NORMAL
- en: Maintaining thread safety in a wxPython application can be handled in a few
    different ways, but the use of events is most typical. The event queue monitored
    by the `MainLoop` provides a thread-safe way to pass data and actions from a background
    thread to be processed in the context of the GUI thread. This recipe shows how
    to use custom events and the `PostEvent` function to make updates to GUI objects
    that exist in the main GUI thread.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Since we will be using events to maintain thread safety in our sample application,
    we will first start by defining a custom event type:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: 'The `CountingThread` class below will be used as this application''s background
    worker thread and will use the previous event class to notify and make updates
    on the main GUI thread:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: Beginning here, with the `ThreadSafeFrame` class, we will create the application's
    GUI. The Frame will be the target for the updates from the `CountingThread:`
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: 'Here is the event handler that the `ThreadSafeFrame` bound to the `EVT_THREAD_UPDATE`
    event binder for the custom `ThreadUpdateEvent` class. This method will be called
    after the `CountingThread` posts a new update event to do the GUI updates on the
    main GUI thread:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: How it works...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The point of this recipe was to show a generic pattern for updating the GUI
    from a background thread. To illustrate this, we created a simple `Frame` that
    has a `Panel` with a single `StaticTextCtrl` that will be updated by our `CountingThread`
    after each time that it has completed its arduous task of incrementing the count
    by one.
  prefs: []
  type: TYPE_NORMAL
- en: First, we created a new event type of `ThreadUpdateEvent`, and related event
    binder to use for transporting the data from the `CountingThread` to the main
    thread when it needs to tell the UI to update the displayed value. The `ThreadUpdateEvent`
    is used by the `CountingThread` in its `run` method by passing it to `PostEvent`,
    which is a thread-safe way to queue up some work for the main GUI thread.
  prefs: []
  type: TYPE_NORMAL
- en: '`PostEvent` will place the event object into the `MainLoop''s` event queue
    so that after it has finished processing any current tasks, it will grab and dispatch
    this update event to the appropriate event handler in our `ThreadSafeFrame`. This
    is the key that makes it possible to safely update the GUI from a background thread.'
  prefs: []
  type: TYPE_NORMAL
- en: If we had instead called the `Panel's DisplayCount` method directly from within
    the context of the `CountingThread`, there is no guarantee that both threads would
    not be trying to access or modify the same data at the same time. For example,
    if the GUI thread was in the middle of processing an internal `PaintEvent` in
    order to redraw the `StaticTextCtrl`, the control's label value would be getting
    accessed. If, at the same time, in the `CountingThread`, it was trying to change
    that value, there would be potential memory corruption, which would cause the
    application to crash. By using an event, the update will be processed in the context
    of the main thread after it has finished any other pending tasks, eliminating
    the risk of collision since access to the variable would be controlled in a serialized
    manner by the main thread.
  prefs: []
  type: TYPE_NORMAL
- en: There's more...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The `CallAfter` function provided by wxPython can also be used to make calls
    to methods that affect a GUI object from a background thread. The `CallAfter`
    function encapsulates much of the event creation and processing internally, and
    can be more convenient and transparent for making simple changes to the GUI, as
    we did in this recipe. So let''s take a little look at how `CallAfter` works and
    can be used:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: '`CallAfter` takes a function as its first argument. The `*args` and `**kw`
    are for specifying any positional or keyword arguments that should be passed the
    function specified by the first argument when it is called. So, for example, we
    could replace the three lines of code in our `CountingThread''s run` method that
    are creating and sending the custom event with the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: Now, the `CallAfter` function will create and post an event that contains the
    function and its arguments to the App object on the main GUI thread. When the
    `MainLoop` gets to processing this event, it will get handled by an event handler
    belonging to the `App` object. This event handler will then just simply call the
    function with any of its specified arguments, so that it is called in the context
    of the main GUI thread.
  prefs: []
  type: TYPE_NORMAL
- en: 'It''s important to understand that `CallAfter` means precisely that—the method
    will be called after the next iteration of the `MainLoop`. So you cannot expect
    to get a return value from the method that you pass to it since it will be called
    asynchronously to the scope of where you made the `CallAfter` call. So, just to
    be clear, `CallAfter` always returns `None`, meaning that you can''t use it for
    code like the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: This is because `window.GetValue` isn't actually called until after the `CallAfter`
    function returns.
  prefs: []
  type: TYPE_NORMAL
- en: See also
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: See the *Creating custom event classes* recipe in [Chapter 2](ch02.html "Chapter 2. Responding
    to Events"), *Responding to Events* for another example of creating custom events.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: See the *Threading tools* recipe in this chapter for some more examples and
    approaches to maintaining the thread safety of the GUI when working with background
    threads.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Threading tools
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Maintaining thread safety can be cumbersome and difficult at times so in this
    recipe we will create three useful utilities that will make working with threads
    easier. We will create two decorator functions and a metaclass to help make applying
    thread safe rules to methods and functions as simple as adding a single line of
    code.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Here, will create a little utility module that can be used to help any wxPython
    application that needs to work with threads:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: 'Starting here, we will create a simple decorator function that can be used
    to decorate any method in a GUI class, so that if a call to the decorated method
    is made from a background thread, it will automatically delegate the call to the
    `CallAfter` function:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: 'Next is the `Synchronizer` class, which is used as a helper class to synchronize
    an asynchronous call to the main GUI thread:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: This method will be called by this class's `Run` method using `CallAfter` to
    execute it on the main GUI thread. It simply calls the function and releases the
    `Semaphore:`
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: The `Run` method is called by the background thread, and uses `CallAfter` to
    delegate the function call to the main GUI thread. It then `acquires` the `Semaphore`
    so that the execution will pause at that line in the background thread until the
    `_AsyncWrapper` method calls `release:`
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: 'Next up is the `syncfunct` decorator which works the same way as the `CallAfter`
    decorator, except that it uses the `Synchronizer` to make the calls from the background
    thread synchronous:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: 'The final utility that we will present in this module is the `ClassSynchronizer`
    metaclass, which can be used to automatically apply the `synchfunct` decorator
    to all of the methods in a class:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: How it works...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Decorators and MetaClasses can be a little intimidating at first if you haven't
    used them before, so let's take a look at each of our three new utilities one
    by one and see how they work and how to use them in your code.
  prefs: []
  type: TYPE_NORMAL
- en: 'The first utility is the `callafter` decorator. This is a very simple decorator
    that will just wrap a function in `CallAfter` when called from a thread that is
    not the GUI thread. Since it uses `CallAfter`, this decorator should only be used
    for methods that don''t expect a return value, such as setting a value or doing
    an update that you don''t need feedback from on the background thread. The usage
    of this decorator is very simple. See the following example snippet:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: Now the `SetSomeGuiValues` method can be called from any thread in the application.
    A decorator function takes another function as an argument and returns a new function
    that usually wraps the existing function in some new behavior. So when our module
    is initialized by Python, it will see that the decorator arguments in the class
    will apply the decorator to the function and then rebind the function to the new
    one returned by the decorator. Our `callafter` decorator simply wraps the given
    function in a check to see if it is being called from the main thread, and if
    not, it uses `CallAfter` to run the function.
  prefs: []
  type: TYPE_NORMAL
- en: Next is the `synchfunct` decorator. This decorator uses our `Synchronizer` class
    to make it possible to synchronize inter-thread calls to functions. This method
    can be used when a background thread needs to make a call to retrieve a value
    from the GUI in a synchronous manner. The `synchfunct` decorator works pretty
    much the same as our `callafter` one, so let's look at how the `Synchronizer`
    makes it possibly to turn the asynchronous `CallAfter` function into a synchronous
    call.
  prefs: []
  type: TYPE_NORMAL
- en: The `Synchronizer` class, like the `CallAfter` function, takes a function and
    any of its arguments as parameters to initialize it. It also creates a `Semaphore`
    object from the `threading` module to use for synchronizing the actions. The `Synchronizer's
    Run` method uses `CallAfter` to call the passed-in function. After calling `CallAfter`,
    the `Run` method will block on the `Semaphore's acquire` call. This will halt
    execution of the rest of the code in the `Run` function and the background thread
    until the `_AsynchWrapper` method has called `release` on the `Semaphore` after
    it has finished running the passed-in function back on the main thread. When `release`
    has been called, the `Run` method will continue past its `acquire` call and will
    either return the result from the function that was run on the main thread or
    raise an exception if one was raised by calling that method.
  prefs: []
  type: TYPE_NORMAL
- en: 'Last, we have the `ClassSynchronizer` metaclass. This metaclass will use the
    `synchfunct` decorator to make every method in a class thread safe. First, let''s
    take a quick look at the snippet below, in order to show how to use this metaclass,
    and then we will check out how it works:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: Can't get much easier than that, can it? When the Python interpreter initializes
    the class, it will see our `__metaclass__` declaration, which will result in our
    `ClassSynchronizer's __call__` method getting called. In `__call__`, we use `dir`
    to enumerate all of the given class's items from its dictionary. Then, for each
    item in the class that is a `MethodType` or `FunctionType`, we apply the `synchfunct`
    decorator in order to get a newly-wrapped version of the method, and then use
    the wrapped version to replace it with.
  prefs: []
  type: TYPE_NORMAL
- en: There's more...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Included in the sample code that accompanies this topic is the full `threadtools`
    module shown above, plus a sample application that shows some additional usage
    examples of the `callafter` and `syncfunct` decorators, as well as the `ClassSynchronizer`
    metaclass in an application that fetches HTML from a given URL and displays it
    in a `TextCtrl`.
  prefs: []
  type: TYPE_NORMAL
- en: See also
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: See the *Understanding thread safety* recipe in this chapter for more information
    about using threads with a GUI.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: See the *Using decorators* recipe in [Chapter 9](ch09.html "Chapter 9. Design
    Approaches and Techniques"), *Design Approaches and Techniques* for another example
    of using decorator functions.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Using Timers
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: A `Timer` is an object that can be created to send out events on a regular periodic
    basis. Typically, a `Timer` is used to run short, atomic tasks, such as status
    checks and updates, but can also be leveraged to keep the UI active during a long-running
    task by performing tasks in incremental steps instead of one long blocking call.
    However, since a `Timer` will run in the context of the main GUI thread, it is
    necessary to be able to design the execution of the long-running task to be able
    to be carried out in several smaller incremental steps, otherwise the UI will
    still become locked up while processing the `TimerEvent`. This recipe creates
    a simple framework for processing long-running tasks by using a Timer.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'First, we will create a base class that defines an interface for tasks to derive
    from:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: 'Next, the `TimerTaskMixin` class can be used to add the functionality for using
    a `Timer` to process `TimerTaskBase-derived` task objects to any window class:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: 'The `OnTimer` method will be called once every 100ms, when the `Timer` generates
    a new event. Each time, it will call the `TimerTask` object''s `ProcessNext` method
    to allow it to perform the next step in its processing:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: How it works...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: First, let's take a look at our `TimerTaskBase` class, which defines the basic
    interface that our `TimerTaskMixin` class will use to execute the long running
    task. The `TimerTaskBase` class is very simple. It provides a `ProcessNext` method
    that must be overridden by a subclass in order to implement the processing of
    the next chunk of the task's work. This method will be called each time that the
    `TimerTaskMixin` class's Timer fires a `TimerEvent`. The other method, `InitTask`,
    is an optional override for a subclass to implement. It will be called immediately
    prior to the first `ProcessNext` call, and can be used to perform any set-up that
    the task may require prior to processing.
  prefs: []
  type: TYPE_NORMAL
- en: The `TimerTaskMixin` class is a mixin class that can be used with any `wx.Window-derived`
    class, such as a `Frame` or `Panel`. It adds the framework for managing a `TimerTask`
    object. This simple framework adds a `StartTask` method that can be used by the
    UI to start the processing of a `TimerTask. StartTask` takes the `TimerTask` object
    that needs to be processed, and then starts the `Timer`. The `Timer` will fire
    every 100ms in order to call the task's `ProcessNext` method, until the task reports
    that its state is in a completed state.
  prefs: []
  type: TYPE_NORMAL
- en: There's more...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In the full sample code that accompanies this topic, there is a simple example
    application that uses this framework for transcribing a string of DNA code to
    RNA, as an example of breaking up a bigger task into many smaller tasks that are
    to be processed during timer events.
  prefs: []
  type: TYPE_NORMAL
- en: See also
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: See the *Handling events* recipe in [Chapter 2](ch02.html "Chapter 2. Responding
    to Events"), *Responding to Events* for more information on event handling.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: See the *Using mixin classes* recipe in [Chapter 9](ch09.html "Chapter 9. Design
    Approaches and Techniques"), *Design Approaches and Techniques* for more information
    on and examples of working with mixin classes.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Capturing output
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: This recipe takes a number of the concepts put forth earlier in this chapter,
    to create an `OutputWindow` component that can be used to capture console output
    from a subprocess and redirect it to a text display in an application. It will
    use `Threads` and `Timers` to implement a high-performance solution to this task,
    so let's get started and take a look at the code.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: When run on Windows, this recipe makes use of the pywin32 extension module.([http://sourceforge.net/projects/pywin32/](http://sourceforge.net/projects/pywin32/))
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'In this recipe, we will create two classes. The first will be a worker thread
    class that will run the `subprocess` and report its output to the GUI. The second
    will be the GUI component that makes use of the worker thread and displays its
    output:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: 'The `ProcessThread` class will run a `subprocess` and read the process''s output
    from its output pipe, and then pass the data back to the thread''s `parent` object:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: 'Here, in the `ProcessThread''s run` method, we use the `subprocess` module
    from the Python standard library to start and run the process that we want to
    get output from:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: 'Here, we just loop as long as the process is running, reading its output and
    appending it to the `parent` object''s update queue:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: Next, we have the GUI control for displaying a process's output. This class
    will use the `ProcessThread` to run a process and be the receiver for its data.
    It will maintain a list of threads so that there can be an arbitrary number of
    processes running at the same time.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: 'The `AppendUpdate` method is used by the `ProcessThread` to pass data to this
    control. The updates are appended to a list that we guard with a lock to ensure
    that only one thread is accessing it at a time:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: 'Next, we have a `Timer` event handler to periodically check the update list
    and apply them to the GUI:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: 'Finally, the `StartProcess` method is what the application can use to tell
    the control to start a new process:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: How it works...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'First, let''s jump in with a look at our `ProcessThread` class. This is the
    worker thread that the `OutputWindow` uses to start an external process and capture
    its output from. The constructor takes three arguments: a parent window, a command-line
    string, and an optional keyword parameter that can specify the amount of text
    to block on reading from the process''s standard output on each iteration. Setting
    the `readblock` parameter to a small number will result in more responsive updates
    from the `ProcessThread`. However, setting it too low on a process that outputs
    lots of data can result in lots of small, inefficient updates. So it''s generally
    best to try to select a value that is as large as is appropriate for the given
    process''s output.'
  prefs: []
  type: TYPE_NORMAL
- en: The `ProcessThread's run` method is where it does all its work. First, we have
    to handle a special case for Windows, because `subprocess.POpen` can cause a command
    window to be opened when running shell commands. The use of the `startupflags`
    can be used to suppress this behavior since we want to show the output in our
    `OutputWindow` instead. Next, we use the `subprocess` module's `POpen` class to
    run the command specified in the constructor. Finally, the thread just enters
    a simple loop that checks to see if the process is still running, and if it is
    it then blocks the read of the specified amount of text from the processes output
    pipe. After the text has been read, it calls the `OutputWindow's AppendUpdate`
    method to add the output to its update queue.
  prefs: []
  type: TYPE_NORMAL
- en: Now, let's see how the `OutputWindow` works to display the text that the `ProcessThread`
    captures. The `OutputWindow` derives from `StyledTextCtrl` because this can handle
    larger amounts of text with generally better performance than the standard `TextCtrl`,
    and has a more powerful API for working with the text in the buffer, should we
    decided to add some additional functionality at a later date. In the `OutputWindow's`
    constructor, we did a few important things. First, we created a lock to use for
    guarding the update queue so that only one thread can modify it at a time. If
    a second thread tries to `acquire` the lock while another thread has it, it will
    cause the second thread to wait at the `acquire` call until the lock is released
    by the other thread. The second is the update queue, third is the `Timer` that
    will be used to poll the update queue periodically, and finally we have a list
    to keep references to the `ProcessThread(s)` that are started.
  prefs: []
  type: TYPE_NORMAL
- en: The remaining methods in the `OutputWindow` class are all used to manage the
    updates from the `ProcessThread(s)` that it owns. `StartProcess` creates and starts
    a new `ProcessThread`, as well as the `OutputWindow's` update Timer if it hasn't
    been previously started. `AppendUpdate` is a thread-safe method for background
    threads to call and add updates to the `OutputWindow`. This method is safe to
    directly call from a background thread because the data object that it is modifying
    is guarded by a lock that will prevent more than one thread from modifying the
    object at the same time. This method was chosen over posting events from the worker
    threads because it can help to keep the UI more responsive during high-volume
    updates, because it allows the updates to the UI to be grouped into a smaller
    number of larger updates as opposed to many small updates which can lead to the
    UI becoming locked up while processing all the events. Last but not least is the
    `OnTimer` method, where the actual UI updates occur. `OnTimer` first checks and
    removes any threads that have finished running from the thread pool, and then
    it acquires the lock to make sure it has exclusive access to the update queue.
    After acquiring the lock, it proceeds to flush all the queued updates to the `OutputWindow`,
    and then empties the queue and releases the lock.
  prefs: []
  type: TYPE_NORMAL
- en: There's more...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'See the sample code that accompanies this topic for a small, sample application
    that makes use of the `OutputWindow` to create a GUI display for running the ping
    command:'
  prefs: []
  type: TYPE_NORMAL
- en: '![There''s more...](img/1780_11_04.jpg)'
  prefs: []
  type: TYPE_IMG
- en: See also
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: See the *Understanding thread safety* recipe in this chapter for a discussion
    of what thread safety is as it relates to the GUI.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: See the *Using Timers* recipe in this chapter for another example of using Timers.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
