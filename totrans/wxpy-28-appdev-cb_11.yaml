- en: Chapter 11. Using Threads and Timers to Create Responsive Interfaces
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第11章 使用线程和计时器创建响应式界面
- en: 'In this chapter, we will cover:'
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将涵盖：
- en: Non-Blocking GUI
  id: totrans-2
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 非阻塞GUI
- en: Understanding thread safety
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 理解线程安全性
- en: Threading tools
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 线程工具
- en: Using Timers
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用计时器
- en: Capturing output
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 捕获输出
- en: Introduction
  id: totrans-7
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 简介
- en: It's all too familiar and an annoying issue when you are using an application
    and click on some button or control only to find that the application's UI all
    of a sudden appears to stop responding, the busy cursor shows up, and you are
    left there wondering if the application is still working, or if it has locked
    up and needs to be forced quit. This unpleasant experience is almost always the
    result of a function or action that takes a considerable amount of time to return
    after being called. If this function or action is called on the same thread that
    the GUI objects live on, it will block all the code that is running in the background
    and that is managing the GUI, leading to this locked up and unresponsive interface.
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 当你使用一个应用程序并点击某个按钮或控件时，突然发现应用程序的UI似乎停止响应，忙碌的光标出现，而你只能在那里猜测应用程序是否还在工作，或者它是否已经锁定并需要强制退出。这种不愉快的体验几乎总是由于一个在调用后需要相当长时间才能返回结果的函数或动作造成的。如果这个函数或动作是在GUI对象所在的同一线程上被调用的，它将阻塞所有在后台运行并管理GUI的代码，导致这个锁定且无响应的界面。
- en: Being able to design an application in a way that prevents this situation from
    being presented to its users requires additional considerations in comparison
    to most traditional procedural approaches. This chapter explores this problem
    by providing solutions, and hopefully all the tools necessary, to build highly-responsive,
    multi-threaded applications in wxPython.
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 能够以防止这种情况出现在用户面前的方式设计应用程序，与大多数传统的程序性方法相比，需要额外的考虑。本章通过提供解决方案，并希望提供所有必要的工具，来探讨这个问题，以构建高度响应的、多线程的wxPython应用程序。
- en: Non-Blocking GUI
  id: totrans-10
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 非阻塞图形用户界面
- en: In this recipe, we explore what a responsive interface is and try to gain a
    good understanding of what the problem is that the other recipes in this chapter
    will provide solutions to. The recipe creates a simple application with two buttons.
    Each button will perform exactly the same task. However, the way in which the
    application responds and provides feedback to the user after the button is clicked
    will differ greatly between the two buttons, due to how the control flow is carried
    out.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个菜谱中，我们探讨什么是响应式界面，并试图对其他菜谱章节中将要提供的解决方案所针对的问题有一个良好的理解。该菜谱创建了一个包含两个按钮的简单应用程序。每个按钮将执行完全相同的任务。然而，由于控制流的执行方式不同，两个按钮在点击按钮后对用户响应和提供反馈的方式将大相径庭。
- en: How to do it...
  id: totrans-12
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何做到这一点...
- en: 'To illustrate the issue at hand, we will create a simple Fibonacci number calculator
    application. First, we will begin by defining a Thread class and the function
    that will be used to calculate the Nth Fibonacci number:'
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 为了说明当前的问题，我们将创建一个简单的斐波那契数计算器应用程序。首先，我们将从定义一个线程类和用于计算第N个斐波那契数的函数开始：
- en: '[PRE0]'
  id: totrans-14
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'Now let''s create the user interface for our Fibonacci number calculator:'
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 现在让我们为我们的斐波那契数计算器创建用户界面：
- en: '[PRE1]'
  id: totrans-16
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'Here, in the `Panel`, is where most of the action will be taking place in this
    example. Here we lay out a simple interface with an input field and an output
    field, two buttons, and a progress bar:'
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，在`面板`中，大部分的操作将在本例中发生。在这里，我们布局了一个简单的界面，包括一个输入字段和一个输出字段，两个按钮，以及一个进度条：
- en: '[PRE2]'
  id: totrans-18
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'Here, in our handler for `EVT_BUTTON`, is where we do the calculations. First,
    we clear the current output and then start the progress `Gauge`. After that, we
    take one of two paths depending upon which `Button` was clicked. If the "Blocking"
    button, we do the calculations right here in the same thread. If the "Non-Blocking"
    button was clicked, we delegate the task to a background thread in order to allow
    the GUI to continue processing:'
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的`EVT_BUTTON`处理程序中，我们进行计算。首先，我们清除当前输出，然后启动进度`Gauge`。之后，我们根据点击的是哪个`Button`选择两条路径之一。如果是“Blocking”按钮，我们就在同一个线程中直接进行计算。如果是“Non-Blocking”按钮被点击，我们将任务委托给后台线程，以便允许GUI继续处理：
- en: '[PRE3]'
  id: totrans-20
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'These methods were added to control the progress Gauge and to update the state
    of the GUI, depending upon whether the application is busy calculating or not:'
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 这些方法被添加以控制进度量表并更新GUI的状态，具体取决于应用程序是否正在计算：
- en: '[PRE4]'
  id: totrans-22
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: How it works...
  id: totrans-23
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: 'Running the previous code will result in the following application window being
    displayed:'
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 运行上一段代码将会显示以下应用程序窗口：
- en: '![How it works...](img/1780_11_01.jpg)'
  id: totrans-25
  prefs: []
  type: TYPE_IMG
  zh: '![如何工作...](img/1780_11_01.jpg)'
- en: This application will calculate the Nth Fibonacci number specified by the first
    field. Using a number of 35 or higher will take from many seconds to several minutes
    to calculate by using the `SlowFib` function. Clicking on either of the two buttons
    will result in the same `SlowFib` function being called, and ultimately the same
    result being generated. So with this in mind, let's jump to the `BlockingPanel's
    OnButton` method to see what happens differently between the two buttons.
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 此应用程序将计算由第一个字段指定的第N个斐波那契数。使用35或更高的数字，通过使用`SlowFib`函数进行计算将需要从几秒到几分钟不等。点击两个按钮中的任意一个，都会调用相同的`SlowFib`函数，并最终生成相同的结果。因此，带着这个想法，让我们跳转到`BlockingPanel`的`OnButton`方法，看看两个按钮之间有什么不同之处。
- en: When `OnButton` is called, we first clear the result field and then `Start`
    the `Timer` to `Pulse` the `Gauge` at the top of the window to give the user feedback
    that we are busy calculating the result. If the Blocking button was clicked, we
    directly call the `SlowFib` function to get the result. At this point, the control
    flow of the application will be stuck waiting for `SlowFib` to return, which means
    that the `MainLoop` will be waiting on our `OnButton` method to return. Since
    `OnButton` will not return until `SlowFib` finishes, the framework will not be
    able to process any events for things such as repainting the window, mouse clicks,
    or our `TimerEvent` for pulsing the `Gauge`. Because of this, the Blocking button
    will still appear to be pressed, and the `Frame` and all of its controls will
    be completely unresponsive until `SlowFib` finishes and returns control to the
    `MainLoop:`
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 当调用`OnButton`时，我们首先清除结果字段，然后`Start`启动`Timer`以`Pulse`窗口顶部的`Gauge`，从而给用户反馈我们正在忙于计算结果。如果点击了阻塞按钮，我们直接调用`SlowFib`函数来获取结果。在此阶段，应用程序的控制流将停滞等待`SlowFib`返回，这意味着`MainLoop`将等待我们的`OnButton`方法返回。由于`OnButton`只有在`SlowFib`完成后才会返回，因此框架将无法处理任何事件，例如重绘窗口、鼠标点击或我们的`TimerEvent`以脉冲`Gauge`。正因为如此，阻塞按钮仍然看起来是按下的，并且`Frame`及其所有控件将完全无响应，直到`SlowFib`完成并返回控制权到`MainLoop`：
- en: '![How it works...](img/1780OS_11_02.jpg)'
  id: totrans-28
  prefs: []
  type: TYPE_IMG
  zh: '![如何工作...](img/1780OS_11_02.jpg)'
- en: 'On the contrary, if you click on the Non-Blocking button we still run the same
    `SlowFib` function, but do it in a separate `Thread`. This allows `OnButton` to
    return immediately, returning control to the `MainLoop`. So since the `MainLoop`
    isn''t stuck in `OnButton`, it is free to process other events, allowing our busy
    indicator to be updated, the buttons to be shown as disabled, and the `Frame`
    to be freely moved around the desktop. When the calculations finish on the `FibThread`,
    it uses the `CallAfter` function to send a message to call the required functions
    to update the GUI back on the main thread and then exits, leaving the GUI ready
    to start another calculation:'
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 相反，如果你点击了非阻塞按钮，我们仍然运行相同的`SlowFib`函数，但是在一个单独的`Thread`中执行。这允许`OnButton`立即返回，将控制权交还给`MainLoop`。因此，由于`MainLoop`没有被`OnButton`阻塞，它可以自由地处理其他事件，允许我们的忙碌指示器更新，按钮显示为禁用状态，以及`Frame`可以在桌面上自由移动。当`FibThread`上的计算完成时，它使用`CallAfter`函数发送消息来调用所需的功能，以在主线程上更新GUI，然后退出，使GUI准备好开始另一个计算：
- en: '![How it works...](img/1780OS_11_03.jpg)'
  id: totrans-30
  prefs: []
  type: TYPE_IMG
  zh: '![如何工作...](img/1780OS_11_03.jpg)'
- en: Both buttons will take about the same time to produce the result, but the Non-Blocking
    button allows the GUI to continue running smoothly and will give the user a better
    impression of knowing that the software is busy working and is not just locked
    up.
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 两个按钮产生结果所需的时间大致相同，但非阻塞按钮允许GUI继续平稳运行，并会给用户留下软件正在忙碌工作的良好印象，知道软件并未锁定。
- en: See also
  id: totrans-32
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 参见
- en: See the *Understanding thread safety* recipe in this chapter for more information
    on creating thread-safe GUIs.
  id: totrans-33
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 有关创建线程安全GUI的更多信息，请参阅本章中的*理解线程安全*配方。
- en: See the *Using Timers* recipe in this chapter for another approach to keeping
    the GUI responsive while performing a long-running task.
  id: totrans-34
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 请参阅本章中的*使用计时器*配方，了解在执行长时间运行的任务时保持GUI响应的其他方法。
- en: Understanding thread safety
  id: totrans-35
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 理解线程安全性
- en: Nearly all user interface toolkits are designed to run within a single thread
    of execution. Knowing how to interact with the GUI thread from other worker threads
    in a threaded application is an important task that needs to be performed with
    care in order to avoid seemingly unexplainable and random crashes in an application.
    This is as true in wxPython as any other typical GUI toolkit.
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 几乎所有用户界面工具包都是设计在单个执行线程中运行的。了解如何在多线程应用程序中与其他工作线程交互GUI线程是一项重要的任务，需要谨慎执行，以避免应用程序中出现看似无法解释且随机的崩溃。这在wxPython中与其他典型的GUI工具包一样适用。
- en: Maintaining thread safety in a wxPython application can be handled in a few
    different ways, but the use of events is most typical. The event queue monitored
    by the `MainLoop` provides a thread-safe way to pass data and actions from a background
    thread to be processed in the context of the GUI thread. This recipe shows how
    to use custom events and the `PostEvent` function to make updates to GUI objects
    that exist in the main GUI thread.
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 在wxPython应用程序中保持线程安全可以通过几种不同的方式来处理，但使用事件是最典型的方法。由`MainLoop`监控的事件队列提供了一种线程安全的方式来从后台线程传递数据和动作，以便在GUI线程的上下文中进行处理。本食谱展示了如何使用自定义事件和`PostEvent`函数来更新存在于主GUI线程中的GUI对象。
- en: How to do it...
  id: totrans-38
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何做到这一点...
- en: 'Since we will be using events to maintain thread safety in our sample application,
    we will first start by defining a custom event type:'
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 由于我们将在示例应用程序中使用事件来维护线程安全，我们首先将定义一个自定义事件类型：
- en: '[PRE5]'
  id: totrans-40
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'The `CountingThread` class below will be used as this application''s background
    worker thread and will use the previous event class to notify and make updates
    on the main GUI thread:'
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 下面的`CountingThread`类将被用作本应用程序的后台工作线程，并使用之前的事件类来通知并在主GUI线程上执行更新：
- en: '[PRE6]'
  id: totrans-42
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: Beginning here, with the `ThreadSafeFrame` class, we will create the application's
    GUI. The Frame will be the target for the updates from the `CountingThread:`
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 从这里开始，我们将使用`ThreadSafeFrame`类来创建应用程序的GUI。框架将是来自`CountingThread:`更新的目标：
- en: '[PRE7]'
  id: totrans-44
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'Here is the event handler that the `ThreadSafeFrame` bound to the `EVT_THREAD_UPDATE`
    event binder for the custom `ThreadUpdateEvent` class. This method will be called
    after the `CountingThread` posts a new update event to do the GUI updates on the
    main GUI thread:'
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 这里是绑定到自定义`ThreadUpdateEvent`类的`EVT_THREAD_UPDATE`事件绑定器的`ThreadSafeFrame`的事件处理器。此方法将在`CountingThread`发布新的更新事件后，在主GUI线程上执行GUI更新时被调用：
- en: '[PRE8]'
  id: totrans-46
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: How it works...
  id: totrans-47
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: The point of this recipe was to show a generic pattern for updating the GUI
    from a background thread. To illustrate this, we created a simple `Frame` that
    has a `Panel` with a single `StaticTextCtrl` that will be updated by our `CountingThread`
    after each time that it has completed its arduous task of incrementing the count
    by one.
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 这个菜谱的目的是展示一个从后台线程更新GUI的通用模式。为了说明这一点，我们创建了一个简单的`Frame`，它包含一个带有单个`StaticTextCtrl`的`Panel`，该`StaticTextCtrl`将在`CountingThread`完成其艰巨的任务（每次将计数增加一）后进行更新。
- en: First, we created a new event type of `ThreadUpdateEvent`, and related event
    binder to use for transporting the data from the `CountingThread` to the main
    thread when it needs to tell the UI to update the displayed value. The `ThreadUpdateEvent`
    is used by the `CountingThread` in its `run` method by passing it to `PostEvent`,
    which is a thread-safe way to queue up some work for the main GUI thread.
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们创建了一个新的事件类型`ThreadUpdateEvent`，以及相关的事件绑定器，用于在需要告诉UI更新显示值时，从`CountingThread`传输数据到主线程。`ThreadUpdateEvent`在`CountingThread`的`run`方法中使用，通过传递给`PostEvent`来使用，这是一种线程安全的方式来为主GUI线程排队一些工作。
- en: '`PostEvent` will place the event object into the `MainLoop''s` event queue
    so that after it has finished processing any current tasks, it will grab and dispatch
    this update event to the appropriate event handler in our `ThreadSafeFrame`. This
    is the key that makes it possible to safely update the GUI from a background thread.'
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: '`PostEvent`会将事件对象放入`MainLoop`的事件队列中，这样在它完成处理任何当前任务后，它将抓取并派发这个更新事件到我们`ThreadSafeFrame`中适当的事件处理器。这是使得从后台线程安全更新GUI成为可能的关键。'
- en: If we had instead called the `Panel's DisplayCount` method directly from within
    the context of the `CountingThread`, there is no guarantee that both threads would
    not be trying to access or modify the same data at the same time. For example,
    if the GUI thread was in the middle of processing an internal `PaintEvent` in
    order to redraw the `StaticTextCtrl`, the control's label value would be getting
    accessed. If, at the same time, in the `CountingThread`, it was trying to change
    that value, there would be potential memory corruption, which would cause the
    application to crash. By using an event, the update will be processed in the context
    of the main thread after it has finished any other pending tasks, eliminating
    the risk of collision since access to the variable would be controlled in a serialized
    manner by the main thread.
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们直接在`CountingThread`的上下文中调用`Panel's DisplayCount`方法，无法保证两个线程不会同时尝试访问或修改相同的数据。例如，如果GUI线程正在处理一个内部的`PaintEvent`以重新绘制`StaticTextCtrl`，控制器的标签值将被访问。如果在同一时间，在`CountingThread`中，它试图更改该值，则可能会发生潜在的内存损坏，这会导致应用程序崩溃。通过使用事件，更新将在主线程完成任何其他挂起的任务后，在主线程的上下文中进行处理，从而消除碰撞的风险，因为对变量的访问将由主线程以序列化的方式进行控制。
- en: There's more...
  id: totrans-52
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 还有更多...
- en: 'The `CallAfter` function provided by wxPython can also be used to make calls
    to methods that affect a GUI object from a background thread. The `CallAfter`
    function encapsulates much of the event creation and processing internally, and
    can be more convenient and transparent for making simple changes to the GUI, as
    we did in this recipe. So let''s take a little look at how `CallAfter` works and
    can be used:'
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: wxPython提供的`CallAfter`函数也可以用于从后台线程调用影响GUI对象的方法。`CallAfter`函数内部封装了大部分事件创建和处理过程，因此在进行简单的GUI更改时，它可能更加方便和透明，正如我们在本食谱中所做的那样。因此，让我们简要了解一下`CallAfter`是如何工作以及如何使用的：
- en: '[PRE9]'
  id: totrans-54
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: '`CallAfter` takes a function as its first argument. The `*args` and `**kw`
    are for specifying any positional or keyword arguments that should be passed the
    function specified by the first argument when it is called. So, for example, we
    could replace the three lines of code in our `CountingThread''s run` method that
    are creating and sending the custom event with the following:'
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: '`CallAfter` 函数将其第一个参数接受为一个函数。`*args` 和 `**kw` 用于指定任何应传递给第一个参数指定的函数的定位或关键字参数。因此，例如，我们可以用以下代码替换掉我们
    `CountingThread` 的 `run` 方法中创建和发送自定义事件的三个代码行：'
- en: '[PRE10]'
  id: totrans-56
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: Now, the `CallAfter` function will create and post an event that contains the
    function and its arguments to the App object on the main GUI thread. When the
    `MainLoop` gets to processing this event, it will get handled by an event handler
    belonging to the `App` object. This event handler will then just simply call the
    function with any of its specified arguments, so that it is called in the context
    of the main GUI thread.
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，`CallAfter` 函数将在主 GUI 线程上创建并发布一个事件，该事件包含函数及其参数到 App 对象。当 `MainLoop` 到达处理此事件时，它将由属于
    `App` 对象的事件处理器处理。然后，此事件处理器将简单地使用其指定的任何参数调用该函数，因此它将在主 GUI 线程的上下文中被调用。
- en: 'It''s important to understand that `CallAfter` means precisely that—the method
    will be called after the next iteration of the `MainLoop`. So you cannot expect
    to get a return value from the method that you pass to it since it will be called
    asynchronously to the scope of where you made the `CallAfter` call. So, just to
    be clear, `CallAfter` always returns `None`, meaning that you can''t use it for
    code like the following:'
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 重要的是要理解`CallAfter`的确切含义——该方法将在`MainLoop`的下一个迭代之后被调用。因此，你不能期望从传递给它的方法中获取返回值，因为它将在你进行`CallAfter`调用作用域之外异步调用。所以，为了明确起见，`CallAfter`总是返回`None`，这意味着你不能用它来编写如下代码：
- en: '[PRE11]'
  id: totrans-59
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: This is because `window.GetValue` isn't actually called until after the `CallAfter`
    function returns.
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 这是因为 `window.GetValue` 实际上是在 `CallAfter` 函数返回之后才被调用的。
- en: See also
  id: totrans-61
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 参见
- en: See the *Creating custom event classes* recipe in [Chapter 2](ch02.html "Chapter 2. Responding
    to Events"), *Responding to Events* for another example of creating custom events.
  id: totrans-62
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 请参阅[第2章](ch02.html "第2章。响应事件")中的*创建自定义事件类*配方，*响应事件*部分提供了创建自定义事件的另一个示例。
- en: See the *Threading tools* recipe in this chapter for some more examples and
    approaches to maintaining the thread safety of the GUI when working with background
    threads.
  id: totrans-63
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 请参阅本章中的 *线程工具* 菜单以获取更多示例和保持与后台线程一起工作时GUI线程安全性的方法。
- en: Threading tools
  id: totrans-64
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 线程工具
- en: Maintaining thread safety can be cumbersome and difficult at times so in this
    recipe we will create three useful utilities that will make working with threads
    easier. We will create two decorator functions and a metaclass to help make applying
    thread safe rules to methods and functions as simple as adding a single line of
    code.
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 维护线程安全性有时可能会很繁琐和困难，因此在本教程中，我们将创建三个有用的工具，使线程操作变得更加容易。我们将创建两个装饰器函数和一个元类，以帮助将线程安全规则应用到方法和函数中，使其变得像添加一行代码一样简单。
- en: How to do it...
  id: totrans-66
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何做到这一点...
- en: 'Here, will create a little utility module that can be used to help any wxPython
    application that needs to work with threads:'
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，将创建一个小的实用模块，它可以被用来帮助任何需要与线程一起工作的 wxPython 应用程序：
- en: '[PRE12]'
  id: totrans-68
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'Starting here, we will create a simple decorator function that can be used
    to decorate any method in a GUI class, so that if a call to the decorated method
    is made from a background thread, it will automatically delegate the call to the
    `CallAfter` function:'
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 从这里开始，我们将创建一个简单的装饰器函数，它可以用来装饰GUI类中的任何方法，这样如果从后台线程调用被装饰的方法，它将自动将调用委托给`CallAfter`函数：
- en: '[PRE13]'
  id: totrans-70
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'Next is the `Synchronizer` class, which is used as a helper class to synchronize
    an asynchronous call to the main GUI thread:'
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来是`Synchronizer`类，它被用作辅助类来同步对主GUI线程的异步调用：
- en: '[PRE14]'
  id: totrans-72
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: This method will be called by this class's `Run` method using `CallAfter` to
    execute it on the main GUI thread. It simply calls the function and releases the
    `Semaphore:`
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 此方法将由该类的`Run`方法通过`CallAfter`在主GUI线程上执行调用。它只是调用该函数并释放`Semaphore:`
- en: '[PRE15]'
  id: totrans-74
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: The `Run` method is called by the background thread, and uses `CallAfter` to
    delegate the function call to the main GUI thread. It then `acquires` the `Semaphore`
    so that the execution will pause at that line in the background thread until the
    `_AsyncWrapper` method calls `release:`
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: '`Run` 方法由后台线程调用，并使用 `CallAfter` 将函数调用委托给主GUI线程。然后它`获取`了`Semaphore`，这样执行就会在后台线程中的该行暂停，直到
    `_AsyncWrapper` 方法调用 `release:`'
- en: '[PRE16]'
  id: totrans-76
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'Next up is the `syncfunct` decorator which works the same way as the `CallAfter`
    decorator, except that it uses the `Synchronizer` to make the calls from the background
    thread synchronous:'
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来是 `syncfunct` 装饰器，它的工作方式与 `CallAfter` 装饰器相同，只不过它使用 `Synchronizer` 来使后台线程的调用变为同步：
- en: '[PRE17]'
  id: totrans-78
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'The final utility that we will present in this module is the `ClassSynchronizer`
    metaclass, which can be used to automatically apply the `synchfunct` decorator
    to all of the methods in a class:'
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 本模块将展示的最终实用工具是 `ClassSynchronizer` 元类，它可以用来自动将 `synchfunct` 装饰器应用到类中的所有方法：
- en: '[PRE18]'
  id: totrans-80
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: How it works...
  id: totrans-81
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: Decorators and MetaClasses can be a little intimidating at first if you haven't
    used them before, so let's take a look at each of our three new utilities one
    by one and see how they work and how to use them in your code.
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你之前没有使用过装饰器和元类，它们可能会让你一开始感到有些 intimidating，所以让我们逐一查看我们这三个新的实用工具，看看它们是如何工作的，以及如何在你的代码中使用它们。
- en: 'The first utility is the `callafter` decorator. This is a very simple decorator
    that will just wrap a function in `CallAfter` when called from a thread that is
    not the GUI thread. Since it uses `CallAfter`, this decorator should only be used
    for methods that don''t expect a return value, such as setting a value or doing
    an update that you don''t need feedback from on the background thread. The usage
    of this decorator is very simple. See the following example snippet:'
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 第一个实用工具是 `callafter` 装饰器。这是一个非常简单的装饰器，当从非GUI线程的线程调用时，它将仅将函数包装在 `CallAfter` 中。由于它使用
    `CallAfter`，此装饰器仅应用于不需要返回值的函数，例如设置值或执行不需要在后台线程中获取反馈的更新。此装饰器的使用非常简单。请参阅以下示例片段：
- en: '[PRE19]'
  id: totrans-84
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: Now the `SetSomeGuiValues` method can be called from any thread in the application.
    A decorator function takes another function as an argument and returns a new function
    that usually wraps the existing function in some new behavior. So when our module
    is initialized by Python, it will see that the decorator arguments in the class
    will apply the decorator to the function and then rebind the function to the new
    one returned by the decorator. Our `callafter` decorator simply wraps the given
    function in a check to see if it is being called from the main thread, and if
    not, it uses `CallAfter` to run the function.
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，`SetSomeGuiValues` 方法可以从应用程序中的任何线程调用。装饰器函数接受另一个函数作为参数，并返回一个新的函数，该函数通常将现有函数包装在某种新行为中。因此，当我们的模块由
    Python 初始化时，它将看到类中的装饰器参数将装饰器应用于函数，然后将函数重新绑定到装饰器返回的新函数。我们的 `callafter` 装饰器简单地将给定的函数包装在一个检查中，以查看它是否是从主线程调用的，如果不是，它将使用
    `CallAfter` 来运行该函数。
- en: Next is the `synchfunct` decorator. This decorator uses our `Synchronizer` class
    to make it possible to synchronize inter-thread calls to functions. This method
    can be used when a background thread needs to make a call to retrieve a value
    from the GUI in a synchronous manner. The `synchfunct` decorator works pretty
    much the same as our `callafter` one, so let's look at how the `Synchronizer`
    makes it possibly to turn the asynchronous `CallAfter` function into a synchronous
    call.
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来是 `synchfunct` 装饰器。这个装饰器使用我们的 `Synchronizer` 类来实现对函数间线程调用的同步。当后台线程需要以同步方式调用
    GUI 来获取值时，可以使用此方法。`synchfunct` 装饰器的工作方式几乎与我们的 `callafter` 装饰器相同，因此让我们看看 `Synchronizer`
    是如何使异步的 `CallAfter` 函数变为同步调用的。
- en: The `Synchronizer` class, like the `CallAfter` function, takes a function and
    any of its arguments as parameters to initialize it. It also creates a `Semaphore`
    object from the `threading` module to use for synchronizing the actions. The `Synchronizer's
    Run` method uses `CallAfter` to call the passed-in function. After calling `CallAfter`,
    the `Run` method will block on the `Semaphore's acquire` call. This will halt
    execution of the rest of the code in the `Run` function and the background thread
    until the `_AsynchWrapper` method has called `release` on the `Semaphore` after
    it has finished running the passed-in function back on the main thread. When `release`
    has been called, the `Run` method will continue past its `acquire` call and will
    either return the result from the function that was run on the main thread or
    raise an exception if one was raised by calling that method.
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: '`Synchronizer` 类，就像 `CallAfter` 函数一样，接受一个函数及其任何参数作为参数来初始化它。它还从 `threading`
    模块创建一个 `Semaphore` 对象，用于同步操作。`Synchronizer` 的 `Run` 方法使用 `CallAfter` 来调用传入的函数。在调用
    `CallAfter` 之后，`Run` 方法将在 `Semaphore` 的 `acquire` 调用上阻塞。这将停止 `Run` 函数中其余代码的执行以及后台线程，直到
    `_AsynchWrapper` 方法在主线程上完成对传入函数的运行后，在 `Semaphore` 上调用 `release`。当调用 `release`
    后，`Run` 方法将继续执行其 `acquire` 调用之后的部分，并将返回在主线程上运行的函数的结果，或者如果调用该方法时引发了异常，则抛出异常。'
- en: 'Last, we have the `ClassSynchronizer` metaclass. This metaclass will use the
    `synchfunct` decorator to make every method in a class thread safe. First, let''s
    take a quick look at the snippet below, in order to show how to use this metaclass,
    and then we will check out how it works:'
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们有`ClassSynchronizer`元类。这个元类将使用`synchfunct`装饰器来使类中的每个方法都成为线程安全的。首先，让我们快速看一下下面的代码片段，以便展示如何使用这个元类，然后我们将检查它是如何工作的：
- en: '[PRE20]'
  id: totrans-89
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: Can't get much easier than that, can it? When the Python interpreter initializes
    the class, it will see our `__metaclass__` declaration, which will result in our
    `ClassSynchronizer's __call__` method getting called. In `__call__`, we use `dir`
    to enumerate all of the given class's items from its dictionary. Then, for each
    item in the class that is a `MethodType` or `FunctionType`, we apply the `synchfunct`
    decorator in order to get a newly-wrapped version of the method, and then use
    the wrapped version to replace it with.
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 没有什么比这更简单了，对吧？当 Python 解释器初始化类时，它会看到我们的 `__metaclass__` 声明，这将导致我们的 `ClassSynchronizer`
    的 `__call__` 方法被调用。在 `__call__` 中，我们使用 `dir` 来枚举给定类字典中的所有项。然后，对于类中的每个是 `MethodType`
    或 `FunctionType` 的项，我们应用 `synchfunct` 装饰器以获取方法的新包装版本，然后使用包装后的版本来替换它。
- en: There's more...
  id: totrans-91
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 还有更多...
- en: Included in the sample code that accompanies this topic is the full `threadtools`
    module shown above, plus a sample application that shows some additional usage
    examples of the `callafter` and `syncfunct` decorators, as well as the `ClassSynchronizer`
    metaclass in an application that fetches HTML from a given URL and displays it
    in a `TextCtrl`.
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 伴随本主题的示例代码中包含了上面显示的完整 `threadtools` 模块，以及一个示例应用程序，该应用程序展示了 `callafter` 和 `syncfunct`
    装饰器的一些额外使用示例，以及在一个从给定 URL 获取 HTML 并在 `TextCtrl` 中显示的应用程序中的 `ClassSynchronizer`
    元类。
- en: See also
  id: totrans-93
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 参见
- en: See the *Understanding thread safety* recipe in this chapter for more information
    about using threads with a GUI.
  id: totrans-94
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 有关使用线程与GUI的更多信息，请参阅本章中的*理解线程安全性*配方。
- en: See the *Using decorators* recipe in [Chapter 9](ch09.html "Chapter 9. Design
    Approaches and Techniques"), *Design Approaches and Techniques* for another example
    of using decorator functions.
  id: totrans-95
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 请参阅[第9章](ch09.html "第9章。设计方法和技巧")中的*使用装饰器*配方，以了解使用装饰器函数的另一个示例，所在章节为*设计方法和技巧*。
- en: Using Timers
  id: totrans-96
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用计时器
- en: A `Timer` is an object that can be created to send out events on a regular periodic
    basis. Typically, a `Timer` is used to run short, atomic tasks, such as status
    checks and updates, but can also be leveraged to keep the UI active during a long-running
    task by performing tasks in incremental steps instead of one long blocking call.
    However, since a `Timer` will run in the context of the main GUI thread, it is
    necessary to be able to design the execution of the long-running task to be able
    to be carried out in several smaller incremental steps, otherwise the UI will
    still become locked up while processing the `TimerEvent`. This recipe creates
    a simple framework for processing long-running tasks by using a Timer.
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: '`计时器`是一个可以创建的对象，用于定期发送事件。通常，`计时器`用于运行短小的原子任务，例如状态检查和更新，但也可以通过分步执行任务而不是一个长时间的阻塞调用，来利用它保持UI在长时间运行的任务中活跃。然而，由于`计时器`将在主GUI线程的上下文中运行，因此有必要设计长时间运行任务的执行，使其能够以几个较小的增量步骤进行，否则在处理`TimerEvent`时UI仍然会锁定。这个配方通过使用计时器创建了一个简单的框架来处理长时间运行的任务。'
- en: How to do it...
  id: totrans-98
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何做到这一点...
- en: 'First, we will create a base class that defines an interface for tasks to derive
    from:'
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们将创建一个基类，该类定义了一个任务可以从中派生的接口：
- en: '[PRE21]'
  id: totrans-100
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'Next, the `TimerTaskMixin` class can be used to add the functionality for using
    a `Timer` to process `TimerTaskBase-derived` task objects to any window class:'
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，可以使用`TimerTaskMixin`类将使用`Timer`处理`TimerTaskBase派生`的任务对象的功能添加到任何窗口类中：
- en: '[PRE22]'
  id: totrans-102
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'The `OnTimer` method will be called once every 100ms, when the `Timer` generates
    a new event. Each time, it will call the `TimerTask` object''s `ProcessNext` method
    to allow it to perform the next step in its processing:'
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: '`OnTimer` 方法将在每 100 毫秒被调用一次，当 `Timer` 生成一个新事件时。每次调用时，它将调用 `TimerTask` 对象的 `ProcessNext`
    方法，以便它能够执行其处理过程中的下一步：'
- en: '[PRE23]'
  id: totrans-104
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: How it works...
  id: totrans-105
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: First, let's take a look at our `TimerTaskBase` class, which defines the basic
    interface that our `TimerTaskMixin` class will use to execute the long running
    task. The `TimerTaskBase` class is very simple. It provides a `ProcessNext` method
    that must be overridden by a subclass in order to implement the processing of
    the next chunk of the task's work. This method will be called each time that the
    `TimerTaskMixin` class's Timer fires a `TimerEvent`. The other method, `InitTask`,
    is an optional override for a subclass to implement. It will be called immediately
    prior to the first `ProcessNext` call, and can be used to perform any set-up that
    the task may require prior to processing.
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，让我们看一下我们的 `TimerTaskBase` 类，它定义了我们的 `TimerTaskMixin` 类将用于执行长时间运行任务的基本接口。`TimerTaskBase`
    类非常简单。它提供了一个 `ProcessNext` 方法，该方法必须由子类重写以实现任务工作下一块的处理。每次 `TimerTaskMixin` 类的计时器触发
    `TimerEvent` 时，都会调用此方法。另一个方法 `InitTask` 是子类可选的重写，用于实现。它将在第一次调用 `ProcessNext` 之前立即被调用，并可用于执行任务在处理之前可能需要的任何设置。
- en: The `TimerTaskMixin` class is a mixin class that can be used with any `wx.Window-derived`
    class, such as a `Frame` or `Panel`. It adds the framework for managing a `TimerTask`
    object. This simple framework adds a `StartTask` method that can be used by the
    UI to start the processing of a `TimerTask. StartTask` takes the `TimerTask` object
    that needs to be processed, and then starts the `Timer`. The `Timer` will fire
    every 100ms in order to call the task's `ProcessNext` method, until the task reports
    that its state is in a completed state.
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: '`TimerTaskMixin` 类是一个混合类，它可以与任何 `wx.Window-derived` 类一起使用，例如 `Frame` 或 `Panel`。它为管理
    `TimerTask` 对象提供了框架。这个简单的框架添加了一个 `StartTask` 方法，该方法可以被 UI 用于启动 `TimerTask` 的处理。`StartTask`
    接收需要处理的 `TimerTask` 对象，然后启动 `Timer`。`Timer` 将每 100 毫秒触发一次，以调用任务的 `ProcessNext`
    方法，直到任务报告其状态处于完成状态。'
- en: There's more...
  id: totrans-108
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 还有更多...
- en: In the full sample code that accompanies this topic, there is a simple example
    application that uses this framework for transcribing a string of DNA code to
    RNA, as an example of breaking up a bigger task into many smaller tasks that are
    to be processed during timer events.
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 在本主题所附带的完整示例代码中，有一个简单的示例应用程序，它使用此框架将一串DNA代码转录为RNA，作为将更大任务分解为许多较小任务并在计时器事件中处理的示例。
- en: See also
  id: totrans-110
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 参见
- en: See the *Handling events* recipe in [Chapter 2](ch02.html "Chapter 2. Responding
    to Events"), *Responding to Events* for more information on event handling.
  id: totrans-111
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 请参阅[第2章](ch02.html "第2章。响应事件")中的*处理事件*配方，*响应事件*章节以获取更多关于事件处理的信息。
- en: See the *Using mixin classes* recipe in [Chapter 9](ch09.html "Chapter 9. Design
    Approaches and Techniques"), *Design Approaches and Techniques* for more information
    on and examples of working with mixin classes.
  id: totrans-112
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 有关使用混合类（mixin classes）的更多信息及示例，请参阅[第9章](ch09.html "第9章。设计方法和技巧")中的*使用混合类*配方，*设计方法和技巧*。
- en: Capturing output
  id: totrans-113
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 捕获输出
- en: This recipe takes a number of the concepts put forth earlier in this chapter,
    to create an `OutputWindow` component that can be used to capture console output
    from a subprocess and redirect it to a text display in an application. It will
    use `Threads` and `Timers` to implement a high-performance solution to this task,
    so let's get started and take a look at the code.
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 这个配方使用了本章前面提出的一些概念，来创建一个`OutputWindow`组件，它可以用来捕获子进程的控制台输出并将其重定向到应用程序中的文本显示。它将使用`Threads`和`Timers`来实现对这个任务的高性能解决方案，所以让我们开始并查看代码。
- en: Note
  id: totrans-115
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意事项
- en: When run on Windows, this recipe makes use of the pywin32 extension module.([http://sourceforge.net/projects/pywin32/](http://sourceforge.net/projects/pywin32/))
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 当在Windows上运行时，此配方使用pywin32扩展模块。（[http://sourceforge.net/projects/pywin32/](http://sourceforge.net/projects/pywin32/))
- en: How to do it...
  id: totrans-117
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何做到这一点...
- en: 'In this recipe, we will create two classes. The first will be a worker thread
    class that will run the `subprocess` and report its output to the GUI. The second
    will be the GUI component that makes use of the worker thread and displays its
    output:'
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个菜谱中，我们将创建两个类。第一个将是一个工作线程类，它将运行`subprocess`并将输出报告给GUI。第二个将是一个GUI组件，它将使用工作线程并显示其输出：
- en: '[PRE24]'
  id: totrans-119
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'The `ProcessThread` class will run a `subprocess` and read the process''s output
    from its output pipe, and then pass the data back to the thread''s `parent` object:'
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: '`ProcessThread` 类将运行一个 `subprocess` 并从其输出管道读取进程的输出，然后将数据传递回线程的 `parent` 对象：'
- en: '[PRE25]'
  id: totrans-121
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'Here, in the `ProcessThread''s run` method, we use the `subprocess` module
    from the Python standard library to start and run the process that we want to
    get output from:'
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里的`ProcessThread`的`run`方法中，我们使用Python标准库中的`subprocess`模块来启动和运行我们想要获取输出的进程：
- en: '[PRE26]'
  id: totrans-123
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: 'Here, we just loop as long as the process is running, reading its output and
    appending it to the `parent` object''s update queue:'
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们只需循环直到进程正在运行，读取其输出并将其附加到`parent`对象的更新队列中：
- en: '[PRE27]'
  id: totrans-125
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: Next, we have the GUI control for displaying a process's output. This class
    will use the `ProcessThread` to run a process and be the receiver for its data.
    It will maintain a list of threads so that there can be an arbitrary number of
    processes running at the same time.
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们有用于显示进程输出的GUI控件。这个类将使用`ProcessThread`来运行进程并作为其数据的接收者。它将维护一个线程列表，以便可以同时运行任意数量的进程。
- en: '[PRE28]'
  id: totrans-127
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: 'The `AppendUpdate` method is used by the `ProcessThread` to pass data to this
    control. The updates are appended to a list that we guard with a lock to ensure
    that only one thread is accessing it at a time:'
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: '`AppendUpdate` 方法由 `ProcessThread` 使用，以向此控件传递数据。更新被追加到一个列表中，我们使用锁来保护它，以确保一次只有一个线程可以访问它：'
- en: '[PRE29]'
  id: totrans-129
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: 'Next, we have a `Timer` event handler to periodically check the update list
    and apply them to the GUI:'
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们有一个`Timer`事件处理器，用于定期检查更新列表并将它们应用到GUI：
- en: '[PRE30]'
  id: totrans-131
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: 'Finally, the `StartProcess` method is what the application can use to tell
    the control to start a new process:'
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，`StartProcess` 方法是应用程序用来告诉控制器启动一个新进程的方法：
- en: '[PRE31]'
  id: totrans-133
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: How it works...
  id: totrans-134
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: 'First, let''s jump in with a look at our `ProcessThread` class. This is the
    worker thread that the `OutputWindow` uses to start an external process and capture
    its output from. The constructor takes three arguments: a parent window, a command-line
    string, and an optional keyword parameter that can specify the amount of text
    to block on reading from the process''s standard output on each iteration. Setting
    the `readblock` parameter to a small number will result in more responsive updates
    from the `ProcessThread`. However, setting it too low on a process that outputs
    lots of data can result in lots of small, inefficient updates. So it''s generally
    best to try to select a value that is as large as is appropriate for the given
    process''s output.'
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，让我们先看看我们的`ProcessThread`类。这是`OutputWindow`用来启动外部进程并捕获其输出的工作线程。构造函数接受三个参数：一个父窗口、一个命令行字符串，以及一个可选的关键字参数，该参数可以指定在每次迭代中从进程的标准输出读取时阻塞的文本量。将`readblock`参数设置为一个较小的数值将导致`ProcessThread`有更多的响应式更新。然而，在一个输出大量数据的进程中设置得太低可能会导致许多小而低效的更新。因此，通常最好尝试选择一个尽可能大的值，这个值对于给定进程的输出是合适的。
- en: The `ProcessThread's run` method is where it does all its work. First, we have
    to handle a special case for Windows, because `subprocess.POpen` can cause a command
    window to be opened when running shell commands. The use of the `startupflags`
    can be used to suppress this behavior since we want to show the output in our
    `OutputWindow` instead. Next, we use the `subprocess` module's `POpen` class to
    run the command specified in the constructor. Finally, the thread just enters
    a simple loop that checks to see if the process is still running, and if it is
    it then blocks the read of the specified amount of text from the processes output
    pipe. After the text has been read, it calls the `OutputWindow's AppendUpdate`
    method to add the output to its update queue.
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: '`ProcessThread` 的 `run` 方法是它执行所有工作的地方。首先，我们必须处理 Windows 的一个特殊情况，因为 `subprocess.POpen`
    在运行 shell 命令时可能会打开一个命令窗口。我们可以使用 `startupflags` 来抑制这种行为，因为我们希望将输出显示在我们的 `OutputWindow`
    中。接下来，我们使用 `subprocess` 模块的 `POpen` 类来运行构造函数中指定的命令。最后，线程进入一个简单的循环，检查进程是否仍在运行，如果是，则阻塞从进程输出管道中读取指定数量的文本。读取文本后，它调用
    `OutputWindow` 的 `AppendUpdate` 方法将输出添加到其更新队列中。'
- en: Now, let's see how the `OutputWindow` works to display the text that the `ProcessThread`
    captures. The `OutputWindow` derives from `StyledTextCtrl` because this can handle
    larger amounts of text with generally better performance than the standard `TextCtrl`,
    and has a more powerful API for working with the text in the buffer, should we
    decided to add some additional functionality at a later date. In the `OutputWindow's`
    constructor, we did a few important things. First, we created a lock to use for
    guarding the update queue so that only one thread can modify it at a time. If
    a second thread tries to `acquire` the lock while another thread has it, it will
    cause the second thread to wait at the `acquire` call until the lock is released
    by the other thread. The second is the update queue, third is the `Timer` that
    will be used to poll the update queue periodically, and finally we have a list
    to keep references to the `ProcessThread(s)` that are started.
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们看看`OutputWindow`是如何工作的，用于显示`ProcessThread`捕获的文本。`OutputWindow`是从`StyledTextCtrl`派生出来的，因为这样可以处理比标准`TextCtrl`更大的文本量，并且通常具有更好的性能，同时提供了一个更强大的API来处理缓冲区中的文本，以便我们决定在以后添加一些额外的功能。在`OutputWindow`的构造函数中，我们做了几件重要的事情。首先，我们创建了一个锁，用于保护更新队列，以确保一次只有一个线程可以修改它。如果第二个线程在另一个线程持有锁的情况下尝试`acquire`这个锁，它将导致第二个线程在`acquire`调用处等待，直到其他线程释放锁。第二是更新队列，第三是用于定期轮询更新队列的`Timer`，最后我们有一个列表来保存已启动的`ProcessThread(s)`的引用。
- en: The remaining methods in the `OutputWindow` class are all used to manage the
    updates from the `ProcessThread(s)` that it owns. `StartProcess` creates and starts
    a new `ProcessThread`, as well as the `OutputWindow's` update Timer if it hasn't
    been previously started. `AppendUpdate` is a thread-safe method for background
    threads to call and add updates to the `OutputWindow`. This method is safe to
    directly call from a background thread because the data object that it is modifying
    is guarded by a lock that will prevent more than one thread from modifying the
    object at the same time. This method was chosen over posting events from the worker
    threads because it can help to keep the UI more responsive during high-volume
    updates, because it allows the updates to the UI to be grouped into a smaller
    number of larger updates as opposed to many small updates which can lead to the
    UI becoming locked up while processing all the events. Last but not least is the
    `OnTimer` method, where the actual UI updates occur. `OnTimer` first checks and
    removes any threads that have finished running from the thread pool, and then
    it acquires the lock to make sure it has exclusive access to the update queue.
    After acquiring the lock, it proceeds to flush all the queued updates to the `OutputWindow`,
    and then empties the queue and releases the lock.
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: '`OutputWindow` 类中剩余的方法都是用来管理它所拥有的 `ProcessThread(s)` 的更新。`StartProcess` 方法用于创建并启动一个新的
    `ProcessThread`，如果之前尚未启动，还会启动 `OutputWindow` 的更新计时器。`AppendUpdate` 是一个线程安全的方法，供后台线程调用并添加更新到
    `OutputWindow`。这个方法可以直接从后台线程调用，因为它正在修改的数据对象被一个锁保护，这个锁可以防止多个线程同时修改对象。这个方法被选择而不是从工作线程发布事件，因为它可以帮助在大量更新时保持UI的响应性，因为它允许将UI更新分组为更少的较大更新，而不是许多小更新，这可能导致在处理所有事件时UI被锁定。最后但同样重要的是
    `OnTimer` 方法，在这里实际发生UI更新。`OnTimer` 首先检查并移除线程池中已经完成运行的任何线程，然后获取锁以确保它对更新队列有独占访问权。在获取锁之后，它继续将所有排队更新刷新到
    `OutputWindow`，然后清空队列并释放锁。'
- en: There's more...
  id: totrans-139
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 还有更多...
- en: 'See the sample code that accompanies this topic for a small, sample application
    that makes use of the `OutputWindow` to create a GUI display for running the ping
    command:'
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 请参阅本主题所附的示例代码，以了解一个小型示例应用程序，该应用程序利用`OutputWindow`创建用于运行ping命令的GUI显示：
- en: '![There''s more...](img/1780_11_04.jpg)'
  id: totrans-141
  prefs: []
  type: TYPE_IMG
  zh: '![还有更多...](img/1780_11_04.jpg)'
- en: See also
  id: totrans-142
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 参见
- en: See the *Understanding thread safety* recipe in this chapter for a discussion
    of what thread safety is as it relates to the GUI.
  id: totrans-143
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 请参阅本章中的*理解线程安全*配方，以了解线程安全与GUI相关的讨论。
- en: See the *Using Timers* recipe in this chapter for another example of using Timers.
  id: totrans-144
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 请参阅本章中的*使用计时器*配方，以了解使用计时器的另一个示例。
