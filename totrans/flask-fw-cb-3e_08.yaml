- en: '8'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Admin Interface for Flask Apps
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Many applications require an interface that provides special privileges to some
    users and can be used to maintain and upgrade an application’s resources. For
    example, we can have an interface in an e-commerce application that will allow
    some special users to create categories, products, and more. Some users might
    have special permissions to handle other users who shop on the website, deal with
    their account information, and so on. Similarly, there can be many cases where
    we need to isolate some parts of the interface of our application from normal
    users.
  prefs: []
  type: TYPE_NORMAL
- en: In comparison to the very popular Python-based web framework, Django, Flask
    does not provide any admin interface by default. Although this can be seen as
    a shortcoming by many, this gives developers the flexibility to create the admin
    interface as per their requirements and have complete control over the application.
  prefs: []
  type: TYPE_NORMAL
- en: We can choose to write an admin interface for our application from scratch or
    use an extension of Flask, which does most of the work for us and gives us the
    option to customize the logic as needed. One very popular extension for creating
    admin interfaces in Flask is Flask-Admin ([https://flask-admin.readthedocs.io/en/latest/](https://flask-admin.readthedocs.io/en/latest/)).
    It is inspired by the Django admin but is implemented in a way that gives the
    developer complete control over the look, feel, and functionality of the application.
    In this chapter, we will start with the creation of an admin interface on our
    own, and then move on to using the `Flask-Admin` extension and fine-tune this
    as needed.
  prefs: []
  type: TYPE_NORMAL
- en: 'In this chapter, we will cover the following recipes:'
  prefs: []
  type: TYPE_NORMAL
- en: Creating a simple CRUD interface
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Using the Flask-Admin extension
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Registering models with Flask-Admin
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Creating custom forms and actions
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Using a WYSIWYG editor for `textarea` integration
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Creating user roles
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Creating a simple CRUD interface
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '**CRUD** refers to **Create, Read, Update, and Delete**. A basic necessity
    of an admin interface is to have the ability to create, modify, or delete the
    records/resources from the application as and when needed. We will create a simple
    admin interface that will allow admin users to perform these operations on the
    records that other normal users generally can’t.'
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: We will start with the authentication application from the *Authenticating using
    the Flask-Login extension* recipe in [*Chapter 6*](B19111_06.xhtml#_idTextAnchor328),
    *Authenticating in Flask*, and add admin authentication with an interface for
    admins, which would allow only the admin users to create, update, and delete user
    records. Here, in this recipe, I will cover some specific parts that are necessary
    to understand the concepts. For the complete application, you can refer to the
    code samples available for the book.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'To create a simple admin interface, perform the following steps:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Start with the models by adding a new `BooleanField` field called `admin` to
    the `User` model in `auth/models.py`. This field will help in identifying whether
    the user is an admin or not:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE1]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE2]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE3]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE4]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE5]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE6]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE7]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE8]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE9]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE10]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE11]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE12]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE13]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: The preceding method simply returns the value of the admin field. This can have
    a custom implementation as per our requirements.
  prefs: []
  type: TYPE_NORMAL
- en: Tip
  prefs: []
  type: TYPE_NORMAL
- en: Since this is a new field being added to the `User` model, database migration
    should be done. You can refer to the *Migrating databases using Alembic and Flask-Migrate*
    recipe in [*Chapter 3*](B19111_03.xhtml#_idTextAnchor129), *Data Modeling in Flask*,
    for more details.
  prefs: []
  type: TYPE_NORMAL
- en: 'Create two forms that will be used by the admin views in `auth/models.py`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE15]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE16]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE17]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE18]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE19]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE20]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE21]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE22]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE23]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Now, modify the views in `auth/views.py` to implement the admin interface:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE25]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE26]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE27]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE28]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE29]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE30]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE31]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE32]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE33]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE34]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: The preceding code is the `admin_login_required` decorator, which works just
    like the `login_required` decorator. Here, the difference is that it needs to
    be implemented along with `login_required`, and it checks whether the currently
    logged-in user is an admin.
  prefs: []
  type: TYPE_NORMAL
- en: 'Create the following handlers, which will be needed to create a simple admin
    interface. Note the usage of the `@admin_login_required` decorator. Everything
    else is pretty much standard, as we learned in the previous chapters of this book
    that focused on views and authentication handling. All the handlers will go in
    `auth/views.py`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE36]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE37]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE38]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE39]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE40]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE41]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE42]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE43]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE44]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE45]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE46]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE47]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE48]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE49]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE50]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE51]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE52]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE53]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE54]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE55]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE56]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE57]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE58]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE59]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE60]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE61]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE62]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE63]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE64]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE65]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE66]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE67]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE68]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE69]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE70]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE71]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE72]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE73]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE74]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE75]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE76]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: The preceding method allows admin users to create new users in the system. This
    works in a manner that is pretty similar to the `register()` method but allows
    the admin to set the `admin` flag on the user.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following method allows the admin users to update the records of other
    users:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE77]'
  prefs: []
  type: TYPE_PRE
- en: However, as per the best practices of writing web applications, we do not allow
    the admin to simply view and change the passwords of any user. In most cases,
    the provision to change passwords should rest with the user who owns the account.
    Although admins can have the provision to update the password in some cases, still,
    it should never be possible for them to see the passwords set by the user earlier.
    This topic is discussed in the *Creating custom forms and actions* recipe.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following method handles the deletion of a user by an admin:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE78]'
  prefs: []
  type: TYPE_PRE
- en: The `user_delete_admin()` method should actually be implemented on a `POST`
    request. This is left to you to implement by yourself.
  prefs: []
  type: TYPE_NORMAL
- en: Followed by models and views, create some templates to complement them. It might
    have been evident to many of you from the code of the views itself that we need
    to add four new templates, namely, `admin-home.html`, `user-create- admin.html`,
    `user-update-admin.html`, and `users-list-admin.html`. How these work is shown
    in the next section. You should now be able to implement these templates by yourself;
    however, for reference, the code is always available with the samples provided
    with the book.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: How it works...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'To begin, we added a menu item to the application; this provides a direct link
    to the admin home page, which will look like the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 8.1 – Menu item for admin access](img/B19111_08_01.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 8.1 – Menu item for admin access
  prefs: []
  type: TYPE_NORMAL
- en: 'A user must be logged in as the admin to access this page and other admin-related
    pages. If a user is not logged in as the admin, then the application will show
    an error, as shown in the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 8.2 – Forbidden error for non-admin users](img/B19111_08_02.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 8.2 – Forbidden error for non-admin users
  prefs: []
  type: TYPE_NORMAL
- en: Information
  prefs: []
  type: TYPE_NORMAL
- en: Create an admin user before you can log in as the admin. To create an admin
    user, you can make DB changes in SQLAlchemy from the command line using SQL queries.
    Another simpler but hacky way of doing this is to change the `admin` flag to `True`
    in `auth/models.py` and then register a new user. This new user will be an admin
    user. Make sure that you revert the `admin` flag to `False` as the default after
    this is done.
  prefs: []
  type: TYPE_NORMAL
- en: 'To a logged-in admin user, the admin home page will look as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 8.3 – Admin home page](img/B19111_08_03.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 8.3 – Admin home page
  prefs: []
  type: TYPE_NORMAL
- en: From here, the admin can see the list of users on a system or create a new user.
    The options to edit or delete the users will be available on the user list page
    itself.
  prefs: []
  type: TYPE_NORMAL
- en: Using the Flask-Admin extension
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '`Flask-Admin` is an available extension that helps in the creation of admin
    interfaces for our application in a simpler and faster way. All the subsequent
    recipes in this chapter will focus on using and extending this extension.'
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'First, we need to install the `Flask-Admin` extension:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE79]'
  prefs: []
  type: TYPE_PRE
- en: We will extend our application from the previous recipe and keep building on
    the same.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it…
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Adding a simple admin interface to any Flask application using the `Flask-Admin`
    extension is just a matter of a couple of statements.
  prefs: []
  type: TYPE_NORMAL
- en: 'Simply add the following lines to the application’s configuration in `my_app/__init__.py`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE80]'
  prefs: []
  type: TYPE_PRE
- en: 'You can also add your own views to this; this is as simple as adding a new
    class as a new view that inherits from the `BaseView` class, as shown in the following
    code block. This code block goes in `auth/views.py`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE81]'
  prefs: []
  type: TYPE_PRE
- en: 'After this, add this view to the `admin` object in the Flask configuration
    in `my_app/__init__.py`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE82]'
  prefs: []
  type: TYPE_PRE
- en: 'One thing to notice here is that this page does not have any authentication
    or authorization logic implemented by default, and it will be accessible to all.
    The reason for this is that `Flask-Admin` does not make any assumptions about
    the authentication system in place. As we are using `Flask-Login` for our applications,
    you can add a method named `is_accessible()` to your `HelloView` class:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE83]'
  prefs: []
  type: TYPE_PRE
- en: How it works…
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Just initializing an application with the `Admin` class from the `Flask-Admin
    extension`, as demonstrated in the first step of this recipe, will put up a basic
    admin page, as shown in the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 8.4 – Admin home page using Flask-Admin](img/B19111_08_04.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 8.4 – Admin home page using Flask-Admin
  prefs: []
  type: TYPE_NORMAL
- en: Notice the URL in the screenshot, which is `http://127.0.0.1:5000/admin/`. Pay
    special attention to the forward slash (`/`) at the end of the URL. If you miss
    that forward slash, then it would open the web page from the last recipe.
  prefs: []
  type: TYPE_NORMAL
- en: 'The addition of the custom `HelloView` in the second step will make the admin
    page look like the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: "![Figure 8.5 – Adding a dummy Hello\uFEFF view](img/B19111_08_05.jpg)"
  prefs: []
  type: TYPE_IMG
- en: Figure 8.5 – Adding a dummy Hello view
  prefs: []
  type: TYPE_NORMAL
- en: There’s more…
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'After implementing the preceding code, there is still an admin view that won’t
    be completely user-protected and will be publicly available. This will be the
    admin home page. To make this available only to the admins, we have to inherit
    from `AdminIndexView` and implement `is_accessible()`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE84]'
  prefs: []
  type: TYPE_PRE
- en: 'Then, just pass this view to the `admin` object in the application’s configuration
    as `index_view`, and we are done:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE85]'
  prefs: []
  type: TYPE_PRE
- en: This approach makes all our admin views accessible only to the admin users.
    We can also implement any permission or conditional access rules in `is_accessible()`
    as and when required.
  prefs: []
  type: TYPE_NORMAL
- en: Registering models with Flask-Admin
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In the previous recipe, we learned how to get started with the `Flask-Admin`
    extension to create admin interfaces/views for our application. In this recipe,
    we will examine how to implement admin views for our existing models with the
    facilities to perform CRUD operations.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: We will extend our application from the previous recipe to include an admin
    interface for the `User` model.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it…
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Again, with `Flask-Admin`, registering a model with the admin interface is
    very easy; perform the following steps:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Just add the following single line of code to `auth/views.py`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE86]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE87]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE88]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Here, in the first line, we imported `ModelView` from `flask_admin.contrib.sqla`,
    which is provided by `Flask-Admin` to integrate SQLAlchemy models.
  prefs: []
  type: TYPE_NORMAL
- en: Looking at the screenshot corresponding to the first step in the *How it works…*
    section of this recipe (*Figure 8.6*), most of us will agree that showing the
    password hash to any user, be they an admin or a normal user, does not make sense.
    Additionally, the default model-creation mechanism provided by `Flask-Admin` will
    fail for our `User` creation, because we have an `__init__()` method in our `User`
    model. This method expects values for the three fields (`username`, `password`,
    and `is_admin`), while the model-creation logic implemented in `Flask-Admin` is
    very generic and does not provide any value during model creation.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, customize the default behavior of `Flask-Admin` to something of your own,
    where you fix the `User` creation mechanism and hide the password hash from view
    in `auth/views.py`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE89]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE90]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE91]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE92]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE93]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE94]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE95]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE96]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE97]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE98]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE99]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: The preceding code shows some rules and settings that our admin view for `User`
    will follow. These are self-explanatory via their names. A couple of them, `column_exclude_list`
    and `form_excluded_columns`, might appear to be slightly confusing. The former
    will exclude the columns mentioned from the admin view itself and refrain from
    using them in search, creation, and other CRUD operations. The latter will prevent
    the field from being shown on the form for CRUD operations.
  prefs: []
  type: TYPE_NORMAL
- en: 'Create a method in `auth/views.py` that overrides the creation of the form
    from the model and adds a `password` field, which will be used in place of the
    password hash:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE100]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE101]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE102]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE103]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE104]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE105]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Then, override the model-creation logic in `auth/views.py` to suit the application:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE106]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE107]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE108]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE109]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE110]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE111]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE112]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE113]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE114]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Finally, add this model to the `admin` object in the application config in
    `my_app/__init__.py` by writing the following:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE115]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE116]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Information
  prefs: []
  type: TYPE_NORMAL
- en: Notice the `self._on_model_change(form, model, True)` statement. Here, the last
    parameter, `True`, signifies that the call is for the creation of a new record.
  prefs: []
  type: TYPE_NORMAL
- en: How it works…
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The first step will create a new admin view for the `User` model, which will
    look like the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 8.6 – List of users without custom logic](img/B19111_08_06.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 8.6 – List of users without custom logic
  prefs: []
  type: TYPE_NORMAL
- en: 'After all the steps have been followed, the admin interface for the `User`
    model will look like the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 8.7 – List of users with password hash hidden](img/B19111_08_07.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 8.7 – List of users with password hash hidden
  prefs: []
  type: TYPE_NORMAL
- en: We have a search box here, and no password hash is visible. There are changes
    to the user creation and edit views too. I recommend that you run the application
    to see this for yourself.
  prefs: []
  type: TYPE_NORMAL
- en: Creating custom forms and actions
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this recipe, we will create a custom form using the forms provided by `Flask-Admin`.
    Additionally, we will create a custom action using the custom form.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'In the previous recipe, we saw that the edit form view for the `User` record
    update had no option to update the password for the user. The form looked like
    the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: "![Figure 8.8 – \uFEFFBuilt-in user edit form](img/B19111_08_08.jpg)"
  prefs: []
  type: TYPE_IMG
- en: Figure 8.8 – Built-in user edit form
  prefs: []
  type: TYPE_NORMAL
- en: In this recipe, we will customize this form to allow administrators to update
    the password for any user.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it…
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The implementation of this feature will only require changes to `views.py`:'
  prefs: []
  type: TYPE_NORMAL
- en: 'First, start by importing `rules` from the `Flask-Admin` form:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE117]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: In the previous recipe, we had `form_edit_rules`, which had just two fields
    – that is, `username` and `admin` – as a list. This denoted the fields that will
    be available for editing to the admin user in the `User` model’s update view.
  prefs: []
  type: TYPE_NORMAL
- en: 'Updating the password is not simply a case of just adding one more field to
    the `form_edit_rules` list; this is because we do not store cleartext passwords.
    Instead, we store password hashes that cannot be edited directly by users. We
    need to input the password from the user and then convert it to a hash while storing.
    Take a look at how to do this in the following code:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE118]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE119]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE120]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE121]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE122]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE123]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE124]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE125]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: The preceding piece of code signifies that we now have a header in our form;
    this header separates the password reset section from the rest of the section.
    Then, add two new fields, `new_password` and `confirm`, which will help us safely
    change the password.
  prefs: []
  type: TYPE_NORMAL
- en: 'This also calls for a change to the `scaffold_form()` method so that the two
    new fields become valid while form rendering:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE126]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE127]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE128]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE129]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE130]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE131]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE132]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE133]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE134]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE135]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Finally, implement the `update_model()` method, which is called when we try
    to update the record:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE136]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE137]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE138]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE139]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE140]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE141]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE142]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE143]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE144]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE145]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE146]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE147]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: In the preceding code, we will first make sure that the password entered in
    both fields is the same. If it is, then we will proceed with resetting the password,
    along with any other change.
  prefs: []
  type: TYPE_NORMAL
- en: How it works…
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The user update form will now look like the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 8.9 – Custom form with a custom action](img/B19111_08_09.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 8.9 – Custom form with a custom action
  prefs: []
  type: TYPE_NORMAL
- en: Here, if we enter the same password in both of the password fields, the user
    password will be updated.
  prefs: []
  type: TYPE_NORMAL
- en: Using a WYSIWYG editor for textarea integration
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: As users of websites, we all know that writing beautifully formatted text using
    the normal `textarea` fields is a nightmare. There are plugins that make our life
    easier and turn simple `textarea` fields into `textarea` fields.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: We start by adding a new `textarea` field to our `User` model for notes and
    then integrate this field with CKEditor to write formatted text. This will include
    the addition of a JavaScript library and a CSS class to a normal `textarea` field
    to convert this into a CKEditor-compatible `textarea` field.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it…
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'To integrate CKEditor with your application, perform the following steps:'
  prefs: []
  type: TYPE_NORMAL
- en: 'First, add the `notes` field to the `User` model in `auth/models.py`, as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE148]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE149]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE150]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE151]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE152]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE153]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE154]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE155]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE156]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE157]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE158]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE159]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE160]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Important
  prefs: []
  type: TYPE_NORMAL
- en: In order to add a new field, you might need to run migration scripts. You can
    refer to the *Migrating databases using Alembic and Flask-Migrate* recipe in [*Chapter
    3*](B19111_03.xhtml#_idTextAnchor129), *Data Modeling in Flask*, for more details.
  prefs: []
  type: TYPE_NORMAL
- en: 'After this, create a custom `wtform` widget and a field for the CKEditor `textarea`
    field in `auth/models.py`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE161]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE162]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE163]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE164]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE165]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE166]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: In the custom widget in the preceding code, we added a `ckeditor` class to our
    `TextArea` widget. For more insights into the WTForms widgets, you can refer to
    the *Creating a custom widget* recipe in [*Chapter 5*](B19111_05.xhtml#_idTextAnchor273),
    *Web Forms* *with WTForms*.
  prefs: []
  type: TYPE_NORMAL
- en: 'Next, create a custom field that inherits `TextAreaField` and updates it to
    use the widget created in the previous step:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE167]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE168]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: In the custom field in the preceding code, we set the widget to `CKTextAreaWidget`,
    and when this field will be rendered, the `ckeditor` CSS class will be added to
    it.
  prefs: []
  type: TYPE_NORMAL
- en: 'Next, modify `form_edit_rules` in the `UserAdminView` class in `auth/views.py`,
    where we specify the template to be used for the `create` and `edit` forms. Additionally,
    override the normal `TextAreaField` object with `CKTextAreaField` for `notes`.
    Make sure that you import `CKTextAreaField` from `auth/models.py`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE169]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE170]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE171]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: In the preceding code block, `form_overrides` enables the overriding of a normal
    `textarea` field with the CKEditor `textarea` field.
  prefs: []
  type: TYPE_NORMAL
- en: 'The final part of this recipe is the `templates/edit.html` template, which
    was mentioned earlier:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE172]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE173]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE174]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE175]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: /4.20.1/standard/ckeditor.js"></script>
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE176]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '{% endblock %}'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE177]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Here, we extend the default `edit.html` file provided by Flask-Admin and add
    the CKEditor JS file so that our `ckeditor` class in `CKTextAreaField` works.
  prefs: []
  type: TYPE_NORMAL
- en: How it works…
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'After we have made all the changes, the create user form will look like the
    following screenshot; in particular, notice the **Notes** field:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 8.10 – Notes field created using a WYSIWYG editor](img/B19111_08_10.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 8.10 – Notes field created using a WYSIWYG editor
  prefs: []
  type: TYPE_NORMAL
- en: Here, anything entered in the **Notes** field will be automatically formatted
    in HTML while saving and can be used anywhere later for display purposes.
  prefs: []
  type: TYPE_NORMAL
- en: See also
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: This recipe is inspired by the **gist** by the author of Flask-Admin. The gist
    can be found at [https://gist.github.com/mrjoes/5189850](https://gist.github.com/mrjoes/5189850).
  prefs: []
  type: TYPE_NORMAL
- en: You can also choose to directly use the Flask-CKEditor extension, which can
    be found at [https://flask-ckeditor.readthedocs.io/en/latest/](https://flask-ckeditor.readthedocs.io/en/latest/).
    I have not used the extension because I wanted to demonstrate the concept from
    a lower level.
  prefs: []
  type: TYPE_NORMAL
- en: Creating user roles
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: So far, we have discovered how a view that is accessible to a certain set of
    admin users can be created easily using the `is_accessible()` method. This can
    be extended to have different kinds of scenarios, where specific users will be
    able to view specific views. There is another way of implementing user roles at
    a much more granular level in a model, where the roles determine whether a user
    can perform all, some, or any of the CRUD operations.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In this recipe, we will explore a basic way of creating user roles, where an
    admin user can only perform actions they are entitled to.
  prefs: []
  type: TYPE_NORMAL
- en: Information
  prefs: []
  type: TYPE_NORMAL
- en: Remember that this is just one way of implementing user roles. There are a number
    of better ways of doing this, but this one appears to be the best one to demonstrate
    the concept of creating user roles. One such method would be to create user groups
    and assign roles to the groups, rather than individual users. Another method can
    be the more complex policy-based user roles, which will include defining the roles
    according to complex business logic. This approach is usually employed by business
    systems such as ERP, CRM, and more.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it…
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'To add basic user roles to the application, perform the following steps:'
  prefs: []
  type: TYPE_NORMAL
- en: 'First, add a field named `roles` to the `User` model in `auth/models.py`, as
    follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE178]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE179]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE180]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE181]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE182]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE183]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE184]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE185]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE186]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE187]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE188]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE189]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE190]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE191]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE192]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Here, we added a new field, `roles`, which is a string field with a length of
    `4`. We assumed that the only entries that are possible in this field are any
    combinations of `C`, `R`, `U`, and `D`. A user with the `roles` value as `CRUD`
    will have permission to perform all the actions, while any missing permissions
    will prevent the user from performing that action. Note that read permissions
    are always implied to any admin user, whether specified or not.
  prefs: []
  type: TYPE_NORMAL
- en: Important
  prefs: []
  type: TYPE_NORMAL
- en: In order to add a new field, you might need to run migration scripts. You can
    refer to the *Migrating databases using Alembic and Flask-Migrate* recipe in [*Chapter
    3*](B19111_03.xhtml#_idTextAnchor129), *Data Modeling in Flask*, for more details.
  prefs: []
  type: TYPE_NORMAL
- en: 'Next, make some changes to the `UserAdminView` class in `auth/views.py`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE193]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE194]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE195]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE196]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE197]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE198]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE199]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE200]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE201]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE202]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE203]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: In the preceding code, we just added the `roles` field to our `create` and `edit`
    forms. We also inherited a class called `ActionsMixin`. This is necessary to handle
    the mass update actions such as mass deletion.
  prefs: []
  type: TYPE_NORMAL
- en: 'Next, we have the methods that we need to implement conditions and handle the
    logic for various roles:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'First is the method that handled the creation of a model:'
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE204]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE205]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE206]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE207]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE208]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE209]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE210]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE211]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE212]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE213]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE214]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE215]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE216]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE217]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: In the preceding method, we first checked whether the `roles` field in `current_user`
    has permission to create records (this is denoted by `C`). If not, we show an
    error message and return from the method.
  prefs: []
  type: TYPE_NORMAL
- en: 'Next is the method that would handle the update:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE218]'
  prefs: []
  type: TYPE_PRE
- en: In the preceding method, we first checked whether the `roles` field in `current_user`
    has permission to update records (this is denoted by `U`). If not, we show an
    error message and return from the method.
  prefs: []
  type: TYPE_NORMAL
- en: 'The next method handles the deletion:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE219]'
  prefs: []
  type: TYPE_PRE
- en: Similarly, in the preceding method, we checked whether `current_user` is allowed
    to delete records.
  prefs: []
  type: TYPE_NORMAL
- en: 'Finally, the need to check for relevant roles and permission is addressed:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE220]'
  prefs: []
  type: TYPE_PRE
- en: In the preceding method, we checked whether the action is `delete` and whether
    `current_user` is allowed to delete. If not, then we flash the error message and
    return a `False` value. This method can be extended to handle any custom-written
    actions too.
  prefs: []
  type: TYPE_NORMAL
- en: How it works…
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: This recipe works in a manner that is very similar to how our application has
    been working so far, except for the fact that, now, users with designated roles
    will be able to perform specific operations. Otherwise, error messages will be
    displayed.
  prefs: []
  type: TYPE_NORMAL
- en: 'The user list will now look like the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 8.11 – Admin role assigned to users](img/B19111_08_11.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 8.11 – Admin role assigned to users
  prefs: []
  type: TYPE_NORMAL
- en: To test the rest of the functionality, such as creating new users (both normal
    and admin), deleting users, updating user records, and more, I urge you to try
    it for yourself.
  prefs: []
  type: TYPE_NORMAL
