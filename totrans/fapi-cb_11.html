<html><head></head><body>
<div><div><h1 class="chapter-number" id="_idParaDest-349"><a id="_idTextAnchor352"/>11</h1>
<h1 id="_idParaDest-350"><a id="_idTextAnchor353"/>Middleware and Webhooks</h1>
<p>In this chapter, we delve into the advanced and crucial aspects of middleware and webhooks in FastAPI. Middleware in FastAPI allows you to process requests and responses globally before they reach your route handlers and after they leave them. Webhooks, on the other hand, enable your FastAPI application to communicate with other services by sending real-time data updates. Both middleware and webhooks are essential for building robust, efficient, and scalable applications.</p>
<p>We will start by exploring how to create custom <strong class="bold">Asynchronous Server Gateway Interface</strong> (<strong class="bold">ASGI</strong>) middleware<a id="_idIndexMarker730"/> from scratch. This will give you a deep understanding of how middleware works at a fundamental level.</p>
<p>Next, we’ll develop middleware specifically for response modification, allowing you to intercept and alter responses before they are sent back to the client.</p>
<p>We will also cover <a id="_idIndexMarker731"/>handling <strong class="bold">Cross-Origin Resource Sharing</strong> (<strong class="bold">CORS</strong>) with middleware. This is particularly important for applications that need to interact with different domains securely. Finally, we will dive into creating webhooks in FastAPI, demonstrating how to set them up and test them effectively.</p>
<p>By the end of this chapter, you will have a comprehensive understanding of how to implement and utilize middleware and webhooks in your FastAPI applications. These skills will enable you to build more dynamic, responsive, and integrated web services.</p>
<p>In this chapter, we’re going to go through the following recipes:</p>
<ul>
<li>Creating custom ASGI middleware</li>
<li>Developing middleware for request modification</li>
<li>Developing middleware for response modification</li>
<li>Handling CORS with middleware</li>
<li>Restricting incoming requests from hosts</li>
<li>Implementing webhooks</li>
</ul>
<h1 id="_idParaDest-351"><a id="_idTextAnchor354"/>Technical requirements</h1>
<p>At this stage of the book, you should already have a good understanding of the basics of FastAPI, how to install it, and how to run it.</p>
<p>The code used in the chapter is hosted on GitHub at the following address: <a href="https://github.com/PacktPublishing/FastAPI-Cookbook/tree/main/Chapter11">https://github.com/PacktPublishing/FastAPI-Cookbook/tree/main/Chapter11</a>.</p>
<p>It is recommended to set up a virtual environment for the project in the project root folder to efficiently manage dependencies and maintain project isolation.</p>
<p>Throughout the chapter, we will only be using the standard <code>fastapi</code> library with <code>uvicorn</code>. You can install all the dependencies within your virtual environment using <code>pip</code> from the command line by running the following:</p>
<pre class="console">
$ pip install fastapi uvicorn</pre> <p>For the <em class="italic">Handling CORS with middleware</em> recipe, having some basic knowledge of JavaScript and HTML will be beneficial.</p>
<h1 id="_idParaDest-352"><a id="_idTextAnchor355"/>Creating custom ASGI middleware</h1>
<p>ASGI is a specification for <a id="_idIndexMarker732"/>Python web servers and applications to communicate with each other, designed to support asynchronous functionality. Middleware is a critical component in web applications, providing a way to process requests and responses.</p>
<p>We have already seen, in the <em class="italic">Creating custom middleware</em> recipe in <a href="B21025_08.xhtml#_idTextAnchor262"><em class="italic">Chapter 8</em></a>, <em class="italic">Advanced Features and Best Practices</em>, how to create custom middleware. However, this technique relies on the <code>BasicHTTPMiddleware</code> class from the Starlette library, which is a high-level implementation of HTTP middleware.</p>
<p>In this recipe, we’ll learn how to create custom ASGI middleware from scratch and integrate it into a FastAPI application. The middleware will be simple and will only print log message information on the terminal.</p>
<p>This approach provides greater control over the request/response cycle compared to the <code>BasicHTTPMiddleware</code> class, allowing for advanced customizations and the creation of any kind of middleware with a deeper level of customization.</p>
<h2 id="_idParaDest-353"><a id="_idTextAnchor356"/>Getting ready</h2>
<p>Since we will use the Starlette library to build middleware, a sound knowledge of this library would be beneficial, although not necessary.</p>
<p>Regarding the development environment, we will exclusively utilize the <code>fastapi</code> package with <code>uvicorn</code>. Ensure they are installed in your environment.</p>
<h2 id="_idParaDest-354"><a id="_idTextAnchor357"/>How to do it…</h2>
<p>Let’s start by creating a project root folder called <code>middleware_project</code>. Under the root folder, create a folder called <code>middleware</code> containing a module called <code>asgi_middleware.py</code>. Let’s<a id="_idIndexMarker733"/> start the module by declaring the logger that we will use during the middleware call:</p>
<pre class="source-code">
import logging
logger = logging.getLogger("uvicorn")</pre> <p>Then we can define the middleware class as follows:</p>
<pre class="source-code">
from starlette.types import (
    ASGIApp, Scope, Receive, Send
)
class ASGIMiddleware:
    def __init__(
        self, app: ASGIApp, parameter: str = "default"
):
        self.app = app
        self.parameter = parameter
    async def __call__(
        self,
        scope: Scope,
        receive: Receive,
        send: Send,
    ):
        logger.info("Entering ASGI middleware")
        logger.info(
            f"The parameter is: {self.parameter}"
        )
        await self.app(scope, receive, send)
        logger.info("Exiting ASGI middleware")</pre> <p>Then, we need to include the middleware in our application. Under the project root folder, create <a id="_idIndexMarker734"/>the <code>main.py</code> module containing the FastAPI class to run the application, as follows:</p>
<pre class="source-code">
from fastapi import FastAPI
from starlette.middleware import Middleware
from middleware.asgi_middleware import ASGIMiddleware
app = FastAPI(
    title="Middleware Application",
    middleware=[
        Middleware(
            ASGIMiddleware,
            parameter="example_parameter",
        ),
    ]
)</pre> <p>This is all you need to implement custom ASGI middleware in a FastAPI application.</p>
<h2 id="_idParaDest-355"><a id="_idTextAnchor358"/>How it works…</h2>
<p>To see the middleware in action, let’s create a general endpoint in <code>main.py</code> module, as in the following example:</p>
<pre class="source-code">
@app.get("/")
async def read_root():
    return {"Hello": "Middleware World"}</pre> <p>Spin up the server by running <code>uvicorn main:app</code> from the command line. You will see the following messages:</p>
<pre class="console">
INFO:    Started server process [2064]
INFO:    Waiting for application startup.
INFO:    Entering ASGI middleware
INFO:    The parameter is: example_parameter</pre> <p>Among the <a id="_idIndexMarker735"/>messages, you will notice those indicating that we have already entered the middleware. Now try to call the root endpoint. You can do it by opening the browser at <code>http://localhost:8000/</code>.</p>
<p>Still on the terminal, this time you will notice both middleware messages for entering and exiting:</p>
<pre class="console">
INFO:    Entering ASGI middleware
INFO:    The parameter is: example_parameter
INFO:    127.0.0.1:55750 - "GET / HTTP/1.1" 200 OK
INFO:    Exiting ASGI middleware</pre> <p>As we understand from the logs, we entered the middleware twice, once on the startup and once when calling the endpoint, but we exited the middleware only once.</p>
<p>This is why the ASGI middleware intercepts every event of the application, not only the HTTP request but also the <code>lifespan</code> event, which includes the startup and shutdown.</p>
<p>Information on the event type within the middleware is stored in the <code>scope</code> parameter of the <code>__call__</code> method. Let’s include the following logs in the <code>ASGIMiddleware.__call__</code> method <a id="_idIndexMarker736"/>to improve our understanding of the mechanism:<a id="_idTextAnchor359"/></p>
<pre class="source-code">
class ASGIMiddleware:
    def __init__(
        self,
        app: ASGIApp,
        parameter: str = "default",
    ):
    # method content
    async def __call__(
        self,
        scope: Scope,
        receive: Receive,
        send: Send,
    ):
        # previous logs
<strong class="bold">        logger.info(</strong>
<strong class="bold">            f"event scope: {scope.get('type')}"</strong>
<strong class="bold">        )</strong>
        await self.app(scope, receive, send)</pre> <p>If you restart the server and remake the call to <code>http://localhost:8000/</code>, you will now see the log messages specifying the event scope type to be <code>lifespan</code> at the server startup and <code>http</code> after the endpoint call.</p>
<h2 id="_idParaDest-356"><a id="_idTextAnchor360"/>There’s more…</h2>
<p>We have just seen how<a id="_idIndexMarker737"/> to build ASGI middleware as a class. However, you can also do it by leveraging the function decorator pattern. For example, you can build the same middleware like this:</p>
<pre class="source-code">
def asgi_middleware(
    app: ASGIApp, parameter: str = "default"
):
    @functools.wraps(app)
    async def wrapped_app(
        scope: Scope, receive: Receive, send: Send
    ):
        logger.info(
            "Entering second ASGI middleware"
        )
        logger.info(
            f"The parameter you proved is: {parameter}"
        )
        logger.info(
            f"event scope: {scope.get('type')}"
        )
        await app(scope, receive, send)
        logger.info("Exiting second ASGI middleware")
    return wrapped_app</pre> <p>This is the equivalent of the <code>ASGIMiddleware</code> class defined earlier in the <em class="italic">How to do it…</em> subsection. To make it work, it should be passed as an argument to the FastAPI instance in exactly the same way:</p>
<pre class="source-code">
from middleware.asgi_middleware import asgi_middleware
app = FastAPI(
    title="Middleware Application",
    middleware=[
        Middleware(
            asgi_middleware,
            parameter="example_parameter",
        ),
    ]</pre> <p>Based on your personal preference, you can choose the style you prefer. However, for the rest of the<a id="_idIndexMarker738"/> chapter, we will continue using the middleware class style.</p>
<h2 id="_idParaDest-357"><a id="_idTextAnchor361"/>See also</h2>
<p>You can read more<a id="_idIndexMarker739"/> on the ASGI specification in the dedicated documentation page:</p>
<ul>
<li><em class="italic">ASGI </em><em class="italic">Documentation</em>: <a href="https://asgi.readthedocs.io/en/latest/">https://asgi.readthedocs.io/en/latest/</a></li>
</ul>
<p>Middleware classes in FastAPI derive from the Starlette library. You can find extensive documentation on creating <a id="_idIndexMarker740"/>ASGI middleware on the Starlette documentation page:</p>
<ul>
<li><em class="italic">Pure ASGI </em><em class="italic">Middleware</em>: <a href="https://www.starlette.io/middleware/#pure-asgi-middleware">https://www.starlette.io/middleware/#pure-asgi-middleware</a></li>
</ul>
<h1 id="_idParaDest-358"><a id="_idTextAnchor362"/>Developing middleware for request modification</h1>
<p>Middleware in web applications<a id="_idIndexMarker741"/> serves as a powerful tool for processing requests. Custom middleware can intercept and modify these messages, allowing developers to add or modify functionalities.</p>
<p>In this recipe, we’ll focus on developing custom ASGI middleware to modify responses before they are sent to the client by hashing the body of each request, if necessary. This approach provides the flexibility to add or change response headers, body content, and other properties dynamically. By the end of the recipe, you will be able to develop custom middleware to control every API request.</p>
<h2 id="_idParaDest-359"><a id="_idTextAnchor363"/>Getting ready</h2>
<p>Before we begin, please make sure you have completed the previous recipe, <em class="italic">Creating custom ASGI middleware</em>, to create specific custom ASGI middleware. We will be working on the <code>middleware_project</code> application, but the recipe can easily be applied to any application.</p>
<p>Before creating the middleware, in the <code>main.py</code> module, let’s create a <code>POST /send</code> endpoint that <a id="_idIndexMarker742"/>accepts body content in the request, as follows:</p>
<pre class="source-code">
import logging
logger = logging.getLogger("uvicorn")
@app.post("/send")
async def send(message: str = Body()):
    logger.info(f"Message: {message}")
    return message</pre> <p>The endpoint will print the body content to the terminal and return it as a response as well.</p>
<p>Now that we have our endpoint, we can create the middleware to hash the body content before sending it to the endpoint.</p>
<h2 id="_idParaDest-360"><a id="_idTextAnchor364"/>How to do it…</h2>
<p>In the <code>middleware</code> folder, let’s create a module called <code>request_middleware.py</code> that will host our middleware class. Let’s go through the following steps to create the middleware:</p>
<ol>
<li>Start the module with the required imports like this:<pre class="source-code">
from starlette.types import (
    ASGIApp, Scope, Receive, Send, Message,
)
from hashlib import sha1</pre><p class="list-inset">We will use the types from the Starlette library to create the middleware class and the <code>sha1</code> function to hash the body.</p></li> <li> Given that only certain <code>HTTP</code> verbs accept the body (<code>POST</code> and <code>PUT</code>, but not <code>GET</code> for example), we will pass to the middleware the paths as parameters where the modifications should be applied.<p class="list-inset">Create a <a id="_idIndexMarker743"/>middleware class called <code>HashBodyContentMiddleware</code>, as follows:</p><pre class="source-code">
class HashBodyContentMiddleWare:
    def __init__(
        self, app: ASGIApp, allowed_paths: list[str]
    ):
        self.app = app
        self.allowed_paths = allowed_paths</pre><p class="list-inset">We will pass the list of paths into the <code>allowed_paths</code> parameters.</p></li> <li>Define the <code>__call__</code> method of the class:<pre class="source-code">
    async def __call__(
        self,
        scope: Scope,
        receive: Receive,
        send: Send,
    ):
        if (
            scope["type"] != "http"
            or scope["path"]
            not in self.allowed_paths
        ):
            await self.app(scope, receive, send)
            return</pre><p class="list-inset">If the event is not an HTTP request or the path is not listed, the middleware won’t take any action and will leave the request passing through the next step.</p></li> <li>The information about the body is brought by the <code>receive</code> variable. However, the <code>receive</code> variable is a coroutine, and it should be passed as that to the <code>self.app</code> object. We will overcome this by creating a new coroutine within the function, as <a id="_idIndexMarker744"/>follows:<pre class="source-code">
        # continue the __call__ method content
        async def receive_with_new_body() -&gt; Message:
            message = await receive()
            assert message["type"] == "http.request"
            body = message.get("body", b"")
            message["body"] = (
                f'"{sha1(body).hexdigest()}"'.encode()
            )
            return message
        await self.app(
            scope,
            receive_with_new_body,
            send,
        )</pre><p class="list-inset">The body request will be modified by the coroutine that is passed to the following steps of the FastAPI object application.</p></li> <li>Now we need to add the middleware to the FastAPI instance. We can do it in the <code>main.py</code> module. But this time we will leverage the <code>add_middleware</code> method of the FastAPI instance object like this:<pre class="source-code">
app.add_middleware(
    HashBodyContentMiddleWare,
    allowed_paths=["/send"],
)</pre><p class="list-inset">Now the application will make the request pass through our middleware.</p></li> </ol>
<p>This is all you <a id="_idIndexMarker745"/>need to implement it. To test the middleware, let’s spin up the server with <code>uvicorn</code> from the command line by running the following:</p>
<pre class="console">
$ uvicorn main:app</pre> <p>Then go to the interactive documentation at <code>http://localhost:8000/docs</code> and test the <code>POST/send</code> endpoint. For example, check whether you can send a body string like this:</p>
<pre class="source-code">
"hello middleware"</pre> <p>If everything is correctly done, you should receive a response body like this:</p>
<pre class="source-code">
"14bb256ec4a292037c01bdbdd3eac61f328515f3"</pre> <p>You have just implemented custom ASGI middleware that hashes the body for the specified endpoints.</p>
<p>This was a simple example, but the potential of controlling requests is limitless. For example, you can use it to introduce an additional security layer to prevent cross-scripting injection <a id="_idIndexMarker746"/>of undesired content.</p>
<h2 id="_idParaDest-361"><a id="_idTextAnchor365"/>See also</h2>
<p>Creating middleware to modify the request is documented on the Starlette documentation page:</p>
<ul>
<li><em class="italic">Inspecting or modifying the </em><em class="italic">request</em>: <a href="https://www.starlette.io/middleware/#inspecting-or-modifying-the-request">https://www.starlette.io/middleware/#inspecting-or-modifying-the-request</a></li>
</ul>
<h1 id="_idParaDest-362"><a id="_idTextAnchor366"/>Developing middleware for response modification</h1>
<p>Besides processing <a id="_idIndexMarker747"/>requests, middleware in web applications is also a powerful tool for processing responses. Custom middleware allows us to intercept responses before they are returned to the API caller. This can be useful for checking response content or personalizing the response. In this recipe, we will develop custom ASGI middleware to add customized headers to all the responses.</p>
<h2 id="_idParaDest-363"><a id="_idTextAnchor367"/>Getting ready</h2>
<p>We will be creating custom ASGI middleware that modifies the response of each HTTP call. Before we get started on this recipe, take a look at the <em class="italic">Creating custom ASGI middleware</em> recipe. Also, this recipe will be complementary to the previous recipe, <em class="italic">Developing middleware for </em><em class="italic">request modification</em>.</p>
<p>While you can apply this recipe to your own project, we will continue working on the <code>middleware_project</code> project that we initialized in the <em class="italic">Developing middleware for request </em><em class="italic">modification</em> recipe.</p>
<h2 id="_idParaDest-364"><a id="_idTextAnchor368"/>How to do it…</h2>
<p>We will create our middleware class in a dedicated module in the <code>middleware</code> folder. We will call the module <code>response_middleware.py</code>. Let's start building the middleware by going through the following steps.</p>
<ol>
<li>Let’s start writing the imports we will use to define the middleware:<pre class="source-code">
from typing import Sequence
from starlette.datastructures import MutableHeaders
from starlette.types import (
    ASGIApp, Receive, Scope, Send, Message
)</pre></li> <li>Then, we can start defining the <code>ExtraHeadersResponseMiddleware</code> middleware class as follows:<pre class="source-code">
class ExtraHeadersResponseMiddleware:
    def __init__(
        self,
        app: ASGIApp,
        headers: Sequence[tuple[str, str]],
    ):
        self.app = app
        self.headers = headers</pre></li> <li>We will pass<a id="_idIndexMarker748"/> the headers list as an argument to the middleware. Then, the <code>__call__</code> method will be as follows:<pre class="source-code">
    async def __call__(
        self,
        scope: Scope,
        receive: Receive,
        send: Send,
    ):
        if scope["type"] != "http":
            return await self.app(
                scope, receive, send
            )</pre></li> <li>We restrain the middleware to HTTP event calls. Similar to what we saw in the previous recipe, <em class="italic">Developing middleware for request modification</em>, we modify the send <a id="_idIndexMarker749"/>object, which is a coroutine, and we pass it to the next middleware, as follows:<pre class="source-code">
        async def send_with_extra_headers(
            message: Message
        ):
            if (
                message["type"]
                == "http.response.start"
            ):
                headers = MutableHeaders(
                    scope=message
                )
                for key, value in self.headers:
                    headers.append(key, value)
            await send(message)
        await self.app(
            scope, receive, send_with_extra_headers
        )</pre><p class="list-inset">The response’s headers are generated from the <code>message</code> parameter of the <code>send_with_extra_headerds</code> coroutine object.</p></li> <li>Once the middleware is defined, we need to add it to the <code>FastAPI</code> object instance to make it effective. We can add it in the <code>main.py</code> module as follows:<pre class="source-code">
app.add_middleware(
    ExtraHeadersResponseMiddleware,
    headers=(
        ("new-header", "fastapi-cookbook"),
        (
            "another-header",
            "fastapi-cookbook",
        ),
    ),
)</pre><p class="list-inset">Here, we add two headers to the response, <code>new-header</code> and <code>another-header</code>. </p><p class="list-inset">To test it, spin up the server by running <code>uvicorn main:app</code> and open the interactive documentation. Call one of the endpoints and check the headers in the response.</p><p class="list-inset">Here is the list of the headers you get when calling the <code>GET /</code> endpoint:</p><pre class="source-code"><strong class="bold">another-header: fastapi-cookbook</strong>
content-length: 28
content-type: application/json
date: Thu,23 May 2024 09:24:41 GMT
<strong class="bold">new-header: fastapi-cookbook</strong>
server: uvicorn</pre><p class="list-inset">You will find<a id="_idIndexMarker750"/> the two headers we previously added to the default ones.</p></li> </ol>
<p>You have just implemented middleware that modifies API responses.</p>
<h2 id="_idParaDest-365"><a id="_idTextAnchor369"/>See also</h2>
<p>In the Starlette documentation, you can find an example of how to create middleware that modifies the response:</p>
<ul>
<li><em class="italic">Inspecting or modifying the </em><em class="italic">response</em>: <a href="https://www.starlette.io/middleware/#inspecting-or-modifying-the-response">https://www.starlette.io/middleware/#inspecting-or-modifying-the-response</a></li>
</ul>
<h1 id="_idParaDest-366"><a id="_idTextAnchor370"/>Handling CORS with middleware</h1>
<p>CORS is a security<a id="_idIndexMarker751"/> feature <a id="_idIndexMarker752"/>implemented in web browsers to prevent malicious websites from making unauthorized requests to APIs hosted on different origins. When building APIs, especially for public consumption, it’s crucial to handle CORS properly to ensure legitimate requests are served while unauthorized ones are blocked.</p>
<p>In this recipe, we will explore how to handle CORS using custom middleware in FastAPI. This approach allows us to deeply understand the CORS mechanism and gain flexibility in customizing the behavior to fit specific requirements.</p>
<h2 id="_idParaDest-367"><a id="_idTextAnchor371"/>Getting ready</h2>
<p>We will apply the recipe to the <code>middleware_project</code> application. Make sure you have the FastAPI application running with at least the <code>GET /</code> endpoint already set up.</p>
<p>Since the recipe will show how to set up CORS middleware to manage CORS, you will need a simple HTML web page that calls our API.</p>
<p>You can create one yourself or download the <code>cors_page.xhtml</code> file from the project’s GitHub repository. The file is a simple HTML page that sends a request to the FastAPI application at <code>http://localhost:8000/</code> and displays the response on the same page.</p>
<p>Before starting the recipe, spin up your FastAPI application by running <code>uvicorn main:app</code>. To view the page, open <code>cors_page.xhtml</code> using a modern browser. Then, open the developer console. In most browsers, you can do this by right-clicking on the page, selecting <strong class="bold">Inspect</strong> from the menu, and then toggling to the <strong class="bold">Console</strong> tab.</p>
<p>On the page, press the <strong class="bold">Send CORS Request</strong> button. You should see an error message on the command line like the following:</p>
<pre class="console">
Access to fetch at 'http://localhost:8000/' from origin 'null' has been blocked by CORS policy: Response to preflight request doesn't pass access control check: No 'Access-Control-Allow-Origin' header is present on the requested resource. If an opaque response serves your needs, set the request's mode to 'no-cors' to fetch the resource with CORS disabled.</pre> <p>That means that the call has been blocked by the CORS policy.</p>
<p>Let’s start the recipe and see how to fix it.</p>
<h2 id="_idParaDest-368"><a id="_idTextAnchor372"/>How to do it…</h2>
<p>In FastAPI, CORS can be handled with a dedicated <code>CORSMiddleware</code> class from the Starlette library.</p>
<p>Let’s add<a id="_idIndexMarker753"/> the<a id="_idIndexMarker754"/> middleware to our application in the <code>main.py</code> module:</p>
<pre class="source-code">
from fastapi.middleware.cors import CORSMiddleware
# rest of the module
app.add_middleware(
    CORSMiddleware,
    allow_origins=["*"],
    allow_methods=["*"],
    allow_headers=["*"],
)</pre> <p>Now, rerun the server, open <code>cors_page.xhtml</code> again, and try to press the <strong class="bold">Send CORS Request</strong> button. This time, you see the response message directly on the page.</p>
<p>The <code>allow_origins</code> parameter specifies the host origin from which the CORS should be allowed. If <code>allow_origins=[*]</code>, it means that any origin is allowed.</p>
<p>The <code>allow_methods</code> parameter specifies the HTTP methods that are allowed. By default, only <code>GET</code> is allowed, and if <code>allow_methods=[*]</code>, it means that all methods are allowed.</p>
<p>Then, the <code>allow_headers</code> parameter specifies the headers that are allowed. Similarly, if we use <code>allow_headers=[*]</code>, it means that all headers are allowed.</p>
<p>In a production environment, it’s important to carefully evaluate each of these parameters to ensure security standards and to make your application run safely.</p>
<p>This is all that’s <a id="_idIndexMarker755"/>needed to <a id="_idIndexMarker756"/>implement CORS middleware for allowing CORS from clients.</p>
<h2 id="_idParaDest-369"><a id="_idTextAnchor373"/>See also</h2>
<p>For more information<a id="_idIndexMarker757"/> about CORS, check out the <strong class="bold">Mozilla</strong> documentation page:</p>
<ul>
<li><em class="italic">CORS</em>: <a href="https://developer.mozilla.org/en-US/docs/Web/HTTP/CORS">https://developer.mozilla.org/en-US/docs/Web/HTTP/CORS</a></li>
</ul>
<p>You can see more about the functionalities and discover other parameters of the CORS middleware in FastAPI on the documentation page:</p>
<ul>
<li><em class="italic">Use </em><em class="italic">CORSMiddleware</em>: <a href="https://fastapi.tiangolo.com/tutorial/cors/#use-corsmiddleware">https://fastapi.tiangolo.com/tutorial/cors/#use-corsmiddleware</a></li>
</ul>
<p>You can also have a look at the Starlette documentation page:</p>
<ul>
<li><em class="italic">CORSMiddleware</em>: <a href="https://www.starlette.io/middleware/#corsmiddleware">https://www.starlette.io/middleware/#corsmiddleware</a></li>
</ul>
<h1 id="_idParaDest-370"><a id="_idTextAnchor374"/>Restricting incoming requests from hosts</h1>
<p>In modern web<a id="_idIndexMarker758"/> applications, security is paramount. One crucial aspect of security is ensuring that your application only processes requests from trusted sources. This practice helps to mitigate risks <a id="_idIndexMarker759"/>such as <strong class="bold">Domain Name System</strong> (<strong class="bold">DNS</strong>) rebinding attacks, where an attacker tricks a user’s browser into interacting with an unauthorized domain.</p>
<p>FastAPI provides middleware called <code>TrustedHostMiddleware</code>, which allows you to specify which hosts are considered trusted. Requests from any other hosts will be rejected. This recipe will guide you through setting up and using the <code>TrustedHostMiddleware</code> class to secure your FastAPI application by accepting requests only from specific hosts.</p>
<h2 id="_idParaDest-371"><a id="_idTextAnchor375"/>Getting ready</h2>
<p>We will apply the recipe to the <code>middleware_project</code> application. The application will need to be working with at least one endpoint to test.</p>
<h2 id="_idParaDest-372"><a id="_idTextAnchor376"/>How to do it…</h2>
<p>Let’s restrict the request to calls coming from localhost. In <code>main.py</code>, let’s import <code>TrustedHostMiddleware</code> and add it to<a id="_idIndexMarker760"/> the FastAPI object instance application, as follows:</p>
<pre class="source-code">
from fastapi.middleware.trustedhost import (
    TrustedHostMiddleware,
)
# rest of the module
app.add_middleware(
    TrustedHostMiddleware,
    allowed_hosts=["localhost"],
)</pre> <p>To test it, let’s try to refuse a call. Let’s spin up the server by broadcasting our service to the network. We can do it by specifying the undefined host address, <code>0.0.0.0</code>, when running <code>uvicorn</code>, as follows:</p>
<pre class="console">
$ uvicorn main:app --host=0.0.0.0</pre> <p>This will make our application visible to the network.</p>
<p>To retrieve the address of your machine within the local network, you can run <code>ipconfig</code> on Windows or <code>ip addr</code> on Linux or macOS.</p>
<p>From another device connected to the same local network as the machine running our FastAPI application (such as a smartphone), open a browser and enter <code>http://&lt;your local address&gt;:8000</code>. If everything is correctly set up, you will see the following message in the browser:</p>
<pre class="source-code">
Invalid host header</pre> <p>While on the machine running the FastAPI server, you will see a log message like the following:</p>
<pre class="console">
INFO: &lt;client ip&gt;:57312 - "GET / HTTP/1.1" 400 Bad Request</pre> <p>This is all you need to set up middleware to prevent your application from being reached by <a id="_idIndexMarker761"/>undesired hosts.</p>
<h2 id="_idParaDest-373"><a id="_idTextAnchor377"/>See also</h2>
<p>You can learn more <a id="_idIndexMarker762"/>about <code>TrustedHostMiddleware</code> on the FastAPI documentation page:</p>
<ul>
<li><em class="italic">TrustedHostMiddleware</em>: <a href="https://fastapi.tiangolo.com/advanced/middleware/#trustedhostmiddleware">https://fastapi.tiangolo.com/advanced/middleware/#trustedhostmiddleware</a></li>
</ul>
<p>Since <code>TrustedHostMiddleware</code> is defined in the Starlette library, you can also find it in the Starlette documentation at the following link:</p>
<ul>
<li><em class="italic">TrustedHostMiddleware</em>: <a href="https://www.starlette.io/middleware/#trustedhostmiddleware">https://www.starlette.io/middleware/#trustedhostmiddleware</a></li>
</ul>
<h1 id="_idParaDest-374"><a id="_idTextAnchor378"/>Implementing webhooks</h1>
<p><strong class="bold">Webhooks</strong> play a <a id="_idIndexMarker763"/>crucial role in modern web development by enabling different systems to communicate and respond to events in real time. They are essentially HTTP callbacks triggered by specific events in one system, which then send a message or payload to another system. This asynchronous event-driven architecture allows for seamless integration with third-party services, real-time notifications, and automated workflows. Understanding how to implement webhooks effectively will empower you to build more interactive and responsive applications.</p>
<p>In this recipe, we will see how to create webhooks in FastAPI. We will create a webhook that notifies the webhook subscribers for each request of the API, acting like a monitoring system. By the end of this recipe, you will be able to implement a robust webhook system in your FastAPI application, facilitating real-time communication and integration with other services.</p>
<h2 id="_idParaDest-375"><a id="_idTextAnchor379"/>Getting ready</h2>
<p>To set up the webhook for sending requests to the subscriber, we will use custom ASGI middleware. Please ensure that you have already followed the <em class="italic">Creating custom ASGI middleware</em> recipe. We will be continuing our work on the <code>middleware_project</code> API. However, you will find guidelines on how to implement your webhook that can be easily adapted to the specific needs of your project.</p>
<p>If you are starting<a id="_idIndexMarker764"/> a new project from scratch, make sure to install the <code>fastapi</code> package with <code>uvicorn</code> in your environment. You can do this using <code>pip</code>:</p>
<pre class="console">
$ pip install fastapi uvicorn</pre> <p>Once you have the packages, we can start the recipe.</p>
<h2 id="_idParaDest-376"><a id="_idTextAnchor380"/>How to do it…</h2>
<p>To build a webhook system in our API, we will need to do the following:</p>
<ol>
<li>Set up the URL registration system.</li>
<li>Implement the webhook callbacks.</li>
<li>Document the webhook.</li>
</ol>
<p>Let’s go through the implementation.</p>
<h3>Setting up the URL registration system</h3>
<p>A webhook call<a id="_idIndexMarker765"/> will send an HTTP request to the <a id="_idIndexMarker766"/>list of URLs registered to the webhook. The API will require a URL registration system. This can be achieved by creating a dedicated endpoint that will store the URL in a stateful system, such as a database. However, for demonstration purposes, we will store the URLs in the application state, which might also be a good choice for small applications.</p>
<p>Let’s create it by going through the following steps:</p>
<ol>
<li>In <code>main.py</code>, let’s create the lifespan context manager to store the registered URLs:<pre class="source-code">
from contextlib import asynccontextmanager
@asynccontextmanager
async def lifespan(app: FastAPI):
    yield {"webhook_urls": []}</pre></li> <li>Let’s pass the lifespan as an argument to the FastAPI object, as follows:<pre class="source-code">
app = FastAPI(
<strong class="bold">    lifespan=lifespan,</strong>
# rest of the parameters
)</pre></li> <li>Then, we can create the endpoint to register the URL, as follows:<pre class="source-code">
@app.post("/register-webhook-url")
async def add_webhook_url(
    request: Request, url: str = Body()
):
    if not url.startswith("http"):
        url = f"http://{url}"
    request.state.webhook_urls.append(url)
    return {"url added": url}</pre><p class="list-inset">The endpoint will accept a text string in the body. If the <code>http</code> or <code>https</code> protocol is missing in the string, an <code>"http://"</code> string will be prepended to the URL before being stored.</p></li> </ol>
<p>You have just<a id="_idIndexMarker767"/> implemented the URL registration <a id="_idIndexMarker768"/>system. Now, let’s continue to implement the webhook callbacks.</p>
<h3>Implementing the webhook callbacks</h3>
<p>After setting up the<a id="_idIndexMarker769"/> registration system, we can begin creating the webhook’s calls. As previously stated, this particular webhook will alert subscribers for every API call. We’ll utilize this information to develop specialized middleware that will handle the calls. Let’s do it by following these steps:</p>
<ol>
<li>Let’s create a new module in the <code>middleware</code> folder called <code>webhook.py</code> and define the event to communicate with the subscribers:<pre class="source-code">
from pydantic import BaseModel
class Event(BaseModel):
    host: str
    path: str
    time: str
    body: str | None = None</pre></li> <li>Then, we define a coroutine that will be used to make the requests to the subscriber URLs, as follows:<pre class="source-code">
import logging
from httpx import AsyncClient
client = AsyncClient()
logger = logging.getLogger("uvicorn")
async def send_event_to_url(
    url: str, event: Event
):
    logger.info(f"Sending event to {url}")
    try:
        await client.post(
            f"{url}/fastapi-webhook",
            json=event.model_dump(),
        )
    except Exception as e:
        logger.error(
            "Error sending webhook event "
            f"to {url}: {e}"
        )</pre><p class="list-inset">The client sends a<a id="_idIndexMarker770"/> request to the URL. If the request fails, a message is printed to the terminal.</p></li> <li>We then define the middleware that will intercept the request. We start with the imports, as follows:<pre class="source-code">
from asyncio import create_task
from datetime import datetime
from fastapi import Request
from starlette.types import (
    ASGIApp, Receive, Scope, Send,
)</pre><p class="list-inset">We then add the <code>WebhookSenderMiddleware</code> class, as follows</p><pre class="source-code">class WebhookSenderMiddleWare:
    def __init__(self, app: ASGIApp):
        self.app = app
    async def __call__(
        self,
        scope: Scope,
        receive: Receive,
        send: Send,
    ):</pre></li> <li>We will filter<a id="_idIndexMarker771"/> only the HTTP requests, as follows:<pre class="source-code">
        if scope["type"] == "http":
            message = await receive()
            body = message.get("body", b"")
            request = Request(scope=scope)</pre></li> <li>We continue in the <code>same __call__</code> function by defining the <code>event</code> object to pass to the webhook subscribers:<pre class="source-code">
            event = Event(
                host=request.client.host,
                path=request.url.path,
                time=datetime.now().isoformat(),
                body=body,
            )</pre></li> <li>Then, we iterate the calls over the URLs by running the <code>send_event_to_url</code> coroutine, as follows:<pre class="source-code">
            urls = request.state.webhook_urls
            for url in urls:
                await create_task(
                    send_event_to_url(url, event)
                )</pre></li> <li>We finalize the <a id="_idIndexMarker772"/>method by returning the modified <code>receive</code> function to the application:<pre class="source-code">
            async def continue_receive():
                return message
            await self.app(
                scope, continue_receive, send
            )
            return
        await self.app(scope, receive, send)</pre><p class="list-inset">We have just defined the middleware that will make the calls.</p></li> <li>Now we need to import the <code>WebhookSenderMiddleWare</code> middleware in the application. We can do this inside <code>main.py</code> as follows:<pre class="source-code">
from middleware.webhook import (
WebhookSenderMiddleWare
)
# rest of the code
app.add_middleware(WebhookSenderMiddleWare)</pre><p class="list-inset">The application will now include our middleware to handle the webhook callbacks.</p></li> </ol>
<p>That is all you need <a id="_idIndexMarker773"/>to implement a complete webhook within your FastAPI application.</p>
<h3>Documenting the webhook</h3>
<p>It is important to<a id="_idIndexMarker774"/> provide API users with documentation on how the webhook functions. FastAPI allows us to document a webhook in the OpenAPI documentation.</p>
<p>To accomplish this, you need to create a function with an empty body and declare it as a webhook endpoint. You can do it in <code>main.py</code> as well:</p>
<pre class="source-code">
@app.webhooks.post("/fastapi-webhook")
def fastapi_webhook(event: Event):
    """_summary_
    Args:
        event (Event): Received event from webhook
        It contains information about the
        host, path, timestamp and body of the request
    """</pre> <p>You can also provide an example of the body content by adding specifications to the <code>Event</code> class in the <code>middleware/webhook.py</code> module, as follows:</p>
<pre class="source-code">
class Event(BaseModel):
    host: str
    path: str
    time: str
    body: str | None = None
<strong class="bold">    model_config = {</strong>
<strong class="bold">        "json_schema_extra": {</strong>
<strong class="bold">            "examples": [</strong>
<strong class="bold">                {</strong>
<strong class="bold">                    "host": "127.0.0.1",</strong>
<strong class="bold">                    "path": "/send",</strong>
<strong class="bold">                    "time": "2024-05-22T14:24:28.847663",</strong>
<strong class="bold">                    "body": '"body content"',</strong>
<strong class="bold">                </strong><strong class="bold">}</strong>
<strong class="bold">            ]</strong>
<strong class="bold">        }</strong>
<code>uvicorn main:app</code> command and opening the browser at <code>http://localhost:8000/docs</code>, you will find the documentation for <code>POST /fastapi-webhook</code> in the <code>POST </code><code>register-webhook-url</code> endpoint.</p>
<h2 id="_idParaDest-377"><a id="_idTextAnchor381"/>How it works…</h2>
<p>To test the webhook, yo<a id="_idIndexMarker776"/>u can set up a simple server running locally on a specific port. You can create one yourself or download the <code>http_server.py</code> file from the GitHub repository. This server will run on port <code>8080</code>.</p>
<p>Once you have set up the server, you can run it from the command line:</p>
<pre class="console">
$ python ./http_server.py</pre> <p>Leave the server running and make sure the FastAPI application is running on a separate terminal.</p>
<p>Open the interactive documentation at <code>http://localhost:8000/docs</code>. Using the <code>POST /register-webhook-url</code> endpoint, add the <code>"localhost:8080"</code> address. Make sure you specify the correct port in the URL.</p>
<p>Now try to call any of the endpoints to the API. The FastAPI application will make a call to the server listening at port <code>8080</code>. If you check the service terminal, you will see the messages streaming<a id="_idIndexMarker777"/> on the terminal containing the information for each call.</p>
<h2 id="_idParaDest-378"><a id="_idTextAnchor382"/>There’s more…</h2>
<p>While the basic implementation of webhooks is powerful, several advanced concepts and enhancements can make your webhook system more robust, secure, and efficient. Some of the most relevant ones are as follows:</p>
<ul>
<li><strong class="bold">Authentication</strong>: To <a id="_idIndexMarker778"/>ensure that your API can securely communicate with a webhook endpoint, you can implement any sort of authentication, from API to OAuth.</li>
<li><strong class="bold">Retry mechanism</strong>: Webhooks rely on HTTP, which is not always reliable. There may be instances where the webhook delivery fails due to network issues, server downtime, or other transient errors. Implementing a retry mechanism ensures that webhook events are eventually delivered even if the initial attempt fails.</li>
<li><strong class="bold">Persistent storage</strong>: Storing webhook events in a database allows you to keep an audit trail, troubleshoot issues, and replay events if necessary. You can use SQLAlchemy, a SQL toolkit <a id="_idIndexMarker779"/>and <strong class="bold">object-relational mapping</strong> library for Python, to save webhook events in a relational database.</li>
<li><strong class="bold">WebSocket webhook</strong>: For real-time updates, you can set up a WebSocket server in FastAPI and notify clients through WebSocket connections when webhooks are received.</li>
<li><strong class="bold">Rate limiting</strong>: To prevent abuse and server overload, rate limiting can be applied to the webhook endpoint. This ensures that a single client cannot overwhelm the server with too many requests in a short period.</li>
</ul>
<p>Webhooks are crucial for constructing interactive, event-driven applications that seamlessly<a id="_idIndexMarker780"/> integrate with third-party systems. Utilize them to their fullest potential.</p>
<h2 id="_idParaDest-379"><a id="_idTextAnchor383"/>See also</h2>
<p>If you want to learn more about webhook applications, check <a id="_idIndexMarker781"/>out the <strong class="bold">Red Hat</strong> blog page explaining what it <a id="_idIndexMarker782"/>is and how it is used in modern applications:</p>
<ul>
<li><em class="italic">What is a </em><em class="italic">webhook?</em>: <a href="https://www.redhat.com/en/topics/automation/what-is-a-webhook">https://www.redhat.com/en/topics/automation/what-is-a-webhook</a></li>
</ul>
<p>You can also refer to the FastAPI documentation for information on how to document webhook endpoints in the OpenAPI documentation:</p>
<ul>
<li><em class="italic">OpenAPI </em><em class="italic">Webhooks</em>: <a href="https://fastapi.tiangolo.com/advanced/openapi-webhooks/">https://fastapi.tiangolo.com/advanced/openapi-webhooks/</a></li>
</ul>
</div>
</div></body></html>