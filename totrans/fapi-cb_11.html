<html><head></head><body>
<div id="sbo-rt-content"><div id="_idContainer015">
<h1 class="chapter-number" id="_idParaDest-349"><a id="_idTextAnchor352"/>11</h1>
<h1 id="_idParaDest-350"><a id="_idTextAnchor353"/>Middleware and Webhooks</h1>
<p>In this chapter, we delve into the advanced and crucial aspects of middleware and webhooks in FastAPI. Middleware in FastAPI allows you to process requests and responses globally before they reach your route handlers and after they leave them. Webhooks, on the other hand, enable your FastAPI application to communicate with other services by sending real-time data updates. Both middleware and webhooks are essential for building robust, efficient, and <span class="No-Break">scalable applications.</span></p>
<p>We will start by exploring how to create custom <strong class="bold">Asynchronous Server Gateway Interface</strong> (<strong class="bold">ASGI</strong>) middleware<a id="_idIndexMarker730"/> from scratch. This will give you a deep understanding of how middleware works at a <span class="No-Break">fundamental level.</span></p>
<p>Next, we’ll develop middleware specifically for response modification, allowing you to intercept and alter responses before they are sent back to <span class="No-Break">the client.</span></p>
<p>We will also cover <a id="_idIndexMarker731"/>handling <strong class="bold">Cross-Origin Resource Sharing</strong> (<strong class="bold">CORS</strong>) with middleware. This is particularly important for applications that need to interact with different domains securely. Finally, we will dive into creating webhooks in FastAPI, demonstrating how to set them up and test <span class="No-Break">them effectively.</span></p>
<p>By the end of this chapter, you will have a comprehensive understanding of how to implement and utilize middleware and webhooks in your FastAPI applications. These skills will enable you to build more dynamic, responsive, and integrated <span class="No-Break">web services.</span></p>
<p>In this chapter, we’re going to go through the <span class="No-Break">following recipes:</span></p>
<ul>
<li>Creating custom <span class="No-Break">ASGI middleware</span></li>
<li>Developing middleware for <span class="No-Break">request modification</span></li>
<li>Developing middleware for <span class="No-Break">response modification</span></li>
<li>Handling CORS <span class="No-Break">with middleware</span></li>
<li>Restricting incoming requests <span class="No-Break">from hosts</span></li>
<li><span class="No-Break">Implementing webhooks</span></li>
</ul>
<h1 id="_idParaDest-351"><a id="_idTextAnchor354"/>Technical requirements</h1>
<p>At this stage of the book, you should already have a good understanding of the basics of FastAPI, how to install it, and how to <span class="No-Break">run it.</span></p>
<p>The code used in the chapter is hosted on GitHub at the following <span class="No-Break">address: </span><a href="https://github.com/PacktPublishing/FastAPI-Cookbook/tree/main/Chapter11"><span class="No-Break">https://github.com/PacktPublishing/FastAPI-Cookbook/tree/main/Chapter11</span></a><span class="No-Break">.</span></p>
<p>It is recommended to set up a virtual environment for the project in the project root folder to efficiently manage dependencies and maintain <span class="No-Break">project isolation.</span></p>
<p>Throughout the chapter, we will only be using the standard <strong class="source-inline">fastapi</strong> library with <strong class="source-inline">uvicorn</strong>. You can install all the dependencies within your virtual environment using <strong class="source-inline">pip</strong> from the command line by running <span class="No-Break">the following:</span></p>
<pre class="console">
$ pip install fastapi uvicorn</pre> <p>For the <em class="italic">Handling CORS with middleware</em> recipe, having some basic knowledge of JavaScript and HTML will <span class="No-Break">be beneficial.</span></p>
<h1 id="_idParaDest-352"><a id="_idTextAnchor355"/>Creating custom ASGI middleware</h1>
<p>ASGI is a specification for <a id="_idIndexMarker732"/>Python web servers and applications to communicate with each other, designed to support asynchronous functionality. Middleware is a critical component in web applications, providing a way to process requests <span class="No-Break">and responses.</span></p>
<p>We have already seen, in the <em class="italic">Creating custom middleware</em> recipe in <a href="B21025_08.xhtml#_idTextAnchor262"><span class="No-Break"><em class="italic">Chapter 8</em></span></a>, <em class="italic">Advanced Features and Best Practices</em>, how to create custom middleware. However, this technique relies on the <strong class="source-inline">BasicHTTPMiddleware</strong> class from the Starlette library, which is a high-level implementation of <span class="No-Break">HTTP middleware.</span></p>
<p>In this recipe, we’ll learn how to create custom ASGI middleware from scratch and integrate it into a FastAPI application. The middleware will be simple and will only print log message information on <span class="No-Break">the terminal.</span></p>
<p>This approach provides greater control over the request/response cycle compared to the <strong class="source-inline">BasicHTTPMiddleware</strong> class, allowing for advanced customizations and the creation of any kind of middleware with a deeper level <span class="No-Break">of customization.</span></p>
<h2 id="_idParaDest-353"><a id="_idTextAnchor356"/>Getting ready</h2>
<p>Since we will use the Starlette library to build middleware, a sound knowledge of this library would be beneficial, although <span class="No-Break">not necessary.</span></p>
<p>Regarding the development environment, we will exclusively utilize the <strong class="source-inline">fastapi</strong> package with <strong class="source-inline">uvicorn</strong>. Ensure they are installed in <span class="No-Break">your environment.</span></p>
<h2 id="_idParaDest-354"><a id="_idTextAnchor357"/>How to do it…</h2>
<p>Let’s start by creating a project root folder called <strong class="source-inline">middleware_project</strong>. Under the root folder, create a folder called <strong class="source-inline">middleware</strong> containing a module called <strong class="source-inline">asgi_middleware.py</strong>. Let’s<a id="_idIndexMarker733"/> start the module by declaring the logger that we will use during the <span class="No-Break">middleware call:</span></p>
<pre class="source-code">
import logging
logger = logging.getLogger("uvicorn")</pre> <p>Then we can define the middleware class <span class="No-Break">as follows:</span></p>
<pre class="source-code">
from starlette.types import (
    ASGIApp, Scope, Receive, Send
)
class ASGIMiddleware:
    def __init__(
        self, app: ASGIApp, parameter: str = "default"
):
        self.app = app
        self.parameter = parameter
    async def __call__(
        self,
        scope: Scope,
        receive: Receive,
        send: Send,
    ):
        logger.info("Entering ASGI middleware")
        logger.info(
            f"The parameter is: {self.parameter}"
        )
        await self.app(scope, receive, send)
        logger.info("Exiting ASGI middleware")</pre> <p>Then, we need to include the middleware in our application. Under the project root folder, create <a id="_idIndexMarker734"/>the <strong class="source-inline">main.py</strong> module containing the FastAPI class to run the application, <span class="No-Break">as follows:</span></p>
<pre class="source-code">
from fastapi import FastAPI
from starlette.middleware import Middleware
from middleware.asgi_middleware import ASGIMiddleware
app = FastAPI(
    title="Middleware Application",
    middleware=[
        Middleware(
            ASGIMiddleware,
            parameter="example_parameter",
        ),
    ]
)</pre> <p>This is all you need to implement custom ASGI middleware in a <span class="No-Break">FastAPI application.</span></p>
<h2 id="_idParaDest-355"><a id="_idTextAnchor358"/>How it works…</h2>
<p>To see the middleware in action, let’s create a general endpoint in <strong class="source-inline">main.py</strong> module, as in the <span class="No-Break">following example:</span></p>
<pre class="source-code">
@app.get("/")
async def read_root():
    return {"Hello": "Middleware World"}</pre> <p>Spin up the server by running <strong class="source-inline">uvicorn main:app</strong> from the command line. You will see the <span class="No-Break">following messages:</span></p>
<pre class="console">
INFO:    Started server process [2064]
INFO:    Waiting for application startup.
INFO:    Entering ASGI middleware
INFO:    The parameter is: example_parameter</pre> <p>Among the <a id="_idIndexMarker735"/>messages, you will notice those indicating that we have already entered the middleware. Now try to call the root endpoint. You can do it by opening the browser <span class="No-Break">at </span><span class="No-Break"><strong class="source-inline">http://localhost:8000/</strong></span><span class="No-Break">.</span></p>
<p>Still on the terminal, this time you will notice both middleware messages for entering <span class="No-Break">and exiting:</span></p>
<pre class="console">
INFO:    Entering ASGI middleware
INFO:    The parameter is: example_parameter
INFO:    127.0.0.1:55750 - "GET / HTTP/1.1" 200 OK
INFO:    Exiting ASGI middleware</pre> <p>As we understand from the logs, we entered the middleware twice, once on the startup and once when calling the endpoint, but we exited the middleware <span class="No-Break">only once.</span></p>
<p>This is why the ASGI middleware intercepts every event of the application, not only the HTTP request but also the <strong class="source-inline">lifespan</strong> event, which includes the startup <span class="No-Break">and shutdown.</span></p>
<p>Information on the event type within the middleware is stored in the <strong class="source-inline">scope</strong> parameter of the <strong class="source-inline">__call__</strong> method. Let’s include the following logs in the <strong class="source-inline">ASGIMiddleware.__call__</strong> method <a id="_idIndexMarker736"/>to improve our understanding of <span class="No-Break">the mechanism:</span><a id="_idTextAnchor359"/></p>
<pre class="source-code">
class ASGIMiddleware:
    def __init__(
        self,
        app: ASGIApp,
        parameter: str = "default",
    ):
    # method content
    async def __call__(
        self,
        scope: Scope,
        receive: Receive,
        send: Send,
    ):
        # previous logs
<strong class="bold">        logger.info(</strong>
<strong class="bold">            f"event scope: {scope.get('type')}"</strong>
<strong class="bold">        )</strong>
        await self.app(scope, receive, send)</pre> <p>If you restart the server and remake the call to <strong class="source-inline">http://localhost:8000/</strong>, you will now see the log messages specifying the event scope type to be <strong class="source-inline">lifespan</strong> at the server startup and <strong class="source-inline">http</strong> after the <span class="No-Break">endpoint call.</span></p>
<h2 id="_idParaDest-356"><a id="_idTextAnchor360"/>There’s more…</h2>
<p>We have just seen how<a id="_idIndexMarker737"/> to build ASGI middleware as a class. However, you can also do it by leveraging the function decorator pattern. For example, you can build the same middleware <span class="No-Break">like this:</span></p>
<pre class="source-code">
def asgi_middleware(
    app: ASGIApp, parameter: str = "default"
):
    @functools.wraps(app)
    async def wrapped_app(
        scope: Scope, receive: Receive, send: Send
    ):
        logger.info(
            "Entering second ASGI middleware"
        )
        logger.info(
            f"The parameter you proved is: {parameter}"
        )
        logger.info(
            f"event scope: {scope.get('type')}"
        )
        await app(scope, receive, send)
        logger.info("Exiting second ASGI middleware")
    return wrapped_app</pre> <p>This is the equivalent of the <strong class="source-inline">ASGIMiddleware</strong> class defined earlier in the <em class="italic">How to do it…</em> subsection. To make it work, it should be passed as an argument to the FastAPI instance in exactly the <span class="No-Break">same way:</span></p>
<pre class="source-code">
from middleware.asgi_middleware import asgi_middleware
app = FastAPI(
    title="Middleware Application",
    middleware=[
        Middleware(
            asgi_middleware,
            parameter="example_parameter",
        ),
    ]</pre> <p>Based on your personal preference, you can choose the style you prefer. However, for the rest of the<a id="_idIndexMarker738"/> chapter, we will continue using the middleware <span class="No-Break">class style.</span></p>
<h2 id="_idParaDest-357"><a id="_idTextAnchor361"/>See also</h2>
<p>You can read more<a id="_idIndexMarker739"/> on the ASGI specification in the dedicated <span class="No-Break">documentation page:</span></p>
<ul>
<li><em class="italic">ASGI </em><span class="No-Break"><em class="italic">Documentation</em></span><span class="No-Break">: </span><a href="https://asgi.readthedocs.io/en/latest/"><span class="No-Break">https://asgi.readthedocs.io/en/latest/</span></a></li>
</ul>
<p>Middleware classes in FastAPI derive from the Starlette library. You can find extensive documentation on creating <a id="_idIndexMarker740"/>ASGI middleware on the Starlette <span class="No-Break">documentation page:</span></p>
<ul>
<li><em class="italic">Pure ASGI </em><span class="No-Break"><em class="italic">Middleware</em></span><span class="No-Break">: </span><a href="https://www.starlette.io/middleware/#pure-asgi-middleware"><span class="No-Break">https://www.starlette.io/middleware/#pure-asgi-middleware</span></a></li>
</ul>
<h1 id="_idParaDest-358"><a id="_idTextAnchor362"/>Developing middleware for request modification</h1>
<p>Middleware in web applications<a id="_idIndexMarker741"/> serves as a powerful tool for processing requests. Custom middleware can intercept and modify these messages, allowing developers to add or modify <span class="No-Break">functionalities.</span></p>
<p>In this recipe, we’ll focus on developing custom ASGI middleware to modify responses before they are sent to the client by hashing the body of each request, if necessary. This approach provides the flexibility to add or change response headers, body content, and other properties dynamically. By the end of the recipe, you will be able to develop custom middleware to control every <span class="No-Break">API request.</span></p>
<h2 id="_idParaDest-359"><a id="_idTextAnchor363"/>Getting ready</h2>
<p>Before we begin, please make sure you have completed the previous recipe, <em class="italic">Creating custom ASGI middleware</em>, to create specific custom ASGI middleware. We will be working on the <strong class="source-inline">middleware_project</strong> application, but the recipe can easily be applied to <span class="No-Break">any application.</span></p>
<p>Before creating the middleware, in the <strong class="source-inline">main.py</strong> module, let’s create a <strong class="source-inline">POST /send</strong> endpoint that <a id="_idIndexMarker742"/>accepts body content in the request, <span class="No-Break">as follows:</span></p>
<pre class="source-code">
import logging
logger = logging.getLogger("uvicorn")
@app.post("/send")
async def send(message: str = Body()):
    logger.info(f"Message: {message}")
    return message</pre> <p>The endpoint will print the body content to the terminal and return it as a response <span class="No-Break">as well.</span></p>
<p>Now that we have our endpoint, we can create the middleware to hash the body content before sending it to <span class="No-Break">the endpoint.</span></p>
<h2 id="_idParaDest-360"><a id="_idTextAnchor364"/>How to do it…</h2>
<p>In the <strong class="source-inline">middleware</strong> folder, let’s create a module called <strong class="source-inline">request_middleware.py</strong> that will host our middleware class. Let’s go through the following steps to create <span class="No-Break">the middleware:</span></p>
<ol>
<li>Start the module with the required imports <span class="No-Break">like this:</span><pre class="source-code">
from starlette.types import (
    ASGIApp, Scope, Receive, Send, Message,
)
from hashlib import sha1</pre><p class="list-inset">We will use the types from the Starlette library to create the middleware class and the <strong class="source-inline">sha1</strong> function to hash <span class="No-Break">the body.</span></p></li> <li> Given that only certain <strong class="source-inline">HTTP</strong> verbs accept the body (<strong class="source-inline">POST</strong> and <strong class="source-inline">PUT</strong>, but not <strong class="source-inline">GET</strong> for example), we will pass to the middleware the paths as parameters where the modifications should <span class="No-Break">be applied.</span><p class="list-inset">Create a <a id="_idIndexMarker743"/>middleware class called <strong class="source-inline">HashBodyContentMiddleware</strong>, <span class="No-Break">as follows:</span></p><pre class="source-code">
class HashBodyContentMiddleWare:
    def __init__(
        self, app: ASGIApp, allowed_paths: list[str]
    ):
        self.app = app
        self.allowed_paths = allowed_paths</pre><p class="list-inset">We will pass the list of paths into the <span class="No-Break"><strong class="source-inline">allowed_paths</strong></span><span class="No-Break"> parameters.</span></p></li> <li>Define the <strong class="source-inline">__call__</strong> method of <span class="No-Break">the class:</span><pre class="source-code">
    async def __call__(
        self,
        scope: Scope,
        receive: Receive,
        send: Send,
    ):
        if (
            scope["type"] != "http"
            or scope["path"]
            not in self.allowed_paths
        ):
            await self.app(scope, receive, send)
            return</pre><p class="list-inset">If the event is not an HTTP request or the path is not listed, the middleware won’t take any action and will leave the request passing through the <span class="No-Break">next step.</span></p></li> <li>The information about the body is brought by the <strong class="source-inline">receive</strong> variable. However, the <strong class="source-inline">receive</strong> variable is a coroutine, and it should be passed as that to the <strong class="source-inline">self.app</strong> object. We will overcome this by creating a new coroutine within the function, <span class="No-Break">as </span><span class="No-Break"><a id="_idIndexMarker744"/></span><span class="No-Break">follows:</span><pre class="source-code">
        # continue the __call__ method content
        async def receive_with_new_body() -&gt; Message:
            message = await receive()
            assert message["type"] == "http.request"
            body = message.get("body", b"")
            message["body"] = (
                f'"{sha1(body).hexdigest()}"'.encode()
            )
            return message
        await self.app(
            scope,
            receive_with_new_body,
            send,
        )</pre><p class="list-inset">The body request will be modified by the coroutine that is passed to the following steps of the FastAPI <span class="No-Break">object application.</span></p></li> <li>Now we need to add the middleware to the FastAPI instance. We can do it in the <strong class="source-inline">main.py</strong> module. But this time we will leverage the <strong class="source-inline">add_middleware</strong> method of the FastAPI instance object <span class="No-Break">like this:</span><pre class="source-code">
app.add_middleware(
    HashBodyContentMiddleWare,
    allowed_paths=["/send"],
)</pre><p class="list-inset">Now the application will make the request pass through <span class="No-Break">our middleware.</span></p></li> </ol>
<p>This is all you <a id="_idIndexMarker745"/>need to implement it. To test the middleware, let’s spin up the server with <strong class="source-inline">uvicorn</strong> from the command line by running <span class="No-Break">the following:</span></p>
<pre class="console">
$ uvicorn main:app</pre> <p>Then go to the interactive documentation at <strong class="source-inline">http://localhost:8000/docs</strong> and test the <strong class="source-inline">POST/send</strong> endpoint. For example, check whether you can send a body string <span class="No-Break">like this:</span></p>
<pre class="source-code">
"hello middleware"</pre> <p>If everything is correctly done, you should receive a response body <span class="No-Break">like this:</span></p>
<pre class="source-code">
"14bb256ec4a292037c01bdbdd3eac61f328515f3"</pre> <p>You have just implemented custom ASGI middleware that hashes the body for the <span class="No-Break">specified endpoints.</span></p>
<p>This was a simple example, but the potential of controlling requests is limitless. For example, you can use it to introduce an additional security layer to prevent cross-scripting injection <a id="_idIndexMarker746"/>of <span class="No-Break">undesired content.</span></p>
<h2 id="_idParaDest-361"><a id="_idTextAnchor365"/>See also</h2>
<p>Creating middleware to modify the request is documented on the Starlette <span class="No-Break">documentation page:</span></p>
<ul>
<li><em class="italic">Inspecting or modifying the </em><span class="No-Break"><em class="italic">request</em></span><span class="No-Break">: </span><a href="https://www.starlette.io/middleware/#inspecting-or-modifying-the-request"><span class="No-Break">https://www.starlette.io/middleware/#inspecting-or-modifying-the-request</span></a></li>
</ul>
<h1 id="_idParaDest-362"><a id="_idTextAnchor366"/>Developing middleware for response modification</h1>
<p>Besides processing <a id="_idIndexMarker747"/>requests, middleware in web applications is also a powerful tool for processing responses. Custom middleware allows us to intercept responses before they are returned to the API caller. This can be useful for checking response content or personalizing the response. In this recipe, we will develop custom ASGI middleware to add customized headers to all <span class="No-Break">the responses.</span></p>
<h2 id="_idParaDest-363"><a id="_idTextAnchor367"/>Getting ready</h2>
<p>We will be creating custom ASGI middleware that modifies the response of each HTTP call. Before we get started on this recipe, take a look at the <em class="italic">Creating custom ASGI middleware</em> recipe. Also, this recipe will be complementary to the previous recipe, <em class="italic">Developing middleware for </em><span class="No-Break"><em class="italic">request modification</em></span><span class="No-Break">.</span></p>
<p>While you can apply this recipe to your own project, we will continue working on the <strong class="source-inline">middleware_project</strong> project that we initialized in the <em class="italic">Developing middleware for request </em><span class="No-Break"><em class="italic">modification</em></span><span class="No-Break"> recipe.</span></p>
<h2 id="_idParaDest-364"><a id="_idTextAnchor368"/>How to do it…</h2>
<p>We will create our middleware class in a dedicated module in the <strong class="source-inline">middleware</strong> folder. We will call the module <strong class="source-inline">response_middleware.py</strong>. Let's start building the middleware by going through the <span class="No-Break">following steps.</span></p>
<ol>
<li>Let’s start writing the imports we will use to define <span class="No-Break">the middleware:</span><pre class="source-code">
from typing import Sequence
from starlette.datastructures import MutableHeaders
from starlette.types import (
    ASGIApp, Receive, Scope, Send, Message
)</pre></li> <li>Then, we can start defining the <strong class="source-inline">ExtraHeadersResponseMiddleware</strong> middleware class <span class="No-Break">as follows:</span><pre class="source-code">
class ExtraHeadersResponseMiddleware:
    def __init__(
        self,
        app: ASGIApp,
        headers: Sequence[tuple[str, str]],
    ):
        self.app = app
        self.headers = headers</pre></li> <li>We will pass<a id="_idIndexMarker748"/> the headers list as an argument to the middleware. Then, the <strong class="source-inline">__call__</strong> method will be <span class="No-Break">as follows:</span><pre class="source-code">
    async def __call__(
        self,
        scope: Scope,
        receive: Receive,
        send: Send,
    ):
        if scope["type"] != "http":
            return await self.app(
                scope, receive, send
            )</pre></li> <li>We restrain the middleware to HTTP event calls. Similar to what we saw in the previous recipe, <em class="italic">Developing middleware for request modification</em>, we modify the send <a id="_idIndexMarker749"/>object, which is a coroutine, and we pass it to the next middleware, <span class="No-Break">as follows:</span><pre class="source-code">
        async def send_with_extra_headers(
            message: Message
        ):
            if (
                message["type"]
                == "http.response.start"
            ):
                headers = MutableHeaders(
                    scope=message
                )
                for key, value in self.headers:
                    headers.append(key, value)
            await send(message)
        await self.app(
            scope, receive, send_with_extra_headers
        )</pre><p class="list-inset">The response’s headers are generated from the <strong class="source-inline">message</strong> parameter of the <strong class="source-inline">send_with_extra_headerds</strong> <span class="No-Break">coroutine object.</span></p></li> <li>Once the middleware is defined, we need to add it to the <strong class="source-inline">FastAPI</strong> object instance to make it effective. We can add it in the <strong class="source-inline">main.py</strong> module <span class="No-Break">as follows:</span><pre class="source-code">
app.add_middleware(
    ExtraHeadersResponseMiddleware,
    headers=(
        ("new-header", "fastapi-cookbook"),
        (
            "another-header",
            "fastapi-cookbook",
        ),
    ),
)</pre><p class="list-inset">Here, we add two headers to the response, <strong class="source-inline">new-header</strong> and <strong class="source-inline">another-header</strong>. </p><p class="list-inset">To test it, spin up the server by running <strong class="source-inline">uvicorn main:app</strong> and open the interactive documentation. Call one of the endpoints and check the headers in <span class="No-Break">the response.</span></p><p class="list-inset">Here is the list of the headers you get when calling the <strong class="source-inline">GET /</strong> <span class="No-Break">endpoint:</span></p><pre class="source-code"><strong class="bold">another-header: fastapi-cookbook</strong>
content-length: 28
content-type: application/json
date: Thu,23 May 2024 09:24:41 GMT
<strong class="bold">new-header: fastapi-cookbook</strong>
server: uvicorn</pre><p class="list-inset">You will find<a id="_idIndexMarker750"/> the two headers we previously added to the <span class="No-Break">default ones.</span></p></li> </ol>
<p>You have just implemented middleware that modifies <span class="No-Break">API responses.</span></p>
<h2 id="_idParaDest-365"><a id="_idTextAnchor369"/>See also</h2>
<p>In the Starlette documentation, you can find an example of how to create middleware that modifies <span class="No-Break">the response:</span></p>
<ul>
<li><em class="italic">Inspecting or modifying the </em><span class="No-Break"><em class="italic">response</em></span><span class="No-Break">: </span><a href="https://www.starlette.io/middleware/#inspecting-or-modifying-the-response"><span class="No-Break">https://www.starlette.io/middleware/#inspecting-or-modifying-the-response</span></a></li>
</ul>
<h1 id="_idParaDest-366"><a id="_idTextAnchor370"/>Handling CORS with middleware</h1>
<p>CORS is a security<a id="_idIndexMarker751"/> feature <a id="_idIndexMarker752"/>implemented in web browsers to prevent malicious websites from making unauthorized requests to APIs hosted on different origins. When building APIs, especially for public consumption, it’s crucial to handle CORS properly to ensure legitimate requests are served while unauthorized ones <span class="No-Break">are blocked.</span></p>
<p>In this recipe, we will explore how to handle CORS using custom middleware in FastAPI. This approach allows us to deeply understand the CORS mechanism and gain flexibility in customizing the behavior to fit <span class="No-Break">specific requirements.</span></p>
<h2 id="_idParaDest-367"><a id="_idTextAnchor371"/>Getting ready</h2>
<p>We will apply the recipe to the <strong class="source-inline">middleware_project</strong> application. Make sure you have the FastAPI application running with at least the <strong class="source-inline">GET /</strong> endpoint already <span class="No-Break">set up.</span></p>
<p>Since the recipe will show how to set up CORS middleware to manage CORS, you will need a simple HTML web page that calls <span class="No-Break">our API.</span></p>
<p>You can create one yourself or download the <strong class="source-inline">cors_page.xhtml</strong> file from the project’s GitHub repository. The file is a simple HTML page that sends a request to the FastAPI application at <strong class="source-inline">http://localhost:8000/</strong> and displays the response on the <span class="No-Break">same page.</span></p>
<p>Before starting the recipe, spin up your FastAPI application by running <strong class="source-inline">uvicorn main:app</strong>. To view the page, open <strong class="source-inline">cors_page.xhtml</strong> using a modern browser. Then, open the developer console. In most browsers, you can do this by right-clicking on the page, selecting <strong class="bold">Inspect</strong> from the menu, and then toggling to the <span class="No-Break"><strong class="bold">Console</strong></span><span class="No-Break"> tab.</span></p>
<p>On the page, press the <strong class="bold">Send CORS Request</strong> button. You should see an error message on the command line like <span class="No-Break">the following:</span></p>
<pre class="console">
Access to fetch at 'http://localhost:8000/' from origin 'null' has been blocked by CORS policy: Response to preflight request doesn't pass access control check: No 'Access-Control-Allow-Origin' header is present on the requested resource. If an opaque response serves your needs, set the request's mode to 'no-cors' to fetch the resource with CORS disabled.</pre> <p>That means that the call has been blocked by the <span class="No-Break">CORS policy.</span></p>
<p>Let’s start the recipe and see how to <span class="No-Break">fix it.</span></p>
<h2 id="_idParaDest-368"><a id="_idTextAnchor372"/>How to do it…</h2>
<p>In FastAPI, CORS can be handled with a dedicated <strong class="source-inline">CORSMiddleware</strong> class from the <span class="No-Break">Starlette library.</span></p>
<p>Let’s add<a id="_idIndexMarker753"/> the<a id="_idIndexMarker754"/> middleware to our application in the <span class="No-Break"><strong class="source-inline">main.py</strong></span><span class="No-Break"> module:</span></p>
<pre class="source-code">
from fastapi.middleware.cors import CORSMiddleware
# rest of the module
app.add_middleware(
    CORSMiddleware,
    allow_origins=["*"],
    allow_methods=["*"],
    allow_headers=["*"],
)</pre> <p>Now, rerun the server, open <strong class="source-inline">cors_page.xhtml</strong> again, and try to press the <strong class="bold">Send CORS Request</strong> button. This time, you see the response message directly on <span class="No-Break">the page.</span></p>
<p>The <strong class="source-inline">allow_origins</strong> parameter specifies the host origin from which the CORS should be allowed. If <strong class="source-inline">allow_origins=[*]</strong>, it means that any origin <span class="No-Break">is allowed.</span></p>
<p>The <strong class="source-inline">allow_methods</strong> parameter specifies the HTTP methods that are allowed. By default, only <strong class="source-inline">GET</strong> is allowed, and if <strong class="source-inline">allow_methods=[*]</strong>, it means that all methods <span class="No-Break">are allowed.</span></p>
<p>Then, the <strong class="source-inline">allow_headers</strong> parameter specifies the headers that are allowed. Similarly, if we use <strong class="source-inline">allow_headers=[*]</strong>, it means that all headers <span class="No-Break">are allowed.</span></p>
<p>In a production environment, it’s important to carefully evaluate each of these parameters to ensure security standards and to make your application <span class="No-Break">run safely.</span></p>
<p>This is all that’s <a id="_idIndexMarker755"/>needed to <a id="_idIndexMarker756"/>implement CORS middleware for allowing CORS <span class="No-Break">from clients.</span></p>
<h2 id="_idParaDest-369"><a id="_idTextAnchor373"/>See also</h2>
<p>For more information<a id="_idIndexMarker757"/> about CORS, check out the <strong class="bold">Mozilla</strong> <span class="No-Break">documentation page:</span></p>
<ul>
<li><span class="No-Break"><em class="italic">CORS</em></span><span class="No-Break">: </span><a href="https://developer.mozilla.org/en-US/docs/Web/HTTP/CORS"><span class="No-Break">https://developer.mozilla.org/en-US/docs/Web/HTTP/CORS</span></a></li>
</ul>
<p>You can see more about the functionalities and discover other parameters of the CORS middleware in FastAPI on the <span class="No-Break">documentation page:</span></p>
<ul>
<li><em class="italic">Use </em><span class="No-Break"><em class="italic">CORSMiddleware</em></span><span class="No-Break">: </span><a href="https://fastapi.tiangolo.com/tutorial/cors/#use-corsmiddleware"><span class="No-Break">https://fastapi.tiangolo.com/tutorial/cors/#use-corsmiddleware</span></a></li>
</ul>
<p>You can also have a look at the Starlette <span class="No-Break">documentation page:</span></p>
<ul>
<li><span class="No-Break"><em class="italic">CORSMiddleware</em></span><span class="No-Break">: </span><a href="https://www.starlette.io/middleware/#corsmiddleware"><span class="No-Break">https://www.starlette.io/middleware/#corsmiddleware</span></a></li>
</ul>
<h1 id="_idParaDest-370"><a id="_idTextAnchor374"/>Restricting incoming requests from hosts</h1>
<p>In modern web<a id="_idIndexMarker758"/> applications, security is paramount. One crucial aspect of security is ensuring that your application only processes requests from trusted sources. This practice helps to mitigate risks <a id="_idIndexMarker759"/>such as <strong class="bold">Domain Name System</strong> (<strong class="bold">DNS</strong>) rebinding attacks, where an attacker tricks a user’s browser into interacting with an <span class="No-Break">unauthorized domain.</span></p>
<p>FastAPI provides middleware called <strong class="source-inline">TrustedHostMiddleware</strong>, which allows you to specify which hosts are considered trusted. Requests from any other hosts will be rejected. This recipe will guide you through setting up and using the <strong class="source-inline">TrustedHostMiddleware</strong> class to secure your FastAPI application by accepting requests only from <span class="No-Break">specific hosts.</span></p>
<h2 id="_idParaDest-371"><a id="_idTextAnchor375"/>Getting ready</h2>
<p>We will apply the recipe to the <strong class="source-inline">middleware_project</strong> application. The application will need to be working with at least one endpoint <span class="No-Break">to test.</span></p>
<h2 id="_idParaDest-372"><a id="_idTextAnchor376"/>How to do it…</h2>
<p>Let’s restrict the request to calls coming from localhost. In <strong class="source-inline">main.py</strong>, let’s import <strong class="source-inline">TrustedHostMiddleware</strong> and add it to<a id="_idIndexMarker760"/> the FastAPI object instance application, <span class="No-Break">as follows:</span></p>
<pre class="source-code">
from fastapi.middleware.trustedhost import (
    TrustedHostMiddleware,
)
# rest of the module
app.add_middleware(
    TrustedHostMiddleware,
    allowed_hosts=["localhost"],
)</pre> <p>To test it, let’s try to refuse a call. Let’s spin up the server by broadcasting our service to the network. We can do it by specifying the undefined host address, <strong class="source-inline">0.0.0.0</strong>, when running <strong class="source-inline">uvicorn</strong>, <span class="No-Break">as follows:</span></p>
<pre class="console">
$ uvicorn main:app --host=0.0.0.0</pre> <p>This will make our application visible to <span class="No-Break">the network.</span></p>
<p>To retrieve the address of your machine within the local network, you can run <strong class="source-inline">ipconfig</strong> on Windows or <strong class="source-inline">ip addr</strong> on Linux <span class="No-Break">or macOS.</span></p>
<p>From another device connected to the same local network as the machine running our FastAPI application (such as a smartphone), open a browser and enter <strong class="source-inline">http://&lt;your local address&gt;:8000</strong>. If everything is correctly set up, you will see the following message in <span class="No-Break">the browser:</span></p>
<pre class="source-code">
Invalid host header</pre> <p>While on the machine running the FastAPI server, you will see a log message like <span class="No-Break">the following:</span></p>
<pre class="console">
INFO: &lt;client ip&gt;:57312 - "GET / HTTP/1.1" 400 Bad Request</pre> <p>This is all you need to set up middleware to prevent your application from being reached by <a id="_idIndexMarker761"/><span class="No-Break">undesired hosts.</span></p>
<h2 id="_idParaDest-373"><a id="_idTextAnchor377"/>See also</h2>
<p>You can learn more <a id="_idIndexMarker762"/>about <strong class="source-inline">TrustedHostMiddleware</strong> on the FastAPI <span class="No-Break">documentation page:</span></p>
<ul>
<li><span class="No-Break"><em class="italic">TrustedHostMiddleware</em></span><span class="No-Break">: </span><a href="https://fastapi.tiangolo.com/advanced/middleware/#trustedhostmiddleware"><span class="No-Break">https://fastapi.tiangolo.com/advanced/middleware/#trustedhostmiddleware</span></a></li>
</ul>
<p>Since <strong class="source-inline">TrustedHostMiddleware</strong> is defined in the Starlette library, you can also find it in the Starlette documentation at the <span class="No-Break">following link:</span></p>
<ul>
<li><span class="No-Break"><em class="italic">TrustedHostMiddleware</em></span><span class="No-Break">: </span><a href="https://www.starlette.io/middleware/#trustedhostmiddleware"><span class="No-Break">https://www.starlette.io/middleware/#trustedhostmiddleware</span></a></li>
</ul>
<h1 id="_idParaDest-374"><a id="_idTextAnchor378"/>Implementing webhooks</h1>
<p><strong class="bold">Webhooks</strong> play a <a id="_idIndexMarker763"/>crucial role in modern web development by enabling different systems to communicate and respond to events in real time. They are essentially HTTP callbacks triggered by specific events in one system, which then send a message or payload to another system. This asynchronous event-driven architecture allows for seamless integration with third-party services, real-time notifications, and automated workflows. Understanding how to implement webhooks effectively will empower you to build more interactive and <span class="No-Break">responsive applications.</span></p>
<p>In this recipe, we will see how to create webhooks in FastAPI. We will create a webhook that notifies the webhook subscribers for each request of the API, acting like a monitoring system. By the end of this recipe, you will be able to implement a robust webhook system in your FastAPI application, facilitating real-time communication and integration with <span class="No-Break">other services.</span></p>
<h2 id="_idParaDest-375"><a id="_idTextAnchor379"/>Getting ready</h2>
<p>To set up the webhook for sending requests to the subscriber, we will use custom ASGI middleware. Please ensure that you have already followed the <em class="italic">Creating custom ASGI middleware</em> recipe. We will be continuing our work on the <strong class="source-inline">middleware_project</strong> API. However, you will find guidelines on how to implement your webhook that can be easily adapted to the specific needs of <span class="No-Break">your project.</span></p>
<p>If you are starting<a id="_idIndexMarker764"/> a new project from scratch, make sure to install the <strong class="source-inline">fastapi</strong> package with <strong class="source-inline">uvicorn</strong> in your environment. You can do this <span class="No-Break">using </span><span class="No-Break"><strong class="source-inline">pip</strong></span><span class="No-Break">:</span></p>
<pre class="console">
$ pip install fastapi uvicorn</pre> <p>Once you have the packages, we can start <span class="No-Break">the recipe.</span></p>
<h2 id="_idParaDest-376"><a id="_idTextAnchor380"/>How to do it…</h2>
<p>To build a webhook system in our API, we will need to do <span class="No-Break">the following:</span></p>
<ol>
<li>Set up the URL <span class="No-Break">registration system.</span></li>
<li>Implement the <span class="No-Break">webhook callbacks.</span></li>
<li>Document <span class="No-Break">the webhook.</span></li>
</ol>
<p>Let’s go through <span class="No-Break">the implementation.</span></p>
<h3>Setting up the URL registration system</h3>
<p>A webhook call<a id="_idIndexMarker765"/> will send an HTTP request to the <a id="_idIndexMarker766"/>list of URLs registered to the webhook. The API will require a URL registration system. This can be achieved by creating a dedicated endpoint that will store the URL in a stateful system, such as a database. However, for demonstration purposes, we will store the URLs in the application state, which might also be a good choice for <span class="No-Break">small applications.</span></p>
<p>Let’s create it by going through the <span class="No-Break">following steps:</span></p>
<ol>
<li>In <strong class="source-inline">main.py</strong>, let’s create the lifespan context manager to store the <span class="No-Break">registered URLs:</span><pre class="source-code">
from contextlib import asynccontextmanager
@asynccontextmanager
async def lifespan(app: FastAPI):
    yield {"webhook_urls": []}</pre></li> <li>Let’s pass the lifespan as an argument to the FastAPI object, <span class="No-Break">as follows:</span><pre class="source-code">
app = FastAPI(
<strong class="bold">    lifespan=lifespan,</strong>
# rest of the parameters
)</pre></li> <li>Then, we can create the endpoint to register the URL, <span class="No-Break">as follows:</span><pre class="source-code">
@app.post("/register-webhook-url")
async def add_webhook_url(
    request: Request, url: str = Body()
):
    if not url.startswith("http"):
        url = f"http://{url}"
    request.state.webhook_urls.append(url)
    return {"url added": url}</pre><p class="list-inset">The endpoint will accept a text string in the body. If the <strong class="source-inline">http</strong> or <strong class="source-inline">https</strong> protocol is missing in the string, an <strong class="source-inline">"http://"</strong> string will be prepended to the URL before <span class="No-Break">being stored.</span></p></li> </ol>
<p>You have just<a id="_idIndexMarker767"/> implemented the URL registration <a id="_idIndexMarker768"/>system. Now, let’s continue to implement the <span class="No-Break">webhook callbacks.</span></p>
<h3>Implementing the webhook callbacks</h3>
<p>After setting up the<a id="_idIndexMarker769"/> registration system, we can begin creating the webhook’s calls. As previously stated, this particular webhook will alert subscribers for every API call. We’ll utilize this information to develop specialized middleware that will handle the calls. Let’s do it by following <span class="No-Break">these steps:</span></p>
<ol>
<li>Let’s create a new module in the <strong class="source-inline">middleware</strong> folder called <strong class="source-inline">webhook.py</strong> and define the event to communicate with <span class="No-Break">the subscribers:</span><pre class="source-code">
from pydantic import BaseModel
class Event(BaseModel):
    host: str
    path: str
    time: str
    body: str | None = None</pre></li> <li>Then, we define a coroutine that will be used to make the requests to the subscriber URLs, <span class="No-Break">as follows:</span><pre class="source-code">
import logging
from httpx import AsyncClient
client = AsyncClient()
logger = logging.getLogger("uvicorn")
async def send_event_to_url(
    url: str, event: Event
):
    logger.info(f"Sending event to {url}")
    try:
        await client.post(
            f"{url}/fastapi-webhook",
            json=event.model_dump(),
        )
    except Exception as e:
        logger.error(
            "Error sending webhook event "
            f"to {url}: {e}"
        )</pre><p class="list-inset">The client sends a<a id="_idIndexMarker770"/> request to the URL. If the request fails, a message is printed to <span class="No-Break">the terminal.</span></p></li> <li>We then define the middleware that will intercept the request. We start with the imports, <span class="No-Break">as follows:</span><pre class="source-code">
from asyncio import create_task
from datetime import datetime
from fastapi import Request
from starlette.types import (
    ASGIApp, Receive, Scope, Send,
)</pre><p class="list-inset">We then add the <strong class="source-inline">WebhookSenderMiddleware</strong> class, <span class="No-Break">as follows</span></p><pre class="source-code">class WebhookSenderMiddleWare:
    def __init__(self, app: ASGIApp):
        self.app = app
    async def __call__(
        self,
        scope: Scope,
        receive: Receive,
        send: Send,
    ):</pre></li> <li>We will filter<a id="_idIndexMarker771"/> only the HTTP requests, <span class="No-Break">as follows:</span><pre class="source-code">
        if scope["type"] == "http":
            message = await receive()
            body = message.get("body", b"")
            request = Request(scope=scope)</pre></li> <li>We continue in the <strong class="source-inline">same __call__</strong> function by defining the <strong class="source-inline">event</strong> object to pass to the <span class="No-Break">webhook subscribers:</span><pre class="source-code">
            event = Event(
                host=request.client.host,
                path=request.url.path,
                time=datetime.now().isoformat(),
                body=body,
            )</pre></li> <li>Then, we iterate the calls over the URLs by running the <strong class="source-inline">send_event_to_url</strong> coroutine, <span class="No-Break">as follows:</span><pre class="source-code">
            urls = request.state.webhook_urls
            for url in urls:
                await create_task(
                    send_event_to_url(url, event)
                )</pre></li> <li>We finalize the <a id="_idIndexMarker772"/>method by returning the modified <strong class="source-inline">receive</strong> function to <span class="No-Break">the application:</span><pre class="source-code">
            async def continue_receive():
                return message
            await self.app(
                scope, continue_receive, send
            )
            return
        await self.app(scope, receive, send)</pre><p class="list-inset">We have just defined the middleware that will make <span class="No-Break">the calls.</span></p></li> <li>Now we need to import the <strong class="source-inline">WebhookSenderMiddleWare</strong> middleware in the application. We can do this inside <strong class="source-inline">main.py</strong> <span class="No-Break">as follows:</span><pre class="source-code">
from middleware.webhook import (
WebhookSenderMiddleWare
)
# rest of the code
app.add_middleware(WebhookSenderMiddleWare)</pre><p class="list-inset">The application will now include our middleware to handle the <span class="No-Break">webhook callbacks.</span></p></li> </ol>
<p>That is all you need <a id="_idIndexMarker773"/>to implement a complete webhook within your <span class="No-Break">FastAPI application.</span></p>
<h3>Documenting the webhook</h3>
<p>It is important to<a id="_idIndexMarker774"/> provide API users with documentation on how the webhook functions. FastAPI allows us to document a webhook in the <span class="No-Break">OpenAPI documentation.</span></p>
<p>To accomplish this, you need to create a function with an empty body and declare it as a webhook endpoint. You can do it in <strong class="source-inline">main.py</strong> <span class="No-Break">as well:</span></p>
<pre class="source-code">
@app.webhooks.post("/fastapi-webhook")
def fastapi_webhook(event: Event):
    """_summary_
    Args:
        event (Event): Received event from webhook
        It contains information about the
        host, path, timestamp and body of the request
    """</pre> <p>You can also provide an example of the body content by adding specifications to the <strong class="source-inline">Event</strong> class in the <strong class="source-inline">middleware/webhook.py</strong> module, <span class="No-Break">as follows:</span></p>
<pre class="source-code">
class Event(BaseModel):
    host: str
    path: str
    time: str
    body: str | None = None
<strong class="bold">    model_config = {</strong>
<strong class="bold">        "json_schema_extra": {</strong>
<strong class="bold">            "examples": [</strong>
<strong class="bold">                {</strong>
<strong class="bold">                    "host": "127.0.0.1",</strong>
<strong class="bold">                    "path": "/send",</strong>
<strong class="bold">                    "time": "2024-05-22T14:24:28.847663",</strong>
<strong class="bold">                    "body": '"body content"',</strong>
<strong class="bold">                </strong><strong class="bold">}</strong>
<strong class="bold">            ]</strong>
<strong class="bold">        }</strong>
<strong class="bold">    }</strong></pre> <p>After starting the server with the <strong class="source-inline">uvicorn main:app</strong> command and opening the browser at <strong class="source-inline">http://localhost:8000/docs</strong>, you will find the documentation for <strong class="source-inline">POST /fastapi-webhook</strong> in the <strong class="bold">Webhook</strong> section. This documentation explains the call that the API will make to<a id="_idIndexMarker775"/> the provided URLs through the <strong class="source-inline">POST </strong><span class="No-Break"><strong class="source-inline">register-webhook-url</strong></span><span class="No-Break"> endpoint.</span></p>
<h2 id="_idParaDest-377"><a id="_idTextAnchor381"/>How it works…</h2>
<p>To test the webhook, yo<a id="_idIndexMarker776"/>u can set up a simple server running locally on a specific port. You can create one yourself or download the <strong class="source-inline">http_server.py</strong> file from the GitHub repository. This server will run on <span class="No-Break">port </span><span class="No-Break"><strong class="source-inline">8080</strong></span><span class="No-Break">.</span></p>
<p>Once you have set up the server, you can run it from the <span class="No-Break">command line:</span></p>
<pre class="console">
$ python ./http_server.py</pre> <p>Leave the server running and make sure the FastAPI application is running on a <span class="No-Break">separate terminal.</span></p>
<p>Open the interactive documentation at <strong class="source-inline">http://localhost:8000/docs</strong>. Using the <strong class="source-inline">POST /register-webhook-url</strong> endpoint, add the <strong class="source-inline">"localhost:8080"</strong> address. Make sure you specify the correct port in <span class="No-Break">the URL.</span></p>
<p>Now try to call any of the endpoints to the API. The FastAPI application will make a call to the server listening at port <strong class="source-inline">8080</strong>. If you check the service terminal, you will see the messages streaming<a id="_idIndexMarker777"/> on the terminal containing the information for <span class="No-Break">each call.</span></p>
<h2 id="_idParaDest-378"><a id="_idTextAnchor382"/>There’s more…</h2>
<p>While the basic implementation of webhooks is powerful, several advanced concepts and enhancements can make your webhook system more robust, secure, and efficient. Some of the most relevant ones are <span class="No-Break">as follows:</span></p>
<ul>
<li><strong class="bold">Authentication</strong>: To <a id="_idIndexMarker778"/>ensure that your API can securely communicate with a webhook endpoint, you can implement any sort of authentication, from API <span class="No-Break">to OAuth.</span></li>
<li><strong class="bold">Retry mechanism</strong>: Webhooks rely on HTTP, which is not always reliable. There may be instances where the webhook delivery fails due to network issues, server downtime, or other transient errors. Implementing a retry mechanism ensures that webhook events are eventually delivered even if the initial <span class="No-Break">attempt fails.</span></li>
<li><strong class="bold">Persistent storage</strong>: Storing webhook events in a database allows you to keep an audit trail, troubleshoot issues, and replay events if necessary. You can use SQLAlchemy, a SQL toolkit <a id="_idIndexMarker779"/>and <strong class="bold">object-relational mapping</strong> library for Python, to save webhook events in a <span class="No-Break">relational database.</span></li>
<li><strong class="bold">WebSocket webhook</strong>: For real-time updates, you can set up a WebSocket server in FastAPI and notify clients through WebSocket connections when webhooks <span class="No-Break">are received.</span></li>
<li><strong class="bold">Rate limiting</strong>: To prevent abuse and server overload, rate limiting can be applied to the webhook endpoint. This ensures that a single client cannot overwhelm the server with too many requests in a <span class="No-Break">short period.</span></li>
</ul>
<p>Webhooks are crucial for constructing interactive, event-driven applications that seamlessly<a id="_idIndexMarker780"/> integrate with third-party systems. Utilize them to their <span class="No-Break">fullest potential.</span></p>
<h2 id="_idParaDest-379"><a id="_idTextAnchor383"/>See also</h2>
<p>If you want to learn more about webhook applications, check <a id="_idIndexMarker781"/>out the <strong class="bold">Red Hat</strong> blog page explaining what it <a id="_idIndexMarker782"/>is and how it is used in <span class="No-Break">modern applications:</span></p>
<ul>
<li><em class="italic">What is a </em><span class="No-Break"><em class="italic">webhook?</em></span><span class="No-Break">: </span><a href="https://www.redhat.com/en/topics/automation/what-is-a-webhook"><span class="No-Break">https://www.redhat.com/en/topics/automation/what-is-a-webhook</span></a></li>
</ul>
<p>You can also refer to the FastAPI documentation for information on how to document webhook endpoints in the <span class="No-Break">OpenAPI documentation:</span></p>
<ul>
<li><em class="italic">OpenAPI </em><span class="No-Break"><em class="italic">Webhooks</em></span><span class="No-Break">: </span><a href="https://fastapi.tiangolo.com/advanced/openapi-webhooks/"><span class="No-Break">https://fastapi.tiangolo.com/advanced/openapi-webhooks/</span></a></li>
</ul>
</div>
</div></body></html>